(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var Grammar = require("../../lib/Grammar"),
    State = require("../../lib/State"),
    Diagram = require("../../lib/Diagram");


var g = new Grammar(["<",">","rule-name","::=","|","line-end","WS","term"]);

g.addRules({
    "syntax": [["rule","syntax"],["rule"]],
    "rule": [[
        "opt-whitespace","<","rule-name",">","opt-whitespace",
        "::=","expression","line-end"
    ]],
    "expression": [["list"],["list","opt-whitespace","|","expression"]],
    "list": [["term"],["term","opt-whitespace","list"]],
    "opt-whitespace": [["WS","opt-whitespace"],[""]]
});


/*g.addRules({
    "syntax": [["rule","syntax"],["rule"]],
    "rule": [[
        "opt-whitespace","line-end"
    ]],
    "opt-whitespace": [["WS","opt-whitespace"],[""]]
});*/

var start = g.build('syntax');

Diagram.drawStateDiagram(start,
    document.getElementById('container'));

},{"../../lib/Diagram":2,"../../lib/Grammar":3,"../../lib/State":4}],2:[function(require,module,exports){
var vis = require("vis");

var Diagram = {};

Diagram.buildData = function(state) {
    var labelIndex = {},
        nodes = [],
        edges = [];
    function buildIndex(state) {
        if(typeof labelIndex[state.label] === "undefined") {
            labelIndex[state.label] =
                {id:state.label, label:state.label};
            nodes.push(labelIndex[state.label]);
            for(var i=0,l=state.states.length;i<l;i++) {
                edges.push({from:state.label,to:state.states[i].label,
                            label:state.states[i].terminal,
                            font: {align: 'middle'},
                            arrows:'to'});
                buildIndex(state.states[i]);
            }
        }
    }
    buildIndex(state);
    return {
        nodes: nodes,
        edges: edges
    };
}

Diagram.drawFromData = function(nodes,edges,container) {
    var network = new vis.Network(container,
        {nodes:nodes,edges:edges}, {});
    return network;
}

Diagram.drawStateDiagram = function(state,container) {
    // first build nodes variable
    var data = Diagram.buildData(state);
    var network = new vis.Network(container, data, {});
    return network;
}

module.exports = Diagram;

},{"vis":5}],3:[function(require,module,exports){
var State = require("./State.js");

function Grammar(terminals, rules) {
    this.terminals = [];
    this.rules = {};
    this.unresolvedStates = [];
    this.stateOptions = {};
    this.addTerminals(terminals || []);
    this.addRules(rules || {});
}

Grammar.prototype = {
    addTerminals : function(terminals) {
        this.terminals = this.terminals.concat(terminals);
    },
    addRules : function(rules) {
        Object.assign(this.rules, rules);
    },
    isTerminal : function(t) {
    		return this.terminals.indexOf(t) > -1;
    },
    firstPass : function(rule,ruleLabel) {
        // want to output the rule's states, one for each option
        // and remember where to insert other rules' states
        // rule is an array of options
        for(var i = 0, rlen = rule.length, option, j, s, ls, rs=[];
            i < rlen; i++) {
            option = rule[i];
            // option is an array of terminals and rule names
            // want to go through them in reverse order
            j = option.length;
            ls = [];
            while(j--) {
                s = new State(option[j]);
                if(ls[0] && ls[0].dummy) {
                    this.unresolvedStates.push([ls[0],s]);
                }
                s.addStates(ls);
                ls = [s];
                if(!this.isTerminal(option[j]) && option[j] !== "") {
                    // remember to put in the correct states later
                    s.dummy = true;
                }
            }
            rs = State.merge(rs,ls);
        }
        this.stateOptions[ruleLabel] = rs;
        return rs;
    },
    build : function(startSymbol) {
        var ret, start = new State("",startSymbol);
        // each rule needs to have it's first pass
        Object.keys(this.rules).forEach(function(ruleLabel){
            this.firstPass(this.rules[ruleLabel],ruleLabel);
        }, this);
        start.addStates(this.buildTraverse(startSymbol));
        return start;
    },

    /*buildTraverse : function(startSymbol,rP,endStates) {
        if(typeof this.stateOptions[startSymbol] === "undefined") {
            console.error("Unknown Rule Name: "+startSymbol);
            return [];
        }
        var rP = rP || {},
            endStates = endStates || [],
            rule = this.stateOptions[startSymbol],
            retState = new State("",startSymbol),
            ls = [];
        rP[startSymbol] = retState;
        rule.forEach(function(state){
            // go through states
            var self = this, blankable = false;
            function processState(state,lastState,li) {
                if(state.dummy) {
                    console.log(li,lastState);
                    if(typeof li !== "undefined")
                        lastState.states.splice(li,1);
                    else blankable = true;
                    if(typeof rP[state.terminal] === "undefined") {
                        lastState.addStates(self.buildTraverse(
                            state.terminal,
                            rP,
                            state.states
                        ));
                    }
                    else {
                        if(state.terminal === startSymbol) {
                            ls.push(lastState);
                        }
                        else {
                            console.log(state.states);
                            lastState.addStates(rP[state.terminal].states,
                                                true);

                        }
                    }
                }
                if(state.terminal === "") {
                    lastState.addStates(endStates);
                    blankable = true;
                }
                else if(state.states.length === 0) {
                    state.states = endStates;
                }
                else {
                    state.states.forEach(function(s,i) {
                        processState(s,state,i);
                    },this);
                }
            }
            processState(state,retState);
            if(!blankable)  retState.addStates([state]);
        },this);
        ls.forEach(function(s){
            s.addStates(rP[startSymbol].states);
        });
        return retState.states;
    },*/

    buildTraverse: function(symbol,endStates) {
        var rule = this.stateOptions(symbol),
            retState = new State("",symbol);
        retState.addStates(rule);
        for(var optionIndex = 0, optionCount = rule.length;
            optionIndex < optionCount; optionIndex++) {
            // step through states
            var state = retState.states[optionIndex], self = this;
            function step(state,lastState,stateIndex) {
                var nextStates = state.states.length > 0 ?
                    state.states : endStates;
                if(state.dummy) {
                    var ruleState = self.buildTraverse(
                        state.terminal,
                        endStates
                    );
                    lastState.states.splice(stateIndex,1);
                    lastState.addStates(ruleState.states);
                    state = lastState;
                }
                // state must be a terminal now
                if(state.terminal === "") {
                    lastState.states.splice(stateIndex,1);
                    lastState.addStates(nextStates);
                    state = lastState;
                }
                // state is now a non-empty terminal
                if(state.states.length === 0) {
                    state.addStates(endStates);
                }
                else {
                    for(var i=0,l=state.states.length; i<l; i++) {
                        step(state.states[i],state,i);
                    }
                }
            }
        }
    }


}
module.exports = Grammar;

},{"./State.js":4}],4:[function(require,module,exports){
var StateCount = 0;

function union_arrays (x, y) {
    var obj = {};
    for (var i = x.length-1; i >= 0; -- i)
       obj[x[i]] = x[i];
    for (var i = y.length-1; i >= 0; -- i)
       obj[y[i]] = y[i];
    var res = []
    for (var k in obj) {
        res.push(obj[k]);
    }
    return res;
}

function State(terminal,label) {
		this.terminal = terminal;
		this.states = [];
    this.label = label || StateCount++;
}

State.merge = function(retops, ops) {
		if(typeof retops === "undefined") {
    		retops = [];
    }
    ops.forEach(function(op){
    		st = retops.find(function(rop) {
        		return rop.terminal === op.terminal;
        });
        if(typeof st !== "undefined") {
        		st = State.merge(st.states, op.states);
        }
        else {
        		retops.push(op);
        }
    });
    return retops;
}

State.addToEnd = function(targets,insert) {
    for(var i=0,l=targets.length; i<l; i++) {
        if(targets[i].states.length === 0) {
            targets[i].states = insert;
        }
        else {
            State.addToEnd(targets[i].states,insert);
        }
    }
}

State.prototype = {
	addStates : function(states,copy) {
        if(copy) {
            var newStates = [];
            states.forEach(function(s){
                newStates.push(s.deepCopy());
            });
            states = newStates;
        }
		this.states = State.merge(this.states, states);
    },
    deepCopy : function() {
        var s = new State(this.terminal),
            oldLabels = {};
        for(var i=0,l=this.states.length;i<l;i++) {
            if(typeof oldLabels[this.states[i].label] === "undefined"
                && !this.states[i].dummy) {
                oldLabels[this.states[i].label] = true;
                s.states.push(this.states[i].deepCopy());
            }
        }
        return s;
    }
}

module.exports = State;

},{}],5:[function(require,module,exports){
/**
 * vis.js
 * https://github.com/almende/vis
 *
 * A dynamic, browser-based visualization library.
 *
 * @version 4.16.1
 * @date    2016-04-18
 *
 * @license
 * Copyright (C) 2011-2016 Almende B.V, http://almende.com
 *
 * Vis.js is dual licensed under both
 *
 * * The Apache 2.0 License
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * and
 *
 * * The MIT License
 *   http://opensource.org/licenses/MIT
 *
 * Vis.js may be distributed under either license.
 */

"use strict";

(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["vis"] = factory();
	else
		root["vis"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var util = __webpack_require__(1);

  // Graph3d
  util.extend(exports, __webpack_require__(7));

  // Timeline & Graph2d
  util.extend(exports, __webpack_require__(24));

  // Network
  util.extend(exports, __webpack_require__(60));

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

  // utility functions

  // first check if moment.js is already loaded in the browser window, if so,
  // use this instance. Else, load via commonjs.

  var moment = __webpack_require__(2);
  var uuid = __webpack_require__(6);

  /**
   * Test whether given object is a number
   * @param {*} object
   * @return {Boolean} isNumber
   */
  exports.isNumber = function (object) {
    return object instanceof Number || typeof object == 'number';
  };

  /**
   * Remove everything in the DOM object
   * @param DOMobject
   */
  exports.recursiveDOMDelete = function (DOMobject) {
    if (DOMobject) {
      while (DOMobject.hasChildNodes() === true) {
        exports.recursiveDOMDelete(DOMobject.firstChild);
        DOMobject.removeChild(DOMobject.firstChild);
      }
    }
  };

  /**
   * this function gives you a range between 0 and 1 based on the min and max values in the set, the total sum of all values and the current value.
   *
   * @param min
   * @param max
   * @param total
   * @param value
   * @returns {number}
   */
  exports.giveRange = function (min, max, total, value) {
    if (max == min) {
      return 0.5;
    } else {
      var scale = 1 / (max - min);
      return Math.max(0, (value - min) * scale);
    }
  };

  /**
   * Test whether given object is a string
   * @param {*} object
   * @return {Boolean} isString
   */
  exports.isString = function (object) {
    return object instanceof String || typeof object == 'string';
  };

  /**
   * Test whether given object is a Date, or a String containing a Date
   * @param {Date | String} object
   * @return {Boolean} isDate
   */
  exports.isDate = function (object) {
    if (object instanceof Date) {
      return true;
    } else if (exports.isString(object)) {
      // test whether this string contains a date
      var match = ASPDateRegex.exec(object);
      if (match) {
        return true;
      } else if (!isNaN(Date.parse(object))) {
        return true;
      }
    }

    return false;
  };

  /**
   * Create a semi UUID
   * source: http://stackoverflow.com/a/105074/1262753
   * @return {String} uuid
   */
  exports.randomUUID = function () {
    return uuid.v4();
  };

  /**
   * assign all keys of an object that are not nested objects to a certain value (used for color objects).
   * @param obj
   * @param value
   */
  exports.assignAllKeys = function (obj, value) {
    for (var prop in obj) {
      if (obj.hasOwnProperty(prop)) {
        if (_typeof(obj[prop]) !== 'object') {
          obj[prop] = value;
        }
      }
    }
  };

  /**
   * Fill an object with a possibly partially defined other object. Only copies values if the a object has an object requiring values.
   * That means an object is not created on a property if only the b object has it.
   * @param obj
   * @param value
   */
  exports.fillIfDefined = function (a, b) {
    var allowDeletion = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

    for (var prop in a) {
      if (b[prop] !== undefined) {
        if (_typeof(b[prop]) !== 'object') {
          if ((b[prop] === undefined || b[prop] === null) && a[prop] !== undefined && allowDeletion === true) {
            delete a[prop];
          } else {
            a[prop] = b[prop];
          }
        } else {
          if (_typeof(a[prop]) === 'object') {
            exports.fillIfDefined(a[prop], b[prop], allowDeletion);
          }
        }
      }
    }
  };

  /**
   * Extend object a with the properties of object b or a series of objects
   * Only properties with defined values are copied
   * @param {Object} a
   * @param {... Object} b
   * @return {Object} a
   */
  exports.protoExtend = function (a, b) {
    for (var i = 1; i < arguments.length; i++) {
      var other = arguments[i];
      for (var prop in other) {
        a[prop] = other[prop];
      }
    }
    return a;
  };

  /**
   * Extend object a with the properties of object b or a series of objects
   * Only properties with defined values are copied
   * @param {Object} a
   * @param {... Object} b
   * @return {Object} a
   */
  exports.extend = function (a, b) {
    for (var i = 1; i < arguments.length; i++) {
      var other = arguments[i];
      for (var prop in other) {
        if (other.hasOwnProperty(prop)) {
          a[prop] = other[prop];
        }
      }
    }
    return a;
  };

  /**
   * Extend object a with selected properties of object b or a series of objects
   * Only properties with defined values are copied
   * @param {Array.<String>} props
   * @param {Object} a
   * @param {Object} b
   * @return {Object} a
   */
  exports.selectiveExtend = function (props, a, b) {
    if (!Array.isArray(props)) {
      throw new Error('Array with property names expected as first argument');
    }

    for (var i = 2; i < arguments.length; i++) {
      var other = arguments[i];

      for (var p = 0; p < props.length; p++) {
        var prop = props[p];
        if (other.hasOwnProperty(prop)) {
          a[prop] = other[prop];
        }
      }
    }
    return a;
  };

  /**
   * Extend object a with selected properties of object b or a series of objects
   * Only properties with defined values are copied
   * @param {Array.<String>} props
   * @param {Object} a
   * @param {Object} b
   * @return {Object} a
   */
  exports.selectiveDeepExtend = function (props, a, b) {
    var allowDeletion = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

    // TODO: add support for Arrays to deepExtend
    if (Array.isArray(b)) {
      throw new TypeError('Arrays are not supported by deepExtend');
    }
    for (var i = 2; i < arguments.length; i++) {
      var other = arguments[i];
      for (var p = 0; p < props.length; p++) {
        var prop = props[p];
        if (other.hasOwnProperty(prop)) {
          if (b[prop] && b[prop].constructor === Object) {
            if (a[prop] === undefined) {
              a[prop] = {};
            }
            if (a[prop].constructor === Object) {
              exports.deepExtend(a[prop], b[prop], false, allowDeletion);
            } else {
              if (b[prop] === null && a[prop] !== undefined && allowDeletion === true) {
                delete a[prop];
              } else {
                a[prop] = b[prop];
              }
            }
          } else if (Array.isArray(b[prop])) {
            throw new TypeError('Arrays are not supported by deepExtend');
          } else {
            if (b[prop] === null && a[prop] !== undefined && allowDeletion === true) {
              delete a[prop];
            } else {
              a[prop] = b[prop];
            }
          }
        }
      }
    }
    return a;
  };

  /**
   * Extend object a with selected properties of object b or a series of objects
   * Only properties with defined values are copied
   * @param {Array.<String>} props
   * @param {Object} a
   * @param {Object} b
   * @return {Object} a
   */
  exports.selectiveNotDeepExtend = function (props, a, b) {
    var allowDeletion = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

    // TODO: add support for Arrays to deepExtend
    if (Array.isArray(b)) {
      throw new TypeError('Arrays are not supported by deepExtend');
    }
    for (var prop in b) {
      if (b.hasOwnProperty(prop)) {
        if (props.indexOf(prop) == -1) {
          if (b[prop] && b[prop].constructor === Object) {
            if (a[prop] === undefined) {
              a[prop] = {};
            }
            if (a[prop].constructor === Object) {
              exports.deepExtend(a[prop], b[prop]);
            } else {
              if (b[prop] === null && a[prop] !== undefined && allowDeletion === true) {
                delete a[prop];
              } else {
                a[prop] = b[prop];
              }
            }
          } else if (Array.isArray(b[prop])) {
            a[prop] = [];
            for (var i = 0; i < b[prop].length; i++) {
              a[prop].push(b[prop][i]);
            }
          } else {
            if (b[prop] === null && a[prop] !== undefined && allowDeletion === true) {
              delete a[prop];
            } else {
              a[prop] = b[prop];
            }
          }
        }
      }
    }
    return a;
  };

  /**
   * Deep extend an object a with the properties of object b
   * @param {Object} a
   * @param {Object} b
   * @param [Boolean] protoExtend --> optional parameter. If true, the prototype values will also be extended.
   *                                  (ie. the options objects that inherit from others will also get the inherited options)
   * @param [Boolean] global      --> optional parameter. If true, the values of fields that are null will not deleted
   * @returns {Object}
   */
  exports.deepExtend = function (a, b, protoExtend, allowDeletion) {
    for (var prop in b) {
      if (b.hasOwnProperty(prop) || protoExtend === true) {
        if (b[prop] && b[prop].constructor === Object) {
          if (a[prop] === undefined) {
            a[prop] = {};
          }
          if (a[prop].constructor === Object) {
            exports.deepExtend(a[prop], b[prop], protoExtend);
          } else {
            if (b[prop] === null && a[prop] !== undefined && allowDeletion === true) {
              delete a[prop];
            } else {
              a[prop] = b[prop];
            }
          }
        } else if (Array.isArray(b[prop])) {
          a[prop] = [];
          for (var i = 0; i < b[prop].length; i++) {
            a[prop].push(b[prop][i]);
          }
        } else {
          if (b[prop] === null && a[prop] !== undefined && allowDeletion === true) {
            delete a[prop];
          } else {
            a[prop] = b[prop];
          }
        }
      }
    }
    return a;
  };

  /**
   * Test whether all elements in two arrays are equal.
   * @param {Array} a
   * @param {Array} b
   * @return {boolean} Returns true if both arrays have the same length and same
   *                   elements.
   */
  exports.equalArray = function (a, b) {
    if (a.length != b.length) return false;

    for (var i = 0, len = a.length; i < len; i++) {
      if (a[i] != b[i]) return false;
    }

    return true;
  };

  /**
   * Convert an object to another type
   * @param {Boolean | Number | String | Date | Moment | Null | undefined} object
   * @param {String | undefined} type   Name of the type. Available types:
   *                                    'Boolean', 'Number', 'String',
   *                                    'Date', 'Moment', ISODate', 'ASPDate'.
   * @return {*} object
   * @throws Error
   */
  exports.convert = function (object, type) {
    var match;

    if (object === undefined) {
      return undefined;
    }
    if (object === null) {
      return null;
    }

    if (!type) {
      return object;
    }
    if (!(typeof type === 'string') && !(type instanceof String)) {
      throw new Error('Type must be a string');
    }

    //noinspection FallthroughInSwitchStatementJS
    switch (type) {
      case 'boolean':
      case 'Boolean':
        return Boolean(object);

      case 'number':
      case 'Number':
        return Number(object.valueOf());

      case 'string':
      case 'String':
        return String(object);

      case 'Date':
        if (exports.isNumber(object)) {
          return new Date(object);
        }
        if (object instanceof Date) {
          return new Date(object.valueOf());
        } else if (moment.isMoment(object)) {
          return new Date(object.valueOf());
        }
        if (exports.isString(object)) {
          match = ASPDateRegex.exec(object);
          if (match) {
            // object is an ASP date
            return new Date(Number(match[1])); // parse number
          } else {
              return moment(object).toDate(); // parse string
            }
        } else {
            throw new Error('Cannot convert object of type ' + exports.getType(object) + ' to type Date');
          }

      case 'Moment':
        if (exports.isNumber(object)) {
          return moment(object);
        }
        if (object instanceof Date) {
          return moment(object.valueOf());
        } else if (moment.isMoment(object)) {
          return moment(object);
        }
        if (exports.isString(object)) {
          match = ASPDateRegex.exec(object);
          if (match) {
            // object is an ASP date
            return moment(Number(match[1])); // parse number
          } else {
              return moment(object); // parse string
            }
        } else {
            throw new Error('Cannot convert object of type ' + exports.getType(object) + ' to type Date');
          }

      case 'ISODate':
        if (exports.isNumber(object)) {
          return new Date(object);
        } else if (object instanceof Date) {
          return object.toISOString();
        } else if (moment.isMoment(object)) {
          return object.toDate().toISOString();
        } else if (exports.isString(object)) {
          match = ASPDateRegex.exec(object);
          if (match) {
            // object is an ASP date
            return new Date(Number(match[1])).toISOString(); // parse number
          } else {
              return new Date(object).toISOString(); // parse string
            }
        } else {
            throw new Error('Cannot convert object of type ' + exports.getType(object) + ' to type ISODate');
          }

      case 'ASPDate':
        if (exports.isNumber(object)) {
          return '/Date(' + object + ')/';
        } else if (object instanceof Date) {
          return '/Date(' + object.valueOf() + ')/';
        } else if (exports.isString(object)) {
          match = ASPDateRegex.exec(object);
          var value;
          if (match) {
            // object is an ASP date
            value = new Date(Number(match[1])).valueOf(); // parse number
          } else {
              value = new Date(object).valueOf(); // parse string
            }
          return '/Date(' + value + ')/';
        } else {
          throw new Error('Cannot convert object of type ' + exports.getType(object) + ' to type ASPDate');
        }

      default:
        throw new Error('Unknown type "' + type + '"');
    }
  };

  // parse ASP.Net Date pattern,
  // for example '/Date(1198908717056)/' or '/Date(1198908717056-0700)/'
  // code from http://momentjs.com/
  var ASPDateRegex = /^\/?Date\((\-?\d+)/i;

  /**
   * Get the type of an object, for example exports.getType([]) returns 'Array'
   * @param {*} object
   * @return {String} type
   */
  exports.getType = function (object) {
    var type = typeof object === 'undefined' ? 'undefined' : _typeof(object);

    if (type == 'object') {
      if (object === null) {
        return 'null';
      }
      if (object instanceof Boolean) {
        return 'Boolean';
      }
      if (object instanceof Number) {
        return 'Number';
      }
      if (object instanceof String) {
        return 'String';
      }
      if (Array.isArray(object)) {
        return 'Array';
      }
      if (object instanceof Date) {
        return 'Date';
      }
      return 'Object';
    } else if (type == 'number') {
      return 'Number';
    } else if (type == 'boolean') {
      return 'Boolean';
    } else if (type == 'string') {
      return 'String';
    } else if (type === undefined) {
      return 'undefined';
    }

    return type;
  };

  /**
   * Used to extend an array and copy it. This is used to propagate paths recursively.
   *
   * @param arr
   * @param newValue
   * @returns {Array}
   */
  exports.copyAndExtendArray = function (arr, newValue) {
    var newArr = [];
    for (var i = 0; i < arr.length; i++) {
      newArr.push(arr[i]);
    }
    newArr.push(newValue);
    return newArr;
  };

  /**
   * Used to extend an array and copy it. This is used to propagate paths recursively.
   *
   * @param arr
   * @param newValue
   * @returns {Array}
   */
  exports.copyArray = function (arr) {
    var newArr = [];
    for (var i = 0; i < arr.length; i++) {
      newArr.push(arr[i]);
    }
    return newArr;
  };

  /**
   * Retrieve the absolute left value of a DOM element
   * @param {Element} elem        A dom element, for example a div
   * @return {number} left        The absolute left position of this element
   *                              in the browser page.
   */
  exports.getAbsoluteLeft = function (elem) {
    return elem.getBoundingClientRect().left;
  };

  exports.getAbsoluteRight = function (elem) {
    return elem.getBoundingClientRect().right;
  };

  /**
   * Retrieve the absolute top value of a DOM element
   * @param {Element} elem        A dom element, for example a div
   * @return {number} top        The absolute top position of this element
   *                              in the browser page.
   */
  exports.getAbsoluteTop = function (elem) {
    return elem.getBoundingClientRect().top;
  };

  /**
   * add a className to the given elements style
   * @param {Element} elem
   * @param {String} className
   */
  exports.addClassName = function (elem, className) {
    var classes = elem.className.split(' ');
    if (classes.indexOf(className) == -1) {
      classes.push(className); // add the class to the array
      elem.className = classes.join(' ');
    }
  };

  /**
   * add a className to the given elements style
   * @param {Element} elem
   * @param {String} className
   */
  exports.removeClassName = function (elem, className) {
    var classes = elem.className.split(' ');
    var index = classes.indexOf(className);
    if (index != -1) {
      classes.splice(index, 1); // remove the class from the array
      elem.className = classes.join(' ');
    }
  };

  /**
   * For each method for both arrays and objects.
   * In case of an array, the built-in Array.forEach() is applied.
   * In case of an Object, the method loops over all properties of the object.
   * @param {Object | Array} object   An Object or Array
   * @param {function} callback       Callback method, called for each item in
   *                                  the object or array with three parameters:
   *                                  callback(value, index, object)
   */
  exports.forEach = function (object, callback) {
    var i, len;
    if (Array.isArray(object)) {
      // array
      for (i = 0, len = object.length; i < len; i++) {
        callback(object[i], i, object);
      }
    } else {
      // object
      for (i in object) {
        if (object.hasOwnProperty(i)) {
          callback(object[i], i, object);
        }
      }
    }
  };

  /**
   * Convert an object into an array: all objects properties are put into the
   * array. The resulting array is unordered.
   * @param {Object} object
   * @param {Array} array
   */
  exports.toArray = function (object) {
    var array = [];

    for (var prop in object) {
      if (object.hasOwnProperty(prop)) array.push(object[prop]);
    }

    return array;
  };

  /**
   * Update a property in an object
   * @param {Object} object
   * @param {String} key
   * @param {*} value
   * @return {Boolean} changed
   */
  exports.updateProperty = function (object, key, value) {
    if (object[key] !== value) {
      object[key] = value;
      return true;
    } else {
      return false;
    }
  };

  /**
   * Throttle the given function to be only executed once every `wait` milliseconds
   * @param {function} fn
   * @param {number} wait    Time in milliseconds
   * @returns {function} Returns the throttled function
   */
  exports.throttle = function (fn, wait) {
    var timeout = null;
    var needExecution = false;

    return function throttled() {
      if (!timeout) {
        needExecution = false;
        fn();

        timeout = setTimeout(function () {
          timeout = null;
          if (needExecution) {
            throttled();
          }
        }, wait);
      } else {
        needExecution = true;
      }
    };
  };

  /**
   * Add and event listener. Works for all browsers
   * @param {Element}     element    An html element
   * @param {string}      action     The action, for example "click",
   *                                 without the prefix "on"
   * @param {function}    listener   The callback function to be executed
   * @param {boolean}     [useCapture]
   */
  exports.addEventListener = function (element, action, listener, useCapture) {
    if (element.addEventListener) {
      if (useCapture === undefined) useCapture = false;

      if (action === "mousewheel" && navigator.userAgent.indexOf("Firefox") >= 0) {
        action = "DOMMouseScroll"; // For Firefox
      }

      element.addEventListener(action, listener, useCapture);
    } else {
      element.attachEvent("on" + action, listener); // IE browsers
    }
  };

  /**
   * Remove an event listener from an element
   * @param {Element}     element         An html dom element
   * @param {string}      action          The name of the event, for example "mousedown"
   * @param {function}    listener        The listener function
   * @param {boolean}     [useCapture]
   */
  exports.removeEventListener = function (element, action, listener, useCapture) {
    if (element.removeEventListener) {
      // non-IE browsers
      if (useCapture === undefined) useCapture = false;

      if (action === "mousewheel" && navigator.userAgent.indexOf("Firefox") >= 0) {
        action = "DOMMouseScroll"; // For Firefox
      }

      element.removeEventListener(action, listener, useCapture);
    } else {
      // IE browsers
      element.detachEvent("on" + action, listener);
    }
  };

  /**
   * Cancels the event if it is cancelable, without stopping further propagation of the event.
   */
  exports.preventDefault = function (event) {
    if (!event) event = window.event;

    if (event.preventDefault) {
      event.preventDefault(); // non-IE browsers
    } else {
        event.returnValue = false; // IE browsers
      }
  };

  /**
   * Get HTML element which is the target of the event
   * @param {Event} event
   * @return {Element} target element
   */
  exports.getTarget = function (event) {
    // code from http://www.quirksmode.org/js/events_properties.html
    if (!event) {
      event = window.event;
    }

    var target;

    if (event.target) {
      target = event.target;
    } else if (event.srcElement) {
      target = event.srcElement;
    }

    if (target.nodeType != undefined && target.nodeType == 3) {
      // defeat Safari bug
      target = target.parentNode;
    }

    return target;
  };

  /**
   * Check if given element contains given parent somewhere in the DOM tree
   * @param {Element} element
   * @param {Element} parent
   */
  exports.hasParent = function (element, parent) {
    var e = element;

    while (e) {
      if (e === parent) {
        return true;
      }
      e = e.parentNode;
    }

    return false;
  };

  exports.option = {};

  /**
   * Convert a value into a boolean
   * @param {Boolean | function | undefined} value
   * @param {Boolean} [defaultValue]
   * @returns {Boolean} bool
   */
  exports.option.asBoolean = function (value, defaultValue) {
    if (typeof value == 'function') {
      value = value();
    }

    if (value != null) {
      return value != false;
    }

    return defaultValue || null;
  };

  /**
   * Convert a value into a number
   * @param {Boolean | function | undefined} value
   * @param {Number} [defaultValue]
   * @returns {Number} number
   */
  exports.option.asNumber = function (value, defaultValue) {
    if (typeof value == 'function') {
      value = value();
    }

    if (value != null) {
      return Number(value) || defaultValue || null;
    }

    return defaultValue || null;
  };

  /**
   * Convert a value into a string
   * @param {String | function | undefined} value
   * @param {String} [defaultValue]
   * @returns {String} str
   */
  exports.option.asString = function (value, defaultValue) {
    if (typeof value == 'function') {
      value = value();
    }

    if (value != null) {
      return String(value);
    }

    return defaultValue || null;
  };

  /**
   * Convert a size or location into a string with pixels or a percentage
   * @param {String | Number | function | undefined} value
   * @param {String} [defaultValue]
   * @returns {String} size
   */
  exports.option.asSize = function (value, defaultValue) {
    if (typeof value == 'function') {
      value = value();
    }

    if (exports.isString(value)) {
      return value;
    } else if (exports.isNumber(value)) {
      return value + 'px';
    } else {
      return defaultValue || null;
    }
  };

  /**
   * Convert a value into a DOM element
   * @param {HTMLElement | function | undefined} value
   * @param {HTMLElement} [defaultValue]
   * @returns {HTMLElement | null} dom
   */
  exports.option.asElement = function (value, defaultValue) {
    if (typeof value == 'function') {
      value = value();
    }

    return value || defaultValue || null;
  };

  /**
   * http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
   *
   * @param {String} hex
   * @returns {{r: *, g: *, b: *}} | 255 range
   */
  exports.hexToRGB = function (hex) {
    // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
    var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    hex = hex.replace(shorthandRegex, function (m, r, g, b) {
      return r + r + g + g + b + b;
    });
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : null;
  };

  /**
   * This function takes color in hex format or rgb() or rgba() format and overrides the opacity. Returns rgba() string.
   * @param color
   * @param opacity
   * @returns {*}
   */
  exports.overrideOpacity = function (color, opacity) {
    if (color.indexOf("rgba") != -1) {
      return color;
    } else if (color.indexOf("rgb") != -1) {
      var rgb = color.substr(color.indexOf("(") + 1).replace(")", "").split(",");
      return "rgba(" + rgb[0] + "," + rgb[1] + "," + rgb[2] + "," + opacity + ")";
    } else {
      var rgb = exports.hexToRGB(color);
      if (rgb == null) {
        return color;
      } else {
        return "rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + "," + opacity + ")";
      }
    }
  };

  /**
   *
   * @param red     0 -- 255
   * @param green   0 -- 255
   * @param blue    0 -- 255
   * @returns {string}
   * @constructor
   */
  exports.RGBToHex = function (red, green, blue) {
    return "#" + ((1 << 24) + (red << 16) + (green << 8) + blue).toString(16).slice(1);
  };

  /**
   * Parse a color property into an object with border, background, and
   * highlight colors
   * @param {Object | String} color
   * @return {Object} colorObject
   */
  exports.parseColor = function (color) {
    var c;
    if (exports.isString(color) === true) {
      if (exports.isValidRGB(color) === true) {
        var rgb = color.substr(4).substr(0, color.length - 5).split(',').map(function (value) {
          return parseInt(value);
        });
        color = exports.RGBToHex(rgb[0], rgb[1], rgb[2]);
      }
      if (exports.isValidHex(color) === true) {
        var hsv = exports.hexToHSV(color);
        var lighterColorHSV = { h: hsv.h, s: hsv.s * 0.8, v: Math.min(1, hsv.v * 1.02) };
        var darkerColorHSV = { h: hsv.h, s: Math.min(1, hsv.s * 1.25), v: hsv.v * 0.8 };
        var darkerColorHex = exports.HSVToHex(darkerColorHSV.h, darkerColorHSV.s, darkerColorHSV.v);
        var lighterColorHex = exports.HSVToHex(lighterColorHSV.h, lighterColorHSV.s, lighterColorHSV.v);
        c = {
          background: color,
          border: darkerColorHex,
          highlight: {
            background: lighterColorHex,
            border: darkerColorHex
          },
          hover: {
            background: lighterColorHex,
            border: darkerColorHex
          }
        };
      } else {
        c = {
          background: color,
          border: color,
          highlight: {
            background: color,
            border: color
          },
          hover: {
            background: color,
            border: color
          }
        };
      }
    } else {
      c = {};
      c.background = color.background || undefined;
      c.border = color.border || undefined;

      if (exports.isString(color.highlight)) {
        c.highlight = {
          border: color.highlight,
          background: color.highlight
        };
      } else {
        c.highlight = {};
        c.highlight.background = color.highlight && color.highlight.background || undefined;
        c.highlight.border = color.highlight && color.highlight.border || undefined;
      }

      if (exports.isString(color.hover)) {
        c.hover = {
          border: color.hover,
          background: color.hover
        };
      } else {
        c.hover = {};
        c.hover.background = color.hover && color.hover.background || undefined;
        c.hover.border = color.hover && color.hover.border || undefined;
      }
    }

    return c;
  };

  /**
   * http://www.javascripter.net/faq/rgb2hsv.htm
   *
   * @param red
   * @param green
   * @param blue
   * @returns {*}
   * @constructor
   */
  exports.RGBToHSV = function (red, green, blue) {
    red = red / 255;green = green / 255;blue = blue / 255;
    var minRGB = Math.min(red, Math.min(green, blue));
    var maxRGB = Math.max(red, Math.max(green, blue));

    // Black-gray-white
    if (minRGB == maxRGB) {
      return { h: 0, s: 0, v: minRGB };
    }

    // Colors other than black-gray-white:
    var d = red == minRGB ? green - blue : blue == minRGB ? red - green : blue - red;
    var h = red == minRGB ? 3 : blue == minRGB ? 1 : 5;
    var hue = 60 * (h - d / (maxRGB - minRGB)) / 360;
    var saturation = (maxRGB - minRGB) / maxRGB;
    var value = maxRGB;
    return { h: hue, s: saturation, v: value };
  };

  var cssUtil = {
    // split a string with css styles into an object with key/values
    split: function split(cssText) {
      var styles = {};

      cssText.split(';').forEach(function (style) {
        if (style.trim() != '') {
          var parts = style.split(':');
          var key = parts[0].trim();
          var value = parts[1].trim();
          styles[key] = value;
        }
      });

      return styles;
    },

    // build a css text string from an object with key/values
    join: function join(styles) {
      return Object.keys(styles).map(function (key) {
        return key + ': ' + styles[key];
      }).join('; ');
    }
  };

  /**
   * Append a string with css styles to an element
   * @param {Element} element
   * @param {String} cssText
   */
  exports.addCssText = function (element, cssText) {
    var currentStyles = cssUtil.split(element.style.cssText);
    var newStyles = cssUtil.split(cssText);
    var styles = exports.extend(currentStyles, newStyles);

    element.style.cssText = cssUtil.join(styles);
  };

  /**
   * Remove a string with css styles from an element
   * @param {Element} element
   * @param {String} cssText
   */
  exports.removeCssText = function (element, cssText) {
    var styles = cssUtil.split(element.style.cssText);
    var removeStyles = cssUtil.split(cssText);

    for (var key in removeStyles) {
      if (removeStyles.hasOwnProperty(key)) {
        delete styles[key];
      }
    }

    element.style.cssText = cssUtil.join(styles);
  };

  /**
   * https://gist.github.com/mjijackson/5311256
   * @param h
   * @param s
   * @param v
   * @returns {{r: number, g: number, b: number}}
   * @constructor
   */
  exports.HSVToRGB = function (h, s, v) {
    var r, g, b;

    var i = Math.floor(h * 6);
    var f = h * 6 - i;
    var p = v * (1 - s);
    var q = v * (1 - f * s);
    var t = v * (1 - (1 - f) * s);

    switch (i % 6) {
      case 0:
        r = v, g = t, b = p;break;
      case 1:
        r = q, g = v, b = p;break;
      case 2:
        r = p, g = v, b = t;break;
      case 3:
        r = p, g = q, b = v;break;
      case 4:
        r = t, g = p, b = v;break;
      case 5:
        r = v, g = p, b = q;break;
    }

    return { r: Math.floor(r * 255), g: Math.floor(g * 255), b: Math.floor(b * 255) };
  };

  exports.HSVToHex = function (h, s, v) {
    var rgb = exports.HSVToRGB(h, s, v);
    return exports.RGBToHex(rgb.r, rgb.g, rgb.b);
  };

  exports.hexToHSV = function (hex) {
    var rgb = exports.hexToRGB(hex);
    return exports.RGBToHSV(rgb.r, rgb.g, rgb.b);
  };

  exports.isValidHex = function (hex) {
    var isOk = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(hex);
    return isOk;
  };

  exports.isValidRGB = function (rgb) {
    rgb = rgb.replace(" ", "");
    var isOk = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/i.test(rgb);
    return isOk;
  };
  exports.isValidRGBA = function (rgba) {
    rgba = rgba.replace(" ", "");
    var isOk = /rgba\((\d{1,3}),(\d{1,3}),(\d{1,3}),(.{1,3})\)/i.test(rgba);
    return isOk;
  };

  /**
   * This recursively redirects the prototype of JSON objects to the referenceObject
   * This is used for default options.
   *
   * @param referenceObject
   * @returns {*}
   */
  exports.selectiveBridgeObject = function (fields, referenceObject) {
    if ((typeof referenceObject === 'undefined' ? 'undefined' : _typeof(referenceObject)) == "object") {
      var objectTo = Object.create(referenceObject);
      for (var i = 0; i < fields.length; i++) {
        if (referenceObject.hasOwnProperty(fields[i])) {
          if (_typeof(referenceObject[fields[i]]) == "object") {
            objectTo[fields[i]] = exports.bridgeObject(referenceObject[fields[i]]);
          }
        }
      }
      return objectTo;
    } else {
      return null;
    }
  };

  /**
   * This recursively redirects the prototype of JSON objects to the referenceObject
   * This is used for default options.
   *
   * @param referenceObject
   * @returns {*}
   */
  exports.bridgeObject = function (referenceObject) {
    if ((typeof referenceObject === 'undefined' ? 'undefined' : _typeof(referenceObject)) == "object") {
      var objectTo = Object.create(referenceObject);
      for (var i in referenceObject) {
        if (referenceObject.hasOwnProperty(i)) {
          if (_typeof(referenceObject[i]) == "object") {
            objectTo[i] = exports.bridgeObject(referenceObject[i]);
          }
        }
      }
      return objectTo;
    } else {
      return null;
    }
  };

  /**
   * This method provides a stable sort implementation, very fast for presorted data
   *
   * @param a the array
   * @param a order comparator
   * @returns {the array}
   */
  exports.insertSort = function (a, compare) {
    for (var i = 0; i < a.length; i++) {
      var k = a[i];
      for (var j = i; j > 0 && compare(k, a[j - 1]) < 0; j--) {
        a[j] = a[j - 1];
      }
      a[j] = k;
    }
    return a;
  };

  /**
   * this is used to set the options of subobjects in the options object. A requirement of these subobjects
   * is that they have an 'enabled' element which is optional for the user but mandatory for the program.
   *
   * @param [object] mergeTarget | this is either this.options or the options used for the groups.
   * @param [object] options     | options
   * @param [String] option      | this is the option key in the options argument
   */
  exports.mergeOptions = function (mergeTarget, options, option) {
    var allowDeletion = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];
    var globalOptions = arguments.length <= 4 || arguments[4] === undefined ? {} : arguments[4];

    if (options[option] === null) {
      mergeTarget[option] = Object.create(globalOptions[option]);
    } else {
      if (options[option] !== undefined) {
        if (typeof options[option] === 'boolean') {
          mergeTarget[option].enabled = options[option];
        } else {
          if (options[option].enabled === undefined) {
            mergeTarget[option].enabled = true;
          }
          for (var prop in options[option]) {
            if (options[option].hasOwnProperty(prop)) {
              mergeTarget[option][prop] = options[option][prop];
            }
          }
        }
      }
    }
  };

  /**
   * This function does a binary search for a visible item in a sorted list. If we find a visible item, the code that uses
   * this function will then iterate in both directions over this sorted list to find all visible items.
   *
   * @param {Item[]} orderedItems       | Items ordered by start
   * @param {function} comparator       | -1 is lower, 0 is equal, 1 is higher
   * @param {String} field
   * @param {String} field2
   * @returns {number}
   * @private
   */
  exports.binarySearchCustom = function (orderedItems, comparator, field, field2) {
    var maxIterations = 10000;
    var iteration = 0;
    var low = 0;
    var high = orderedItems.length - 1;

    while (low <= high && iteration < maxIterations) {
      var middle = Math.floor((low + high) / 2);

      var item = orderedItems[middle];
      var value = field2 === undefined ? item[field] : item[field][field2];

      var searchResult = comparator(value);
      if (searchResult == 0) {
        // jihaa, found a visible item!
        return middle;
      } else if (searchResult == -1) {
        // it is too small --> increase low
        low = middle + 1;
      } else {
        // it is too big --> decrease high
        high = middle - 1;
      }

      iteration++;
    }

    return -1;
  };

  /**
   * This function does a binary search for a specific value in a sorted array. If it does not exist but is in between of
   * two values, we return either the one before or the one after, depending on user input
   * If it is found, we return the index, else -1.
   *
   * @param {Array} orderedItems
   * @param {{start: number, end: number}} target
   * @param {String} field
   * @param {String} sidePreference   'before' or 'after'
   * @param {function} comparator an optional comparator, returning -1,0,1 for <,==,>.
   * @returns {number}
   * @private
   */
  exports.binarySearchValue = function (orderedItems, target, field, sidePreference, comparator) {
    var maxIterations = 10000;
    var iteration = 0;
    var low = 0;
    var high = orderedItems.length - 1;
    var prevValue, value, nextValue, middle;

    var comparator = comparator != undefined ? comparator : function (a, b) {
      return a == b ? 0 : a < b ? -1 : 1;
    };

    while (low <= high && iteration < maxIterations) {
      // get a new guess
      middle = Math.floor(0.5 * (high + low));
      prevValue = orderedItems[Math.max(0, middle - 1)][field];
      value = orderedItems[middle][field];
      nextValue = orderedItems[Math.min(orderedItems.length - 1, middle + 1)][field];

      if (comparator(value, target) == 0) {
        // we found the target
        return middle;
      } else if (comparator(prevValue, target) < 0 && comparator(value, target) > 0) {
        // target is in between of the previous and the current
        return sidePreference == 'before' ? Math.max(0, middle - 1) : middle;
      } else if (comparator(value, target) < 0 && comparator(nextValue, target) > 0) {
        // target is in between of the current and the next
        return sidePreference == 'before' ? middle : Math.min(orderedItems.length - 1, middle + 1);
      } else {
        // didnt find the target, we need to change our boundaries.
        if (comparator(value, target) < 0) {
          // it is too small --> increase low
          low = middle + 1;
        } else {
          // it is too big --> decrease high
          high = middle - 1;
        }
      }
      iteration++;
    }

    // didnt find anything. Return -1.
    return -1;
  };

  /*
   * Easing Functions - inspired from http://gizma.com/easing/
   * only considering the t value for the range [0, 1] => [0, 1]
   * https://gist.github.com/gre/1650294
   */
  exports.easingFunctions = {
    // no easing, no acceleration
    linear: function linear(t) {
      return t;
    },
    // accelerating from zero velocity
    easeInQuad: function easeInQuad(t) {
      return t * t;
    },
    // decelerating to zero velocity
    easeOutQuad: function easeOutQuad(t) {
      return t * (2 - t);
    },
    // acceleration until halfway, then deceleration
    easeInOutQuad: function easeInOutQuad(t) {
      return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    },
    // accelerating from zero velocity
    easeInCubic: function easeInCubic(t) {
      return t * t * t;
    },
    // decelerating to zero velocity
    easeOutCubic: function easeOutCubic(t) {
      return --t * t * t + 1;
    },
    // acceleration until halfway, then deceleration
    easeInOutCubic: function easeInOutCubic(t) {
      return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
    },
    // accelerating from zero velocity
    easeInQuart: function easeInQuart(t) {
      return t * t * t * t;
    },
    // decelerating to zero velocity
    easeOutQuart: function easeOutQuart(t) {
      return 1 - --t * t * t * t;
    },
    // acceleration until halfway, then deceleration
    easeInOutQuart: function easeInOutQuart(t) {
      return t < .5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
    },
    // accelerating from zero velocity
    easeInQuint: function easeInQuint(t) {
      return t * t * t * t * t;
    },
    // decelerating to zero velocity
    easeOutQuint: function easeOutQuint(t) {
      return 1 + --t * t * t * t * t;
    },
    // acceleration until halfway, then deceleration
    easeInOutQuint: function easeInOutQuint(t) {
      return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
    }
  };

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  // first check if moment.js is already loaded in the browser window, if so,
  // use this instance. Else, load via commonjs.
  module.exports = typeof window !== 'undefined' && window['moment'] || __webpack_require__(3);

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

  /* WEBPACK VAR INJECTION */(function(module) {//! moment.js
  //! version : 2.13.0
  //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
  //! license : MIT
  //! momentjs.com

  ;(function (global, factory) {
       true ? module.exports = factory() :
      typeof define === 'function' && define.amd ? define(factory) :
      global.moment = factory()
  }(this, function () { 'use strict';

      var hookCallback;

      function utils_hooks__hooks () {
          return hookCallback.apply(null, arguments);
      }

      // This is done to register the method called with moment()
      // without creating circular dependencies.
      function setHookCallback (callback) {
          hookCallback = callback;
      }

      function isArray(input) {
          return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
      }

      function isDate(input) {
          return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
      }

      function map(arr, fn) {
          var res = [], i;
          for (i = 0; i < arr.length; ++i) {
              res.push(fn(arr[i], i));
          }
          return res;
      }

      function hasOwnProp(a, b) {
          return Object.prototype.hasOwnProperty.call(a, b);
      }

      function extend(a, b) {
          for (var i in b) {
              if (hasOwnProp(b, i)) {
                  a[i] = b[i];
              }
          }

          if (hasOwnProp(b, 'toString')) {
              a.toString = b.toString;
          }

          if (hasOwnProp(b, 'valueOf')) {
              a.valueOf = b.valueOf;
          }

          return a;
      }

      function create_utc__createUTC (input, format, locale, strict) {
          return createLocalOrUTC(input, format, locale, strict, true).utc();
      }

      function defaultParsingFlags() {
          // We need to deep clone this object.
          return {
              empty           : false,
              unusedTokens    : [],
              unusedInput     : [],
              overflow        : -2,
              charsLeftOver   : 0,
              nullInput       : false,
              invalidMonth    : null,
              invalidFormat   : false,
              userInvalidated : false,
              iso             : false,
              parsedDateParts : [],
              meridiem        : null
          };
      }

      function getParsingFlags(m) {
          if (m._pf == null) {
              m._pf = defaultParsingFlags();
          }
          return m._pf;
      }

      var some;
      if (Array.prototype.some) {
          some = Array.prototype.some;
      } else {
          some = function (fun) {
              var t = Object(this);
              var len = t.length >>> 0;

              for (var i = 0; i < len; i++) {
                  if (i in t && fun.call(this, t[i], i, t)) {
                      return true;
                  }
              }

              return false;
          };
      }

      function valid__isValid(m) {
          if (m._isValid == null) {
              var flags = getParsingFlags(m);
              var parsedParts = some.call(flags.parsedDateParts, function (i) {
                  return i != null;
              });
              m._isValid = !isNaN(m._d.getTime()) &&
                  flags.overflow < 0 &&
                  !flags.empty &&
                  !flags.invalidMonth &&
                  !flags.invalidWeekday &&
                  !flags.nullInput &&
                  !flags.invalidFormat &&
                  !flags.userInvalidated &&
                  (!flags.meridiem || (flags.meridiem && parsedParts));

              if (m._strict) {
                  m._isValid = m._isValid &&
                      flags.charsLeftOver === 0 &&
                      flags.unusedTokens.length === 0 &&
                      flags.bigHour === undefined;
              }
          }
          return m._isValid;
      }

      function valid__createInvalid (flags) {
          var m = create_utc__createUTC(NaN);
          if (flags != null) {
              extend(getParsingFlags(m), flags);
          }
          else {
              getParsingFlags(m).userInvalidated = true;
          }

          return m;
      }

      function isUndefined(input) {
          return input === void 0;
      }

      // Plugins that add properties should also add the key here (null value),
      // so we can properly clone ourselves.
      var momentProperties = utils_hooks__hooks.momentProperties = [];

      function copyConfig(to, from) {
          var i, prop, val;

          if (!isUndefined(from._isAMomentObject)) {
              to._isAMomentObject = from._isAMomentObject;
          }
          if (!isUndefined(from._i)) {
              to._i = from._i;
          }
          if (!isUndefined(from._f)) {
              to._f = from._f;
          }
          if (!isUndefined(from._l)) {
              to._l = from._l;
          }
          if (!isUndefined(from._strict)) {
              to._strict = from._strict;
          }
          if (!isUndefined(from._tzm)) {
              to._tzm = from._tzm;
          }
          if (!isUndefined(from._isUTC)) {
              to._isUTC = from._isUTC;
          }
          if (!isUndefined(from._offset)) {
              to._offset = from._offset;
          }
          if (!isUndefined(from._pf)) {
              to._pf = getParsingFlags(from);
          }
          if (!isUndefined(from._locale)) {
              to._locale = from._locale;
          }

          if (momentProperties.length > 0) {
              for (i in momentProperties) {
                  prop = momentProperties[i];
                  val = from[prop];
                  if (!isUndefined(val)) {
                      to[prop] = val;
                  }
              }
          }

          return to;
      }

      var updateInProgress = false;

      // Moment prototype object
      function Moment(config) {
          copyConfig(this, config);
          this._d = new Date(config._d != null ? config._d.getTime() : NaN);
          // Prevent infinite loop in case updateOffset creates new moment
          // objects.
          if (updateInProgress === false) {
              updateInProgress = true;
              utils_hooks__hooks.updateOffset(this);
              updateInProgress = false;
          }
      }

      function isMoment (obj) {
          return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
      }

      function absFloor (number) {
          if (number < 0) {
              return Math.ceil(number);
          } else {
              return Math.floor(number);
          }
      }

      function toInt(argumentForCoercion) {
          var coercedNumber = +argumentForCoercion,
              value = 0;

          if (coercedNumber !== 0 && isFinite(coercedNumber)) {
              value = absFloor(coercedNumber);
          }

          return value;
      }

      // compare two arrays, return the number of differences
      function compareArrays(array1, array2, dontConvert) {
          var len = Math.min(array1.length, array2.length),
              lengthDiff = Math.abs(array1.length - array2.length),
              diffs = 0,
              i;
          for (i = 0; i < len; i++) {
              if ((dontConvert && array1[i] !== array2[i]) ||
                  (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                  diffs++;
              }
          }
          return diffs + lengthDiff;
      }

      function warn(msg) {
          if (utils_hooks__hooks.suppressDeprecationWarnings === false &&
                  (typeof console !==  'undefined') && console.warn) {
              console.warn('Deprecation warning: ' + msg);
          }
      }

      function deprecate(msg, fn) {
          var firstTime = true;

          return extend(function () {
              if (utils_hooks__hooks.deprecationHandler != null) {
                  utils_hooks__hooks.deprecationHandler(null, msg);
              }
              if (firstTime) {
                  warn(msg + '\nArguments: ' + Array.prototype.slice.call(arguments).join(', ') + '\n' + (new Error()).stack);
                  firstTime = false;
              }
              return fn.apply(this, arguments);
          }, fn);
      }

      var deprecations = {};

      function deprecateSimple(name, msg) {
          if (utils_hooks__hooks.deprecationHandler != null) {
              utils_hooks__hooks.deprecationHandler(name, msg);
          }
          if (!deprecations[name]) {
              warn(msg);
              deprecations[name] = true;
          }
      }

      utils_hooks__hooks.suppressDeprecationWarnings = false;
      utils_hooks__hooks.deprecationHandler = null;

      function isFunction(input) {
          return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
      }

      function isObject(input) {
          return Object.prototype.toString.call(input) === '[object Object]';
      }

      function locale_set__set (config) {
          var prop, i;
          for (i in config) {
              prop = config[i];
              if (isFunction(prop)) {
                  this[i] = prop;
              } else {
                  this['_' + i] = prop;
              }
          }
          this._config = config;
          // Lenient ordinal parsing accepts just a number in addition to
          // number + (possibly) stuff coming from _ordinalParseLenient.
          this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
      }

      function mergeConfigs(parentConfig, childConfig) {
          var res = extend({}, parentConfig), prop;
          for (prop in childConfig) {
              if (hasOwnProp(childConfig, prop)) {
                  if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                      res[prop] = {};
                      extend(res[prop], parentConfig[prop]);
                      extend(res[prop], childConfig[prop]);
                  } else if (childConfig[prop] != null) {
                      res[prop] = childConfig[prop];
                  } else {
                      delete res[prop];
                  }
              }
          }
          return res;
      }

      function Locale(config) {
          if (config != null) {
              this.set(config);
          }
      }

      var keys;

      if (Object.keys) {
          keys = Object.keys;
      } else {
          keys = function (obj) {
              var i, res = [];
              for (i in obj) {
                  if (hasOwnProp(obj, i)) {
                      res.push(i);
                  }
              }
              return res;
          };
      }

      // internal storage for locale config files
      var locales = {};
      var globalLocale;

      function normalizeLocale(key) {
          return key ? key.toLowerCase().replace('_', '-') : key;
      }

      // pick the locale from the array
      // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
      // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
      function chooseLocale(names) {
          var i = 0, j, next, locale, split;

          while (i < names.length) {
              split = normalizeLocale(names[i]).split('-');
              j = split.length;
              next = normalizeLocale(names[i + 1]);
              next = next ? next.split('-') : null;
              while (j > 0) {
                  locale = loadLocale(split.slice(0, j).join('-'));
                  if (locale) {
                      return locale;
                  }
                  if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                      //the next array item is better than a shallower substring of this one
                      break;
                  }
                  j--;
              }
              i++;
          }
          return null;
      }

      function loadLocale(name) {
          var oldLocale = null;
          // TODO: Find a better way to register and load all the locales in Node
          if (!locales[name] && (typeof module !== 'undefined') &&
                  module && module.exports) {
              try {
                  oldLocale = globalLocale._abbr;
                  !(function webpackMissingModule() { var e = new Error("Cannot find module \"./locale\""); e.code = 'MODULE_NOT_FOUND'; throw e; }());
                  // because defineLocale currently also sets the global locale, we
                  // want to undo that for lazy loaded locales
                  locale_locales__getSetGlobalLocale(oldLocale);
              } catch (e) { }
          }
          return locales[name];
      }

      // This function will load locale and then set the global locale.  If
      // no arguments are passed in, it will simply return the current global
      // locale key.
      function locale_locales__getSetGlobalLocale (key, values) {
          var data;
          if (key) {
              if (isUndefined(values)) {
                  data = locale_locales__getLocale(key);
              }
              else {
                  data = defineLocale(key, values);
              }

              if (data) {
                  // moment.duration._locale = moment._locale = data;
                  globalLocale = data;
              }
          }

          return globalLocale._abbr;
      }

      function defineLocale (name, config) {
          if (config !== null) {
              config.abbr = name;
              if (locales[name] != null) {
                  deprecateSimple('defineLocaleOverride',
                          'use moment.updateLocale(localeName, config) to change ' +
                          'an existing locale. moment.defineLocale(localeName, ' +
                          'config) should only be used for creating a new locale');
                  config = mergeConfigs(locales[name]._config, config);
              } else if (config.parentLocale != null) {
                  if (locales[config.parentLocale] != null) {
                      config = mergeConfigs(locales[config.parentLocale]._config, config);
                  } else {
                      // treat as if there is no base config
                      deprecateSimple('parentLocaleUndefined',
                              'specified parentLocale is not defined yet');
                  }
              }
              locales[name] = new Locale(config);

              // backwards compat for now: also set the locale
              locale_locales__getSetGlobalLocale(name);

              return locales[name];
          } else {
              // useful for testing
              delete locales[name];
              return null;
          }
      }

      function updateLocale(name, config) {
          if (config != null) {
              var locale;
              if (locales[name] != null) {
                  config = mergeConfigs(locales[name]._config, config);
              }
              locale = new Locale(config);
              locale.parentLocale = locales[name];
              locales[name] = locale;

              // backwards compat for now: also set the locale
              locale_locales__getSetGlobalLocale(name);
          } else {
              // pass null for config to unupdate, useful for tests
              if (locales[name] != null) {
                  if (locales[name].parentLocale != null) {
                      locales[name] = locales[name].parentLocale;
                  } else if (locales[name] != null) {
                      delete locales[name];
                  }
              }
          }
          return locales[name];
      }

      // returns locale data
      function locale_locales__getLocale (key) {
          var locale;

          if (key && key._locale && key._locale._abbr) {
              key = key._locale._abbr;
          }

          if (!key) {
              return globalLocale;
          }

          if (!isArray(key)) {
              //short-circuit everything else
              locale = loadLocale(key);
              if (locale) {
                  return locale;
              }
              key = [key];
          }

          return chooseLocale(key);
      }

      function locale_locales__listLocales() {
          return keys(locales);
      }

      var aliases = {};

      function addUnitAlias (unit, shorthand) {
          var lowerCase = unit.toLowerCase();
          aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
      }

      function normalizeUnits(units) {
          return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
      }

      function normalizeObjectUnits(inputObject) {
          var normalizedInput = {},
              normalizedProp,
              prop;

          for (prop in inputObject) {
              if (hasOwnProp(inputObject, prop)) {
                  normalizedProp = normalizeUnits(prop);
                  if (normalizedProp) {
                      normalizedInput[normalizedProp] = inputObject[prop];
                  }
              }
          }

          return normalizedInput;
      }

      function makeGetSet (unit, keepTime) {
          return function (value) {
              if (value != null) {
                  get_set__set(this, unit, value);
                  utils_hooks__hooks.updateOffset(this, keepTime);
                  return this;
              } else {
                  return get_set__get(this, unit);
              }
          };
      }

      function get_set__get (mom, unit) {
          return mom.isValid() ?
              mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
      }

      function get_set__set (mom, unit, value) {
          if (mom.isValid()) {
              mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
          }
      }

      // MOMENTS

      function getSet (units, value) {
          var unit;
          if (typeof units === 'object') {
              for (unit in units) {
                  this.set(unit, units[unit]);
              }
          } else {
              units = normalizeUnits(units);
              if (isFunction(this[units])) {
                  return this[units](value);
              }
          }
          return this;
      }

      function zeroFill(number, targetLength, forceSign) {
          var absNumber = '' + Math.abs(number),
              zerosToFill = targetLength - absNumber.length,
              sign = number >= 0;
          return (sign ? (forceSign ? '+' : '') : '-') +
              Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
      }

      var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

      var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

      var formatFunctions = {};

      var formatTokenFunctions = {};

      // token:    'M'
      // padded:   ['MM', 2]
      // ordinal:  'Mo'
      // callback: function () { this.month() + 1 }
      function addFormatToken (token, padded, ordinal, callback) {
          var func = callback;
          if (typeof callback === 'string') {
              func = function () {
                  return this[callback]();
              };
          }
          if (token) {
              formatTokenFunctions[token] = func;
          }
          if (padded) {
              formatTokenFunctions[padded[0]] = function () {
                  return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
              };
          }
          if (ordinal) {
              formatTokenFunctions[ordinal] = function () {
                  return this.localeData().ordinal(func.apply(this, arguments), token);
              };
          }
      }

      function removeFormattingTokens(input) {
          if (input.match(/\[[\s\S]/)) {
              return input.replace(/^\[|\]$/g, '');
          }
          return input.replace(/\\/g, '');
      }

      function makeFormatFunction(format) {
          var array = format.match(formattingTokens), i, length;

          for (i = 0, length = array.length; i < length; i++) {
              if (formatTokenFunctions[array[i]]) {
                  array[i] = formatTokenFunctions[array[i]];
              } else {
                  array[i] = removeFormattingTokens(array[i]);
              }
          }

          return function (mom) {
              var output = '', i;
              for (i = 0; i < length; i++) {
                  output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
              }
              return output;
          };
      }

      // format date using native date object
      function formatMoment(m, format) {
          if (!m.isValid()) {
              return m.localeData().invalidDate();
          }

          format = expandFormat(format, m.localeData());
          formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

          return formatFunctions[format](m);
      }

      function expandFormat(format, locale) {
          var i = 5;

          function replaceLongDateFormatTokens(input) {
              return locale.longDateFormat(input) || input;
          }

          localFormattingTokens.lastIndex = 0;
          while (i >= 0 && localFormattingTokens.test(format)) {
              format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
              localFormattingTokens.lastIndex = 0;
              i -= 1;
          }

          return format;
      }

      var match1         = /\d/;            //       0 - 9
      var match2         = /\d\d/;          //      00 - 99
      var match3         = /\d{3}/;         //     000 - 999
      var match4         = /\d{4}/;         //    0000 - 9999
      var match6         = /[+-]?\d{6}/;    // -999999 - 999999
      var match1to2      = /\d\d?/;         //       0 - 99
      var match3to4      = /\d\d\d\d?/;     //     999 - 9999
      var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
      var match1to3      = /\d{1,3}/;       //       0 - 999
      var match1to4      = /\d{1,4}/;       //       0 - 9999
      var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

      var matchUnsigned  = /\d+/;           //       0 - inf
      var matchSigned    = /[+-]?\d+/;      //    -inf - inf

      var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
      var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

      var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

      // any word (or two) characters or numbers including two/three word month in arabic.
      // includes scottish gaelic two word and hyphenated months
      var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


      var regexes = {};

      function addRegexToken (token, regex, strictRegex) {
          regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
              return (isStrict && strictRegex) ? strictRegex : regex;
          };
      }

      function getParseRegexForToken (token, config) {
          if (!hasOwnProp(regexes, token)) {
              return new RegExp(unescapeFormat(token));
          }

          return regexes[token](config._strict, config._locale);
      }

      // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
      function unescapeFormat(s) {
          return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
              return p1 || p2 || p3 || p4;
          }));
      }

      function regexEscape(s) {
          return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
      }

      var tokens = {};

      function addParseToken (token, callback) {
          var i, func = callback;
          if (typeof token === 'string') {
              token = [token];
          }
          if (typeof callback === 'number') {
              func = function (input, array) {
                  array[callback] = toInt(input);
              };
          }
          for (i = 0; i < token.length; i++) {
              tokens[token[i]] = func;
          }
      }

      function addWeekParseToken (token, callback) {
          addParseToken(token, function (input, array, config, token) {
              config._w = config._w || {};
              callback(input, config._w, config, token);
          });
      }

      function addTimeToArrayFromToken(token, input, config) {
          if (input != null && hasOwnProp(tokens, token)) {
              tokens[token](input, config._a, config, token);
          }
      }

      var YEAR = 0;
      var MONTH = 1;
      var DATE = 2;
      var HOUR = 3;
      var MINUTE = 4;
      var SECOND = 5;
      var MILLISECOND = 6;
      var WEEK = 7;
      var WEEKDAY = 8;

      var indexOf;

      if (Array.prototype.indexOf) {
          indexOf = Array.prototype.indexOf;
      } else {
          indexOf = function (o) {
              // I know
              var i;
              for (i = 0; i < this.length; ++i) {
                  if (this[i] === o) {
                      return i;
                  }
              }
              return -1;
          };
      }

      function daysInMonth(year, month) {
          return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
      }

      // FORMATTING

      addFormatToken('M', ['MM', 2], 'Mo', function () {
          return this.month() + 1;
      });

      addFormatToken('MMM', 0, 0, function (format) {
          return this.localeData().monthsShort(this, format);
      });

      addFormatToken('MMMM', 0, 0, function (format) {
          return this.localeData().months(this, format);
      });

      // ALIASES

      addUnitAlias('month', 'M');

      // PARSING

      addRegexToken('M',    match1to2);
      addRegexToken('MM',   match1to2, match2);
      addRegexToken('MMM',  function (isStrict, locale) {
          return locale.monthsShortRegex(isStrict);
      });
      addRegexToken('MMMM', function (isStrict, locale) {
          return locale.monthsRegex(isStrict);
      });

      addParseToken(['M', 'MM'], function (input, array) {
          array[MONTH] = toInt(input) - 1;
      });

      addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
          var month = config._locale.monthsParse(input, token, config._strict);
          // if we didn't find a month name, mark the date as invalid.
          if (month != null) {
              array[MONTH] = month;
          } else {
              getParsingFlags(config).invalidMonth = input;
          }
      });

      // LOCALES

      var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/;
      var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
      function localeMonths (m, format) {
          return isArray(this._months) ? this._months[m.month()] :
              this._months[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
      }

      var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
      function localeMonthsShort (m, format) {
          return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
              this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
      }

      function units_month__handleStrictParse(monthName, format, strict) {
          var i, ii, mom, llc = monthName.toLocaleLowerCase();
          if (!this._monthsParse) {
              // this is not used
              this._monthsParse = [];
              this._longMonthsParse = [];
              this._shortMonthsParse = [];
              for (i = 0; i < 12; ++i) {
                  mom = create_utc__createUTC([2000, i]);
                  this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                  this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
              }
          }

          if (strict) {
              if (format === 'MMM') {
                  ii = indexOf.call(this._shortMonthsParse, llc);
                  return ii !== -1 ? ii : null;
              } else {
                  ii = indexOf.call(this._longMonthsParse, llc);
                  return ii !== -1 ? ii : null;
              }
          } else {
              if (format === 'MMM') {
                  ii = indexOf.call(this._shortMonthsParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._longMonthsParse, llc);
                  return ii !== -1 ? ii : null;
              } else {
                  ii = indexOf.call(this._longMonthsParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._shortMonthsParse, llc);
                  return ii !== -1 ? ii : null;
              }
          }
      }

      function localeMonthsParse (monthName, format, strict) {
          var i, mom, regex;

          if (this._monthsParseExact) {
              return units_month__handleStrictParse.call(this, monthName, format, strict);
          }

          if (!this._monthsParse) {
              this._monthsParse = [];
              this._longMonthsParse = [];
              this._shortMonthsParse = [];
          }

          // TODO: add sorting
          // Sorting makes sure if one month (or abbr) is a prefix of another
          // see sorting in computeMonthsParse
          for (i = 0; i < 12; i++) {
              // make the regex if we don't have it already
              mom = create_utc__createUTC([2000, i]);
              if (strict && !this._longMonthsParse[i]) {
                  this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                  this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
              }
              if (!strict && !this._monthsParse[i]) {
                  regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                  this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
              }
              // test the regex
              if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                  return i;
              } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                  return i;
              } else if (!strict && this._monthsParse[i].test(monthName)) {
                  return i;
              }
          }
      }

      // MOMENTS

      function setMonth (mom, value) {
          var dayOfMonth;

          if (!mom.isValid()) {
              // No op
              return mom;
          }

          if (typeof value === 'string') {
              if (/^\d+$/.test(value)) {
                  value = toInt(value);
              } else {
                  value = mom.localeData().monthsParse(value);
                  // TODO: Another silent failure?
                  if (typeof value !== 'number') {
                      return mom;
                  }
              }
          }

          dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
          mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
          return mom;
      }

      function getSetMonth (value) {
          if (value != null) {
              setMonth(this, value);
              utils_hooks__hooks.updateOffset(this, true);
              return this;
          } else {
              return get_set__get(this, 'Month');
          }
      }

      function getDaysInMonth () {
          return daysInMonth(this.year(), this.month());
      }

      var defaultMonthsShortRegex = matchWord;
      function monthsShortRegex (isStrict) {
          if (this._monthsParseExact) {
              if (!hasOwnProp(this, '_monthsRegex')) {
                  computeMonthsParse.call(this);
              }
              if (isStrict) {
                  return this._monthsShortStrictRegex;
              } else {
                  return this._monthsShortRegex;
              }
          } else {
              return this._monthsShortStrictRegex && isStrict ?
                  this._monthsShortStrictRegex : this._monthsShortRegex;
          }
      }

      var defaultMonthsRegex = matchWord;
      function monthsRegex (isStrict) {
          if (this._monthsParseExact) {
              if (!hasOwnProp(this, '_monthsRegex')) {
                  computeMonthsParse.call(this);
              }
              if (isStrict) {
                  return this._monthsStrictRegex;
              } else {
                  return this._monthsRegex;
              }
          } else {
              return this._monthsStrictRegex && isStrict ?
                  this._monthsStrictRegex : this._monthsRegex;
          }
      }

      function computeMonthsParse () {
          function cmpLenRev(a, b) {
              return b.length - a.length;
          }

          var shortPieces = [], longPieces = [], mixedPieces = [],
              i, mom;
          for (i = 0; i < 12; i++) {
              // make the regex if we don't have it already
              mom = create_utc__createUTC([2000, i]);
              shortPieces.push(this.monthsShort(mom, ''));
              longPieces.push(this.months(mom, ''));
              mixedPieces.push(this.months(mom, ''));
              mixedPieces.push(this.monthsShort(mom, ''));
          }
          // Sorting makes sure if one month (or abbr) is a prefix of another it
          // will match the longer piece.
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          for (i = 0; i < 12; i++) {
              shortPieces[i] = regexEscape(shortPieces[i]);
              longPieces[i] = regexEscape(longPieces[i]);
              mixedPieces[i] = regexEscape(mixedPieces[i]);
          }

          this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
          this._monthsShortRegex = this._monthsRegex;
          this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
          this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
      }

      function checkOverflow (m) {
          var overflow;
          var a = m._a;

          if (a && getParsingFlags(m).overflow === -2) {
              overflow =
                  a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                  a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                  a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                  a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                  a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                  a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                  -1;

              if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                  overflow = DATE;
              }
              if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                  overflow = WEEK;
              }
              if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                  overflow = WEEKDAY;
              }

              getParsingFlags(m).overflow = overflow;
          }

          return m;
      }

      // iso 8601 regex
      // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
      var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
      var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;

      var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

      var isoDates = [
          ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
          ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
          ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
          ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
          ['YYYY-DDD', /\d{4}-\d{3}/],
          ['YYYY-MM', /\d{4}-\d\d/, false],
          ['YYYYYYMMDD', /[+-]\d{10}/],
          ['YYYYMMDD', /\d{8}/],
          // YYYYMM is NOT allowed by the standard
          ['GGGG[W]WWE', /\d{4}W\d{3}/],
          ['GGGG[W]WW', /\d{4}W\d{2}/, false],
          ['YYYYDDD', /\d{7}/]
      ];

      // iso time formats and regexes
      var isoTimes = [
          ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
          ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
          ['HH:mm:ss', /\d\d:\d\d:\d\d/],
          ['HH:mm', /\d\d:\d\d/],
          ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
          ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
          ['HHmmss', /\d\d\d\d\d\d/],
          ['HHmm', /\d\d\d\d/],
          ['HH', /\d\d/]
      ];

      var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

      // date from iso format
      function configFromISO(config) {
          var i, l,
              string = config._i,
              match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
              allowTime, dateFormat, timeFormat, tzFormat;

          if (match) {
              getParsingFlags(config).iso = true;

              for (i = 0, l = isoDates.length; i < l; i++) {
                  if (isoDates[i][1].exec(match[1])) {
                      dateFormat = isoDates[i][0];
                      allowTime = isoDates[i][2] !== false;
                      break;
                  }
              }
              if (dateFormat == null) {
                  config._isValid = false;
                  return;
              }
              if (match[3]) {
                  for (i = 0, l = isoTimes.length; i < l; i++) {
                      if (isoTimes[i][1].exec(match[3])) {
                          // match[2] should be 'T' or space
                          timeFormat = (match[2] || ' ') + isoTimes[i][0];
                          break;
                      }
                  }
                  if (timeFormat == null) {
                      config._isValid = false;
                      return;
                  }
              }
              if (!allowTime && timeFormat != null) {
                  config._isValid = false;
                  return;
              }
              if (match[4]) {
                  if (tzRegex.exec(match[4])) {
                      tzFormat = 'Z';
                  } else {
                      config._isValid = false;
                      return;
                  }
              }
              config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
              configFromStringAndFormat(config);
          } else {
              config._isValid = false;
          }
      }

      // date from iso format or fallback
      function configFromString(config) {
          var matched = aspNetJsonRegex.exec(config._i);

          if (matched !== null) {
              config._d = new Date(+matched[1]);
              return;
          }

          configFromISO(config);
          if (config._isValid === false) {
              delete config._isValid;
              utils_hooks__hooks.createFromInputFallback(config);
          }
      }

      utils_hooks__hooks.createFromInputFallback = deprecate(
          'moment construction falls back to js Date. This is ' +
          'discouraged and will be removed in upcoming major ' +
          'release. Please refer to ' +
          'https://github.com/moment/moment/issues/1407 for more info.',
          function (config) {
              config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
          }
      );

      function createDate (y, m, d, h, M, s, ms) {
          //can't just apply() to create a date:
          //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
          var date = new Date(y, m, d, h, M, s, ms);

          //the date constructor remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
              date.setFullYear(y);
          }
          return date;
      }

      function createUTCDate (y) {
          var date = new Date(Date.UTC.apply(null, arguments));

          //the Date.UTC function remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
              date.setUTCFullYear(y);
          }
          return date;
      }

      // FORMATTING

      addFormatToken('Y', 0, 0, function () {
          var y = this.year();
          return y <= 9999 ? '' + y : '+' + y;
      });

      addFormatToken(0, ['YY', 2], 0, function () {
          return this.year() % 100;
      });

      addFormatToken(0, ['YYYY',   4],       0, 'year');
      addFormatToken(0, ['YYYYY',  5],       0, 'year');
      addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

      // ALIASES

      addUnitAlias('year', 'y');

      // PARSING

      addRegexToken('Y',      matchSigned);
      addRegexToken('YY',     match1to2, match2);
      addRegexToken('YYYY',   match1to4, match4);
      addRegexToken('YYYYY',  match1to6, match6);
      addRegexToken('YYYYYY', match1to6, match6);

      addParseToken(['YYYYY', 'YYYYYY'], YEAR);
      addParseToken('YYYY', function (input, array) {
          array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
      });
      addParseToken('YY', function (input, array) {
          array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
      });
      addParseToken('Y', function (input, array) {
          array[YEAR] = parseInt(input, 10);
      });

      // HELPERS

      function daysInYear(year) {
          return isLeapYear(year) ? 366 : 365;
      }

      function isLeapYear(year) {
          return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
      }

      // HOOKS

      utils_hooks__hooks.parseTwoDigitYear = function (input) {
          return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
      };

      // MOMENTS

      var getSetYear = makeGetSet('FullYear', true);

      function getIsLeapYear () {
          return isLeapYear(this.year());
      }

      // start-of-first-week - start-of-year
      function firstWeekOffset(year, dow, doy) {
          var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
              fwd = 7 + dow - doy,
              // first-week day local weekday -- which local weekday is fwd
              fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

          return -fwdlw + fwd - 1;
      }

      //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
      function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
          var localWeekday = (7 + weekday - dow) % 7,
              weekOffset = firstWeekOffset(year, dow, doy),
              dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
              resYear, resDayOfYear;

          if (dayOfYear <= 0) {
              resYear = year - 1;
              resDayOfYear = daysInYear(resYear) + dayOfYear;
          } else if (dayOfYear > daysInYear(year)) {
              resYear = year + 1;
              resDayOfYear = dayOfYear - daysInYear(year);
          } else {
              resYear = year;
              resDayOfYear = dayOfYear;
          }

          return {
              year: resYear,
              dayOfYear: resDayOfYear
          };
      }

      function weekOfYear(mom, dow, doy) {
          var weekOffset = firstWeekOffset(mom.year(), dow, doy),
              week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
              resWeek, resYear;

          if (week < 1) {
              resYear = mom.year() - 1;
              resWeek = week + weeksInYear(resYear, dow, doy);
          } else if (week > weeksInYear(mom.year(), dow, doy)) {
              resWeek = week - weeksInYear(mom.year(), dow, doy);
              resYear = mom.year() + 1;
          } else {
              resYear = mom.year();
              resWeek = week;
          }

          return {
              week: resWeek,
              year: resYear
          };
      }

      function weeksInYear(year, dow, doy) {
          var weekOffset = firstWeekOffset(year, dow, doy),
              weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
          return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
      }

      // Pick the first defined of two or three arguments.
      function defaults(a, b, c) {
          if (a != null) {
              return a;
          }
          if (b != null) {
              return b;
          }
          return c;
      }

      function currentDateArray(config) {
          // hooks is actually the exported moment object
          var nowValue = new Date(utils_hooks__hooks.now());
          if (config._useUTC) {
              return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
          }
          return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
      }

      // convert an array to a date.
      // the array should mirror the parameters below
      // note: all values past the year are optional and will default to the lowest possible value.
      // [year, month, day , hour, minute, second, millisecond]
      function configFromArray (config) {
          var i, date, input = [], currentDate, yearToUse;

          if (config._d) {
              return;
          }

          currentDate = currentDateArray(config);

          //compute day of the year from weeks and weekdays
          if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
              dayOfYearFromWeekInfo(config);
          }

          //if the day of the year is set, figure out what it is
          if (config._dayOfYear) {
              yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

              if (config._dayOfYear > daysInYear(yearToUse)) {
                  getParsingFlags(config)._overflowDayOfYear = true;
              }

              date = createUTCDate(yearToUse, 0, config._dayOfYear);
              config._a[MONTH] = date.getUTCMonth();
              config._a[DATE] = date.getUTCDate();
          }

          // Default to current date.
          // * if no year, month, day of month are given, default to today
          // * if day of month is given, default month and year
          // * if month is given, default only year
          // * if year is given, don't default anything
          for (i = 0; i < 3 && config._a[i] == null; ++i) {
              config._a[i] = input[i] = currentDate[i];
          }

          // Zero out whatever was not defaulted, including time
          for (; i < 7; i++) {
              config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
          }

          // Check for 24:00:00.000
          if (config._a[HOUR] === 24 &&
                  config._a[MINUTE] === 0 &&
                  config._a[SECOND] === 0 &&
                  config._a[MILLISECOND] === 0) {
              config._nextDay = true;
              config._a[HOUR] = 0;
          }

          config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
          // Apply timezone offset from input. The actual utcOffset can be changed
          // with parseZone.
          if (config._tzm != null) {
              config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          }

          if (config._nextDay) {
              config._a[HOUR] = 24;
          }
      }

      function dayOfYearFromWeekInfo(config) {
          var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

          w = config._w;
          if (w.GG != null || w.W != null || w.E != null) {
              dow = 1;
              doy = 4;

              // TODO: We need to take the current isoWeekYear, but that depends on
              // how we interpret now (local, utc, fixed offset). So create
              // a now version of current config (take local/utc/offset flags, and
              // create now).
              weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
              week = defaults(w.W, 1);
              weekday = defaults(w.E, 1);
              if (weekday < 1 || weekday > 7) {
                  weekdayOverflow = true;
              }
          } else {
              dow = config._locale._week.dow;
              doy = config._locale._week.doy;

              weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
              week = defaults(w.w, 1);

              if (w.d != null) {
                  // weekday -- low day numbers are considered next week
                  weekday = w.d;
                  if (weekday < 0 || weekday > 6) {
                      weekdayOverflow = true;
                  }
              } else if (w.e != null) {
                  // local weekday -- counting starts from begining of week
                  weekday = w.e + dow;
                  if (w.e < 0 || w.e > 6) {
                      weekdayOverflow = true;
                  }
              } else {
                  // default to begining of week
                  weekday = dow;
              }
          }
          if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
              getParsingFlags(config)._overflowWeeks = true;
          } else if (weekdayOverflow != null) {
              getParsingFlags(config)._overflowWeekday = true;
          } else {
              temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
              config._a[YEAR] = temp.year;
              config._dayOfYear = temp.dayOfYear;
          }
      }

      // constant that refers to the ISO standard
      utils_hooks__hooks.ISO_8601 = function () {};

      // date from string and format string
      function configFromStringAndFormat(config) {
          // TODO: Move this to another part of the creation flow to prevent circular deps
          if (config._f === utils_hooks__hooks.ISO_8601) {
              configFromISO(config);
              return;
          }

          config._a = [];
          getParsingFlags(config).empty = true;

          // This array is used to make a Date, either with `new Date` or `Date.UTC`
          var string = '' + config._i,
              i, parsedInput, tokens, token, skipped,
              stringLength = string.length,
              totalParsedInputLength = 0;

          tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

          for (i = 0; i < tokens.length; i++) {
              token = tokens[i];
              parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
              // console.log('token', token, 'parsedInput', parsedInput,
              //         'regex', getParseRegexForToken(token, config));
              if (parsedInput) {
                  skipped = string.substr(0, string.indexOf(parsedInput));
                  if (skipped.length > 0) {
                      getParsingFlags(config).unusedInput.push(skipped);
                  }
                  string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                  totalParsedInputLength += parsedInput.length;
              }
              // don't parse if it's not a known token
              if (formatTokenFunctions[token]) {
                  if (parsedInput) {
                      getParsingFlags(config).empty = false;
                  }
                  else {
                      getParsingFlags(config).unusedTokens.push(token);
                  }
                  addTimeToArrayFromToken(token, parsedInput, config);
              }
              else if (config._strict && !parsedInput) {
                  getParsingFlags(config).unusedTokens.push(token);
              }
          }

          // add remaining unparsed input length to the string
          getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
          if (string.length > 0) {
              getParsingFlags(config).unusedInput.push(string);
          }

          // clear _12h flag if hour is <= 12
          if (getParsingFlags(config).bigHour === true &&
                  config._a[HOUR] <= 12 &&
                  config._a[HOUR] > 0) {
              getParsingFlags(config).bigHour = undefined;
          }

          getParsingFlags(config).parsedDateParts = config._a.slice(0);
          getParsingFlags(config).meridiem = config._meridiem;
          // handle meridiem
          config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

          configFromArray(config);
          checkOverflow(config);
      }


      function meridiemFixWrap (locale, hour, meridiem) {
          var isPm;

          if (meridiem == null) {
              // nothing to do
              return hour;
          }
          if (locale.meridiemHour != null) {
              return locale.meridiemHour(hour, meridiem);
          } else if (locale.isPM != null) {
              // Fallback
              isPm = locale.isPM(meridiem);
              if (isPm && hour < 12) {
                  hour += 12;
              }
              if (!isPm && hour === 12) {
                  hour = 0;
              }
              return hour;
          } else {
              // this is not supposed to happen
              return hour;
          }
      }

      // date from string and array of format strings
      function configFromStringAndArray(config) {
          var tempConfig,
              bestMoment,

              scoreToBeat,
              i,
              currentScore;

          if (config._f.length === 0) {
              getParsingFlags(config).invalidFormat = true;
              config._d = new Date(NaN);
              return;
          }

          for (i = 0; i < config._f.length; i++) {
              currentScore = 0;
              tempConfig = copyConfig({}, config);
              if (config._useUTC != null) {
                  tempConfig._useUTC = config._useUTC;
              }
              tempConfig._f = config._f[i];
              configFromStringAndFormat(tempConfig);

              if (!valid__isValid(tempConfig)) {
                  continue;
              }

              // if there is any input that was not parsed add a penalty for that format
              currentScore += getParsingFlags(tempConfig).charsLeftOver;

              //or tokens
              currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

              getParsingFlags(tempConfig).score = currentScore;

              if (scoreToBeat == null || currentScore < scoreToBeat) {
                  scoreToBeat = currentScore;
                  bestMoment = tempConfig;
              }
          }

          extend(config, bestMoment || tempConfig);
      }

      function configFromObject(config) {
          if (config._d) {
              return;
          }

          var i = normalizeObjectUnits(config._i);
          config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
              return obj && parseInt(obj, 10);
          });

          configFromArray(config);
      }

      function createFromConfig (config) {
          var res = new Moment(checkOverflow(prepareConfig(config)));
          if (res._nextDay) {
              // Adding is smart enough around DST
              res.add(1, 'd');
              res._nextDay = undefined;
          }

          return res;
      }

      function prepareConfig (config) {
          var input = config._i,
              format = config._f;

          config._locale = config._locale || locale_locales__getLocale(config._l);

          if (input === null || (format === undefined && input === '')) {
              return valid__createInvalid({nullInput: true});
          }

          if (typeof input === 'string') {
              config._i = input = config._locale.preparse(input);
          }

          if (isMoment(input)) {
              return new Moment(checkOverflow(input));
          } else if (isArray(format)) {
              configFromStringAndArray(config);
          } else if (format) {
              configFromStringAndFormat(config);
          } else if (isDate(input)) {
              config._d = input;
          } else {
              configFromInput(config);
          }

          if (!valid__isValid(config)) {
              config._d = null;
          }

          return config;
      }

      function configFromInput(config) {
          var input = config._i;
          if (input === undefined) {
              config._d = new Date(utils_hooks__hooks.now());
          } else if (isDate(input)) {
              config._d = new Date(input.valueOf());
          } else if (typeof input === 'string') {
              configFromString(config);
          } else if (isArray(input)) {
              config._a = map(input.slice(0), function (obj) {
                  return parseInt(obj, 10);
              });
              configFromArray(config);
          } else if (typeof(input) === 'object') {
              configFromObject(config);
          } else if (typeof(input) === 'number') {
              // from milliseconds
              config._d = new Date(input);
          } else {
              utils_hooks__hooks.createFromInputFallback(config);
          }
      }

      function createLocalOrUTC (input, format, locale, strict, isUTC) {
          var c = {};

          if (typeof(locale) === 'boolean') {
              strict = locale;
              locale = undefined;
          }
          // object construction must be done this way.
          // https://github.com/moment/moment/issues/1423
          c._isAMomentObject = true;
          c._useUTC = c._isUTC = isUTC;
          c._l = locale;
          c._i = input;
          c._f = format;
          c._strict = strict;

          return createFromConfig(c);
      }

      function local__createLocal (input, format, locale, strict) {
          return createLocalOrUTC(input, format, locale, strict, false);
      }

      var prototypeMin = deprecate(
           'moment().min is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
           function () {
               var other = local__createLocal.apply(null, arguments);
               if (this.isValid() && other.isValid()) {
                   return other < this ? this : other;
               } else {
                   return valid__createInvalid();
               }
           }
       );

      var prototypeMax = deprecate(
          'moment().max is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
          function () {
              var other = local__createLocal.apply(null, arguments);
              if (this.isValid() && other.isValid()) {
                  return other > this ? this : other;
              } else {
                  return valid__createInvalid();
              }
          }
      );

      // Pick a moment m from moments so that m[fn](other) is true for all
      // other. This relies on the function fn to be transitive.
      //
      // moments should either be an array of moment objects or an array, whose
      // first element is an array of moment objects.
      function pickBy(fn, moments) {
          var res, i;
          if (moments.length === 1 && isArray(moments[0])) {
              moments = moments[0];
          }
          if (!moments.length) {
              return local__createLocal();
          }
          res = moments[0];
          for (i = 1; i < moments.length; ++i) {
              if (!moments[i].isValid() || moments[i][fn](res)) {
                  res = moments[i];
              }
          }
          return res;
      }

      // TODO: Use [].sort instead?
      function min () {
          var args = [].slice.call(arguments, 0);

          return pickBy('isBefore', args);
      }

      function max () {
          var args = [].slice.call(arguments, 0);

          return pickBy('isAfter', args);
      }

      var now = function () {
          return Date.now ? Date.now() : +(new Date());
      };

      function Duration (duration) {
          var normalizedInput = normalizeObjectUnits(duration),
              years = normalizedInput.year || 0,
              quarters = normalizedInput.quarter || 0,
              months = normalizedInput.month || 0,
              weeks = normalizedInput.week || 0,
              days = normalizedInput.day || 0,
              hours = normalizedInput.hour || 0,
              minutes = normalizedInput.minute || 0,
              seconds = normalizedInput.second || 0,
              milliseconds = normalizedInput.millisecond || 0;

          // representation for dateAddRemove
          this._milliseconds = +milliseconds +
              seconds * 1e3 + // 1000
              minutes * 6e4 + // 1000 * 60
              hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
          // Because of dateAddRemove treats 24 hours as different from a
          // day when working around DST, we need to store them separately
          this._days = +days +
              weeks * 7;
          // It is impossible translate months into days without knowing
          // which months you are are talking about, so we have to store
          // it separately.
          this._months = +months +
              quarters * 3 +
              years * 12;

          this._data = {};

          this._locale = locale_locales__getLocale();

          this._bubble();
      }

      function isDuration (obj) {
          return obj instanceof Duration;
      }

      // FORMATTING

      function offset (token, separator) {
          addFormatToken(token, 0, 0, function () {
              var offset = this.utcOffset();
              var sign = '+';
              if (offset < 0) {
                  offset = -offset;
                  sign = '-';
              }
              return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
          });
      }

      offset('Z', ':');
      offset('ZZ', '');

      // PARSING

      addRegexToken('Z',  matchShortOffset);
      addRegexToken('ZZ', matchShortOffset);
      addParseToken(['Z', 'ZZ'], function (input, array, config) {
          config._useUTC = true;
          config._tzm = offsetFromString(matchShortOffset, input);
      });

      // HELPERS

      // timezone chunker
      // '+10:00' > ['10',  '00']
      // '-1530'  > ['-15', '30']
      var chunkOffset = /([\+\-]|\d\d)/gi;

      function offsetFromString(matcher, string) {
          var matches = ((string || '').match(matcher) || []);
          var chunk   = matches[matches.length - 1] || [];
          var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
          var minutes = +(parts[1] * 60) + toInt(parts[2]);

          return parts[0] === '+' ? minutes : -minutes;
      }

      // Return a moment from input, that is local/utc/zone equivalent to model.
      function cloneWithOffset(input, model) {
          var res, diff;
          if (model._isUTC) {
              res = model.clone();
              diff = (isMoment(input) || isDate(input) ? input.valueOf() : local__createLocal(input).valueOf()) - res.valueOf();
              // Use low-level api, because this fn is low-level api.
              res._d.setTime(res._d.valueOf() + diff);
              utils_hooks__hooks.updateOffset(res, false);
              return res;
          } else {
              return local__createLocal(input).local();
          }
      }

      function getDateOffset (m) {
          // On Firefox.24 Date#getTimezoneOffset returns a floating point.
          // https://github.com/moment/moment/pull/1871
          return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
      }

      // HOOKS

      // This function will be called whenever a moment is mutated.
      // It is intended to keep the offset in sync with the timezone.
      utils_hooks__hooks.updateOffset = function () {};

      // MOMENTS

      // keepLocalTime = true means only change the timezone, without
      // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
      // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
      // +0200, so we adjust the time as needed, to be valid.
      //
      // Keeping the time actually adds/subtracts (one hour)
      // from the actual represented time. That is why we call updateOffset
      // a second time. In case it wants us to change the offset again
      // _changeInProgress == true case, then we have to adjust, because
      // there is no such time in the given timezone.
      function getSetOffset (input, keepLocalTime) {
          var offset = this._offset || 0,
              localAdjust;
          if (!this.isValid()) {
              return input != null ? this : NaN;
          }
          if (input != null) {
              if (typeof input === 'string') {
                  input = offsetFromString(matchShortOffset, input);
              } else if (Math.abs(input) < 16) {
                  input = input * 60;
              }
              if (!this._isUTC && keepLocalTime) {
                  localAdjust = getDateOffset(this);
              }
              this._offset = input;
              this._isUTC = true;
              if (localAdjust != null) {
                  this.add(localAdjust, 'm');
              }
              if (offset !== input) {
                  if (!keepLocalTime || this._changeInProgress) {
                      add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
                  } else if (!this._changeInProgress) {
                      this._changeInProgress = true;
                      utils_hooks__hooks.updateOffset(this, true);
                      this._changeInProgress = null;
                  }
              }
              return this;
          } else {
              return this._isUTC ? offset : getDateOffset(this);
          }
      }

      function getSetZone (input, keepLocalTime) {
          if (input != null) {
              if (typeof input !== 'string') {
                  input = -input;
              }

              this.utcOffset(input, keepLocalTime);

              return this;
          } else {
              return -this.utcOffset();
          }
      }

      function setOffsetToUTC (keepLocalTime) {
          return this.utcOffset(0, keepLocalTime);
      }

      function setOffsetToLocal (keepLocalTime) {
          if (this._isUTC) {
              this.utcOffset(0, keepLocalTime);
              this._isUTC = false;

              if (keepLocalTime) {
                  this.subtract(getDateOffset(this), 'm');
              }
          }
          return this;
      }

      function setOffsetToParsedOffset () {
          if (this._tzm) {
              this.utcOffset(this._tzm);
          } else if (typeof this._i === 'string') {
              this.utcOffset(offsetFromString(matchOffset, this._i));
          }
          return this;
      }

      function hasAlignedHourOffset (input) {
          if (!this.isValid()) {
              return false;
          }
          input = input ? local__createLocal(input).utcOffset() : 0;

          return (this.utcOffset() - input) % 60 === 0;
      }

      function isDaylightSavingTime () {
          return (
              this.utcOffset() > this.clone().month(0).utcOffset() ||
              this.utcOffset() > this.clone().month(5).utcOffset()
          );
      }

      function isDaylightSavingTimeShifted () {
          if (!isUndefined(this._isDSTShifted)) {
              return this._isDSTShifted;
          }

          var c = {};

          copyConfig(c, this);
          c = prepareConfig(c);

          if (c._a) {
              var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
              this._isDSTShifted = this.isValid() &&
                  compareArrays(c._a, other.toArray()) > 0;
          } else {
              this._isDSTShifted = false;
          }

          return this._isDSTShifted;
      }

      function isLocal () {
          return this.isValid() ? !this._isUTC : false;
      }

      function isUtcOffset () {
          return this.isValid() ? this._isUTC : false;
      }

      function isUtc () {
          return this.isValid() ? this._isUTC && this._offset === 0 : false;
      }

      // ASP.NET json date format regex
      var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?\d*)?$/;

      // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
      // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
      // and further modified to allow for strings containing both week and day
      var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;

      function create__createDuration (input, key) {
          var duration = input,
              // matching against regexp is expensive, do it on demand
              match = null,
              sign,
              ret,
              diffRes;

          if (isDuration(input)) {
              duration = {
                  ms : input._milliseconds,
                  d  : input._days,
                  M  : input._months
              };
          } else if (typeof input === 'number') {
              duration = {};
              if (key) {
                  duration[key] = input;
              } else {
                  duration.milliseconds = input;
              }
          } else if (!!(match = aspNetRegex.exec(input))) {
              sign = (match[1] === '-') ? -1 : 1;
              duration = {
                  y  : 0,
                  d  : toInt(match[DATE])        * sign,
                  h  : toInt(match[HOUR])        * sign,
                  m  : toInt(match[MINUTE])      * sign,
                  s  : toInt(match[SECOND])      * sign,
                  ms : toInt(match[MILLISECOND]) * sign
              };
          } else if (!!(match = isoRegex.exec(input))) {
              sign = (match[1] === '-') ? -1 : 1;
              duration = {
                  y : parseIso(match[2], sign),
                  M : parseIso(match[3], sign),
                  w : parseIso(match[4], sign),
                  d : parseIso(match[5], sign),
                  h : parseIso(match[6], sign),
                  m : parseIso(match[7], sign),
                  s : parseIso(match[8], sign)
              };
          } else if (duration == null) {// checks for null or undefined
              duration = {};
          } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
              diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));

              duration = {};
              duration.ms = diffRes.milliseconds;
              duration.M = diffRes.months;
          }

          ret = new Duration(duration);

          if (isDuration(input) && hasOwnProp(input, '_locale')) {
              ret._locale = input._locale;
          }

          return ret;
      }

      create__createDuration.fn = Duration.prototype;

      function parseIso (inp, sign) {
          // We'd normally use ~~inp for this, but unfortunately it also
          // converts floats to ints.
          // inp may be undefined, so careful calling replace on it.
          var res = inp && parseFloat(inp.replace(',', '.'));
          // apply sign while we're at it
          return (isNaN(res) ? 0 : res) * sign;
      }

      function positiveMomentsDifference(base, other) {
          var res = {milliseconds: 0, months: 0};

          res.months = other.month() - base.month() +
              (other.year() - base.year()) * 12;
          if (base.clone().add(res.months, 'M').isAfter(other)) {
              --res.months;
          }

          res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

          return res;
      }

      function momentsDifference(base, other) {
          var res;
          if (!(base.isValid() && other.isValid())) {
              return {milliseconds: 0, months: 0};
          }

          other = cloneWithOffset(other, base);
          if (base.isBefore(other)) {
              res = positiveMomentsDifference(base, other);
          } else {
              res = positiveMomentsDifference(other, base);
              res.milliseconds = -res.milliseconds;
              res.months = -res.months;
          }

          return res;
      }

      function absRound (number) {
          if (number < 0) {
              return Math.round(-1 * number) * -1;
          } else {
              return Math.round(number);
          }
      }

      // TODO: remove 'name' arg after deprecation is removed
      function createAdder(direction, name) {
          return function (val, period) {
              var dur, tmp;
              //invert the arguments, but complain about it
              if (period !== null && !isNaN(+period)) {
                  deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
                  tmp = val; val = period; period = tmp;
              }

              val = typeof val === 'string' ? +val : val;
              dur = create__createDuration(val, period);
              add_subtract__addSubtract(this, dur, direction);
              return this;
          };
      }

      function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {
          var milliseconds = duration._milliseconds,
              days = absRound(duration._days),
              months = absRound(duration._months);

          if (!mom.isValid()) {
              // No op
              return;
          }

          updateOffset = updateOffset == null ? true : updateOffset;

          if (milliseconds) {
              mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
          }
          if (days) {
              get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
          }
          if (months) {
              setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
          }
          if (updateOffset) {
              utils_hooks__hooks.updateOffset(mom, days || months);
          }
      }

      var add_subtract__add      = createAdder(1, 'add');
      var add_subtract__subtract = createAdder(-1, 'subtract');

      function moment_calendar__calendar (time, formats) {
          // We want to compare the start of today, vs this.
          // Getting start-of-today depends on whether we're local/utc/offset or not.
          var now = time || local__createLocal(),
              sod = cloneWithOffset(now, this).startOf('day'),
              diff = this.diff(sod, 'days', true),
              format = diff < -6 ? 'sameElse' :
                  diff < -1 ? 'lastWeek' :
                  diff < 0 ? 'lastDay' :
                  diff < 1 ? 'sameDay' :
                  diff < 2 ? 'nextDay' :
                  diff < 7 ? 'nextWeek' : 'sameElse';

          var output = formats && (isFunction(formats[format]) ? formats[format]() : formats[format]);

          return this.format(output || this.localeData().calendar(format, this, local__createLocal(now)));
      }

      function clone () {
          return new Moment(this);
      }

      function isAfter (input, units) {
          var localInput = isMoment(input) ? input : local__createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
              return false;
          }
          units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
          if (units === 'millisecond') {
              return this.valueOf() > localInput.valueOf();
          } else {
              return localInput.valueOf() < this.clone().startOf(units).valueOf();
          }
      }

      function isBefore (input, units) {
          var localInput = isMoment(input) ? input : local__createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
              return false;
          }
          units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
          if (units === 'millisecond') {
              return this.valueOf() < localInput.valueOf();
          } else {
              return this.clone().endOf(units).valueOf() < localInput.valueOf();
          }
      }

      function isBetween (from, to, units, inclusivity) {
          inclusivity = inclusivity || '()';
          return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
              (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
      }

      function isSame (input, units) {
          var localInput = isMoment(input) ? input : local__createLocal(input),
              inputMs;
          if (!(this.isValid() && localInput.isValid())) {
              return false;
          }
          units = normalizeUnits(units || 'millisecond');
          if (units === 'millisecond') {
              return this.valueOf() === localInput.valueOf();
          } else {
              inputMs = localInput.valueOf();
              return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
          }
      }

      function isSameOrAfter (input, units) {
          return this.isSame(input, units) || this.isAfter(input,units);
      }

      function isSameOrBefore (input, units) {
          return this.isSame(input, units) || this.isBefore(input,units);
      }

      function diff (input, units, asFloat) {
          var that,
              zoneDelta,
              delta, output;

          if (!this.isValid()) {
              return NaN;
          }

          that = cloneWithOffset(input, this);

          if (!that.isValid()) {
              return NaN;
          }

          zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

          units = normalizeUnits(units);

          if (units === 'year' || units === 'month' || units === 'quarter') {
              output = monthDiff(this, that);
              if (units === 'quarter') {
                  output = output / 3;
              } else if (units === 'year') {
                  output = output / 12;
              }
          } else {
              delta = this - that;
              output = units === 'second' ? delta / 1e3 : // 1000
                  units === 'minute' ? delta / 6e4 : // 1000 * 60
                  units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
                  units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                  units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                  delta;
          }
          return asFloat ? output : absFloor(output);
      }

      function monthDiff (a, b) {
          // difference in months
          var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
              // b is in (anchor - 1 month, anchor + 1 month)
              anchor = a.clone().add(wholeMonthDiff, 'months'),
              anchor2, adjust;

          if (b - anchor < 0) {
              anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
              // linear across the month
              adjust = (b - anchor) / (anchor - anchor2);
          } else {
              anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
              // linear across the month
              adjust = (b - anchor) / (anchor2 - anchor);
          }

          //check for negative zero, return zero if negative zero
          return -(wholeMonthDiff + adjust) || 0;
      }

      utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
      utils_hooks__hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

      function toString () {
          return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
      }

      function moment_format__toISOString () {
          var m = this.clone().utc();
          if (0 < m.year() && m.year() <= 9999) {
              if (isFunction(Date.prototype.toISOString)) {
                  // native implementation is ~50x faster, use it when we can
                  return this.toDate().toISOString();
              } else {
                  return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
              }
          } else {
              return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
          }
      }

      function format (inputString) {
          if (!inputString) {
              inputString = this.isUtc() ? utils_hooks__hooks.defaultFormatUtc : utils_hooks__hooks.defaultFormat;
          }
          var output = formatMoment(this, inputString);
          return this.localeData().postformat(output);
      }

      function from (time, withoutSuffix) {
          if (this.isValid() &&
                  ((isMoment(time) && time.isValid()) ||
                   local__createLocal(time).isValid())) {
              return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
          } else {
              return this.localeData().invalidDate();
          }
      }

      function fromNow (withoutSuffix) {
          return this.from(local__createLocal(), withoutSuffix);
      }

      function to (time, withoutSuffix) {
          if (this.isValid() &&
                  ((isMoment(time) && time.isValid()) ||
                   local__createLocal(time).isValid())) {
              return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
          } else {
              return this.localeData().invalidDate();
          }
      }

      function toNow (withoutSuffix) {
          return this.to(local__createLocal(), withoutSuffix);
      }

      // If passed a locale key, it will set the locale for this
      // instance.  Otherwise, it will return the locale configuration
      // variables for this instance.
      function locale (key) {
          var newLocaleData;

          if (key === undefined) {
              return this._locale._abbr;
          } else {
              newLocaleData = locale_locales__getLocale(key);
              if (newLocaleData != null) {
                  this._locale = newLocaleData;
              }
              return this;
          }
      }

      var lang = deprecate(
          'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
          function (key) {
              if (key === undefined) {
                  return this.localeData();
              } else {
                  return this.locale(key);
              }
          }
      );

      function localeData () {
          return this._locale;
      }

      function startOf (units) {
          units = normalizeUnits(units);
          // the following switch intentionally omits break keywords
          // to utilize falling through the cases.
          switch (units) {
          case 'year':
              this.month(0);
              /* falls through */
          case 'quarter':
          case 'month':
              this.date(1);
              /* falls through */
          case 'week':
          case 'isoWeek':
          case 'day':
          case 'date':
              this.hours(0);
              /* falls through */
          case 'hour':
              this.minutes(0);
              /* falls through */
          case 'minute':
              this.seconds(0);
              /* falls through */
          case 'second':
              this.milliseconds(0);
          }

          // weeks are a special case
          if (units === 'week') {
              this.weekday(0);
          }
          if (units === 'isoWeek') {
              this.isoWeekday(1);
          }

          // quarters are also special
          if (units === 'quarter') {
              this.month(Math.floor(this.month() / 3) * 3);
          }

          return this;
      }

      function endOf (units) {
          units = normalizeUnits(units);
          if (units === undefined || units === 'millisecond') {
              return this;
          }

          // 'date' is an alias for 'day', so it should be considered as such.
          if (units === 'date') {
              units = 'day';
          }

          return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
      }

      function to_type__valueOf () {
          return this._d.valueOf() - ((this._offset || 0) * 60000);
      }

      function unix () {
          return Math.floor(this.valueOf() / 1000);
      }

      function toDate () {
          return this._offset ? new Date(this.valueOf()) : this._d;
      }

      function toArray () {
          var m = this;
          return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
      }

      function toObject () {
          var m = this;
          return {
              years: m.year(),
              months: m.month(),
              date: m.date(),
              hours: m.hours(),
              minutes: m.minutes(),
              seconds: m.seconds(),
              milliseconds: m.milliseconds()
          };
      }

      function toJSON () {
          // new Date(NaN).toJSON() === null
          return this.isValid() ? this.toISOString() : null;
      }

      function moment_valid__isValid () {
          return valid__isValid(this);
      }

      function parsingFlags () {
          return extend({}, getParsingFlags(this));
      }

      function invalidAt () {
          return getParsingFlags(this).overflow;
      }

      function creationData() {
          return {
              input: this._i,
              format: this._f,
              locale: this._locale,
              isUTC: this._isUTC,
              strict: this._strict
          };
      }

      // FORMATTING

      addFormatToken(0, ['gg', 2], 0, function () {
          return this.weekYear() % 100;
      });

      addFormatToken(0, ['GG', 2], 0, function () {
          return this.isoWeekYear() % 100;
      });

      function addWeekYearFormatToken (token, getter) {
          addFormatToken(0, [token, token.length], 0, getter);
      }

      addWeekYearFormatToken('gggg',     'weekYear');
      addWeekYearFormatToken('ggggg',    'weekYear');
      addWeekYearFormatToken('GGGG',  'isoWeekYear');
      addWeekYearFormatToken('GGGGG', 'isoWeekYear');

      // ALIASES

      addUnitAlias('weekYear', 'gg');
      addUnitAlias('isoWeekYear', 'GG');

      // PARSING

      addRegexToken('G',      matchSigned);
      addRegexToken('g',      matchSigned);
      addRegexToken('GG',     match1to2, match2);
      addRegexToken('gg',     match1to2, match2);
      addRegexToken('GGGG',   match1to4, match4);
      addRegexToken('gggg',   match1to4, match4);
      addRegexToken('GGGGG',  match1to6, match6);
      addRegexToken('ggggg',  match1to6, match6);

      addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
          week[token.substr(0, 2)] = toInt(input);
      });

      addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
          week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
      });

      // MOMENTS

      function getSetWeekYear (input) {
          return getSetWeekYearHelper.call(this,
                  input,
                  this.week(),
                  this.weekday(),
                  this.localeData()._week.dow,
                  this.localeData()._week.doy);
      }

      function getSetISOWeekYear (input) {
          return getSetWeekYearHelper.call(this,
                  input, this.isoWeek(), this.isoWeekday(), 1, 4);
      }

      function getISOWeeksInYear () {
          return weeksInYear(this.year(), 1, 4);
      }

      function getWeeksInYear () {
          var weekInfo = this.localeData()._week;
          return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
      }

      function getSetWeekYearHelper(input, week, weekday, dow, doy) {
          var weeksTarget;
          if (input == null) {
              return weekOfYear(this, dow, doy).year;
          } else {
              weeksTarget = weeksInYear(input, dow, doy);
              if (week > weeksTarget) {
                  week = weeksTarget;
              }
              return setWeekAll.call(this, input, week, weekday, dow, doy);
          }
      }

      function setWeekAll(weekYear, week, weekday, dow, doy) {
          var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
              date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

          this.year(date.getUTCFullYear());
          this.month(date.getUTCMonth());
          this.date(date.getUTCDate());
          return this;
      }

      // FORMATTING

      addFormatToken('Q', 0, 'Qo', 'quarter');

      // ALIASES

      addUnitAlias('quarter', 'Q');

      // PARSING

      addRegexToken('Q', match1);
      addParseToken('Q', function (input, array) {
          array[MONTH] = (toInt(input) - 1) * 3;
      });

      // MOMENTS

      function getSetQuarter (input) {
          return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
      }

      // FORMATTING

      addFormatToken('w', ['ww', 2], 'wo', 'week');
      addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

      // ALIASES

      addUnitAlias('week', 'w');
      addUnitAlias('isoWeek', 'W');

      // PARSING

      addRegexToken('w',  match1to2);
      addRegexToken('ww', match1to2, match2);
      addRegexToken('W',  match1to2);
      addRegexToken('WW', match1to2, match2);

      addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
          week[token.substr(0, 1)] = toInt(input);
      });

      // HELPERS

      // LOCALES

      function localeWeek (mom) {
          return weekOfYear(mom, this._week.dow, this._week.doy).week;
      }

      var defaultLocaleWeek = {
          dow : 0, // Sunday is the first day of the week.
          doy : 6  // The week that contains Jan 1st is the first week of the year.
      };

      function localeFirstDayOfWeek () {
          return this._week.dow;
      }

      function localeFirstDayOfYear () {
          return this._week.doy;
      }

      // MOMENTS

      function getSetWeek (input) {
          var week = this.localeData().week(this);
          return input == null ? week : this.add((input - week) * 7, 'd');
      }

      function getSetISOWeek (input) {
          var week = weekOfYear(this, 1, 4).week;
          return input == null ? week : this.add((input - week) * 7, 'd');
      }

      // FORMATTING

      addFormatToken('D', ['DD', 2], 'Do', 'date');

      // ALIASES

      addUnitAlias('date', 'D');

      // PARSING

      addRegexToken('D',  match1to2);
      addRegexToken('DD', match1to2, match2);
      addRegexToken('Do', function (isStrict, locale) {
          return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
      });

      addParseToken(['D', 'DD'], DATE);
      addParseToken('Do', function (input, array) {
          array[DATE] = toInt(input.match(match1to2)[0], 10);
      });

      // MOMENTS

      var getSetDayOfMonth = makeGetSet('Date', true);

      // FORMATTING

      addFormatToken('d', 0, 'do', 'day');

      addFormatToken('dd', 0, 0, function (format) {
          return this.localeData().weekdaysMin(this, format);
      });

      addFormatToken('ddd', 0, 0, function (format) {
          return this.localeData().weekdaysShort(this, format);
      });

      addFormatToken('dddd', 0, 0, function (format) {
          return this.localeData().weekdays(this, format);
      });

      addFormatToken('e', 0, 0, 'weekday');
      addFormatToken('E', 0, 0, 'isoWeekday');

      // ALIASES

      addUnitAlias('day', 'd');
      addUnitAlias('weekday', 'e');
      addUnitAlias('isoWeekday', 'E');

      // PARSING

      addRegexToken('d',    match1to2);
      addRegexToken('e',    match1to2);
      addRegexToken('E',    match1to2);
      addRegexToken('dd',   function (isStrict, locale) {
          return locale.weekdaysMinRegex(isStrict);
      });
      addRegexToken('ddd',   function (isStrict, locale) {
          return locale.weekdaysShortRegex(isStrict);
      });
      addRegexToken('dddd',   function (isStrict, locale) {
          return locale.weekdaysRegex(isStrict);
      });

      addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
          var weekday = config._locale.weekdaysParse(input, token, config._strict);
          // if we didn't get a weekday name, mark the date as invalid
          if (weekday != null) {
              week.d = weekday;
          } else {
              getParsingFlags(config).invalidWeekday = input;
          }
      });

      addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
          week[token] = toInt(input);
      });

      // HELPERS

      function parseWeekday(input, locale) {
          if (typeof input !== 'string') {
              return input;
          }

          if (!isNaN(input)) {
              return parseInt(input, 10);
          }

          input = locale.weekdaysParse(input);
          if (typeof input === 'number') {
              return input;
          }

          return null;
      }

      // LOCALES

      var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
      function localeWeekdays (m, format) {
          return isArray(this._weekdays) ? this._weekdays[m.day()] :
              this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
      }

      var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
      function localeWeekdaysShort (m) {
          return this._weekdaysShort[m.day()];
      }

      var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
      function localeWeekdaysMin (m) {
          return this._weekdaysMin[m.day()];
      }

      function day_of_week__handleStrictParse(weekdayName, format, strict) {
          var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
          if (!this._weekdaysParse) {
              this._weekdaysParse = [];
              this._shortWeekdaysParse = [];
              this._minWeekdaysParse = [];

              for (i = 0; i < 7; ++i) {
                  mom = create_utc__createUTC([2000, 1]).day(i);
                  this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                  this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                  this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
              }
          }

          if (strict) {
              if (format === 'dddd') {
                  ii = indexOf.call(this._weekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              } else if (format === 'ddd') {
                  ii = indexOf.call(this._shortWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              } else {
                  ii = indexOf.call(this._minWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              }
          } else {
              if (format === 'dddd') {
                  ii = indexOf.call(this._weekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._shortWeekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._minWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              } else if (format === 'ddd') {
                  ii = indexOf.call(this._shortWeekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._weekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._minWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              } else {
                  ii = indexOf.call(this._minWeekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._weekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._shortWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              }
          }
      }

      function localeWeekdaysParse (weekdayName, format, strict) {
          var i, mom, regex;

          if (this._weekdaysParseExact) {
              return day_of_week__handleStrictParse.call(this, weekdayName, format, strict);
          }

          if (!this._weekdaysParse) {
              this._weekdaysParse = [];
              this._minWeekdaysParse = [];
              this._shortWeekdaysParse = [];
              this._fullWeekdaysParse = [];
          }

          for (i = 0; i < 7; i++) {
              // make the regex if we don't have it already

              mom = create_utc__createUTC([2000, 1]).day(i);
              if (strict && !this._fullWeekdaysParse[i]) {
                  this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
                  this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
                  this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
              }
              if (!this._weekdaysParse[i]) {
                  regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                  this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
              }
              // test the regex
              if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                  return i;
              } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                  return i;
              } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                  return i;
              } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                  return i;
              }
          }
      }

      // MOMENTS

      function getSetDayOfWeek (input) {
          if (!this.isValid()) {
              return input != null ? this : NaN;
          }
          var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
          if (input != null) {
              input = parseWeekday(input, this.localeData());
              return this.add(input - day, 'd');
          } else {
              return day;
          }
      }

      function getSetLocaleDayOfWeek (input) {
          if (!this.isValid()) {
              return input != null ? this : NaN;
          }
          var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
          return input == null ? weekday : this.add(input - weekday, 'd');
      }

      function getSetISODayOfWeek (input) {
          if (!this.isValid()) {
              return input != null ? this : NaN;
          }
          // behaves the same as moment#day except
          // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
          // as a setter, sunday should belong to the previous week.
          return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
      }

      var defaultWeekdaysRegex = matchWord;
      function weekdaysRegex (isStrict) {
          if (this._weekdaysParseExact) {
              if (!hasOwnProp(this, '_weekdaysRegex')) {
                  computeWeekdaysParse.call(this);
              }
              if (isStrict) {
                  return this._weekdaysStrictRegex;
              } else {
                  return this._weekdaysRegex;
              }
          } else {
              return this._weekdaysStrictRegex && isStrict ?
                  this._weekdaysStrictRegex : this._weekdaysRegex;
          }
      }

      var defaultWeekdaysShortRegex = matchWord;
      function weekdaysShortRegex (isStrict) {
          if (this._weekdaysParseExact) {
              if (!hasOwnProp(this, '_weekdaysRegex')) {
                  computeWeekdaysParse.call(this);
              }
              if (isStrict) {
                  return this._weekdaysShortStrictRegex;
              } else {
                  return this._weekdaysShortRegex;
              }
          } else {
              return this._weekdaysShortStrictRegex && isStrict ?
                  this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
          }
      }

      var defaultWeekdaysMinRegex = matchWord;
      function weekdaysMinRegex (isStrict) {
          if (this._weekdaysParseExact) {
              if (!hasOwnProp(this, '_weekdaysRegex')) {
                  computeWeekdaysParse.call(this);
              }
              if (isStrict) {
                  return this._weekdaysMinStrictRegex;
              } else {
                  return this._weekdaysMinRegex;
              }
          } else {
              return this._weekdaysMinStrictRegex && isStrict ?
                  this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
          }
      }


      function computeWeekdaysParse () {
          function cmpLenRev(a, b) {
              return b.length - a.length;
          }

          var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
              i, mom, minp, shortp, longp;
          for (i = 0; i < 7; i++) {
              // make the regex if we don't have it already
              mom = create_utc__createUTC([2000, 1]).day(i);
              minp = this.weekdaysMin(mom, '');
              shortp = this.weekdaysShort(mom, '');
              longp = this.weekdays(mom, '');
              minPieces.push(minp);
              shortPieces.push(shortp);
              longPieces.push(longp);
              mixedPieces.push(minp);
              mixedPieces.push(shortp);
              mixedPieces.push(longp);
          }
          // Sorting makes sure if one weekday (or abbr) is a prefix of another it
          // will match the longer piece.
          minPieces.sort(cmpLenRev);
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          for (i = 0; i < 7; i++) {
              shortPieces[i] = regexEscape(shortPieces[i]);
              longPieces[i] = regexEscape(longPieces[i]);
              mixedPieces[i] = regexEscape(mixedPieces[i]);
          }

          this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
          this._weekdaysShortRegex = this._weekdaysRegex;
          this._weekdaysMinRegex = this._weekdaysRegex;

          this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
          this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
          this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
      }

      // FORMATTING

      addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

      // ALIASES

      addUnitAlias('dayOfYear', 'DDD');

      // PARSING

      addRegexToken('DDD',  match1to3);
      addRegexToken('DDDD', match3);
      addParseToken(['DDD', 'DDDD'], function (input, array, config) {
          config._dayOfYear = toInt(input);
      });

      // HELPERS

      // MOMENTS

      function getSetDayOfYear (input) {
          var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
          return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
      }

      // FORMATTING

      function hFormat() {
          return this.hours() % 12 || 12;
      }

      function kFormat() {
          return this.hours() || 24;
      }

      addFormatToken('H', ['HH', 2], 0, 'hour');
      addFormatToken('h', ['hh', 2], 0, hFormat);
      addFormatToken('k', ['kk', 2], 0, kFormat);

      addFormatToken('hmm', 0, 0, function () {
          return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
      });

      addFormatToken('hmmss', 0, 0, function () {
          return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
              zeroFill(this.seconds(), 2);
      });

      addFormatToken('Hmm', 0, 0, function () {
          return '' + this.hours() + zeroFill(this.minutes(), 2);
      });

      addFormatToken('Hmmss', 0, 0, function () {
          return '' + this.hours() + zeroFill(this.minutes(), 2) +
              zeroFill(this.seconds(), 2);
      });

      function meridiem (token, lowercase) {
          addFormatToken(token, 0, 0, function () {
              return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
          });
      }

      meridiem('a', true);
      meridiem('A', false);

      // ALIASES

      addUnitAlias('hour', 'h');

      // PARSING

      function matchMeridiem (isStrict, locale) {
          return locale._meridiemParse;
      }

      addRegexToken('a',  matchMeridiem);
      addRegexToken('A',  matchMeridiem);
      addRegexToken('H',  match1to2);
      addRegexToken('h',  match1to2);
      addRegexToken('HH', match1to2, match2);
      addRegexToken('hh', match1to2, match2);

      addRegexToken('hmm', match3to4);
      addRegexToken('hmmss', match5to6);
      addRegexToken('Hmm', match3to4);
      addRegexToken('Hmmss', match5to6);

      addParseToken(['H', 'HH'], HOUR);
      addParseToken(['a', 'A'], function (input, array, config) {
          config._isPm = config._locale.isPM(input);
          config._meridiem = input;
      });
      addParseToken(['h', 'hh'], function (input, array, config) {
          array[HOUR] = toInt(input);
          getParsingFlags(config).bigHour = true;
      });
      addParseToken('hmm', function (input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
          getParsingFlags(config).bigHour = true;
      });
      addParseToken('hmmss', function (input, array, config) {
          var pos1 = input.length - 4;
          var pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
          getParsingFlags(config).bigHour = true;
      });
      addParseToken('Hmm', function (input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
      });
      addParseToken('Hmmss', function (input, array, config) {
          var pos1 = input.length - 4;
          var pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
      });

      // LOCALES

      function localeIsPM (input) {
          // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
          // Using charAt should be more compatible.
          return ((input + '').toLowerCase().charAt(0) === 'p');
      }

      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
      function localeMeridiem (hours, minutes, isLower) {
          if (hours > 11) {
              return isLower ? 'pm' : 'PM';
          } else {
              return isLower ? 'am' : 'AM';
          }
      }


      // MOMENTS

      // Setting the hour should keep the time, because the user explicitly
      // specified which hour he wants. So trying to maintain the same hour (in
      // a new timezone) makes sense. Adding/subtracting hours does not follow
      // this rule.
      var getSetHour = makeGetSet('Hours', true);

      // FORMATTING

      addFormatToken('m', ['mm', 2], 0, 'minute');

      // ALIASES

      addUnitAlias('minute', 'm');

      // PARSING

      addRegexToken('m',  match1to2);
      addRegexToken('mm', match1to2, match2);
      addParseToken(['m', 'mm'], MINUTE);

      // MOMENTS

      var getSetMinute = makeGetSet('Minutes', false);

      // FORMATTING

      addFormatToken('s', ['ss', 2], 0, 'second');

      // ALIASES

      addUnitAlias('second', 's');

      // PARSING

      addRegexToken('s',  match1to2);
      addRegexToken('ss', match1to2, match2);
      addParseToken(['s', 'ss'], SECOND);

      // MOMENTS

      var getSetSecond = makeGetSet('Seconds', false);

      // FORMATTING

      addFormatToken('S', 0, 0, function () {
          return ~~(this.millisecond() / 100);
      });

      addFormatToken(0, ['SS', 2], 0, function () {
          return ~~(this.millisecond() / 10);
      });

      addFormatToken(0, ['SSS', 3], 0, 'millisecond');
      addFormatToken(0, ['SSSS', 4], 0, function () {
          return this.millisecond() * 10;
      });
      addFormatToken(0, ['SSSSS', 5], 0, function () {
          return this.millisecond() * 100;
      });
      addFormatToken(0, ['SSSSSS', 6], 0, function () {
          return this.millisecond() * 1000;
      });
      addFormatToken(0, ['SSSSSSS', 7], 0, function () {
          return this.millisecond() * 10000;
      });
      addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
          return this.millisecond() * 100000;
      });
      addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
          return this.millisecond() * 1000000;
      });


      // ALIASES

      addUnitAlias('millisecond', 'ms');

      // PARSING

      addRegexToken('S',    match1to3, match1);
      addRegexToken('SS',   match1to3, match2);
      addRegexToken('SSS',  match1to3, match3);

      var token;
      for (token = 'SSSS'; token.length <= 9; token += 'S') {
          addRegexToken(token, matchUnsigned);
      }

      function parseMs(input, array) {
          array[MILLISECOND] = toInt(('0.' + input) * 1000);
      }

      for (token = 'S'; token.length <= 9; token += 'S') {
          addParseToken(token, parseMs);
      }
      // MOMENTS

      var getSetMillisecond = makeGetSet('Milliseconds', false);

      // FORMATTING

      addFormatToken('z',  0, 0, 'zoneAbbr');
      addFormatToken('zz', 0, 0, 'zoneName');

      // MOMENTS

      function getZoneAbbr () {
          return this._isUTC ? 'UTC' : '';
      }

      function getZoneName () {
          return this._isUTC ? 'Coordinated Universal Time' : '';
      }

      var momentPrototype__proto = Moment.prototype;

      momentPrototype__proto.add               = add_subtract__add;
      momentPrototype__proto.calendar          = moment_calendar__calendar;
      momentPrototype__proto.clone             = clone;
      momentPrototype__proto.diff              = diff;
      momentPrototype__proto.endOf             = endOf;
      momentPrototype__proto.format            = format;
      momentPrototype__proto.from              = from;
      momentPrototype__proto.fromNow           = fromNow;
      momentPrototype__proto.to                = to;
      momentPrototype__proto.toNow             = toNow;
      momentPrototype__proto.get               = getSet;
      momentPrototype__proto.invalidAt         = invalidAt;
      momentPrototype__proto.isAfter           = isAfter;
      momentPrototype__proto.isBefore          = isBefore;
      momentPrototype__proto.isBetween         = isBetween;
      momentPrototype__proto.isSame            = isSame;
      momentPrototype__proto.isSameOrAfter     = isSameOrAfter;
      momentPrototype__proto.isSameOrBefore    = isSameOrBefore;
      momentPrototype__proto.isValid           = moment_valid__isValid;
      momentPrototype__proto.lang              = lang;
      momentPrototype__proto.locale            = locale;
      momentPrototype__proto.localeData        = localeData;
      momentPrototype__proto.max               = prototypeMax;
      momentPrototype__proto.min               = prototypeMin;
      momentPrototype__proto.parsingFlags      = parsingFlags;
      momentPrototype__proto.set               = getSet;
      momentPrototype__proto.startOf           = startOf;
      momentPrototype__proto.subtract          = add_subtract__subtract;
      momentPrototype__proto.toArray           = toArray;
      momentPrototype__proto.toObject          = toObject;
      momentPrototype__proto.toDate            = toDate;
      momentPrototype__proto.toISOString       = moment_format__toISOString;
      momentPrototype__proto.toJSON            = toJSON;
      momentPrototype__proto.toString          = toString;
      momentPrototype__proto.unix              = unix;
      momentPrototype__proto.valueOf           = to_type__valueOf;
      momentPrototype__proto.creationData      = creationData;

      // Year
      momentPrototype__proto.year       = getSetYear;
      momentPrototype__proto.isLeapYear = getIsLeapYear;

      // Week Year
      momentPrototype__proto.weekYear    = getSetWeekYear;
      momentPrototype__proto.isoWeekYear = getSetISOWeekYear;

      // Quarter
      momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;

      // Month
      momentPrototype__proto.month       = getSetMonth;
      momentPrototype__proto.daysInMonth = getDaysInMonth;

      // Week
      momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;
      momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;
      momentPrototype__proto.weeksInYear    = getWeeksInYear;
      momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;

      // Day
      momentPrototype__proto.date       = getSetDayOfMonth;
      momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;
      momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;
      momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
      momentPrototype__proto.dayOfYear  = getSetDayOfYear;

      // Hour
      momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;

      // Minute
      momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;

      // Second
      momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;

      // Millisecond
      momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;

      // Offset
      momentPrototype__proto.utcOffset            = getSetOffset;
      momentPrototype__proto.utc                  = setOffsetToUTC;
      momentPrototype__proto.local                = setOffsetToLocal;
      momentPrototype__proto.parseZone            = setOffsetToParsedOffset;
      momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
      momentPrototype__proto.isDST                = isDaylightSavingTime;
      momentPrototype__proto.isDSTShifted         = isDaylightSavingTimeShifted;
      momentPrototype__proto.isLocal              = isLocal;
      momentPrototype__proto.isUtcOffset          = isUtcOffset;
      momentPrototype__proto.isUtc                = isUtc;
      momentPrototype__proto.isUTC                = isUtc;

      // Timezone
      momentPrototype__proto.zoneAbbr = getZoneAbbr;
      momentPrototype__proto.zoneName = getZoneName;

      // Deprecations
      momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
      momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
      momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
      momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779', getSetZone);

      var momentPrototype = momentPrototype__proto;

      function moment__createUnix (input) {
          return local__createLocal(input * 1000);
      }

      function moment__createInZone () {
          return local__createLocal.apply(null, arguments).parseZone();
      }

      var defaultCalendar = {
          sameDay : '[Today at] LT',
          nextDay : '[Tomorrow at] LT',
          nextWeek : 'dddd [at] LT',
          lastDay : '[Yesterday at] LT',
          lastWeek : '[Last] dddd [at] LT',
          sameElse : 'L'
      };

      function locale_calendar__calendar (key, mom, now) {
          var output = this._calendar[key];
          return isFunction(output) ? output.call(mom, now) : output;
      }

      var defaultLongDateFormat = {
          LTS  : 'h:mm:ss A',
          LT   : 'h:mm A',
          L    : 'MM/DD/YYYY',
          LL   : 'MMMM D, YYYY',
          LLL  : 'MMMM D, YYYY h:mm A',
          LLLL : 'dddd, MMMM D, YYYY h:mm A'
      };

      function longDateFormat (key) {
          var format = this._longDateFormat[key],
              formatUpper = this._longDateFormat[key.toUpperCase()];

          if (format || !formatUpper) {
              return format;
          }

          this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
              return val.slice(1);
          });

          return this._longDateFormat[key];
      }

      var defaultInvalidDate = 'Invalid date';

      function invalidDate () {
          return this._invalidDate;
      }

      var defaultOrdinal = '%d';
      var defaultOrdinalParse = /\d{1,2}/;

      function ordinal (number) {
          return this._ordinal.replace('%d', number);
      }

      function preParsePostFormat (string) {
          return string;
      }

      var defaultRelativeTime = {
          future : 'in %s',
          past   : '%s ago',
          s  : 'a few seconds',
          m  : 'a minute',
          mm : '%d minutes',
          h  : 'an hour',
          hh : '%d hours',
          d  : 'a day',
          dd : '%d days',
          M  : 'a month',
          MM : '%d months',
          y  : 'a year',
          yy : '%d years'
      };

      function relative__relativeTime (number, withoutSuffix, string, isFuture) {
          var output = this._relativeTime[string];
          return (isFunction(output)) ?
              output(number, withoutSuffix, string, isFuture) :
              output.replace(/%d/i, number);
      }

      function pastFuture (diff, output) {
          var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
          return isFunction(format) ? format(output) : format.replace(/%s/i, output);
      }

      var prototype__proto = Locale.prototype;

      prototype__proto._calendar       = defaultCalendar;
      prototype__proto.calendar        = locale_calendar__calendar;
      prototype__proto._longDateFormat = defaultLongDateFormat;
      prototype__proto.longDateFormat  = longDateFormat;
      prototype__proto._invalidDate    = defaultInvalidDate;
      prototype__proto.invalidDate     = invalidDate;
      prototype__proto._ordinal        = defaultOrdinal;
      prototype__proto.ordinal         = ordinal;
      prototype__proto._ordinalParse   = defaultOrdinalParse;
      prototype__proto.preparse        = preParsePostFormat;
      prototype__proto.postformat      = preParsePostFormat;
      prototype__proto._relativeTime   = defaultRelativeTime;
      prototype__proto.relativeTime    = relative__relativeTime;
      prototype__proto.pastFuture      = pastFuture;
      prototype__proto.set             = locale_set__set;

      // Month
      prototype__proto.months            =        localeMonths;
      prototype__proto._months           = defaultLocaleMonths;
      prototype__proto.monthsShort       =        localeMonthsShort;
      prototype__proto._monthsShort      = defaultLocaleMonthsShort;
      prototype__proto.monthsParse       =        localeMonthsParse;
      prototype__proto._monthsRegex      = defaultMonthsRegex;
      prototype__proto.monthsRegex       = monthsRegex;
      prototype__proto._monthsShortRegex = defaultMonthsShortRegex;
      prototype__proto.monthsShortRegex  = monthsShortRegex;

      // Week
      prototype__proto.week = localeWeek;
      prototype__proto._week = defaultLocaleWeek;
      prototype__proto.firstDayOfYear = localeFirstDayOfYear;
      prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;

      // Day of Week
      prototype__proto.weekdays       =        localeWeekdays;
      prototype__proto._weekdays      = defaultLocaleWeekdays;
      prototype__proto.weekdaysMin    =        localeWeekdaysMin;
      prototype__proto._weekdaysMin   = defaultLocaleWeekdaysMin;
      prototype__proto.weekdaysShort  =        localeWeekdaysShort;
      prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;
      prototype__proto.weekdaysParse  =        localeWeekdaysParse;

      prototype__proto._weekdaysRegex      = defaultWeekdaysRegex;
      prototype__proto.weekdaysRegex       =        weekdaysRegex;
      prototype__proto._weekdaysShortRegex = defaultWeekdaysShortRegex;
      prototype__proto.weekdaysShortRegex  =        weekdaysShortRegex;
      prototype__proto._weekdaysMinRegex   = defaultWeekdaysMinRegex;
      prototype__proto.weekdaysMinRegex    =        weekdaysMinRegex;

      // Hours
      prototype__proto.isPM = localeIsPM;
      prototype__proto._meridiemParse = defaultLocaleMeridiemParse;
      prototype__proto.meridiem = localeMeridiem;

      function lists__get (format, index, field, setter) {
          var locale = locale_locales__getLocale();
          var utc = create_utc__createUTC().set(setter, index);
          return locale[field](utc, format);
      }

      function listMonthsImpl (format, index, field) {
          if (typeof format === 'number') {
              index = format;
              format = undefined;
          }

          format = format || '';

          if (index != null) {
              return lists__get(format, index, field, 'month');
          }

          var i;
          var out = [];
          for (i = 0; i < 12; i++) {
              out[i] = lists__get(format, i, field, 'month');
          }
          return out;
      }

      // ()
      // (5)
      // (fmt, 5)
      // (fmt)
      // (true)
      // (true, 5)
      // (true, fmt, 5)
      // (true, fmt)
      function listWeekdaysImpl (localeSorted, format, index, field) {
          if (typeof localeSorted === 'boolean') {
              if (typeof format === 'number') {
                  index = format;
                  format = undefined;
              }

              format = format || '';
          } else {
              format = localeSorted;
              index = format;
              localeSorted = false;

              if (typeof format === 'number') {
                  index = format;
                  format = undefined;
              }

              format = format || '';
          }

          var locale = locale_locales__getLocale(),
              shift = localeSorted ? locale._week.dow : 0;

          if (index != null) {
              return lists__get(format, (index + shift) % 7, field, 'day');
          }

          var i;
          var out = [];
          for (i = 0; i < 7; i++) {
              out[i] = lists__get(format, (i + shift) % 7, field, 'day');
          }
          return out;
      }

      function lists__listMonths (format, index) {
          return listMonthsImpl(format, index, 'months');
      }

      function lists__listMonthsShort (format, index) {
          return listMonthsImpl(format, index, 'monthsShort');
      }

      function lists__listWeekdays (localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
      }

      function lists__listWeekdaysShort (localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
      }

      function lists__listWeekdaysMin (localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
      }

      locale_locales__getSetGlobalLocale('en', {
          ordinalParse: /\d{1,2}(th|st|nd|rd)/,
          ordinal : function (number) {
              var b = number % 10,
                  output = (toInt(number % 100 / 10) === 1) ? 'th' :
                  (b === 1) ? 'st' :
                  (b === 2) ? 'nd' :
                  (b === 3) ? 'rd' : 'th';
              return number + output;
          }
      });

      // Side effect imports
      utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
      utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);

      var mathAbs = Math.abs;

      function duration_abs__abs () {
          var data           = this._data;

          this._milliseconds = mathAbs(this._milliseconds);
          this._days         = mathAbs(this._days);
          this._months       = mathAbs(this._months);

          data.milliseconds  = mathAbs(data.milliseconds);
          data.seconds       = mathAbs(data.seconds);
          data.minutes       = mathAbs(data.minutes);
          data.hours         = mathAbs(data.hours);
          data.months        = mathAbs(data.months);
          data.years         = mathAbs(data.years);

          return this;
      }

      function duration_add_subtract__addSubtract (duration, input, value, direction) {
          var other = create__createDuration(input, value);

          duration._milliseconds += direction * other._milliseconds;
          duration._days         += direction * other._days;
          duration._months       += direction * other._months;

          return duration._bubble();
      }

      // supports only 2.0-style add(1, 's') or add(duration)
      function duration_add_subtract__add (input, value) {
          return duration_add_subtract__addSubtract(this, input, value, 1);
      }

      // supports only 2.0-style subtract(1, 's') or subtract(duration)
      function duration_add_subtract__subtract (input, value) {
          return duration_add_subtract__addSubtract(this, input, value, -1);
      }

      function absCeil (number) {
          if (number < 0) {
              return Math.floor(number);
          } else {
              return Math.ceil(number);
          }
      }

      function bubble () {
          var milliseconds = this._milliseconds;
          var days         = this._days;
          var months       = this._months;
          var data         = this._data;
          var seconds, minutes, hours, years, monthsFromDays;

          // if we have a mix of positive and negative values, bubble down first
          // check: https://github.com/moment/moment/issues/2166
          if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                  (milliseconds <= 0 && days <= 0 && months <= 0))) {
              milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
              days = 0;
              months = 0;
          }

          // The following code bubbles up values, see the tests for
          // examples of what that means.
          data.milliseconds = milliseconds % 1000;

          seconds           = absFloor(milliseconds / 1000);
          data.seconds      = seconds % 60;

          minutes           = absFloor(seconds / 60);
          data.minutes      = minutes % 60;

          hours             = absFloor(minutes / 60);
          data.hours        = hours % 24;

          days += absFloor(hours / 24);

          // convert days to months
          monthsFromDays = absFloor(daysToMonths(days));
          months += monthsFromDays;
          days -= absCeil(monthsToDays(monthsFromDays));

          // 12 months -> 1 year
          years = absFloor(months / 12);
          months %= 12;

          data.days   = days;
          data.months = months;
          data.years  = years;

          return this;
      }

      function daysToMonths (days) {
          // 400 years have 146097 days (taking into account leap year rules)
          // 400 years have 12 months === 4800
          return days * 4800 / 146097;
      }

      function monthsToDays (months) {
          // the reverse of daysToMonths
          return months * 146097 / 4800;
      }

      function as (units) {
          var days;
          var months;
          var milliseconds = this._milliseconds;

          units = normalizeUnits(units);

          if (units === 'month' || units === 'year') {
              days   = this._days   + milliseconds / 864e5;
              months = this._months + daysToMonths(days);
              return units === 'month' ? months : months / 12;
          } else {
              // handle milliseconds separately because of floating point math errors (issue #1867)
              days = this._days + Math.round(monthsToDays(this._months));
              switch (units) {
                  case 'week'   : return days / 7     + milliseconds / 6048e5;
                  case 'day'    : return days         + milliseconds / 864e5;
                  case 'hour'   : return days * 24    + milliseconds / 36e5;
                  case 'minute' : return days * 1440  + milliseconds / 6e4;
                  case 'second' : return days * 86400 + milliseconds / 1000;
                  // Math.floor prevents floating point math errors here
                  case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                  default: throw new Error('Unknown unit ' + units);
              }
          }
      }

      // TODO: Use this.as('ms')?
      function duration_as__valueOf () {
          return (
              this._milliseconds +
              this._days * 864e5 +
              (this._months % 12) * 2592e6 +
              toInt(this._months / 12) * 31536e6
          );
      }

      function makeAs (alias) {
          return function () {
              return this.as(alias);
          };
      }

      var asMilliseconds = makeAs('ms');
      var asSeconds      = makeAs('s');
      var asMinutes      = makeAs('m');
      var asHours        = makeAs('h');
      var asDays         = makeAs('d');
      var asWeeks        = makeAs('w');
      var asMonths       = makeAs('M');
      var asYears        = makeAs('y');

      function duration_get__get (units) {
          units = normalizeUnits(units);
          return this[units + 's']();
      }

      function makeGetter(name) {
          return function () {
              return this._data[name];
          };
      }

      var milliseconds = makeGetter('milliseconds');
      var seconds      = makeGetter('seconds');
      var minutes      = makeGetter('minutes');
      var hours        = makeGetter('hours');
      var days         = makeGetter('days');
      var months       = makeGetter('months');
      var years        = makeGetter('years');

      function weeks () {
          return absFloor(this.days() / 7);
      }

      var round = Math.round;
      var thresholds = {
          s: 45,  // seconds to minute
          m: 45,  // minutes to hour
          h: 22,  // hours to day
          d: 26,  // days to month
          M: 11   // months to year
      };

      // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
      function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
          return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
      }

      function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {
          var duration = create__createDuration(posNegDuration).abs();
          var seconds  = round(duration.as('s'));
          var minutes  = round(duration.as('m'));
          var hours    = round(duration.as('h'));
          var days     = round(duration.as('d'));
          var months   = round(duration.as('M'));
          var years    = round(duration.as('y'));

          var a = seconds < thresholds.s && ['s', seconds]  ||
                  minutes <= 1           && ['m']           ||
                  minutes < thresholds.m && ['mm', minutes] ||
                  hours   <= 1           && ['h']           ||
                  hours   < thresholds.h && ['hh', hours]   ||
                  days    <= 1           && ['d']           ||
                  days    < thresholds.d && ['dd', days]    ||
                  months  <= 1           && ['M']           ||
                  months  < thresholds.M && ['MM', months]  ||
                  years   <= 1           && ['y']           || ['yy', years];

          a[2] = withoutSuffix;
          a[3] = +posNegDuration > 0;
          a[4] = locale;
          return substituteTimeAgo.apply(null, a);
      }

      // This function allows you to set a threshold for relative time strings
      function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {
          if (thresholds[threshold] === undefined) {
              return false;
          }
          if (limit === undefined) {
              return thresholds[threshold];
          }
          thresholds[threshold] = limit;
          return true;
      }

      function humanize (withSuffix) {
          var locale = this.localeData();
          var output = duration_humanize__relativeTime(this, !withSuffix, locale);

          if (withSuffix) {
              output = locale.pastFuture(+this, output);
          }

          return locale.postformat(output);
      }

      var iso_string__abs = Math.abs;

      function iso_string__toISOString() {
          // for ISO strings we do not use the normal bubbling rules:
          //  * milliseconds bubble up until they become hours
          //  * days do not bubble at all
          //  * months bubble up until they become years
          // This is because there is no context-free conversion between hours and days
          // (think of clock changes)
          // and also not between days and months (28-31 days per month)
          var seconds = iso_string__abs(this._milliseconds) / 1000;
          var days         = iso_string__abs(this._days);
          var months       = iso_string__abs(this._months);
          var minutes, hours, years;

          // 3600 seconds -> 60 minutes -> 1 hour
          minutes           = absFloor(seconds / 60);
          hours             = absFloor(minutes / 60);
          seconds %= 60;
          minutes %= 60;

          // 12 months -> 1 year
          years  = absFloor(months / 12);
          months %= 12;


          // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
          var Y = years;
          var M = months;
          var D = days;
          var h = hours;
          var m = minutes;
          var s = seconds;
          var total = this.asSeconds();

          if (!total) {
              // this is the same as C#'s (Noda) and python (isodate)...
              // but not other JS (goog.date)
              return 'P0D';
          }

          return (total < 0 ? '-' : '') +
              'P' +
              (Y ? Y + 'Y' : '') +
              (M ? M + 'M' : '') +
              (D ? D + 'D' : '') +
              ((h || m || s) ? 'T' : '') +
              (h ? h + 'H' : '') +
              (m ? m + 'M' : '') +
              (s ? s + 'S' : '');
      }

      var duration_prototype__proto = Duration.prototype;

      duration_prototype__proto.abs            = duration_abs__abs;
      duration_prototype__proto.add            = duration_add_subtract__add;
      duration_prototype__proto.subtract       = duration_add_subtract__subtract;
      duration_prototype__proto.as             = as;
      duration_prototype__proto.asMilliseconds = asMilliseconds;
      duration_prototype__proto.asSeconds      = asSeconds;
      duration_prototype__proto.asMinutes      = asMinutes;
      duration_prototype__proto.asHours        = asHours;
      duration_prototype__proto.asDays         = asDays;
      duration_prototype__proto.asWeeks        = asWeeks;
      duration_prototype__proto.asMonths       = asMonths;
      duration_prototype__proto.asYears        = asYears;
      duration_prototype__proto.valueOf        = duration_as__valueOf;
      duration_prototype__proto._bubble        = bubble;
      duration_prototype__proto.get            = duration_get__get;
      duration_prototype__proto.milliseconds   = milliseconds;
      duration_prototype__proto.seconds        = seconds;
      duration_prototype__proto.minutes        = minutes;
      duration_prototype__proto.hours          = hours;
      duration_prototype__proto.days           = days;
      duration_prototype__proto.weeks          = weeks;
      duration_prototype__proto.months         = months;
      duration_prototype__proto.years          = years;
      duration_prototype__proto.humanize       = humanize;
      duration_prototype__proto.toISOString    = iso_string__toISOString;
      duration_prototype__proto.toString       = iso_string__toISOString;
      duration_prototype__proto.toJSON         = iso_string__toISOString;
      duration_prototype__proto.locale         = locale;
      duration_prototype__proto.localeData     = localeData;

      // Deprecations
      duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
      duration_prototype__proto.lang = lang;

      // Side effect imports

      // FORMATTING

      addFormatToken('X', 0, 0, 'unix');
      addFormatToken('x', 0, 0, 'valueOf');

      // PARSING

      addRegexToken('x', matchSigned);
      addRegexToken('X', matchTimestamp);
      addParseToken('X', function (input, array, config) {
          config._d = new Date(parseFloat(input, 10) * 1000);
      });
      addParseToken('x', function (input, array, config) {
          config._d = new Date(toInt(input));
      });

      // Side effect imports


      utils_hooks__hooks.version = '2.13.0';

      setHookCallback(local__createLocal);

      utils_hooks__hooks.fn                    = momentPrototype;
      utils_hooks__hooks.min                   = min;
      utils_hooks__hooks.max                   = max;
      utils_hooks__hooks.now                   = now;
      utils_hooks__hooks.utc                   = create_utc__createUTC;
      utils_hooks__hooks.unix                  = moment__createUnix;
      utils_hooks__hooks.months                = lists__listMonths;
      utils_hooks__hooks.isDate                = isDate;
      utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;
      utils_hooks__hooks.invalid               = valid__createInvalid;
      utils_hooks__hooks.duration              = create__createDuration;
      utils_hooks__hooks.isMoment              = isMoment;
      utils_hooks__hooks.weekdays              = lists__listWeekdays;
      utils_hooks__hooks.parseZone             = moment__createInZone;
      utils_hooks__hooks.localeData            = locale_locales__getLocale;
      utils_hooks__hooks.isDuration            = isDuration;
      utils_hooks__hooks.monthsShort           = lists__listMonthsShort;
      utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;
      utils_hooks__hooks.defineLocale          = defineLocale;
      utils_hooks__hooks.updateLocale          = updateLocale;
      utils_hooks__hooks.locales               = locale_locales__listLocales;
      utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;
      utils_hooks__hooks.normalizeUnits        = normalizeUnits;
      utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
      utils_hooks__hooks.prototype             = momentPrototype;

      var _moment = utils_hooks__hooks;

      return _moment;

  }));
  /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)(module)))

/***/ },
/* 4 */
/***/ function(module, exports) {

  module.exports = function(module) {
  	if(!module.webpackPolyfill) {
  		module.deprecate = function() {};
  		module.paths = [];
  		// module.parent = undefined by default
  		module.children = [];
  		module.webpackPolyfill = 1;
  	}
  	return module;
  }


/***/ },
/* 5 */
/***/ function(module, exports) {

  function webpackContext(req) {
  	throw new Error("Cannot find module '" + req + "'.");
  }
  webpackContext.keys = function() { return []; };
  webpackContext.resolve = webpackContext;
  module.exports = webpackContext;
  webpackContext.id = 5;


/***/ },
/* 6 */
/***/ function(module, exports) {

  /* WEBPACK VAR INJECTION */(function(global) {'use strict';

  var _rng;

  var globalVar = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : null;

  if (globalVar && globalVar.crypto && crypto.getRandomValues) {
    // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
    // Moderately fast, high quality
    var _rnds8 = new Uint8Array(16);
    _rng = function whatwgRNG() {
      crypto.getRandomValues(_rnds8);
      return _rnds8;
    };
  }

  if (!_rng) {
    // Math.random()-based (RNG)
    //
    // If all else fails, use Math.random().  It's fast, but is of unspecified
    // quality.
    var _rnds = new Array(16);
    _rng = function _rng() {
      for (var i = 0, r; i < 16; i++) {
        if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
        _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
      }

      return _rnds;
    };
  }

  //     uuid.js
  //
  //     Copyright (c) 2010-2012 Robert Kieffer
  //     MIT License - http://opensource.org/licenses/mit-license.php

  // Unique ID creation requires a high quality random # generator.  We feature
  // detect to determine the best RNG source, normalizing to a function that
  // returns 128-bits of randomness, since that's what's usually required

  //var _rng = require('./rng');

  // Maps for number <-> hex string conversion
  var _byteToHex = [];
  var _hexToByte = {};
  for (var i = 0; i < 256; i++) {
    _byteToHex[i] = (i + 0x100).toString(16).substr(1);
    _hexToByte[_byteToHex[i]] = i;
  }

  // **`parse()` - Parse a UUID into it's component bytes**
  function parse(s, buf, offset) {
    var i = buf && offset || 0,
        ii = 0;

    buf = buf || [];
    s.toLowerCase().replace(/[0-9a-f]{2}/g, function (oct) {
      if (ii < 16) {
        // Don't overflow!
        buf[i + ii++] = _hexToByte[oct];
      }
    });

    // Zero out remaining bytes if string was short
    while (ii < 16) {
      buf[i + ii++] = 0;
    }

    return buf;
  }

  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**
  function unparse(buf, offset) {
    var i = offset || 0,
        bth = _byteToHex;
    return bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]];
  }

  // **`v1()` - Generate time-based UUID**
  //
  // Inspired by https://github.com/LiosK/UUID.js
  // and http://docs.python.org/library/uuid.html

  // random #'s we need to init node and clockseq
  var _seedBytes = _rng();

  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
  var _nodeId = [_seedBytes[0] | 0x01, _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]];

  // Per 4.2.2, randomize (14 bit) clockseq
  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

  // Previous uuid creation time
  var _lastMSecs = 0,
      _lastNSecs = 0;

  // See https://github.com/broofa/node-uuid for API details
  function v1(options, buf, offset) {
    var i = buf && offset || 0;
    var b = buf || [];

    options = options || {};

    var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

    // UUID timestamps are 100 nano-second units since the Gregorian epoch,
    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
    var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

    // Per 4.2.1.2, use count of uuid's generated during the current clock
    // cycle to simulate higher resolution clock
    var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

    // Time since last uuid creation (in msecs)
    var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000;

    // Per 4.2.1.2, Bump clockseq on clock regression
    if (dt < 0 && options.clockseq === undefined) {
      clockseq = clockseq + 1 & 0x3fff;
    }

    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
    // time interval
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
      nsecs = 0;
    }

    // Per 4.2.1.2 Throw error if too many uuids are requested
    if (nsecs >= 10000) {
      throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
    }

    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;

    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
    msecs += 12219292800000;

    // `time_low`
    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    b[i++] = tl >>> 24 & 0xff;
    b[i++] = tl >>> 16 & 0xff;
    b[i++] = tl >>> 8 & 0xff;
    b[i++] = tl & 0xff;

    // `time_mid`
    var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
    b[i++] = tmh >>> 8 & 0xff;
    b[i++] = tmh & 0xff;

    // `time_high_and_version`
    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
    b[i++] = tmh >>> 16 & 0xff;

    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
    b[i++] = clockseq >>> 8 | 0x80;

    // `clock_seq_low`
    b[i++] = clockseq & 0xff;

    // `node`
    var node = options.node || _nodeId;
    for (var n = 0; n < 6; n++) {
      b[i + n] = node[n];
    }

    return buf ? buf : unparse(b);
  }

  // **`v4()` - Generate random UUID**

  // See https://github.com/broofa/node-uuid for API details
  function v4(options, buf, offset) {
    // Deprecated - 'format' argument, as supported in v1.2
    var i = buf && offset || 0;

    if (typeof options == 'string') {
      buf = options == 'binary' ? new Array(16) : null;
      options = null;
    }
    options = options || {};

    var rnds = options.random || (options.rng || _rng)();

    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = rnds[6] & 0x0f | 0x40;
    rnds[8] = rnds[8] & 0x3f | 0x80;

    // Copy bytes to buffer, if provided
    if (buf) {
      for (var ii = 0; ii < 16; ii++) {
        buf[i + ii] = rnds[ii];
      }
    }

    return buf || unparse(rnds);
  }

  // Export public API
  var uuid = v4;
  uuid.v1 = v1;
  uuid.v4 = v4;
  uuid.parse = parse;
  uuid.unparse = unparse;

  module.exports = uuid;
  /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  // utils
  exports.util = __webpack_require__(1);
  exports.DOMutil = __webpack_require__(8);

  // data
  exports.DataSet = __webpack_require__(9);
  exports.DataView = __webpack_require__(11);
  exports.Queue = __webpack_require__(10);

  // Graph3d
  exports.Graph3d = __webpack_require__(12);
  exports.graph3d = {
    Camera: __webpack_require__(16),
    Filter: __webpack_require__(17),
    Point2d: __webpack_require__(15),
    Point3d: __webpack_require__(14),
    Slider: __webpack_require__(18),
    StepNumber: __webpack_require__(19)
  };

  // bundled external libraries
  exports.moment = __webpack_require__(2);
  exports.Hammer = __webpack_require__(20);
  exports.keycharm = __webpack_require__(23);

/***/ },
/* 8 */
/***/ function(module, exports) {

  'use strict';

  // DOM utility methods

  /**
   * this prepares the JSON container for allocating SVG elements
   * @param JSONcontainer
   * @private
   */
  exports.prepareElements = function (JSONcontainer) {
    // cleanup the redundant svgElements;
    for (var elementType in JSONcontainer) {
      if (JSONcontainer.hasOwnProperty(elementType)) {
        JSONcontainer[elementType].redundant = JSONcontainer[elementType].used;
        JSONcontainer[elementType].used = [];
      }
    }
  };

  /**
   * this cleans up all the unused SVG elements. By asking for the parentNode, we only need to supply the JSON container from
   * which to remove the redundant elements.
   *
   * @param JSONcontainer
   * @private
   */
  exports.cleanupElements = function (JSONcontainer) {
    // cleanup the redundant svgElements;
    for (var elementType in JSONcontainer) {
      if (JSONcontainer.hasOwnProperty(elementType)) {
        if (JSONcontainer[elementType].redundant) {
          for (var i = 0; i < JSONcontainer[elementType].redundant.length; i++) {
            JSONcontainer[elementType].redundant[i].parentNode.removeChild(JSONcontainer[elementType].redundant[i]);
          }
          JSONcontainer[elementType].redundant = [];
        }
      }
    }
  };

  /**
   * Ensures that all elements are removed first up so they can be recreated cleanly
   * @param JSONcontainer
   */
  exports.resetElements = function (JSONcontainer) {
    exports.prepareElements(JSONcontainer);
    exports.cleanupElements(JSONcontainer);
    exports.prepareElements(JSONcontainer);
  };

  /**
   * Allocate or generate an SVG element if needed. Store a reference to it in the JSON container and draw it in the svgContainer
   * the JSON container and the SVG container have to be supplied so other svg containers (like the legend) can use this.
   *
   * @param elementType
   * @param JSONcontainer
   * @param svgContainer
   * @returns {*}
   * @private
   */
  exports.getSVGElement = function (elementType, JSONcontainer, svgContainer) {
    var element;
    // allocate SVG element, if it doesnt yet exist, create one.
    if (JSONcontainer.hasOwnProperty(elementType)) {
      // this element has been created before
      // check if there is an redundant element
      if (JSONcontainer[elementType].redundant.length > 0) {
        element = JSONcontainer[elementType].redundant[0];
        JSONcontainer[elementType].redundant.shift();
      } else {
        // create a new element and add it to the SVG
        element = document.createElementNS('http://www.w3.org/2000/svg', elementType);
        svgContainer.appendChild(element);
      }
    } else {
      // create a new element and add it to the SVG, also create a new object in the svgElements to keep track of it.
      element = document.createElementNS('http://www.w3.org/2000/svg', elementType);
      JSONcontainer[elementType] = { used: [], redundant: [] };
      svgContainer.appendChild(element);
    }
    JSONcontainer[elementType].used.push(element);
    return element;
  };

  /**
   * Allocate or generate an SVG element if needed. Store a reference to it in the JSON container and draw it in the svgContainer
   * the JSON container and the SVG container have to be supplied so other svg containers (like the legend) can use this.
   *
   * @param elementType
   * @param JSONcontainer
   * @param DOMContainer
   * @returns {*}
   * @private
   */
  exports.getDOMElement = function (elementType, JSONcontainer, DOMContainer, insertBefore) {
    var element;
    // allocate DOM element, if it doesnt yet exist, create one.
    if (JSONcontainer.hasOwnProperty(elementType)) {
      // this element has been created before
      // check if there is an redundant element
      if (JSONcontainer[elementType].redundant.length > 0) {
        element = JSONcontainer[elementType].redundant[0];
        JSONcontainer[elementType].redundant.shift();
      } else {
        // create a new element and add it to the SVG
        element = document.createElement(elementType);
        if (insertBefore !== undefined) {
          DOMContainer.insertBefore(element, insertBefore);
        } else {
          DOMContainer.appendChild(element);
        }
      }
    } else {
      // create a new element and add it to the SVG, also create a new object in the svgElements to keep track of it.
      element = document.createElement(elementType);
      JSONcontainer[elementType] = { used: [], redundant: [] };
      if (insertBefore !== undefined) {
        DOMContainer.insertBefore(element, insertBefore);
      } else {
        DOMContainer.appendChild(element);
      }
    }
    JSONcontainer[elementType].used.push(element);
    return element;
  };

  /**
   * Draw a point object. This is a separate function because it can also be called by the legend.
   * The reason the JSONcontainer and the target SVG svgContainer have to be supplied is so the legend can use these functions
   * as well.
   *
   * @param x
   * @param y
   * @param groupTemplate: A template containing the necessary information to draw the datapoint e.g., {style: 'circle', size: 5, className: 'className' }
   * @param JSONcontainer
   * @param svgContainer
   * @param labelObj
   * @returns {*}
   */
  exports.drawPoint = function (x, y, groupTemplate, JSONcontainer, svgContainer, labelObj) {
    var point;
    if (groupTemplate.style == 'circle') {
      point = exports.getSVGElement('circle', JSONcontainer, svgContainer);
      point.setAttributeNS(null, "cx", x);
      point.setAttributeNS(null, "cy", y);
      point.setAttributeNS(null, "r", 0.5 * groupTemplate.size);
    } else {
      point = exports.getSVGElement('rect', JSONcontainer, svgContainer);
      point.setAttributeNS(null, "x", x - 0.5 * groupTemplate.size);
      point.setAttributeNS(null, "y", y - 0.5 * groupTemplate.size);
      point.setAttributeNS(null, "width", groupTemplate.size);
      point.setAttributeNS(null, "height", groupTemplate.size);
    }

    if (groupTemplate.styles !== undefined) {
      point.setAttributeNS(null, "style", groupTemplate.styles);
    }
    point.setAttributeNS(null, "class", groupTemplate.className + " vis-point");
    //handle label

    if (labelObj) {
      var label = exports.getSVGElement('text', JSONcontainer, svgContainer);
      if (labelObj.xOffset) {
        x = x + labelObj.xOffset;
      }

      if (labelObj.yOffset) {
        y = y + labelObj.yOffset;
      }
      if (labelObj.content) {
        label.textContent = labelObj.content;
      }

      if (labelObj.className) {
        label.setAttributeNS(null, "class", labelObj.className + " vis-label");
      }
      label.setAttributeNS(null, "x", x);
      label.setAttributeNS(null, "y", y);
    }

    return point;
  };

  /**
   * draw a bar SVG element centered on the X coordinate
   *
   * @param x
   * @param y
   * @param className
   */
  exports.drawBar = function (x, y, width, height, className, JSONcontainer, svgContainer, style) {
    if (height != 0) {
      if (height < 0) {
        height *= -1;
        y -= height;
      }
      var rect = exports.getSVGElement('rect', JSONcontainer, svgContainer);
      rect.setAttributeNS(null, "x", x - 0.5 * width);
      rect.setAttributeNS(null, "y", y);
      rect.setAttributeNS(null, "width", width);
      rect.setAttributeNS(null, "height", height);
      rect.setAttributeNS(null, "class", className);
      if (style) {
        rect.setAttributeNS(null, "style", style);
      }
    }
  };

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

  var util = __webpack_require__(1);
  var Queue = __webpack_require__(10);

  /**
   * DataSet
   *
   * Usage:
   *     var dataSet = new DataSet({
   *         fieldId: '_id',
   *         type: {
   *             // ...
   *         }
   *     });
   *
   *     dataSet.add(item);
   *     dataSet.add(data);
   *     dataSet.update(item);
   *     dataSet.update(data);
   *     dataSet.remove(id);
   *     dataSet.remove(ids);
   *     var data = dataSet.get();
   *     var data = dataSet.get(id);
   *     var data = dataSet.get(ids);
   *     var data = dataSet.get(ids, options, data);
   *     dataSet.clear();
   *
   * A data set can:
   * - add/remove/update data
   * - gives triggers upon changes in the data
   * - can  import/export data in various data formats
   *
   * @param {Array} [data]    Optional array with initial data
   * @param {Object} [options]   Available options:
   *                             {String} fieldId Field name of the id in the
   *                                              items, 'id' by default.
   *                             {Object.<String, String} type
   *                                              A map with field names as key,
   *                                              and the field type as value.
   *                             {Object} queue   Queue changes to the DataSet,
   *                                              flush them all at once.
   *                                              Queue options:
   *                                              - {number} delay  Delay in ms, null by default
   *                                              - {number} max    Maximum number of entries in the queue, Infinity by default
   * @constructor DataSet
   */
  // TODO: add a DataSet constructor DataSet(data, options)
  function DataSet(data, options) {
    // correctly read optional arguments
    if (data && !Array.isArray(data)) {
      options = data;
      data = null;
    }

    this._options = options || {};
    this._data = {}; // map with data indexed by id
    this.length = 0; // number of items in the DataSet
    this._fieldId = this._options.fieldId || 'id'; // name of the field containing id
    this._type = {}; // internal field types (NOTE: this can differ from this._options.type)

    // all variants of a Date are internally stored as Date, so we can convert
    // from everything to everything (also from ISODate to Number for example)
    if (this._options.type) {
      var fields = Object.keys(this._options.type);
      for (var i = 0, len = fields.length; i < len; i++) {
        var field = fields[i];
        var value = this._options.type[field];
        if (value == 'Date' || value == 'ISODate' || value == 'ASPDate') {
          this._type[field] = 'Date';
        } else {
          this._type[field] = value;
        }
      }
    }

    // TODO: deprecated since version 1.1.1 (or 2.0.0?)
    if (this._options.convert) {
      throw new Error('Option "convert" is deprecated. Use "type" instead.');
    }

    this._subscribers = {}; // event subscribers

    // add initial data when provided
    if (data) {
      this.add(data);
    }

    this.setOptions(options);
  }

  /**
   * @param {Object} [options]   Available options:
   *                             {Object} queue   Queue changes to the DataSet,
   *                                              flush them all at once.
   *                                              Queue options:
   *                                              - {number} delay  Delay in ms, null by default
   *                                              - {number} max    Maximum number of entries in the queue, Infinity by default
   * @param options
   */
  DataSet.prototype.setOptions = function (options) {
    if (options && options.queue !== undefined) {
      if (options.queue === false) {
        // delete queue if loaded
        if (this._queue) {
          this._queue.destroy();
          delete this._queue;
        }
      } else {
        // create queue and update its options
        if (!this._queue) {
          this._queue = Queue.extend(this, {
            replace: ['add', 'update', 'remove']
          });
        }

        if (_typeof(options.queue) === 'object') {
          this._queue.setOptions(options.queue);
        }
      }
    }
  };

  /**
   * Subscribe to an event, add an event listener
   * @param {String} event        Event name. Available events: 'put', 'update',
   *                              'remove'
   * @param {function} callback   Callback method. Called with three parameters:
   *                                  {String} event
   *                                  {Object | null} params
   *                                  {String | Number} senderId
   */
  DataSet.prototype.on = function (event, callback) {
    var subscribers = this._subscribers[event];
    if (!subscribers) {
      subscribers = [];
      this._subscribers[event] = subscribers;
    }

    subscribers.push({
      callback: callback
    });
  };

  // TODO: remove this deprecated function some day (replaced with `on` since version 0.5, deprecated since v4.0)
  DataSet.prototype.subscribe = function () {
    throw new Error('DataSet.subscribe is deprecated. Use DataSet.on instead.');
  };

  /**
   * Unsubscribe from an event, remove an event listener
   * @param {String} event
   * @param {function} callback
   */
  DataSet.prototype.off = function (event, callback) {
    var subscribers = this._subscribers[event];
    if (subscribers) {
      this._subscribers[event] = subscribers.filter(function (listener) {
        return listener.callback != callback;
      });
    }
  };

  // TODO: remove this deprecated function some day (replaced with `on` since version 0.5, deprecated since v4.0)
  DataSet.prototype.unsubscribe = function () {
    throw new Error('DataSet.unsubscribe is deprecated. Use DataSet.off instead.');
  };

  /**
   * Trigger an event
   * @param {String} event
   * @param {Object | null} params
   * @param {String} [senderId]       Optional id of the sender.
   * @private
   */
  DataSet.prototype._trigger = function (event, params, senderId) {
    if (event == '*') {
      throw new Error('Cannot trigger event *');
    }

    var subscribers = [];
    if (event in this._subscribers) {
      subscribers = subscribers.concat(this._subscribers[event]);
    }
    if ('*' in this._subscribers) {
      subscribers = subscribers.concat(this._subscribers['*']);
    }

    for (var i = 0, len = subscribers.length; i < len; i++) {
      var subscriber = subscribers[i];
      if (subscriber.callback) {
        subscriber.callback(event, params, senderId || null);
      }
    }
  };

  /**
   * Add data.
   * Adding an item will fail when there already is an item with the same id.
   * @param {Object | Array} data
   * @param {String} [senderId] Optional sender id
   * @return {Array} addedIds      Array with the ids of the added items
   */
  DataSet.prototype.add = function (data, senderId) {
    var addedIds = [],
        id,
        me = this;

    if (Array.isArray(data)) {
      // Array
      for (var i = 0, len = data.length; i < len; i++) {
        id = me._addItem(data[i]);
        addedIds.push(id);
      }
    } else if (data instanceof Object) {
      // Single item
      id = me._addItem(data);
      addedIds.push(id);
    } else {
      throw new Error('Unknown dataType');
    }

    if (addedIds.length) {
      this._trigger('add', { items: addedIds }, senderId);
    }

    return addedIds;
  };

  /**
   * Update existing items. When an item does not exist, it will be created
   * @param {Object | Array} data
   * @param {String} [senderId] Optional sender id
   * @return {Array} updatedIds     The ids of the added or updated items
   */
  DataSet.prototype.update = function (data, senderId) {
    var addedIds = [];
    var updatedIds = [];
    var oldData = [];
    var updatedData = [];
    var me = this;
    var fieldId = me._fieldId;

    var addOrUpdate = function addOrUpdate(item) {
      var id = item[fieldId];
      if (me._data[id]) {
        var oldItem = util.extend({}, me._data[id]);
        // update item
        id = me._updateItem(item);
        updatedIds.push(id);
        updatedData.push(item);
        oldData.push(oldItem);
      } else {
        // add new item
        id = me._addItem(item);
        addedIds.push(id);
      }
    };

    if (Array.isArray(data)) {
      // Array
      for (var i = 0, len = data.length; i < len; i++) {
        if (data[i] instanceof Object) {
          addOrUpdate(data[i]);
        } else {
          console.warn('Ignoring input item, which is not an object at index ' + i);
        }
      }
    } else if (data instanceof Object) {
      // Single item
      addOrUpdate(data);
    } else {
      throw new Error('Unknown dataType');
    }

    if (addedIds.length) {
      this._trigger('add', { items: addedIds }, senderId);
    }
    if (updatedIds.length) {
      var props = { items: updatedIds, oldData: oldData, data: updatedData };
      // TODO: remove deprecated property 'data' some day
      //Object.defineProperty(props, 'data', {
      //  'get': (function() {
      //    console.warn('Property data is deprecated. Use DataSet.get(ids) to retrieve the new data, use the oldData property on this object to get the old data');
      //    return updatedData;
      //  }).bind(this)
      //});
      this._trigger('update', props, senderId);
    }

    return addedIds.concat(updatedIds);
  };

  /**
   * Get a data item or multiple items.
   *
   * Usage:
   *
   *     get()
   *     get(options: Object)
   *
   *     get(id: Number | String)
   *     get(id: Number | String, options: Object)
   *
   *     get(ids: Number[] | String[])
   *     get(ids: Number[] | String[], options: Object)
   *
   * Where:
   *
   * {Number | String} id         The id of an item
   * {Number[] | String{}} ids    An array with ids of items
   * {Object} options             An Object with options. Available options:
   * {String} [returnType]        Type of data to be returned.
   *                              Can be 'Array' (default) or 'Object'.
   * {Object.<String, String>} [type]
   * {String[]} [fields]          field names to be returned
   * {function} [filter]          filter items
   * {String | function} [order]  Order the items by a field name or custom sort function.
   * @throws Error
   */
  DataSet.prototype.get = function (args) {
    var me = this;

    // parse the arguments
    var id, ids, options;
    var firstType = util.getType(arguments[0]);
    if (firstType == 'String' || firstType == 'Number') {
      // get(id [, options])
      id = arguments[0];
      options = arguments[1];
    } else if (firstType == 'Array') {
      // get(ids [, options])
      ids = arguments[0];
      options = arguments[1];
    } else {
      // get([, options])
      options = arguments[0];
    }

    // determine the return type
    var returnType;
    if (options && options.returnType) {
      var allowedValues = ['Array', 'Object'];
      returnType = allowedValues.indexOf(options.returnType) == -1 ? 'Array' : options.returnType;
    } else {
      returnType = 'Array';
    }

    // build options
    var type = options && options.type || this._options.type;
    var filter = options && options.filter;
    var items = [],
        item,
        itemIds,
        itemId,
        i,
        len;

    // convert items
    if (id != undefined) {
      // return a single item
      item = me._getItem(id, type);
      if (item && filter && !filter(item)) {
        item = null;
      }
    } else if (ids != undefined) {
      // return a subset of items
      for (i = 0, len = ids.length; i < len; i++) {
        item = me._getItem(ids[i], type);
        if (!filter || filter(item)) {
          items.push(item);
        }
      }
    } else {
      // return all items
      itemIds = Object.keys(this._data);
      for (i = 0, len = itemIds.length; i < len; i++) {
        itemId = itemIds[i];
        item = me._getItem(itemId, type);
        if (!filter || filter(item)) {
          items.push(item);
        }
      }
    }

    // order the results
    if (options && options.order && id == undefined) {
      this._sort(items, options.order);
    }

    // filter fields of the items
    if (options && options.fields) {
      var fields = options.fields;
      if (id != undefined) {
        item = this._filterFields(item, fields);
      } else {
        for (i = 0, len = items.length; i < len; i++) {
          items[i] = this._filterFields(items[i], fields);
        }
      }
    }

    // return the results
    if (returnType == 'Object') {
      var result = {},
          resultant;
      for (i = 0, len = items.length; i < len; i++) {
        resultant = items[i];
        result[resultant.id] = resultant;
      }
      return result;
    } else {
      if (id != undefined) {
        // a single item
        return item;
      } else {
        // just return our array
        return items;
      }
    }
  };

  /**
   * Get ids of all items or from a filtered set of items.
   * @param {Object} [options]    An Object with options. Available options:
   *                              {function} [filter] filter items
   *                              {String | function} [order] Order the items by
   *                                  a field name or custom sort function.
   * @return {Array} ids
   */
  DataSet.prototype.getIds = function (options) {
    var data = this._data,
        filter = options && options.filter,
        order = options && options.order,
        type = options && options.type || this._options.type,
        itemIds = Object.keys(data),
        i,
        len,
        id,
        item,
        items,
        ids = [];

    if (filter) {
      // get filtered items
      if (order) {
        // create ordered list
        items = [];
        for (i = 0, len = itemIds.length; i < len; i++) {
          id = itemIds[i];
          item = this._getItem(id, type);
          if (filter(item)) {
            items.push(item);
          }
        }

        this._sort(items, order);

        for (i = 0, len = items.length; i < len; i++) {
          ids.push(items[i][this._fieldId]);
        }
      } else {
        // create unordered list
        for (i = 0, len = itemIds.length; i < len; i++) {
          id = itemIds[i];
          item = this._getItem(id, type);
          if (filter(item)) {
            ids.push(item[this._fieldId]);
          }
        }
      }
    } else {
      // get all items
      if (order) {
        // create an ordered list
        items = [];
        for (i = 0, len = itemIds.length; i < len; i++) {
          id = itemIds[i];
          items.push(data[id]);
        }

        this._sort(items, order);

        for (i = 0, len = items.length; i < len; i++) {
          ids.push(items[i][this._fieldId]);
        }
      } else {
        // create unordered list
        for (i = 0, len = itemIds.length; i < len; i++) {
          id = itemIds[i];
          item = data[id];
          ids.push(item[this._fieldId]);
        }
      }
    }

    return ids;
  };

  /**
   * Returns the DataSet itself. Is overwritten for example by the DataView,
   * which returns the DataSet it is connected to instead.
   */
  DataSet.prototype.getDataSet = function () {
    return this;
  };

  /**
   * Execute a callback function for every item in the dataset.
   * @param {function} callback
   * @param {Object} [options]    Available options:
   *                              {Object.<String, String>} [type]
   *                              {String[]} [fields] filter fields
   *                              {function} [filter] filter items
   *                              {String | function} [order] Order the items by
   *                                  a field name or custom sort function.
   */
  DataSet.prototype.forEach = function (callback, options) {
    var filter = options && options.filter,
        type = options && options.type || this._options.type,
        data = this._data,
        itemIds = Object.keys(data),
        i,
        len,
        item,
        id;

    if (options && options.order) {
      // execute forEach on ordered list
      var items = this.get(options);

      for (i = 0, len = items.length; i < len; i++) {
        item = items[i];
        id = item[this._fieldId];
        callback(item, id);
      }
    } else {
      // unordered
      for (i = 0, len = itemIds.length; i < len; i++) {
        id = itemIds[i];
        item = this._getItem(id, type);
        if (!filter || filter(item)) {
          callback(item, id);
        }
      }
    }
  };

  /**
   * Map every item in the dataset.
   * @param {function} callback
   * @param {Object} [options]    Available options:
   *                              {Object.<String, String>} [type]
   *                              {String[]} [fields] filter fields
   *                              {function} [filter] filter items
   *                              {String | function} [order] Order the items by
   *                                  a field name or custom sort function.
   * @return {Object[]} mappedItems
   */
  DataSet.prototype.map = function (callback, options) {
    var filter = options && options.filter,
        type = options && options.type || this._options.type,
        mappedItems = [],
        data = this._data,
        itemIds = Object.keys(data),
        i,
        len,
        id,
        item;

    // convert and filter items
    for (i = 0, len = itemIds.length; i < len; i++) {
      id = itemIds[i];
      item = this._getItem(id, type);
      if (!filter || filter(item)) {
        mappedItems.push(callback(item, id));
      }
    }

    // order items
    if (options && options.order) {
      this._sort(mappedItems, options.order);
    }

    return mappedItems;
  };

  /**
   * Filter the fields of an item
   * @param {Object | null} item
   * @param {String[]} fields     Field names
   * @return {Object | null} filteredItem or null if no item is provided
   * @private
   */
  DataSet.prototype._filterFields = function (item, fields) {
    if (!item) {
      // item is null
      return item;
    }

    var filteredItem = {},
        itemFields = Object.keys(item),
        len = itemFields.length,
        i,
        field;

    if (Array.isArray(fields)) {
      for (i = 0; i < len; i++) {
        field = itemFields[i];
        if (fields.indexOf(field) != -1) {
          filteredItem[field] = item[field];
        }
      }
    } else {
      for (i = 0; i < len; i++) {
        field = itemFields[i];
        if (fields.hasOwnProperty(field)) {
          filteredItem[fields[field]] = item[field];
        }
      }
    }

    return filteredItem;
  };

  /**
   * Sort the provided array with items
   * @param {Object[]} items
   * @param {String | function} order      A field name or custom sort function.
   * @private
   */
  DataSet.prototype._sort = function (items, order) {
    if (util.isString(order)) {
      // order by provided field name
      var name = order; // field name
      items.sort(function (a, b) {
        var av = a[name];
        var bv = b[name];
        return av > bv ? 1 : av < bv ? -1 : 0;
      });
    } else if (typeof order === 'function') {
      // order by sort function
      items.sort(order);
    }
    // TODO: extend order by an Object {field:String, direction:String}
    //       where direction can be 'asc' or 'desc'
    else {
        throw new TypeError('Order must be a function or a string');
      }
  };

  /**
   * Remove an object by pointer or by id
   * @param {String | Number | Object | Array} id Object or id, or an array with
   *                                              objects or ids to be removed
   * @param {String} [senderId] Optional sender id
   * @return {Array} removedIds
   */
  DataSet.prototype.remove = function (id, senderId) {
    var removedIds = [],
        i,
        len,
        removedId;

    if (Array.isArray(id)) {
      for (i = 0, len = id.length; i < len; i++) {
        removedId = this._remove(id[i]);
        if (removedId != null) {
          removedIds.push(removedId);
        }
      }
    } else {
      removedId = this._remove(id);
      if (removedId != null) {
        removedIds.push(removedId);
      }
    }

    if (removedIds.length) {
      this._trigger('remove', { items: removedIds }, senderId);
    }

    return removedIds;
  };

  /**
   * Remove an item by its id
   * @param {Number | String | Object} id   id or item
   * @returns {Number | String | null} id
   * @private
   */
  DataSet.prototype._remove = function (id) {
    if (util.isNumber(id) || util.isString(id)) {
      if (this._data[id]) {
        delete this._data[id];
        this.length--;
        return id;
      }
    } else if (id instanceof Object) {
      var itemId = id[this._fieldId];
      if (itemId !== undefined && this._data[itemId]) {
        delete this._data[itemId];
        this.length--;
        return itemId;
      }
    }
    return null;
  };

  /**
   * Clear the data
   * @param {String} [senderId] Optional sender id
   * @return {Array} removedIds    The ids of all removed items
   */
  DataSet.prototype.clear = function (senderId) {
    var ids = Object.keys(this._data);

    this._data = {};
    this.length = 0;

    this._trigger('remove', { items: ids }, senderId);

    return ids;
  };

  /**
   * Find the item with maximum value of a specified field
   * @param {String} field
   * @return {Object | null} item  Item containing max value, or null if no items
   */
  DataSet.prototype.max = function (field) {
    var data = this._data,
        itemIds = Object.keys(data),
        max = null,
        maxField = null,
        i,
        len;

    for (i = 0, len = itemIds.length; i < len; i++) {
      var id = itemIds[i];
      var item = data[id];
      var itemField = item[field];
      if (itemField != null && (!max || itemField > maxField)) {
        max = item;
        maxField = itemField;
      }
    }

    return max;
  };

  /**
   * Find the item with minimum value of a specified field
   * @param {String} field
   * @return {Object | null} item  Item containing max value, or null if no items
   */
  DataSet.prototype.min = function (field) {
    var data = this._data,
        itemIds = Object.keys(data),
        min = null,
        minField = null,
        i,
        len;

    for (i = 0, len = itemIds.length; i < len; i++) {
      var id = itemIds[i];
      var item = data[id];
      var itemField = item[field];
      if (itemField != null && (!min || itemField < minField)) {
        min = item;
        minField = itemField;
      }
    }

    return min;
  };

  /**
   * Find all distinct values of a specified field
   * @param {String} field
   * @return {Array} values  Array containing all distinct values. If data items
   *                         do not contain the specified field are ignored.
   *                         The returned array is unordered.
   */
  DataSet.prototype.distinct = function (field) {
    var data = this._data;
    var itemIds = Object.keys(data);
    var values = [];
    var fieldType = this._options.type && this._options.type[field] || null;
    var count = 0;
    var i, j, len;

    for (i = 0, len = itemIds.length; i < len; i++) {
      var id = itemIds[i];
      var item = data[id];
      var value = item[field];
      var exists = false;
      for (j = 0; j < count; j++) {
        if (values[j] == value) {
          exists = true;
          break;
        }
      }
      if (!exists && value !== undefined) {
        values[count] = value;
        count++;
      }
    }

    if (fieldType) {
      for (i = 0, len = values.length; i < len; i++) {
        values[i] = util.convert(values[i], fieldType);
      }
    }

    return values;
  };

  /**
   * Add a single item. Will fail when an item with the same id already exists.
   * @param {Object} item
   * @return {String} id
   * @private
   */
  DataSet.prototype._addItem = function (item) {
    var id = item[this._fieldId];

    if (id != undefined) {
      // check whether this id is already taken
      if (this._data[id]) {
        // item already exists
        throw new Error('Cannot add item: item with id ' + id + ' already exists');
      }
    } else {
      // generate an id
      id = util.randomUUID();
      item[this._fieldId] = id;
    }

    var d = {},
        fields = Object.keys(item),
        i,
        len;
    for (i = 0, len = fields.length; i < len; i++) {
      var field = fields[i];
      var fieldType = this._type[field]; // type may be undefined
      d[field] = util.convert(item[field], fieldType);
    }
    this._data[id] = d;
    this.length++;

    return id;
  };

  /**
   * Get an item. Fields can be converted to a specific type
   * @param {String} id
   * @param {Object.<String, String>} [types]  field types to convert
   * @return {Object | null} item
   * @private
   */
  DataSet.prototype._getItem = function (id, types) {
    var field, value, i, len;

    // get the item from the dataset
    var raw = this._data[id];
    if (!raw) {
      return null;
    }

    // convert the items field types
    var converted = {},
        fields = Object.keys(raw);

    if (types) {
      for (i = 0, len = fields.length; i < len; i++) {
        field = fields[i];
        value = raw[field];
        converted[field] = util.convert(value, types[field]);
      }
    } else {
      // no field types specified, no converting needed
      for (i = 0, len = fields.length; i < len; i++) {
        field = fields[i];
        value = raw[field];
        converted[field] = value;
      }
    }
    return converted;
  };

  /**
   * Update a single item: merge with existing item.
   * Will fail when the item has no id, or when there does not exist an item
   * with the same id.
   * @param {Object} item
   * @return {String} id
   * @private
   */
  DataSet.prototype._updateItem = function (item) {
    var id = item[this._fieldId];
    if (id == undefined) {
      throw new Error('Cannot update item: item has no id (item: ' + JSON.stringify(item) + ')');
    }
    var d = this._data[id];
    if (!d) {
      // item doesn't exist
      throw new Error('Cannot update item: no item with id ' + id + ' found');
    }

    // merge with current item
    var fields = Object.keys(item);
    for (var i = 0, len = fields.length; i < len; i++) {
      var field = fields[i];
      var fieldType = this._type[field]; // type may be undefined
      d[field] = util.convert(item[field], fieldType);
    }

    return id;
  };

  module.exports = DataSet;

/***/ },
/* 10 */
/***/ function(module, exports) {

  'use strict';

  /**
   * A queue
   * @param {Object} options
   *            Available options:
   *            - delay: number    When provided, the queue will be flushed
   *                               automatically after an inactivity of this delay
   *                               in milliseconds.
   *                               Default value is null.
   *            - max: number      When the queue exceeds the given maximum number
   *                               of entries, the queue is flushed automatically.
   *                               Default value of max is Infinity.
   * @constructor
   */
  function Queue(options) {
    // options
    this.delay = null;
    this.max = Infinity;

    // properties
    this._queue = [];
    this._timeout = null;
    this._extended = null;

    this.setOptions(options);
  }

  /**
   * Update the configuration of the queue
   * @param {Object} options
   *            Available options:
   *            - delay: number    When provided, the queue will be flushed
   *                               automatically after an inactivity of this delay
   *                               in milliseconds.
   *                               Default value is null.
   *            - max: number      When the queue exceeds the given maximum number
   *                               of entries, the queue is flushed automatically.
   *                               Default value of max is Infinity.
   * @param options
   */
  Queue.prototype.setOptions = function (options) {
    if (options && typeof options.delay !== 'undefined') {
      this.delay = options.delay;
    }
    if (options && typeof options.max !== 'undefined') {
      this.max = options.max;
    }

    this._flushIfNeeded();
  };

  /**
   * Extend an object with queuing functionality.
   * The object will be extended with a function flush, and the methods provided
   * in options.replace will be replaced with queued ones.
   * @param {Object} object
   * @param {Object} options
   *            Available options:
   *            - replace: Array.<string>
   *                               A list with method names of the methods
   *                               on the object to be replaced with queued ones.
   *            - delay: number    When provided, the queue will be flushed
   *                               automatically after an inactivity of this delay
   *                               in milliseconds.
   *                               Default value is null.
   *            - max: number      When the queue exceeds the given maximum number
   *                               of entries, the queue is flushed automatically.
   *                               Default value of max is Infinity.
   * @return {Queue} Returns the created queue
   */
  Queue.extend = function (object, options) {
    var queue = new Queue(options);

    if (object.flush !== undefined) {
      throw new Error('Target object already has a property flush');
    }
    object.flush = function () {
      queue.flush();
    };

    var methods = [{
      name: 'flush',
      original: undefined
    }];

    if (options && options.replace) {
      for (var i = 0; i < options.replace.length; i++) {
        var name = options.replace[i];
        methods.push({
          name: name,
          original: object[name]
        });
        queue.replace(object, name);
      }
    }

    queue._extended = {
      object: object,
      methods: methods
    };

    return queue;
  };

  /**
   * Destroy the queue. The queue will first flush all queued actions, and in
   * case it has extended an object, will restore the original object.
   */
  Queue.prototype.destroy = function () {
    this.flush();

    if (this._extended) {
      var object = this._extended.object;
      var methods = this._extended.methods;
      for (var i = 0; i < methods.length; i++) {
        var method = methods[i];
        if (method.original) {
          object[method.name] = method.original;
        } else {
          delete object[method.name];
        }
      }
      this._extended = null;
    }
  };

  /**
   * Replace a method on an object with a queued version
   * @param {Object} object   Object having the method
   * @param {string} method   The method name
   */
  Queue.prototype.replace = function (object, method) {
    var me = this;
    var original = object[method];
    if (!original) {
      throw new Error('Method ' + method + ' undefined');
    }

    object[method] = function () {
      // create an Array with the arguments
      var args = [];
      for (var i = 0; i < arguments.length; i++) {
        args[i] = arguments[i];
      }

      // add this call to the queue
      me.queue({
        args: args,
        fn: original,
        context: this
      });
    };
  };

  /**
   * Queue a call
   * @param {function | {fn: function, args: Array} | {fn: function, args: Array, context: Object}} entry
   */
  Queue.prototype.queue = function (entry) {
    if (typeof entry === 'function') {
      this._queue.push({ fn: entry });
    } else {
      this._queue.push(entry);
    }

    this._flushIfNeeded();
  };

  /**
   * Check whether the queue needs to be flushed
   * @private
   */
  Queue.prototype._flushIfNeeded = function () {
    // flush when the maximum is exceeded.
    if (this._queue.length > this.max) {
      this.flush();
    }

    // flush after a period of inactivity when a delay is configured
    clearTimeout(this._timeout);
    if (this.queue.length > 0 && typeof this.delay === 'number') {
      var me = this;
      this._timeout = setTimeout(function () {
        me.flush();
      }, this.delay);
    }
  };

  /**
   * Flush all queued calls
   */
  Queue.prototype.flush = function () {
    while (this._queue.length > 0) {
      var entry = this._queue.shift();
      entry.fn.apply(entry.context || entry.fn, entry.args || []);
    }
  };

  module.exports = Queue;

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var util = __webpack_require__(1);
  var DataSet = __webpack_require__(9);

  /**
   * DataView
   *
   * a dataview offers a filtered view on a dataset or an other dataview.
   *
   * @param {DataSet | DataView} data
   * @param {Object} [options]   Available options: see method get
   *
   * @constructor DataView
   */
  function DataView(data, options) {
    this._data = null;
    this._ids = {}; // ids of the items currently in memory (just contains a boolean true)
    this.length = 0; // number of items in the DataView
    this._options = options || {};
    this._fieldId = 'id'; // name of the field containing id
    this._subscribers = {}; // event subscribers

    var me = this;
    this.listener = function () {
      me._onEvent.apply(me, arguments);
    };

    this.setData(data);
  }

  // TODO: implement a function .config() to dynamically update things like configured filter
  // and trigger changes accordingly

  /**
   * Set a data source for the view
   * @param {DataSet | DataView} data
   */
  DataView.prototype.setData = function (data) {
    var ids, id, i, len;

    if (this._data) {
      // unsubscribe from current dataset
      if (this._data.off) {
        this._data.off('*', this.listener);
      }

      // trigger a remove of all items in memory
      ids = Object.keys(this._ids);
      this._ids = {};
      this.length = 0;
      this._trigger('remove', { items: ids });
    }

    this._data = data;

    if (this._data) {
      // update fieldId
      this._fieldId = this._options.fieldId || this._data && this._data.options && this._data.options.fieldId || 'id';

      // trigger an add of all added items
      ids = this._data.getIds({ filter: this._options && this._options.filter });
      for (i = 0, len = ids.length; i < len; i++) {
        id = ids[i];
        this._ids[id] = true;
      }
      this.length = ids.length;
      this._trigger('add', { items: ids });

      // subscribe to new dataset
      if (this._data.on) {
        this._data.on('*', this.listener);
      }
    }
  };

  /**
   * Refresh the DataView. Useful when the DataView has a filter function
   * containing a variable parameter.
   */
  DataView.prototype.refresh = function () {
    var id, i, len;
    var ids = this._data.getIds({ filter: this._options && this._options.filter });
    var oldIds = Object.keys(this._ids);
    var newIds = {};
    var added = [];
    var removed = [];

    // check for additions
    for (i = 0, len = ids.length; i < len; i++) {
      id = ids[i];
      newIds[id] = true;
      if (!this._ids[id]) {
        added.push(id);
        this._ids[id] = true;
      }
    }

    // check for removals
    for (i = 0, len = oldIds.length; i < len; i++) {
      id = oldIds[i];
      if (!newIds[id]) {
        removed.push(id);
        delete this._ids[id];
      }
    }

    this.length += added.length - removed.length;

    // trigger events
    if (added.length) {
      this._trigger('add', { items: added });
    }
    if (removed.length) {
      this._trigger('remove', { items: removed });
    }
  };

  /**
   * Get data from the data view
   *
   * Usage:
   *
   *     get()
   *     get(options: Object)
   *     get(options: Object, data: Array | DataTable)
   *
   *     get(id: Number)
   *     get(id: Number, options: Object)
   *     get(id: Number, options: Object, data: Array | DataTable)
   *
   *     get(ids: Number[])
   *     get(ids: Number[], options: Object)
   *     get(ids: Number[], options: Object, data: Array | DataTable)
   *
   * Where:
   *
   * {Number | String} id         The id of an item
   * {Number[] | String{}} ids    An array with ids of items
   * {Object} options             An Object with options. Available options:
   *                              {String} [type] Type of data to be returned. Can
   *                                              be 'DataTable' or 'Array' (default)
   *                              {Object.<String, String>} [convert]
   *                              {String[]} [fields] field names to be returned
   *                              {function} [filter] filter items
   *                              {String | function} [order] Order the items by
   *                                  a field name or custom sort function.
   * {Array | DataTable} [data]   If provided, items will be appended to this
   *                              array or table. Required in case of Google
   *                              DataTable.
   * @param args
   */
  DataView.prototype.get = function (args) {
    var me = this;

    // parse the arguments
    var ids, options, data;
    var firstType = util.getType(arguments[0]);
    if (firstType == 'String' || firstType == 'Number' || firstType == 'Array') {
      // get(id(s) [, options] [, data])
      ids = arguments[0]; // can be a single id or an array with ids
      options = arguments[1];
      data = arguments[2];
    } else {
      // get([, options] [, data])
      options = arguments[0];
      data = arguments[1];
    }

    // extend the options with the default options and provided options
    var viewOptions = util.extend({}, this._options, options);

    // create a combined filter method when needed
    if (this._options.filter && options && options.filter) {
      viewOptions.filter = function (item) {
        return me._options.filter(item) && options.filter(item);
      };
    }

    // build up the call to the linked data set
    var getArguments = [];
    if (ids != undefined) {
      getArguments.push(ids);
    }
    getArguments.push(viewOptions);
    getArguments.push(data);

    return this._data && this._data.get.apply(this._data, getArguments);
  };

  /**
   * Get ids of all items or from a filtered set of items.
   * @param {Object} [options]    An Object with options. Available options:
   *                              {function} [filter] filter items
   *                              {String | function} [order] Order the items by
   *                                  a field name or custom sort function.
   * @return {Array} ids
   */
  DataView.prototype.getIds = function (options) {
    var ids;

    if (this._data) {
      var defaultFilter = this._options.filter;
      var filter;

      if (options && options.filter) {
        if (defaultFilter) {
          filter = function filter(item) {
            return defaultFilter(item) && options.filter(item);
          };
        } else {
          filter = options.filter;
        }
      } else {
        filter = defaultFilter;
      }

      ids = this._data.getIds({
        filter: filter,
        order: options && options.order
      });
    } else {
      ids = [];
    }

    return ids;
  };

  /**
   * Map every item in the dataset.
   * @param {function} callback
   * @param {Object} [options]    Available options:
   *                              {Object.<String, String>} [type]
   *                              {String[]} [fields] filter fields
   *                              {function} [filter] filter items
   *                              {String | function} [order] Order the items by
   *                                  a field name or custom sort function.
   * @return {Object[]} mappedItems
   */
  DataView.prototype.map = function (callback, options) {
    var mappedItems = [];
    if (this._data) {
      var defaultFilter = this._options.filter;
      var filter;

      if (options && options.filter) {
        if (defaultFilter) {
          filter = function filter(item) {
            return defaultFilter(item) && options.filter(item);
          };
        } else {
          filter = options.filter;
        }
      } else {
        filter = defaultFilter;
      }

      mappedItems = this._data.map(callback, {
        filter: filter,
        order: options && options.order
      });
    } else {
      mappedItems = [];
    }

    return mappedItems;
  };

  /**
   * Get the DataSet to which this DataView is connected. In case there is a chain
   * of multiple DataViews, the root DataSet of this chain is returned.
   * @return {DataSet} dataSet
   */
  DataView.prototype.getDataSet = function () {
    var dataSet = this;
    while (dataSet instanceof DataView) {
      dataSet = dataSet._data;
    }
    return dataSet || null;
  };

  /**
   * Event listener. Will propagate all events from the connected data set to
   * the subscribers of the DataView, but will filter the items and only trigger
   * when there are changes in the filtered data set.
   * @param {String} event
   * @param {Object | null} params
   * @param {String} senderId
   * @private
   */
  DataView.prototype._onEvent = function (event, params, senderId) {
    var i, len, id, item;
    var ids = params && params.items;
    var data = this._data;
    var updatedData = [];
    var added = [];
    var updated = [];
    var removed = [];

    if (ids && data) {
      switch (event) {
        case 'add':
          // filter the ids of the added items
          for (i = 0, len = ids.length; i < len; i++) {
            id = ids[i];
            item = this.get(id);
            if (item) {
              this._ids[id] = true;
              added.push(id);
            }
          }

          break;

        case 'update':
          // determine the event from the views viewpoint: an updated
          // item can be added, updated, or removed from this view.
          for (i = 0, len = ids.length; i < len; i++) {
            id = ids[i];
            item = this.get(id);

            if (item) {
              if (this._ids[id]) {
                updated.push(id);
                updatedData.push(params.data[i]);
              } else {
                this._ids[id] = true;
                added.push(id);
              }
            } else {
              if (this._ids[id]) {
                delete this._ids[id];
                removed.push(id);
              } else {
                // nothing interesting for me :-(
              }
            }
          }

          break;

        case 'remove':
          // filter the ids of the removed items
          for (i = 0, len = ids.length; i < len; i++) {
            id = ids[i];
            if (this._ids[id]) {
              delete this._ids[id];
              removed.push(id);
            }
          }

          break;
      }

      this.length += added.length - removed.length;

      if (added.length) {
        this._trigger('add', { items: added }, senderId);
      }
      if (updated.length) {
        this._trigger('update', { items: updated, data: updatedData }, senderId);
      }
      if (removed.length) {
        this._trigger('remove', { items: removed }, senderId);
      }
    }
  };

  // copy subscription functionality from DataSet
  DataView.prototype.on = DataSet.prototype.on;
  DataView.prototype.off = DataSet.prototype.off;
  DataView.prototype._trigger = DataSet.prototype._trigger;

  // TODO: make these functions deprecated (replaced with `on` and `off` since version 0.5)
  DataView.prototype.subscribe = DataView.prototype.on;
  DataView.prototype.unsubscribe = DataView.prototype.off;

  module.exports = DataView;

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

  var Emitter = __webpack_require__(13);
  var DataSet = __webpack_require__(9);
  var DataView = __webpack_require__(11);
  var util = __webpack_require__(1);
  var Point3d = __webpack_require__(14);
  var Point2d = __webpack_require__(15);
  var Camera = __webpack_require__(16);
  var Filter = __webpack_require__(17);
  var Slider = __webpack_require__(18);
  var StepNumber = __webpack_require__(19);

  /**
   * @constructor Graph3d
   * Graph3d displays data in 3d.
   *
   * Graph3d is developed in javascript as a Google Visualization Chart.
   *
   * @param {Element} container   The DOM element in which the Graph3d will
   *                              be created. Normally a div element.
   * @param {DataSet | DataView | Array} [data]
   * @param {Object} [options]
   */
  function Graph3d(container, data, options) {
    if (!(this instanceof Graph3d)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    // create variables and set default values
    this.containerElement = container;
    this.width = '400px';
    this.height = '400px';
    this.margin = 10; // px
    this.defaultXCenter = '55%';
    this.defaultYCenter = '50%';

    this.xLabel = 'x';
    this.yLabel = 'y';
    this.zLabel = 'z';

    var passValueFn = function passValueFn(v) {
      return v;
    };
    this.xValueLabel = passValueFn;
    this.yValueLabel = passValueFn;
    this.zValueLabel = passValueFn;

    this.filterLabel = 'time';
    this.legendLabel = 'value';

    this.style = Graph3d.STYLE.DOT;
    this.showPerspective = true;
    this.showGrid = true;
    this.keepAspectRatio = true;
    this.showShadow = false;
    this.showGrayBottom = false; // TODO: this does not work correctly
    this.showTooltip = false;
    this.verticalRatio = 0.5; // 0.1 to 1.0, where 1.0 results in a 'cube'

    this.animationInterval = 1000; // milliseconds
    this.animationPreload = false;

    this.camera = new Camera();
    this.camera.setArmRotation(1.0, 0.5);
    this.camera.setArmLength(1.7);
    this.eye = new Point3d(0, 0, -1); // TODO: set eye.z about 3/4 of the width of the window?

    this.dataTable = null; // The original data table
    this.dataPoints = null; // The table with point objects

    // the column indexes
    this.colX = undefined;
    this.colY = undefined;
    this.colZ = undefined;
    this.colValue = undefined;
    this.colFilter = undefined;

    this.xMin = 0;
    this.xStep = undefined; // auto by default
    this.xMax = 1;
    this.yMin = 0;
    this.yStep = undefined; // auto by default
    this.yMax = 1;
    this.zMin = 0;
    this.zStep = undefined; // auto by default
    this.zMax = 1;
    this.valueMin = 0;
    this.valueMax = 1;
    this.xBarWidth = 1;
    this.yBarWidth = 1;
    // TODO: customize axis range

    // colors
    this.axisColor = '#4D4D4D';
    this.gridColor = '#D3D3D3';
    this.dataColor = {
      fill: '#7DC1FF',
      stroke: '#3267D2',
      strokeWidth: 1 // px
    };

    this.dotSizeRatio = 0.02; // size of the dots as a fraction of the graph width

    // create a frame and canvas
    this.create();

    // apply options (also when undefined)
    this.setOptions(options);

    // apply data
    if (data) {
      this.setData(data);
    }
  }

  // Extend Graph3d with an Emitter mixin
  Emitter(Graph3d.prototype);

  /**
   * Calculate the scaling values, dependent on the range in x, y, and z direction
   */
  Graph3d.prototype._setScale = function () {
    this.scale = new Point3d(1 / (this.xMax - this.xMin), 1 / (this.yMax - this.yMin), 1 / (this.zMax - this.zMin));

    // keep aspect ration between x and y scale if desired
    if (this.keepAspectRatio) {
      if (this.scale.x < this.scale.y) {
        //noinspection JSSuspiciousNameCombination
        this.scale.y = this.scale.x;
      } else {
        //noinspection JSSuspiciousNameCombination
        this.scale.x = this.scale.y;
      }
    }

    // scale the vertical axis
    this.scale.z *= this.verticalRatio;
    // TODO: can this be automated? verticalRatio?

    // determine scale for (optional) value
    this.scale.value = 1 / (this.valueMax - this.valueMin);

    // position the camera arm
    var xCenter = (this.xMax + this.xMin) / 2 * this.scale.x;
    var yCenter = (this.yMax + this.yMin) / 2 * this.scale.y;
    var zCenter = (this.zMax + this.zMin) / 2 * this.scale.z;
    this.camera.setArmLocation(xCenter, yCenter, zCenter);
  };

  /**
   * Convert a 3D location to a 2D location on screen
   * http://en.wikipedia.org/wiki/3D_projection
   * @param {Point3d} point3d   A 3D point with parameters x, y, z
   * @return {Point2d} point2d  A 2D point with parameters x, y
   */
  Graph3d.prototype._convert3Dto2D = function (point3d) {
    var translation = this._convertPointToTranslation(point3d);
    return this._convertTranslationToScreen(translation);
  };

  /**
   * Convert a 3D location its translation seen from the camera
   * http://en.wikipedia.org/wiki/3D_projection
   * @param {Point3d} point3d    A 3D point with parameters x, y, z
   * @return {Point3d} translation A 3D point with parameters x, y, z This is
   *                   the translation of the point, seen from the
   *                   camera
   */
  Graph3d.prototype._convertPointToTranslation = function (point3d) {
    var ax = point3d.x * this.scale.x,
        ay = point3d.y * this.scale.y,
        az = point3d.z * this.scale.z,
        cx = this.camera.getCameraLocation().x,
        cy = this.camera.getCameraLocation().y,
        cz = this.camera.getCameraLocation().z,


    // calculate angles
    sinTx = Math.sin(this.camera.getCameraRotation().x),
        cosTx = Math.cos(this.camera.getCameraRotation().x),
        sinTy = Math.sin(this.camera.getCameraRotation().y),
        cosTy = Math.cos(this.camera.getCameraRotation().y),
        sinTz = Math.sin(this.camera.getCameraRotation().z),
        cosTz = Math.cos(this.camera.getCameraRotation().z),


    // calculate translation
    dx = cosTy * (sinTz * (ay - cy) + cosTz * (ax - cx)) - sinTy * (az - cz),
        dy = sinTx * (cosTy * (az - cz) + sinTy * (sinTz * (ay - cy) + cosTz * (ax - cx))) + cosTx * (cosTz * (ay - cy) - sinTz * (ax - cx)),
        dz = cosTx * (cosTy * (az - cz) + sinTy * (sinTz * (ay - cy) + cosTz * (ax - cx))) - sinTx * (cosTz * (ay - cy) - sinTz * (ax - cx));

    return new Point3d(dx, dy, dz);
  };

  /**
   * Convert a translation point to a point on the screen
   * @param {Point3d} translation   A 3D point with parameters x, y, z This is
   *                    the translation of the point, seen from the
   *                    camera
   * @return {Point2d} point2d    A 2D point with parameters x, y
   */
  Graph3d.prototype._convertTranslationToScreen = function (translation) {
    var ex = this.eye.x,
        ey = this.eye.y,
        ez = this.eye.z,
        dx = translation.x,
        dy = translation.y,
        dz = translation.z;

    // calculate position on screen from translation
    var bx;
    var by;
    if (this.showPerspective) {
      bx = (dx - ex) * (ez / dz);
      by = (dy - ey) * (ez / dz);
    } else {
      bx = dx * -(ez / this.camera.getArmLength());
      by = dy * -(ez / this.camera.getArmLength());
    }

    // shift and scale the point to the center of the screen
    // use the width of the graph to scale both horizontally and vertically.
    return new Point2d(this.xcenter + bx * this.frame.canvas.clientWidth, this.ycenter - by * this.frame.canvas.clientWidth);
  };

  /**
   * Set the background styling for the graph
   * @param {string | {fill: string, stroke: string, strokeWidth: string}} backgroundColor
   */
  Graph3d.prototype._setBackgroundColor = function (backgroundColor) {
    var fill = 'white';
    var stroke = 'gray';
    var strokeWidth = 1;

    if (typeof backgroundColor === 'string') {
      fill = backgroundColor;
      stroke = 'none';
      strokeWidth = 0;
    } else if ((typeof backgroundColor === 'undefined' ? 'undefined' : _typeof(backgroundColor)) === 'object') {
      if (backgroundColor.fill !== undefined) fill = backgroundColor.fill;
      if (backgroundColor.stroke !== undefined) stroke = backgroundColor.stroke;
      if (backgroundColor.strokeWidth !== undefined) strokeWidth = backgroundColor.strokeWidth;
    } else if (backgroundColor === undefined) {
      // use use defaults
    } else {
        throw 'Unsupported type of backgroundColor';
      }

    this.frame.style.backgroundColor = fill;
    this.frame.style.borderColor = stroke;
    this.frame.style.borderWidth = strokeWidth + 'px';
    this.frame.style.borderStyle = 'solid';
  };

  /// enumerate the available styles
  Graph3d.STYLE = {
    BAR: 0,
    BARCOLOR: 1,
    BARSIZE: 2,
    DOT: 3,
    DOTLINE: 4,
    DOTCOLOR: 5,
    DOTSIZE: 6,
    GRID: 7,
    LINE: 8,
    SURFACE: 9
  };

  /**
   * Retrieve the style index from given styleName
   * @param {string} styleName  Style name such as 'dot', 'grid', 'dot-line'
   * @return {Number} styleNumber Enumeration value representing the style, or -1
   *                when not found
   */
  Graph3d.prototype._getStyleNumber = function (styleName) {
    switch (styleName) {
      case 'dot':
        return Graph3d.STYLE.DOT;
      case 'dot-line':
        return Graph3d.STYLE.DOTLINE;
      case 'dot-color':
        return Graph3d.STYLE.DOTCOLOR;
      case 'dot-size':
        return Graph3d.STYLE.DOTSIZE;
      case 'line':
        return Graph3d.STYLE.LINE;
      case 'grid':
        return Graph3d.STYLE.GRID;
      case 'surface':
        return Graph3d.STYLE.SURFACE;
      case 'bar':
        return Graph3d.STYLE.BAR;
      case 'bar-color':
        return Graph3d.STYLE.BARCOLOR;
      case 'bar-size':
        return Graph3d.STYLE.BARSIZE;
    }

    return -1;
  };

  /**
   * Determine the indexes of the data columns, based on the given style and data
   * @param {DataSet} data
   * @param {Number}  style
   */
  Graph3d.prototype._determineColumnIndexes = function (data, style) {
    if (this.style === Graph3d.STYLE.DOT || this.style === Graph3d.STYLE.DOTLINE || this.style === Graph3d.STYLE.LINE || this.style === Graph3d.STYLE.GRID || this.style === Graph3d.STYLE.SURFACE || this.style === Graph3d.STYLE.BAR) {
      // 3 columns expected, and optionally a 4th with filter values
      this.colX = 0;
      this.colY = 1;
      this.colZ = 2;
      this.colValue = undefined;

      if (data.getNumberOfColumns() > 3) {
        this.colFilter = 3;
      }
    } else if (this.style === Graph3d.STYLE.DOTCOLOR || this.style === Graph3d.STYLE.DOTSIZE || this.style === Graph3d.STYLE.BARCOLOR || this.style === Graph3d.STYLE.BARSIZE) {
      // 4 columns expected, and optionally a 5th with filter values
      this.colX = 0;
      this.colY = 1;
      this.colZ = 2;
      this.colValue = 3;

      if (data.getNumberOfColumns() > 4) {
        this.colFilter = 4;
      }
    } else {
      throw 'Unknown style "' + this.style + '"';
    }
  };

  Graph3d.prototype.getNumberOfRows = function (data) {
    return data.length;
  };

  Graph3d.prototype.getNumberOfColumns = function (data) {
    var counter = 0;
    for (var column in data[0]) {
      if (data[0].hasOwnProperty(column)) {
        counter++;
      }
    }
    return counter;
  };

  Graph3d.prototype.getDistinctValues = function (data, column) {
    var distinctValues = [];
    for (var i = 0; i < data.length; i++) {
      if (distinctValues.indexOf(data[i][column]) == -1) {
        distinctValues.push(data[i][column]);
      }
    }
    return distinctValues;
  };

  Graph3d.prototype.getColumnRange = function (data, column) {
    var minMax = { min: data[0][column], max: data[0][column] };
    for (var i = 0; i < data.length; i++) {
      if (minMax.min > data[i][column]) {
        minMax.min = data[i][column];
      }
      if (minMax.max < data[i][column]) {
        minMax.max = data[i][column];
      }
    }
    return minMax;
  };

  /**
   * Initialize the data from the data table. Calculate minimum and maximum values
   * and column index values
   * @param {Array | DataSet | DataView} rawData   The data containing the items for the Graph.
   * @param {Number}     style   Style Number
   */
  Graph3d.prototype._dataInitialize = function (rawData, style) {
    var me = this;

    // unsubscribe from the dataTable
    if (this.dataSet) {
      this.dataSet.off('*', this._onChange);
    }

    if (rawData === undefined) return;

    if (Array.isArray(rawData)) {
      rawData = new DataSet(rawData);
    }

    var data;
    if (rawData instanceof DataSet || rawData instanceof DataView) {
      data = rawData.get();
    } else {
      throw new Error('Array, DataSet, or DataView expected');
    }

    if (data.length == 0) return;

    this.dataSet = rawData;
    this.dataTable = data;

    // subscribe to changes in the dataset
    this._onChange = function () {
      me.setData(me.dataSet);
    };
    this.dataSet.on('*', this._onChange);

    // _determineColumnIndexes
    // getNumberOfRows (points)
    // getNumberOfColumns (x,y,z,v,t,t1,t2...)
    // getDistinctValues (unique values?)
    // getColumnRange

    // determine the location of x,y,z,value,filter columns
    this.colX = 'x';
    this.colY = 'y';
    this.colZ = 'z';
    this.colValue = 'style';
    this.colFilter = 'filter';

    // check if a filter column is provided
    if (data[0].hasOwnProperty('filter')) {
      if (this.dataFilter === undefined) {
        this.dataFilter = new Filter(rawData, this.colFilter, this);
        this.dataFilter.setOnLoadCallback(function () {
          me.redraw();
        });
      }
    }

    var withBars = this.style == Graph3d.STYLE.BAR || this.style == Graph3d.STYLE.BARCOLOR || this.style == Graph3d.STYLE.BARSIZE;

    // determine barWidth from data
    if (withBars) {
      if (this.defaultXBarWidth !== undefined) {
        this.xBarWidth = this.defaultXBarWidth;
      } else {
        var dataX = this.getDistinctValues(data, this.colX);
        this.xBarWidth = dataX[1] - dataX[0] || 1;
      }

      if (this.defaultYBarWidth !== undefined) {
        this.yBarWidth = this.defaultYBarWidth;
      } else {
        var dataY = this.getDistinctValues(data, this.colY);
        this.yBarWidth = dataY[1] - dataY[0] || 1;
      }
    }

    // calculate minimums and maximums
    var xRange = this.getColumnRange(data, this.colX);
    if (withBars) {
      xRange.min -= this.xBarWidth / 2;
      xRange.max += this.xBarWidth / 2;
    }
    this.xMin = this.defaultXMin !== undefined ? this.defaultXMin : xRange.min;
    this.xMax = this.defaultXMax !== undefined ? this.defaultXMax : xRange.max;
    if (this.xMax <= this.xMin) this.xMax = this.xMin + 1;
    this.xStep = this.defaultXStep !== undefined ? this.defaultXStep : (this.xMax - this.xMin) / 5;

    var yRange = this.getColumnRange(data, this.colY);
    if (withBars) {
      yRange.min -= this.yBarWidth / 2;
      yRange.max += this.yBarWidth / 2;
    }
    this.yMin = this.defaultYMin !== undefined ? this.defaultYMin : yRange.min;
    this.yMax = this.defaultYMax !== undefined ? this.defaultYMax : yRange.max;
    if (this.yMax <= this.yMin) this.yMax = this.yMin + 1;
    this.yStep = this.defaultYStep !== undefined ? this.defaultYStep : (this.yMax - this.yMin) / 5;

    var zRange = this.getColumnRange(data, this.colZ);
    this.zMin = this.defaultZMin !== undefined ? this.defaultZMin : zRange.min;
    this.zMax = this.defaultZMax !== undefined ? this.defaultZMax : zRange.max;
    if (this.zMax <= this.zMin) this.zMax = this.zMin + 1;
    this.zStep = this.defaultZStep !== undefined ? this.defaultZStep : (this.zMax - this.zMin) / 5;

    if (this.colValue !== undefined) {
      var valueRange = this.getColumnRange(data, this.colValue);
      this.valueMin = this.defaultValueMin !== undefined ? this.defaultValueMin : valueRange.min;
      this.valueMax = this.defaultValueMax !== undefined ? this.defaultValueMax : valueRange.max;
      if (this.valueMax <= this.valueMin) this.valueMax = this.valueMin + 1;
    }

    // set the scale dependent on the ranges.
    this._setScale();
  };

  /**
   * Filter the data based on the current filter
   * @param {Array} data
   * @return {Array} dataPoints   Array with point objects which can be drawn on screen
   */
  Graph3d.prototype._getDataPoints = function (data) {
    // TODO: store the created matrix dataPoints in the filters instead of reloading each time
    var x, y, i, z, obj, point;

    var dataPoints = [];

    if (this.style === Graph3d.STYLE.GRID || this.style === Graph3d.STYLE.SURFACE) {
      // copy all values from the google data table to a matrix
      // the provided values are supposed to form a grid of (x,y) positions

      // create two lists with all present x and y values
      var dataX = [];
      var dataY = [];
      for (i = 0; i < this.getNumberOfRows(data); i++) {
        x = data[i][this.colX] || 0;
        y = data[i][this.colY] || 0;

        if (dataX.indexOf(x) === -1) {
          dataX.push(x);
        }
        if (dataY.indexOf(y) === -1) {
          dataY.push(y);
        }
      }

      var sortNumber = function sortNumber(a, b) {
        return a - b;
      };
      dataX.sort(sortNumber);
      dataY.sort(sortNumber);

      // create a grid, a 2d matrix, with all values.
      var dataMatrix = []; // temporary data matrix
      for (i = 0; i < data.length; i++) {
        x = data[i][this.colX] || 0;
        y = data[i][this.colY] || 0;
        z = data[i][this.colZ] || 0;

        var xIndex = dataX.indexOf(x); // TODO: implement Array().indexOf() for Internet Explorer
        var yIndex = dataY.indexOf(y);

        if (dataMatrix[xIndex] === undefined) {
          dataMatrix[xIndex] = [];
        }

        var point3d = new Point3d();
        point3d.x = x;
        point3d.y = y;
        point3d.z = z;

        obj = {};
        obj.point = point3d;
        obj.trans = undefined;
        obj.screen = undefined;
        obj.bottom = new Point3d(x, y, this.zMin);

        dataMatrix[xIndex][yIndex] = obj;

        dataPoints.push(obj);
      }

      // fill in the pointers to the neighbors.
      for (x = 0; x < dataMatrix.length; x++) {
        for (y = 0; y < dataMatrix[x].length; y++) {
          if (dataMatrix[x][y]) {
            dataMatrix[x][y].pointRight = x < dataMatrix.length - 1 ? dataMatrix[x + 1][y] : undefined;
            dataMatrix[x][y].pointTop = y < dataMatrix[x].length - 1 ? dataMatrix[x][y + 1] : undefined;
            dataMatrix[x][y].pointCross = x < dataMatrix.length - 1 && y < dataMatrix[x].length - 1 ? dataMatrix[x + 1][y + 1] : undefined;
          }
        }
      }
    } else {
      // 'dot', 'dot-line', etc.
      // copy all values from the google data table to a list with Point3d objects
      for (i = 0; i < data.length; i++) {
        point = new Point3d();
        point.x = data[i][this.colX] || 0;
        point.y = data[i][this.colY] || 0;
        point.z = data[i][this.colZ] || 0;

        if (this.colValue !== undefined) {
          point.value = data[i][this.colValue] || 0;
        }

        obj = {};
        obj.point = point;
        obj.bottom = new Point3d(point.x, point.y, this.zMin);
        obj.trans = undefined;
        obj.screen = undefined;

        dataPoints.push(obj);
      }
    }

    return dataPoints;
  };

  /**
   * Create the main frame for the Graph3d.
   * This function is executed once when a Graph3d object is created. The frame
   * contains a canvas, and this canvas contains all objects like the axis and
   * nodes.
   */
  Graph3d.prototype.create = function () {
    // remove all elements from the container element.
    while (this.containerElement.hasChildNodes()) {
      this.containerElement.removeChild(this.containerElement.firstChild);
    }

    this.frame = document.createElement('div');
    this.frame.style.position = 'relative';
    this.frame.style.overflow = 'hidden';

    // create the graph canvas (HTML canvas element)
    this.frame.canvas = document.createElement('canvas');
    this.frame.canvas.style.position = 'relative';
    this.frame.appendChild(this.frame.canvas);
    //if (!this.frame.canvas.getContext) {
    {
      var noCanvas = document.createElement('DIV');
      noCanvas.style.color = 'red';
      noCanvas.style.fontWeight = 'bold';
      noCanvas.style.padding = '10px';
      noCanvas.innerHTML = 'Error: your browser does not support HTML canvas';
      this.frame.canvas.appendChild(noCanvas);
    }

    this.frame.filter = document.createElement('div');
    this.frame.filter.style.position = 'absolute';
    this.frame.filter.style.bottom = '0px';
    this.frame.filter.style.left = '0px';
    this.frame.filter.style.width = '100%';
    this.frame.appendChild(this.frame.filter);

    // add event listeners to handle moving and zooming the contents
    var me = this;
    var onmousedown = function onmousedown(event) {
      me._onMouseDown(event);
    };
    var ontouchstart = function ontouchstart(event) {
      me._onTouchStart(event);
    };
    var onmousewheel = function onmousewheel(event) {
      me._onWheel(event);
    };
    var ontooltip = function ontooltip(event) {
      me._onTooltip(event);
    };
    // TODO: these events are never cleaned up... can give a 'memory leakage'

    util.addEventListener(this.frame.canvas, 'keydown', onkeydown);
    util.addEventListener(this.frame.canvas, 'mousedown', onmousedown);
    util.addEventListener(this.frame.canvas, 'touchstart', ontouchstart);
    util.addEventListener(this.frame.canvas, 'mousewheel', onmousewheel);
    util.addEventListener(this.frame.canvas, 'mousemove', ontooltip);

    // add the new graph to the container element
    this.containerElement.appendChild(this.frame);
  };

  /**
   * Set a new size for the graph
   * @param {string} width   Width in pixels or percentage (for example '800px'
   *             or '50%')
   * @param {string} height  Height in pixels or percentage  (for example '400px'
   *             or '30%')
   */
  Graph3d.prototype.setSize = function (width, height) {
    this.frame.style.width = width;
    this.frame.style.height = height;

    this._resizeCanvas();
  };

  /**
   * Resize the canvas to the current size of the frame
   */
  Graph3d.prototype._resizeCanvas = function () {
    this.frame.canvas.style.width = '100%';
    this.frame.canvas.style.height = '100%';

    this.frame.canvas.width = this.frame.canvas.clientWidth;
    this.frame.canvas.height = this.frame.canvas.clientHeight;

    // adjust with for margin
    this.frame.filter.style.width = this.frame.canvas.clientWidth - 2 * 10 + 'px';
  };

  /**
   * Start animation
   */
  Graph3d.prototype.animationStart = function () {
    if (!this.frame.filter || !this.frame.filter.slider) throw 'No animation available';

    this.frame.filter.slider.play();
  };

  /**
   * Stop animation
   */
  Graph3d.prototype.animationStop = function () {
    if (!this.frame.filter || !this.frame.filter.slider) return;

    this.frame.filter.slider.stop();
  };

  /**
   * Resize the center position based on the current values in this.defaultXCenter
   * and this.defaultYCenter (which are strings with a percentage or a value
   * in pixels). The center positions are the variables this.xCenter
   * and this.yCenter
   */
  Graph3d.prototype._resizeCenter = function () {
    // calculate the horizontal center position
    if (this.defaultXCenter.charAt(this.defaultXCenter.length - 1) === '%') {
      this.xcenter = parseFloat(this.defaultXCenter) / 100 * this.frame.canvas.clientWidth;
    } else {
      this.xcenter = parseFloat(this.defaultXCenter); // supposed to be in px
    }

    // calculate the vertical center position
    if (this.defaultYCenter.charAt(this.defaultYCenter.length - 1) === '%') {
      this.ycenter = parseFloat(this.defaultYCenter) / 100 * (this.frame.canvas.clientHeight - this.frame.filter.clientHeight);
    } else {
      this.ycenter = parseFloat(this.defaultYCenter); // supposed to be in px
    }
  };

  /**
   * Set the rotation and distance of the camera
   * @param {Object} pos   An object with the camera position. The object
   *             contains three parameters:
   *             - horizontal {Number}
   *             The horizontal rotation, between 0 and 2*PI.
   *             Optional, can be left undefined.
   *             - vertical {Number}
   *             The vertical rotation, between 0 and 0.5*PI
   *             if vertical=0.5*PI, the graph is shown from the
   *             top. Optional, can be left undefined.
   *             - distance {Number}
   *             The (normalized) distance of the camera to the
   *             center of the graph, a value between 0.71 and 5.0.
   *             Optional, can be left undefined.
   */
  Graph3d.prototype.setCameraPosition = function (pos) {
    if (pos === undefined) {
      return;
    }

    if (pos.horizontal !== undefined && pos.vertical !== undefined) {
      this.camera.setArmRotation(pos.horizontal, pos.vertical);
    }

    if (pos.distance !== undefined) {
      this.camera.setArmLength(pos.distance);
    }

    this.redraw();
  };

  /**
   * Retrieve the current camera rotation
   * @return {object}   An object with parameters horizontal, vertical, and
   *          distance
   */
  Graph3d.prototype.getCameraPosition = function () {
    var pos = this.camera.getArmRotation();
    pos.distance = this.camera.getArmLength();
    return pos;
  };

  /**
   * Load data into the 3D Graph
   */
  Graph3d.prototype._readData = function (data) {
    // read the data
    this._dataInitialize(data, this.style);

    if (this.dataFilter) {
      // apply filtering
      this.dataPoints = this.dataFilter._getDataPoints();
    } else {
      // no filtering. load all data
      this.dataPoints = this._getDataPoints(this.dataTable);
    }

    // draw the filter
    this._redrawFilter();
  };

  /**
   * Replace the dataset of the Graph3d
   * @param {Array | DataSet | DataView} data
   */
  Graph3d.prototype.setData = function (data) {
    this._readData(data);
    this.redraw();

    // start animation when option is true
    if (this.animationAutoStart && this.dataFilter) {
      this.animationStart();
    }
  };

  /**
   * Update the options. Options will be merged with current options
   * @param {Object} options
   */
  Graph3d.prototype.setOptions = function (options) {
    var cameraPosition = undefined;

    this.animationStop();

    if (options !== undefined) {
      // retrieve parameter values
      if (options.width !== undefined) this.width = options.width;
      if (options.height !== undefined) this.height = options.height;

      if (options.xCenter !== undefined) this.defaultXCenter = options.xCenter;
      if (options.yCenter !== undefined) this.defaultYCenter = options.yCenter;

      if (options.filterLabel !== undefined) this.filterLabel = options.filterLabel;
      if (options.legendLabel !== undefined) this.legendLabel = options.legendLabel;
      if (options.xLabel !== undefined) this.xLabel = options.xLabel;
      if (options.yLabel !== undefined) this.yLabel = options.yLabel;
      if (options.zLabel !== undefined) this.zLabel = options.zLabel;

      if (options.xValueLabel !== undefined) this.xValueLabel = options.xValueLabel;
      if (options.yValueLabel !== undefined) this.yValueLabel = options.yValueLabel;
      if (options.zValueLabel !== undefined) this.zValueLabel = options.zValueLabel;

      if (options.dotSizeRatio !== undefined) this.dotSizeRatio = options.dotSizeRatio;

      if (options.style !== undefined) {
        var styleNumber = this._getStyleNumber(options.style);
        if (styleNumber !== -1) {
          this.style = styleNumber;
        }
      }
      if (options.showGrid !== undefined) this.showGrid = options.showGrid;
      if (options.showPerspective !== undefined) this.showPerspective = options.showPerspective;
      if (options.showShadow !== undefined) this.showShadow = options.showShadow;
      if (options.tooltip !== undefined) this.showTooltip = options.tooltip;
      if (options.showAnimationControls !== undefined) this.showAnimationControls = options.showAnimationControls;
      if (options.keepAspectRatio !== undefined) this.keepAspectRatio = options.keepAspectRatio;
      if (options.verticalRatio !== undefined) this.verticalRatio = options.verticalRatio;

      if (options.animationInterval !== undefined) this.animationInterval = options.animationInterval;
      if (options.animationPreload !== undefined) this.animationPreload = options.animationPreload;
      if (options.animationAutoStart !== undefined) this.animationAutoStart = options.animationAutoStart;

      if (options.xBarWidth !== undefined) this.defaultXBarWidth = options.xBarWidth;
      if (options.yBarWidth !== undefined) this.defaultYBarWidth = options.yBarWidth;

      if (options.xMin !== undefined) this.defaultXMin = options.xMin;
      if (options.xStep !== undefined) this.defaultXStep = options.xStep;
      if (options.xMax !== undefined) this.defaultXMax = options.xMax;
      if (options.yMin !== undefined) this.defaultYMin = options.yMin;
      if (options.yStep !== undefined) this.defaultYStep = options.yStep;
      if (options.yMax !== undefined) this.defaultYMax = options.yMax;
      if (options.zMin !== undefined) this.defaultZMin = options.zMin;
      if (options.zStep !== undefined) this.defaultZStep = options.zStep;
      if (options.zMax !== undefined) this.defaultZMax = options.zMax;
      if (options.valueMin !== undefined) this.defaultValueMin = options.valueMin;
      if (options.valueMax !== undefined) this.defaultValueMax = options.valueMax;
      if (options.backgroundColor !== undefined) this._setBackgroundColor(options.backgroundColor);

      if (options.cameraPosition !== undefined) cameraPosition = options.cameraPosition;

      if (cameraPosition !== undefined) {
        this.camera.setArmRotation(cameraPosition.horizontal, cameraPosition.vertical);
        this.camera.setArmLength(cameraPosition.distance);
      }

      // colors
      if (options.axisColor !== undefined) this.axisColor = options.axisColor;
      if (options.gridColor !== undefined) this.gridColor = options.gridColor;
      if (options.dataColor) {
        if (typeof options.dataColor === 'string') {
          this.dataColor.fill = options.dataColor;
          this.dataColor.stroke = options.dataColor;
        } else {
          if (options.dataColor.fill) {
            this.dataColor.fill = options.dataColor.fill;
          }
          if (options.dataColor.stroke) {
            this.dataColor.stroke = options.dataColor.stroke;
          }
          if (options.dataColor.strokeWidth !== undefined) {
            this.dataColor.strokeWidth = options.dataColor.strokeWidth;
          }
        }
      }
    }

    this.setSize(this.width, this.height);

    // re-load the data
    if (this.dataTable) {
      this.setData(this.dataTable);
    }

    // start animation when option is true
    if (this.animationAutoStart && this.dataFilter) {
      this.animationStart();
    }
  };

  /**
   * Redraw the Graph.
   */
  Graph3d.prototype.redraw = function () {
    if (this.dataPoints === undefined) {
      throw 'Error: graph data not initialized';
    }

    this._resizeCanvas();
    this._resizeCenter();
    this._redrawSlider();
    this._redrawClear();
    this._redrawAxis();

    if (this.style === Graph3d.STYLE.GRID || this.style === Graph3d.STYLE.SURFACE) {
      this._redrawDataGrid();
    } else if (this.style === Graph3d.STYLE.LINE) {
      this._redrawDataLine();
    } else if (this.style === Graph3d.STYLE.BAR || this.style === Graph3d.STYLE.BARCOLOR || this.style === Graph3d.STYLE.BARSIZE) {
      this._redrawDataBar();
    } else {
      // style is DOT, DOTLINE, DOTCOLOR, DOTSIZE
      this._redrawDataDot();
    }

    this._redrawInfo();
    this._redrawLegend();
  };

  /**
   * Clear the canvas before redrawing
   */
  Graph3d.prototype._redrawClear = function () {
    var canvas = this.frame.canvas;
    var ctx = canvas.getContext('2d');

    ctx.clearRect(0, 0, canvas.width, canvas.height);
  };

  /**
   * Redraw the legend showing the colors
   */
  Graph3d.prototype._redrawLegend = function () {
    var y;

    if (this.style === Graph3d.STYLE.DOTCOLOR || this.style === Graph3d.STYLE.DOTSIZE) {

      var dotSize = this.frame.clientWidth * this.dotSizeRatio;

      var widthMin, widthMax;
      if (this.style === Graph3d.STYLE.DOTSIZE) {
        widthMin = dotSize / 2; // px
        widthMax = dotSize / 2 + dotSize * 2; // Todo: put this in one function
      } else {
          widthMin = 20; // px
          widthMax = 20; // px
        }

      var height = Math.max(this.frame.clientHeight * 0.25, 100);
      var top = this.margin;
      var right = this.frame.clientWidth - this.margin;
      var left = right - widthMax;
      var bottom = top + height;
    }

    var canvas = this.frame.canvas;
    var ctx = canvas.getContext('2d');
    ctx.lineWidth = 1;
    ctx.font = '14px arial'; // TODO: put in options

    if (this.style === Graph3d.STYLE.DOTCOLOR) {
      // draw the color bar
      var ymin = 0;
      var ymax = height; // Todo: make height customizable
      for (y = ymin; y < ymax; y++) {
        var f = (y - ymin) / (ymax - ymin);

        //var width = (dotSize / 2 + (1-f) * dotSize * 2); // Todo: put this in one function
        var hue = f * 240;
        var color = this._hsv2rgb(hue, 1, 1);

        ctx.strokeStyle = color;
        ctx.beginPath();
        ctx.moveTo(left, top + y);
        ctx.lineTo(right, top + y);
        ctx.stroke();
      }

      ctx.strokeStyle = this.axisColor;
      ctx.strokeRect(left, top, widthMax, height);
    }

    if (this.style === Graph3d.STYLE.DOTSIZE) {
      // draw border around color bar
      ctx.strokeStyle = this.axisColor;
      ctx.fillStyle = this.dataColor.fill;
      ctx.beginPath();
      ctx.moveTo(left, top);
      ctx.lineTo(right, top);
      ctx.lineTo(right - widthMax + widthMin, bottom);
      ctx.lineTo(left, bottom);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    }

    if (this.style === Graph3d.STYLE.DOTCOLOR || this.style === Graph3d.STYLE.DOTSIZE) {
      // print values along the color bar
      var gridLineLen = 5; // px
      var step = new StepNumber(this.valueMin, this.valueMax, (this.valueMax - this.valueMin) / 5, true);
      step.start();
      if (step.getCurrent() < this.valueMin) {
        step.next();
      }
      while (!step.end()) {
        y = bottom - (step.getCurrent() - this.valueMin) / (this.valueMax - this.valueMin) * height;

        ctx.beginPath();
        ctx.moveTo(left - gridLineLen, y);
        ctx.lineTo(left, y);
        ctx.stroke();

        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = this.axisColor;
        ctx.fillText(step.getCurrent(), left - 2 * gridLineLen, y);

        step.next();
      }

      ctx.textAlign = 'right';
      ctx.textBaseline = 'top';
      var label = this.legendLabel;
      ctx.fillText(label, right, bottom + this.margin);
    }
  };

  /**
   * Redraw the filter
   */
  Graph3d.prototype._redrawFilter = function () {
    this.frame.filter.innerHTML = '';

    if (this.dataFilter) {
      var options = {
        'visible': this.showAnimationControls
      };
      var slider = new Slider(this.frame.filter, options);
      this.frame.filter.slider = slider;

      // TODO: css here is not nice here...
      this.frame.filter.style.padding = '10px';
      //this.frame.filter.style.backgroundColor = '#EFEFEF';

      slider.setValues(this.dataFilter.values);
      slider.setPlayInterval(this.animationInterval);

      // create an event handler
      var me = this;
      var onchange = function onchange() {
        var index = slider.getIndex();

        me.dataFilter.selectValue(index);
        me.dataPoints = me.dataFilter._getDataPoints();

        me.redraw();
      };
      slider.setOnChangeCallback(onchange);
    } else {
      this.frame.filter.slider = undefined;
    }
  };

  /**
   * Redraw the slider
   */
  Graph3d.prototype._redrawSlider = function () {
    if (this.frame.filter.slider !== undefined) {
      this.frame.filter.slider.redraw();
    }
  };

  /**
   * Redraw common information
   */
  Graph3d.prototype._redrawInfo = function () {
    if (this.dataFilter) {
      var canvas = this.frame.canvas;
      var ctx = canvas.getContext('2d');

      ctx.font = '14px arial'; // TODO: put in options
      ctx.lineStyle = 'gray';
      ctx.fillStyle = 'gray';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';

      var x = this.margin;
      var y = this.margin;
      ctx.fillText(this.dataFilter.getLabel() + ': ' + this.dataFilter.getSelectedValue(), x, y);
    }
  };

  /**
   * Redraw the axis
   */
  Graph3d.prototype._redrawAxis = function () {
    var canvas = this.frame.canvas,
        ctx = canvas.getContext('2d'),
        from,
        to,
        step,
        prettyStep,
        text,
        xText,
        yText,
        zText,
        offset,
        xOffset,
        yOffset,
        xMin2d,
        xMax2d;

    // TODO: get the actual rendered style of the containerElement
    //ctx.font = this.containerElement.style.font;
    ctx.font = 24 / this.camera.getArmLength() + 'px arial';

    // calculate the length for the short grid lines
    var gridLenX = 0.025 / this.scale.x;
    var gridLenY = 0.025 / this.scale.y;
    var textMargin = 5 / this.camera.getArmLength(); // px
    var armAngle = this.camera.getArmRotation().horizontal;

    // draw x-grid lines
    ctx.lineWidth = 1;
    prettyStep = this.defaultXStep === undefined;
    step = new StepNumber(this.xMin, this.xMax, this.xStep, prettyStep);
    step.start();
    if (step.getCurrent() < this.xMin) {
      step.next();
    }
    while (!step.end()) {
      var x = step.getCurrent();

      if (this.showGrid) {
        from = this._convert3Dto2D(new Point3d(x, this.yMin, this.zMin));
        to = this._convert3Dto2D(new Point3d(x, this.yMax, this.zMin));
        ctx.strokeStyle = this.gridColor;
        ctx.beginPath();
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(to.x, to.y);
        ctx.stroke();
      } else {
        from = this._convert3Dto2D(new Point3d(x, this.yMin, this.zMin));
        to = this._convert3Dto2D(new Point3d(x, this.yMin + gridLenX, this.zMin));
        ctx.strokeStyle = this.axisColor;
        ctx.beginPath();
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(to.x, to.y);
        ctx.stroke();

        from = this._convert3Dto2D(new Point3d(x, this.yMax, this.zMin));
        to = this._convert3Dto2D(new Point3d(x, this.yMax - gridLenX, this.zMin));
        ctx.strokeStyle = this.axisColor;
        ctx.beginPath();
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(to.x, to.y);
        ctx.stroke();
      }

      yText = Math.cos(armAngle) > 0 ? this.yMin : this.yMax;
      text = this._convert3Dto2D(new Point3d(x, yText, this.zMin));
      if (Math.cos(armAngle * 2) > 0) {
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        text.y += textMargin;
      } else if (Math.sin(armAngle * 2) < 0) {
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
      } else {
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
      }
      ctx.fillStyle = this.axisColor;
      ctx.fillText('  ' + this.xValueLabel(step.getCurrent()) + '  ', text.x, text.y);

      step.next();
    }

    // draw y-grid lines
    ctx.lineWidth = 1;
    prettyStep = this.defaultYStep === undefined;
    step = new StepNumber(this.yMin, this.yMax, this.yStep, prettyStep);
    step.start();
    if (step.getCurrent() < this.yMin) {
      step.next();
    }
    while (!step.end()) {
      if (this.showGrid) {
        from = this._convert3Dto2D(new Point3d(this.xMin, step.getCurrent(), this.zMin));
        to = this._convert3Dto2D(new Point3d(this.xMax, step.getCurrent(), this.zMin));
        ctx.strokeStyle = this.gridColor;
        ctx.beginPath();
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(to.x, to.y);
        ctx.stroke();
      } else {
        from = this._convert3Dto2D(new Point3d(this.xMin, step.getCurrent(), this.zMin));
        to = this._convert3Dto2D(new Point3d(this.xMin + gridLenY, step.getCurrent(), this.zMin));
        ctx.strokeStyle = this.axisColor;
        ctx.beginPath();
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(to.x, to.y);
        ctx.stroke();

        from = this._convert3Dto2D(new Point3d(this.xMax, step.getCurrent(), this.zMin));
        to = this._convert3Dto2D(new Point3d(this.xMax - gridLenY, step.getCurrent(), this.zMin));
        ctx.strokeStyle = this.axisColor;
        ctx.beginPath();
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(to.x, to.y);
        ctx.stroke();
      }

      xText = Math.sin(armAngle) > 0 ? this.xMin : this.xMax;
      text = this._convert3Dto2D(new Point3d(xText, step.getCurrent(), this.zMin));
      if (Math.cos(armAngle * 2) < 0) {
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        text.y += textMargin;
      } else if (Math.sin(armAngle * 2) > 0) {
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
      } else {
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
      }
      ctx.fillStyle = this.axisColor;
      ctx.fillText('  ' + this.yValueLabel(step.getCurrent()) + '  ', text.x, text.y);

      step.next();
    }

    // draw z-grid lines and axis
    ctx.lineWidth = 1;
    prettyStep = this.defaultZStep === undefined;
    step = new StepNumber(this.zMin, this.zMax, this.zStep, prettyStep);
    step.start();
    if (step.getCurrent() < this.zMin) {
      step.next();
    }
    xText = Math.cos(armAngle) > 0 ? this.xMin : this.xMax;
    yText = Math.sin(armAngle) < 0 ? this.yMin : this.yMax;
    while (!step.end()) {
      // TODO: make z-grid lines really 3d?
      from = this._convert3Dto2D(new Point3d(xText, yText, step.getCurrent()));
      ctx.strokeStyle = this.axisColor;
      ctx.beginPath();
      ctx.moveTo(from.x, from.y);
      ctx.lineTo(from.x - textMargin, from.y);
      ctx.stroke();

      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = this.axisColor;
      ctx.fillText(this.zValueLabel(step.getCurrent()) + ' ', from.x - 5, from.y);

      step.next();
    }
    ctx.lineWidth = 1;
    from = this._convert3Dto2D(new Point3d(xText, yText, this.zMin));
    to = this._convert3Dto2D(new Point3d(xText, yText, this.zMax));
    ctx.strokeStyle = this.axisColor;
    ctx.beginPath();
    ctx.moveTo(from.x, from.y);
    ctx.lineTo(to.x, to.y);
    ctx.stroke();

    // draw x-axis
    ctx.lineWidth = 1;
    // line at yMin
    xMin2d = this._convert3Dto2D(new Point3d(this.xMin, this.yMin, this.zMin));
    xMax2d = this._convert3Dto2D(new Point3d(this.xMax, this.yMin, this.zMin));
    ctx.strokeStyle = this.axisColor;
    ctx.beginPath();
    ctx.moveTo(xMin2d.x, xMin2d.y);
    ctx.lineTo(xMax2d.x, xMax2d.y);
    ctx.stroke();
    // line at ymax
    xMin2d = this._convert3Dto2D(new Point3d(this.xMin, this.yMax, this.zMin));
    xMax2d = this._convert3Dto2D(new Point3d(this.xMax, this.yMax, this.zMin));
    ctx.strokeStyle = this.axisColor;
    ctx.beginPath();
    ctx.moveTo(xMin2d.x, xMin2d.y);
    ctx.lineTo(xMax2d.x, xMax2d.y);
    ctx.stroke();

    // draw y-axis
    ctx.lineWidth = 1;
    // line at xMin
    from = this._convert3Dto2D(new Point3d(this.xMin, this.yMin, this.zMin));
    to = this._convert3Dto2D(new Point3d(this.xMin, this.yMax, this.zMin));
    ctx.strokeStyle = this.axisColor;
    ctx.beginPath();
    ctx.moveTo(from.x, from.y);
    ctx.lineTo(to.x, to.y);
    ctx.stroke();
    // line at xMax
    from = this._convert3Dto2D(new Point3d(this.xMax, this.yMin, this.zMin));
    to = this._convert3Dto2D(new Point3d(this.xMax, this.yMax, this.zMin));
    ctx.strokeStyle = this.axisColor;
    ctx.beginPath();
    ctx.moveTo(from.x, from.y);
    ctx.lineTo(to.x, to.y);
    ctx.stroke();

    // draw x-label
    var xLabel = this.xLabel;
    if (xLabel.length > 0) {
      yOffset = 0.1 / this.scale.y;
      xText = (this.xMin + this.xMax) / 2;
      yText = Math.cos(armAngle) > 0 ? this.yMin - yOffset : this.yMax + yOffset;
      text = this._convert3Dto2D(new Point3d(xText, yText, this.zMin));
      if (Math.cos(armAngle * 2) > 0) {
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
      } else if (Math.sin(armAngle * 2) < 0) {
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
      } else {
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
      }
      ctx.fillStyle = this.axisColor;
      ctx.fillText(xLabel, text.x, text.y);
    }

    // draw y-label
    var yLabel = this.yLabel;
    if (yLabel.length > 0) {
      xOffset = 0.1 / this.scale.x;
      xText = Math.sin(armAngle) > 0 ? this.xMin - xOffset : this.xMax + xOffset;
      yText = (this.yMin + this.yMax) / 2;
      text = this._convert3Dto2D(new Point3d(xText, yText, this.zMin));
      if (Math.cos(armAngle * 2) < 0) {
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
      } else if (Math.sin(armAngle * 2) > 0) {
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
      } else {
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
      }
      ctx.fillStyle = this.axisColor;
      ctx.fillText(yLabel, text.x, text.y);
    }

    // draw z-label
    var zLabel = this.zLabel;
    if (zLabel.length > 0) {
      offset = 30; // pixels.  // TODO: relate to the max width of the values on the z axis?
      xText = Math.cos(armAngle) > 0 ? this.xMin : this.xMax;
      yText = Math.sin(armAngle) < 0 ? this.yMin : this.yMax;
      zText = (this.zMin + this.zMax) / 2;
      text = this._convert3Dto2D(new Point3d(xText, yText, zText));
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = this.axisColor;
      ctx.fillText(zLabel, text.x - offset, text.y);
    }
  };

  /**
   * Calculate the color based on the given value.
   * @param {Number} H   Hue, a value be between 0 and 360
   * @param {Number} S   Saturation, a value between 0 and 1
   * @param {Number} V   Value, a value between 0 and 1
   */
  Graph3d.prototype._hsv2rgb = function (H, S, V) {
    var R, G, B, C, Hi, X;

    C = V * S;
    Hi = Math.floor(H / 60); // hi = 0,1,2,3,4,5
    X = C * (1 - Math.abs(H / 60 % 2 - 1));

    switch (Hi) {
      case 0:
        R = C;G = X;B = 0;break;
      case 1:
        R = X;G = C;B = 0;break;
      case 2:
        R = 0;G = C;B = X;break;
      case 3:
        R = 0;G = X;B = C;break;
      case 4:
        R = X;G = 0;B = C;break;
      case 5:
        R = C;G = 0;B = X;break;

      default:
        R = 0;G = 0;B = 0;break;
    }

    return 'RGB(' + parseInt(R * 255) + ',' + parseInt(G * 255) + ',' + parseInt(B * 255) + ')';
  };

  /**
   * Draw all datapoints as a grid
   * This function can be used when the style is 'grid'
   */
  Graph3d.prototype._redrawDataGrid = function () {
    var canvas = this.frame.canvas,
        ctx = canvas.getContext('2d'),
        point,
        right,
        top,
        cross,
        i,
        topSideVisible,
        fillStyle,
        strokeStyle,
        lineWidth,
        h,
        s,
        v,
        zAvg;

    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';

    if (this.dataPoints === undefined || this.dataPoints.length <= 0) return; // TODO: throw exception?

    // calculate the translations and screen position of all points
    for (i = 0; i < this.dataPoints.length; i++) {
      var trans = this._convertPointToTranslation(this.dataPoints[i].point);
      var screen = this._convertTranslationToScreen(trans);

      this.dataPoints[i].trans = trans;
      this.dataPoints[i].screen = screen;

      // calculate the translation of the point at the bottom (needed for sorting)
      var transBottom = this._convertPointToTranslation(this.dataPoints[i].bottom);
      this.dataPoints[i].dist = this.showPerspective ? transBottom.length() : -transBottom.z;
    }

    // sort the points on depth of their (x,y) position (not on z)
    var sortDepth = function sortDepth(a, b) {
      return b.dist - a.dist;
    };
    this.dataPoints.sort(sortDepth);

    if (this.style === Graph3d.STYLE.SURFACE) {
      for (i = 0; i < this.dataPoints.length; i++) {
        point = this.dataPoints[i];
        right = this.dataPoints[i].pointRight;
        top = this.dataPoints[i].pointTop;
        cross = this.dataPoints[i].pointCross;

        if (point !== undefined && right !== undefined && top !== undefined && cross !== undefined) {

          if (this.showGrayBottom || this.showShadow) {
            // calculate the cross product of the two vectors from center
            // to left and right, in order to know whether we are looking at the
            // bottom or at the top side. We can also use the cross product
            // for calculating light intensity
            var aDiff = Point3d.subtract(cross.trans, point.trans);
            var bDiff = Point3d.subtract(top.trans, right.trans);
            var crossproduct = Point3d.crossProduct(aDiff, bDiff);
            var len = crossproduct.length();
            // FIXME: there is a bug with determining the surface side (shadow or colored)

            topSideVisible = crossproduct.z > 0;
          } else {
            topSideVisible = true;
          }

          if (topSideVisible) {
            // calculate Hue from the current value. At zMin the hue is 240, at zMax the hue is 0
            zAvg = (point.point.z + right.point.z + top.point.z + cross.point.z) / 4;
            h = (1 - (zAvg - this.zMin) * this.scale.z / this.verticalRatio) * 240;
            s = 1; // saturation

            if (this.showShadow) {
              v = Math.min(1 + crossproduct.x / len / 2, 1); // value. TODO: scale
              fillStyle = this._hsv2rgb(h, s, v);
              strokeStyle = fillStyle;
            } else {
              v = 1;
              fillStyle = this._hsv2rgb(h, s, v);
              strokeStyle = this.axisColor; // TODO: should be customizable
            }
          } else {
              fillStyle = 'gray';
              strokeStyle = this.axisColor;
            }

          ctx.lineWidth = this._getStrokeWidth(point);
          ctx.fillStyle = fillStyle;
          ctx.strokeStyle = strokeStyle;
          ctx.beginPath();
          ctx.moveTo(point.screen.x, point.screen.y);
          ctx.lineTo(right.screen.x, right.screen.y);
          ctx.lineTo(cross.screen.x, cross.screen.y);
          ctx.lineTo(top.screen.x, top.screen.y);
          ctx.closePath();
          ctx.fill();
          ctx.stroke(); // TODO: only draw stroke when strokeWidth > 0
        }
      }
    } else {
        // grid style
        for (i = 0; i < this.dataPoints.length; i++) {
          point = this.dataPoints[i];
          right = this.dataPoints[i].pointRight;
          top = this.dataPoints[i].pointTop;

          if (point !== undefined && right !== undefined) {
            // calculate Hue from the current value. At zMin the hue is 240, at zMax the hue is 0
            zAvg = (point.point.z + right.point.z) / 2;
            h = (1 - (zAvg - this.zMin) * this.scale.z / this.verticalRatio) * 240;

            ctx.lineWidth = this._getStrokeWidth(point) * 2;
            ctx.strokeStyle = this._hsv2rgb(h, 1, 1);
            ctx.beginPath();
            ctx.moveTo(point.screen.x, point.screen.y);
            ctx.lineTo(right.screen.x, right.screen.y);
            ctx.stroke();
          }

          if (point !== undefined && top !== undefined) {
            // calculate Hue from the current value. At zMin the hue is 240, at zMax the hue is 0
            zAvg = (point.point.z + top.point.z) / 2;
            h = (1 - (zAvg - this.zMin) * this.scale.z / this.verticalRatio) * 240;

            ctx.lineWidth = this._getStrokeWidth(point) * 2;
            ctx.strokeStyle = this._hsv2rgb(h, 1, 1);
            ctx.beginPath();
            ctx.moveTo(point.screen.x, point.screen.y);
            ctx.lineTo(top.screen.x, top.screen.y);
            ctx.stroke();
          }
        }
      }
  };

  Graph3d.prototype._getStrokeWidth = function (point) {
    if (point !== undefined) {
      if (this.showPerspective) {
        return 1 / -point.trans.z * this.dataColor.strokeWidth;
      } else {
        return -(this.eye.z / this.camera.getArmLength()) * this.dataColor.strokeWidth;
      }
    }

    return this.dataColor.strokeWidth;
  };

  /**
   * Draw all datapoints as dots.
   * This function can be used when the style is 'dot' or 'dot-line'
   */
  Graph3d.prototype._redrawDataDot = function () {
    var canvas = this.frame.canvas;
    var ctx = canvas.getContext('2d');
    var i;

    if (this.dataPoints === undefined || this.dataPoints.length <= 0) return; // TODO: throw exception?

    // calculate the translations of all points
    for (i = 0; i < this.dataPoints.length; i++) {
      var trans = this._convertPointToTranslation(this.dataPoints[i].point);
      var screen = this._convertTranslationToScreen(trans);
      this.dataPoints[i].trans = trans;
      this.dataPoints[i].screen = screen;

      // calculate the distance from the point at the bottom to the camera
      var transBottom = this._convertPointToTranslation(this.dataPoints[i].bottom);
      this.dataPoints[i].dist = this.showPerspective ? transBottom.length() : -transBottom.z;
    }

    // order the translated points by depth
    var sortDepth = function sortDepth(a, b) {
      return b.dist - a.dist;
    };
    this.dataPoints.sort(sortDepth);

    // draw the datapoints as colored circles
    var dotSize = this.frame.clientWidth * this.dotSizeRatio; // px
    for (i = 0; i < this.dataPoints.length; i++) {
      var point = this.dataPoints[i];

      if (this.style === Graph3d.STYLE.DOTLINE) {
        // draw a vertical line from the bottom to the graph value
        //var from = this._convert3Dto2D(new Point3d(point.point.x, point.point.y, this.zMin));
        var from = this._convert3Dto2D(point.bottom);
        ctx.lineWidth = 1;
        ctx.strokeStyle = this.gridColor;
        ctx.beginPath();
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(point.screen.x, point.screen.y);
        ctx.stroke();
      }

      // calculate radius for the circle
      var size;
      if (this.style === Graph3d.STYLE.DOTSIZE) {
        size = dotSize / 2 + 2 * dotSize * (point.point.value - this.valueMin) / (this.valueMax - this.valueMin);
      } else {
        size = dotSize;
      }

      var radius;
      if (this.showPerspective) {
        radius = size / -point.trans.z;
      } else {
        radius = size * -(this.eye.z / this.camera.getArmLength());
      }
      if (radius < 0) {
        radius = 0;
      }

      var hue, color, borderColor;
      if (this.style === Graph3d.STYLE.DOTCOLOR) {
        // calculate the color based on the value
        hue = (1 - (point.point.value - this.valueMin) * this.scale.value) * 240;
        color = this._hsv2rgb(hue, 1, 1);
        borderColor = this._hsv2rgb(hue, 1, 0.8);
      } else if (this.style === Graph3d.STYLE.DOTSIZE) {
        color = this.dataColor.fill;
        borderColor = this.dataColor.stroke;
      } else {
        // calculate Hue from the current value. At zMin the hue is 240, at zMax the hue is 0
        hue = (1 - (point.point.z - this.zMin) * this.scale.z / this.verticalRatio) * 240;
        color = this._hsv2rgb(hue, 1, 1);
        borderColor = this._hsv2rgb(hue, 1, 0.8);
      }

      // draw the circle
      ctx.lineWidth = this._getStrokeWidth(point);
      ctx.strokeStyle = borderColor;
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(point.screen.x, point.screen.y, radius, 0, Math.PI * 2, true);
      ctx.fill();
      ctx.stroke();
    }
  };

  /**
   * Draw all datapoints as bars.
   * This function can be used when the style is 'bar', 'bar-color', or 'bar-size'
   */
  Graph3d.prototype._redrawDataBar = function () {
    var canvas = this.frame.canvas;
    var ctx = canvas.getContext('2d');
    var i, j, surface, corners;

    if (this.dataPoints === undefined || this.dataPoints.length <= 0) return; // TODO: throw exception?

    // calculate the translations of all points
    for (i = 0; i < this.dataPoints.length; i++) {
      var trans = this._convertPointToTranslation(this.dataPoints[i].point);
      var screen = this._convertTranslationToScreen(trans);
      this.dataPoints[i].trans = trans;
      this.dataPoints[i].screen = screen;

      // calculate the distance from the point at the bottom to the camera
      var transBottom = this._convertPointToTranslation(this.dataPoints[i].bottom);
      this.dataPoints[i].dist = this.showPerspective ? transBottom.length() : -transBottom.z;
    }

    // order the translated points by depth
    var sortDepth = function sortDepth(a, b) {
      return b.dist - a.dist;
    };
    this.dataPoints.sort(sortDepth);

    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';

    // draw the datapoints as bars
    var xWidth = this.xBarWidth / 2;
    var yWidth = this.yBarWidth / 2;
    for (i = 0; i < this.dataPoints.length; i++) {
      var point = this.dataPoints[i];

      // determine color
      var hue, color, borderColor;
      if (this.style === Graph3d.STYLE.BARCOLOR) {
        // calculate the color based on the value
        hue = (1 - (point.point.value - this.valueMin) * this.scale.value) * 240;
        color = this._hsv2rgb(hue, 1, 1);
        borderColor = this._hsv2rgb(hue, 1, 0.8);
      } else if (this.style === Graph3d.STYLE.BARSIZE) {
        color = this.dataColor.fill;
        borderColor = this.dataColor.stroke;
      } else {
        // calculate Hue from the current value. At zMin the hue is 240, at zMax the hue is 0
        hue = (1 - (point.point.z - this.zMin) * this.scale.z / this.verticalRatio) * 240;
        color = this._hsv2rgb(hue, 1, 1);
        borderColor = this._hsv2rgb(hue, 1, 0.8);
      }

      // calculate size for the bar
      if (this.style === Graph3d.STYLE.BARSIZE) {
        xWidth = this.xBarWidth / 2 * ((point.point.value - this.valueMin) / (this.valueMax - this.valueMin) * 0.8 + 0.2);
        yWidth = this.yBarWidth / 2 * ((point.point.value - this.valueMin) / (this.valueMax - this.valueMin) * 0.8 + 0.2);
      }

      // calculate all corner points
      var me = this;
      var point3d = point.point;
      var top = [{ point: new Point3d(point3d.x - xWidth, point3d.y - yWidth, point3d.z) }, { point: new Point3d(point3d.x + xWidth, point3d.y - yWidth, point3d.z) }, { point: new Point3d(point3d.x + xWidth, point3d.y + yWidth, point3d.z) }, { point: new Point3d(point3d.x - xWidth, point3d.y + yWidth, point3d.z) }];
      var bottom = [{ point: new Point3d(point3d.x - xWidth, point3d.y - yWidth, this.zMin) }, { point: new Point3d(point3d.x + xWidth, point3d.y - yWidth, this.zMin) }, { point: new Point3d(point3d.x + xWidth, point3d.y + yWidth, this.zMin) }, { point: new Point3d(point3d.x - xWidth, point3d.y + yWidth, this.zMin) }];

      // calculate screen location of the points
      top.forEach(function (obj) {
        obj.screen = me._convert3Dto2D(obj.point);
      });
      bottom.forEach(function (obj) {
        obj.screen = me._convert3Dto2D(obj.point);
      });

      // create five sides, calculate both corner points and center points
      var surfaces = [{ corners: top, center: Point3d.avg(bottom[0].point, bottom[2].point) }, { corners: [top[0], top[1], bottom[1], bottom[0]], center: Point3d.avg(bottom[1].point, bottom[0].point) }, { corners: [top[1], top[2], bottom[2], bottom[1]], center: Point3d.avg(bottom[2].point, bottom[1].point) }, { corners: [top[2], top[3], bottom[3], bottom[2]], center: Point3d.avg(bottom[3].point, bottom[2].point) }, { corners: [top[3], top[0], bottom[0], bottom[3]], center: Point3d.avg(bottom[0].point, bottom[3].point) }];
      point.surfaces = surfaces;

      // calculate the distance of each of the surface centers to the camera
      for (j = 0; j < surfaces.length; j++) {
        surface = surfaces[j];
        var transCenter = this._convertPointToTranslation(surface.center);
        surface.dist = this.showPerspective ? transCenter.length() : -transCenter.z;
        // TODO: this dept calculation doesn't work 100% of the cases due to perspective,
        //     but the current solution is fast/simple and works in 99.9% of all cases
        //     the issue is visible in example 14, with graph.setCameraPosition({horizontal: 2.97, vertical: 0.5, distance: 0.9})
      }

      // order the surfaces by their (translated) depth
      surfaces.sort(function (a, b) {
        var diff = b.dist - a.dist;
        if (diff) return diff;

        // if equal depth, sort the top surface last
        if (a.corners === top) return 1;
        if (b.corners === top) return -1;

        // both are equal
        return 0;
      });

      // draw the ordered surfaces
      ctx.lineWidth = this._getStrokeWidth(point);
      ctx.strokeStyle = borderColor;
      ctx.fillStyle = color;
      // NOTE: we start at j=2 instead of j=0 as we don't need to draw the two surfaces at the backside
      for (j = 2; j < surfaces.length; j++) {
        surface = surfaces[j];
        corners = surface.corners;
        ctx.beginPath();
        ctx.moveTo(corners[3].screen.x, corners[3].screen.y);
        ctx.lineTo(corners[0].screen.x, corners[0].screen.y);
        ctx.lineTo(corners[1].screen.x, corners[1].screen.y);
        ctx.lineTo(corners[2].screen.x, corners[2].screen.y);
        ctx.lineTo(corners[3].screen.x, corners[3].screen.y);
        ctx.fill();
        ctx.stroke();
      }
    }
  };

  /**
   * Draw a line through all datapoints.
   * This function can be used when the style is 'line'
   */
  Graph3d.prototype._redrawDataLine = function () {
    var canvas = this.frame.canvas,
        ctx = canvas.getContext('2d'),
        point,
        i;

    if (this.dataPoints === undefined || this.dataPoints.length <= 0) return; // TODO: throw exception?

    // calculate the translations of all points
    for (i = 0; i < this.dataPoints.length; i++) {
      var trans = this._convertPointToTranslation(this.dataPoints[i].point);
      var screen = this._convertTranslationToScreen(trans);

      this.dataPoints[i].trans = trans;
      this.dataPoints[i].screen = screen;
    }

    // start the line
    if (this.dataPoints.length > 0) {
      point = this.dataPoints[0];

      ctx.lineWidth = this._getStrokeWidth(point);
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      ctx.strokeStyle = this.dataColor.stroke;
      ctx.beginPath();
      ctx.moveTo(point.screen.x, point.screen.y);

      // draw the datapoints as colored circles
      for (i = 1; i < this.dataPoints.length; i++) {
        point = this.dataPoints[i];
        ctx.lineTo(point.screen.x, point.screen.y);
      }

      // finish the line
      ctx.stroke();
    }
  };

  /**
   * Start a moving operation inside the provided parent element
   * @param {Event}     event     The event that occurred (required for
   *                  retrieving the  mouse position)
   */
  Graph3d.prototype._onMouseDown = function (event) {
    event = event || window.event;

    // check if mouse is still down (may be up when focus is lost for example
    // in an iframe)
    if (this.leftButtonDown) {
      this._onMouseUp(event);
    }

    // only react on left mouse button down
    this.leftButtonDown = event.which ? event.which === 1 : event.button === 1;
    if (!this.leftButtonDown && !this.touchDown) return;

    // get mouse position (different code for IE and all other browsers)
    this.startMouseX = getMouseX(event);
    this.startMouseY = getMouseY(event);

    this.startStart = new Date(this.start);
    this.startEnd = new Date(this.end);
    this.startArmRotation = this.camera.getArmRotation();

    this.frame.style.cursor = 'move';

    // add event listeners to handle moving the contents
    // we store the function onmousemove and onmouseup in the graph, so we can
    // remove the eventlisteners lateron in the function mouseUp()
    var me = this;
    this.onmousemove = function (event) {
      me._onMouseMove(event);
    };
    this.onmouseup = function (event) {
      me._onMouseUp(event);
    };
    util.addEventListener(document, 'mousemove', me.onmousemove);
    util.addEventListener(document, 'mouseup', me.onmouseup);
    util.preventDefault(event);
  };

  /**
   * Perform moving operating.
   * This function activated from within the funcion Graph.mouseDown().
   * @param {Event}   event  Well, eehh, the event
   */
  Graph3d.prototype._onMouseMove = function (event) {
    event = event || window.event;

    // calculate change in mouse position
    var diffX = parseFloat(getMouseX(event)) - this.startMouseX;
    var diffY = parseFloat(getMouseY(event)) - this.startMouseY;

    var horizontalNew = this.startArmRotation.horizontal + diffX / 200;
    var verticalNew = this.startArmRotation.vertical + diffY / 200;

    var snapAngle = 4; // degrees
    var snapValue = Math.sin(snapAngle / 360 * 2 * Math.PI);

    // snap horizontally to nice angles at 0pi, 0.5pi, 1pi, 1.5pi, etc...
    // the -0.001 is to take care that the vertical axis is always drawn at the left front corner
    if (Math.abs(Math.sin(horizontalNew)) < snapValue) {
      horizontalNew = Math.round(horizontalNew / Math.PI) * Math.PI - 0.001;
    }
    if (Math.abs(Math.cos(horizontalNew)) < snapValue) {
      horizontalNew = (Math.round(horizontalNew / Math.PI - 0.5) + 0.5) * Math.PI - 0.001;
    }

    // snap vertically to nice angles
    if (Math.abs(Math.sin(verticalNew)) < snapValue) {
      verticalNew = Math.round(verticalNew / Math.PI) * Math.PI;
    }
    if (Math.abs(Math.cos(verticalNew)) < snapValue) {
      verticalNew = (Math.round(verticalNew / Math.PI - 0.5) + 0.5) * Math.PI;
    }

    this.camera.setArmRotation(horizontalNew, verticalNew);
    this.redraw();

    // fire a cameraPositionChange event
    var parameters = this.getCameraPosition();
    this.emit('cameraPositionChange', parameters);

    util.preventDefault(event);
  };

  /**
   * Stop moving operating.
   * This function activated from within the funcion Graph.mouseDown().
   * @param {event}  event   The event
   */
  Graph3d.prototype._onMouseUp = function (event) {
    this.frame.style.cursor = 'auto';
    this.leftButtonDown = false;

    // remove event listeners here
    util.removeEventListener(document, 'mousemove', this.onmousemove);
    util.removeEventListener(document, 'mouseup', this.onmouseup);
    util.preventDefault(event);
  };

  /**
   * After having moved the mouse, a tooltip should pop up when the mouse is resting on a data point
   * @param {Event}  event   A mouse move event
   */
  Graph3d.prototype._onTooltip = function (event) {
    var delay = 300; // ms
    var boundingRect = this.frame.getBoundingClientRect();
    var mouseX = getMouseX(event) - boundingRect.left;
    var mouseY = getMouseY(event) - boundingRect.top;

    if (!this.showTooltip) {
      return;
    }

    if (this.tooltipTimeout) {
      clearTimeout(this.tooltipTimeout);
    }

    // (delayed) display of a tooltip only if no mouse button is down
    if (this.leftButtonDown) {
      this._hideTooltip();
      return;
    }

    if (this.tooltip && this.tooltip.dataPoint) {
      // tooltip is currently visible
      var dataPoint = this._dataPointFromXY(mouseX, mouseY);
      if (dataPoint !== this.tooltip.dataPoint) {
        // datapoint changed
        if (dataPoint) {
          this._showTooltip(dataPoint);
        } else {
          this._hideTooltip();
        }
      }
    } else {
      // tooltip is currently not visible
      var me = this;
      this.tooltipTimeout = setTimeout(function () {
        me.tooltipTimeout = null;

        // show a tooltip if we have a data point
        var dataPoint = me._dataPointFromXY(mouseX, mouseY);
        if (dataPoint) {
          me._showTooltip(dataPoint);
        }
      }, delay);
    }
  };

  /**
   * Event handler for touchstart event on mobile devices
   */
  Graph3d.prototype._onTouchStart = function (event) {
    this.touchDown = true;

    var me = this;
    this.ontouchmove = function (event) {
      me._onTouchMove(event);
    };
    this.ontouchend = function (event) {
      me._onTouchEnd(event);
    };
    util.addEventListener(document, 'touchmove', me.ontouchmove);
    util.addEventListener(document, 'touchend', me.ontouchend);

    this._onMouseDown(event);
  };

  /**
   * Event handler for touchmove event on mobile devices
   */
  Graph3d.prototype._onTouchMove = function (event) {
    this._onMouseMove(event);
  };

  /**
   * Event handler for touchend event on mobile devices
   */
  Graph3d.prototype._onTouchEnd = function (event) {
    this.touchDown = false;

    util.removeEventListener(document, 'touchmove', this.ontouchmove);
    util.removeEventListener(document, 'touchend', this.ontouchend);

    this._onMouseUp(event);
  };

  /**
   * Event handler for mouse wheel event, used to zoom the graph
   * Code from http://adomas.org/javascript-mouse-wheel/
   * @param {event}  event   The event
   */
  Graph3d.prototype._onWheel = function (event) {
    if (!event) /* For IE. */
      event = window.event;

    // retrieve delta
    var delta = 0;
    if (event.wheelDelta) {
      /* IE/Opera. */
      delta = event.wheelDelta / 120;
    } else if (event.detail) {
      /* Mozilla case. */
      // In Mozilla, sign of delta is different than in IE.
      // Also, delta is multiple of 3.
      delta = -event.detail / 3;
    }

    // If delta is nonzero, handle it.
    // Basically, delta is now positive if wheel was scrolled up,
    // and negative, if wheel was scrolled down.
    if (delta) {
      var oldLength = this.camera.getArmLength();
      var newLength = oldLength * (1 - delta / 10);

      this.camera.setArmLength(newLength);
      this.redraw();

      this._hideTooltip();
    }

    // fire a cameraPositionChange event
    var parameters = this.getCameraPosition();
    this.emit('cameraPositionChange', parameters);

    // Prevent default actions caused by mouse wheel.
    // That might be ugly, but we handle scrolls somehow
    // anyway, so don't bother here..
    util.preventDefault(event);
  };

  /**
   * Test whether a point lies inside given 2D triangle
   * @param {Point2d} point
   * @param {Point2d[]} triangle
   * @return {boolean} Returns true if given point lies inside or on the edge of the triangle
   * @private
   */
  Graph3d.prototype._insideTriangle = function (point, triangle) {
    var a = triangle[0],
        b = triangle[1],
        c = triangle[2];

    function sign(x) {
      return x > 0 ? 1 : x < 0 ? -1 : 0;
    }

    var as = sign((b.x - a.x) * (point.y - a.y) - (b.y - a.y) * (point.x - a.x));
    var bs = sign((c.x - b.x) * (point.y - b.y) - (c.y - b.y) * (point.x - b.x));
    var cs = sign((a.x - c.x) * (point.y - c.y) - (a.y - c.y) * (point.x - c.x));

    // each of the three signs must be either equal to each other or zero
    return (as == 0 || bs == 0 || as == bs) && (bs == 0 || cs == 0 || bs == cs) && (as == 0 || cs == 0 || as == cs);
  };

  /**
   * Find a data point close to given screen position (x, y)
   * @param {Number} x
   * @param {Number} y
   * @return {Object | null} The closest data point or null if not close to any data point
   * @private
   */
  Graph3d.prototype._dataPointFromXY = function (x, y) {
    var i,
        distMax = 100,
        // px
    dataPoint = null,
        closestDataPoint = null,
        closestDist = null,
        center = new Point2d(x, y);

    if (this.style === Graph3d.STYLE.BAR || this.style === Graph3d.STYLE.BARCOLOR || this.style === Graph3d.STYLE.BARSIZE) {
      // the data points are ordered from far away to closest
      for (i = this.dataPoints.length - 1; i >= 0; i--) {
        dataPoint = this.dataPoints[i];
        var surfaces = dataPoint.surfaces;
        if (surfaces) {
          for (var s = surfaces.length - 1; s >= 0; s--) {
            // split each surface in two triangles, and see if the center point is inside one of these
            var surface = surfaces[s];
            var corners = surface.corners;
            var triangle1 = [corners[0].screen, corners[1].screen, corners[2].screen];
            var triangle2 = [corners[2].screen, corners[3].screen, corners[0].screen];
            if (this._insideTriangle(center, triangle1) || this._insideTriangle(center, triangle2)) {
              // return immediately at the first hit
              return dataPoint;
            }
          }
        }
      }
    } else {
      // find the closest data point, using distance to the center of the point on 2d screen
      for (i = 0; i < this.dataPoints.length; i++) {
        dataPoint = this.dataPoints[i];
        var point = dataPoint.screen;
        if (point) {
          var distX = Math.abs(x - point.x);
          var distY = Math.abs(y - point.y);
          var dist = Math.sqrt(distX * distX + distY * distY);

          if ((closestDist === null || dist < closestDist) && dist < distMax) {
            closestDist = dist;
            closestDataPoint = dataPoint;
          }
        }
      }
    }

    return closestDataPoint;
  };

  /**
   * Display a tooltip for given data point
   * @param {Object} dataPoint
   * @private
   */
  Graph3d.prototype._showTooltip = function (dataPoint) {
    var content, line, dot;

    if (!this.tooltip) {
      content = document.createElement('div');
      content.style.position = 'absolute';
      content.style.padding = '10px';
      content.style.border = '1px solid #4d4d4d';
      content.style.color = '#1a1a1a';
      content.style.background = 'rgba(255,255,255,0.7)';
      content.style.borderRadius = '2px';
      content.style.boxShadow = '5px 5px 10px rgba(128,128,128,0.5)';

      line = document.createElement('div');
      line.style.position = 'absolute';
      line.style.height = '40px';
      line.style.width = '0';
      line.style.borderLeft = '1px solid #4d4d4d';

      dot = document.createElement('div');
      dot.style.position = 'absolute';
      dot.style.height = '0';
      dot.style.width = '0';
      dot.style.border = '5px solid #4d4d4d';
      dot.style.borderRadius = '5px';

      this.tooltip = {
        dataPoint: null,
        dom: {
          content: content,
          line: line,
          dot: dot
        }
      };
    } else {
      content = this.tooltip.dom.content;
      line = this.tooltip.dom.line;
      dot = this.tooltip.dom.dot;
    }

    this._hideTooltip();

    this.tooltip.dataPoint = dataPoint;
    if (typeof this.showTooltip === 'function') {
      content.innerHTML = this.showTooltip(dataPoint.point);
    } else {
      content.innerHTML = '<table>' + '<tr><td>' + this.xLabel + ':</td><td>' + dataPoint.point.x + '</td></tr>' + '<tr><td>' + this.yLabel + ':</td><td>' + dataPoint.point.y + '</td></tr>' + '<tr><td>' + this.zLabel + ':</td><td>' + dataPoint.point.z + '</td></tr>' + '</table>';
    }

    content.style.left = '0';
    content.style.top = '0';
    this.frame.appendChild(content);
    this.frame.appendChild(line);
    this.frame.appendChild(dot);

    // calculate sizes
    var contentWidth = content.offsetWidth;
    var contentHeight = content.offsetHeight;
    var lineHeight = line.offsetHeight;
    var dotWidth = dot.offsetWidth;
    var dotHeight = dot.offsetHeight;

    var left = dataPoint.screen.x - contentWidth / 2;
    left = Math.min(Math.max(left, 10), this.frame.clientWidth - 10 - contentWidth);

    line.style.left = dataPoint.screen.x + 'px';
    line.style.top = dataPoint.screen.y - lineHeight + 'px';
    content.style.left = left + 'px';
    content.style.top = dataPoint.screen.y - lineHeight - contentHeight + 'px';
    dot.style.left = dataPoint.screen.x - dotWidth / 2 + 'px';
    dot.style.top = dataPoint.screen.y - dotHeight / 2 + 'px';
  };

  /**
   * Hide the tooltip when displayed
   * @private
   */
  Graph3d.prototype._hideTooltip = function () {
    if (this.tooltip) {
      this.tooltip.dataPoint = null;

      for (var prop in this.tooltip.dom) {
        if (this.tooltip.dom.hasOwnProperty(prop)) {
          var elem = this.tooltip.dom[prop];
          if (elem && elem.parentNode) {
            elem.parentNode.removeChild(elem);
          }
        }
      }
    }
  };

  /**--------------------------------------------------------------------------**/

  /**
   * Get the horizontal mouse position from a mouse event
   * @param {Event} event
   * @return {Number} mouse x
   */
  function getMouseX(event) {
    if ('clientX' in event) return event.clientX;
    return event.targetTouches[0] && event.targetTouches[0].clientX || 0;
  }

  /**
   * Get the vertical mouse position from a mouse event
   * @param {Event} event
   * @return {Number} mouse y
   */
  function getMouseY(event) {
    if ('clientY' in event) return event.clientY;
    return event.targetTouches[0] && event.targetTouches[0].clientY || 0;
  }

  module.exports = Graph3d;

/***/ },
/* 13 */
/***/ function(module, exports) {

  
  /**
   * Expose `Emitter`.
   */

  module.exports = Emitter;

  /**
   * Initialize a new `Emitter`.
   *
   * @api public
   */

  function Emitter(obj) {
    if (obj) return mixin(obj);
  };

  /**
   * Mixin the emitter properties.
   *
   * @param {Object} obj
   * @return {Object}
   * @api private
   */

  function mixin(obj) {
    for (var key in Emitter.prototype) {
      obj[key] = Emitter.prototype[key];
    }
    return obj;
  }

  /**
   * Listen on the given `event` with `fn`.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */

  Emitter.prototype.on =
  Emitter.prototype.addEventListener = function(event, fn){
    this._callbacks = this._callbacks || {};
    (this._callbacks[event] = this._callbacks[event] || [])
      .push(fn);
    return this;
  };

  /**
   * Adds an `event` listener that will be invoked a single
   * time then automatically removed.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */

  Emitter.prototype.once = function(event, fn){
    var self = this;
    this._callbacks = this._callbacks || {};

    function on() {
      self.off(event, on);
      fn.apply(this, arguments);
    }

    on.fn = fn;
    this.on(event, on);
    return this;
  };

  /**
   * Remove the given callback for `event` or all
   * registered callbacks.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */

  Emitter.prototype.off =
  Emitter.prototype.removeListener =
  Emitter.prototype.removeAllListeners =
  Emitter.prototype.removeEventListener = function(event, fn){
    this._callbacks = this._callbacks || {};

    // all
    if (0 == arguments.length) {
      this._callbacks = {};
      return this;
    }

    // specific event
    var callbacks = this._callbacks[event];
    if (!callbacks) return this;

    // remove all handlers
    if (1 == arguments.length) {
      delete this._callbacks[event];
      return this;
    }

    // remove specific handler
    var cb;
    for (var i = 0; i < callbacks.length; i++) {
      cb = callbacks[i];
      if (cb === fn || cb.fn === fn) {
        callbacks.splice(i, 1);
        break;
      }
    }
    return this;
  };

  /**
   * Emit `event` with the given args.
   *
   * @param {String} event
   * @param {Mixed} ...
   * @return {Emitter}
   */

  Emitter.prototype.emit = function(event){
    this._callbacks = this._callbacks || {};
    var args = [].slice.call(arguments, 1)
      , callbacks = this._callbacks[event];

    if (callbacks) {
      callbacks = callbacks.slice(0);
      for (var i = 0, len = callbacks.length; i < len; ++i) {
        callbacks[i].apply(this, args);
      }
    }

    return this;
  };

  /**
   * Return array of callbacks for `event`.
   *
   * @param {String} event
   * @return {Array}
   * @api public
   */

  Emitter.prototype.listeners = function(event){
    this._callbacks = this._callbacks || {};
    return this._callbacks[event] || [];
  };

  /**
   * Check if this emitter has `event` handlers.
   *
   * @param {String} event
   * @return {Boolean}
   * @api public
   */

  Emitter.prototype.hasListeners = function(event){
    return !! this.listeners(event).length;
  };


/***/ },
/* 14 */
/***/ function(module, exports) {

  "use strict";

  /**
   * @prototype Point3d
   * @param {Number} [x]
   * @param {Number} [y]
   * @param {Number} [z]
   */
  function Point3d(x, y, z) {
    this.x = x !== undefined ? x : 0;
    this.y = y !== undefined ? y : 0;
    this.z = z !== undefined ? z : 0;
  };

  /**
   * Subtract the two provided points, returns a-b
   * @param {Point3d} a
   * @param {Point3d} b
   * @return {Point3d} a-b
   */
  Point3d.subtract = function (a, b) {
    var sub = new Point3d();
    sub.x = a.x - b.x;
    sub.y = a.y - b.y;
    sub.z = a.z - b.z;
    return sub;
  };

  /**
   * Add the two provided points, returns a+b
   * @param {Point3d} a
   * @param {Point3d} b
   * @return {Point3d} a+b
   */
  Point3d.add = function (a, b) {
    var sum = new Point3d();
    sum.x = a.x + b.x;
    sum.y = a.y + b.y;
    sum.z = a.z + b.z;
    return sum;
  };

  /**
   * Calculate the average of two 3d points
   * @param {Point3d} a
   * @param {Point3d} b
   * @return {Point3d} The average, (a+b)/2
   */
  Point3d.avg = function (a, b) {
    return new Point3d((a.x + b.x) / 2, (a.y + b.y) / 2, (a.z + b.z) / 2);
  };

  /**
   * Calculate the cross product of the two provided points, returns axb
   * Documentation: http://en.wikipedia.org/wiki/Cross_product
   * @param {Point3d} a
   * @param {Point3d} b
   * @return {Point3d} cross product axb
   */
  Point3d.crossProduct = function (a, b) {
    var crossproduct = new Point3d();

    crossproduct.x = a.y * b.z - a.z * b.y;
    crossproduct.y = a.z * b.x - a.x * b.z;
    crossproduct.z = a.x * b.y - a.y * b.x;

    return crossproduct;
  };

  /**
   * Rtrieve the length of the vector (or the distance from this point to the origin
   * @return {Number}  length
   */
  Point3d.prototype.length = function () {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  };

  module.exports = Point3d;

/***/ },
/* 15 */
/***/ function(module, exports) {

  "use strict";

  /**
   * @prototype Point2d
   * @param {Number} [x]
   * @param {Number} [y]
   */
  function Point2d(x, y) {
    this.x = x !== undefined ? x : 0;
    this.y = y !== undefined ? y : 0;
  }

  module.exports = Point2d;

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var Point3d = __webpack_require__(14);

  /**
   * @class Camera
   * The camera is mounted on a (virtual) camera arm. The camera arm can rotate
   * The camera is always looking in the direction of the origin of the arm.
   * This way, the camera always rotates around one fixed point, the location
   * of the camera arm.
   *
   * Documentation:
   *   http://en.wikipedia.org/wiki/3D_projection
   */
  function Camera() {
    this.armLocation = new Point3d();
    this.armRotation = {};
    this.armRotation.horizontal = 0;
    this.armRotation.vertical = 0;
    this.armLength = 1.7;

    this.cameraLocation = new Point3d();
    this.cameraRotation = new Point3d(0.5 * Math.PI, 0, 0);

    this.calculateCameraOrientation();
  }

  /**
   * Set the location (origin) of the arm
   * @param {Number} x  Normalized value of x
   * @param {Number} y  Normalized value of y
   * @param {Number} z  Normalized value of z
   */
  Camera.prototype.setArmLocation = function (x, y, z) {
    this.armLocation.x = x;
    this.armLocation.y = y;
    this.armLocation.z = z;

    this.calculateCameraOrientation();
  };

  /**
   * Set the rotation of the camera arm
   * @param {Number} horizontal   The horizontal rotation, between 0 and 2*PI.
   *                Optional, can be left undefined.
   * @param {Number} vertical   The vertical rotation, between 0 and 0.5*PI
   *                if vertical=0.5*PI, the graph is shown from the
   *                top. Optional, can be left undefined.
   */
  Camera.prototype.setArmRotation = function (horizontal, vertical) {
    if (horizontal !== undefined) {
      this.armRotation.horizontal = horizontal;
    }

    if (vertical !== undefined) {
      this.armRotation.vertical = vertical;
      if (this.armRotation.vertical < 0) this.armRotation.vertical = 0;
      if (this.armRotation.vertical > 0.5 * Math.PI) this.armRotation.vertical = 0.5 * Math.PI;
    }

    if (horizontal !== undefined || vertical !== undefined) {
      this.calculateCameraOrientation();
    }
  };

  /**
   * Retrieve the current arm rotation
   * @return {object}   An object with parameters horizontal and vertical
   */
  Camera.prototype.getArmRotation = function () {
    var rot = {};
    rot.horizontal = this.armRotation.horizontal;
    rot.vertical = this.armRotation.vertical;

    return rot;
  };

  /**
   * Set the (normalized) length of the camera arm.
   * @param {Number} length A length between 0.71 and 5.0
   */
  Camera.prototype.setArmLength = function (length) {
    if (length === undefined) return;

    this.armLength = length;

    // Radius must be larger than the corner of the graph,
    // which has a distance of sqrt(0.5^2+0.5^2) = 0.71 from the center of the
    // graph
    if (this.armLength < 0.71) this.armLength = 0.71;
    if (this.armLength > 5.0) this.armLength = 5.0;

    this.calculateCameraOrientation();
  };

  /**
   * Retrieve the arm length
   * @return {Number} length
   */
  Camera.prototype.getArmLength = function () {
    return this.armLength;
  };

  /**
   * Retrieve the camera location
   * @return {Point3d} cameraLocation
   */
  Camera.prototype.getCameraLocation = function () {
    return this.cameraLocation;
  };

  /**
   * Retrieve the camera rotation
   * @return {Point3d} cameraRotation
   */
  Camera.prototype.getCameraRotation = function () {
    return this.cameraRotation;
  };

  /**
   * Calculate the location and rotation of the camera based on the
   * position and orientation of the camera arm
   */
  Camera.prototype.calculateCameraOrientation = function () {
    // calculate location of the camera
    this.cameraLocation.x = this.armLocation.x - this.armLength * Math.sin(this.armRotation.horizontal) * Math.cos(this.armRotation.vertical);
    this.cameraLocation.y = this.armLocation.y - this.armLength * Math.cos(this.armRotation.horizontal) * Math.cos(this.armRotation.vertical);
    this.cameraLocation.z = this.armLocation.z + this.armLength * Math.sin(this.armRotation.vertical);

    // calculate rotation of the camera
    this.cameraRotation.x = Math.PI / 2 - this.armRotation.vertical;
    this.cameraRotation.y = 0;
    this.cameraRotation.z = -this.armRotation.horizontal;
  };

  module.exports = Camera;

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var DataView = __webpack_require__(11);

  /**
   * @class Filter
   *
   * @param {DataSet} data The google data table
   * @param {Number}  column             The index of the column to be filtered
   * @param {Graph} graph           The graph
   */
  function Filter(data, column, graph) {
    this.data = data;
    this.column = column;
    this.graph = graph; // the parent graph

    this.index = undefined;
    this.value = undefined;

    // read all distinct values and select the first one
    this.values = graph.getDistinctValues(data.get(), this.column);

    // sort both numeric and string values correctly
    this.values.sort(function (a, b) {
      return a > b ? 1 : a < b ? -1 : 0;
    });

    if (this.values.length > 0) {
      this.selectValue(0);
    }

    // create an array with the filtered datapoints. this will be loaded afterwards
    this.dataPoints = [];

    this.loaded = false;
    this.onLoadCallback = undefined;

    if (graph.animationPreload) {
      this.loaded = false;
      this.loadInBackground();
    } else {
      this.loaded = true;
    }
  };

  /**
   * Return the label
   * @return {string} label
   */
  Filter.prototype.isLoaded = function () {
    return this.loaded;
  };

  /**
   * Return the loaded progress
   * @return {Number} percentage between 0 and 100
   */
  Filter.prototype.getLoadedProgress = function () {
    var len = this.values.length;

    var i = 0;
    while (this.dataPoints[i]) {
      i++;
    }

    return Math.round(i / len * 100);
  };

  /**
   * Return the label
   * @return {string} label
   */
  Filter.prototype.getLabel = function () {
    return this.graph.filterLabel;
  };

  /**
   * Return the columnIndex of the filter
   * @return {Number} columnIndex
   */
  Filter.prototype.getColumn = function () {
    return this.column;
  };

  /**
   * Return the currently selected value. Returns undefined if there is no selection
   * @return {*} value
   */
  Filter.prototype.getSelectedValue = function () {
    if (this.index === undefined) return undefined;

    return this.values[this.index];
  };

  /**
   * Retrieve all values of the filter
   * @return {Array} values
   */
  Filter.prototype.getValues = function () {
    return this.values;
  };

  /**
   * Retrieve one value of the filter
   * @param {Number}  index
   * @return {*} value
   */
  Filter.prototype.getValue = function (index) {
    if (index >= this.values.length) throw 'Error: index out of range';

    return this.values[index];
  };

  /**
   * Retrieve the (filtered) dataPoints for the currently selected filter index
   * @param {Number} [index] (optional)
   * @return {Array} dataPoints
   */
  Filter.prototype._getDataPoints = function (index) {
    if (index === undefined) index = this.index;

    if (index === undefined) return [];

    var dataPoints;
    if (this.dataPoints[index]) {
      dataPoints = this.dataPoints[index];
    } else {
      var f = {};
      f.column = this.column;
      f.value = this.values[index];

      var dataView = new DataView(this.data, { filter: function filter(item) {
          return item[f.column] == f.value;
        } }).get();
      dataPoints = this.graph._getDataPoints(dataView);

      this.dataPoints[index] = dataPoints;
    }

    return dataPoints;
  };

  /**
   * Set a callback function when the filter is fully loaded.
   */
  Filter.prototype.setOnLoadCallback = function (callback) {
    this.onLoadCallback = callback;
  };

  /**
   * Add a value to the list with available values for this filter
   * No double entries will be created.
   * @param {Number} index
   */
  Filter.prototype.selectValue = function (index) {
    if (index >= this.values.length) throw 'Error: index out of range';

    this.index = index;
    this.value = this.values[index];
  };

  /**
   * Load all filtered rows in the background one by one
   * Start this method without providing an index!
   */
  Filter.prototype.loadInBackground = function (index) {
    if (index === undefined) index = 0;

    var frame = this.graph.frame;

    if (index < this.values.length) {
      var dataPointsTemp = this._getDataPoints(index);
      //this.graph.redrawInfo(); // TODO: not neat

      // create a progress box
      if (frame.progress === undefined) {
        frame.progress = document.createElement('DIV');
        frame.progress.style.position = 'absolute';
        frame.progress.style.color = 'gray';
        frame.appendChild(frame.progress);
      }
      var progress = this.getLoadedProgress();
      frame.progress.innerHTML = 'Loading animation... ' + progress + '%';
      // TODO: this is no nice solution...
      frame.progress.style.bottom = 60 + 'px'; // TODO: use height of slider
      frame.progress.style.left = 10 + 'px';

      var me = this;
      setTimeout(function () {
        me.loadInBackground(index + 1);
      }, 10);
      this.loaded = false;
    } else {
      this.loaded = true;

      // remove the progress box
      if (frame.progress !== undefined) {
        frame.removeChild(frame.progress);
        frame.progress = undefined;
      }

      if (this.onLoadCallback) this.onLoadCallback();
    }
  };

  module.exports = Filter;

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var util = __webpack_require__(1);

  /**
   * @constructor Slider
   *
   * An html slider control with start/stop/prev/next buttons
   * @param {Element} container  The element where the slider will be created
   * @param {Object} options   Available options:
   *                 {boolean} visible   If true (default) the
   *                           slider is visible.
   */
  function Slider(container, options) {
    if (container === undefined) {
      throw 'Error: No container element defined';
    }
    this.container = container;
    this.visible = options && options.visible != undefined ? options.visible : true;

    if (this.visible) {
      this.frame = document.createElement('DIV');
      //this.frame.style.backgroundColor = '#E5E5E5';
      this.frame.style.width = '100%';
      this.frame.style.position = 'relative';
      this.container.appendChild(this.frame);

      this.frame.prev = document.createElement('INPUT');
      this.frame.prev.type = 'BUTTON';
      this.frame.prev.value = 'Prev';
      this.frame.appendChild(this.frame.prev);

      this.frame.play = document.createElement('INPUT');
      this.frame.play.type = 'BUTTON';
      this.frame.play.value = 'Play';
      this.frame.appendChild(this.frame.play);

      this.frame.next = document.createElement('INPUT');
      this.frame.next.type = 'BUTTON';
      this.frame.next.value = 'Next';
      this.frame.appendChild(this.frame.next);

      this.frame.bar = document.createElement('INPUT');
      this.frame.bar.type = 'BUTTON';
      this.frame.bar.style.position = 'absolute';
      this.frame.bar.style.border = '1px solid red';
      this.frame.bar.style.width = '100px';
      this.frame.bar.style.height = '6px';
      this.frame.bar.style.borderRadius = '2px';
      this.frame.bar.style.MozBorderRadius = '2px';
      this.frame.bar.style.border = '1px solid #7F7F7F';
      this.frame.bar.style.backgroundColor = '#E5E5E5';
      this.frame.appendChild(this.frame.bar);

      this.frame.slide = document.createElement('INPUT');
      this.frame.slide.type = 'BUTTON';
      this.frame.slide.style.margin = '0px';
      this.frame.slide.value = ' ';
      this.frame.slide.style.position = 'relative';
      this.frame.slide.style.left = '-100px';
      this.frame.appendChild(this.frame.slide);

      // create events
      var me = this;
      this.frame.slide.onmousedown = function (event) {
        me._onMouseDown(event);
      };
      this.frame.prev.onclick = function (event) {
        me.prev(event);
      };
      this.frame.play.onclick = function (event) {
        me.togglePlay(event);
      };
      this.frame.next.onclick = function (event) {
        me.next(event);
      };
    }

    this.onChangeCallback = undefined;

    this.values = [];
    this.index = undefined;

    this.playTimeout = undefined;
    this.playInterval = 1000; // milliseconds
    this.playLoop = true;
  }

  /**
   * Select the previous index
   */
  Slider.prototype.prev = function () {
    var index = this.getIndex();
    if (index > 0) {
      index--;
      this.setIndex(index);
    }
  };

  /**
   * Select the next index
   */
  Slider.prototype.next = function () {
    var index = this.getIndex();
    if (index < this.values.length - 1) {
      index++;
      this.setIndex(index);
    }
  };

  /**
   * Select the next index
   */
  Slider.prototype.playNext = function () {
    var start = new Date();

    var index = this.getIndex();
    if (index < this.values.length - 1) {
      index++;
      this.setIndex(index);
    } else if (this.playLoop) {
      // jump to the start
      index = 0;
      this.setIndex(index);
    }

    var end = new Date();
    var diff = end - start;

    // calculate how much time it to to set the index and to execute the callback
    // function.
    var interval = Math.max(this.playInterval - diff, 0);
    // document.title = diff // TODO: cleanup

    var me = this;
    this.playTimeout = setTimeout(function () {
      me.playNext();
    }, interval);
  };

  /**
   * Toggle start or stop playing
   */
  Slider.prototype.togglePlay = function () {
    if (this.playTimeout === undefined) {
      this.play();
    } else {
      this.stop();
    }
  };

  /**
   * Start playing
   */
  Slider.prototype.play = function () {
    // Test whether already playing
    if (this.playTimeout) return;

    this.playNext();

    if (this.frame) {
      this.frame.play.value = 'Stop';
    }
  };

  /**
   * Stop playing
   */
  Slider.prototype.stop = function () {
    clearInterval(this.playTimeout);
    this.playTimeout = undefined;

    if (this.frame) {
      this.frame.play.value = 'Play';
    }
  };

  /**
   * Set a callback function which will be triggered when the value of the
   * slider bar has changed.
   */
  Slider.prototype.setOnChangeCallback = function (callback) {
    this.onChangeCallback = callback;
  };

  /**
   * Set the interval for playing the list
   * @param {Number} interval   The interval in milliseconds
   */
  Slider.prototype.setPlayInterval = function (interval) {
    this.playInterval = interval;
  };

  /**
   * Retrieve the current play interval
   * @return {Number} interval   The interval in milliseconds
   */
  Slider.prototype.getPlayInterval = function (interval) {
    return this.playInterval;
  };

  /**
   * Set looping on or off
   * @pararm {boolean} doLoop  If true, the slider will jump to the start when
   *               the end is passed, and will jump to the end
   *               when the start is passed.
   */
  Slider.prototype.setPlayLoop = function (doLoop) {
    this.playLoop = doLoop;
  };

  /**
   * Execute the onchange callback function
   */
  Slider.prototype.onChange = function () {
    if (this.onChangeCallback !== undefined) {
      this.onChangeCallback();
    }
  };

  /**
   * redraw the slider on the correct place
   */
  Slider.prototype.redraw = function () {
    if (this.frame) {
      // resize the bar
      this.frame.bar.style.top = this.frame.clientHeight / 2 - this.frame.bar.offsetHeight / 2 + 'px';
      this.frame.bar.style.width = this.frame.clientWidth - this.frame.prev.clientWidth - this.frame.play.clientWidth - this.frame.next.clientWidth - 30 + 'px';

      // position the slider button
      var left = this.indexToLeft(this.index);
      this.frame.slide.style.left = left + 'px';
    }
  };

  /**
   * Set the list with values for the slider
   * @param {Array} values   A javascript array with values (any type)
   */
  Slider.prototype.setValues = function (values) {
    this.values = values;

    if (this.values.length > 0) this.setIndex(0);else this.index = undefined;
  };

  /**
   * Select a value by its index
   * @param {Number} index
   */
  Slider.prototype.setIndex = function (index) {
    if (index < this.values.length) {
      this.index = index;

      this.redraw();
      this.onChange();
    } else {
      throw 'Error: index out of range';
    }
  };

  /**
   * retrieve the index of the currently selected vaue
   * @return {Number} index
   */
  Slider.prototype.getIndex = function () {
    return this.index;
  };

  /**
   * retrieve the currently selected value
   * @return {*} value
   */
  Slider.prototype.get = function () {
    return this.values[this.index];
  };

  Slider.prototype._onMouseDown = function (event) {
    // only react on left mouse button down
    var leftButtonDown = event.which ? event.which === 1 : event.button === 1;
    if (!leftButtonDown) return;

    this.startClientX = event.clientX;
    this.startSlideX = parseFloat(this.frame.slide.style.left);

    this.frame.style.cursor = 'move';

    // add event listeners to handle moving the contents
    // we store the function onmousemove and onmouseup in the graph, so we can
    // remove the eventlisteners lateron in the function mouseUp()
    var me = this;
    this.onmousemove = function (event) {
      me._onMouseMove(event);
    };
    this.onmouseup = function (event) {
      me._onMouseUp(event);
    };
    util.addEventListener(document, 'mousemove', this.onmousemove);
    util.addEventListener(document, 'mouseup', this.onmouseup);
    util.preventDefault(event);
  };

  Slider.prototype.leftToIndex = function (left) {
    var width = parseFloat(this.frame.bar.style.width) - this.frame.slide.clientWidth - 10;
    var x = left - 3;

    var index = Math.round(x / width * (this.values.length - 1));
    if (index < 0) index = 0;
    if (index > this.values.length - 1) index = this.values.length - 1;

    return index;
  };

  Slider.prototype.indexToLeft = function (index) {
    var width = parseFloat(this.frame.bar.style.width) - this.frame.slide.clientWidth - 10;

    var x = index / (this.values.length - 1) * width;
    var left = x + 3;

    return left;
  };

  Slider.prototype._onMouseMove = function (event) {
    var diff = event.clientX - this.startClientX;
    var x = this.startSlideX + diff;

    var index = this.leftToIndex(x);

    this.setIndex(index);

    util.preventDefault();
  };

  Slider.prototype._onMouseUp = function (event) {
    this.frame.style.cursor = 'auto';

    // remove event listeners
    util.removeEventListener(document, 'mousemove', this.onmousemove);
    util.removeEventListener(document, 'mouseup', this.onmouseup);

    util.preventDefault();
  };

  module.exports = Slider;

/***/ },
/* 19 */
/***/ function(module, exports) {

  "use strict";

  /**
   * @prototype StepNumber
   * The class StepNumber is an iterator for Numbers. You provide a start and end
   * value, and a best step size. StepNumber itself rounds to fixed values and
   * a finds the step that best fits the provided step.
   *
   * If prettyStep is true, the step size is chosen as close as possible to the
   * provided step, but being a round value like 1, 2, 5, 10, 20, 50, ....
   *
   * Example usage:
   *   var step = new StepNumber(0, 10, 2.5, true);
   *   step.start();
   *   while (!step.end()) {
   *   alert(step.getCurrent());
   *   step.next();
   *   }
   *
   * Version: 1.0
   *
   * @param {Number} start     The start value
   * @param {Number} end     The end value
   * @param {Number} step    Optional. Step size. Must be a positive value.
   * @param {boolean} prettyStep Optional. If true, the step size is rounded
   *               To a pretty step size (like 1, 2, 5, 10, 20, 50, ...)
   */
  function StepNumber(start, end, step, prettyStep) {
    // set default values
    this._start = 0;
    this._end = 0;
    this._step = 1;
    this.prettyStep = true;
    this.precision = 5;

    this._current = 0;
    this.setRange(start, end, step, prettyStep);
  };

  /**
   * Set a new range: start, end and step.
   *
   * @param {Number} start     The start value
   * @param {Number} end     The end value
   * @param {Number} step    Optional. Step size. Must be a positive value.
   * @param {boolean} prettyStep Optional. If true, the step size is rounded
   *               To a pretty step size (like 1, 2, 5, 10, 20, 50, ...)
   */
  StepNumber.prototype.setRange = function (start, end, step, prettyStep) {
    this._start = start ? start : 0;
    this._end = end ? end : 0;

    this.setStep(step, prettyStep);
  };

  /**
   * Set a new step size
   * @param {Number} step    New step size. Must be a positive value
   * @param {boolean} prettyStep Optional. If true, the provided step is rounded
   *               to a pretty step size (like 1, 2, 5, 10, 20, 50, ...)
   */
  StepNumber.prototype.setStep = function (step, prettyStep) {
    if (step === undefined || step <= 0) return;

    if (prettyStep !== undefined) this.prettyStep = prettyStep;

    if (this.prettyStep === true) this._step = StepNumber.calculatePrettyStep(step);else this._step = step;
  };

  /**
   * Calculate a nice step size, closest to the desired step size.
   * Returns a value in one of the ranges 1*10^n, 2*10^n, or 5*10^n, where n is an
   * integer Number. For example 1, 2, 5, 10, 20, 50, etc...
   * @param {Number}  step  Desired step size
   * @return {Number}     Nice step size
   */
  StepNumber.calculatePrettyStep = function (step) {
    var log10 = function log10(x) {
      return Math.log(x) / Math.LN10;
    };

    // try three steps (multiple of 1, 2, or 5
    var step1 = Math.pow(10, Math.round(log10(step))),
        step2 = 2 * Math.pow(10, Math.round(log10(step / 2))),
        step5 = 5 * Math.pow(10, Math.round(log10(step / 5)));

    // choose the best step (closest to minimum step)
    var prettyStep = step1;
    if (Math.abs(step2 - step) <= Math.abs(prettyStep - step)) prettyStep = step2;
    if (Math.abs(step5 - step) <= Math.abs(prettyStep - step)) prettyStep = step5;

    // for safety
    if (prettyStep <= 0) {
      prettyStep = 1;
    }

    return prettyStep;
  };

  /**
   * returns the current value of the step
   * @return {Number} current value
   */
  StepNumber.prototype.getCurrent = function () {
    return parseFloat(this._current.toPrecision(this.precision));
  };

  /**
   * returns the current step size
   * @return {Number} current step size
   */
  StepNumber.prototype.getStep = function () {
    return this._step;
  };

  /**
   * Set the current value to the largest value smaller than start, which
   * is a multiple of the step size
   */
  StepNumber.prototype.start = function () {
    this._current = this._start - this._start % this._step;
  };

  /**
   * Do a step, add the step size to the current value
   */
  StepNumber.prototype.next = function () {
    this._current += this._step;
  };

  /**
   * Returns true whether the end is reached
   * @return {boolean}  True if the current value has passed the end value.
   */
  StepNumber.prototype.end = function () {
    return this._current > this._end;
  };

  module.exports = StepNumber;

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  // Only load hammer.js when in a browser environment
  // (loading hammer.js in a node.js environment gives errors)
  if (typeof window !== 'undefined') {
    var propagating = __webpack_require__(21);
    var Hammer = window['Hammer'] || __webpack_require__(22);
    module.exports = propagating(Hammer, {
      preventDefault: 'mouse'
    });
  } else {
    module.exports = function () {
      throw Error('hammer.js is only available in a browser, not in node.js.');
    };
  }

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

  var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

  (function (factory) {
    if (true) {
      // AMD. Register as an anonymous module.
      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if (typeof exports === 'object') {
      // Node. Does not work with strict CommonJS, but
      // only CommonJS-like environments that support module.exports,
      // like Node.
      module.exports = factory();
    } else {
      // Browser globals (root is window)
      window.propagating = factory();
    }
  }(function () {
    var _firstTarget = null; // singleton, will contain the target element where the touch event started

    /**
     * Extend an Hammer.js instance with event propagation.
     *
     * Features:
     * - Events emitted by hammer will propagate in order from child to parent
     *   elements.
     * - Events are extended with a function `event.stopPropagation()` to stop
     *   propagation to parent elements.
     * - An option `preventDefault` to stop all default browser behavior.
     *
     * Usage:
     *   var hammer = propagatingHammer(new Hammer(element));
     *   var hammer = propagatingHammer(new Hammer(element), {preventDefault: true});
     *
     * @param {Hammer.Manager} hammer   An hammer instance.
     * @param {Object} [options]        Available options:
     *                                  - `preventDefault: true | false | 'mouse' | 'touch' | 'pen'`.
     *                                    Enforce preventing the default browser behavior.
     *                                    Cannot be set to `false`.
     * @return {Hammer.Manager} Returns the same hammer instance with extended
     *                          functionality
     */
    return function propagating(hammer, options) {
      var _options = options || {
        preventDefault: false
      };

      if (hammer.Manager) {
        // This looks like the Hammer constructor.
        // Overload the constructors with our own.
        var Hammer = hammer;

        var PropagatingHammer = function(element, options) {
          var o = Object.create(_options);
          if (options) Hammer.assign(o, options);
          return propagating(new Hammer(element, o), o);
        };
        Hammer.assign(PropagatingHammer, Hammer);

        PropagatingHammer.Manager = function (element, options) {
          var o = Object.create(_options);
          if (options) Hammer.assign(o, options);
          return propagating(new Hammer.Manager(element, o), o);
        };

        return PropagatingHammer;
      }

      // create a wrapper object which will override the functions
      // `on`, `off`, `destroy`, and `emit` of the hammer instance
      var wrapper = Object.create(hammer);

      // attach to DOM element
      var element = hammer.element;

      if(!element.hammer) element.hammer = [];
      element.hammer.push(wrapper);

      // register an event to catch the start of a gesture and store the
      // target in a singleton
      hammer.on('hammer.input', function (event) {
        if (_options.preventDefault === true || (_options.preventDefault === event.pointerType)) {
          event.preventDefault();
        }
        if (event.isFirst) {
          _firstTarget = event.target;
        }
      });

      /** @type {Object.<String, Array.<function>>} */
      wrapper._handlers = {};

      /**
       * Register a handler for one or multiple events
       * @param {String} events    A space separated string with events
       * @param {function} handler A callback function, called as handler(event)
       * @returns {Hammer.Manager} Returns the hammer instance
       */
      wrapper.on = function (events, handler) {
        // register the handler
        split(events).forEach(function (event) {
          var _handlers = wrapper._handlers[event];
          if (!_handlers) {
            wrapper._handlers[event] = _handlers = [];

            // register the static, propagated handler
            hammer.on(event, propagatedHandler);
          }
          _handlers.push(handler);
        });

        return wrapper;
      };

      /**
       * Unregister a handler for one or multiple events
       * @param {String} events      A space separated string with events
       * @param {function} [handler] Optional. The registered handler. If not
       *                             provided, all handlers for given events
       *                             are removed.
       * @returns {Hammer.Manager}   Returns the hammer instance
       */
      wrapper.off = function (events, handler) {
        // unregister the handler
        split(events).forEach(function (event) {
          var _handlers = wrapper._handlers[event];
          if (_handlers) {
            _handlers = handler ? _handlers.filter(function (h) {
              return h !== handler;
            }) : [];

            if (_handlers.length > 0) {
              wrapper._handlers[event] = _handlers;
            }
            else {
              // remove static, propagated handler
              hammer.off(event, propagatedHandler);
              delete wrapper._handlers[event];
            }
          }
        });

        return wrapper;
      };

      /**
       * Emit to the event listeners
       * @param {string} eventType
       * @param {Event} event
       */
      wrapper.emit = function(eventType, event) {
        _firstTarget = event.target;
        hammer.emit(eventType, event);
      };

      wrapper.destroy = function () {
        // Detach from DOM element
        var hammers = hammer.element.hammer;
        var idx = hammers.indexOf(wrapper);
        if(idx !== -1) hammers.splice(idx,1);
        if(!hammers.length) delete hammer.element.hammer;

        // clear all handlers
        wrapper._handlers = {};

        // call original hammer destroy
        hammer.destroy();
      };

      // split a string with space separated words
      function split(events) {
        return events.match(/[^ ]+/g);
      }

      /**
       * A static event handler, applying event propagation.
       * @param {Object} event
       */
      function propagatedHandler(event) {
        // let only a single hammer instance handle this event
        if (event.type !== 'hammer.input') {
          // it is possible that the same srcEvent is used with multiple hammer events,
          // we keep track on which events are handled in an object _handled
          if (!event.srcEvent._handled) {
            event.srcEvent._handled = {};
          }

          if (event.srcEvent._handled[event.type]) {
            return;
          }
          else {
            event.srcEvent._handled[event.type] = true;
          }
        }

        // attach a stopPropagation function to the event
        var stopped = false;
        event.stopPropagation = function () {
          stopped = true;
        };

        //wrap the srcEvent's stopPropagation to also stop hammer propagation:
        var srcStop = event.srcEvent.stopPropagation.bind(event.srcEvent);
        if(typeof srcStop == "function") {
          event.srcEvent.stopPropagation = function(){
            srcStop();
            event.stopPropagation();
          }
        }

        // attach firstTarget property to the event
        event.firstTarget = _firstTarget;

        // propagate over all elements (until stopped)
        var elem = _firstTarget;
        while (elem && !stopped) {
          var elemHammer = elem.hammer;
          if(elemHammer){
            var _handlers;
            for(var k = 0; k < elemHammer.length; k++){
              _handlers = elemHammer[k]._handlers[event.type];
              if(_handlers) for (var i = 0; i < _handlers.length && !stopped; i++) {
                _handlers[i](event);
              }
            }
          }
          elem = elem.parentNode;
        }
      }

      return wrapper;
    };
  }));


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

  var __WEBPACK_AMD_DEFINE_RESULT__;/*! Hammer.JS - v2.0.6 - 2015-12-23
   * http://hammerjs.github.io/
   *
   * Copyright (c) 2015 Jorik Tangelder;
   * Licensed under the  license */
  (function(window, document, exportName, undefined) {
    'use strict';

  var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
  var TEST_ELEMENT = document.createElement('div');

  var TYPE_FUNCTION = 'function';

  var round = Math.round;
  var abs = Math.abs;
  var now = Date.now;

  /**
   * set a timeout with a given scope
   * @param {Function} fn
   * @param {Number} timeout
   * @param {Object} context
   * @returns {number}
   */
  function setTimeoutContext(fn, timeout, context) {
      return setTimeout(bindFn(fn, context), timeout);
  }

  /**
   * if the argument is an array, we want to execute the fn on each entry
   * if it aint an array we don't want to do a thing.
   * this is used by all the methods that accept a single and array argument.
   * @param {*|Array} arg
   * @param {String} fn
   * @param {Object} [context]
   * @returns {Boolean}
   */
  function invokeArrayArg(arg, fn, context) {
      if (Array.isArray(arg)) {
          each(arg, context[fn], context);
          return true;
      }
      return false;
  }

  /**
   * walk objects and arrays
   * @param {Object} obj
   * @param {Function} iterator
   * @param {Object} context
   */
  function each(obj, iterator, context) {
      var i;

      if (!obj) {
          return;
      }

      if (obj.forEach) {
          obj.forEach(iterator, context);
      } else if (obj.length !== undefined) {
          i = 0;
          while (i < obj.length) {
              iterator.call(context, obj[i], i, obj);
              i++;
          }
      } else {
          for (i in obj) {
              obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
          }
      }
  }

  /**
   * wrap a method with a deprecation warning and stack trace
   * @param {Function} method
   * @param {String} name
   * @param {String} message
   * @returns {Function} A new function wrapping the supplied method.
   */
  function deprecate(method, name, message) {
      var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
      return function() {
          var e = new Error('get-stack-trace');
          var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '')
              .replace(/^\s+at\s+/gm, '')
              .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

          var log = window.console && (window.console.warn || window.console.log);
          if (log) {
              log.call(window.console, deprecationMessage, stack);
          }
          return method.apply(this, arguments);
      };
  }

  /**
   * extend object.
   * means that properties in dest will be overwritten by the ones in src.
   * @param {Object} target
   * @param {...Object} objects_to_assign
   * @returns {Object} target
   */
  var assign;
  if (typeof Object.assign !== 'function') {
      assign = function assign(target) {
          if (target === undefined || target === null) {
              throw new TypeError('Cannot convert undefined or null to object');
          }

          var output = Object(target);
          for (var index = 1; index < arguments.length; index++) {
              var source = arguments[index];
              if (source !== undefined && source !== null) {
                  for (var nextKey in source) {
                      if (source.hasOwnProperty(nextKey)) {
                          output[nextKey] = source[nextKey];
                      }
                  }
              }
          }
          return output;
      };
  } else {
      assign = Object.assign;
  }

  /**
   * extend object.
   * means that properties in dest will be overwritten by the ones in src.
   * @param {Object} dest
   * @param {Object} src
   * @param {Boolean=false} [merge]
   * @returns {Object} dest
   */
  var extend = deprecate(function extend(dest, src, merge) {
      var keys = Object.keys(src);
      var i = 0;
      while (i < keys.length) {
          if (!merge || (merge && dest[keys[i]] === undefined)) {
              dest[keys[i]] = src[keys[i]];
          }
          i++;
      }
      return dest;
  }, 'extend', 'Use `assign`.');

  /**
   * merge the values from src in the dest.
   * means that properties that exist in dest will not be overwritten by src
   * @param {Object} dest
   * @param {Object} src
   * @returns {Object} dest
   */
  var merge = deprecate(function merge(dest, src) {
      return extend(dest, src, true);
  }, 'merge', 'Use `assign`.');

  /**
   * simple class inheritance
   * @param {Function} child
   * @param {Function} base
   * @param {Object} [properties]
   */
  function inherit(child, base, properties) {
      var baseP = base.prototype,
          childP;

      childP = child.prototype = Object.create(baseP);
      childP.constructor = child;
      childP._super = baseP;

      if (properties) {
          assign(childP, properties);
      }
  }

  /**
   * simple function bind
   * @param {Function} fn
   * @param {Object} context
   * @returns {Function}
   */
  function bindFn(fn, context) {
      return function boundFn() {
          return fn.apply(context, arguments);
      };
  }

  /**
   * let a boolean value also be a function that must return a boolean
   * this first item in args will be used as the context
   * @param {Boolean|Function} val
   * @param {Array} [args]
   * @returns {Boolean}
   */
  function boolOrFn(val, args) {
      if (typeof val == TYPE_FUNCTION) {
          return val.apply(args ? args[0] || undefined : undefined, args);
      }
      return val;
  }

  /**
   * use the val2 when val1 is undefined
   * @param {*} val1
   * @param {*} val2
   * @returns {*}
   */
  function ifUndefined(val1, val2) {
      return (val1 === undefined) ? val2 : val1;
  }

  /**
   * addEventListener with multiple events at once
   * @param {EventTarget} target
   * @param {String} types
   * @param {Function} handler
   */
  function addEventListeners(target, types, handler) {
      each(splitStr(types), function(type) {
          target.addEventListener(type, handler, false);
      });
  }

  /**
   * removeEventListener with multiple events at once
   * @param {EventTarget} target
   * @param {String} types
   * @param {Function} handler
   */
  function removeEventListeners(target, types, handler) {
      each(splitStr(types), function(type) {
          target.removeEventListener(type, handler, false);
      });
  }

  /**
   * find if a node is in the given parent
   * @method hasParent
   * @param {HTMLElement} node
   * @param {HTMLElement} parent
   * @return {Boolean} found
   */
  function hasParent(node, parent) {
      while (node) {
          if (node == parent) {
              return true;
          }
          node = node.parentNode;
      }
      return false;
  }

  /**
   * small indexOf wrapper
   * @param {String} str
   * @param {String} find
   * @returns {Boolean} found
   */
  function inStr(str, find) {
      return str.indexOf(find) > -1;
  }

  /**
   * split string on whitespace
   * @param {String} str
   * @returns {Array} words
   */
  function splitStr(str) {
      return str.trim().split(/\s+/g);
  }

  /**
   * find if a array contains the object using indexOf or a simple polyFill
   * @param {Array} src
   * @param {String} find
   * @param {String} [findByKey]
   * @return {Boolean|Number} false when not found, or the index
   */
  function inArray(src, find, findByKey) {
      if (src.indexOf && !findByKey) {
          return src.indexOf(find);
      } else {
          var i = 0;
          while (i < src.length) {
              if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                  return i;
              }
              i++;
          }
          return -1;
      }
  }

  /**
   * convert array-like objects to real arrays
   * @param {Object} obj
   * @returns {Array}
   */
  function toArray(obj) {
      return Array.prototype.slice.call(obj, 0);
  }

  /**
   * unique array with objects based on a key (like 'id') or just by the array's value
   * @param {Array} src [{id:1},{id:2},{id:1}]
   * @param {String} [key]
   * @param {Boolean} [sort=False]
   * @returns {Array} [{id:1},{id:2}]
   */
  function uniqueArray(src, key, sort) {
      var results = [];
      var values = [];
      var i = 0;

      while (i < src.length) {
          var val = key ? src[i][key] : src[i];
          if (inArray(values, val) < 0) {
              results.push(src[i]);
          }
          values[i] = val;
          i++;
      }

      if (sort) {
          if (!key) {
              results = results.sort();
          } else {
              results = results.sort(function sortUniqueArray(a, b) {
                  return a[key] > b[key];
              });
          }
      }

      return results;
  }

  /**
   * get the prefixed property
   * @param {Object} obj
   * @param {String} property
   * @returns {String|Undefined} prefixed
   */
  function prefixed(obj, property) {
      var prefix, prop;
      var camelProp = property[0].toUpperCase() + property.slice(1);

      var i = 0;
      while (i < VENDOR_PREFIXES.length) {
          prefix = VENDOR_PREFIXES[i];
          prop = (prefix) ? prefix + camelProp : property;

          if (prop in obj) {
              return prop;
          }
          i++;
      }
      return undefined;
  }

  /**
   * get a unique id
   * @returns {number} uniqueId
   */
  var _uniqueId = 1;
  function uniqueId() {
      return _uniqueId++;
  }

  /**
   * get the window object of an element
   * @param {HTMLElement} element
   * @returns {DocumentView|Window}
   */
  function getWindowForElement(element) {
      var doc = element.ownerDocument || element;
      return (doc.defaultView || doc.parentWindow || window);
  }

  var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

  var SUPPORT_TOUCH = ('ontouchstart' in window);
  var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
  var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

  var INPUT_TYPE_TOUCH = 'touch';
  var INPUT_TYPE_PEN = 'pen';
  var INPUT_TYPE_MOUSE = 'mouse';
  var INPUT_TYPE_KINECT = 'kinect';

  var COMPUTE_INTERVAL = 25;

  var INPUT_START = 1;
  var INPUT_MOVE = 2;
  var INPUT_END = 4;
  var INPUT_CANCEL = 8;

  var DIRECTION_NONE = 1;
  var DIRECTION_LEFT = 2;
  var DIRECTION_RIGHT = 4;
  var DIRECTION_UP = 8;
  var DIRECTION_DOWN = 16;

  var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
  var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
  var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

  var PROPS_XY = ['x', 'y'];
  var PROPS_CLIENT_XY = ['clientX', 'clientY'];

  /**
   * create new input type manager
   * @param {Manager} manager
   * @param {Function} callback
   * @returns {Input}
   * @constructor
   */
  function Input(manager, callback) {
      var self = this;
      this.manager = manager;
      this.callback = callback;
      this.element = manager.element;
      this.target = manager.options.inputTarget;

      // smaller wrapper around the handler, for the scope and the enabled state of the manager,
      // so when disabled the input events are completely bypassed.
      this.domHandler = function(ev) {
          if (boolOrFn(manager.options.enable, [manager])) {
              self.handler(ev);
          }
      };

      this.init();

  }

  Input.prototype = {
      /**
       * should handle the inputEvent data and trigger the callback
       * @virtual
       */
      handler: function() { },

      /**
       * bind the events
       */
      init: function() {
          this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
          this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
          this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
      },

      /**
       * unbind the events
       */
      destroy: function() {
          this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
          this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
          this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
      }
  };

  /**
   * create new input type manager
   * called by the Manager constructor
   * @param {Hammer} manager
   * @returns {Input}
   */
  function createInputInstance(manager) {
      var Type;
      var inputClass = manager.options.inputClass;

      if (inputClass) {
          Type = inputClass;
      } else if (SUPPORT_POINTER_EVENTS) {
          Type = PointerEventInput;
      } else if (SUPPORT_ONLY_TOUCH) {
          Type = TouchInput;
      } else if (!SUPPORT_TOUCH) {
          Type = MouseInput;
      } else {
          Type = TouchMouseInput;
      }
      return new (Type)(manager, inputHandler);
  }

  /**
   * handle input events
   * @param {Manager} manager
   * @param {String} eventType
   * @param {Object} input
   */
  function inputHandler(manager, eventType, input) {
      var pointersLen = input.pointers.length;
      var changedPointersLen = input.changedPointers.length;
      var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
      var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

      input.isFirst = !!isFirst;
      input.isFinal = !!isFinal;

      if (isFirst) {
          manager.session = {};
      }

      // source event is the normalized value of the domEvents
      // like 'touchstart, mouseup, pointerdown'
      input.eventType = eventType;

      // compute scale, rotation etc
      computeInputData(manager, input);

      // emit secret event
      manager.emit('hammer.input', input);

      manager.recognize(input);
      manager.session.prevInput = input;
  }

  /**
   * extend the data with some usable properties like scale, rotate, velocity etc
   * @param {Object} manager
   * @param {Object} input
   */
  function computeInputData(manager, input) {
      var session = manager.session;
      var pointers = input.pointers;
      var pointersLength = pointers.length;

      // store the first input to calculate the distance and direction
      if (!session.firstInput) {
          session.firstInput = simpleCloneInputData(input);
      }

      // to compute scale and rotation we need to store the multiple touches
      if (pointersLength > 1 && !session.firstMultiple) {
          session.firstMultiple = simpleCloneInputData(input);
      } else if (pointersLength === 1) {
          session.firstMultiple = false;
      }

      var firstInput = session.firstInput;
      var firstMultiple = session.firstMultiple;
      var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

      var center = input.center = getCenter(pointers);
      input.timeStamp = now();
      input.deltaTime = input.timeStamp - firstInput.timeStamp;

      input.angle = getAngle(offsetCenter, center);
      input.distance = getDistance(offsetCenter, center);

      computeDeltaXY(session, input);
      input.offsetDirection = getDirection(input.deltaX, input.deltaY);

      var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
      input.overallVelocityX = overallVelocity.x;
      input.overallVelocityY = overallVelocity.y;
      input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;

      input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
      input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

      input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
          session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);

      computeIntervalInputData(session, input);

      // find the correct target
      var target = manager.element;
      if (hasParent(input.srcEvent.target, target)) {
          target = input.srcEvent.target;
      }
      input.target = target;
  }

  function computeDeltaXY(session, input) {
      var center = input.center;
      var offset = session.offsetDelta || {};
      var prevDelta = session.prevDelta || {};
      var prevInput = session.prevInput || {};

      if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
          prevDelta = session.prevDelta = {
              x: prevInput.deltaX || 0,
              y: prevInput.deltaY || 0
          };

          offset = session.offsetDelta = {
              x: center.x,
              y: center.y
          };
      }

      input.deltaX = prevDelta.x + (center.x - offset.x);
      input.deltaY = prevDelta.y + (center.y - offset.y);
  }

  /**
   * velocity is calculated every x ms
   * @param {Object} session
   * @param {Object} input
   */
  function computeIntervalInputData(session, input) {
      var last = session.lastInterval || input,
          deltaTime = input.timeStamp - last.timeStamp,
          velocity, velocityX, velocityY, direction;

      if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
          var deltaX = input.deltaX - last.deltaX;
          var deltaY = input.deltaY - last.deltaY;

          var v = getVelocity(deltaTime, deltaX, deltaY);
          velocityX = v.x;
          velocityY = v.y;
          velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
          direction = getDirection(deltaX, deltaY);

          session.lastInterval = input;
      } else {
          // use latest velocity info if it doesn't overtake a minimum period
          velocity = last.velocity;
          velocityX = last.velocityX;
          velocityY = last.velocityY;
          direction = last.direction;
      }

      input.velocity = velocity;
      input.velocityX = velocityX;
      input.velocityY = velocityY;
      input.direction = direction;
  }

  /**
   * create a simple clone from the input used for storage of firstInput and firstMultiple
   * @param {Object} input
   * @returns {Object} clonedInputData
   */
  function simpleCloneInputData(input) {
      // make a simple copy of the pointers because we will get a reference if we don't
      // we only need clientXY for the calculations
      var pointers = [];
      var i = 0;
      while (i < input.pointers.length) {
          pointers[i] = {
              clientX: round(input.pointers[i].clientX),
              clientY: round(input.pointers[i].clientY)
          };
          i++;
      }

      return {
          timeStamp: now(),
          pointers: pointers,
          center: getCenter(pointers),
          deltaX: input.deltaX,
          deltaY: input.deltaY
      };
  }

  /**
   * get the center of all the pointers
   * @param {Array} pointers
   * @return {Object} center contains `x` and `y` properties
   */
  function getCenter(pointers) {
      var pointersLength = pointers.length;

      // no need to loop when only one touch
      if (pointersLength === 1) {
          return {
              x: round(pointers[0].clientX),
              y: round(pointers[0].clientY)
          };
      }

      var x = 0, y = 0, i = 0;
      while (i < pointersLength) {
          x += pointers[i].clientX;
          y += pointers[i].clientY;
          i++;
      }

      return {
          x: round(x / pointersLength),
          y: round(y / pointersLength)
      };
  }

  /**
   * calculate the velocity between two points. unit is in px per ms.
   * @param {Number} deltaTime
   * @param {Number} x
   * @param {Number} y
   * @return {Object} velocity `x` and `y`
   */
  function getVelocity(deltaTime, x, y) {
      return {
          x: x / deltaTime || 0,
          y: y / deltaTime || 0
      };
  }

  /**
   * get the direction between two points
   * @param {Number} x
   * @param {Number} y
   * @return {Number} direction
   */
  function getDirection(x, y) {
      if (x === y) {
          return DIRECTION_NONE;
      }

      if (abs(x) >= abs(y)) {
          return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
      }
      return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
  }

  /**
   * calculate the absolute distance between two points
   * @param {Object} p1 {x, y}
   * @param {Object} p2 {x, y}
   * @param {Array} [props] containing x and y keys
   * @return {Number} distance
   */
  function getDistance(p1, p2, props) {
      if (!props) {
          props = PROPS_XY;
      }
      var x = p2[props[0]] - p1[props[0]],
          y = p2[props[1]] - p1[props[1]];

      return Math.sqrt((x * x) + (y * y));
  }

  /**
   * calculate the angle between two coordinates
   * @param {Object} p1
   * @param {Object} p2
   * @param {Array} [props] containing x and y keys
   * @return {Number} angle
   */
  function getAngle(p1, p2, props) {
      if (!props) {
          props = PROPS_XY;
      }
      var x = p2[props[0]] - p1[props[0]],
          y = p2[props[1]] - p1[props[1]];
      return Math.atan2(y, x) * 180 / Math.PI;
  }

  /**
   * calculate the rotation degrees between two pointersets
   * @param {Array} start array of pointers
   * @param {Array} end array of pointers
   * @return {Number} rotation
   */
  function getRotation(start, end) {
      return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
  }

  /**
   * calculate the scale factor between two pointersets
   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
   * @param {Array} start array of pointers
   * @param {Array} end array of pointers
   * @return {Number} scale
   */
  function getScale(start, end) {
      return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
  }

  var MOUSE_INPUT_MAP = {
      mousedown: INPUT_START,
      mousemove: INPUT_MOVE,
      mouseup: INPUT_END
  };

  var MOUSE_ELEMENT_EVENTS = 'mousedown';
  var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

  /**
   * Mouse events input
   * @constructor
   * @extends Input
   */
  function MouseInput() {
      this.evEl = MOUSE_ELEMENT_EVENTS;
      this.evWin = MOUSE_WINDOW_EVENTS;

      this.allow = true; // used by Input.TouchMouse to disable mouse events
      this.pressed = false; // mousedown state

      Input.apply(this, arguments);
  }

  inherit(MouseInput, Input, {
      /**
       * handle mouse events
       * @param {Object} ev
       */
      handler: function MEhandler(ev) {
          var eventType = MOUSE_INPUT_MAP[ev.type];

          // on start we want to have the left mouse button down
          if (eventType & INPUT_START && ev.button === 0) {
              this.pressed = true;
          }

          if (eventType & INPUT_MOVE && ev.which !== 1) {
              eventType = INPUT_END;
          }

          // mouse must be down, and mouse events are allowed (see the TouchMouse input)
          if (!this.pressed || !this.allow) {
              return;
          }

          if (eventType & INPUT_END) {
              this.pressed = false;
          }

          this.callback(this.manager, eventType, {
              pointers: [ev],
              changedPointers: [ev],
              pointerType: INPUT_TYPE_MOUSE,
              srcEvent: ev
          });
      }
  });

  var POINTER_INPUT_MAP = {
      pointerdown: INPUT_START,
      pointermove: INPUT_MOVE,
      pointerup: INPUT_END,
      pointercancel: INPUT_CANCEL,
      pointerout: INPUT_CANCEL
  };

  // in IE10 the pointer types is defined as an enum
  var IE10_POINTER_TYPE_ENUM = {
      2: INPUT_TYPE_TOUCH,
      3: INPUT_TYPE_PEN,
      4: INPUT_TYPE_MOUSE,
      5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
  };

  var POINTER_ELEMENT_EVENTS = 'pointerdown';
  var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

  // IE10 has prefixed support, and case-sensitive
  if (window.MSPointerEvent && !window.PointerEvent) {
      POINTER_ELEMENT_EVENTS = 'MSPointerDown';
      POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
  }

  /**
   * Pointer events input
   * @constructor
   * @extends Input
   */
  function PointerEventInput() {
      this.evEl = POINTER_ELEMENT_EVENTS;
      this.evWin = POINTER_WINDOW_EVENTS;

      Input.apply(this, arguments);

      this.store = (this.manager.session.pointerEvents = []);
  }

  inherit(PointerEventInput, Input, {
      /**
       * handle mouse events
       * @param {Object} ev
       */
      handler: function PEhandler(ev) {
          var store = this.store;
          var removePointer = false;

          var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
          var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
          var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

          var isTouch = (pointerType == INPUT_TYPE_TOUCH);

          // get index of the event in the store
          var storeIndex = inArray(store, ev.pointerId, 'pointerId');

          // start and mouse must be down
          if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
              if (storeIndex < 0) {
                  store.push(ev);
                  storeIndex = store.length - 1;
              }
          } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
              removePointer = true;
          }

          // it not found, so the pointer hasn't been down (so it's probably a hover)
          if (storeIndex < 0) {
              return;
          }

          // update the event in the store
          store[storeIndex] = ev;

          this.callback(this.manager, eventType, {
              pointers: store,
              changedPointers: [ev],
              pointerType: pointerType,
              srcEvent: ev
          });

          if (removePointer) {
              // remove from the store
              store.splice(storeIndex, 1);
          }
      }
  });

  var SINGLE_TOUCH_INPUT_MAP = {
      touchstart: INPUT_START,
      touchmove: INPUT_MOVE,
      touchend: INPUT_END,
      touchcancel: INPUT_CANCEL
  };

  var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
  var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

  /**
   * Touch events input
   * @constructor
   * @extends Input
   */
  function SingleTouchInput() {
      this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
      this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
      this.started = false;

      Input.apply(this, arguments);
  }

  inherit(SingleTouchInput, Input, {
      handler: function TEhandler(ev) {
          var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

          // should we handle the touch events?
          if (type === INPUT_START) {
              this.started = true;
          }

          if (!this.started) {
              return;
          }

          var touches = normalizeSingleTouches.call(this, ev, type);

          // when done, reset the started state
          if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
              this.started = false;
          }

          this.callback(this.manager, type, {
              pointers: touches[0],
              changedPointers: touches[1],
              pointerType: INPUT_TYPE_TOUCH,
              srcEvent: ev
          });
      }
  });

  /**
   * @this {TouchInput}
   * @param {Object} ev
   * @param {Number} type flag
   * @returns {undefined|Array} [all, changed]
   */
  function normalizeSingleTouches(ev, type) {
      var all = toArray(ev.touches);
      var changed = toArray(ev.changedTouches);

      if (type & (INPUT_END | INPUT_CANCEL)) {
          all = uniqueArray(all.concat(changed), 'identifier', true);
      }

      return [all, changed];
  }

  var TOUCH_INPUT_MAP = {
      touchstart: INPUT_START,
      touchmove: INPUT_MOVE,
      touchend: INPUT_END,
      touchcancel: INPUT_CANCEL
  };

  var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

  /**
   * Multi-user touch events input
   * @constructor
   * @extends Input
   */
  function TouchInput() {
      this.evTarget = TOUCH_TARGET_EVENTS;
      this.targetIds = {};

      Input.apply(this, arguments);
  }

  inherit(TouchInput, Input, {
      handler: function MTEhandler(ev) {
          var type = TOUCH_INPUT_MAP[ev.type];
          var touches = getTouches.call(this, ev, type);
          if (!touches) {
              return;
          }

          this.callback(this.manager, type, {
              pointers: touches[0],
              changedPointers: touches[1],
              pointerType: INPUT_TYPE_TOUCH,
              srcEvent: ev
          });
      }
  });

  /**
   * @this {TouchInput}
   * @param {Object} ev
   * @param {Number} type flag
   * @returns {undefined|Array} [all, changed]
   */
  function getTouches(ev, type) {
      var allTouches = toArray(ev.touches);
      var targetIds = this.targetIds;

      // when there is only one touch, the process can be simplified
      if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
          targetIds[allTouches[0].identifier] = true;
          return [allTouches, allTouches];
      }

      var i,
          targetTouches,
          changedTouches = toArray(ev.changedTouches),
          changedTargetTouches = [],
          target = this.target;

      // get target touches from touches
      targetTouches = allTouches.filter(function(touch) {
          return hasParent(touch.target, target);
      });

      // collect touches
      if (type === INPUT_START) {
          i = 0;
          while (i < targetTouches.length) {
              targetIds[targetTouches[i].identifier] = true;
              i++;
          }
      }

      // filter changed touches to only contain touches that exist in the collected target ids
      i = 0;
      while (i < changedTouches.length) {
          if (targetIds[changedTouches[i].identifier]) {
              changedTargetTouches.push(changedTouches[i]);
          }

          // cleanup removed touches
          if (type & (INPUT_END | INPUT_CANCEL)) {
              delete targetIds[changedTouches[i].identifier];
          }
          i++;
      }

      if (!changedTargetTouches.length) {
          return;
      }

      return [
          // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
          uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
          changedTargetTouches
      ];
  }

  /**
   * Combined touch and mouse input
   *
   * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
   * This because touch devices also emit mouse events while doing a touch.
   *
   * @constructor
   * @extends Input
   */
  function TouchMouseInput() {
      Input.apply(this, arguments);

      var handler = bindFn(this.handler, this);
      this.touch = new TouchInput(this.manager, handler);
      this.mouse = new MouseInput(this.manager, handler);
  }

  inherit(TouchMouseInput, Input, {
      /**
       * handle mouse and touch events
       * @param {Hammer} manager
       * @param {String} inputEvent
       * @param {Object} inputData
       */
      handler: function TMEhandler(manager, inputEvent, inputData) {
          var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
              isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

          // when we're in a touch event, so  block all upcoming mouse events
          // most mobile browser also emit mouseevents, right after touchstart
          if (isTouch) {
              this.mouse.allow = false;
          } else if (isMouse && !this.mouse.allow) {
              return;
          }

          // reset the allowMouse when we're done
          if (inputEvent & (INPUT_END | INPUT_CANCEL)) {
              this.mouse.allow = true;
          }

          this.callback(manager, inputEvent, inputData);
      },

      /**
       * remove the event listeners
       */
      destroy: function destroy() {
          this.touch.destroy();
          this.mouse.destroy();
      }
  });

  var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
  var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

  // magical touchAction value
  var TOUCH_ACTION_COMPUTE = 'compute';
  var TOUCH_ACTION_AUTO = 'auto';
  var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
  var TOUCH_ACTION_NONE = 'none';
  var TOUCH_ACTION_PAN_X = 'pan-x';
  var TOUCH_ACTION_PAN_Y = 'pan-y';

  /**
   * Touch Action
   * sets the touchAction property or uses the js alternative
   * @param {Manager} manager
   * @param {String} value
   * @constructor
   */
  function TouchAction(manager, value) {
      this.manager = manager;
      this.set(value);
  }

  TouchAction.prototype = {
      /**
       * set the touchAction value on the element or enable the polyfill
       * @param {String} value
       */
      set: function(value) {
          // find out the touch-action by the event handlers
          if (value == TOUCH_ACTION_COMPUTE) {
              value = this.compute();
          }

          if (NATIVE_TOUCH_ACTION && this.manager.element.style) {
              this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
          }
          this.actions = value.toLowerCase().trim();
      },

      /**
       * just re-set the touchAction value
       */
      update: function() {
          this.set(this.manager.options.touchAction);
      },

      /**
       * compute the value for the touchAction property based on the recognizer's settings
       * @returns {String} value
       */
      compute: function() {
          var actions = [];
          each(this.manager.recognizers, function(recognizer) {
              if (boolOrFn(recognizer.options.enable, [recognizer])) {
                  actions = actions.concat(recognizer.getTouchAction());
              }
          });
          return cleanTouchActions(actions.join(' '));
      },

      /**
       * this method is called on each input cycle and provides the preventing of the browser behavior
       * @param {Object} input
       */
      preventDefaults: function(input) {
          // not needed with native support for the touchAction property
          if (NATIVE_TOUCH_ACTION) {
              return;
          }

          var srcEvent = input.srcEvent;
          var direction = input.offsetDirection;

          // if the touch action did prevented once this session
          if (this.manager.session.prevented) {
              srcEvent.preventDefault();
              return;
          }

          var actions = this.actions;
          var hasNone = inStr(actions, TOUCH_ACTION_NONE);
          var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
          var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);

          if (hasNone) {
              //do not prevent defaults if this is a tap gesture

              var isTapPointer = input.pointers.length === 1;
              var isTapMovement = input.distance < 2;
              var isTapTouchTime = input.deltaTime < 250;

              if (isTapPointer && isTapMovement && isTapTouchTime) {
                  return;
              }
          }

          if (hasPanX && hasPanY) {
              // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
              return;
          }

          if (hasNone ||
              (hasPanY && direction & DIRECTION_HORIZONTAL) ||
              (hasPanX && direction & DIRECTION_VERTICAL)) {
              return this.preventSrc(srcEvent);
          }
      },

      /**
       * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
       * @param {Object} srcEvent
       */
      preventSrc: function(srcEvent) {
          this.manager.session.prevented = true;
          srcEvent.preventDefault();
      }
  };

  /**
   * when the touchActions are collected they are not a valid value, so we need to clean things up. *
   * @param {String} actions
   * @returns {*}
   */
  function cleanTouchActions(actions) {
      // none
      if (inStr(actions, TOUCH_ACTION_NONE)) {
          return TOUCH_ACTION_NONE;
      }

      var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
      var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

      // if both pan-x and pan-y are set (different recognizers
      // for different directions, e.g. horizontal pan but vertical swipe?)
      // we need none (as otherwise with pan-x pan-y combined none of these
      // recognizers will work, since the browser would handle all panning
      if (hasPanX && hasPanY) {
          return TOUCH_ACTION_NONE;
      }

      // pan-x OR pan-y
      if (hasPanX || hasPanY) {
          return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
      }

      // manipulation
      if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
          return TOUCH_ACTION_MANIPULATION;
      }

      return TOUCH_ACTION_AUTO;
  }

  /**
   * Recognizer flow explained; *
   * All recognizers have the initial state of POSSIBLE when a input session starts.
   * The definition of a input session is from the first input until the last input, with all it's movement in it. *
   * Example session for mouse-input: mousedown -> mousemove -> mouseup
   *
   * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
   * which determines with state it should be.
   *
   * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
   * POSSIBLE to give it another change on the next cycle.
   *
   *               Possible
   *                  |
   *            +-----+---------------+
   *            |                     |
   *      +-----+-----+               |
   *      |           |               |
   *   Failed      Cancelled          |
   *                          +-------+------+
   *                          |              |
   *                      Recognized       Began
   *                                         |
   *                                      Changed
   *                                         |
   *                                  Ended/Recognized
   */
  var STATE_POSSIBLE = 1;
  var STATE_BEGAN = 2;
  var STATE_CHANGED = 4;
  var STATE_ENDED = 8;
  var STATE_RECOGNIZED = STATE_ENDED;
  var STATE_CANCELLED = 16;
  var STATE_FAILED = 32;

  /**
   * Recognizer
   * Every recognizer needs to extend from this class.
   * @constructor
   * @param {Object} options
   */
  function Recognizer(options) {
      this.options = assign({}, this.defaults, options || {});

      this.id = uniqueId();

      this.manager = null;

      // default is enable true
      this.options.enable = ifUndefined(this.options.enable, true);

      this.state = STATE_POSSIBLE;

      this.simultaneous = {};
      this.requireFail = [];
  }

  Recognizer.prototype = {
      /**
       * @virtual
       * @type {Object}
       */
      defaults: {},

      /**
       * set options
       * @param {Object} options
       * @return {Recognizer}
       */
      set: function(options) {
          assign(this.options, options);

          // also update the touchAction, in case something changed about the directions/enabled state
          this.manager && this.manager.touchAction.update();
          return this;
      },

      /**
       * recognize simultaneous with an other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      recognizeWith: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
              return this;
          }

          var simultaneous = this.simultaneous;
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          if (!simultaneous[otherRecognizer.id]) {
              simultaneous[otherRecognizer.id] = otherRecognizer;
              otherRecognizer.recognizeWith(this);
          }
          return this;
      },

      /**
       * drop the simultaneous link. it doesnt remove the link on the other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      dropRecognizeWith: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
              return this;
          }

          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          delete this.simultaneous[otherRecognizer.id];
          return this;
      },

      /**
       * recognizer can only run when an other is failing
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      requireFailure: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
              return this;
          }

          var requireFail = this.requireFail;
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          if (inArray(requireFail, otherRecognizer) === -1) {
              requireFail.push(otherRecognizer);
              otherRecognizer.requireFailure(this);
          }
          return this;
      },

      /**
       * drop the requireFailure link. it does not remove the link on the other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      dropRequireFailure: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
              return this;
          }

          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          var index = inArray(this.requireFail, otherRecognizer);
          if (index > -1) {
              this.requireFail.splice(index, 1);
          }
          return this;
      },

      /**
       * has require failures boolean
       * @returns {boolean}
       */
      hasRequireFailures: function() {
          return this.requireFail.length > 0;
      },

      /**
       * if the recognizer can recognize simultaneous with an other recognizer
       * @param {Recognizer} otherRecognizer
       * @returns {Boolean}
       */
      canRecognizeWith: function(otherRecognizer) {
          return !!this.simultaneous[otherRecognizer.id];
      },

      /**
       * You should use `tryEmit` instead of `emit` directly to check
       * that all the needed recognizers has failed before emitting.
       * @param {Object} input
       */
      emit: function(input) {
          var self = this;
          var state = this.state;

          function emit(event) {
              self.manager.emit(event, input);
          }

          // 'panstart' and 'panmove'
          if (state < STATE_ENDED) {
              emit(self.options.event + stateStr(state));
          }

          emit(self.options.event); // simple 'eventName' events

          if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)
              emit(input.additionalEvent);
          }

          // panend and pancancel
          if (state >= STATE_ENDED) {
              emit(self.options.event + stateStr(state));
          }
      },

      /**
       * Check that all the require failure recognizers has failed,
       * if true, it emits a gesture event,
       * otherwise, setup the state to FAILED.
       * @param {Object} input
       */
      tryEmit: function(input) {
          if (this.canEmit()) {
              return this.emit(input);
          }
          // it's failing anyway
          this.state = STATE_FAILED;
      },

      /**
       * can we emit?
       * @returns {boolean}
       */
      canEmit: function() {
          var i = 0;
          while (i < this.requireFail.length) {
              if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                  return false;
              }
              i++;
          }
          return true;
      },

      /**
       * update the recognizer
       * @param {Object} inputData
       */
      recognize: function(inputData) {
          // make a new copy of the inputData
          // so we can change the inputData without messing up the other recognizers
          var inputDataClone = assign({}, inputData);

          // is is enabled and allow recognizing?
          if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
              this.reset();
              this.state = STATE_FAILED;
              return;
          }

          // reset when we've reached the end
          if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
              this.state = STATE_POSSIBLE;
          }

          this.state = this.process(inputDataClone);

          // the recognizer has recognized a gesture
          // so trigger an event
          if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
              this.tryEmit(inputDataClone);
          }
      },

      /**
       * return the state of the recognizer
       * the actual recognizing happens in this method
       * @virtual
       * @param {Object} inputData
       * @returns {Const} STATE
       */
      process: function(inputData) { }, // jshint ignore:line

      /**
       * return the preferred touch-action
       * @virtual
       * @returns {Array}
       */
      getTouchAction: function() { },

      /**
       * called when the gesture isn't allowed to recognize
       * like when another is being recognized or it is disabled
       * @virtual
       */
      reset: function() { }
  };

  /**
   * get a usable string, used as event postfix
   * @param {Const} state
   * @returns {String} state
   */
  function stateStr(state) {
      if (state & STATE_CANCELLED) {
          return 'cancel';
      } else if (state & STATE_ENDED) {
          return 'end';
      } else if (state & STATE_CHANGED) {
          return 'move';
      } else if (state & STATE_BEGAN) {
          return 'start';
      }
      return '';
  }

  /**
   * direction cons to string
   * @param {Const} direction
   * @returns {String}
   */
  function directionStr(direction) {
      if (direction == DIRECTION_DOWN) {
          return 'down';
      } else if (direction == DIRECTION_UP) {
          return 'up';
      } else if (direction == DIRECTION_LEFT) {
          return 'left';
      } else if (direction == DIRECTION_RIGHT) {
          return 'right';
      }
      return '';
  }

  /**
   * get a recognizer by name if it is bound to a manager
   * @param {Recognizer|String} otherRecognizer
   * @param {Recognizer} recognizer
   * @returns {Recognizer}
   */
  function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
      var manager = recognizer.manager;
      if (manager) {
          return manager.get(otherRecognizer);
      }
      return otherRecognizer;
  }

  /**
   * This recognizer is just used as a base for the simple attribute recognizers.
   * @constructor
   * @extends Recognizer
   */
  function AttrRecognizer() {
      Recognizer.apply(this, arguments);
  }

  inherit(AttrRecognizer, Recognizer, {
      /**
       * @namespace
       * @memberof AttrRecognizer
       */
      defaults: {
          /**
           * @type {Number}
           * @default 1
           */
          pointers: 1
      },

      /**
       * Used to check if it the recognizer receives valid input, like input.distance > 10.
       * @memberof AttrRecognizer
       * @param {Object} input
       * @returns {Boolean} recognized
       */
      attrTest: function(input) {
          var optionPointers = this.options.pointers;
          return optionPointers === 0 || input.pointers.length === optionPointers;
      },

      /**
       * Process the input and return the state for the recognizer
       * @memberof AttrRecognizer
       * @param {Object} input
       * @returns {*} State
       */
      process: function(input) {
          var state = this.state;
          var eventType = input.eventType;

          var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
          var isValid = this.attrTest(input);

          // on cancel input and we've recognized before, return STATE_CANCELLED
          if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
              return state | STATE_CANCELLED;
          } else if (isRecognized || isValid) {
              if (eventType & INPUT_END) {
                  return state | STATE_ENDED;
              } else if (!(state & STATE_BEGAN)) {
                  return STATE_BEGAN;
              }
              return state | STATE_CHANGED;
          }
          return STATE_FAILED;
      }
  });

  /**
   * Pan
   * Recognized when the pointer is down and moved in the allowed direction.
   * @constructor
   * @extends AttrRecognizer
   */
  function PanRecognizer() {
      AttrRecognizer.apply(this, arguments);

      this.pX = null;
      this.pY = null;
  }

  inherit(PanRecognizer, AttrRecognizer, {
      /**
       * @namespace
       * @memberof PanRecognizer
       */
      defaults: {
          event: 'pan',
          threshold: 10,
          pointers: 1,
          direction: DIRECTION_ALL
      },

      getTouchAction: function() {
          var direction = this.options.direction;
          var actions = [];
          if (direction & DIRECTION_HORIZONTAL) {
              actions.push(TOUCH_ACTION_PAN_Y);
          }
          if (direction & DIRECTION_VERTICAL) {
              actions.push(TOUCH_ACTION_PAN_X);
          }
          return actions;
      },

      directionTest: function(input) {
          var options = this.options;
          var hasMoved = true;
          var distance = input.distance;
          var direction = input.direction;
          var x = input.deltaX;
          var y = input.deltaY;

          // lock to axis?
          if (!(direction & options.direction)) {
              if (options.direction & DIRECTION_HORIZONTAL) {
                  direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                  hasMoved = x != this.pX;
                  distance = Math.abs(input.deltaX);
              } else {
                  direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                  hasMoved = y != this.pY;
                  distance = Math.abs(input.deltaY);
              }
          }
          input.direction = direction;
          return hasMoved && distance > options.threshold && direction & options.direction;
      },

      attrTest: function(input) {
          return AttrRecognizer.prototype.attrTest.call(this, input) &&
              (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
      },

      emit: function(input) {

          this.pX = input.deltaX;
          this.pY = input.deltaY;

          var direction = directionStr(input.direction);

          if (direction) {
              input.additionalEvent = this.options.event + direction;
          }
          this._super.emit.call(this, input);
      }
  });

  /**
   * Pinch
   * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
   * @constructor
   * @extends AttrRecognizer
   */
  function PinchRecognizer() {
      AttrRecognizer.apply(this, arguments);
  }

  inherit(PinchRecognizer, AttrRecognizer, {
      /**
       * @namespace
       * @memberof PinchRecognizer
       */
      defaults: {
          event: 'pinch',
          threshold: 0,
          pointers: 2
      },

      getTouchAction: function() {
          return [TOUCH_ACTION_NONE];
      },

      attrTest: function(input) {
          return this._super.attrTest.call(this, input) &&
              (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
      },

      emit: function(input) {
          if (input.scale !== 1) {
              var inOut = input.scale < 1 ? 'in' : 'out';
              input.additionalEvent = this.options.event + inOut;
          }
          this._super.emit.call(this, input);
      }
  });

  /**
   * Press
   * Recognized when the pointer is down for x ms without any movement.
   * @constructor
   * @extends Recognizer
   */
  function PressRecognizer() {
      Recognizer.apply(this, arguments);

      this._timer = null;
      this._input = null;
  }

  inherit(PressRecognizer, Recognizer, {
      /**
       * @namespace
       * @memberof PressRecognizer
       */
      defaults: {
          event: 'press',
          pointers: 1,
          time: 251, // minimal time of the pointer to be pressed
          threshold: 9 // a minimal movement is ok, but keep it low
      },

      getTouchAction: function() {
          return [TOUCH_ACTION_AUTO];
      },

      process: function(input) {
          var options = this.options;
          var validPointers = input.pointers.length === options.pointers;
          var validMovement = input.distance < options.threshold;
          var validTime = input.deltaTime > options.time;

          this._input = input;

          // we only allow little movement
          // and we've reached an end event, so a tap is possible
          if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
              this.reset();
          } else if (input.eventType & INPUT_START) {
              this.reset();
              this._timer = setTimeoutContext(function() {
                  this.state = STATE_RECOGNIZED;
                  this.tryEmit();
              }, options.time, this);
          } else if (input.eventType & INPUT_END) {
              return STATE_RECOGNIZED;
          }
          return STATE_FAILED;
      },

      reset: function() {
          clearTimeout(this._timer);
      },

      emit: function(input) {
          if (this.state !== STATE_RECOGNIZED) {
              return;
          }

          if (input && (input.eventType & INPUT_END)) {
              this.manager.emit(this.options.event + 'up', input);
          } else {
              this._input.timeStamp = now();
              this.manager.emit(this.options.event, this._input);
          }
      }
  });

  /**
   * Rotate
   * Recognized when two or more pointer are moving in a circular motion.
   * @constructor
   * @extends AttrRecognizer
   */
  function RotateRecognizer() {
      AttrRecognizer.apply(this, arguments);
  }

  inherit(RotateRecognizer, AttrRecognizer, {
      /**
       * @namespace
       * @memberof RotateRecognizer
       */
      defaults: {
          event: 'rotate',
          threshold: 0,
          pointers: 2
      },

      getTouchAction: function() {
          return [TOUCH_ACTION_NONE];
      },

      attrTest: function(input) {
          return this._super.attrTest.call(this, input) &&
              (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
      }
  });

  /**
   * Swipe
   * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
   * @constructor
   * @extends AttrRecognizer
   */
  function SwipeRecognizer() {
      AttrRecognizer.apply(this, arguments);
  }

  inherit(SwipeRecognizer, AttrRecognizer, {
      /**
       * @namespace
       * @memberof SwipeRecognizer
       */
      defaults: {
          event: 'swipe',
          threshold: 10,
          velocity: 0.3,
          direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
          pointers: 1
      },

      getTouchAction: function() {
          return PanRecognizer.prototype.getTouchAction.call(this);
      },

      attrTest: function(input) {
          var direction = this.options.direction;
          var velocity;

          if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
              velocity = input.overallVelocity;
          } else if (direction & DIRECTION_HORIZONTAL) {
              velocity = input.overallVelocityX;
          } else if (direction & DIRECTION_VERTICAL) {
              velocity = input.overallVelocityY;
          }

          return this._super.attrTest.call(this, input) &&
              direction & input.offsetDirection &&
              input.distance > this.options.threshold &&
              input.maxPointers == this.options.pointers &&
              abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
      },

      emit: function(input) {
          var direction = directionStr(input.offsetDirection);
          if (direction) {
              this.manager.emit(this.options.event + direction, input);
          }

          this.manager.emit(this.options.event, input);
      }
  });

  /**
   * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
   * between the given interval and position. The delay option can be used to recognize multi-taps without firing
   * a single tap.
   *
   * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
   * multi-taps being recognized.
   * @constructor
   * @extends Recognizer
   */
  function TapRecognizer() {
      Recognizer.apply(this, arguments);

      // previous time and center,
      // used for tap counting
      this.pTime = false;
      this.pCenter = false;

      this._timer = null;
      this._input = null;
      this.count = 0;
  }

  inherit(TapRecognizer, Recognizer, {
      /**
       * @namespace
       * @memberof PinchRecognizer
       */
      defaults: {
          event: 'tap',
          pointers: 1,
          taps: 1,
          interval: 300, // max time between the multi-tap taps
          time: 250, // max time of the pointer to be down (like finger on the screen)
          threshold: 9, // a minimal movement is ok, but keep it low
          posThreshold: 10 // a multi-tap can be a bit off the initial position
      },

      getTouchAction: function() {
          return [TOUCH_ACTION_MANIPULATION];
      },

      process: function(input) {
          var options = this.options;

          var validPointers = input.pointers.length === options.pointers;
          var validMovement = input.distance < options.threshold;
          var validTouchTime = input.deltaTime < options.time;

          this.reset();

          if ((input.eventType & INPUT_START) && (this.count === 0)) {
              return this.failTimeout();
          }

          // we only allow little movement
          // and we've reached an end event, so a tap is possible
          if (validMovement && validTouchTime && validPointers) {
              if (input.eventType != INPUT_END) {
                  return this.failTimeout();
              }

              var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
              var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

              this.pTime = input.timeStamp;
              this.pCenter = input.center;

              if (!validMultiTap || !validInterval) {
                  this.count = 1;
              } else {
                  this.count += 1;
              }

              this._input = input;

              // if tap count matches we have recognized it,
              // else it has began recognizing...
              var tapCount = this.count % options.taps;
              if (tapCount === 0) {
                  // no failing requirements, immediately trigger the tap event
                  // or wait as long as the multitap interval to trigger
                  if (!this.hasRequireFailures()) {
                      return STATE_RECOGNIZED;
                  } else {
                      this._timer = setTimeoutContext(function() {
                          this.state = STATE_RECOGNIZED;
                          this.tryEmit();
                      }, options.interval, this);
                      return STATE_BEGAN;
                  }
              }
          }
          return STATE_FAILED;
      },

      failTimeout: function() {
          this._timer = setTimeoutContext(function() {
              this.state = STATE_FAILED;
          }, this.options.interval, this);
          return STATE_FAILED;
      },

      reset: function() {
          clearTimeout(this._timer);
      },

      emit: function() {
          if (this.state == STATE_RECOGNIZED) {
              this._input.tapCount = this.count;
              this.manager.emit(this.options.event, this._input);
          }
      }
  });

  /**
   * Simple way to create a manager with a default set of recognizers.
   * @param {HTMLElement} element
   * @param {Object} [options]
   * @constructor
   */
  function Hammer(element, options) {
      options = options || {};
      options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
      return new Manager(element, options);
  }

  /**
   * @const {string}
   */
  Hammer.VERSION = '2.0.6';

  /**
   * default settings
   * @namespace
   */
  Hammer.defaults = {
      /**
       * set if DOM events are being triggered.
       * But this is slower and unused by simple implementations, so disabled by default.
       * @type {Boolean}
       * @default false
       */
      domEvents: false,

      /**
       * The value for the touchAction property/fallback.
       * When set to `compute` it will magically set the correct value based on the added recognizers.
       * @type {String}
       * @default compute
       */
      touchAction: TOUCH_ACTION_COMPUTE,

      /**
       * @type {Boolean}
       * @default true
       */
      enable: true,

      /**
       * EXPERIMENTAL FEATURE -- can be removed/changed
       * Change the parent input target element.
       * If Null, then it is being set the to main element.
       * @type {Null|EventTarget}
       * @default null
       */
      inputTarget: null,

      /**
       * force an input class
       * @type {Null|Function}
       * @default null
       */
      inputClass: null,

      /**
       * Default recognizer setup when calling `Hammer()`
       * When creating a new Manager these will be skipped.
       * @type {Array}
       */
      preset: [
          // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
          [RotateRecognizer, {enable: false}],
          [PinchRecognizer, {enable: false}, ['rotate']],
          [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
          [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],
          [TapRecognizer],
          [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],
          [PressRecognizer]
      ],

      /**
       * Some CSS properties can be used to improve the working of Hammer.
       * Add them to this method and they will be set when creating a new Manager.
       * @namespace
       */
      cssProps: {
          /**
           * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userSelect: 'none',

          /**
           * Disable the Windows Phone grippers when pressing an element.
           * @type {String}
           * @default 'none'
           */
          touchSelect: 'none',

          /**
           * Disables the default callout shown when you touch and hold a touch target.
           * On iOS, when you touch and hold a touch target such as a link, Safari displays
           * a callout containing information about the link. This property allows you to disable that callout.
           * @type {String}
           * @default 'none'
           */
          touchCallout: 'none',

          /**
           * Specifies whether zooming is enabled. Used by IE10>
           * @type {String}
           * @default 'none'
           */
          contentZooming: 'none',

          /**
           * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userDrag: 'none',

          /**
           * Overrides the highlight color shown when the user taps a link or a JavaScript
           * clickable element in iOS. This property obeys the alpha value, if specified.
           * @type {String}
           * @default 'rgba(0,0,0,0)'
           */
          tapHighlightColor: 'rgba(0,0,0,0)'
      }
  };

  var STOP = 1;
  var FORCED_STOP = 2;

  /**
   * Manager
   * @param {HTMLElement} element
   * @param {Object} [options]
   * @constructor
   */
  function Manager(element, options) {
      this.options = assign({}, Hammer.defaults, options || {});

      this.options.inputTarget = this.options.inputTarget || element;

      this.handlers = {};
      this.session = {};
      this.recognizers = [];

      this.element = element;
      this.input = createInputInstance(this);
      this.touchAction = new TouchAction(this, this.options.touchAction);

      toggleCssProps(this, true);

      each(this.options.recognizers, function(item) {
          var recognizer = this.add(new (item[0])(item[1]));
          item[2] && recognizer.recognizeWith(item[2]);
          item[3] && recognizer.requireFailure(item[3]);
      }, this);
  }

  Manager.prototype = {
      /**
       * set options
       * @param {Object} options
       * @returns {Manager}
       */
      set: function(options) {
          assign(this.options, options);

          // Options that need a little more setup
          if (options.touchAction) {
              this.touchAction.update();
          }
          if (options.inputTarget) {
              // Clean up existing event listeners and reinitialize
              this.input.destroy();
              this.input.target = options.inputTarget;
              this.input.init();
          }
          return this;
      },

      /**
       * stop recognizing for this session.
       * This session will be discarded, when a new [input]start event is fired.
       * When forced, the recognizer cycle is stopped immediately.
       * @param {Boolean} [force]
       */
      stop: function(force) {
          this.session.stopped = force ? FORCED_STOP : STOP;
      },

      /**
       * run the recognizers!
       * called by the inputHandler function on every movement of the pointers (touches)
       * it walks through all the recognizers and tries to detect the gesture that is being made
       * @param {Object} inputData
       */
      recognize: function(inputData) {
          var session = this.session;
          if (session.stopped) {
              return;
          }

          // run the touch-action polyfill
          this.touchAction.preventDefaults(inputData);

          var recognizer;
          var recognizers = this.recognizers;

          // this holds the recognizer that is being recognized.
          // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
          // if no recognizer is detecting a thing, it is set to `null`
          var curRecognizer = session.curRecognizer;

          // reset when the last recognizer is recognized
          // or when we're in a new session
          if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
              curRecognizer = session.curRecognizer = null;
          }

          var i = 0;
          while (i < recognizers.length) {
              recognizer = recognizers[i];

              // find out if we are allowed try to recognize the input for this one.
              // 1.   allow if the session is NOT forced stopped (see the .stop() method)
              // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
              //      that is being recognized.
              // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
              //      this can be setup with the `recognizeWith()` method on the recognizer.
              if (session.stopped !== FORCED_STOP && ( // 1
                      !curRecognizer || recognizer == curRecognizer || // 2
                      recognizer.canRecognizeWith(curRecognizer))) { // 3
                  recognizer.recognize(inputData);
              } else {
                  recognizer.reset();
              }

              // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
              // current active recognizer. but only if we don't already have an active recognizer
              if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                  curRecognizer = session.curRecognizer = recognizer;
              }
              i++;
          }
      },

      /**
       * get a recognizer by its event name.
       * @param {Recognizer|String} recognizer
       * @returns {Recognizer|Null}
       */
      get: function(recognizer) {
          if (recognizer instanceof Recognizer) {
              return recognizer;
          }

          var recognizers = this.recognizers;
          for (var i = 0; i < recognizers.length; i++) {
              if (recognizers[i].options.event == recognizer) {
                  return recognizers[i];
              }
          }
          return null;
      },

      /**
       * add a recognizer to the manager
       * existing recognizers with the same event name will be removed
       * @param {Recognizer} recognizer
       * @returns {Recognizer|Manager}
       */
      add: function(recognizer) {
          if (invokeArrayArg(recognizer, 'add', this)) {
              return this;
          }

          // remove existing
          var existing = this.get(recognizer.options.event);
          if (existing) {
              this.remove(existing);
          }

          this.recognizers.push(recognizer);
          recognizer.manager = this;

          this.touchAction.update();
          return recognizer;
      },

      /**
       * remove a recognizer by name or instance
       * @param {Recognizer|String} recognizer
       * @returns {Manager}
       */
      remove: function(recognizer) {
          if (invokeArrayArg(recognizer, 'remove', this)) {
              return this;
          }

          recognizer = this.get(recognizer);

          // let's make sure this recognizer exists
          if (recognizer) {
              var recognizers = this.recognizers;
              var index = inArray(recognizers, recognizer);

              if (index !== -1) {
                  recognizers.splice(index, 1);
                  this.touchAction.update();
              }
          }

          return this;
      },

      /**
       * bind event
       * @param {String} events
       * @param {Function} handler
       * @returns {EventEmitter} this
       */
      on: function(events, handler) {
          var handlers = this.handlers;
          each(splitStr(events), function(event) {
              handlers[event] = handlers[event] || [];
              handlers[event].push(handler);
          });
          return this;
      },

      /**
       * unbind event, leave emit blank to remove all handlers
       * @param {String} events
       * @param {Function} [handler]
       * @returns {EventEmitter} this
       */
      off: function(events, handler) {
          var handlers = this.handlers;
          each(splitStr(events), function(event) {
              if (!handler) {
                  delete handlers[event];
              } else {
                  handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
              }
          });
          return this;
      },

      /**
       * emit event to the listeners
       * @param {String} event
       * @param {Object} data
       */
      emit: function(event, data) {
          // we also want to trigger dom events
          if (this.options.domEvents) {
              triggerDomEvent(event, data);
          }

          // no handlers, so skip it all
          var handlers = this.handlers[event] && this.handlers[event].slice();
          if (!handlers || !handlers.length) {
              return;
          }

          data.type = event;
          data.preventDefault = function() {
              data.srcEvent.preventDefault();
          };

          var i = 0;
          while (i < handlers.length) {
              handlers[i](data);
              i++;
          }
      },

      /**
       * destroy the manager and unbinds all events
       * it doesn't unbind dom events, that is the user own responsibility
       */
      destroy: function() {
          this.element && toggleCssProps(this, false);

          this.handlers = {};
          this.session = {};
          this.input.destroy();
          this.element = null;
      }
  };

  /**
   * add/remove the css properties as defined in manager.options.cssProps
   * @param {Manager} manager
   * @param {Boolean} add
   */
  function toggleCssProps(manager, add) {
      var element = manager.element;
      if (!element.style) {
          return;
      }
      each(manager.options.cssProps, function(value, name) {
          element.style[prefixed(element.style, name)] = add ? value : '';
      });
  }

  /**
   * trigger dom event
   * @param {String} event
   * @param {Object} data
   */
  function triggerDomEvent(event, data) {
      var gestureEvent = document.createEvent('Event');
      gestureEvent.initEvent(event, true, true);
      gestureEvent.gesture = data;
      data.target.dispatchEvent(gestureEvent);
  }

  assign(Hammer, {
      INPUT_START: INPUT_START,
      INPUT_MOVE: INPUT_MOVE,
      INPUT_END: INPUT_END,
      INPUT_CANCEL: INPUT_CANCEL,

      STATE_POSSIBLE: STATE_POSSIBLE,
      STATE_BEGAN: STATE_BEGAN,
      STATE_CHANGED: STATE_CHANGED,
      STATE_ENDED: STATE_ENDED,
      STATE_RECOGNIZED: STATE_RECOGNIZED,
      STATE_CANCELLED: STATE_CANCELLED,
      STATE_FAILED: STATE_FAILED,

      DIRECTION_NONE: DIRECTION_NONE,
      DIRECTION_LEFT: DIRECTION_LEFT,
      DIRECTION_RIGHT: DIRECTION_RIGHT,
      DIRECTION_UP: DIRECTION_UP,
      DIRECTION_DOWN: DIRECTION_DOWN,
      DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
      DIRECTION_VERTICAL: DIRECTION_VERTICAL,
      DIRECTION_ALL: DIRECTION_ALL,

      Manager: Manager,
      Input: Input,
      TouchAction: TouchAction,

      TouchInput: TouchInput,
      MouseInput: MouseInput,
      PointerEventInput: PointerEventInput,
      TouchMouseInput: TouchMouseInput,
      SingleTouchInput: SingleTouchInput,

      Recognizer: Recognizer,
      AttrRecognizer: AttrRecognizer,
      Tap: TapRecognizer,
      Pan: PanRecognizer,
      Swipe: SwipeRecognizer,
      Pinch: PinchRecognizer,
      Rotate: RotateRecognizer,
      Press: PressRecognizer,

      on: addEventListeners,
      off: removeEventListeners,
      each: each,
      merge: merge,
      extend: extend,
      assign: assign,
      inherit: inherit,
      bindFn: bindFn,
      prefixed: prefixed
  });

  // this prevents errors when Hammer is loaded in the presence of an AMD
  //  style loader but by script tag, not by the loader.
  var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line
  freeGlobal.Hammer = Hammer;

  if (true) {
      !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
          return Hammer;
      }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof module != 'undefined' && module.exports) {
      module.exports = Hammer;
  } else {
      window[exportName] = Hammer;
  }

  })(window, document, 'Hammer');


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

  var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;"use strict";
  /**
   * Created by Alex on 11/6/2014.
   */

  // https://github.com/umdjs/umd/blob/master/returnExports.js#L40-L60
  // if the module has no dependencies, the above pattern can be simplified to
  (function (root, factory) {
    if (true) {
      // AMD. Register as an anonymous module.
      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if (typeof exports === 'object') {
      // Node. Does not work with strict CommonJS, but
      // only CommonJS-like environments that support module.exports,
      // like Node.
      module.exports = factory();
    } else {
      // Browser globals (root is window)
      root.keycharm = factory();
    }
  }(this, function () {

    function keycharm(options) {
      var preventDefault = options && options.preventDefault || false;

      var container = options && options.container || window;

      var _exportFunctions = {};
      var _bound = {keydown:{}, keyup:{}};
      var _keys = {};
      var i;

      // a - z
      for (i = 97; i <= 122; i++) {_keys[String.fromCharCode(i)] = {code:65 + (i - 97), shift: false};}
      // A - Z
      for (i = 65; i <= 90; i++) {_keys[String.fromCharCode(i)] = {code:i, shift: true};}
      // 0 - 9
      for (i = 0;  i <= 9;   i++) {_keys['' + i] = {code:48 + i, shift: false};}
      // F1 - F12
      for (i = 1;  i <= 12;   i++) {_keys['F' + i] = {code:111 + i, shift: false};}
      // num0 - num9
      for (i = 0;  i <= 9;   i++) {_keys['num' + i] = {code:96 + i, shift: false};}

      // numpad misc
      _keys['num*'] = {code:106, shift: false};
      _keys['num+'] = {code:107, shift: false};
      _keys['num-'] = {code:109, shift: false};
      _keys['num/'] = {code:111, shift: false};
      _keys['num.'] = {code:110, shift: false};
      // arrows
      _keys['left']  = {code:37, shift: false};
      _keys['up']    = {code:38, shift: false};
      _keys['right'] = {code:39, shift: false};
      _keys['down']  = {code:40, shift: false};
      // extra keys
      _keys['space'] = {code:32, shift: false};
      _keys['enter'] = {code:13, shift: false};
      _keys['shift'] = {code:16, shift: undefined};
      _keys['esc']   = {code:27, shift: false};
      _keys['backspace'] = {code:8, shift: false};
      _keys['tab']       = {code:9, shift: false};
      _keys['ctrl']      = {code:17, shift: false};
      _keys['alt']       = {code:18, shift: false};
      _keys['delete']    = {code:46, shift: false};
      _keys['pageup']    = {code:33, shift: false};
      _keys['pagedown']  = {code:34, shift: false};
      // symbols
      _keys['=']     = {code:187, shift: false};
      _keys['-']     = {code:189, shift: false};
      _keys[']']     = {code:221, shift: false};
      _keys['[']     = {code:219, shift: false};



      var down = function(event) {handleEvent(event,'keydown');};
      var up = function(event) {handleEvent(event,'keyup');};

      // handle the actualy bound key with the event
      var handleEvent = function(event,type) {
        if (_bound[type][event.keyCode] !== undefined) {
          var bound = _bound[type][event.keyCode];
          for (var i = 0; i < bound.length; i++) {
            if (bound[i].shift === undefined) {
              bound[i].fn(event);
            }
            else if (bound[i].shift == true && event.shiftKey == true) {
              bound[i].fn(event);
            }
            else if (bound[i].shift == false && event.shiftKey == false) {
              bound[i].fn(event);
            }
          }

          if (preventDefault == true) {
            event.preventDefault();
          }
        }
      };

      // bind a key to a callback
      _exportFunctions.bind = function(key, callback, type) {
        if (type === undefined) {
          type = 'keydown';
        }
        if (_keys[key] === undefined) {
          throw new Error("unsupported key: " + key);
        }
        if (_bound[type][_keys[key].code] === undefined) {
          _bound[type][_keys[key].code] = [];
        }
        _bound[type][_keys[key].code].push({fn:callback, shift:_keys[key].shift});
      };


      // bind all keys to a call back (demo purposes)
      _exportFunctions.bindAll = function(callback, type) {
        if (type === undefined) {
          type = 'keydown';
        }
        for (var key in _keys) {
          if (_keys.hasOwnProperty(key)) {
            _exportFunctions.bind(key,callback,type);
          }
        }
      };

      // get the key label from an event
      _exportFunctions.getKey = function(event) {
        for (var key in _keys) {
          if (_keys.hasOwnProperty(key)) {
            if (event.shiftKey == true && _keys[key].shift == true && event.keyCode == _keys[key].code) {
              return key;
            }
            else if (event.shiftKey == false && _keys[key].shift == false && event.keyCode == _keys[key].code) {
              return key;
            }
            else if (event.keyCode == _keys[key].code && key == 'shift') {
              return key;
            }
          }
        }
        return "unknown key, currently not supported";
      };

      // unbind either a specific callback from a key or all of them (by leaving callback undefined)
      _exportFunctions.unbind = function(key, callback, type) {
        if (type === undefined) {
          type = 'keydown';
        }
        if (_keys[key] === undefined) {
          throw new Error("unsupported key: " + key);
        }
        if (callback !== undefined) {
          var newBindings = [];
          var bound = _bound[type][_keys[key].code];
          if (bound !== undefined) {
            for (var i = 0; i < bound.length; i++) {
              if (!(bound[i].fn == callback && bound[i].shift == _keys[key].shift)) {
                newBindings.push(_bound[type][_keys[key].code][i]);
              }
            }
          }
          _bound[type][_keys[key].code] = newBindings;
        }
        else {
          _bound[type][_keys[key].code] = [];
        }
      };

      // reset all bound variables.
      _exportFunctions.reset = function() {
        _bound = {keydown:{}, keyup:{}};
      };

      // unbind all listeners and reset all variables.
      _exportFunctions.destroy = function() {
        _bound = {keydown:{}, keyup:{}};
        container.removeEventListener('keydown', down, true);
        container.removeEventListener('keyup', up, true);
      };

      // create listeners.
      container.addEventListener('keydown',down,true);
      container.addEventListener('keyup',up,true);

      // return the public functions.
      return _exportFunctions;
    }

    return keycharm;
  }));




/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  // utils
  exports.util = __webpack_require__(1);
  exports.DOMutil = __webpack_require__(8);

  // data
  exports.DataSet = __webpack_require__(9);
  exports.DataView = __webpack_require__(11);
  exports.Queue = __webpack_require__(10);

  // Timeline
  exports.Timeline = __webpack_require__(25);
  exports.Graph2d = __webpack_require__(50);
  exports.timeline = {
    Core: __webpack_require__(33),
    DateUtil: __webpack_require__(32),
    Range: __webpack_require__(30),
    stack: __webpack_require__(37),
    TimeStep: __webpack_require__(35),

    components: {
      items: {
        Item: __webpack_require__(39),
        BackgroundItem: __webpack_require__(43),
        BoxItem: __webpack_require__(41),
        PointItem: __webpack_require__(42),
        RangeItem: __webpack_require__(38)
      },

      BackgroundGroup: __webpack_require__(40),
      Component: __webpack_require__(31),
      CurrentTime: __webpack_require__(48),
      CustomTime: __webpack_require__(46),
      DataAxis: __webpack_require__(52),
      DataScale: __webpack_require__(53),
      GraphGroup: __webpack_require__(54),
      Group: __webpack_require__(36),
      ItemSet: __webpack_require__(34),
      Legend: __webpack_require__(58),
      LineGraph: __webpack_require__(51),
      TimeAxis: __webpack_require__(44)
    }
  };

  // bundled external libraries
  exports.moment = __webpack_require__(2);
  exports.Hammer = __webpack_require__(20);
  exports.keycharm = __webpack_require__(23);

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var _Configurator = __webpack_require__(26);

  var _Configurator2 = _interopRequireDefault(_Configurator);

  var _Validator = __webpack_require__(29);

  var _Validator2 = _interopRequireDefault(_Validator);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var Emitter = __webpack_require__(13);
  var Hammer = __webpack_require__(20);
  var moment = __webpack_require__(2);
  var util = __webpack_require__(1);
  var DataSet = __webpack_require__(9);
  var DataView = __webpack_require__(11);
  var Range = __webpack_require__(30);
  var Core = __webpack_require__(33);
  var TimeAxis = __webpack_require__(44);
  var CurrentTime = __webpack_require__(48);
  var CustomTime = __webpack_require__(46);
  var ItemSet = __webpack_require__(34);

  var printStyle = __webpack_require__(29).printStyle;
  var allOptions = __webpack_require__(49).allOptions;
  var configureOptions = __webpack_require__(49).configureOptions;

  /**
   * Create a timeline visualization
   * @param {HTMLElement} container
   * @param {vis.DataSet | vis.DataView | Array} [items]
   * @param {vis.DataSet | vis.DataView | Array} [groups]
   * @param {Object} [options]  See Timeline.setOptions for the available options.
   * @constructor
   * @extends Core
   */
  function Timeline(container, items, groups, options) {

    if (!(this instanceof Timeline)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    // if the third element is options, the forth is groups (optionally);
    if (!(Array.isArray(groups) || groups instanceof DataSet || groups instanceof DataView) && groups instanceof Object) {
      var forthArgument = options;
      options = groups;
      groups = forthArgument;
    }

    var me = this;
    this.defaultOptions = {
      start: null,
      end: null,

      autoResize: true,
      throttleRedraw: 0, // ms

      orientation: {
        axis: 'bottom', // axis orientation: 'bottom', 'top', or 'both'
        item: 'bottom' // not relevant
      },
      rtl: false,
      moment: moment,

      width: null,
      height: null,
      maxHeight: null,
      minHeight: null
    };
    this.options = util.deepExtend({}, this.defaultOptions);

    // Create the DOM, props, and emitter
    this._create(container);

    // all components listed here will be repainted automatically
    this.components = [];

    this.body = {
      dom: this.dom,
      domProps: this.props,
      emitter: {
        on: this.on.bind(this),
        off: this.off.bind(this),
        emit: this.emit.bind(this)
      },
      hiddenDates: [],
      util: {
        getScale: function getScale() {
          return me.timeAxis.step.scale;
        },
        getStep: function getStep() {
          return me.timeAxis.step.step;
        },

        toScreen: me._toScreen.bind(me),
        toGlobalScreen: me._toGlobalScreen.bind(me), // this refers to the root.width
        toTime: me._toTime.bind(me),
        toGlobalTime: me._toGlobalTime.bind(me)
      }
    };

    // range
    this.range = new Range(this.body);
    this.components.push(this.range);
    this.body.range = this.range;

    // time axis
    this.timeAxis = new TimeAxis(this.body);
    this.timeAxis2 = null; // used in case of orientation option 'both'
    this.components.push(this.timeAxis);

    // current time bar
    this.currentTime = new CurrentTime(this.body);
    this.components.push(this.currentTime);

    // item set
    this.itemSet = new ItemSet(this.body, this.options);
    this.components.push(this.itemSet);

    this.itemsData = null; // DataSet
    this.groupsData = null; // DataSet

    this.on('tap', function (event) {
      me.emit('click', me.getEventProperties(event));
    });
    this.on('doubletap', function (event) {
      me.emit('doubleClick', me.getEventProperties(event));
    });
    this.dom.root.oncontextmenu = function (event) {
      me.emit('contextmenu', me.getEventProperties(event));
    };

    //Single time autoscale/fit
    this.fitDone = false;
    this.on('changed', function () {
      if (this.itemsData == null) return;
      if (!me.fitDone) {
        me.fitDone = true;
        if (me.options.start != undefined || me.options.end != undefined) {
          if (me.options.start == undefined || me.options.end == undefined) {
            var range = me.getItemRange();
          }

          var start = me.options.start != undefined ? me.options.start : range.min;
          var end = me.options.end != undefined ? me.options.end : range.max;

          me.setWindow(start, end, { animation: false });
        } else {
          me.fit({ animation: false });
        }
      }
    });

    // apply options
    if (options) {
      this.setOptions(options);
    }

    // IMPORTANT: THIS HAPPENS BEFORE SET ITEMS!
    if (groups) {
      this.setGroups(groups);
    }

    // create itemset
    if (items) {
      this.setItems(items);
    }

    // draw for the first time
    this._redraw();
  }

  // Extend the functionality from Core
  Timeline.prototype = new Core();

  /**
   * Load a configurator
   * @return {Object}
   * @private
   */
  Timeline.prototype._createConfigurator = function () {
    return new _Configurator2.default(this, this.dom.container, configureOptions);
  };

  /**
   * Force a redraw. The size of all items will be recalculated.
   * Can be useful to manually redraw when option autoResize=false and the window
   * has been resized, or when the items CSS has been changed.
   *
   * Note: this function will be overridden on construction with a trottled version
   */
  Timeline.prototype.redraw = function () {
    this.itemSet && this.itemSet.markDirty({ refreshItems: true });
    this._redraw();
  };

  Timeline.prototype.setOptions = function (options) {
    // validate options
    var errorFound = _Validator2.default.validate(options, allOptions);

    if (errorFound === true) {
      console.log('%cErrors have been found in the supplied options object.', printStyle);
    }

    Core.prototype.setOptions.call(this, options);

    if ('type' in options) {
      if (options.type !== this.options.type) {
        this.options.type = options.type;

        // force recreation of all items
        var itemsData = this.itemsData;
        if (itemsData) {
          var selection = this.getSelection();
          this.setItems(null); // remove all
          this.setItems(itemsData); // add all
          this.setSelection(selection); // restore selection
        }
      }
    }
  };

  /**
   * Set items
   * @param {vis.DataSet | Array | null} items
   */
  Timeline.prototype.setItems = function (items) {
    // convert to type DataSet when needed
    var newDataSet;
    if (!items) {
      newDataSet = null;
    } else if (items instanceof DataSet || items instanceof DataView) {
      newDataSet = items;
    } else {
      // turn an array into a dataset
      newDataSet = new DataSet(items, {
        type: {
          start: 'Date',
          end: 'Date'
        }
      });
    }

    // set items
    this.itemsData = newDataSet;
    this.itemSet && this.itemSet.setItems(newDataSet);
  };

  /**
   * Set groups
   * @param {vis.DataSet | Array} groups
   */
  Timeline.prototype.setGroups = function (groups) {
    // convert to type DataSet when needed
    var newDataSet;
    if (!groups) {
      newDataSet = null;
    } else if (groups instanceof DataSet || groups instanceof DataView) {
      newDataSet = groups;
    } else {
      // turn an array into a dataset
      newDataSet = new DataSet(groups);
    }

    this.groupsData = newDataSet;
    this.itemSet.setGroups(newDataSet);
  };

  /**
   * Set both items and groups in one go
   * @param {{items: Array | vis.DataSet, groups: Array | vis.DataSet}} data
   */
  Timeline.prototype.setData = function (data) {
    if (data && data.groups) {
      this.setGroups(data.groups);
    }

    if (data && data.items) {
      this.setItems(data.items);
    }
  };

  /**
   * Set selected items by their id. Replaces the current selection
   * Unknown id's are silently ignored.
   * @param {string[] | string} [ids]  An array with zero or more id's of the items to be
   *                                selected. If ids is an empty array, all items will be
   *                                unselected.
   * @param {Object} [options]      Available options:
   *                                `focus: boolean`
   *                                    If true, focus will be set to the selected item(s)
   *                                `animation: boolean | {duration: number, easingFunction: string}`
   *                                    If true (default), the range is animated
   *                                    smoothly to the new window. An object can be
   *                                    provided to specify duration and easing function.
   *                                    Default duration is 500 ms, and default easing
   *                                    function is 'easeInOutQuad'.
   *                                    Only applicable when option focus is true.
   */
  Timeline.prototype.setSelection = function (ids, options) {
    this.itemSet && this.itemSet.setSelection(ids);

    if (options && options.focus) {
      this.focus(ids, options);
    }
  };

  /**
   * Get the selected items by their id
   * @return {Array} ids  The ids of the selected items
   */
  Timeline.prototype.getSelection = function () {
    return this.itemSet && this.itemSet.getSelection() || [];
  };

  /**
   * Adjust the visible window such that the selected item (or multiple items)
   * are centered on screen.
   * @param {String | String[]} id     An item id or array with item ids
   * @param {Object} [options]      Available options:
   *                                `animation: boolean | {duration: number, easingFunction: string}`
   *                                    If true (default), the range is animated
   *                                    smoothly to the new window. An object can be
   *                                    provided to specify duration and easing function.
   *                                    Default duration is 500 ms, and default easing
   *                                    function is 'easeInOutQuad'.
   */
  Timeline.prototype.focus = function (id, options) {
    if (!this.itemsData || id == undefined) return;

    var ids = Array.isArray(id) ? id : [id];

    // get the specified item(s)
    var itemsData = this.itemsData.getDataSet().get(ids, {
      type: {
        start: 'Date',
        end: 'Date'
      }
    });

    // calculate minimum start and maximum end of specified items
    var start = null;
    var end = null;
    itemsData.forEach(function (itemData) {
      var s = itemData.start.valueOf();
      var e = 'end' in itemData ? itemData.end.valueOf() : itemData.start.valueOf();

      if (start === null || s < start) {
        start = s;
      }

      if (end === null || e > end) {
        end = e;
      }
    });

    if (start !== null && end !== null) {
      // calculate the new middle and interval for the window
      var middle = (start + end) / 2;
      var interval = Math.max(this.range.end - this.range.start, (end - start) * 1.1);

      var animation = options && options.animation !== undefined ? options.animation : true;
      this.range.setRange(middle - interval / 2, middle + interval / 2, animation);
    }
  };

  /**
   * Set Timeline window such that it fits all items
   * @param {Object} [options]  Available options:
   *                                `animation: boolean | {duration: number, easingFunction: string}`
   *                                    If true (default), the range is animated
   *                                    smoothly to the new window. An object can be
   *                                    provided to specify duration and easing function.
   *                                    Default duration is 500 ms, and default easing
   *                                    function is 'easeInOutQuad'.
   */
  Timeline.prototype.fit = function (options) {
    var animation = options && options.animation !== undefined ? options.animation : true;
    var range;

    var dataset = this.itemsData && this.itemsData.getDataSet();
    if (dataset.length === 1 && dataset.get()[0].end === undefined) {
      // a single item -> don't fit, just show a range around the item from -4 to +3 days
      range = this.getDataRange();
      this.moveTo(range.min.valueOf(), { animation: animation });
    } else {
      // exactly fit the items (plus a small margin)
      range = this.getItemRange();
      this.range.setRange(range.min, range.max, animation);
    }
  };

  /**
   * Determine the range of the items, taking into account their actual width
   * and a margin of 10 pixels on both sides.
   * @return {{min: Date | null, max: Date | null}}
   */
  Timeline.prototype.getItemRange = function () {
    var _this = this;

    // get a rough approximation for the range based on the items start and end dates
    var range = this.getDataRange();
    var min = range.min !== null ? range.min.valueOf() : null;
    var max = range.max !== null ? range.max.valueOf() : null;
    var minItem = null;
    var maxItem = null;

    if (min != null && max != null) {
      var interval;
      var factor;
      var lhs;
      var rhs;
      var delta;

      (function () {
        var getStart = function getStart(item) {
          return util.convert(item.data.start, 'Date').valueOf();
        };

        var getEnd = function getEnd(item) {
          var end = item.data.end != undefined ? item.data.end : item.data.start;
          return util.convert(end, 'Date').valueOf();
        };

        // calculate the date of the left side and right side of the items given


        interval = max - min; // ms

        if (interval <= 0) {
          interval = 10;
        }
        factor = interval / _this.props.center.width;
        util.forEach(_this.itemSet.items, function (item) {
          item.show();
          item.repositionX();

          var start = getStart(item);
          var end = getEnd(item);

          if (this.options.rtl) {
            var startSide = start - (item.getWidthRight() + 10) * factor;
            var endSide = end + (item.getWidthLeft() + 10) * factor;
          } else {
            var startSide = start - (item.getWidthLeft() + 10) * factor;
            var endSide = end + (item.getWidthRight() + 10) * factor;
          }

          if (startSide < min) {
            min = startSide;
            minItem = item;
          }
          if (endSide > max) {
            max = endSide;
            maxItem = item;
          }
        }.bind(_this));

        if (minItem && maxItem) {
          lhs = minItem.getWidthLeft() + 10;
          rhs = maxItem.getWidthRight() + 10;
          delta = _this.props.center.width - lhs - rhs; // px

          if (delta > 0) {
            if (_this.options.rtl) {
              min = getStart(minItem) - rhs * interval / delta; // ms
              max = getEnd(maxItem) + lhs * interval / delta; // ms
            } else {
                min = getStart(minItem) - lhs * interval / delta; // ms
                max = getEnd(maxItem) + rhs * interval / delta; // ms
              }
          }
        }
      })();
    }

    return {
      min: min != null ? new Date(min) : null,
      max: max != null ? new Date(max) : null
    };
  };

  /**
   * Calculate the data range of the items start and end dates
   * @returns {{min: Date | null, max: Date | null}}
   */
  Timeline.prototype.getDataRange = function () {
    var min = null;
    var max = null;

    var dataset = this.itemsData && this.itemsData.getDataSet();
    if (dataset) {
      dataset.forEach(function (item) {
        var start = util.convert(item.start, 'Date').valueOf();
        var end = util.convert(item.end != undefined ? item.end : item.start, 'Date').valueOf();
        if (min === null || start < min) {
          min = start;
        }
        if (max === null || end > max) {
          max = end;
        }
      });
    }

    return {
      min: min != null ? new Date(min) : null,
      max: max != null ? new Date(max) : null
    };
  };

  /**
   * Generate Timeline related information from an event
   * @param {Event} event
   * @return {Object} An object with related information, like on which area
   *                  The event happened, whether clicked on an item, etc.
   */
  Timeline.prototype.getEventProperties = function (event) {
    var clientX = event.center ? event.center.x : event.clientX;
    var clientY = event.center ? event.center.y : event.clientY;
    if (this.options.rtl) {
      var x = util.getAbsoluteRight(this.dom.centerContainer) - clientX;
    } else {
      var x = clientX - util.getAbsoluteLeft(this.dom.centerContainer);
    }
    var y = clientY - util.getAbsoluteTop(this.dom.centerContainer);

    var item = this.itemSet.itemFromTarget(event);
    var group = this.itemSet.groupFromTarget(event);
    var customTime = CustomTime.customTimeFromTarget(event);

    var snap = this.itemSet.options.snap || null;
    var scale = this.body.util.getScale();
    var step = this.body.util.getStep();
    var time = this._toTime(x);
    var snappedTime = snap ? snap(time, scale, step) : time;

    var element = util.getTarget(event);
    var what = null;
    if (item != null) {
      what = 'item';
    } else if (customTime != null) {
      what = 'custom-time';
    } else if (util.hasParent(element, this.timeAxis.dom.foreground)) {
      what = 'axis';
    } else if (this.timeAxis2 && util.hasParent(element, this.timeAxis2.dom.foreground)) {
      what = 'axis';
    } else if (util.hasParent(element, this.itemSet.dom.labelSet)) {
      what = 'group-label';
    } else if (util.hasParent(element, this.currentTime.bar)) {
      what = 'current-time';
    } else if (util.hasParent(element, this.dom.center)) {
      what = 'background';
    }

    return {
      event: event,
      item: item ? item.id : null,
      group: group ? group.groupId : null,
      what: what,
      pageX: event.srcEvent ? event.srcEvent.pageX : event.pageX,
      pageY: event.srcEvent ? event.srcEvent.pageY : event.pageY,
      x: x,
      y: y,
      time: time,
      snappedTime: snappedTime
    };
  };

  module.exports = Timeline;

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _ColorPicker = __webpack_require__(27);

  var _ColorPicker2 = _interopRequireDefault(_ColorPicker);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);

  /**
   * The way this works is for all properties of this.possible options, you can supply the property name in any form to list the options.
   * Boolean options are recognised as Boolean
   * Number options should be written as array: [default value, min value, max value, stepsize]
   * Colors should be written as array: ['color', '#ffffff']
   * Strings with should be written as array: [option1, option2, option3, ..]
   *
   * The options are matched with their counterparts in each of the modules and the values used in the configuration are
   *
   * @param parentModule        | the location where parentModule.setOptions() can be called
   * @param defaultContainer    | the default container of the module
   * @param configureOptions    | the fully configured and predefined options set found in allOptions.js
   * @param pixelRatio          | canvas pixel ratio
   */

  var Configurator = function () {
    function Configurator(parentModule, defaultContainer, configureOptions) {
      var pixelRatio = arguments.length <= 3 || arguments[3] === undefined ? 1 : arguments[3];

      _classCallCheck(this, Configurator);

      this.parent = parentModule;
      this.changedOptions = [];
      this.container = defaultContainer;
      this.allowCreation = false;

      this.options = {};
      this.initialized = false;
      this.popupCounter = 0;
      this.defaultOptions = {
        enabled: false,
        filter: true,
        container: undefined,
        showButton: true
      };
      util.extend(this.options, this.defaultOptions);

      this.configureOptions = configureOptions;
      this.moduleOptions = {};
      this.domElements = [];
      this.popupDiv = {};
      this.popupLimit = 5;
      this.popupHistory = {};
      this.colorPicker = new _ColorPicker2.default(pixelRatio);
      this.wrapper = undefined;
    }

    /**
     * refresh all options.
     * Because all modules parse their options by themselves, we just use their options. We copy them here.
     *
     * @param options
     */


    _createClass(Configurator, [{
      key: 'setOptions',
      value: function setOptions(options) {
        if (options !== undefined) {
          // reset the popup history because the indices may have been changed.
          this.popupHistory = {};
          this._removePopup();

          var enabled = true;
          if (typeof options === 'string') {
            this.options.filter = options;
          } else if (options instanceof Array) {
            this.options.filter = options.join();
          } else if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
            if (options.container !== undefined) {
              this.options.container = options.container;
            }
            if (options.filter !== undefined) {
              this.options.filter = options.filter;
            }
            if (options.showButton !== undefined) {
              this.options.showButton = options.showButton;
            }
            if (options.enabled !== undefined) {
              enabled = options.enabled;
            }
          } else if (typeof options === 'boolean') {
            this.options.filter = true;
            enabled = options;
          } else if (typeof options === 'function') {
            this.options.filter = options;
            enabled = true;
          }
          if (this.options.filter === false) {
            enabled = false;
          }

          this.options.enabled = enabled;
        }
        this._clean();
      }
    }, {
      key: 'setModuleOptions',
      value: function setModuleOptions(moduleOptions) {
        this.moduleOptions = moduleOptions;
        if (this.options.enabled === true) {
          this._clean();
          if (this.options.container !== undefined) {
            this.container = this.options.container;
          }
          this._create();
        }
      }

      /**
       * Create all DOM elements
       * @private
       */

    }, {
      key: '_create',
      value: function _create() {
        var _this = this;

        this._clean();
        this.changedOptions = [];

        var filter = this.options.filter;
        var counter = 0;
        var show = false;
        for (var option in this.configureOptions) {
          if (this.configureOptions.hasOwnProperty(option)) {
            this.allowCreation = false;
            show = false;
            if (typeof filter === 'function') {
              show = filter(option, []);
              show = show || this._handleObject(this.configureOptions[option], [option], true);
            } else if (filter === true || filter.indexOf(option) !== -1) {
              show = true;
            }

            if (show !== false) {
              this.allowCreation = true;

              // linebreak between categories
              if (counter > 0) {
                this._makeItem([]);
              }
              // a header for the category
              this._makeHeader(option);

              // get the sub options
              this._handleObject(this.configureOptions[option], [option]);
            }
            counter++;
          }
        }

        if (this.options.showButton === true) {
          (function () {
            var generateButton = document.createElement('div');
            generateButton.className = 'vis-configuration vis-config-button';
            generateButton.innerHTML = 'generate options';
            generateButton.onclick = function () {
              _this._printOptions();
            };
            generateButton.onmouseover = function () {
              generateButton.className = 'vis-configuration vis-config-button hover';
            };
            generateButton.onmouseout = function () {
              generateButton.className = 'vis-configuration vis-config-button';
            };

            _this.optionsContainer = document.createElement('div');
            _this.optionsContainer.className = 'vis-configuration vis-config-option-container';

            _this.domElements.push(_this.optionsContainer);
            _this.domElements.push(generateButton);
          })();
        }

        this._push();
        //~ this.colorPicker.insertTo(this.container);
      }

      /**
       * draw all DOM elements on the screen
       * @private
       */

    }, {
      key: '_push',
      value: function _push() {
        this.wrapper = document.createElement('div');
        this.wrapper.className = 'vis-configuration-wrapper';
        this.container.appendChild(this.wrapper);
        for (var i = 0; i < this.domElements.length; i++) {
          this.wrapper.appendChild(this.domElements[i]);
        }

        this._showPopupIfNeeded();
      }

      /**
       * delete all DOM elements
       * @private
       */

    }, {
      key: '_clean',
      value: function _clean() {
        for (var i = 0; i < this.domElements.length; i++) {
          this.wrapper.removeChild(this.domElements[i]);
        }

        if (this.wrapper !== undefined) {
          this.container.removeChild(this.wrapper);
          this.wrapper = undefined;
        }
        this.domElements = [];

        this._removePopup();
      }

      /**
       * get the value from the actualOptions if it exists
       * @param {array} path    | where to look for the actual option
       * @returns {*}
       * @private
       */

    }, {
      key: '_getValue',
      value: function _getValue(path) {
        var base = this.moduleOptions;
        for (var i = 0; i < path.length; i++) {
          if (base[path[i]] !== undefined) {
            base = base[path[i]];
          } else {
            base = undefined;
            break;
          }
        }
        return base;
      }

      /**
       * all option elements are wrapped in an item
       * @param path
       * @param domElements
       * @private
       */

    }, {
      key: '_makeItem',
      value: function _makeItem(path) {
        var _arguments = arguments,
            _this2 = this;

        if (this.allowCreation === true) {
          var _len, domElements, _key;

          var _ret2 = function () {
            var item = document.createElement('div');
            item.className = 'vis-configuration vis-config-item vis-config-s' + path.length;

            for (_len = _arguments.length, domElements = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              domElements[_key - 1] = _arguments[_key];
            }

            domElements.forEach(function (element) {
              item.appendChild(element);
            });
            _this2.domElements.push(item);
            return {
              v: _this2.domElements.length
            };
          }();

          if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === "object") return _ret2.v;
        }
        return 0;
      }

      /**
       * header for major subjects
       * @param name
       * @private
       */

    }, {
      key: '_makeHeader',
      value: function _makeHeader(name) {
        var div = document.createElement('div');
        div.className = 'vis-configuration vis-config-header';
        div.innerHTML = name;
        this._makeItem([], div);
      }

      /**
       * make a label, if it is an object label, it gets different styling.
       * @param name
       * @param path
       * @param objectLabel
       * @returns {HTMLElement}
       * @private
       */

    }, {
      key: '_makeLabel',
      value: function _makeLabel(name, path) {
        var objectLabel = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

        var div = document.createElement('div');
        div.className = 'vis-configuration vis-config-label vis-config-s' + path.length;
        if (objectLabel === true) {
          div.innerHTML = '<i><b>' + name + ':</b></i>';
        } else {
          div.innerHTML = name + ':';
        }
        return div;
      }

      /**
       * make a dropdown list for multiple possible string optoins
       * @param arr
       * @param value
       * @param path
       * @private
       */

    }, {
      key: '_makeDropdown',
      value: function _makeDropdown(arr, value, path) {
        var select = document.createElement('select');
        select.className = 'vis-configuration vis-config-select';
        var selectedValue = 0;
        if (value !== undefined) {
          if (arr.indexOf(value) !== -1) {
            selectedValue = arr.indexOf(value);
          }
        }

        for (var i = 0; i < arr.length; i++) {
          var option = document.createElement('option');
          option.value = arr[i];
          if (i === selectedValue) {
            option.selected = 'selected';
          }
          option.innerHTML = arr[i];
          select.appendChild(option);
        }

        var me = this;
        select.onchange = function () {
          me._update(this.value, path);
        };

        var label = this._makeLabel(path[path.length - 1], path);
        this._makeItem(path, label, select);
      }

      /**
       * make a range object for numeric options
       * @param arr
       * @param value
       * @param path
       * @private
       */

    }, {
      key: '_makeRange',
      value: function _makeRange(arr, value, path) {
        var defaultValue = arr[0];
        var min = arr[1];
        var max = arr[2];
        var step = arr[3];
        var range = document.createElement('input');
        range.className = 'vis-configuration vis-config-range';
        try {
          range.type = 'range'; // not supported on IE9
          range.min = min;
          range.max = max;
        } catch (err) {}
        range.step = step;

        // set up the popup settings in case they are needed.
        var popupString = '';
        var popupValue = 0;

        if (value !== undefined) {
          var factor = 1.20;
          if (value < 0 && value * factor < min) {
            range.min = Math.ceil(value * factor);
            popupValue = range.min;
            popupString = 'range increased';
          } else if (value / factor < min) {
            range.min = Math.ceil(value / factor);
            popupValue = range.min;
            popupString = 'range increased';
          }
          if (value * factor > max && max !== 1) {
            range.max = Math.ceil(value * factor);
            popupValue = range.max;
            popupString = 'range increased';
          }
          range.value = value;
        } else {
          range.value = defaultValue;
        }

        var input = document.createElement('input');
        input.className = 'vis-configuration vis-config-rangeinput';
        input.value = range.value;

        var me = this;
        range.onchange = function () {
          input.value = this.value;me._update(Number(this.value), path);
        };
        range.oninput = function () {
          input.value = this.value;
        };

        var label = this._makeLabel(path[path.length - 1], path);
        var itemIndex = this._makeItem(path, label, range, input);

        // if a popup is needed AND it has not been shown for this value, show it.
        if (popupString !== '' && this.popupHistory[itemIndex] !== popupValue) {
          this.popupHistory[itemIndex] = popupValue;
          this._setupPopup(popupString, itemIndex);
        }
      }

      /**
       * prepare the popup
       * @param string
       * @param index
       * @private
       */

    }, {
      key: '_setupPopup',
      value: function _setupPopup(string, index) {
        var _this3 = this;

        if (this.initialized === true && this.allowCreation === true && this.popupCounter < this.popupLimit) {
          var div = document.createElement("div");
          div.id = "vis-configuration-popup";
          div.className = "vis-configuration-popup";
          div.innerHTML = string;
          div.onclick = function () {
            _this3._removePopup();
          };
          this.popupCounter += 1;
          this.popupDiv = { html: div, index: index };
        }
      }

      /**
       * remove the popup from the dom
       * @private
       */

    }, {
      key: '_removePopup',
      value: function _removePopup() {
        if (this.popupDiv.html !== undefined) {
          this.popupDiv.html.parentNode.removeChild(this.popupDiv.html);
          clearTimeout(this.popupDiv.hideTimeout);
          clearTimeout(this.popupDiv.deleteTimeout);
          this.popupDiv = {};
        }
      }

      /**
       * Show the popup if it is needed.
       * @private
       */

    }, {
      key: '_showPopupIfNeeded',
      value: function _showPopupIfNeeded() {
        var _this4 = this;

        if (this.popupDiv.html !== undefined) {
          var correspondingElement = this.domElements[this.popupDiv.index];
          var rect = correspondingElement.getBoundingClientRect();
          this.popupDiv.html.style.left = rect.left + "px";
          this.popupDiv.html.style.top = rect.top - 30 + "px"; // 30 is the height;
          document.body.appendChild(this.popupDiv.html);
          this.popupDiv.hideTimeout = setTimeout(function () {
            _this4.popupDiv.html.style.opacity = 0;
          }, 1500);
          this.popupDiv.deleteTimeout = setTimeout(function () {
            _this4._removePopup();
          }, 1800);
        }
      }

      /**
       * make a checkbox for boolean options.
       * @param defaultValue
       * @param value
       * @param path
       * @private
       */

    }, {
      key: '_makeCheckbox',
      value: function _makeCheckbox(defaultValue, value, path) {
        var checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'vis-configuration vis-config-checkbox';
        checkbox.checked = defaultValue;
        if (value !== undefined) {
          checkbox.checked = value;
          if (value !== defaultValue) {
            if ((typeof defaultValue === 'undefined' ? 'undefined' : _typeof(defaultValue)) === 'object') {
              if (value !== defaultValue.enabled) {
                this.changedOptions.push({ path: path, value: value });
              }
            } else {
              this.changedOptions.push({ path: path, value: value });
            }
          }
        }

        var me = this;
        checkbox.onchange = function () {
          me._update(this.checked, path);
        };

        var label = this._makeLabel(path[path.length - 1], path);
        this._makeItem(path, label, checkbox);
      }

      /**
       * make a text input field for string options.
       * @param defaultValue
       * @param value
       * @param path
       * @private
       */

    }, {
      key: '_makeTextInput',
      value: function _makeTextInput(defaultValue, value, path) {
        var checkbox = document.createElement('input');
        checkbox.type = 'text';
        checkbox.className = 'vis-configuration vis-config-text';
        checkbox.value = value;
        if (value !== defaultValue) {
          this.changedOptions.push({ path: path, value: value });
        }

        var me = this;
        checkbox.onchange = function () {
          me._update(this.value, path);
        };

        var label = this._makeLabel(path[path.length - 1], path);
        this._makeItem(path, label, checkbox);
      }

      /**
       * make a color field with a color picker for color fields
       * @param arr
       * @param value
       * @param path
       * @private
       */

    }, {
      key: '_makeColorField',
      value: function _makeColorField(arr, value, path) {
        var _this5 = this;

        var defaultColor = arr[1];
        var div = document.createElement('div');
        value = value === undefined ? defaultColor : value;

        if (value !== 'none') {
          div.className = 'vis-configuration vis-config-colorBlock';
          div.style.backgroundColor = value;
        } else {
          div.className = 'vis-configuration vis-config-colorBlock none';
        }

        value = value === undefined ? defaultColor : value;
        div.onclick = function () {
          _this5._showColorPicker(value, div, path);
        };

        var label = this._makeLabel(path[path.length - 1], path);
        this._makeItem(path, label, div);
      }

      /**
       * used by the color buttons to call the color picker.
       * @param event
       * @param value
       * @param div
       * @param path
       * @private
       */

    }, {
      key: '_showColorPicker',
      value: function _showColorPicker(value, div, path) {
        var _this6 = this;

        // clear the callback from this div
        div.onclick = function () {};

        this.colorPicker.insertTo(div);
        this.colorPicker.show();

        this.colorPicker.setColor(value);
        this.colorPicker.setUpdateCallback(function (color) {
          var colorString = 'rgba(' + color.r + ',' + color.g + ',' + color.b + ',' + color.a + ')';
          div.style.backgroundColor = colorString;
          _this6._update(colorString, path);
        });

        // on close of the colorpicker, restore the callback.
        this.colorPicker.setCloseCallback(function () {
          div.onclick = function () {
            _this6._showColorPicker(value, div, path);
          };
        });
      }

      /**
       * parse an object and draw the correct items
       * @param obj
       * @param path
       * @private
       */

    }, {
      key: '_handleObject',
      value: function _handleObject(obj) {
        var path = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
        var checkOnly = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

        var show = false;
        var filter = this.options.filter;
        var visibleInSet = false;
        for (var subObj in obj) {
          if (obj.hasOwnProperty(subObj)) {
            show = true;
            var item = obj[subObj];
            var newPath = util.copyAndExtendArray(path, subObj);
            if (typeof filter === 'function') {
              show = filter(subObj, path);

              // if needed we must go deeper into the object.
              if (show === false) {
                if (!(item instanceof Array) && typeof item !== 'string' && typeof item !== 'boolean' && item instanceof Object) {
                  this.allowCreation = false;
                  show = this._handleObject(item, newPath, true);
                  this.allowCreation = checkOnly === false;
                }
              }
            }

            if (show !== false) {
              visibleInSet = true;
              var value = this._getValue(newPath);

              if (item instanceof Array) {
                this._handleArray(item, value, newPath);
              } else if (typeof item === 'string') {
                this._makeTextInput(item, value, newPath);
              } else if (typeof item === 'boolean') {
                this._makeCheckbox(item, value, newPath);
              } else if (item instanceof Object) {
                // collapse the physics options that are not enabled
                var draw = true;
                if (path.indexOf('physics') !== -1) {
                  if (this.moduleOptions.physics.solver !== subObj) {
                    draw = false;
                  }
                }

                if (draw === true) {
                  // initially collapse options with an disabled enabled option.
                  if (item.enabled !== undefined) {
                    var enabledPath = util.copyAndExtendArray(newPath, 'enabled');
                    var enabledValue = this._getValue(enabledPath);
                    if (enabledValue === true) {
                      var label = this._makeLabel(subObj, newPath, true);
                      this._makeItem(newPath, label);
                      visibleInSet = this._handleObject(item, newPath) || visibleInSet;
                    } else {
                      this._makeCheckbox(item, enabledValue, newPath);
                    }
                  } else {
                    var _label = this._makeLabel(subObj, newPath, true);
                    this._makeItem(newPath, _label);
                    visibleInSet = this._handleObject(item, newPath) || visibleInSet;
                  }
                }
              } else {
                console.error('dont know how to handle', item, subObj, newPath);
              }
            }
          }
        }
        return visibleInSet;
      }

      /**
       * handle the array type of option
       * @param optionName
       * @param arr
       * @param value
       * @param path
       * @private
       */

    }, {
      key: '_handleArray',
      value: function _handleArray(arr, value, path) {
        if (typeof arr[0] === 'string' && arr[0] === 'color') {
          this._makeColorField(arr, value, path);
          if (arr[1] !== value) {
            this.changedOptions.push({ path: path, value: value });
          }
        } else if (typeof arr[0] === 'string') {
          this._makeDropdown(arr, value, path);
          if (arr[0] !== value) {
            this.changedOptions.push({ path: path, value: value });
          }
        } else if (typeof arr[0] === 'number') {
          this._makeRange(arr, value, path);
          if (arr[0] !== value) {
            this.changedOptions.push({ path: path, value: Number(value) });
          }
        }
      }

      /**
       * called to update the network with the new settings.
       * @param value
       * @param path
       * @private
       */

    }, {
      key: '_update',
      value: function _update(value, path) {
        var options = this._constructOptions(value, path);

        if (this.parent.body && this.parent.body.emitter && this.parent.body.emitter.emit) {
          this.parent.body.emitter.emit("configChange", options);
        }
        this.initialized = true;
        this.parent.setOptions(options);
      }
    }, {
      key: '_constructOptions',
      value: function _constructOptions(value, path) {
        var optionsObj = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

        var pointer = optionsObj;

        // when dropdown boxes can be string or boolean, we typecast it into correct types
        value = value === 'true' ? true : value;
        value = value === 'false' ? false : value;

        for (var i = 0; i < path.length; i++) {
          if (path[i] !== 'global') {
            if (pointer[path[i]] === undefined) {
              pointer[path[i]] = {};
            }
            if (i !== path.length - 1) {
              pointer = pointer[path[i]];
            } else {
              pointer[path[i]] = value;
            }
          }
        }
        return optionsObj;
      }
    }, {
      key: '_printOptions',
      value: function _printOptions() {
        var options = this.getOptions();
        this.optionsContainer.innerHTML = '<pre>var options = ' + JSON.stringify(options, null, 2) + '</pre>';
      }
    }, {
      key: 'getOptions',
      value: function getOptions() {
        var options = {};
        for (var i = 0; i < this.changedOptions.length; i++) {
          this._constructOptions(this.changedOptions[i].value, this.changedOptions[i].path, options);
        }
        return options;
      }
    }]);

    return Configurator;
  }();

  exports.default = Configurator;

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var Hammer = __webpack_require__(20);
  var hammerUtil = __webpack_require__(28);
  var util = __webpack_require__(1);

  var ColorPicker = function () {
    function ColorPicker() {
      var pixelRatio = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];

      _classCallCheck(this, ColorPicker);

      this.pixelRatio = pixelRatio;
      this.generated = false;
      this.centerCoordinates = { x: 289 / 2, y: 289 / 2 };
      this.r = 289 * 0.49;
      this.color = { r: 255, g: 255, b: 255, a: 1.0 };
      this.hueCircle = undefined;
      this.initialColor = { r: 255, g: 255, b: 255, a: 1.0 };
      this.previousColor = undefined;
      this.applied = false;

      // bound by
      this.updateCallback = function () {};
      this.closeCallback = function () {};

      // create all DOM elements
      this._create();
    }

    /**
     * this inserts the colorPicker into a div from the DOM
     * @param container
     */


    _createClass(ColorPicker, [{
      key: 'insertTo',
      value: function insertTo(container) {
        if (this.hammer !== undefined) {
          this.hammer.destroy();
          this.hammer = undefined;
        }
        this.container = container;
        this.container.appendChild(this.frame);
        this._bindHammer();

        this._setSize();
      }

      /**
       * the callback is executed on apply and save. Bind it to the application
       * @param callback
       */

    }, {
      key: 'setUpdateCallback',
      value: function setUpdateCallback(callback) {
        if (typeof callback === 'function') {
          this.updateCallback = callback;
        } else {
          throw new Error("Function attempted to set as colorPicker update callback is not a function.");
        }
      }

      /**
       * the callback is executed on apply and save. Bind it to the application
       * @param callback
       */

    }, {
      key: 'setCloseCallback',
      value: function setCloseCallback(callback) {
        if (typeof callback === 'function') {
          this.closeCallback = callback;
        } else {
          throw new Error("Function attempted to set as colorPicker closing callback is not a function.");
        }
      }
    }, {
      key: '_isColorString',
      value: function _isColorString(color) {
        var htmlColors = { black: '#000000', navy: '#000080', darkblue: '#00008B', mediumblue: '#0000CD', blue: '#0000FF', darkgreen: '#006400', green: '#008000', teal: '#008080', darkcyan: '#008B8B', deepskyblue: '#00BFFF', darkturquoise: '#00CED1', mediumspringgreen: '#00FA9A', lime: '#00FF00', springgreen: '#00FF7F', aqua: '#00FFFF', cyan: '#00FFFF', midnightblue: '#191970', dodgerblue: '#1E90FF', lightseagreen: '#20B2AA', forestgreen: '#228B22', seagreen: '#2E8B57', darkslategray: '#2F4F4F', limegreen: '#32CD32', mediumseagreen: '#3CB371', turquoise: '#40E0D0', royalblue: '#4169E1', steelblue: '#4682B4', darkslateblue: '#483D8B', mediumturquoise: '#48D1CC', indigo: '#4B0082', darkolivegreen: '#556B2F', cadetblue: '#5F9EA0', cornflowerblue: '#6495ED', mediumaquamarine: '#66CDAA', dimgray: '#696969', slateblue: '#6A5ACD', olivedrab: '#6B8E23', slategray: '#708090', lightslategray: '#778899', mediumslateblue: '#7B68EE', lawngreen: '#7CFC00', chartreuse: '#7FFF00', aquamarine: '#7FFFD4', maroon: '#800000', purple: '#800080', olive: '#808000', gray: '#808080', skyblue: '#87CEEB', lightskyblue: '#87CEFA', blueviolet: '#8A2BE2', darkred: '#8B0000', darkmagenta: '#8B008B', saddlebrown: '#8B4513', darkseagreen: '#8FBC8F', lightgreen: '#90EE90', mediumpurple: '#9370D8', darkviolet: '#9400D3', palegreen: '#98FB98', darkorchid: '#9932CC', yellowgreen: '#9ACD32', sienna: '#A0522D', brown: '#A52A2A', darkgray: '#A9A9A9', lightblue: '#ADD8E6', greenyellow: '#ADFF2F', paleturquoise: '#AFEEEE', lightsteelblue: '#B0C4DE', powderblue: '#B0E0E6', firebrick: '#B22222', darkgoldenrod: '#B8860B', mediumorchid: '#BA55D3', rosybrown: '#BC8F8F', darkkhaki: '#BDB76B', silver: '#C0C0C0', mediumvioletred: '#C71585', indianred: '#CD5C5C', peru: '#CD853F', chocolate: '#D2691E', tan: '#D2B48C', lightgrey: '#D3D3D3', palevioletred: '#D87093', thistle: '#D8BFD8', orchid: '#DA70D6', goldenrod: '#DAA520', crimson: '#DC143C', gainsboro: '#DCDCDC', plum: '#DDA0DD', burlywood: '#DEB887', lightcyan: '#E0FFFF', lavender: '#E6E6FA', darksalmon: '#E9967A', violet: '#EE82EE', palegoldenrod: '#EEE8AA', lightcoral: '#F08080', khaki: '#F0E68C', aliceblue: '#F0F8FF', honeydew: '#F0FFF0', azure: '#F0FFFF', sandybrown: '#F4A460', wheat: '#F5DEB3', beige: '#F5F5DC', whitesmoke: '#F5F5F5', mintcream: '#F5FFFA', ghostwhite: '#F8F8FF', salmon: '#FA8072', antiquewhite: '#FAEBD7', linen: '#FAF0E6', lightgoldenrodyellow: '#FAFAD2', oldlace: '#FDF5E6', red: '#FF0000', fuchsia: '#FF00FF', magenta: '#FF00FF', deeppink: '#FF1493', orangered: '#FF4500', tomato: '#FF6347', hotpink: '#FF69B4', coral: '#FF7F50', darkorange: '#FF8C00', lightsalmon: '#FFA07A', orange: '#FFA500', lightpink: '#FFB6C1', pink: '#FFC0CB', gold: '#FFD700', peachpuff: '#FFDAB9', navajowhite: '#FFDEAD', moccasin: '#FFE4B5', bisque: '#FFE4C4', mistyrose: '#FFE4E1', blanchedalmond: '#FFEBCD', papayawhip: '#FFEFD5', lavenderblush: '#FFF0F5', seashell: '#FFF5EE', cornsilk: '#FFF8DC', lemonchiffon: '#FFFACD', floralwhite: '#FFFAF0', snow: '#FFFAFA', yellow: '#FFFF00', lightyellow: '#FFFFE0', ivory: '#FFFFF0', white: '#FFFFFF' };
        if (typeof color === 'string') {
          return htmlColors[color];
        }
      }

      /**
       * Set the color of the colorPicker
       * Supported formats:
       * 'red'                   --> HTML color string
       * '#ffffff'               --> hex string
       * 'rbg(255,255,255)'      --> rgb string
       * 'rgba(255,255,255,1.0)' --> rgba string
       * {r:255,g:255,b:255}     --> rgb object
       * {r:255,g:255,b:255,a:1.0} --> rgba object
       * @param color
       * @param setInitial
       */

    }, {
      key: 'setColor',
      value: function setColor(color) {
        var setInitial = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

        if (color === 'none') {
          return;
        }

        var rgba = void 0;

        // if a html color shorthand is used, convert to hex
        var htmlColor = this._isColorString(color);
        if (htmlColor !== undefined) {
          color = htmlColor;
        }

        // check format
        if (util.isString(color) === true) {
          if (util.isValidRGB(color) === true) {
            var rgbaArray = color.substr(4).substr(0, color.length - 5).split(',');
            rgba = { r: rgbaArray[0], g: rgbaArray[1], b: rgbaArray[2], a: 1.0 };
          } else if (util.isValidRGBA(color) === true) {
            var _rgbaArray = color.substr(5).substr(0, color.length - 6).split(',');
            rgba = { r: _rgbaArray[0], g: _rgbaArray[1], b: _rgbaArray[2], a: _rgbaArray[3] };
          } else if (util.isValidHex(color) === true) {
            var rgbObj = util.hexToRGB(color);
            rgba = { r: rgbObj.r, g: rgbObj.g, b: rgbObj.b, a: 1.0 };
          }
        } else {
          if (color instanceof Object) {
            if (color.r !== undefined && color.g !== undefined && color.b !== undefined) {
              var alpha = color.a !== undefined ? color.a : '1.0';
              rgba = { r: color.r, g: color.g, b: color.b, a: alpha };
            }
          }
        }

        // set color
        if (rgba === undefined) {
          throw new Error("Unknown color passed to the colorPicker. Supported are strings: rgb, hex, rgba. Object: rgb ({r:r,g:g,b:b,[a:a]}). Supplied: " + JSON.stringify(color));
        } else {
          this._setColor(rgba, setInitial);
        }
      }

      /**
       * this shows the color picker.
       * The hue circle is constructed once and stored.
       */

    }, {
      key: 'show',
      value: function show() {
        if (this.closeCallback !== undefined) {
          this.closeCallback();
          this.closeCallback = undefined;
        }

        this.applied = false;
        this.frame.style.display = 'block';
        this._generateHueCircle();
      }

      // ------------------------------------------ PRIVATE ----------------------------- //

      /**
       * Hide the picker. Is called by the cancel button.
       * Optional boolean to store the previous color for easy access later on.
       * @param storePrevious
       * @private
       */

    }, {
      key: '_hide',
      value: function _hide() {
        var _this = this;

        var storePrevious = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

        // store the previous color for next time;
        if (storePrevious === true) {
          this.previousColor = util.extend({}, this.color);
        }

        if (this.applied === true) {
          this.updateCallback(this.initialColor);
        }

        this.frame.style.display = 'none';

        // call the closing callback, restoring the onclick method.
        // this is in a setTimeout because it will trigger the show again before the click is done.
        setTimeout(function () {
          if (_this.closeCallback !== undefined) {
            _this.closeCallback();
            _this.closeCallback = undefined;
          }
        }, 0);
      }

      /**
       * bound to the save button. Saves and hides.
       * @private
       */

    }, {
      key: '_save',
      value: function _save() {
        this.updateCallback(this.color);
        this.applied = false;
        this._hide();
      }

      /**
       * Bound to apply button. Saves but does not close. Is undone by the cancel button.
       * @private
       */

    }, {
      key: '_apply',
      value: function _apply() {
        this.applied = true;
        this.updateCallback(this.color);
        this._updatePicker(this.color);
      }

      /**
       * load the color from the previous session.
       * @private
       */

    }, {
      key: '_loadLast',
      value: function _loadLast() {
        if (this.previousColor !== undefined) {
          this.setColor(this.previousColor, false);
        } else {
          alert("There is no last color to load...");
        }
      }

      /**
       * set the color, place the picker
       * @param rgba
       * @param setInitial
       * @private
       */

    }, {
      key: '_setColor',
      value: function _setColor(rgba) {
        var setInitial = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

        // store the initial color
        if (setInitial === true) {
          this.initialColor = util.extend({}, rgba);
        }

        this.color = rgba;
        var hsv = util.RGBToHSV(rgba.r, rgba.g, rgba.b);

        var angleConvert = 2 * Math.PI;
        var radius = this.r * hsv.s;
        var x = this.centerCoordinates.x + radius * Math.sin(angleConvert * hsv.h);
        var y = this.centerCoordinates.y + radius * Math.cos(angleConvert * hsv.h);

        this.colorPickerSelector.style.left = x - 0.5 * this.colorPickerSelector.clientWidth + 'px';
        this.colorPickerSelector.style.top = y - 0.5 * this.colorPickerSelector.clientHeight + 'px';

        this._updatePicker(rgba);
      }

      /**
       * bound to opacity control
       * @param value
       * @private
       */

    }, {
      key: '_setOpacity',
      value: function _setOpacity(value) {
        this.color.a = value / 100;
        this._updatePicker(this.color);
      }

      /**
       * bound to brightness control
       * @param value
       * @private
       */

    }, {
      key: '_setBrightness',
      value: function _setBrightness(value) {
        var hsv = util.RGBToHSV(this.color.r, this.color.g, this.color.b);
        hsv.v = value / 100;
        var rgba = util.HSVToRGB(hsv.h, hsv.s, hsv.v);
        rgba['a'] = this.color.a;
        this.color = rgba;
        this._updatePicker();
      }

      /**
       * update the color picker. A black circle overlays the hue circle to mimic the brightness decreasing.
       * @param rgba
       * @private
       */

    }, {
      key: '_updatePicker',
      value: function _updatePicker() {
        var rgba = arguments.length <= 0 || arguments[0] === undefined ? this.color : arguments[0];

        var hsv = util.RGBToHSV(rgba.r, rgba.g, rgba.b);
        var ctx = this.colorPickerCanvas.getContext('2d');
        if (this.pixelRation === undefined) {
          this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
        }
        ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);

        // clear the canvas
        var w = this.colorPickerCanvas.clientWidth;
        var h = this.colorPickerCanvas.clientHeight;
        ctx.clearRect(0, 0, w, h);

        ctx.putImageData(this.hueCircle, 0, 0);
        ctx.fillStyle = 'rgba(0,0,0,' + (1 - hsv.v) + ')';
        ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);
        ctx.fill();

        this.brightnessRange.value = 100 * hsv.v;
        this.opacityRange.value = 100 * rgba.a;

        this.initialColorDiv.style.backgroundColor = 'rgba(' + this.initialColor.r + ',' + this.initialColor.g + ',' + this.initialColor.b + ',' + this.initialColor.a + ')';
        this.newColorDiv.style.backgroundColor = 'rgba(' + this.color.r + ',' + this.color.g + ',' + this.color.b + ',' + this.color.a + ')';
      }

      /**
       * used by create to set the size of the canvas.
       * @private
       */

    }, {
      key: '_setSize',
      value: function _setSize() {
        this.colorPickerCanvas.style.width = '100%';
        this.colorPickerCanvas.style.height = '100%';

        this.colorPickerCanvas.width = 289 * this.pixelRatio;
        this.colorPickerCanvas.height = 289 * this.pixelRatio;
      }

      /**
       * create all dom elements
       * TODO: cleanup, lots of similar dom elements
       * @private
       */

    }, {
      key: '_create',
      value: function _create() {
        this.frame = document.createElement('div');
        this.frame.className = 'vis-color-picker';

        this.colorPickerDiv = document.createElement('div');
        this.colorPickerSelector = document.createElement('div');
        this.colorPickerSelector.className = 'vis-selector';
        this.colorPickerDiv.appendChild(this.colorPickerSelector);

        this.colorPickerCanvas = document.createElement('canvas');
        this.colorPickerDiv.appendChild(this.colorPickerCanvas);

        if (!this.colorPickerCanvas.getContext) {
          var noCanvas = document.createElement('DIV');
          noCanvas.style.color = 'red';
          noCanvas.style.fontWeight = 'bold';
          noCanvas.style.padding = '10px';
          noCanvas.innerHTML = 'Error: your browser does not support HTML canvas';
          this.colorPickerCanvas.appendChild(noCanvas);
        } else {
          var ctx = this.colorPickerCanvas.getContext("2d");
          this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);

          this.colorPickerCanvas.getContext("2d").setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
        }

        this.colorPickerDiv.className = 'vis-color';

        this.opacityDiv = document.createElement('div');
        this.opacityDiv.className = 'vis-opacity';

        this.brightnessDiv = document.createElement('div');
        this.brightnessDiv.className = 'vis-brightness';

        this.arrowDiv = document.createElement('div');
        this.arrowDiv.className = 'vis-arrow';

        this.opacityRange = document.createElement('input');
        try {
          this.opacityRange.type = 'range'; // Not supported on IE9
          this.opacityRange.min = '0';
          this.opacityRange.max = '100';
        } catch (err) {}
        this.opacityRange.value = '100';
        this.opacityRange.className = 'vis-range';

        this.brightnessRange = document.createElement('input');
        try {
          this.brightnessRange.type = 'range'; // Not supported on IE9
          this.brightnessRange.min = '0';
          this.brightnessRange.max = '100';
        } catch (err) {}
        this.brightnessRange.value = '100';
        this.brightnessRange.className = 'vis-range';

        this.opacityDiv.appendChild(this.opacityRange);
        this.brightnessDiv.appendChild(this.brightnessRange);

        var me = this;
        this.opacityRange.onchange = function () {
          me._setOpacity(this.value);
        };
        this.opacityRange.oninput = function () {
          me._setOpacity(this.value);
        };
        this.brightnessRange.onchange = function () {
          me._setBrightness(this.value);
        };
        this.brightnessRange.oninput = function () {
          me._setBrightness(this.value);
        };

        this.brightnessLabel = document.createElement("div");
        this.brightnessLabel.className = "vis-label vis-brightness";
        this.brightnessLabel.innerHTML = 'brightness:';

        this.opacityLabel = document.createElement("div");
        this.opacityLabel.className = "vis-label vis-opacity";
        this.opacityLabel.innerHTML = 'opacity:';

        this.newColorDiv = document.createElement("div");
        this.newColorDiv.className = "vis-new-color";
        this.newColorDiv.innerHTML = 'new';

        this.initialColorDiv = document.createElement("div");
        this.initialColorDiv.className = "vis-initial-color";
        this.initialColorDiv.innerHTML = 'initial';

        this.cancelButton = document.createElement("div");
        this.cancelButton.className = "vis-button vis-cancel";
        this.cancelButton.innerHTML = 'cancel';
        this.cancelButton.onclick = this._hide.bind(this, false);

        this.applyButton = document.createElement("div");
        this.applyButton.className = "vis-button vis-apply";
        this.applyButton.innerHTML = 'apply';
        this.applyButton.onclick = this._apply.bind(this);

        this.saveButton = document.createElement("div");
        this.saveButton.className = "vis-button vis-save";
        this.saveButton.innerHTML = 'save';
        this.saveButton.onclick = this._save.bind(this);

        this.loadButton = document.createElement("div");
        this.loadButton.className = "vis-button vis-load";
        this.loadButton.innerHTML = 'load last';
        this.loadButton.onclick = this._loadLast.bind(this);

        this.frame.appendChild(this.colorPickerDiv);
        this.frame.appendChild(this.arrowDiv);
        this.frame.appendChild(this.brightnessLabel);
        this.frame.appendChild(this.brightnessDiv);
        this.frame.appendChild(this.opacityLabel);
        this.frame.appendChild(this.opacityDiv);
        this.frame.appendChild(this.newColorDiv);
        this.frame.appendChild(this.initialColorDiv);

        this.frame.appendChild(this.cancelButton);
        this.frame.appendChild(this.applyButton);
        this.frame.appendChild(this.saveButton);
        this.frame.appendChild(this.loadButton);
      }

      /**
       * bind hammer to the color picker
       * @private
       */

    }, {
      key: '_bindHammer',
      value: function _bindHammer() {
        var _this2 = this;

        this.drag = {};
        this.pinch = {};
        this.hammer = new Hammer(this.colorPickerCanvas);
        this.hammer.get('pinch').set({ enable: true });

        hammerUtil.onTouch(this.hammer, function (event) {
          _this2._moveSelector(event);
        });
        this.hammer.on('tap', function (event) {
          _this2._moveSelector(event);
        });
        this.hammer.on('panstart', function (event) {
          _this2._moveSelector(event);
        });
        this.hammer.on('panmove', function (event) {
          _this2._moveSelector(event);
        });
        this.hammer.on('panend', function (event) {
          _this2._moveSelector(event);
        });
      }

      /**
       * generate the hue circle. This is relatively heavy (200ms) and is done only once on the first time it is shown.
       * @private
       */

    }, {
      key: '_generateHueCircle',
      value: function _generateHueCircle() {
        if (this.generated === false) {
          var ctx = this.colorPickerCanvas.getContext('2d');
          if (this.pixelRation === undefined) {
            this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
          }
          ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);

          // clear the canvas
          var w = this.colorPickerCanvas.clientWidth;
          var h = this.colorPickerCanvas.clientHeight;
          ctx.clearRect(0, 0, w, h);

          // draw hue circle
          var x = void 0,
              y = void 0,
              hue = void 0,
              sat = void 0;
          this.centerCoordinates = { x: w * 0.5, y: h * 0.5 };
          this.r = 0.49 * w;
          var angleConvert = 2 * Math.PI / 360;
          var hfac = 1 / 360;
          var sfac = 1 / this.r;
          var rgb = void 0;
          for (hue = 0; hue < 360; hue++) {
            for (sat = 0; sat < this.r; sat++) {
              x = this.centerCoordinates.x + sat * Math.sin(angleConvert * hue);
              y = this.centerCoordinates.y + sat * Math.cos(angleConvert * hue);
              rgb = util.HSVToRGB(hue * hfac, sat * sfac, 1);
              ctx.fillStyle = 'rgb(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ')';
              ctx.fillRect(x - 0.5, y - 0.5, 2, 2);
            }
          }
          ctx.strokeStyle = 'rgba(0,0,0,1)';
          ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);
          ctx.stroke();

          this.hueCircle = ctx.getImageData(0, 0, w, h);
        }
        this.generated = true;
      }

      /**
       * move the selector. This is called by hammer functions.
       *
       * @param event
       * @private
       */

    }, {
      key: '_moveSelector',
      value: function _moveSelector(event) {
        var rect = this.colorPickerDiv.getBoundingClientRect();
        var left = event.center.x - rect.left;
        var top = event.center.y - rect.top;

        var centerY = 0.5 * this.colorPickerDiv.clientHeight;
        var centerX = 0.5 * this.colorPickerDiv.clientWidth;

        var x = left - centerX;
        var y = top - centerY;

        var angle = Math.atan2(x, y);
        var radius = 0.98 * Math.min(Math.sqrt(x * x + y * y), centerX);

        var newTop = Math.cos(angle) * radius + centerY;
        var newLeft = Math.sin(angle) * radius + centerX;

        this.colorPickerSelector.style.top = newTop - 0.5 * this.colorPickerSelector.clientHeight + 'px';
        this.colorPickerSelector.style.left = newLeft - 0.5 * this.colorPickerSelector.clientWidth + 'px';

        // set color
        var h = angle / (2 * Math.PI);
        h = h < 0 ? h + 1 : h;
        var s = radius / this.r;
        var hsv = util.RGBToHSV(this.color.r, this.color.g, this.color.b);
        hsv.h = h;
        hsv.s = s;
        var rgba = util.HSVToRGB(hsv.h, hsv.s, hsv.v);
        rgba['a'] = this.color.a;
        this.color = rgba;

        // update previews
        this.initialColorDiv.style.backgroundColor = 'rgba(' + this.initialColor.r + ',' + this.initialColor.g + ',' + this.initialColor.b + ',' + this.initialColor.a + ')';
        this.newColorDiv.style.backgroundColor = 'rgba(' + this.color.r + ',' + this.color.g + ',' + this.color.b + ',' + this.color.a + ')';
      }
    }]);

    return ColorPicker;
  }();

  exports.default = ColorPicker;

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var Hammer = __webpack_require__(20);

  /**
   * Register a touch event, taking place before a gesture
   * @param {Hammer} hammer       A hammer instance
   * @param {function} callback   Callback, called as callback(event)
   */
  exports.onTouch = function (hammer, callback) {
    callback.inputHandler = function (event) {
      if (event.isFirst) {
        callback(event);
      }
    };

    hammer.on('hammer.input', callback.inputHandler);
  };

  /**
   * Register a release event, taking place after a gesture
   * @param {Hammer} hammer       A hammer instance
   * @param {function} callback   Callback, called as callback(event)
   */
  exports.onRelease = function (hammer, callback) {
    callback.inputHandler = function (event) {
      if (event.isFinal) {
        callback(event);
      }
    };

    return hammer.on('hammer.input', callback.inputHandler);
  };

  /**
   * Unregister a touch event, taking place before a gesture
   * @param {Hammer} hammer       A hammer instance
   * @param {function} callback   Callback, called as callback(event)
   */
  exports.offTouch = function (hammer, callback) {
    hammer.off('hammer.input', callback.inputHandler);
  };

  /**
   * Unregister a release event, taking place before a gesture
   * @param {Hammer} hammer       A hammer instance
   * @param {function} callback   Callback, called as callback(event)
   */
  exports.offRelease = exports.offTouch;

  /**
   * Hack the PinchRecognizer such that it doesn't prevent default behavior
   * for vertical panning.
   *
   * Yeah ... this is quite a hack ... see https://github.com/hammerjs/hammer.js/issues/932
   *
   * @param {Hammer.Pinch} pinchRecognizer
   * @return {Hammer.Pinch} returns the pinchRecognizer
   */
  exports.disablePreventDefaultVertically = function (pinchRecognizer) {
    var TOUCH_ACTION_PAN_Y = 'pan-y';

    pinchRecognizer.getTouchAction = function () {
      // default method returns [TOUCH_ACTION_NONE]
      return [TOUCH_ACTION_PAN_Y];
    };

    return pinchRecognizer;
  };

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);

  var errorFound = false;
  var allOptions = void 0;
  var printStyle = 'background: #FFeeee; color: #dd0000';
  /**
   *  Used to validate options.
   */

  var Validator = function () {
    function Validator() {
      _classCallCheck(this, Validator);
    }

    /**
     * Main function to be called
     * @param options
     * @param subObject
     * @returns {boolean}
     */


    _createClass(Validator, null, [{
      key: 'validate',
      value: function validate(options, referenceOptions, subObject) {
        errorFound = false;
        allOptions = referenceOptions;
        var usedOptions = referenceOptions;
        if (subObject !== undefined) {
          usedOptions = referenceOptions[subObject];
        }
        Validator.parse(options, usedOptions, []);
        return errorFound;
      }

      /**
       * Will traverse an object recursively and check every value
       * @param options
       * @param referenceOptions
       * @param path
       */

    }, {
      key: 'parse',
      value: function parse(options, referenceOptions, path) {
        for (var option in options) {
          if (options.hasOwnProperty(option)) {
            Validator.check(option, options, referenceOptions, path);
          }
        }
      }

      /**
       * Check every value. If the value is an object, call the parse function on that object.
       * @param option
       * @param options
       * @param referenceOptions
       * @param path
       */

    }, {
      key: 'check',
      value: function check(option, options, referenceOptions, path) {
        if (referenceOptions[option] === undefined && referenceOptions.__any__ === undefined) {
          Validator.getSuggestion(option, referenceOptions, path);
        } else if (referenceOptions[option] === undefined && referenceOptions.__any__ !== undefined) {
          // __any__ is a wildcard. Any value is accepted and will be further analysed by reference.
          if (Validator.getType(options[option]) === 'object' && referenceOptions['__any__'].__type__ !== undefined) {
            // if the any subgroup is not a predefined object int he configurator we do not look deeper into the object.
            Validator.checkFields(option, options, referenceOptions, '__any__', referenceOptions['__any__'].__type__, path);
          } else {
            Validator.checkFields(option, options, referenceOptions, '__any__', referenceOptions['__any__'], path);
          }
        } else {
          // Since all options in the reference are objects, we can check whether they are supposed to be object to look for the __type__ field.
          if (referenceOptions[option].__type__ !== undefined) {
            // if this should be an object, we check if the correct type has been supplied to account for shorthand options.
            Validator.checkFields(option, options, referenceOptions, option, referenceOptions[option].__type__, path);
          } else {
            Validator.checkFields(option, options, referenceOptions, option, referenceOptions[option], path);
          }
        }
      }

      /**
       *
       * @param {String}  option     | the option property
       * @param {Object}  options    | The supplied options object
       * @param {Object}  referenceOptions    | The reference options containing all options and their allowed formats
       * @param {String}  referenceOption     | Usually this is the same as option, except when handling an __any__ tag.
       * @param {String}  refOptionType       | This is the type object from the reference options
       * @param {Array}   path      | where in the object is the option
       */

    }, {
      key: 'checkFields',
      value: function checkFields(option, options, referenceOptions, referenceOption, refOptionObj, path) {
        var optionType = Validator.getType(options[option]);
        var refOptionType = refOptionObj[optionType];
        if (refOptionType !== undefined) {
          // if the type is correct, we check if it is supposed to be one of a few select values
          if (Validator.getType(refOptionType) === 'array') {
            if (refOptionType.indexOf(options[option]) === -1) {
              console.log('%cInvalid option detected in "' + option + '".' + ' Allowed values are:' + Validator.print(refOptionType) + ' not "' + options[option] + '". ' + Validator.printLocation(path, option), printStyle);
              errorFound = true;
            } else if (optionType === 'object' && referenceOption !== "__any__") {
              path = util.copyAndExtendArray(path, option);
              Validator.parse(options[option], referenceOptions[referenceOption], path);
            }
          } else if (optionType === 'object' && referenceOption !== "__any__") {
            path = util.copyAndExtendArray(path, option);
            Validator.parse(options[option], referenceOptions[referenceOption], path);
          }
        } else if (refOptionObj['any'] === undefined) {
          // type of the field is incorrect and the field cannot be any
          console.log('%cInvalid type received for "' + option + '". Expected: ' + Validator.print(Object.keys(refOptionObj)) + '. Received [' + optionType + '] "' + options[option] + '"' + Validator.printLocation(path, option), printStyle);
          errorFound = true;
        }
      }
    }, {
      key: 'getType',
      value: function getType(object) {
        var type = typeof object === 'undefined' ? 'undefined' : _typeof(object);

        if (type === 'object') {
          if (object === null) {
            return 'null';
          }
          if (object instanceof Boolean) {
            return 'boolean';
          }
          if (object instanceof Number) {
            return 'number';
          }
          if (object instanceof String) {
            return 'string';
          }
          if (Array.isArray(object)) {
            return 'array';
          }
          if (object instanceof Date) {
            return 'date';
          }
          if (object.nodeType !== undefined) {
            return 'dom';
          }
          if (object._isAMomentObject === true) {
            return 'moment';
          }
          return 'object';
        } else if (type === 'number') {
          return 'number';
        } else if (type === 'boolean') {
          return 'boolean';
        } else if (type === 'string') {
          return 'string';
        } else if (type === undefined) {
          return 'undefined';
        }
        return type;
      }
    }, {
      key: 'getSuggestion',
      value: function getSuggestion(option, options, path) {
        var localSearch = Validator.findInOptions(option, options, path, false);
        var globalSearch = Validator.findInOptions(option, allOptions, [], true);

        var localSearchThreshold = 8;
        var globalSearchThreshold = 4;

        if (localSearch.indexMatch !== undefined) {
          console.log('%cUnknown option detected: "' + option + '" in ' + Validator.printLocation(localSearch.path, option, '') + 'Perhaps it was incomplete? Did you mean: "' + localSearch.indexMatch + '"?\n\n', printStyle);
        } else if (globalSearch.distance <= globalSearchThreshold && localSearch.distance > globalSearch.distance) {
          console.log('%cUnknown option detected: "' + option + '" in ' + Validator.printLocation(localSearch.path, option, '') + 'Perhaps it was misplaced? Matching option found at: ' + Validator.printLocation(globalSearch.path, globalSearch.closestMatch, ''), printStyle);
        } else if (localSearch.distance <= localSearchThreshold) {
          console.log('%cUnknown option detected: "' + option + '". Did you mean "' + localSearch.closestMatch + '"?' + Validator.printLocation(localSearch.path, option), printStyle);
        } else {
          console.log('%cUnknown option detected: "' + option + '". Did you mean one of these: ' + Validator.print(Object.keys(options)) + Validator.printLocation(path, option), printStyle);
        }

        errorFound = true;
      }

      /**
       * traverse the options in search for a match.
       * @param option
       * @param options
       * @param path
       * @param recursive
       * @returns {{closestMatch: string, path: Array, distance: number}}
       */

    }, {
      key: 'findInOptions',
      value: function findInOptions(option, options, path) {
        var recursive = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

        var min = 1e9;
        var closestMatch = '';
        var closestMatchPath = [];
        var lowerCaseOption = option.toLowerCase();
        var indexMatch = undefined;
        for (var op in options) {
          var distance = void 0;
          if (options[op].__type__ !== undefined && recursive === true) {
            var result = Validator.findInOptions(option, options[op], util.copyAndExtendArray(path, op));
            if (min > result.distance) {
              closestMatch = result.closestMatch;
              closestMatchPath = result.path;
              min = result.distance;
              indexMatch = result.indexMatch;
            }
          } else {
            if (op.toLowerCase().indexOf(lowerCaseOption) !== -1) {
              indexMatch = op;
            }
            distance = Validator.levenshteinDistance(option, op);
            if (min > distance) {
              closestMatch = op;
              closestMatchPath = util.copyArray(path);
              min = distance;
            }
          }
        }
        return { closestMatch: closestMatch, path: closestMatchPath, distance: min, indexMatch: indexMatch };
      }
    }, {
      key: 'printLocation',
      value: function printLocation(path, option) {
        var prefix = arguments.length <= 2 || arguments[2] === undefined ? 'Problem value found at: \n' : arguments[2];

        var str = '\n\n' + prefix + 'options = {\n';
        for (var i = 0; i < path.length; i++) {
          for (var j = 0; j < i + 1; j++) {
            str += '  ';
          }
          str += path[i] + ': {\n';
        }
        for (var _j = 0; _j < path.length + 1; _j++) {
          str += '  ';
        }
        str += option + '\n';
        for (var _i = 0; _i < path.length + 1; _i++) {
          for (var _j2 = 0; _j2 < path.length - _i; _j2++) {
            str += '  ';
          }
          str += '}\n';
        }
        return str + '\n\n';
      }
    }, {
      key: 'print',
      value: function print(options) {
        return JSON.stringify(options).replace(/(\")|(\[)|(\])|(,"__type__")/g, "").replace(/(\,)/g, ', ');
      }

      // Compute the edit distance between the two given strings
      // http://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance#JavaScript
      /*
       Copyright (c) 2011 Andrei Mackenzie
        Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
        The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
       */

    }, {
      key: 'levenshteinDistance',
      value: function levenshteinDistance(a, b) {
        if (a.length === 0) return b.length;
        if (b.length === 0) return a.length;

        var matrix = [];

        // increment along the first column of each row
        var i;
        for (i = 0; i <= b.length; i++) {
          matrix[i] = [i];
        }

        // increment each column in the first row
        var j;
        for (j = 0; j <= a.length; j++) {
          matrix[0][j] = j;
        }

        // Fill in the rest of the matrix
        for (i = 1; i <= b.length; i++) {
          for (j = 1; j <= a.length; j++) {
            if (b.charAt(i - 1) == a.charAt(j - 1)) {
              matrix[i][j] = matrix[i - 1][j - 1];
            } else {
              matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, // substitution
              Math.min(matrix[i][j - 1] + 1, // insertion
              matrix[i - 1][j] + 1)); // deletion
            }
          }
        }

        return matrix[b.length][a.length];
      }
    }]);

    return Validator;
  }();

  exports.default = Validator;
  exports.printStyle = printStyle;

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

  var util = __webpack_require__(1);
  var hammerUtil = __webpack_require__(28);
  var moment = __webpack_require__(2);
  var Component = __webpack_require__(31);
  var DateUtil = __webpack_require__(32);

  /**
   * @constructor Range
   * A Range controls a numeric range with a start and end value.
   * The Range adjusts the range based on mouse events or programmatic changes,
   * and triggers events when the range is changing or has been changed.
   * @param {{dom: Object, domProps: Object, emitter: Emitter}} body
   * @param {Object} [options]    See description at Range.setOptions
   */
  function Range(body, options) {
    var now = moment().hours(0).minutes(0).seconds(0).milliseconds(0);
    this.start = now.clone().add(-3, 'days').valueOf(); // Number
    this.end = now.clone().add(4, 'days').valueOf(); // Number

    this.body = body;
    this.deltaDifference = 0;
    this.scaleOffset = 0;
    this.startToFront = false;
    this.endToFront = true;

    // default options
    this.defaultOptions = {
      rtl: false,
      start: null,
      end: null,
      moment: moment,
      direction: 'horizontal', // 'horizontal' or 'vertical'
      moveable: true,
      zoomable: true,
      min: null,
      max: null,
      zoomMin: 10, // milliseconds
      zoomMax: 1000 * 60 * 60 * 24 * 365 * 10000 // milliseconds
    };
    this.options = util.extend({}, this.defaultOptions);
    this.props = {
      touch: {}
    };
    this.animationTimer = null;

    // drag listeners for dragging
    this.body.emitter.on('panstart', this._onDragStart.bind(this));
    this.body.emitter.on('panmove', this._onDrag.bind(this));
    this.body.emitter.on('panend', this._onDragEnd.bind(this));

    // mouse wheel for zooming
    this.body.emitter.on('mousewheel', this._onMouseWheel.bind(this));

    // pinch to zoom
    this.body.emitter.on('touch', this._onTouch.bind(this));
    this.body.emitter.on('pinch', this._onPinch.bind(this));

    this.setOptions(options);
  }

  Range.prototype = new Component();

  /**
   * Set options for the range controller
   * @param {Object} options      Available options:
   *                              {Number | Date | String} start  Start date for the range
   *                              {Number | Date | String} end    End date for the range
   *                              {Number} min    Minimum value for start
   *                              {Number} max    Maximum value for end
   *                              {Number} zoomMin    Set a minimum value for
   *                                                  (end - start).
   *                              {Number} zoomMax    Set a maximum value for
   *                                                  (end - start).
   *                              {Boolean} moveable Enable moving of the range
   *                                                 by dragging. True by default
   *                              {Boolean} zoomable Enable zooming of the range
   *                                                 by pinching/scrolling. True by default
   */
  Range.prototype.setOptions = function (options) {
    if (options) {
      // copy the options that we know
      var fields = ['direction', 'min', 'max', 'zoomMin', 'zoomMax', 'moveable', 'zoomable', 'moment', 'activate', 'hiddenDates', 'zoomKey', 'rtl'];
      util.selectiveExtend(fields, this.options, options);

      if ('start' in options || 'end' in options) {
        // apply a new range. both start and end are optional
        this.setRange(options.start, options.end);
      }
    }
  };

  /**
   * Test whether direction has a valid value
   * @param {String} direction    'horizontal' or 'vertical'
   */
  function validateDirection(direction) {
    if (direction != 'horizontal' && direction != 'vertical') {
      throw new TypeError('Unknown direction "' + direction + '". ' + 'Choose "horizontal" or "vertical".');
    }
  }

  /**
   * Set a new start and end range
   * @param {Date | Number | String} [start]
   * @param {Date | Number | String} [end]
   * @param {boolean | {duration: number, easingFunction: string}} [animation=false]
   *                                    If true (default), the range is animated
   *                                    smoothly to the new window. An object can be
   *                                    provided to specify duration and easing function.
   *                                    Default duration is 500 ms, and default easing
   *                                    function is 'easeInOutQuad'.
   * @param {Boolean} [byUser=false]
   *
   */
  Range.prototype.setRange = function (start, end, animation, byUser) {
    if (byUser !== true) {
      byUser = false;
    }
    var finalStart = start != undefined ? util.convert(start, 'Date').valueOf() : null;
    var finalEnd = end != undefined ? util.convert(end, 'Date').valueOf() : null;
    this._cancelAnimation();

    if (animation) {
      // true or an Object
      var me = this;
      var initStart = this.start;
      var initEnd = this.end;
      var duration = (typeof animation === 'undefined' ? 'undefined' : _typeof(animation)) === 'object' && 'duration' in animation ? animation.duration : 500;
      var easingName = (typeof animation === 'undefined' ? 'undefined' : _typeof(animation)) === 'object' && 'easingFunction' in animation ? animation.easingFunction : 'easeInOutQuad';
      var easingFunction = util.easingFunctions[easingName];
      if (!easingFunction) {
        throw new Error('Unknown easing function ' + JSON.stringify(easingName) + '. ' + 'Choose from: ' + Object.keys(util.easingFunctions).join(', '));
      }

      var initTime = new Date().valueOf();
      var anyChanged = false;

      var next = function next() {
        if (!me.props.touch.dragging) {
          var now = new Date().valueOf();
          var time = now - initTime;
          var ease = easingFunction(time / duration);
          var done = time > duration;
          var s = done || finalStart === null ? finalStart : initStart + (finalStart - initStart) * ease;
          var e = done || finalEnd === null ? finalEnd : initEnd + (finalEnd - initEnd) * ease;

          changed = me._applyRange(s, e);
          DateUtil.updateHiddenDates(me.options.moment, me.body, me.options.hiddenDates);
          anyChanged = anyChanged || changed;
          if (changed) {
            me.body.emitter.emit('rangechange', { start: new Date(me.start), end: new Date(me.end), byUser: byUser });
          }

          if (done) {
            if (anyChanged) {
              me.body.emitter.emit('rangechanged', { start: new Date(me.start), end: new Date(me.end), byUser: byUser });
            }
          } else {
            // animate with as high as possible frame rate, leave 20 ms in between
            // each to prevent the browser from blocking
            me.animationTimer = setTimeout(next, 20);
          }
        }
      };

      return next();
    } else {
      var changed = this._applyRange(finalStart, finalEnd);
      DateUtil.updateHiddenDates(this.options.moment, this.body, this.options.hiddenDates);
      if (changed) {
        var params = { start: new Date(this.start), end: new Date(this.end), byUser: byUser };
        this.body.emitter.emit('rangechange', params);
        this.body.emitter.emit('rangechanged', params);
      }
    }
  };

  /**
   * Stop an animation
   * @private
   */
  Range.prototype._cancelAnimation = function () {
    if (this.animationTimer) {
      clearTimeout(this.animationTimer);
      this.animationTimer = null;
    }
  };

  /**
   * Set a new start and end range. This method is the same as setRange, but
   * does not trigger a range change and range changed event, and it returns
   * true when the range is changed
   * @param {Number} [start]
   * @param {Number} [end]
   * @return {Boolean} changed
   * @private
   */
  Range.prototype._applyRange = function (start, end) {
    var newStart = start != null ? util.convert(start, 'Date').valueOf() : this.start,
        newEnd = end != null ? util.convert(end, 'Date').valueOf() : this.end,
        max = this.options.max != null ? util.convert(this.options.max, 'Date').valueOf() : null,
        min = this.options.min != null ? util.convert(this.options.min, 'Date').valueOf() : null,
        diff;

    // check for valid number
    if (isNaN(newStart) || newStart === null) {
      throw new Error('Invalid start "' + start + '"');
    }
    if (isNaN(newEnd) || newEnd === null) {
      throw new Error('Invalid end "' + end + '"');
    }

    // prevent start < end
    if (newEnd < newStart) {
      newEnd = newStart;
    }

    // prevent start < min
    if (min !== null) {
      if (newStart < min) {
        diff = min - newStart;
        newStart += diff;
        newEnd += diff;

        // prevent end > max
        if (max != null) {
          if (newEnd > max) {
            newEnd = max;
          }
        }
      }
    }

    // prevent end > max
    if (max !== null) {
      if (newEnd > max) {
        diff = newEnd - max;
        newStart -= diff;
        newEnd -= diff;

        // prevent start < min
        if (min != null) {
          if (newStart < min) {
            newStart = min;
          }
        }
      }
    }

    // prevent (end-start) < zoomMin
    if (this.options.zoomMin !== null) {
      var zoomMin = parseFloat(this.options.zoomMin);
      if (zoomMin < 0) {
        zoomMin = 0;
      }
      if (newEnd - newStart < zoomMin) {
        if (this.end - this.start === zoomMin && newStart > this.start && newEnd < this.end) {
          // ignore this action, we are already zoomed to the minimum
          newStart = this.start;
          newEnd = this.end;
        } else {
          // zoom to the minimum
          diff = zoomMin - (newEnd - newStart);
          newStart -= diff / 2;
          newEnd += diff / 2;
        }
      }
    }

    // prevent (end-start) > zoomMax
    if (this.options.zoomMax !== null) {
      var zoomMax = parseFloat(this.options.zoomMax);
      if (zoomMax < 0) {
        zoomMax = 0;
      }

      if (newEnd - newStart > zoomMax) {
        if (this.end - this.start === zoomMax && newStart < this.start && newEnd > this.end) {
          // ignore this action, we are already zoomed to the maximum
          newStart = this.start;
          newEnd = this.end;
        } else {
          // zoom to the maximum
          diff = newEnd - newStart - zoomMax;
          newStart += diff / 2;
          newEnd -= diff / 2;
        }
      }
    }

    var changed = this.start != newStart || this.end != newEnd;

    // if the new range does NOT overlap with the old range, emit checkRangedItems to avoid not showing ranged items (ranged meaning has end time, not necessarily of type Range)
    if (!(newStart >= this.start && newStart <= this.end || newEnd >= this.start && newEnd <= this.end) && !(this.start >= newStart && this.start <= newEnd || this.end >= newStart && this.end <= newEnd)) {
      this.body.emitter.emit('checkRangedItems');
    }

    this.start = newStart;
    this.end = newEnd;
    return changed;
  };

  /**
   * Retrieve the current range.
   * @return {Object} An object with start and end properties
   */
  Range.prototype.getRange = function () {
    return {
      start: this.start,
      end: this.end
    };
  };

  /**
   * Calculate the conversion offset and scale for current range, based on
   * the provided width
   * @param {Number} width
   * @returns {{offset: number, scale: number}} conversion
   */
  Range.prototype.conversion = function (width, totalHidden) {
    return Range.conversion(this.start, this.end, width, totalHidden);
  };

  /**
   * Static method to calculate the conversion offset and scale for a range,
   * based on the provided start, end, and width
   * @param {Number} start
   * @param {Number} end
   * @param {Number} width
   * @returns {{offset: number, scale: number}} conversion
   */
  Range.conversion = function (start, end, width, totalHidden) {
    if (totalHidden === undefined) {
      totalHidden = 0;
    }
    if (width != 0 && end - start != 0) {
      return {
        offset: start,
        scale: width / (end - start - totalHidden)
      };
    } else {
      return {
        offset: 0,
        scale: 1
      };
    }
  };

  /**
   * Start dragging horizontally or vertically
   * @param {Event} event
   * @private
   */
  Range.prototype._onDragStart = function (event) {
    this.deltaDifference = 0;
    this.previousDelta = 0;

    // only allow dragging when configured as movable
    if (!this.options.moveable) return;

    // only start dragging when the mouse is inside the current range
    if (!this._isInsideRange(event)) return;

    // refuse to drag when we where pinching to prevent the timeline make a jump
    // when releasing the fingers in opposite order from the touch screen
    if (!this.props.touch.allowDragging) return;

    this.props.touch.start = this.start;
    this.props.touch.end = this.end;
    this.props.touch.dragging = true;

    if (this.body.dom.root) {
      this.body.dom.root.style.cursor = 'move';
    }
  };

  /**
   * Perform dragging operation
   * @param {Event} event
   * @private
   */
  Range.prototype._onDrag = function (event) {
    if (!this.props.touch.dragging) return;

    // only allow dragging when configured as movable
    if (!this.options.moveable) return;

    // TODO: this may be redundant in hammerjs2
    // refuse to drag when we where pinching to prevent the timeline make a jump
    // when releasing the fingers in opposite order from the touch screen
    if (!this.props.touch.allowDragging) return;

    var direction = this.options.direction;
    validateDirection(direction);
    var delta = direction == 'horizontal' ? event.deltaX : event.deltaY;
    delta -= this.deltaDifference;
    var interval = this.props.touch.end - this.props.touch.start;

    // normalize dragging speed if cutout is in between.
    var duration = DateUtil.getHiddenDurationBetween(this.body.hiddenDates, this.start, this.end);
    interval -= duration;

    var width = direction == 'horizontal' ? this.body.domProps.center.width : this.body.domProps.center.height;

    if (this.options.rtl) {
      var diffRange = delta / width * interval;
    } else {
      var diffRange = -delta / width * interval;
    }

    var newStart = this.props.touch.start + diffRange;
    var newEnd = this.props.touch.end + diffRange;

    // snapping times away from hidden zones
    var safeStart = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newStart, this.previousDelta - delta, true);
    var safeEnd = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newEnd, this.previousDelta - delta, true);
    if (safeStart != newStart || safeEnd != newEnd) {
      this.deltaDifference += delta;
      this.props.touch.start = safeStart;
      this.props.touch.end = safeEnd;
      this._onDrag(event);
      return;
    }

    this.previousDelta = delta;
    this._applyRange(newStart, newEnd);

    var startDate = new Date(this.start);
    var endDate = new Date(this.end);

    // fire a rangechange event
    this.body.emitter.emit('rangechange', {
      start: startDate,
      end: endDate,
      byUser: true
    });
  };

  /**
   * Stop dragging operation
   * @param {event} event
   * @private
   */
  Range.prototype._onDragEnd = function (event) {
    if (!this.props.touch.dragging) return;

    // only allow dragging when configured as movable
    if (!this.options.moveable) return;

    // TODO: this may be redundant in hammerjs2
    // refuse to drag when we where pinching to prevent the timeline make a jump
    // when releasing the fingers in opposite order from the touch screen
    if (!this.props.touch.allowDragging) return;

    this.props.touch.dragging = false;
    if (this.body.dom.root) {
      this.body.dom.root.style.cursor = 'auto';
    }

    // fire a rangechanged event
    this.body.emitter.emit('rangechanged', {
      start: new Date(this.start),
      end: new Date(this.end),
      byUser: true
    });
  };

  /**
   * Event handler for mouse wheel event, used to zoom
   * Code from http://adomas.org/javascript-mouse-wheel/
   * @param {Event} event
   * @private
   */
  Range.prototype._onMouseWheel = function (event) {
    // only allow zooming when configured as zoomable and moveable
    if (!(this.options.zoomable && this.options.moveable)) return;

    // only zoom when the mouse is inside the current range
    if (!this._isInsideRange(event)) return;

    // only zoom when the according key is pressed and the zoomKey option is set
    if (this.options.zoomKey && !event[this.options.zoomKey]) return;

    // retrieve delta
    var delta = 0;
    if (event.wheelDelta) {
      /* IE/Opera. */
      delta = event.wheelDelta / 120;
    } else if (event.detail) {
      /* Mozilla case. */
      // In Mozilla, sign of delta is different than in IE.
      // Also, delta is multiple of 3.
      delta = -event.detail / 3;
    }

    // If delta is nonzero, handle it.
    // Basically, delta is now positive if wheel was scrolled up,
    // and negative, if wheel was scrolled down.
    if (delta) {
      // perform the zoom action. Delta is normally 1 or -1

      // adjust a negative delta such that zooming in with delta 0.1
      // equals zooming out with a delta -0.1
      var scale;
      if (delta < 0) {
        scale = 1 - delta / 5;
      } else {
        scale = 1 / (1 + delta / 5);
      }

      // calculate center, the date to zoom around
      var pointer = this.getPointer({ x: event.clientX, y: event.clientY }, this.body.dom.center);
      var pointerDate = this._pointerToDate(pointer);

      this.zoom(scale, pointerDate, delta);
    }

    // Prevent default actions caused by mouse wheel
    // (else the page and timeline both zoom and scroll)
    event.preventDefault();
  };

  /**
   * Start of a touch gesture
   * @private
   */
  Range.prototype._onTouch = function (event) {
    this.props.touch.start = this.start;
    this.props.touch.end = this.end;
    this.props.touch.allowDragging = true;
    this.props.touch.center = null;
    this.scaleOffset = 0;
    this.deltaDifference = 0;
  };

  /**
   * Handle pinch event
   * @param {Event} event
   * @private
   */
  Range.prototype._onPinch = function (event) {
    // only allow zooming when configured as zoomable and moveable
    if (!(this.options.zoomable && this.options.moveable)) return;

    this.props.touch.allowDragging = false;

    if (!this.props.touch.center) {
      this.props.touch.center = this.getPointer(event.center, this.body.dom.center);
    }

    var scale = 1 / (event.scale + this.scaleOffset);
    var centerDate = this._pointerToDate(this.props.touch.center);

    var hiddenDuration = DateUtil.getHiddenDurationBetween(this.body.hiddenDates, this.start, this.end);
    var hiddenDurationBefore = DateUtil.getHiddenDurationBefore(this.options.moment, this.body.hiddenDates, this, centerDate);
    var hiddenDurationAfter = hiddenDuration - hiddenDurationBefore;

    // calculate new start and end
    var newStart = centerDate - hiddenDurationBefore + (this.props.touch.start - (centerDate - hiddenDurationBefore)) * scale;
    var newEnd = centerDate + hiddenDurationAfter + (this.props.touch.end - (centerDate + hiddenDurationAfter)) * scale;

    // snapping times away from hidden zones
    this.startToFront = 1 - scale <= 0; // used to do the right auto correction with periodic hidden times
    this.endToFront = scale - 1 <= 0; // used to do the right auto correction with periodic hidden times

    var safeStart = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newStart, 1 - scale, true);
    var safeEnd = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newEnd, scale - 1, true);
    if (safeStart != newStart || safeEnd != newEnd) {
      this.props.touch.start = safeStart;
      this.props.touch.end = safeEnd;
      this.scaleOffset = 1 - event.scale;
      newStart = safeStart;
      newEnd = safeEnd;
    }

    this.setRange(newStart, newEnd, false, true);

    this.startToFront = false; // revert to default
    this.endToFront = true; // revert to default
  };

  /**
   * Test whether the mouse from a mouse event is inside the visible window,
   * between the current start and end date
   * @param {Object} event
   * @return {boolean} Returns true when inside the visible window
   * @private
   */
  Range.prototype._isInsideRange = function (event) {
    // calculate the time where the mouse is, check whether inside
    // and no scroll action should happen.
    var clientX = event.center ? event.center.x : event.clientX;
    if (this.options.rtl) {
      var x = clientX - util.getAbsoluteLeft(this.body.dom.centerContainer);
    } else {
      var x = util.getAbsoluteRight(this.body.dom.centerContainer) - clientX;
    }
    var time = this.body.util.toTime(x);

    return time >= this.start && time <= this.end;
  };

  /**
   * Helper function to calculate the center date for zooming
   * @param {{x: Number, y: Number}} pointer
   * @return {number} date
   * @private
   */
  Range.prototype._pointerToDate = function (pointer) {
    var conversion;
    var direction = this.options.direction;

    validateDirection(direction);

    if (direction == 'horizontal') {
      return this.body.util.toTime(pointer.x).valueOf();
    } else {
      var height = this.body.domProps.center.height;
      conversion = this.conversion(height);
      return pointer.y / conversion.scale + conversion.offset;
    }
  };

  /**
   * Get the pointer location relative to the location of the dom element
   * @param {{x: Number, y: Number}} touch
   * @param {Element} element   HTML DOM element
   * @return {{x: Number, y: Number}} pointer
   * @private
   */
  Range.prototype.getPointer = function (touch, element) {
    if (this.options.rtl) {
      return {
        x: util.getAbsoluteRight(element) - touch.x,
        y: touch.y - util.getAbsoluteTop(element)
      };
    } else {
      return {
        x: touch.x - util.getAbsoluteLeft(element),
        y: touch.y - util.getAbsoluteTop(element)
      };
    }
  };

  /**
   * Zoom the range the given scale in or out. Start and end date will
   * be adjusted, and the timeline will be redrawn. You can optionally give a
   * date around which to zoom.
   * For example, try scale = 0.9 or 1.1
   * @param {Number} scale      Scaling factor. Values above 1 will zoom out,
   *                            values below 1 will zoom in.
   * @param {Number} [center]   Value representing a date around which will
   *                            be zoomed.
   */
  Range.prototype.zoom = function (scale, center, delta) {
    // if centerDate is not provided, take it half between start Date and end Date
    if (center == null) {
      center = (this.start + this.end) / 2;
    }

    var hiddenDuration = DateUtil.getHiddenDurationBetween(this.body.hiddenDates, this.start, this.end);
    var hiddenDurationBefore = DateUtil.getHiddenDurationBefore(this.options.moment, this.body.hiddenDates, this, center);
    var hiddenDurationAfter = hiddenDuration - hiddenDurationBefore;

    // calculate new start and end
    var newStart = center - hiddenDurationBefore + (this.start - (center - hiddenDurationBefore)) * scale;
    var newEnd = center + hiddenDurationAfter + (this.end - (center + hiddenDurationAfter)) * scale;

    // snapping times away from hidden zones
    this.startToFront = delta > 0 ? false : true; // used to do the right autocorrection with periodic hidden times
    this.endToFront = -delta > 0 ? false : true; // used to do the right autocorrection with periodic hidden times
    var safeStart = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newStart, delta, true);
    var safeEnd = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newEnd, -delta, true);
    if (safeStart != newStart || safeEnd != newEnd) {
      newStart = safeStart;
      newEnd = safeEnd;
    }

    this.setRange(newStart, newEnd, false, true);

    this.startToFront = false; // revert to default
    this.endToFront = true; // revert to default
  };

  /**
   * Move the range with a given delta to the left or right. Start and end
   * value will be adjusted. For example, try delta = 0.1 or -0.1
   * @param {Number}  delta     Moving amount. Positive value will move right,
   *                            negative value will move left
   */
  Range.prototype.move = function (delta) {
    // zoom start Date and end Date relative to the centerDate
    var diff = this.end - this.start;

    // apply new values
    var newStart = this.start + diff * delta;
    var newEnd = this.end + diff * delta;

    // TODO: reckon with min and max range

    this.start = newStart;
    this.end = newEnd;
  };

  /**
   * Move the range to a new center point
   * @param {Number} moveTo      New center point of the range
   */
  Range.prototype.moveTo = function (moveTo) {
    var center = (this.start + this.end) / 2;

    var diff = center - moveTo;

    // calculate new start and end
    var newStart = this.start - diff;
    var newEnd = this.end - diff;

    this.setRange(newStart, newEnd);
  };

  module.exports = Range;

/***/ },
/* 31 */
/***/ function(module, exports) {

  "use strict";

  /**
   * Prototype for visual components
   * @param {{dom: Object, domProps: Object, emitter: Emitter, range: Range}} [body]
   * @param {Object} [options]
   */
  function Component(body, options) {
    this.options = null;
    this.props = null;
  }

  /**
   * Set options for the component. The new options will be merged into the
   * current options.
   * @param {Object} options
   */
  Component.prototype.setOptions = function (options) {
    if (options) {
      util.extend(this.options, options);
    }
  };

  /**
   * Repaint the component
   * @return {boolean} Returns true if the component is resized
   */
  Component.prototype.redraw = function () {
    // should be implemented by the component
    return false;
  };

  /**
   * Destroy the component. Cleanup DOM and event listeners
   */
  Component.prototype.destroy = function () {
    // should be implemented by the component
  };

  /**
   * Test whether the component is resized since the last time _isResized() was
   * called.
   * @return {Boolean} Returns true if the component is resized
   * @protected
   */
  Component.prototype._isResized = function () {
    var resized = this.props._previousWidth !== this.props.width || this.props._previousHeight !== this.props.height;

    this.props._previousWidth = this.props.width;
    this.props._previousHeight = this.props.height;

    return resized;
  };

  module.exports = Component;

/***/ },
/* 32 */
/***/ function(module, exports) {

  "use strict";

  /**
   * used in Core to convert the options into a volatile variable
   * 
   * @param {function} moment
   * @param {Object} body
   * @param {Array | Object} hiddenDates
   */
  exports.convertHiddenOptions = function (moment, body, hiddenDates) {
    if (hiddenDates && !Array.isArray(hiddenDates)) {
      return exports.convertHiddenOptions(moment, body, [hiddenDates]);
    }

    body.hiddenDates = [];
    if (hiddenDates) {
      if (Array.isArray(hiddenDates) == true) {
        for (var i = 0; i < hiddenDates.length; i++) {
          if (hiddenDates[i].repeat === undefined) {
            var dateItem = {};
            dateItem.start = moment(hiddenDates[i].start).toDate().valueOf();
            dateItem.end = moment(hiddenDates[i].end).toDate().valueOf();
            body.hiddenDates.push(dateItem);
          }
        }
        body.hiddenDates.sort(function (a, b) {
          return a.start - b.start;
        }); // sort by start time
      }
    }
  };

  /**
   * create new entrees for the repeating hidden dates
   * @param {function} moment
   * @param {Object} body
   * @param {Array | Object} hiddenDates
   */
  exports.updateHiddenDates = function (moment, body, hiddenDates) {
    if (hiddenDates && !Array.isArray(hiddenDates)) {
      return exports.updateHiddenDates(moment, body, [hiddenDates]);
    }

    if (hiddenDates && body.domProps.centerContainer.width !== undefined) {
      exports.convertHiddenOptions(moment, body, hiddenDates);

      var start = moment(body.range.start);
      var end = moment(body.range.end);

      var totalRange = body.range.end - body.range.start;
      var pixelTime = totalRange / body.domProps.centerContainer.width;

      for (var i = 0; i < hiddenDates.length; i++) {
        if (hiddenDates[i].repeat !== undefined) {
          var startDate = moment(hiddenDates[i].start);
          var endDate = moment(hiddenDates[i].end);

          if (startDate._d == "Invalid Date") {
            throw new Error("Supplied start date is not valid: " + hiddenDates[i].start);
          }
          if (endDate._d == "Invalid Date") {
            throw new Error("Supplied end date is not valid: " + hiddenDates[i].end);
          }

          var duration = endDate - startDate;
          if (duration >= 4 * pixelTime) {

            var offset = 0;
            var runUntil = end.clone();
            switch (hiddenDates[i].repeat) {
              case "daily":
                // case of time
                if (startDate.day() != endDate.day()) {
                  offset = 1;
                }
                startDate.dayOfYear(start.dayOfYear());
                startDate.year(start.year());
                startDate.subtract(7, 'days');

                endDate.dayOfYear(start.dayOfYear());
                endDate.year(start.year());
                endDate.subtract(7 - offset, 'days');

                runUntil.add(1, 'weeks');
                break;
              case "weekly":
                var dayOffset = endDate.diff(startDate, 'days');
                var day = startDate.day();

                // set the start date to the range.start
                startDate.date(start.date());
                startDate.month(start.month());
                startDate.year(start.year());
                endDate = startDate.clone();

                // force
                startDate.day(day);
                endDate.day(day);
                endDate.add(dayOffset, 'days');

                startDate.subtract(1, 'weeks');
                endDate.subtract(1, 'weeks');

                runUntil.add(1, 'weeks');
                break;
              case "monthly":
                if (startDate.month() != endDate.month()) {
                  offset = 1;
                }
                startDate.month(start.month());
                startDate.year(start.year());
                startDate.subtract(1, 'months');

                endDate.month(start.month());
                endDate.year(start.year());
                endDate.subtract(1, 'months');
                endDate.add(offset, 'months');

                runUntil.add(1, 'months');
                break;
              case "yearly":
                if (startDate.year() != endDate.year()) {
                  offset = 1;
                }
                startDate.year(start.year());
                startDate.subtract(1, 'years');
                endDate.year(start.year());
                endDate.subtract(1, 'years');
                endDate.add(offset, 'years');

                runUntil.add(1, 'years');
                break;
              default:
                console.log("Wrong repeat format, allowed are: daily, weekly, monthly, yearly. Given:", hiddenDates[i].repeat);
                return;
            }
            while (startDate < runUntil) {
              body.hiddenDates.push({ start: startDate.valueOf(), end: endDate.valueOf() });
              switch (hiddenDates[i].repeat) {
                case "daily":
                  startDate.add(1, 'days');
                  endDate.add(1, 'days');
                  break;
                case "weekly":
                  startDate.add(1, 'weeks');
                  endDate.add(1, 'weeks');
                  break;
                case "monthly":
                  startDate.add(1, 'months');
                  endDate.add(1, 'months');
                  break;
                case "yearly":
                  startDate.add(1, 'y');
                  endDate.add(1, 'y');
                  break;
                default:
                  console.log("Wrong repeat format, allowed are: daily, weekly, monthly, yearly. Given:", hiddenDates[i].repeat);
                  return;
              }
            }
            body.hiddenDates.push({ start: startDate.valueOf(), end: endDate.valueOf() });
          }
        }
      }
      // remove duplicates, merge where possible
      exports.removeDuplicates(body);
      // ensure the new positions are not on hidden dates
      var startHidden = exports.isHidden(body.range.start, body.hiddenDates);
      var endHidden = exports.isHidden(body.range.end, body.hiddenDates);
      var rangeStart = body.range.start;
      var rangeEnd = body.range.end;
      if (startHidden.hidden == true) {
        rangeStart = body.range.startToFront == true ? startHidden.startDate - 1 : startHidden.endDate + 1;
      }
      if (endHidden.hidden == true) {
        rangeEnd = body.range.endToFront == true ? endHidden.startDate - 1 : endHidden.endDate + 1;
      }
      if (startHidden.hidden == true || endHidden.hidden == true) {
        body.range._applyRange(rangeStart, rangeEnd);
      }
    }
  };

  /**
   * remove duplicates from the hidden dates list. Duplicates are evil. They mess everything up.
   * Scales with N^2
   * @param body
   */
  exports.removeDuplicates = function (body) {
    var hiddenDates = body.hiddenDates;
    var safeDates = [];
    for (var i = 0; i < hiddenDates.length; i++) {
      for (var j = 0; j < hiddenDates.length; j++) {
        if (i != j && hiddenDates[j].remove != true && hiddenDates[i].remove != true) {
          // j inside i
          if (hiddenDates[j].start >= hiddenDates[i].start && hiddenDates[j].end <= hiddenDates[i].end) {
            hiddenDates[j].remove = true;
          }
          // j start inside i
          else if (hiddenDates[j].start >= hiddenDates[i].start && hiddenDates[j].start <= hiddenDates[i].end) {
              hiddenDates[i].end = hiddenDates[j].end;
              hiddenDates[j].remove = true;
            }
            // j end inside i
            else if (hiddenDates[j].end >= hiddenDates[i].start && hiddenDates[j].end <= hiddenDates[i].end) {
                hiddenDates[i].start = hiddenDates[j].start;
                hiddenDates[j].remove = true;
              }
        }
      }
    }

    for (var i = 0; i < hiddenDates.length; i++) {
      if (hiddenDates[i].remove !== true) {
        safeDates.push(hiddenDates[i]);
      }
    }

    body.hiddenDates = safeDates;
    body.hiddenDates.sort(function (a, b) {
      return a.start - b.start;
    }); // sort by start time
  };

  exports.printDates = function (dates) {
    for (var i = 0; i < dates.length; i++) {
      console.log(i, new Date(dates[i].start), new Date(dates[i].end), dates[i].start, dates[i].end, dates[i].remove);
    }
  };

  /**
   * Used in TimeStep to avoid the hidden times.
   * @param {function} moment
   * @param {TimeStep} timeStep
   * @param previousTime
   */
  exports.stepOverHiddenDates = function (moment, timeStep, previousTime) {
    var stepInHidden = false;
    var currentValue = timeStep.current.valueOf();
    for (var i = 0; i < timeStep.hiddenDates.length; i++) {
      var startDate = timeStep.hiddenDates[i].start;
      var endDate = timeStep.hiddenDates[i].end;
      if (currentValue >= startDate && currentValue < endDate) {
        stepInHidden = true;
        break;
      }
    }

    if (stepInHidden == true && currentValue < timeStep._end.valueOf() && currentValue != previousTime) {
      var prevValue = moment(previousTime);
      var newValue = moment(endDate);
      //check if the next step should be major
      if (prevValue.year() != newValue.year()) {
        timeStep.switchedYear = true;
      } else if (prevValue.month() != newValue.month()) {
        timeStep.switchedMonth = true;
      } else if (prevValue.dayOfYear() != newValue.dayOfYear()) {
        timeStep.switchedDay = true;
      }

      timeStep.current = newValue;
    }
  };

  ///**
  // * Used in TimeStep to avoid the hidden times.
  // * @param timeStep
  // * @param previousTime
  // */
  //exports.checkFirstStep = function(timeStep) {
  //  var stepInHidden = false;
  //  var currentValue = timeStep.current.valueOf();
  //  for (var i = 0; i < timeStep.hiddenDates.length; i++) {
  //    var startDate = timeStep.hiddenDates[i].start;
  //    var endDate = timeStep.hiddenDates[i].end;
  //    if (currentValue >= startDate && currentValue < endDate) {
  //      stepInHidden = true;
  //      break;
  //    }
  //  }
  //
  //  if (stepInHidden == true && currentValue <= timeStep._end.valueOf()) {
  //    var newValue = moment(endDate);
  //    timeStep.current = newValue.toDate();
  //  }
  //};

  /**
   * replaces the Core toScreen methods
   * @param Core
   * @param time
   * @param width
   * @returns {number}
   */
  exports.toScreen = function (Core, time, width) {
    if (Core.body.hiddenDates.length == 0) {
      var conversion = Core.range.conversion(width);
      return (time.valueOf() - conversion.offset) * conversion.scale;
    } else {
      var hidden = exports.isHidden(time, Core.body.hiddenDates);
      if (hidden.hidden == true) {
        time = hidden.startDate;
      }

      var duration = exports.getHiddenDurationBetween(Core.body.hiddenDates, Core.range.start, Core.range.end);
      time = exports.correctTimeForHidden(Core.options.moment, Core.body.hiddenDates, Core.range, time);

      var conversion = Core.range.conversion(width, duration);
      return (time.valueOf() - conversion.offset) * conversion.scale;
    }
  };

  /**
   * Replaces the core toTime methods
   * @param body
   * @param range
   * @param x
   * @param width
   * @returns {Date}
   */
  exports.toTime = function (Core, x, width) {
    if (Core.body.hiddenDates.length == 0) {
      var conversion = Core.range.conversion(width);
      return new Date(x / conversion.scale + conversion.offset);
    } else {
      var hiddenDuration = exports.getHiddenDurationBetween(Core.body.hiddenDates, Core.range.start, Core.range.end);
      var totalDuration = Core.range.end - Core.range.start - hiddenDuration;
      var partialDuration = totalDuration * x / width;
      var accumulatedHiddenDuration = exports.getAccumulatedHiddenDuration(Core.body.hiddenDates, Core.range, partialDuration);

      var newTime = new Date(accumulatedHiddenDuration + partialDuration + Core.range.start);
      return newTime;
    }
  };

  /**
   * Support function
   *
   * @param hiddenDates
   * @param range
   * @returns {number}
   */
  exports.getHiddenDurationBetween = function (hiddenDates, start, end) {
    var duration = 0;
    for (var i = 0; i < hiddenDates.length; i++) {
      var startDate = hiddenDates[i].start;
      var endDate = hiddenDates[i].end;
      // if time after the cutout, and the
      if (startDate >= start && endDate < end) {
        duration += endDate - startDate;
      }
    }
    return duration;
  };

  /**
   * Support function
   * @param moment
   * @param hiddenDates
   * @param range
   * @param time
   * @returns {{duration: number, time: *, offset: number}}
   */
  exports.correctTimeForHidden = function (moment, hiddenDates, range, time) {
    time = moment(time).toDate().valueOf();
    time -= exports.getHiddenDurationBefore(moment, hiddenDates, range, time);
    return time;
  };

  exports.getHiddenDurationBefore = function (moment, hiddenDates, range, time) {
    var timeOffset = 0;
    time = moment(time).toDate().valueOf();

    for (var i = 0; i < hiddenDates.length; i++) {
      var startDate = hiddenDates[i].start;
      var endDate = hiddenDates[i].end;
      // if time after the cutout, and the
      if (startDate >= range.start && endDate < range.end) {
        if (time >= endDate) {
          timeOffset += endDate - startDate;
        }
      }
    }
    return timeOffset;
  };

  /**
   * sum the duration from start to finish, including the hidden duration,
   * until the required amount has been reached, return the accumulated hidden duration
   * @param hiddenDates
   * @param range
   * @param time
   * @returns {{duration: number, time: *, offset: number}}
   */
  exports.getAccumulatedHiddenDuration = function (hiddenDates, range, requiredDuration) {
    var hiddenDuration = 0;
    var duration = 0;
    var previousPoint = range.start;
    //exports.printDates(hiddenDates)
    for (var i = 0; i < hiddenDates.length; i++) {
      var startDate = hiddenDates[i].start;
      var endDate = hiddenDates[i].end;
      // if time after the cutout, and the
      if (startDate >= range.start && endDate < range.end) {
        duration += startDate - previousPoint;
        previousPoint = endDate;
        if (duration >= requiredDuration) {
          break;
        } else {
          hiddenDuration += endDate - startDate;
        }
      }
    }

    return hiddenDuration;
  };

  /**
   * used to step over to either side of a hidden block. Correction is disabled on tablets, might be set to true
   * @param hiddenDates
   * @param time
   * @param direction
   * @param correctionEnabled
   * @returns {*}
   */
  exports.snapAwayFromHidden = function (hiddenDates, time, direction, correctionEnabled) {
    var isHidden = exports.isHidden(time, hiddenDates);
    if (isHidden.hidden == true) {
      if (direction < 0) {
        if (correctionEnabled == true) {
          return isHidden.startDate - (isHidden.endDate - time) - 1;
        } else {
          return isHidden.startDate - 1;
        }
      } else {
        if (correctionEnabled == true) {
          return isHidden.endDate + (time - isHidden.startDate) + 1;
        } else {
          return isHidden.endDate + 1;
        }
      }
    } else {
      return time;
    }
  };

  /**
   * Check if a time is hidden
   *
   * @param time
   * @param hiddenDates
   * @returns {{hidden: boolean, startDate: Window.start, endDate: *}}
   */
  exports.isHidden = function (time, hiddenDates) {
    for (var i = 0; i < hiddenDates.length; i++) {
      var startDate = hiddenDates[i].start;
      var endDate = hiddenDates[i].end;

      if (time >= startDate && time < endDate) {
        // if the start is entering a hidden zone
        return { hidden: true, startDate: startDate, endDate: endDate };
        break;
      }
    }
    return { hidden: false, startDate: startDate, endDate: endDate };
  };

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

  var Emitter = __webpack_require__(13);
  var Hammer = __webpack_require__(20);
  var hammerUtil = __webpack_require__(28);
  var util = __webpack_require__(1);
  var DataSet = __webpack_require__(9);
  var DataView = __webpack_require__(11);
  var Range = __webpack_require__(30);
  var ItemSet = __webpack_require__(34);
  var TimeAxis = __webpack_require__(44);
  var Activator = __webpack_require__(45);
  var DateUtil = __webpack_require__(32);
  var CustomTime = __webpack_require__(46);

  /**
   * Create a timeline visualization
   * @constructor
   */
  function Core() {}

  // turn Core into an event emitter
  Emitter(Core.prototype);

  /**
   * Create the main DOM for the Core: a root panel containing left, right,
   * top, bottom, content, and background panel.
   * @param {Element} container  The container element where the Core will
   *                             be attached.
   * @protected
   */
  Core.prototype._create = function (container) {
    this.dom = {};

    this.dom.container = container;

    this.dom.root = document.createElement('div');
    this.dom.background = document.createElement('div');
    this.dom.backgroundVertical = document.createElement('div');
    this.dom.backgroundHorizontal = document.createElement('div');
    this.dom.centerContainer = document.createElement('div');
    this.dom.leftContainer = document.createElement('div');
    this.dom.rightContainer = document.createElement('div');
    this.dom.center = document.createElement('div');
    this.dom.left = document.createElement('div');
    this.dom.right = document.createElement('div');
    this.dom.top = document.createElement('div');
    this.dom.bottom = document.createElement('div');
    this.dom.shadowTop = document.createElement('div');
    this.dom.shadowBottom = document.createElement('div');
    this.dom.shadowTopLeft = document.createElement('div');
    this.dom.shadowBottomLeft = document.createElement('div');
    this.dom.shadowTopRight = document.createElement('div');
    this.dom.shadowBottomRight = document.createElement('div');

    this.dom.root.className = 'vis-timeline';
    this.dom.background.className = 'vis-panel vis-background';
    this.dom.backgroundVertical.className = 'vis-panel vis-background vis-vertical';
    this.dom.backgroundHorizontal.className = 'vis-panel vis-background vis-horizontal';
    this.dom.centerContainer.className = 'vis-panel vis-center';
    this.dom.leftContainer.className = 'vis-panel vis-left';
    this.dom.rightContainer.className = 'vis-panel vis-right';
    this.dom.top.className = 'vis-panel vis-top';
    this.dom.bottom.className = 'vis-panel vis-bottom';
    this.dom.left.className = 'vis-content';
    this.dom.center.className = 'vis-content';
    this.dom.right.className = 'vis-content';
    this.dom.shadowTop.className = 'vis-shadow vis-top';
    this.dom.shadowBottom.className = 'vis-shadow vis-bottom';
    this.dom.shadowTopLeft.className = 'vis-shadow vis-top';
    this.dom.shadowBottomLeft.className = 'vis-shadow vis-bottom';
    this.dom.shadowTopRight.className = 'vis-shadow vis-top';
    this.dom.shadowBottomRight.className = 'vis-shadow vis-bottom';

    this.dom.root.appendChild(this.dom.background);
    this.dom.root.appendChild(this.dom.backgroundVertical);
    this.dom.root.appendChild(this.dom.backgroundHorizontal);
    this.dom.root.appendChild(this.dom.centerContainer);
    this.dom.root.appendChild(this.dom.leftContainer);
    this.dom.root.appendChild(this.dom.rightContainer);
    this.dom.root.appendChild(this.dom.top);
    this.dom.root.appendChild(this.dom.bottom);

    this.dom.centerContainer.appendChild(this.dom.center);
    this.dom.leftContainer.appendChild(this.dom.left);
    this.dom.rightContainer.appendChild(this.dom.right);

    this.dom.centerContainer.appendChild(this.dom.shadowTop);
    this.dom.centerContainer.appendChild(this.dom.shadowBottom);
    this.dom.leftContainer.appendChild(this.dom.shadowTopLeft);
    this.dom.leftContainer.appendChild(this.dom.shadowBottomLeft);
    this.dom.rightContainer.appendChild(this.dom.shadowTopRight);
    this.dom.rightContainer.appendChild(this.dom.shadowBottomRight);

    this.on('rangechange', function () {
      if (this.initialDrawDone === true) {
        this._redraw(); // this allows overriding the _redraw method
      }
    }.bind(this));
    this.on('touch', this._onTouch.bind(this));
    this.on('pan', this._onDrag.bind(this));

    var me = this;
    this.on('_change', function (properties) {
      if (properties && properties.queue == true) {
        // redraw once on next tick
        if (!me._redrawTimer) {
          me._redrawTimer = setTimeout(function () {
            me._redrawTimer = null;
            me._redraw();
          }, 0);
        }
      } else {
        // redraw immediately
        me._redraw();
      }
    });

    // create event listeners for all interesting events, these events will be
    // emitted via emitter
    this.hammer = new Hammer(this.dom.root);
    var pinchRecognizer = this.hammer.get('pinch').set({ enable: true });
    hammerUtil.disablePreventDefaultVertically(pinchRecognizer);
    this.hammer.get('pan').set({ threshold: 5, direction: Hammer.DIRECTION_HORIZONTAL });
    this.listeners = {};

    var events = ['tap', 'doubletap', 'press', 'pinch', 'pan', 'panstart', 'panmove', 'panend'
    // TODO: cleanup
    //'touch', 'pinch',
    //'tap', 'doubletap', 'hold',
    //'dragstart', 'drag', 'dragend',
    //'mousewheel', 'DOMMouseScroll' // DOMMouseScroll is needed for Firefox
    ];
    events.forEach(function (type) {
      var listener = function listener(event) {
        if (me.isActive()) {
          me.emit(type, event);
        }
      };
      me.hammer.on(type, listener);
      me.listeners[type] = listener;
    });

    // emulate a touch event (emitted before the start of a pan, pinch, tap, or press)
    hammerUtil.onTouch(this.hammer, function (event) {
      me.emit('touch', event);
    }.bind(this));

    // emulate a release event (emitted after a pan, pinch, tap, or press)
    hammerUtil.onRelease(this.hammer, function (event) {
      me.emit('release', event);
    }.bind(this));

    function onMouseWheel(event) {
      if (me.isActive()) {
        me.emit('mousewheel', event);
      }
    }
    this.dom.root.addEventListener('mousewheel', onMouseWheel);
    this.dom.root.addEventListener('DOMMouseScroll', onMouseWheel);

    // size properties of each of the panels
    this.props = {
      root: {},
      background: {},
      centerContainer: {},
      leftContainer: {},
      rightContainer: {},
      center: {},
      left: {},
      right: {},
      top: {},
      bottom: {},
      border: {},
      scrollTop: 0,
      scrollTopMin: 0
    };

    this.customTimes = [];

    // store state information needed for touch events
    this.touch = {};

    this.redrawCount = 0;
    this.initialDrawDone = false;

    // attach the root panel to the provided container
    if (!container) throw new Error('No container provided');
    container.appendChild(this.dom.root);
  };

  /**
   * Set options. Options will be passed to all components loaded in the Timeline.
   * @param {Object} [options]
   *                           {String} orientation
   *                              Vertical orientation for the Timeline,
   *                              can be 'bottom' (default) or 'top'.
   *                           {String | Number} width
   *                              Width for the timeline, a number in pixels or
   *                              a css string like '1000px' or '75%'. '100%' by default.
   *                           {String | Number} height
   *                              Fixed height for the Timeline, a number in pixels or
   *                              a css string like '400px' or '75%'. If undefined,
   *                              The Timeline will automatically size such that
   *                              its contents fit.
   *                           {String | Number} minHeight
   *                              Minimum height for the Timeline, a number in pixels or
   *                              a css string like '400px' or '75%'.
   *                           {String | Number} maxHeight
   *                              Maximum height for the Timeline, a number in pixels or
   *                              a css string like '400px' or '75%'.
   *                           {Number | Date | String} start
   *                              Start date for the visible window
   *                           {Number | Date | String} end
   *                              End date for the visible window
   */
  Core.prototype.setOptions = function (options) {
    if (options) {
      // copy the known options
      var fields = ['width', 'height', 'minHeight', 'maxHeight', 'autoResize', 'start', 'end', 'clickToUse', 'dataAttributes', 'hiddenDates', 'locale', 'locales', 'moment', 'rtl', 'throttleRedraw'];
      util.selectiveExtend(fields, this.options, options);

      if (this.options.rtl) {
        var contentContainer = this.dom.leftContainer;
        this.dom.leftContainer = this.dom.rightContainer;
        this.dom.rightContainer = contentContainer;
        this.dom.container.style.direction = "rtl";
        this.dom.backgroundVertical.className = 'vis-panel vis-background vis-vertical-rtl';
      }

      this.options.orientation = { item: undefined, axis: undefined };
      if ('orientation' in options) {
        if (typeof options.orientation === 'string') {
          this.options.orientation = {
            item: options.orientation,
            axis: options.orientation
          };
        } else if (_typeof(options.orientation) === 'object') {
          if ('item' in options.orientation) {
            this.options.orientation.item = options.orientation.item;
          }
          if ('axis' in options.orientation) {
            this.options.orientation.axis = options.orientation.axis;
          }
        }
      }

      if (this.options.orientation.axis === 'both') {
        if (!this.timeAxis2) {
          var timeAxis2 = this.timeAxis2 = new TimeAxis(this.body);
          timeAxis2.setOptions = function (options) {
            var _options = options ? util.extend({}, options) : {};
            _options.orientation = 'top'; // override the orientation option, always top
            TimeAxis.prototype.setOptions.call(timeAxis2, _options);
          };
          this.components.push(timeAxis2);
        }
      } else {
        if (this.timeAxis2) {
          var index = this.components.indexOf(this.timeAxis2);
          if (index !== -1) {
            this.components.splice(index, 1);
          }
          this.timeAxis2.destroy();
          this.timeAxis2 = null;
        }
      }

      // if the graph2d's drawPoints is a function delegate the callback to the onRender property
      if (typeof options.drawPoints == 'function') {
        options.drawPoints = {
          onRender: options.drawPoints
        };
      }

      if ('hiddenDates' in this.options) {
        DateUtil.convertHiddenOptions(this.options.moment, this.body, this.options.hiddenDates);
      }

      if ('clickToUse' in options) {
        if (options.clickToUse) {
          if (!this.activator) {
            this.activator = new Activator(this.dom.root);
          }
        } else {
          if (this.activator) {
            this.activator.destroy();
            delete this.activator;
          }
        }
      }

      if ('showCustomTime' in options) {
        throw new Error('Option `showCustomTime` is deprecated. Create a custom time bar via timeline.addCustomTime(time [, id])');
      }

      // enable/disable autoResize
      this._initAutoResize();
    }

    // propagate options to all components
    this.components.forEach(function (component) {
      return component.setOptions(options);
    });

    // enable/disable configure
    if ('configure' in options) {
      if (!this.configurator) {
        this.configurator = this._createConfigurator();
      }

      this.configurator.setOptions(options.configure);

      // collect the settings of all components, and pass them to the configuration system
      var appliedOptions = util.deepExtend({}, this.options);
      this.components.forEach(function (component) {
        util.deepExtend(appliedOptions, component.options);
      });
      this.configurator.setModuleOptions({ global: appliedOptions });
    }

    // override redraw with a throttled version
    if (!this._origRedraw) {
      this._origRedraw = this._redraw.bind(this);
      this._redraw = util.throttle(this._origRedraw, this.options.throttleRedraw);
    } else {
      // Not the initial run: redraw everything
      this._redraw();
    }
  };

  /**
   * Returns true when the Timeline is active.
   * @returns {boolean}
   */
  Core.prototype.isActive = function () {
    return !this.activator || this.activator.active;
  };

  /**
   * Destroy the Core, clean up all DOM elements and event listeners.
   */
  Core.prototype.destroy = function () {
    // unbind datasets
    this.setItems(null);
    this.setGroups(null);

    // remove all event listeners
    this.off();

    // stop checking for changed size
    this._stopAutoResize();

    // remove from DOM
    if (this.dom.root.parentNode) {
      this.dom.root.parentNode.removeChild(this.dom.root);
    }
    this.dom = null;

    // remove Activator
    if (this.activator) {
      this.activator.destroy();
      delete this.activator;
    }

    // cleanup hammer touch events
    for (var event in this.listeners) {
      if (this.listeners.hasOwnProperty(event)) {
        delete this.listeners[event];
      }
    }
    this.listeners = null;
    this.hammer = null;

    // give all components the opportunity to cleanup
    this.components.forEach(function (component) {
      return component.destroy();
    });

    this.body = null;
  };

  /**
   * Set a custom time bar
   * @param {Date} time
   * @param {number} [id=undefined] Optional id of the custom time bar to be adjusted.
   */
  Core.prototype.setCustomTime = function (time, id) {
    var customTimes = this.customTimes.filter(function (component) {
      return id === component.options.id;
    });

    if (customTimes.length === 0) {
      throw new Error('No custom time bar found with id ' + JSON.stringify(id));
    }

    if (customTimes.length > 0) {
      customTimes[0].setCustomTime(time);
    }
  };

  /**
   * Retrieve the current custom time.
   * @param {number} [id=undefined]    Id of the custom time bar.
   * @return {Date | undefined} customTime
   */
  Core.prototype.getCustomTime = function (id) {
    var customTimes = this.customTimes.filter(function (component) {
      return component.options.id === id;
    });

    if (customTimes.length === 0) {
      throw new Error('No custom time bar found with id ' + JSON.stringify(id));
    }
    return customTimes[0].getCustomTime();
  };

  /**
   * Set a custom title for the custom time bar.
   * @param {String} [title] Custom title
   * @param {number} [id=undefined]    Id of the custom time bar.
   */
  Core.prototype.setCustomTimeTitle = function (title, id) {
    var customTimes = this.customTimes.filter(function (component) {
      return component.options.id === id;
    });

    if (customTimes.length === 0) {
      throw new Error('No custom time bar found with id ' + JSON.stringify(id));
    }
    if (customTimes.length > 0) {
      return customTimes[0].setCustomTitle(title);
    }
  };

  /**
   * Retrieve meta information from an event.
   * Should be overridden by classes extending Core
   * @param {Event} event
   * @return {Object} An object with related information.
   */
  Core.prototype.getEventProperties = function (event) {
    return { event: event };
  };

  /**
   * Add custom vertical bar
   * @param {Date | String | Number} [time]  A Date, unix timestamp, or
   *                                         ISO date string. Time point where
   *                                         the new bar should be placed.
   *                                         If not provided, `new Date()` will
   *                                         be used.
   * @param {Number | String} [id=undefined] Id of the new bar. Optional
   * @return {Number | String}               Returns the id of the new bar
   */
  Core.prototype.addCustomTime = function (time, id) {
    var timestamp = time !== undefined ? util.convert(time, 'Date').valueOf() : new Date();

    var exists = this.customTimes.some(function (customTime) {
      return customTime.options.id === id;
    });
    if (exists) {
      throw new Error('A custom time with id ' + JSON.stringify(id) + ' already exists');
    }

    var customTime = new CustomTime(this.body, util.extend({}, this.options, {
      time: timestamp,
      id: id
    }));

    this.customTimes.push(customTime);
    this.components.push(customTime);
    this._redraw();

    return id;
  };

  /**
   * Remove previously added custom bar
   * @param {int} id ID of the custom bar to be removed
   * @return {boolean} True if the bar exists and is removed, false otherwise
   */
  Core.prototype.removeCustomTime = function (id) {
    var customTimes = this.customTimes.filter(function (bar) {
      return bar.options.id === id;
    });

    if (customTimes.length === 0) {
      throw new Error('No custom time bar found with id ' + JSON.stringify(id));
    }

    customTimes.forEach(function (customTime) {
      this.customTimes.splice(this.customTimes.indexOf(customTime), 1);
      this.components.splice(this.components.indexOf(customTime), 1);
      customTime.destroy();
    }.bind(this));
  };

  /**
   * Get the id's of the currently visible items.
   * @returns {Array} The ids of the visible items
   */
  Core.prototype.getVisibleItems = function () {
    return this.itemSet && this.itemSet.getVisibleItems() || [];
  };

  /**
   * Set Core window such that it fits all items
   * @param {Object} [options]  Available options:
   *                                `animation: boolean | {duration: number, easingFunction: string}`
   *                                    If true (default), the range is animated
   *                                    smoothly to the new window. An object can be
   *                                    provided to specify duration and easing function.
   *                                    Default duration is 500 ms, and default easing
   *                                    function is 'easeInOutQuad'.
   */
  Core.prototype.fit = function (options) {
    var range = this.getDataRange();

    // skip range set if there is no min and max date
    if (range.min === null && range.max === null) {
      return;
    }

    // apply a margin of 1% left and right of the data
    var interval = range.max - range.min;
    var min = new Date(range.min.valueOf() - interval * 0.01);
    var max = new Date(range.max.valueOf() + interval * 0.01);
    var animation = options && options.animation !== undefined ? options.animation : true;
    this.range.setRange(min, max, animation);
  };

  /**
   * Calculate the data range of the items start and end dates
   * @returns {{min: Date | null, max: Date | null}}
   * @protected
   */
  Core.prototype.getDataRange = function () {
    // must be implemented by Timeline and Graph2d
    throw new Error('Cannot invoke abstract method getDataRange');
  };

  /**
   * Set the visible window. Both parameters are optional, you can change only
   * start or only end. Syntax:
   *
   *     TimeLine.setWindow(start, end)
   *     TimeLine.setWindow(start, end, options)
   *     TimeLine.setWindow(range)
   *
   * Where start and end can be a Date, number, or string, and range is an
   * object with properties start and end.
   *
   * @param {Date | Number | String | Object} [start] Start date of visible window
   * @param {Date | Number | String} [end]            End date of visible window
   * @param {Object} [options]  Available options:
   *                                `animation: boolean | {duration: number, easingFunction: string}`
   *                                    If true (default), the range is animated
   *                                    smoothly to the new window. An object can be
   *                                    provided to specify duration and easing function.
   *                                    Default duration is 500 ms, and default easing
   *                                    function is 'easeInOutQuad'.
   */
  Core.prototype.setWindow = function (start, end, options) {
    var animation;
    if (arguments.length == 1) {
      var range = arguments[0];
      animation = range.animation !== undefined ? range.animation : true;
      this.range.setRange(range.start, range.end, animation);
    } else {
      animation = options && options.animation !== undefined ? options.animation : true;
      this.range.setRange(start, end, animation);
    }
  };

  /**
   * Move the window such that given time is centered on screen.
   * @param {Date | Number | String} time
   * @param {Object} [options]  Available options:
   *                                `animation: boolean | {duration: number, easingFunction: string}`
   *                                    If true (default), the range is animated
   *                                    smoothly to the new window. An object can be
   *                                    provided to specify duration and easing function.
   *                                    Default duration is 500 ms, and default easing
   *                                    function is 'easeInOutQuad'.
   */
  Core.prototype.moveTo = function (time, options) {
    var interval = this.range.end - this.range.start;
    var t = util.convert(time, 'Date').valueOf();

    var start = t - interval / 2;
    var end = t + interval / 2;
    var animation = options && options.animation !== undefined ? options.animation : true;

    this.range.setRange(start, end, animation);
  };

  /**
   * Get the visible window
   * @return {{start: Date, end: Date}}   Visible range
   */
  Core.prototype.getWindow = function () {
    var range = this.range.getRange();
    return {
      start: new Date(range.start),
      end: new Date(range.end)
    };
  };

  /**
   * Force a redraw. Can be overridden by implementations of Core
   *
   * Note: this function will be overridden on construction with a trottled version
   */
  Core.prototype.redraw = function () {
    this._redraw();
  };

  /**
   * Redraw for internal use. Redraws all components. See also the public
   * method redraw.
   * @protected
   */
  Core.prototype._redraw = function () {
    this.redrawCount++;
    var resized = false;
    var options = this.options;
    var props = this.props;
    var dom = this.dom;

    if (!dom || !dom.container || dom.root.offsetWidth == 0) return; // when destroyed, or invisible

    DateUtil.updateHiddenDates(this.options.moment, this.body, this.options.hiddenDates);

    // update class names
    if (options.orientation == 'top') {
      util.addClassName(dom.root, 'vis-top');
      util.removeClassName(dom.root, 'vis-bottom');
    } else {
      util.removeClassName(dom.root, 'vis-top');
      util.addClassName(dom.root, 'vis-bottom');
    }

    // update root width and height options
    dom.root.style.maxHeight = util.option.asSize(options.maxHeight, '');
    dom.root.style.minHeight = util.option.asSize(options.minHeight, '');
    dom.root.style.width = util.option.asSize(options.width, '');

    // calculate border widths
    props.border.left = (dom.centerContainer.offsetWidth - dom.centerContainer.clientWidth) / 2;
    props.border.right = props.border.left;
    props.border.top = (dom.centerContainer.offsetHeight - dom.centerContainer.clientHeight) / 2;
    props.border.bottom = props.border.top;
    var borderRootHeight = dom.root.offsetHeight - dom.root.clientHeight;
    var borderRootWidth = dom.root.offsetWidth - dom.root.clientWidth;

    // workaround for a bug in IE: the clientWidth of an element with
    // a height:0px and overflow:hidden is not calculated and always has value 0
    if (dom.centerContainer.clientHeight === 0) {
      props.border.left = props.border.top;
      props.border.right = props.border.left;
    }
    if (dom.root.clientHeight === 0) {
      borderRootWidth = borderRootHeight;
    }

    // calculate the heights. If any of the side panels is empty, we set the height to
    // minus the border width, such that the border will be invisible
    props.center.height = dom.center.offsetHeight;
    props.left.height = dom.left.offsetHeight;
    props.right.height = dom.right.offsetHeight;
    props.top.height = dom.top.clientHeight || -props.border.top;
    props.bottom.height = dom.bottom.clientHeight || -props.border.bottom;

    // TODO: compensate borders when any of the panels is empty.

    // apply auto height
    // TODO: only calculate autoHeight when needed (else we cause an extra reflow/repaint of the DOM)
    var contentHeight = Math.max(props.left.height, props.center.height, props.right.height);
    var autoHeight = props.top.height + contentHeight + props.bottom.height + borderRootHeight + props.border.top + props.border.bottom;
    dom.root.style.height = util.option.asSize(options.height, autoHeight + 'px');

    // calculate heights of the content panels
    props.root.height = dom.root.offsetHeight;
    props.background.height = props.root.height - borderRootHeight;
    var containerHeight = props.root.height - props.top.height - props.bottom.height - borderRootHeight;
    props.centerContainer.height = containerHeight;
    props.leftContainer.height = containerHeight;
    props.rightContainer.height = props.leftContainer.height;

    // calculate the widths of the panels
    props.root.width = dom.root.offsetWidth;
    props.background.width = props.root.width - borderRootWidth;
    props.left.width = dom.leftContainer.clientWidth || -props.border.left;
    props.leftContainer.width = props.left.width;
    props.right.width = dom.rightContainer.clientWidth || -props.border.right;
    props.rightContainer.width = props.right.width;
    var centerWidth = props.root.width - props.left.width - props.right.width - borderRootWidth;
    props.center.width = centerWidth;
    props.centerContainer.width = centerWidth;
    props.top.width = centerWidth;
    props.bottom.width = centerWidth;

    // resize the panels
    dom.background.style.height = props.background.height + 'px';
    dom.backgroundVertical.style.height = props.background.height + 'px';
    dom.backgroundHorizontal.style.height = props.centerContainer.height + 'px';
    dom.centerContainer.style.height = props.centerContainer.height + 'px';
    dom.leftContainer.style.height = props.leftContainer.height + 'px';
    dom.rightContainer.style.height = props.rightContainer.height + 'px';

    dom.background.style.width = props.background.width + 'px';
    dom.backgroundVertical.style.width = props.centerContainer.width + 'px';
    dom.backgroundHorizontal.style.width = props.background.width + 'px';
    dom.centerContainer.style.width = props.center.width + 'px';
    dom.top.style.width = props.top.width + 'px';
    dom.bottom.style.width = props.bottom.width + 'px';

    // reposition the panels
    dom.background.style.left = '0';
    dom.background.style.top = '0';
    dom.backgroundVertical.style.left = props.left.width + props.border.left + 'px';
    dom.backgroundVertical.style.top = '0';
    dom.backgroundHorizontal.style.left = '0';
    dom.backgroundHorizontal.style.top = props.top.height + 'px';
    dom.centerContainer.style.left = props.left.width + 'px';
    dom.centerContainer.style.top = props.top.height + 'px';
    dom.leftContainer.style.left = '0';
    dom.leftContainer.style.top = props.top.height + 'px';
    dom.rightContainer.style.left = props.left.width + props.center.width + 'px';
    dom.rightContainer.style.top = props.top.height + 'px';
    dom.top.style.left = props.left.width + 'px';
    dom.top.style.top = '0';
    dom.bottom.style.left = props.left.width + 'px';
    dom.bottom.style.top = props.top.height + props.centerContainer.height + 'px';

    // update the scrollTop, feasible range for the offset can be changed
    // when the height of the Core or of the contents of the center changed
    this._updateScrollTop();

    // reposition the scrollable contents
    var offset = this.props.scrollTop;
    if (options.orientation.item != 'top') {
      offset += Math.max(this.props.centerContainer.height - this.props.center.height - this.props.border.top - this.props.border.bottom, 0);
    }
    dom.center.style.left = '0';
    dom.center.style.top = offset + 'px';
    dom.left.style.left = '0';
    dom.left.style.top = offset + 'px';
    dom.right.style.left = '0';
    dom.right.style.top = offset + 'px';

    // show shadows when vertical scrolling is available
    var visibilityTop = this.props.scrollTop == 0 ? 'hidden' : '';
    var visibilityBottom = this.props.scrollTop == this.props.scrollTopMin ? 'hidden' : '';
    dom.shadowTop.style.visibility = visibilityTop;
    dom.shadowBottom.style.visibility = visibilityBottom;
    dom.shadowTopLeft.style.visibility = visibilityTop;
    dom.shadowBottomLeft.style.visibility = visibilityBottom;
    dom.shadowTopRight.style.visibility = visibilityTop;
    dom.shadowBottomRight.style.visibility = visibilityBottom;

    // enable/disable vertical panning
    var contentsOverflow = this.props.center.height > this.props.centerContainer.height;
    this.hammer.get('pan').set({
      direction: contentsOverflow ? Hammer.DIRECTION_ALL : Hammer.DIRECTION_HORIZONTAL
    });

    // redraw all components
    this.components.forEach(function (component) {
      resized = component.redraw() || resized;
    });
    var MAX_REDRAW = 5;
    if (resized) {
      if (this.redrawCount < MAX_REDRAW) {
        this.body.emitter.emit('_change');
        return;
      } else {
        console.log('WARNING: infinite loop in redraw?');
      }
    } else {
      this.redrawCount = 0;
    }
    this.initialDrawDone = true;

    //Emit public 'changed' event for UI updates, see issue #1592
    this.body.emitter.emit("changed");
  };

  // TODO: deprecated since version 1.1.0, remove some day
  Core.prototype.repaint = function () {
    throw new Error('Function repaint is deprecated. Use redraw instead.');
  };

  /**
   * Set a current time. This can be used for example to ensure that a client's
   * time is synchronized with a shared server time.
   * Only applicable when option `showCurrentTime` is true.
   * @param {Date | String | Number} time     A Date, unix timestamp, or
   *                                          ISO date string.
   */
  Core.prototype.setCurrentTime = function (time) {
    if (!this.currentTime) {
      throw new Error('Option showCurrentTime must be true');
    }

    this.currentTime.setCurrentTime(time);
  };

  /**
   * Get the current time.
   * Only applicable when option `showCurrentTime` is true.
   * @return {Date} Returns the current time.
   */
  Core.prototype.getCurrentTime = function () {
    if (!this.currentTime) {
      throw new Error('Option showCurrentTime must be true');
    }

    return this.currentTime.getCurrentTime();
  };

  /**
   * Convert a position on screen (pixels) to a datetime
   * @param {int}     x    Position on the screen in pixels
   * @return {Date}   time The datetime the corresponds with given position x
   * @protected
   */
  // TODO: move this function to Range
  Core.prototype._toTime = function (x) {
    return DateUtil.toTime(this, x, this.props.center.width);
  };

  /**
   * Convert a position on the global screen (pixels) to a datetime
   * @param {int}     x    Position on the screen in pixels
   * @return {Date}   time The datetime the corresponds with given position x
   * @protected
   */
  // TODO: move this function to Range
  Core.prototype._toGlobalTime = function (x) {
    return DateUtil.toTime(this, x, this.props.root.width);
    //var conversion = this.range.conversion(this.props.root.width);
    //return new Date(x / conversion.scale + conversion.offset);
  };

  /**
   * Convert a datetime (Date object) into a position on the screen
   * @param {Date}   time A date
   * @return {int}   x    The position on the screen in pixels which corresponds
   *                      with the given date.
   * @protected
   */
  // TODO: move this function to Range
  Core.prototype._toScreen = function (time) {
    return DateUtil.toScreen(this, time, this.props.center.width);
  };

  /**
   * Convert a datetime (Date object) into a position on the root
   * This is used to get the pixel density estimate for the screen, not the center panel
   * @param {Date}   time A date
   * @return {int}   x    The position on root in pixels which corresponds
   *                      with the given date.
   * @protected
   */
  // TODO: move this function to Range
  Core.prototype._toGlobalScreen = function (time) {
    return DateUtil.toScreen(this, time, this.props.root.width);
    //var conversion = this.range.conversion(this.props.root.width);
    //return (time.valueOf() - conversion.offset) * conversion.scale;
  };

  /**
   * Initialize watching when option autoResize is true
   * @private
   */
  Core.prototype._initAutoResize = function () {
    if (this.options.autoResize == true) {
      this._startAutoResize();
    } else {
      this._stopAutoResize();
    }
  };

  /**
   * Watch for changes in the size of the container. On resize, the Panel will
   * automatically redraw itself.
   * @private
   */
  Core.prototype._startAutoResize = function () {
    var me = this;

    this._stopAutoResize();

    this._onResize = function () {
      if (me.options.autoResize != true) {
        // stop watching when the option autoResize is changed to false
        me._stopAutoResize();
        return;
      }

      if (me.dom.root) {
        // check whether the frame is resized
        // Note: we compare offsetWidth here, not clientWidth. For some reason,
        // IE does not restore the clientWidth from 0 to the actual width after
        // changing the timeline's container display style from none to visible
        if (me.dom.root.offsetWidth != me.props.lastWidth || me.dom.root.offsetHeight != me.props.lastHeight) {
          me.props.lastWidth = me.dom.root.offsetWidth;
          me.props.lastHeight = me.dom.root.offsetHeight;

          me.body.emitter.emit('_change');
        }
      }
    };

    // add event listener to window resize
    util.addEventListener(window, 'resize', this._onResize);

    //Prevent initial unnecessary redraw
    if (me.dom.root) {
      me.props.lastWidth = me.dom.root.offsetWidth;
      me.props.lastHeight = me.dom.root.offsetHeight;
    }

    this.watchTimer = setInterval(this._onResize, 1000);
  };

  /**
   * Stop watching for a resize of the frame.
   * @private
   */
  Core.prototype._stopAutoResize = function () {
    if (this.watchTimer) {
      clearInterval(this.watchTimer);
      this.watchTimer = undefined;
    }

    // remove event listener on window.resize
    if (this._onResize) {
      util.removeEventListener(window, 'resize', this._onResize);
      this._onResize = null;
    }
  };

  /**
   * Start moving the timeline vertically
   * @param {Event} event
   * @private
   */
  Core.prototype._onTouch = function (event) {
    this.touch.allowDragging = true;
    this.touch.initialScrollTop = this.props.scrollTop;
  };

  /**
   * Start moving the timeline vertically
   * @param {Event} event
   * @private
   */
  Core.prototype._onPinch = function (event) {
    this.touch.allowDragging = false;
  };

  /**
   * Move the timeline vertically
   * @param {Event} event
   * @private
   */
  Core.prototype._onDrag = function (event) {
    // refuse to drag when we where pinching to prevent the timeline make a jump
    // when releasing the fingers in opposite order from the touch screen
    if (!this.touch.allowDragging) return;

    var delta = event.deltaY;

    var oldScrollTop = this._getScrollTop();
    var newScrollTop = this._setScrollTop(this.touch.initialScrollTop + delta);

    if (newScrollTop != oldScrollTop) {
      this.emit("verticalDrag");
    }
  };

  /**
   * Apply a scrollTop
   * @param {Number} scrollTop
   * @returns {Number} scrollTop  Returns the applied scrollTop
   * @private
   */
  Core.prototype._setScrollTop = function (scrollTop) {
    this.props.scrollTop = scrollTop;
    this._updateScrollTop();
    return this.props.scrollTop;
  };

  /**
   * Update the current scrollTop when the height of  the containers has been changed
   * @returns {Number} scrollTop  Returns the applied scrollTop
   * @private
   */
  Core.prototype._updateScrollTop = function () {
    // recalculate the scrollTopMin
    var scrollTopMin = Math.min(this.props.centerContainer.height - this.props.center.height, 0); // is negative or zero
    if (scrollTopMin != this.props.scrollTopMin) {
      // in case of bottom orientation, change the scrollTop such that the contents
      // do not move relative to the time axis at the bottom
      if (this.options.orientation.item != 'top') {
        this.props.scrollTop += scrollTopMin - this.props.scrollTopMin;
      }
      this.props.scrollTopMin = scrollTopMin;
    }

    // limit the scrollTop to the feasible scroll range
    if (this.props.scrollTop > 0) this.props.scrollTop = 0;
    if (this.props.scrollTop < scrollTopMin) this.props.scrollTop = scrollTopMin;

    return this.props.scrollTop;
  };

  /**
   * Get the current scrollTop
   * @returns {number} scrollTop
   * @private
   */
  Core.prototype._getScrollTop = function () {
    return this.props.scrollTop;
  };

  /**
   * Load a configurator
   * @return {Object}
   * @private
   */
  Core.prototype._createConfigurator = function () {
    throw new Error('Cannot invoke abstract method _createConfigurator');
  };

  module.exports = Core;

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

  var Hammer = __webpack_require__(20);
  var util = __webpack_require__(1);
  var DataSet = __webpack_require__(9);
  var DataView = __webpack_require__(11);
  var TimeStep = __webpack_require__(35);
  var Component = __webpack_require__(31);
  var Group = __webpack_require__(36);
  var BackgroundGroup = __webpack_require__(40);
  var BoxItem = __webpack_require__(41);
  var PointItem = __webpack_require__(42);
  var RangeItem = __webpack_require__(38);
  var BackgroundItem = __webpack_require__(43);

  var UNGROUPED = '__ungrouped__'; // reserved group id for ungrouped items
  var BACKGROUND = '__background__'; // reserved group id for background items without group

  /**
   * An ItemSet holds a set of items and ranges which can be displayed in a
   * range. The width is determined by the parent of the ItemSet, and the height
   * is determined by the size of the items.
   * @param {{dom: Object, domProps: Object, emitter: Emitter, range: Range}} body
   * @param {Object} [options]      See ItemSet.setOptions for the available options.
   * @constructor ItemSet
   * @extends Component
   */
  function ItemSet(body, options) {
    this.body = body;
    this.defaultOptions = {
      rtl: false,
      type: null, // 'box', 'point', 'range', 'background'
      orientation: {
        item: 'bottom' // item orientation: 'top' or 'bottom'
      },
      align: 'auto', // alignment of box items
      stack: true,
      groupOrderSwap: function groupOrderSwap(fromGroup, toGroup, groups) {
        var targetOrder = toGroup.order;
        toGroup.order = fromGroup.order;
        fromGroup.order = targetOrder;
      },
      groupOrder: 'order',

      selectable: true,
      multiselect: false,
      itemsAlwaysDraggable: false,

      editable: {
        updateTime: false,
        updateGroup: false,
        add: false,
        remove: false
      },

      groupEditable: {
        order: false,
        add: false,
        remove: false
      },

      snap: TimeStep.snap,

      onAdd: function onAdd(item, callback) {
        callback(item);
      },
      onUpdate: function onUpdate(item, callback) {
        callback(item);
      },
      onMove: function onMove(item, callback) {
        callback(item);
      },
      onRemove: function onRemove(item, callback) {
        callback(item);
      },
      onMoving: function onMoving(item, callback) {
        callback(item);
      },
      onAddGroup: function onAddGroup(item, callback) {
        callback(item);
      },
      onMoveGroup: function onMoveGroup(item, callback) {
        callback(item);
      },
      onRemoveGroup: function onRemoveGroup(item, callback) {
        callback(item);
      },

      margin: {
        item: {
          horizontal: 10,
          vertical: 10
        },
        axis: 20
      }
    };

    // options is shared by this ItemSet and all its items
    this.options = util.extend({}, this.defaultOptions);

    // options for getting items from the DataSet with the correct type
    this.itemOptions = {
      type: { start: 'Date', end: 'Date' }
    };

    this.conversion = {
      toScreen: body.util.toScreen,
      toTime: body.util.toTime
    };
    this.dom = {};
    this.props = {};
    this.hammer = null;

    var me = this;
    this.itemsData = null; // DataSet
    this.groupsData = null; // DataSet

    // listeners for the DataSet of the items
    this.itemListeners = {
      'add': function add(event, params, senderId) {
        me._onAdd(params.items);
      },
      'update': function update(event, params, senderId) {
        me._onUpdate(params.items);
      },
      'remove': function remove(event, params, senderId) {
        me._onRemove(params.items);
      }
    };

    // listeners for the DataSet of the groups
    this.groupListeners = {
      'add': function add(event, params, senderId) {
        me._onAddGroups(params.items);
      },
      'update': function update(event, params, senderId) {
        me._onUpdateGroups(params.items);
      },
      'remove': function remove(event, params, senderId) {
        me._onRemoveGroups(params.items);
      }
    };

    this.items = {}; // object with an Item for every data item
    this.groups = {}; // Group object for every group
    this.groupIds = [];

    this.selection = []; // list with the ids of all selected nodes
    this.stackDirty = true; // if true, all items will be restacked on next redraw

    this.touchParams = {}; // stores properties while dragging
    this.groupTouchParams = {};
    // create the HTML DOM

    this._create();

    this.setOptions(options);
  }

  ItemSet.prototype = new Component();

  // available item types will be registered here
  ItemSet.types = {
    background: BackgroundItem,
    box: BoxItem,
    range: RangeItem,
    point: PointItem
  };

  /**
   * Create the HTML DOM for the ItemSet
   */
  ItemSet.prototype._create = function () {
    var frame = document.createElement('div');
    frame.className = 'vis-itemset';
    frame['timeline-itemset'] = this;
    this.dom.frame = frame;

    // create background panel
    var background = document.createElement('div');
    background.className = 'vis-background';
    frame.appendChild(background);
    this.dom.background = background;

    // create foreground panel
    var foreground = document.createElement('div');
    foreground.className = 'vis-foreground';
    frame.appendChild(foreground);
    this.dom.foreground = foreground;

    // create axis panel
    var axis = document.createElement('div');
    axis.className = 'vis-axis';
    this.dom.axis = axis;

    // create labelset
    var labelSet = document.createElement('div');
    labelSet.className = 'vis-labelset';
    this.dom.labelSet = labelSet;

    // create ungrouped Group
    this._updateUngrouped();

    // create background Group
    var backgroundGroup = new BackgroundGroup(BACKGROUND, null, this);
    backgroundGroup.show();
    this.groups[BACKGROUND] = backgroundGroup;

    // attach event listeners
    // Note: we bind to the centerContainer for the case where the height
    //       of the center container is larger than of the ItemSet, so we
    //       can click in the empty area to create a new item or deselect an item.
    this.hammer = new Hammer(this.body.dom.centerContainer);

    // drag items when selected
    this.hammer.on('hammer.input', function (event) {
      if (event.isFirst) {
        this._onTouch(event);
      }
    }.bind(this));
    this.hammer.on('panstart', this._onDragStart.bind(this));
    this.hammer.on('panmove', this._onDrag.bind(this));
    this.hammer.on('panend', this._onDragEnd.bind(this));
    this.hammer.get('pan').set({ threshold: 5, direction: Hammer.DIRECTION_HORIZONTAL });

    // single select (or unselect) when tapping an item
    this.hammer.on('tap', this._onSelectItem.bind(this));

    // multi select when holding mouse/touch, or on ctrl+click
    this.hammer.on('press', this._onMultiSelectItem.bind(this));

    // add item on doubletap
    this.hammer.on('doubletap', this._onAddItem.bind(this));
    this.groupHammer = new Hammer(this.body.dom.leftContainer);

    this.groupHammer.on('panstart', this._onGroupDragStart.bind(this));
    this.groupHammer.on('panmove', this._onGroupDrag.bind(this));
    this.groupHammer.on('panend', this._onGroupDragEnd.bind(this));
    this.groupHammer.get('pan').set({ threshold: 5, direction: Hammer.DIRECTION_HORIZONTAL });

    // attach to the DOM
    this.show();
  };

  /**
   * Set options for the ItemSet. Existing options will be extended/overwritten.
   * @param {Object} [options] The following options are available:
   *                           {String} type
   *                              Default type for the items. Choose from 'box'
   *                              (default), 'point', 'range', or 'background'.
   *                              The default style can be overwritten by
   *                              individual items.
   *                           {String} align
   *                              Alignment for the items, only applicable for
   *                              BoxItem. Choose 'center' (default), 'left', or
   *                              'right'.
   *                           {String} orientation.item
   *                              Orientation of the item set. Choose 'top' or
   *                              'bottom' (default).
   *                           {Function} groupOrder
   *                              A sorting function for ordering groups
   *                           {Boolean} stack
   *                              If true (default), items will be stacked on
   *                              top of each other.
   *                           {Number} margin.axis
   *                              Margin between the axis and the items in pixels.
   *                              Default is 20.
   *                           {Number} margin.item.horizontal
   *                              Horizontal margin between items in pixels.
   *                              Default is 10.
   *                           {Number} margin.item.vertical
   *                              Vertical Margin between items in pixels.
   *                              Default is 10.
   *                           {Number} margin.item
   *                              Margin between items in pixels in both horizontal
   *                              and vertical direction. Default is 10.
   *                           {Number} margin
   *                              Set margin for both axis and items in pixels.
   *                           {Boolean} selectable
   *                              If true (default), items can be selected.
   *                           {Boolean} multiselect
   *                              If true, multiple items can be selected.
   *                              False by default.
   *                           {Boolean} editable
   *                              Set all editable options to true or false
   *                           {Boolean} editable.updateTime
   *                              Allow dragging an item to an other moment in time
   *                           {Boolean} editable.updateGroup
   *                              Allow dragging an item to an other group
   *                           {Boolean} editable.add
   *                              Allow creating new items on double tap
   *                           {Boolean} editable.remove
   *                              Allow removing items by clicking the delete button
   *                              top right of a selected item.
   *                           {Function(item: Item, callback: Function)} onAdd
   *                              Callback function triggered when an item is about to be added:
   *                              when the user double taps an empty space in the Timeline.
   *                           {Function(item: Item, callback: Function)} onUpdate
   *                              Callback function fired when an item is about to be updated.
   *                              This function typically has to show a dialog where the user
   *                              change the item. If not implemented, nothing happens.
   *                           {Function(item: Item, callback: Function)} onMove
   *                              Fired when an item has been moved. If not implemented,
   *                              the move action will be accepted.
   *                           {Function(item: Item, callback: Function)} onRemove
   *                              Fired when an item is about to be deleted.
   *                              If not implemented, the item will be always removed.
   */
  ItemSet.prototype.setOptions = function (options) {
    if (options) {
      // copy all options that we know
      var fields = ['type', 'rtl', 'align', 'order', 'stack', 'selectable', 'multiselect', 'itemsAlwaysDraggable', 'multiselectPerGroup', 'groupOrder', 'dataAttributes', 'template', 'groupTemplate', 'hide', 'snap', 'groupOrderSwap'];
      util.selectiveExtend(fields, this.options, options);

      if ('orientation' in options) {
        if (typeof options.orientation === 'string') {
          this.options.orientation.item = options.orientation === 'top' ? 'top' : 'bottom';
        } else if (_typeof(options.orientation) === 'object' && 'item' in options.orientation) {
          this.options.orientation.item = options.orientation.item;
        }
      }

      if ('margin' in options) {
        if (typeof options.margin === 'number') {
          this.options.margin.axis = options.margin;
          this.options.margin.item.horizontal = options.margin;
          this.options.margin.item.vertical = options.margin;
        } else if (_typeof(options.margin) === 'object') {
          util.selectiveExtend(['axis'], this.options.margin, options.margin);
          if ('item' in options.margin) {
            if (typeof options.margin.item === 'number') {
              this.options.margin.item.horizontal = options.margin.item;
              this.options.margin.item.vertical = options.margin.item;
            } else if (_typeof(options.margin.item) === 'object') {
              util.selectiveExtend(['horizontal', 'vertical'], this.options.margin.item, options.margin.item);
            }
          }
        }
      }

      if ('editable' in options) {
        if (typeof options.editable === 'boolean') {
          this.options.editable.updateTime = options.editable;
          this.options.editable.updateGroup = options.editable;
          this.options.editable.add = options.editable;
          this.options.editable.remove = options.editable;
        } else if (_typeof(options.editable) === 'object') {
          util.selectiveExtend(['updateTime', 'updateGroup', 'add', 'remove'], this.options.editable, options.editable);
        }
      }

      if ('groupEditable' in options) {
        if (typeof options.groupEditable === 'boolean') {
          this.options.groupEditable.order = options.groupEditable;
          this.options.groupEditable.add = options.groupEditable;
          this.options.groupEditable.remove = options.groupEditable;
        } else if (_typeof(options.groupEditable) === 'object') {
          util.selectiveExtend(['order', 'add', 'remove'], this.options.groupEditable, options.groupEditable);
        }
      }

      // callback functions
      var addCallback = function (name) {
        var fn = options[name];
        if (fn) {
          if (!(fn instanceof Function)) {
            throw new Error('option ' + name + ' must be a function ' + name + '(item, callback)');
          }
          this.options[name] = fn;
        }
      }.bind(this);
      ['onAdd', 'onUpdate', 'onRemove', 'onMove', 'onMoving', 'onAddGroup', 'onMoveGroup', 'onRemoveGroup'].forEach(addCallback);

      // force the itemSet to refresh: options like orientation and margins may be changed
      this.markDirty();
    }
  };

  /**
   * Mark the ItemSet dirty so it will refresh everything with next redraw.
   * Optionally, all items can be marked as dirty and be refreshed.
   * @param {{refreshItems: boolean}} [options]
   */
  ItemSet.prototype.markDirty = function (options) {
    this.groupIds = [];
    this.stackDirty = true;

    if (options && options.refreshItems) {
      util.forEach(this.items, function (item) {
        item.dirty = true;
        if (item.displayed) item.redraw();
      });
    }
  };

  /**
   * Destroy the ItemSet
   */
  ItemSet.prototype.destroy = function () {
    this.hide();
    this.setItems(null);
    this.setGroups(null);

    this.hammer = null;

    this.body = null;
    this.conversion = null;
  };

  /**
   * Hide the component from the DOM
   */
  ItemSet.prototype.hide = function () {
    // remove the frame containing the items
    if (this.dom.frame.parentNode) {
      this.dom.frame.parentNode.removeChild(this.dom.frame);
    }

    // remove the axis with dots
    if (this.dom.axis.parentNode) {
      this.dom.axis.parentNode.removeChild(this.dom.axis);
    }

    // remove the labelset containing all group labels
    if (this.dom.labelSet.parentNode) {
      this.dom.labelSet.parentNode.removeChild(this.dom.labelSet);
    }
  };

  /**
   * Show the component in the DOM (when not already visible).
   * @return {Boolean} changed
   */
  ItemSet.prototype.show = function () {
    // show frame containing the items
    if (!this.dom.frame.parentNode) {
      this.body.dom.center.appendChild(this.dom.frame);
    }

    // show axis with dots
    if (!this.dom.axis.parentNode) {
      this.body.dom.backgroundVertical.appendChild(this.dom.axis);
    }

    // show labelset containing labels
    if (!this.dom.labelSet.parentNode) {
      this.body.dom.left.appendChild(this.dom.labelSet);
    }
  };

  /**
   * Set selected items by their id. Replaces the current selection
   * Unknown id's are silently ignored.
   * @param {string[] | string} [ids] An array with zero or more id's of the items to be
   *                                  selected, or a single item id. If ids is undefined
   *                                  or an empty array, all items will be unselected.
   */
  ItemSet.prototype.setSelection = function (ids) {
    var i, ii, id, item;

    if (ids == undefined) ids = [];
    if (!Array.isArray(ids)) ids = [ids];

    // unselect currently selected items
    for (i = 0, ii = this.selection.length; i < ii; i++) {
      id = this.selection[i];
      item = this.items[id];
      if (item) item.unselect();
    }

    // select items
    this.selection = [];
    for (i = 0, ii = ids.length; i < ii; i++) {
      id = ids[i];
      item = this.items[id];
      if (item) {
        this.selection.push(id);
        item.select();
      }
    }
  };

  /**
   * Get the selected items by their id
   * @return {Array} ids  The ids of the selected items
   */
  ItemSet.prototype.getSelection = function () {
    return this.selection.concat([]);
  };

  /**
   * Get the id's of the currently visible items.
   * @returns {Array} The ids of the visible items
   */
  ItemSet.prototype.getVisibleItems = function () {
    var range = this.body.range.getRange();

    if (this.options.rtl) {
      var right = this.body.util.toScreen(range.start);
      var left = this.body.util.toScreen(range.end);
    } else {
      var left = this.body.util.toScreen(range.start);
      var right = this.body.util.toScreen(range.end);
    }

    var ids = [];
    for (var groupId in this.groups) {
      if (this.groups.hasOwnProperty(groupId)) {
        var group = this.groups[groupId];
        var rawVisibleItems = group.visibleItems;

        // filter the "raw" set with visibleItems into a set which is really
        // visible by pixels
        for (var i = 0; i < rawVisibleItems.length; i++) {
          var item = rawVisibleItems[i];
          // TODO: also check whether visible vertically
          if (this.options.rtl) {
            if (item.right < left && item.right + item.width > right) {
              ids.push(item.id);
            }
          } else {
            if (item.left < right && item.left + item.width > left) {
              ids.push(item.id);
            }
          }
        }
      }
    }

    return ids;
  };

  /**
   * Deselect a selected item
   * @param {String | Number} id
   * @private
   */
  ItemSet.prototype._deselect = function (id) {
    var selection = this.selection;
    for (var i = 0, ii = selection.length; i < ii; i++) {
      if (selection[i] == id) {
        // non-strict comparison!
        selection.splice(i, 1);
        break;
      }
    }
  };

  /**
   * Repaint the component
   * @return {boolean} Returns true if the component is resized
   */
  ItemSet.prototype.redraw = function () {
    var margin = this.options.margin,
        range = this.body.range,
        asSize = util.option.asSize,
        options = this.options,
        orientation = options.orientation.item,
        resized = false,
        frame = this.dom.frame;

    // recalculate absolute position (before redrawing groups)
    this.props.top = this.body.domProps.top.height + this.body.domProps.border.top;

    if (this.options.rtl) {
      this.props.right = this.body.domProps.right.width + this.body.domProps.border.right;
    } else {
      this.props.left = this.body.domProps.left.width + this.body.domProps.border.left;
    }

    // update class name
    frame.className = 'vis-itemset';

    // reorder the groups (if needed)
    resized = this._orderGroups() || resized;

    // check whether zoomed (in that case we need to re-stack everything)
    // TODO: would be nicer to get this as a trigger from Range
    var visibleInterval = range.end - range.start;
    var zoomed = visibleInterval != this.lastVisibleInterval || this.props.width != this.props.lastWidth;
    if (zoomed) this.stackDirty = true;
    this.lastVisibleInterval = visibleInterval;
    this.props.lastWidth = this.props.width;

    var restack = this.stackDirty;
    var firstGroup = this._firstGroup();
    var firstMargin = {
      item: margin.item,
      axis: margin.axis
    };
    var nonFirstMargin = {
      item: margin.item,
      axis: margin.item.vertical / 2
    };
    var height = 0;
    var minHeight = margin.axis + margin.item.vertical;

    // redraw the background group
    this.groups[BACKGROUND].redraw(range, nonFirstMargin, restack);

    // redraw all regular groups
    util.forEach(this.groups, function (group) {
      var groupMargin = group == firstGroup ? firstMargin : nonFirstMargin;
      var groupResized = group.redraw(range, groupMargin, restack);
      resized = groupResized || resized;
      height += group.height;
    });
    height = Math.max(height, minHeight);
    this.stackDirty = false;

    // update frame height
    frame.style.height = asSize(height);

    // calculate actual size
    this.props.width = frame.offsetWidth;
    this.props.height = height;

    // reposition axis
    this.dom.axis.style.top = asSize(orientation == 'top' ? this.body.domProps.top.height + this.body.domProps.border.top : this.body.domProps.top.height + this.body.domProps.centerContainer.height);
    if (this.options.rtl) {
      this.dom.axis.style.right = '0';
    } else {
      this.dom.axis.style.left = '0';
    }

    // check if this component is resized
    resized = this._isResized() || resized;

    return resized;
  };

  /**
   * Get the first group, aligned with the axis
   * @return {Group | null} firstGroup
   * @private
   */
  ItemSet.prototype._firstGroup = function () {
    var firstGroupIndex = this.options.orientation.item == 'top' ? 0 : this.groupIds.length - 1;
    var firstGroupId = this.groupIds[firstGroupIndex];
    var firstGroup = this.groups[firstGroupId] || this.groups[UNGROUPED];

    return firstGroup || null;
  };

  /**
   * Create or delete the group holding all ungrouped items. This group is used when
   * there are no groups specified.
   * @protected
   */
  ItemSet.prototype._updateUngrouped = function () {
    var ungrouped = this.groups[UNGROUPED];
    var background = this.groups[BACKGROUND];
    var item, itemId;

    if (this.groupsData) {
      // remove the group holding all ungrouped items
      if (ungrouped) {
        ungrouped.hide();
        delete this.groups[UNGROUPED];

        for (itemId in this.items) {
          if (this.items.hasOwnProperty(itemId)) {
            item = this.items[itemId];
            item.parent && item.parent.remove(item);
            var groupId = this._getGroupId(item.data);
            var group = this.groups[groupId];
            group && group.add(item) || item.hide();
          }
        }
      }
    } else {
      // create a group holding all (unfiltered) items
      if (!ungrouped) {
        var id = null;
        var data = null;
        ungrouped = new Group(id, data, this);
        this.groups[UNGROUPED] = ungrouped;

        for (itemId in this.items) {
          if (this.items.hasOwnProperty(itemId)) {
            item = this.items[itemId];
            ungrouped.add(item);
          }
        }

        ungrouped.show();
      }
    }
  };

  /**
   * Get the element for the labelset
   * @return {HTMLElement} labelSet
   */
  ItemSet.prototype.getLabelSet = function () {
    return this.dom.labelSet;
  };

  /**
   * Set items
   * @param {vis.DataSet | null} items
   */
  ItemSet.prototype.setItems = function (items) {
    var me = this,
        ids,
        oldItemsData = this.itemsData;

    // replace the dataset
    if (!items) {
      this.itemsData = null;
    } else if (items instanceof DataSet || items instanceof DataView) {
      this.itemsData = items;
    } else {
      throw new TypeError('Data must be an instance of DataSet or DataView');
    }

    if (oldItemsData) {
      // unsubscribe from old dataset
      util.forEach(this.itemListeners, function (callback, event) {
        oldItemsData.off(event, callback);
      });

      // remove all drawn items
      ids = oldItemsData.getIds();
      this._onRemove(ids);
    }

    if (this.itemsData) {
      // subscribe to new dataset
      var id = this.id;
      util.forEach(this.itemListeners, function (callback, event) {
        me.itemsData.on(event, callback, id);
      });

      // add all new items
      ids = this.itemsData.getIds();
      this._onAdd(ids);

      // update the group holding all ungrouped items
      this._updateUngrouped();
    }

    this.body.emitter.emit('_change', { queue: true });
  };

  /**
   * Get the current items
   * @returns {vis.DataSet | null}
   */
  ItemSet.prototype.getItems = function () {
    return this.itemsData;
  };

  /**
   * Set groups
   * @param {vis.DataSet} groups
   */
  ItemSet.prototype.setGroups = function (groups) {
    var me = this,
        ids;

    // unsubscribe from current dataset
    if (this.groupsData) {
      util.forEach(this.groupListeners, function (callback, event) {
        me.groupsData.off(event, callback);
      });

      // remove all drawn groups
      ids = this.groupsData.getIds();
      this.groupsData = null;
      this._onRemoveGroups(ids); // note: this will cause a redraw
    }

    // replace the dataset
    if (!groups) {
      this.groupsData = null;
    } else if (groups instanceof DataSet || groups instanceof DataView) {
      this.groupsData = groups;
    } else {
      throw new TypeError('Data must be an instance of DataSet or DataView');
    }

    if (this.groupsData) {
      // subscribe to new dataset
      var id = this.id;
      util.forEach(this.groupListeners, function (callback, event) {
        me.groupsData.on(event, callback, id);
      });

      // draw all ms
      ids = this.groupsData.getIds();
      this._onAddGroups(ids);
    }

    // update the group holding all ungrouped items
    this._updateUngrouped();

    // update the order of all items in each group
    this._order();

    this.body.emitter.emit('_change', { queue: true });
  };

  /**
   * Get the current groups
   * @returns {vis.DataSet | null} groups
   */
  ItemSet.prototype.getGroups = function () {
    return this.groupsData;
  };

  /**
   * Remove an item by its id
   * @param {String | Number} id
   */
  ItemSet.prototype.removeItem = function (id) {
    var item = this.itemsData.get(id),
        dataset = this.itemsData.getDataSet();

    if (item) {
      // confirm deletion
      this.options.onRemove(item, function (item) {
        if (item) {
          // remove by id here, it is possible that an item has no id defined
          // itself, so better not delete by the item itself
          dataset.remove(id);
        }
      });
    }
  };

  /**
   * Get the time of an item based on it's data and options.type
   * @param {Object} itemData
   * @returns {string} Returns the type
   * @private
   */
  ItemSet.prototype._getType = function (itemData) {
    return itemData.type || this.options.type || (itemData.end ? 'range' : 'box');
  };

  /**
   * Get the group id for an item
   * @param {Object} itemData
   * @returns {string} Returns the groupId
   * @private
   */
  ItemSet.prototype._getGroupId = function (itemData) {
    var type = this._getType(itemData);
    if (type == 'background' && itemData.group == undefined) {
      return BACKGROUND;
    } else {
      return this.groupsData ? itemData.group : UNGROUPED;
    }
  };

  /**
   * Handle updated items
   * @param {Number[]} ids
   * @protected
   */
  ItemSet.prototype._onUpdate = function (ids) {
    var me = this;

    ids.forEach(function (id) {
      var itemData = me.itemsData.get(id, me.itemOptions);
      var item = me.items[id];
      var type = me._getType(itemData);

      var constructor = ItemSet.types[type];
      var selected;

      if (item) {
        // update item
        if (!constructor || !(item instanceof constructor)) {
          // item type has changed, delete the item and recreate it
          selected = item.selected; // preserve selection of this item
          me._removeItem(item);
          item = null;
        } else {
          me._updateItem(item, itemData);
        }
      }

      if (!item) {
        // create item
        if (constructor) {
          item = new constructor(itemData, me.conversion, me.options);
          item.id = id; // TODO: not so nice setting id afterwards
          me._addItem(item);
          if (selected) {
            this.selection.push(id);
            item.select();
          }
        } else if (type == 'rangeoverflow') {
          // TODO: deprecated since version 2.1.0 (or 3.0.0?). cleanup some day
          throw new TypeError('Item type "rangeoverflow" is deprecated. Use css styling instead: ' + '.vis-item.vis-range .vis-item-content {overflow: visible;}');
        } else {
          throw new TypeError('Unknown item type "' + type + '"');
        }
      }
    }.bind(this));

    this._order();
    this.stackDirty = true; // force re-stacking of all items next redraw
    this.body.emitter.emit('_change', { queue: true });
  };

  /**
   * Handle added items
   * @param {Number[]} ids
   * @protected
   */
  ItemSet.prototype._onAdd = ItemSet.prototype._onUpdate;

  /**
   * Handle removed items
   * @param {Number[]} ids
   * @protected
   */
  ItemSet.prototype._onRemove = function (ids) {
    var count = 0;
    var me = this;
    ids.forEach(function (id) {
      var item = me.items[id];
      if (item) {
        count++;
        me._removeItem(item);
      }
    });

    if (count) {
      // update order
      this._order();
      this.stackDirty = true; // force re-stacking of all items next redraw
      this.body.emitter.emit('_change', { queue: true });
    }
  };

  /**
   * Update the order of item in all groups
   * @private
   */
  ItemSet.prototype._order = function () {
    // reorder the items in all groups
    // TODO: optimization: only reorder groups affected by the changed items
    util.forEach(this.groups, function (group) {
      group.order();
    });
  };

  /**
   * Handle updated groups
   * @param {Number[]} ids
   * @private
   */
  ItemSet.prototype._onUpdateGroups = function (ids) {
    this._onAddGroups(ids);
  };

  /**
   * Handle changed groups (added or updated)
   * @param {Number[]} ids
   * @private
   */
  ItemSet.prototype._onAddGroups = function (ids) {
    var me = this;

    ids.forEach(function (id) {
      var groupData = me.groupsData.get(id);
      var group = me.groups[id];

      if (!group) {
        // check for reserved ids
        if (id == UNGROUPED || id == BACKGROUND) {
          throw new Error('Illegal group id. ' + id + ' is a reserved id.');
        }

        var groupOptions = Object.create(me.options);
        util.extend(groupOptions, {
          height: null
        });

        group = new Group(id, groupData, me);
        me.groups[id] = group;

        // add items with this groupId to the new group
        for (var itemId in me.items) {
          if (me.items.hasOwnProperty(itemId)) {
            var item = me.items[itemId];
            if (item.data.group == id) {
              group.add(item);
            }
          }
        }

        group.order();
        group.show();
      } else {
        // update group
        group.setData(groupData);
      }
    });

    this.body.emitter.emit('_change', { queue: true });
  };

  /**
   * Handle removed groups
   * @param {Number[]} ids
   * @private
   */
  ItemSet.prototype._onRemoveGroups = function (ids) {
    var groups = this.groups;
    ids.forEach(function (id) {
      var group = groups[id];

      if (group) {
        group.hide();
        delete groups[id];
      }
    });

    this.markDirty();

    this.body.emitter.emit('_change', { queue: true });
  };

  /**
   * Reorder the groups if needed
   * @return {boolean} changed
   * @private
   */
  ItemSet.prototype._orderGroups = function () {
    if (this.groupsData) {
      // reorder the groups
      var groupIds = this.groupsData.getIds({
        order: this.options.groupOrder
      });

      var changed = !util.equalArray(groupIds, this.groupIds);
      if (changed) {
        // hide all groups, removes them from the DOM
        var groups = this.groups;
        groupIds.forEach(function (groupId) {
          groups[groupId].hide();
        });

        // show the groups again, attach them to the DOM in correct order
        groupIds.forEach(function (groupId) {
          groups[groupId].show();
        });

        this.groupIds = groupIds;
      }

      return changed;
    } else {
      return false;
    }
  };

  /**
   * Add a new item
   * @param {Item} item
   * @private
   */
  ItemSet.prototype._addItem = function (item) {
    this.items[item.id] = item;

    // add to group
    var groupId = this._getGroupId(item.data);
    var group = this.groups[groupId];
    if (group) group.add(item);
  };

  /**
   * Update an existing item
   * @param {Item} item
   * @param {Object} itemData
   * @private
   */
  ItemSet.prototype._updateItem = function (item, itemData) {
    var oldGroupId = item.data.group;
    var oldSubGroupId = item.data.subgroup;

    // update the items data (will redraw the item when displayed)
    item.setData(itemData);

    // update group
    if (oldGroupId != item.data.group || oldSubGroupId != item.data.subgroup) {
      var oldGroup = this.groups[oldGroupId];
      if (oldGroup) oldGroup.remove(item);

      var groupId = this._getGroupId(item.data);
      var group = this.groups[groupId];
      if (group) group.add(item);
    }
  };

  /**
   * Delete an item from the ItemSet: remove it from the DOM, from the map
   * with items, and from the map with visible items, and from the selection
   * @param {Item} item
   * @private
   */
  ItemSet.prototype._removeItem = function (item) {
    // remove from DOM
    item.hide();

    // remove from items
    delete this.items[item.id];

    // remove from selection
    var index = this.selection.indexOf(item.id);
    if (index != -1) this.selection.splice(index, 1);

    // remove from group
    item.parent && item.parent.remove(item);
  };

  /**
   * Create an array containing all items being a range (having an end date)
   * @param array
   * @returns {Array}
   * @private
   */
  ItemSet.prototype._constructByEndArray = function (array) {
    var endArray = [];

    for (var i = 0; i < array.length; i++) {
      if (array[i] instanceof RangeItem) {
        endArray.push(array[i]);
      }
    }
    return endArray;
  };

  /**
   * Register the clicked item on touch, before dragStart is initiated.
   *
   * dragStart is initiated from a mousemove event, AFTER the mouse/touch is
   * already moving. Therefore, the mouse/touch can sometimes be above an other
   * DOM element than the item itself.
   *
   * @param {Event} event
   * @private
   */
  ItemSet.prototype._onTouch = function (event) {
    // store the touched item, used in _onDragStart
    this.touchParams.item = this.itemFromTarget(event);
    this.touchParams.dragLeftItem = event.target.dragLeftItem || false;
    this.touchParams.dragRightItem = event.target.dragRightItem || false;
    this.touchParams.itemProps = null;
  };

  /**
   * Given an group id, returns the index it has.
   *
   * @param {Number} groupID
   * @private
   */
  ItemSet.prototype._getGroupIndex = function (groupId) {
    for (var i = 0; i < this.groupIds.length; i++) {
      if (groupId == this.groupIds[i]) return i;
    }
  };

  /**
   * Start dragging the selected events
   * @param {Event} event
   * @private
   */
  ItemSet.prototype._onDragStart = function (event) {
    var item = this.touchParams.item || null;
    var me = this;
    var props;

    if (item && (item.selected || this.options.itemsAlwaysDraggable)) {

      if (!this.options.editable.updateTime && !this.options.editable.updateGroup && !item.editable) {
        return;
      }

      // override options.editable
      if (item.editable === false) {
        return;
      }

      var dragLeftItem = this.touchParams.dragLeftItem;
      var dragRightItem = this.touchParams.dragRightItem;

      if (dragLeftItem) {
        props = {
          item: dragLeftItem,
          initialX: event.center.x,
          dragLeft: true,
          data: this._cloneItemData(item.data)
        };

        this.touchParams.itemProps = [props];
      } else if (dragRightItem) {
        props = {
          item: dragRightItem,
          initialX: event.center.x,
          dragRight: true,
          data: this._cloneItemData(item.data)
        };

        this.touchParams.itemProps = [props];
      } else {
        this.touchParams.selectedItem = item;

        var baseGroupIndex = this._getGroupIndex(item.data.group);

        var itemsToDrag = this.options.itemsAlwaysDraggable && !item.selected ? [item.id] : this.getSelection();

        this.touchParams.itemProps = itemsToDrag.map(function (id) {
          var item = me.items[id];
          var groupIndex = me._getGroupIndex(item.data.group);
          return {
            item: item,
            initialX: event.center.x,
            groupOffset: baseGroupIndex - groupIndex,
            data: this._cloneItemData(item.data)
          };
        }.bind(this));
      }

      event.stopPropagation();
    } else if (this.options.editable.add && (event.srcEvent.ctrlKey || event.srcEvent.metaKey)) {
      // create a new range item when dragging with ctrl key down
      this._onDragStartAddItem(event);
    }
  };

  /**
   * Start creating a new range item by dragging.
   * @param {Event} event
   * @private
   */
  ItemSet.prototype._onDragStartAddItem = function (event) {
    var snap = this.options.snap || null;

    if (this.options.rtl) {
      var xAbs = util.getAbsoluteRight(this.dom.frame);
      var x = xAbs - event.center.x + 10; // plus 10 to compensate for the drag starting as soon as you've moved 10px
    } else {
        var xAbs = util.getAbsoluteLeft(this.dom.frame);
        var x = event.center.x - xAbs - 10; // minus 10 to compensate for the drag starting as soon as you've moved 10px
      }

    var time = this.body.util.toTime(x);
    var scale = this.body.util.getScale();
    var step = this.body.util.getStep();
    var start = snap ? snap(time, scale, step) : time;
    var end = start;

    var itemData = {
      type: 'range',
      start: start,
      end: end,
      content: 'new item'
    };

    var id = util.randomUUID();
    itemData[this.itemsData._fieldId] = id;

    var group = this.groupFromTarget(event);
    if (group) {
      itemData.group = group.groupId;
    }
    var newItem = new RangeItem(itemData, this.conversion, this.options);
    newItem.id = id; // TODO: not so nice setting id afterwards
    newItem.data = this._cloneItemData(itemData);
    this._addItem(newItem);

    var props = {
      item: newItem,
      initialX: event.center.x,
      data: newItem.data
    };

    if (this.options.rtl) {
      props.dragLeft = true;
    } else {
      props.dragRight = true;
    }
    this.touchParams.itemProps = [props];

    event.stopPropagation();
  };

  /**
   * Drag selected items
   * @param {Event} event
   * @private
   */
  ItemSet.prototype._onDrag = function (event) {
    if (this.touchParams.itemProps) {
      event.stopPropagation();

      var me = this;
      var snap = this.options.snap || null;

      if (this.options.rtl) {
        var xOffset = this.body.dom.root.offsetLeft + this.body.domProps.right.width;
      } else {
        var xOffset = this.body.dom.root.offsetLeft + this.body.domProps.left.width;
      }

      var scale = this.body.util.getScale();
      var step = this.body.util.getStep();

      //only calculate the new group for the item that's actually dragged
      var selectedItem = this.touchParams.selectedItem;
      var updateGroupAllowed = me.options.editable.updateGroup;
      var newGroupBase = null;
      if (updateGroupAllowed && selectedItem) {
        if (selectedItem.data.group != undefined) {
          // drag from one group to another
          var group = me.groupFromTarget(event);
          if (group) {
            //we know the offset for all items, so the new group for all items
            //will be relative to this one.
            newGroupBase = this._getGroupIndex(group.groupId);
          }
        }
      }

      // move
      this.touchParams.itemProps.forEach(function (props) {
        var current = me.body.util.toTime(event.center.x - xOffset);
        var initial = me.body.util.toTime(props.initialX - xOffset);

        if (this.options.rtl) {
          var offset = -(current - initial); // ms
        } else {
            var offset = current - initial; // ms
          }

        var itemData = this._cloneItemData(props.item.data); // clone the data
        if (props.item.editable === false) {
          return;
        }

        var updateTimeAllowed = me.options.editable.updateTime || props.item.editable === true;
        if (updateTimeAllowed) {
          if (props.dragLeft) {
            // drag left side of a range item
            if (this.options.rtl) {
              if (itemData.end != undefined) {
                var initialEnd = util.convert(props.data.end, 'Date');
                var end = new Date(initialEnd.valueOf() + offset);
                // TODO: pass a Moment instead of a Date to snap(). (Breaking change)
                itemData.end = snap ? snap(end, scale, step) : end;
              }
            } else {
              if (itemData.start != undefined) {
                var initialStart = util.convert(props.data.start, 'Date');
                var start = new Date(initialStart.valueOf() + offset);
                // TODO: pass a Moment instead of a Date to snap(). (Breaking change)
                itemData.start = snap ? snap(start, scale, step) : start;
              }
            }
          } else if (props.dragRight) {
            // drag right side of a range item
            if (this.options.rtl) {
              if (itemData.start != undefined) {
                var initialStart = util.convert(props.data.start, 'Date');
                var start = new Date(initialStart.valueOf() + offset);
                // TODO: pass a Moment instead of a Date to snap(). (Breaking change)
                itemData.start = snap ? snap(start, scale, step) : start;
              }
            } else {
              if (itemData.end != undefined) {
                var initialEnd = util.convert(props.data.end, 'Date');
                var end = new Date(initialEnd.valueOf() + offset);
                // TODO: pass a Moment instead of a Date to snap(). (Breaking change)
                itemData.end = snap ? snap(end, scale, step) : end;
              }
            }
          } else {
            // drag both start and end
            if (itemData.start != undefined) {

              var initialStart = util.convert(props.data.start, 'Date').valueOf();
              var start = new Date(initialStart + offset);

              if (itemData.end != undefined) {
                var initialEnd = util.convert(props.data.end, 'Date');
                var duration = initialEnd.valueOf() - initialStart.valueOf();

                // TODO: pass a Moment instead of a Date to snap(). (Breaking change)
                itemData.start = snap ? snap(start, scale, step) : start;
                itemData.end = new Date(itemData.start.valueOf() + duration);
              } else {
                // TODO: pass a Moment instead of a Date to snap(). (Breaking change)
                itemData.start = snap ? snap(start, scale, step) : start;
              }
            }
          }
        }

        var updateGroupAllowed = me.options.editable.updateGroup || props.item.editable === true;

        if (updateGroupAllowed && !props.dragLeft && !props.dragRight && newGroupBase != null) {
          if (itemData.group != undefined) {
            var newOffset = newGroupBase - props.groupOffset;

            //make sure we stay in bounds
            newOffset = Math.max(0, newOffset);
            newOffset = Math.min(me.groupIds.length - 1, newOffset);

            itemData.group = me.groupIds[newOffset];
          }
        }

        // confirm moving the item
        itemData = this._cloneItemData(itemData); // convert start and end to the correct type
        me.options.onMoving(itemData, function (itemData) {
          if (itemData) {
            props.item.setData(this._cloneItemData(itemData, 'Date'));
          }
        }.bind(this));
      }.bind(this));

      this.stackDirty = true; // force re-stacking of all items next redraw
      this.body.emitter.emit('_change');
    }
  };

  /**
   * Move an item to another group
   * @param {Item} item
   * @param {String | Number} groupId
   * @private
   */
  ItemSet.prototype._moveToGroup = function (item, groupId) {
    var group = this.groups[groupId];
    if (group && group.groupId != item.data.group) {
      var oldGroup = item.parent;
      oldGroup.remove(item);
      oldGroup.order();
      group.add(item);
      group.order();

      item.data.group = group.groupId;
    }
  };

  /**
   * End of dragging selected items
   * @param {Event} event
   * @private
   */
  ItemSet.prototype._onDragEnd = function (event) {
    if (this.touchParams.itemProps) {
      event.stopPropagation();

      var me = this;
      var dataset = this.itemsData.getDataSet();
      var itemProps = this.touchParams.itemProps;
      this.touchParams.itemProps = null;

      itemProps.forEach(function (props) {
        var id = props.item.id;
        var exists = me.itemsData.get(id, me.itemOptions) != null;

        if (!exists) {
          // add a new item
          me.options.onAdd(props.item.data, function (itemData) {
            me._removeItem(props.item); // remove temporary item
            if (itemData) {
              me.itemsData.getDataSet().add(itemData);
            }

            // force re-stacking of all items next redraw
            me.stackDirty = true;
            me.body.emitter.emit('_change');
          });
        } else {
          // update existing item
          var itemData = this._cloneItemData(props.item.data); // convert start and end to the correct type
          me.options.onMove(itemData, function (itemData) {
            if (itemData) {
              // apply changes
              itemData[dataset._fieldId] = id; // ensure the item contains its id (can be undefined)
              dataset.update(itemData);
            } else {
              // restore original values
              props.item.setData(props.data);

              me.stackDirty = true; // force re-stacking of all items next redraw
              me.body.emitter.emit('_change');
            }
          });
        }
      }.bind(this));
    }
  };

  ItemSet.prototype._onGroupDragStart = function (event) {
    if (this.options.groupEditable.order) {
      this.groupTouchParams.group = this.groupFromTarget(event);

      if (this.groupTouchParams.group) {
        event.stopPropagation();

        this.groupTouchParams.originalOrder = this.groupsData.getIds({
          order: this.options.groupOrder
        });
      }
    }
  };

  ItemSet.prototype._onGroupDrag = function (event) {
    if (this.options.groupEditable.order && this.groupTouchParams.group) {
      event.stopPropagation();

      // drag from one group to another
      var group = this.groupFromTarget(event);

      // try to avoid toggling when groups differ in height
      if (group && group.height != this.groupTouchParams.group.height) {
        var movingUp = group.top < this.groupTouchParams.group.top;
        var clientY = event.center ? event.center.y : event.clientY;
        var targetGroupTop = util.getAbsoluteTop(group.dom.foreground);
        var draggedGroupHeight = this.groupTouchParams.group.height;
        if (movingUp) {
          // skip swapping the groups when the dragged group is not below clientY afterwards
          if (targetGroupTop + draggedGroupHeight < clientY) {
            return;
          }
        } else {
          var targetGroupHeight = group.height;
          // skip swapping the groups when the dragged group is not below clientY afterwards
          if (targetGroupTop + targetGroupHeight - draggedGroupHeight > clientY) {
            return;
          }
        }
      }

      if (group && group != this.groupTouchParams.group) {
        var groupsData = this.groupsData;
        var targetGroup = groupsData.get(group.groupId);
        var draggedGroup = groupsData.get(this.groupTouchParams.group.groupId);

        // switch groups
        if (draggedGroup && targetGroup) {
          this.options.groupOrderSwap(draggedGroup, targetGroup, this.groupsData);
          this.groupsData.update(draggedGroup);
          this.groupsData.update(targetGroup);
        }

        // fetch current order of groups
        var newOrder = this.groupsData.getIds({
          order: this.options.groupOrder
        });

        // in case of changes since _onGroupDragStart
        if (!util.equalArray(newOrder, this.groupTouchParams.originalOrder)) {
          var groupsData = this.groupsData;
          var origOrder = this.groupTouchParams.originalOrder;
          var draggedId = this.groupTouchParams.group.groupId;
          var numGroups = Math.min(origOrder.length, newOrder.length);
          var curPos = 0;
          var newOffset = 0;
          var orgOffset = 0;
          while (curPos < numGroups) {
            // as long as the groups are where they should be step down along the groups order
            while (curPos + newOffset < numGroups && curPos + orgOffset < numGroups && newOrder[curPos + newOffset] == origOrder[curPos + orgOffset]) {
              curPos++;
            }

            // all ok
            if (curPos + newOffset >= numGroups) {
              break;
            }

            // not all ok
            // if dragged group was move upwards everything below should have an offset
            if (newOrder[curPos + newOffset] == draggedId) {
              newOffset = 1;
              continue;
            }
            // if dragged group was move downwards everything above should have an offset
            else if (origOrder[curPos + orgOffset] == draggedId) {
                orgOffset = 1;
                continue;
              }
              // found a group (apart from dragged group) that has the wrong position -> switch with the
              // group at the position where other one should be, fix index arrays and continue
              else {
                  var slippedPosition = newOrder.indexOf(origOrder[curPos + orgOffset]);
                  var switchGroup = groupsData.get(newOrder[curPos + newOffset]);
                  var shouldBeGroup = groupsData.get(origOrder[curPos + orgOffset]);
                  this.options.groupOrderSwap(switchGroup, shouldBeGroup, groupsData);
                  groupsData.update(switchGroup);
                  groupsData.update(shouldBeGroup);

                  var switchGroupId = newOrder[curPos + newOffset];
                  newOrder[curPos + newOffset] = origOrder[curPos + orgOffset];
                  newOrder[slippedPosition] = switchGroupId;

                  curPos++;
                }
          }
        }
      }
    }
  };

  ItemSet.prototype._onGroupDragEnd = function (event) {
    if (this.options.groupEditable.order && this.groupTouchParams.group) {
      event.stopPropagation();

      // update existing group
      var me = this;
      var id = me.groupTouchParams.group.groupId;
      var dataset = me.groupsData.getDataSet();
      var groupData = util.extend({}, dataset.get(id)); // clone the data
      me.options.onMoveGroup(groupData, function (groupData) {
        if (groupData) {
          // apply changes
          groupData[dataset._fieldId] = id; // ensure the group contains its id (can be undefined)
          dataset.update(groupData);
        } else {

          // fetch current order of groups
          var newOrder = dataset.getIds({
            order: me.options.groupOrder
          });

          // restore original order
          if (!util.equalArray(newOrder, me.groupTouchParams.originalOrder)) {
            var origOrder = me.groupTouchParams.originalOrder;
            var numGroups = Math.min(origOrder.length, newOrder.length);
            var curPos = 0;
            while (curPos < numGroups) {
              // as long as the groups are where they should be step down along the groups order
              while (curPos < numGroups && newOrder[curPos] == origOrder[curPos]) {
                curPos++;
              }

              // all ok
              if (curPos >= numGroups) {
                break;
              }

              // found a group that has the wrong position -> switch with the
              // group at the position where other one should be, fix index arrays and continue
              var slippedPosition = newOrder.indexOf(origOrder[curPos]);
              var switchGroup = dataset.get(newOrder[curPos]);
              var shouldBeGroup = dataset.get(origOrder[curPos]);
              me.options.groupOrderSwap(switchGroup, shouldBeGroup, dataset);
              groupsData.update(switchGroup);
              groupsData.update(shouldBeGroup);

              var switchGroupId = newOrder[curPos];
              newOrder[curPos] = origOrder[curPos];
              newOrder[slippedPosition] = switchGroupId;

              curPos++;
            }
          }
        }
      });

      me.body.emitter.emit('groupDragged', { groupId: id });
    }
  };

  /**
   * Handle selecting/deselecting an item when tapping it
   * @param {Event} event
   * @private
   */
  ItemSet.prototype._onSelectItem = function (event) {
    if (!this.options.selectable) return;

    var ctrlKey = event.srcEvent && (event.srcEvent.ctrlKey || event.srcEvent.metaKey);
    var shiftKey = event.srcEvent && event.srcEvent.shiftKey;
    if (ctrlKey || shiftKey) {
      this._onMultiSelectItem(event);
      return;
    }

    var oldSelection = this.getSelection();

    var item = this.itemFromTarget(event);
    var selection = item ? [item.id] : [];
    this.setSelection(selection);

    var newSelection = this.getSelection();

    // emit a select event,
    // except when old selection is empty and new selection is still empty
    if (newSelection.length > 0 || oldSelection.length > 0) {
      this.body.emitter.emit('select', {
        items: newSelection,
        event: event
      });
    }
  };

  /**
   * Handle creation and updates of an item on double tap
   * @param event
   * @private
   */
  ItemSet.prototype._onAddItem = function (event) {
    if (!this.options.selectable) return;
    if (!this.options.editable.add) return;

    var me = this;
    var snap = this.options.snap || null;
    var item = this.itemFromTarget(event);

    if (item) {
      // update item

      // execute async handler to update the item (or cancel it)
      var itemData = me.itemsData.get(item.id); // get a clone of the data from the dataset
      this.options.onUpdate(itemData, function (itemData) {
        if (itemData) {
          me.itemsData.getDataSet().update(itemData);
        }
      });
    } else {
      // add item
      if (this.options.rtl) {
        var xAbs = util.getAbsoluteRight(this.dom.frame);
        var x = xAbs - event.center.x;
      } else {
        var xAbs = util.getAbsoluteLeft(this.dom.frame);
        var x = event.center.x - xAbs;
      }
      // var xAbs = util.getAbsoluteLeft(this.dom.frame);
      // var x = event.center.x - xAbs;
      var start = this.body.util.toTime(x);
      var scale = this.body.util.getScale();
      var step = this.body.util.getStep();

      var newItemData = {
        start: snap ? snap(start, scale, step) : start,
        content: 'new item'
      };

      // when default type is a range, add a default end date to the new item
      if (this.options.type === 'range') {
        var end = this.body.util.toTime(x + this.props.width / 5);
        newItemData.end = snap ? snap(end, scale, step) : end;
      }

      newItemData[this.itemsData._fieldId] = util.randomUUID();

      var group = this.groupFromTarget(event);
      if (group) {
        newItemData.group = group.groupId;
      }

      // execute async handler to customize (or cancel) adding an item
      newItemData = this._cloneItemData(newItemData); // convert start and end to the correct type
      this.options.onAdd(newItemData, function (item) {
        if (item) {
          me.itemsData.getDataSet().add(item);
          // TODO: need to trigger a redraw?
        }
      });
    }
  };

  /**
   * Handle selecting/deselecting multiple items when holding an item
   * @param {Event} event
   * @private
   */
  ItemSet.prototype._onMultiSelectItem = function (event) {
    if (!this.options.selectable) return;

    var item = this.itemFromTarget(event);

    if (item) {
      // multi select items (if allowed)

      var selection = this.options.multiselect ? this.getSelection() // take current selection
      : []; // deselect current selection

      var shiftKey = event.srcEvent && event.srcEvent.shiftKey || false;

      if (shiftKey && this.options.multiselect) {
        // select all items between the old selection and the tapped item
        var itemGroup = this.itemsData.get(item.id).group;

        // when filtering get the group of the last selected item
        var lastSelectedGroup = undefined;
        if (this.options.multiselectPerGroup) {
          if (selection.length > 0) {
            lastSelectedGroup = this.itemsData.get(selection[0]).group;
          }
        }

        // determine the selection range
        if (!this.options.multiselectPerGroup || lastSelectedGroup == undefined || lastSelectedGroup == itemGroup) {
          selection.push(item.id);
        }
        var range = ItemSet._getItemRange(this.itemsData.get(selection, this.itemOptions));

        if (!this.options.multiselectPerGroup || lastSelectedGroup == itemGroup) {
          // select all items within the selection range
          selection = [];
          for (var id in this.items) {
            if (this.items.hasOwnProperty(id)) {
              var _item = this.items[id];
              var start = _item.data.start;
              var end = _item.data.end !== undefined ? _item.data.end : start;

              if (start >= range.min && end <= range.max && (!this.options.multiselectPerGroup || lastSelectedGroup == this.itemsData.get(_item.id).group) && !(_item instanceof BackgroundItem)) {
                selection.push(_item.id); // do not use id but item.id, id itself is stringified
              }
            }
          }
        }
      } else {
          // add/remove this item from the current selection
          var index = selection.indexOf(item.id);
          if (index == -1) {
            // item is not yet selected -> select it
            selection.push(item.id);
          } else {
            // item is already selected -> deselect it
            selection.splice(index, 1);
          }
        }

      this.setSelection(selection);

      this.body.emitter.emit('select', {
        items: this.getSelection(),
        event: event
      });
    }
  };

  /**
   * Calculate the time range of a list of items
   * @param {Array.<Object>} itemsData
   * @return {{min: Date, max: Date}} Returns the range of the provided items
   * @private
   */
  ItemSet._getItemRange = function (itemsData) {
    var max = null;
    var min = null;

    itemsData.forEach(function (data) {
      if (min == null || data.start < min) {
        min = data.start;
      }

      if (data.end != undefined) {
        if (max == null || data.end > max) {
          max = data.end;
        }
      } else {
        if (max == null || data.start > max) {
          max = data.start;
        }
      }
    });

    return {
      min: min,
      max: max
    };
  };

  /**
   * Find an item from an event target:
   * searches for the attribute 'timeline-item' in the event target's element tree
   * @param {Event} event
   * @return {Item | null} item
   */
  ItemSet.prototype.itemFromTarget = function (event) {
    var target = event.target;
    while (target) {
      if (target.hasOwnProperty('timeline-item')) {
        return target['timeline-item'];
      }
      target = target.parentNode;
    }

    return null;
  };

  /**
   * Find the Group from an event target:
   * searches for the attribute 'timeline-group' in the event target's element tree
   * @param {Event} event
   * @return {Group | null} group
   */
  ItemSet.prototype.groupFromTarget = function (event) {
    var clientY = event.center ? event.center.y : event.clientY;
    for (var i = 0; i < this.groupIds.length; i++) {
      var groupId = this.groupIds[i];
      var group = this.groups[groupId];
      var foreground = group.dom.foreground;
      var top = util.getAbsoluteTop(foreground);
      if (clientY > top && clientY < top + foreground.offsetHeight) {
        return group;
      }

      if (this.options.orientation.item === 'top') {
        if (i === this.groupIds.length - 1 && clientY > top) {
          return group;
        }
      } else {
        if (i === 0 && clientY < top + foreground.offset) {
          return group;
        }
      }
    }

    return null;
  };

  /**
   * Find the ItemSet from an event target:
   * searches for the attribute 'timeline-itemset' in the event target's element tree
   * @param {Event} event
   * @return {ItemSet | null} item
   */
  ItemSet.itemSetFromTarget = function (event) {
    var target = event.target;
    while (target) {
      if (target.hasOwnProperty('timeline-itemset')) {
        return target['timeline-itemset'];
      }
      target = target.parentNode;
    }

    return null;
  };

  /**
   * Clone the data of an item, and "normalize" it: convert the start and end date
   * to the type (Date, Moment, ...) configured in the DataSet. If not configured,
   * start and end are converted to Date.
   * @param {Object} itemData, typically `item.data`
   * @param {string} [type]  Optional Date type. If not provided, the type from the DataSet is taken
   * @return {Object} The cloned object
   * @private
   */
  ItemSet.prototype._cloneItemData = function (itemData, type) {
    var clone = util.extend({}, itemData);

    if (!type) {
      // convert start and end date to the type (Date, Moment, ...) configured in the DataSet
      type = this.itemsData.getDataSet()._options.type;
    }

    if (clone.start != undefined) {
      clone.start = util.convert(clone.start, type && type.start || 'Date');
    }
    if (clone.end != undefined) {
      clone.end = util.convert(clone.end, type && type.end || 'Date');
    }

    return clone;
  };

  module.exports = ItemSet;

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var moment = __webpack_require__(2);
  var DateUtil = __webpack_require__(32);
  var util = __webpack_require__(1);

  /**
   * @constructor  TimeStep
   * The class TimeStep is an iterator for dates. You provide a start date and an
   * end date. The class itself determines the best scale (step size) based on the
   * provided start Date, end Date, and minimumStep.
   *
   * If minimumStep is provided, the step size is chosen as close as possible
   * to the minimumStep but larger than minimumStep. If minimumStep is not
   * provided, the scale is set to 1 DAY.
   * The minimumStep should correspond with the onscreen size of about 6 characters
   *
   * Alternatively, you can set a scale by hand.
   * After creation, you can initialize the class by executing first(). Then you
   * can iterate from the start date to the end date via next(). You can check if
   * the end date is reached with the function hasNext(). After each step, you can
   * retrieve the current date via getCurrent().
   * The TimeStep has scales ranging from milliseconds, seconds, minutes, hours,
   * days, to years.
   *
   * Version: 1.2
   *
   * @param {Date} [start]         The start date, for example new Date(2010, 9, 21)
   *                               or new Date(2010, 9, 21, 23, 45, 00)
   * @param {Date} [end]           The end date
   * @param {Number} [minimumStep] Optional. Minimum step size in milliseconds
   */
  function TimeStep(start, end, minimumStep, hiddenDates) {
    this.moment = moment;

    // variables
    this.current = this.moment();
    this._start = this.moment();
    this._end = this.moment();

    this.autoScale = true;
    this.scale = 'day';
    this.step = 1;

    // initialize the range
    this.setRange(start, end, minimumStep);

    // hidden Dates options
    this.switchedDay = false;
    this.switchedMonth = false;
    this.switchedYear = false;
    if (Array.isArray(hiddenDates)) {
      this.hiddenDates = hiddenDates;
    } else if (hiddenDates != undefined) {
      this.hiddenDates = [hiddenDates];
    } else {
      this.hiddenDates = [];
    }

    this.format = TimeStep.FORMAT; // default formatting
  }

  // Time formatting
  TimeStep.FORMAT = {
    minorLabels: {
      millisecond: 'SSS',
      second: 's',
      minute: 'HH:mm',
      hour: 'HH:mm',
      weekday: 'ddd D',
      day: 'D',
      month: 'MMM',
      year: 'YYYY'
    },
    majorLabels: {
      millisecond: 'HH:mm:ss',
      second: 'D MMMM HH:mm',
      minute: 'ddd D MMMM',
      hour: 'ddd D MMMM',
      weekday: 'MMMM YYYY',
      day: 'MMMM YYYY',
      month: 'YYYY',
      year: ''
    }
  };

  /**
   * Set custom constructor function for moment. Can be used to set dates
   * to UTC or to set a utcOffset.
   * @param {function} moment
   */
  TimeStep.prototype.setMoment = function (moment) {
    this.moment = moment;

    // update the date properties, can have a new utcOffset
    this.current = this.moment(this.current);
    this._start = this.moment(this._start);
    this._end = this.moment(this._end);
  };

  /**
   * Set custom formatting for the minor an major labels of the TimeStep.
   * Both `minorLabels` and `majorLabels` are an Object with properties:
   * 'millisecond', 'second', 'minute', 'hour', 'weekday', 'day', 'month', 'year'.
   * @param {{minorLabels: Object, majorLabels: Object}} format
   */
  TimeStep.prototype.setFormat = function (format) {
    var defaultFormat = util.deepExtend({}, TimeStep.FORMAT);
    this.format = util.deepExtend(defaultFormat, format);
  };

  /**
   * Set a new range
   * If minimumStep is provided, the step size is chosen as close as possible
   * to the minimumStep but larger than minimumStep. If minimumStep is not
   * provided, the scale is set to 1 DAY.
   * The minimumStep should correspond with the onscreen size of about 6 characters
   * @param {Date} [start]      The start date and time.
   * @param {Date} [end]        The end date and time.
   * @param {int} [minimumStep] Optional. Minimum step size in milliseconds
   */
  TimeStep.prototype.setRange = function (start, end, minimumStep) {
    if (!(start instanceof Date) || !(end instanceof Date)) {
      throw "No legal start or end date in method setRange";
    }

    this._start = start != undefined ? this.moment(start.valueOf()) : new Date();
    this._end = end != undefined ? this.moment(end.valueOf()) : new Date();

    if (this.autoScale) {
      this.setMinimumStep(minimumStep);
    }
  };

  /**
   * Set the range iterator to the start date.
   */
  TimeStep.prototype.start = function () {
    this.current = this._start.clone();
    this.roundToMinor();
  };

  /**
   * Round the current date to the first minor date value
   * This must be executed once when the current date is set to start Date
   */
  TimeStep.prototype.roundToMinor = function () {
    // round to floor
    // IMPORTANT: we have no breaks in this switch! (this is no bug)
    // noinspection FallThroughInSwitchStatementJS
    switch (this.scale) {
      case 'year':
        this.current.year(this.step * Math.floor(this.current.year() / this.step));
        this.current.month(0);
      case 'month':
        this.current.date(1);
      case 'day': // intentional fall through
      case 'weekday':
        this.current.hours(0);
      case 'hour':
        this.current.minutes(0);
      case 'minute':
        this.current.seconds(0);
      case 'second':
        this.current.milliseconds(0);
      //case 'millisecond': // nothing to do for milliseconds
    }

    if (this.step != 1) {
      // round down to the first minor value that is a multiple of the current step size
      switch (this.scale) {
        case 'millisecond':
          this.current.subtract(this.current.milliseconds() % this.step, 'milliseconds');break;
        case 'second':
          this.current.subtract(this.current.seconds() % this.step, 'seconds');break;
        case 'minute':
          this.current.subtract(this.current.minutes() % this.step, 'minutes');break;
        case 'hour':
          this.current.subtract(this.current.hours() % this.step, 'hours');break;
        case 'weekday': // intentional fall through
        case 'day':
          this.current.subtract((this.current.date() - 1) % this.step, 'day');break;
        case 'month':
          this.current.subtract(this.current.month() % this.step, 'month');break;
        case 'year':
          this.current.subtract(this.current.year() % this.step, 'year');break;
        default:
          break;
      }
    }
  };

  /**
   * Check if the there is a next step
   * @return {boolean}  true if the current date has not passed the end date
   */
  TimeStep.prototype.hasNext = function () {
    return this.current.valueOf() <= this._end.valueOf();
  };

  /**
   * Do the next step
   */
  TimeStep.prototype.next = function () {
    var prev = this.current.valueOf();

    // Two cases, needed to prevent issues with switching daylight savings
    // (end of March and end of October)
    if (this.current.month() < 6) {
      switch (this.scale) {
        case 'millisecond':
          this.current.add(this.step, 'millisecond');break;
        case 'second':
          this.current.add(this.step, 'second');break;
        case 'minute':
          this.current.add(this.step, 'minute');break;
        case 'hour':
          this.current.add(this.step, 'hour');
          // in case of skipping an hour for daylight savings, adjust the hour again (else you get: 0h 5h 9h ... instead of 0h 4h 8h ...)
          // TODO: is this still needed now we use the function of moment.js?
          this.current.subtract(this.current.hours() % this.step, 'hour');
          break;
        case 'weekday': // intentional fall through
        case 'day':
          this.current.add(this.step, 'day');break;
        case 'month':
          this.current.add(this.step, 'month');break;
        case 'year':
          this.current.add(this.step, 'year');break;
        default:
          break;
      }
    } else {
      switch (this.scale) {
        case 'millisecond':
          this.current.add(this.step, 'millisecond');break;
        case 'second':
          this.current.add(this.step, 'second');break;
        case 'minute':
          this.current.add(this.step, 'minute');break;
        case 'hour':
          this.current.add(this.step, 'hour');break;
        case 'weekday': // intentional fall through
        case 'day':
          this.current.add(this.step, 'day');break;
        case 'month':
          this.current.add(this.step, 'month');break;
        case 'year':
          this.current.add(this.step, 'year');break;
        default:
          break;
      }
    }

    if (this.step != 1) {
      // round down to the correct major value
      switch (this.scale) {
        case 'millisecond':
          if (this.current.milliseconds() < this.step) this.current.milliseconds(0);break;
        case 'second':
          if (this.current.seconds() < this.step) this.current.seconds(0);break;
        case 'minute':
          if (this.current.minutes() < this.step) this.current.minutes(0);break;
        case 'hour':
          if (this.current.hours() < this.step) this.current.hours(0);break;
        case 'weekday': // intentional fall through
        case 'day':
          if (this.current.date() < this.step + 1) this.current.date(1);break;
        case 'month':
          if (this.current.month() < this.step) this.current.month(0);break;
        case 'year':
          break; // nothing to do for year
        default:
          break;
      }
    }

    // safety mechanism: if current time is still unchanged, move to the end
    if (this.current.valueOf() == prev) {
      this.current = this._end.clone();
    }

    DateUtil.stepOverHiddenDates(this.moment, this, prev);
  };

  /**
   * Get the current datetime
   * @return {Moment}  current The current date
   */
  TimeStep.prototype.getCurrent = function () {
    return this.current;
  };

  /**
   * Set a custom scale. Autoscaling will be disabled.
   * For example setScale('minute', 5) will result
   * in minor steps of 5 minutes, and major steps of an hour.
   *
   * @param {{scale: string, step: number}} params
   *                               An object containing two properties:
   *                               - A string 'scale'. Choose from 'millisecond', 'second',
   *                                 'minute', 'hour', 'weekday', 'day', 'month', 'year'.
   *                               - A number 'step'. A step size, by default 1.
   *                                 Choose for example 1, 2, 5, or 10.
   */
  TimeStep.prototype.setScale = function (params) {
    if (params && typeof params.scale == 'string') {
      this.scale = params.scale;
      this.step = params.step > 0 ? params.step : 1;
      this.autoScale = false;
    }
  };

  /**
   * Enable or disable autoscaling
   * @param {boolean} enable  If true, autoascaling is set true
   */
  TimeStep.prototype.setAutoScale = function (enable) {
    this.autoScale = enable;
  };

  /**
   * Automatically determine the scale that bests fits the provided minimum step
   * @param {Number} [minimumStep]  The minimum step size in milliseconds
   */
  TimeStep.prototype.setMinimumStep = function (minimumStep) {
    if (minimumStep == undefined) {
      return;
    }

    //var b = asc + ds;

    var stepYear = 1000 * 60 * 60 * 24 * 30 * 12;
    var stepMonth = 1000 * 60 * 60 * 24 * 30;
    var stepDay = 1000 * 60 * 60 * 24;
    var stepHour = 1000 * 60 * 60;
    var stepMinute = 1000 * 60;
    var stepSecond = 1000;
    var stepMillisecond = 1;

    // find the smallest step that is larger than the provided minimumStep
    if (stepYear * 1000 > minimumStep) {
      this.scale = 'year';this.step = 1000;
    }
    if (stepYear * 500 > minimumStep) {
      this.scale = 'year';this.step = 500;
    }
    if (stepYear * 100 > minimumStep) {
      this.scale = 'year';this.step = 100;
    }
    if (stepYear * 50 > minimumStep) {
      this.scale = 'year';this.step = 50;
    }
    if (stepYear * 10 > minimumStep) {
      this.scale = 'year';this.step = 10;
    }
    if (stepYear * 5 > minimumStep) {
      this.scale = 'year';this.step = 5;
    }
    if (stepYear > minimumStep) {
      this.scale = 'year';this.step = 1;
    }
    if (stepMonth * 3 > minimumStep) {
      this.scale = 'month';this.step = 3;
    }
    if (stepMonth > minimumStep) {
      this.scale = 'month';this.step = 1;
    }
    if (stepDay * 5 > minimumStep) {
      this.scale = 'day';this.step = 5;
    }
    if (stepDay * 2 > minimumStep) {
      this.scale = 'day';this.step = 2;
    }
    if (stepDay > minimumStep) {
      this.scale = 'day';this.step = 1;
    }
    if (stepDay / 2 > minimumStep) {
      this.scale = 'weekday';this.step = 1;
    }
    if (stepHour * 4 > minimumStep) {
      this.scale = 'hour';this.step = 4;
    }
    if (stepHour > minimumStep) {
      this.scale = 'hour';this.step = 1;
    }
    if (stepMinute * 15 > minimumStep) {
      this.scale = 'minute';this.step = 15;
    }
    if (stepMinute * 10 > minimumStep) {
      this.scale = 'minute';this.step = 10;
    }
    if (stepMinute * 5 > minimumStep) {
      this.scale = 'minute';this.step = 5;
    }
    if (stepMinute > minimumStep) {
      this.scale = 'minute';this.step = 1;
    }
    if (stepSecond * 15 > minimumStep) {
      this.scale = 'second';this.step = 15;
    }
    if (stepSecond * 10 > minimumStep) {
      this.scale = 'second';this.step = 10;
    }
    if (stepSecond * 5 > minimumStep) {
      this.scale = 'second';this.step = 5;
    }
    if (stepSecond > minimumStep) {
      this.scale = 'second';this.step = 1;
    }
    if (stepMillisecond * 200 > minimumStep) {
      this.scale = 'millisecond';this.step = 200;
    }
    if (stepMillisecond * 100 > minimumStep) {
      this.scale = 'millisecond';this.step = 100;
    }
    if (stepMillisecond * 50 > minimumStep) {
      this.scale = 'millisecond';this.step = 50;
    }
    if (stepMillisecond * 10 > minimumStep) {
      this.scale = 'millisecond';this.step = 10;
    }
    if (stepMillisecond * 5 > minimumStep) {
      this.scale = 'millisecond';this.step = 5;
    }
    if (stepMillisecond > minimumStep) {
      this.scale = 'millisecond';this.step = 1;
    }
  };

  /**
   * Snap a date to a rounded value.
   * The snap intervals are dependent on the current scale and step.
   * Static function
   * @param {Date} date    the date to be snapped.
   * @param {string} scale Current scale, can be 'millisecond', 'second',
   *                       'minute', 'hour', 'weekday, 'day', 'month', 'year'.
   * @param {number} step  Current step (1, 2, 4, 5, ...
   * @return {Date} snappedDate
   */
  TimeStep.snap = function (date, scale, step) {
    var clone = moment(date);

    if (scale == 'year') {
      var year = clone.year() + Math.round(clone.month() / 12);
      clone.year(Math.round(year / step) * step);
      clone.month(0);
      clone.date(0);
      clone.hours(0);
      clone.minutes(0);
      clone.seconds(0);
      clone.milliseconds(0);
    } else if (scale == 'month') {
      if (clone.date() > 15) {
        clone.date(1);
        clone.add(1, 'month');
        // important: first set Date to 1, after that change the month.
      } else {
          clone.date(1);
        }

      clone.hours(0);
      clone.minutes(0);
      clone.seconds(0);
      clone.milliseconds(0);
    } else if (scale == 'day') {
      //noinspection FallthroughInSwitchStatementJS
      switch (step) {
        case 5:
        case 2:
          clone.hours(Math.round(clone.hours() / 24) * 24);break;
        default:
          clone.hours(Math.round(clone.hours() / 12) * 12);break;
      }
      clone.minutes(0);
      clone.seconds(0);
      clone.milliseconds(0);
    } else if (scale == 'weekday') {
      //noinspection FallthroughInSwitchStatementJS
      switch (step) {
        case 5:
        case 2:
          clone.hours(Math.round(clone.hours() / 12) * 12);break;
        default:
          clone.hours(Math.round(clone.hours() / 6) * 6);break;
      }
      clone.minutes(0);
      clone.seconds(0);
      clone.milliseconds(0);
    } else if (scale == 'hour') {
      switch (step) {
        case 4:
          clone.minutes(Math.round(clone.minutes() / 60) * 60);break;
        default:
          clone.minutes(Math.round(clone.minutes() / 30) * 30);break;
      }
      clone.seconds(0);
      clone.milliseconds(0);
    } else if (scale == 'minute') {
      //noinspection FallthroughInSwitchStatementJS
      switch (step) {
        case 15:
        case 10:
          clone.minutes(Math.round(clone.minutes() / 5) * 5);
          clone.seconds(0);
          break;
        case 5:
          clone.seconds(Math.round(clone.seconds() / 60) * 60);break;
        default:
          clone.seconds(Math.round(clone.seconds() / 30) * 30);break;
      }
      clone.milliseconds(0);
    } else if (scale == 'second') {
      //noinspection FallthroughInSwitchStatementJS
      switch (step) {
        case 15:
        case 10:
          clone.seconds(Math.round(clone.seconds() / 5) * 5);
          clone.milliseconds(0);
          break;
        case 5:
          clone.milliseconds(Math.round(clone.milliseconds() / 1000) * 1000);break;
        default:
          clone.milliseconds(Math.round(clone.milliseconds() / 500) * 500);break;
      }
    } else if (scale == 'millisecond') {
      var _step = step > 5 ? step / 2 : 1;
      clone.milliseconds(Math.round(clone.milliseconds() / _step) * _step);
    }

    return clone;
  };

  /**
   * Check if the current value is a major value (for example when the step
   * is DAY, a major value is each first day of the MONTH)
   * @return {boolean} true if current date is major, else false.
   */
  TimeStep.prototype.isMajor = function () {
    if (this.switchedYear == true) {
      this.switchedYear = false;
      switch (this.scale) {
        case 'year':
        case 'month':
        case 'weekday':
        case 'day':
        case 'hour':
        case 'minute':
        case 'second':
        case 'millisecond':
          return true;
        default:
          return false;
      }
    } else if (this.switchedMonth == true) {
      this.switchedMonth = false;
      switch (this.scale) {
        case 'weekday':
        case 'day':
        case 'hour':
        case 'minute':
        case 'second':
        case 'millisecond':
          return true;
        default:
          return false;
      }
    } else if (this.switchedDay == true) {
      this.switchedDay = false;
      switch (this.scale) {
        case 'millisecond':
        case 'second':
        case 'minute':
        case 'hour':
          return true;
        default:
          return false;
      }
    }

    var date = this.moment(this.current);
    switch (this.scale) {
      case 'millisecond':
        return date.milliseconds() == 0;
      case 'second':
        return date.seconds() == 0;
      case 'minute':
        return date.hours() == 0 && date.minutes() == 0;
      case 'hour':
        return date.hours() == 0;
      case 'weekday': // intentional fall through
      case 'day':
        return date.date() == 1;
      case 'month':
        return date.month() == 0;
      case 'year':
        return false;
      default:
        return false;
    }
  };

  /**
   * Returns formatted text for the minor axislabel, depending on the current
   * date and the scale. For example when scale is MINUTE, the current time is
   * formatted as "hh:mm".
   * @param {Date} [date] custom date. if not provided, current date is taken
   */
  TimeStep.prototype.getLabelMinor = function (date) {
    if (date == undefined) {
      date = this.current;
    }

    var format = this.format.minorLabels[this.scale];
    return format && format.length > 0 ? this.moment(date).format(format) : '';
  };

  /**
   * Returns formatted text for the major axis label, depending on the current
   * date and the scale. For example when scale is MINUTE, the major scale is
   * hours, and the hour will be formatted as "hh".
   * @param {Date} [date] custom date. if not provided, current date is taken
   */
  TimeStep.prototype.getLabelMajor = function (date) {
    if (date == undefined) {
      date = this.current;
    }

    var format = this.format.majorLabels[this.scale];
    return format && format.length > 0 ? this.moment(date).format(format) : '';
  };

  TimeStep.prototype.getClassName = function () {
    var _moment = this.moment;
    var m = this.moment(this.current);
    var current = m.locale ? m.locale('en') : m.lang('en'); // old versions of moment have .lang() function
    var step = this.step;

    function even(value) {
      return value / step % 2 == 0 ? ' vis-even' : ' vis-odd';
    }

    function today(date) {
      if (date.isSame(new Date(), 'day')) {
        return ' vis-today';
      }
      if (date.isSame(_moment().add(1, 'day'), 'day')) {
        return ' vis-tomorrow';
      }
      if (date.isSame(_moment().add(-1, 'day'), 'day')) {
        return ' vis-yesterday';
      }
      return '';
    }

    function currentWeek(date) {
      return date.isSame(new Date(), 'week') ? ' vis-current-week' : '';
    }

    function currentMonth(date) {
      return date.isSame(new Date(), 'month') ? ' vis-current-month' : '';
    }

    function currentYear(date) {
      return date.isSame(new Date(), 'year') ? ' vis-current-year' : '';
    }

    switch (this.scale) {
      case 'millisecond':
        return even(current.milliseconds()).trim();

      case 'second':
        return even(current.seconds()).trim();

      case 'minute':
        return even(current.minutes()).trim();

      case 'hour':
        var hours = current.hours();
        if (this.step == 4) {
          hours = hours + '-h' + (hours + 4);
        }
        return 'vis-h' + hours + today(current) + even(current.hours());

      case 'weekday':
        return 'vis-' + current.format('dddd').toLowerCase() + today(current) + currentWeek(current) + even(current.date());

      case 'day':
        var day = current.date();
        var month = current.format('MMMM').toLowerCase();
        return 'vis-day' + day + ' vis-' + month + currentMonth(current) + even(day - 1);

      case 'month':
        return 'vis-' + current.format('MMMM').toLowerCase() + currentMonth(current) + even(current.month());

      case 'year':
        var year = current.year();
        return 'vis-year' + year + currentYear(current) + even(year);

      default:
        return '';
    }
  };

  module.exports = TimeStep;

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var util = __webpack_require__(1);
  var stack = __webpack_require__(37);
  var RangeItem = __webpack_require__(38);

  /**
   * @constructor Group
   * @param {Number | String} groupId
   * @param {Object} data
   * @param {ItemSet} itemSet
   */
  function Group(groupId, data, itemSet) {
    this.groupId = groupId;
    this.subgroups = {};
    this.subgroupIndex = 0;
    this.subgroupOrderer = data && data.subgroupOrder;
    this.itemSet = itemSet;

    this.dom = {};
    this.props = {
      label: {
        width: 0,
        height: 0
      }
    };
    this.className = null;

    this.items = {}; // items filtered by groupId of this group
    this.visibleItems = []; // items currently visible in window
    this.orderedItems = {
      byStart: [],
      byEnd: []
    };
    this.checkRangedItems = false; // needed to refresh the ranged items if the window is programatically changed with NO overlap.
    var me = this;
    this.itemSet.body.emitter.on("checkRangedItems", function () {
      me.checkRangedItems = true;
    });

    this._create();

    this.setData(data);
  }

  /**
   * Create DOM elements for the group
   * @private
   */
  Group.prototype._create = function () {
    var label = document.createElement('div');
    if (this.itemSet.options.groupEditable.order) {
      label.className = 'vis-label draggable';
    } else {
      label.className = 'vis-label';
    }
    this.dom.label = label;

    var inner = document.createElement('div');
    inner.className = 'vis-inner';
    label.appendChild(inner);
    this.dom.inner = inner;

    var foreground = document.createElement('div');
    foreground.className = 'vis-group';
    foreground['timeline-group'] = this;
    this.dom.foreground = foreground;

    this.dom.background = document.createElement('div');
    this.dom.background.className = 'vis-group';

    this.dom.axis = document.createElement('div');
    this.dom.axis.className = 'vis-group';

    // create a hidden marker to detect when the Timelines container is attached
    // to the DOM, or the style of a parent of the Timeline is changed from
    // display:none is changed to visible.
    this.dom.marker = document.createElement('div');
    this.dom.marker.style.visibility = 'hidden';
    this.dom.marker.innerHTML = '?';
    this.dom.background.appendChild(this.dom.marker);
  };

  /**
   * Set the group data for this group
   * @param {Object} data   Group data, can contain properties content and className
   */
  Group.prototype.setData = function (data) {
    // update contents
    var content;
    if (this.itemSet.options && this.itemSet.options.groupTemplate) {
      content = this.itemSet.options.groupTemplate(data);
    } else {
      content = data && data.content;
    }

    if (content instanceof Element) {
      this.dom.inner.appendChild(content);
      while (this.dom.inner.firstChild) {
        this.dom.inner.removeChild(this.dom.inner.firstChild);
      }
      this.dom.inner.appendChild(content);
    } else if (content !== undefined && content !== null) {
      this.dom.inner.innerHTML = content;
    } else {
      this.dom.inner.innerHTML = this.groupId || ''; // groupId can be null
    }

    // update title
    this.dom.label.title = data && data.title || '';

    if (!this.dom.inner.firstChild) {
      util.addClassName(this.dom.inner, 'vis-hidden');
    } else {
      util.removeClassName(this.dom.inner, 'vis-hidden');
    }

    // update className
    var className = data && data.className || null;
    if (className != this.className) {
      if (this.className) {
        util.removeClassName(this.dom.label, this.className);
        util.removeClassName(this.dom.foreground, this.className);
        util.removeClassName(this.dom.background, this.className);
        util.removeClassName(this.dom.axis, this.className);
      }
      util.addClassName(this.dom.label, className);
      util.addClassName(this.dom.foreground, className);
      util.addClassName(this.dom.background, className);
      util.addClassName(this.dom.axis, className);
      this.className = className;
    }

    // update style
    if (this.style) {
      util.removeCssText(this.dom.label, this.style);
      this.style = null;
    }
    if (data && data.style) {
      util.addCssText(this.dom.label, data.style);
      this.style = data.style;
    }
  };

  /**
   * Get the width of the group label
   * @return {number} width
   */
  Group.prototype.getLabelWidth = function () {
    return this.props.label.width;
  };

  /**
   * Repaint this group
   * @param {{start: number, end: number}} range
   * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
   * @param {boolean} [restack=false]  Force restacking of all items
   * @return {boolean} Returns true if the group is resized
   */
  Group.prototype.redraw = function (range, margin, restack) {
    var resized = false;

    // force recalculation of the height of the items when the marker height changed
    // (due to the Timeline being attached to the DOM or changed from display:none to visible)
    var markerHeight = this.dom.marker.clientHeight;
    if (markerHeight != this.lastMarkerHeight) {
      this.lastMarkerHeight = markerHeight;

      util.forEach(this.items, function (item) {
        item.dirty = true;
        if (item.displayed) item.redraw();
      });

      restack = true;
    }

    // recalculate the height of the subgroups
    this._calculateSubGroupHeights();

    // reposition visible items vertically
    if (typeof this.itemSet.options.order === 'function') {
      // a custom order function

      if (restack) {
        // brute force restack of all items

        // show all items
        var me = this;
        var limitSize = false;
        util.forEach(this.items, function (item) {
          if (!item.displayed) {
            item.redraw();
            me.visibleItems.push(item);
          }
          item.repositionX(limitSize);
        });

        // order all items and force a restacking
        var customOrderedItems = this.orderedItems.byStart.slice().sort(function (a, b) {
          return me.itemSet.options.order(a.data, b.data);
        });
        stack.stack(customOrderedItems, margin, true /* restack=true */);
      }

      this.visibleItems = this._updateVisibleItems(this.orderedItems, this.visibleItems, range);
    } else {
      // no custom order function, lazy stacking

      this.visibleItems = this._updateVisibleItems(this.orderedItems, this.visibleItems, range);
      if (this.itemSet.options.stack) {
        // TODO: ugly way to access options...
        stack.stack(this.visibleItems, margin, restack);
      } else {
        // no stacking
        stack.nostack(this.visibleItems, margin, this.subgroups);
      }
    }

    // recalculate the height of the group
    var height = this._calculateHeight(margin);

    // calculate actual size and position
    var foreground = this.dom.foreground;
    this.top = foreground.offsetTop;
    this.right = foreground.offsetLeft;
    this.width = foreground.offsetWidth;
    resized = util.updateProperty(this, 'height', height) || resized;
    // recalculate size of label
    resized = util.updateProperty(this.props.label, 'width', this.dom.inner.clientWidth) || resized;
    resized = util.updateProperty(this.props.label, 'height', this.dom.inner.clientHeight) || resized;

    // apply new height
    this.dom.background.style.height = height + 'px';
    this.dom.foreground.style.height = height + 'px';
    this.dom.label.style.height = height + 'px';

    // update vertical position of items after they are re-stacked and the height of the group is calculated
    for (var i = 0, ii = this.visibleItems.length; i < ii; i++) {
      var item = this.visibleItems[i];
      item.repositionY(margin);
    }

    return resized;
  };

  /**
   * recalculate the height of the subgroups
   * @private
   */
  Group.prototype._calculateSubGroupHeights = function () {
    if (Object.keys(this.subgroups).length > 0) {
      var me = this;

      this.resetSubgroups();

      util.forEach(this.visibleItems, function (item) {
        if (item.data.subgroup !== undefined) {
          me.subgroups[item.data.subgroup].height = Math.max(me.subgroups[item.data.subgroup].height, item.height);
          me.subgroups[item.data.subgroup].visible = true;
        }
      });
    }
  };

  /**
   * recalculate the height of the group
   * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
   * @returns {number} Returns the height
   * @private
   */
  Group.prototype._calculateHeight = function (margin) {
    // recalculate the height of the group
    var height;
    var visibleItems = this.visibleItems;
    if (visibleItems.length > 0) {
      var min = visibleItems[0].top;
      var max = visibleItems[0].top + visibleItems[0].height;
      util.forEach(visibleItems, function (item) {
        min = Math.min(min, item.top);
        max = Math.max(max, item.top + item.height);
      });
      if (min > margin.axis) {
        // there is an empty gap between the lowest item and the axis
        var offset = min - margin.axis;
        max -= offset;
        util.forEach(visibleItems, function (item) {
          item.top -= offset;
        });
      }
      height = max + margin.item.vertical / 2;
    } else {
      height = 0;
    }
    height = Math.max(height, this.props.label.height);

    return height;
  };

  /**
   * Show this group: attach to the DOM
   */
  Group.prototype.show = function () {
    if (!this.dom.label.parentNode) {
      this.itemSet.dom.labelSet.appendChild(this.dom.label);
    }

    if (!this.dom.foreground.parentNode) {
      this.itemSet.dom.foreground.appendChild(this.dom.foreground);
    }

    if (!this.dom.background.parentNode) {
      this.itemSet.dom.background.appendChild(this.dom.background);
    }

    if (!this.dom.axis.parentNode) {
      this.itemSet.dom.axis.appendChild(this.dom.axis);
    }
  };

  /**
   * Hide this group: remove from the DOM
   */
  Group.prototype.hide = function () {
    var label = this.dom.label;
    if (label.parentNode) {
      label.parentNode.removeChild(label);
    }

    var foreground = this.dom.foreground;
    if (foreground.parentNode) {
      foreground.parentNode.removeChild(foreground);
    }

    var background = this.dom.background;
    if (background.parentNode) {
      background.parentNode.removeChild(background);
    }

    var axis = this.dom.axis;
    if (axis.parentNode) {
      axis.parentNode.removeChild(axis);
    }
  };

  /**
   * Add an item to the group
   * @param {Item} item
   */
  Group.prototype.add = function (item) {
    this.items[item.id] = item;
    item.setParent(this);

    // add to
    if (item.data.subgroup !== undefined) {
      if (this.subgroups[item.data.subgroup] === undefined) {
        this.subgroups[item.data.subgroup] = { height: 0, visible: false, index: this.subgroupIndex, items: [] };
        this.subgroupIndex++;
      }
      this.subgroups[item.data.subgroup].items.push(item);
    }
    this.orderSubgroups();

    if (this.visibleItems.indexOf(item) == -1) {
      var range = this.itemSet.body.range; // TODO: not nice accessing the range like this
      this._checkIfVisible(item, this.visibleItems, range);
    }
  };

  Group.prototype.orderSubgroups = function () {
    if (this.subgroupOrderer !== undefined) {
      var sortArray = [];
      if (typeof this.subgroupOrderer == 'string') {
        for (var subgroup in this.subgroups) {
          sortArray.push({ subgroup: subgroup, sortField: this.subgroups[subgroup].items[0].data[this.subgroupOrderer] });
        }
        sortArray.sort(function (a, b) {
          return a.sortField - b.sortField;
        });
      } else if (typeof this.subgroupOrderer == 'function') {
        for (var subgroup in this.subgroups) {
          sortArray.push(this.subgroups[subgroup].items[0].data);
        }
        sortArray.sort(this.subgroupOrderer);
      }

      if (sortArray.length > 0) {
        for (var i = 0; i < sortArray.length; i++) {
          this.subgroups[sortArray[i].subgroup].index = i;
        }
      }
    }
  };

  Group.prototype.resetSubgroups = function () {
    for (var subgroup in this.subgroups) {
      if (this.subgroups.hasOwnProperty(subgroup)) {
        this.subgroups[subgroup].visible = false;
      }
    }
  };

  /**
   * Remove an item from the group
   * @param {Item} item
   */
  Group.prototype.remove = function (item) {
    delete this.items[item.id];
    item.setParent(null);

    // remove from visible items
    var index = this.visibleItems.indexOf(item);
    if (index != -1) this.visibleItems.splice(index, 1);

    if (item.data.subgroup !== undefined) {
      var subgroup = this.subgroups[item.data.subgroup];
      if (subgroup) {
        var itemIndex = subgroup.items.indexOf(item);
        subgroup.items.splice(itemIndex, 1);
        if (!subgroup.items.length) {
          delete this.subgroups[item.data.subgroup];
          this.subgroupIndex--;
        }
        this.orderSubgroups();
      }
    }
  };

  /**
   * Remove an item from the corresponding DataSet
   * @param {Item} item
   */
  Group.prototype.removeFromDataSet = function (item) {
    this.itemSet.removeItem(item.id);
  };

  /**
   * Reorder the items
   */
  Group.prototype.order = function () {
    var array = util.toArray(this.items);
    var startArray = [];
    var endArray = [];

    for (var i = 0; i < array.length; i++) {
      if (array[i].data.end !== undefined) {
        endArray.push(array[i]);
      }
      startArray.push(array[i]);
    }
    this.orderedItems = {
      byStart: startArray,
      byEnd: endArray
    };

    stack.orderByStart(this.orderedItems.byStart);
    stack.orderByEnd(this.orderedItems.byEnd);
  };

  /**
   * Update the visible items
   * @param {{byStart: Item[], byEnd: Item[]}} orderedItems   All items ordered by start date and by end date
   * @param {Item[]} visibleItems                             The previously visible items.
   * @param {{start: number, end: number}} range              Visible range
   * @return {Item[]} visibleItems                            The new visible items.
   * @private
   */
  Group.prototype._updateVisibleItems = function (orderedItems, oldVisibleItems, range) {
    var visibleItems = [];
    var visibleItemsLookup = {}; // we keep this to quickly look up if an item already exists in the list without using indexOf on visibleItems
    var interval = (range.end - range.start) / 4;
    var lowerBound = range.start - interval;
    var upperBound = range.end + interval;
    var item, i;

    // this function is used to do the binary search.
    var searchFunction = function searchFunction(value) {
      if (value < lowerBound) {
        return -1;
      } else if (value <= upperBound) {
        return 0;
      } else {
        return 1;
      }
    };

    // first check if the items that were in view previously are still in view.
    // IMPORTANT: this handles the case for the items with startdate before the window and enddate after the window!
    // also cleans up invisible items.
    if (oldVisibleItems.length > 0) {
      for (i = 0; i < oldVisibleItems.length; i++) {
        this._checkIfVisibleWithReference(oldVisibleItems[i], visibleItems, visibleItemsLookup, range);
      }
    }

    // we do a binary search for the items that have only start values.
    var initialPosByStart = util.binarySearchCustom(orderedItems.byStart, searchFunction, 'data', 'start');

    // trace the visible items from the inital start pos both ways until an invisible item is found, we only look at the start values.
    this._traceVisible(initialPosByStart, orderedItems.byStart, visibleItems, visibleItemsLookup, function (item) {
      return item.data.start < lowerBound || item.data.start > upperBound;
    });

    // if the window has changed programmatically without overlapping the old window, the ranged items with start < lowerBound and end > upperbound are not shown.
    // We therefore have to brute force check all items in the byEnd list
    if (this.checkRangedItems == true) {
      this.checkRangedItems = false;
      for (i = 0; i < orderedItems.byEnd.length; i++) {
        this._checkIfVisibleWithReference(orderedItems.byEnd[i], visibleItems, visibleItemsLookup, range);
      }
    } else {
      // we do a binary search for the items that have defined end times.
      var initialPosByEnd = util.binarySearchCustom(orderedItems.byEnd, searchFunction, 'data', 'end');

      // trace the visible items from the inital start pos both ways until an invisible item is found, we only look at the end values.
      this._traceVisible(initialPosByEnd, orderedItems.byEnd, visibleItems, visibleItemsLookup, function (item) {
        return item.data.end < lowerBound || item.data.end > upperBound;
      });
    }

    // finally, we reposition all the visible items.
    for (i = 0; i < visibleItems.length; i++) {
      item = visibleItems[i];
      if (!item.displayed) item.show();
      // reposition item horizontally
      item.repositionX();
    }

    // debug
    //console.log("new line")
    //if (this.groupId == null) {
    //  for (i = 0; i < orderedItems.byStart.length; i++) {
    //    item = orderedItems.byStart[i].data;
    //    console.log('start',i,initialPosByStart, item.start.valueOf(), item.content, item.start >= lowerBound && item.start <= upperBound,i == initialPosByStart ? "<------------------- HEREEEE" : "")
    //  }
    //  for (i = 0; i < orderedItems.byEnd.length; i++) {
    //    item = orderedItems.byEnd[i].data;
    //    console.log('rangeEnd',i,initialPosByEnd, item.end.valueOf(), item.content, item.end >= range.start && item.end <= range.end,i == initialPosByEnd ? "<------------------- HEREEEE" : "")
    //  }
    //}

    return visibleItems;
  };

  Group.prototype._traceVisible = function (initialPos, items, visibleItems, visibleItemsLookup, breakCondition) {
    var item;
    var i;

    if (initialPos != -1) {
      for (i = initialPos; i >= 0; i--) {
        item = items[i];
        if (breakCondition(item)) {
          break;
        } else {
          if (visibleItemsLookup[item.id] === undefined) {
            visibleItemsLookup[item.id] = true;
            visibleItems.push(item);
          }
        }
      }

      for (i = initialPos + 1; i < items.length; i++) {
        item = items[i];
        if (breakCondition(item)) {
          break;
        } else {
          if (visibleItemsLookup[item.id] === undefined) {
            visibleItemsLookup[item.id] = true;
            visibleItems.push(item);
          }
        }
      }
    }
  };

  /**
   * this function is very similar to the _checkIfInvisible() but it does not
   * return booleans, hides the item if it should not be seen and always adds to
   * the visibleItems.
   * this one is for brute forcing and hiding.
   *
   * @param {Item} item
   * @param {Array} visibleItems
   * @param {{start:number, end:number}} range
   * @private
   */
  Group.prototype._checkIfVisible = function (item, visibleItems, range) {
    if (item.isVisible(range)) {
      if (!item.displayed) item.show();
      // reposition item horizontally
      item.repositionX();
      visibleItems.push(item);
    } else {
      if (item.displayed) item.hide();
    }
  };

  /**
   * this function is very similar to the _checkIfInvisible() but it does not
   * return booleans, hides the item if it should not be seen and always adds to
   * the visibleItems.
   * this one is for brute forcing and hiding.
   *
   * @param {Item} item
   * @param {Array} visibleItems
   * @param {{start:number, end:number}} range
   * @private
   */
  Group.prototype._checkIfVisibleWithReference = function (item, visibleItems, visibleItemsLookup, range) {
    if (item.isVisible(range)) {
      if (visibleItemsLookup[item.id] === undefined) {
        visibleItemsLookup[item.id] = true;
        visibleItems.push(item);
      }
    } else {
      if (item.displayed) item.hide();
    }
  };

  module.exports = Group;

/***/ },
/* 37 */
/***/ function(module, exports) {

  'use strict';

  // Utility functions for ordering and stacking of items
  var EPSILON = 0.001; // used when checking collisions, to prevent round-off errors

  /**
   * Order items by their start data
   * @param {Item[]} items
   */
  exports.orderByStart = function (items) {
    items.sort(function (a, b) {
      return a.data.start - b.data.start;
    });
  };

  /**
   * Order items by their end date. If they have no end date, their start date
   * is used.
   * @param {Item[]} items
   */
  exports.orderByEnd = function (items) {
    items.sort(function (a, b) {
      var aTime = 'end' in a.data ? a.data.end : a.data.start,
          bTime = 'end' in b.data ? b.data.end : b.data.start;

      return aTime - bTime;
    });
  };

  /**
   * Adjust vertical positions of the items such that they don't overlap each
   * other.
   * @param {Item[]} items
   *            All visible items
   * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
   *            Margins between items and between items and the axis.
   * @param {boolean} [force=false]
   *            If true, all items will be repositioned. If false (default), only
   *            items having a top===null will be re-stacked
   */
  exports.stack = function (items, margin, force) {
    var i, iMax;
    if (force) {
      // reset top position of all items
      for (i = 0, iMax = items.length; i < iMax; i++) {
        items[i].top = null;
      }
    }

    // calculate new, non-overlapping positions
    for (i = 0, iMax = items.length; i < iMax; i++) {
      var item = items[i];
      if (item.stack && item.top === null) {
        // initialize top position
        item.top = margin.axis;

        do {
          // TODO: optimize checking for overlap. when there is a gap without items,
          //       you only need to check for items from the next item on, not from zero
          var collidingItem = null;
          for (var j = 0, jj = items.length; j < jj; j++) {
            var other = items[j];
            if (other.top !== null && other !== item && other.stack && exports.collision(item, other, margin.item, other.options.rtl)) {
              collidingItem = other;
              break;
            }
          }

          if (collidingItem != null) {
            // There is a collision. Reposition the items above the colliding element
            item.top = collidingItem.top + collidingItem.height + margin.item.vertical;
          }
        } while (collidingItem);
      }
    }
  };

  /**
   * Adjust vertical positions of the items without stacking them
   * @param {Item[]} items
   *            All visible items
   * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
   *            Margins between items and between items and the axis.
   */
  exports.nostack = function (items, margin, subgroups) {
    var i, iMax, newTop;

    // reset top position of all items
    for (i = 0, iMax = items.length; i < iMax; i++) {
      if (items[i].data.subgroup !== undefined) {
        newTop = margin.axis;
        for (var subgroup in subgroups) {
          if (subgroups.hasOwnProperty(subgroup)) {
            if (subgroups[subgroup].visible == true && subgroups[subgroup].index < subgroups[items[i].data.subgroup].index) {
              newTop += subgroups[subgroup].height + margin.item.vertical;
            }
          }
        }
        items[i].top = newTop;
      } else {
        items[i].top = margin.axis;
      }
    }
  };

  /**
   * Test if the two provided items collide
   * The items must have parameters left, width, top, and height.
   * @param {Item} a          The first item
   * @param {Item} b          The second item
   * @param {{horizontal: number, vertical: number}} margin
   *                          An object containing a horizontal and vertical
   *                          minimum required margin.
   * @param {boolean} rtl
   * @return {boolean}        true if a and b collide, else false
   */
  exports.collision = function (a, b, margin, rtl) {
    if (rtl) {
      return a.right - margin.horizontal + EPSILON < b.right + b.width && a.right + a.width + margin.horizontal - EPSILON > b.right && a.top - margin.vertical + EPSILON < b.top + b.height && a.top + a.height + margin.vertical - EPSILON > b.top;
    } else {
      return a.left - margin.horizontal + EPSILON < b.left + b.width && a.left + a.width + margin.horizontal - EPSILON > b.left && a.top - margin.vertical + EPSILON < b.top + b.height && a.top + a.height + margin.vertical - EPSILON > b.top;
    }
  };

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var Hammer = __webpack_require__(20);
  var Item = __webpack_require__(39);

  /**
   * @constructor RangeItem
   * @extends Item
   * @param {Object} data             Object containing parameters start, end
   *                                  content, className.
   * @param {{toScreen: function, toTime: function}} conversion
   *                                  Conversion functions from time to screen and vice versa
   * @param {Object} [options]        Configuration options
   *                                  // TODO: describe options
   */
  function RangeItem(data, conversion, options) {
    this.props = {
      content: {
        width: 0
      }
    };
    this.overflow = false; // if contents can overflow (css styling), this flag is set to true
    this.options = options;
    // validate data
    if (data) {
      if (data.start == undefined) {
        throw new Error('Property "start" missing in item ' + data.id);
      }
      if (data.end == undefined) {
        throw new Error('Property "end" missing in item ' + data.id);
      }
    }

    Item.call(this, data, conversion, options);
  }

  RangeItem.prototype = new Item(null, null, null);

  RangeItem.prototype.baseClassName = 'vis-item vis-range';

  /**
   * Check whether this item is visible inside given range
   * @returns {{start: Number, end: Number}} range with a timestamp for start and end
   * @returns {boolean} True if visible
   */
  RangeItem.prototype.isVisible = function (range) {
    // determine visibility
    return this.data.start < range.end && this.data.end > range.start;
  };

  /**
   * Repaint the item
   */
  RangeItem.prototype.redraw = function () {
    var dom = this.dom;
    if (!dom) {
      // create DOM
      this.dom = {};
      dom = this.dom;

      // background box
      dom.box = document.createElement('div');
      // className is updated in redraw()

      // frame box (to prevent the item contents from overflowing
      dom.frame = document.createElement('div');
      dom.frame.className = 'vis-item-overflow';
      dom.box.appendChild(dom.frame);

      // contents box
      dom.content = document.createElement('div');
      dom.content.className = 'vis-item-content';
      dom.frame.appendChild(dom.content);

      // attach this item as attribute
      dom.box['timeline-item'] = this;

      this.dirty = true;
    }

    // append DOM to parent DOM
    if (!this.parent) {
      throw new Error('Cannot redraw item: no parent attached');
    }
    if (!dom.box.parentNode) {
      var foreground = this.parent.dom.foreground;
      if (!foreground) {
        throw new Error('Cannot redraw item: parent has no foreground container element');
      }
      foreground.appendChild(dom.box);
    }
    this.displayed = true;

    // Update DOM when item is marked dirty. An item is marked dirty when:
    // - the item is not yet rendered
    // - the item's data is changed
    // - the item is selected/deselected
    if (this.dirty) {
      this._updateContents(this.dom.content);
      this._updateTitle(this.dom.box);
      this._updateDataAttributes(this.dom.box);
      this._updateStyle(this.dom.box);

      var editable = (this.options.editable.updateTime || this.options.editable.updateGroup || this.editable === true) && this.editable !== false;

      // update class
      var className = (this.data.className ? ' ' + this.data.className : '') + (this.selected ? ' vis-selected' : '') + (editable ? ' vis-editable' : ' vis-readonly');
      dom.box.className = this.baseClassName + className;

      // determine from css whether this box has overflow
      this.overflow = window.getComputedStyle(dom.frame).overflow !== 'hidden';

      // recalculate size
      // turn off max-width to be able to calculate the real width
      // this causes an extra browser repaint/reflow, but so be it
      this.dom.content.style.maxWidth = 'none';
      this.props.content.width = this.dom.content.offsetWidth;
      this.height = this.dom.box.offsetHeight;
      this.dom.content.style.maxWidth = '';

      this.dirty = false;
    }
    this._repaintDeleteButton(dom.box);
    this._repaintDragLeft();
    this._repaintDragRight();
  };

  /**
   * Show the item in the DOM (when not already visible). The items DOM will
   * be created when needed.
   */
  RangeItem.prototype.show = function () {
    if (!this.displayed) {
      this.redraw();
    }
  };

  /**
   * Hide the item from the DOM (when visible)
   * @return {Boolean} changed
   */
  RangeItem.prototype.hide = function () {
    if (this.displayed) {
      var box = this.dom.box;

      if (box.parentNode) {
        box.parentNode.removeChild(box);
      }

      this.displayed = false;
    }
  };

  /**
   * Reposition the item horizontally
   * @param {boolean} [limitSize=true] If true (default), the width of the range
   *                                   item will be limited, as the browser cannot
   *                                   display very wide divs. This means though
   *                                   that the applied left and width may
   *                                   not correspond to the ranges start and end
   * @Override
   */
  RangeItem.prototype.repositionX = function (limitSize) {
    var parentWidth = this.parent.width;
    var start = this.conversion.toScreen(this.data.start);
    var end = this.conversion.toScreen(this.data.end);
    var contentStartPosition;
    var contentWidth;

    // limit the width of the range, as browsers cannot draw very wide divs
    if (limitSize === undefined || limitSize === true) {
      if (start < -parentWidth) {
        start = -parentWidth;
      }
      if (end > 2 * parentWidth) {
        end = 2 * parentWidth;
      }
    }
    var boxWidth = Math.max(end - start, 1);

    if (this.overflow) {
      if (this.options.rtl) {
        this.right = start;
      } else {
        this.left = start;
      }
      this.width = boxWidth + this.props.content.width;
      contentWidth = this.props.content.width;

      // Note: The calculation of width is an optimistic calculation, giving
      //       a width which will not change when moving the Timeline
      //       So no re-stacking needed, which is nicer for the eye;
    } else {
        if (this.options.rtl) {
          this.right = start;
        } else {
          this.left = start;
        }
        this.width = boxWidth;
        contentWidth = Math.min(end - start, this.props.content.width);
      }

    if (this.options.rtl) {
      this.dom.box.style.right = this.right + 'px';
    } else {
      this.dom.box.style.left = this.left + 'px';
    }
    this.dom.box.style.width = boxWidth + 'px';

    switch (this.options.align) {
      case 'left':
        if (this.options.rtl) {
          this.dom.content.style.right = '0';
        } else {
          this.dom.content.style.left = '0';
        }
        break;

      case 'right':
        if (this.options.rtl) {
          this.dom.content.style.right = Math.max(boxWidth - contentWidth, 0) + 'px';
        } else {
          this.dom.content.style.left = Math.max(boxWidth - contentWidth, 0) + 'px';
        }
        break;

      case 'center':
        if (this.options.rtl) {
          this.dom.content.style.right = Math.max((boxWidth - contentWidth) / 2, 0) + 'px';
        } else {
          this.dom.content.style.left = Math.max((boxWidth - contentWidth) / 2, 0) + 'px';
        }

        break;

      default:
        // 'auto'
        // when range exceeds left of the window, position the contents at the left of the visible area
        if (this.overflow) {
          if (end > 0) {
            contentStartPosition = Math.max(-start, 0);
          } else {
            contentStartPosition = -contentWidth; // ensure it's not visible anymore
          }
        } else {
            if (start < 0) {
              contentStartPosition = -start;
            } else {
              contentStartPosition = 0;
            }
          }
        if (this.options.rtl) {
          this.dom.content.style.right = contentStartPosition + 'px';
        } else {
          this.dom.content.style.left = contentStartPosition + 'px';
        }
    }
  };

  /**
   * Reposition the item vertically
   * @Override
   */
  RangeItem.prototype.repositionY = function () {
    var orientation = this.options.orientation.item;
    var box = this.dom.box;

    if (orientation == 'top') {
      box.style.top = this.top + 'px';
    } else {
      box.style.top = this.parent.height - this.top - this.height + 'px';
    }
  };

  /**
   * Repaint a drag area on the left side of the range when the range is selected
   * @protected
   */
  RangeItem.prototype._repaintDragLeft = function () {
    if (this.selected && this.options.editable.updateTime && !this.dom.dragLeft) {
      // create and show drag area
      var dragLeft = document.createElement('div');
      dragLeft.className = 'vis-drag-left';
      dragLeft.dragLeftItem = this;

      this.dom.box.appendChild(dragLeft);
      this.dom.dragLeft = dragLeft;
    } else if (!this.selected && this.dom.dragLeft) {
      // delete drag area
      if (this.dom.dragLeft.parentNode) {
        this.dom.dragLeft.parentNode.removeChild(this.dom.dragLeft);
      }
      this.dom.dragLeft = null;
    }
  };

  /**
   * Repaint a drag area on the right side of the range when the range is selected
   * @protected
   */
  RangeItem.prototype._repaintDragRight = function () {
    if (this.selected && this.options.editable.updateTime && !this.dom.dragRight) {
      // create and show drag area
      var dragRight = document.createElement('div');
      dragRight.className = 'vis-drag-right';
      dragRight.dragRightItem = this;

      this.dom.box.appendChild(dragRight);
      this.dom.dragRight = dragRight;
    } else if (!this.selected && this.dom.dragRight) {
      // delete drag area
      if (this.dom.dragRight.parentNode) {
        this.dom.dragRight.parentNode.removeChild(this.dom.dragRight);
      }
      this.dom.dragRight = null;
    }
  };

  module.exports = RangeItem;

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var Hammer = __webpack_require__(20);
  var util = __webpack_require__(1);

  /**
   * @constructor Item
   * @param {Object} data             Object containing (optional) parameters type,
   *                                  start, end, content, group, className.
   * @param {{toScreen: function, toTime: function}} conversion
   *                                  Conversion functions from time to screen and vice versa
   * @param {Object} options          Configuration options
   *                                  // TODO: describe available options
   */
  function Item(data, conversion, options) {
    this.id = null;
    this.parent = null;
    this.data = data;
    this.dom = null;
    this.conversion = conversion || {};
    this.options = options || {};

    this.selected = false;
    this.displayed = false;
    this.dirty = true;

    this.top = null;
    this.right = null;
    this.left = null;
    this.width = null;
    this.height = null;

    this.editable = null;
    if (this.data && this.data.hasOwnProperty('editable') && typeof this.data.editable === 'boolean') {
      this.editable = data.editable;
    }
  }

  Item.prototype.stack = true;

  /**
   * Select current item
   */
  Item.prototype.select = function () {
    this.selected = true;
    this.dirty = true;
    if (this.displayed) this.redraw();
  };

  /**
   * Unselect current item
   */
  Item.prototype.unselect = function () {
    this.selected = false;
    this.dirty = true;
    if (this.displayed) this.redraw();
  };

  /**
   * Set data for the item. Existing data will be updated. The id should not
   * be changed. When the item is displayed, it will be redrawn immediately.
   * @param {Object} data
   */
  Item.prototype.setData = function (data) {
    var groupChanged = data.group != undefined && this.data.group != data.group;
    if (groupChanged) {
      this.parent.itemSet._moveToGroup(this, data.group);
    }

    if (data.hasOwnProperty('editable') && typeof data.editable === 'boolean') {
      this.editable = data.editable;
    }

    this.data = data;
    this.dirty = true;
    if (this.displayed) this.redraw();
  };

  /**
   * Set a parent for the item
   * @param {ItemSet | Group} parent
   */
  Item.prototype.setParent = function (parent) {
    if (this.displayed) {
      this.hide();
      this.parent = parent;
      if (this.parent) {
        this.show();
      }
    } else {
      this.parent = parent;
    }
  };

  /**
   * Check whether this item is visible inside given range
   * @returns {{start: Number, end: Number}} range with a timestamp for start and end
   * @returns {boolean} True if visible
   */
  Item.prototype.isVisible = function (range) {
    // Should be implemented by Item implementations
    return false;
  };

  /**
   * Show the Item in the DOM (when not already visible)
   * @return {Boolean} changed
   */
  Item.prototype.show = function () {
    return false;
  };

  /**
   * Hide the Item from the DOM (when visible)
   * @return {Boolean} changed
   */
  Item.prototype.hide = function () {
    return false;
  };

  /**
   * Repaint the item
   */
  Item.prototype.redraw = function () {
    // should be implemented by the item
  };

  /**
   * Reposition the Item horizontally
   */
  Item.prototype.repositionX = function () {
    // should be implemented by the item
  };

  /**
   * Reposition the Item vertically
   */
  Item.prototype.repositionY = function () {
    // should be implemented by the item
  };

  /**
   * Repaint a delete button on the top right of the item when the item is selected
   * @param {HTMLElement} anchor
   * @protected
   */
  Item.prototype._repaintDeleteButton = function (anchor) {
    var editable = (this.options.editable.remove || this.data.editable === true) && this.data.editable !== false;

    if (this.selected && editable && !this.dom.deleteButton) {
      // create and show button
      var me = this;

      var deleteButton = document.createElement('div');

      if (this.options.rtl) {
        deleteButton.className = 'vis-delete-rtl';
      } else {
        deleteButton.className = 'vis-delete';
      }
      deleteButton.title = 'Delete this item';

      // TODO: be able to destroy the delete button
      new Hammer(deleteButton).on('tap', function (event) {
        event.stopPropagation();
        me.parent.removeFromDataSet(me);
      });

      anchor.appendChild(deleteButton);
      this.dom.deleteButton = deleteButton;
    } else if (!this.selected && this.dom.deleteButton) {
      // remove button
      if (this.dom.deleteButton.parentNode) {
        this.dom.deleteButton.parentNode.removeChild(this.dom.deleteButton);
      }
      this.dom.deleteButton = null;
    }
  };

  /**
   * Set HTML contents for the item
   * @param {Element} element   HTML element to fill with the contents
   * @private
   */
  Item.prototype._updateContents = function (element) {
    var content;
    if (this.options.template) {
      var itemData = this.parent.itemSet.itemsData.get(this.id); // get a clone of the data from the dataset
      content = this.options.template(itemData);
    } else {
      content = this.data.content;
    }

    var changed = this._contentToString(this.content) !== this._contentToString(content);
    if (changed) {
      // only replace the content when changed
      if (content instanceof Element) {
        element.innerHTML = '';
        element.appendChild(content);
      } else if (content != undefined) {
        element.innerHTML = content;
      } else {
        if (!(this.data.type == 'background' && this.data.content === undefined)) {
          throw new Error('Property "content" missing in item ' + this.id);
        }
      }

      this.content = content;
    }
  };

  /**
   * Set HTML contents for the item
   * @param {Element} element   HTML element to fill with the contents
   * @private
   */
  Item.prototype._updateTitle = function (element) {
    if (this.data.title != null) {
      element.title = this.data.title || '';
    } else {
      element.removeAttribute('vis-title');
    }
  };

  /**
   * Process dataAttributes timeline option and set as data- attributes on dom.content
   * @param {Element} element   HTML element to which the attributes will be attached
   * @private
   */
  Item.prototype._updateDataAttributes = function (element) {
    if (this.options.dataAttributes && this.options.dataAttributes.length > 0) {
      var attributes = [];

      if (Array.isArray(this.options.dataAttributes)) {
        attributes = this.options.dataAttributes;
      } else if (this.options.dataAttributes == 'all') {
        attributes = Object.keys(this.data);
      } else {
        return;
      }

      for (var i = 0; i < attributes.length; i++) {
        var name = attributes[i];
        var value = this.data[name];

        if (value != null) {
          element.setAttribute('data-' + name, value);
        } else {
          element.removeAttribute('data-' + name);
        }
      }
    }
  };

  /**
   * Update custom styles of the element
   * @param element
   * @private
   */
  Item.prototype._updateStyle = function (element) {
    // remove old styles
    if (this.style) {
      util.removeCssText(element, this.style);
      this.style = null;
    }

    // append new styles
    if (this.data.style) {
      util.addCssText(element, this.data.style);
      this.style = this.data.style;
    }
  };

  /**
   * Stringify the items contents
   * @param {string | Element | undefined} content
   * @returns {string | undefined}
   * @private
   */
  Item.prototype._contentToString = function (content) {
    if (typeof content === 'string') return content;
    if (content && 'outerHTML' in content) return content.outerHTML;
    return content;
  };

  /**
   * Return the width of the item left from its start date
   * @return {number}
   */
  Item.prototype.getWidthLeft = function () {
    return 0;
  };

  /**
   * Return the width of the item right from the max of its start and end date
   * @return {number}
   */
  Item.prototype.getWidthRight = function () {
    return 0;
  };

  module.exports = Item;

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var util = __webpack_require__(1);
  var Group = __webpack_require__(36);

  /**
   * @constructor BackgroundGroup
   * @param {Number | String} groupId
   * @param {Object} data
   * @param {ItemSet} itemSet
   */
  function BackgroundGroup(groupId, data, itemSet) {
    Group.call(this, groupId, data, itemSet);

    this.width = 0;
    this.height = 0;
    this.top = 0;
    this.left = 0;
  }

  BackgroundGroup.prototype = Object.create(Group.prototype);

  /**
   * Repaint this group
   * @param {{start: number, end: number}} range
   * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
   * @param {boolean} [restack=false]  Force restacking of all items
   * @return {boolean} Returns true if the group is resized
   */
  BackgroundGroup.prototype.redraw = function (range, margin, restack) {
    var resized = false;

    this.visibleItems = this._updateVisibleItems(this.orderedItems, this.visibleItems, range);

    // calculate actual size
    this.width = this.dom.background.offsetWidth;

    // apply new height (just always zero for BackgroundGroup
    this.dom.background.style.height = '0';

    // update vertical position of items after they are re-stacked and the height of the group is calculated
    for (var i = 0, ii = this.visibleItems.length; i < ii; i++) {
      var item = this.visibleItems[i];
      item.repositionY(margin);
    }

    return resized;
  };

  /**
   * Show this group: attach to the DOM
   */
  BackgroundGroup.prototype.show = function () {
    if (!this.dom.background.parentNode) {
      this.itemSet.dom.background.appendChild(this.dom.background);
    }
  };

  module.exports = BackgroundGroup;

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var Item = __webpack_require__(39);
  var util = __webpack_require__(1);

  /**
   * @constructor BoxItem
   * @extends Item
   * @param {Object} data             Object containing parameters start
   *                                  content, className.
   * @param {{toScreen: function, toTime: function}} conversion
   *                                  Conversion functions from time to screen and vice versa
   * @param {Object} [options]        Configuration options
   *                                  // TODO: describe available options
   */
  function BoxItem(data, conversion, options) {
    this.props = {
      dot: {
        width: 0,
        height: 0
      },
      line: {
        width: 0,
        height: 0
      }
    };
    this.options = options;
    // validate data
    if (data) {
      if (data.start == undefined) {
        throw new Error('Property "start" missing in item ' + data);
      }
    }

    Item.call(this, data, conversion, options);
  }

  BoxItem.prototype = new Item(null, null, null);

  /**
   * Check whether this item is visible inside given range
   * @returns {{start: Number, end: Number}} range with a timestamp for start and end
   * @returns {boolean} True if visible
   */
  BoxItem.prototype.isVisible = function (range) {
    // determine visibility
    // TODO: account for the real width of the item. Right now we just add 1/4 to the window
    var interval = (range.end - range.start) / 4;
    return this.data.start > range.start - interval && this.data.start < range.end + interval;
  };

  /**
   * Repaint the item
   */
  BoxItem.prototype.redraw = function () {
    var dom = this.dom;
    if (!dom) {
      // create DOM
      this.dom = {};
      dom = this.dom;

      // create main box
      dom.box = document.createElement('DIV');

      // contents box (inside the background box). used for making margins
      dom.content = document.createElement('DIV');
      dom.content.className = 'vis-item-content';
      dom.box.appendChild(dom.content);

      // line to axis
      dom.line = document.createElement('DIV');
      dom.line.className = 'vis-line';

      // dot on axis
      dom.dot = document.createElement('DIV');
      dom.dot.className = 'vis-dot';

      // attach this item as attribute
      dom.box['timeline-item'] = this;

      this.dirty = true;
    }

    // append DOM to parent DOM
    if (!this.parent) {
      throw new Error('Cannot redraw item: no parent attached');
    }
    if (!dom.box.parentNode) {
      var foreground = this.parent.dom.foreground;
      if (!foreground) throw new Error('Cannot redraw item: parent has no foreground container element');
      foreground.appendChild(dom.box);
    }
    if (!dom.line.parentNode) {
      var background = this.parent.dom.background;
      if (!background) throw new Error('Cannot redraw item: parent has no background container element');
      background.appendChild(dom.line);
    }
    if (!dom.dot.parentNode) {
      var axis = this.parent.dom.axis;
      if (!background) throw new Error('Cannot redraw item: parent has no axis container element');
      axis.appendChild(dom.dot);
    }
    this.displayed = true;

    // Update DOM when item is marked dirty. An item is marked dirty when:
    // - the item is not yet rendered
    // - the item's data is changed
    // - the item is selected/deselected
    if (this.dirty) {
      this._updateContents(this.dom.content);
      this._updateTitle(this.dom.box);
      this._updateDataAttributes(this.dom.box);
      this._updateStyle(this.dom.box);

      var editable = (this.options.editable.updateTime || this.options.editable.updateGroup || this.editable === true) && this.editable !== false;

      // update class
      var className = (this.data.className ? ' ' + this.data.className : '') + (this.selected ? ' vis-selected' : '') + (editable ? ' vis-editable' : ' vis-readonly');
      dom.box.className = 'vis-item vis-box' + className;
      dom.line.className = 'vis-item vis-line' + className;
      dom.dot.className = 'vis-item vis-dot' + className;

      // recalculate size
      this.props.dot.height = dom.dot.offsetHeight;
      this.props.dot.width = dom.dot.offsetWidth;
      this.props.line.width = dom.line.offsetWidth;
      this.width = dom.box.offsetWidth;
      this.height = dom.box.offsetHeight;

      this.dirty = false;
    }

    this._repaintDeleteButton(dom.box);
  };

  /**
   * Show the item in the DOM (when not already displayed). The items DOM will
   * be created when needed.
   */
  BoxItem.prototype.show = function () {
    if (!this.displayed) {
      this.redraw();
    }
  };

  /**
   * Hide the item from the DOM (when visible)
   */
  BoxItem.prototype.hide = function () {
    if (this.displayed) {
      var dom = this.dom;

      if (dom.box.parentNode) dom.box.parentNode.removeChild(dom.box);
      if (dom.line.parentNode) dom.line.parentNode.removeChild(dom.line);
      if (dom.dot.parentNode) dom.dot.parentNode.removeChild(dom.dot);

      this.displayed = false;
    }
  };

  /**
   * Reposition the item horizontally
   * @Override
   */
  BoxItem.prototype.repositionX = function () {
    var start = this.conversion.toScreen(this.data.start);
    var align = this.options.align;

    // calculate left position of the box
    if (align == 'right') {
      if (this.options.rtl) {
        this.right = start - this.width;

        // reposition box, line, and dot
        this.dom.box.style.right = this.right + 'px';
        this.dom.line.style.right = start - this.props.line.width + 'px';
        this.dom.dot.style.right = start - this.props.line.width / 2 - this.props.dot.width / 2 + 'px';
      } else {
        this.left = start - this.width;

        // reposition box, line, and dot
        this.dom.box.style.left = this.left + 'px';
        this.dom.line.style.left = start - this.props.line.width + 'px';
        this.dom.dot.style.left = start - this.props.line.width / 2 - this.props.dot.width / 2 + 'px';
      }
    } else if (align == 'left') {
      if (this.options.rtl) {
        this.right = start;

        // reposition box, line, and dot
        this.dom.box.style.right = this.right + 'px';
        this.dom.line.style.right = start + 'px';
        this.dom.dot.style.right = start + this.props.line.width / 2 - this.props.dot.width / 2 + 'px';
      } else {
        this.left = start;

        // reposition box, line, and dot
        this.dom.box.style.left = this.left + 'px';
        this.dom.line.style.left = start + 'px';
        this.dom.dot.style.left = start + this.props.line.width / 2 - this.props.dot.width / 2 + 'px';
      }
    } else {
      // default or 'center'
      if (this.options.rtl) {
        this.right = start - this.width / 2;

        // reposition box, line, and dot
        this.dom.box.style.right = this.right + 'px';
        this.dom.line.style.right = start - this.props.line.width + 'px';
        this.dom.dot.style.right = start - this.props.dot.width / 2 + 'px';
      } else {
        this.left = start - this.width / 2;

        // reposition box, line, and dot
        this.dom.box.style.left = this.left + 'px';
        this.dom.line.style.left = start - this.props.line.width / 2 + 'px';
        this.dom.dot.style.left = start - this.props.dot.width / 2 + 'px';
      }
    }
  };

  /**
   * Reposition the item vertically
   * @Override
   */
  BoxItem.prototype.repositionY = function () {
    var orientation = this.options.orientation.item;
    var box = this.dom.box;
    var line = this.dom.line;
    var dot = this.dom.dot;

    if (orientation == 'top') {
      box.style.top = (this.top || 0) + 'px';

      line.style.top = '0';
      line.style.height = this.parent.top + this.top + 1 + 'px';
      line.style.bottom = '';
    } else {
      // orientation 'bottom'
      var itemSetHeight = this.parent.itemSet.props.height; // TODO: this is nasty
      var lineHeight = itemSetHeight - this.parent.top - this.parent.height + this.top;

      box.style.top = (this.parent.height - this.top - this.height || 0) + 'px';
      line.style.top = itemSetHeight - lineHeight + 'px';
      line.style.bottom = '0';
    }

    dot.style.top = -this.props.dot.height / 2 + 'px';
  };

  /**
   * Return the width of the item left from its start date
   * @return {number}
   */
  BoxItem.prototype.getWidthLeft = function () {
    return this.width / 2;
  };

  /**
   * Return the width of the item right from its start date
   * @return {number}
   */
  BoxItem.prototype.getWidthRight = function () {
    return this.width / 2;
  };

  module.exports = BoxItem;

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var Item = __webpack_require__(39);

  /**
   * @constructor PointItem
   * @extends Item
   * @param {Object} data             Object containing parameters start
   *                                  content, className.
   * @param {{toScreen: function, toTime: function}} conversion
   *                                  Conversion functions from time to screen and vice versa
   * @param {Object} [options]        Configuration options
   *                                  // TODO: describe available options
   */
  function PointItem(data, conversion, options) {
    this.props = {
      dot: {
        top: 0,
        width: 0,
        height: 0
      },
      content: {
        height: 0,
        marginLeft: 0,
        marginRight: 0
      }
    };
    this.options = options;
    // validate data
    if (data) {
      if (data.start == undefined) {
        throw new Error('Property "start" missing in item ' + data);
      }
    }

    Item.call(this, data, conversion, options);
  }

  PointItem.prototype = new Item(null, null, null);

  /**
   * Check whether this item is visible inside given range
   * @returns {{start: Number, end: Number}} range with a timestamp for start and end
   * @returns {boolean} True if visible
   */
  PointItem.prototype.isVisible = function (range) {
    // determine visibility
    // TODO: account for the real width of the item. Right now we just add 1/4 to the window
    var interval = (range.end - range.start) / 4;
    return this.data.start > range.start - interval && this.data.start < range.end + interval;
  };

  /**
   * Repaint the item
   */
  PointItem.prototype.redraw = function () {
    var dom = this.dom;
    if (!dom) {
      // create DOM
      this.dom = {};
      dom = this.dom;

      // background box
      dom.point = document.createElement('div');
      // className is updated in redraw()

      // contents box, right from the dot
      dom.content = document.createElement('div');
      dom.content.className = 'vis-item-content';
      dom.point.appendChild(dom.content);

      // dot at start
      dom.dot = document.createElement('div');
      dom.point.appendChild(dom.dot);

      // attach this item as attribute
      dom.point['timeline-item'] = this;

      this.dirty = true;
    }

    // append DOM to parent DOM
    if (!this.parent) {
      throw new Error('Cannot redraw item: no parent attached');
    }
    if (!dom.point.parentNode) {
      var foreground = this.parent.dom.foreground;
      if (!foreground) {
        throw new Error('Cannot redraw item: parent has no foreground container element');
      }
      foreground.appendChild(dom.point);
    }
    this.displayed = true;

    // Update DOM when item is marked dirty. An item is marked dirty when:
    // - the item is not yet rendered
    // - the item's data is changed
    // - the item is selected/deselected
    if (this.dirty) {
      this._updateContents(this.dom.content);
      this._updateTitle(this.dom.point);
      this._updateDataAttributes(this.dom.point);
      this._updateStyle(this.dom.point);

      var editable = (this.options.editable.updateTime || this.options.editable.updateGroup || this.editable === true) && this.editable !== false;

      // update class
      var className = (this.data.className ? ' ' + this.data.className : '') + (this.selected ? ' vis-selected' : '') + (editable ? ' vis-editable' : ' vis-readonly');
      dom.point.className = 'vis-item vis-point' + className;
      dom.dot.className = 'vis-item vis-dot' + className;

      // recalculate size of dot and contents
      this.props.dot.width = dom.dot.offsetWidth;
      this.props.dot.height = dom.dot.offsetHeight;
      this.props.content.height = dom.content.offsetHeight;

      // resize contents
      if (this.options.rtl) {
        dom.content.style.marginRight = 2 * this.props.dot.width + 'px';
      } else {
        dom.content.style.marginLeft = 2 * this.props.dot.width + 'px';
      }
      //dom.content.style.marginRight = ... + 'px'; // TODO: margin right

      // recalculate size
      this.width = dom.point.offsetWidth;
      this.height = dom.point.offsetHeight;

      // reposition the dot
      dom.dot.style.top = (this.height - this.props.dot.height) / 2 + 'px';
      if (this.options.rtl) {
        dom.dot.style.right = this.props.dot.width / 2 + 'px';
      } else {
        dom.dot.style.left = this.props.dot.width / 2 + 'px';
      }

      this.dirty = false;
    }

    this._repaintDeleteButton(dom.point);
  };

  /**
   * Show the item in the DOM (when not already visible). The items DOM will
   * be created when needed.
   */
  PointItem.prototype.show = function () {
    if (!this.displayed) {
      this.redraw();
    }
  };

  /**
   * Hide the item from the DOM (when visible)
   */
  PointItem.prototype.hide = function () {
    if (this.displayed) {
      if (this.dom.point.parentNode) {
        this.dom.point.parentNode.removeChild(this.dom.point);
      }

      this.displayed = false;
    }
  };

  /**
   * Reposition the item horizontally
   * @Override
   */
  PointItem.prototype.repositionX = function () {
    var start = this.conversion.toScreen(this.data.start);

    if (this.options.rtl) {
      this.right = start - this.props.dot.width;

      // reposition point
      this.dom.point.style.right = this.right + 'px';
    } else {
      this.left = start - this.props.dot.width;

      // reposition point
      this.dom.point.style.left = this.left + 'px';
    }
  };

  /**
   * Reposition the item vertically
   * @Override
   */
  PointItem.prototype.repositionY = function () {
    var orientation = this.options.orientation.item;
    var point = this.dom.point;
    if (orientation == 'top') {
      point.style.top = this.top + 'px';
    } else {
      point.style.top = this.parent.height - this.top - this.height + 'px';
    }
  };

  /**
   * Return the width of the item left from its start date
   * @return {number}
   */
  PointItem.prototype.getWidthLeft = function () {
    return this.props.dot.width;
  };

  /**
   * Return the width of the item right from  its start date
   * @return {number}
   */
  PointItem.prototype.getWidthRight = function () {
    return this.props.dot.width;
  };

  module.exports = PointItem;

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var Hammer = __webpack_require__(20);
  var Item = __webpack_require__(39);
  var BackgroundGroup = __webpack_require__(40);
  var RangeItem = __webpack_require__(38);

  /**
   * @constructor BackgroundItem
   * @extends Item
   * @param {Object} data             Object containing parameters start, end
   *                                  content, className.
   * @param {{toScreen: function, toTime: function}} conversion
   *                                  Conversion functions from time to screen and vice versa
   * @param {Object} [options]        Configuration options
   *                                  // TODO: describe options
   */
  // TODO: implement support for the BackgroundItem just having a start, then being displayed as a sort of an annotation
  function BackgroundItem(data, conversion, options) {
    this.props = {
      content: {
        width: 0
      }
    };
    this.overflow = false; // if contents can overflow (css styling), this flag is set to true

    // validate data
    if (data) {
      if (data.start == undefined) {
        throw new Error('Property "start" missing in item ' + data.id);
      }
      if (data.end == undefined) {
        throw new Error('Property "end" missing in item ' + data.id);
      }
    }

    Item.call(this, data, conversion, options);
  }

  BackgroundItem.prototype = new Item(null, null, null);

  BackgroundItem.prototype.baseClassName = 'vis-item vis-background';
  BackgroundItem.prototype.stack = false;

  /**
   * Check whether this item is visible inside given range
   * @returns {{start: Number, end: Number}} range with a timestamp for start and end
   * @returns {boolean} True if visible
   */
  BackgroundItem.prototype.isVisible = function (range) {
    // determine visibility
    return this.data.start < range.end && this.data.end > range.start;
  };

  /**
   * Repaint the item
   */
  BackgroundItem.prototype.redraw = function () {
    var dom = this.dom;
    if (!dom) {
      // create DOM
      this.dom = {};
      dom = this.dom;

      // background box
      dom.box = document.createElement('div');
      // className is updated in redraw()

      // frame box (to prevent the item contents from overflowing
      dom.frame = document.createElement('div');
      dom.frame.className = 'vis-item-overflow';
      dom.box.appendChild(dom.frame);

      // contents box
      dom.content = document.createElement('div');
      dom.content.className = 'vis-item-content';
      dom.frame.appendChild(dom.content);

      // Note: we do NOT attach this item as attribute to the DOM,
      //       such that background items cannot be selected
      //dom.box['timeline-item'] = this;

      this.dirty = true;
    }

    // append DOM to parent DOM
    if (!this.parent) {
      throw new Error('Cannot redraw item: no parent attached');
    }
    if (!dom.box.parentNode) {
      var background = this.parent.dom.background;
      if (!background) {
        throw new Error('Cannot redraw item: parent has no background container element');
      }
      background.appendChild(dom.box);
    }
    this.displayed = true;

    // Update DOM when item is marked dirty. An item is marked dirty when:
    // - the item is not yet rendered
    // - the item's data is changed
    // - the item is selected/deselected
    if (this.dirty) {
      this._updateContents(this.dom.content);
      this._updateTitle(this.dom.content);
      this._updateDataAttributes(this.dom.content);
      this._updateStyle(this.dom.box);

      // update class
      var className = (this.data.className ? ' ' + this.data.className : '') + (this.selected ? ' vis-selected' : '');
      dom.box.className = this.baseClassName + className;

      // determine from css whether this box has overflow
      this.overflow = window.getComputedStyle(dom.content).overflow !== 'hidden';

      // recalculate size
      this.props.content.width = this.dom.content.offsetWidth;
      this.height = 0; // set height zero, so this item will be ignored when stacking items

      this.dirty = false;
    }
  };

  /**
   * Show the item in the DOM (when not already visible). The items DOM will
   * be created when needed.
   */
  BackgroundItem.prototype.show = RangeItem.prototype.show;

  /**
   * Hide the item from the DOM (when visible)
   * @return {Boolean} changed
   */
  BackgroundItem.prototype.hide = RangeItem.prototype.hide;

  /**
   * Reposition the item horizontally
   * @Override
   */
  BackgroundItem.prototype.repositionX = RangeItem.prototype.repositionX;

  /**
   * Reposition the item vertically
   * @Override
   */
  BackgroundItem.prototype.repositionY = function (margin) {
    var onTop = this.options.orientation.item === 'top';
    this.dom.content.style.top = onTop ? '' : '0';
    this.dom.content.style.bottom = onTop ? '0' : '';
    var height;

    // special positioning for subgroups
    if (this.data.subgroup !== undefined) {
      // TODO: instead of calculating the top position of the subgroups here for every BackgroundItem, calculate the top of the subgroup once in Itemset

      var itemSubgroup = this.data.subgroup;
      var subgroups = this.parent.subgroups;
      var subgroupIndex = subgroups[itemSubgroup].index;
      // if the orientation is top, we need to take the difference in height into account.
      if (onTop == true) {
        // the first subgroup will have to account for the distance from the top to the first item.
        height = this.parent.subgroups[itemSubgroup].height + margin.item.vertical;
        height += subgroupIndex == 0 ? margin.axis - 0.5 * margin.item.vertical : 0;
        var newTop = this.parent.top;
        for (var subgroup in subgroups) {
          if (subgroups.hasOwnProperty(subgroup)) {
            if (subgroups[subgroup].visible == true && subgroups[subgroup].index < subgroupIndex) {
              newTop += subgroups[subgroup].height + margin.item.vertical;
            }
          }
        }

        // the others will have to be offset downwards with this same distance.
        newTop += subgroupIndex != 0 ? margin.axis - 0.5 * margin.item.vertical : 0;
        this.dom.box.style.top = newTop + 'px';
        this.dom.box.style.bottom = '';
      }
      // and when the orientation is bottom:
      else {
          var newTop = this.parent.top;
          var totalHeight = 0;
          for (var subgroup in subgroups) {
            if (subgroups.hasOwnProperty(subgroup)) {
              if (subgroups[subgroup].visible == true) {
                var newHeight = subgroups[subgroup].height + margin.item.vertical;
                totalHeight += newHeight;
                if (subgroups[subgroup].index > subgroupIndex) {
                  newTop += newHeight;
                }
              }
            }
          }
          height = this.parent.subgroups[itemSubgroup].height + margin.item.vertical;
          this.dom.box.style.top = this.parent.height - totalHeight + newTop + 'px';
          this.dom.box.style.bottom = '';
        }
    }
    // and in the case of no subgroups:
    else {
        // we want backgrounds with groups to only show in groups.
        if (this.parent instanceof BackgroundGroup) {
          // if the item is not in a group:
          height = Math.max(this.parent.height, this.parent.itemSet.body.domProps.center.height, this.parent.itemSet.body.domProps.centerContainer.height);
          this.dom.box.style.top = onTop ? '0' : '';
          this.dom.box.style.bottom = onTop ? '' : '0';
        } else {
          height = this.parent.height;
          // same alignment for items when orientation is top or bottom
          this.dom.box.style.top = this.parent.top + 'px';
          this.dom.box.style.bottom = '';
        }
      }
    this.dom.box.style.height = height + 'px';
  };

  module.exports = BackgroundItem;

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

  var util = __webpack_require__(1);
  var Component = __webpack_require__(31);
  var TimeStep = __webpack_require__(35);
  var DateUtil = __webpack_require__(32);
  var moment = __webpack_require__(2);

  /**
   * A horizontal time axis
   * @param {{dom: Object, domProps: Object, emitter: Emitter, range: Range}} body
   * @param {Object} [options]        See TimeAxis.setOptions for the available
   *                                  options.
   * @constructor TimeAxis
   * @extends Component
   */
  function TimeAxis(body, options) {
    this.dom = {
      foreground: null,
      lines: [],
      majorTexts: [],
      minorTexts: [],
      redundant: {
        lines: [],
        majorTexts: [],
        minorTexts: []
      }
    };
    this.props = {
      range: {
        start: 0,
        end: 0,
        minimumStep: 0
      },
      lineTop: 0
    };

    this.defaultOptions = {
      orientation: {
        axis: 'bottom'
      }, // axis orientation: 'top' or 'bottom'
      showMinorLabels: true,
      showMajorLabels: true,
      maxMinorChars: 7,
      format: TimeStep.FORMAT,
      moment: moment,
      timeAxis: null
    };
    this.options = util.extend({}, this.defaultOptions);

    this.body = body;

    // create the HTML DOM
    this._create();

    this.setOptions(options);
  }

  TimeAxis.prototype = new Component();

  /**
   * Set options for the TimeAxis.
   * Parameters will be merged in current options.
   * @param {Object} options  Available options:
   *                          {string} [orientation.axis]
   *                          {boolean} [showMinorLabels]
   *                          {boolean} [showMajorLabels]
   */
  TimeAxis.prototype.setOptions = function (options) {
    if (options) {
      // copy all options that we know
      util.selectiveExtend(['showMinorLabels', 'showMajorLabels', 'maxMinorChars', 'hiddenDates', 'timeAxis', 'moment', 'rtl'], this.options, options);

      // deep copy the format options
      util.selectiveDeepExtend(['format'], this.options, options);

      if ('orientation' in options) {
        if (typeof options.orientation === 'string') {
          this.options.orientation.axis = options.orientation;
        } else if (_typeof(options.orientation) === 'object' && 'axis' in options.orientation) {
          this.options.orientation.axis = options.orientation.axis;
        }
      }

      // apply locale to moment.js
      // TODO: not so nice, this is applied globally to moment.js
      if ('locale' in options) {
        if (typeof moment.locale === 'function') {
          // moment.js 2.8.1+
          moment.locale(options.locale);
        } else {
          moment.lang(options.locale);
        }
      }
    }
  };

  /**
   * Create the HTML DOM for the TimeAxis
   */
  TimeAxis.prototype._create = function () {
    this.dom.foreground = document.createElement('div');
    this.dom.background = document.createElement('div');

    this.dom.foreground.className = 'vis-time-axis vis-foreground';
    this.dom.background.className = 'vis-time-axis vis-background';
  };

  /**
   * Destroy the TimeAxis
   */
  TimeAxis.prototype.destroy = function () {
    // remove from DOM
    if (this.dom.foreground.parentNode) {
      this.dom.foreground.parentNode.removeChild(this.dom.foreground);
    }
    if (this.dom.background.parentNode) {
      this.dom.background.parentNode.removeChild(this.dom.background);
    }

    this.body = null;
  };

  /**
   * Repaint the component
   * @return {boolean} Returns true if the component is resized
   */
  TimeAxis.prototype.redraw = function () {
    var props = this.props;
    var foreground = this.dom.foreground;
    var background = this.dom.background;

    // determine the correct parent DOM element (depending on option orientation)
    var parent = this.options.orientation.axis == 'top' ? this.body.dom.top : this.body.dom.bottom;
    var parentChanged = foreground.parentNode !== parent;

    // calculate character width and height
    this._calculateCharSize();

    // TODO: recalculate sizes only needed when parent is resized or options is changed
    var showMinorLabels = this.options.showMinorLabels && this.options.orientation.axis !== 'none';
    var showMajorLabels = this.options.showMajorLabels && this.options.orientation.axis !== 'none';

    // determine the width and height of the elemens for the axis
    props.minorLabelHeight = showMinorLabels ? props.minorCharHeight : 0;
    props.majorLabelHeight = showMajorLabels ? props.majorCharHeight : 0;
    props.height = props.minorLabelHeight + props.majorLabelHeight;
    props.width = foreground.offsetWidth;

    props.minorLineHeight = this.body.domProps.root.height - props.majorLabelHeight - (this.options.orientation.axis == 'top' ? this.body.domProps.bottom.height : this.body.domProps.top.height);
    props.minorLineWidth = 1; // TODO: really calculate width
    props.majorLineHeight = props.minorLineHeight + props.majorLabelHeight;
    props.majorLineWidth = 1; // TODO: really calculate width

    //  take foreground and background offline while updating (is almost twice as fast)
    var foregroundNextSibling = foreground.nextSibling;
    var backgroundNextSibling = background.nextSibling;
    foreground.parentNode && foreground.parentNode.removeChild(foreground);
    background.parentNode && background.parentNode.removeChild(background);

    foreground.style.height = this.props.height + 'px';

    this._repaintLabels();

    // put DOM online again (at the same place)
    if (foregroundNextSibling) {
      parent.insertBefore(foreground, foregroundNextSibling);
    } else {
      parent.appendChild(foreground);
    }
    if (backgroundNextSibling) {
      this.body.dom.backgroundVertical.insertBefore(background, backgroundNextSibling);
    } else {
      this.body.dom.backgroundVertical.appendChild(background);
    }
    return this._isResized() || parentChanged;
  };

  /**
   * Repaint major and minor text labels and vertical grid lines
   * @private
   */
  TimeAxis.prototype._repaintLabels = function () {
    var orientation = this.options.orientation.axis;

    // calculate range and step (step such that we have space for 7 characters per label)
    var start = util.convert(this.body.range.start, 'Number');
    var end = util.convert(this.body.range.end, 'Number');
    var timeLabelsize = this.body.util.toTime((this.props.minorCharWidth || 10) * this.options.maxMinorChars).valueOf();
    var minimumStep = timeLabelsize - DateUtil.getHiddenDurationBefore(this.options.moment, this.body.hiddenDates, this.body.range, timeLabelsize);
    minimumStep -= this.body.util.toTime(0).valueOf();

    var step = new TimeStep(new Date(start), new Date(end), minimumStep, this.body.hiddenDates);
    step.setMoment(this.options.moment);
    if (this.options.format) {
      step.setFormat(this.options.format);
    }
    if (this.options.timeAxis) {
      step.setScale(this.options.timeAxis);
    }
    this.step = step;

    // Move all DOM elements to a "redundant" list, where they
    // can be picked for re-use, and clear the lists with lines and texts.
    // At the end of the function _repaintLabels, left over elements will be cleaned up
    var dom = this.dom;
    dom.redundant.lines = dom.lines;
    dom.redundant.majorTexts = dom.majorTexts;
    dom.redundant.minorTexts = dom.minorTexts;
    dom.lines = [];
    dom.majorTexts = [];
    dom.minorTexts = [];

    var current;
    var next;
    var x;
    var xNext;
    var isMajor, nextIsMajor;
    var width = 0,
        prevWidth;
    var line;
    var labelMinor;
    var xFirstMajorLabel = undefined;
    var count = 0;
    var MAX = 1000;
    var className;

    step.start();
    next = step.getCurrent();
    xNext = this.body.util.toScreen(next);
    while (step.hasNext() && count < MAX) {
      count++;

      isMajor = step.isMajor();
      className = step.getClassName();
      labelMinor = step.getLabelMinor();

      current = next;
      x = xNext;

      step.next();
      next = step.getCurrent();
      nextIsMajor = step.isMajor();
      xNext = this.body.util.toScreen(next);

      prevWidth = width;
      width = xNext - x;
      var showMinorGrid = width >= prevWidth * 0.4; // prevent displaying of the 31th of the month on a scale of 5 days

      if (this.options.showMinorLabels && showMinorGrid) {
        var label = this._repaintMinorText(x, labelMinor, orientation, className);
        label.style.width = width + 'px'; // set width to prevent overflow
      }

      if (isMajor && this.options.showMajorLabels) {
        if (x > 0) {
          if (xFirstMajorLabel == undefined) {
            xFirstMajorLabel = x;
          }
          label = this._repaintMajorText(x, step.getLabelMajor(), orientation, className);
        }
        line = this._repaintMajorLine(x, width, orientation, className);
      } else {
        // minor line
        if (showMinorGrid) {
          line = this._repaintMinorLine(x, width, orientation, className);
        } else {
          if (line) {
            // adjust the width of the previous grid
            line.style.width = parseInt(line.style.width) + width + 'px';
          }
        }
      }
    }

    if (count === MAX && !warnedForOverflow) {
      console.warn('Something is wrong with the Timeline scale. Limited drawing of grid lines to ' + MAX + ' lines.');
      warnedForOverflow = true;
    }

    // create a major label on the left when needed
    if (this.options.showMajorLabels) {
      var leftTime = this.body.util.toTime(0),
          leftText = step.getLabelMajor(leftTime),
          widthText = leftText.length * (this.props.majorCharWidth || 10) + 10; // upper bound estimation

      if (xFirstMajorLabel == undefined || widthText < xFirstMajorLabel) {
        this._repaintMajorText(0, leftText, orientation, className);
      }
    }

    // Cleanup leftover DOM elements from the redundant list
    util.forEach(this.dom.redundant, function (arr) {
      while (arr.length) {
        var elem = arr.pop();
        if (elem && elem.parentNode) {
          elem.parentNode.removeChild(elem);
        }
      }
    });
  };

  /**
   * Create a minor label for the axis at position x
   * @param {Number} x
   * @param {String} text
   * @param {String} orientation   "top" or "bottom" (default)
   * @param {String} className
   * @return {Element} Returns the HTML element of the created label
   * @private
   */
  TimeAxis.prototype._repaintMinorText = function (x, text, orientation, className) {
    // reuse redundant label
    var label = this.dom.redundant.minorTexts.shift();

    if (!label) {
      // create new label
      var content = document.createTextNode('');
      label = document.createElement('div');
      label.appendChild(content);
      this.dom.foreground.appendChild(label);
    }
    this.dom.minorTexts.push(label);

    label.childNodes[0].nodeValue = text;

    label.style.top = orientation == 'top' ? this.props.majorLabelHeight + 'px' : '0';

    if (this.options.rtl) {
      label.style.left = "";
      label.style.right = x + 'px';
    } else {
      label.style.left = x + 'px';
    };
    label.className = 'vis-text vis-minor ' + className;
    //label.title = title;  // TODO: this is a heavy operation

    return label;
  };

  /**
   * Create a Major label for the axis at position x
   * @param {Number} x
   * @param {String} text
   * @param {String} orientation   "top" or "bottom" (default)
   * @param {String} className
   * @return {Element} Returns the HTML element of the created label
   * @private
   */
  TimeAxis.prototype._repaintMajorText = function (x, text, orientation, className) {
    // reuse redundant label
    var label = this.dom.redundant.majorTexts.shift();

    if (!label) {
      // create label
      var content = document.createTextNode(text);
      label = document.createElement('div');
      label.appendChild(content);
      this.dom.foreground.appendChild(label);
    }
    this.dom.majorTexts.push(label);

    label.childNodes[0].nodeValue = text;
    label.className = 'vis-text vis-major ' + className;
    //label.title = title; // TODO: this is a heavy operation

    label.style.top = orientation == 'top' ? '0' : this.props.minorLabelHeight + 'px';
    if (this.options.rtl) {
      label.style.left = "";
      label.style.right = x + 'px';
    } else {
      label.style.left = x + 'px';
    };

    return label;
  };

  /**
   * Create a minor line for the axis at position x
   * @param {Number} x
   * @param {Number} width
   * @param {String} orientation   "top" or "bottom" (default)
   * @param {String} className
   * @return {Element} Returns the created line
   * @private
   */
  TimeAxis.prototype._repaintMinorLine = function (x, width, orientation, className) {
    // reuse redundant line
    var line = this.dom.redundant.lines.shift();
    if (!line) {
      // create vertical line
      line = document.createElement('div');
      this.dom.background.appendChild(line);
    }
    this.dom.lines.push(line);

    var props = this.props;
    if (orientation == 'top') {
      line.style.top = props.majorLabelHeight + 'px';
    } else {
      line.style.top = this.body.domProps.top.height + 'px';
    }
    line.style.height = props.minorLineHeight + 'px';
    if (this.options.rtl) {
      line.style.left = "";
      line.style.right = x - props.minorLineWidth / 2 + 'px';
      line.className = 'vis-grid vis-vertical-rtl vis-minor ' + className;
    } else {
      line.style.left = x - props.minorLineWidth / 2 + 'px';
      line.className = 'vis-grid vis-vertical vis-minor ' + className;
    };
    line.style.width = width + 'px';

    return line;
  };

  /**
   * Create a Major line for the axis at position x
   * @param {Number} x
   * @param {Number} width
   * @param {String} orientation   "top" or "bottom" (default)
   * @param {String} className
   * @return {Element} Returns the created line
   * @private
   */
  TimeAxis.prototype._repaintMajorLine = function (x, width, orientation, className) {
    // reuse redundant line
    var line = this.dom.redundant.lines.shift();
    if (!line) {
      // create vertical line
      line = document.createElement('div');
      this.dom.background.appendChild(line);
    }
    this.dom.lines.push(line);

    var props = this.props;
    if (orientation == 'top') {
      line.style.top = '0';
    } else {
      line.style.top = this.body.domProps.top.height + 'px';
    }

    if (this.options.rtl) {
      line.style.left = "";
      line.style.right = x - props.majorLineWidth / 2 + 'px';
      line.className = 'vis-grid vis-vertical-rtl vis-major ' + className;
    } else {
      line.style.left = x - props.majorLineWidth / 2 + 'px';
      line.className = 'vis-grid vis-vertical vis-major ' + className;
    }

    line.style.height = props.majorLineHeight + 'px';
    line.style.width = width + 'px';

    return line;
  };

  /**
   * Determine the size of text on the axis (both major and minor axis).
   * The size is calculated only once and then cached in this.props.
   * @private
   */
  TimeAxis.prototype._calculateCharSize = function () {
    // Note: We calculate char size with every redraw. Size may change, for
    // example when any of the timelines parents had display:none for example.

    // determine the char width and height on the minor axis
    if (!this.dom.measureCharMinor) {
      this.dom.measureCharMinor = document.createElement('DIV');
      this.dom.measureCharMinor.className = 'vis-text vis-minor vis-measure';
      this.dom.measureCharMinor.style.position = 'absolute';

      this.dom.measureCharMinor.appendChild(document.createTextNode('0'));
      this.dom.foreground.appendChild(this.dom.measureCharMinor);
    }
    this.props.minorCharHeight = this.dom.measureCharMinor.clientHeight;
    this.props.minorCharWidth = this.dom.measureCharMinor.clientWidth;

    // determine the char width and height on the major axis
    if (!this.dom.measureCharMajor) {
      this.dom.measureCharMajor = document.createElement('DIV');
      this.dom.measureCharMajor.className = 'vis-text vis-major vis-measure';
      this.dom.measureCharMajor.style.position = 'absolute';

      this.dom.measureCharMajor.appendChild(document.createTextNode('0'));
      this.dom.foreground.appendChild(this.dom.measureCharMajor);
    }
    this.props.majorCharHeight = this.dom.measureCharMajor.clientHeight;
    this.props.majorCharWidth = this.dom.measureCharMajor.clientWidth;
  };

  var warnedForOverflow = false;

  module.exports = TimeAxis;

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var keycharm = __webpack_require__(23);
  var Emitter = __webpack_require__(13);
  var Hammer = __webpack_require__(20);
  var util = __webpack_require__(1);

  /**
   * Turn an element into an clickToUse element.
   * When not active, the element has a transparent overlay. When the overlay is
   * clicked, the mode is changed to active.
   * When active, the element is displayed with a blue border around it, and
   * the interactive contents of the element can be used. When clicked outside
   * the element, the elements mode is changed to inactive.
   * @param {Element} container
   * @constructor
   */
  function Activator(container) {
    this.active = false;

    this.dom = {
      container: container
    };

    this.dom.overlay = document.createElement('div');
    this.dom.overlay.className = 'vis-overlay';

    this.dom.container.appendChild(this.dom.overlay);

    this.hammer = Hammer(this.dom.overlay);
    this.hammer.on('tap', this._onTapOverlay.bind(this));

    // block all touch events (except tap)
    var me = this;
    var events = ['tap', 'doubletap', 'press', 'pinch', 'pan', 'panstart', 'panmove', 'panend'];
    events.forEach(function (event) {
      me.hammer.on(event, function (event) {
        event.stopPropagation();
      });
    });

    // attach a click event to the window, in order to deactivate when clicking outside the timeline
    if (document && document.body) {
      this.onClick = function (event) {
        if (!_hasParent(event.target, container)) {
          me.deactivate();
        }
      };
      document.body.addEventListener('click', this.onClick);
    }

    if (this.keycharm !== undefined) {
      this.keycharm.destroy();
    }
    this.keycharm = keycharm();

    // keycharm listener only bounded when active)
    this.escListener = this.deactivate.bind(this);
  }

  // turn into an event emitter
  Emitter(Activator.prototype);

  // The currently active activator
  Activator.current = null;

  /**
   * Destroy the activator. Cleans up all created DOM and event listeners
   */
  Activator.prototype.destroy = function () {
    this.deactivate();

    // remove dom
    this.dom.overlay.parentNode.removeChild(this.dom.overlay);

    // remove global event listener
    if (this.onClick) {
      document.body.removeEventListener('click', this.onClick);
    }

    // cleanup hammer instances
    this.hammer.destroy();
    this.hammer = null;
    // FIXME: cleaning up hammer instances doesn't work (Timeline not removed from memory)
  };

  /**
   * Activate the element
   * Overlay is hidden, element is decorated with a blue shadow border
   */
  Activator.prototype.activate = function () {
    // we allow only one active activator at a time
    if (Activator.current) {
      Activator.current.deactivate();
    }
    Activator.current = this;

    this.active = true;
    this.dom.overlay.style.display = 'none';
    util.addClassName(this.dom.container, 'vis-active');

    this.emit('change');
    this.emit('activate');

    // ugly hack: bind ESC after emitting the events, as the Network rebinds all
    // keyboard events on a 'change' event
    this.keycharm.bind('esc', this.escListener);
  };

  /**
   * Deactivate the element
   * Overlay is displayed on top of the element
   */
  Activator.prototype.deactivate = function () {
    this.active = false;
    this.dom.overlay.style.display = '';
    util.removeClassName(this.dom.container, 'vis-active');
    this.keycharm.unbind('esc', this.escListener);

    this.emit('change');
    this.emit('deactivate');
  };

  /**
   * Handle a tap event: activate the container
   * @param event
   * @private
   */
  Activator.prototype._onTapOverlay = function (event) {
    // activate the container
    this.activate();
    event.stopPropagation();
  };

  /**
   * Test whether the element has the requested parent element somewhere in
   * its chain of parent nodes.
   * @param {HTMLElement} element
   * @param {HTMLElement} parent
   * @returns {boolean} Returns true when the parent is found somewhere in the
   *                    chain of parent nodes.
   * @private
   */
  function _hasParent(element, parent) {
    while (element) {
      if (element === parent) {
        return true;
      }
      element = element.parentNode;
    }
    return false;
  }

  module.exports = Activator;

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var Hammer = __webpack_require__(20);
  var util = __webpack_require__(1);
  var Component = __webpack_require__(31);
  var moment = __webpack_require__(2);
  var locales = __webpack_require__(47);

  /**
   * A custom time bar
   * @param {{range: Range, dom: Object}} body
   * @param {Object} [options]        Available parameters:
   *                                  {number | string} id
   *                                  {string} locales
   *                                  {string} locale
   * @constructor CustomTime
   * @extends Component
   */

  function CustomTime(body, options) {
    this.body = body;

    // default options
    this.defaultOptions = {
      moment: moment,
      locales: locales,
      locale: 'en',
      id: undefined,
      title: undefined
    };
    this.options = util.extend({}, this.defaultOptions);

    if (options && options.time) {
      this.customTime = options.time;
    } else {
      this.customTime = new Date();
    }

    this.eventParams = {}; // stores state parameters while dragging the bar

    this.setOptions(options);

    // create the DOM
    this._create();
  }

  CustomTime.prototype = new Component();

  /**
   * Set options for the component. Options will be merged in current options.
   * @param {Object} options  Available parameters:
   *                                  {number | string} id
   *                                  {string} locales
   *                                  {string} locale
   */
  CustomTime.prototype.setOptions = function (options) {
    if (options) {
      // copy all options that we know
      util.selectiveExtend(['moment', 'locale', 'locales', 'id'], this.options, options);
    }
  };

  /**
   * Create the DOM for the custom time
   * @private
   */
  CustomTime.prototype._create = function () {
    var bar = document.createElement('div');
    bar['custom-time'] = this;
    bar.className = 'vis-custom-time ' + (this.options.id || '');
    bar.style.position = 'absolute';
    bar.style.top = '0px';
    bar.style.height = '100%';
    this.bar = bar;

    var drag = document.createElement('div');
    drag.style.position = 'relative';
    drag.style.top = '0px';
    drag.style.left = '-10px';
    drag.style.height = '100%';
    drag.style.width = '20px';
    bar.appendChild(drag);

    // attach event listeners
    this.hammer = new Hammer(drag);
    this.hammer.on('panstart', this._onDragStart.bind(this));
    this.hammer.on('panmove', this._onDrag.bind(this));
    this.hammer.on('panend', this._onDragEnd.bind(this));
    this.hammer.get('pan').set({ threshold: 5, direction: Hammer.DIRECTION_HORIZONTAL });
  };

  /**
   * Destroy the CustomTime bar
   */
  CustomTime.prototype.destroy = function () {
    this.hide();

    this.hammer.destroy();
    this.hammer = null;

    this.body = null;
  };

  /**
   * Repaint the component
   * @return {boolean} Returns true if the component is resized
   */
  CustomTime.prototype.redraw = function () {
    var parent = this.body.dom.backgroundVertical;
    if (this.bar.parentNode != parent) {
      // attach to the dom
      if (this.bar.parentNode) {
        this.bar.parentNode.removeChild(this.bar);
      }
      parent.appendChild(this.bar);
    }

    var x = this.body.util.toScreen(this.customTime);

    var locale = this.options.locales[this.options.locale];
    if (!locale) {
      if (!this.warned) {
        console.log('WARNING: options.locales[\'' + this.options.locale + '\'] not found. See http://visjs.org/docs/timeline.html#Localization');
        this.warned = true;
      }
      locale = this.options.locales['en']; // fall back on english when not available
    }

    var title = this.options.title;
    // To hide the title completely use empty string ''.
    if (title === undefined) {
      title = locale.time + ': ' + this.options.moment(this.customTime).format('dddd, MMMM Do YYYY, H:mm:ss');
      title = title.charAt(0).toUpperCase() + title.substring(1);
    }

    this.bar.style.left = x + 'px';
    this.bar.title = title;

    return false;
  };

  /**
   * Remove the CustomTime from the DOM
   */
  CustomTime.prototype.hide = function () {
    // remove the line from the DOM
    if (this.bar.parentNode) {
      this.bar.parentNode.removeChild(this.bar);
    }
  };

  /**
   * Set custom time.
   * @param {Date | number | string} time
   */
  CustomTime.prototype.setCustomTime = function (time) {
    this.customTime = util.convert(time, 'Date');
    this.redraw();
  };

  /**
   * Retrieve the current custom time.
   * @return {Date} customTime
   */
  CustomTime.prototype.getCustomTime = function () {
    return new Date(this.customTime.valueOf());
  };

  /**
    * Set custom title.
    * @param {Date | number | string} title
    */
  CustomTime.prototype.setCustomTitle = function (title) {
    this.options.title = title;
  };

  /**
   * Start moving horizontally
   * @param {Event} event
   * @private
   */
  CustomTime.prototype._onDragStart = function (event) {
    this.eventParams.dragging = true;
    this.eventParams.customTime = this.customTime;

    event.stopPropagation();
  };

  /**
   * Perform moving operating.
   * @param {Event} event
   * @private
   */
  CustomTime.prototype._onDrag = function (event) {
    if (!this.eventParams.dragging) return;

    var x = this.body.util.toScreen(this.eventParams.customTime) + event.deltaX;
    var time = this.body.util.toTime(x);

    this.setCustomTime(time);

    // fire a timechange event
    this.body.emitter.emit('timechange', {
      id: this.options.id,
      time: new Date(this.customTime.valueOf())
    });

    event.stopPropagation();
  };

  /**
   * Stop moving operating.
   * @param {Event} event
   * @private
   */
  CustomTime.prototype._onDragEnd = function (event) {
    if (!this.eventParams.dragging) return;

    // fire a timechanged event
    this.body.emitter.emit('timechanged', {
      id: this.options.id,
      time: new Date(this.customTime.valueOf())
    });

    event.stopPropagation();
  };

  /**
   * Find a custom time from an event target:
   * searches for the attribute 'custom-time' in the event target's element tree
   * @param {Event} event
   * @return {CustomTime | null} customTime
   */
  CustomTime.customTimeFromTarget = function (event) {
    var target = event.target;
    while (target) {
      if (target.hasOwnProperty('custom-time')) {
        return target['custom-time'];
      }
      target = target.parentNode;
    }

    return null;
  };

  module.exports = CustomTime;

/***/ },
/* 47 */
/***/ function(module, exports) {

  'use strict';

  // English
  exports['en'] = {
    current: 'current',
    time: 'time'
  };
  exports['en_EN'] = exports['en'];
  exports['en_US'] = exports['en'];

  // Dutch
  exports['nl'] = {
    current: 'huidige',
    time: 'tijd'
  };
  exports['nl_NL'] = exports['nl'];
  exports['nl_BE'] = exports['nl'];

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var util = __webpack_require__(1);
  var Component = __webpack_require__(31);
  var moment = __webpack_require__(2);
  var locales = __webpack_require__(47);

  /**
   * A current time bar
   * @param {{range: Range, dom: Object, domProps: Object}} body
   * @param {Object} [options]        Available parameters:
   *                                  {Boolean} [showCurrentTime]
   * @constructor CurrentTime
   * @extends Component
   */
  function CurrentTime(body, options) {
    this.body = body;

    // default options
    this.defaultOptions = {
      rtl: false,
      showCurrentTime: true,

      moment: moment,
      locales: locales,
      locale: 'en'
    };
    this.options = util.extend({}, this.defaultOptions);
    this.offset = 0;

    this._create();

    this.setOptions(options);
  }

  CurrentTime.prototype = new Component();

  /**
   * Create the HTML DOM for the current time bar
   * @private
   */
  CurrentTime.prototype._create = function () {
    var bar = document.createElement('div');
    bar.className = 'vis-current-time';
    bar.style.position = 'absolute';
    bar.style.top = '0px';
    bar.style.height = '100%';

    this.bar = bar;
  };

  /**
   * Destroy the CurrentTime bar
   */
  CurrentTime.prototype.destroy = function () {
    this.options.showCurrentTime = false;
    this.redraw(); // will remove the bar from the DOM and stop refreshing

    this.body = null;
  };

  /**
   * Set options for the component. Options will be merged in current options.
   * @param {Object} options  Available parameters:
   *                          {boolean} [showCurrentTime]
   */
  CurrentTime.prototype.setOptions = function (options) {
    if (options) {
      // copy all options that we know
      util.selectiveExtend(['rtl', 'showCurrentTime', 'moment', 'locale', 'locales'], this.options, options);
    }
  };

  /**
   * Repaint the component
   * @return {boolean} Returns true if the component is resized
   */
  CurrentTime.prototype.redraw = function () {
    if (this.options.showCurrentTime) {
      var parent = this.body.dom.backgroundVertical;
      if (this.bar.parentNode != parent) {
        // attach to the dom
        if (this.bar.parentNode) {
          this.bar.parentNode.removeChild(this.bar);
        }
        parent.appendChild(this.bar);

        this.start();
      }

      var now = this.options.moment(new Date().valueOf() + this.offset);
      var x = this.body.util.toScreen(now);

      var locale = this.options.locales[this.options.locale];
      if (!locale) {
        if (!this.warned) {
          console.log('WARNING: options.locales[\'' + this.options.locale + '\'] not found. See http://visjs.org/docs/timeline/#Localization');
          this.warned = true;
        }
        locale = this.options.locales['en']; // fall back on english when not available
      }
      var title = locale.current + ' ' + locale.time + ': ' + now.format('dddd, MMMM Do YYYY, H:mm:ss');
      title = title.charAt(0).toUpperCase() + title.substring(1);

      if (this.options.rtl) {
        this.bar.style.right = x + 'px';
      } else {
        this.bar.style.left = x + 'px';
      }
      this.bar.title = title;
    } else {
      // remove the line from the DOM
      if (this.bar.parentNode) {
        this.bar.parentNode.removeChild(this.bar);
      }
      this.stop();
    }

    return false;
  };

  /**
   * Start auto refreshing the current time bar
   */
  CurrentTime.prototype.start = function () {
    var me = this;

    function update() {
      me.stop();

      // determine interval to refresh
      var scale = me.body.range.conversion(me.body.domProps.center.width).scale;
      var interval = 1 / scale / 10;
      if (interval < 30) interval = 30;
      if (interval > 1000) interval = 1000;

      me.redraw();
      me.body.emitter.emit('currentTimeTick');

      // start a renderTimer to adjust for the new time
      me.currentTimeTimer = setTimeout(update, interval);
    }

    update();
  };

  /**
   * Stop auto refreshing the current time bar
   */
  CurrentTime.prototype.stop = function () {
    if (this.currentTimeTimer !== undefined) {
      clearTimeout(this.currentTimeTimer);
      delete this.currentTimeTimer;
    }
  };

  /**
   * Set a current time. This can be used for example to ensure that a client's
   * time is synchronized with a shared server time.
   * @param {Date | String | Number} time     A Date, unix timestamp, or
   *                                          ISO date string.
   */
  CurrentTime.prototype.setCurrentTime = function (time) {
    var t = util.convert(time, 'Date').valueOf();
    var now = new Date().valueOf();
    this.offset = t - now;
    this.redraw();
  };

  /**
   * Get the current time.
   * @return {Date} Returns the current time.
   */
  CurrentTime.prototype.getCurrentTime = function () {
    return new Date(new Date().valueOf() + this.offset);
  };

  module.exports = CurrentTime;

/***/ },
/* 49 */
/***/ function(module, exports) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  /**
   * This object contains all possible options. It will check if the types are correct, if required if the option is one
   * of the allowed values.
   *
   * __any__ means that the name of the property does not matter.
   * __type__ is a required field for all objects and contains the allowed types of all objects
   */
  var string = 'string';
  var boolean = 'boolean';
  var number = 'number';
  var array = 'array';
  var date = 'date';
  var object = 'object'; // should only be in a __type__ property
  var dom = 'dom';
  var moment = 'moment';
  var any = 'any';

  var allOptions = {
    configure: {
      enabled: { boolean: boolean },
      filter: { boolean: boolean, 'function': 'function' },
      container: { dom: dom },
      __type__: { object: object, boolean: boolean, 'function': 'function' }
    },

    //globals :
    align: { string: string },
    rtl: { boolean: boolean, 'undefined': 'undefined' },
    autoResize: { boolean: boolean },
    throttleRedraw: { number: number },
    clickToUse: { boolean: boolean },
    dataAttributes: { string: string, array: array },
    editable: {
      add: { boolean: boolean, 'undefined': 'undefined' },
      remove: { boolean: boolean, 'undefined': 'undefined' },
      updateGroup: { boolean: boolean, 'undefined': 'undefined' },
      updateTime: { boolean: boolean, 'undefined': 'undefined' },
      __type__: { boolean: boolean, object: object }
    },
    end: { number: number, date: date, string: string, moment: moment },
    format: {
      minorLabels: {
        millisecond: { string: string, 'undefined': 'undefined' },
        second: { string: string, 'undefined': 'undefined' },
        minute: { string: string, 'undefined': 'undefined' },
        hour: { string: string, 'undefined': 'undefined' },
        weekday: { string: string, 'undefined': 'undefined' },
        day: { string: string, 'undefined': 'undefined' },
        month: { string: string, 'undefined': 'undefined' },
        year: { string: string, 'undefined': 'undefined' },
        __type__: { object: object }
      },
      majorLabels: {
        millisecond: { string: string, 'undefined': 'undefined' },
        second: { string: string, 'undefined': 'undefined' },
        minute: { string: string, 'undefined': 'undefined' },
        hour: { string: string, 'undefined': 'undefined' },
        weekday: { string: string, 'undefined': 'undefined' },
        day: { string: string, 'undefined': 'undefined' },
        month: { string: string, 'undefined': 'undefined' },
        year: { string: string, 'undefined': 'undefined' },
        __type__: { object: object }
      },
      __type__: { object: object }
    },
    moment: { 'function': 'function' },
    groupOrder: { string: string, 'function': 'function' },
    groupEditable: {
      add: { boolean: boolean, 'undefined': 'undefined' },
      remove: { boolean: boolean, 'undefined': 'undefined' },
      order: { boolean: boolean, 'undefined': 'undefined' },
      __type__: { boolean: boolean, object: object }
    },
    groupOrderSwap: { 'function': 'function' },
    height: { string: string, number: number },
    hiddenDates: {
      start: { date: date, number: number, string: string, moment: moment },
      end: { date: date, number: number, string: string, moment: moment },
      repeat: { string: string },
      __type__: { object: object, array: array }
    },
    itemsAlwaysDraggable: { boolean: boolean },
    locale: { string: string },
    locales: {
      __any__: { any: any },
      __type__: { object: object }
    },
    margin: {
      axis: { number: number },
      item: {
        horizontal: { number: number, 'undefined': 'undefined' },
        vertical: { number: number, 'undefined': 'undefined' },
        __type__: { object: object, number: number }
      },
      __type__: { object: object, number: number }
    },
    max: { date: date, number: number, string: string, moment: moment },
    maxHeight: { number: number, string: string },
    maxMinorChars: { number: number },
    min: { date: date, number: number, string: string, moment: moment },
    minHeight: { number: number, string: string },
    moveable: { boolean: boolean },
    multiselect: { boolean: boolean },
    multiselectPerGroup: { boolean: boolean },
    onAdd: { 'function': 'function' },
    onUpdate: { 'function': 'function' },
    onMove: { 'function': 'function' },
    onMoving: { 'function': 'function' },
    onRemove: { 'function': 'function' },
    onAddGroup: { 'function': 'function' },
    onMoveGroup: { 'function': 'function' },
    onRemoveGroup: { 'function': 'function' },
    order: { 'function': 'function' },
    orientation: {
      axis: { string: string, 'undefined': 'undefined' },
      item: { string: string, 'undefined': 'undefined' },
      __type__: { string: string, object: object }
    },
    selectable: { boolean: boolean },
    showCurrentTime: { boolean: boolean },
    showMajorLabels: { boolean: boolean },
    showMinorLabels: { boolean: boolean },
    stack: { boolean: boolean },
    snap: { 'function': 'function', 'null': 'null' },
    start: { date: date, number: number, string: string, moment: moment },
    template: { 'function': 'function' },
    groupTemplate: { 'function': 'function' },
    timeAxis: {
      scale: { string: string, 'undefined': 'undefined' },
      step: { number: number, 'undefined': 'undefined' },
      __type__: { object: object }
    },
    type: { string: string },
    width: { string: string, number: number },
    zoomable: { boolean: boolean },
    zoomKey: { string: ['ctrlKey', 'altKey', 'metaKey', ''] },
    zoomMax: { number: number },
    zoomMin: { number: number },

    __type__: { object: object }
  };

  var configureOptions = {
    global: {
      align: ['center', 'left', 'right'],
      direction: false,
      autoResize: true,
      throttleRedraw: [10, 0, 1000, 10],
      clickToUse: false,
      // dataAttributes: ['all'], // FIXME: can be 'all' or string[]
      editable: {
        add: false,
        remove: false,
        updateGroup: false,
        updateTime: false
      },
      end: '',
      format: {
        minorLabels: {
          millisecond: 'SSS',
          second: 's',
          minute: 'HH:mm',
          hour: 'HH:mm',
          weekday: 'ddd D',
          day: 'D',
          month: 'MMM',
          year: 'YYYY'
        },
        majorLabels: {
          millisecond: 'HH:mm:ss',
          second: 'D MMMM HH:mm',
          minute: 'ddd D MMMM',
          hour: 'ddd D MMMM',
          weekday: 'MMMM YYYY',
          day: 'MMMM YYYY',
          month: 'YYYY',
          year: ''
        }
      },

      //groupOrder: {string, 'function': 'function'},
      groupsDraggable: false,
      height: '',
      //hiddenDates: {object, array},
      locale: '',
      margin: {
        axis: [20, 0, 100, 1],
        item: {
          horizontal: [10, 0, 100, 1],
          vertical: [10, 0, 100, 1]
        }
      },
      max: '',
      maxHeight: '',
      maxMinorChars: [7, 0, 20, 1],
      min: '',
      minHeight: '',
      moveable: false,
      multiselect: false,
      multiselectPerGroup: false,
      //onAdd: {'function': 'function'},
      //onUpdate: {'function': 'function'},
      //onMove: {'function': 'function'},
      //onMoving: {'function': 'function'},
      //onRename: {'function': 'function'},
      //order: {'function': 'function'},
      orientation: {
        axis: ['both', 'bottom', 'top'],
        item: ['bottom', 'top']
      },
      selectable: true,
      showCurrentTime: false,
      showMajorLabels: true,
      showMinorLabels: true,
      stack: true,
      //snap: {'function': 'function', nada},
      start: '',
      //template: {'function': 'function'},
      //timeAxis: {
      //  scale: ['millisecond', 'second', 'minute', 'hour', 'weekday', 'day', 'month', 'year'],
      //  step: [1, 1, 10, 1]
      //},
      type: ['box', 'point', 'range', 'background'],
      width: '100%',
      zoomable: true,
      zoomKey: ['ctrlKey', 'altKey', 'metaKey', ''],
      zoomMax: [315360000000000, 10, 315360000000000, 1],
      zoomMin: [10, 10, 315360000000000, 1]
    }
  };

  exports.allOptions = allOptions;
  exports.configureOptions = configureOptions;

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var _Configurator = __webpack_require__(26);

  var _Configurator2 = _interopRequireDefault(_Configurator);

  var _Validator = __webpack_require__(29);

  var _Validator2 = _interopRequireDefault(_Validator);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var Emitter = __webpack_require__(13);
  var Hammer = __webpack_require__(20);
  var moment = __webpack_require__(2);
  var util = __webpack_require__(1);
  var DataSet = __webpack_require__(9);
  var DataView = __webpack_require__(11);
  var Range = __webpack_require__(30);
  var Core = __webpack_require__(33);
  var TimeAxis = __webpack_require__(44);
  var CurrentTime = __webpack_require__(48);
  var CustomTime = __webpack_require__(46);
  var LineGraph = __webpack_require__(51);

  var printStyle = __webpack_require__(29).printStyle;
  var allOptions = __webpack_require__(59).allOptions;
  var configureOptions = __webpack_require__(59).configureOptions;

  /**
   * Create a timeline visualization
   * @param {HTMLElement} container
   * @param {vis.DataSet | Array} [items]
   * @param {Object} [options]  See Graph2d.setOptions for the available options.
   * @constructor
   * @extends Core
   */
  function Graph2d(container, items, groups, options) {
    // if the third element is options, the forth is groups (optionally);
    if (!(Array.isArray(groups) || groups instanceof DataSet || groups instanceof DataView) && groups instanceof Object) {
      var forthArgument = options;
      options = groups;
      groups = forthArgument;
    }

    var me = this;
    this.defaultOptions = {
      start: null,
      end: null,

      autoResize: true,

      orientation: {
        axis: 'bottom', // axis orientation: 'bottom', 'top', or 'both'
        item: 'bottom' // not relevant for Graph2d
      },

      moment: moment,

      width: null,
      height: null,
      maxHeight: null,
      minHeight: null
    };
    this.options = util.deepExtend({}, this.defaultOptions);

    // Create the DOM, props, and emitter
    this._create(container);

    // all components listed here will be repainted automatically
    this.components = [];

    this.body = {
      dom: this.dom,
      domProps: this.props,
      emitter: {
        on: this.on.bind(this),
        off: this.off.bind(this),
        emit: this.emit.bind(this)
      },
      hiddenDates: [],
      util: {
        toScreen: me._toScreen.bind(me),
        toGlobalScreen: me._toGlobalScreen.bind(me), // this refers to the root.width
        toTime: me._toTime.bind(me),
        toGlobalTime: me._toGlobalTime.bind(me)
      }
    };

    // range
    this.range = new Range(this.body);
    this.components.push(this.range);
    this.body.range = this.range;

    // time axis
    this.timeAxis = new TimeAxis(this.body);
    this.components.push(this.timeAxis);
    //this.body.util.snap = this.timeAxis.snap.bind(this.timeAxis);

    // current time bar
    this.currentTime = new CurrentTime(this.body);
    this.components.push(this.currentTime);

    // item set
    this.linegraph = new LineGraph(this.body);

    this.components.push(this.linegraph);

    this.itemsData = null; // DataSet
    this.groupsData = null; // DataSet

    this.on('tap', function (event) {
      me.emit('click', me.getEventProperties(event));
    });
    this.on('doubletap', function (event) {
      me.emit('doubleClick', me.getEventProperties(event));
    });
    this.dom.root.oncontextmenu = function (event) {
      me.emit('contextmenu', me.getEventProperties(event));
    };

    // apply options
    if (options) {
      this.setOptions(options);
    }

    // IMPORTANT: THIS HAPPENS BEFORE SET ITEMS!
    if (groups) {
      this.setGroups(groups);
    }

    // create itemset
    if (items) {
      this.setItems(items);
    }

    // draw for the first time
    this._redraw();
  }

  // Extend the functionality from Core
  Graph2d.prototype = new Core();

  Graph2d.prototype.setOptions = function (options) {
    // validate options
    var errorFound = _Validator2.default.validate(options, allOptions);
    if (errorFound === true) {
      console.log('%cErrors have been found in the supplied options object.', printStyle);
    }

    Core.prototype.setOptions.call(this, options);
  };

  /**
   * Set items
   * @param {vis.DataSet | Array | null} items
   */
  Graph2d.prototype.setItems = function (items) {
    var initialLoad = this.itemsData == null;

    // convert to type DataSet when needed
    var newDataSet;
    if (!items) {
      newDataSet = null;
    } else if (items instanceof DataSet || items instanceof DataView) {
      newDataSet = items;
    } else {
      // turn an array into a dataset
      newDataSet = new DataSet(items, {
        type: {
          start: 'Date',
          end: 'Date'
        }
      });
    }

    // set items
    this.itemsData = newDataSet;
    this.linegraph && this.linegraph.setItems(newDataSet);

    if (initialLoad) {
      if (this.options.start != undefined || this.options.end != undefined) {
        var start = this.options.start != undefined ? this.options.start : null;
        var end = this.options.end != undefined ? this.options.end : null;
        this.setWindow(start, end, { animation: false });
      } else {
        this.fit({ animation: false });
      }
    }
  };

  /**
   * Set groups
   * @param {vis.DataSet | Array} groups
   */
  Graph2d.prototype.setGroups = function (groups) {
    // convert to type DataSet when needed
    var newDataSet;
    if (!groups) {
      newDataSet = null;
    } else if (groups instanceof DataSet || groups instanceof DataView) {
      newDataSet = groups;
    } else {
      // turn an array into a dataset
      newDataSet = new DataSet(groups);
    }

    this.groupsData = newDataSet;
    this.linegraph.setGroups(newDataSet);
  };

  /**
   * Returns an object containing an SVG element with the icon of the group (size determined by iconWidth and iconHeight), the label of the group (content) and the yAxisOrientation of the group (left or right).
   * @param groupId
   * @param width
   * @param height
   */
  Graph2d.prototype.getLegend = function (groupId, width, height) {
    if (width === undefined) {
      width = 15;
    }
    if (height === undefined) {
      height = 15;
    }
    if (this.linegraph.groups[groupId] !== undefined) {
      return this.linegraph.groups[groupId].getLegend(width, height);
    } else {
      return "cannot find group:'" + groupId + "'";
    }
  };

  /**
   * This checks if the visible option of the supplied group (by ID) is true or false.
   * @param groupId
   * @returns {*}
   */
  Graph2d.prototype.isGroupVisible = function (groupId) {
    if (this.linegraph.groups[groupId] !== undefined) {
      return this.linegraph.groups[groupId].visible && (this.linegraph.options.groups.visibility[groupId] === undefined || this.linegraph.options.groups.visibility[groupId] == true);
    } else {
      return false;
    }
  };

  /**
   * Get the data range of the item set.
   * @returns {{min: Date, max: Date}} range  A range with a start and end Date.
   *                                          When no minimum is found, min==null
   *                                          When no maximum is found, max==null
   */
  Graph2d.prototype.getDataRange = function () {
    var min = null;
    var max = null;

    // calculate min from start filed
    for (var groupId in this.linegraph.groups) {
      if (this.linegraph.groups.hasOwnProperty(groupId)) {
        if (this.linegraph.groups[groupId].visible == true) {
          for (var i = 0; i < this.linegraph.groups[groupId].itemsData.length; i++) {
            var item = this.linegraph.groups[groupId].itemsData[i];
            var value = util.convert(item.x, 'Date').valueOf();
            min = min == null ? value : min > value ? value : min;
            max = max == null ? value : max < value ? value : max;
          }
        }
      }
    }

    return {
      min: min != null ? new Date(min) : null,
      max: max != null ? new Date(max) : null
    };
  };

  /**
   * Generate Timeline related information from an event
   * @param {Event} event
   * @return {Object} An object with related information, like on which area
   *                  The event happened, whether clicked on an item, etc.
   */
  Graph2d.prototype.getEventProperties = function (event) {
    var clientX = event.center ? event.center.x : event.clientX;
    var clientY = event.center ? event.center.y : event.clientY;
    var x = clientX - util.getAbsoluteLeft(this.dom.centerContainer);
    var y = clientY - util.getAbsoluteTop(this.dom.centerContainer);
    var time = this._toTime(x);

    var customTime = CustomTime.customTimeFromTarget(event);

    var element = util.getTarget(event);
    var what = null;
    if (util.hasParent(element, this.timeAxis.dom.foreground)) {
      what = 'axis';
    } else if (this.timeAxis2 && util.hasParent(element, this.timeAxis2.dom.foreground)) {
      what = 'axis';
    } else if (util.hasParent(element, this.linegraph.yAxisLeft.dom.frame)) {
      what = 'data-axis';
    } else if (util.hasParent(element, this.linegraph.yAxisRight.dom.frame)) {
      what = 'data-axis';
    } else if (util.hasParent(element, this.linegraph.legendLeft.dom.frame)) {
      what = 'legend';
    } else if (util.hasParent(element, this.linegraph.legendRight.dom.frame)) {
      what = 'legend';
    } else if (customTime != null) {
      what = 'custom-time';
    } else if (util.hasParent(element, this.currentTime.bar)) {
      what = 'current-time';
    } else if (util.hasParent(element, this.dom.center)) {
      what = 'background';
    }

    var value = [];
    var yAxisLeft = this.linegraph.yAxisLeft;
    var yAxisRight = this.linegraph.yAxisRight;
    if (!yAxisLeft.hidden) {
      value.push(yAxisLeft.screenToValue(y));
    }
    if (!yAxisRight.hidden) {
      value.push(yAxisRight.screenToValue(y));
    }

    return {
      event: event,
      what: what,
      pageX: event.srcEvent ? event.srcEvent.pageX : event.pageX,
      pageY: event.srcEvent ? event.srcEvent.pageY : event.pageY,
      x: x,
      y: y,
      time: time,
      value: value
    };
  };

  /**
   * Load a configurator
   * @return {Object}
   * @private
   */
  Graph2d.prototype._createConfigurator = function () {
    return new _Configurator2.default(this, this.dom.container, configureOptions);
  };

  module.exports = Graph2d;

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

  var util = __webpack_require__(1);
  var DOMutil = __webpack_require__(8);
  var DataSet = __webpack_require__(9);
  var DataView = __webpack_require__(11);
  var Component = __webpack_require__(31);
  var DataAxis = __webpack_require__(52);
  var GraphGroup = __webpack_require__(54);
  var Legend = __webpack_require__(58);
  var Bars = __webpack_require__(55);
  var Lines = __webpack_require__(57);
  var Points = __webpack_require__(56);

  var UNGROUPED = '__ungrouped__'; // reserved group id for ungrouped items

  /**
   * This is the constructor of the LineGraph. It requires a Timeline body and options.
   *
   * @param body
   * @param options
   * @constructor
   */
  function LineGraph(body, options) {
    this.id = util.randomUUID();
    this.body = body;

    this.defaultOptions = {
      yAxisOrientation: 'left',
      defaultGroup: 'default',
      sort: true,
      sampling: true,
      stack: false,
      graphHeight: '400px',
      shaded: {
        enabled: false,
        orientation: 'bottom' // top, bottom, zero
      },
      style: 'line', // line, bar
      barChart: {
        width: 50,
        sideBySide: false,
        align: 'center' // left, center, right
      },
      interpolation: {
        enabled: true,
        parametrization: 'centripetal', // uniform (alpha = 0.0), chordal (alpha = 1.0), centripetal (alpha = 0.5)
        alpha: 0.5
      },
      drawPoints: {
        enabled: true,
        size: 6,
        style: 'square' // square, circle
      },
      dataAxis: {}, //Defaults are done on DataAxis level
      legend: {}, //Defaults are done on Legend level
      groups: {
        visibility: {}
      }
    };

    // options is shared by this lineGraph and all its items
    this.options = util.extend({}, this.defaultOptions);
    this.dom = {};
    this.props = {};
    this.hammer = null;
    this.groups = {};
    this.abortedGraphUpdate = false;
    this.updateSVGheight = false;
    this.updateSVGheightOnResize = false;
    this.forceGraphUpdate = true;

    var me = this;
    this.itemsData = null; // DataSet
    this.groupsData = null; // DataSet

    // listeners for the DataSet of the items
    this.itemListeners = {
      'add': function add(event, params, senderId) {
        me._onAdd(params.items);
      },
      'update': function update(event, params, senderId) {
        me._onUpdate(params.items);
      },
      'remove': function remove(event, params, senderId) {
        me._onRemove(params.items);
      }
    };

    // listeners for the DataSet of the groups
    this.groupListeners = {
      'add': function add(event, params, senderId) {
        me._onAddGroups(params.items);
      },
      'update': function update(event, params, senderId) {
        me._onUpdateGroups(params.items);
      },
      'remove': function remove(event, params, senderId) {
        me._onRemoveGroups(params.items);
      }
    };

    this.items = {}; // object with an Item for every data item
    this.selection = []; // list with the ids of all selected nodes
    this.lastStart = this.body.range.start;
    this.touchParams = {}; // stores properties while dragging

    this.svgElements = {};
    this.setOptions(options);
    this.groupsUsingDefaultStyles = [0];
    this.body.emitter.on('rangechanged', function () {
      me.lastStart = me.body.range.start;
      me.svg.style.left = util.option.asSize(-me.props.width);

      me.forceGraphUpdate = true;
      //Is this local redraw necessary? (Core also does a change event!)
      me.redraw.call(me);
    });

    // create the HTML DOM
    this._create();
    this.framework = { svg: this.svg, svgElements: this.svgElements, options: this.options, groups: this.groups };
  }

  LineGraph.prototype = new Component();

  /**
   * Create the HTML DOM for the ItemSet
   */
  LineGraph.prototype._create = function () {
    var frame = document.createElement('div');
    frame.className = 'vis-line-graph';
    this.dom.frame = frame;

    // create svg element for graph drawing.
    this.svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    this.svg.style.position = 'relative';
    this.svg.style.height = ('' + this.options.graphHeight).replace('px', '') + 'px';
    this.svg.style.display = 'block';
    frame.appendChild(this.svg);

    // data axis
    this.options.dataAxis.orientation = 'left';
    this.yAxisLeft = new DataAxis(this.body, this.options.dataAxis, this.svg, this.options.groups);

    this.options.dataAxis.orientation = 'right';
    this.yAxisRight = new DataAxis(this.body, this.options.dataAxis, this.svg, this.options.groups);
    delete this.options.dataAxis.orientation;

    // legends
    this.legendLeft = new Legend(this.body, this.options.legend, 'left', this.options.groups);
    this.legendRight = new Legend(this.body, this.options.legend, 'right', this.options.groups);

    this.show();
  };

  /**
   * set the options of the LineGraph. the mergeOptions is used for subObjects that have an enabled element.
   * @param {object} options
   */
  LineGraph.prototype.setOptions = function (options) {
    if (options) {
      var fields = ['sampling', 'defaultGroup', 'stack', 'height', 'graphHeight', 'yAxisOrientation', 'style', 'barChart', 'dataAxis', 'sort', 'groups'];
      if (options.graphHeight === undefined && options.height !== undefined) {
        this.updateSVGheight = true;
        this.updateSVGheightOnResize = true;
      } else if (this.body.domProps.centerContainer.height !== undefined && options.graphHeight !== undefined) {
        if (parseInt((options.graphHeight + '').replace("px", '')) < this.body.domProps.centerContainer.height) {
          this.updateSVGheight = true;
        }
      }
      util.selectiveDeepExtend(fields, this.options, options);
      util.mergeOptions(this.options, options, 'interpolation');
      util.mergeOptions(this.options, options, 'drawPoints');
      util.mergeOptions(this.options, options, 'shaded');
      util.mergeOptions(this.options, options, 'legend');

      if (options.interpolation) {
        if (_typeof(options.interpolation) == 'object') {
          if (options.interpolation.parametrization) {
            if (options.interpolation.parametrization == 'uniform') {
              this.options.interpolation.alpha = 0;
            } else if (options.interpolation.parametrization == 'chordal') {
              this.options.interpolation.alpha = 1.0;
            } else {
              this.options.interpolation.parametrization = 'centripetal';
              this.options.interpolation.alpha = 0.5;
            }
          }
        }
      }

      if (this.yAxisLeft) {
        if (options.dataAxis !== undefined) {
          this.yAxisLeft.setOptions(this.options.dataAxis);
          this.yAxisRight.setOptions(this.options.dataAxis);
        }
      }

      if (this.legendLeft) {
        if (options.legend !== undefined) {
          this.legendLeft.setOptions(this.options.legend);
          this.legendRight.setOptions(this.options.legend);
        }
      }

      if (this.groups.hasOwnProperty(UNGROUPED)) {
        this.groups[UNGROUPED].setOptions(options);
      }
    }

    // this is used to redraw the graph if the visibility of the groups is changed.
    if (this.dom.frame) {
      //not on initial run?
      this.forceGraphUpdate = true;
      this.body.emitter.emit("_change", { queue: true });
    }
  };

  /**
   * Hide the component from the DOM
   */
  LineGraph.prototype.hide = function () {
    // remove the frame containing the items
    if (this.dom.frame.parentNode) {
      this.dom.frame.parentNode.removeChild(this.dom.frame);
    }
  };

  /**
   * Show the component in the DOM (when not already visible).
   * @return {Boolean} changed
   */
  LineGraph.prototype.show = function () {
    // show frame containing the items
    if (!this.dom.frame.parentNode) {
      this.body.dom.center.appendChild(this.dom.frame);
    }
  };

  /**
   * Set items
   * @param {vis.DataSet | null} items
   */
  LineGraph.prototype.setItems = function (items) {
    var me = this,
        ids,
        oldItemsData = this.itemsData;

    // replace the dataset
    if (!items) {
      this.itemsData = null;
    } else if (items instanceof DataSet || items instanceof DataView) {
      this.itemsData = items;
    } else {
      throw new TypeError('Data must be an instance of DataSet or DataView');
    }

    if (oldItemsData) {
      // unsubscribe from old dataset
      util.forEach(this.itemListeners, function (callback, event) {
        oldItemsData.off(event, callback);
      });

      // remove all drawn items
      ids = oldItemsData.getIds();
      this._onRemove(ids);
    }

    if (this.itemsData) {
      // subscribe to new dataset
      var id = this.id;
      util.forEach(this.itemListeners, function (callback, event) {
        me.itemsData.on(event, callback, id);
      });

      // add all new items
      ids = this.itemsData.getIds();
      this._onAdd(ids);
    }
  };

  /**
   * Set groups
   * @param {vis.DataSet} groups
   */
  LineGraph.prototype.setGroups = function (groups) {
    var me = this;
    var ids;

    // unsubscribe from current dataset
    if (this.groupsData) {
      util.forEach(this.groupListeners, function (callback, event) {
        me.groupsData.off(event, callback);
      });

      // remove all drawn groups
      ids = this.groupsData.getIds();
      this.groupsData = null;
      for (var i = 0; i < ids.length; i++) {
        this._removeGroup(ids[i]);
      }
    }

    // replace the dataset
    if (!groups) {
      this.groupsData = null;
    } else if (groups instanceof DataSet || groups instanceof DataView) {
      this.groupsData = groups;
    } else {
      throw new TypeError('Data must be an instance of DataSet or DataView');
    }

    if (this.groupsData) {
      // subscribe to new dataset
      var id = this.id;
      util.forEach(this.groupListeners, function (callback, event) {
        me.groupsData.on(event, callback, id);
      });

      // draw all ms
      ids = this.groupsData.getIds();
      this._onAddGroups(ids);
    }
  };

  LineGraph.prototype._onUpdate = function (ids) {
    this._updateAllGroupData();
  };
  LineGraph.prototype._onAdd = function (ids) {
    this._onUpdate(ids);
  };
  LineGraph.prototype._onRemove = function (ids) {
    this._onUpdate(ids);
  };
  LineGraph.prototype._onUpdateGroups = function (groupIds) {
    this._updateAllGroupData();
  };
  LineGraph.prototype._onAddGroups = function (groupIds) {
    this._onUpdateGroups(groupIds);
  };

  /**
   * this cleans the group out off the legends and the dataaxis, updates the ungrouped and updates the graph
   * @param {Array} groupIds
   * @private
   */
  LineGraph.prototype._onRemoveGroups = function (groupIds) {
    for (var i = 0; i < groupIds.length; i++) {
      this._removeGroup(groupIds[i]);
    }
    this.forceGraphUpdate = true;
    this.body.emitter.emit("_change", { queue: true });
  };

  /**
   * this cleans the group out off the legends and the dataaxis
   * @param groupId
   * @private
   */
  LineGraph.prototype._removeGroup = function (groupId) {
    if (this.groups.hasOwnProperty(groupId)) {
      if (this.groups[groupId].options.yAxisOrientation == 'right') {
        this.yAxisRight.removeGroup(groupId);
        this.legendRight.removeGroup(groupId);
        this.legendRight.redraw();
      } else {
        this.yAxisLeft.removeGroup(groupId);
        this.legendLeft.removeGroup(groupId);
        this.legendLeft.redraw();
      }
      delete this.groups[groupId];
    }
  };

  /**
   * update a group object with the group dataset entree
   *
   * @param group
   * @param groupId
   * @private
   */
  LineGraph.prototype._updateGroup = function (group, groupId) {
    if (!this.groups.hasOwnProperty(groupId)) {
      this.groups[groupId] = new GraphGroup(group, groupId, this.options, this.groupsUsingDefaultStyles);
      if (this.groups[groupId].options.yAxisOrientation == 'right') {
        this.yAxisRight.addGroup(groupId, this.groups[groupId]);
        this.legendRight.addGroup(groupId, this.groups[groupId]);
      } else {
        this.yAxisLeft.addGroup(groupId, this.groups[groupId]);
        this.legendLeft.addGroup(groupId, this.groups[groupId]);
      }
    } else {
      this.groups[groupId].update(group);
      if (this.groups[groupId].options.yAxisOrientation == 'right') {
        this.yAxisRight.updateGroup(groupId, this.groups[groupId]);
        this.legendRight.updateGroup(groupId, this.groups[groupId]);
        //If yAxisOrientation changed, clean out the group from the other axis.
        this.yAxisLeft.removeGroup(groupId);
        this.legendLeft.removeGroup(groupId);
      } else {
        this.yAxisLeft.updateGroup(groupId, this.groups[groupId]);
        this.legendLeft.updateGroup(groupId, this.groups[groupId]);
        //If yAxisOrientation changed, clean out the group from the other axis.
        this.yAxisRight.removeGroup(groupId);
        this.legendRight.removeGroup(groupId);
      }
    }
    this.legendLeft.redraw();
    this.legendRight.redraw();
  };

  /**
   * this updates all groups, it is used when there is an update the the itemset.
   *
   * @private
   */
  LineGraph.prototype._updateAllGroupData = function () {
    if (this.itemsData != null) {
      var groupsContent = {};
      var items = this.itemsData.get();
      //pre-Determine array sizes, for more efficient memory claim
      var groupCounts = {};
      for (var i = 0; i < items.length; i++) {
        var item = items[i];
        var groupId = item.group;
        if (groupId === null || groupId === undefined) {
          groupId = UNGROUPED;
        }
        groupCounts.hasOwnProperty(groupId) ? groupCounts[groupId]++ : groupCounts[groupId] = 1;
      }
      //Now insert data into the arrays.
      for (var i = 0; i < items.length; i++) {
        var item = items[i];
        var groupId = item.group;
        if (groupId === null || groupId === undefined) {
          groupId = UNGROUPED;
        }
        if (!groupsContent.hasOwnProperty(groupId)) {
          groupsContent[groupId] = new Array(groupCounts[groupId]);
        }
        //Copy data (because of unmodifiable DataView input.
        var extended = util.bridgeObject(item);
        extended.x = util.convert(item.x, 'Date');
        extended.orginalY = item.y; //real Y
        extended.y = Number(item.y);

        var index = groupsContent[groupId].length - groupCounts[groupId]--;
        groupsContent[groupId][index] = extended;
      }

      //Make sure all groups are present, to allow removal of old groups
      for (var groupId in this.groups) {
        if (this.groups.hasOwnProperty(groupId)) {
          if (!groupsContent.hasOwnProperty(groupId)) {
            groupsContent[groupId] = new Array(0);
          }
        }
      }

      //Update legendas, style and axis
      for (var groupId in groupsContent) {
        if (groupsContent.hasOwnProperty(groupId)) {
          if (groupsContent[groupId].length == 0) {
            if (this.groups.hasOwnProperty(groupId)) {
              this._removeGroup(groupId);
            }
          } else {
            var group = undefined;
            if (this.groupsData != undefined) {
              group = this.groupsData.get(groupId);
            }
            if (group == undefined) {
              group = { id: groupId, content: this.options.defaultGroup + groupId };
            }
            this._updateGroup(group, groupId);
            this.groups[groupId].setItems(groupsContent[groupId]);
          }
        }
      }
      this.forceGraphUpdate = true;
      this.body.emitter.emit("_change", { queue: true });
    }
  };

  /**
   * Redraw the component, mandatory function
   * @return {boolean} Returns true if the component is resized
   */
  LineGraph.prototype.redraw = function () {
    var resized = false;

    // calculate actual size and position
    this.props.width = this.dom.frame.offsetWidth;
    this.props.height = this.body.domProps.centerContainer.height - this.body.domProps.border.top - this.body.domProps.border.bottom;

    // check if this component is resized
    resized = this._isResized() || resized;

    // check whether zoomed (in that case we need to re-stack everything)
    var visibleInterval = this.body.range.end - this.body.range.start;
    var zoomed = visibleInterval != this.lastVisibleInterval;
    this.lastVisibleInterval = visibleInterval;

    // the svg element is three times as big as the width, this allows for fully dragging left and right
    // without reloading the graph. the controls for this are bound to events in the constructor
    if (resized == true) {
      this.svg.style.width = util.option.asSize(3 * this.props.width);
      this.svg.style.left = util.option.asSize(-this.props.width);

      // if the height of the graph is set as proportional, change the height of the svg
      if ((this.options.height + '').indexOf("%") != -1 || this.updateSVGheightOnResize == true) {
        this.updateSVGheight = true;
      }
    }

    // update the height of the graph on each redraw of the graph.
    if (this.updateSVGheight == true) {
      if (this.options.graphHeight != this.props.height + 'px') {
        this.options.graphHeight = this.props.height + 'px';
        this.svg.style.height = this.props.height + 'px';
      }
      this.updateSVGheight = false;
    } else {
      this.svg.style.height = ('' + this.options.graphHeight).replace('px', '') + 'px';
    }

    // zoomed is here to ensure that animations are shown correctly.
    if (resized == true || zoomed == true || this.abortedGraphUpdate == true || this.forceGraphUpdate == true) {
      resized = this._updateGraph() || resized;
      this.forceGraphUpdate = false;
    } else {
      // move the whole svg while dragging
      if (this.lastStart != 0) {
        var offset = this.body.range.start - this.lastStart;
        var range = this.body.range.end - this.body.range.start;
        if (this.props.width != 0) {
          var rangePerPixelInv = this.props.width / range;
          var xOffset = offset * rangePerPixelInv;
          this.svg.style.left = -this.props.width - xOffset + 'px';
        }
      }
    }
    this.legendLeft.redraw();
    this.legendRight.redraw();
    return resized;
  };

  LineGraph.prototype._getSortedGroupIds = function () {
    // getting group Ids
    var grouplist = [];
    for (var groupId in this.groups) {
      if (this.groups.hasOwnProperty(groupId)) {
        var group = this.groups[groupId];
        if (group.visible == true && (this.options.groups.visibility[groupId] === undefined || this.options.groups.visibility[groupId] == true)) {
          grouplist.push({ id: groupId, zIndex: group.options.zIndex });
        }
      }
    }
    util.insertSort(grouplist, function (a, b) {
      var az = a.zIndex;
      var bz = b.zIndex;
      if (az === undefined) az = 0;
      if (bz === undefined) bz = 0;
      return az == bz ? 0 : az < bz ? -1 : 1;
    });
    var groupIds = new Array(grouplist.length);
    for (var i = 0; i < grouplist.length; i++) {
      groupIds[i] = grouplist[i].id;
    }
    return groupIds;
  };

  /**
   * Update and redraw the graph.
   *
   */
  LineGraph.prototype._updateGraph = function () {
    // reset the svg elements
    DOMutil.prepareElements(this.svgElements);
    if (this.props.width != 0 && this.itemsData != null) {
      var group, i;
      var groupRanges = {};
      var changeCalled = false;
      // this is the range of the SVG canvas
      var minDate = this.body.util.toGlobalTime(-this.body.domProps.root.width);
      var maxDate = this.body.util.toGlobalTime(2 * this.body.domProps.root.width);

      // getting group Ids
      var groupIds = this._getSortedGroupIds();
      if (groupIds.length > 0) {
        var groupsData = {};

        // fill groups data, this only loads the data we require based on the timewindow
        this._getRelevantData(groupIds, groupsData, minDate, maxDate);

        // apply sampling, if disabled, it will pass through this function.
        this._applySampling(groupIds, groupsData);

        // we transform the X coordinates to detect collisions
        for (i = 0; i < groupIds.length; i++) {
          this._convertXcoordinates(groupsData[groupIds[i]]);
        }

        // now all needed data has been collected we start the processing.
        this._getYRanges(groupIds, groupsData, groupRanges);

        // update the Y axis first, we use this data to draw at the correct Y points
        changeCalled = this._updateYAxis(groupIds, groupRanges);

        //  at changeCalled, abort this update cycle as the graph needs another update with new Width input from the Redraw container.
        //  Cleanup SVG elements on abort.
        if (changeCalled == true) {
          DOMutil.cleanupElements(this.svgElements);
          this.abortedGraphUpdate = true;
          return true;
        }
        this.abortedGraphUpdate = false;

        // With the yAxis scaled correctly, use this to get the Y values of the points.
        var below = undefined;
        for (i = 0; i < groupIds.length; i++) {
          group = this.groups[groupIds[i]];
          if (this.options.stack === true && this.options.style === 'line') {
            if (group.options.excludeFromStacking == undefined || !group.options.excludeFromStacking) {
              if (below != undefined) {
                this._stack(groupsData[group.id], groupsData[below.id]);
                if (group.options.shaded.enabled == true && group.options.shaded.orientation !== "group") {
                  if (group.options.shaded.orientation == "top" && below.options.shaded.orientation !== "group") {
                    below.options.shaded.orientation = "group";
                    below.options.shaded.groupId = group.id;
                  } else {
                    group.options.shaded.orientation = "group";
                    group.options.shaded.groupId = below.id;
                  }
                }
              }
              below = group;
            }
          }
          this._convertYcoordinates(groupsData[groupIds[i]], group);
        }

        //Precalculate paths and draw shading if appropriate. This will make sure the shading is always behind any lines.
        var paths = {};
        for (i = 0; i < groupIds.length; i++) {
          group = this.groups[groupIds[i]];
          if (group.options.style === 'line' && group.options.shaded.enabled == true) {
            var dataset = groupsData[groupIds[i]];
            if (dataset == null || dataset.length == 0) {
              continue;
            }
            if (!paths.hasOwnProperty(groupIds[i])) {
              paths[groupIds[i]] = Lines.calcPath(dataset, group);
            }
            if (group.options.shaded.orientation === "group") {
              var subGroupId = group.options.shaded.groupId;
              if (groupIds.indexOf(subGroupId) === -1) {
                console.log(group.id + ": Unknown shading group target given:" + subGroupId);
                continue;
              }
              if (!paths.hasOwnProperty(subGroupId)) {
                paths[subGroupId] = Lines.calcPath(groupsData[subGroupId], this.groups[subGroupId]);
              }
              Lines.drawShading(paths[groupIds[i]], group, paths[subGroupId], this.framework);
            } else {
              Lines.drawShading(paths[groupIds[i]], group, undefined, this.framework);
            }
          }
        }

        // draw the groups, calculating paths if still necessary.
        Bars.draw(groupIds, groupsData, this.framework);
        for (i = 0; i < groupIds.length; i++) {
          group = this.groups[groupIds[i]];
          if (groupsData[groupIds[i]].length > 0) {
            switch (group.options.style) {
              case "line":
                if (!paths.hasOwnProperty(groupIds[i])) {
                  paths[groupIds[i]] = Lines.calcPath(groupsData[groupIds[i]], group);
                }
                Lines.draw(paths[groupIds[i]], group, this.framework);
              //explicit no break;
              case "point":
              //explicit no break;
              case "points":
                if (group.options.style == "point" || group.options.style == "points" || group.options.drawPoints.enabled == true) {
                  Points.draw(groupsData[groupIds[i]], group, this.framework);
                }
                break;
              case "bar":
              // bar needs to be drawn enmasse
              //explicit no break
              default:
              //do nothing...
            }
          }
        }
      }
    }

    // cleanup unused svg elements
    DOMutil.cleanupElements(this.svgElements);
    return false;
  };

  LineGraph.prototype._stack = function (data, subData) {
    var index, dx, dy, subPrevPoint, subNextPoint;
    index = 0;
    // for each data point we look for a matching on in the set below
    for (var j = 0; j < data.length; j++) {
      subPrevPoint = undefined;
      subNextPoint = undefined;
      // we look for time matches or a before-after point
      for (var k = index; k < subData.length; k++) {
        // if times match exactly
        if (subData[k].x === data[j].x) {
          subPrevPoint = subData[k];
          subNextPoint = subData[k];
          index = k;
          break;
        } else if (subData[k].x > data[j].x) {
          // overshoot
          subNextPoint = subData[k];
          if (k == 0) {
            subPrevPoint = subNextPoint;
          } else {
            subPrevPoint = subData[k - 1];
          }
          index = k;
          break;
        }
      }
      // in case the last data point has been used, we assume it stays like this.
      if (subNextPoint === undefined) {
        subPrevPoint = subData[subData.length - 1];
        subNextPoint = subData[subData.length - 1];
      }
      // linear interpolation
      dx = subNextPoint.x - subPrevPoint.x;
      dy = subNextPoint.y - subPrevPoint.y;
      if (dx == 0) {
        data[j].y = data[j].orginalY + subNextPoint.y;
      } else {
        data[j].y = data[j].orginalY + dy / dx * (data[j].x - subPrevPoint.x) + subPrevPoint.y; // ax + b where b is data[j].y
      }
    }
  };

  /**
   * first select and preprocess the data from the datasets.
   * the groups have their preselection of data, we now loop over this data to see
   * what data we need to draw. Sorted data is much faster.
   * more optimization is possible by doing the sampling before and using the binary search
   * to find the end date to determine the increment.
   *
   * @param {array}  groupIds
   * @param {object} groupsData
   * @param {date}   minDate
   * @param {date}   maxDate
   * @private
   */
  LineGraph.prototype._getRelevantData = function (groupIds, groupsData, minDate, maxDate) {
    var group, i, j, item;
    if (groupIds.length > 0) {
      for (i = 0; i < groupIds.length; i++) {
        group = this.groups[groupIds[i]];
        var itemsData = group.getItems();
        // optimization for sorted data
        if (group.options.sort == true) {
          var dateComparator = function dateComparator(a, b) {
            return a.getTime() == b.getTime() ? 0 : a < b ? -1 : 1;
          };
          var first = Math.max(0, util.binarySearchValue(itemsData, minDate, 'x', 'before', dateComparator));
          var last = Math.min(itemsData.length, util.binarySearchValue(itemsData, maxDate, 'x', 'after', dateComparator) + 1);
          if (last <= 0) {
            last = itemsData.length;
          }
          var dataContainer = new Array(last - first);
          for (j = first; j < last; j++) {
            item = group.itemsData[j];
            dataContainer[j - first] = item;
          }
          groupsData[groupIds[i]] = dataContainer;
        } else {
          // If unsorted data, all data is relevant, just returning entire structure
          groupsData[groupIds[i]] = group.itemsData;
        }
      }
    }
  };

  /**
   *
   * @param groupIds
   * @param groupsData
   * @private
   */
  LineGraph.prototype._applySampling = function (groupIds, groupsData) {
    var group;
    if (groupIds.length > 0) {
      for (var i = 0; i < groupIds.length; i++) {
        group = this.groups[groupIds[i]];
        if (group.options.sampling == true) {
          var dataContainer = groupsData[groupIds[i]];
          if (dataContainer.length > 0) {
            var increment = 1;
            var amountOfPoints = dataContainer.length;

            // the global screen is used because changing the width of the yAxis may affect the increment, resulting in an endless loop
            // of width changing of the yAxis.
            var xDistance = this.body.util.toGlobalScreen(dataContainer[dataContainer.length - 1].x) - this.body.util.toGlobalScreen(dataContainer[0].x);
            var pointsPerPixel = amountOfPoints / xDistance;
            increment = Math.min(Math.ceil(0.2 * amountOfPoints), Math.max(1, Math.round(pointsPerPixel)));

            var sampledData = new Array(amountOfPoints);
            for (var j = 0; j < amountOfPoints; j += increment) {
              var idx = Math.round(j / increment);
              sampledData[idx] = dataContainer[j];
            }
            groupsData[groupIds[i]] = sampledData.splice(0, Math.round(amountOfPoints / increment));
          }
        }
      }
    }
  };

  /**
   *
   *
   * @param {array}  groupIds
   * @param {object} groupsData
   * @param {object} groupRanges  | this is being filled here
   * @private
   */
  LineGraph.prototype._getYRanges = function (groupIds, groupsData, groupRanges) {
    var groupData, group, i;
    var combinedDataLeft = [];
    var combinedDataRight = [];
    var options;
    if (groupIds.length > 0) {
      for (i = 0; i < groupIds.length; i++) {
        groupData = groupsData[groupIds[i]];
        options = this.groups[groupIds[i]].options;
        if (groupData.length > 0) {
          group = this.groups[groupIds[i]];
          // if bar graphs are stacked, their range need to be handled differently and accumulated over all groups.
          if (options.stack === true && options.style === 'bar') {
            if (options.yAxisOrientation === 'left') {
              combinedDataLeft = combinedDataLeft.concat(group.getItems());
            } else {
              combinedDataRight = combinedDataRight.concat(group.getItems());
            }
          } else {
            groupRanges[groupIds[i]] = group.getYRange(groupData, groupIds[i]);
          }
        }
      }

      // if bar graphs are stacked, their range need to be handled differently and accumulated over all groups.
      Bars.getStackedYRange(combinedDataLeft, groupRanges, groupIds, '__barStackLeft', 'left');
      Bars.getStackedYRange(combinedDataRight, groupRanges, groupIds, '__barStackRight', 'right');
    }
  };

  /**
   * this sets the Y ranges for the Y axis. It also determines which of the axis should be shown or hidden.
   * @param {Array} groupIds
   * @param {Object} groupRanges
   * @private
   */
  LineGraph.prototype._updateYAxis = function (groupIds, groupRanges) {
    var resized = false;
    var yAxisLeftUsed = false;
    var yAxisRightUsed = false;
    var minLeft = 1e9,
        minRight = 1e9,
        maxLeft = -1e9,
        maxRight = -1e9,
        minVal,
        maxVal;
    // if groups are present
    if (groupIds.length > 0) {
      // this is here to make sure that if there are no items in the axis but there are groups, that there is no infinite draw/redraw loop.
      for (var i = 0; i < groupIds.length; i++) {
        var group = this.groups[groupIds[i]];
        if (group && group.options.yAxisOrientation != 'right') {
          yAxisLeftUsed = true;
          minLeft = 1e9;
          maxLeft = -1e9;
        } else if (group && group.options.yAxisOrientation) {
          yAxisRightUsed = true;
          minRight = 1e9;
          maxRight = -1e9;
        }
      }

      // if there are items:
      for (var i = 0; i < groupIds.length; i++) {
        if (groupRanges.hasOwnProperty(groupIds[i])) {
          if (groupRanges[groupIds[i]].ignore !== true) {
            minVal = groupRanges[groupIds[i]].min;
            maxVal = groupRanges[groupIds[i]].max;

            if (groupRanges[groupIds[i]].yAxisOrientation != 'right') {
              yAxisLeftUsed = true;
              minLeft = minLeft > minVal ? minVal : minLeft;
              maxLeft = maxLeft < maxVal ? maxVal : maxLeft;
            } else {
              yAxisRightUsed = true;
              minRight = minRight > minVal ? minVal : minRight;
              maxRight = maxRight < maxVal ? maxVal : maxRight;
            }
          }
        }
      }

      if (yAxisLeftUsed == true) {
        this.yAxisLeft.setRange(minLeft, maxLeft);
      }
      if (yAxisRightUsed == true) {
        this.yAxisRight.setRange(minRight, maxRight);
      }
    }
    resized = this._toggleAxisVisiblity(yAxisLeftUsed, this.yAxisLeft) || resized;
    resized = this._toggleAxisVisiblity(yAxisRightUsed, this.yAxisRight) || resized;

    if (yAxisRightUsed == true && yAxisLeftUsed == true) {
      this.yAxisLeft.drawIcons = true;
      this.yAxisRight.drawIcons = true;
    } else {
      this.yAxisLeft.drawIcons = false;
      this.yAxisRight.drawIcons = false;
    }
    this.yAxisRight.master = !yAxisLeftUsed;
    this.yAxisRight.masterAxis = this.yAxisLeft;

    if (this.yAxisRight.master == false) {
      if (yAxisRightUsed == true) {
        this.yAxisLeft.lineOffset = this.yAxisRight.width;
      } else {
        this.yAxisLeft.lineOffset = 0;
      }

      resized = this.yAxisLeft.redraw() || resized;
      resized = this.yAxisRight.redraw() || resized;
    } else {
      resized = this.yAxisRight.redraw() || resized;
    }

    // clean the accumulated lists
    var tempGroups = ['__barStackLeft', '__barStackRight', '__lineStackLeft', '__lineStackRight'];
    for (var i = 0; i < tempGroups.length; i++) {
      if (groupIds.indexOf(tempGroups[i]) != -1) {
        groupIds.splice(groupIds.indexOf(tempGroups[i]), 1);
      }
    }

    return resized;
  };

  /**
   * This shows or hides the Y axis if needed. If there is a change, the changed event is emitted by the updateYAxis function
   *
   * @param {boolean} axisUsed
   * @returns {boolean}
   * @private
   * @param axis
   */
  LineGraph.prototype._toggleAxisVisiblity = function (axisUsed, axis) {
    var changed = false;
    if (axisUsed == false) {
      if (axis.dom.frame.parentNode && axis.hidden == false) {
        axis.hide();
        changed = true;
      }
    } else {
      if (!axis.dom.frame.parentNode && axis.hidden == true) {
        axis.show();
        changed = true;
      }
    }
    return changed;
  };

  /**
   * This uses the DataAxis object to generate the correct X coordinate on the SVG window. It uses the
   * util function toScreen to get the x coordinate from the timestamp. It also pre-filters the data and get the minMax ranges for
   * the yAxis.
   *
   * @param datapoints
   * @returns {Array}
   * @private
   */
  LineGraph.prototype._convertXcoordinates = function (datapoints) {
    var toScreen = this.body.util.toScreen;
    for (var i = 0; i < datapoints.length; i++) {
      datapoints[i].screen_x = toScreen(datapoints[i].x) + this.props.width;
      datapoints[i].screen_y = datapoints[i].y; //starting point for range calculations
    }
  };

  /**
   * This uses the DataAxis object to generate the correct X coordinate on the SVG window. It uses the
   * util function toScreen to get the x coordinate from the timestamp. It also pre-filters the data and get the minMax ranges for
   * the yAxis.
   *
   * @param datapoints
   * @param group
   * @returns {Array}
   * @private
   */
  LineGraph.prototype._convertYcoordinates = function (datapoints, group) {
    var axis = this.yAxisLeft;
    var svgHeight = Number(this.svg.style.height.replace('px', ''));
    if (group.options.yAxisOrientation == 'right') {
      axis = this.yAxisRight;
    }
    for (var i = 0; i < datapoints.length; i++) {
      datapoints[i].screen_y = Math.round(axis.convertValue(datapoints[i].y));
    }
    group.setZeroPosition(Math.min(svgHeight, axis.convertValue(0)));
  };

  module.exports = LineGraph;

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var util = __webpack_require__(1);
  var DOMutil = __webpack_require__(8);
  var Component = __webpack_require__(31);
  var DataScale = __webpack_require__(53);
  /**
   * A horizontal time axis
   * @param {Object} [options]        See DataAxis.setOptions for the available
   *                                  options.
   * @constructor DataAxis
   * @extends Component
   * @param body
   */
  function DataAxis(body, options, svg, linegraphOptions) {
    this.id = util.randomUUID();
    this.body = body;

    this.defaultOptions = {
      orientation: 'left', // supported: 'left', 'right'
      showMinorLabels: true,
      showMajorLabels: true,
      icons: false,
      majorLinesOffset: 7,
      minorLinesOffset: 4,
      labelOffsetX: 10,
      labelOffsetY: 2,
      iconWidth: 20,
      width: '40px',
      visible: true,
      alignZeros: true,
      left: {
        range: { min: undefined, max: undefined },
        format: function format(value) {
          return '' + parseFloat(value.toPrecision(3));
        },
        title: { text: undefined, style: undefined }
      },
      right: {
        range: { min: undefined, max: undefined },
        format: function format(value) {
          return '' + parseFloat(value.toPrecision(3));
        },
        title: { text: undefined, style: undefined }
      }
    };

    this.linegraphOptions = linegraphOptions;
    this.linegraphSVG = svg;
    this.props = {};
    this.DOMelements = { // dynamic elements
      lines: {},
      labels: {},
      title: {}
    };

    this.dom = {};
    this.scale = undefined;
    this.range = { start: 0, end: 0 };

    this.options = util.extend({}, this.defaultOptions);
    this.conversionFactor = 1;

    this.setOptions(options);
    this.width = Number(('' + this.options.width).replace("px", ""));
    this.minWidth = this.width;
    this.height = this.linegraphSVG.getBoundingClientRect().height;
    this.hidden = false;

    this.stepPixels = 25;
    this.zeroCrossing = -1;
    this.amountOfSteps = -1;

    this.lineOffset = 0;
    this.master = true;
    this.masterAxis = null;
    this.svgElements = {};
    this.iconsRemoved = false;

    this.groups = {};
    this.amountOfGroups = 0;

    // create the HTML DOM
    this._create();
    this.framework = { svg: this.svg, svgElements: this.svgElements, options: this.options, groups: this.groups };

    var me = this;
    this.body.emitter.on("verticalDrag", function () {
      me.dom.lineContainer.style.top = me.body.domProps.scrollTop + 'px';
    });
  }

  DataAxis.prototype = new Component();

  DataAxis.prototype.addGroup = function (label, graphOptions) {
    if (!this.groups.hasOwnProperty(label)) {
      this.groups[label] = graphOptions;
    }
    this.amountOfGroups += 1;
  };

  DataAxis.prototype.updateGroup = function (label, graphOptions) {
    if (!this.groups.hasOwnProperty(label)) {
      this.amountOfGroups += 1;
    }
    this.groups[label] = graphOptions;
  };

  DataAxis.prototype.removeGroup = function (label) {
    if (this.groups.hasOwnProperty(label)) {
      delete this.groups[label];
      this.amountOfGroups -= 1;
    }
  };

  DataAxis.prototype.setOptions = function (options) {
    if (options) {
      var redraw = false;
      if (this.options.orientation != options.orientation && options.orientation !== undefined) {
        redraw = true;
      }
      var fields = ['orientation', 'showMinorLabels', 'showMajorLabels', 'icons', 'majorLinesOffset', 'minorLinesOffset', 'labelOffsetX', 'labelOffsetY', 'iconWidth', 'width', 'visible', 'left', 'right', 'alignZeros'];
      util.selectiveDeepExtend(fields, this.options, options);

      this.minWidth = Number(('' + this.options.width).replace("px", ""));
      if (redraw === true && this.dom.frame) {
        this.hide();
        this.show();
      }
    }
  };

  /**
   * Create the HTML DOM for the DataAxis
   */
  DataAxis.prototype._create = function () {
    this.dom.frame = document.createElement('div');
    this.dom.frame.style.width = this.options.width;
    this.dom.frame.style.height = this.height;

    this.dom.lineContainer = document.createElement('div');
    this.dom.lineContainer.style.width = '100%';
    this.dom.lineContainer.style.height = this.height;
    this.dom.lineContainer.style.position = 'relative';

    // create svg element for graph drawing.
    this.svg = document.createElementNS('http://www.w3.org/2000/svg', "svg");
    this.svg.style.position = "absolute";
    this.svg.style.top = '0px';
    this.svg.style.height = '100%';
    this.svg.style.width = '100%';
    this.svg.style.display = "block";
    this.dom.frame.appendChild(this.svg);
  };

  DataAxis.prototype._redrawGroupIcons = function () {
    DOMutil.prepareElements(this.svgElements);

    var x;
    var iconWidth = this.options.iconWidth;
    var iconHeight = 15;
    var iconOffset = 4;
    var y = iconOffset + 0.5 * iconHeight;

    if (this.options.orientation === 'left') {
      x = iconOffset;
    } else {
      x = this.width - iconWidth - iconOffset;
    }

    var groupArray = Object.keys(this.groups);
    groupArray.sort(function (a, b) {
      return a < b ? -1 : 1;
    });

    for (var i = 0; i < groupArray.length; i++) {
      var groupId = groupArray[i];
      if (this.groups[groupId].visible === true && (this.linegraphOptions.visibility[groupId] === undefined || this.linegraphOptions.visibility[groupId] === true)) {
        this.groups[groupId].getLegend(iconWidth, iconHeight, this.framework, x, y);
        y += iconHeight + iconOffset;
      }
    }

    DOMutil.cleanupElements(this.svgElements);
    this.iconsRemoved = false;
  };

  DataAxis.prototype._cleanupIcons = function () {
    if (this.iconsRemoved === false) {
      DOMutil.prepareElements(this.svgElements);
      DOMutil.cleanupElements(this.svgElements);
      this.iconsRemoved = true;
    }
  };

  /**
   * Create the HTML DOM for the DataAxis
   */
  DataAxis.prototype.show = function () {
    this.hidden = false;
    if (!this.dom.frame.parentNode) {
      if (this.options.rtl) {
        this.body.dom.left.appendChild(this.dom.frame);
      } else {
        this.body.dom.left.appendChild(this.dom.frame);
      }
    }

    if (!this.dom.lineContainer.parentNode) {
      this.body.dom.backgroundHorizontal.appendChild(this.dom.lineContainer);
    }
  };

  /**
   * Create the HTML DOM for the DataAxis
   */
  DataAxis.prototype.hide = function () {
    this.hidden = true;
    if (this.dom.frame.parentNode) {
      this.dom.frame.parentNode.removeChild(this.dom.frame);
    }

    if (this.dom.lineContainer.parentNode) {
      this.dom.lineContainer.parentNode.removeChild(this.dom.lineContainer);
    }
  };

  /**
   * Set a range (start and end)
   * @param end
   * @param start
   * @param end
   */
  DataAxis.prototype.setRange = function (start, end) {
    this.range.start = start;
    this.range.end = end;
  };

  /**
   * Repaint the component
   * @return {boolean} Returns true if the component is resized
   */
  DataAxis.prototype.redraw = function () {
    var resized = false;
    var activeGroups = 0;

    // Make sure the line container adheres to the vertical scrolling.
    this.dom.lineContainer.style.top = this.body.domProps.scrollTop + 'px';

    for (var groupId in this.groups) {
      if (this.groups.hasOwnProperty(groupId)) {
        if (this.groups[groupId].visible === true && (this.linegraphOptions.visibility[groupId] === undefined || this.linegraphOptions.visibility[groupId] === true)) {
          activeGroups++;
        }
      }
    }
    if (this.amountOfGroups === 0 || activeGroups === 0) {
      this.hide();
    } else {
      this.show();
      this.height = Number(this.linegraphSVG.style.height.replace("px", ""));

      // svg offsetheight did not work in firefox and explorer...
      this.dom.lineContainer.style.height = this.height + 'px';
      this.width = this.options.visible === true ? Number(('' + this.options.width).replace("px", "")) : 0;

      var props = this.props;
      var frame = this.dom.frame;

      // update classname
      frame.className = 'vis-data-axis';

      // calculate character width and height
      this._calculateCharSize();

      var orientation = this.options.orientation;
      var showMinorLabels = this.options.showMinorLabels;
      var showMajorLabels = this.options.showMajorLabels;

      // determine the width and height of the elements for the axis
      props.minorLabelHeight = showMinorLabels ? props.minorCharHeight : 0;
      props.majorLabelHeight = showMajorLabels ? props.majorCharHeight : 0;

      props.minorLineWidth = this.body.dom.backgroundHorizontal.offsetWidth - this.lineOffset - this.width + 2 * this.options.minorLinesOffset;
      props.minorLineHeight = 1;
      props.majorLineWidth = this.body.dom.backgroundHorizontal.offsetWidth - this.lineOffset - this.width + 2 * this.options.majorLinesOffset;
      props.majorLineHeight = 1;

      //  take frame offline while updating (is almost twice as fast)
      if (orientation === 'left') {
        frame.style.top = '0';
        frame.style.left = '0';
        frame.style.bottom = '';
        frame.style.width = this.width + 'px';
        frame.style.height = this.height + "px";
        this.props.width = this.body.domProps.left.width;
        this.props.height = this.body.domProps.left.height;
      } else {
        // right
        frame.style.top = '';
        frame.style.bottom = '0';
        frame.style.left = '0';
        frame.style.width = this.width + 'px';
        frame.style.height = this.height + "px";
        this.props.width = this.body.domProps.right.width;
        this.props.height = this.body.domProps.right.height;
      }

      resized = this._redrawLabels();
      resized = this._isResized() || resized;

      if (this.options.icons === true) {
        this._redrawGroupIcons();
      } else {
        this._cleanupIcons();
      }

      this._redrawTitle(orientation);
    }
    return resized;
  };

  /**
   * Repaint major and minor text labels and vertical grid lines
   * @private
   */
  DataAxis.prototype._redrawLabels = function () {
    var _this = this;

    var resized = false;
    DOMutil.prepareElements(this.DOMelements.lines);
    DOMutil.prepareElements(this.DOMelements.labels);
    var orientation = this.options['orientation'];
    var customRange = this.options[orientation].range != undefined ? this.options[orientation].range : {};

    //Override range with manual options:
    var autoScaleEnd = true;
    if (customRange.max != undefined) {
      this.range.end = customRange.max;
      autoScaleEnd = false;
    }
    var autoScaleStart = true;
    if (customRange.min != undefined) {
      this.range.start = customRange.min;
      autoScaleStart = false;
    }

    this.scale = new DataScale(this.range.start, this.range.end, autoScaleStart, autoScaleEnd, this.dom.frame.offsetHeight, this.props.majorCharHeight, this.options.alignZeros, this.options[orientation].format);

    if (this.master === false && this.masterAxis != undefined) {
      this.scale.followScale(this.masterAxis.scale);
    }

    //Is updated in side-effect of _redrawLabel():
    this.maxLabelSize = 0;

    var lines = this.scale.getLines();
    lines.forEach(function (line) {
      var y = line.y;
      var isMajor = line.major;
      if (_this.options['showMinorLabels'] && isMajor === false) {
        _this._redrawLabel(y - 2, line.val, orientation, 'vis-y-axis vis-minor', _this.props.minorCharHeight);
      }
      if (isMajor) {
        if (y >= 0) {
          _this._redrawLabel(y - 2, line.val, orientation, 'vis-y-axis vis-major', _this.props.majorCharHeight);
        }
      }
      if (_this.master === true) {
        if (isMajor) {
          _this._redrawLine(y, orientation, 'vis-grid vis-horizontal vis-major', _this.options.majorLinesOffset, _this.props.majorLineWidth);
        } else {
          _this._redrawLine(y, orientation, 'vis-grid vis-horizontal vis-minor', _this.options.minorLinesOffset, _this.props.minorLineWidth);
        }
      }
    });

    // Note that title is rotated, so we're using the height, not width!
    var titleWidth = 0;
    if (this.options[orientation].title !== undefined && this.options[orientation].title.text !== undefined) {
      titleWidth = this.props.titleCharHeight;
    }
    var offset = this.options.icons === true ? Math.max(this.options.iconWidth, titleWidth) + this.options.labelOffsetX + 15 : titleWidth + this.options.labelOffsetX + 15;

    // this will resize the yAxis to accommodate the labels.
    if (this.maxLabelSize > this.width - offset && this.options.visible === true) {
      this.width = this.maxLabelSize + offset;
      this.options.width = this.width + "px";
      DOMutil.cleanupElements(this.DOMelements.lines);
      DOMutil.cleanupElements(this.DOMelements.labels);
      this.redraw();
      resized = true;
    }
    // this will resize the yAxis if it is too big for the labels.
    else if (this.maxLabelSize < this.width - offset && this.options.visible === true && this.width > this.minWidth) {
        this.width = Math.max(this.minWidth, this.maxLabelSize + offset);
        this.options.width = this.width + "px";
        DOMutil.cleanupElements(this.DOMelements.lines);
        DOMutil.cleanupElements(this.DOMelements.labels);
        this.redraw();
        resized = true;
      } else {
        DOMutil.cleanupElements(this.DOMelements.lines);
        DOMutil.cleanupElements(this.DOMelements.labels);
        resized = false;
      }

    return resized;
  };

  DataAxis.prototype.convertValue = function (value) {
    return this.scale.convertValue(value);
  };

  DataAxis.prototype.screenToValue = function (x) {
    return this.scale.screenToValue(x);
  };

  /**
   * Create a label for the axis at position x
   * @private
   * @param y
   * @param text
   * @param orientation
   * @param className
   * @param characterHeight
   */
  DataAxis.prototype._redrawLabel = function (y, text, orientation, className, characterHeight) {
    // reuse redundant label
    var label = DOMutil.getDOMElement('div', this.DOMelements.labels, this.dom.frame); //this.dom.redundant.labels.shift();
    label.className = className;
    label.innerHTML = text;
    if (orientation === 'left') {
      label.style.left = '-' + this.options.labelOffsetX + 'px';
      label.style.textAlign = "right";
    } else {
      label.style.right = '-' + this.options.labelOffsetX + 'px';
      label.style.textAlign = "left";
    }

    label.style.top = y - 0.5 * characterHeight + this.options.labelOffsetY + 'px';

    text += '';

    var largestWidth = Math.max(this.props.majorCharWidth, this.props.minorCharWidth);
    if (this.maxLabelSize < text.length * largestWidth) {
      this.maxLabelSize = text.length * largestWidth;
    }
  };

  /**
   * Create a minor line for the axis at position y
   * @param y
   * @param orientation
   * @param className
   * @param offset
   * @param width
   */
  DataAxis.prototype._redrawLine = function (y, orientation, className, offset, width) {
    if (this.master === true) {
      var line = DOMutil.getDOMElement('div', this.DOMelements.lines, this.dom.lineContainer); //this.dom.redundant.lines.shift();
      line.className = className;
      line.innerHTML = '';

      if (orientation === 'left') {
        line.style.left = this.width - offset + 'px';
      } else {
        line.style.right = this.width - offset + 'px';
      }

      line.style.width = width + 'px';
      line.style.top = y + 'px';
    }
  };

  /**
   * Create a title for the axis
   * @private
   * @param orientation
   */
  DataAxis.prototype._redrawTitle = function (orientation) {
    DOMutil.prepareElements(this.DOMelements.title);

    // Check if the title is defined for this axes
    if (this.options[orientation].title !== undefined && this.options[orientation].title.text !== undefined) {
      var title = DOMutil.getDOMElement('div', this.DOMelements.title, this.dom.frame);
      title.className = 'vis-y-axis vis-title vis-' + orientation;
      title.innerHTML = this.options[orientation].title.text;

      // Add style - if provided
      if (this.options[orientation].title.style !== undefined) {
        util.addCssText(title, this.options[orientation].title.style);
      }

      if (orientation === 'left') {
        title.style.left = this.props.titleCharHeight + 'px';
      } else {
        title.style.right = this.props.titleCharHeight + 'px';
      }

      title.style.width = this.height + 'px';
    }

    // we need to clean up in case we did not use all elements.
    DOMutil.cleanupElements(this.DOMelements.title);
  };

  /**
   * Determine the size of text on the axis (both major and minor axis).
   * The size is calculated only once and then cached in this.props.
   * @private
   */
  DataAxis.prototype._calculateCharSize = function () {
    // determine the char width and height on the minor axis
    if (!('minorCharHeight' in this.props)) {
      var textMinor = document.createTextNode('0');
      var measureCharMinor = document.createElement('div');
      measureCharMinor.className = 'vis-y-axis vis-minor vis-measure';
      measureCharMinor.appendChild(textMinor);
      this.dom.frame.appendChild(measureCharMinor);

      this.props.minorCharHeight = measureCharMinor.clientHeight;
      this.props.minorCharWidth = measureCharMinor.clientWidth;

      this.dom.frame.removeChild(measureCharMinor);
    }

    if (!('majorCharHeight' in this.props)) {
      var textMajor = document.createTextNode('0');
      var measureCharMajor = document.createElement('div');
      measureCharMajor.className = 'vis-y-axis vis-major vis-measure';
      measureCharMajor.appendChild(textMajor);
      this.dom.frame.appendChild(measureCharMajor);

      this.props.majorCharHeight = measureCharMajor.clientHeight;
      this.props.majorCharWidth = measureCharMajor.clientWidth;

      this.dom.frame.removeChild(measureCharMajor);
    }

    if (!('titleCharHeight' in this.props)) {
      var textTitle = document.createTextNode('0');
      var measureCharTitle = document.createElement('div');
      measureCharTitle.className = 'vis-y-axis vis-title vis-measure';
      measureCharTitle.appendChild(textTitle);
      this.dom.frame.appendChild(measureCharTitle);

      this.props.titleCharHeight = measureCharTitle.clientHeight;
      this.props.titleCharWidth = measureCharTitle.clientWidth;

      this.dom.frame.removeChild(measureCharTitle);
    }
  };

  module.exports = DataAxis;

/***/ },
/* 53 */
/***/ function(module, exports) {

  'use strict';

  /**
   * Created by ludo on 25-1-16.
   */

  function DataScale(start, end, autoScaleStart, autoScaleEnd, containerHeight, majorCharHeight) {
    var zeroAlign = arguments.length <= 6 || arguments[6] === undefined ? false : arguments[6];
    var formattingFunction = arguments.length <= 7 || arguments[7] === undefined ? false : arguments[7];

    this.majorSteps = [1, 2, 5, 10];
    this.minorSteps = [0.25, 0.5, 1, 2];
    this.customLines = null;

    this.containerHeight = containerHeight;
    this.majorCharHeight = majorCharHeight;
    this._start = start;
    this._end = end;

    this.scale = 1;
    this.minorStepIdx = -1;
    this.magnitudefactor = 1;
    this.determineScale();

    this.zeroAlign = zeroAlign;
    this.autoScaleStart = autoScaleStart;
    this.autoScaleEnd = autoScaleEnd;

    this.formattingFunction = formattingFunction;

    if (autoScaleStart || autoScaleEnd) {
      var me = this;
      var roundToMinor = function roundToMinor(value) {
        var rounded = value - value % (me.magnitudefactor * me.minorSteps[me.minorStepIdx]);
        if (value % (me.magnitudefactor * me.minorSteps[me.minorStepIdx]) > 0.5 * (me.magnitudefactor * me.minorSteps[me.minorStepIdx])) {
          return rounded + me.magnitudefactor * me.minorSteps[me.minorStepIdx];
        } else {
          return rounded;
        }
      };
      if (autoScaleStart) {
        this._start -= this.magnitudefactor * 2 * this.minorSteps[this.minorStepIdx];
        this._start = roundToMinor(this._start);
      }

      if (autoScaleEnd) {
        this._end += this.magnitudefactor * this.minorSteps[this.minorStepIdx];
        this._end = roundToMinor(this._end);
      }
      this.determineScale();
    }
  }

  DataScale.prototype.setCharHeight = function (majorCharHeight) {
    this.majorCharHeight = majorCharHeight;
  };

  DataScale.prototype.setHeight = function (containerHeight) {
    this.containerHeight = containerHeight;
  };

  DataScale.prototype.determineScale = function () {
    var range = this._end - this._start;
    this.scale = this.containerHeight / range;
    var minimumStepValue = this.majorCharHeight / this.scale;
    var orderOfMagnitude = range > 0 ? Math.round(Math.log(range) / Math.LN10) : 0;

    this.minorStepIdx = -1;
    this.magnitudefactor = Math.pow(10, orderOfMagnitude);

    var start = 0;
    if (orderOfMagnitude < 0) {
      start = orderOfMagnitude;
    }

    var solutionFound = false;
    for (var l = start; Math.abs(l) <= Math.abs(orderOfMagnitude); l++) {
      this.magnitudefactor = Math.pow(10, l);
      for (var j = 0; j < this.minorSteps.length; j++) {
        var stepSize = this.magnitudefactor * this.minorSteps[j];
        if (stepSize >= minimumStepValue) {
          solutionFound = true;
          this.minorStepIdx = j;
          break;
        }
      }
      if (solutionFound === true) {
        break;
      }
    }
  };

  DataScale.prototype.is_major = function (value) {
    return value % (this.magnitudefactor * this.majorSteps[this.minorStepIdx]) === 0;
  };

  DataScale.prototype.getStep = function () {
    return this.magnitudefactor * this.minorSteps[this.minorStepIdx];
  };

  DataScale.prototype.getFirstMajor = function () {
    var majorStep = this.magnitudefactor * this.majorSteps[this.minorStepIdx];
    return this.convertValue(this._start + (majorStep - this._start % majorStep) % majorStep);
  };

  DataScale.prototype.formatValue = function (current) {
    var returnValue = current.toPrecision(5);
    if (typeof this.formattingFunction === 'function') {
      returnValue = this.formattingFunction(current);
    }

    if (typeof returnValue === 'number') {
      return '' + returnValue;
    } else if (typeof returnValue === 'string') {
      return returnValue;
    } else {
      return current.toPrecision(5);
    }
  };

  DataScale.prototype.getLines = function () {
    var lines = [];
    var step = this.getStep();
    var bottomOffset = (step - this._start % step) % step;
    for (var i = this._start + bottomOffset; this._end - i > 0.00001; i += step) {
      if (i != this._start) {
        //Skip the bottom line
        lines.push({ major: this.is_major(i), y: this.convertValue(i), val: this.formatValue(i) });
      }
    }
    return lines;
  };

  DataScale.prototype.followScale = function (other) {
    var oldStepIdx = this.minorStepIdx;
    var oldStart = this._start;
    var oldEnd = this._end;

    var me = this;
    var increaseMagnitude = function increaseMagnitude() {
      me.magnitudefactor *= 2;
    };
    var decreaseMagnitude = function decreaseMagnitude() {
      me.magnitudefactor /= 2;
    };

    if (other.minorStepIdx <= 1 && this.minorStepIdx <= 1 || other.minorStepIdx > 1 && this.minorStepIdx > 1) {
      //easy, no need to change stepIdx nor multiplication factor
    } else if (other.minorStepIdx < this.minorStepIdx) {
        //I'm 5, they are 4 per major.
        this.minorStepIdx = 1;
        if (oldStepIdx == 2) {
          increaseMagnitude();
        } else {
          increaseMagnitude();
          increaseMagnitude();
        }
      } else {
        //I'm 4, they are 5 per major
        this.minorStepIdx = 2;
        if (oldStepIdx == 1) {
          decreaseMagnitude();
        } else {
          decreaseMagnitude();
          decreaseMagnitude();
        }
      }

    //Get masters stats:
    var lines = other.getLines();
    var otherZero = other.convertValue(0);
    var otherStep = other.getStep() * other.scale;

    var done = false;
    var count = 0;
    //Loop until magnitude is correct for given constrains.
    while (!done && count++ < 5) {

      //Get my stats:
      this.scale = otherStep / (this.minorSteps[this.minorStepIdx] * this.magnitudefactor);
      var newRange = this.containerHeight / this.scale;

      //For the case the magnitudefactor has changed:
      this._start = oldStart;
      this._end = this._start + newRange;

      var myOriginalZero = this._end * this.scale;
      var majorStep = this.magnitudefactor * this.majorSteps[this.minorStepIdx];
      var majorOffset = this.getFirstMajor() - other.getFirstMajor();

      if (this.zeroAlign) {
        var zeroOffset = otherZero - myOriginalZero;
        this._end += zeroOffset / this.scale;
        this._start = this._end - newRange;
      } else {
        if (!this.autoScaleStart) {
          this._start += majorStep - majorOffset / this.scale;
          this._end = this._start + newRange;
        } else {
          this._start -= majorOffset / this.scale;
          this._end = this._start + newRange;
        }
      }
      if (!this.autoScaleEnd && this._end > oldEnd + 0.00001) {
        //Need to decrease magnitude to prevent scale overshoot! (end)
        decreaseMagnitude();
        done = false;
        continue;
      }
      if (!this.autoScaleStart && this._start < oldStart - 0.00001) {
        if (this.zeroAlign && oldStart >= 0) {
          console.warn("Can't adhere to given 'min' range, due to zeroalign");
        } else {
          //Need to decrease magnitude to prevent scale overshoot! (start)
          decreaseMagnitude();
          done = false;
          continue;
        }
      }
      if (this.autoScaleStart && this.autoScaleEnd && newRange < oldEnd - oldStart) {
        increaseMagnitude();
        done = false;
        continue;
      }
      done = true;
    }
  };

  DataScale.prototype.convertValue = function (value) {
    return this.containerHeight - (value - this._start) * this.scale;
  };

  DataScale.prototype.screenToValue = function (pixels) {
    return (this.containerHeight - pixels) / this.scale + this._start;
  };

  module.exports = DataScale;

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

  var util = __webpack_require__(1);
  var DOMutil = __webpack_require__(8);
  var Bars = __webpack_require__(55);
  var Lines = __webpack_require__(57);
  var Points = __webpack_require__(56);

  /**
   * /**
   * @param {object} group            | the object of the group from the dataset
   * @param {string} groupId          | ID of the group
   * @param {object} options          | the default options
   * @param {array} groupsUsingDefaultStyles  | this array has one entree.
   *                                            It is passed as an array so it is passed by reference.
   *                                            It enumerates through the default styles
   * @constructor
   */
  function GraphGroup(group, groupId, options, groupsUsingDefaultStyles) {
    this.id = groupId;
    var fields = ['sampling', 'style', 'sort', 'yAxisOrientation', 'barChart', 'drawPoints', 'shaded', 'interpolation', 'zIndex', 'excludeFromStacking', 'excludeFromLegend'];
    this.options = util.selectiveBridgeObject(fields, options);
    this.usingDefaultStyle = group.className === undefined;
    this.groupsUsingDefaultStyles = groupsUsingDefaultStyles;
    this.zeroPosition = 0;
    this.update(group);
    if (this.usingDefaultStyle == true) {
      this.groupsUsingDefaultStyles[0] += 1;
    }
    this.itemsData = [];
    this.visible = group.visible === undefined ? true : group.visible;
  }

  /**
   * this loads a reference to all items in this group into this group.
   * @param {array} items
   */
  GraphGroup.prototype.setItems = function (items) {
    if (items != null) {
      this.itemsData = items;
      if (this.options.sort == true) {
        util.insertSort(this.itemsData, function (a, b) {
          return a.x > b.x ? 1 : -1;
        });
      }
    } else {
      this.itemsData = [];
    }
  };

  GraphGroup.prototype.getItems = function () {
    return this.itemsData;
  };

  /**
   * this is used for barcharts and shading, this way, we only have to calculate it once.
   * @param pos
   */
  GraphGroup.prototype.setZeroPosition = function (pos) {
    this.zeroPosition = pos;
  };

  /**
   * set the options of the graph group over the default options.
   * @param options
   */
  GraphGroup.prototype.setOptions = function (options) {
    if (options !== undefined) {
      var fields = ['sampling', 'style', 'sort', 'yAxisOrientation', 'barChart', 'zIndex', 'excludeFromStacking', 'excludeFromLegend'];
      util.selectiveDeepExtend(fields, this.options, options);

      // if the group's drawPoints is a function delegate the callback to the onRender property
      if (typeof options.drawPoints == 'function') {
        options.drawPoints = {
          onRender: options.drawPoints
        };
      }

      util.mergeOptions(this.options, options, 'interpolation');
      util.mergeOptions(this.options, options, 'drawPoints');
      util.mergeOptions(this.options, options, 'shaded');

      if (options.interpolation) {
        if (_typeof(options.interpolation) == 'object') {
          if (options.interpolation.parametrization) {
            if (options.interpolation.parametrization == 'uniform') {
              this.options.interpolation.alpha = 0;
            } else if (options.interpolation.parametrization == 'chordal') {
              this.options.interpolation.alpha = 1.0;
            } else {
              this.options.interpolation.parametrization = 'centripetal';
              this.options.interpolation.alpha = 0.5;
            }
          }
        }
      }
    }
  };

  /**
   * this updates the current group class with the latest group dataset entree, used in _updateGroup in linegraph
   * @param group
   */
  GraphGroup.prototype.update = function (group) {
    this.group = group;
    this.content = group.content || 'graph';
    this.className = group.className || this.className || 'vis-graph-group' + this.groupsUsingDefaultStyles[0] % 10;
    this.visible = group.visible === undefined ? true : group.visible;
    this.style = group.style;
    this.setOptions(group.options);
  };

  /**
   * return the legend entree for this group.
   *
   * @param iconWidth
   * @param iconHeight
   * @returns {{icon: HTMLElement, label: (group.content|*|string), orientation: (.options.yAxisOrientation|*)}}
   */
  GraphGroup.prototype.getLegend = function (iconWidth, iconHeight, framework, x, y) {
    if (framework == undefined || framework == null) {
      var svg = document.createElementNS('http://www.w3.org/2000/svg', "svg");
      framework = { svg: svg, svgElements: {}, options: this.options, groups: [this] };
    }
    if (x == undefined || x == null) {
      x = 0;
    }
    if (y == undefined || y == null) {
      y = 0.5 * iconHeight;
    }
    switch (this.options.style) {
      case "line":
        Lines.drawIcon(this, x, y, iconWidth, iconHeight, framework);
        break;
      case "points": //explicit no break
      case "point":
        Points.drawIcon(this, x, y, iconWidth, iconHeight, framework);
        break;
      case "bar":
        Bars.drawIcon(this, x, y, iconWidth, iconHeight, framework);
        break;
    }
    return { icon: framework.svg, label: this.content, orientation: this.options.yAxisOrientation };
  };

  GraphGroup.prototype.getYRange = function (groupData) {
    var yMin = groupData[0].y;
    var yMax = groupData[0].y;
    for (var j = 0; j < groupData.length; j++) {
      yMin = yMin > groupData[j].y ? groupData[j].y : yMin;
      yMax = yMax < groupData[j].y ? groupData[j].y : yMax;
    }
    return { min: yMin, max: yMax, yAxisOrientation: this.options.yAxisOrientation };
  };

  module.exports = GraphGroup;

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var DOMutil = __webpack_require__(8);
  var Points = __webpack_require__(56);

  function Bargraph(groupId, options) {}

  Bargraph.drawIcon = function (group, x, y, iconWidth, iconHeight, framework) {
    var fillHeight = iconHeight * 0.5;
    var path, fillPath;

    var outline = DOMutil.getSVGElement("rect", framework.svgElements, framework.svg);
    outline.setAttributeNS(null, "x", x);
    outline.setAttributeNS(null, "y", y - fillHeight);
    outline.setAttributeNS(null, "width", iconWidth);
    outline.setAttributeNS(null, "height", 2 * fillHeight);
    outline.setAttributeNS(null, "class", "vis-outline");

    var barWidth = Math.round(0.3 * iconWidth);
    var originalWidth = group.options.barChart.width;
    var scale = originalWidth / barWidth;
    var bar1Height = Math.round(0.4 * iconHeight);
    var bar2Height = Math.round(0.75 * iconHeight);

    var offset = Math.round((iconWidth - 2 * barWidth) / 3);

    DOMutil.drawBar(x + 0.5 * barWidth + offset, y + fillHeight - bar1Height - 1, barWidth, bar1Height, group.className + ' vis-bar', framework.svgElements, framework.svg, group.style);
    DOMutil.drawBar(x + 1.5 * barWidth + offset + 2, y + fillHeight - bar2Height - 1, barWidth, bar2Height, group.className + ' vis-bar', framework.svgElements, framework.svg, group.style);

    if (group.options.drawPoints.enabled == true) {
      var groupTemplate = {
        style: group.options.drawPoints.style,
        styles: group.options.drawPoints.styles,
        size: group.options.drawPoints.size / scale,
        className: group.className
      };
      DOMutil.drawPoint(x + 0.5 * barWidth + offset, y + fillHeight - bar1Height - 1, groupTemplate, framework.svgElements, framework.svg);
      DOMutil.drawPoint(x + 1.5 * barWidth + offset + 2, y + fillHeight - bar2Height - 1, groupTemplate, framework.svgElements, framework.svg);
    }
  };

  /**
   * draw a bar graph
   *
   * @param groupIds
   * @param processedGroupData
   */
  Bargraph.draw = function (groupIds, processedGroupData, framework) {
    var combinedData = [];
    var intersections = {};
    var coreDistance;
    var key, drawData;
    var group;
    var i, j;
    var barPoints = 0;

    // combine all barchart data
    for (i = 0; i < groupIds.length; i++) {
      group = framework.groups[groupIds[i]];
      if (group.options.style === 'bar') {
        if (group.visible === true && (framework.options.groups.visibility[groupIds[i]] === undefined || framework.options.groups.visibility[groupIds[i]] === true)) {
          for (j = 0; j < processedGroupData[groupIds[i]].length; j++) {
            combinedData.push({
              screen_x: processedGroupData[groupIds[i]][j].screen_x,
              screen_y: processedGroupData[groupIds[i]][j].screen_y,
              x: processedGroupData[groupIds[i]][j].x,
              y: processedGroupData[groupIds[i]][j].y,
              groupId: groupIds[i],
              label: processedGroupData[groupIds[i]][j].label
            });
            barPoints += 1;
          }
        }
      }
    }

    if (barPoints === 0) {
      return;
    }

    // sort by time and by group
    combinedData.sort(function (a, b) {
      if (a.screen_x === b.screen_x) {
        return a.groupId < b.groupId ? -1 : 1;
      } else {
        return a.screen_x - b.screen_x;
      }
    });

    // get intersections
    Bargraph._getDataIntersections(intersections, combinedData);

    // plot barchart
    for (i = 0; i < combinedData.length; i++) {
      group = framework.groups[combinedData[i].groupId];
      var minWidth = group.options.barChart.minWidth != undefined ? group.options.barChart.minWidth : 0.1 * group.options.barChart.width;

      key = combinedData[i].screen_x;
      var heightOffset = 0;
      if (intersections[key] === undefined) {
        if (i + 1 < combinedData.length) {
          coreDistance = Math.abs(combinedData[i + 1].screen_x - key);
        }
        drawData = Bargraph._getSafeDrawData(coreDistance, group, minWidth);
      } else {
        var nextKey = i + (intersections[key].amount - intersections[key].resolved);
        var prevKey = i - (intersections[key].resolved + 1);
        if (nextKey < combinedData.length) {
          coreDistance = Math.abs(combinedData[nextKey].screen_x - key);
        }
        drawData = Bargraph._getSafeDrawData(coreDistance, group, minWidth);
        intersections[key].resolved += 1;

        if (group.options.stack === true && group.options.excludeFromStacking !== true) {
          if (combinedData[i].screen_y < group.zeroPosition) {
            heightOffset = intersections[key].accumulatedNegative;
            intersections[key].accumulatedNegative += group.zeroPosition - combinedData[i].screen_y;
          } else {
            heightOffset = intersections[key].accumulatedPositive;
            intersections[key].accumulatedPositive += group.zeroPosition - combinedData[i].screen_y;
          }
        } else if (group.options.barChart.sideBySide === true) {
          drawData.width = drawData.width / intersections[key].amount;
          drawData.offset += intersections[key].resolved * drawData.width - 0.5 * drawData.width * (intersections[key].amount + 1);
        }
      }
      DOMutil.drawBar(combinedData[i].screen_x + drawData.offset, combinedData[i].screen_y - heightOffset, drawData.width, group.zeroPosition - combinedData[i].screen_y, group.className + ' vis-bar', framework.svgElements, framework.svg, group.style);
      // draw points
      if (group.options.drawPoints.enabled === true) {
        var pointData = {
          screen_x: combinedData[i].screen_x,
          screen_y: combinedData[i].screen_y - heightOffset,
          x: combinedData[i].x,
          y: combinedData[i].y,
          groupId: combinedData[i].groupId,
          label: combinedData[i].label
        };
        Points.draw([pointData], group, framework, drawData.offset);
        //DOMutil.drawPoint(combinedData[i].x + drawData.offset, combinedData[i].y, group, framework.svgElements, framework.svg);
      }
    }
  };

  /**
   * Fill the intersections object with counters of how many datapoints share the same x coordinates
   * @param intersections
   * @param combinedData
   * @private
   */
  Bargraph._getDataIntersections = function (intersections, combinedData) {
    // get intersections
    var coreDistance;
    for (var i = 0; i < combinedData.length; i++) {
      if (i + 1 < combinedData.length) {
        coreDistance = Math.abs(combinedData[i + 1].screen_x - combinedData[i].screen_x);
      }
      if (i > 0) {
        coreDistance = Math.min(coreDistance, Math.abs(combinedData[i - 1].screen_x - combinedData[i].screen_x));
      }
      if (coreDistance === 0) {
        if (intersections[combinedData[i].screen_x] === undefined) {
          intersections[combinedData[i].screen_x] = {
            amount: 0,
            resolved: 0,
            accumulatedPositive: 0,
            accumulatedNegative: 0
          };
        }
        intersections[combinedData[i].screen_x].amount += 1;
      }
    }
  };

  /**
   * Get the width and offset for bargraphs based on the coredistance between datapoints
   *
   * @param coreDistance
   * @param group
   * @param minWidth
   * @returns {{width: Number, offset: Number}}
   * @private
   */
  Bargraph._getSafeDrawData = function (coreDistance, group, minWidth) {
    var width, offset;
    if (coreDistance < group.options.barChart.width && coreDistance > 0) {
      width = coreDistance < minWidth ? minWidth : coreDistance;

      offset = 0; // recalculate offset with the new width;
      if (group.options.barChart.align === 'left') {
        offset -= 0.5 * coreDistance;
      } else if (group.options.barChart.align === 'right') {
        offset += 0.5 * coreDistance;
      }
    } else {
      // default settings
      width = group.options.barChart.width;
      offset = 0;
      if (group.options.barChart.align === 'left') {
        offset -= 0.5 * group.options.barChart.width;
      } else if (group.options.barChart.align === 'right') {
        offset += 0.5 * group.options.barChart.width;
      }
    }

    return { width: width, offset: offset };
  };

  Bargraph.getStackedYRange = function (combinedData, groupRanges, groupIds, groupLabel, orientation) {
    if (combinedData.length > 0) {
      // sort by time and by group
      combinedData.sort(function (a, b) {
        if (a.screen_x === b.screen_x) {
          return a.groupId < b.groupId ? -1 : 1;
        } else {
          return a.screen_x - b.screen_x;
        }
      });
      var intersections = {};

      Bargraph._getDataIntersections(intersections, combinedData);
      groupRanges[groupLabel] = Bargraph._getStackedYRange(intersections, combinedData);
      groupRanges[groupLabel].yAxisOrientation = orientation;
      groupIds.push(groupLabel);
    }
  };

  Bargraph._getStackedYRange = function (intersections, combinedData) {
    var key;
    var yMin = combinedData[0].screen_y;
    var yMax = combinedData[0].screen_y;
    for (var i = 0; i < combinedData.length; i++) {
      key = combinedData[i].screen_x;
      if (intersections[key] === undefined) {
        yMin = yMin > combinedData[i].screen_y ? combinedData[i].screen_y : yMin;
        yMax = yMax < combinedData[i].screen_y ? combinedData[i].screen_y : yMax;
      } else {
        if (combinedData[i].screen_y < 0) {
          intersections[key].accumulatedNegative += combinedData[i].screen_y;
        } else {
          intersections[key].accumulatedPositive += combinedData[i].screen_y;
        }
      }
    }
    for (var xpos in intersections) {
      if (intersections.hasOwnProperty(xpos)) {
        yMin = yMin > intersections[xpos].accumulatedNegative ? intersections[xpos].accumulatedNegative : yMin;
        yMin = yMin > intersections[xpos].accumulatedPositive ? intersections[xpos].accumulatedPositive : yMin;
        yMax = yMax < intersections[xpos].accumulatedNegative ? intersections[xpos].accumulatedNegative : yMax;
        yMax = yMax < intersections[xpos].accumulatedPositive ? intersections[xpos].accumulatedPositive : yMax;
      }
    }

    return { min: yMin, max: yMax };
  };

  module.exports = Bargraph;

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

  var DOMutil = __webpack_require__(8);

  function Points(groupId, options) {}

  /**
   * draw the data points
   *
   * @param {Array} dataset
   * @param {Object} JSONcontainer
   * @param {Object} svg            | SVG DOM element
   * @param {GraphGroup} group
   * @param {Number} [offset]
   */
  Points.draw = function (dataset, group, framework, offset) {
    offset = offset || 0;
    var callback = getCallback(framework, group);

    for (var i = 0; i < dataset.length; i++) {
      if (!callback) {
        // draw the point the simple way.
        DOMutil.drawPoint(dataset[i].screen_x + offset, dataset[i].screen_y, getGroupTemplate(group), framework.svgElements, framework.svg, dataset[i].label);
      } else {
        var callbackResult = callback(dataset[i], group); // result might be true, false or an object
        if (callbackResult === true || (typeof callbackResult === 'undefined' ? 'undefined' : _typeof(callbackResult)) === 'object') {
          DOMutil.drawPoint(dataset[i].screen_x + offset, dataset[i].screen_y, getGroupTemplate(group, callbackResult), framework.svgElements, framework.svg, dataset[i].label);
        }
      }
    }
  };

  Points.drawIcon = function (group, x, y, iconWidth, iconHeight, framework) {
    var fillHeight = iconHeight * 0.5;
    var path, fillPath;

    var outline = DOMutil.getSVGElement("rect", framework.svgElements, framework.svg);
    outline.setAttributeNS(null, "x", x);
    outline.setAttributeNS(null, "y", y - fillHeight);
    outline.setAttributeNS(null, "width", iconWidth);
    outline.setAttributeNS(null, "height", 2 * fillHeight);
    outline.setAttributeNS(null, "class", "vis-outline");

    //Don't call callback on icon
    DOMutil.drawPoint(x + 0.5 * iconWidth, y, getGroupTemplate(group), framework.svgElements, framework.svg);
  };

  function getGroupTemplate(group, callbackResult) {
    callbackResult = typeof callbackResult === 'undefined' ? {} : callbackResult;
    return {
      style: callbackResult.style || group.options.drawPoints.style,
      styles: callbackResult.styles || group.options.drawPoints.styles,
      size: callbackResult.size || group.options.drawPoints.size,
      className: callbackResult.className || group.className
    };
  }

  function getCallback(framework, group) {
    var callback = undefined;
    // check for the graph2d onRender
    if (framework.options && framework.options.drawPoints && framework.options.drawPoints.onRender && typeof framework.options.drawPoints.onRender == 'function') {
      callback = framework.options.drawPoints.onRender;
    }

    // override it with the group onRender if defined
    if (group.group.options && group.group.options.drawPoints && group.group.options.drawPoints.onRender && typeof group.group.options.drawPoints.onRender == 'function') {
      callback = group.group.options.drawPoints.onRender;
    }
    return callback;
  }

  module.exports = Points;

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

  "use strict";

  var DOMutil = __webpack_require__(8);

  function Line(groupId, options) {}

  Line.calcPath = function (dataset, group) {
      if (dataset != null) {
          if (dataset.length > 0) {
              var d = [];

              // construct path from dataset
              if (group.options.interpolation.enabled == true) {
                  d = Line._catmullRom(dataset, group);
              } else {
                  d = Line._linear(dataset);
              }
              return d;
          }
      }
  };

  Line.drawIcon = function (group, x, y, iconWidth, iconHeight, framework) {
      var fillHeight = iconHeight * 0.5;
      var path, fillPath;

      var outline = DOMutil.getSVGElement("rect", framework.svgElements, framework.svg);
      outline.setAttributeNS(null, "x", x);
      outline.setAttributeNS(null, "y", y - fillHeight);
      outline.setAttributeNS(null, "width", iconWidth);
      outline.setAttributeNS(null, "height", 2 * fillHeight);
      outline.setAttributeNS(null, "class", "vis-outline");

      path = DOMutil.getSVGElement("path", framework.svgElements, framework.svg);
      path.setAttributeNS(null, "class", group.className);
      if (group.style !== undefined) {
          path.setAttributeNS(null, "style", group.style);
      }

      path.setAttributeNS(null, "d", "M" + x + "," + y + " L" + (x + iconWidth) + "," + y + "");
      if (group.options.shaded.enabled == true) {
          fillPath = DOMutil.getSVGElement("path", framework.svgElements, framework.svg);
          if (group.options.shaded.orientation == 'top') {
              fillPath.setAttributeNS(null, "d", "M" + x + ", " + (y - fillHeight) + "L" + x + "," + y + " L" + (x + iconWidth) + "," + y + " L" + (x + iconWidth) + "," + (y - fillHeight));
          } else {
              fillPath.setAttributeNS(null, "d", "M" + x + "," + y + " " + "L" + x + "," + (y + fillHeight) + " " + "L" + (x + iconWidth) + "," + (y + fillHeight) + "L" + (x + iconWidth) + "," + y);
          }
          fillPath.setAttributeNS(null, "class", group.className + " vis-icon-fill");
          if (group.options.shaded.style !== undefined && group.options.shaded.style !== "") {
              fillPath.setAttributeNS(null, "style", group.options.shaded.style);
          }
      }

      if (group.options.drawPoints.enabled == true) {
          var groupTemplate = {
              style: group.options.drawPoints.style,
              styles: group.options.drawPoints.styles,
              size: group.options.drawPoints.size,
              className: group.className
          };
          DOMutil.drawPoint(x + 0.5 * iconWidth, y, groupTemplate, framework.svgElements, framework.svg);
      }
  };

  Line.drawShading = function (pathArray, group, subPathArray, framework) {
      // append shading to the path
      if (group.options.shaded.enabled == true) {
          var svgHeight = Number(framework.svg.style.height.replace('px', ''));
          var fillPath = DOMutil.getSVGElement('path', framework.svgElements, framework.svg);
          var type = "L";
          if (group.options.interpolation.enabled == true) {
              type = "C";
          }
          var dFill;
          var zero = 0;
          if (group.options.shaded.orientation == 'top') {
              zero = 0;
          } else if (group.options.shaded.orientation == 'bottom') {
              zero = svgHeight;
          } else {
              zero = Math.min(Math.max(0, group.zeroPosition), svgHeight);
          }
          if (group.options.shaded.orientation == 'group' && subPathArray != null && subPathArray != undefined) {
              dFill = 'M' + pathArray[0][0] + "," + pathArray[0][1] + " " + this.serializePath(pathArray, type, false) + ' L' + subPathArray[subPathArray.length - 1][0] + "," + subPathArray[subPathArray.length - 1][1] + " " + this.serializePath(subPathArray, type, true) + subPathArray[0][0] + "," + subPathArray[0][1] + " Z";
          } else {
              dFill = 'M' + pathArray[0][0] + "," + pathArray[0][1] + " " + this.serializePath(pathArray, type, false) + ' V' + zero + ' H' + pathArray[0][0] + " Z";
          }

          fillPath.setAttributeNS(null, 'class', group.className + ' vis-fill');
          if (group.options.shaded.style !== undefined) {
              fillPath.setAttributeNS(null, 'style', group.options.shaded.style);
          }
          fillPath.setAttributeNS(null, 'd', dFill);
      }
  };

  /**
   * draw a line graph
   *
   * @param dataset
   * @param group
   */
  Line.draw = function (pathArray, group, framework) {
      if (pathArray != null && pathArray != undefined) {
          var path = DOMutil.getSVGElement('path', framework.svgElements, framework.svg);
          path.setAttributeNS(null, "class", group.className);
          if (group.style !== undefined) {
              path.setAttributeNS(null, "style", group.style);
          }

          var type = "L";
          if (group.options.interpolation.enabled == true) {
              type = "C";
          }
          // copy properties to path for drawing.
          path.setAttributeNS(null, 'd', 'M' + pathArray[0][0] + "," + pathArray[0][1] + " " + this.serializePath(pathArray, type, false));
      }
  };

  Line.serializePath = function (pathArray, type, inverse) {
      if (pathArray.length < 2) {
          //Too little data to create a path.
          return "";
      }
      var d = type;
      if (inverse) {
          for (var i = pathArray.length - 2; i > 0; i--) {
              d += pathArray[i][0] + "," + pathArray[i][1] + " ";
          }
      } else {
          for (var i = 1; i < pathArray.length; i++) {
              d += pathArray[i][0] + "," + pathArray[i][1] + " ";
          }
      }
      return d;
  };

  /**
   * This uses an uniform parametrization of the interpolation algorithm:
   * 'On the Parameterization of Catmull-Rom Curves' by Cem Yuksel et al.
   * @param data
   * @returns {string}
   * @private
   */
  Line._catmullRomUniform = function (data) {
      // catmull rom
      var p0, p1, p2, p3, bp1, bp2;
      var d = [];
      d.push([Math.round(data[0].screen_x), Math.round(data[0].screen_y)]);
      var normalization = 1 / 6;
      var length = data.length;
      for (var i = 0; i < length - 1; i++) {

          p0 = i == 0 ? data[0] : data[i - 1];
          p1 = data[i];
          p2 = data[i + 1];
          p3 = i + 2 < length ? data[i + 2] : p2;

          // Catmull-Rom to Cubic Bezier conversion matrix
          //    0       1       0       0
          //  -1/6      1      1/6      0
          //    0      1/6      1     -1/6
          //    0       0       1       0

          //    bp0 = { x: p1.x,                               y: p1.y };
          bp1 = {
              screen_x: (-p0.screen_x + 6 * p1.screen_x + p2.screen_x) * normalization,
              screen_y: (-p0.screen_y + 6 * p1.screen_y + p2.screen_y) * normalization
          };
          bp2 = {
              screen_x: (p1.screen_x + 6 * p2.screen_x - p3.screen_x) * normalization,
              screen_y: (p1.screen_y + 6 * p2.screen_y - p3.screen_y) * normalization
          };
          //    bp0 = { x: p2.x,                               y: p2.y };

          d.push([bp1.screen_x, bp1.screen_y]);
          d.push([bp2.screen_x, bp2.screen_y]);
          d.push([p2.screen_x, p2.screen_y]);
      }

      return d;
  };

  /**
   * This uses either the chordal or centripetal parameterization of the catmull-rom algorithm.
   * By default, the centripetal parameterization is used because this gives the nicest results.
   * These parameterizations are relatively heavy because the distance between 4 points have to be calculated.
   *
   * One optimization can be used to reuse distances since this is a sliding window approach.
   * @param data
   * @param group
   * @returns {string}
   * @private
   */
  Line._catmullRom = function (data, group) {
      var alpha = group.options.interpolation.alpha;
      if (alpha == 0 || alpha === undefined) {
          return this._catmullRomUniform(data);
      } else {
          var p0, p1, p2, p3, bp1, bp2, d1, d2, d3, A, B, N, M;
          var d3powA, d2powA, d3pow2A, d2pow2A, d1pow2A, d1powA;
          var d = [];
          d.push([Math.round(data[0].screen_x), Math.round(data[0].screen_y)]);
          var length = data.length;
          for (var i = 0; i < length - 1; i++) {

              p0 = i == 0 ? data[0] : data[i - 1];
              p1 = data[i];
              p2 = data[i + 1];
              p3 = i + 2 < length ? data[i + 2] : p2;

              d1 = Math.sqrt(Math.pow(p0.screen_x - p1.screen_x, 2) + Math.pow(p0.screen_y - p1.screen_y, 2));
              d2 = Math.sqrt(Math.pow(p1.screen_x - p2.screen_x, 2) + Math.pow(p1.screen_y - p2.screen_y, 2));
              d3 = Math.sqrt(Math.pow(p2.screen_x - p3.screen_x, 2) + Math.pow(p2.screen_y - p3.screen_y, 2));

              // Catmull-Rom to Cubic Bezier conversion matrix

              // A = 2d1^2a + 3d1^a * d2^a + d3^2a
              // B = 2d3^2a + 3d3^a * d2^a + d2^2a

              // [   0             1            0          0          ]
              // [   -d2^2a /N     A/N          d1^2a /N   0          ]
              // [   0             d3^2a /M     B/M        -d2^2a /M  ]
              // [   0             0            1          0          ]

              d3powA = Math.pow(d3, alpha);
              d3pow2A = Math.pow(d3, 2 * alpha);
              d2powA = Math.pow(d2, alpha);
              d2pow2A = Math.pow(d2, 2 * alpha);
              d1powA = Math.pow(d1, alpha);
              d1pow2A = Math.pow(d1, 2 * alpha);

              A = 2 * d1pow2A + 3 * d1powA * d2powA + d2pow2A;
              B = 2 * d3pow2A + 3 * d3powA * d2powA + d2pow2A;
              N = 3 * d1powA * (d1powA + d2powA);
              if (N > 0) {
                  N = 1 / N;
              }
              M = 3 * d3powA * (d3powA + d2powA);
              if (M > 0) {
                  M = 1 / M;
              }

              bp1 = {
                  screen_x: (-d2pow2A * p0.screen_x + A * p1.screen_x + d1pow2A * p2.screen_x) * N,
                  screen_y: (-d2pow2A * p0.screen_y + A * p1.screen_y + d1pow2A * p2.screen_y) * N
              };

              bp2 = {
                  screen_x: (d3pow2A * p1.screen_x + B * p2.screen_x - d2pow2A * p3.screen_x) * M,
                  screen_y: (d3pow2A * p1.screen_y + B * p2.screen_y - d2pow2A * p3.screen_y) * M
              };

              if (bp1.screen_x == 0 && bp1.screen_y == 0) {
                  bp1 = p1;
              }
              if (bp2.screen_x == 0 && bp2.screen_y == 0) {
                  bp2 = p2;
              }
              d.push([bp1.screen_x, bp1.screen_y]);
              d.push([bp2.screen_x, bp2.screen_y]);
              d.push([p2.screen_x, p2.screen_y]);
          }

          return d;
      }
  };

  /**
   * this generates the SVG path for a linear drawing between datapoints.
   * @param data
   * @returns {string}
   * @private
   */
  Line._linear = function (data) {
      // linear
      var d = [];
      for (var i = 0; i < data.length; i++) {
          d.push([data[i].screen_x, data[i].screen_y]);
      }
      return d;
  };

  module.exports = Line;

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var util = __webpack_require__(1);
  var DOMutil = __webpack_require__(8);
  var Component = __webpack_require__(31);

  /**
   * Legend for Graph2d
   */
  function Legend(body, options, side, linegraphOptions) {
    this.body = body;
    this.defaultOptions = {
      enabled: false,
      icons: true,
      iconSize: 20,
      iconSpacing: 6,
      left: {
        visible: true,
        position: 'top-left' // top/bottom - left,center,right
      },
      right: {
        visible: true,
        position: 'top-right' // top/bottom - left,center,right
      }
    };

    this.side = side;
    this.options = util.extend({}, this.defaultOptions);
    this.linegraphOptions = linegraphOptions;

    this.svgElements = {};
    this.dom = {};
    this.groups = {};
    this.amountOfGroups = 0;
    this._create();
    this.framework = { svg: this.svg, svgElements: this.svgElements, options: this.options, groups: this.groups };

    this.setOptions(options);
  }

  Legend.prototype = new Component();

  Legend.prototype.clear = function () {
    this.groups = {};
    this.amountOfGroups = 0;
  };

  Legend.prototype.addGroup = function (label, graphOptions) {

    // Include a group only if the group option 'excludeFromLegend: false' is not set.
    if (graphOptions.options.excludeFromLegend != true) {
      if (!this.groups.hasOwnProperty(label)) {
        this.groups[label] = graphOptions;
      }
      this.amountOfGroups += 1;
    }
  };

  Legend.prototype.updateGroup = function (label, graphOptions) {
    this.groups[label] = graphOptions;
  };

  Legend.prototype.removeGroup = function (label) {
    if (this.groups.hasOwnProperty(label)) {
      delete this.groups[label];
      this.amountOfGroups -= 1;
    }
  };

  Legend.prototype._create = function () {
    this.dom.frame = document.createElement('div');
    this.dom.frame.className = 'vis-legend';
    this.dom.frame.style.position = "absolute";
    this.dom.frame.style.top = "10px";
    this.dom.frame.style.display = "block";

    this.dom.textArea = document.createElement('div');
    this.dom.textArea.className = 'vis-legend-text';
    this.dom.textArea.style.position = "relative";
    this.dom.textArea.style.top = "0px";

    this.svg = document.createElementNS('http://www.w3.org/2000/svg', "svg");
    this.svg.style.position = 'absolute';
    this.svg.style.top = 0 + 'px';
    this.svg.style.width = this.options.iconSize + 5 + 'px';
    this.svg.style.height = '100%';

    this.dom.frame.appendChild(this.svg);
    this.dom.frame.appendChild(this.dom.textArea);
  };

  /**
   * Hide the component from the DOM
   */
  Legend.prototype.hide = function () {
    // remove the frame containing the items
    if (this.dom.frame.parentNode) {
      this.dom.frame.parentNode.removeChild(this.dom.frame);
    }
  };

  /**
   * Show the component in the DOM (when not already visible).
   * @return {Boolean} changed
   */
  Legend.prototype.show = function () {
    // show frame containing the items
    if (!this.dom.frame.parentNode) {
      this.body.dom.center.appendChild(this.dom.frame);
    }
  };

  Legend.prototype.setOptions = function (options) {
    var fields = ['enabled', 'orientation', 'icons', 'left', 'right'];
    util.selectiveDeepExtend(fields, this.options, options);
  };

  Legend.prototype.redraw = function () {
    var activeGroups = 0;
    var groupArray = Object.keys(this.groups);
    groupArray.sort(function (a, b) {
      return a < b ? -1 : 1;
    });

    for (var i = 0; i < groupArray.length; i++) {
      var groupId = groupArray[i];
      if (this.groups[groupId].visible == true && (this.linegraphOptions.visibility[groupId] === undefined || this.linegraphOptions.visibility[groupId] == true)) {
        activeGroups++;
      }
    }

    if (this.options[this.side].visible == false || this.amountOfGroups == 0 || this.options.enabled == false || activeGroups == 0) {
      this.hide();
    } else {
      this.show();
      if (this.options[this.side].position == 'top-left' || this.options[this.side].position == 'bottom-left') {
        this.dom.frame.style.left = '4px';
        this.dom.frame.style.textAlign = "left";
        this.dom.textArea.style.textAlign = "left";
        this.dom.textArea.style.left = this.options.iconSize + 15 + 'px';
        this.dom.textArea.style.right = '';
        this.svg.style.left = 0 + 'px';
        this.svg.style.right = '';
      } else {
        this.dom.frame.style.right = '4px';
        this.dom.frame.style.textAlign = "right";
        this.dom.textArea.style.textAlign = "right";
        this.dom.textArea.style.right = this.options.iconSize + 15 + 'px';
        this.dom.textArea.style.left = '';
        this.svg.style.right = 0 + 'px';
        this.svg.style.left = '';
      }

      if (this.options[this.side].position == 'top-left' || this.options[this.side].position == 'top-right') {
        this.dom.frame.style.top = 4 - Number(this.body.dom.center.style.top.replace("px", "")) + 'px';
        this.dom.frame.style.bottom = '';
      } else {
        var scrollableHeight = this.body.domProps.center.height - this.body.domProps.centerContainer.height;
        this.dom.frame.style.bottom = 4 + scrollableHeight + Number(this.body.dom.center.style.top.replace("px", "")) + 'px';
        this.dom.frame.style.top = '';
      }

      if (this.options.icons == false) {
        this.dom.frame.style.width = this.dom.textArea.offsetWidth + 10 + 'px';
        this.dom.textArea.style.right = '';
        this.dom.textArea.style.left = '';
        this.svg.style.width = '0px';
      } else {
        this.dom.frame.style.width = this.options.iconSize + 15 + this.dom.textArea.offsetWidth + 10 + 'px';
        this.drawLegendIcons();
      }

      var content = '';
      for (var i = 0; i < groupArray.length; i++) {
        var groupId = groupArray[i];
        if (this.groups[groupId].visible == true && (this.linegraphOptions.visibility[groupId] === undefined || this.linegraphOptions.visibility[groupId] == true)) {
          content += this.groups[groupId].content + '<br />';
        }
      }
      this.dom.textArea.innerHTML = content;
      this.dom.textArea.style.lineHeight = 0.75 * this.options.iconSize + this.options.iconSpacing + 'px';
    }
  };

  Legend.prototype.drawLegendIcons = function () {
    if (this.dom.frame.parentNode) {
      var groupArray = Object.keys(this.groups);
      groupArray.sort(function (a, b) {
        return a < b ? -1 : 1;
      });

      // this resets the elements so the order is maintained
      DOMutil.resetElements(this.svgElements);

      var padding = window.getComputedStyle(this.dom.frame).paddingTop;
      var iconOffset = Number(padding.replace('px', ''));
      var x = iconOffset;
      var iconWidth = this.options.iconSize;
      var iconHeight = 0.75 * this.options.iconSize;
      var y = iconOffset + 0.5 * iconHeight + 3;

      this.svg.style.width = iconWidth + 5 + iconOffset + 'px';

      for (var i = 0; i < groupArray.length; i++) {
        var groupId = groupArray[i];
        if (this.groups[groupId].visible == true && (this.linegraphOptions.visibility[groupId] === undefined || this.linegraphOptions.visibility[groupId] == true)) {
          this.groups[groupId].getLegend(iconWidth, iconHeight, this.framework, x, y);
          y += iconHeight + this.options.iconSpacing;
        }
      }
    }
  };

  module.exports = Legend;

/***/ },
/* 59 */
/***/ function(module, exports) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  /**
   * This object contains all possible options. It will check if the types are correct, if required if the option is one
   * of the allowed values.
   *
   * __any__ means that the name of the property does not matter.
   * __type__ is a required field for all objects and contains the allowed types of all objects
   */
  var string = 'string';
  var boolean = 'boolean';
  var number = 'number';
  var array = 'array';
  var date = 'date';
  var object = 'object'; // should only be in a __type__ property
  var dom = 'dom';
  var moment = 'moment';
  var any = 'any';

  var allOptions = {
    configure: {
      enabled: { boolean: boolean },
      filter: { boolean: boolean, 'function': 'function' },
      container: { dom: dom },
      __type__: { object: object, boolean: boolean, 'function': 'function' }
    },

    //globals :
    yAxisOrientation: { string: ['left', 'right'] },
    defaultGroup: { string: string },
    sort: { boolean: boolean },
    sampling: { boolean: boolean },
    stack: { boolean: boolean },
    graphHeight: { string: string, number: number },
    shaded: {
      enabled: { boolean: boolean },
      orientation: { string: ['bottom', 'top', 'zero', 'group'] }, // top, bottom, zero, group
      groupId: { object: object },
      __type__: { boolean: boolean, object: object }
    },
    style: { string: ['line', 'bar', 'points'] }, // line, bar
    barChart: {
      width: { number: number },
      minWidth: { number: number },
      sideBySide: { boolean: boolean },
      align: { string: ['left', 'center', 'right'] },
      __type__: { object: object }
    },
    interpolation: {
      enabled: { boolean: boolean },
      parametrization: { string: ['centripetal', 'chordal', 'uniform'] }, // uniform (alpha = 0.0), chordal (alpha = 1.0), centripetal (alpha = 0.5)
      alpha: { number: number },
      __type__: { object: object, boolean: boolean }
    },
    drawPoints: {
      enabled: { boolean: boolean },
      onRender: { 'function': 'function' },
      size: { number: number },
      style: { string: ['square', 'circle'] }, // square, circle
      __type__: { object: object, boolean: boolean, 'function': 'function' }
    },
    dataAxis: {
      showMinorLabels: { boolean: boolean },
      showMajorLabels: { boolean: boolean },
      icons: { boolean: boolean },
      width: { string: string, number: number },
      visible: { boolean: boolean },
      alignZeros: { boolean: boolean },
      left: {
        range: { min: { number: number }, max: { number: number }, __type__: { object: object } },
        format: { 'function': 'function' },
        title: { text: { string: string, number: number }, style: { string: string }, __type__: { object: object } },
        __type__: { object: object }
      },
      right: {
        range: { min: { number: number }, max: { number: number }, __type__: { object: object } },
        format: { 'function': 'function' },
        title: { text: { string: string, number: number }, style: { string: string }, __type__: { object: object } },
        __type__: { object: object }
      },
      __type__: { object: object }
    },
    legend: {
      enabled: { boolean: boolean },
      icons: { boolean: boolean },
      left: {
        visible: { boolean: boolean },
        position: { string: ['top-right', 'bottom-right', 'top-left', 'bottom-left'] },
        __type__: { object: object }
      },
      right: {
        visible: { boolean: boolean },
        position: { string: ['top-right', 'bottom-right', 'top-left', 'bottom-left'] },
        __type__: { object: object }
      },
      __type__: { object: object, boolean: boolean }
    },
    groups: {
      visibility: { any: any },
      __type__: { object: object }
    },

    autoResize: { boolean: boolean },
    throttleRedraw: { number: number },
    clickToUse: { boolean: boolean },
    end: { number: number, date: date, string: string, moment: moment },
    format: {
      minorLabels: {
        millisecond: { string: string, 'undefined': 'undefined' },
        second: { string: string, 'undefined': 'undefined' },
        minute: { string: string, 'undefined': 'undefined' },
        hour: { string: string, 'undefined': 'undefined' },
        weekday: { string: string, 'undefined': 'undefined' },
        day: { string: string, 'undefined': 'undefined' },
        month: { string: string, 'undefined': 'undefined' },
        year: { string: string, 'undefined': 'undefined' },
        __type__: { object: object }
      },
      majorLabels: {
        millisecond: { string: string, 'undefined': 'undefined' },
        second: { string: string, 'undefined': 'undefined' },
        minute: { string: string, 'undefined': 'undefined' },
        hour: { string: string, 'undefined': 'undefined' },
        weekday: { string: string, 'undefined': 'undefined' },
        day: { string: string, 'undefined': 'undefined' },
        month: { string: string, 'undefined': 'undefined' },
        year: { string: string, 'undefined': 'undefined' },
        __type__: { object: object }
      },
      __type__: { object: object }
    },
    moment: { 'function': 'function' },
    height: { string: string, number: number },
    hiddenDates: {
      start: { date: date, number: number, string: string, moment: moment },
      end: { date: date, number: number, string: string, moment: moment },
      repeat: { string: string },
      __type__: { object: object, array: array }
    },
    locale: { string: string },
    locales: {
      __any__: { any: any },
      __type__: { object: object }
    },
    max: { date: date, number: number, string: string, moment: moment },
    maxHeight: { number: number, string: string },
    maxMinorChars: { number: number },
    min: { date: date, number: number, string: string, moment: moment },
    minHeight: { number: number, string: string },
    moveable: { boolean: boolean },
    multiselect: { boolean: boolean },
    orientation: { string: string },
    showCurrentTime: { boolean: boolean },
    showMajorLabels: { boolean: boolean },
    showMinorLabels: { boolean: boolean },
    start: { date: date, number: number, string: string, moment: moment },
    timeAxis: {
      scale: { string: string, 'undefined': 'undefined' },
      step: { number: number, 'undefined': 'undefined' },
      __type__: { object: object }
    },
    width: { string: string, number: number },
    zoomable: { boolean: boolean },
    zoomKey: { string: ['ctrlKey', 'altKey', 'metaKey', ''] },
    zoomMax: { number: number },
    zoomMin: { number: number },
    zIndex: { number: number },
    __type__: { object: object }
  };

  var configureOptions = {
    global: {
      //yAxisOrientation: ['left','right'], // TDOO: enable as soon as Grahp2d doesn't crash when changing this on the fly
      sort: true,
      sampling: true,
      stack: false,
      shaded: {
        enabled: false,
        orientation: ['zero', 'top', 'bottom', 'group'] // zero, top, bottom
      },
      style: ['line', 'bar', 'points'], // line, bar
      barChart: {
        width: [50, 5, 100, 5],
        minWidth: [50, 5, 100, 5],
        sideBySide: false,
        align: ['left', 'center', 'right'] // left, center, right
      },
      interpolation: {
        enabled: true,
        parametrization: ['centripetal', 'chordal', 'uniform'] // uniform (alpha = 0.0), chordal (alpha = 1.0), centripetal (alpha = 0.5)
      },
      drawPoints: {
        enabled: true,
        size: [6, 2, 30, 1],
        style: ['square', 'circle'] // square, circle
      },
      dataAxis: {
        showMinorLabels: true,
        showMajorLabels: true,
        icons: false,
        width: [40, 0, 200, 1],
        visible: true,
        alignZeros: true,
        left: {
          //range: {min:'undefined': 'undefined'ined,max:'undefined': 'undefined'ined},
          //format: function (value) {return value;},
          title: { text: '', style: '' }
        },
        right: {
          //range: {min:'undefined': 'undefined'ined,max:'undefined': 'undefined'ined},
          //format: function (value) {return value;},
          title: { text: '', style: '' }
        }
      },
      legend: {
        enabled: false,
        icons: true,
        left: {
          visible: true,
          position: ['top-right', 'bottom-right', 'top-left', 'bottom-left'] // top/bottom - left,right
        },
        right: {
          visible: true,
          position: ['top-right', 'bottom-right', 'top-left', 'bottom-left'] // top/bottom - left,right
        }
      },

      autoResize: true,
      throttleRedraw: [10, 0, 1000, 10],
      clickToUse: false,
      end: '',
      format: {
        minorLabels: {
          millisecond: 'SSS',
          second: 's',
          minute: 'HH:mm',
          hour: 'HH:mm',
          weekday: 'ddd D',
          day: 'D',
          month: 'MMM',
          year: 'YYYY'
        },
        majorLabels: {
          millisecond: 'HH:mm:ss',
          second: 'D MMMM HH:mm',
          minute: 'ddd D MMMM',
          hour: 'ddd D MMMM',
          weekday: 'MMMM YYYY',
          day: 'MMMM YYYY',
          month: 'YYYY',
          year: ''
        }
      },

      height: '',
      locale: '',
      max: '',
      maxHeight: '',
      maxMinorChars: [7, 0, 20, 1],
      min: '',
      minHeight: '',
      moveable: true,
      orientation: ['both', 'bottom', 'top'],
      showCurrentTime: false,
      showMajorLabels: true,
      showMinorLabels: true,
      start: '',
      width: '100%',
      zoomable: true,
      zoomKey: ['ctrlKey', 'altKey', 'metaKey', ''],
      zoomMax: [315360000000000, 10, 315360000000000, 1],
      zoomMin: [10, 10, 315360000000000, 1],
      zIndex: 0
    }
  };

  exports.allOptions = allOptions;
  exports.configureOptions = configureOptions;

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  // utils
  exports.util = __webpack_require__(1);
  exports.DOMutil = __webpack_require__(8);

  // data
  exports.DataSet = __webpack_require__(9);
  exports.DataView = __webpack_require__(11);
  exports.Queue = __webpack_require__(10);

  // Network
  exports.Network = __webpack_require__(61);
  exports.network = {
    Images: __webpack_require__(62),
    dotparser: __webpack_require__(118),
    gephiParser: __webpack_require__(119),
    allOptions: __webpack_require__(114)
  };
  exports.network.convertDot = function (input) {
    return exports.network.dotparser.DOTToGraph(input);
  };
  exports.network.convertGephi = function (input, options) {
    return exports.network.gephiParser.parseGephi(input, options);
  };

  // bundled external libraries
  exports.moment = __webpack_require__(2);
  exports.Hammer = __webpack_require__(20);
  exports.keycharm = __webpack_require__(23);

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var _Images = __webpack_require__(62);

  var _Images2 = _interopRequireDefault(_Images);

  var _Groups = __webpack_require__(63);

  var _Groups2 = _interopRequireDefault(_Groups);

  var _NodesHandler = __webpack_require__(64);

  var _NodesHandler2 = _interopRequireDefault(_NodesHandler);

  var _EdgesHandler = __webpack_require__(84);

  var _EdgesHandler2 = _interopRequireDefault(_EdgesHandler);

  var _PhysicsEngine = __webpack_require__(93);

  var _PhysicsEngine2 = _interopRequireDefault(_PhysicsEngine);

  var _Clustering = __webpack_require__(102);

  var _Clustering2 = _interopRequireDefault(_Clustering);

  var _CanvasRenderer = __webpack_require__(105);

  var _CanvasRenderer2 = _interopRequireDefault(_CanvasRenderer);

  var _Canvas = __webpack_require__(106);

  var _Canvas2 = _interopRequireDefault(_Canvas);

  var _View = __webpack_require__(107);

  var _View2 = _interopRequireDefault(_View);

  var _InteractionHandler = __webpack_require__(108);

  var _InteractionHandler2 = _interopRequireDefault(_InteractionHandler);

  var _SelectionHandler = __webpack_require__(111);

  var _SelectionHandler2 = _interopRequireDefault(_SelectionHandler);

  var _LayoutEngine = __webpack_require__(112);

  var _LayoutEngine2 = _interopRequireDefault(_LayoutEngine);

  var _ManipulationSystem = __webpack_require__(113);

  var _ManipulationSystem2 = _interopRequireDefault(_ManipulationSystem);

  var _Configurator = __webpack_require__(26);

  var _Configurator2 = _interopRequireDefault(_Configurator);

  var _Validator = __webpack_require__(29);

  var _Validator2 = _interopRequireDefault(_Validator);

  var _options = __webpack_require__(114);

  var _KamadaKawai = __webpack_require__(115);

  var _KamadaKawai2 = _interopRequireDefault(_KamadaKawai);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  // Load custom shapes into CanvasRenderingContext2D
  __webpack_require__(117);

  var Emitter = __webpack_require__(13);
  var util = __webpack_require__(1);
  var DataSet = __webpack_require__(9);
  var DataView = __webpack_require__(11);
  var dotparser = __webpack_require__(118);
  var gephiParser = __webpack_require__(119);
  var Activator = __webpack_require__(45);
  var locales = __webpack_require__(120);

  /**
   * @constructor Network
   * Create a network visualization, displaying nodes and edges.
   *
   * @param {Element} container   The DOM element in which the Network will
   *                                  be created. Normally a div element.
   * @param {Object} data         An object containing parameters
   *                              {Array} nodes
   *                              {Array} edges
   * @param {Object} options      Options
   */
  function Network(container, data, options) {
    var _this = this;

    if (!(this instanceof Network)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    // set constant values
    this.options = {};
    this.defaultOptions = {
      locale: 'en',
      locales: locales,
      clickToUse: false
    };
    util.extend(this.options, this.defaultOptions);

    // containers for nodes and edges
    this.body = {
      container: container,
      nodes: {},
      nodeIndices: [],
      edges: {},
      edgeIndices: [],
      emitter: {
        on: this.on.bind(this),
        off: this.off.bind(this),
        emit: this.emit.bind(this),
        once: this.once.bind(this)
      },
      eventListeners: {
        onTap: function onTap() {},
        onTouch: function onTouch() {},
        onDoubleTap: function onDoubleTap() {},
        onHold: function onHold() {},
        onDragStart: function onDragStart() {},
        onDrag: function onDrag() {},
        onDragEnd: function onDragEnd() {},
        onMouseWheel: function onMouseWheel() {},
        onPinch: function onPinch() {},
        onMouseMove: function onMouseMove() {},
        onRelease: function onRelease() {},
        onContext: function onContext() {}
      },
      data: {
        nodes: null, // A DataSet or DataView
        edges: null // A DataSet or DataView
      },
      functions: {
        createNode: function createNode() {},
        createEdge: function createEdge() {},
        getPointer: function getPointer() {}
      },
      modules: {},
      view: {
        scale: 1,
        translation: { x: 0, y: 0 }
      }
    };

    // bind the event listeners
    this.bindEventListeners();

    // setting up all modules
    this.images = new _Images2.default(function () {
      return _this.body.emitter.emit("_requestRedraw");
    }); // object with images
    this.groups = new _Groups2.default(); // object with groups
    this.canvas = new _Canvas2.default(this.body); // DOM handler
    this.selectionHandler = new _SelectionHandler2.default(this.body, this.canvas); // Selection handler
    this.interactionHandler = new _InteractionHandler2.default(this.body, this.canvas, this.selectionHandler); // Interaction handler handles all the hammer bindings (that are bound by canvas), key
    this.view = new _View2.default(this.body, this.canvas); // camera handler, does animations and zooms
    this.renderer = new _CanvasRenderer2.default(this.body, this.canvas); // renderer, starts renderloop, has events that modules can hook into
    this.physics = new _PhysicsEngine2.default(this.body); // physics engine, does all the simulations
    this.layoutEngine = new _LayoutEngine2.default(this.body); // layout engine for inital layout and hierarchical layout
    this.clustering = new _Clustering2.default(this.body); // clustering api
    this.manipulation = new _ManipulationSystem2.default(this.body, this.canvas, this.selectionHandler); // data manipulation system

    this.nodesHandler = new _NodesHandler2.default(this.body, this.images, this.groups, this.layoutEngine); // Handle adding, deleting and updating of nodes as well as global options
    this.edgesHandler = new _EdgesHandler2.default(this.body, this.images, this.groups); // Handle adding, deleting and updating of edges as well as global options

    this.body.modules["kamadaKawai"] = new _KamadaKawai2.default(this.body, 150, 0.05); // Layouting algorithm.
    this.body.modules["clustering"] = this.clustering;

    // create the DOM elements
    this.canvas._create();

    // apply options
    this.setOptions(options);

    // load data (the disable start variable will be the same as the enabled clustering)
    this.setData(data);
  }

  // Extend Network with an Emitter mixin
  Emitter(Network.prototype);

  /**
   * Set options
   * @param {Object} options
   */
  Network.prototype.setOptions = function (options) {
    var _this2 = this;

    if (options !== undefined) {
      var errorFound = _Validator2.default.validate(options, _options.allOptions);
      if (errorFound === true) {
        console.log('%cErrors have been found in the supplied options object.', _Validator.printStyle);
      }

      // copy the global fields over
      var fields = ['locale', 'locales', 'clickToUse'];
      util.selectiveDeepExtend(fields, this.options, options);

      // the hierarchical system can adapt the edges and the physics to it's own options because not all combinations work with the hierarichical system.
      options = this.layoutEngine.setOptions(options.layout, options);

      this.canvas.setOptions(options); // options for canvas are in globals

      // pass the options to the modules
      this.groups.setOptions(options.groups);
      this.nodesHandler.setOptions(options.nodes);
      this.edgesHandler.setOptions(options.edges);
      this.physics.setOptions(options.physics);
      this.manipulation.setOptions(options.manipulation, options, this.options); // manipulation uses the locales in the globals

      this.interactionHandler.setOptions(options.interaction);
      this.renderer.setOptions(options.interaction); // options for rendering are in interaction
      this.selectionHandler.setOptions(options.interaction); // options for selection are in interaction

      // reload the settings of the nodes to apply changes in groups that are not referenced by pointer.
      if (options.groups !== undefined) {
        this.body.emitter.emit("refreshNodes");
      }
      // these two do not have options at the moment, here for completeness
      //this.view.setOptions(options.view);
      //this.clustering.setOptions(options.clustering);

      if ('configure' in options) {
        if (!this.configurator) {
          this.configurator = new _Configurator2.default(this, this.body.container, _options.configureOptions, this.canvas.pixelRatio);
        }

        this.configurator.setOptions(options.configure);
      }

      // if the configuration system is enabled, copy all options and put them into the config system
      if (this.configurator && this.configurator.options.enabled === true) {
        var networkOptions = { nodes: {}, edges: {}, layout: {}, interaction: {}, manipulation: {}, physics: {}, global: {} };
        util.deepExtend(networkOptions.nodes, this.nodesHandler.options);
        util.deepExtend(networkOptions.edges, this.edgesHandler.options);
        util.deepExtend(networkOptions.layout, this.layoutEngine.options);
        // load the selectionHandler and render default options in to the interaction group
        util.deepExtend(networkOptions.interaction, this.selectionHandler.options);
        util.deepExtend(networkOptions.interaction, this.renderer.options);

        util.deepExtend(networkOptions.interaction, this.interactionHandler.options);
        util.deepExtend(networkOptions.manipulation, this.manipulation.options);
        util.deepExtend(networkOptions.physics, this.physics.options);

        // load globals into the global object
        util.deepExtend(networkOptions.global, this.canvas.options);
        util.deepExtend(networkOptions.global, this.options);

        this.configurator.setModuleOptions(networkOptions);
      }

      // handle network global options
      if (options.clickToUse !== undefined) {
        if (options.clickToUse === true) {
          if (this.activator === undefined) {
            this.activator = new Activator(this.canvas.frame);
            this.activator.on('change', function () {
              _this2.body.emitter.emit("activate");
            });
          }
        } else {
          if (this.activator !== undefined) {
            this.activator.destroy();
            delete this.activator;
          }
          this.body.emitter.emit("activate");
        }
      } else {
        this.body.emitter.emit("activate");
      }

      this.canvas.setSize();
      // start the physics simulation. Can be safely called multiple times.
      this.body.emitter.emit("startSimulation");
    }
  };

  /**
   * Update the this.body.nodeIndices with the most recent node index list
   * @private
   */
  Network.prototype._updateVisibleIndices = function () {
    var nodes = this.body.nodes;
    var edges = this.body.edges;
    this.body.nodeIndices = [];
    this.body.edgeIndices = [];

    for (var nodeId in nodes) {
      if (nodes.hasOwnProperty(nodeId)) {
        if (nodes[nodeId].options.hidden === false) {
          this.body.nodeIndices.push(nodes[nodeId].id);
        }
      }
    }

    for (var edgeId in edges) {
      if (edges.hasOwnProperty(edgeId)) {
        if (edges[edgeId].options.hidden === false) {
          this.body.edgeIndices.push(edges[edgeId].id);
        }
      }
    }
  };

  /**
   * Bind all events
   */
  Network.prototype.bindEventListeners = function () {
    var _this3 = this;

    // this event will trigger a rebuilding of the cache everything. Used when nodes or edges have been added or removed.
    this.body.emitter.on("_dataChanged", function () {
      // update shortcut lists
      _this3._updateVisibleIndices();
      _this3.body.emitter.emit("_requestRedraw");
      // call the dataUpdated event because the only difference between the two is the updating of the indices
      _this3.body.emitter.emit("_dataUpdated");
    });

    // this is called when options of EXISTING nodes or edges have changed.
    this.body.emitter.on("_dataUpdated", function () {
      // update values
      _this3._updateValueRange(_this3.body.nodes);
      _this3._updateValueRange(_this3.body.edges);
      // start simulation (can be called safely, even if already running)
      _this3.body.emitter.emit("startSimulation");
      _this3.body.emitter.emit("_requestRedraw");
    });
  };

  /**
   * Set nodes and edges, and optionally options as well.
   *
   * @param {Object} data              Object containing parameters:
   *                                   {Array | DataSet | DataView} [nodes] Array with nodes
   *                                   {Array | DataSet | DataView} [edges] Array with edges
   *                                   {String} [dot] String containing data in DOT format
   *                                   {String} [gephi] String containing data in gephi JSON format
   *                                   {Options} [options] Object with options
   */
  Network.prototype.setData = function (data) {
    // reset the physics engine.
    this.body.emitter.emit("resetPhysics");
    this.body.emitter.emit("_resetData");

    // unselect all to ensure no selections from old data are carried over.
    this.selectionHandler.unselectAll();

    if (data && data.dot && (data.nodes || data.edges)) {
      throw new SyntaxError('Data must contain either parameter "dot" or ' + ' parameter pair "nodes" and "edges", but not both.');
    }

    // set options
    this.setOptions(data && data.options);
    // set all data
    if (data && data.dot) {
      console.log('The dot property has been depricated. Please use the static convertDot method to convert DOT into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertDot(dotString);');
      // parse DOT file
      var dotData = dotparser.DOTToGraph(data.dot);
      this.setData(dotData);
      return;
    } else if (data && data.gephi) {
      // parse DOT file
      console.log('The gephi property has been depricated. Please use the static convertGephi method to convert gephi into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertGephi(gephiJson);');
      var gephiData = gephiParser.parseGephi(data.gephi);
      this.setData(gephiData);
      return;
    } else {
      this.nodesHandler.setData(data && data.nodes, true);
      this.edgesHandler.setData(data && data.edges, true);
    }

    // emit change in data
    this.body.emitter.emit("_dataChanged");

    // emit data loaded
    this.body.emitter.emit("_dataLoaded");

    // find a stable position or start animating to a stable position
    this.body.emitter.emit("initPhysics");
  };

  /**
   * Cleans up all bindings of the network, removing it fully from the memory IF the variable is set to null after calling this function.
   * var network = new vis.Network(..);
   * network.destroy();
   * network = null;
   */
  Network.prototype.destroy = function () {
    this.body.emitter.emit("destroy");
    // clear events
    this.body.emitter.off();
    this.off();

    // delete modules
    delete this.groups;
    delete this.canvas;
    delete this.selectionHandler;
    delete this.interactionHandler;
    delete this.view;
    delete this.renderer;
    delete this.physics;
    delete this.layoutEngine;
    delete this.clustering;
    delete this.manipulation;
    delete this.nodesHandler;
    delete this.edgesHandler;
    delete this.configurator;
    delete this.images;

    for (var nodeId in this.body.nodes) {
      delete this.body.nodes[nodeId];
    }
    for (var edgeId in this.body.edges) {
      delete this.body.edges[edgeId];
    }

    // remove the container and everything inside it recursively
    util.recursiveDOMDelete(this.body.container);
  };

  /**
   * Update the values of all object in the given array according to the current
   * value range of the objects in the array.
   * @param {Object} obj    An object containing a set of Edges or Nodes
   *                        The objects must have a method getValue() and
   *                        setValueRange(min, max).
   * @private
   */
  Network.prototype._updateValueRange = function (obj) {
    var id;

    // determine the range of the objects
    var valueMin = undefined;
    var valueMax = undefined;
    var valueTotal = 0;
    for (id in obj) {
      if (obj.hasOwnProperty(id)) {
        var value = obj[id].getValue();
        if (value !== undefined) {
          valueMin = valueMin === undefined ? value : Math.min(value, valueMin);
          valueMax = valueMax === undefined ? value : Math.max(value, valueMax);
          valueTotal += value;
        }
      }
    }

    // adjust the range of all objects
    if (valueMin !== undefined && valueMax !== undefined) {
      for (id in obj) {
        if (obj.hasOwnProperty(id)) {
          obj[id].setValueRange(valueMin, valueMax, valueTotal);
        }
      }
    }
  };

  /**
   * Returns true when the Network is active.
   * @returns {boolean}
   */
  Network.prototype.isActive = function () {
    return !this.activator || this.activator.active;
  };

  Network.prototype.setSize = function () {
    return this.canvas.setSize.apply(this.canvas, arguments);
  };
  Network.prototype.canvasToDOM = function () {
    return this.canvas.canvasToDOM.apply(this.canvas, arguments);
  };
  Network.prototype.DOMtoCanvas = function () {
    return this.canvas.DOMtoCanvas.apply(this.canvas, arguments);
  };
  Network.prototype.findNode = function () {
    return this.clustering.findNode.apply(this.clustering, arguments);
  };
  Network.prototype.isCluster = function () {
    return this.clustering.isCluster.apply(this.clustering, arguments);
  };
  Network.prototype.openCluster = function () {
    return this.clustering.openCluster.apply(this.clustering, arguments);
  };
  Network.prototype.cluster = function () {
    return this.clustering.cluster.apply(this.clustering, arguments);
  };
  Network.prototype.getNodesInCluster = function () {
    return this.clustering.getNodesInCluster.apply(this.clustering, arguments);
  };
  Network.prototype.clusterByConnection = function () {
    return this.clustering.clusterByConnection.apply(this.clustering, arguments);
  };
  Network.prototype.clusterByHubsize = function () {
    return this.clustering.clusterByHubsize.apply(this.clustering, arguments);
  };
  Network.prototype.clusterOutliers = function () {
    return this.clustering.clusterOutliers.apply(this.clustering, arguments);
  };
  Network.prototype.getSeed = function () {
    return this.layoutEngine.getSeed.apply(this.layoutEngine, arguments);
  };
  Network.prototype.enableEditMode = function () {
    return this.manipulation.enableEditMode.apply(this.manipulation, arguments);
  };
  Network.prototype.disableEditMode = function () {
    return this.manipulation.disableEditMode.apply(this.manipulation, arguments);
  };
  Network.prototype.addNodeMode = function () {
    return this.manipulation.addNodeMode.apply(this.manipulation, arguments);
  };
  Network.prototype.editNode = function () {
    return this.manipulation.editNode.apply(this.manipulation, arguments);
  };
  Network.prototype.editNodeMode = function () {
    console.log("Deprecated: Please use editNode instead of editNodeMode.");return this.manipulation.editNode.apply(this.manipulation, arguments);
  };
  Network.prototype.addEdgeMode = function () {
    return this.manipulation.addEdgeMode.apply(this.manipulation, arguments);
  };
  Network.prototype.editEdgeMode = function () {
    return this.manipulation.editEdgeMode.apply(this.manipulation, arguments);
  };
  Network.prototype.deleteSelected = function () {
    return this.manipulation.deleteSelected.apply(this.manipulation, arguments);
  };
  Network.prototype.getPositions = function () {
    return this.nodesHandler.getPositions.apply(this.nodesHandler, arguments);
  };
  Network.prototype.storePositions = function () {
    return this.nodesHandler.storePositions.apply(this.nodesHandler, arguments);
  };
  Network.prototype.moveNode = function () {
    return this.nodesHandler.moveNode.apply(this.nodesHandler, arguments);
  };
  Network.prototype.getBoundingBox = function () {
    return this.nodesHandler.getBoundingBox.apply(this.nodesHandler, arguments);
  };
  Network.prototype.getConnectedNodes = function (objectId) {
    if (this.body.nodes[objectId] !== undefined) {
      return this.nodesHandler.getConnectedNodes.apply(this.nodesHandler, arguments);
    } else {
      return this.edgesHandler.getConnectedNodes.apply(this.edgesHandler, arguments);
    }
  };
  Network.prototype.getConnectedEdges = function () {
    return this.nodesHandler.getConnectedEdges.apply(this.nodesHandler, arguments);
  };
  Network.prototype.startSimulation = function () {
    return this.physics.startSimulation.apply(this.physics, arguments);
  };
  Network.prototype.stopSimulation = function () {
    return this.physics.stopSimulation.apply(this.physics, arguments);
  };
  Network.prototype.stabilize = function () {
    return this.physics.stabilize.apply(this.physics, arguments);
  };
  Network.prototype.getSelection = function () {
    return this.selectionHandler.getSelection.apply(this.selectionHandler, arguments);
  };
  Network.prototype.setSelection = function () {
    return this.selectionHandler.setSelection.apply(this.selectionHandler, arguments);
  };
  Network.prototype.getSelectedNodes = function () {
    return this.selectionHandler.getSelectedNodes.apply(this.selectionHandler, arguments);
  };
  Network.prototype.getSelectedEdges = function () {
    return this.selectionHandler.getSelectedEdges.apply(this.selectionHandler, arguments);
  };
  Network.prototype.getNodeAt = function () {
    var node = this.selectionHandler.getNodeAt.apply(this.selectionHandler, arguments);
    if (node !== undefined && node.id !== undefined) {
      return node.id;
    }
    return node;
  };
  Network.prototype.getEdgeAt = function () {
    var edge = this.selectionHandler.getEdgeAt.apply(this.selectionHandler, arguments);
    if (edge !== undefined && edge.id !== undefined) {
      return edge.id;
    }
    return edge;
  };
  Network.prototype.selectNodes = function () {
    return this.selectionHandler.selectNodes.apply(this.selectionHandler, arguments);
  };
  Network.prototype.selectEdges = function () {
    return this.selectionHandler.selectEdges.apply(this.selectionHandler, arguments);
  };
  Network.prototype.unselectAll = function () {
    this.selectionHandler.unselectAll.apply(this.selectionHandler, arguments);
    this.redraw();
  };
  Network.prototype.redraw = function () {
    return this.renderer.redraw.apply(this.renderer, arguments);
  };
  Network.prototype.getScale = function () {
    return this.view.getScale.apply(this.view, arguments);
  };
  Network.prototype.getViewPosition = function () {
    return this.view.getViewPosition.apply(this.view, arguments);
  };
  Network.prototype.fit = function () {
    return this.view.fit.apply(this.view, arguments);
  };
  Network.prototype.moveTo = function () {
    return this.view.moveTo.apply(this.view, arguments);
  };
  Network.prototype.focus = function () {
    return this.view.focus.apply(this.view, arguments);
  };
  Network.prototype.releaseNode = function () {
    return this.view.releaseNode.apply(this.view, arguments);
  };
  Network.prototype.getOptionsFromConfigurator = function () {
    var options = {};
    if (this.configurator) {
      options = this.configurator.getOptions.apply(this.configurator);
    }
    return options;
  };

  module.exports = Network;

/***/ },
/* 62 */
/***/ function(module, exports) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
      value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  /**
   * @class Images
   * This class loads images and keeps them stored.
   */

  var Images = function () {
      function Images(callback) {
          _classCallCheck(this, Images);

          this.images = {};
          this.imageBroken = {};
          this.callback = callback;
      }

      /**
       * @param {string} url                      The Url to cache the image as 
        * @return {Image} imageToLoadBrokenUrlOn  The image object
       */


      _createClass(Images, [{
          key: "_addImageToCache",
          value: function _addImageToCache(url, imageToCache) {
              // IE11 fix -- thanks dponch!
              if (imageToCache.width === 0) {
                  document.body.appendChild(imageToCache);
                  imageToCache.width = imageToCache.offsetWidth;
                  imageToCache.height = imageToCache.offsetHeight;
                  document.body.removeChild(imageToCache);
              }

              this.images[url] = imageToCache;
          }

          /**
           * @param {string} url                      The original Url that failed to load, if the broken image is successfully loaded it will be added to the cache using this Url as the key so that subsequent requests for this Url will return the broken image
           * @param {string} brokenUrl                Url the broken image to try and load
           * @return {Image} imageToLoadBrokenUrlOn   The image object
           */

      }, {
          key: "_tryloadBrokenUrl",
          value: function _tryloadBrokenUrl(url, brokenUrl, imageToLoadBrokenUrlOn) {
              var _this = this;

              //If any of the parameters aren't specified then exit the function because nothing constructive can be done
              if (url === undefined || brokenUrl === undefined || imageToLoadBrokenUrlOn === undefined) return;

              //Clear the old subscription to the error event and put a new in place that only handle errors in loading the brokenImageUrl
              imageToLoadBrokenUrlOn.onerror = function () {
                  console.error("Could not load brokenImage:", brokenUrl);
                  //Add an empty image to the cache so that when subsequent load calls are made for the url we don't try load the image and broken image again
                  _this._addImageToCache(url, new Image());
              };

              //Set the source of the image to the brokenUrl, this is actually what kicks off the loading of the broken image
              imageToLoadBrokenUrlOn.src = brokenUrl;
          }

          /**
           * @return {Image} imageToRedrawWith The images that will be passed to the callback when it is invoked
           */

      }, {
          key: "_redrawWithImage",
          value: function _redrawWithImage(imageToRedrawWith) {
              if (this.callback) {
                  this.callback(imageToRedrawWith);
              }
          }

          /**
           * @param {string} url          Url of the image
           * @param {string} brokenUrl    Url of an image to use if the url image is not found
           * @return {Image} img          The image object
           */

      }, {
          key: "load",
          value: function load(url, brokenUrl, id) {
              var _this2 = this;

              //Try and get the image from the cache, if successful then return the cached image  
              var cachedImage = this.images[url];
              if (cachedImage) return cachedImage;

              //Create a new image
              var img = new Image();

              //Subscribe to the event that is raised if the image loads successfully
              img.onload = function () {
                  //Add the image to the cache and then request a redraw
                  _this2._addImageToCache(url, img);
                  _this2._redrawWithImage(img);
              };

              //Subscribe to the event that is raised if the image fails to load
              img.onerror = function () {
                  console.error("Could not load image:", url);
                  //Try and load the image specified by the brokenUrl using
                  _this2._tryloadBrokenUrl(url, brokenUrl, img);
              };

              //Set the source of the image to the url, this is actuall what kicks off the loading of the image
              img.src = url;

              //Return the new image
              return img;
          }
      }]);

      return Images;
  }();

  exports.default = Images;

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);

  /**
   * @class Groups
   * This class can store groups and options specific for groups.
   */

  var Groups = function () {
    function Groups() {
      _classCallCheck(this, Groups);

      this.clear();
      this.defaultIndex = 0;
      this.groupsArray = [];
      this.groupIndex = 0;

      this.defaultGroups = [{ border: "#2B7CE9", background: "#97C2FC", highlight: { border: "#2B7CE9", background: "#D2E5FF" }, hover: { border: "#2B7CE9", background: "#D2E5FF" } }, // 0: blue
      { border: "#FFA500", background: "#FFFF00", highlight: { border: "#FFA500", background: "#FFFFA3" }, hover: { border: "#FFA500", background: "#FFFFA3" } }, // 1: yellow
      { border: "#FA0A10", background: "#FB7E81", highlight: { border: "#FA0A10", background: "#FFAFB1" }, hover: { border: "#FA0A10", background: "#FFAFB1" } }, // 2: red
      { border: "#41A906", background: "#7BE141", highlight: { border: "#41A906", background: "#A1EC76" }, hover: { border: "#41A906", background: "#A1EC76" } }, // 3: green
      { border: "#E129F0", background: "#EB7DF4", highlight: { border: "#E129F0", background: "#F0B3F5" }, hover: { border: "#E129F0", background: "#F0B3F5" } }, // 4: magenta
      { border: "#7C29F0", background: "#AD85E4", highlight: { border: "#7C29F0", background: "#D3BDF0" }, hover: { border: "#7C29F0", background: "#D3BDF0" } }, // 5: purple
      { border: "#C37F00", background: "#FFA807", highlight: { border: "#C37F00", background: "#FFCA66" }, hover: { border: "#C37F00", background: "#FFCA66" } }, // 6: orange
      { border: "#4220FB", background: "#6E6EFD", highlight: { border: "#4220FB", background: "#9B9BFD" }, hover: { border: "#4220FB", background: "#9B9BFD" } }, // 7: darkblue
      { border: "#FD5A77", background: "#FFC0CB", highlight: { border: "#FD5A77", background: "#FFD1D9" }, hover: { border: "#FD5A77", background: "#FFD1D9" } }, // 8: pink
      { border: "#4AD63A", background: "#C2FABC", highlight: { border: "#4AD63A", background: "#E6FFE3" }, hover: { border: "#4AD63A", background: "#E6FFE3" } }, // 9: mint

      { border: "#990000", background: "#EE0000", highlight: { border: "#BB0000", background: "#FF3333" }, hover: { border: "#BB0000", background: "#FF3333" } }, // 10:bright red

      { border: "#FF6000", background: "#FF6000", highlight: { border: "#FF6000", background: "#FF6000" }, hover: { border: "#FF6000", background: "#FF6000" } }, // 12: real orange
      { border: "#97C2FC", background: "#2B7CE9", highlight: { border: "#D2E5FF", background: "#2B7CE9" }, hover: { border: "#D2E5FF", background: "#2B7CE9" } }, // 13: blue
      { border: "#399605", background: "#255C03", highlight: { border: "#399605", background: "#255C03" }, hover: { border: "#399605", background: "#255C03" } }, // 14: green
      { border: "#B70054", background: "#FF007E", highlight: { border: "#B70054", background: "#FF007E" }, hover: { border: "#B70054", background: "#FF007E" } }, // 15: magenta
      { border: "#AD85E4", background: "#7C29F0", highlight: { border: "#D3BDF0", background: "#7C29F0" }, hover: { border: "#D3BDF0", background: "#7C29F0" } }, // 16: purple
      { border: "#4557FA", background: "#000EA1", highlight: { border: "#6E6EFD", background: "#000EA1" }, hover: { border: "#6E6EFD", background: "#000EA1" } }, // 17: darkblue
      { border: "#FFC0CB", background: "#FD5A77", highlight: { border: "#FFD1D9", background: "#FD5A77" }, hover: { border: "#FFD1D9", background: "#FD5A77" } }, // 18: pink
      { border: "#C2FABC", background: "#74D66A", highlight: { border: "#E6FFE3", background: "#74D66A" }, hover: { border: "#E6FFE3", background: "#74D66A" } }, // 19: mint

      { border: "#EE0000", background: "#990000", highlight: { border: "#FF3333", background: "#BB0000" }, hover: { border: "#FF3333", background: "#BB0000" } } // 20:bright red
      ];

      this.options = {};
      this.defaultOptions = {
        useDefaultGroups: true
      };
      util.extend(this.options, this.defaultOptions);
    }

    _createClass(Groups, [{
      key: "setOptions",
      value: function setOptions(options) {
        var optionFields = ['useDefaultGroups'];

        if (options !== undefined) {
          for (var groupName in options) {
            if (options.hasOwnProperty(groupName)) {
              if (optionFields.indexOf(groupName) === -1) {
                var group = options[groupName];
                this.add(groupName, group);
              }
            }
          }
        }
      }

      /**
       * Clear all groups
       */

    }, {
      key: "clear",
      value: function clear() {
        this.groups = {};
        this.groupsArray = [];
      }

      /**
       * get group options of a groupname. If groupname is not found, a new group
       * is added.
       * @param {*} groupname        Can be a number, string, Date, etc.
       * @return {Object} group      The created group, containing all group options
       */

    }, {
      key: "get",
      value: function get(groupname) {
        var group = this.groups[groupname];
        if (group === undefined) {
          if (this.options.useDefaultGroups === false && this.groupsArray.length > 0) {
            // create new group
            var index = this.groupIndex % this.groupsArray.length;
            this.groupIndex++;
            group = {};
            group.color = this.groups[this.groupsArray[index]];
            this.groups[groupname] = group;
          } else {
            // create new group
            var _index = this.defaultIndex % this.defaultGroups.length;
            this.defaultIndex++;
            group = {};
            group.color = this.defaultGroups[_index];
            this.groups[groupname] = group;
          }
        }

        return group;
      }

      /**
       * Add a custom group style
       * @param {String} groupName
       * @param {Object} style       An object containing borderColor,
       *                             backgroundColor, etc.
       * @return {Object} group      The created group object
       */

    }, {
      key: "add",
      value: function add(groupName, style) {
        this.groups[groupName] = style;
        this.groupsArray.push(groupName);
        return style;
      }
    }]);

    return Groups;
  }();

  exports.default = Groups;

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _Node = __webpack_require__(65);

  var _Node2 = _interopRequireDefault(_Node);

  var _Label = __webpack_require__(66);

  var _Label2 = _interopRequireDefault(_Label);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);
  var DataSet = __webpack_require__(9);
  var DataView = __webpack_require__(11);

  var NodesHandler = function () {
    function NodesHandler(body, images, groups, layoutEngine) {
      var _this = this;

      _classCallCheck(this, NodesHandler);

      this.body = body;
      this.images = images;
      this.groups = groups;
      this.layoutEngine = layoutEngine;

      // create the node API in the body container
      this.body.functions.createNode = this.create.bind(this);

      this.nodesListeners = {
        add: function add(event, params) {
          _this.add(params.items);
        },
        update: function update(event, params) {
          _this.update(params.items, params.data);
        },
        remove: function remove(event, params) {
          _this.remove(params.items);
        }
      };

      this.options = {};
      this.defaultOptions = {
        borderWidth: 1,
        borderWidthSelected: 2,
        brokenImage: undefined,
        color: {
          border: '#2B7CE9',
          background: '#97C2FC',
          highlight: {
            border: '#2B7CE9',
            background: '#D2E5FF'
          },
          hover: {
            border: '#2B7CE9',
            background: '#D2E5FF'
          }
        },
        fixed: {
          x: false,
          y: false
        },
        font: {
          color: '#343434',
          size: 14, // px
          face: 'arial',
          background: 'none',
          strokeWidth: 0, // px
          strokeColor: '#ffffff',
          align: 'center'
        },
        group: undefined,
        hidden: false,
        icon: {
          face: 'FontAwesome', //'FontAwesome',
          code: undefined, //'\uf007',
          size: 50, //50,
          color: '#2B7CE9' //'#aa00ff'
        },
        image: undefined, // --> URL
        label: undefined,
        labelHighlightBold: true,
        level: undefined,
        mass: 1,
        physics: true,
        scaling: {
          min: 10,
          max: 30,
          label: {
            enabled: false,
            min: 14,
            max: 30,
            maxVisible: 30,
            drawThreshold: 5
          },
          customScalingFunction: function customScalingFunction(min, max, total, value) {
            if (max === min) {
              return 0.5;
            } else {
              var scale = 1 / (max - min);
              return Math.max(0, (value - min) * scale);
            }
          }
        },
        shadow: {
          enabled: false,
          color: 'rgba(0,0,0,0.5)',
          size: 10,
          x: 5,
          y: 5
        },
        shape: 'ellipse',
        shapeProperties: {
          borderDashes: false, // only for borders
          borderRadius: 6, // only for box shape
          interpolation: true, // only for image and circularImage shapes
          useImageSize: false, // only for image and circularImage shapes
          useBorderWithImage: false // only for image shape
        },
        size: 25,
        title: undefined,
        value: undefined,
        x: undefined,
        y: undefined
      };
      util.extend(this.options, this.defaultOptions);

      this.bindEventListeners();
    }

    _createClass(NodesHandler, [{
      key: 'bindEventListeners',
      value: function bindEventListeners() {
        var _this2 = this;

        // refresh the nodes. Used when reverting from hierarchical layout
        this.body.emitter.on('refreshNodes', this.refresh.bind(this));
        this.body.emitter.on('refresh', this.refresh.bind(this));
        this.body.emitter.on('destroy', function () {
          util.forEach(_this2.nodesListeners, function (callback, event) {
            if (_this2.body.data.nodes) _this2.body.data.nodes.off(event, callback);
          });
          delete _this2.body.functions.createNode;
          delete _this2.nodesListeners.add;
          delete _this2.nodesListeners.update;
          delete _this2.nodesListeners.remove;
          delete _this2.nodesListeners;
        });
      }
    }, {
      key: 'setOptions',
      value: function setOptions(options) {
        if (options !== undefined) {
          _Node2.default.parseOptions(this.options, options);

          // update the shape in all nodes
          if (options.shape !== undefined) {
            for (var nodeId in this.body.nodes) {
              if (this.body.nodes.hasOwnProperty(nodeId)) {
                this.body.nodes[nodeId].updateShape();
              }
            }
          }

          // update the font in all nodes
          if (options.font !== undefined) {
            _Label2.default.parseOptions(this.options.font, options);
            for (var _nodeId in this.body.nodes) {
              if (this.body.nodes.hasOwnProperty(_nodeId)) {
                this.body.nodes[_nodeId].updateLabelModule();
                this.body.nodes[_nodeId]._reset();
              }
            }
          }

          // update the shape size in all nodes
          if (options.size !== undefined) {
            for (var _nodeId2 in this.body.nodes) {
              if (this.body.nodes.hasOwnProperty(_nodeId2)) {
                this.body.nodes[_nodeId2]._reset();
              }
            }
          }

          // update the state of the letiables if needed
          if (options.hidden !== undefined || options.physics !== undefined) {
            this.body.emitter.emit('_dataChanged');
          }
        }
      }

      /**
       * Set a data set with nodes for the network
       * @param {Array | DataSet | DataView} nodes         The data containing the nodes.
       * @private
       */

    }, {
      key: 'setData',
      value: function setData(nodes) {
        var _this3 = this;

        var doNotEmit = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

        var oldNodesData = this.body.data.nodes;

        if (nodes instanceof DataSet || nodes instanceof DataView) {
          this.body.data.nodes = nodes;
        } else if (Array.isArray(nodes)) {
          this.body.data.nodes = new DataSet();
          this.body.data.nodes.add(nodes);
        } else if (!nodes) {
          this.body.data.nodes = new DataSet();
        } else {
          throw new TypeError('Array or DataSet expected');
        }

        if (oldNodesData) {
          // unsubscribe from old dataset
          util.forEach(this.nodesListeners, function (callback, event) {
            oldNodesData.off(event, callback);
          });
        }

        // remove drawn nodes
        this.body.nodes = {};

        if (this.body.data.nodes) {
          (function () {
            // subscribe to new dataset
            var me = _this3;
            util.forEach(_this3.nodesListeners, function (callback, event) {
              me.body.data.nodes.on(event, callback);
            });

            // draw all new nodes
            var ids = _this3.body.data.nodes.getIds();
            _this3.add(ids, true);
          })();
        }

        if (doNotEmit === false) {
          this.body.emitter.emit("_dataChanged");
        }
      }

      /**
       * Add nodes
       * @param {Number[] | String[]} ids
       * @private
       */

    }, {
      key: 'add',
      value: function add(ids) {
        var doNotEmit = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

        var id = void 0;
        var newNodes = [];
        for (var i = 0; i < ids.length; i++) {
          id = ids[i];
          var properties = this.body.data.nodes.get(id);
          var node = this.create(properties);
          newNodes.push(node);
          this.body.nodes[id] = node; // note: this may replace an existing node
        }

        this.layoutEngine.positionInitially(newNodes);

        if (doNotEmit === false) {
          this.body.emitter.emit("_dataChanged");
        }
      }

      /**
       * Update existing nodes, or create them when not yet existing
       * @param {Number[] | String[]} ids
       * @private
       */

    }, {
      key: 'update',
      value: function update(ids, changedData) {
        var nodes = this.body.nodes;
        var dataChanged = false;
        for (var i = 0; i < ids.length; i++) {
          var id = ids[i];
          var node = nodes[id];
          var data = changedData[i];
          if (node !== undefined) {
            // update node
            dataChanged = node.setOptions(data);
          } else {
            dataChanged = true;
            // create node
            node = this.create(data);
            nodes[id] = node;
          }
        }
        if (dataChanged === true) {
          this.body.emitter.emit("_dataChanged");
        } else {
          this.body.emitter.emit("_dataUpdated");
        }
      }

      /**
       * Remove existing nodes. If nodes do not exist, the method will just ignore it.
       * @param {Number[] | String[]} ids
       * @private
       */

    }, {
      key: 'remove',
      value: function remove(ids) {
        var nodes = this.body.nodes;

        for (var i = 0; i < ids.length; i++) {
          var id = ids[i];
          delete nodes[id];
        }

        this.body.emitter.emit("_dataChanged");
      }

      /**
       * create a node
       * @param properties
       * @param constructorClass
       */

    }, {
      key: 'create',
      value: function create(properties) {
        var constructorClass = arguments.length <= 1 || arguments[1] === undefined ? _Node2.default : arguments[1];

        return new constructorClass(properties, this.body, this.images, this.groups, this.options);
      }
    }, {
      key: 'refresh',
      value: function refresh() {
        var clearPositions = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];

        var nodes = this.body.nodes;
        for (var nodeId in nodes) {
          var node = undefined;
          if (nodes.hasOwnProperty(nodeId)) {
            node = nodes[nodeId];
          }
          var data = this.body.data.nodes._data[nodeId];
          if (node !== undefined && data !== undefined) {
            if (clearPositions === true) {
              node.setOptions({ x: null, y: null });
            }
            node.setOptions({ fixed: false });
            node.setOptions(data);
          }
        }
      }

      /**
       * Returns the positions of the nodes.
       * @param ids  --> optional, can be array of nodeIds, can be string
       * @returns {{}}
       */

    }, {
      key: 'getPositions',
      value: function getPositions(ids) {
        var dataArray = {};
        if (ids !== undefined) {
          if (Array.isArray(ids) === true) {
            for (var i = 0; i < ids.length; i++) {
              if (this.body.nodes[ids[i]] !== undefined) {
                var node = this.body.nodes[ids[i]];
                dataArray[ids[i]] = { x: Math.round(node.x), y: Math.round(node.y) };
              }
            }
          } else {
            if (this.body.nodes[ids] !== undefined) {
              var _node = this.body.nodes[ids];
              dataArray[ids] = { x: Math.round(_node.x), y: Math.round(_node.y) };
            }
          }
        } else {
          for (var _i = 0; _i < this.body.nodeIndices.length; _i++) {
            var _node2 = this.body.nodes[this.body.nodeIndices[_i]];
            dataArray[this.body.nodeIndices[_i]] = { x: Math.round(_node2.x), y: Math.round(_node2.y) };
          }
        }
        return dataArray;
      }

      /**
       * Load the XY positions of the nodes into the dataset.
       */

    }, {
      key: 'storePositions',
      value: function storePositions() {
        // todo: add support for clusters and hierarchical.
        var dataArray = [];
        var dataset = this.body.data.nodes.getDataSet();

        for (var nodeId in dataset._data) {
          if (dataset._data.hasOwnProperty(nodeId)) {
            var node = this.body.nodes[nodeId];
            if (dataset._data[nodeId].x != Math.round(node.x) || dataset._data[nodeId].y != Math.round(node.y)) {
              dataArray.push({ id: node.id, x: Math.round(node.x), y: Math.round(node.y) });
            }
          }
        }
        dataset.update(dataArray);
      }

      /**
       * get the bounding box of a node.
       * @param nodeId
       * @returns {j|*}
       */

    }, {
      key: 'getBoundingBox',
      value: function getBoundingBox(nodeId) {
        if (this.body.nodes[nodeId] !== undefined) {
          return this.body.nodes[nodeId].shape.boundingBox;
        }
      }

      /**
       * Get the Ids of nodes connected to this node.
       * @param nodeId
       * @returns {Array}
       */

    }, {
      key: 'getConnectedNodes',
      value: function getConnectedNodes(nodeId) {
        var nodeList = [];
        if (this.body.nodes[nodeId] !== undefined) {
          var node = this.body.nodes[nodeId];
          var nodeObj = {}; // used to quickly check if node already exists
          for (var i = 0; i < node.edges.length; i++) {
            var edge = node.edges[i];
            if (edge.toId == node.id) {
              // these are double equals since ids can be numeric or string
              if (nodeObj[edge.fromId] === undefined) {
                nodeList.push(edge.fromId);
                nodeObj[edge.fromId] = true;
              }
            } else if (edge.fromId == node.id) {
              // these are double equals since ids can be numeric or string
              if (nodeObj[edge.toId] === undefined) {
                nodeList.push(edge.toId);
                nodeObj[edge.toId] = true;
              }
            }
          }
        }
        return nodeList;
      }

      /**
       * Get the ids of the edges connected to this node.
       * @param nodeId
       * @returns {*}
       */

    }, {
      key: 'getConnectedEdges',
      value: function getConnectedEdges(nodeId) {
        var edgeList = [];
        if (this.body.nodes[nodeId] !== undefined) {
          var node = this.body.nodes[nodeId];
          for (var i = 0; i < node.edges.length; i++) {
            edgeList.push(node.edges[i].id);
          }
        } else {
          console.log("NodeId provided for getConnectedEdges does not exist. Provided: ", nodeId);
        }
        return edgeList;
      }

      /**
       * Move a node.
       * @param String nodeId
       * @param Number x
       * @param Number y
       */

    }, {
      key: 'moveNode',
      value: function moveNode(nodeId, x, y) {
        var _this4 = this;

        if (this.body.nodes[nodeId] !== undefined) {
          this.body.nodes[nodeId].x = Number(x);
          this.body.nodes[nodeId].y = Number(y);
          setTimeout(function () {
            _this4.body.emitter.emit("startSimulation");
          }, 0);
        } else {
          console.log("Node id supplied to moveNode does not exist. Provided: ", nodeId);
        }
      }
    }]);

    return NodesHandler;
  }();

  exports.default = NodesHandler;

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _Label = __webpack_require__(66);

  var _Label2 = _interopRequireDefault(_Label);

  var _Box = __webpack_require__(67);

  var _Box2 = _interopRequireDefault(_Box);

  var _Circle = __webpack_require__(69);

  var _Circle2 = _interopRequireDefault(_Circle);

  var _CircularImage = __webpack_require__(71);

  var _CircularImage2 = _interopRequireDefault(_CircularImage);

  var _Database = __webpack_require__(72);

  var _Database2 = _interopRequireDefault(_Database);

  var _Diamond = __webpack_require__(73);

  var _Diamond2 = _interopRequireDefault(_Diamond);

  var _Dot = __webpack_require__(75);

  var _Dot2 = _interopRequireDefault(_Dot);

  var _Ellipse = __webpack_require__(76);

  var _Ellipse2 = _interopRequireDefault(_Ellipse);

  var _Icon = __webpack_require__(77);

  var _Icon2 = _interopRequireDefault(_Icon);

  var _Image = __webpack_require__(78);

  var _Image2 = _interopRequireDefault(_Image);

  var _Square = __webpack_require__(79);

  var _Square2 = _interopRequireDefault(_Square);

  var _Star = __webpack_require__(80);

  var _Star2 = _interopRequireDefault(_Star);

  var _Text = __webpack_require__(81);

  var _Text2 = _interopRequireDefault(_Text);

  var _Triangle = __webpack_require__(82);

  var _Triangle2 = _interopRequireDefault(_Triangle);

  var _TriangleDown = __webpack_require__(83);

  var _TriangleDown2 = _interopRequireDefault(_TriangleDown);

  var _Validator = __webpack_require__(29);

  var _Validator2 = _interopRequireDefault(_Validator);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);

  /**
   * @class Node
   * A node. A node can be connected to other nodes via one or multiple edges.
   * @param {object} options An object containing options for the node. All
   *                            options are optional, except for the id.
   *                              {number} id     Id of the node. Required
   *                              {string} label  Text label for the node
   *                              {number} x      Horizontal position of the node
   *                              {number} y      Vertical position of the node
   *                              {string} shape  Node shape, available:
   *                                              "database", "circle", "ellipse",
   *                                              "box", "image", "text", "dot",
   *                                              "star", "triangle", "triangleDown",
   *                                              "square", "icon"
   *                              {string} image  An image url
   *                              {string} title  An title text, can be HTML
   *                              {anytype} group A group name or number
   * @param {Network.Images} imagelist    A list with images. Only needed
   *                                            when the node has an image
   * @param {Network.Groups} grouplist    A list with groups. Needed for
   *                                            retrieving group options
   * @param {Object}               constants    An object with default values for
   *                                            example for the color
   *
   */

  var Node = function () {
    function Node(options, body, imagelist, grouplist, globalOptions) {
      _classCallCheck(this, Node);

      this.options = util.bridgeObject(globalOptions);
      this.globalOptions = globalOptions;
      this.body = body;

      this.edges = []; // all edges connected to this node

      // set defaults for the options
      this.id = undefined;
      this.imagelist = imagelist;
      this.grouplist = grouplist;

      // state options
      this.x = undefined;
      this.y = undefined;
      this.baseSize = this.options.size;
      this.baseFontSize = this.options.font.size;
      this.predefinedPosition = false; // used to check if initial fit should just take the range or approximate
      this.selected = false;
      this.hover = false;

      this.labelModule = new _Label2.default(this.body, this.options, false /* Not edge label */);
      this.setOptions(options);
    }

    /**
     * Attach a edge to the node
     * @param {Edge} edge
     */


    _createClass(Node, [{
      key: 'attachEdge',
      value: function attachEdge(edge) {
        if (this.edges.indexOf(edge) === -1) {
          this.edges.push(edge);
        }
      }

      /**
       * Detach a edge from the node
       * @param {Edge} edge
       */

    }, {
      key: 'detachEdge',
      value: function detachEdge(edge) {
        var index = this.edges.indexOf(edge);
        if (index != -1) {
          this.edges.splice(index, 1);
        }
      }

      /**
       * Set or overwrite options for the node
       * @param {Object} options an object with options
       * @param {Object} constants  and object with default, global options
       */

    }, {
      key: 'setOptions',
      value: function setOptions(options) {
        var currentShape = this.options.shape;
        if (!options) {
          return;
        }
        // basic options
        if (options.id !== undefined) {
          this.id = options.id;
        }

        if (this.id === undefined) {
          throw "Node must have an id";
        }

        // set these options locally
        // clear x and y positions
        if (options.x !== undefined) {
          if (options.x === null) {
            this.x = undefined;this.predefinedPosition = false;
          } else {
            this.x = parseInt(options.x);this.predefinedPosition = true;
          }
        }
        if (options.y !== undefined) {
          if (options.y === null) {
            this.y = undefined;this.predefinedPosition = false;
          } else {
            this.y = parseInt(options.y);this.predefinedPosition = true;
          }
        }
        if (options.size !== undefined) {
          this.baseSize = options.size;
        }
        if (options.value !== undefined) {
          options.value = parseFloat(options.value);
        }

        // copy group options
        if (typeof options.group === 'number' || typeof options.group === 'string' && options.group != '') {
          var groupObj = this.grouplist.get(options.group);
          util.deepExtend(this.options, groupObj);
          // the color object needs to be completely defined. Since groups can partially overwrite the colors, we parse it again, just in case.
          this.options.color = util.parseColor(this.options.color);
        }

        // this transforms all shorthands into fully defined options
        Node.parseOptions(this.options, options, true, this.globalOptions);

        // load the images
        if (this.options.image !== undefined) {
          if (this.imagelist) {
            this.imageObj = this.imagelist.load(this.options.image, this.options.brokenImage, this.id);
          } else {
            throw "No imagelist provided";
          }
        }

        this.updateLabelModule();
        this.updateShape(currentShape);

        if (options.hidden !== undefined || options.physics !== undefined) {
          return true;
        }
        return false;
      }

      /**
       * This process all possible shorthands in the new options and makes sure that the parentOptions are fully defined.
       * Static so it can also be used by the handler.
       * @param parentOptions
       * @param newOptions
       * @param allowDeletion
       * @param globalOptions
       */

    }, {
      key: 'updateLabelModule',
      value: function updateLabelModule() {
        if (this.options.label === undefined || this.options.label === null) {
          this.options.label = '';
        }
        this.labelModule.setOptions(this.options, true);
        if (this.labelModule.baseSize !== undefined) {
          this.baseFontSize = this.labelModule.baseSize;
        }
      }
    }, {
      key: 'updateShape',
      value: function updateShape(currentShape) {
        if (currentShape === this.options.shape && this.shape) {
          this.shape.setOptions(this.options, this.imageObj);
        } else {
          // choose draw method depending on the shape
          switch (this.options.shape) {
            case 'box':
              this.shape = new _Box2.default(this.options, this.body, this.labelModule);
              break;
            case 'circle':
              this.shape = new _Circle2.default(this.options, this.body, this.labelModule);
              break;
            case 'circularImage':
              this.shape = new _CircularImage2.default(this.options, this.body, this.labelModule, this.imageObj);
              break;
            case 'database':
              this.shape = new _Database2.default(this.options, this.body, this.labelModule);
              break;
            case 'diamond':
              this.shape = new _Diamond2.default(this.options, this.body, this.labelModule);
              break;
            case 'dot':
              this.shape = new _Dot2.default(this.options, this.body, this.labelModule);
              break;
            case 'ellipse':
              this.shape = new _Ellipse2.default(this.options, this.body, this.labelModule);
              break;
            case 'icon':
              this.shape = new _Icon2.default(this.options, this.body, this.labelModule);
              break;
            case 'image':
              this.shape = new _Image2.default(this.options, this.body, this.labelModule, this.imageObj);
              break;
            case 'square':
              this.shape = new _Square2.default(this.options, this.body, this.labelModule);
              break;
            case 'star':
              this.shape = new _Star2.default(this.options, this.body, this.labelModule);
              break;
            case 'text':
              this.shape = new _Text2.default(this.options, this.body, this.labelModule);
              break;
            case 'triangle':
              this.shape = new _Triangle2.default(this.options, this.body, this.labelModule);
              break;
            case 'triangleDown':
              this.shape = new _TriangleDown2.default(this.options, this.body, this.labelModule);
              break;
            default:
              this.shape = new _Ellipse2.default(this.options, this.body, this.labelModule);
              break;
          }
        }
        this._reset();
      }

      /**
       * select this node
       */

    }, {
      key: 'select',
      value: function select() {
        this.selected = true;
        this._reset();
      }

      /**
       * unselect this node
       */

    }, {
      key: 'unselect',
      value: function unselect() {
        this.selected = false;
        this._reset();
      }

      /**
       * Reset the calculated size of the node, forces it to recalculate its size
       * @private
       */

    }, {
      key: '_reset',
      value: function _reset() {
        this.shape.width = undefined;
        this.shape.height = undefined;
      }

      /**
       * get the title of this node.
       * @return {string} title    The title of the node, or undefined when no title
       *                           has been set.
       */

    }, {
      key: 'getTitle',
      value: function getTitle() {
        return this.options.title;
      }

      /**
       * Calculate the distance to the border of the Node
       * @param {CanvasRenderingContext2D}   ctx
       * @param {Number} angle        Angle in radians
       * @returns {number} distance   Distance to the border in pixels
       */

    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        return this.shape.distanceToBorder(ctx, angle);
      }

      /**
       * Check if this node has a fixed x and y position
       * @return {boolean}      true if fixed, false if not
       */

    }, {
      key: 'isFixed',
      value: function isFixed() {
        return this.options.fixed.x && this.options.fixed.y;
      }

      /**
       * check if this node is selecte
       * @return {boolean} selected   True if node is selected, else false
       */

    }, {
      key: 'isSelected',
      value: function isSelected() {
        return this.selected;
      }

      /**
       * Retrieve the value of the node. Can be undefined
       * @return {Number} value
       */

    }, {
      key: 'getValue',
      value: function getValue() {
        return this.options.value;
      }

      /**
       * Adjust the value range of the node. The node will adjust it's size
       * based on its value.
       * @param {Number} min
       * @param {Number} max
       */

    }, {
      key: 'setValueRange',
      value: function setValueRange(min, max, total) {
        if (this.options.value !== undefined) {
          var scale = this.options.scaling.customScalingFunction(min, max, total, this.options.value);
          var sizeDiff = this.options.scaling.max - this.options.scaling.min;
          if (this.options.scaling.label.enabled === true) {
            var fontDiff = this.options.scaling.label.max - this.options.scaling.label.min;
            this.options.font.size = this.options.scaling.label.min + scale * fontDiff;
          }
          this.options.size = this.options.scaling.min + scale * sizeDiff;
        } else {
          this.options.size = this.baseSize;
          this.options.font.size = this.baseFontSize;
        }

        this.updateLabelModule();
      }

      /**
       * Draw this node in the given canvas
       * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
       * @param {CanvasRenderingContext2D}   ctx
       */

    }, {
      key: 'draw',
      value: function draw(ctx) {
        this.shape.draw(ctx, this.x, this.y, this.selected, this.hover);
      }

      /**
       * Update the bounding box of the shape
       */

    }, {
      key: 'updateBoundingBox',
      value: function updateBoundingBox(ctx) {
        this.shape.updateBoundingBox(this.x, this.y, ctx);
      }

      /**
       * Recalculate the size of this node in the given canvas
       * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
       * @param {CanvasRenderingContext2D}   ctx
       */

    }, {
      key: 'resize',
      value: function resize(ctx) {
        this.shape.resize(ctx, this.selected);
      }

      /**
       * Check if this object is overlapping with the provided object
       * @param {Object} obj   an object with parameters left, top, right, bottom
       * @return {boolean}     True if location is located on node
       */

    }, {
      key: 'isOverlappingWith',
      value: function isOverlappingWith(obj) {
        return this.shape.left < obj.right && this.shape.left + this.shape.width > obj.left && this.shape.top < obj.bottom && this.shape.top + this.shape.height > obj.top;
      }

      /**
       * Check if this object is overlapping with the provided object
       * @param {Object} obj   an object with parameters left, top, right, bottom
       * @return {boolean}     True if location is located on node
       */

    }, {
      key: 'isBoundingBoxOverlappingWith',
      value: function isBoundingBoxOverlappingWith(obj) {
        return this.shape.boundingBox.left < obj.right && this.shape.boundingBox.right > obj.left && this.shape.boundingBox.top < obj.bottom && this.shape.boundingBox.bottom > obj.top;
      }
    }], [{
      key: 'parseOptions',
      value: function parseOptions(parentOptions, newOptions) {
        var allowDeletion = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];
        var globalOptions = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

        var fields = ['color', 'font', 'fixed', 'shadow'];
        util.selectiveNotDeepExtend(fields, parentOptions, newOptions, allowDeletion);

        // merge the shadow options into the parent.
        util.mergeOptions(parentOptions, newOptions, 'shadow', allowDeletion, globalOptions);

        // individual shape newOptions
        if (newOptions.color !== undefined && newOptions.color !== null) {
          var parsedColor = util.parseColor(newOptions.color);
          util.fillIfDefined(parentOptions.color, parsedColor);
        } else if (allowDeletion === true && newOptions.color === null) {
          parentOptions.color = util.bridgeObject(globalOptions.color); // set the object back to the global options
        }

        // handle the fixed options
        if (newOptions.fixed !== undefined && newOptions.fixed !== null) {
          if (typeof newOptions.fixed === 'boolean') {
            parentOptions.fixed.x = newOptions.fixed;
            parentOptions.fixed.y = newOptions.fixed;
          } else {
            if (newOptions.fixed.x !== undefined && typeof newOptions.fixed.x === 'boolean') {
              parentOptions.fixed.x = newOptions.fixed.x;
            }
            if (newOptions.fixed.y !== undefined && typeof newOptions.fixed.y === 'boolean') {
              parentOptions.fixed.y = newOptions.fixed.y;
            }
          }
        }

        // handle the font options
        if (newOptions.font !== undefined && newOptions.font !== null) {
          _Label2.default.parseOptions(parentOptions.font, newOptions);
        } else if (allowDeletion === true && newOptions.font === null) {
          parentOptions.font = util.bridgeObject(globalOptions.font); // set the object back to the global options
        }

        // handle the scaling options, specifically the label part
        if (newOptions.scaling !== undefined) {
          util.mergeOptions(parentOptions.scaling, newOptions.scaling, 'label', allowDeletion, globalOptions.scaling);
        }
      }
    }]);

    return Node;
  }();

  exports.default = Node;

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);

  var Label = function () {
    function Label(body, options) {
      var edgelabel = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

      _classCallCheck(this, Label);

      this.body = body;

      this.pointToSelf = false;
      this.baseSize = undefined;
      this.fontOptions = {};
      this.setOptions(options);
      this.size = { top: 0, left: 0, width: 0, height: 0, yLine: 0 }; // could be cached
      this.isEdgeLabel = edgelabel;
    }

    _createClass(Label, [{
      key: 'setOptions',
      value: function setOptions(options) {
        var allowDeletion = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

        this.nodeOptions = options;

        // We want to keep the font options seperated from the node options.
        // The node options have to mirror the globals when they are not overruled.
        this.fontOptions = util.deepExtend({}, options.font, true);

        if (options.label !== undefined) {
          this.labelDirty = true;
        }

        if (options.font !== undefined) {
          Label.parseOptions(this.fontOptions, options, allowDeletion);
          if (typeof options.font === 'string') {
            this.baseSize = this.fontOptions.size;
          } else if (_typeof(options.font) === 'object') {
            if (options.font.size !== undefined) {
              this.baseSize = options.font.size;
            }
          }
        }
      }
    }, {
      key: 'draw',


      /**
       * Main function. This is called from anything that wants to draw a label.
       * @param ctx
       * @param x
       * @param y
       * @param selected
       * @param baseline
       */
      value: function draw(ctx, x, y, selected) {
        var baseline = arguments.length <= 4 || arguments[4] === undefined ? 'middle' : arguments[4];

        // if no label, return
        if (this.nodeOptions.label === undefined) return;

        // check if we have to render the label
        var viewFontSize = this.fontOptions.size * this.body.view.scale;
        if (this.nodeOptions.label && viewFontSize < this.nodeOptions.scaling.label.drawThreshold - 1) return;

        // update the size cache if required
        this.calculateLabelSize(ctx, selected, x, y, baseline);

        // create the fontfill background
        this._drawBackground(ctx);
        // draw text
        this._drawText(ctx, selected, x, y, baseline);
      }

      /**
       * Draws the label background
       * @param {CanvasRenderingContext2D} ctx
       * @private
       */

    }, {
      key: '_drawBackground',
      value: function _drawBackground(ctx) {
        if (this.fontOptions.background !== undefined && this.fontOptions.background !== "none") {
          ctx.fillStyle = this.fontOptions.background;

          var lineMargin = 2;

          if (this.isEdgeLabel) {
            switch (this.fontOptions.align) {
              case 'middle':
                ctx.fillRect(-this.size.width * 0.5, -this.size.height * 0.5, this.size.width, this.size.height);
                break;
              case 'top':
                ctx.fillRect(-this.size.width * 0.5, -(this.size.height + lineMargin), this.size.width, this.size.height);
                break;
              case 'bottom':
                ctx.fillRect(-this.size.width * 0.5, lineMargin, this.size.width, this.size.height);
                break;
              default:
                ctx.fillRect(this.size.left, this.size.top - 0.5 * lineMargin, this.size.width, this.size.height);
                break;
            }
          } else {
            ctx.fillRect(this.size.left, this.size.top - 0.5 * lineMargin, this.size.width, this.size.height);
          }
        }
      }

      /**
       *
       * @param ctx
       * @param x
       * @param baseline
       * @private
       */

    }, {
      key: '_drawText',
      value: function _drawText(ctx, selected, x, y) {
        var baseline = arguments.length <= 4 || arguments[4] === undefined ? 'middle' : arguments[4];

        var fontSize = this.fontOptions.size;
        var viewFontSize = fontSize * this.body.view.scale;
        // this ensures that there will not be HUGE letters on screen by setting an upper limit on the visible text size (regardless of zoomLevel)
        if (viewFontSize >= this.nodeOptions.scaling.label.maxVisible) {
          fontSize = Number(this.nodeOptions.scaling.label.maxVisible) / this.body.view.scale;
        }

        var yLine = this.size.yLine;

        var _getColor2 = this._getColor(viewFontSize);

        var _getColor3 = _slicedToArray(_getColor2, 2);

        var fontColor = _getColor3[0];
        var strokeColor = _getColor3[1];


        // configure context for drawing the text

        var _setAlignment2 = this._setAlignment(ctx, x, yLine, baseline);

        var _setAlignment3 = _slicedToArray(_setAlignment2, 2);

        x = _setAlignment3[0];
        yLine = _setAlignment3[1];
        ctx.font = (selected && this.nodeOptions.labelHighlightBold ? 'bold ' : '') + fontSize + "px " + this.fontOptions.face;
        ctx.fillStyle = fontColor;
        // When the textAlign property is 'left', make label left-justified
        if (!this.isEdgeLabel && this.fontOptions.align === 'left') {
          ctx.textAlign = this.fontOptions.align;
          x = x - 0.5 * this.size.width; // Shift label 1/2-distance to the left
        } else {
            ctx.textAlign = 'center';
          }

        // set the strokeWidth
        if (this.fontOptions.strokeWidth > 0) {
          ctx.lineWidth = this.fontOptions.strokeWidth;
          ctx.strokeStyle = strokeColor;
          ctx.lineJoin = 'round';
        }

        // draw the text
        for (var i = 0; i < this.lineCount; i++) {
          if (this.fontOptions.strokeWidth > 0) {
            ctx.strokeText(this.lines[i], x, yLine);
          }
          ctx.fillText(this.lines[i], x, yLine);
          yLine += fontSize;
        }
      }
    }, {
      key: '_setAlignment',
      value: function _setAlignment(ctx, x, yLine, baseline) {
        // check for label alignment (for edges)
        // TODO: make alignment for nodes
        if (this.isEdgeLabel && this.fontOptions.align !== 'horizontal' && this.pointToSelf === false) {
          x = 0;
          yLine = 0;

          var lineMargin = 2;
          if (this.fontOptions.align === 'top') {
            ctx.textBaseline = 'alphabetic';
            yLine -= 2 * lineMargin; // distance from edge, required because we use alphabetic. Alphabetic has less difference between browsers
          } else if (this.fontOptions.align === 'bottom') {
              ctx.textBaseline = 'hanging';
              yLine += 2 * lineMargin; // distance from edge, required because we use hanging. Hanging has less difference between browsers
            } else {
                ctx.textBaseline = 'middle';
              }
        } else {
          ctx.textBaseline = baseline;
        }

        return [x, yLine];
      }

      /**
       * fade in when relative scale is between threshold and threshold - 1.
       * If the relative scale would be smaller than threshold -1 the draw function would have returned before coming here.
       *
       * @param viewFontSize
       * @returns {*[]}
       * @private
       */

    }, {
      key: '_getColor',
      value: function _getColor(viewFontSize) {
        var fontColor = this.fontOptions.color || '#000000';
        var strokeColor = this.fontOptions.strokeColor || '#ffffff';
        if (viewFontSize <= this.nodeOptions.scaling.label.drawThreshold) {
          var opacity = Math.max(0, Math.min(1, 1 - (this.nodeOptions.scaling.label.drawThreshold - viewFontSize)));
          fontColor = util.overrideOpacity(fontColor, opacity);
          strokeColor = util.overrideOpacity(strokeColor, opacity);
        }
        return [fontColor, strokeColor];
      }

      /**
       *
       * @param ctx
       * @param selected
       * @returns {{width: number, height: number}}
       */

    }, {
      key: 'getTextSize',
      value: function getTextSize(ctx) {
        var selected = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

        var size = {
          width: this._processLabel(ctx, selected),
          height: this.fontOptions.size * this.lineCount,
          lineCount: this.lineCount
        };
        return size;
      }

      /**
       *
       * @param ctx
       * @param selected
       * @param x
       * @param y
       * @param baseline
       */

    }, {
      key: 'calculateLabelSize',
      value: function calculateLabelSize(ctx, selected) {
        var x = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
        var y = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];
        var baseline = arguments.length <= 4 || arguments[4] === undefined ? 'middle' : arguments[4];

        if (this.labelDirty === true) {
          this.size.width = this._processLabel(ctx, selected);
        }
        this.size.height = this.fontOptions.size * this.lineCount;
        this.size.left = x - this.size.width * 0.5;
        this.size.top = y - this.size.height * 0.5;
        this.size.yLine = y + (1 - this.lineCount) * 0.5 * this.fontOptions.size;
        if (baseline === "hanging") {
          this.size.top += 0.5 * this.fontOptions.size;
          this.size.top += 4; // distance from node, required because we use hanging. Hanging has less difference between browsers
          this.size.yLine += 4; // distance from node
        }

        this.labelDirty = false;
      }

      /**
       * This calculates the width as well as explodes the label string and calculates the amount of lines.
       * @param ctx
       * @param selected
       * @returns {number}
       * @private
       */

    }, {
      key: '_processLabel',
      value: function _processLabel(ctx, selected) {
        var width = 0;
        var lines = [''];
        var lineCount = 0;
        if (this.nodeOptions.label !== undefined) {
          lines = String(this.nodeOptions.label).split('\n');
          lineCount = lines.length;
          ctx.font = (selected && this.nodeOptions.labelHighlightBold ? 'bold ' : '') + this.fontOptions.size + "px " + this.fontOptions.face;
          width = ctx.measureText(lines[0]).width;
          for (var i = 1; i < lineCount; i++) {
            var lineWidth = ctx.measureText(lines[i]).width;
            width = lineWidth > width ? lineWidth : width;
          }
        }
        this.lines = lines;
        this.lineCount = lineCount;

        return width;
      }
    }], [{
      key: 'parseOptions',
      value: function parseOptions(parentOptions, newOptions) {
        var allowDeletion = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

        if (typeof newOptions.font === 'string') {
          var newOptionsArray = newOptions.font.split(" ");
          parentOptions.size = newOptionsArray[0].replace("px", '');
          parentOptions.face = newOptionsArray[1];
          parentOptions.color = newOptionsArray[2];
        } else if (_typeof(newOptions.font) === 'object') {
          util.fillIfDefined(parentOptions, newOptions.font, allowDeletion);
        }
        parentOptions.size = Number(parentOptions.size);
      }
    }]);

    return Label;
  }();

  exports.default = Label;

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _NodeBase2 = __webpack_require__(68);

  var _NodeBase3 = _interopRequireDefault(_NodeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var Box = function (_NodeBase) {
    _inherits(Box, _NodeBase);

    function Box(options, body, labelModule) {
      _classCallCheck(this, Box);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(Box).call(this, options, body, labelModule));
    }

    _createClass(Box, [{
      key: 'resize',
      value: function resize(ctx, selected) {
        if (this.width === undefined) {
          var margin = 5;
          var textSize = this.labelModule.getTextSize(ctx, selected);
          this.width = textSize.width + 2 * margin;
          this.height = textSize.height + 2 * margin;
          this.radius = 0.5 * this.width;
        }
      }
    }, {
      key: 'draw',
      value: function draw(ctx, x, y, selected, hover) {
        this.resize(ctx, selected);
        this.left = x - this.width / 2;
        this.top = y - this.height / 2;

        var borderWidth = this.options.borderWidth;
        var selectionLineWidth = this.options.borderWidthSelected || 2 * this.options.borderWidth;

        ctx.strokeStyle = selected ? this.options.color.highlight.border : hover ? this.options.color.hover.border : this.options.color.border;
        ctx.lineWidth = selected ? selectionLineWidth : borderWidth;
        ctx.lineWidth /= this.body.view.scale;
        ctx.lineWidth = Math.min(this.width, ctx.lineWidth);

        ctx.fillStyle = selected ? this.options.color.highlight.background : hover ? this.options.color.hover.background : this.options.color.background;

        var borderRadius = this.options.shapeProperties.borderRadius; // only effective for box
        ctx.roundRect(this.left, this.top, this.width, this.height, borderRadius);

        // draw shadow if enabled
        this.enableShadow(ctx);
        // draw the background
        ctx.fill();
        // disable shadows for other elements.
        this.disableShadow(ctx);

        //draw dashed border if enabled, save and restore is required for firefox not to crash on unix.
        ctx.save();
        // if borders are zero width, they will be drawn with width 1 by default. This prevents that
        if (borderWidth > 0) {
          this.enableBorderDashes(ctx);
          //draw the border
          ctx.stroke();
          //disable dashed border for other elements
          this.disableBorderDashes(ctx);
        }
        ctx.restore();

        this.updateBoundingBox(x, y, ctx, selected);
        this.labelModule.draw(ctx, x, y, selected);
      }
    }, {
      key: 'updateBoundingBox',
      value: function updateBoundingBox(x, y, ctx, selected) {
        this.resize(ctx, selected);
        this.left = x - this.width * 0.5;
        this.top = y - this.height * 0.5;

        var borderRadius = this.options.shapeProperties.borderRadius; // only effective for box
        this.boundingBox.left = this.left - borderRadius;
        this.boundingBox.top = this.top - borderRadius;
        this.boundingBox.bottom = this.top + this.height + borderRadius;
        this.boundingBox.right = this.left + this.width + borderRadius;
      }
    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        this.resize(ctx);
        var borderWidth = this.options.borderWidth;

        return Math.min(Math.abs(this.width / 2 / Math.cos(angle)), Math.abs(this.height / 2 / Math.sin(angle))) + borderWidth;
      }
    }]);

    return Box;
  }(_NodeBase3.default);

  exports.default = Box;

/***/ },
/* 68 */
/***/ function(module, exports) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var NodeBase = function () {
    function NodeBase(options, body, labelModule) {
      _classCallCheck(this, NodeBase);

      this.body = body;
      this.labelModule = labelModule;
      this.setOptions(options);
      this.top = undefined;
      this.left = undefined;
      this.height = undefined;
      this.width = undefined;
      this.radius = undefined;
      this.boundingBox = { top: 0, left: 0, right: 0, bottom: 0 };
    }

    _createClass(NodeBase, [{
      key: "setOptions",
      value: function setOptions(options) {
        this.options = options;
      }
    }, {
      key: "_distanceToBorder",
      value: function _distanceToBorder(ctx, angle) {
        var borderWidth = this.options.borderWidth;
        this.resize(ctx);
        return Math.min(Math.abs(this.width / 2 / Math.cos(angle)), Math.abs(this.height / 2 / Math.sin(angle))) + borderWidth;
      }
    }, {
      key: "enableShadow",
      value: function enableShadow(ctx) {
        if (this.options.shadow.enabled === true) {
          ctx.shadowColor = this.options.shadow.color;
          ctx.shadowBlur = this.options.shadow.size;
          ctx.shadowOffsetX = this.options.shadow.x;
          ctx.shadowOffsetY = this.options.shadow.y;
        }
      }
    }, {
      key: "disableShadow",
      value: function disableShadow(ctx) {
        if (this.options.shadow.enabled === true) {
          ctx.shadowColor = 'rgba(0,0,0,0)';
          ctx.shadowBlur = 0;
          ctx.shadowOffsetX = 0;
          ctx.shadowOffsetY = 0;
        }
      }
    }, {
      key: "enableBorderDashes",
      value: function enableBorderDashes(ctx) {
        if (this.options.shapeProperties.borderDashes !== false) {
          if (ctx.setLineDash !== undefined) {
            var dashes = this.options.shapeProperties.borderDashes;
            if (dashes === true) {
              dashes = [5, 15];
            }
            ctx.setLineDash(dashes);
          } else {
            console.warn("setLineDash is not supported in this browser. The dashed borders cannot be used.");
            this.options.shapeProperties.borderDashes = false;
          }
        }
      }
    }, {
      key: "disableBorderDashes",
      value: function disableBorderDashes(ctx) {
        if (this.options.shapeProperties.borderDashes !== false) {
          if (ctx.setLineDash !== undefined) {
            ctx.setLineDash([0]);
          } else {
            console.warn("setLineDash is not supported in this browser. The dashed borders cannot be used.");
            this.options.shapeProperties.borderDashes = false;
          }
        }
      }
    }]);

    return NodeBase;
  }();

  exports.default = NodeBase;

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _CircleImageBase2 = __webpack_require__(70);

  var _CircleImageBase3 = _interopRequireDefault(_CircleImageBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var Circle = function (_CircleImageBase) {
    _inherits(Circle, _CircleImageBase);

    function Circle(options, body, labelModule) {
      _classCallCheck(this, Circle);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(Circle).call(this, options, body, labelModule));
    }

    _createClass(Circle, [{
      key: 'resize',
      value: function resize(ctx, selected) {
        if (this.width === undefined) {
          var margin = 5;
          var textSize = this.labelModule.getTextSize(ctx, selected);
          var diameter = Math.max(textSize.width, textSize.height) + 2 * margin;
          this.options.size = diameter / 2;

          this.width = diameter;
          this.height = diameter;
          this.radius = 0.5 * this.width;
        }
      }
    }, {
      key: 'draw',
      value: function draw(ctx, x, y, selected, hover) {
        this.resize(ctx, selected);
        this.left = x - this.width / 2;
        this.top = y - this.height / 2;

        this._drawRawCircle(ctx, x, y, selected, hover, this.options.size);

        this.boundingBox.top = y - this.options.size;
        this.boundingBox.left = x - this.options.size;
        this.boundingBox.right = x + this.options.size;
        this.boundingBox.bottom = y + this.options.size;

        this.updateBoundingBox(x, y);
        this.labelModule.draw(ctx, x, y, selected);
      }
    }, {
      key: 'updateBoundingBox',
      value: function updateBoundingBox(x, y) {
        this.boundingBox.top = y - this.options.size;
        this.boundingBox.left = x - this.options.size;
        this.boundingBox.right = x + this.options.size;
        this.boundingBox.bottom = y + this.options.size;
      }
    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        this.resize(ctx);
        return this.width * 0.5;
      }
    }]);

    return Circle;
  }(_CircleImageBase3.default);

  exports.default = Circle;

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _NodeBase2 = __webpack_require__(68);

  var _NodeBase3 = _interopRequireDefault(_NodeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var CircleImageBase = function (_NodeBase) {
    _inherits(CircleImageBase, _NodeBase);

    function CircleImageBase(options, body, labelModule) {
      _classCallCheck(this, CircleImageBase);

      var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(CircleImageBase).call(this, options, body, labelModule));

      _this.labelOffset = 0;
      _this.imageLoaded = false;
      return _this;
    }

    _createClass(CircleImageBase, [{
      key: 'setOptions',
      value: function setOptions(options, imageObj) {
        this.options = options;
        if (imageObj) {
          this.imageObj = imageObj;
        }
      }

      /**
       * This function resizes the image by the options size when the image has not yet loaded. If the image has loaded, we
       * force the update of the size again.
       *
       * @private
       */

    }, {
      key: '_resizeImage',
      value: function _resizeImage() {
        var force = false;
        if (!this.imageObj.width || !this.imageObj.height) {
          // undefined or 0
          this.imageLoaded = false;
        } else if (this.imageLoaded === false) {
          this.imageLoaded = true;
          force = true;
        }

        if (!this.width || !this.height || force === true) {
          // undefined or 0
          var width, height, ratio;
          if (this.imageObj.width && this.imageObj.height) {
            // not undefined or 0
            width = 0;
            height = 0;
          }
          if (this.options.shapeProperties.useImageSize === false) {
            if (this.imageObj.width > this.imageObj.height) {
              ratio = this.imageObj.width / this.imageObj.height;
              width = this.options.size * 2 * ratio || this.imageObj.width;
              height = this.options.size * 2 || this.imageObj.height;
            } else {
              if (this.imageObj.width && this.imageObj.height) {
                // not undefined or 0
                ratio = this.imageObj.height / this.imageObj.width;
              } else {
                ratio = 1;
              }
              width = this.options.size * 2;
              height = this.options.size * 2 * ratio;
            }
          } else {
            // when not using the size property, we use the image size
            width = this.imageObj.width;
            height = this.imageObj.height;
          }
          this.width = width;
          this.height = height;
          this.radius = 0.5 * this.width;
        }
      }
    }, {
      key: '_drawRawCircle',
      value: function _drawRawCircle(ctx, x, y, selected, hover, size) {
        var neutralborderWidth = this.options.borderWidth;
        var selectionLineWidth = this.options.borderWidthSelected || 2 * this.options.borderWidth;
        var borderWidth = (selected ? selectionLineWidth : neutralborderWidth) / this.body.view.scale;
        ctx.lineWidth = Math.min(this.width, borderWidth);

        ctx.strokeStyle = selected ? this.options.color.highlight.border : hover ? this.options.color.hover.border : this.options.color.border;
        ctx.fillStyle = selected ? this.options.color.highlight.background : hover ? this.options.color.hover.background : this.options.color.background;
        ctx.circle(x, y, size);

        // draw shadow if enabled
        this.enableShadow(ctx);
        // draw the background
        ctx.fill();
        // disable shadows for other elements.
        this.disableShadow(ctx);

        //draw dashed border if enabled, save and restore is required for firefox not to crash on unix.
        ctx.save();
        // if borders are zero width, they will be drawn with width 1 by default. This prevents that
        if (borderWidth > 0) {
          this.enableBorderDashes(ctx);
          //draw the border
          ctx.stroke();
          //disable dashed border for other elements
          this.disableBorderDashes(ctx);
        }
        ctx.restore();
      }
    }, {
      key: '_drawImageAtPosition',
      value: function _drawImageAtPosition(ctx) {
        if (this.imageObj.width != 0) {
          // draw the image
          ctx.globalAlpha = 1.0;

          // draw shadow if enabled
          this.enableShadow(ctx);

          var factor = this.imageObj.width / this.width / this.body.view.scale;
          if (factor > 2 && this.options.shapeProperties.interpolation === true) {
            var w = this.imageObj.width;
            var h = this.imageObj.height;
            var can2 = document.createElement('canvas');
            can2.width = w;
            can2.height = w;
            var ctx2 = can2.getContext('2d');

            factor *= 0.5;
            w *= 0.5;
            h *= 0.5;
            ctx2.drawImage(this.imageObj, 0, 0, w, h);

            var distance = 0;
            var iterations = 1;
            while (factor > 2 && iterations < 4) {
              ctx2.drawImage(can2, distance, 0, w, h, distance + w, 0, w / 2, h / 2);
              distance += w;
              factor *= 0.5;
              w *= 0.5;
              h *= 0.5;
              iterations += 1;
            }
            ctx.drawImage(can2, distance, 0, w, h, this.left, this.top, this.width, this.height);
          } else {
            // draw image
            ctx.drawImage(this.imageObj, this.left, this.top, this.width, this.height);
          }

          // disable shadows for other elements.
          this.disableShadow(ctx);
        }
      }
    }, {
      key: '_drawImageLabel',
      value: function _drawImageLabel(ctx, x, y, selected) {
        var yLabel;
        var offset = 0;

        if (this.height !== undefined) {
          offset = this.height * 0.5;
          var labelDimensions = this.labelModule.getTextSize(ctx);
          if (labelDimensions.lineCount >= 1) {
            offset += labelDimensions.height / 2;
          }
        }

        yLabel = y + offset;

        if (this.options.label) {
          this.labelOffset = offset;
        }
        this.labelModule.draw(ctx, x, yLabel, selected, 'hanging');
      }
    }]);

    return CircleImageBase;
  }(_NodeBase3.default);

  exports.default = CircleImageBase;

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _CircleImageBase2 = __webpack_require__(70);

  var _CircleImageBase3 = _interopRequireDefault(_CircleImageBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var CircularImage = function (_CircleImageBase) {
    _inherits(CircularImage, _CircleImageBase);

    function CircularImage(options, body, labelModule, imageObj) {
      _classCallCheck(this, CircularImage);

      var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(CircularImage).call(this, options, body, labelModule));

      _this.imageObj = imageObj;
      _this._swapToImageResizeWhenImageLoaded = true;
      return _this;
    }

    _createClass(CircularImage, [{
      key: 'resize',
      value: function resize() {
        if (this.imageObj.src === undefined || this.imageObj.width === undefined || this.imageObj.height === undefined) {
          if (!this.width) {
            var diameter = this.options.size * 2;
            this.width = diameter;
            this.height = diameter;
            this._swapToImageResizeWhenImageLoaded = true;
            this.radius = 0.5 * this.width;
          }
        } else {
          if (this._swapToImageResizeWhenImageLoaded) {
            this.width = undefined;
            this.height = undefined;
            this._swapToImageResizeWhenImageLoaded = false;
          }
          this._resizeImage();
        }
      }
    }, {
      key: 'draw',
      value: function draw(ctx, x, y, selected, hover) {
        this.resize();

        this.left = x - this.width / 2;
        this.top = y - this.height / 2;

        var size = Math.min(0.5 * this.height, 0.5 * this.width);

        // draw the background circle. IMPORTANT: the stroke in this method is used by the clip method below.
        this._drawRawCircle(ctx, x, y, selected, hover, size);

        // now we draw in the circle, we save so we can revert the clip operation after drawing.
        ctx.save();
        // clip is used to use the stroke in drawRawCircle as an area that we can draw in.
        ctx.clip();
        // draw the image
        this._drawImageAtPosition(ctx);
        // restore so we can again draw on the full canvas
        ctx.restore();

        this._drawImageLabel(ctx, x, y, selected);

        this.updateBoundingBox(x, y);
      }
    }, {
      key: 'updateBoundingBox',
      value: function updateBoundingBox(x, y) {
        this.boundingBox.top = y - this.options.size;
        this.boundingBox.left = x - this.options.size;
        this.boundingBox.right = x + this.options.size;
        this.boundingBox.bottom = y + this.options.size;
        this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
        this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
        this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelOffset);
      }
    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        this.resize(ctx);
        return this.width * 0.5;
      }
    }]);

    return CircularImage;
  }(_CircleImageBase3.default);

  exports.default = CircularImage;

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _NodeBase2 = __webpack_require__(68);

  var _NodeBase3 = _interopRequireDefault(_NodeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var Database = function (_NodeBase) {
    _inherits(Database, _NodeBase);

    function Database(options, body, labelModule) {
      _classCallCheck(this, Database);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(Database).call(this, options, body, labelModule));
    }

    _createClass(Database, [{
      key: 'resize',
      value: function resize(ctx, selected) {
        if (this.width === undefined) {
          var margin = 5;
          var textSize = this.labelModule.getTextSize(ctx, selected);
          var size = textSize.width + 2 * margin;
          this.width = size;
          this.height = size;
          this.radius = 0.5 * this.width;
        }
      }
    }, {
      key: 'draw',
      value: function draw(ctx, x, y, selected, hover) {
        this.resize(ctx, selected);
        this.left = x - this.width / 2;
        this.top = y - this.height / 2;

        var neutralborderWidth = this.options.borderWidth;
        var selectionLineWidth = this.options.borderWidthSelected || 2 * this.options.borderWidth;
        var borderWidth = (selected ? selectionLineWidth : neutralborderWidth) / this.body.view.scale;
        ctx.lineWidth = Math.min(this.width, borderWidth);

        ctx.strokeStyle = selected ? this.options.color.highlight.border : hover ? this.options.color.hover.border : this.options.color.border;

        ctx.fillStyle = selected ? this.options.color.highlight.background : hover ? this.options.color.hover.background : this.options.color.background;
        ctx.database(x - this.width / 2, y - this.height * 0.5, this.width, this.height);

        // draw shadow if enabled
        this.enableShadow(ctx);
        // draw the background
        ctx.fill();
        // disable shadows for other elements.
        this.disableShadow(ctx);

        //draw dashed border if enabled, save and restore is required for firefox not to crash on unix.
        ctx.save();
        // if borders are zero width, they will be drawn with width 1 by default. This prevents that
        if (borderWidth > 0) {
          this.enableBorderDashes(ctx);
          //draw the border
          ctx.stroke();
          //disable dashed border for other elements
          this.disableBorderDashes(ctx);
        }
        ctx.restore();

        this.updateBoundingBox(x, y, ctx, selected);
        this.labelModule.draw(ctx, x, y, selected);
      }
    }, {
      key: 'updateBoundingBox',
      value: function updateBoundingBox(x, y, ctx, selected) {
        this.resize(ctx, selected);

        this.left = x - this.width * 0.5;
        this.top = y - this.height * 0.5;

        this.boundingBox.left = this.left;
        this.boundingBox.top = this.top;
        this.boundingBox.bottom = this.top + this.height;
        this.boundingBox.right = this.left + this.width;
      }
    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        return this._distanceToBorder(ctx, angle);
      }
    }]);

    return Database;
  }(_NodeBase3.default);

  exports.default = Database;

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _ShapeBase2 = __webpack_require__(74);

  var _ShapeBase3 = _interopRequireDefault(_ShapeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var Diamond = function (_ShapeBase) {
    _inherits(Diamond, _ShapeBase);

    function Diamond(options, body, labelModule) {
      _classCallCheck(this, Diamond);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(Diamond).call(this, options, body, labelModule));
    }

    _createClass(Diamond, [{
      key: 'resize',
      value: function resize(ctx) {
        this._resizeShape();
      }
    }, {
      key: 'draw',
      value: function draw(ctx, x, y, selected, hover) {
        this._drawShape(ctx, 'diamond', 4, x, y, selected, hover);
      }
    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        return this._distanceToBorder(ctx, angle);
      }
    }]);

    return Diamond;
  }(_ShapeBase3.default);

  exports.default = Diamond;

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _NodeBase2 = __webpack_require__(68);

  var _NodeBase3 = _interopRequireDefault(_NodeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var ShapeBase = function (_NodeBase) {
    _inherits(ShapeBase, _NodeBase);

    function ShapeBase(options, body, labelModule) {
      _classCallCheck(this, ShapeBase);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(ShapeBase).call(this, options, body, labelModule));
    }

    _createClass(ShapeBase, [{
      key: '_resizeShape',
      value: function _resizeShape() {
        if (this.width === undefined) {
          var size = 2 * this.options.size;
          this.width = size;
          this.height = size;
          this.radius = 0.5 * this.width;
        }
      }
    }, {
      key: '_drawShape',
      value: function _drawShape(ctx, shape, sizeMultiplier, x, y, selected, hover) {
        this._resizeShape();

        this.left = x - this.width / 2;
        this.top = y - this.height / 2;

        var neutralborderWidth = this.options.borderWidth;
        var selectionLineWidth = this.options.borderWidthSelected || 2 * this.options.borderWidth;
        var borderWidth = (selected ? selectionLineWidth : neutralborderWidth) / this.body.view.scale;
        ctx.lineWidth = Math.min(this.width, borderWidth);

        ctx.strokeStyle = selected ? this.options.color.highlight.border : hover ? this.options.color.hover.border : this.options.color.border;
        ctx.fillStyle = selected ? this.options.color.highlight.background : hover ? this.options.color.hover.background : this.options.color.background;
        ctx[shape](x, y, this.options.size);

        // draw shadow if enabled
        this.enableShadow(ctx);
        // draw the background
        ctx.fill();
        // disable shadows for other elements.
        this.disableShadow(ctx);

        //draw dashed border if enabled, save and restore is required for firefox not to crash on unix.
        ctx.save();
        // if borders are zero width, they will be drawn with width 1 by default. This prevents that
        if (borderWidth > 0) {
          this.enableBorderDashes(ctx);
          //draw the border
          ctx.stroke();
          //disable dashed border for other elements
          this.disableBorderDashes(ctx);
        }
        ctx.restore();

        if (this.options.label !== undefined) {
          var yLabel = y + 0.5 * this.height + 3; // the + 3 is to offset it a bit below the node.
          this.labelModule.draw(ctx, x, yLabel, selected, 'hanging');
        }

        this.updateBoundingBox(x, y);
      }
    }, {
      key: 'updateBoundingBox',
      value: function updateBoundingBox(x, y) {
        this.boundingBox.top = y - this.options.size;
        this.boundingBox.left = x - this.options.size;
        this.boundingBox.right = x + this.options.size;
        this.boundingBox.bottom = y + this.options.size;

        if (this.options.label !== undefined && this.labelModule.size.width > 0) {
          this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
          this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
          this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelModule.size.height + 3);
        }
      }
    }]);

    return ShapeBase;
  }(_NodeBase3.default);

  exports.default = ShapeBase;

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _ShapeBase2 = __webpack_require__(74);

  var _ShapeBase3 = _interopRequireDefault(_ShapeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var Dot = function (_ShapeBase) {
    _inherits(Dot, _ShapeBase);

    function Dot(options, body, labelModule) {
      _classCallCheck(this, Dot);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(Dot).call(this, options, body, labelModule));
    }

    _createClass(Dot, [{
      key: 'resize',
      value: function resize(ctx) {
        this._resizeShape();
      }
    }, {
      key: 'draw',
      value: function draw(ctx, x, y, selected, hover) {
        this._drawShape(ctx, 'circle', 2, x, y, selected, hover);
      }
    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        this.resize(ctx);
        return this.options.size;
      }
    }]);

    return Dot;
  }(_ShapeBase3.default);

  exports.default = Dot;

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _NodeBase2 = __webpack_require__(68);

  var _NodeBase3 = _interopRequireDefault(_NodeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var Ellipse = function (_NodeBase) {
    _inherits(Ellipse, _NodeBase);

    function Ellipse(options, body, labelModule) {
      _classCallCheck(this, Ellipse);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(Ellipse).call(this, options, body, labelModule));
    }

    _createClass(Ellipse, [{
      key: 'resize',
      value: function resize(ctx, selected) {
        if (this.width === undefined) {
          var textSize = this.labelModule.getTextSize(ctx, selected);

          this.width = textSize.width * 1.5;
          this.height = textSize.height * 2;
          if (this.width < this.height) {
            this.width = this.height;
          }
          this.radius = 0.5 * this.width;
        }
      }
    }, {
      key: 'draw',
      value: function draw(ctx, x, y, selected, hover) {
        this.resize(ctx, selected);
        this.left = x - this.width * 0.5;
        this.top = y - this.height * 0.5;

        var neutralborderWidth = this.options.borderWidth;
        var selectionLineWidth = this.options.borderWidthSelected || 2 * this.options.borderWidth;
        var borderWidth = (selected ? selectionLineWidth : neutralborderWidth) / this.body.view.scale;
        ctx.lineWidth = Math.min(this.width, borderWidth);

        ctx.strokeStyle = selected ? this.options.color.highlight.border : hover ? this.options.color.hover.border : this.options.color.border;

        ctx.fillStyle = selected ? this.options.color.highlight.background : hover ? this.options.color.hover.background : this.options.color.background;
        ctx.ellipse(this.left, this.top, this.width, this.height);

        // draw shadow if enabled
        this.enableShadow(ctx);
        // draw the background
        ctx.fill();
        // disable shadows for other elements.
        this.disableShadow(ctx);

        //draw dashed border if enabled, save and restore is required for firefox not to crash on unix.
        ctx.save();

        // if borders are zero width, they will be drawn with width 1 by default. This prevents that
        if (borderWidth > 0) {
          this.enableBorderDashes(ctx);
          //draw the border
          ctx.stroke();
          //disable dashed border for other elements
          this.disableBorderDashes(ctx);
        }

        ctx.restore();

        this.updateBoundingBox(x, y, ctx, selected);
        this.labelModule.draw(ctx, x, y, selected);
      }
    }, {
      key: 'updateBoundingBox',
      value: function updateBoundingBox(x, y, ctx, selected) {
        this.resize(ctx, selected); // just in case

        this.left = x - this.width * 0.5;
        this.top = y - this.height * 0.5;

        this.boundingBox.left = this.left;
        this.boundingBox.top = this.top;
        this.boundingBox.bottom = this.top + this.height;
        this.boundingBox.right = this.left + this.width;
      }
    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        this.resize(ctx);
        var a = this.width * 0.5;
        var b = this.height * 0.5;
        var w = Math.sin(angle) * a;
        var h = Math.cos(angle) * b;
        return a * b / Math.sqrt(w * w + h * h);
      }
    }]);

    return Ellipse;
  }(_NodeBase3.default);

  exports.default = Ellipse;

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _NodeBase2 = __webpack_require__(68);

  var _NodeBase3 = _interopRequireDefault(_NodeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var Icon = function (_NodeBase) {
    _inherits(Icon, _NodeBase);

    function Icon(options, body, labelModule) {
      _classCallCheck(this, Icon);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(Icon).call(this, options, body, labelModule));
    }

    _createClass(Icon, [{
      key: 'resize',
      value: function resize(ctx) {
        if (this.width === undefined) {
          var margin = 5;
          var iconSize = {
            width: Number(this.options.icon.size),
            height: Number(this.options.icon.size)
          };
          this.width = iconSize.width + 2 * margin;
          this.height = iconSize.height + 2 * margin;
          this.radius = 0.5 * this.width;
        }
      }
    }, {
      key: 'draw',
      value: function draw(ctx, x, y, selected, hover) {
        this.resize(ctx);
        this.options.icon.size = this.options.icon.size || 50;

        this.left = x - this.width * 0.5;
        this.top = y - this.height * 0.5;
        this._icon(ctx, x, y, selected);

        if (this.options.label !== undefined) {
          var iconTextSpacing = 5;
          this.labelModule.draw(ctx, x, y + this.height * 0.5 + iconTextSpacing, selected);
        }

        this.updateBoundingBox(x, y);
      }
    }, {
      key: 'updateBoundingBox',
      value: function updateBoundingBox(x, y) {
        this.boundingBox.top = y - this.options.icon.size * 0.5;
        this.boundingBox.left = x - this.options.icon.size * 0.5;
        this.boundingBox.right = x + this.options.icon.size * 0.5;
        this.boundingBox.bottom = y + this.options.icon.size * 0.5;

        if (this.options.label !== undefined && this.labelModule.size.width > 0) {
          var iconTextSpacing = 5;
          this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
          this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
          this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelModule.size.height + iconTextSpacing);
        }
      }
    }, {
      key: '_icon',
      value: function _icon(ctx, x, y, selected) {
        var iconSize = Number(this.options.icon.size);

        if (this.options.icon.code !== undefined) {
          ctx.font = (selected ? "bold " : "") + iconSize + "px " + this.options.icon.face;

          // draw icon
          ctx.fillStyle = this.options.icon.color || "black";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";

          // draw shadow if enabled
          this.enableShadow(ctx);
          ctx.fillText(this.options.icon.code, x, y);

          // disable shadows for other elements.
          this.disableShadow(ctx);
        } else {
          console.error('When using the icon shape, you need to define the code in the icon options object. This can be done per node or globally.');
        }
      }
    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        return this._distanceToBorder(ctx, angle);
      }
    }]);

    return Icon;
  }(_NodeBase3.default);

  exports.default = Icon;

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _CircleImageBase2 = __webpack_require__(70);

  var _CircleImageBase3 = _interopRequireDefault(_CircleImageBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var Image = function (_CircleImageBase) {
    _inherits(Image, _CircleImageBase);

    function Image(options, body, labelModule, imageObj) {
      _classCallCheck(this, Image);

      var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Image).call(this, options, body, labelModule));

      _this.imageObj = imageObj;
      return _this;
    }

    _createClass(Image, [{
      key: 'resize',
      value: function resize() {
        this._resizeImage();
      }
    }, {
      key: 'draw',
      value: function draw(ctx, x, y, selected, hover) {
        this.resize();
        this.left = x - this.width / 2;
        this.top = y - this.height / 2;

        if (this.options.shapeProperties.useBorderWithImage === true) {
          var neutralborderWidth = this.options.borderWidth;
          var selectionLineWidth = this.options.borderWidthSelected || 2 * this.options.borderWidth;
          var borderWidth = (selected ? selectionLineWidth : neutralborderWidth) / this.body.view.scale;
          ctx.lineWidth = Math.min(this.width, borderWidth);

          ctx.beginPath();

          // setup the line properties.
          ctx.strokeStyle = selected ? this.options.color.highlight.border : hover ? this.options.color.hover.border : this.options.color.border;

          // set a fillstyle
          ctx.fillStyle = selected ? this.options.color.highlight.background : hover ? this.options.color.hover.background : this.options.color.background;

          // draw a rectangle to form the border around. This rectangle is filled so the opacity of a picture (in future vis releases?) can be used to tint the image
          ctx.rect(this.left - 0.5 * ctx.lineWidth, this.top - 0.5 * ctx.lineWidth, this.width + ctx.lineWidth, this.height + ctx.lineWidth);
          ctx.fill();

          //draw dashed border if enabled, save and restore is required for firefox not to crash on unix.
          ctx.save();
          // if borders are zero width, they will be drawn with width 1 by default. This prevents that
          if (borderWidth > 0) {
            this.enableBorderDashes(ctx);
            //draw the border
            ctx.stroke();
            //disable dashed border for other elements
            this.disableBorderDashes(ctx);
          }
          ctx.restore();

          ctx.closePath();
        }

        this._drawImageAtPosition(ctx);

        this._drawImageLabel(ctx, x, y, selected || hover);

        this.updateBoundingBox(x, y);
      }
    }, {
      key: 'updateBoundingBox',
      value: function updateBoundingBox(x, y) {
        this.resize();
        this.left = x - this.width / 2;
        this.top = y - this.height / 2;

        this.boundingBox.top = this.top;
        this.boundingBox.left = this.left;
        this.boundingBox.right = this.left + this.width;
        this.boundingBox.bottom = this.top + this.height;

        if (this.options.label !== undefined && this.labelModule.size.width > 0) {
          this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
          this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
          this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelOffset);
        }
      }
    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        return this._distanceToBorder(ctx, angle);
      }
    }]);

    return Image;
  }(_CircleImageBase3.default);

  exports.default = Image;

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _ShapeBase2 = __webpack_require__(74);

  var _ShapeBase3 = _interopRequireDefault(_ShapeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var Square = function (_ShapeBase) {
    _inherits(Square, _ShapeBase);

    function Square(options, body, labelModule) {
      _classCallCheck(this, Square);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(Square).call(this, options, body, labelModule));
    }

    _createClass(Square, [{
      key: 'resize',
      value: function resize() {
        this._resizeShape();
      }
    }, {
      key: 'draw',
      value: function draw(ctx, x, y, selected, hover) {
        this._drawShape(ctx, 'square', 2, x, y, selected, hover);
      }
    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        return this._distanceToBorder(ctx, angle);
      }
    }]);

    return Square;
  }(_ShapeBase3.default);

  exports.default = Square;

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _ShapeBase2 = __webpack_require__(74);

  var _ShapeBase3 = _interopRequireDefault(_ShapeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var Star = function (_ShapeBase) {
    _inherits(Star, _ShapeBase);

    function Star(options, body, labelModule) {
      _classCallCheck(this, Star);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(Star).call(this, options, body, labelModule));
    }

    _createClass(Star, [{
      key: 'resize',
      value: function resize(ctx) {
        this._resizeShape();
      }
    }, {
      key: 'draw',
      value: function draw(ctx, x, y, selected, hover) {
        this._drawShape(ctx, 'star', 4, x, y, selected, hover);
      }
    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        return this._distanceToBorder(ctx, angle);
      }
    }]);

    return Star;
  }(_ShapeBase3.default);

  exports.default = Star;

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _NodeBase2 = __webpack_require__(68);

  var _NodeBase3 = _interopRequireDefault(_NodeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var Text = function (_NodeBase) {
    _inherits(Text, _NodeBase);

    function Text(options, body, labelModule) {
      _classCallCheck(this, Text);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(Text).call(this, options, body, labelModule));
    }

    _createClass(Text, [{
      key: 'resize',
      value: function resize(ctx, selected) {
        if (this.width === undefined) {
          var margin = 5;
          var textSize = this.labelModule.getTextSize(ctx, selected);
          this.width = textSize.width + 2 * margin;
          this.height = textSize.height + 2 * margin;
          this.radius = 0.5 * this.width;
        }
      }
    }, {
      key: 'draw',
      value: function draw(ctx, x, y, selected, hover) {
        this.resize(ctx, selected || hover);
        this.left = x - this.width / 2;
        this.top = y - this.height / 2;

        // draw shadow if enabled
        this.enableShadow(ctx);
        this.labelModule.draw(ctx, x, y, selected || hover);

        // disable shadows for other elements.
        this.disableShadow(ctx);

        this.updateBoundingBox(x, y, ctx, selected);
      }
    }, {
      key: 'updateBoundingBox',
      value: function updateBoundingBox(x, y, ctx, selected) {
        this.resize(ctx, selected);

        this.left = x - this.width / 2;
        this.top = y - this.height / 2;

        this.boundingBox.top = this.top;
        this.boundingBox.left = this.left;
        this.boundingBox.right = this.left + this.width;
        this.boundingBox.bottom = this.top + this.height;
      }
    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        return this._distanceToBorder(ctx, angle);
      }
    }]);

    return Text;
  }(_NodeBase3.default);

  exports.default = Text;

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _ShapeBase2 = __webpack_require__(74);

  var _ShapeBase3 = _interopRequireDefault(_ShapeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var Triangle = function (_ShapeBase) {
    _inherits(Triangle, _ShapeBase);

    function Triangle(options, body, labelModule) {
      _classCallCheck(this, Triangle);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(Triangle).call(this, options, body, labelModule));
    }

    _createClass(Triangle, [{
      key: 'resize',
      value: function resize(ctx) {
        this._resizeShape();
      }
    }, {
      key: 'draw',
      value: function draw(ctx, x, y, selected, hover) {
        this._drawShape(ctx, 'triangle', 3, x, y, selected, hover);
      }
    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        return this._distanceToBorder(ctx, angle);
      }
    }]);

    return Triangle;
  }(_ShapeBase3.default);

  exports.default = Triangle;

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _ShapeBase2 = __webpack_require__(74);

  var _ShapeBase3 = _interopRequireDefault(_ShapeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var TriangleDown = function (_ShapeBase) {
    _inherits(TriangleDown, _ShapeBase);

    function TriangleDown(options, body, labelModule) {
      _classCallCheck(this, TriangleDown);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(TriangleDown).call(this, options, body, labelModule));
    }

    _createClass(TriangleDown, [{
      key: 'resize',
      value: function resize(ctx) {
        this._resizeShape();
      }
    }, {
      key: 'draw',
      value: function draw(ctx, x, y, selected, hover) {
        this._drawShape(ctx, 'triangleDown', 3, x, y, selected, hover);
      }
    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        return this._distanceToBorder(ctx, angle);
      }
    }]);

    return TriangleDown;
  }(_ShapeBase3.default);

  exports.default = TriangleDown;

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _Edge = __webpack_require__(85);

  var _Edge2 = _interopRequireDefault(_Edge);

  var _Label = __webpack_require__(66);

  var _Label2 = _interopRequireDefault(_Label);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);
  var DataSet = __webpack_require__(9);
  var DataView = __webpack_require__(11);

  var EdgesHandler = function () {
    function EdgesHandler(body, images, groups) {
      var _this = this;

      _classCallCheck(this, EdgesHandler);

      this.body = body;
      this.images = images;
      this.groups = groups;

      // create the edge API in the body container
      this.body.functions.createEdge = this.create.bind(this);

      this.edgesListeners = {
        add: function add(event, params) {
          _this.add(params.items);
        },
        update: function update(event, params) {
          _this.update(params.items);
        },
        remove: function remove(event, params) {
          _this.remove(params.items);
        }
      };

      this.options = {};
      this.defaultOptions = {
        arrows: {
          to: { enabled: false, scaleFactor: 1 }, // boolean / {arrowScaleFactor:1} / {enabled: false, arrowScaleFactor:1}
          middle: { enabled: false, scaleFactor: 1 },
          from: { enabled: false, scaleFactor: 1 }
        },
        arrowStrikethrough: true,
        color: {
          color: '#848484',
          highlight: '#848484',
          hover: '#848484',
          inherit: 'from',
          opacity: 1.0
        },
        dashes: false,
        font: {
          color: '#343434',
          size: 14, // px
          face: 'arial',
          background: 'none',
          strokeWidth: 2, // px
          strokeColor: '#ffffff',
          align: 'horizontal'
        },
        hidden: false,
        hoverWidth: 1.5,
        label: undefined,
        labelHighlightBold: true,
        length: undefined,
        physics: true,
        scaling: {
          min: 1,
          max: 15,
          label: {
            enabled: true,
            min: 14,
            max: 30,
            maxVisible: 30,
            drawThreshold: 5
          },
          customScalingFunction: function customScalingFunction(min, max, total, value) {
            if (max === min) {
              return 0.5;
            } else {
              var scale = 1 / (max - min);
              return Math.max(0, (value - min) * scale);
            }
          }
        },
        selectionWidth: 1.5,
        selfReferenceSize: 20,
        shadow: {
          enabled: false,
          color: 'rgba(0,0,0,0.5)',
          size: 10,
          x: 5,
          y: 5
        },
        smooth: {
          enabled: true,
          type: "dynamic",
          forceDirection: 'none',
          roundness: 0.5
        },
        title: undefined,
        width: 1,
        value: undefined
      };

      util.extend(this.options, this.defaultOptions);

      this.bindEventListeners();
    }

    _createClass(EdgesHandler, [{
      key: 'bindEventListeners',
      value: function bindEventListeners() {
        var _this2 = this;

        // this allows external modules to force all dynamic curves to turn static.
        this.body.emitter.on("_forceDisableDynamicCurves", function (type) {
          if (type === 'dynamic') {
            type = 'continuous';
          }
          var emitChange = false;
          for (var edgeId in _this2.body.edges) {
            if (_this2.body.edges.hasOwnProperty(edgeId)) {
              var edge = _this2.body.edges[edgeId];
              var edgeData = _this2.body.data.edges._data[edgeId];

              // only forcibly remove the smooth curve if the data has been set of the edge has the smooth curves defined.
              // this is because a change in the global would not affect these curves.
              if (edgeData !== undefined) {
                var edgeOptions = edgeData.smooth;
                if (edgeOptions !== undefined) {
                  if (edgeOptions.enabled === true && edgeOptions.type === 'dynamic') {
                    if (type === undefined) {
                      edge.setOptions({ smooth: false });
                    } else {
                      edge.setOptions({ smooth: { type: type } });
                    }
                    emitChange = true;
                  }
                }
              }
            }
          }
          if (emitChange === true) {
            _this2.body.emitter.emit("_dataChanged");
          }
        });

        // this is called when options of EXISTING nodes or edges have changed.
        this.body.emitter.on("_dataUpdated", function () {
          _this2.reconnectEdges();
          _this2.markAllEdgesAsDirty();
        });

        // refresh the edges. Used when reverting from hierarchical layout
        this.body.emitter.on("refreshEdges", this.refresh.bind(this));
        this.body.emitter.on("refresh", this.refresh.bind(this));
        this.body.emitter.on("destroy", function () {
          util.forEach(_this2.edgesListeners, function (callback, event) {
            if (_this2.body.data.edges) _this2.body.data.edges.off(event, callback);
          });
          delete _this2.body.functions.createEdge;
          delete _this2.edgesListeners.add;
          delete _this2.edgesListeners.update;
          delete _this2.edgesListeners.remove;
          delete _this2.edgesListeners;
        });
      }
    }, {
      key: 'setOptions',
      value: function setOptions(options) {
        if (options !== undefined) {
          // use the parser from the Edge class to fill in all shorthand notations
          _Edge2.default.parseOptions(this.options, options);

          // handle multiple input cases for color
          if (options.color !== undefined) {
            this.markAllEdgesAsDirty();
          }

          // update smooth settings in all edges
          var dataChanged = false;
          if (options.smooth !== undefined) {
            for (var edgeId in this.body.edges) {
              if (this.body.edges.hasOwnProperty(edgeId)) {
                dataChanged = this.body.edges[edgeId].updateEdgeType() || dataChanged;
              }
            }
          }

          // update fonts in all edges
          if (options.font !== undefined) {
            // use the parser from the Label class to fill in all shorthand notations
            _Label2.default.parseOptions(this.options.font, options);
            for (var _edgeId in this.body.edges) {
              if (this.body.edges.hasOwnProperty(_edgeId)) {
                this.body.edges[_edgeId].updateLabelModule();
              }
            }
          }

          // update the state of the variables if needed
          if (options.hidden !== undefined || options.physics !== undefined || dataChanged === true) {
            this.body.emitter.emit('_dataChanged');
          }
        }
      }

      /**
       * Load edges by reading the data table
       * @param {Array | DataSet | DataView} edges    The data containing the edges.
       * @private
       * @private
       */

    }, {
      key: 'setData',
      value: function setData(edges) {
        var _this3 = this;

        var doNotEmit = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

        var oldEdgesData = this.body.data.edges;

        if (edges instanceof DataSet || edges instanceof DataView) {
          this.body.data.edges = edges;
        } else if (Array.isArray(edges)) {
          this.body.data.edges = new DataSet();
          this.body.data.edges.add(edges);
        } else if (!edges) {
          this.body.data.edges = new DataSet();
        } else {
          throw new TypeError('Array or DataSet expected');
        }

        // TODO: is this null or undefined or false?
        if (oldEdgesData) {
          // unsubscribe from old dataset
          util.forEach(this.edgesListeners, function (callback, event) {
            oldEdgesData.off(event, callback);
          });
        }

        // remove drawn edges
        this.body.edges = {};

        // TODO: is this null or undefined or false?
        if (this.body.data.edges) {
          // subscribe to new dataset
          util.forEach(this.edgesListeners, function (callback, event) {
            _this3.body.data.edges.on(event, callback);
          });

          // draw all new nodes
          var ids = this.body.data.edges.getIds();
          this.add(ids, true);
        }

        if (doNotEmit === false) {
          this.body.emitter.emit("_dataChanged");
        }
      }

      /**
       * Add edges
       * @param {Number[] | String[]} ids
       * @private
       */

    }, {
      key: 'add',
      value: function add(ids) {
        var doNotEmit = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

        var edges = this.body.edges;
        var edgesData = this.body.data.edges;

        for (var i = 0; i < ids.length; i++) {
          var id = ids[i];

          var oldEdge = edges[id];
          if (oldEdge) {
            oldEdge.disconnect();
          }

          var data = edgesData.get(id, { "showInternalIds": true });
          edges[id] = this.create(data);
        }

        if (doNotEmit === false) {
          this.body.emitter.emit("_dataChanged");
        }
      }

      /**
       * Update existing edges, or create them when not yet existing
       * @param {Number[] | String[]} ids
       * @private
       */

    }, {
      key: 'update',
      value: function update(ids) {
        var edges = this.body.edges;
        var edgesData = this.body.data.edges;
        var dataChanged = false;
        for (var i = 0; i < ids.length; i++) {
          var id = ids[i];
          var data = edgesData.get(id);
          var edge = edges[id];
          if (edge !== undefined) {
            // update edge
            edge.disconnect();
            dataChanged = edge.setOptions(data) || dataChanged; // if a support node is added, data can be changed.
            edge.connect();
          } else {
            // create edge
            this.body.edges[id] = this.create(data);
            dataChanged = true;
          }
        }

        if (dataChanged === true) {
          this.body.emitter.emit("_dataChanged");
        } else {
          this.body.emitter.emit("_dataUpdated");
        }
      }

      /**
       * Remove existing edges. Non existing ids will be ignored
       * @param {Number[] | String[]} ids
       * @private
       */

    }, {
      key: 'remove',
      value: function remove(ids) {
        var edges = this.body.edges;
        for (var i = 0; i < ids.length; i++) {
          var id = ids[i];
          var edge = edges[id];
          if (edge !== undefined) {
            edge.cleanup();
            edge.disconnect();
            delete edges[id];
          }
        }

        this.body.emitter.emit("_dataChanged");
      }
    }, {
      key: 'refresh',
      value: function refresh() {
        var edges = this.body.edges;
        for (var edgeId in edges) {
          var edge = undefined;
          if (edges.hasOwnProperty(edgeId)) {
            edge = edges[edgeId];
          }
          var data = this.body.data.edges._data[edgeId];
          if (edge !== undefined && data !== undefined) {
            edge.setOptions(data);
          }
        }
      }
    }, {
      key: 'create',
      value: function create(properties) {
        return new _Edge2.default(properties, this.body, this.options);
      }
    }, {
      key: 'markAllEdgesAsDirty',
      value: function markAllEdgesAsDirty() {
        for (var edgeId in this.body.edges) {
          this.body.edges[edgeId].edgeType.colorDirty = true;
        }
      }

      /**
       * Reconnect all edges
       * @private
       */

    }, {
      key: 'reconnectEdges',
      value: function reconnectEdges() {
        var id;
        var nodes = this.body.nodes;
        var edges = this.body.edges;

        for (id in nodes) {
          if (nodes.hasOwnProperty(id)) {
            nodes[id].edges = [];
          }
        }

        for (id in edges) {
          if (edges.hasOwnProperty(id)) {
            var edge = edges[id];
            edge.from = null;
            edge.to = null;
            edge.connect();
          }
        }
      }
    }, {
      key: 'getConnectedNodes',
      value: function getConnectedNodes(edgeId) {
        var nodeList = [];
        if (this.body.edges[edgeId] !== undefined) {
          var edge = this.body.edges[edgeId];
          if (edge.fromId) {
            nodeList.push(edge.fromId);
          }
          if (edge.toId) {
            nodeList.push(edge.toId);
          }
        }
        return nodeList;
      }
    }]);

    return EdgesHandler;
  }();

  exports.default = EdgesHandler;

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _Label = __webpack_require__(66);

  var _Label2 = _interopRequireDefault(_Label);

  var _CubicBezierEdge = __webpack_require__(86);

  var _CubicBezierEdge2 = _interopRequireDefault(_CubicBezierEdge);

  var _BezierEdgeDynamic = __webpack_require__(90);

  var _BezierEdgeDynamic2 = _interopRequireDefault(_BezierEdgeDynamic);

  var _BezierEdgeStatic = __webpack_require__(91);

  var _BezierEdgeStatic2 = _interopRequireDefault(_BezierEdgeStatic);

  var _StraightEdge = __webpack_require__(92);

  var _StraightEdge2 = _interopRequireDefault(_StraightEdge);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);

  /**
   * @class Edge
   *
   * A edge connects two nodes
   * @param {Object} properties     Object with options. Must contain
   *                                At least options from and to.
   *                                Available options: from (number),
   *                                to (number), label (string, color (string),
   *                                width (number), style (string),
   *                                length (number), title (string)
   * @param {Network} network       A Network object, used to find and edge to
   *                                nodes.
   * @param {Object} constants      An object with default values for
   *                                example for the color
   */

  var Edge = function () {
    function Edge(options, body, globalOptions) {
      _classCallCheck(this, Edge);

      if (body === undefined) {
        throw "No body provided";
      }
      this.options = util.bridgeObject(globalOptions);
      this.globalOptions = globalOptions;
      this.body = body;

      // initialize variables
      this.id = undefined;
      this.fromId = undefined;
      this.toId = undefined;
      this.selected = false;
      this.hover = false;
      this.labelDirty = true;
      this.colorDirty = true;

      this.baseWidth = this.options.width;
      this.baseFontSize = this.options.font.size;

      this.from = undefined; // a node
      this.to = undefined; // a node

      this.edgeType = undefined;

      this.connected = false;

      this.labelModule = new _Label2.default(this.body, this.options, true /* It's an edge label */);

      this.setOptions(options);
    }

    /**
     * Set or overwrite options for the edge
     * @param {Object} options  an object with options
     * @param doNotEmit
     */


    _createClass(Edge, [{
      key: 'setOptions',
      value: function setOptions(options) {
        if (!options) {
          return;
        }
        this.colorDirty = true;

        Edge.parseOptions(this.options, options, true, this.globalOptions);

        if (options.id !== undefined) {
          this.id = options.id;
        }
        if (options.from !== undefined) {
          this.fromId = options.from;
        }
        if (options.to !== undefined) {
          this.toId = options.to;
        }
        if (options.title !== undefined) {
          this.title = options.title;
        }
        if (options.value !== undefined) {
          options.value = parseFloat(options.value);
        }

        // update label Module
        this.updateLabelModule();

        var dataChanged = this.updateEdgeType();

        // if anything has been updates, reset the selection width and the hover width
        this._setInteractionWidths();

        // A node is connected when it has a from and to node that both exist in the network.body.nodes.
        this.connect();

        if (options.hidden !== undefined || options.physics !== undefined) {
          dataChanged = true;
        }

        return dataChanged;
      }
    }, {
      key: 'updateLabelModule',
      // set the object back to the global options


      /**
       * update the options in the label module
       */
      value: function updateLabelModule() {
        this.labelModule.setOptions(this.options, true);
        if (this.labelModule.baseSize !== undefined) {
          this.baseFontSize = this.labelModule.baseSize;
        }
      }

      /**
       * update the edge type, set the options
       * @returns {boolean}
       */

    }, {
      key: 'updateEdgeType',
      value: function updateEdgeType() {
        var dataChanged = false;
        var changeInType = true;
        var smooth = this.options.smooth;
        if (this.edgeType !== undefined) {
          if (this.edgeType instanceof _BezierEdgeDynamic2.default && smooth.enabled === true && smooth.type === 'dynamic') {
            changeInType = false;
          }
          if (this.edgeType instanceof _CubicBezierEdge2.default && smooth.enabled === true && smooth.type === 'cubicBezier') {
            changeInType = false;
          }
          if (this.edgeType instanceof _BezierEdgeStatic2.default && smooth.enabled === true && smooth.type !== 'dynamic' && smooth.type !== 'cubicBezier') {
            changeInType = false;
          }
          if (this.edgeType instanceof _StraightEdge2.default && smooth.enabled === false) {
            changeInType = false;
          }

          if (changeInType === true) {
            dataChanged = this.cleanup();
          }
        }

        if (changeInType === true) {
          if (this.options.smooth.enabled === true) {
            if (this.options.smooth.type === 'dynamic') {
              dataChanged = true;
              this.edgeType = new _BezierEdgeDynamic2.default(this.options, this.body, this.labelModule);
            } else if (this.options.smooth.type === 'cubicBezier') {
              this.edgeType = new _CubicBezierEdge2.default(this.options, this.body, this.labelModule);
            } else {
              this.edgeType = new _BezierEdgeStatic2.default(this.options, this.body, this.labelModule);
            }
          } else {
            this.edgeType = new _StraightEdge2.default(this.options, this.body, this.labelModule);
          }
        } else {
          // if nothing changes, we just set the options.
          this.edgeType.setOptions(this.options);
        }

        return dataChanged;
      }

      /**
       * Connect an edge to its nodes
       */

    }, {
      key: 'connect',
      value: function connect() {
        this.disconnect();

        this.from = this.body.nodes[this.fromId] || undefined;
        this.to = this.body.nodes[this.toId] || undefined;
        this.connected = this.from !== undefined && this.to !== undefined;

        if (this.connected === true) {
          this.from.attachEdge(this);
          this.to.attachEdge(this);
        } else {
          if (this.from) {
            this.from.detachEdge(this);
          }
          if (this.to) {
            this.to.detachEdge(this);
          }
        }

        this.edgeType.connect();
      }

      /**
       * Disconnect an edge from its nodes
       */

    }, {
      key: 'disconnect',
      value: function disconnect() {
        if (this.from) {
          this.from.detachEdge(this);
          this.from = undefined;
        }
        if (this.to) {
          this.to.detachEdge(this);
          this.to = undefined;
        }

        this.connected = false;
      }

      /**
       * get the title of this edge.
       * @return {string} title    The title of the edge, or undefined when no title
       *                           has been set.
       */

    }, {
      key: 'getTitle',
      value: function getTitle() {
        return this.title;
      }

      /**
       * check if this node is selecte
       * @return {boolean} selected   True if node is selected, else false
       */

    }, {
      key: 'isSelected',
      value: function isSelected() {
        return this.selected;
      }

      /**
       * Retrieve the value of the edge. Can be undefined
       * @return {Number} value
       */

    }, {
      key: 'getValue',
      value: function getValue() {
        return this.options.value;
      }

      /**
       * Adjust the value range of the edge. The edge will adjust it's width
       * based on its value.
       * @param {Number} min
       * @param {Number} max
       * @param total
       */

    }, {
      key: 'setValueRange',
      value: function setValueRange(min, max, total) {
        if (this.options.value !== undefined) {
          var scale = this.options.scaling.customScalingFunction(min, max, total, this.options.value);
          var widthDiff = this.options.scaling.max - this.options.scaling.min;
          if (this.options.scaling.label.enabled === true) {
            var fontDiff = this.options.scaling.label.max - this.options.scaling.label.min;
            this.options.font.size = this.options.scaling.label.min + scale * fontDiff;
          }
          this.options.width = this.options.scaling.min + scale * widthDiff;
        } else {
          this.options.width = this.baseWidth;
          this.options.font.size = this.baseFontSize;
        }

        this._setInteractionWidths();
        this.updateLabelModule();
      }
    }, {
      key: '_setInteractionWidths',
      value: function _setInteractionWidths() {
        if (typeof this.options.hoverWidth === 'function') {
          this.edgeType.hoverWidth = this.options.hoverWidth(this.options.width);
        } else {
          this.edgeType.hoverWidth = this.options.hoverWidth + this.options.width;
        }

        if (typeof this.options.selectionWidth === 'function') {
          this.edgeType.selectionWidth = this.options.selectionWidth(this.options.width);
        } else {
          this.edgeType.selectionWidth = this.options.selectionWidth + this.options.width;
        }
      }

      /**
       * Redraw a edge
       * Draw this edge in the given canvas
       * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
       * @param {CanvasRenderingContext2D}   ctx
       */

    }, {
      key: 'draw',
      value: function draw(ctx) {
        // get the via node from the edge type
        var viaNode = this.edgeType.getViaNode();
        var arrowData = {};

        // restore edge targets to defaults
        this.edgeType.fromPoint = this.edgeType.from;
        this.edgeType.toPoint = this.edgeType.to;

        // from and to arrows give a different end point for edges. we set them here
        if (this.options.arrows.from.enabled === true) {
          arrowData.from = this.edgeType.getArrowData(ctx, 'from', viaNode, this.selected, this.hover);
          if (this.options.arrowStrikethrough === false) this.edgeType.fromPoint = arrowData.from.core;
        }
        if (this.options.arrows.to.enabled === true) {
          arrowData.to = this.edgeType.getArrowData(ctx, 'to', viaNode, this.selected, this.hover);
          if (this.options.arrowStrikethrough === false) this.edgeType.toPoint = arrowData.to.core;
        }

        // the middle arrow depends on the line, which can depend on the to and from arrows so we do this one lastly.
        if (this.options.arrows.middle.enabled === true) {
          arrowData.middle = this.edgeType.getArrowData(ctx, 'middle', viaNode, this.selected, this.hover);
        }

        // draw everything
        this.edgeType.drawLine(ctx, this.selected, this.hover, viaNode);
        this.drawArrows(ctx, arrowData);
        this.drawLabel(ctx, viaNode);
      }
    }, {
      key: 'drawArrows',
      value: function drawArrows(ctx, arrowData) {
        if (this.options.arrows.from.enabled === true) {
          this.edgeType.drawArrowHead(ctx, this.selected, this.hover, arrowData.from);
        }
        if (this.options.arrows.middle.enabled === true) {
          this.edgeType.drawArrowHead(ctx, this.selected, this.hover, arrowData.middle);
        }
        if (this.options.arrows.to.enabled === true) {
          this.edgeType.drawArrowHead(ctx, this.selected, this.hover, arrowData.to);
        }
      }
    }, {
      key: 'drawLabel',
      value: function drawLabel(ctx, viaNode) {
        if (this.options.label !== undefined) {
          // set style
          var node1 = this.from;
          var node2 = this.to;
          var selected = this.from.selected || this.to.selected || this.selected;
          if (node1.id != node2.id) {
            this.labelModule.pointToSelf = false;
            var point = this.edgeType.getPoint(0.5, viaNode);
            ctx.save();

            // if the label has to be rotated:
            if (this.options.font.align !== "horizontal") {
              this.labelModule.calculateLabelSize(ctx, selected, point.x, point.y);
              ctx.translate(point.x, this.labelModule.size.yLine);
              this._rotateForLabelAlignment(ctx);
            }

            // draw the label
            this.labelModule.draw(ctx, point.x, point.y, selected);
            ctx.restore();
          } else {
            // Ignore the orientations.
            this.labelModule.pointToSelf = true;
            var x, y;
            var radius = this.options.selfReferenceSize;
            if (node1.shape.width > node1.shape.height) {
              x = node1.x + node1.shape.width * 0.5;
              y = node1.y - radius;
            } else {
              x = node1.x + radius;
              y = node1.y - node1.shape.height * 0.5;
            }
            point = this._pointOnCircle(x, y, radius, 0.125);
            this.labelModule.draw(ctx, point.x, point.y, selected);
          }
        }
      }

      /**
       * Check if this object is overlapping with the provided object
       * @param {Object} obj   an object with parameters left, top
       * @return {boolean}     True if location is located on the edge
       */

    }, {
      key: 'isOverlappingWith',
      value: function isOverlappingWith(obj) {
        if (this.connected) {
          var distMax = 10;
          var xFrom = this.from.x;
          var yFrom = this.from.y;
          var xTo = this.to.x;
          var yTo = this.to.y;
          var xObj = obj.left;
          var yObj = obj.top;

          var dist = this.edgeType.getDistanceToEdge(xFrom, yFrom, xTo, yTo, xObj, yObj);

          return dist < distMax;
        } else {
          return false;
        }
      }

      /**
       * Rotates the canvas so the text is most readable
       * @param {CanvasRenderingContext2D} ctx
       * @private
       */

    }, {
      key: '_rotateForLabelAlignment',
      value: function _rotateForLabelAlignment(ctx) {
        var dy = this.from.y - this.to.y;
        var dx = this.from.x - this.to.x;
        var angleInDegrees = Math.atan2(dy, dx);

        // rotate so label it is readable
        if (angleInDegrees < -1 && dx < 0 || angleInDegrees > 0 && dx < 0) {
          angleInDegrees = angleInDegrees + Math.PI;
        }

        ctx.rotate(angleInDegrees);
      }

      /**
       * Get a point on a circle
       * @param {Number} x
       * @param {Number} y
       * @param {Number} radius
       * @param {Number} percentage. Value between 0 (line start) and 1 (line end)
       * @return {Object} point
       * @private
       */

    }, {
      key: '_pointOnCircle',
      value: function _pointOnCircle(x, y, radius, percentage) {
        var angle = percentage * 2 * Math.PI;
        return {
          x: x + radius * Math.cos(angle),
          y: y - radius * Math.sin(angle)
        };
      }
    }, {
      key: 'select',
      value: function select() {
        this.selected = true;
      }
    }, {
      key: 'unselect',
      value: function unselect() {
        this.selected = false;
      }

      /**
       * cleans all required things on delete
       * @returns {*}
       */

    }, {
      key: 'cleanup',
      value: function cleanup() {
        return this.edgeType.cleanup();
      }
    }], [{
      key: 'parseOptions',
      value: function parseOptions(parentOptions, newOptions) {
        var allowDeletion = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];
        var globalOptions = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

        var fields = ['arrowStrikethrough', 'id', 'from', 'hidden', 'hoverWidth', 'label', 'labelHighlightBold', 'length', 'line', 'opacity', 'physics', 'scaling', 'selectionWidth', 'selfReferenceSize', 'to', 'title', 'value', 'width'];

        // only deep extend the items in the field array. These do not have shorthand.
        util.selectiveDeepExtend(fields, parentOptions, newOptions, allowDeletion);

        util.mergeOptions(parentOptions, newOptions, 'smooth', allowDeletion, globalOptions);
        util.mergeOptions(parentOptions, newOptions, 'shadow', allowDeletion, globalOptions);

        if (newOptions.dashes !== undefined && newOptions.dashes !== null) {
          parentOptions.dashes = newOptions.dashes;
        } else if (allowDeletion === true && newOptions.dashes === null) {
          parentOptions.dashes = Object.create(globalOptions.dashes); // this sets the pointer of the option back to the global option.
        }

        // set the scaling newOptions
        if (newOptions.scaling !== undefined && newOptions.scaling !== null) {
          if (newOptions.scaling.min !== undefined) {
            parentOptions.scaling.min = newOptions.scaling.min;
          }
          if (newOptions.scaling.max !== undefined) {
            parentOptions.scaling.max = newOptions.scaling.max;
          }
          util.mergeOptions(parentOptions.scaling, newOptions.scaling, 'label', allowDeletion, globalOptions.scaling);
        } else if (allowDeletion === true && newOptions.scaling === null) {
          parentOptions.scaling = Object.create(globalOptions.scaling); // this sets the pointer of the option back to the global option.
        }

        // handle multiple input cases for arrows
        if (newOptions.arrows !== undefined && newOptions.arrows !== null) {
          if (typeof newOptions.arrows === 'string') {
            var arrows = newOptions.arrows.toLowerCase();
            parentOptions.arrows.to.enabled = arrows.indexOf("to") != -1;
            parentOptions.arrows.middle.enabled = arrows.indexOf("middle") != -1;
            parentOptions.arrows.from.enabled = arrows.indexOf("from") != -1;
          } else if (_typeof(newOptions.arrows) === 'object') {
            util.mergeOptions(parentOptions.arrows, newOptions.arrows, 'to', allowDeletion, globalOptions.arrows);
            util.mergeOptions(parentOptions.arrows, newOptions.arrows, 'middle', allowDeletion, globalOptions.arrows);
            util.mergeOptions(parentOptions.arrows, newOptions.arrows, 'from', allowDeletion, globalOptions.arrows);
          } else {
            throw new Error("The arrow newOptions can only be an object or a string. Refer to the documentation. You used:" + JSON.stringify(newOptions.arrows));
          }
        } else if (allowDeletion === true && newOptions.arrows === null) {
          parentOptions.arrows = Object.create(globalOptions.arrows); // this sets the pointer of the option back to the global option.
        }

        // handle multiple input cases for color
        if (newOptions.color !== undefined && newOptions.color !== null) {
          // make a copy of the parent object in case this is referring to the global one (due to object create once, then update)
          parentOptions.color = util.deepExtend({}, parentOptions.color, true);
          if (util.isString(newOptions.color)) {
            parentOptions.color.color = newOptions.color;
            parentOptions.color.highlight = newOptions.color;
            parentOptions.color.hover = newOptions.color;
            parentOptions.color.inherit = false;
          } else {
            var colorsDefined = false;
            if (newOptions.color.color !== undefined) {
              parentOptions.color.color = newOptions.color.color;colorsDefined = true;
            }
            if (newOptions.color.highlight !== undefined) {
              parentOptions.color.highlight = newOptions.color.highlight;colorsDefined = true;
            }
            if (newOptions.color.hover !== undefined) {
              parentOptions.color.hover = newOptions.color.hover;colorsDefined = true;
            }
            if (newOptions.color.inherit !== undefined) {
              parentOptions.color.inherit = newOptions.color.inherit;
            }
            if (newOptions.color.opacity !== undefined) {
              parentOptions.color.opacity = Math.min(1, Math.max(0, newOptions.color.opacity));
            }

            if (newOptions.color.inherit === undefined && colorsDefined === true) {
              parentOptions.color.inherit = false;
            }
          }
        } else if (allowDeletion === true && newOptions.color === null) {
          parentOptions.color = util.bridgeObject(globalOptions.color); // set the object back to the global options
        }

        // handle the font settings
        if (newOptions.font !== undefined && newOptions.font !== null) {
          _Label2.default.parseOptions(parentOptions.font, newOptions);
        } else if (allowDeletion === true && newOptions.font === null) {
          parentOptions.font = util.bridgeObject(globalOptions.font);
        }
      }
    }]);

    return Edge;
  }();

  exports.default = Edge;

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _CubicBezierEdgeBase2 = __webpack_require__(87);

  var _CubicBezierEdgeBase3 = _interopRequireDefault(_CubicBezierEdgeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var CubicBezierEdge = function (_CubicBezierEdgeBase) {
    _inherits(CubicBezierEdge, _CubicBezierEdgeBase);

    function CubicBezierEdge(options, body, labelModule) {
      _classCallCheck(this, CubicBezierEdge);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(CubicBezierEdge).call(this, options, body, labelModule));
    }

    /**
     * Draw a line between two nodes
     * @param {CanvasRenderingContext2D} ctx
     * @private
     */


    _createClass(CubicBezierEdge, [{
      key: '_line',
      value: function _line(ctx, viaNodes) {
        // get the coordinates of the support points.
        var via1 = viaNodes[0];
        var via2 = viaNodes[1];

        // start drawing the line.
        ctx.beginPath();
        ctx.moveTo(this.fromPoint.x, this.fromPoint.y);

        // fallback to normal straight edges
        if (viaNodes === undefined || via1.x === undefined) {
          ctx.lineTo(this.toPoint.x, this.toPoint.y);
        } else {
          ctx.bezierCurveTo(via1.x, via1.y, via2.x, via2.y, this.toPoint.x, this.toPoint.y);
        }
        // draw shadow if enabled
        this.enableShadow(ctx);
        ctx.stroke();
        this.disableShadow(ctx);
      }
    }, {
      key: '_getViaCoordinates',
      value: function _getViaCoordinates() {
        var dx = this.from.x - this.to.x;
        var dy = this.from.y - this.to.y;

        var x1 = void 0,
            y1 = void 0,
            x2 = void 0,
            y2 = void 0;
        var roundness = this.options.smooth.roundness;

        // horizontal if x > y or if direction is forced or if direction is horizontal
        if ((Math.abs(dx) > Math.abs(dy) || this.options.smooth.forceDirection === true || this.options.smooth.forceDirection === 'horizontal') && this.options.smooth.forceDirection !== 'vertical') {
          y1 = this.from.y;
          y2 = this.to.y;
          x1 = this.from.x - roundness * dx;
          x2 = this.to.x + roundness * dx;
        } else {
          y1 = this.from.y - roundness * dy;
          y2 = this.to.y + roundness * dy;
          x1 = this.from.x;
          x2 = this.to.x;
        }

        return [{ x: x1, y: y1 }, { x: x2, y: y2 }];
      }
    }, {
      key: 'getViaNode',
      value: function getViaNode() {
        return this._getViaCoordinates();
      }
    }, {
      key: '_findBorderPosition',
      value: function _findBorderPosition(nearNode, ctx) {
        return this._findBorderPositionBezier(nearNode, ctx);
      }
    }, {
      key: '_getDistanceToEdge',
      value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
        var _ref = arguments.length <= 6 || arguments[6] === undefined ? this._getViaCoordinates() : arguments[6];

        var _ref2 = _slicedToArray(_ref, 2);

        var via1 = _ref2[0];
        var via2 = _ref2[1];
        // x3,y3 is the point
        return this._getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, via1, via2);
      }

      /**
       * Combined function of pointOnLine and pointOnBezier. This gives the coordinates of a point on the line at a certain percentage of the way
       * @param percentage
       * @param via
       * @returns {{x: number, y: number}}
       * @private
       */

    }, {
      key: 'getPoint',
      value: function getPoint(percentage) {
        var _ref3 = arguments.length <= 1 || arguments[1] === undefined ? this._getViaCoordinates() : arguments[1];

        var _ref4 = _slicedToArray(_ref3, 2);

        var via1 = _ref4[0];
        var via2 = _ref4[1];

        var t = percentage;
        var vec = [];
        vec[0] = Math.pow(1 - t, 3);
        vec[1] = 3 * t * Math.pow(1 - t, 2);
        vec[2] = 3 * Math.pow(t, 2) * (1 - t);
        vec[3] = Math.pow(t, 3);
        var x = vec[0] * this.fromPoint.x + vec[1] * via1.x + vec[2] * via2.x + vec[3] * this.toPoint.x;
        var y = vec[0] * this.fromPoint.y + vec[1] * via1.y + vec[2] * via2.y + vec[3] * this.toPoint.y;

        return { x: x, y: y };
      }
    }]);

    return CubicBezierEdge;
  }(_CubicBezierEdgeBase3.default);

  exports.default = CubicBezierEdge;

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _BezierEdgeBase2 = __webpack_require__(88);

  var _BezierEdgeBase3 = _interopRequireDefault(_BezierEdgeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var CubicBezierEdgeBase = function (_BezierEdgeBase) {
    _inherits(CubicBezierEdgeBase, _BezierEdgeBase);

    function CubicBezierEdgeBase(options, body, labelModule) {
      _classCallCheck(this, CubicBezierEdgeBase);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(CubicBezierEdgeBase).call(this, options, body, labelModule));
    }

    /**
     * Calculate the distance between a point (x3,y3) and a line segment from
     * (x1,y1) to (x2,y2).
     * http://stackoverflow.com/questions/849211/shortest-distancae-between-a-point-and-a-line-segment
     * https://en.wikipedia.org/wiki/B%C3%A9zier_curve
     * @param {number} x1 from x
     * @param {number} y1 from y
     * @param {number} x2 to x
     * @param {number} y2 to y
     * @param {number} x3 point to check x
     * @param {number} y3 point to check y
     * @private
     */


    _createClass(CubicBezierEdgeBase, [{
      key: '_getDistanceToBezierEdge',
      value: function _getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, via1, via2) {
        // x3,y3 is the point
        var minDistance = 1e9;
        var distance = void 0;
        var i = void 0,
            t = void 0,
            x = void 0,
            y = void 0;
        var lastX = x1;
        var lastY = y1;
        var vec = [0, 0, 0, 0];
        for (i = 1; i < 10; i++) {
          t = 0.1 * i;
          vec[0] = Math.pow(1 - t, 3);
          vec[1] = 3 * t * Math.pow(1 - t, 2);
          vec[2] = 3 * Math.pow(t, 2) * (1 - t);
          vec[3] = Math.pow(t, 3);
          x = vec[0] * x1 + vec[1] * via1.x + vec[2] * via2.x + vec[3] * x2;
          y = vec[0] * y1 + vec[1] * via1.y + vec[2] * via2.y + vec[3] * y2;
          if (i > 0) {
            distance = this._getDistanceToLine(lastX, lastY, x, y, x3, y3);
            minDistance = distance < minDistance ? distance : minDistance;
          }
          lastX = x;
          lastY = y;
        }

        return minDistance;
      }
    }]);

    return CubicBezierEdgeBase;
  }(_BezierEdgeBase3.default);

  exports.default = CubicBezierEdgeBase;

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _EdgeBase2 = __webpack_require__(89);

  var _EdgeBase3 = _interopRequireDefault(_EdgeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var BezierEdgeBase = function (_EdgeBase) {
    _inherits(BezierEdgeBase, _EdgeBase);

    function BezierEdgeBase(options, body, labelModule) {
      _classCallCheck(this, BezierEdgeBase);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(BezierEdgeBase).call(this, options, body, labelModule));
    }

    /**
     * This function uses binary search to look for the point where the bezier curve crosses the border of the node.
     *
     * @param nearNode
     * @param ctx
     * @param viaNode
     * @param nearNode
     * @param ctx
     * @param viaNode
     * @param nearNode
     * @param ctx
     * @param viaNode
     */


    _createClass(BezierEdgeBase, [{
      key: '_findBorderPositionBezier',
      value: function _findBorderPositionBezier(nearNode, ctx) {
        var viaNode = arguments.length <= 2 || arguments[2] === undefined ? this._getViaCoordinates() : arguments[2];

        var maxIterations = 10;
        var iteration = 0;
        var low = 0;
        var high = 1;
        var pos, angle, distanceToBorder, distanceToPoint, difference;
        var threshold = 0.2;
        var node = this.to;
        var from = false;
        if (nearNode.id === this.from.id) {
          node = this.from;
          from = true;
        }

        while (low <= high && iteration < maxIterations) {
          var middle = (low + high) * 0.5;

          pos = this.getPoint(middle, viaNode);
          angle = Math.atan2(node.y - pos.y, node.x - pos.x);
          distanceToBorder = node.distanceToBorder(ctx, angle);
          distanceToPoint = Math.sqrt(Math.pow(pos.x - node.x, 2) + Math.pow(pos.y - node.y, 2));
          difference = distanceToBorder - distanceToPoint;
          if (Math.abs(difference) < threshold) {
            break; // found
          } else if (difference < 0) {
              // distance to nodes is larger than distance to border --> t needs to be bigger if we're looking at the to node.
              if (from === false) {
                low = middle;
              } else {
                high = middle;
              }
            } else {
              if (from === false) {
                high = middle;
              } else {
                low = middle;
              }
            }

          iteration++;
        }
        pos.t = middle;

        return pos;
      }

      /**
       * Calculate the distance between a point (x3,y3) and a line segment from
       * (x1,y1) to (x2,y2).
       * http://stackoverflow.com/questions/849211/shortest-distancae-between-a-point-and-a-line-segment
       * @param {number} x1 from x
       * @param {number} y1 from y
       * @param {number} x2 to x
       * @param {number} y2 to y
       * @param {number} x3 point to check x
       * @param {number} y3 point to check y
       * @private
       */

    }, {
      key: '_getDistanceToBezierEdge',
      value: function _getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, via) {
        // x3,y3 is the point
        var minDistance = 1e9;
        var distance = void 0;
        var i = void 0,
            t = void 0,
            x = void 0,
            y = void 0;
        var lastX = x1;
        var lastY = y1;
        for (i = 1; i < 10; i++) {
          t = 0.1 * i;
          x = Math.pow(1 - t, 2) * x1 + 2 * t * (1 - t) * via.x + Math.pow(t, 2) * x2;
          y = Math.pow(1 - t, 2) * y1 + 2 * t * (1 - t) * via.y + Math.pow(t, 2) * y2;
          if (i > 0) {
            distance = this._getDistanceToLine(lastX, lastY, x, y, x3, y3);
            minDistance = distance < minDistance ? distance : minDistance;
          }
          lastX = x;
          lastY = y;
        }

        return minDistance;
      }
    }]);

    return BezierEdgeBase;
  }(_EdgeBase3.default);

  exports.default = BezierEdgeBase;

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);

  var EdgeBase = function () {
    function EdgeBase(options, body, labelModule) {
      _classCallCheck(this, EdgeBase);

      this.body = body;
      this.labelModule = labelModule;
      this.options = {};
      this.setOptions(options);
      this.colorDirty = true;
      this.color = {};
      this.selectionWidth = 2;
      this.hoverWidth = 1.5;
      this.fromPoint = this.from;
      this.toPoint = this.to;
    }

    _createClass(EdgeBase, [{
      key: 'connect',
      value: function connect() {
        this.from = this.body.nodes[this.options.from];
        this.to = this.body.nodes[this.options.to];
      }
    }, {
      key: 'cleanup',
      value: function cleanup() {
        return false;
      }
    }, {
      key: 'setOptions',
      value: function setOptions(options) {
        this.options = options;
        this.from = this.body.nodes[this.options.from];
        this.to = this.body.nodes[this.options.to];
        this.id = this.options.id;
      }

      /**
       * Redraw a edge as a line
       * Draw this edge in the given canvas
       * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
       * @param {CanvasRenderingContext2D}   ctx
       * @private
       */

    }, {
      key: 'drawLine',
      value: function drawLine(ctx, selected, hover, viaNode) {
        // set style
        ctx.strokeStyle = this.getColor(ctx, selected, hover);
        ctx.lineWidth = this.getLineWidth(selected, hover);

        if (this.options.dashes !== false) {
          this._drawDashedLine(ctx, viaNode);
        } else {
          this._drawLine(ctx, viaNode);
        }
      }
    }, {
      key: '_drawLine',
      value: function _drawLine(ctx, viaNode, fromPoint, toPoint) {
        if (this.from != this.to) {
          // draw line
          this._line(ctx, viaNode, fromPoint, toPoint);
        } else {
          var _getCircleData2 = this._getCircleData(ctx);

          var _getCircleData3 = _slicedToArray(_getCircleData2, 3);

          var x = _getCircleData3[0];
          var y = _getCircleData3[1];
          var radius = _getCircleData3[2];

          this._circle(ctx, x, y, radius);
        }
      }
    }, {
      key: '_drawDashedLine',
      value: function _drawDashedLine(ctx, viaNode, fromPoint, toPoint) {
        ctx.lineCap = 'round';
        var pattern = [5, 5];
        if (Array.isArray(this.options.dashes) === true) {
          pattern = this.options.dashes;
        }

        // only firefox and chrome support this method, else we use the legacy one.
        if (ctx.setLineDash !== undefined) {
          ctx.save();

          // set dash settings for chrome or firefox
          ctx.setLineDash(pattern);
          ctx.lineDashOffset = 0;

          // draw the line
          if (this.from != this.to) {
            // draw line
            this._line(ctx, viaNode);
          } else {
            var _getCircleData4 = this._getCircleData(ctx);

            var _getCircleData5 = _slicedToArray(_getCircleData4, 3);

            var x = _getCircleData5[0];
            var y = _getCircleData5[1];
            var radius = _getCircleData5[2];

            this._circle(ctx, x, y, radius);
          }

          // restore the dash settings.
          ctx.setLineDash([0]);
          ctx.lineDashOffset = 0;
          ctx.restore();
        } else {
          // unsupporting smooth lines
          if (this.from != this.to) {
            // draw line
            ctx.dashedLine(this.from.x, this.from.y, this.to.x, this.to.y, pattern);
          } else {
            var _getCircleData6 = this._getCircleData(ctx);

            var _getCircleData7 = _slicedToArray(_getCircleData6, 3);

            var _x = _getCircleData7[0];
            var _y = _getCircleData7[1];
            var _radius = _getCircleData7[2];

            this._circle(ctx, _x, _y, _radius);
          }
          // draw shadow if enabled
          this.enableShadow(ctx);

          ctx.stroke();

          // disable shadows for other elements.
          this.disableShadow(ctx);
        }
      }
    }, {
      key: 'findBorderPosition',
      value: function findBorderPosition(nearNode, ctx, options) {
        if (this.from != this.to) {
          return this._findBorderPosition(nearNode, ctx, options);
        } else {
          return this._findBorderPositionCircle(nearNode, ctx, options);
        }
      }
    }, {
      key: 'findBorderPositions',
      value: function findBorderPositions(ctx) {
        var from = {};
        var to = {};
        if (this.from != this.to) {
          from = this._findBorderPosition(this.from, ctx);
          to = this._findBorderPosition(this.to, ctx);
        } else {
          var _getCircleData8 = this._getCircleData(ctx);

          var _getCircleData9 = _slicedToArray(_getCircleData8, 3);

          var x = _getCircleData9[0];
          var y = _getCircleData9[1];
          var radius = _getCircleData9[2];


          from = this._findBorderPositionCircle(this.from, ctx, { x: x, y: y, low: 0.25, high: 0.6, direction: -1 });
          to = this._findBorderPositionCircle(this.from, ctx, { x: x, y: y, low: 0.6, high: 0.8, direction: 1 });
        }
        return { from: from, to: to };
      }
    }, {
      key: '_getCircleData',
      value: function _getCircleData(ctx) {
        var x = void 0,
            y = void 0;
        var node = this.from;
        var radius = this.options.selfReferenceSize;

        if (ctx !== undefined) {
          if (node.shape.width === undefined) {
            node.shape.resize(ctx);
          }
        }

        // get circle coordinates
        if (node.shape.width > node.shape.height) {
          x = node.x + node.shape.width * 0.5;
          y = node.y - radius;
        } else {
          x = node.x + radius;
          y = node.y - node.shape.height * 0.5;
        }
        return [x, y, radius];
      }

      /**
       * Get a point on a circle
       * @param {Number} x
       * @param {Number} y
       * @param {Number} radius
       * @param {Number} percentage. Value between 0 (line start) and 1 (line end)
       * @return {Object} point
       * @private
       */

    }, {
      key: '_pointOnCircle',
      value: function _pointOnCircle(x, y, radius, percentage) {
        var angle = percentage * 2 * Math.PI;
        return {
          x: x + radius * Math.cos(angle),
          y: y - radius * Math.sin(angle)
        };
      }

      /**
       * This function uses binary search to look for the point where the circle crosses the border of the node.
       * @param node
       * @param ctx
       * @param options
       * @returns {*}
       * @private
       */

    }, {
      key: '_findBorderPositionCircle',
      value: function _findBorderPositionCircle(node, ctx, options) {
        var x = options.x;
        var y = options.y;
        var low = options.low;
        var high = options.high;
        var direction = options.direction;

        var maxIterations = 10;
        var iteration = 0;
        var radius = this.options.selfReferenceSize;
        var pos = void 0,
            angle = void 0,
            distanceToBorder = void 0,
            distanceToPoint = void 0,
            difference = void 0;
        var threshold = 0.05;
        var middle = (low + high) * 0.5;

        while (low <= high && iteration < maxIterations) {
          middle = (low + high) * 0.5;

          pos = this._pointOnCircle(x, y, radius, middle);
          angle = Math.atan2(node.y - pos.y, node.x - pos.x);
          distanceToBorder = node.distanceToBorder(ctx, angle);
          distanceToPoint = Math.sqrt(Math.pow(pos.x - node.x, 2) + Math.pow(pos.y - node.y, 2));
          difference = distanceToBorder - distanceToPoint;
          if (Math.abs(difference) < threshold) {
            break; // found
          } else if (difference > 0) {
              // distance to nodes is larger than distance to border --> t needs to be bigger if we're looking at the to node.
              if (direction > 0) {
                low = middle;
              } else {
                high = middle;
              }
            } else {
              if (direction > 0) {
                high = middle;
              } else {
                low = middle;
              }
            }
          iteration++;
        }
        pos.t = middle;

        return pos;
      }

      /**
       * Get the line width of the edge. Depends on width and whether one of the
       * connected nodes is selected.
       * @return {Number} width
       * @private
       */

    }, {
      key: 'getLineWidth',
      value: function getLineWidth(selected, hover) {
        if (selected === true) {
          return Math.max(this.selectionWidth, 0.3 / this.body.view.scale);
        } else {
          if (hover === true) {
            return Math.max(this.hoverWidth, 0.3 / this.body.view.scale);
          } else {
            return Math.max(this.options.width, 0.3 / this.body.view.scale);
          }
        }
      }
    }, {
      key: 'getColor',
      value: function getColor(ctx, selected, hover) {
        var colorOptions = this.options.color;
        if (colorOptions.inherit !== false) {
          // when this is a loop edge, just use the 'from' method
          if (colorOptions.inherit === 'both' && this.from.id !== this.to.id) {
            var grd = ctx.createLinearGradient(this.from.x, this.from.y, this.to.x, this.to.y);
            var fromColor = void 0,
                toColor = void 0;
            fromColor = this.from.options.color.highlight.border;
            toColor = this.to.options.color.highlight.border;

            if (this.from.selected === false && this.to.selected === false) {
              fromColor = util.overrideOpacity(this.from.options.color.border, this.options.color.opacity);
              toColor = util.overrideOpacity(this.to.options.color.border, this.options.color.opacity);
            } else if (this.from.selected === true && this.to.selected === false) {
              toColor = this.to.options.color.border;
            } else if (this.from.selected === false && this.to.selected === true) {
              fromColor = this.from.options.color.border;
            }
            grd.addColorStop(0, fromColor);
            grd.addColorStop(1, toColor);

            // -------------------- this returns -------------------- //
            return grd;
          }

          if (this.colorDirty === true) {
            if (colorOptions.inherit === "to") {
              this.color.highlight = this.to.options.color.highlight.border;
              this.color.hover = this.to.options.color.hover.border;
              this.color.color = util.overrideOpacity(this.to.options.color.border, colorOptions.opacity);
            } else {
              // (this.options.color.inherit.source === "from") {
              this.color.highlight = this.from.options.color.highlight.border;
              this.color.hover = this.from.options.color.hover.border;
              this.color.color = util.overrideOpacity(this.from.options.color.border, colorOptions.opacity);
            }
          }
        } else if (this.colorDirty === true) {
          this.color.highlight = colorOptions.highlight;
          this.color.hover = colorOptions.hover;
          this.color.color = util.overrideOpacity(colorOptions.color, colorOptions.opacity);
        }

        // if color inherit is on and gradients are used, the function has already returned by now.
        this.colorDirty = false;

        if (selected === true) {
          return this.color.highlight;
        } else if (hover === true) {
          return this.color.hover;
        } else {
          return this.color.color;
        }
      }

      /**
       * Draw a line from a node to itself, a circle
       * @param {CanvasRenderingContext2D} ctx
       * @param {Number} x
       * @param {Number} y
       * @param {Number} radius
       * @private
       */

    }, {
      key: '_circle',
      value: function _circle(ctx, x, y, radius) {
        // draw shadow if enabled
        this.enableShadow(ctx);

        // draw a circle
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, 2 * Math.PI, false);
        ctx.stroke();

        // disable shadows for other elements.
        this.disableShadow(ctx);
      }

      /**
       * Calculate the distance between a point (x3,y3) and a line segment from
       * (x1,y1) to (x2,y2).
       * http://stackoverflow.com/questions/849211/shortest-distancae-between-a-point-and-a-line-segment
       * @param {number} x1
       * @param {number} y1
       * @param {number} x2
       * @param {number} y2
       * @param {number} x3
       * @param {number} y3
       * @private
       */

    }, {
      key: 'getDistanceToEdge',
      value: function getDistanceToEdge(x1, y1, x2, y2, x3, y3, via) {
        // x3,y3 is the point
        var returnValue = 0;
        if (this.from != this.to) {
          returnValue = this._getDistanceToEdge(x1, y1, x2, y2, x3, y3, via);
        } else {
          var _getCircleData10 = this._getCircleData();

          var _getCircleData11 = _slicedToArray(_getCircleData10, 3);

          var x = _getCircleData11[0];
          var y = _getCircleData11[1];
          var radius = _getCircleData11[2];

          var dx = x - x3;
          var dy = y - y3;
          returnValue = Math.abs(Math.sqrt(dx * dx + dy * dy) - radius);
        }

        if (this.labelModule.size.left < x3 && this.labelModule.size.left + this.labelModule.size.width > x3 && this.labelModule.size.top < y3 && this.labelModule.size.top + this.labelModule.size.height > y3) {
          return 0;
        } else {
          return returnValue;
        }
      }
    }, {
      key: '_getDistanceToLine',
      value: function _getDistanceToLine(x1, y1, x2, y2, x3, y3) {
        var px = x2 - x1;
        var py = y2 - y1;
        var something = px * px + py * py;
        var u = ((x3 - x1) * px + (y3 - y1) * py) / something;

        if (u > 1) {
          u = 1;
        } else if (u < 0) {
          u = 0;
        }

        var x = x1 + u * px;
        var y = y1 + u * py;
        var dx = x - x3;
        var dy = y - y3;

        //# Note: If the actual distance does not matter,
        //# if you only want to compare what this function
        //# returns to other results of this function, you
        //# can just return the squared distance instead
        //# (i.e. remove the sqrt) to gain a little performance

        return Math.sqrt(dx * dx + dy * dy);
      }

      /**
       *
       * @param ctx
       * @param position
       * @param viaNode
       */

    }, {
      key: 'getArrowData',
      value: function getArrowData(ctx, position, viaNode, selected, hover) {
        // set lets
        var angle = void 0;
        var arrowPoint = void 0;
        var node1 = void 0;
        var node2 = void 0;
        var guideOffset = void 0;
        var scaleFactor = void 0;
        var lineWidth = this.getLineWidth(selected, hover);

        if (position === 'from') {
          node1 = this.from;
          node2 = this.to;
          guideOffset = 0.1;
          scaleFactor = this.options.arrows.from.scaleFactor;
        } else if (position === 'to') {
          node1 = this.to;
          node2 = this.from;
          guideOffset = -0.1;
          scaleFactor = this.options.arrows.to.scaleFactor;
        } else {
          node1 = this.to;
          node2 = this.from;
          scaleFactor = this.options.arrows.middle.scaleFactor;
        }

        // if not connected to itself
        if (node1 != node2) {
          if (position !== 'middle') {
            // draw arrow head
            if (this.options.smooth.enabled === true) {
              arrowPoint = this.findBorderPosition(node1, ctx, { via: viaNode });
              var guidePos = this.getPoint(Math.max(0.0, Math.min(1.0, arrowPoint.t + guideOffset)), viaNode);
              angle = Math.atan2(arrowPoint.y - guidePos.y, arrowPoint.x - guidePos.x);
            } else {
              angle = Math.atan2(node1.y - node2.y, node1.x - node2.x);
              arrowPoint = this.findBorderPosition(node1, ctx);
            }
          } else {
            angle = Math.atan2(node1.y - node2.y, node1.x - node2.x);
            arrowPoint = this.getPoint(0.5, viaNode); // this is 0.6 to account for the size of the arrow.
          }
        } else {
            // draw circle

            var _getCircleData12 = this._getCircleData(ctx);

            var _getCircleData13 = _slicedToArray(_getCircleData12, 3);

            var x = _getCircleData13[0];
            var y = _getCircleData13[1];
            var radius = _getCircleData13[2];


            if (position === 'from') {
              arrowPoint = this.findBorderPosition(this.from, ctx, { x: x, y: y, low: 0.25, high: 0.6, direction: -1 });
              angle = arrowPoint.t * -2 * Math.PI + 1.5 * Math.PI + 0.1 * Math.PI;
            } else if (position === 'to') {
              arrowPoint = this.findBorderPosition(this.from, ctx, { x: x, y: y, low: 0.6, high: 1.0, direction: 1 });
              angle = arrowPoint.t * -2 * Math.PI + 1.5 * Math.PI - 1.1 * Math.PI;
            } else {
              arrowPoint = this._pointOnCircle(x, y, radius, 0.175);
              angle = 3.9269908169872414; // === 0.175 * -2 * Math.PI + 1.5 * Math.PI + 0.1 * Math.PI;
            }
          }

        var length = 15 * scaleFactor + 3 * lineWidth; // 3* lineWidth is the width of the edge.

        var xi = arrowPoint.x - length * 0.9 * Math.cos(angle);
        var yi = arrowPoint.y - length * 0.9 * Math.sin(angle);
        var arrowCore = { x: xi, y: yi };

        return { point: arrowPoint, core: arrowCore, angle: angle, length: length };
      }

      /**
       *
       * @param ctx
       * @param selected
       * @param hover
       * @param arrowData
       */

    }, {
      key: 'drawArrowHead',
      value: function drawArrowHead(ctx, selected, hover, arrowData) {
        // set style
        ctx.strokeStyle = this.getColor(ctx, selected, hover);
        ctx.fillStyle = ctx.strokeStyle;
        ctx.lineWidth = this.getLineWidth(selected, hover);

        // draw arrow at the end of the line
        ctx.arrow(arrowData.point.x, arrowData.point.y, arrowData.angle, arrowData.length);

        // draw shadow if enabled
        this.enableShadow(ctx);
        ctx.fill();
        // disable shadows for other elements.
        this.disableShadow(ctx);
      }
    }, {
      key: 'enableShadow',
      value: function enableShadow(ctx) {
        if (this.options.shadow.enabled === true) {
          ctx.shadowColor = this.options.shadow.color;
          ctx.shadowBlur = this.options.shadow.size;
          ctx.shadowOffsetX = this.options.shadow.x;
          ctx.shadowOffsetY = this.options.shadow.y;
        }
      }
    }, {
      key: 'disableShadow',
      value: function disableShadow(ctx) {
        if (this.options.shadow.enabled === true) {
          ctx.shadowColor = 'rgba(0,0,0,0)';
          ctx.shadowBlur = 0;
          ctx.shadowOffsetX = 0;
          ctx.shadowOffsetY = 0;
        }
      }
    }]);

    return EdgeBase;
  }();

  exports.default = EdgeBase;

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _BezierEdgeBase2 = __webpack_require__(88);

  var _BezierEdgeBase3 = _interopRequireDefault(_BezierEdgeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var BezierEdgeDynamic = function (_BezierEdgeBase) {
    _inherits(BezierEdgeDynamic, _BezierEdgeBase);

    function BezierEdgeDynamic(options, body, labelModule) {
      _classCallCheck(this, BezierEdgeDynamic);

      // --> this calls the setOptions below

      var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(BezierEdgeDynamic).call(this, options, body, labelModule));
      //this.via = undefined; // Here for completeness but not allowed to defined before super() is invoked.


      _this._boundFunction = function () {
        _this.positionBezierNode();
      };
      _this.body.emitter.on("_repositionBezierNodes", _this._boundFunction);
      return _this;
    }

    _createClass(BezierEdgeDynamic, [{
      key: "setOptions",
      value: function setOptions(options) {
        // check if the physics has changed.
        var physicsChange = false;
        if (this.options.physics !== options.physics) {
          physicsChange = true;
        }

        // set the options and the to and from nodes
        this.options = options;
        this.id = this.options.id;
        this.from = this.body.nodes[this.options.from];
        this.to = this.body.nodes[this.options.to];

        // setup the support node and connect
        this.setupSupportNode();
        this.connect();

        // when we change the physics state of the edge, we reposition the support node.
        if (physicsChange === true) {
          this.via.setOptions({ physics: this.options.physics });
          this.positionBezierNode();
        }
      }
    }, {
      key: "connect",
      value: function connect() {
        this.from = this.body.nodes[this.options.from];
        this.to = this.body.nodes[this.options.to];
        if (this.from === undefined || this.to === undefined || this.options.physics === false) {
          this.via.setOptions({ physics: false });
        } else {
          // fix weird behaviour where a self referencing node has physics enabled
          if (this.from.id === this.to.id) {
            this.via.setOptions({ physics: false });
          } else {
            this.via.setOptions({ physics: true });
          }
        }
      }

      /**
       * remove the support nodes
       * @returns {boolean}
       */

    }, {
      key: "cleanup",
      value: function cleanup() {
        this.body.emitter.off("_repositionBezierNodes", this._boundFunction);
        if (this.via !== undefined) {
          delete this.body.nodes[this.via.id];
          this.via = undefined;
          return true;
        }
        return false;
      }

      /**
       * Bezier curves require an anchor point to calculate the smooth flow. These points are nodes. These nodes are invisible but
       * are used for the force calculation.
       *
       * The changed data is not called, if needed, it is returned by the main edge constructor.
       * @private
       */

    }, {
      key: "setupSupportNode",
      value: function setupSupportNode() {
        if (this.via === undefined) {
          var nodeId = "edgeId:" + this.id;
          var node = this.body.functions.createNode({
            id: nodeId,
            shape: 'circle',
            physics: true,
            hidden: true
          });
          this.body.nodes[nodeId] = node;
          this.via = node;
          this.via.parentEdgeId = this.id;
          this.positionBezierNode();
        }
      }
    }, {
      key: "positionBezierNode",
      value: function positionBezierNode() {
        if (this.via !== undefined && this.from !== undefined && this.to !== undefined) {
          this.via.x = 0.5 * (this.from.x + this.to.x);
          this.via.y = 0.5 * (this.from.y + this.to.y);
        } else if (this.via !== undefined) {
          this.via.x = 0;
          this.via.y = 0;
        }
      }

      /**
       * Draw a line between two nodes
       * @param {CanvasRenderingContext2D} ctx
       * @private
       */

    }, {
      key: "_line",
      value: function _line(ctx, viaNode) {
        // draw a straight line
        ctx.beginPath();
        ctx.moveTo(this.fromPoint.x, this.fromPoint.y);
        // fallback to normal straight edges
        if (viaNode.x === undefined) {
          ctx.lineTo(this.toPoint.x, this.toPoint.y);
        } else {
          ctx.quadraticCurveTo(viaNode.x, viaNode.y, this.toPoint.x, this.toPoint.y);
        }
        // draw shadow if enabled
        this.enableShadow(ctx);
        ctx.stroke();
        this.disableShadow(ctx);
      }
    }, {
      key: "getViaNode",
      value: function getViaNode() {
        return this.via;
      }

      /**
       * Combined function of pointOnLine and pointOnBezier. This gives the coordinates of a point on the line at a certain percentage of the way
       * @param percentage
       * @param viaNode
       * @returns {{x: number, y: number}}
       * @private
       */

    }, {
      key: "getPoint",
      value: function getPoint(percentage) {
        var viaNode = arguments.length <= 1 || arguments[1] === undefined ? this.via : arguments[1];

        var t = percentage;
        var x = Math.pow(1 - t, 2) * this.fromPoint.x + 2 * t * (1 - t) * viaNode.x + Math.pow(t, 2) * this.toPoint.x;
        var y = Math.pow(1 - t, 2) * this.fromPoint.y + 2 * t * (1 - t) * viaNode.y + Math.pow(t, 2) * this.toPoint.y;

        return { x: x, y: y };
      }
    }, {
      key: "_findBorderPosition",
      value: function _findBorderPosition(nearNode, ctx) {
        return this._findBorderPositionBezier(nearNode, ctx, this.via);
      }
    }, {
      key: "_getDistanceToEdge",
      value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
        // x3,y3 is the point
        return this._getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, this.via);
      }
    }]);

    return BezierEdgeDynamic;
  }(_BezierEdgeBase3.default);

  exports.default = BezierEdgeDynamic;

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _BezierEdgeBase2 = __webpack_require__(88);

  var _BezierEdgeBase3 = _interopRequireDefault(_BezierEdgeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var BezierEdgeStatic = function (_BezierEdgeBase) {
    _inherits(BezierEdgeStatic, _BezierEdgeBase);

    function BezierEdgeStatic(options, body, labelModule) {
      _classCallCheck(this, BezierEdgeStatic);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(BezierEdgeStatic).call(this, options, body, labelModule));
    }

    /**
     * Draw a line between two nodes
     * @param {CanvasRenderingContext2D} ctx
     * @private
     */


    _createClass(BezierEdgeStatic, [{
      key: '_line',
      value: function _line(ctx, viaNode) {
        // draw a straight line
        ctx.beginPath();
        ctx.moveTo(this.fromPoint.x, this.fromPoint.y);

        // fallback to normal straight edges
        if (viaNode.x === undefined) {
          ctx.lineTo(this.toPoint.x, this.toPoint.y);
        } else {
          ctx.quadraticCurveTo(viaNode.x, viaNode.y, this.toPoint.x, this.toPoint.y);
        }
        // draw shadow if enabled
        this.enableShadow(ctx);
        ctx.stroke();
        this.disableShadow(ctx);
      }
    }, {
      key: 'getViaNode',
      value: function getViaNode() {
        return this._getViaCoordinates();
      }

      /**
       * We do not use the to and fromPoints here to make the via nodes the same as edges without arrows.
       * @returns {{x: undefined, y: undefined}}
       * @private
       */

    }, {
      key: '_getViaCoordinates',
      value: function _getViaCoordinates() {
        var xVia = undefined;
        var yVia = undefined;
        var factor = this.options.smooth.roundness;
        var type = this.options.smooth.type;
        var dx = Math.abs(this.from.x - this.to.x);
        var dy = Math.abs(this.from.y - this.to.y);
        if (type === 'discrete' || type === 'diagonalCross') {
          if (Math.abs(this.from.x - this.to.x) <= Math.abs(this.from.y - this.to.y)) {
            if (this.from.y >= this.to.y) {
              if (this.from.x <= this.to.x) {
                xVia = this.from.x + factor * dy;
                yVia = this.from.y - factor * dy;
              } else if (this.from.x > this.to.x) {
                xVia = this.from.x - factor * dy;
                yVia = this.from.y - factor * dy;
              }
            } else if (this.from.y < this.to.y) {
              if (this.from.x <= this.to.x) {
                xVia = this.from.x + factor * dy;
                yVia = this.from.y + factor * dy;
              } else if (this.from.x > this.to.x) {
                xVia = this.from.x - factor * dy;
                yVia = this.from.y + factor * dy;
              }
            }
            if (type === "discrete") {
              xVia = dx < factor * dy ? this.from.x : xVia;
            }
          } else if (Math.abs(this.from.x - this.to.x) > Math.abs(this.from.y - this.to.y)) {
            if (this.from.y >= this.to.y) {
              if (this.from.x <= this.to.x) {
                xVia = this.from.x + factor * dx;
                yVia = this.from.y - factor * dx;
              } else if (this.from.x > this.to.x) {
                xVia = this.from.x - factor * dx;
                yVia = this.from.y - factor * dx;
              }
            } else if (this.from.y < this.to.y) {
              if (this.from.x <= this.to.x) {
                xVia = this.from.x + factor * dx;
                yVia = this.from.y + factor * dx;
              } else if (this.from.x > this.to.x) {
                xVia = this.from.x - factor * dx;
                yVia = this.from.y + factor * dx;
              }
            }
            if (type === "discrete") {
              yVia = dy < factor * dx ? this.from.y : yVia;
            }
          }
        } else if (type === "straightCross") {
          if (Math.abs(this.from.x - this.to.x) <= Math.abs(this.from.y - this.to.y)) {
            // up - down
            xVia = this.from.x;
            if (this.from.y < this.to.y) {
              yVia = this.to.y - (1 - factor) * dy;
            } else {
              yVia = this.to.y + (1 - factor) * dy;
            }
          } else if (Math.abs(this.from.x - this.to.x) > Math.abs(this.from.y - this.to.y)) {
            // left - right
            if (this.from.x < this.to.x) {
              xVia = this.to.x - (1 - factor) * dx;
            } else {
              xVia = this.to.x + (1 - factor) * dx;
            }
            yVia = this.from.y;
          }
        } else if (type === 'horizontal') {
          if (this.from.x < this.to.x) {
            xVia = this.to.x - (1 - factor) * dx;
          } else {
            xVia = this.to.x + (1 - factor) * dx;
          }
          yVia = this.from.y;
        } else if (type === 'vertical') {
          xVia = this.from.x;
          if (this.from.y < this.to.y) {
            yVia = this.to.y - (1 - factor) * dy;
          } else {
            yVia = this.to.y + (1 - factor) * dy;
          }
        } else if (type === 'curvedCW') {
          dx = this.to.x - this.from.x;
          dy = this.from.y - this.to.y;
          var radius = Math.sqrt(dx * dx + dy * dy);
          var pi = Math.PI;

          var originalAngle = Math.atan2(dy, dx);
          var myAngle = (originalAngle + (factor * 0.5 + 0.5) * pi) % (2 * pi);

          xVia = this.from.x + (factor * 0.5 + 0.5) * radius * Math.sin(myAngle);
          yVia = this.from.y + (factor * 0.5 + 0.5) * radius * Math.cos(myAngle);
        } else if (type === 'curvedCCW') {
          dx = this.to.x - this.from.x;
          dy = this.from.y - this.to.y;
          var _radius = Math.sqrt(dx * dx + dy * dy);
          var _pi = Math.PI;

          var _originalAngle = Math.atan2(dy, dx);
          var _myAngle = (_originalAngle + (-factor * 0.5 + 0.5) * _pi) % (2 * _pi);

          xVia = this.from.x + (factor * 0.5 + 0.5) * _radius * Math.sin(_myAngle);
          yVia = this.from.y + (factor * 0.5 + 0.5) * _radius * Math.cos(_myAngle);
        } else {
          // continuous
          if (Math.abs(this.from.x - this.to.x) <= Math.abs(this.from.y - this.to.y)) {
            if (this.from.y >= this.to.y) {
              if (this.from.x <= this.to.x) {
                xVia = this.from.x + factor * dy;
                yVia = this.from.y - factor * dy;
                xVia = this.to.x < xVia ? this.to.x : xVia;
              } else if (this.from.x > this.to.x) {
                xVia = this.from.x - factor * dy;
                yVia = this.from.y - factor * dy;
                xVia = this.to.x > xVia ? this.to.x : xVia;
              }
            } else if (this.from.y < this.to.y) {
              if (this.from.x <= this.to.x) {
                xVia = this.from.x + factor * dy;
                yVia = this.from.y + factor * dy;
                xVia = this.to.x < xVia ? this.to.x : xVia;
              } else if (this.from.x > this.to.x) {
                xVia = this.from.x - factor * dy;
                yVia = this.from.y + factor * dy;
                xVia = this.to.x > xVia ? this.to.x : xVia;
              }
            }
          } else if (Math.abs(this.from.x - this.to.x) > Math.abs(this.from.y - this.to.y)) {
            if (this.from.y >= this.to.y) {
              if (this.from.x <= this.to.x) {
                xVia = this.from.x + factor * dx;
                yVia = this.from.y - factor * dx;
                yVia = this.to.y > yVia ? this.to.y : yVia;
              } else if (this.from.x > this.to.x) {
                xVia = this.from.x - factor * dx;
                yVia = this.from.y - factor * dx;
                yVia = this.to.y > yVia ? this.to.y : yVia;
              }
            } else if (this.from.y < this.to.y) {
              if (this.from.x <= this.to.x) {
                xVia = this.from.x + factor * dx;
                yVia = this.from.y + factor * dx;
                yVia = this.to.y < yVia ? this.to.y : yVia;
              } else if (this.from.x > this.to.x) {
                xVia = this.from.x - factor * dx;
                yVia = this.from.y + factor * dx;
                yVia = this.to.y < yVia ? this.to.y : yVia;
              }
            }
          }
        }
        return { x: xVia, y: yVia };
      }
    }, {
      key: '_findBorderPosition',
      value: function _findBorderPosition(nearNode, ctx) {
        var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

        return this._findBorderPositionBezier(nearNode, ctx, options.via);
      }
    }, {
      key: '_getDistanceToEdge',
      value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
        var viaNode = arguments.length <= 6 || arguments[6] === undefined ? this._getViaCoordinates() : arguments[6];
        // x3,y3 is the point
        return this._getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, viaNode);
      }

      /**
       * Combined function of pointOnLine and pointOnBezier. This gives the coordinates of a point on the line at a certain percentage of the way
       * @param percentage
       * @param viaNode
       * @returns {{x: number, y: number}}
       * @private
       */

    }, {
      key: 'getPoint',
      value: function getPoint(percentage) {
        var viaNode = arguments.length <= 1 || arguments[1] === undefined ? this._getViaCoordinates() : arguments[1];

        var t = percentage;
        var x = Math.pow(1 - t, 2) * this.fromPoint.x + 2 * t * (1 - t) * viaNode.x + Math.pow(t, 2) * this.toPoint.x;
        var y = Math.pow(1 - t, 2) * this.fromPoint.y + 2 * t * (1 - t) * viaNode.y + Math.pow(t, 2) * this.toPoint.y;

        return { x: x, y: y };
      }
    }]);

    return BezierEdgeStatic;
  }(_BezierEdgeBase3.default);

  exports.default = BezierEdgeStatic;

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _EdgeBase2 = __webpack_require__(89);

  var _EdgeBase3 = _interopRequireDefault(_EdgeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var StraightEdge = function (_EdgeBase) {
    _inherits(StraightEdge, _EdgeBase);

    function StraightEdge(options, body, labelModule) {
      _classCallCheck(this, StraightEdge);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(StraightEdge).call(this, options, body, labelModule));
    }

    /**
     * Draw a line between two nodes
     * @param {CanvasRenderingContext2D} ctx
     * @private
     */


    _createClass(StraightEdge, [{
      key: '_line',
      value: function _line(ctx) {
        // draw a straight line
        ctx.beginPath();
        ctx.moveTo(this.fromPoint.x, this.fromPoint.y);
        ctx.lineTo(this.toPoint.x, this.toPoint.y);
        // draw shadow if enabled
        this.enableShadow(ctx);
        ctx.stroke();
        this.disableShadow(ctx);
      }
    }, {
      key: 'getViaNode',
      value: function getViaNode() {
        return undefined;
      }

      /**
       * Combined function of pointOnLine and pointOnBezier. This gives the coordinates of a point on the line at a certain percentage of the way
       * @param percentage
       * @param via
       * @returns {{x: number, y: number}}
       * @private
       */

    }, {
      key: 'getPoint',
      value: function getPoint(percentage) {
        return {
          x: (1 - percentage) * this.fromPoint.x + percentage * this.toPoint.x,
          y: (1 - percentage) * this.fromPoint.y + percentage * this.toPoint.y
        };
      }
    }, {
      key: '_findBorderPosition',
      value: function _findBorderPosition(nearNode, ctx) {
        var node1 = this.to;
        var node2 = this.from;
        if (nearNode.id === this.from.id) {
          node1 = this.from;
          node2 = this.to;
        }

        var angle = Math.atan2(node1.y - node2.y, node1.x - node2.x);
        var dx = node1.x - node2.x;
        var dy = node1.y - node2.y;
        var edgeSegmentLength = Math.sqrt(dx * dx + dy * dy);
        var toBorderDist = nearNode.distanceToBorder(ctx, angle);
        var toBorderPoint = (edgeSegmentLength - toBorderDist) / edgeSegmentLength;

        var borderPos = {};
        borderPos.x = (1 - toBorderPoint) * node2.x + toBorderPoint * node1.x;
        borderPos.y = (1 - toBorderPoint) * node2.y + toBorderPoint * node1.y;

        return borderPos;
      }
    }, {
      key: '_getDistanceToEdge',
      value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
        // x3,y3 is the point
        return this._getDistanceToLine(x1, y1, x2, y2, x3, y3);
      }
    }]);

    return StraightEdge;
  }(_EdgeBase3.default);

  exports.default = StraightEdge;

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _BarnesHutSolver = __webpack_require__(94);

  var _BarnesHutSolver2 = _interopRequireDefault(_BarnesHutSolver);

  var _RepulsionSolver = __webpack_require__(95);

  var _RepulsionSolver2 = _interopRequireDefault(_RepulsionSolver);

  var _HierarchicalRepulsionSolver = __webpack_require__(96);

  var _HierarchicalRepulsionSolver2 = _interopRequireDefault(_HierarchicalRepulsionSolver);

  var _SpringSolver = __webpack_require__(97);

  var _SpringSolver2 = _interopRequireDefault(_SpringSolver);

  var _HierarchicalSpringSolver = __webpack_require__(98);

  var _HierarchicalSpringSolver2 = _interopRequireDefault(_HierarchicalSpringSolver);

  var _CentralGravitySolver = __webpack_require__(99);

  var _CentralGravitySolver2 = _interopRequireDefault(_CentralGravitySolver);

  var _FA2BasedRepulsionSolver = __webpack_require__(100);

  var _FA2BasedRepulsionSolver2 = _interopRequireDefault(_FA2BasedRepulsionSolver);

  var _FA2BasedCentralGravitySolver = __webpack_require__(101);

  var _FA2BasedCentralGravitySolver2 = _interopRequireDefault(_FA2BasedCentralGravitySolver);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);

  var PhysicsEngine = function () {
    function PhysicsEngine(body) {
      _classCallCheck(this, PhysicsEngine);

      this.body = body;
      this.physicsBody = { physicsNodeIndices: [], physicsEdgeIndices: [], forces: {}, velocities: {} };

      this.physicsEnabled = true;
      this.simulationInterval = 1000 / 60;
      this.requiresTimeout = true;
      this.previousStates = {};
      this.referenceState = {};
      this.freezeCache = {};
      this.renderTimer = undefined;

      // parameters for the adaptive timestep
      this.adaptiveTimestep = false;
      this.adaptiveTimestepEnabled = false;
      this.adaptiveCounter = 0;
      this.adaptiveInterval = 3;

      this.stabilized = false;
      this.startedStabilization = false;
      this.stabilizationIterations = 0;
      this.ready = false; // will be set to true if the stabilize

      // default options
      this.options = {};
      this.defaultOptions = {
        enabled: true,
        barnesHut: {
          theta: 0.5,
          gravitationalConstant: -2000,
          centralGravity: 0.3,
          springLength: 95,
          springConstant: 0.04,
          damping: 0.09,
          avoidOverlap: 0
        },
        forceAtlas2Based: {
          theta: 0.5,
          gravitationalConstant: -50,
          centralGravity: 0.01,
          springConstant: 0.08,
          springLength: 100,
          damping: 0.4,
          avoidOverlap: 0
        },
        repulsion: {
          centralGravity: 0.2,
          springLength: 200,
          springConstant: 0.05,
          nodeDistance: 100,
          damping: 0.09,
          avoidOverlap: 0
        },
        hierarchicalRepulsion: {
          centralGravity: 0.0,
          springLength: 100,
          springConstant: 0.01,
          nodeDistance: 120,
          damping: 0.09
        },
        maxVelocity: 50,
        minVelocity: 0.75, // px/s
        solver: 'barnesHut',
        stabilization: {
          enabled: true,
          iterations: 1000, // maximum number of iteration to stabilize
          updateInterval: 50,
          onlyDynamicEdges: false,
          fit: true
        },
        timestep: 0.5,
        adaptiveTimestep: true
      };
      util.extend(this.options, this.defaultOptions);
      this.timestep = 0.5;
      this.layoutFailed = false;

      this.bindEventListeners();
    }

    _createClass(PhysicsEngine, [{
      key: 'bindEventListeners',
      value: function bindEventListeners() {
        var _this = this;

        this.body.emitter.on('initPhysics', function () {
          _this.initPhysics();
        });
        this.body.emitter.on('_layoutFailed', function () {
          _this.layoutFailed = true;
        });
        this.body.emitter.on('resetPhysics', function () {
          _this.stopSimulation();_this.ready = false;
        });
        this.body.emitter.on('disablePhysics', function () {
          _this.physicsEnabled = false;_this.stopSimulation();
        });
        this.body.emitter.on('restorePhysics', function () {
          _this.setOptions(_this.options);
          if (_this.ready === true) {
            _this.startSimulation();
          }
        });
        this.body.emitter.on('startSimulation', function () {
          if (_this.ready === true) {
            _this.startSimulation();
          }
        });
        this.body.emitter.on('stopSimulation', function () {
          _this.stopSimulation();
        });
        this.body.emitter.on('destroy', function () {
          _this.stopSimulation(false);
          _this.body.emitter.off();
        });
        // this event will trigger a rebuilding of the cache everything. Used when nodes or edges have been added or removed.
        this.body.emitter.on("_dataChanged", function () {
          // update shortcut lists
          _this.updatePhysicsData();
        });

        // debug: show forces
        // this.body.emitter.on("afterDrawing", (ctx) => {this._drawForces(ctx);});
      }

      /**
       * set the physics options
       * @param options
       */

    }, {
      key: 'setOptions',
      value: function setOptions(options) {
        if (options !== undefined) {
          if (options === false) {
            this.options.enabled = false;
            this.physicsEnabled = false;
            this.stopSimulation();
          } else {
            this.physicsEnabled = true;
            util.selectiveNotDeepExtend(['stabilization'], this.options, options);
            util.mergeOptions(this.options, options, 'stabilization');

            if (options.enabled === undefined) {
              this.options.enabled = true;
            }

            if (this.options.enabled === false) {
              this.physicsEnabled = false;
              this.stopSimulation();
            }

            // set the timestep
            this.timestep = this.options.timestep;
          }
        }
        this.init();
      }

      /**
       * configure the engine.
       */

    }, {
      key: 'init',
      value: function init() {
        var options;
        if (this.options.solver === 'forceAtlas2Based') {
          options = this.options.forceAtlas2Based;
          this.nodesSolver = new _FA2BasedRepulsionSolver2.default(this.body, this.physicsBody, options);
          this.edgesSolver = new _SpringSolver2.default(this.body, this.physicsBody, options);
          this.gravitySolver = new _FA2BasedCentralGravitySolver2.default(this.body, this.physicsBody, options);
        } else if (this.options.solver === 'repulsion') {
          options = this.options.repulsion;
          this.nodesSolver = new _RepulsionSolver2.default(this.body, this.physicsBody, options);
          this.edgesSolver = new _SpringSolver2.default(this.body, this.physicsBody, options);
          this.gravitySolver = new _CentralGravitySolver2.default(this.body, this.physicsBody, options);
        } else if (this.options.solver === 'hierarchicalRepulsion') {
          options = this.options.hierarchicalRepulsion;
          this.nodesSolver = new _HierarchicalRepulsionSolver2.default(this.body, this.physicsBody, options);
          this.edgesSolver = new _HierarchicalSpringSolver2.default(this.body, this.physicsBody, options);
          this.gravitySolver = new _CentralGravitySolver2.default(this.body, this.physicsBody, options);
        } else {
          // barnesHut
          options = this.options.barnesHut;
          this.nodesSolver = new _BarnesHutSolver2.default(this.body, this.physicsBody, options);
          this.edgesSolver = new _SpringSolver2.default(this.body, this.physicsBody, options);
          this.gravitySolver = new _CentralGravitySolver2.default(this.body, this.physicsBody, options);
        }

        this.modelOptions = options;
      }

      /**
       * initialize the engine
       */

    }, {
      key: 'initPhysics',
      value: function initPhysics() {
        if (this.physicsEnabled === true && this.options.enabled === true) {
          if (this.options.stabilization.enabled === true) {
            this.stabilize();
          } else {
            this.stabilized = false;
            this.ready = true;
            this.body.emitter.emit('fit', {}, this.layoutFailed); // if the layout failed, we use the approximation for the zoom
            this.startSimulation();
          }
        } else {
          this.ready = true;
          this.body.emitter.emit('fit');
        }
      }

      /**
       * Start the simulation
       */

    }, {
      key: 'startSimulation',
      value: function startSimulation() {
        if (this.physicsEnabled === true && this.options.enabled === true) {
          this.stabilized = false;

          // when visible, adaptivity is disabled.
          this.adaptiveTimestep = false;

          // this sets the width of all nodes initially which could be required for the avoidOverlap
          this.body.emitter.emit("_resizeNodes");
          if (this.viewFunction === undefined) {
            this.viewFunction = this.simulationStep.bind(this);
            this.body.emitter.on('initRedraw', this.viewFunction);
            this.body.emitter.emit('_startRendering');
          }
        } else {
          this.body.emitter.emit('_redraw');
        }
      }

      /**
       * Stop the simulation, force stabilization.
       */

    }, {
      key: 'stopSimulation',
      value: function stopSimulation() {
        var emit = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

        this.stabilized = true;
        if (emit === true) {
          this._emitStabilized();
        }
        if (this.viewFunction !== undefined) {
          this.body.emitter.off('initRedraw', this.viewFunction);
          this.viewFunction = undefined;
          if (emit === true) {
            this.body.emitter.emit('_stopRendering');
          }
        }
      }

      /**
       * The viewFunction inserts this step into each render loop. It calls the physics tick and handles the cleanup at stabilized.
       *
       */

    }, {
      key: 'simulationStep',
      value: function simulationStep() {
        // check if the physics have settled
        var startTime = Date.now();
        this.physicsTick();
        var physicsTime = Date.now() - startTime;

        // run double speed if it is a little graph
        if ((physicsTime < 0.4 * this.simulationInterval || this.runDoubleSpeed === true) && this.stabilized === false) {
          this.physicsTick();

          // this makes sure there is no jitter. The decision is taken once to run it at double speed.
          this.runDoubleSpeed = true;
        }

        if (this.stabilized === true) {
          this.stopSimulation();
        }
      }

      /**
       * trigger the stabilized event.
       * @private
       */

    }, {
      key: '_emitStabilized',
      value: function _emitStabilized() {
        var _this2 = this;

        var amountOfIterations = arguments.length <= 0 || arguments[0] === undefined ? this.stabilizationIterations : arguments[0];

        if (this.stabilizationIterations > 1 || this.startedStabilization === true) {
          setTimeout(function () {
            _this2.body.emitter.emit('stabilized', { iterations: amountOfIterations });
            _this2.startedStabilization = false;
            _this2.stabilizationIterations = 0;
          }, 0);
        }
      }

      /**
       * A single simulation step (or 'tick') in the physics simulation
       *
       * @private
       */

    }, {
      key: 'physicsTick',
      value: function physicsTick() {
        // this is here to ensure that there is no start event when the network is already stable.
        if (this.startedStabilization === false) {
          this.body.emitter.emit('startStabilizing');
          this.startedStabilization = true;
        }

        if (this.stabilized === false) {
          // adaptivity means the timestep adapts to the situation, only applicable for stabilization
          if (this.adaptiveTimestep === true && this.adaptiveTimestepEnabled === true) {
            // this is the factor for increasing the timestep on success.
            var factor = 1.2;

            // we assume the adaptive interval is
            if (this.adaptiveCounter % this.adaptiveInterval === 0) {
              // we leave the timestep stable for "interval" iterations.
              // first the big step and revert. Revert saves the reference state.
              this.timestep = 2 * this.timestep;
              this.calculateForces();
              this.moveNodes();
              this.revert();

              // now the normal step. Since this is the last step, it is the more stable one and we will take this.
              this.timestep = 0.5 * this.timestep;

              // since it's half the step, we do it twice.
              this.calculateForces();
              this.moveNodes();
              this.calculateForces();
              this.moveNodes();

              // we compare the two steps. if it is acceptable we double the step.
              if (this._evaluateStepQuality() === true) {
                this.timestep = factor * this.timestep;
              } else {
                // if not, we decrease the step to a minimum of the options timestep.
                // if the decreased timestep is smaller than the options step, we do not reset the counter
                // we assume that the options timestep is stable enough.
                if (this.timestep / factor < this.options.timestep) {
                  this.timestep = this.options.timestep;
                } else {
                  // if the timestep was larger than 2 times the option one we check the adaptivity again to ensure
                  // that large instabilities do not form.
                  this.adaptiveCounter = -1; // check again next iteration
                  this.timestep = Math.max(this.options.timestep, this.timestep / factor);
                }
              }
            } else {
              // normal step, keeping timestep constant
              this.calculateForces();
              this.moveNodes();
            }

            // increment the counter
            this.adaptiveCounter += 1;
          } else {
            // case for the static timestep, we reset it to the one in options and take a normal step.
            this.timestep = this.options.timestep;
            this.calculateForces();
            this.moveNodes();
          }

          // determine if the network has stabilzied
          if (this.stabilized === true) {
            this.revert();
          }

          this.stabilizationIterations++;
        }
      }

      /**
       * Nodes and edges can have the physics toggles on or off. A collection of indices is created here so we can skip the check all the time.
       *
       * @private
       */

    }, {
      key: 'updatePhysicsData',
      value: function updatePhysicsData() {
        this.physicsBody.forces = {};
        this.physicsBody.physicsNodeIndices = [];
        this.physicsBody.physicsEdgeIndices = [];
        var nodes = this.body.nodes;
        var edges = this.body.edges;

        // get node indices for physics
        for (var nodeId in nodes) {
          if (nodes.hasOwnProperty(nodeId)) {
            if (nodes[nodeId].options.physics === true) {
              this.physicsBody.physicsNodeIndices.push(nodes[nodeId].id);
            }
          }
        }

        // get edge indices for physics
        for (var edgeId in edges) {
          if (edges.hasOwnProperty(edgeId)) {
            if (edges[edgeId].options.physics === true) {
              this.physicsBody.physicsEdgeIndices.push(edges[edgeId].id);
            }
          }
        }

        // get the velocity and the forces vector
        for (var i = 0; i < this.physicsBody.physicsNodeIndices.length; i++) {
          var _nodeId = this.physicsBody.physicsNodeIndices[i];
          this.physicsBody.forces[_nodeId] = { x: 0, y: 0 };

          // forces can be reset because they are recalculated. Velocities have to persist.
          if (this.physicsBody.velocities[_nodeId] === undefined) {
            this.physicsBody.velocities[_nodeId] = { x: 0, y: 0 };
          }
        }

        // clean deleted nodes from the velocity vector
        for (var _nodeId2 in this.physicsBody.velocities) {
          if (nodes[_nodeId2] === undefined) {
            delete this.physicsBody.velocities[_nodeId2];
          }
        }
      }

      /**
       * Revert the simulation one step. This is done so after stabilization, every new start of the simulation will also say stabilized.
       */

    }, {
      key: 'revert',
      value: function revert() {
        var nodeIds = Object.keys(this.previousStates);
        var nodes = this.body.nodes;
        var velocities = this.physicsBody.velocities;
        this.referenceState = {};

        for (var i = 0; i < nodeIds.length; i++) {
          var nodeId = nodeIds[i];
          if (nodes[nodeId] !== undefined) {
            if (nodes[nodeId].options.physics === true) {
              this.referenceState[nodeId] = {
                positions: { x: nodes[nodeId].x, y: nodes[nodeId].y }
              };
              velocities[nodeId].x = this.previousStates[nodeId].vx;
              velocities[nodeId].y = this.previousStates[nodeId].vy;
              nodes[nodeId].x = this.previousStates[nodeId].x;
              nodes[nodeId].y = this.previousStates[nodeId].y;
            }
          } else {
            delete this.previousStates[nodeId];
          }
        }
      }

      /**
       * This compares the reference state to the current state
       */

    }, {
      key: '_evaluateStepQuality',
      value: function _evaluateStepQuality() {
        var dx = void 0,
            dy = void 0,
            dpos = void 0;
        var nodes = this.body.nodes;
        var reference = this.referenceState;
        var posThreshold = 0.3;

        for (var nodeId in this.referenceState) {
          if (this.referenceState.hasOwnProperty(nodeId) && nodes[nodeId] !== undefined) {
            dx = nodes[nodeId].x - reference[nodeId].positions.x;
            dy = nodes[nodeId].y - reference[nodeId].positions.y;

            dpos = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));

            if (dpos > posThreshold) {
              return false;
            }
          }
        }
        return true;
      }

      /**
       * move the nodes one timestep and check if they are stabilized
       * @returns {boolean}
       */

    }, {
      key: 'moveNodes',
      value: function moveNodes() {
        var nodeIndices = this.physicsBody.physicsNodeIndices;
        var maxVelocity = this.options.maxVelocity ? this.options.maxVelocity : 1e9;
        var maxNodeVelocity = 0;
        var averageNodeVelocity = 0;

        // the velocity threshold (energy in the system) for the adaptivity toggle
        var velocityAdaptiveThreshold = 5;

        for (var i = 0; i < nodeIndices.length; i++) {
          var nodeId = nodeIndices[i];
          var nodeVelocity = this._performStep(nodeId, maxVelocity);
          // stabilized is true if stabilized is true and velocity is smaller than vmin --> all nodes must be stabilized
          maxNodeVelocity = Math.max(maxNodeVelocity, nodeVelocity);
          averageNodeVelocity += nodeVelocity;
        }

        // evaluating the stabilized and adaptiveTimestepEnabled conditions
        this.adaptiveTimestepEnabled = averageNodeVelocity / nodeIndices.length < velocityAdaptiveThreshold;
        this.stabilized = maxNodeVelocity < this.options.minVelocity;
      }

      /**
       * Perform the actual step
       *
       * @param nodeId
       * @param maxVelocity
       * @returns {number}
       * @private
       */

    }, {
      key: '_performStep',
      value: function _performStep(nodeId, maxVelocity) {
        var node = this.body.nodes[nodeId];
        var timestep = this.timestep;
        var forces = this.physicsBody.forces;
        var velocities = this.physicsBody.velocities;

        // store the state so we can revert
        this.previousStates[nodeId] = { x: node.x, y: node.y, vx: velocities[nodeId].x, vy: velocities[nodeId].y };

        if (node.options.fixed.x === false) {
          var dx = this.modelOptions.damping * velocities[nodeId].x; // damping force
          var ax = (forces[nodeId].x - dx) / node.options.mass; // acceleration
          velocities[nodeId].x += ax * timestep; // velocity
          velocities[nodeId].x = Math.abs(velocities[nodeId].x) > maxVelocity ? velocities[nodeId].x > 0 ? maxVelocity : -maxVelocity : velocities[nodeId].x;
          node.x += velocities[nodeId].x * timestep; // position
        } else {
            forces[nodeId].x = 0;
            velocities[nodeId].x = 0;
          }

        if (node.options.fixed.y === false) {
          var dy = this.modelOptions.damping * velocities[nodeId].y; // damping force
          var ay = (forces[nodeId].y - dy) / node.options.mass; // acceleration
          velocities[nodeId].y += ay * timestep; // velocity
          velocities[nodeId].y = Math.abs(velocities[nodeId].y) > maxVelocity ? velocities[nodeId].y > 0 ? maxVelocity : -maxVelocity : velocities[nodeId].y;
          node.y += velocities[nodeId].y * timestep; // position
        } else {
            forces[nodeId].y = 0;
            velocities[nodeId].y = 0;
          }

        var totalVelocity = Math.sqrt(Math.pow(velocities[nodeId].x, 2) + Math.pow(velocities[nodeId].y, 2));
        return totalVelocity;
      }

      /**
       * calculate the forces for one physics iteration.
       */

    }, {
      key: 'calculateForces',
      value: function calculateForces() {
        this.gravitySolver.solve();
        this.nodesSolver.solve();
        this.edgesSolver.solve();
      }

      /**
       * When initializing and stabilizing, we can freeze nodes with a predefined position. This greatly speeds up stabilization
       * because only the supportnodes for the smoothCurves have to settle.
       *
       * @private
       */

    }, {
      key: '_freezeNodes',
      value: function _freezeNodes() {
        var nodes = this.body.nodes;
        for (var id in nodes) {
          if (nodes.hasOwnProperty(id)) {
            if (nodes[id].x && nodes[id].y) {
              this.freezeCache[id] = { x: nodes[id].options.fixed.x, y: nodes[id].options.fixed.y };
              nodes[id].options.fixed.x = true;
              nodes[id].options.fixed.y = true;
            }
          }
        }
      }

      /**
       * Unfreezes the nodes that have been frozen by _freezeDefinedNodes.
       *
       * @private
       */

    }, {
      key: '_restoreFrozenNodes',
      value: function _restoreFrozenNodes() {
        var nodes = this.body.nodes;
        for (var id in nodes) {
          if (nodes.hasOwnProperty(id)) {
            if (this.freezeCache[id] !== undefined) {
              nodes[id].options.fixed.x = this.freezeCache[id].x;
              nodes[id].options.fixed.y = this.freezeCache[id].y;
            }
          }
        }
        this.freezeCache = {};
      }

      /**
       * Find a stable position for all nodes
       */

    }, {
      key: 'stabilize',
      value: function stabilize() {
        var _this3 = this;

        var iterations = arguments.length <= 0 || arguments[0] === undefined ? this.options.stabilization.iterations : arguments[0];

        if (typeof iterations !== 'number') {
          console.log('The stabilize method needs a numeric amount of iterations. Switching to default: ', this.options.stabilization.iterations);
          iterations = this.options.stabilization.iterations;
        }

        if (this.physicsBody.physicsNodeIndices.length === 0) {
          this.ready = true;
          return;
        }

        // enable adaptive timesteps
        this.adaptiveTimestep = true && this.options.adaptiveTimestep;

        // this sets the width of all nodes initially which could be required for the avoidOverlap
        this.body.emitter.emit("_resizeNodes");

        // stop the render loop
        this.stopSimulation();

        // set stabilze to false
        this.stabilized = false;

        // block redraw requests
        this.body.emitter.emit('_blockRedraw');
        this.targetIterations = iterations;

        // start the stabilization
        if (this.options.stabilization.onlyDynamicEdges === true) {
          this._freezeNodes();
        }
        this.stabilizationIterations = 0;

        setTimeout(function () {
          return _this3._stabilizationBatch();
        }, 0);
      }

      /**
       * One batch of stabilization
       * @private
       */

    }, {
      key: '_stabilizationBatch',
      value: function _stabilizationBatch() {
        // this is here to ensure that there is at least one start event.
        if (this.startedStabilization === false) {
          this.body.emitter.emit('startStabilizing');
          this.startedStabilization = true;
        }

        var count = 0;
        while (this.stabilized === false && count < this.options.stabilization.updateInterval && this.stabilizationIterations < this.targetIterations) {
          this.physicsTick();
          count++;
        }

        if (this.stabilized === false && this.stabilizationIterations < this.targetIterations) {
          this.body.emitter.emit('stabilizationProgress', { iterations: this.stabilizationIterations, total: this.targetIterations });
          setTimeout(this._stabilizationBatch.bind(this), 0);
        } else {
          this._finalizeStabilization();
        }
      }

      /**
       * Wrap up the stabilization, fit and emit the events.
       * @private
       */

    }, {
      key: '_finalizeStabilization',
      value: function _finalizeStabilization() {
        this.body.emitter.emit('_allowRedraw');
        if (this.options.stabilization.fit === true) {
          this.body.emitter.emit('fit');
        }

        if (this.options.stabilization.onlyDynamicEdges === true) {
          this._restoreFrozenNodes();
        }

        this.body.emitter.emit('stabilizationIterationsDone');
        this.body.emitter.emit('_requestRedraw');

        if (this.stabilized === true) {
          this._emitStabilized();
        } else {
          this.startSimulation();
        }

        this.ready = true;
      }
    }, {
      key: '_drawForces',
      value: function _drawForces(ctx) {
        for (var i = 0; i < this.physicsBody.physicsNodeIndices.length; i++) {
          var node = this.body.nodes[this.physicsBody.physicsNodeIndices[i]];
          var force = this.physicsBody.forces[this.physicsBody.physicsNodeIndices[i]];
          var factor = 20;
          var colorFactor = 0.03;
          var forceSize = Math.sqrt(Math.pow(force.x, 2) + Math.pow(force.x, 2));

          var size = Math.min(Math.max(5, forceSize), 15);
          var arrowSize = 3 * size;

          var color = util.HSVToHex((180 - Math.min(1, Math.max(0, colorFactor * forceSize)) * 180) / 360, 1, 1);

          ctx.lineWidth = size;
          ctx.strokeStyle = color;
          ctx.beginPath();
          ctx.moveTo(node.x, node.y);
          ctx.lineTo(node.x + factor * force.x, node.y + factor * force.y);
          ctx.stroke();

          var angle = Math.atan2(force.y, force.x);
          ctx.fillStyle = color;
          ctx.arrow(node.x + factor * force.x + Math.cos(angle) * arrowSize, node.y + factor * force.y + Math.sin(angle) * arrowSize, angle, arrowSize);
          ctx.fill();
        }
      }
    }]);

    return PhysicsEngine;
  }();

  exports.default = PhysicsEngine;

/***/ },
/* 94 */
/***/ function(module, exports) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var BarnesHutSolver = function () {
    function BarnesHutSolver(body, physicsBody, options) {
      _classCallCheck(this, BarnesHutSolver);

      this.body = body;
      this.physicsBody = physicsBody;
      this.barnesHutTree;
      this.setOptions(options);
      this.randomSeed = 5;

      // debug: show grid
      //this.body.emitter.on("afterDrawing", (ctx) => {this._debug(ctx,'#ff0000')})
    }

    _createClass(BarnesHutSolver, [{
      key: "setOptions",
      value: function setOptions(options) {
        this.options = options;
        this.thetaInversed = 1 / this.options.theta;
        this.overlapAvoidanceFactor = 1 - Math.max(0, Math.min(1, this.options.avoidOverlap)); // if 1 then min distance = 0.5, if 0.5 then min distance = 0.5 + 0.5*node.shape.radius
      }
    }, {
      key: "seededRandom",
      value: function seededRandom() {
        var x = Math.sin(this.randomSeed++) * 10000;
        return x - Math.floor(x);
      }

      /**
       * This function calculates the forces the nodes apply on each other based on a gravitational model.
       * The Barnes Hut method is used to speed up this N-body simulation.
       *
       * @private
       */

    }, {
      key: "solve",
      value: function solve() {
        if (this.options.gravitationalConstant !== 0 && this.physicsBody.physicsNodeIndices.length > 0) {
          var node = void 0;
          var nodes = this.body.nodes;
          var nodeIndices = this.physicsBody.physicsNodeIndices;
          var nodeCount = nodeIndices.length;

          // create the tree
          var barnesHutTree = this._formBarnesHutTree(nodes, nodeIndices);

          // for debugging
          this.barnesHutTree = barnesHutTree;

          // place the nodes one by one recursively
          for (var i = 0; i < nodeCount; i++) {
            node = nodes[nodeIndices[i]];
            if (node.options.mass > 0) {
              // starting with root is irrelevant, it never passes the BarnesHutSolver condition
              this._getForceContribution(barnesHutTree.root.children.NW, node);
              this._getForceContribution(barnesHutTree.root.children.NE, node);
              this._getForceContribution(barnesHutTree.root.children.SW, node);
              this._getForceContribution(barnesHutTree.root.children.SE, node);
            }
          }
        }
      }

      /**
       * This function traverses the barnesHutTree. It checks when it can approximate distant nodes with their center of mass.
       * If a region contains a single node, we check if it is not itself, then we apply the force.
       *
       * @param parentBranch
       * @param node
       * @private
       */

    }, {
      key: "_getForceContribution",
      value: function _getForceContribution(parentBranch, node) {
        // we get no force contribution from an empty region
        if (parentBranch.childrenCount > 0) {
          var dx = void 0,
              dy = void 0,
              distance = void 0;

          // get the distance from the center of mass to the node.
          dx = parentBranch.centerOfMass.x - node.x;
          dy = parentBranch.centerOfMass.y - node.y;
          distance = Math.sqrt(dx * dx + dy * dy);

          // BarnesHutSolver condition
          // original condition : s/d < theta = passed  ===  d/s > 1/theta = passed
          // calcSize = 1/s --> d * 1/s > 1/theta = passed
          if (distance * parentBranch.calcSize > this.thetaInversed) {
            this._calculateForces(distance, dx, dy, node, parentBranch);
          } else {
            // Did not pass the condition, go into children if available
            if (parentBranch.childrenCount === 4) {
              this._getForceContribution(parentBranch.children.NW, node);
              this._getForceContribution(parentBranch.children.NE, node);
              this._getForceContribution(parentBranch.children.SW, node);
              this._getForceContribution(parentBranch.children.SE, node);
            } else {
              // parentBranch must have only one node, if it was empty we wouldnt be here
              if (parentBranch.children.data.id != node.id) {
                // if it is not self
                this._calculateForces(distance, dx, dy, node, parentBranch);
              }
            }
          }
        }
      }

      /**
       * Calculate the forces based on the distance.
       *
       * @param distance
       * @param dx
       * @param dy
       * @param node
       * @param parentBranch
       * @private
       */

    }, {
      key: "_calculateForces",
      value: function _calculateForces(distance, dx, dy, node, parentBranch) {
        if (distance === 0) {
          distance = 0.1;
          dx = distance;
        }

        if (this.overlapAvoidanceFactor < 1) {
          distance = Math.max(0.1 + this.overlapAvoidanceFactor * node.shape.radius, distance - node.shape.radius);
        }

        // the dividing by the distance cubed instead of squared allows us to get the fx and fy components without sines and cosines
        // it is shorthand for gravityforce with distance squared and fx = dx/distance * gravityForce
        var gravityForce = this.options.gravitationalConstant * parentBranch.mass * node.options.mass / Math.pow(distance, 3);
        var fx = dx * gravityForce;
        var fy = dy * gravityForce;

        this.physicsBody.forces[node.id].x += fx;
        this.physicsBody.forces[node.id].y += fy;
      }

      /**
       * This function constructs the barnesHut tree recursively. It creates the root, splits it and starts placing the nodes.
       *
       * @param nodes
       * @param nodeIndices
       * @private
       */

    }, {
      key: "_formBarnesHutTree",
      value: function _formBarnesHutTree(nodes, nodeIndices) {
        var node = void 0;
        var nodeCount = nodeIndices.length;

        var minX = nodes[nodeIndices[0]].x;
        var minY = nodes[nodeIndices[0]].y;
        var maxX = nodes[nodeIndices[0]].x;
        var maxY = nodes[nodeIndices[0]].y;

        // get the range of the nodes
        for (var i = 1; i < nodeCount; i++) {
          var x = nodes[nodeIndices[i]].x;
          var y = nodes[nodeIndices[i]].y;
          if (nodes[nodeIndices[i]].options.mass > 0) {
            if (x < minX) {
              minX = x;
            }
            if (x > maxX) {
              maxX = x;
            }
            if (y < minY) {
              minY = y;
            }
            if (y > maxY) {
              maxY = y;
            }
          }
        }
        // make the range a square
        var sizeDiff = Math.abs(maxX - minX) - Math.abs(maxY - minY); // difference between X and Y
        if (sizeDiff > 0) {
          minY -= 0.5 * sizeDiff;
          maxY += 0.5 * sizeDiff;
        } // xSize > ySize
        else {
            minX += 0.5 * sizeDiff;
            maxX -= 0.5 * sizeDiff;
          } // xSize < ySize

        var minimumTreeSize = 1e-5;
        var rootSize = Math.max(minimumTreeSize, Math.abs(maxX - minX));
        var halfRootSize = 0.5 * rootSize;
        var centerX = 0.5 * (minX + maxX),
            centerY = 0.5 * (minY + maxY);

        // construct the barnesHutTree
        var barnesHutTree = {
          root: {
            centerOfMass: { x: 0, y: 0 },
            mass: 0,
            range: {
              minX: centerX - halfRootSize, maxX: centerX + halfRootSize,
              minY: centerY - halfRootSize, maxY: centerY + halfRootSize
            },
            size: rootSize,
            calcSize: 1 / rootSize,
            children: { data: null },
            maxWidth: 0,
            level: 0,
            childrenCount: 4
          }
        };
        this._splitBranch(barnesHutTree.root);

        // place the nodes one by one recursively
        for (var _i = 0; _i < nodeCount; _i++) {
          node = nodes[nodeIndices[_i]];
          if (node.options.mass > 0) {
            this._placeInTree(barnesHutTree.root, node);
          }
        }

        // make global
        return barnesHutTree;
      }

      /**
       * this updates the mass of a branch. this is increased by adding a node.
       *
       * @param parentBranch
       * @param node
       * @private
       */

    }, {
      key: "_updateBranchMass",
      value: function _updateBranchMass(parentBranch, node) {
        var totalMass = parentBranch.mass + node.options.mass;
        var totalMassInv = 1 / totalMass;

        parentBranch.centerOfMass.x = parentBranch.centerOfMass.x * parentBranch.mass + node.x * node.options.mass;
        parentBranch.centerOfMass.x *= totalMassInv;

        parentBranch.centerOfMass.y = parentBranch.centerOfMass.y * parentBranch.mass + node.y * node.options.mass;
        parentBranch.centerOfMass.y *= totalMassInv;

        parentBranch.mass = totalMass;
        var biggestSize = Math.max(Math.max(node.height, node.radius), node.width);
        parentBranch.maxWidth = parentBranch.maxWidth < biggestSize ? biggestSize : parentBranch.maxWidth;
      }

      /**
       * determine in which branch the node will be placed.
       *
       * @param parentBranch
       * @param node
       * @param skipMassUpdate
       * @private
       */

    }, {
      key: "_placeInTree",
      value: function _placeInTree(parentBranch, node, skipMassUpdate) {
        if (skipMassUpdate != true || skipMassUpdate === undefined) {
          // update the mass of the branch.
          this._updateBranchMass(parentBranch, node);
        }

        if (parentBranch.children.NW.range.maxX > node.x) {
          // in NW or SW
          if (parentBranch.children.NW.range.maxY > node.y) {
            // in NW
            this._placeInRegion(parentBranch, node, "NW");
          } else {
            // in SW
            this._placeInRegion(parentBranch, node, "SW");
          }
        } else {
          // in NE or SE
          if (parentBranch.children.NW.range.maxY > node.y) {
            // in NE
            this._placeInRegion(parentBranch, node, "NE");
          } else {
            // in SE
            this._placeInRegion(parentBranch, node, "SE");
          }
        }
      }

      /**
       * actually place the node in a region (or branch)
       *
       * @param parentBranch
       * @param node
       * @param region
       * @private
       */

    }, {
      key: "_placeInRegion",
      value: function _placeInRegion(parentBranch, node, region) {
        switch (parentBranch.children[region].childrenCount) {
          case 0:
            // place node here
            parentBranch.children[region].children.data = node;
            parentBranch.children[region].childrenCount = 1;
            this._updateBranchMass(parentBranch.children[region], node);
            break;
          case 1:
            // convert into children
            // if there are two nodes exactly overlapping (on init, on opening of cluster etc.)
            // we move one node a little bit and we do not put it in the tree.
            if (parentBranch.children[region].children.data.x === node.x && parentBranch.children[region].children.data.y === node.y) {
              node.x += this.seededRandom();
              node.y += this.seededRandom();
            } else {
              this._splitBranch(parentBranch.children[region]);
              this._placeInTree(parentBranch.children[region], node);
            }
            break;
          case 4:
            // place in branch
            this._placeInTree(parentBranch.children[region], node);
            break;
        }
      }

      /**
       * this function splits a branch into 4 sub branches. If the branch contained a node, we place it in the subbranch
       * after the split is complete.
       *
       * @param parentBranch
       * @private
       */

    }, {
      key: "_splitBranch",
      value: function _splitBranch(parentBranch) {
        // if the branch is shaded with a node, replace the node in the new subset.
        var containedNode = null;
        if (parentBranch.childrenCount === 1) {
          containedNode = parentBranch.children.data;
          parentBranch.mass = 0;
          parentBranch.centerOfMass.x = 0;
          parentBranch.centerOfMass.y = 0;
        }
        parentBranch.childrenCount = 4;
        parentBranch.children.data = null;
        this._insertRegion(parentBranch, "NW");
        this._insertRegion(parentBranch, "NE");
        this._insertRegion(parentBranch, "SW");
        this._insertRegion(parentBranch, "SE");

        if (containedNode != null) {
          this._placeInTree(parentBranch, containedNode);
        }
      }

      /**
       * This function subdivides the region into four new segments.
       * Specifically, this inserts a single new segment.
       * It fills the children section of the parentBranch
       *
       * @param parentBranch
       * @param region
       * @param parentRange
       * @private
       */

    }, {
      key: "_insertRegion",
      value: function _insertRegion(parentBranch, region) {
        var minX = void 0,
            maxX = void 0,
            minY = void 0,
            maxY = void 0;
        var childSize = 0.5 * parentBranch.size;
        switch (region) {
          case "NW":
            minX = parentBranch.range.minX;
            maxX = parentBranch.range.minX + childSize;
            minY = parentBranch.range.minY;
            maxY = parentBranch.range.minY + childSize;
            break;
          case "NE":
            minX = parentBranch.range.minX + childSize;
            maxX = parentBranch.range.maxX;
            minY = parentBranch.range.minY;
            maxY = parentBranch.range.minY + childSize;
            break;
          case "SW":
            minX = parentBranch.range.minX;
            maxX = parentBranch.range.minX + childSize;
            minY = parentBranch.range.minY + childSize;
            maxY = parentBranch.range.maxY;
            break;
          case "SE":
            minX = parentBranch.range.minX + childSize;
            maxX = parentBranch.range.maxX;
            minY = parentBranch.range.minY + childSize;
            maxY = parentBranch.range.maxY;
            break;
        }

        parentBranch.children[region] = {
          centerOfMass: { x: 0, y: 0 },
          mass: 0,
          range: { minX: minX, maxX: maxX, minY: minY, maxY: maxY },
          size: 0.5 * parentBranch.size,
          calcSize: 2 * parentBranch.calcSize,
          children: { data: null },
          maxWidth: 0,
          level: parentBranch.level + 1,
          childrenCount: 0
        };
      }

      //---------------------------  DEBUGGING BELOW  ---------------------------//

      /**
       * This function is for debugging purposed, it draws the tree.
       *
       * @param ctx
       * @param color
       * @private
       */

    }, {
      key: "_debug",
      value: function _debug(ctx, color) {
        if (this.barnesHutTree !== undefined) {

          ctx.lineWidth = 1;

          this._drawBranch(this.barnesHutTree.root, ctx, color);
        }
      }

      /**
       * This function is for debugging purposes. It draws the branches recursively.
       *
       * @param branch
       * @param ctx
       * @param color
       * @private
       */

    }, {
      key: "_drawBranch",
      value: function _drawBranch(branch, ctx, color) {
        if (color === undefined) {
          color = "#FF0000";
        }

        if (branch.childrenCount === 4) {
          this._drawBranch(branch.children.NW, ctx);
          this._drawBranch(branch.children.NE, ctx);
          this._drawBranch(branch.children.SE, ctx);
          this._drawBranch(branch.children.SW, ctx);
        }
        ctx.strokeStyle = color;
        ctx.beginPath();
        ctx.moveTo(branch.range.minX, branch.range.minY);
        ctx.lineTo(branch.range.maxX, branch.range.minY);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(branch.range.maxX, branch.range.minY);
        ctx.lineTo(branch.range.maxX, branch.range.maxY);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(branch.range.maxX, branch.range.maxY);
        ctx.lineTo(branch.range.minX, branch.range.maxY);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(branch.range.minX, branch.range.maxY);
        ctx.lineTo(branch.range.minX, branch.range.minY);
        ctx.stroke();

        /*
         if (branch.mass > 0) {
         ctx.circle(branch.centerOfMass.x, branch.centerOfMass.y, 3*branch.mass);
         ctx.stroke();
         }
         */
      }
    }]);

    return BarnesHutSolver;
  }();

  exports.default = BarnesHutSolver;

/***/ },
/* 95 */
/***/ function(module, exports) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var RepulsionSolver = function () {
    function RepulsionSolver(body, physicsBody, options) {
      _classCallCheck(this, RepulsionSolver);

      this.body = body;
      this.physicsBody = physicsBody;
      this.setOptions(options);
    }

    _createClass(RepulsionSolver, [{
      key: "setOptions",
      value: function setOptions(options) {
        this.options = options;
      }
      /**
       * Calculate the forces the nodes apply on each other based on a repulsion field.
       * This field is linearly approximated.
       *
       * @private
       */

    }, {
      key: "solve",
      value: function solve() {
        var dx, dy, distance, fx, fy, repulsingForce, node1, node2;

        var nodes = this.body.nodes;
        var nodeIndices = this.physicsBody.physicsNodeIndices;
        var forces = this.physicsBody.forces;

        // repulsing forces between nodes
        var nodeDistance = this.options.nodeDistance;

        // approximation constants
        var a = -2 / 3 / nodeDistance;
        var b = 4 / 3;

        // we loop from i over all but the last entree in the array
        // j loops from i+1 to the last. This way we do not double count any of the indices, nor i === j
        for (var i = 0; i < nodeIndices.length - 1; i++) {
          node1 = nodes[nodeIndices[i]];
          for (var j = i + 1; j < nodeIndices.length; j++) {
            node2 = nodes[nodeIndices[j]];

            dx = node2.x - node1.x;
            dy = node2.y - node1.y;
            distance = Math.sqrt(dx * dx + dy * dy);

            // same condition as BarnesHutSolver, making sure nodes are never 100% overlapping.
            if (distance === 0) {
              distance = 0.1 * Math.random();
              dx = distance;
            }

            if (distance < 2 * nodeDistance) {
              if (distance < 0.5 * nodeDistance) {
                repulsingForce = 1.0;
              } else {
                repulsingForce = a * distance + b; // linear approx of  1 / (1 + Math.exp((distance / nodeDistance - 1) * steepness))
              }
              repulsingForce = repulsingForce / distance;

              fx = dx * repulsingForce;
              fy = dy * repulsingForce;

              forces[node1.id].x -= fx;
              forces[node1.id].y -= fy;
              forces[node2.id].x += fx;
              forces[node2.id].y += fy;
            }
          }
        }
      }
    }]);

    return RepulsionSolver;
  }();

  exports.default = RepulsionSolver;

/***/ },
/* 96 */
/***/ function(module, exports) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var HierarchicalRepulsionSolver = function () {
    function HierarchicalRepulsionSolver(body, physicsBody, options) {
      _classCallCheck(this, HierarchicalRepulsionSolver);

      this.body = body;
      this.physicsBody = physicsBody;
      this.setOptions(options);
    }

    _createClass(HierarchicalRepulsionSolver, [{
      key: "setOptions",
      value: function setOptions(options) {
        this.options = options;
      }

      /**
       * Calculate the forces the nodes apply on each other based on a repulsion field.
       * This field is linearly approximated.
       *
       * @private
       */

    }, {
      key: "solve",
      value: function solve() {
        var dx, dy, distance, fx, fy, repulsingForce, node1, node2, i, j;

        var nodes = this.body.nodes;
        var nodeIndices = this.physicsBody.physicsNodeIndices;
        var forces = this.physicsBody.forces;

        // repulsing forces between nodes
        var nodeDistance = this.options.nodeDistance;

        // we loop from i over all but the last entree in the array
        // j loops from i+1 to the last. This way we do not double count any of the indices, nor i === j
        for (i = 0; i < nodeIndices.length - 1; i++) {
          node1 = nodes[nodeIndices[i]];
          for (j = i + 1; j < nodeIndices.length; j++) {
            node2 = nodes[nodeIndices[j]];

            // nodes only affect nodes on their level
            if (node1.level === node2.level) {
              dx = node2.x - node1.x;
              dy = node2.y - node1.y;
              distance = Math.sqrt(dx * dx + dy * dy);

              var steepness = 0.05;
              if (distance < nodeDistance) {
                repulsingForce = -Math.pow(steepness * distance, 2) + Math.pow(steepness * nodeDistance, 2);
              } else {
                repulsingForce = 0;
              }
              // normalize force with
              if (distance === 0) {
                distance = 0.01;
              } else {
                repulsingForce = repulsingForce / distance;
              }
              fx = dx * repulsingForce;
              fy = dy * repulsingForce;

              forces[node1.id].x -= fx;
              forces[node1.id].y -= fy;
              forces[node2.id].x += fx;
              forces[node2.id].y += fy;
            }
          }
        }
      }
    }]);

    return HierarchicalRepulsionSolver;
  }();

  exports.default = HierarchicalRepulsionSolver;

/***/ },
/* 97 */
/***/ function(module, exports) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var SpringSolver = function () {
    function SpringSolver(body, physicsBody, options) {
      _classCallCheck(this, SpringSolver);

      this.body = body;
      this.physicsBody = physicsBody;
      this.setOptions(options);
    }

    _createClass(SpringSolver, [{
      key: "setOptions",
      value: function setOptions(options) {
        this.options = options;
      }

      /**
       * This function calculates the springforces on the nodes, accounting for the support nodes.
       *
       * @private
       */

    }, {
      key: "solve",
      value: function solve() {
        var edgeLength = void 0,
            edge = void 0;
        var edgeIndices = this.physicsBody.physicsEdgeIndices;
        var edges = this.body.edges;
        var node1 = void 0,
            node2 = void 0,
            node3 = void 0;

        // forces caused by the edges, modelled as springs
        for (var i = 0; i < edgeIndices.length; i++) {
          edge = edges[edgeIndices[i]];
          if (edge.connected === true && edge.toId !== edge.fromId) {
            // only calculate forces if nodes are in the same sector
            if (this.body.nodes[edge.toId] !== undefined && this.body.nodes[edge.fromId] !== undefined) {
              if (edge.edgeType.via !== undefined) {
                edgeLength = edge.options.length === undefined ? this.options.springLength : edge.options.length;
                node1 = edge.to;
                node2 = edge.edgeType.via;
                node3 = edge.from;

                this._calculateSpringForce(node1, node2, 0.5 * edgeLength);
                this._calculateSpringForce(node2, node3, 0.5 * edgeLength);
              } else {
                // the * 1.5 is here so the edge looks as large as a smooth edge. It does not initially because the smooth edges use
                // the support nodes which exert a repulsive force on the to and from nodes, making the edge appear larger.
                edgeLength = edge.options.length === undefined ? this.options.springLength * 1.5 : edge.options.length;
                this._calculateSpringForce(edge.from, edge.to, edgeLength);
              }
            }
          }
        }
      }

      /**
       * This is the code actually performing the calculation for the function above.
       *
       * @param node1
       * @param node2
       * @param edgeLength
       * @private
       */

    }, {
      key: "_calculateSpringForce",
      value: function _calculateSpringForce(node1, node2, edgeLength) {
        var dx = node1.x - node2.x;
        var dy = node1.y - node2.y;
        var distance = Math.max(Math.sqrt(dx * dx + dy * dy), 0.01);

        // the 1/distance is so the fx and fy can be calculated without sine or cosine.
        var springForce = this.options.springConstant * (edgeLength - distance) / distance;

        var fx = dx * springForce;
        var fy = dy * springForce;

        // handle the case where one node is not part of the physcis
        if (this.physicsBody.forces[node1.id] !== undefined) {
          this.physicsBody.forces[node1.id].x += fx;
          this.physicsBody.forces[node1.id].y += fy;
        }

        if (this.physicsBody.forces[node2.id] !== undefined) {
          this.physicsBody.forces[node2.id].x -= fx;
          this.physicsBody.forces[node2.id].y -= fy;
        }
      }
    }]);

    return SpringSolver;
  }();

  exports.default = SpringSolver;

/***/ },
/* 98 */
/***/ function(module, exports) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var HierarchicalSpringSolver = function () {
    function HierarchicalSpringSolver(body, physicsBody, options) {
      _classCallCheck(this, HierarchicalSpringSolver);

      this.body = body;
      this.physicsBody = physicsBody;
      this.setOptions(options);
    }

    _createClass(HierarchicalSpringSolver, [{
      key: "setOptions",
      value: function setOptions(options) {
        this.options = options;
      }

      /**
       * This function calculates the springforces on the nodes, accounting for the support nodes.
       *
       * @private
       */

    }, {
      key: "solve",
      value: function solve() {
        var edgeLength, edge;
        var dx, dy, fx, fy, springForce, distance;
        var edges = this.body.edges;
        var factor = 0.5;

        var edgeIndices = this.physicsBody.physicsEdgeIndices;
        var nodeIndices = this.physicsBody.physicsNodeIndices;
        var forces = this.physicsBody.forces;

        // initialize the spring force counters
        for (var i = 0; i < nodeIndices.length; i++) {
          var nodeId = nodeIndices[i];
          forces[nodeId].springFx = 0;
          forces[nodeId].springFy = 0;
        }

        // forces caused by the edges, modelled as springs
        for (var _i = 0; _i < edgeIndices.length; _i++) {
          edge = edges[edgeIndices[_i]];
          if (edge.connected === true) {
            edgeLength = edge.options.length === undefined ? this.options.springLength : edge.options.length;

            dx = edge.from.x - edge.to.x;
            dy = edge.from.y - edge.to.y;
            distance = Math.sqrt(dx * dx + dy * dy);
            distance = distance === 0 ? 0.01 : distance;

            // the 1/distance is so the fx and fy can be calculated without sine or cosine.
            springForce = this.options.springConstant * (edgeLength - distance) / distance;

            fx = dx * springForce;
            fy = dy * springForce;

            if (edge.to.level != edge.from.level) {
              if (forces[edge.toId] !== undefined) {
                forces[edge.toId].springFx -= fx;
                forces[edge.toId].springFy -= fy;
              }
              if (forces[edge.fromId] !== undefined) {
                forces[edge.fromId].springFx += fx;
                forces[edge.fromId].springFy += fy;
              }
            } else {
              if (forces[edge.toId] !== undefined) {
                forces[edge.toId].x -= factor * fx;
                forces[edge.toId].y -= factor * fy;
              }
              if (forces[edge.fromId] !== undefined) {
                forces[edge.fromId].x += factor * fx;
                forces[edge.fromId].y += factor * fy;
              }
            }
          }
        }

        // normalize spring forces
        var springForce = 1;
        var springFx, springFy;
        for (var _i2 = 0; _i2 < nodeIndices.length; _i2++) {
          var _nodeId = nodeIndices[_i2];
          springFx = Math.min(springForce, Math.max(-springForce, forces[_nodeId].springFx));
          springFy = Math.min(springForce, Math.max(-springForce, forces[_nodeId].springFy));

          forces[_nodeId].x += springFx;
          forces[_nodeId].y += springFy;
        }

        // retain energy balance
        var totalFx = 0;
        var totalFy = 0;
        for (var _i3 = 0; _i3 < nodeIndices.length; _i3++) {
          var _nodeId2 = nodeIndices[_i3];
          totalFx += forces[_nodeId2].x;
          totalFy += forces[_nodeId2].y;
        }
        var correctionFx = totalFx / nodeIndices.length;
        var correctionFy = totalFy / nodeIndices.length;

        for (var _i4 = 0; _i4 < nodeIndices.length; _i4++) {
          var _nodeId3 = nodeIndices[_i4];
          forces[_nodeId3].x -= correctionFx;
          forces[_nodeId3].y -= correctionFy;
        }
      }
    }]);

    return HierarchicalSpringSolver;
  }();

  exports.default = HierarchicalSpringSolver;

/***/ },
/* 99 */
/***/ function(module, exports) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var CentralGravitySolver = function () {
    function CentralGravitySolver(body, physicsBody, options) {
      _classCallCheck(this, CentralGravitySolver);

      this.body = body;
      this.physicsBody = physicsBody;
      this.setOptions(options);
    }

    _createClass(CentralGravitySolver, [{
      key: "setOptions",
      value: function setOptions(options) {
        this.options = options;
      }
    }, {
      key: "solve",
      value: function solve() {
        var dx = void 0,
            dy = void 0,
            distance = void 0,
            node = void 0;
        var nodes = this.body.nodes;
        var nodeIndices = this.physicsBody.physicsNodeIndices;
        var forces = this.physicsBody.forces;

        for (var i = 0; i < nodeIndices.length; i++) {
          var nodeId = nodeIndices[i];
          node = nodes[nodeId];
          dx = -node.x;
          dy = -node.y;
          distance = Math.sqrt(dx * dx + dy * dy);

          this._calculateForces(distance, dx, dy, forces, node);
        }
      }

      /**
       * Calculate the forces based on the distance.
       * @private
       */

    }, {
      key: "_calculateForces",
      value: function _calculateForces(distance, dx, dy, forces, node) {
        var gravityForce = distance === 0 ? 0 : this.options.centralGravity / distance;
        forces[node.id].x = dx * gravityForce;
        forces[node.id].y = dy * gravityForce;
      }
    }]);

    return CentralGravitySolver;
  }();

  exports.default = CentralGravitySolver;

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _BarnesHutSolver2 = __webpack_require__(94);

  var _BarnesHutSolver3 = _interopRequireDefault(_BarnesHutSolver2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var ForceAtlas2BasedRepulsionSolver = function (_BarnesHutSolver) {
    _inherits(ForceAtlas2BasedRepulsionSolver, _BarnesHutSolver);

    function ForceAtlas2BasedRepulsionSolver(body, physicsBody, options) {
      _classCallCheck(this, ForceAtlas2BasedRepulsionSolver);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(ForceAtlas2BasedRepulsionSolver).call(this, body, physicsBody, options));
    }

    /**
     * Calculate the forces based on the distance.
     *
     * @param distance
     * @param dx
     * @param dy
     * @param node
     * @param parentBranch
     * @private
     */


    _createClass(ForceAtlas2BasedRepulsionSolver, [{
      key: "_calculateForces",
      value: function _calculateForces(distance, dx, dy, node, parentBranch) {
        if (distance === 0) {
          distance = 0.1 * Math.random();
          dx = distance;
        }

        if (this.overlapAvoidanceFactor < 1) {
          distance = Math.max(0.1 + this.overlapAvoidanceFactor * node.shape.radius, distance - node.shape.radius);
        }

        var degree = node.edges.length + 1;
        // the dividing by the distance cubed instead of squared allows us to get the fx and fy components without sines and cosines
        // it is shorthand for gravityforce with distance squared and fx = dx/distance * gravityForce
        var gravityForce = this.options.gravitationalConstant * parentBranch.mass * node.options.mass * degree / Math.pow(distance, 2);
        var fx = dx * gravityForce;
        var fy = dy * gravityForce;

        this.physicsBody.forces[node.id].x += fx;
        this.physicsBody.forces[node.id].y += fy;
      }
    }]);

    return ForceAtlas2BasedRepulsionSolver;
  }(_BarnesHutSolver3.default);

  exports.default = ForceAtlas2BasedRepulsionSolver;

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _CentralGravitySolver2 = __webpack_require__(99);

  var _CentralGravitySolver3 = _interopRequireDefault(_CentralGravitySolver2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var ForceAtlas2BasedCentralGravitySolver = function (_CentralGravitySolver) {
    _inherits(ForceAtlas2BasedCentralGravitySolver, _CentralGravitySolver);

    function ForceAtlas2BasedCentralGravitySolver(body, physicsBody, options) {
      _classCallCheck(this, ForceAtlas2BasedCentralGravitySolver);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(ForceAtlas2BasedCentralGravitySolver).call(this, body, physicsBody, options));
    }

    /**
     * Calculate the forces based on the distance.
     * @private
     */


    _createClass(ForceAtlas2BasedCentralGravitySolver, [{
      key: "_calculateForces",
      value: function _calculateForces(distance, dx, dy, forces, node) {
        if (distance > 0) {
          var degree = node.edges.length + 1;
          var gravityForce = this.options.centralGravity * degree * node.options.mass;
          forces[node.id].x = dx * gravityForce;
          forces[node.id].y = dy * gravityForce;
        }
      }
    }]);

    return ForceAtlas2BasedCentralGravitySolver;
  }(_CentralGravitySolver3.default);

  exports.default = ForceAtlas2BasedCentralGravitySolver;

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _NetworkUtil = __webpack_require__(103);

  var _NetworkUtil2 = _interopRequireDefault(_NetworkUtil);

  var _Cluster = __webpack_require__(104);

  var _Cluster2 = _interopRequireDefault(_Cluster);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);

  var ClusterEngine = function () {
    function ClusterEngine(body) {
      var _this = this;

      _classCallCheck(this, ClusterEngine);

      this.body = body;
      this.clusteredNodes = {};
      this.clusteredEdges = {};

      this.options = {};
      this.defaultOptions = {};
      util.extend(this.options, this.defaultOptions);

      this.body.emitter.on('_resetData', function () {
        _this.clusteredNodes = {};_this.clusteredEdges = {};
      });
    }

    _createClass(ClusterEngine, [{
      key: 'setOptions',
      value: function setOptions(options) {
        if (options !== undefined) {}
      }

      /**
      *
      * @param hubsize
      * @param options
      */

    }, {
      key: 'clusterByHubsize',
      value: function clusterByHubsize(hubsize, options) {
        if (hubsize === undefined) {
          hubsize = this._getHubSize();
        } else if ((typeof hubsize === 'undefined' ? 'undefined' : _typeof(hubsize)) === "object") {
          options = this._checkOptions(hubsize);
          hubsize = this._getHubSize();
        }

        var nodesToCluster = [];
        for (var i = 0; i < this.body.nodeIndices.length; i++) {
          var node = this.body.nodes[this.body.nodeIndices[i]];
          if (node.edges.length >= hubsize) {
            nodesToCluster.push(node.id);
          }
        }

        for (var _i = 0; _i < nodesToCluster.length; _i++) {
          this.clusterByConnection(nodesToCluster[_i], options, true);
        }

        this.body.emitter.emit('_dataChanged');
      }

      /**
      * loop over all nodes, check if they adhere to the condition and cluster if needed.
      * @param options
      * @param refreshData
      */

    }, {
      key: 'cluster',
      value: function cluster() {
        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
        var refreshData = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

        if (options.joinCondition === undefined) {
          throw new Error("Cannot call clusterByNodeData without a joinCondition function in the options.");
        }

        // check if the options object is fine, append if needed
        options = this._checkOptions(options);

        var childNodesObj = {};
        var childEdgesObj = {};

        // collect the nodes that will be in the cluster
        for (var i = 0; i < this.body.nodeIndices.length; i++) {
          var nodeId = this.body.nodeIndices[i];
          var node = this.body.nodes[nodeId];
          var clonedOptions = _NetworkUtil2.default.cloneOptions(node);
          if (options.joinCondition(clonedOptions) === true) {
            childNodesObj[nodeId] = this.body.nodes[nodeId];

            // collect the nodes that will be in the cluster
            for (var _i2 = 0; _i2 < node.edges.length; _i2++) {
              var edge = node.edges[_i2];
              if (this.clusteredEdges[edge.id] === undefined) {
                childEdgesObj[edge.id] = edge;
              }
            }
          }
        }

        this._cluster(childNodesObj, childEdgesObj, options, refreshData);
      }

      /**
       * Cluster all nodes in the network that have only X edges
       * @param edgeCount
       * @param options
       * @param refreshData
       */

    }, {
      key: 'clusterByEdgeCount',
      value: function clusterByEdgeCount(edgeCount, options) {
        var refreshData = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];

        options = this._checkOptions(options);
        var clusters = [];
        var usedNodes = {};
        var edge = void 0,
            edges = void 0,
            node = void 0,
            nodeId = void 0,
            relevantEdgeCount = void 0;
        // collect the nodes that will be in the cluster
        for (var i = 0; i < this.body.nodeIndices.length; i++) {
          var childNodesObj = {};
          var childEdgesObj = {};
          nodeId = this.body.nodeIndices[i];

          // if this node is already used in another cluster this session, we do not have to re-evaluate it.
          if (usedNodes[nodeId] === undefined) {
            relevantEdgeCount = 0;
            node = this.body.nodes[nodeId];
            edges = [];
            for (var j = 0; j < node.edges.length; j++) {
              edge = node.edges[j];
              if (this.clusteredEdges[edge.id] === undefined) {
                if (edge.toId !== edge.fromId) {
                  relevantEdgeCount++;
                }
                edges.push(edge);
              }
            }

            // this node qualifies, we collect its neighbours to start the clustering process.
            if (relevantEdgeCount === edgeCount) {
              var gatheringSuccessful = true;
              for (var _j = 0; _j < edges.length; _j++) {
                edge = edges[_j];
                var childNodeId = this._getConnectedId(edge, nodeId);
                // add the nodes to the list by the join condition.
                if (options.joinCondition === undefined) {
                  childEdgesObj[edge.id] = edge;
                  childNodesObj[nodeId] = this.body.nodes[nodeId];
                  childNodesObj[childNodeId] = this.body.nodes[childNodeId];
                  usedNodes[nodeId] = true;
                } else {
                  var clonedOptions = _NetworkUtil2.default.cloneOptions(this.body.nodes[nodeId]);
                  if (options.joinCondition(clonedOptions) === true) {
                    childEdgesObj[edge.id] = edge;
                    childNodesObj[nodeId] = this.body.nodes[nodeId];
                    usedNodes[nodeId] = true;
                  } else {
                    // this node does not qualify after all.
                    gatheringSuccessful = false;
                    break;
                  }
                }
              }

              // add to the cluster queue
              if (Object.keys(childNodesObj).length > 0 && Object.keys(childEdgesObj).length > 0 && gatheringSuccessful === true) {
                clusters.push({ nodes: childNodesObj, edges: childEdgesObj });
              }
            }
          }
        }

        for (var _i3 = 0; _i3 < clusters.length; _i3++) {
          this._cluster(clusters[_i3].nodes, clusters[_i3].edges, options, false);
        }

        if (refreshData === true) {
          this.body.emitter.emit('_dataChanged');
        }
      }

      /**
      * Cluster all nodes in the network that have only 1 edge
      * @param options
      * @param refreshData
      */

    }, {
      key: 'clusterOutliers',
      value: function clusterOutliers(options) {
        var refreshData = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

        this.clusterByEdgeCount(1, options, refreshData);
      }

      /**
       * Cluster all nodes in the network that have only 2 edge
       * @param options
       * @param refreshData
       */

    }, {
      key: 'clusterBridges',
      value: function clusterBridges(options) {
        var refreshData = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

        this.clusterByEdgeCount(2, options, refreshData);
      }

      /**
      * suck all connected nodes of a node into the node.
      * @param nodeId
      * @param options
      * @param refreshData
      */

    }, {
      key: 'clusterByConnection',
      value: function clusterByConnection(nodeId, options) {
        var refreshData = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];

        // kill conditions
        if (nodeId === undefined) {
          throw new Error("No nodeId supplied to clusterByConnection!");
        }
        if (this.body.nodes[nodeId] === undefined) {
          throw new Error("The nodeId given to clusterByConnection does not exist!");
        }

        var node = this.body.nodes[nodeId];
        options = this._checkOptions(options, node);
        if (options.clusterNodeProperties.x === undefined) {
          options.clusterNodeProperties.x = node.x;
        }
        if (options.clusterNodeProperties.y === undefined) {
          options.clusterNodeProperties.y = node.y;
        }
        if (options.clusterNodeProperties.fixed === undefined) {
          options.clusterNodeProperties.fixed = {};
          options.clusterNodeProperties.fixed.x = node.options.fixed.x;
          options.clusterNodeProperties.fixed.y = node.options.fixed.y;
        }

        var childNodesObj = {};
        var childEdgesObj = {};
        var parentNodeId = node.id;
        var parentClonedOptions = _NetworkUtil2.default.cloneOptions(node);
        childNodesObj[parentNodeId] = node;

        // collect the nodes that will be in the cluster
        for (var i = 0; i < node.edges.length; i++) {
          var edge = node.edges[i];
          if (this.clusteredEdges[edge.id] === undefined) {
            var childNodeId = this._getConnectedId(edge, parentNodeId);

            // if the child node is not in a cluster
            if (this.clusteredNodes[childNodeId] === undefined) {
              if (childNodeId !== parentNodeId) {
                if (options.joinCondition === undefined) {
                  childEdgesObj[edge.id] = edge;
                  childNodesObj[childNodeId] = this.body.nodes[childNodeId];
                } else {
                  // clone the options and insert some additional parameters that could be interesting.
                  var childClonedOptions = _NetworkUtil2.default.cloneOptions(this.body.nodes[childNodeId]);
                  if (options.joinCondition(parentClonedOptions, childClonedOptions) === true) {
                    childEdgesObj[edge.id] = edge;
                    childNodesObj[childNodeId] = this.body.nodes[childNodeId];
                  }
                }
              } else {
                // swallow the edge if it is self-referencing.
                childEdgesObj[edge.id] = edge;
              }
            }
          }
        }

        this._cluster(childNodesObj, childEdgesObj, options, refreshData);
      }

      /**
      * This function creates the edges that will be attached to the cluster
      * It looks for edges that are connected to the nodes from the "outside' of the cluster.
      *
      * @param childNodesObj
      * @param childEdgesObj
      * @param clusterNodeProperties
      * @param clusterEdgeProperties
      * @private
      */

    }, {
      key: '_createClusterEdges',
      value: function _createClusterEdges(childNodesObj, childEdgesObj, clusterNodeProperties, clusterEdgeProperties) {
        var edge = void 0,
            childNodeId = void 0,
            childNode = void 0,
            toId = void 0,
            fromId = void 0,
            otherNodeId = void 0;

        // loop over all child nodes and their edges to find edges going out of the cluster
        // these edges will be replaced by clusterEdges.
        var childKeys = Object.keys(childNodesObj);
        var createEdges = [];
        for (var i = 0; i < childKeys.length; i++) {
          childNodeId = childKeys[i];
          childNode = childNodesObj[childNodeId];

          // construct new edges from the cluster to others
          for (var j = 0; j < childNode.edges.length; j++) {
            edge = childNode.edges[j];
            // we only handle edges that are visible to the system, not the disabled ones from the clustering process.
            if (this.clusteredEdges[edge.id] === undefined) {
              // self-referencing edges will be added to the "hidden" list
              if (edge.toId == edge.fromId) {
                childEdgesObj[edge.id] = edge;
              } else {
                // set up the from and to.
                if (edge.toId == childNodeId) {
                  // this is a double equals because ints and strings can be interchanged here.
                  toId = clusterNodeProperties.id;
                  fromId = edge.fromId;
                  otherNodeId = fromId;
                } else {
                  toId = edge.toId;
                  fromId = clusterNodeProperties.id;
                  otherNodeId = toId;
                }
              }

              // Only edges from the cluster outwards are being replaced.
              if (childNodesObj[otherNodeId] === undefined) {
                createEdges.push({ edge: edge, fromId: fromId, toId: toId });
              }
            }
          }
        }

        // here we actually create the replacement edges. We could not do this in the loop above as the creation process
        // would add an edge to the edges array we are iterating over.
        for (var _j2 = 0; _j2 < createEdges.length; _j2++) {
          var _edge = createEdges[_j2].edge;
          // copy the options of the edge we will replace
          var clonedOptions = _NetworkUtil2.default.cloneOptions(_edge, 'edge');
          // make sure the properties of clusterEdges are superimposed on it
          util.deepExtend(clonedOptions, clusterEdgeProperties);

          // set up the edge
          clonedOptions.from = createEdges[_j2].fromId;
          clonedOptions.to = createEdges[_j2].toId;
          clonedOptions.id = 'clusterEdge:' + util.randomUUID();
          //clonedOptions.id = '(cf: ' + createEdges[j].fromId + " to: " + createEdges[j].toId + ")" + Math.random();

          // create the edge and give a reference to the one it replaced.
          var newEdge = this.body.functions.createEdge(clonedOptions);
          newEdge.clusteringEdgeReplacingId = _edge.id;

          // connect the edge.
          this.body.edges[newEdge.id] = newEdge;
          newEdge.connect();

          // hide the replaced edge
          this._backupEdgeOptions(_edge);
          _edge.setOptions({ physics: false, hidden: true });
        }
      }

      /**
      * This function checks the options that can be supplied to the different cluster functions
      * for certain fields and inserts defaults if needed
      * @param options
      * @returns {*}
      * @private
      */

    }, {
      key: '_checkOptions',
      value: function _checkOptions() {
        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

        if (options.clusterEdgeProperties === undefined) {
          options.clusterEdgeProperties = {};
        }
        if (options.clusterNodeProperties === undefined) {
          options.clusterNodeProperties = {};
        }

        return options;
      }

      /**
      *
      * @param {Object}    childNodesObj         | object with node objects, id as keys, same as childNodes except it also contains a source node
      * @param {Object}    childEdgesObj         | object with edge objects, id as keys
      * @param {Array}     options               | object with {clusterNodeProperties, clusterEdgeProperties, processProperties}
      * @param {Boolean}   refreshData | when true, do not wrap up
      * @private
      */

    }, {
      key: '_cluster',
      value: function _cluster(childNodesObj, childEdgesObj, options) {
        var refreshData = arguments.length <= 3 || arguments[3] === undefined ? true : arguments[3];

        // kill condition: no children so can't cluster or only one node in the cluster, don't bother
        if (Object.keys(childNodesObj).length < 2) {
          return;
        }

        // check if this cluster call is not trying to cluster anything that is in another cluster.
        for (var nodeId in childNodesObj) {
          if (childNodesObj.hasOwnProperty(nodeId)) {
            if (this.clusteredNodes[nodeId] !== undefined) {
              return;
            }
          }
        }

        var clusterNodeProperties = util.deepExtend({}, options.clusterNodeProperties);

        // construct the clusterNodeProperties
        if (options.processProperties !== undefined) {
          // get the childNode options
          var childNodesOptions = [];
          for (var _nodeId in childNodesObj) {
            if (childNodesObj.hasOwnProperty(_nodeId)) {
              var clonedOptions = _NetworkUtil2.default.cloneOptions(childNodesObj[_nodeId]);
              childNodesOptions.push(clonedOptions);
            }
          }

          // get cluster properties based on childNodes
          var childEdgesOptions = [];
          for (var edgeId in childEdgesObj) {
            if (childEdgesObj.hasOwnProperty(edgeId)) {
              // these cluster edges will be removed on creation of the cluster.
              if (edgeId.substr(0, 12) !== "clusterEdge:") {
                var _clonedOptions = _NetworkUtil2.default.cloneOptions(childEdgesObj[edgeId], 'edge');
                childEdgesOptions.push(_clonedOptions);
              }
            }
          }

          clusterNodeProperties = options.processProperties(clusterNodeProperties, childNodesOptions, childEdgesOptions);
          if (!clusterNodeProperties) {
            throw new Error("The processProperties function does not return properties!");
          }
        }

        // check if we have an unique id;
        if (clusterNodeProperties.id === undefined) {
          clusterNodeProperties.id = 'cluster:' + util.randomUUID();
        }
        var clusterId = clusterNodeProperties.id;

        if (clusterNodeProperties.label === undefined) {
          clusterNodeProperties.label = 'cluster';
        }

        // give the clusterNode a position if it does not have one.
        var pos = undefined;
        if (clusterNodeProperties.x === undefined) {
          pos = this._getClusterPosition(childNodesObj);
          clusterNodeProperties.x = pos.x;
        }
        if (clusterNodeProperties.y === undefined) {
          if (pos === undefined) {
            pos = this._getClusterPosition(childNodesObj);
          }
          clusterNodeProperties.y = pos.y;
        }

        // force the ID to remain the same
        clusterNodeProperties.id = clusterId;

        // create the clusterNode
        var clusterNode = this.body.functions.createNode(clusterNodeProperties, _Cluster2.default);
        clusterNode.isCluster = true;
        clusterNode.containedNodes = childNodesObj;
        clusterNode.containedEdges = childEdgesObj;
        // cache a copy from the cluster edge properties if we have to reconnect others later on
        clusterNode.clusterEdgeProperties = options.clusterEdgeProperties;

        // finally put the cluster node into global
        this.body.nodes[clusterNodeProperties.id] = clusterNode;

        // create the new edges that will connect to the cluster, all self-referencing edges will be added to childEdgesObject here.
        this._createClusterEdges(childNodesObj, childEdgesObj, clusterNodeProperties, options.clusterEdgeProperties);

        // disable the childEdges
        for (var _edgeId in childEdgesObj) {
          if (childEdgesObj.hasOwnProperty(_edgeId)) {
            if (this.body.edges[_edgeId] !== undefined) {
              var edge = this.body.edges[_edgeId];
              // cache the options before changing
              this._backupEdgeOptions(edge);
              // disable physics and hide the edge
              edge.setOptions({ physics: false, hidden: true });
            }
          }
        }

        // disable the childNodes
        for (var _nodeId2 in childNodesObj) {
          if (childNodesObj.hasOwnProperty(_nodeId2)) {
            this.clusteredNodes[_nodeId2] = { clusterId: clusterNodeProperties.id, node: this.body.nodes[_nodeId2] };
            this.body.nodes[_nodeId2].setOptions({ hidden: true, physics: false });
          }
        }

        // set ID to undefined so no duplicates arise
        clusterNodeProperties.id = undefined;

        // wrap up
        if (refreshData === true) {
          this.body.emitter.emit('_dataChanged');
        }
      }
    }, {
      key: '_backupEdgeOptions',
      value: function _backupEdgeOptions(edge) {
        if (this.clusteredEdges[edge.id] === undefined) {
          this.clusteredEdges[edge.id] = { physics: edge.options.physics, hidden: edge.options.hidden };
        }
      }
    }, {
      key: '_restoreEdge',
      value: function _restoreEdge(edge) {
        var originalOptions = this.clusteredEdges[edge.id];
        if (originalOptions !== undefined) {
          edge.setOptions({ physics: originalOptions.physics, hidden: originalOptions.hidden });
          delete this.clusteredEdges[edge.id];
        }
      }

      /**
      * Check if a node is a cluster.
      * @param nodeId
      * @returns {*}
      */

    }, {
      key: 'isCluster',
      value: function isCluster(nodeId) {
        if (this.body.nodes[nodeId] !== undefined) {
          return this.body.nodes[nodeId].isCluster === true;
        } else {
          console.log("Node does not exist.");
          return false;
        }
      }

      /**
      * get the position of the cluster node based on what's inside
      * @param {object} childNodesObj    | object with node objects, id as keys
      * @returns {{x: number, y: number}}
      * @private
      */

    }, {
      key: '_getClusterPosition',
      value: function _getClusterPosition(childNodesObj) {
        var childKeys = Object.keys(childNodesObj);
        var minX = childNodesObj[childKeys[0]].x;
        var maxX = childNodesObj[childKeys[0]].x;
        var minY = childNodesObj[childKeys[0]].y;
        var maxY = childNodesObj[childKeys[0]].y;
        var node = void 0;
        for (var i = 1; i < childKeys.length; i++) {
          node = childNodesObj[childKeys[i]];
          minX = node.x < minX ? node.x : minX;
          maxX = node.x > maxX ? node.x : maxX;
          minY = node.y < minY ? node.y : minY;
          maxY = node.y > maxY ? node.y : maxY;
        }

        return { x: 0.5 * (minX + maxX), y: 0.5 * (minY + maxY) };
      }

      /**
      * Open a cluster by calling this function.
      * @param {String}  clusterNodeId | the ID of the cluster node
      * @param {Boolean} refreshData | wrap up afterwards if not true
      */

    }, {
      key: 'openCluster',
      value: function openCluster(clusterNodeId, options) {
        var refreshData = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];

        // kill conditions
        if (clusterNodeId === undefined) {
          throw new Error("No clusterNodeId supplied to openCluster.");
        }
        if (this.body.nodes[clusterNodeId] === undefined) {
          throw new Error("The clusterNodeId supplied to openCluster does not exist.");
        }
        if (this.body.nodes[clusterNodeId].containedNodes === undefined) {
          console.log("The node:" + clusterNodeId + " is not a cluster.");
          return;
        }
        var clusterNode = this.body.nodes[clusterNodeId];
        var containedNodes = clusterNode.containedNodes;
        var containedEdges = clusterNode.containedEdges;

        // allow the user to position the nodes after release.
        if (options !== undefined && options.releaseFunction !== undefined && typeof options.releaseFunction === 'function') {
          var positions = {};
          var clusterPosition = { x: clusterNode.x, y: clusterNode.y };
          for (var nodeId in containedNodes) {
            if (containedNodes.hasOwnProperty(nodeId)) {
              var containedNode = this.body.nodes[nodeId];
              positions[nodeId] = { x: containedNode.x, y: containedNode.y };
            }
          }
          var newPositions = options.releaseFunction(clusterPosition, positions);

          for (var _nodeId3 in containedNodes) {
            if (containedNodes.hasOwnProperty(_nodeId3)) {
              var _containedNode = this.body.nodes[_nodeId3];
              if (newPositions[_nodeId3] !== undefined) {
                _containedNode.x = newPositions[_nodeId3].x === undefined ? clusterNode.x : newPositions[_nodeId3].x;
                _containedNode.y = newPositions[_nodeId3].y === undefined ? clusterNode.y : newPositions[_nodeId3].y;
              }
            }
          }
        } else {
          // copy the position from the cluster
          for (var _nodeId4 in containedNodes) {
            if (containedNodes.hasOwnProperty(_nodeId4)) {
              var _containedNode2 = this.body.nodes[_nodeId4];
              _containedNode2 = containedNodes[_nodeId4];
              // inherit position
              if (_containedNode2.options.fixed.x === false) {
                _containedNode2.x = clusterNode.x;
              }
              if (_containedNode2.options.fixed.y === false) {
                _containedNode2.y = clusterNode.y;
              }
            }
          }
        }

        // release nodes
        for (var _nodeId5 in containedNodes) {
          if (containedNodes.hasOwnProperty(_nodeId5)) {
            var _containedNode3 = this.body.nodes[_nodeId5];

            // inherit speed
            _containedNode3.vx = clusterNode.vx;
            _containedNode3.vy = clusterNode.vy;

            // we use these methods to avoid re-instantiating the shape, which happens with setOptions.
            _containedNode3.setOptions({ hidden: false, physics: true });

            delete this.clusteredNodes[_nodeId5];
          }
        }

        // copy the clusterNode edges because we cannot iterate over an object that we add or remove from.
        var edgesToBeDeleted = [];
        for (var i = 0; i < clusterNode.edges.length; i++) {
          edgesToBeDeleted.push(clusterNode.edges[i]);
        }

        // actually handling the deleting.
        for (var _i4 = 0; _i4 < edgesToBeDeleted.length; _i4++) {
          var edge = edgesToBeDeleted[_i4];

          var otherNodeId = this._getConnectedId(edge, clusterNodeId);
          // if the other node is in another cluster, we transfer ownership of this edge to the other cluster
          if (this.clusteredNodes[otherNodeId] !== undefined) {
            // transfer ownership:
            var otherCluster = this.body.nodes[this.clusteredNodes[otherNodeId].clusterId];
            var transferEdge = this.body.edges[edge.clusteringEdgeReplacingId];
            if (transferEdge !== undefined) {
              otherCluster.containedEdges[transferEdge.id] = transferEdge;

              // delete local reference
              delete containedEdges[transferEdge.id];

              // create new cluster edge from the otherCluster:
              // get to and from
              var fromId = transferEdge.fromId;
              var toId = transferEdge.toId;
              if (transferEdge.toId == otherNodeId) {
                toId = this.clusteredNodes[otherNodeId].clusterId;
              } else {
                fromId = this.clusteredNodes[otherNodeId].clusterId;
              }

              // clone the options and apply the cluster options to them
              var clonedOptions = _NetworkUtil2.default.cloneOptions(transferEdge, 'edge');
              util.deepExtend(clonedOptions, otherCluster.clusterEdgeProperties);

              // apply the edge specific options to it.
              var id = 'clusterEdge:' + util.randomUUID();
              util.deepExtend(clonedOptions, { from: fromId, to: toId, hidden: false, physics: true, id: id });

              // create it
              var newEdge = this.body.functions.createEdge(clonedOptions);
              newEdge.clusteringEdgeReplacingId = transferEdge.id;
              this.body.edges[id] = newEdge;
              this.body.edges[id].connect();
            }
          } else {
            var replacedEdge = this.body.edges[edge.clusteringEdgeReplacingId];
            if (replacedEdge !== undefined) {
              this._restoreEdge(replacedEdge);
            }
          }
          edge.cleanup();
          // this removes the edge from node.edges, which is why edgeIds is formed
          edge.disconnect();
          delete this.body.edges[edge.id];
        }

        // handle the releasing of the edges
        for (var edgeId in containedEdges) {
          if (containedEdges.hasOwnProperty(edgeId)) {
            this._restoreEdge(containedEdges[edgeId]);
          }
        }

        // remove clusterNode
        delete this.body.nodes[clusterNodeId];

        if (refreshData === true) {
          this.body.emitter.emit('_dataChanged');
        }
      }
    }, {
      key: 'getNodesInCluster',
      value: function getNodesInCluster(clusterId) {
        var nodesArray = [];
        if (this.isCluster(clusterId) === true) {
          var containedNodes = this.body.nodes[clusterId].containedNodes;
          for (var nodeId in containedNodes) {
            if (containedNodes.hasOwnProperty(nodeId)) {
              nodesArray.push(this.body.nodes[nodeId].id);
            }
          }
        }

        return nodesArray;
      }

      /**
      * Get the stack clusterId's that a certain node resides in. cluster A -> cluster B -> cluster C -> node
      * @param nodeId
      * @returns {Array}
      */

    }, {
      key: 'findNode',
      value: function findNode(nodeId) {
        var stack = [];
        var max = 100;
        var counter = 0;

        while (this.clusteredNodes[nodeId] !== undefined && counter < max) {
          stack.push(this.body.nodes[nodeId].id);
          nodeId = this.clusteredNodes[nodeId].clusterId;
          counter++;
        }
        stack.push(this.body.nodes[nodeId].id);
        stack.reverse();

        return stack;
      }

      /**
      * Get the Id the node is connected to
      * @param edge
      * @param nodeId
      * @returns {*}
      * @private
      */

    }, {
      key: '_getConnectedId',
      value: function _getConnectedId(edge, nodeId) {
        if (edge.toId != nodeId) {
          return edge.toId;
        } else if (edge.fromId != nodeId) {
          return edge.fromId;
        } else {
          return edge.fromId;
        }
      }

      /**
      * We determine how many connections denote an important hub.
      * We take the mean + 2*std as the important hub size. (Assuming a normal distribution of data, ~2.2%)
      *
      * @private
      */

    }, {
      key: '_getHubSize',
      value: function _getHubSize() {
        var average = 0;
        var averageSquared = 0;
        var hubCounter = 0;
        var largestHub = 0;

        for (var i = 0; i < this.body.nodeIndices.length; i++) {
          var node = this.body.nodes[this.body.nodeIndices[i]];
          if (node.edges.length > largestHub) {
            largestHub = node.edges.length;
          }
          average += node.edges.length;
          averageSquared += Math.pow(node.edges.length, 2);
          hubCounter += 1;
        }
        average = average / hubCounter;
        averageSquared = averageSquared / hubCounter;

        var variance = averageSquared - Math.pow(average, 2);
        var standardDeviation = Math.sqrt(variance);

        var hubThreshold = Math.floor(average + 2 * standardDeviation);

        // always have at least one to cluster
        if (hubThreshold > largestHub) {
          hubThreshold = largestHub;
        }

        return hubThreshold;
      }
    }]);

    return ClusterEngine;
  }();

  exports.default = ClusterEngine;

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);

  var NetworkUtil = function () {
    function NetworkUtil() {
      _classCallCheck(this, NetworkUtil);
    }

    /**
     * Find the center position of the network considering the bounding boxes
     */


    _createClass(NetworkUtil, null, [{
      key: "getRange",
      value: function getRange(allNodes) {
        var specificNodes = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];

        var minY = 1e9,
            maxY = -1e9,
            minX = 1e9,
            maxX = -1e9,
            node;
        if (specificNodes.length > 0) {
          for (var i = 0; i < specificNodes.length; i++) {
            node = allNodes[specificNodes[i]];
            if (minX > node.shape.boundingBox.left) {
              minX = node.shape.boundingBox.left;
            }
            if (maxX < node.shape.boundingBox.right) {
              maxX = node.shape.boundingBox.right;
            }
            if (minY > node.shape.boundingBox.top) {
              minY = node.shape.boundingBox.top;
            } // top is negative, bottom is positive
            if (maxY < node.shape.boundingBox.bottom) {
              maxY = node.shape.boundingBox.bottom;
            } // top is negative, bottom is positive
          }
        }

        if (minX === 1e9 && maxX === -1e9 && minY === 1e9 && maxY === -1e9) {
          minY = 0, maxY = 0, minX = 0, maxX = 0;
        }
        return { minX: minX, maxX: maxX, minY: minY, maxY: maxY };
      }

      /**
       * Find the center position of the network
       */

    }, {
      key: "getRangeCore",
      value: function getRangeCore(allNodes) {
        var specificNodes = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];

        var minY = 1e9,
            maxY = -1e9,
            minX = 1e9,
            maxX = -1e9,
            node;
        if (specificNodes.length > 0) {
          for (var i = 0; i < specificNodes.length; i++) {
            node = allNodes[specificNodes[i]];
            if (minX > node.x) {
              minX = node.x;
            }
            if (maxX < node.x) {
              maxX = node.x;
            }
            if (minY > node.y) {
              minY = node.y;
            } // top is negative, bottom is positive
            if (maxY < node.y) {
              maxY = node.y;
            } // top is negative, bottom is positive
          }
        }

        if (minX === 1e9 && maxX === -1e9 && minY === 1e9 && maxY === -1e9) {
          minY = 0, maxY = 0, minX = 0, maxX = 0;
        }
        return { minX: minX, maxX: maxX, minY: minY, maxY: maxY };
      }

      /**
       * @param {object} range = {minX: minX, maxX: maxX, minY: minY, maxY: maxY};
       * @returns {{x: number, y: number}}
       */

    }, {
      key: "findCenter",
      value: function findCenter(range) {
        return { x: 0.5 * (range.maxX + range.minX),
          y: 0.5 * (range.maxY + range.minY) };
      }

      /**
       * This returns a clone of the options or options of the edge or node to be used for construction of new edges or check functions for new nodes.
       * @param item
       * @param type
       * @returns {{}}
       */

    }, {
      key: "cloneOptions",
      value: function cloneOptions(item, type) {
        var clonedOptions = {};
        if (type === undefined || type === 'node') {
          util.deepExtend(clonedOptions, item.options, true);
          clonedOptions.x = item.x;
          clonedOptions.y = item.y;
          clonedOptions.amountOfConnections = item.edges.length;
        } else {
          util.deepExtend(clonedOptions, item.options, true);
        }
        return clonedOptions;
      }
    }]);

    return NetworkUtil;
  }();

  exports.default = NetworkUtil;

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _Node2 = __webpack_require__(65);

  var _Node3 = _interopRequireDefault(_Node2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  /**
   *
   */

  var Cluster = function (_Node) {
    _inherits(Cluster, _Node);

    function Cluster(options, body, imagelist, grouplist, globalOptions) {
      _classCallCheck(this, Cluster);

      var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Cluster).call(this, options, body, imagelist, grouplist, globalOptions));

      _this.isCluster = true;
      _this.containedNodes = {};
      _this.containedEdges = {};
      return _this;
    }

    return Cluster;
  }(_Node3.default);

  exports.default = Cluster;

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  if (typeof window !== 'undefined') {
    window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
  }

  var util = __webpack_require__(1);

  var CanvasRenderer = function () {
    function CanvasRenderer(body, canvas) {
      _classCallCheck(this, CanvasRenderer);

      this.body = body;
      this.canvas = canvas;

      this.redrawRequested = false;
      this.renderTimer = undefined;
      this.requiresTimeout = true;
      this.renderingActive = false;
      this.renderRequests = 0;
      this.pixelRatio = undefined;
      this.allowRedraw = true;

      this.dragging = false;
      this.options = {};
      this.defaultOptions = {
        hideEdgesOnDrag: false,
        hideNodesOnDrag: false
      };
      util.extend(this.options, this.defaultOptions);

      this._determineBrowserMethod();
      this.bindEventListeners();
    }

    _createClass(CanvasRenderer, [{
      key: 'bindEventListeners',
      value: function bindEventListeners() {
        var _this = this;

        this.body.emitter.on("dragStart", function () {
          _this.dragging = true;
        });
        this.body.emitter.on("dragEnd", function () {
          return _this.dragging = false;
        });
        this.body.emitter.on("_resizeNodes", function () {
          return _this._resizeNodes();
        });
        this.body.emitter.on("_redraw", function () {
          if (_this.renderingActive === false) {
            _this._redraw();
          }
        });
        this.body.emitter.on("_blockRedraw", function () {
          _this.allowRedraw = false;
        });
        this.body.emitter.on("_allowRedraw", function () {
          _this.allowRedraw = true;_this.redrawRequested = false;
        });
        this.body.emitter.on("_requestRedraw", this._requestRedraw.bind(this));
        this.body.emitter.on("_startRendering", function () {
          _this.renderRequests += 1;
          _this.renderingActive = true;
          _this._startRendering();
        });
        this.body.emitter.on("_stopRendering", function () {
          _this.renderRequests -= 1;
          _this.renderingActive = _this.renderRequests > 0;
          _this.renderTimer = undefined;
        });
        this.body.emitter.on('destroy', function () {
          _this.renderRequests = 0;
          _this.allowRedraw = false;
          _this.renderingActive = false;
          if (_this.requiresTimeout === true) {
            clearTimeout(_this.renderTimer);
          } else {
            cancelAnimationFrame(_this.renderTimer);
          }
          _this.body.emitter.off();
        });
      }
    }, {
      key: 'setOptions',
      value: function setOptions(options) {
        if (options !== undefined) {
          var fields = ['hideEdgesOnDrag', 'hideNodesOnDrag'];
          util.selectiveDeepExtend(fields, this.options, options);
        }
      }
    }, {
      key: '_startRendering',
      value: function _startRendering() {
        if (this.renderingActive === true) {
          if (this.renderTimer === undefined) {
            if (this.requiresTimeout === true) {
              this.renderTimer = window.setTimeout(this._renderStep.bind(this), this.simulationInterval); // wait this.renderTimeStep milliseconds and perform the animation step function
            } else {
                this.renderTimer = window.requestAnimationFrame(this._renderStep.bind(this)); // wait this.renderTimeStep milliseconds and perform the animation step function
              }
          }
        }
      }
    }, {
      key: '_renderStep',
      value: function _renderStep() {
        if (this.renderingActive === true) {
          // reset the renderTimer so a new scheduled animation step can be set
          this.renderTimer = undefined;

          if (this.requiresTimeout === true) {
            // this schedules a new simulation step
            this._startRendering();
          }

          this._redraw();

          if (this.requiresTimeout === false) {
            // this schedules a new simulation step
            this._startRendering();
          }
        }
      }

      /**
       * Redraw the network with the current data
       * chart will be resized too.
       */

    }, {
      key: 'redraw',
      value: function redraw() {
        this.body.emitter.emit('setSize');
        this._redraw();
      }

      /**
       * Redraw the network with the current data
       * @param hidden | used to get the first estimate of the node sizes. only the nodes are drawn after which they are quickly drawn over.
       * @private
       */

    }, {
      key: '_requestRedraw',
      value: function _requestRedraw() {
        var _this2 = this;

        if (this.redrawRequested !== true && this.renderingActive === false && this.allowRedraw === true) {
          this.redrawRequested = true;
          if (this.requiresTimeout === true) {
            window.setTimeout(function () {
              _this2._redraw(false);
            }, 0);
          } else {
            window.requestAnimationFrame(function () {
              _this2._redraw(false);
            });
          }
        }
      }
    }, {
      key: '_redraw',
      value: function _redraw() {
        var hidden = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];

        if (this.allowRedraw === true) {
          this.body.emitter.emit("initRedraw");

          this.redrawRequested = false;
          var ctx = this.canvas.frame.canvas.getContext('2d');

          // when the container div was hidden, this fixes it back up!
          if (this.canvas.frame.canvas.width === 0 || this.canvas.frame.canvas.height === 0) {
            this.canvas.setSize();
          }

          this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);

          ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);

          // clear the canvas
          var w = this.canvas.frame.canvas.clientWidth;
          var h = this.canvas.frame.canvas.clientHeight;
          ctx.clearRect(0, 0, w, h);

          // if the div is hidden, we stop the redraw here for performance.
          if (this.canvas.frame.clientWidth === 0) {
            return;
          }

          // set scaling and translation
          ctx.save();
          ctx.translate(this.body.view.translation.x, this.body.view.translation.y);
          ctx.scale(this.body.view.scale, this.body.view.scale);

          ctx.beginPath();
          this.body.emitter.emit("beforeDrawing", ctx);
          ctx.closePath();

          if (hidden === false) {
            if (this.dragging === false || this.dragging === true && this.options.hideEdgesOnDrag === false) {
              this._drawEdges(ctx);
            }
          }

          if (this.dragging === false || this.dragging === true && this.options.hideNodesOnDrag === false) {
            this._drawNodes(ctx, hidden);
          }

          ctx.beginPath();
          this.body.emitter.emit("afterDrawing", ctx);
          ctx.closePath();

          // restore original scaling and translation
          ctx.restore();
          if (hidden === true) {
            ctx.clearRect(0, 0, w, h);
          }
        }
      }

      /**
       * Redraw all nodes
       * The 2d context of a HTML canvas can be retrieved by canvas.getContext('2d');
       * @param {CanvasRenderingContext2D}   ctx
       * @param {Boolean} [alwaysShow]
       * @private
       */

    }, {
      key: '_resizeNodes',
      value: function _resizeNodes() {
        var ctx = this.canvas.frame.canvas.getContext('2d');
        if (this.pixelRatio === undefined) {
          this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
        }
        ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
        ctx.save();
        ctx.translate(this.body.view.translation.x, this.body.view.translation.y);
        ctx.scale(this.body.view.scale, this.body.view.scale);

        var nodes = this.body.nodes;
        var node = void 0;

        // resize all nodes
        for (var nodeId in nodes) {
          if (nodes.hasOwnProperty(nodeId)) {
            node = nodes[nodeId];
            node.resize(ctx);
            node.updateBoundingBox(ctx, node.selected);
          }
        }

        // restore original scaling and translation
        ctx.restore();
      }

      /**
       * Redraw all nodes
       * The 2d context of a HTML canvas can be retrieved by canvas.getContext('2d');
       * @param {CanvasRenderingContext2D}   ctx
       * @param {Boolean} [alwaysShow]
       * @private
       */

    }, {
      key: '_drawNodes',
      value: function _drawNodes(ctx) {
        var alwaysShow = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

        var nodes = this.body.nodes;
        var nodeIndices = this.body.nodeIndices;
        var node = void 0;
        var selected = [];
        var margin = 20;
        var topLeft = this.canvas.DOMtoCanvas({ x: -margin, y: -margin });
        var bottomRight = this.canvas.DOMtoCanvas({
          x: this.canvas.frame.canvas.clientWidth + margin,
          y: this.canvas.frame.canvas.clientHeight + margin
        });
        var viewableArea = { top: topLeft.y, left: topLeft.x, bottom: bottomRight.y, right: bottomRight.x };

        // draw unselected nodes;
        for (var i = 0; i < nodeIndices.length; i++) {
          node = nodes[nodeIndices[i]];
          // set selected nodes aside
          if (node.isSelected()) {
            selected.push(nodeIndices[i]);
          } else {
            if (alwaysShow === true) {
              node.draw(ctx);
            } else if (node.isBoundingBoxOverlappingWith(viewableArea) === true) {
              node.draw(ctx);
            } else {
              node.updateBoundingBox(ctx, node.selected);
            }
          }
        }

        // draw the selected nodes on top
        for (var _i = 0; _i < selected.length; _i++) {
          node = nodes[selected[_i]];
          node.draw(ctx);
        }
      }

      /**
       * Redraw all edges
       * The 2d context of a HTML canvas can be retrieved by canvas.getContext('2d');
       * @param {CanvasRenderingContext2D}   ctx
       * @private
       */

    }, {
      key: '_drawEdges',
      value: function _drawEdges(ctx) {
        var edges = this.body.edges;
        var edgeIndices = this.body.edgeIndices;
        var edge = void 0;

        for (var i = 0; i < edgeIndices.length; i++) {
          edge = edges[edgeIndices[i]];
          if (edge.connected === true) {
            edge.draw(ctx);
          }
        }
      }

      /**
       * Determine if the browser requires a setTimeout or a requestAnimationFrame. This was required because
       * some implementations (safari and IE9) did not support requestAnimationFrame
       * @private
       */

    }, {
      key: '_determineBrowserMethod',
      value: function _determineBrowserMethod() {
        if (typeof window !== 'undefined') {
          var browserType = navigator.userAgent.toLowerCase();
          this.requiresTimeout = false;
          if (browserType.indexOf('msie 9.0') != -1) {
            // IE 9
            this.requiresTimeout = true;
          } else if (browserType.indexOf('safari') != -1) {
            // safari
            if (browserType.indexOf('chrome') <= -1) {
              this.requiresTimeout = true;
            }
          }
        } else {
          this.requiresTimeout = true;
        }
      }
    }]);

    return CanvasRenderer;
  }();

  exports.default = CanvasRenderer;

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var Hammer = __webpack_require__(20);
  var hammerUtil = __webpack_require__(28);

  var util = __webpack_require__(1);

  /**
   * Create the main frame for the Network.
   * This function is executed once when a Network object is created. The frame
   * contains a canvas, and this canvas contains all objects like the axis and
   * nodes.
   * @private
   */

  var Canvas = function () {
    function Canvas(body) {
      _classCallCheck(this, Canvas);

      this.body = body;
      this.pixelRatio = 1;
      this.resizeTimer = undefined;
      this.resizeFunction = this._onResize.bind(this);
      this.cameraState = {};
      this.initialized = false;

      this.options = {};
      this.defaultOptions = {
        autoResize: true,
        height: '100%',
        width: '100%'
      };
      util.extend(this.options, this.defaultOptions);

      this.bindEventListeners();
    }

    _createClass(Canvas, [{
      key: 'bindEventListeners',
      value: function bindEventListeners() {
        var _this = this;

        // bind the events
        this.body.emitter.once("resize", function (obj) {
          if (obj.width !== 0) {
            _this.body.view.translation.x = obj.width * 0.5;
          }
          if (obj.height !== 0) {
            _this.body.view.translation.y = obj.height * 0.5;
          }
        });
        this.body.emitter.on("setSize", this.setSize.bind(this));
        this.body.emitter.on("destroy", function () {
          _this.hammerFrame.destroy();
          _this.hammer.destroy();
          _this._cleanUp();
        });
      }
    }, {
      key: 'setOptions',
      value: function setOptions(options) {
        var _this2 = this;

        if (options !== undefined) {
          var fields = ['width', 'height', 'autoResize'];
          util.selectiveDeepExtend(fields, this.options, options);
        }

        if (this.options.autoResize === true) {
          // automatically adapt to a changing size of the browser.
          this._cleanUp();
          this.resizeTimer = setInterval(function () {
            var changed = _this2.setSize();
            if (changed === true) {
              _this2.body.emitter.emit("_requestRedraw");
            }
          }, 1000);
          this.resizeFunction = this._onResize.bind(this);
          util.addEventListener(window, 'resize', this.resizeFunction);
        }
      }
    }, {
      key: '_cleanUp',
      value: function _cleanUp() {
        // automatically adapt to a changing size of the browser.
        if (this.resizeTimer !== undefined) {
          clearInterval(this.resizeTimer);
        }
        util.removeEventListener(window, 'resize', this.resizeFunction);
        this.resizeFunction = undefined;
      }
    }, {
      key: '_onResize',
      value: function _onResize() {
        this.setSize();
        this.body.emitter.emit("_redraw");
      }

      /**
       * Get and store the cameraState
       * @private
       */

    }, {
      key: '_getCameraState',
      value: function _getCameraState() {
        var pixelRatio = arguments.length <= 0 || arguments[0] === undefined ? this.pixelRatio : arguments[0];

        if (this.initialized === true) {
          this.cameraState.previousWidth = this.frame.canvas.width / pixelRatio;
          this.cameraState.previousHeight = this.frame.canvas.height / pixelRatio;
          this.cameraState.scale = this.body.view.scale;
          this.cameraState.position = this.DOMtoCanvas({
            x: 0.5 * this.frame.canvas.width / pixelRatio,
            y: 0.5 * this.frame.canvas.height / pixelRatio
          });
        }
      }

      /**
       * Set the cameraState
       * @private
       */

    }, {
      key: '_setCameraState',
      value: function _setCameraState() {
        if (this.cameraState.scale !== undefined && this.frame.canvas.clientWidth !== 0 && this.frame.canvas.clientHeight !== 0 && this.pixelRatio !== 0 && this.cameraState.previousWidth > 0) {

          var widthRatio = this.frame.canvas.width / this.pixelRatio / this.cameraState.previousWidth;
          var heightRatio = this.frame.canvas.height / this.pixelRatio / this.cameraState.previousHeight;
          var newScale = this.cameraState.scale;

          if (widthRatio != 1 && heightRatio != 1) {
            newScale = this.cameraState.scale * 0.5 * (widthRatio + heightRatio);
          } else if (widthRatio != 1) {
            newScale = this.cameraState.scale * widthRatio;
          } else if (heightRatio != 1) {
            newScale = this.cameraState.scale * heightRatio;
          }

          this.body.view.scale = newScale;
          // this comes from the view module.
          var currentViewCenter = this.DOMtoCanvas({
            x: 0.5 * this.frame.canvas.clientWidth,
            y: 0.5 * this.frame.canvas.clientHeight
          });

          var distanceFromCenter = { // offset from view, distance view has to change by these x and y to center the node
            x: currentViewCenter.x - this.cameraState.position.x,
            y: currentViewCenter.y - this.cameraState.position.y
          };
          this.body.view.translation.x += distanceFromCenter.x * this.body.view.scale;
          this.body.view.translation.y += distanceFromCenter.y * this.body.view.scale;
        }
      }
    }, {
      key: '_prepareValue',
      value: function _prepareValue(value) {
        if (typeof value === 'number') {
          return value + 'px';
        } else if (typeof value === 'string') {
          if (value.indexOf('%') !== -1 || value.indexOf('px') !== -1) {
            return value;
          } else if (value.indexOf('%') === -1) {
            return value + 'px';
          }
        }
        throw new Error('Could not use the value supplied for width or height:' + value);
      }

      /**
       * Create the HTML
       */

    }, {
      key: '_create',
      value: function _create() {
        // remove all elements from the container element.
        while (this.body.container.hasChildNodes()) {
          this.body.container.removeChild(this.body.container.firstChild);
        }

        this.frame = document.createElement('div');
        this.frame.className = 'vis-network';
        this.frame.style.position = 'relative';
        this.frame.style.overflow = 'hidden';
        this.frame.tabIndex = 900; // tab index is required for keycharm to bind keystrokes to the div instead of the window

        //////////////////////////////////////////////////////////////////

        this.frame.canvas = document.createElement("canvas");
        this.frame.canvas.style.position = 'relative';
        this.frame.appendChild(this.frame.canvas);

        if (!this.frame.canvas.getContext) {
          var noCanvas = document.createElement('DIV');
          noCanvas.style.color = 'red';
          noCanvas.style.fontWeight = 'bold';
          noCanvas.style.padding = '10px';
          noCanvas.innerHTML = 'Error: your browser does not support HTML canvas';
          this.frame.canvas.appendChild(noCanvas);
        } else {
          var ctx = this.frame.canvas.getContext("2d");
          this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);

          this.frame.canvas.getContext("2d").setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
        }

        // add the frame to the container element
        this.body.container.appendChild(this.frame);

        this.body.view.scale = 1;
        this.body.view.translation = { x: 0.5 * this.frame.canvas.clientWidth, y: 0.5 * this.frame.canvas.clientHeight };

        this._bindHammer();
      }

      /**
       * This function binds hammer, it can be repeated over and over due to the uniqueness check.
       * @private
       */

    }, {
      key: '_bindHammer',
      value: function _bindHammer() {
        var _this3 = this;

        if (this.hammer !== undefined) {
          this.hammer.destroy();
        }
        this.drag = {};
        this.pinch = {};

        // init hammer
        this.hammer = new Hammer(this.frame.canvas);
        this.hammer.get('pinch').set({ enable: true });
        // enable to get better response, todo: test on mobile.
        this.hammer.get('pan').set({ threshold: 5, direction: Hammer.DIRECTION_ALL });

        hammerUtil.onTouch(this.hammer, function (event) {
          _this3.body.eventListeners.onTouch(event);
        });
        this.hammer.on('tap', function (event) {
          _this3.body.eventListeners.onTap(event);
        });
        this.hammer.on('doubletap', function (event) {
          _this3.body.eventListeners.onDoubleTap(event);
        });
        this.hammer.on('press', function (event) {
          _this3.body.eventListeners.onHold(event);
        });
        this.hammer.on('panstart', function (event) {
          _this3.body.eventListeners.onDragStart(event);
        });
        this.hammer.on('panmove', function (event) {
          _this3.body.eventListeners.onDrag(event);
        });
        this.hammer.on('panend', function (event) {
          _this3.body.eventListeners.onDragEnd(event);
        });
        this.hammer.on('pinch', function (event) {
          _this3.body.eventListeners.onPinch(event);
        });

        // TODO: neatly cleanup these handlers when re-creating the Canvas, IF these are done with hammer, event.stopPropagation will not work?
        this.frame.canvas.addEventListener('mousewheel', function (event) {
          _this3.body.eventListeners.onMouseWheel(event);
        });
        this.frame.canvas.addEventListener('DOMMouseScroll', function (event) {
          _this3.body.eventListeners.onMouseWheel(event);
        });

        this.frame.canvas.addEventListener('mousemove', function (event) {
          _this3.body.eventListeners.onMouseMove(event);
        });
        this.frame.canvas.addEventListener('contextmenu', function (event) {
          _this3.body.eventListeners.onContext(event);
        });

        this.hammerFrame = new Hammer(this.frame);
        hammerUtil.onRelease(this.hammerFrame, function (event) {
          _this3.body.eventListeners.onRelease(event);
        });
      }

      /**
       * Set a new size for the network
       * @param {string} width   Width in pixels or percentage (for example '800px'
       *                         or '50%')
       * @param {string} height  Height in pixels or percentage  (for example '400px'
       *                         or '30%')
       */

    }, {
      key: 'setSize',
      value: function setSize() {
        var width = arguments.length <= 0 || arguments[0] === undefined ? this.options.width : arguments[0];
        var height = arguments.length <= 1 || arguments[1] === undefined ? this.options.height : arguments[1];

        width = this._prepareValue(width);
        height = this._prepareValue(height);

        var emitEvent = false;
        var oldWidth = this.frame.canvas.width;
        var oldHeight = this.frame.canvas.height;

        // update the pixel ratio
        var ctx = this.frame.canvas.getContext("2d");
        var previousRatio = this.pixelRatio; // we cache this because the camera state storage needs the old value
        this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);

        if (width != this.options.width || height != this.options.height || this.frame.style.width != width || this.frame.style.height != height) {
          this._getCameraState(previousRatio);

          this.frame.style.width = width;
          this.frame.style.height = height;

          this.frame.canvas.style.width = '100%';
          this.frame.canvas.style.height = '100%';

          this.frame.canvas.width = Math.round(this.frame.canvas.clientWidth * this.pixelRatio);
          this.frame.canvas.height = Math.round(this.frame.canvas.clientHeight * this.pixelRatio);

          this.options.width = width;
          this.options.height = height;

          emitEvent = true;
        } else {
          // this would adapt the width of the canvas to the width from 100% if and only if
          // there is a change.

          // store the camera if there is a change in size.
          if (this.frame.canvas.width != Math.round(this.frame.canvas.clientWidth * this.pixelRatio) || this.frame.canvas.height != Math.round(this.frame.canvas.clientHeight * this.pixelRatio)) {
            this._getCameraState(previousRatio);
          }

          if (this.frame.canvas.width != Math.round(this.frame.canvas.clientWidth * this.pixelRatio)) {
            this.frame.canvas.width = Math.round(this.frame.canvas.clientWidth * this.pixelRatio);
            emitEvent = true;
          }
          if (this.frame.canvas.height != Math.round(this.frame.canvas.clientHeight * this.pixelRatio)) {
            this.frame.canvas.height = Math.round(this.frame.canvas.clientHeight * this.pixelRatio);
            emitEvent = true;
          }
        }

        if (emitEvent === true) {
          this.body.emitter.emit('resize', {
            width: Math.round(this.frame.canvas.width / this.pixelRatio),
            height: Math.round(this.frame.canvas.height / this.pixelRatio),
            oldWidth: Math.round(oldWidth / this.pixelRatio),
            oldHeight: Math.round(oldHeight / this.pixelRatio)
          });

          // restore the camera on change.
          this._setCameraState();
        }

        // set initialized so the get and set camera will work from now on.
        this.initialized = true;
        return emitEvent;
      }
    }, {
      key: '_XconvertDOMtoCanvas',


      /**
       * Convert the X coordinate in DOM-space (coordinate point in browser relative to the container div) to
       * the X coordinate in canvas-space (the simulation sandbox, which the camera looks upon)
       * @param {number} x
       * @returns {number}
       * @private
       */
      value: function _XconvertDOMtoCanvas(x) {
        return (x - this.body.view.translation.x) / this.body.view.scale;
      }

      /**
       * Convert the X coordinate in canvas-space (the simulation sandbox, which the camera looks upon) to
       * the X coordinate in DOM-space (coordinate point in browser relative to the container div)
       * @param {number} x
       * @returns {number}
       * @private
       */

    }, {
      key: '_XconvertCanvasToDOM',
      value: function _XconvertCanvasToDOM(x) {
        return x * this.body.view.scale + this.body.view.translation.x;
      }

      /**
       * Convert the Y coordinate in DOM-space (coordinate point in browser relative to the container div) to
       * the Y coordinate in canvas-space (the simulation sandbox, which the camera looks upon)
       * @param {number} y
       * @returns {number}
       * @private
       */

    }, {
      key: '_YconvertDOMtoCanvas',
      value: function _YconvertDOMtoCanvas(y) {
        return (y - this.body.view.translation.y) / this.body.view.scale;
      }

      /**
       * Convert the Y coordinate in canvas-space (the simulation sandbox, which the camera looks upon) to
       * the Y coordinate in DOM-space (coordinate point in browser relative to the container div)
       * @param {number} y
       * @returns {number}
       * @private
       */

    }, {
      key: '_YconvertCanvasToDOM',
      value: function _YconvertCanvasToDOM(y) {
        return y * this.body.view.scale + this.body.view.translation.y;
      }

      /**
       *
       * @param {object} pos   = {x: number, y: number}
       * @returns {{x: number, y: number}}
       * @constructor
       */

    }, {
      key: 'canvasToDOM',
      value: function canvasToDOM(pos) {
        return { x: this._XconvertCanvasToDOM(pos.x), y: this._YconvertCanvasToDOM(pos.y) };
      }

      /**
       *
       * @param {object} pos   = {x: number, y: number}
       * @returns {{x: number, y: number}}
       * @constructor
       */

    }, {
      key: 'DOMtoCanvas',
      value: function DOMtoCanvas(pos) {
        return { x: this._XconvertDOMtoCanvas(pos.x), y: this._YconvertDOMtoCanvas(pos.y) };
      }
    }]);

    return Canvas;
  }();

  exports.default = Canvas;

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _NetworkUtil = __webpack_require__(103);

  var _NetworkUtil2 = _interopRequireDefault(_NetworkUtil);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);

  var View = function () {
    function View(body, canvas) {
      var _this = this;

      _classCallCheck(this, View);

      this.body = body;
      this.canvas = canvas;

      this.animationSpeed = 1 / this.renderRefreshRate;
      this.animationEasingFunction = "easeInOutQuint";
      this.easingTime = 0;
      this.sourceScale = 0;
      this.targetScale = 0;
      this.sourceTranslation = 0;
      this.targetTranslation = 0;
      this.lockedOnNodeId = undefined;
      this.lockedOnNodeOffset = undefined;
      this.touchTime = 0;

      this.viewFunction = undefined;

      this.body.emitter.on("fit", this.fit.bind(this));
      this.body.emitter.on("animationFinished", function () {
        _this.body.emitter.emit("_stopRendering");
      });
      this.body.emitter.on("unlockNode", this.releaseNode.bind(this));
    }

    _createClass(View, [{
      key: 'setOptions',
      value: function setOptions() {
        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

        this.options = options;
      }

      /**
       * This function zooms out to fit all data on screen based on amount of nodes
       * @param {Object} Options
       * @param {Boolean} [initialZoom]  | zoom based on fitted formula or range, true = fitted, default = false;
       */

    }, {
      key: 'fit',
      value: function fit() {
        var options = arguments.length <= 0 || arguments[0] === undefined ? { nodes: [] } : arguments[0];
        var initialZoom = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

        var range = void 0;
        var zoomLevel = void 0;
        if (options.nodes === undefined || options.nodes.length === 0) {
          options.nodes = this.body.nodeIndices;
        }

        if (initialZoom === true) {
          // check if more than half of the nodes have a predefined position. If so, we use the range, not the approximation.
          var positionDefined = 0;
          for (var nodeId in this.body.nodes) {
            if (this.body.nodes.hasOwnProperty(nodeId)) {
              var node = this.body.nodes[nodeId];
              if (node.predefinedPosition === true) {
                positionDefined += 1;
              }
            }
          }
          if (positionDefined > 0.5 * this.body.nodeIndices.length) {
            this.fit(options, false);
            return;
          }

          range = _NetworkUtil2.default.getRange(this.body.nodes, options.nodes);

          var numberOfNodes = this.body.nodeIndices.length;
          zoomLevel = 12.662 / (numberOfNodes + 7.4147) + 0.0964822; // this is obtained from fitting a dataset from 5 points with scale levels that looked good.

          // correct for larger canvasses.
          var factor = Math.min(this.canvas.frame.canvas.clientWidth / 600, this.canvas.frame.canvas.clientHeight / 600);
          zoomLevel *= factor;
        } else {
          this.body.emitter.emit("_resizeNodes");
          range = _NetworkUtil2.default.getRange(this.body.nodes, options.nodes);

          var xDistance = Math.abs(range.maxX - range.minX) * 1.1;
          var yDistance = Math.abs(range.maxY - range.minY) * 1.1;

          var xZoomLevel = this.canvas.frame.canvas.clientWidth / xDistance;
          var yZoomLevel = this.canvas.frame.canvas.clientHeight / yDistance;

          zoomLevel = xZoomLevel <= yZoomLevel ? xZoomLevel : yZoomLevel;
        }

        if (zoomLevel > 1.0) {
          zoomLevel = 1.0;
        } else if (zoomLevel === 0) {
          zoomLevel = 1.0;
        }

        var center = _NetworkUtil2.default.findCenter(range);
        var animationOptions = { position: center, scale: zoomLevel, animation: options.animation };
        this.moveTo(animationOptions);
      }

      // animation

      /**
       * Center a node in view.
       *
       * @param {Number} nodeId
       * @param {Number} [options]
       */

    }, {
      key: 'focus',
      value: function focus(nodeId) {
        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        if (this.body.nodes[nodeId] !== undefined) {
          var nodePosition = { x: this.body.nodes[nodeId].x, y: this.body.nodes[nodeId].y };
          options.position = nodePosition;
          options.lockedOnNode = nodeId;

          this.moveTo(options);
        } else {
          console.log("Node: " + nodeId + " cannot be found.");
        }
      }

      /**
       *
       * @param {Object} options  |  options.offset   = {x:Number, y:Number}   // offset from the center in DOM pixels
       *                          |  options.scale    = Number                 // scale to move to
       *                          |  options.position = {x:Number, y:Number}   // position to move to
       *                          |  options.animation = {duration:Number, easingFunction:String} || Boolean   // position to move to
       */

    }, {
      key: 'moveTo',
      value: function moveTo(options) {
        if (options === undefined) {
          options = {};
          return;
        }
        if (options.offset === undefined) {
          options.offset = { x: 0, y: 0 };
        }
        if (options.offset.x === undefined) {
          options.offset.x = 0;
        }
        if (options.offset.y === undefined) {
          options.offset.y = 0;
        }
        if (options.scale === undefined) {
          options.scale = this.body.view.scale;
        }
        if (options.position === undefined) {
          options.position = this.getViewPosition();
        }
        if (options.animation === undefined) {
          options.animation = { duration: 0 };
        }
        if (options.animation === false) {
          options.animation = { duration: 0 };
        }
        if (options.animation === true) {
          options.animation = {};
        }
        if (options.animation.duration === undefined) {
          options.animation.duration = 1000;
        } // default duration
        if (options.animation.easingFunction === undefined) {
          options.animation.easingFunction = "easeInOutQuad";
        } // default easing function

        this.animateView(options);
      }

      /**
       *
       * @param {Object} options  |  options.offset   = {x:Number, y:Number}   // offset from the center in DOM pixels
       *                          |  options.time     = Number                 // animation time in milliseconds
       *                          |  options.scale    = Number                 // scale to animate to
       *                          |  options.position = {x:Number, y:Number}   // position to animate to
       *                          |  options.easingFunction = String           // linear, easeInQuad, easeOutQuad, easeInOutQuad,
       *                                                                       // easeInCubic, easeOutCubic, easeInOutCubic,
       *                                                                       // easeInQuart, easeOutQuart, easeInOutQuart,
       *                                                                       // easeInQuint, easeOutQuint, easeInOutQuint
       */

    }, {
      key: 'animateView',
      value: function animateView(options) {
        if (options === undefined) {
          return;
        }
        this.animationEasingFunction = options.animation.easingFunction;
        // release if something focussed on the node
        this.releaseNode();
        if (options.locked === true) {
          this.lockedOnNodeId = options.lockedOnNode;
          this.lockedOnNodeOffset = options.offset;
        }

        // forcefully complete the old animation if it was still running
        if (this.easingTime != 0) {
          this._transitionRedraw(true); // by setting easingtime to 1, we finish the animation.
        }

        this.sourceScale = this.body.view.scale;
        this.sourceTranslation = this.body.view.translation;
        this.targetScale = options.scale;

        // set the scale so the viewCenter is based on the correct zoom level. This is overridden in the transitionRedraw
        // but at least then we'll have the target transition
        this.body.view.scale = this.targetScale;
        var viewCenter = this.canvas.DOMtoCanvas({ x: 0.5 * this.canvas.frame.canvas.clientWidth, y: 0.5 * this.canvas.frame.canvas.clientHeight });

        var distanceFromCenter = { // offset from view, distance view has to change by these x and y to center the node
          x: viewCenter.x - options.position.x,
          y: viewCenter.y - options.position.y
        };
        this.targetTranslation = {
          x: this.sourceTranslation.x + distanceFromCenter.x * this.targetScale + options.offset.x,
          y: this.sourceTranslation.y + distanceFromCenter.y * this.targetScale + options.offset.y
        };

        // if the time is set to 0, don't do an animation
        if (options.animation.duration === 0) {
          if (this.lockedOnNodeId != undefined) {
            this.viewFunction = this._lockedRedraw.bind(this);
            this.body.emitter.on("initRedraw", this.viewFunction);
          } else {
            this.body.view.scale = this.targetScale;
            this.body.view.translation = this.targetTranslation;
            this.body.emitter.emit("_requestRedraw");
          }
        } else {
          this.animationSpeed = 1 / (60 * options.animation.duration * 0.001) || 1 / 60; // 60 for 60 seconds, 0.001 for milli's
          this.animationEasingFunction = options.animation.easingFunction;

          this.viewFunction = this._transitionRedraw.bind(this);
          this.body.emitter.on("initRedraw", this.viewFunction);
          this.body.emitter.emit("_startRendering");
        }
      }

      /**
       * used to animate smoothly by hijacking the redraw function.
       * @private
       */

    }, {
      key: '_lockedRedraw',
      value: function _lockedRedraw() {
        var nodePosition = { x: this.body.nodes[this.lockedOnNodeId].x, y: this.body.nodes[this.lockedOnNodeId].y };
        var viewCenter = this.canvas.DOMtoCanvas({ x: 0.5 * this.canvas.frame.canvas.clientWidth, y: 0.5 * this.canvas.frame.canvas.clientHeight });
        var distanceFromCenter = { // offset from view, distance view has to change by these x and y to center the node
          x: viewCenter.x - nodePosition.x,
          y: viewCenter.y - nodePosition.y
        };
        var sourceTranslation = this.body.view.translation;
        var targetTranslation = {
          x: sourceTranslation.x + distanceFromCenter.x * this.body.view.scale + this.lockedOnNodeOffset.x,
          y: sourceTranslation.y + distanceFromCenter.y * this.body.view.scale + this.lockedOnNodeOffset.y
        };

        this.body.view.translation = targetTranslation;
      }
    }, {
      key: 'releaseNode',
      value: function releaseNode() {
        if (this.lockedOnNodeId !== undefined && this.viewFunction !== undefined) {
          this.body.emitter.off("initRedraw", this.viewFunction);
          this.lockedOnNodeId = undefined;
          this.lockedOnNodeOffset = undefined;
        }
      }

      /**
       *
       * @param easingTime
       * @private
       */

    }, {
      key: '_transitionRedraw',
      value: function _transitionRedraw() {
        var finished = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];

        this.easingTime += this.animationSpeed;
        this.easingTime = finished === true ? 1.0 : this.easingTime;

        var progress = util.easingFunctions[this.animationEasingFunction](this.easingTime);

        this.body.view.scale = this.sourceScale + (this.targetScale - this.sourceScale) * progress;
        this.body.view.translation = {
          x: this.sourceTranslation.x + (this.targetTranslation.x - this.sourceTranslation.x) * progress,
          y: this.sourceTranslation.y + (this.targetTranslation.y - this.sourceTranslation.y) * progress
        };

        // cleanup
        if (this.easingTime >= 1.0) {
          this.body.emitter.off("initRedraw", this.viewFunction);
          this.easingTime = 0;
          if (this.lockedOnNodeId != undefined) {
            this.viewFunction = this._lockedRedraw.bind(this);
            this.body.emitter.on("initRedraw", this.viewFunction);
          }
          this.body.emitter.emit("animationFinished");
        }
      }
    }, {
      key: 'getScale',
      value: function getScale() {
        return this.body.view.scale;
      }
    }, {
      key: 'getViewPosition',
      value: function getViewPosition() {
        return this.canvas.DOMtoCanvas({ x: 0.5 * this.canvas.frame.canvas.clientWidth, y: 0.5 * this.canvas.frame.canvas.clientHeight });
      }
    }]);

    return View;
  }();

  exports.default = View;

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _NavigationHandler = __webpack_require__(109);

  var _NavigationHandler2 = _interopRequireDefault(_NavigationHandler);

  var _Popup = __webpack_require__(110);

  var _Popup2 = _interopRequireDefault(_Popup);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);

  var InteractionHandler = function () {
    function InteractionHandler(body, canvas, selectionHandler) {
      _classCallCheck(this, InteractionHandler);

      this.body = body;
      this.canvas = canvas;
      this.selectionHandler = selectionHandler;
      this.navigationHandler = new _NavigationHandler2.default(body, canvas);

      // bind the events from hammer to functions in this object
      this.body.eventListeners.onTap = this.onTap.bind(this);
      this.body.eventListeners.onTouch = this.onTouch.bind(this);
      this.body.eventListeners.onDoubleTap = this.onDoubleTap.bind(this);
      this.body.eventListeners.onHold = this.onHold.bind(this);
      this.body.eventListeners.onDragStart = this.onDragStart.bind(this);
      this.body.eventListeners.onDrag = this.onDrag.bind(this);
      this.body.eventListeners.onDragEnd = this.onDragEnd.bind(this);
      this.body.eventListeners.onMouseWheel = this.onMouseWheel.bind(this);
      this.body.eventListeners.onPinch = this.onPinch.bind(this);
      this.body.eventListeners.onMouseMove = this.onMouseMove.bind(this);
      this.body.eventListeners.onRelease = this.onRelease.bind(this);
      this.body.eventListeners.onContext = this.onContext.bind(this);

      this.touchTime = 0;
      this.drag = {};
      this.pinch = {};
      this.popup = undefined;
      this.popupObj = undefined;
      this.popupTimer = undefined;

      this.body.functions.getPointer = this.getPointer.bind(this);

      this.options = {};
      this.defaultOptions = {
        dragNodes: true,
        dragView: true,
        hover: false,
        keyboard: {
          enabled: false,
          speed: { x: 10, y: 10, zoom: 0.02 },
          bindToWindow: true
        },
        navigationButtons: false,
        tooltipDelay: 300,
        zoomView: true
      };
      util.extend(this.options, this.defaultOptions);

      this.bindEventListeners();
    }

    _createClass(InteractionHandler, [{
      key: 'bindEventListeners',
      value: function bindEventListeners() {
        var _this = this;

        this.body.emitter.on('destroy', function () {
          clearTimeout(_this.popupTimer);
          delete _this.body.functions.getPointer;
        });
      }
    }, {
      key: 'setOptions',
      value: function setOptions(options) {
        if (options !== undefined) {
          // extend all but the values in fields
          var fields = ['hideEdgesOnDrag', 'hideNodesOnDrag', 'keyboard', 'multiselect', 'selectable', 'selectConnectedEdges'];
          util.selectiveNotDeepExtend(fields, this.options, options);

          // merge the keyboard options in.
          util.mergeOptions(this.options, options, 'keyboard');

          if (options.tooltip) {
            util.extend(this.options.tooltip, options.tooltip);
            if (options.tooltip.color) {
              this.options.tooltip.color = util.parseColor(options.tooltip.color);
            }
          }
        }

        this.navigationHandler.setOptions(this.options);
      }

      /**
       * Get the pointer location from a touch location
       * @param {{x: Number, y: Number}} touch
       * @return {{x: Number, y: Number}} pointer
       * @private
       */

    }, {
      key: 'getPointer',
      value: function getPointer(touch) {
        return {
          x: touch.x - util.getAbsoluteLeft(this.canvas.frame.canvas),
          y: touch.y - util.getAbsoluteTop(this.canvas.frame.canvas)
        };
      }

      /**
       * On start of a touch gesture, store the pointer
       * @param event
       * @private
       */

    }, {
      key: 'onTouch',
      value: function onTouch(event) {
        if (new Date().valueOf() - this.touchTime > 50) {
          this.drag.pointer = this.getPointer(event.center);
          this.drag.pinched = false;
          this.pinch.scale = this.body.view.scale;
          // to avoid double fireing of this event because we have two hammer instances. (on canvas and on frame)
          this.touchTime = new Date().valueOf();
        }
      }

      /**
       * handle tap/click event: select/unselect a node
       * @private
       */

    }, {
      key: 'onTap',
      value: function onTap(event) {
        var pointer = this.getPointer(event.center);
        var multiselect = this.selectionHandler.options.multiselect && (event.changedPointers[0].ctrlKey || event.changedPointers[0].metaKey);

        this.checkSelectionChanges(pointer, event, multiselect);
        this.selectionHandler._generateClickEvent('click', event, pointer);
      }

      /**
       * handle doubletap event
       * @private
       */

    }, {
      key: 'onDoubleTap',
      value: function onDoubleTap(event) {
        var pointer = this.getPointer(event.center);
        this.selectionHandler._generateClickEvent('doubleClick', event, pointer);
      }

      /**
       * handle long tap event: multi select nodes
       * @private
       */

    }, {
      key: 'onHold',
      value: function onHold(event) {
        var pointer = this.getPointer(event.center);
        var multiselect = this.selectionHandler.options.multiselect;

        this.checkSelectionChanges(pointer, event, multiselect);

        this.selectionHandler._generateClickEvent('click', event, pointer);
        this.selectionHandler._generateClickEvent('hold', event, pointer);
      }

      /**
       * handle the release of the screen
       *
       * @private
       */

    }, {
      key: 'onRelease',
      value: function onRelease(event) {
        if (new Date().valueOf() - this.touchTime > 10) {
          var pointer = this.getPointer(event.center);
          this.selectionHandler._generateClickEvent('release', event, pointer);
          // to avoid double fireing of this event because we have two hammer instances. (on canvas and on frame)
          this.touchTime = new Date().valueOf();
        }
      }
    }, {
      key: 'onContext',
      value: function onContext(event) {
        var pointer = this.getPointer({ x: event.clientX, y: event.clientY });
        this.selectionHandler._generateClickEvent('oncontext', event, pointer);
      }

      /**
       *
       * @param pointer
       * @param add
       */

    }, {
      key: 'checkSelectionChanges',
      value: function checkSelectionChanges(pointer, event) {
        var add = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

        var previouslySelectedEdgeCount = this.selectionHandler._getSelectedEdgeCount();
        var previouslySelectedNodeCount = this.selectionHandler._getSelectedNodeCount();
        var previousSelection = this.selectionHandler.getSelection();
        var selected = void 0;
        if (add === true) {
          selected = this.selectionHandler.selectAdditionalOnPoint(pointer);
        } else {
          selected = this.selectionHandler.selectOnPoint(pointer);
        }
        var selectedEdgesCount = this.selectionHandler._getSelectedEdgeCount();
        var selectedNodesCount = this.selectionHandler._getSelectedNodeCount();
        var currentSelection = this.selectionHandler.getSelection();

        var _determineIfDifferent2 = this._determineIfDifferent(previousSelection, currentSelection);

        var nodesChanged = _determineIfDifferent2.nodesChanged;
        var edgesChanged = _determineIfDifferent2.edgesChanged;

        var nodeSelected = false;

        if (selectedNodesCount - previouslySelectedNodeCount > 0) {
          // node was selected
          this.selectionHandler._generateClickEvent('selectNode', event, pointer);
          selected = true;
          nodeSelected = true;
        } else if (nodesChanged === true && selectedNodesCount > 0) {
          this.selectionHandler._generateClickEvent('deselectNode', event, pointer, previousSelection);
          this.selectionHandler._generateClickEvent('selectNode', event, pointer);
          nodeSelected = true;
          selected = true;
        } else if (selectedNodesCount - previouslySelectedNodeCount < 0) {
          // node was deselected
          this.selectionHandler._generateClickEvent('deselectNode', event, pointer, previousSelection);
          selected = true;
        }

        // handle the selected edges
        if (selectedEdgesCount - previouslySelectedEdgeCount > 0 && nodeSelected === false) {
          // edge was selected
          this.selectionHandler._generateClickEvent('selectEdge', event, pointer);
          selected = true;
        } else if (selectedEdgesCount > 0 && edgesChanged === true) {
          this.selectionHandler._generateClickEvent('deselectEdge', event, pointer, previousSelection);
          this.selectionHandler._generateClickEvent('selectEdge', event, pointer);
          selected = true;
        } else if (selectedEdgesCount - previouslySelectedEdgeCount < 0) {
          // edge was deselected
          this.selectionHandler._generateClickEvent('deselectEdge', event, pointer, previousSelection);
          selected = true;
        }

        // fire the select event if anything has been selected or deselected
        if (selected === true) {
          // select or unselect
          this.selectionHandler._generateClickEvent('select', event, pointer);
        }
      }

      /**
       * This function checks if the nodes and edges previously selected have changed.
       * @param previousSelection
       * @param currentSelection
       * @returns {{nodesChanged: boolean, edgesChanged: boolean}}
       * @private
       */

    }, {
      key: '_determineIfDifferent',
      value: function _determineIfDifferent(previousSelection, currentSelection) {
        var nodesChanged = false;
        var edgesChanged = false;

        for (var i = 0; i < previousSelection.nodes.length; i++) {
          if (currentSelection.nodes.indexOf(previousSelection.nodes[i]) === -1) {
            nodesChanged = true;
          }
        }
        for (var _i = 0; _i < currentSelection.nodes.length; _i++) {
          if (previousSelection.nodes.indexOf(previousSelection.nodes[_i]) === -1) {
            nodesChanged = true;
          }
        }
        for (var _i2 = 0; _i2 < previousSelection.edges.length; _i2++) {
          if (currentSelection.edges.indexOf(previousSelection.edges[_i2]) === -1) {
            edgesChanged = true;
          }
        }
        for (var _i3 = 0; _i3 < currentSelection.edges.length; _i3++) {
          if (previousSelection.edges.indexOf(previousSelection.edges[_i3]) === -1) {
            edgesChanged = true;
          }
        }

        return { nodesChanged: nodesChanged, edgesChanged: edgesChanged };
      }

      /**
       * This function is called by onDragStart.
       * It is separated out because we can then overload it for the datamanipulation system.
       *
       * @private
       */

    }, {
      key: 'onDragStart',
      value: function onDragStart(event) {
        //in case the touch event was triggered on an external div, do the initial touch now.
        if (this.drag.pointer === undefined) {
          this.onTouch(event);
        }

        // note: drag.pointer is set in onTouch to get the initial touch location
        var node = this.selectionHandler.getNodeAt(this.drag.pointer);

        this.drag.dragging = true;
        this.drag.selection = [];
        this.drag.translation = util.extend({}, this.body.view.translation); // copy the object
        this.drag.nodeId = undefined;

        if (node !== undefined && this.options.dragNodes === true) {
          this.drag.nodeId = node.id;
          // select the clicked node if not yet selected
          if (node.isSelected() === false) {
            this.selectionHandler.unselectAll();
            this.selectionHandler.selectObject(node);
          }

          // after select to contain the node
          this.selectionHandler._generateClickEvent('dragStart', event, this.drag.pointer);

          var selection = this.selectionHandler.selectionObj.nodes;
          // create an array with the selected nodes and their original location and status
          for (var nodeId in selection) {
            if (selection.hasOwnProperty(nodeId)) {
              var object = selection[nodeId];
              var s = {
                id: object.id,
                node: object,

                // store original x, y, xFixed and yFixed, make the node temporarily Fixed
                x: object.x,
                y: object.y,
                xFixed: object.options.fixed.x,
                yFixed: object.options.fixed.y
              };

              object.options.fixed.x = true;
              object.options.fixed.y = true;

              this.drag.selection.push(s);
            }
          }
        } else {
          // fallback if no node is selected and thus the view is dragged.
          this.selectionHandler._generateClickEvent('dragStart', event, this.drag.pointer, undefined, true);
        }
      }

      /**
       * handle drag event
       * @private
       */

    }, {
      key: 'onDrag',
      value: function onDrag(event) {
        var _this2 = this;

        if (this.drag.pinched === true) {
          return;
        }

        // remove the focus on node if it is focussed on by the focusOnNode
        this.body.emitter.emit('unlockNode');

        var pointer = this.getPointer(event.center);

        var selection = this.drag.selection;
        if (selection && selection.length && this.options.dragNodes === true) {
          (function () {
            _this2.selectionHandler._generateClickEvent('dragging', event, pointer);

            // calculate delta's and new location
            var deltaX = pointer.x - _this2.drag.pointer.x;
            var deltaY = pointer.y - _this2.drag.pointer.y;

            // update position of all selected nodes
            selection.forEach(function (selection) {
              var node = selection.node;
              // only move the node if it was not fixed initially
              if (selection.xFixed === false) {
                node.x = _this2.canvas._XconvertDOMtoCanvas(_this2.canvas._XconvertCanvasToDOM(selection.x) + deltaX);
              }
              // only move the node if it was not fixed initially
              if (selection.yFixed === false) {
                node.y = _this2.canvas._YconvertDOMtoCanvas(_this2.canvas._YconvertCanvasToDOM(selection.y) + deltaY);
              }
            });

            // start the simulation of the physics
            _this2.body.emitter.emit('startSimulation');
          })();
        } else {
          // move the network
          if (this.options.dragView === true) {
            this.selectionHandler._generateClickEvent('dragging', event, pointer, undefined, true);

            // if the drag was not started properly because the click started outside the network div, start it now.
            if (this.drag.pointer === undefined) {
              this.onDragStart(event);
              return;
            }
            var diffX = pointer.x - this.drag.pointer.x;
            var diffY = pointer.y - this.drag.pointer.y;

            this.body.view.translation = { x: this.drag.translation.x + diffX, y: this.drag.translation.y + diffY };
            this.body.emitter.emit('_redraw');
          }
        }
      }

      /**
       * handle drag start event
       * @private
       */

    }, {
      key: 'onDragEnd',
      value: function onDragEnd(event) {
        this.drag.dragging = false;
        var selection = this.drag.selection;
        if (selection && selection.length) {
          selection.forEach(function (s) {
            // restore original xFixed and yFixed
            s.node.options.fixed.x = s.xFixed;
            s.node.options.fixed.y = s.yFixed;
          });
          this.selectionHandler._generateClickEvent('dragEnd', event, this.getPointer(event.center));
          this.body.emitter.emit('startSimulation');
        } else {
          this.selectionHandler._generateClickEvent('dragEnd', event, this.getPointer(event.center), undefined, true);
          this.body.emitter.emit('_requestRedraw');
        }
      }

      /**
       * Handle pinch event
       * @param event
       * @private
       */

    }, {
      key: 'onPinch',
      value: function onPinch(event) {
        var pointer = this.getPointer(event.center);

        this.drag.pinched = true;
        if (this.pinch['scale'] === undefined) {
          this.pinch.scale = 1;
        }

        // TODO: enabled moving while pinching?
        var scale = this.pinch.scale * event.scale;
        this.zoom(scale, pointer);
      }

      /**
       * Zoom the network in or out
       * @param {Number} scale a number around 1, and between 0.01 and 10
       * @param {{x: Number, y: Number}} pointer    Position on screen
       * @return {Number} appliedScale    scale is limited within the boundaries
       * @private
       */

    }, {
      key: 'zoom',
      value: function zoom(scale, pointer) {
        if (this.options.zoomView === true) {
          var scaleOld = this.body.view.scale;
          if (scale < 0.00001) {
            scale = 0.00001;
          }
          if (scale > 10) {
            scale = 10;
          }

          var preScaleDragPointer = undefined;
          if (this.drag !== undefined) {
            if (this.drag.dragging === true) {
              preScaleDragPointer = this.canvas.DOMtoCanvas(this.drag.pointer);
            }
          }
          // + this.canvas.frame.canvas.clientHeight / 2
          var translation = this.body.view.translation;

          var scaleFrac = scale / scaleOld;
          var tx = (1 - scaleFrac) * pointer.x + translation.x * scaleFrac;
          var ty = (1 - scaleFrac) * pointer.y + translation.y * scaleFrac;

          this.body.view.scale = scale;
          this.body.view.translation = { x: tx, y: ty };

          if (preScaleDragPointer != undefined) {
            var postScaleDragPointer = this.canvas.canvasToDOM(preScaleDragPointer);
            this.drag.pointer.x = postScaleDragPointer.x;
            this.drag.pointer.y = postScaleDragPointer.y;
          }

          this.body.emitter.emit('_requestRedraw');

          if (scaleOld < scale) {
            this.body.emitter.emit('zoom', { direction: '+', scale: this.body.view.scale });
          } else {
            this.body.emitter.emit('zoom', { direction: '-', scale: this.body.view.scale });
          }
        }
      }

      /**
       * Event handler for mouse wheel event, used to zoom the timeline
       * See http://adomas.org/javascript-mouse-wheel/
       *     https://github.com/EightMedia/hammer.js/issues/256
       * @param {MouseEvent}  event
       * @private
       */

    }, {
      key: 'onMouseWheel',
      value: function onMouseWheel(event) {
        if (this.options.zoomView === true) {
          // retrieve delta
          var delta = 0;
          if (event.wheelDelta) {
            /* IE/Opera. */
            delta = event.wheelDelta / 120;
          } else if (event.detail) {
            /* Mozilla case. */
            // In Mozilla, sign of delta is different than in IE.
            // Also, delta is multiple of 3.
            delta = -event.detail / 3;
          }

          // If delta is nonzero, handle it.
          // Basically, delta is now positive if wheel was scrolled up,
          // and negative, if wheel was scrolled down.
          if (delta !== 0) {

            // calculate the new scale
            var scale = this.body.view.scale;
            var zoom = delta / 10;
            if (delta < 0) {
              zoom = zoom / (1 - zoom);
            }
            scale *= 1 + zoom;

            // calculate the pointer location
            var pointer = this.getPointer({ x: event.clientX, y: event.clientY });

            // apply the new scale
            this.zoom(scale, pointer);
          }

          // Prevent default actions caused by mouse wheel.
          event.preventDefault();
        }
      }

      /**
       * Mouse move handler for checking whether the title moves over a node with a title.
       * @param  {Event} event
       * @private
       */

    }, {
      key: 'onMouseMove',
      value: function onMouseMove(event) {
        var _this3 = this;

        var pointer = this.getPointer({ x: event.clientX, y: event.clientY });
        var popupVisible = false;

        // check if the previously selected node is still selected
        if (this.popup !== undefined) {
          if (this.popup.hidden === false) {
            this._checkHidePopup(pointer);
          }

          // if the popup was not hidden above
          if (this.popup.hidden === false) {
            popupVisible = true;
            this.popup.setPosition(pointer.x + 3, pointer.y - 5);
            this.popup.show();
          }
        }

        // if we bind the keyboard to the div, we have to highlight it to use it. This highlights it on mouse over.
        if (this.options.keyboard.bindToWindow === false && this.options.keyboard.enabled === true) {
          this.canvas.frame.focus();
        }

        // start a timeout that will check if the mouse is positioned above an element
        if (popupVisible === false) {
          if (this.popupTimer !== undefined) {
            clearInterval(this.popupTimer); // stop any running calculationTimer
            this.popupTimer = undefined;
          }
          if (!this.drag.dragging) {
            this.popupTimer = setTimeout(function () {
              return _this3._checkShowPopup(pointer);
            }, this.options.tooltipDelay);
          }
        }

        /**
        * Adding hover highlights
        */
        if (this.options.hover === true) {
          // adding hover highlights
          var obj = this.selectionHandler.getNodeAt(pointer);
          if (obj === undefined) {
            obj = this.selectionHandler.getEdgeAt(pointer);
          }
          this.selectionHandler.hoverObject(obj);
        }
      }

      /**
       * Check if there is an element on the given position in the network
       * (a node or edge). If so, and if this element has a title,
       * show a popup window with its title.
       *
       * @param {{x:Number, y:Number}} pointer
       * @private
       */

    }, {
      key: '_checkShowPopup',
      value: function _checkShowPopup(pointer) {
        var x = this.canvas._XconvertDOMtoCanvas(pointer.x);
        var y = this.canvas._YconvertDOMtoCanvas(pointer.y);
        var pointerObj = {
          left: x,
          top: y,
          right: x,
          bottom: y
        };

        var previousPopupObjId = this.popupObj === undefined ? undefined : this.popupObj.id;
        var nodeUnderCursor = false;
        var popupType = 'node';

        // check if a node is under the cursor.
        if (this.popupObj === undefined) {
          // search the nodes for overlap, select the top one in case of multiple nodes
          var nodeIndices = this.body.nodeIndices;
          var nodes = this.body.nodes;
          var node = void 0;
          var overlappingNodes = [];
          for (var i = 0; i < nodeIndices.length; i++) {
            node = nodes[nodeIndices[i]];
            if (node.isOverlappingWith(pointerObj) === true) {
              if (node.getTitle() !== undefined) {
                overlappingNodes.push(nodeIndices[i]);
              }
            }
          }

          if (overlappingNodes.length > 0) {
            // if there are overlapping nodes, select the last one, this is the one which is drawn on top of the others
            this.popupObj = nodes[overlappingNodes[overlappingNodes.length - 1]];
            // if you hover over a node, the title of the edge is not supposed to be shown.
            nodeUnderCursor = true;
          }
        }

        if (this.popupObj === undefined && nodeUnderCursor === false) {
          // search the edges for overlap
          var edgeIndices = this.body.edgeIndices;
          var edges = this.body.edges;
          var edge = void 0;
          var overlappingEdges = [];
          for (var _i4 = 0; _i4 < edgeIndices.length; _i4++) {
            edge = edges[edgeIndices[_i4]];
            if (edge.isOverlappingWith(pointerObj) === true) {
              if (edge.connected === true && edge.getTitle() !== undefined) {
                overlappingEdges.push(edgeIndices[_i4]);
              }
            }
          }

          if (overlappingEdges.length > 0) {
            this.popupObj = edges[overlappingEdges[overlappingEdges.length - 1]];
            popupType = 'edge';
          }
        }

        if (this.popupObj !== undefined) {
          // show popup message window
          if (this.popupObj.id !== previousPopupObjId) {
            if (this.popup === undefined) {
              this.popup = new _Popup2.default(this.canvas.frame);
            }

            this.popup.popupTargetType = popupType;
            this.popup.popupTargetId = this.popupObj.id;

            // adjust a small offset such that the mouse cursor is located in the
            // bottom left location of the popup, and you can easily move over the
            // popup area
            this.popup.setPosition(pointer.x + 3, pointer.y - 5);
            this.popup.setText(this.popupObj.getTitle());
            this.popup.show();
            this.body.emitter.emit('showPopup', this.popupObj.id);
          }
        } else {
          if (this.popup !== undefined) {
            this.popup.hide();
            this.body.emitter.emit('hidePopup');
          }
        }
      }

      /**
       * Check if the popup must be hidden, which is the case when the mouse is no
       * longer hovering on the object
       * @param {{x:Number, y:Number}} pointer
       * @private
       */

    }, {
      key: '_checkHidePopup',
      value: function _checkHidePopup(pointer) {
        var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);

        var stillOnObj = false;
        if (this.popup.popupTargetType === 'node') {
          if (this.body.nodes[this.popup.popupTargetId] !== undefined) {
            stillOnObj = this.body.nodes[this.popup.popupTargetId].isOverlappingWith(pointerObj);

            // if the mouse is still one the node, we have to check if it is not also on one that is drawn on top of it.
            // we initially only check stillOnObj because this is much faster.
            if (stillOnObj === true) {
              var overNode = this.selectionHandler.getNodeAt(pointer);
              stillOnObj = overNode.id === this.popup.popupTargetId;
            }
          }
        } else {
          if (this.selectionHandler.getNodeAt(pointer) === undefined) {
            if (this.body.edges[this.popup.popupTargetId] !== undefined) {
              stillOnObj = this.body.edges[this.popup.popupTargetId].isOverlappingWith(pointerObj);
            }
          }
        }

        if (stillOnObj === false) {
          this.popupObj = undefined;
          this.popup.hide();
          this.body.emitter.emit('hidePopup');
        }
      }
    }]);

    return InteractionHandler;
  }();

  exports.default = InteractionHandler;

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);
  var Hammer = __webpack_require__(20);
  var hammerUtil = __webpack_require__(28);
  var keycharm = __webpack_require__(23);

  var NavigationHandler = function () {
    function NavigationHandler(body, canvas) {
      var _this = this;

      _classCallCheck(this, NavigationHandler);

      this.body = body;
      this.canvas = canvas;

      this.iconsCreated = false;
      this.navigationHammers = [];
      this.boundFunctions = {};
      this.touchTime = 0;
      this.activated = false;

      this.body.emitter.on("activate", function () {
        _this.activated = true;_this.configureKeyboardBindings();
      });
      this.body.emitter.on("deactivate", function () {
        _this.activated = false;_this.configureKeyboardBindings();
      });
      this.body.emitter.on("destroy", function () {
        if (_this.keycharm !== undefined) {
          _this.keycharm.destroy();
        }
      });

      this.options = {};
    }

    _createClass(NavigationHandler, [{
      key: 'setOptions',
      value: function setOptions(options) {
        if (options !== undefined) {
          this.options = options;
          this.create();
        }
      }
    }, {
      key: 'create',
      value: function create() {
        if (this.options.navigationButtons === true) {
          if (this.iconsCreated === false) {
            this.loadNavigationElements();
          }
        } else if (this.iconsCreated === true) {
          this.cleanNavigation();
        }

        this.configureKeyboardBindings();
      }
    }, {
      key: 'cleanNavigation',
      value: function cleanNavigation() {
        // clean hammer bindings
        if (this.navigationHammers.length != 0) {
          for (var i = 0; i < this.navigationHammers.length; i++) {
            this.navigationHammers[i].destroy();
          }
          this.navigationHammers = [];
        }

        // clean up previous navigation items
        if (this.navigationDOM && this.navigationDOM['wrapper'] && this.navigationDOM['wrapper'].parentNode) {
          this.navigationDOM['wrapper'].parentNode.removeChild(this.navigationDOM['wrapper']);
        }

        this.iconsCreated = false;
      }

      /**
       * Creation of the navigation controls nodes. They are drawn over the rest of the nodes and are not affected by scale and translation
       * they have a triggerFunction which is called on click. If the position of the navigation controls is dependent
       * on this.frame.canvas.clientWidth or this.frame.canvas.clientHeight, we flag horizontalAlignLeft and verticalAlignTop false.
       * This means that the location will be corrected by the _relocateNavigation function on a size change of the canvas.
       *
       * @private
       */

    }, {
      key: 'loadNavigationElements',
      value: function loadNavigationElements() {
        var _this2 = this;

        this.cleanNavigation();

        this.navigationDOM = {};
        var navigationDivs = ['up', 'down', 'left', 'right', 'zoomIn', 'zoomOut', 'zoomExtends'];
        var navigationDivActions = ['_moveUp', '_moveDown', '_moveLeft', '_moveRight', '_zoomIn', '_zoomOut', '_fit'];

        this.navigationDOM['wrapper'] = document.createElement('div');
        this.navigationDOM['wrapper'].className = 'vis-navigation';
        this.canvas.frame.appendChild(this.navigationDOM['wrapper']);

        for (var i = 0; i < navigationDivs.length; i++) {
          this.navigationDOM[navigationDivs[i]] = document.createElement('div');
          this.navigationDOM[navigationDivs[i]].className = 'vis-button vis-' + navigationDivs[i];
          this.navigationDOM['wrapper'].appendChild(this.navigationDOM[navigationDivs[i]]);

          var hammer = new Hammer(this.navigationDOM[navigationDivs[i]]);
          if (navigationDivActions[i] === "_fit") {
            hammerUtil.onTouch(hammer, this._fit.bind(this));
          } else {
            hammerUtil.onTouch(hammer, this.bindToRedraw.bind(this, navigationDivActions[i]));
          }

          this.navigationHammers.push(hammer);
        }

        // use a hammer for the release so we do not require the one used in the rest of the network
        // the one the rest uses can be overloaded by the manipulation system.
        var hammerFrame = new Hammer(this.canvas.frame);
        hammerUtil.onRelease(hammerFrame, function () {
          _this2._stopMovement();
        });
        this.navigationHammers.push(hammerFrame);

        this.iconsCreated = true;
      }
    }, {
      key: 'bindToRedraw',
      value: function bindToRedraw(action) {
        if (this.boundFunctions[action] === undefined) {
          this.boundFunctions[action] = this[action].bind(this);
          this.body.emitter.on("initRedraw", this.boundFunctions[action]);
          this.body.emitter.emit("_startRendering");
        }
      }
    }, {
      key: 'unbindFromRedraw',
      value: function unbindFromRedraw(action) {
        if (this.boundFunctions[action] !== undefined) {
          this.body.emitter.off("initRedraw", this.boundFunctions[action]);
          this.body.emitter.emit("_stopRendering");
          delete this.boundFunctions[action];
        }
      }

      /**
       * this stops all movement induced by the navigation buttons
       *
       * @private
       */

    }, {
      key: '_fit',
      value: function _fit() {
        if (new Date().valueOf() - this.touchTime > 700) {
          // TODO: fix ugly hack to avoid hammer's double fireing of event (because we use release?)
          this.body.emitter.emit("fit", { duration: 700 });
          this.touchTime = new Date().valueOf();
        }
      }

      /**
       * this stops all movement induced by the navigation buttons
       *
       * @private
       */

    }, {
      key: '_stopMovement',
      value: function _stopMovement() {
        for (var boundAction in this.boundFunctions) {
          if (this.boundFunctions.hasOwnProperty(boundAction)) {
            this.body.emitter.off("initRedraw", this.boundFunctions[boundAction]);
            this.body.emitter.emit("_stopRendering");
          }
        }
        this.boundFunctions = {};
      }
    }, {
      key: '_moveUp',
      value: function _moveUp() {
        this.body.view.translation.y += this.options.keyboard.speed.y;
      }
    }, {
      key: '_moveDown',
      value: function _moveDown() {
        this.body.view.translation.y -= this.options.keyboard.speed.y;
      }
    }, {
      key: '_moveLeft',
      value: function _moveLeft() {
        this.body.view.translation.x += this.options.keyboard.speed.x;
      }
    }, {
      key: '_moveRight',
      value: function _moveRight() {
        this.body.view.translation.x -= this.options.keyboard.speed.x;
      }
    }, {
      key: '_zoomIn',
      value: function _zoomIn() {
        this.body.view.scale *= 1 + this.options.keyboard.speed.zoom;
        this.body.emitter.emit('zoom', { direction: '+', scale: this.body.view.scale });
      }
    }, {
      key: '_zoomOut',
      value: function _zoomOut() {
        this.body.view.scale /= 1 + this.options.keyboard.speed.zoom;
        this.body.emitter.emit('zoom', { direction: '-', scale: this.body.view.scale });
      }

      /**
       * bind all keys using keycharm.
       */

    }, {
      key: 'configureKeyboardBindings',
      value: function configureKeyboardBindings() {
        var _this3 = this;

        if (this.keycharm !== undefined) {
          this.keycharm.destroy();
        }

        if (this.options.keyboard.enabled === true) {
          if (this.options.keyboard.bindToWindow === true) {
            this.keycharm = keycharm({ container: window, preventDefault: true });
          } else {
            this.keycharm = keycharm({ container: this.canvas.frame, preventDefault: true });
          }

          this.keycharm.reset();

          if (this.activated === true) {
            this.keycharm.bind("up", function () {
              _this3.bindToRedraw("_moveUp");
            }, "keydown");
            this.keycharm.bind("down", function () {
              _this3.bindToRedraw("_moveDown");
            }, "keydown");
            this.keycharm.bind("left", function () {
              _this3.bindToRedraw("_moveLeft");
            }, "keydown");
            this.keycharm.bind("right", function () {
              _this3.bindToRedraw("_moveRight");
            }, "keydown");
            this.keycharm.bind("=", function () {
              _this3.bindToRedraw("_zoomIn");
            }, "keydown");
            this.keycharm.bind("num+", function () {
              _this3.bindToRedraw("_zoomIn");
            }, "keydown");
            this.keycharm.bind("num-", function () {
              _this3.bindToRedraw("_zoomOut");
            }, "keydown");
            this.keycharm.bind("-", function () {
              _this3.bindToRedraw("_zoomOut");
            }, "keydown");
            this.keycharm.bind("[", function () {
              _this3.bindToRedraw("_zoomOut");
            }, "keydown");
            this.keycharm.bind("]", function () {
              _this3.bindToRedraw("_zoomIn");
            }, "keydown");
            this.keycharm.bind("pageup", function () {
              _this3.bindToRedraw("_zoomIn");
            }, "keydown");
            this.keycharm.bind("pagedown", function () {
              _this3.bindToRedraw("_zoomOut");
            }, "keydown");

            this.keycharm.bind("up", function () {
              _this3.unbindFromRedraw("_moveUp");
            }, "keyup");
            this.keycharm.bind("down", function () {
              _this3.unbindFromRedraw("_moveDown");
            }, "keyup");
            this.keycharm.bind("left", function () {
              _this3.unbindFromRedraw("_moveLeft");
            }, "keyup");
            this.keycharm.bind("right", function () {
              _this3.unbindFromRedraw("_moveRight");
            }, "keyup");
            this.keycharm.bind("=", function () {
              _this3.unbindFromRedraw("_zoomIn");
            }, "keyup");
            this.keycharm.bind("num+", function () {
              _this3.unbindFromRedraw("_zoomIn");
            }, "keyup");
            this.keycharm.bind("num-", function () {
              _this3.unbindFromRedraw("_zoomOut");
            }, "keyup");
            this.keycharm.bind("-", function () {
              _this3.unbindFromRedraw("_zoomOut");
            }, "keyup");
            this.keycharm.bind("[", function () {
              _this3.unbindFromRedraw("_zoomOut");
            }, "keyup");
            this.keycharm.bind("]", function () {
              _this3.unbindFromRedraw("_zoomIn");
            }, "keyup");
            this.keycharm.bind("pageup", function () {
              _this3.unbindFromRedraw("_zoomIn");
            }, "keyup");
            this.keycharm.bind("pagedown", function () {
              _this3.unbindFromRedraw("_zoomOut");
            }, "keyup");
          }
        }
      }
    }]);

    return NavigationHandler;
  }();

  exports.default = NavigationHandler;

/***/ },
/* 110 */
/***/ function(module, exports) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  /**
   * Popup is a class to create a popup window with some text
   * @param {Element}  container     The container object.
   * @param {Number} [x]
   * @param {Number} [y]
   * @param {String} [text]
   * @param {Object} [style]     An object containing borderColor,
   *                             backgroundColor, etc.
   */

  var Popup = function () {
    function Popup(container) {
      _classCallCheck(this, Popup);

      this.container = container;

      this.x = 0;
      this.y = 0;
      this.padding = 5;
      this.hidden = false;

      // create the frame
      this.frame = document.createElement('div');
      this.frame.className = 'vis-network-tooltip';
      this.container.appendChild(this.frame);
    }

    /**
     * @param {number} x   Horizontal position of the popup window
     * @param {number} y   Vertical position of the popup window
     */


    _createClass(Popup, [{
      key: 'setPosition',
      value: function setPosition(x, y) {
        this.x = parseInt(x);
        this.y = parseInt(y);
      }

      /**
       * Set the content for the popup window. This can be HTML code or text.
       * @param {string | Element} content
       */

    }, {
      key: 'setText',
      value: function setText(content) {
        if (content instanceof Element) {
          this.frame.innerHTML = '';
          this.frame.appendChild(content);
        } else {
          this.frame.innerHTML = content; // string containing text or HTML
        }
      }

      /**
       * Show the popup window
       * @param {boolean} [doShow]    Show or hide the window
       */

    }, {
      key: 'show',
      value: function show(doShow) {
        if (doShow === undefined) {
          doShow = true;
        }

        if (doShow === true) {
          var height = this.frame.clientHeight;
          var width = this.frame.clientWidth;
          var maxHeight = this.frame.parentNode.clientHeight;
          var maxWidth = this.frame.parentNode.clientWidth;

          var top = this.y - height;
          if (top + height + this.padding > maxHeight) {
            top = maxHeight - height - this.padding;
          }
          if (top < this.padding) {
            top = this.padding;
          }

          var left = this.x;
          if (left + width + this.padding > maxWidth) {
            left = maxWidth - width - this.padding;
          }
          if (left < this.padding) {
            left = this.padding;
          }

          this.frame.style.left = left + "px";
          this.frame.style.top = top + "px";
          this.frame.style.visibility = "visible";
          this.hidden = false;
        } else {
          this.hide();
        }
      }

      /**
       * Hide the popup window
       */

    }, {
      key: 'hide',
      value: function hide() {
        this.hidden = true;
        this.frame.style.visibility = "hidden";
      }
    }]);

    return Popup;
  }();

  exports.default = Popup;

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _Node = __webpack_require__(65);

  var _Node2 = _interopRequireDefault(_Node);

  var _Edge = __webpack_require__(85);

  var _Edge2 = _interopRequireDefault(_Edge);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);

  var SelectionHandler = function () {
    function SelectionHandler(body, canvas) {
      var _this = this;

      _classCallCheck(this, SelectionHandler);

      this.body = body;
      this.canvas = canvas;
      this.selectionObj = { nodes: [], edges: [] };
      this.hoverObj = { nodes: {}, edges: {} };

      this.options = {};
      this.defaultOptions = {
        multiselect: false,
        selectable: true,
        selectConnectedEdges: true,
        hoverConnectedEdges: true
      };
      util.extend(this.options, this.defaultOptions);

      this.body.emitter.on("_dataChanged", function () {
        _this.updateSelection();
      });
    }

    _createClass(SelectionHandler, [{
      key: 'setOptions',
      value: function setOptions(options) {
        if (options !== undefined) {
          var fields = ['multiselect', 'hoverConnectedEdges', 'selectable', 'selectConnectedEdges'];
          util.selectiveDeepExtend(fields, this.options, options);
        }
      }

      /**
       * handles the selection part of the tap;
       *
       * @param {Object} pointer
       * @private
       */

    }, {
      key: 'selectOnPoint',
      value: function selectOnPoint(pointer) {
        var selected = false;
        if (this.options.selectable === true) {
          var obj = this.getNodeAt(pointer) || this.getEdgeAt(pointer);

          // unselect after getting the objects in order to restore width and height.
          this.unselectAll();

          if (obj !== undefined) {
            selected = this.selectObject(obj);
          }
          this.body.emitter.emit("_requestRedraw");
        }
        return selected;
      }
    }, {
      key: 'selectAdditionalOnPoint',
      value: function selectAdditionalOnPoint(pointer) {
        var selectionChanged = false;
        if (this.options.selectable === true) {
          var obj = this.getNodeAt(pointer) || this.getEdgeAt(pointer);

          if (obj !== undefined) {
            selectionChanged = true;
            if (obj.isSelected() === true) {
              this.deselectObject(obj);
            } else {
              this.selectObject(obj);
            }

            this.body.emitter.emit("_requestRedraw");
          }
        }
        return selectionChanged;
      }
    }, {
      key: '_generateClickEvent',
      value: function _generateClickEvent(eventType, event, pointer, oldSelection) {
        var emptySelection = arguments.length <= 4 || arguments[4] === undefined ? false : arguments[4];

        var properties = void 0;
        if (emptySelection === true) {
          properties = { nodes: [], edges: [] };
        } else {
          properties = this.getSelection();
        }
        properties['pointer'] = {
          DOM: { x: pointer.x, y: pointer.y },
          canvas: this.canvas.DOMtoCanvas(pointer)
        };
        properties['event'] = event;

        if (oldSelection !== undefined) {
          properties['previousSelection'] = oldSelection;
        }
        this.body.emitter.emit(eventType, properties);
      }
    }, {
      key: 'selectObject',
      value: function selectObject(obj) {
        var highlightEdges = arguments.length <= 1 || arguments[1] === undefined ? this.options.selectConnectedEdges : arguments[1];

        if (obj !== undefined) {
          if (obj instanceof _Node2.default) {
            if (highlightEdges === true) {
              this._selectConnectedEdges(obj);
            }
          }
          obj.select();
          this._addToSelection(obj);
          return true;
        }
        return false;
      }
    }, {
      key: 'deselectObject',
      value: function deselectObject(obj) {
        if (obj.isSelected() === true) {
          obj.selected = false;
          this._removeFromSelection(obj);
        }
      }

      /**
       * retrieve all nodes overlapping with given object
       * @param {Object} object  An object with parameters left, top, right, bottom
       * @return {Number[]}   An array with id's of the overlapping nodes
       * @private
       */

    }, {
      key: '_getAllNodesOverlappingWith',
      value: function _getAllNodesOverlappingWith(object) {
        var overlappingNodes = [];
        var nodes = this.body.nodes;
        for (var i = 0; i < this.body.nodeIndices.length; i++) {
          var nodeId = this.body.nodeIndices[i];
          if (nodes[nodeId].isOverlappingWith(object)) {
            overlappingNodes.push(nodeId);
          }
        }
        return overlappingNodes;
      }

      /**
       * Return a position object in canvasspace from a single point in screenspace
       *
       * @param pointer
       * @returns {{left: number, top: number, right: number, bottom: number}}
       * @private
       */

    }, {
      key: '_pointerToPositionObject',
      value: function _pointerToPositionObject(pointer) {
        var canvasPos = this.canvas.DOMtoCanvas(pointer);
        return {
          left: canvasPos.x - 1,
          top: canvasPos.y + 1,
          right: canvasPos.x + 1,
          bottom: canvasPos.y - 1
        };
      }

      /**
       * Get the top node at the a specific point (like a click)
       *
       * @param {{x: Number, y: Number}} pointer
       * @return {Node | undefined} node
       */

    }, {
      key: 'getNodeAt',
      value: function getNodeAt(pointer) {
        var returnNode = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

        // we first check if this is an navigation controls element
        var positionObject = this._pointerToPositionObject(pointer);
        var overlappingNodes = this._getAllNodesOverlappingWith(positionObject);
        // if there are overlapping nodes, select the last one, this is the
        // one which is drawn on top of the others
        if (overlappingNodes.length > 0) {
          if (returnNode === true) {
            return this.body.nodes[overlappingNodes[overlappingNodes.length - 1]];
          } else {
            return overlappingNodes[overlappingNodes.length - 1];
          }
        } else {
          return undefined;
        }
      }

      /**
       * retrieve all edges overlapping with given object, selector is around center
       * @param {Object} object  An object with parameters left, top, right, bottom
       * @return {Number[]}   An array with id's of the overlapping nodes
       * @private
       */

    }, {
      key: '_getEdgesOverlappingWith',
      value: function _getEdgesOverlappingWith(object, overlappingEdges) {
        var edges = this.body.edges;
        for (var i = 0; i < this.body.edgeIndices.length; i++) {
          var edgeId = this.body.edgeIndices[i];
          if (edges[edgeId].isOverlappingWith(object)) {
            overlappingEdges.push(edgeId);
          }
        }
      }

      /**
       * retrieve all nodes overlapping with given object
       * @param {Object} object  An object with parameters left, top, right, bottom
       * @return {Number[]}   An array with id's of the overlapping nodes
       * @private
       */

    }, {
      key: '_getAllEdgesOverlappingWith',
      value: function _getAllEdgesOverlappingWith(object) {
        var overlappingEdges = [];
        this._getEdgesOverlappingWith(object, overlappingEdges);
        return overlappingEdges;
      }

      /**
       * Place holder. To implement change the getNodeAt to a _getObjectAt. Have the _getObjectAt call
       * getNodeAt and _getEdgesAt, then priortize the selection to user preferences.
       *
       * @param pointer
       * @returns {undefined}
       */

    }, {
      key: 'getEdgeAt',
      value: function getEdgeAt(pointer) {
        var returnEdge = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

        var positionObject = this._pointerToPositionObject(pointer);
        var overlappingEdges = this._getAllEdgesOverlappingWith(positionObject);

        if (overlappingEdges.length > 0) {
          if (returnEdge === true) {
            return this.body.edges[overlappingEdges[overlappingEdges.length - 1]];
          } else {
            return overlappingEdges[overlappingEdges.length - 1];
          }
        } else {
          return undefined;
        }
      }

      /**
       * Add object to the selection array.
       *
       * @param obj
       * @private
       */

    }, {
      key: '_addToSelection',
      value: function _addToSelection(obj) {
        if (obj instanceof _Node2.default) {
          this.selectionObj.nodes[obj.id] = obj;
        } else {
          this.selectionObj.edges[obj.id] = obj;
        }
      }

      /**
       * Add object to the selection array.
       *
       * @param obj
       * @private
       */

    }, {
      key: '_addToHover',
      value: function _addToHover(obj) {
        if (obj instanceof _Node2.default) {
          this.hoverObj.nodes[obj.id] = obj;
        } else {
          this.hoverObj.edges[obj.id] = obj;
        }
      }

      /**
       * Remove a single option from selection.
       *
       * @param {Object} obj
       * @private
       */

    }, {
      key: '_removeFromSelection',
      value: function _removeFromSelection(obj) {
        if (obj instanceof _Node2.default) {
          delete this.selectionObj.nodes[obj.id];
          this._unselectConnectedEdges(obj);
        } else {
          delete this.selectionObj.edges[obj.id];
        }
      }

      /**
       * Unselect all. The selectionObj is useful for this.
       */

    }, {
      key: 'unselectAll',
      value: function unselectAll() {
        for (var nodeId in this.selectionObj.nodes) {
          if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
            this.selectionObj.nodes[nodeId].unselect();
          }
        }
        for (var edgeId in this.selectionObj.edges) {
          if (this.selectionObj.edges.hasOwnProperty(edgeId)) {
            this.selectionObj.edges[edgeId].unselect();
          }
        }

        this.selectionObj = { nodes: {}, edges: {} };
      }

      /**
       * return the number of selected nodes
       *
       * @returns {number}
       * @private
       */

    }, {
      key: '_getSelectedNodeCount',
      value: function _getSelectedNodeCount() {
        var count = 0;
        for (var nodeId in this.selectionObj.nodes) {
          if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
            count += 1;
          }
        }
        return count;
      }

      /**
       * return the selected node
       *
       * @returns {number}
       * @private
       */

    }, {
      key: '_getSelectedNode',
      value: function _getSelectedNode() {
        for (var nodeId in this.selectionObj.nodes) {
          if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
            return this.selectionObj.nodes[nodeId];
          }
        }
        return undefined;
      }

      /**
       * return the selected edge
       *
       * @returns {number}
       * @private
       */

    }, {
      key: '_getSelectedEdge',
      value: function _getSelectedEdge() {
        for (var edgeId in this.selectionObj.edges) {
          if (this.selectionObj.edges.hasOwnProperty(edgeId)) {
            return this.selectionObj.edges[edgeId];
          }
        }
        return undefined;
      }

      /**
       * return the number of selected edges
       *
       * @returns {number}
       * @private
       */

    }, {
      key: '_getSelectedEdgeCount',
      value: function _getSelectedEdgeCount() {
        var count = 0;
        for (var edgeId in this.selectionObj.edges) {
          if (this.selectionObj.edges.hasOwnProperty(edgeId)) {
            count += 1;
          }
        }
        return count;
      }

      /**
       * return the number of selected objects.
       *
       * @returns {number}
       * @private
       */

    }, {
      key: '_getSelectedObjectCount',
      value: function _getSelectedObjectCount() {
        var count = 0;
        for (var nodeId in this.selectionObj.nodes) {
          if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
            count += 1;
          }
        }
        for (var edgeId in this.selectionObj.edges) {
          if (this.selectionObj.edges.hasOwnProperty(edgeId)) {
            count += 1;
          }
        }
        return count;
      }

      /**
       * Check if anything is selected
       *
       * @returns {boolean}
       * @private
       */

    }, {
      key: '_selectionIsEmpty',
      value: function _selectionIsEmpty() {
        for (var nodeId in this.selectionObj.nodes) {
          if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
            return false;
          }
        }
        for (var edgeId in this.selectionObj.edges) {
          if (this.selectionObj.edges.hasOwnProperty(edgeId)) {
            return false;
          }
        }
        return true;
      }

      /**
       * check if one of the selected nodes is a cluster.
       *
       * @returns {boolean}
       * @private
       */

    }, {
      key: '_clusterInSelection',
      value: function _clusterInSelection() {
        for (var nodeId in this.selectionObj.nodes) {
          if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
            if (this.selectionObj.nodes[nodeId].clusterSize > 1) {
              return true;
            }
          }
        }
        return false;
      }

      /**
       * select the edges connected to the node that is being selected
       *
       * @param {Node} node
       * @private
       */

    }, {
      key: '_selectConnectedEdges',
      value: function _selectConnectedEdges(node) {
        for (var i = 0; i < node.edges.length; i++) {
          var edge = node.edges[i];
          edge.select();
          this._addToSelection(edge);
        }
      }

      /**
       * select the edges connected to the node that is being selected
       *
       * @param {Node} node
       * @private
       */

    }, {
      key: '_hoverConnectedEdges',
      value: function _hoverConnectedEdges(node) {
        for (var i = 0; i < node.edges.length; i++) {
          var edge = node.edges[i];
          edge.hover = true;
          this._addToHover(edge);
        }
      }

      /**
       * unselect the edges connected to the node that is being selected
       *
       * @param {Node} node
       * @private
       */

    }, {
      key: '_unselectConnectedEdges',
      value: function _unselectConnectedEdges(node) {
        for (var i = 0; i < node.edges.length; i++) {
          var edge = node.edges[i];
          edge.unselect();
          this._removeFromSelection(edge);
        }
      }

      /**
       * This is called when someone clicks on a node. either select or deselect it.
       * If there is an existing selection and we don't want to append to it, clear the existing selection
       *
       * @param {Node || Edge} object
       * @private
       */

    }, {
      key: 'blurObject',
      value: function blurObject(object) {
        if (object.hover === true) {
          object.hover = false;
          if (object instanceof _Node2.default) {
            this.body.emitter.emit("blurNode", { node: object.id });
          } else {
            this.body.emitter.emit("blurEdge", { edge: object.id });
          }
        }
      }

      /**
       * This is called when someone clicks on a node. either select or deselect it.
       * If there is an existing selection and we don't want to append to it, clear the existing selection
       *
       * @param {Node || Edge} object
       * @private
       */

    }, {
      key: 'hoverObject',
      value: function hoverObject(object) {
        var hoverChanged = false;
        // remove all node hover highlights
        for (var nodeId in this.hoverObj.nodes) {
          if (this.hoverObj.nodes.hasOwnProperty(nodeId)) {
            if (object === undefined || object instanceof _Node2.default && object.id != nodeId || object instanceof _Edge2.default) {
              this.blurObject(this.hoverObj.nodes[nodeId]);
              delete this.hoverObj.nodes[nodeId];
              hoverChanged = true;
            }
          }
        }

        // removing all edge hover highlights
        for (var edgeId in this.hoverObj.edges) {
          if (this.hoverObj.edges.hasOwnProperty(edgeId)) {
            // if the hover has been changed here it means that the node has been hovered over or off
            // we then do not use the blurObject method here.
            if (hoverChanged === true) {
              this.hoverObj.edges[edgeId].hover = false;
              delete this.hoverObj.edges[edgeId];
            }
            // if the blur remains the same and the object is undefined (mouse off), we blur the edge
            else if (object === undefined) {
                this.blurObject(this.hoverObj.edges[edgeId]);
                delete this.hoverObj.edges[edgeId];
                hoverChanged = true;
              }
          }
        }

        if (object !== undefined) {
          if (object.hover === false) {
            object.hover = true;
            this._addToHover(object);
            hoverChanged = true;
            if (object instanceof _Node2.default) {
              this.body.emitter.emit("hoverNode", { node: object.id });
            } else {
              this.body.emitter.emit("hoverEdge", { edge: object.id });
            }
          }
          if (object instanceof _Node2.default && this.options.hoverConnectedEdges === true) {
            this._hoverConnectedEdges(object);
          }
        }

        if (hoverChanged === true) {
          this.body.emitter.emit('_requestRedraw');
        }
      }

      /**
       *
       * retrieve the currently selected objects
       * @return {{nodes: Array.<String>, edges: Array.<String>}} selection
       */

    }, {
      key: 'getSelection',
      value: function getSelection() {
        var nodeIds = this.getSelectedNodes();
        var edgeIds = this.getSelectedEdges();
        return { nodes: nodeIds, edges: edgeIds };
      }

      /**
       *
       * retrieve the currently selected nodes
       * @return {String[]} selection    An array with the ids of the
       *                                            selected nodes.
       */

    }, {
      key: 'getSelectedNodes',
      value: function getSelectedNodes() {
        var idArray = [];
        if (this.options.selectable === true) {
          for (var nodeId in this.selectionObj.nodes) {
            if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
              idArray.push(this.selectionObj.nodes[nodeId].id);
            }
          }
        }
        return idArray;
      }

      /**
       *
       * retrieve the currently selected edges
       * @return {Array} selection    An array with the ids of the
       *                                            selected nodes.
       */

    }, {
      key: 'getSelectedEdges',
      value: function getSelectedEdges() {
        var idArray = [];
        if (this.options.selectable === true) {
          for (var edgeId in this.selectionObj.edges) {
            if (this.selectionObj.edges.hasOwnProperty(edgeId)) {
              idArray.push(this.selectionObj.edges[edgeId].id);
            }
          }
        }
        return idArray;
      }

      /**
       * Updates the current selection
       * @param {{nodes: Array.<String>, edges: Array.<String>}} Selection
       * @param {Object} options                                 Options
       */

    }, {
      key: 'setSelection',
      value: function setSelection(selection) {
        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        var i = void 0,
            id = void 0;

        if (!selection || !selection.nodes && !selection.edges) throw 'Selection must be an object with nodes and/or edges properties';
        // first unselect any selected node, if option is true or undefined
        if (options.unselectAll || options.unselectAll === undefined) {
          this.unselectAll();
        }
        if (selection.nodes) {
          for (i = 0; i < selection.nodes.length; i++) {
            id = selection.nodes[i];

            var node = this.body.nodes[id];
            if (!node) {
              throw new RangeError('Node with id "' + id + '" not found');
            }
            // don't select edges with it
            this.selectObject(node, options.highlightEdges);
          }
        }

        if (selection.edges) {
          for (i = 0; i < selection.edges.length; i++) {
            id = selection.edges[i];

            var edge = this.body.edges[id];
            if (!edge) {
              throw new RangeError('Edge with id "' + id + '" not found');
            }
            this.selectObject(edge);
          }
        }
        this.body.emitter.emit('_requestRedraw');
      }

      /**
       * select zero or more nodes with the option to highlight edges
       * @param {Number[] | String[]} selection     An array with the ids of the
       *                                            selected nodes.
       * @param {boolean} [highlightEdges]
       */

    }, {
      key: 'selectNodes',
      value: function selectNodes(selection) {
        var highlightEdges = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

        if (!selection || selection.length === undefined) throw 'Selection must be an array with ids';

        this.setSelection({ nodes: selection }, { highlightEdges: highlightEdges });
      }

      /**
       * select zero or more edges
       * @param {Number[] | String[]} selection     An array with the ids of the
       *                                            selected nodes.
       */

    }, {
      key: 'selectEdges',
      value: function selectEdges(selection) {
        if (!selection || selection.length === undefined) throw 'Selection must be an array with ids';

        this.setSelection({ edges: selection });
      }

      /**
       * Validate the selection: remove ids of nodes which no longer exist
       * @private
       */

    }, {
      key: 'updateSelection',
      value: function updateSelection() {
        for (var nodeId in this.selectionObj.nodes) {
          if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
            if (!this.body.nodes.hasOwnProperty(nodeId)) {
              delete this.selectionObj.nodes[nodeId];
            }
          }
        }
        for (var edgeId in this.selectionObj.edges) {
          if (this.selectionObj.edges.hasOwnProperty(edgeId)) {
            if (!this.body.edges.hasOwnProperty(edgeId)) {
              delete this.selectionObj.edges[edgeId];
            }
          }
        }
      }
    }]);

    return SelectionHandler;
  }();

  exports.default = SelectionHandler;

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _NetworkUtil = __webpack_require__(103);

  var _NetworkUtil2 = _interopRequireDefault(_NetworkUtil);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);

  var LayoutEngine = function () {
    function LayoutEngine(body) {
      _classCallCheck(this, LayoutEngine);

      this.body = body;

      this.initialRandomSeed = Math.round(Math.random() * 1000000);
      this.randomSeed = this.initialRandomSeed;
      this.setPhysics = false;
      this.options = {};
      this.optionsBackup = { physics: {} };

      this.defaultOptions = {
        randomSeed: undefined,
        improvedLayout: true,
        hierarchical: {
          enabled: false,
          levelSeparation: 150,
          nodeSpacing: 100,
          treeSpacing: 200,
          blockShifting: true,
          edgeMinimization: true,
          parentCentralization: true,
          direction: 'UD', // UD, DU, LR, RL
          sortMethod: 'hubsize' // hubsize, directed
        }
      };
      util.extend(this.options, this.defaultOptions);
      this.bindEventListeners();
    }

    _createClass(LayoutEngine, [{
      key: 'bindEventListeners',
      value: function bindEventListeners() {
        var _this = this;

        this.body.emitter.on('_dataChanged', function () {
          _this.setupHierarchicalLayout();
        });
        this.body.emitter.on('_dataLoaded', function () {
          _this.layoutNetwork();
        });
        this.body.emitter.on('_resetHierarchicalLayout', function () {
          _this.setupHierarchicalLayout();
        });
      }
    }, {
      key: 'setOptions',
      value: function setOptions(options, allOptions) {
        if (options !== undefined) {
          var prevHierarchicalState = this.options.hierarchical.enabled;
          util.selectiveDeepExtend(["randomSeed", "improvedLayout"], this.options, options);
          util.mergeOptions(this.options, options, 'hierarchical');
          if (options.randomSeed !== undefined) {
            this.initialRandomSeed = options.randomSeed;
          }

          if (this.options.hierarchical.enabled === true) {
            if (prevHierarchicalState === true) {
              // refresh the overridden options for nodes and edges.
              this.body.emitter.emit('refresh', true);
            }

            // make sure the level separation is the right way up
            if (this.options.hierarchical.direction === 'RL' || this.options.hierarchical.direction === 'DU') {
              if (this.options.hierarchical.levelSeparation > 0) {
                this.options.hierarchical.levelSeparation *= -1;
              }
            } else {
              if (this.options.hierarchical.levelSeparation < 0) {
                this.options.hierarchical.levelSeparation *= -1;
              }
            }

            this.body.emitter.emit('_resetHierarchicalLayout');
            // because the hierarchical system needs it's own physics and smooth curve settings, we adapt the other options if needed.
            return this.adaptAllOptionsForHierarchicalLayout(allOptions);
          } else {
            if (prevHierarchicalState === true) {
              // refresh the overridden options for nodes and edges.
              this.body.emitter.emit('refresh');
              return util.deepExtend(allOptions, this.optionsBackup);
            }
          }
        }
        return allOptions;
      }
    }, {
      key: 'adaptAllOptionsForHierarchicalLayout',
      value: function adaptAllOptionsForHierarchicalLayout(allOptions) {
        if (this.options.hierarchical.enabled === true) {
          // set the physics
          if (allOptions.physics === undefined || allOptions.physics === true) {
            allOptions.physics = {
              enabled: this.optionsBackup.physics.enabled === undefined ? true : this.optionsBackup.physics.enabled,
              solver: 'hierarchicalRepulsion'
            };
            this.optionsBackup.physics.enabled = this.optionsBackup.physics.enabled === undefined ? true : this.optionsBackup.physics.enabled;
            this.optionsBackup.physics.solver = this.optionsBackup.physics.solver || 'barnesHut';
          } else if (_typeof(allOptions.physics) === 'object') {
            this.optionsBackup.physics.enabled = allOptions.physics.enabled === undefined ? true : allOptions.physics.enabled;
            this.optionsBackup.physics.solver = allOptions.physics.solver || 'barnesHut';
            allOptions.physics.solver = 'hierarchicalRepulsion';
          } else if (allOptions.physics !== false) {
            this.optionsBackup.physics.solver = 'barnesHut';
            allOptions.physics = { solver: 'hierarchicalRepulsion' };
          }

          // get the type of static smooth curve in case it is required
          var type = 'horizontal';
          if (this.options.hierarchical.direction === 'RL' || this.options.hierarchical.direction === 'LR') {
            type = 'vertical';
          }

          // disable smooth curves if nothing is defined. If smooth curves have been turned on, turn them into static smooth curves.
          if (allOptions.edges === undefined) {
            this.optionsBackup.edges = { smooth: { enabled: true, type: 'dynamic' } };
            allOptions.edges = { smooth: false };
          } else if (allOptions.edges.smooth === undefined) {
            this.optionsBackup.edges = { smooth: { enabled: true, type: 'dynamic' } };
            allOptions.edges.smooth = false;
          } else {
            if (typeof allOptions.edges.smooth === 'boolean') {
              this.optionsBackup.edges = { smooth: allOptions.edges.smooth };
              allOptions.edges.smooth = { enabled: allOptions.edges.smooth, type: type };
            } else {
              // allow custom types except for dynamic
              if (allOptions.edges.smooth.type !== undefined && allOptions.edges.smooth.type !== 'dynamic') {
                type = allOptions.edges.smooth.type;
              }

              this.optionsBackup.edges = {
                smooth: allOptions.edges.smooth.enabled === undefined ? true : allOptions.edges.smooth.enabled,
                type: allOptions.edges.smooth.type === undefined ? 'dynamic' : allOptions.edges.smooth.type,
                roundness: allOptions.edges.smooth.roundness === undefined ? 0.5 : allOptions.edges.smooth.roundness,
                forceDirection: allOptions.edges.smooth.forceDirection === undefined ? false : allOptions.edges.smooth.forceDirection
              };
              allOptions.edges.smooth = {
                enabled: allOptions.edges.smooth.enabled === undefined ? true : allOptions.edges.smooth.enabled,
                type: type,
                roundness: allOptions.edges.smooth.roundness === undefined ? 0.5 : allOptions.edges.smooth.roundness,
                forceDirection: allOptions.edges.smooth.forceDirection === undefined ? false : allOptions.edges.smooth.forceDirection
              };
            }
          }

          // force all edges into static smooth curves. Only applies to edges that do not use the global options for smooth.
          this.body.emitter.emit('_forceDisableDynamicCurves', type);
        }

        return allOptions;
      }
    }, {
      key: 'seededRandom',
      value: function seededRandom() {
        var x = Math.sin(this.randomSeed++) * 10000;
        return x - Math.floor(x);
      }
    }, {
      key: 'positionInitially',
      value: function positionInitially(nodesArray) {
        if (this.options.hierarchical.enabled !== true) {
          this.randomSeed = this.initialRandomSeed;
          for (var i = 0; i < nodesArray.length; i++) {
            var node = nodesArray[i];
            var radius = 10 * 0.1 * nodesArray.length + 10;
            var angle = 2 * Math.PI * this.seededRandom();
            if (node.x === undefined) {
              node.x = radius * Math.cos(angle);
            }
            if (node.y === undefined) {
              node.y = radius * Math.sin(angle);
            }
          }
        }
      }

      /**
       * Use Kamada Kawai to position nodes. This is quite a heavy algorithm so if there are a lot of nodes we
       * cluster them first to reduce the amount.
       */

    }, {
      key: 'layoutNetwork',
      value: function layoutNetwork() {
        if (this.options.hierarchical.enabled !== true && this.options.improvedLayout === true) {
          // first check if we should Kamada Kawai to layout. The threshold is if less than half of the visible
          // nodes have predefined positions we use this.
          var positionDefined = 0;
          for (var i = 0; i < this.body.nodeIndices.length; i++) {
            var node = this.body.nodes[this.body.nodeIndices[i]];
            if (node.predefinedPosition === true) {
              positionDefined += 1;
            }
          }

          // if less than half of the nodes have a predefined position we continue
          if (positionDefined < 0.5 * this.body.nodeIndices.length) {
            var MAX_LEVELS = 10;
            var level = 0;
            var clusterThreshold = 100;
            // if there are a lot of nodes, we cluster before we run the algorithm.
            if (this.body.nodeIndices.length > clusterThreshold) {
              var startLength = this.body.nodeIndices.length;
              while (this.body.nodeIndices.length > clusterThreshold) {
                //console.time("clustering")
                level += 1;
                var before = this.body.nodeIndices.length;
                // if there are many nodes we do a hubsize cluster
                if (level % 3 === 0) {
                  this.body.modules.clustering.clusterBridges();
                } else {
                  this.body.modules.clustering.clusterOutliers();
                }
                var after = this.body.nodeIndices.length;
                if (before == after && level % 3 !== 0 || level > MAX_LEVELS) {
                  this._declusterAll();
                  this.body.emitter.emit("_layoutFailed");
                  console.info("This network could not be positioned by this version of the improved layout algorithm. Please disable improvedLayout for better performance.");
                  return;
                }
                //console.timeEnd("clustering")
                //console.log(level,after)
              }
              // increase the size of the edges
              this.body.modules.kamadaKawai.setOptions({ springLength: Math.max(150, 2 * startLength) });
            }

            // position the system for these nodes and edges
            this.body.modules.kamadaKawai.solve(this.body.nodeIndices, this.body.edgeIndices, true);

            // shift to center point
            this._shiftToCenter();

            // perturb the nodes a little bit to force the physics to kick in
            var offset = 70;
            for (var _i = 0; _i < this.body.nodeIndices.length; _i++) {
              this.body.nodes[this.body.nodeIndices[_i]].x += (0.5 - this.seededRandom()) * offset;
              this.body.nodes[this.body.nodeIndices[_i]].y += (0.5 - this.seededRandom()) * offset;
            }

            // uncluster all clusters
            this._declusterAll();

            // reposition all bezier nodes.
            this.body.emitter.emit("_repositionBezierNodes");
          }
        }
      }

      /**
       * Move all the nodes towards to the center so gravitational pull wil not move the nodes away from view
       * @private
       */

    }, {
      key: '_shiftToCenter',
      value: function _shiftToCenter() {
        var range = _NetworkUtil2.default.getRangeCore(this.body.nodes, this.body.nodeIndices);
        var center = _NetworkUtil2.default.findCenter(range);
        for (var i = 0; i < this.body.nodeIndices.length; i++) {
          this.body.nodes[this.body.nodeIndices[i]].x -= center.x;
          this.body.nodes[this.body.nodeIndices[i]].y -= center.y;
        }
      }
    }, {
      key: '_declusterAll',
      value: function _declusterAll() {
        var clustersPresent = true;
        while (clustersPresent === true) {
          clustersPresent = false;
          for (var i = 0; i < this.body.nodeIndices.length; i++) {
            if (this.body.nodes[this.body.nodeIndices[i]].isCluster === true) {
              clustersPresent = true;
              this.body.modules.clustering.openCluster(this.body.nodeIndices[i], {}, false);
            }
          }
          if (clustersPresent === true) {
            this.body.emitter.emit('_dataChanged');
          }
        }
      }
    }, {
      key: 'getSeed',
      value: function getSeed() {
        return this.initialRandomSeed;
      }

      /**
       * This is the main function to layout the nodes in a hierarchical way.
       * It checks if the node details are supplied correctly
       *
       * @private
       */

    }, {
      key: 'setupHierarchicalLayout',
      value: function setupHierarchicalLayout() {
        if (this.options.hierarchical.enabled === true && this.body.nodeIndices.length > 0) {
          // get the size of the largest hubs and check if the user has defined a level for a node.
          var node = void 0,
              nodeId = void 0;
          var definedLevel = false;
          var definedPositions = true;
          var undefinedLevel = false;
          this.hierarchicalLevels = {};
          this.lastNodeOnLevel = {};
          this.hierarchicalChildrenReference = {};
          this.hierarchicalParentReference = {};
          this.hierarchicalTrees = {};
          this.treeIndex = -1;

          this.distributionOrdering = {};
          this.distributionIndex = {};
          this.distributionOrderingPresence = {};

          for (nodeId in this.body.nodes) {
            if (this.body.nodes.hasOwnProperty(nodeId)) {
              node = this.body.nodes[nodeId];
              if (node.options.x === undefined && node.options.y === undefined) {
                definedPositions = false;
              }
              if (node.options.level !== undefined) {
                definedLevel = true;
                this.hierarchicalLevels[nodeId] = node.options.level;
              } else {
                undefinedLevel = true;
              }
            }
          }

          // if the user defined some levels but not all, alert and run without hierarchical layout
          if (undefinedLevel === true && definedLevel === true) {
            throw new Error('To use the hierarchical layout, nodes require either no predefined levels or levels have to be defined for all nodes.');
            return;
          } else {
            // define levels if undefined by the users. Based on hubsize.
            if (undefinedLevel === true) {
              if (this.options.hierarchical.sortMethod === 'hubsize') {
                this._determineLevelsByHubsize();
              } else if (this.options.hierarchical.sortMethod === 'directed') {
                this._determineLevelsDirected();
              } else if (this.options.hierarchical.sortMethod === 'custom') {
                this._determineLevelsCustomCallback();
              }
            }

            // fallback for cases where there are nodes but no edges
            for (var _nodeId in this.body.nodes) {
              if (this.body.nodes.hasOwnProperty(_nodeId)) {
                if (this.hierarchicalLevels[_nodeId] === undefined) {
                  this.hierarchicalLevels[_nodeId] = 0;
                }
              }
            }
            // check the distribution of the nodes per level.
            var distribution = this._getDistribution();

            // get the parent children relations.
            this._generateMap();

            // place the nodes on the canvas.
            this._placeNodesByHierarchy(distribution);

            // condense the whitespace.
            this._condenseHierarchy();

            // shift to center so gravity does not have to do much
            this._shiftToCenter();
          }
        }
      }

      /**
       * @private
       */

    }, {
      key: '_condenseHierarchy',
      value: function _condenseHierarchy() {
        var _this2 = this;

        // Global var in this scope to define when the movement has stopped.
        var stillShifting = false;
        var branches = {};
        // first we have some methods to help shifting trees around.
        // the main method to shift the trees
        var shiftTrees = function shiftTrees() {
          var treeSizes = getTreeSizes();
          for (var i = 0; i < treeSizes.length - 1; i++) {
            var diff = treeSizes[i].max - treeSizes[i + 1].min;
            shiftTree(i + 1, diff + _this2.options.hierarchical.treeSpacing);
          }
        };

        // shift a single tree by an offset
        var shiftTree = function shiftTree(index, offset) {
          for (var nodeId in _this2.hierarchicalTrees) {
            if (_this2.hierarchicalTrees.hasOwnProperty(nodeId)) {
              if (_this2.hierarchicalTrees[nodeId] === index) {
                var node = _this2.body.nodes[nodeId];
                var pos = _this2._getPositionForHierarchy(node);
                _this2._setPositionForHierarchy(node, pos + offset, undefined, true);
              }
            }
          }
        };

        // get the width of a tree
        var getTreeSize = function getTreeSize(index) {
          var min = 1e9;
          var max = -1e9;
          for (var nodeId in _this2.hierarchicalTrees) {
            if (_this2.hierarchicalTrees.hasOwnProperty(nodeId)) {
              if (_this2.hierarchicalTrees[nodeId] === index) {
                var pos = _this2._getPositionForHierarchy(_this2.body.nodes[nodeId]);
                min = Math.min(pos, min);
                max = Math.max(pos, max);
              }
            }
          }
          return { min: min, max: max };
        };

        // get the width of all trees
        var getTreeSizes = function getTreeSizes() {
          var treeWidths = [];
          for (var i = 0; i <= _this2.treeIndex; i++) {
            treeWidths.push(getTreeSize(i));
          }
          return treeWidths;
        };

        // get a map of all nodes in this branch
        var getBranchNodes = function getBranchNodes(source, map) {
          map[source.id] = true;
          if (_this2.hierarchicalChildrenReference[source.id]) {
            var children = _this2.hierarchicalChildrenReference[source.id];
            if (children.length > 0) {
              for (var i = 0; i < children.length; i++) {
                getBranchNodes(_this2.body.nodes[children[i]], map);
              }
            }
          }
        };

        // get a min max width as well as the maximum movement space it has on either sides
        // we use min max terminology because width and height can interchange depending on the direction of the layout
        var getBranchBoundary = function getBranchBoundary(branchMap) {
          var maxLevel = arguments.length <= 1 || arguments[1] === undefined ? 1e9 : arguments[1];

          var minSpace = 1e9;
          var maxSpace = 1e9;
          var min = 1e9;
          var max = -1e9;
          for (var branchNode in branchMap) {
            if (branchMap.hasOwnProperty(branchNode)) {
              var node = _this2.body.nodes[branchNode];
              var level = _this2.hierarchicalLevels[node.id];
              var position = _this2._getPositionForHierarchy(node);

              // get the space around the node.

              var _getSpaceAroundNode2 = _this2._getSpaceAroundNode(node, branchMap);

              var _getSpaceAroundNode3 = _slicedToArray(_getSpaceAroundNode2, 2);

              var minSpaceNode = _getSpaceAroundNode3[0];
              var maxSpaceNode = _getSpaceAroundNode3[1];

              minSpace = Math.min(minSpaceNode, minSpace);
              maxSpace = Math.min(maxSpaceNode, maxSpace);

              // the width is only relevant for the levels two nodes have in common. This is why we filter on this.
              if (level <= maxLevel) {
                min = Math.min(position, min);
                max = Math.max(position, max);
              }
            }
          }

          return [min, max, minSpace, maxSpace];
        };

        // get the maximum level of a branch.
        var getMaxLevel = function getMaxLevel(nodeId) {
          var level = _this2.hierarchicalLevels[nodeId];
          if (_this2.hierarchicalChildrenReference[nodeId]) {
            var children = _this2.hierarchicalChildrenReference[nodeId];
            if (children.length > 0) {
              for (var i = 0; i < children.length; i++) {
                level = Math.max(level, getMaxLevel(children[i]));
              }
            }
          }
          return level;
        };

        // check what the maximum level is these nodes have in common.
        var getCollisionLevel = function getCollisionLevel(node1, node2) {
          var maxLevel1 = getMaxLevel(node1.id);
          var maxLevel2 = getMaxLevel(node2.id);
          return Math.min(maxLevel1, maxLevel2);
        };

        // check if two nodes have the same parent(s)
        var hasSameParent = function hasSameParent(node1, node2) {
          var parents1 = _this2.hierarchicalParentReference[node1.id];
          var parents2 = _this2.hierarchicalParentReference[node2.id];
          if (parents1 === undefined || parents2 === undefined) {
            return false;
          }

          for (var i = 0; i < parents1.length; i++) {
            for (var j = 0; j < parents2.length; j++) {
              if (parents1[i] == parents2[j]) {
                return true;
              }
            }
          }
          return false;
        };

        // condense elements. These can be nodes or branches depending on the callback.
        var shiftElementsCloser = function shiftElementsCloser(callback, levels, centerParents) {
          for (var i = 0; i < levels.length; i++) {
            var level = levels[i];
            var levelNodes = _this2.distributionOrdering[level];
            if (levelNodes.length > 1) {
              for (var j = 0; j < levelNodes.length - 1; j++) {
                if (hasSameParent(levelNodes[j], levelNodes[j + 1]) === true) {
                  if (_this2.hierarchicalTrees[levelNodes[j].id] === _this2.hierarchicalTrees[levelNodes[j + 1].id]) {
                    callback(levelNodes[j], levelNodes[j + 1], centerParents);
                  }
                }
              }
            }
          }
        };

        // callback for shifting branches
        var branchShiftCallback = function branchShiftCallback(node1, node2) {
          var centerParent = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

          //window.CALLBACKS.push(() => {
          var pos1 = _this2._getPositionForHierarchy(node1);
          var pos2 = _this2._getPositionForHierarchy(node2);
          var diffAbs = Math.abs(pos2 - pos1);
          //console.log("NOW CHEcKING:", node1.id, node2.id, diffAbs);
          if (diffAbs > _this2.options.hierarchical.nodeSpacing) {
            var branchNodes1 = {};branchNodes1[node1.id] = true;
            var branchNodes2 = {};branchNodes2[node2.id] = true;

            getBranchNodes(node1, branchNodes1);
            getBranchNodes(node2, branchNodes2);

            // check the largest distance between the branches
            var maxLevel = getCollisionLevel(node1, node2);

            var _getBranchBoundary = getBranchBoundary(branchNodes1, maxLevel);

            var _getBranchBoundary2 = _slicedToArray(_getBranchBoundary, 4);

            var min1 = _getBranchBoundary2[0];
            var max1 = _getBranchBoundary2[1];
            var minSpace1 = _getBranchBoundary2[2];
            var maxSpace1 = _getBranchBoundary2[3];

            var _getBranchBoundary3 = getBranchBoundary(branchNodes2, maxLevel);

            var _getBranchBoundary4 = _slicedToArray(_getBranchBoundary3, 4);

            var min2 = _getBranchBoundary4[0];
            var max2 = _getBranchBoundary4[1];
            var minSpace2 = _getBranchBoundary4[2];
            var maxSpace2 = _getBranchBoundary4[3];

            //console.log(node1.id, getBranchBoundary(branchNodes1, maxLevel), node2.id, getBranchBoundary(branchNodes2, maxLevel), maxLevel);

            var diffBranch = Math.abs(max1 - min2);
            if (diffBranch > _this2.options.hierarchical.nodeSpacing) {
              var offset = max1 - min2 + _this2.options.hierarchical.nodeSpacing;
              if (offset < -minSpace2 + _this2.options.hierarchical.nodeSpacing) {
                offset = -minSpace2 + _this2.options.hierarchical.nodeSpacing;
                //console.log("RESETTING OFFSET", max1 - min2 + this.options.hierarchical.nodeSpacing, -minSpace2, offset);
              }
              if (offset < 0) {
                //console.log("SHIFTING", node2.id, offset);
                _this2._shiftBlock(node2.id, offset);
                stillShifting = true;

                if (centerParent === true) _this2._centerParent(node2);
              }
            }
          }
          //this.body.emitter.emit("_redraw");})
        };

        var minimizeEdgeLength = function minimizeEdgeLength(iterations, node) {
          //window.CALLBACKS.push(() => {
          //  console.log("ts",node.id);
          var nodeId = node.id;
          var allEdges = node.edges;
          var nodeLevel = _this2.hierarchicalLevels[node.id];

          // gather constants
          var C2 = _this2.options.hierarchical.levelSeparation * _this2.options.hierarchical.levelSeparation;
          var referenceNodes = {};
          var aboveEdges = [];
          for (var i = 0; i < allEdges.length; i++) {
            var edge = allEdges[i];
            if (edge.toId != edge.fromId) {
              var otherNode = edge.toId == nodeId ? edge.from : edge.to;
              referenceNodes[allEdges[i].id] = otherNode;
              if (_this2.hierarchicalLevels[otherNode.id] < nodeLevel) {
                aboveEdges.push(edge);
              }
            }
          }

          // differentiated sum of lengths based on only moving one node over one axis
          var getFx = function getFx(point, edges) {
            var sum = 0;
            for (var _i2 = 0; _i2 < edges.length; _i2++) {
              if (referenceNodes[edges[_i2].id] !== undefined) {
                var a = _this2._getPositionForHierarchy(referenceNodes[edges[_i2].id]) - point;
                sum += a / Math.sqrt(a * a + C2);
              }
            }
            return sum;
          };

          // doubly differentiated sum of lengths based on only moving one node over one axis
          var getDFx = function getDFx(point, edges) {
            var sum = 0;
            for (var _i3 = 0; _i3 < edges.length; _i3++) {
              if (referenceNodes[edges[_i3].id] !== undefined) {
                var a = _this2._getPositionForHierarchy(referenceNodes[edges[_i3].id]) - point;
                sum -= C2 * Math.pow(a * a + C2, -1.5);
              }
            }
            return sum;
          };

          var getGuess = function getGuess(iterations, edges) {
            var guess = _this2._getPositionForHierarchy(node);
            // Newton's method for optimization
            var guessMap = {};
            for (var _i4 = 0; _i4 < iterations; _i4++) {
              var fx = getFx(guess, edges);
              var dfx = getDFx(guess, edges);

              // we limit the movement to avoid instability.
              var limit = 40;
              var ratio = Math.max(-limit, Math.min(limit, Math.round(fx / dfx)));
              guess = guess - ratio;
              // reduce duplicates
              if (guessMap[guess] !== undefined) {
                break;
              }
              guessMap[guess] = _i4;
            }
            return guess;
          };

          var moveBranch = function moveBranch(guess) {
            // position node if there is space
            var nodePosition = _this2._getPositionForHierarchy(node);

            // check movable area of the branch
            if (branches[node.id] === undefined) {
              var branchNodes = {};
              branchNodes[node.id] = true;
              getBranchNodes(node, branchNodes);
              branches[node.id] = branchNodes;
            }

            var _getBranchBoundary5 = getBranchBoundary(branches[node.id]);

            var _getBranchBoundary6 = _slicedToArray(_getBranchBoundary5, 4);

            var minBranch = _getBranchBoundary6[0];
            var maxBranch = _getBranchBoundary6[1];
            var minSpaceBranch = _getBranchBoundary6[2];
            var maxSpaceBranch = _getBranchBoundary6[3];


            var diff = guess - nodePosition;

            // check if we are allowed to move the node:
            var branchOffset = 0;
            if (diff > 0) {
              branchOffset = Math.min(diff, maxSpaceBranch - _this2.options.hierarchical.nodeSpacing);
            } else if (diff < 0) {
              branchOffset = -Math.min(-diff, minSpaceBranch - _this2.options.hierarchical.nodeSpacing);
            }

            if (branchOffset != 0) {
              //console.log("moving branch:",branchOffset, maxSpaceBranch, minSpaceBranch)
              _this2._shiftBlock(node.id, branchOffset);
              //this.body.emitter.emit("_redraw");
              stillShifting = true;
            }
          };

          var moveNode = function moveNode(guess) {
            var nodePosition = _this2._getPositionForHierarchy(node);

            // position node if there is space

            var _getSpaceAroundNode4 = _this2._getSpaceAroundNode(node);

            var _getSpaceAroundNode5 = _slicedToArray(_getSpaceAroundNode4, 2);

            var minSpace = _getSpaceAroundNode5[0];
            var maxSpace = _getSpaceAroundNode5[1];

            var diff = guess - nodePosition;
            // check if we are allowed to move the node:
            var newPosition = nodePosition;
            if (diff > 0) {
              newPosition = Math.min(nodePosition + (maxSpace - _this2.options.hierarchical.nodeSpacing), guess);
            } else if (diff < 0) {
              newPosition = Math.max(nodePosition - (minSpace - _this2.options.hierarchical.nodeSpacing), guess);
            }

            if (newPosition !== nodePosition) {
              //console.log("moving Node:",diff, minSpace, maxSpace);
              _this2._setPositionForHierarchy(node, newPosition, undefined, true);
              //this.body.emitter.emit("_redraw");
              stillShifting = true;
            }
          };

          var guess = getGuess(iterations, aboveEdges);
          moveBranch(guess);
          guess = getGuess(iterations, allEdges);
          moveNode(guess);
          //})
        };

        // method to remove whitespace between branches. Because we do bottom up, we can center the parents.
        var minimizeEdgeLengthBottomUp = function minimizeEdgeLengthBottomUp(iterations) {
          var levels = Object.keys(_this2.distributionOrdering);
          levels = levels.reverse();
          for (var i = 0; i < iterations; i++) {
            stillShifting = false;
            for (var j = 0; j < levels.length; j++) {
              var level = levels[j];
              var levelNodes = _this2.distributionOrdering[level];
              for (var k = 0; k < levelNodes.length; k++) {
                minimizeEdgeLength(1000, levelNodes[k]);
              }
            }
            if (stillShifting !== true) {
              //console.log("FINISHED minimizeEdgeLengthBottomUp IN " + i);
              break;
            }
          }
        };

        // method to remove whitespace between branches. Because we do bottom up, we can center the parents.
        var shiftBranchesCloserBottomUp = function shiftBranchesCloserBottomUp(iterations) {
          var levels = Object.keys(_this2.distributionOrdering);
          levels = levels.reverse();
          for (var i = 0; i < iterations; i++) {
            stillShifting = false;
            shiftElementsCloser(branchShiftCallback, levels, true);
            if (stillShifting !== true) {
              //console.log("FINISHED shiftBranchesCloserBottomUp IN " + (i+1));
              break;
            }
          }
        };

        // center all parents
        var centerAllParents = function centerAllParents() {
          for (var nodeId in _this2.body.nodes) {
            if (_this2.body.nodes.hasOwnProperty(nodeId)) _this2._centerParent(_this2.body.nodes[nodeId]);
          }
        };

        // center all parents
        var centerAllParentsBottomUp = function centerAllParentsBottomUp() {
          var levels = Object.keys(_this2.distributionOrdering);
          levels = levels.reverse();
          for (var i = 0; i < levels.length; i++) {
            var level = levels[i];
            var levelNodes = _this2.distributionOrdering[level];
            for (var j = 0; j < levelNodes.length; j++) {
              _this2._centerParent(levelNodes[j]);
            }
          }
        };

        // the actual work is done here.
        if (this.options.hierarchical.blockShifting === true) {
          shiftBranchesCloserBottomUp(5);
          centerAllParents();
        }

        // minimize edge length
        if (this.options.hierarchical.edgeMinimization === true) {
          minimizeEdgeLengthBottomUp(20);
        }

        if (this.options.hierarchical.parentCentralization === true) {
          centerAllParentsBottomUp();
        }

        shiftTrees();
      }

      /**
       * This gives the space around the node. IF a map is supplied, it will only check against nodes NOT in the map.
       * This is used to only get the distances to nodes outside of a branch.
       * @param node
       * @param map
       * @returns {*[]}
       * @private
       */

    }, {
      key: '_getSpaceAroundNode',
      value: function _getSpaceAroundNode(node, map) {
        var useMap = true;
        if (map === undefined) {
          useMap = false;
        }
        var level = this.hierarchicalLevels[node.id];
        if (level !== undefined) {
          var index = this.distributionIndex[node.id];
          var position = this._getPositionForHierarchy(node);
          var minSpace = 1e9;
          var maxSpace = 1e9;
          if (index !== 0) {
            var prevNode = this.distributionOrdering[level][index - 1];
            if (useMap === true && map[prevNode.id] === undefined || useMap === false) {
              var prevPos = this._getPositionForHierarchy(prevNode);
              minSpace = position - prevPos;
            }
          }

          if (index != this.distributionOrdering[level].length - 1) {
            var nextNode = this.distributionOrdering[level][index + 1];
            if (useMap === true && map[nextNode.id] === undefined || useMap === false) {
              var nextPos = this._getPositionForHierarchy(nextNode);
              maxSpace = Math.min(maxSpace, nextPos - position);
            }
          }

          return [minSpace, maxSpace];
        } else {
          return [0, 0];
        }
      }

      /**
       * We use this method to center a parent node and check if it does not cross other nodes when it does.
       * @param node
       * @private
       */

    }, {
      key: '_centerParent',
      value: function _centerParent(node) {
        if (this.hierarchicalParentReference[node.id]) {
          var parents = this.hierarchicalParentReference[node.id];
          for (var i = 0; i < parents.length; i++) {
            var parentId = parents[i];
            var parentNode = this.body.nodes[parentId];
            if (this.hierarchicalChildrenReference[parentId]) {
              // get the range of the children
              var minPos = 1e9;
              var maxPos = -1e9;
              var children = this.hierarchicalChildrenReference[parentId];
              if (children.length > 0) {
                for (var _i5 = 0; _i5 < children.length; _i5++) {
                  var childNode = this.body.nodes[children[_i5]];
                  minPos = Math.min(minPos, this._getPositionForHierarchy(childNode));
                  maxPos = Math.max(maxPos, this._getPositionForHierarchy(childNode));
                }
              }

              var position = this._getPositionForHierarchy(parentNode);

              var _getSpaceAroundNode6 = this._getSpaceAroundNode(parentNode);

              var _getSpaceAroundNode7 = _slicedToArray(_getSpaceAroundNode6, 2);

              var minSpace = _getSpaceAroundNode7[0];
              var maxSpace = _getSpaceAroundNode7[1];

              var newPosition = 0.5 * (minPos + maxPos);
              var diff = position - newPosition;
              if (diff < 0 && Math.abs(diff) < maxSpace - this.options.hierarchical.nodeSpacing || diff > 0 && Math.abs(diff) < minSpace - this.options.hierarchical.nodeSpacing) {
                this._setPositionForHierarchy(parentNode, newPosition, undefined, true);
              }
            }
          }
        }
      }

      /**
       * This function places the nodes on the canvas based on the hierarchial distribution.
       *
       * @param {Object} distribution | obtained by the function this._getDistribution()
       * @private
       */

    }, {
      key: '_placeNodesByHierarchy',
      value: function _placeNodesByHierarchy(distribution) {
        this.positionedNodes = {};
        // start placing all the level 0 nodes first. Then recursively position their branches.
        for (var level in distribution) {
          if (distribution.hasOwnProperty(level)) {
            // sort nodes in level by position:
            var nodeArray = Object.keys(distribution[level]);
            nodeArray = this._indexArrayToNodes(nodeArray);
            this._sortNodeArray(nodeArray);
            var handledNodeCount = 0;

            for (var i = 0; i < nodeArray.length; i++) {
              var node = nodeArray[i];
              if (this.positionedNodes[node.id] === undefined) {
                var pos = this.options.hierarchical.nodeSpacing * handledNodeCount;
                // we get the X or Y values we need and store them in pos and previousPos. The get and set make sure we get X or Y
                if (handledNodeCount > 0) {
                  pos = this._getPositionForHierarchy(nodeArray[i - 1]) + this.options.hierarchical.nodeSpacing;
                }
                this._setPositionForHierarchy(node, pos, level);
                this._validataPositionAndContinue(node, level, pos);

                handledNodeCount++;
              }
            }
          }
        }
      }

      /**
       * This is a recursively called function to enumerate the branches from the largest hubs and place the nodes
       * on a X position that ensures there will be no overlap.
       *
       * @param parentId
       * @param parentLevel
       * @private
       */

    }, {
      key: '_placeBranchNodes',
      value: function _placeBranchNodes(parentId, parentLevel) {
        // if this is not a parent, cancel the placing. This can happen with multiple parents to one child.
        if (this.hierarchicalChildrenReference[parentId] === undefined) {
          return;
        }

        // get a list of childNodes
        var childNodes = [];
        for (var i = 0; i < this.hierarchicalChildrenReference[parentId].length; i++) {
          childNodes.push(this.body.nodes[this.hierarchicalChildrenReference[parentId][i]]);
        }

        // use the positions to order the nodes.
        this._sortNodeArray(childNodes);

        // position the childNodes
        for (var _i6 = 0; _i6 < childNodes.length; _i6++) {
          var childNode = childNodes[_i6];
          var childNodeLevel = this.hierarchicalLevels[childNode.id];
          // check if the child node is below the parent node and if it has already been positioned.
          if (childNodeLevel > parentLevel && this.positionedNodes[childNode.id] === undefined) {
            // get the amount of space required for this node. If parent the width is based on the amount of children.
            var pos = void 0;

            // we get the X or Y values we need and store them in pos and previousPos. The get and set make sure we get X or Y
            if (_i6 === 0) {
              pos = this._getPositionForHierarchy(this.body.nodes[parentId]);
            } else {
              pos = this._getPositionForHierarchy(childNodes[_i6 - 1]) + this.options.hierarchical.nodeSpacing;
            }
            this._setPositionForHierarchy(childNode, pos, childNodeLevel);
            this._validataPositionAndContinue(childNode, childNodeLevel, pos);
          } else {
            return;
          }
        }

        // center the parent nodes.
        var minPos = 1e9;
        var maxPos = -1e9;
        for (var _i7 = 0; _i7 < childNodes.length; _i7++) {
          var childNodeId = childNodes[_i7].id;
          minPos = Math.min(minPos, this._getPositionForHierarchy(this.body.nodes[childNodeId]));
          maxPos = Math.max(maxPos, this._getPositionForHierarchy(this.body.nodes[childNodeId]));
        }
        this._setPositionForHierarchy(this.body.nodes[parentId], 0.5 * (minPos + maxPos), parentLevel);
      }

      /**
       * This method checks for overlap and if required shifts the branch. It also keeps records of positioned nodes.
       * Finally it will call _placeBranchNodes to place the branch nodes.
       * @param node
       * @param level
       * @param pos
       * @private
       */

    }, {
      key: '_validataPositionAndContinue',
      value: function _validataPositionAndContinue(node, level, pos) {
        // if overlap has been detected, we shift the branch
        if (this.lastNodeOnLevel[level] !== undefined) {
          var previousPos = this._getPositionForHierarchy(this.body.nodes[this.lastNodeOnLevel[level]]);
          if (pos - previousPos < this.options.hierarchical.nodeSpacing) {
            var diff = previousPos + this.options.hierarchical.nodeSpacing - pos;
            var sharedParent = this._findCommonParent(this.lastNodeOnLevel[level], node.id);
            this._shiftBlock(sharedParent.withChild, diff);
          }
        }

        // store change in position.
        this.lastNodeOnLevel[level] = node.id;

        this.positionedNodes[node.id] = true;

        this._placeBranchNodes(node.id, level);
      }

      /**
       * Receives an array with node indices and returns an array with the actual node references. Used for sorting based on
       * node properties.
       * @param idArray
       */

    }, {
      key: '_indexArrayToNodes',
      value: function _indexArrayToNodes(idArray) {
        var array = [];
        for (var i = 0; i < idArray.length; i++) {
          array.push(this.body.nodes[idArray[i]]);
        }
        return array;
      }

      /**
       * This function get the distribution of levels based on hubsize
       *
       * @returns {Object}
       * @private
       */

    }, {
      key: '_getDistribution',
      value: function _getDistribution() {
        var distribution = {};
        var nodeId = void 0,
            node = void 0;

        // we fix Y because the hierarchy is vertical, we fix X so we do not give a node an x position for a second time.
        // the fix of X is removed after the x value has been set.
        for (nodeId in this.body.nodes) {
          if (this.body.nodes.hasOwnProperty(nodeId)) {
            node = this.body.nodes[nodeId];
            var level = this.hierarchicalLevels[nodeId] === undefined ? 0 : this.hierarchicalLevels[nodeId];
            if (this.options.hierarchical.direction === 'UD' || this.options.hierarchical.direction === 'DU') {
              node.y = this.options.hierarchical.levelSeparation * level;
              node.options.fixed.y = true;
            } else {
              node.x = this.options.hierarchical.levelSeparation * level;
              node.options.fixed.x = true;
            }
            if (distribution[level] === undefined) {
              distribution[level] = {};
            }
            distribution[level][nodeId] = node;
          }
        }
        return distribution;
      }

      /**
       * Get the hubsize from all remaining unlevelled nodes.
       *
       * @returns {number}
       * @private
       */

    }, {
      key: '_getHubSize',
      value: function _getHubSize() {
        var hubSize = 0;
        for (var nodeId in this.body.nodes) {
          if (this.body.nodes.hasOwnProperty(nodeId)) {
            var node = this.body.nodes[nodeId];
            if (this.hierarchicalLevels[nodeId] === undefined) {
              hubSize = node.edges.length < hubSize ? hubSize : node.edges.length;
            }
          }
        }
        return hubSize;
      }

      /**
       * this function allocates nodes in levels based on the recursive branching from the largest hubs.
       *
       * @param hubsize
       * @private
       */

    }, {
      key: '_determineLevelsByHubsize',
      value: function _determineLevelsByHubsize() {
        var _this3 = this;

        var hubSize = 1;

        var levelDownstream = function levelDownstream(nodeA, nodeB) {
          if (_this3.hierarchicalLevels[nodeB.id] === undefined) {
            // set initial level
            if (_this3.hierarchicalLevels[nodeA.id] === undefined) {
              _this3.hierarchicalLevels[nodeA.id] = 0;
            }
            // set level
            _this3.hierarchicalLevels[nodeB.id] = _this3.hierarchicalLevels[nodeA.id] + 1;
          }
        };

        while (hubSize > 0) {
          // determine hubs
          hubSize = this._getHubSize();
          if (hubSize === 0) break;

          for (var nodeId in this.body.nodes) {
            if (this.body.nodes.hasOwnProperty(nodeId)) {
              var node = this.body.nodes[nodeId];
              if (node.edges.length === hubSize) {
                this._crawlNetwork(levelDownstream, nodeId);
              }
            }
          }
        }
      }

      /**
       * TODO: release feature
       * @private
       */

    }, {
      key: '_determineLevelsCustomCallback',
      value: function _determineLevelsCustomCallback() {
        var _this4 = this;

        var minLevel = 100000;

        // TODO: this should come from options.
        var customCallback = function customCallback(nodeA, nodeB, edge) {};

        var levelByDirection = function levelByDirection(nodeA, nodeB, edge) {
          var levelA = _this4.hierarchicalLevels[nodeA.id];
          // set initial level
          if (levelA === undefined) {
            _this4.hierarchicalLevels[nodeA.id] = minLevel;
          }

          var diff = customCallback(_NetworkUtil2.default.cloneOptions(nodeA, 'node'), _NetworkUtil2.default.cloneOptions(nodeB, 'node'), _NetworkUtil2.default.cloneOptions(edge, 'edge'));

          _this4.hierarchicalLevels[nodeB.id] = _this4.hierarchicalLevels[nodeA.id] + diff;
        };

        this._crawlNetwork(levelByDirection);
        this._setMinLevelToZero();
      }

      /**
       * this function allocates nodes in levels based on the direction of the edges
       *
       * @param hubsize
       * @private
       */

    }, {
      key: '_determineLevelsDirected',
      value: function _determineLevelsDirected() {
        var _this5 = this;

        var minLevel = 10000;
        var levelByDirection = function levelByDirection(nodeA, nodeB, edge) {
          var levelA = _this5.hierarchicalLevels[nodeA.id];
          // set initial level
          if (levelA === undefined) {
            _this5.hierarchicalLevels[nodeA.id] = minLevel;
          }
          if (edge.toId == nodeB.id) {
            _this5.hierarchicalLevels[nodeB.id] = _this5.hierarchicalLevels[nodeA.id] + 1;
          } else {
            _this5.hierarchicalLevels[nodeB.id] = _this5.hierarchicalLevels[nodeA.id] - 1;
          }
        };
        this._crawlNetwork(levelByDirection);
        this._setMinLevelToZero();
      }

      /**
       * Small util method to set the minimum levels of the nodes to zero.
       * @private
       */

    }, {
      key: '_setMinLevelToZero',
      value: function _setMinLevelToZero() {
        var minLevel = 1e9;
        // get the minimum level
        for (var nodeId in this.body.nodes) {
          if (this.body.nodes.hasOwnProperty(nodeId)) {
            if (this.hierarchicalLevels[nodeId] !== undefined) {
              minLevel = Math.min(this.hierarchicalLevels[nodeId], minLevel);
            }
          }
        }

        // subtract the minimum from the set so we have a range starting from 0
        for (var _nodeId2 in this.body.nodes) {
          if (this.body.nodes.hasOwnProperty(_nodeId2)) {
            if (this.hierarchicalLevels[_nodeId2] !== undefined) {
              this.hierarchicalLevels[_nodeId2] -= minLevel;
            }
          }
        }
      }

      /**
       * Update the bookkeeping of parent and child.
       * @private
       */

    }, {
      key: '_generateMap',
      value: function _generateMap() {
        var _this6 = this;

        var fillInRelations = function fillInRelations(parentNode, childNode) {
          if (_this6.hierarchicalLevels[childNode.id] > _this6.hierarchicalLevels[parentNode.id]) {
            var parentNodeId = parentNode.id;
            var childNodeId = childNode.id;
            if (_this6.hierarchicalChildrenReference[parentNodeId] === undefined) {
              _this6.hierarchicalChildrenReference[parentNodeId] = [];
            }
            _this6.hierarchicalChildrenReference[parentNodeId].push(childNodeId);
            if (_this6.hierarchicalParentReference[childNodeId] === undefined) {
              _this6.hierarchicalParentReference[childNodeId] = [];
            }
            _this6.hierarchicalParentReference[childNodeId].push(parentNodeId);
          }
        };

        this._crawlNetwork(fillInRelations);
      }

      /**
       * Crawl over the entire network and use a callback on each node couple that is connected to each other.
       * @param callback          | will receive nodeA nodeB and the connecting edge. A and B are unique.
       * @param startingNodeId
       * @private
       */

    }, {
      key: '_crawlNetwork',
      value: function _crawlNetwork() {
        var _this7 = this;

        var callback = arguments.length <= 0 || arguments[0] === undefined ? function () {} : arguments[0];
        var startingNodeId = arguments[1];

        var progress = {};
        var treeIndex = 0;

        var crawler = function crawler(node, tree) {
          if (progress[node.id] === undefined) {

            if (_this7.hierarchicalTrees[node.id] === undefined) {
              _this7.hierarchicalTrees[node.id] = tree;
              _this7.treeIndex = Math.max(tree, _this7.treeIndex);
            }

            progress[node.id] = true;
            var childNode = void 0;
            for (var i = 0; i < node.edges.length; i++) {
              if (node.edges[i].connected === true) {
                if (node.edges[i].toId === node.id) {
                  childNode = node.edges[i].from;
                } else {
                  childNode = node.edges[i].to;
                }

                if (node.id !== childNode.id) {
                  callback(node, childNode, node.edges[i]);
                  crawler(childNode, tree);
                }
              }
            }
          }
        };

        // we can crawl from a specific node or over all nodes.
        if (startingNodeId === undefined) {
          for (var i = 0; i < this.body.nodeIndices.length; i++) {
            var node = this.body.nodes[this.body.nodeIndices[i]];
            if (progress[node.id] === undefined) {
              crawler(node, treeIndex);
              treeIndex += 1;
            }
          }
        } else {
          var _node = this.body.nodes[startingNodeId];
          if (_node === undefined) {
            console.error("Node not found:", startingNodeId);
            return;
          }
          crawler(_node);
        }
      }

      /**
       * Shift a branch a certain distance
       * @param parentId
       * @param diff
       * @private
       */

    }, {
      key: '_shiftBlock',
      value: function _shiftBlock(parentId, diff) {
        if (this.options.hierarchical.direction === 'UD' || this.options.hierarchical.direction === 'DU') {
          this.body.nodes[parentId].x += diff;
        } else {
          this.body.nodes[parentId].y += diff;
        }
        if (this.hierarchicalChildrenReference[parentId] !== undefined) {
          for (var i = 0; i < this.hierarchicalChildrenReference[parentId].length; i++) {
            this._shiftBlock(this.hierarchicalChildrenReference[parentId][i], diff);
          }
        }
      }

      /**
       * Find a common parent between branches.
       * @param childA
       * @param childB
       * @returns {{foundParent, withChild}}
       * @private
       */

    }, {
      key: '_findCommonParent',
      value: function _findCommonParent(childA, childB) {
        var _this8 = this;

        var parents = {};
        var iterateParents = function iterateParents(parents, child) {
          if (_this8.hierarchicalParentReference[child] !== undefined) {
            for (var i = 0; i < _this8.hierarchicalParentReference[child].length; i++) {
              var parent = _this8.hierarchicalParentReference[child][i];
              parents[parent] = true;
              iterateParents(parents, parent);
            }
          }
        };
        var findParent = function findParent(parents, child) {
          if (_this8.hierarchicalParentReference[child] !== undefined) {
            for (var i = 0; i < _this8.hierarchicalParentReference[child].length; i++) {
              var parent = _this8.hierarchicalParentReference[child][i];
              if (parents[parent] !== undefined) {
                return { foundParent: parent, withChild: child };
              }
              var branch = findParent(parents, parent);
              if (branch.foundParent !== null) {
                return branch;
              }
            }
          }
          return { foundParent: null, withChild: child };
        };

        iterateParents(parents, childA);
        return findParent(parents, childB);
      }

      /**
       * Abstract the getting of the position so we won't have to repeat the check for direction all the time
       * @param node
       * @param position
       * @param level
       * @private
       */

    }, {
      key: '_setPositionForHierarchy',
      value: function _setPositionForHierarchy(node, position, level) {
        var doNotUpdate = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

        //console.log('_setPositionForHierarchy',node.id, position)
        if (doNotUpdate !== true) {
          if (this.distributionOrdering[level] === undefined) {
            this.distributionOrdering[level] = [];
            this.distributionOrderingPresence[level] = {};
          }

          if (this.distributionOrderingPresence[level][node.id] === undefined) {
            this.distributionOrdering[level].push(node);
            this.distributionIndex[node.id] = this.distributionOrdering[level].length - 1;
          }
          this.distributionOrderingPresence[level][node.id] = true;
        }

        if (this.options.hierarchical.direction === 'UD' || this.options.hierarchical.direction === 'DU') {
          node.x = position;
        } else {
          node.y = position;
        }
      }

      /**
       * Abstract the getting of the position of a node so we do not have to repeat the direction check all the time.
       * @param node
       * @returns {number|*}
       * @private
       */

    }, {
      key: '_getPositionForHierarchy',
      value: function _getPositionForHierarchy(node) {
        if (this.options.hierarchical.direction === 'UD' || this.options.hierarchical.direction === 'DU') {
          return node.x;
        } else {
          return node.y;
        }
      }

      /**
       * Use the x or y value to sort the array, allowing users to specify order.
       * @param nodeArray
       * @private
       */

    }, {
      key: '_sortNodeArray',
      value: function _sortNodeArray(nodeArray) {
        if (nodeArray.length > 1) {
          if (this.options.hierarchical.direction === 'UD' || this.options.hierarchical.direction === 'DU') {
            nodeArray.sort(function (a, b) {
              return a.x - b.x;
            });
          } else {
            nodeArray.sort(function (a, b) {
              return a.y - b.y;
            });
          }
        }
      }
    }]);

    return LayoutEngine;
  }();

  exports.default = LayoutEngine;

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);
  var Hammer = __webpack_require__(20);
  var hammerUtil = __webpack_require__(28);

  /**
   * clears the toolbar div element of children
   *
   * @private
   */

  var ManipulationSystem = function () {
    function ManipulationSystem(body, canvas, selectionHandler) {
      var _this = this;

      _classCallCheck(this, ManipulationSystem);

      this.body = body;
      this.canvas = canvas;
      this.selectionHandler = selectionHandler;

      this.editMode = false;
      this.manipulationDiv = undefined;
      this.editModeDiv = undefined;
      this.closeDiv = undefined;

      this.manipulationHammers = [];
      this.temporaryUIFunctions = {};
      this.temporaryEventFunctions = [];

      this.touchTime = 0;
      this.temporaryIds = { nodes: [], edges: [] };
      this.guiEnabled = false;
      this.inMode = false;
      this.selectedControlNode = undefined;

      this.options = {};
      this.defaultOptions = {
        enabled: false,
        initiallyActive: false,
        addNode: true,
        addEdge: true,
        editNode: undefined,
        editEdge: true,
        deleteNode: true,
        deleteEdge: true,
        controlNodeStyle: {
          shape: 'dot',
          size: 6,
          color: { background: '#ff0000', border: '#3c3c3c', highlight: { background: '#07f968', border: '#3c3c3c' } },
          borderWidth: 2,
          borderWidthSelected: 2
        }
      };
      util.extend(this.options, this.defaultOptions);

      this.body.emitter.on('destroy', function () {
        _this._clean();
      });
      this.body.emitter.on('_dataChanged', this._restore.bind(this));
      this.body.emitter.on('_resetData', this._restore.bind(this));
    }

    /**
     * If something changes in the data during editing, switch back to the initial datamanipulation state and close all edit modes.
     * @private
     */


    _createClass(ManipulationSystem, [{
      key: '_restore',
      value: function _restore() {
        if (this.inMode !== false) {
          if (this.options.initiallyActive === true) {
            this.enableEditMode();
          } else {
            this.disableEditMode();
          }
        }
      }

      /**
       * Set the Options
       * @param options
       */

    }, {
      key: 'setOptions',
      value: function setOptions(options, allOptions, globalOptions) {
        if (allOptions !== undefined) {
          if (allOptions.locale !== undefined) {
            this.options.locale = allOptions.locale;
          } else {
            this.options.locale = globalOptions.locale;
          }
          if (allOptions.locales !== undefined) {
            this.options.locales = allOptions.locales;
          } else {
            this.options.locales = globalOptions.locales;
          }
        }

        if (options !== undefined) {
          if (typeof options === 'boolean') {
            this.options.enabled = options;
          } else {
            this.options.enabled = true;
            util.deepExtend(this.options, options);
          }
          if (this.options.initiallyActive === true) {
            this.editMode = true;
          }
          this._setup();
        }
      }

      /**
       * Enable or disable edit-mode. Draws the DOM required and cleans up after itself.
       *
       * @private
       */

    }, {
      key: 'toggleEditMode',
      value: function toggleEditMode() {
        if (this.editMode === true) {
          this.disableEditMode();
        } else {
          this.enableEditMode();
        }
      }
    }, {
      key: 'enableEditMode',
      value: function enableEditMode() {
        this.editMode = true;

        this._clean();
        if (this.guiEnabled === true) {
          this.manipulationDiv.style.display = 'block';
          this.closeDiv.style.display = 'block';
          this.editModeDiv.style.display = 'none';
          this.showManipulatorToolbar();
        }
      }
    }, {
      key: 'disableEditMode',
      value: function disableEditMode() {
        this.editMode = false;

        this._clean();
        if (this.guiEnabled === true) {
          this.manipulationDiv.style.display = 'none';
          this.closeDiv.style.display = 'none';
          this.editModeDiv.style.display = 'block';
          this._createEditButton();
        }
      }

      /**
       * Creates the main toolbar. Removes functions bound to the select event. Binds all the buttons of the toolbar.
       *
       * @private
       */

    }, {
      key: 'showManipulatorToolbar',
      value: function showManipulatorToolbar() {
        // restore the state of any bound functions or events, remove control nodes, restore physics
        this._clean();

        // reset global variables
        this.manipulationDOM = {};

        // if the gui is enabled, draw all elements.
        if (this.guiEnabled === true) {
          // a _restore will hide these menus
          this.editMode = true;
          this.manipulationDiv.style.display = 'block';
          this.closeDiv.style.display = 'block';

          var selectedNodeCount = this.selectionHandler._getSelectedNodeCount();
          var selectedEdgeCount = this.selectionHandler._getSelectedEdgeCount();
          var selectedTotalCount = selectedNodeCount + selectedEdgeCount;
          var locale = this.options.locales[this.options.locale];
          var needSeperator = false;

          if (this.options.addNode !== false) {
            this._createAddNodeButton(locale);
            needSeperator = true;
          }
          if (this.options.addEdge !== false) {
            if (needSeperator === true) {
              this._createSeperator(1);
            } else {
              needSeperator = true;
            }
            this._createAddEdgeButton(locale);
          }

          if (selectedNodeCount === 1 && typeof this.options.editNode === 'function') {
            if (needSeperator === true) {
              this._createSeperator(2);
            } else {
              needSeperator = true;
            }
            this._createEditNodeButton(locale);
          } else if (selectedEdgeCount === 1 && selectedNodeCount === 0 && this.options.editEdge !== false) {
            if (needSeperator === true) {
              this._createSeperator(3);
            } else {
              needSeperator = true;
            }
            this._createEditEdgeButton(locale);
          }

          // remove buttons
          if (selectedTotalCount !== 0) {
            if (selectedNodeCount > 0 && this.options.deleteNode !== false) {
              if (needSeperator === true) {
                this._createSeperator(4);
              }
              this._createDeleteButton(locale);
            } else if (selectedNodeCount === 0 && this.options.deleteEdge !== false) {
              if (needSeperator === true) {
                this._createSeperator(4);
              }
              this._createDeleteButton(locale);
            }
          }

          // bind the close button
          this._bindHammerToDiv(this.closeDiv, this.toggleEditMode.bind(this));

          // refresh this bar based on what has been selected
          this._temporaryBindEvent('select', this.showManipulatorToolbar.bind(this));
        }

        // redraw to show any possible changes
        this.body.emitter.emit('_redraw');
      }

      /**
       * Create the toolbar for adding Nodes
       */

    }, {
      key: 'addNodeMode',
      value: function addNodeMode() {
        // when using the gui, enable edit mode if it wasnt already.
        if (this.editMode !== true) {
          this.enableEditMode();
        }

        // restore the state of any bound functions or events, remove control nodes, restore physics
        this._clean();

        this.inMode = 'addNode';
        if (this.guiEnabled === true) {
          var locale = this.options.locales[this.options.locale];
          this.manipulationDOM = {};
          this._createBackButton(locale);
          this._createSeperator();
          this._createDescription(locale['addDescription'] || this.options.locales['en']['addDescription']);

          // bind the close button
          this._bindHammerToDiv(this.closeDiv, this.toggleEditMode.bind(this));
        }

        this._temporaryBindEvent('click', this._performAddNode.bind(this));
      }

      /**
       * call the bound function to handle the editing of the node. The node has to be selected.
       */

    }, {
      key: 'editNode',
      value: function editNode() {
        var _this2 = this;

        // when using the gui, enable edit mode if it wasnt already.
        if (this.editMode !== true) {
          this.enableEditMode();
        }

        // restore the state of any bound functions or events, remove control nodes, restore physics
        this._clean();
        var node = this.selectionHandler._getSelectedNode();
        if (node !== undefined) {
          this.inMode = 'editNode';
          if (typeof this.options.editNode === 'function') {
            if (node.isCluster !== true) {
              var data = util.deepExtend({}, node.options, false);
              data.x = node.x;
              data.y = node.y;

              if (this.options.editNode.length === 2) {
                this.options.editNode(data, function (finalizedData) {
                  if (finalizedData !== null && finalizedData !== undefined && _this2.inMode === 'editNode') {
                    // if for whatever reason the mode has changes (due to dataset change) disregard the callback) {
                    _this2.body.data.nodes.getDataSet().update(finalizedData);
                  }
                  _this2.showManipulatorToolbar();
                });
              } else {
                throw new Error('The function for edit does not support two arguments (data, callback)');
              }
            } else {
              alert(this.options.locales[this.options.locale]['editClusterError'] || this.options.locales['en']['editClusterError']);
            }
          } else {
            throw new Error('No function has been configured to handle the editing of nodes.');
          }
        } else {
          this.showManipulatorToolbar();
        }
      }

      /**
       * create the toolbar to connect nodes
       */

    }, {
      key: 'addEdgeMode',
      value: function addEdgeMode() {
        // when using the gui, enable edit mode if it wasnt already.
        if (this.editMode !== true) {
          this.enableEditMode();
        }

        // restore the state of any bound functions or events, remove control nodes, restore physics
        this._clean();

        this.inMode = 'addEdge';
        if (this.guiEnabled === true) {
          var locale = this.options.locales[this.options.locale];
          this.manipulationDOM = {};
          this._createBackButton(locale);
          this._createSeperator();
          this._createDescription(locale['edgeDescription'] || this.options.locales['en']['edgeDescription']);

          // bind the close button
          this._bindHammerToDiv(this.closeDiv, this.toggleEditMode.bind(this));
        }

        // temporarily overload functions
        this._temporaryBindUI('onTouch', this._handleConnect.bind(this));
        this._temporaryBindUI('onDragEnd', this._finishConnect.bind(this));
        this._temporaryBindUI('onDrag', this._dragControlNode.bind(this));
        this._temporaryBindUI('onRelease', this._finishConnect.bind(this));

        this._temporaryBindUI('onDragStart', function () {});
        this._temporaryBindUI('onHold', function () {});
      }

      /**
       * create the toolbar to edit edges
       */

    }, {
      key: 'editEdgeMode',
      value: function editEdgeMode() {
        var _this3 = this;

        // when using the gui, enable edit mode if it wasn't already.
        if (this.editMode !== true) {
          this.enableEditMode();
        }

        // restore the state of any bound functions or events, remove control nodes, restore physics
        this._clean();

        this.inMode = 'editEdge';
        if (this.guiEnabled === true) {
          var locale = this.options.locales[this.options.locale];
          this.manipulationDOM = {};
          this._createBackButton(locale);
          this._createSeperator();
          this._createDescription(locale['editEdgeDescription'] || this.options.locales['en']['editEdgeDescription']);

          // bind the close button
          this._bindHammerToDiv(this.closeDiv, this.toggleEditMode.bind(this));
        }

        this.edgeBeingEditedId = this.selectionHandler.getSelectedEdges()[0];
        if (this.edgeBeingEditedId !== undefined) {
          (function () {
            var edge = _this3.body.edges[_this3.edgeBeingEditedId];

            // create control nodes
            var controlNodeFrom = _this3._getNewTargetNode(edge.from.x, edge.from.y);
            var controlNodeTo = _this3._getNewTargetNode(edge.to.x, edge.to.y);

            _this3.temporaryIds.nodes.push(controlNodeFrom.id);
            _this3.temporaryIds.nodes.push(controlNodeTo.id);

            _this3.body.nodes[controlNodeFrom.id] = controlNodeFrom;
            _this3.body.nodeIndices.push(controlNodeFrom.id);
            _this3.body.nodes[controlNodeTo.id] = controlNodeTo;
            _this3.body.nodeIndices.push(controlNodeTo.id);

            // temporarily overload UI functions, cleaned up automatically because of _temporaryBindUI
            _this3._temporaryBindUI('onTouch', _this3._controlNodeTouch.bind(_this3)); // used to get the position
            _this3._temporaryBindUI('onTap', function () {}); // disabled
            _this3._temporaryBindUI('onHold', function () {}); // disabled
            _this3._temporaryBindUI('onDragStart', _this3._controlNodeDragStart.bind(_this3)); // used to select control node
            _this3._temporaryBindUI('onDrag', _this3._controlNodeDrag.bind(_this3)); // used to drag control node
            _this3._temporaryBindUI('onDragEnd', _this3._controlNodeDragEnd.bind(_this3)); // used to connect or revert control nodes
            _this3._temporaryBindUI('onMouseMove', function () {}); // disabled

            // create function to position control nodes correctly on movement
            // automatically cleaned up because we use the temporary bind
            _this3._temporaryBindEvent('beforeDrawing', function (ctx) {
              var positions = edge.edgeType.findBorderPositions(ctx);
              if (controlNodeFrom.selected === false) {
                controlNodeFrom.x = positions.from.x;
                controlNodeFrom.y = positions.from.y;
              }
              if (controlNodeTo.selected === false) {
                controlNodeTo.x = positions.to.x;
                controlNodeTo.y = positions.to.y;
              }
            });

            _this3.body.emitter.emit('_redraw');
          })();
        } else {
          this.showManipulatorToolbar();
        }
      }

      /**
       * delete everything in the selection
       */

    }, {
      key: 'deleteSelected',
      value: function deleteSelected() {
        var _this4 = this;

        // when using the gui, enable edit mode if it wasnt already.
        if (this.editMode !== true) {
          this.enableEditMode();
        }

        // restore the state of any bound functions or events, remove control nodes, restore physics
        this._clean();

        this.inMode = 'delete';
        var selectedNodes = this.selectionHandler.getSelectedNodes();
        var selectedEdges = this.selectionHandler.getSelectedEdges();
        var deleteFunction = undefined;
        if (selectedNodes.length > 0) {
          for (var i = 0; i < selectedNodes.length; i++) {
            if (this.body.nodes[selectedNodes[i]].isCluster === true) {
              alert(this.options.locales[this.options.locale]['deleteClusterError'] || this.options.locales['en']['deleteClusterError']);
              return;
            }
          }

          if (typeof this.options.deleteNode === 'function') {
            deleteFunction = this.options.deleteNode;
          }
        } else if (selectedEdges.length > 0) {
          if (typeof this.options.deleteEdge === 'function') {
            deleteFunction = this.options.deleteEdge;
          }
        }

        if (typeof deleteFunction === 'function') {
          var data = { nodes: selectedNodes, edges: selectedEdges };
          if (deleteFunction.length === 2) {
            deleteFunction(data, function (finalizedData) {
              if (finalizedData !== null && finalizedData !== undefined && _this4.inMode === 'delete') {
                // if for whatever reason the mode has changes (due to dataset change) disregard the callback) {
                _this4.body.data.edges.getDataSet().remove(finalizedData.edges);
                _this4.body.data.nodes.getDataSet().remove(finalizedData.nodes);
                _this4.body.emitter.emit('startSimulation');
                _this4.showManipulatorToolbar();
              } else {
                _this4.body.emitter.emit('startSimulation');
                _this4.showManipulatorToolbar();
              }
            });
          } else {
            throw new Error('The function for delete does not support two arguments (data, callback)');
          }
        } else {
          this.body.data.edges.getDataSet().remove(selectedEdges);
          this.body.data.nodes.getDataSet().remove(selectedNodes);
          this.body.emitter.emit('startSimulation');
          this.showManipulatorToolbar();
        }
      }

      //********************************************** PRIVATE ***************************************//

      /**
       * draw or remove the DOM
       * @private
       */

    }, {
      key: '_setup',
      value: function _setup() {
        if (this.options.enabled === true) {
          // Enable the GUI
          this.guiEnabled = true;

          this._createWrappers();
          if (this.editMode === false) {
            this._createEditButton();
          } else {
            this.showManipulatorToolbar();
          }
        } else {
          this._removeManipulationDOM();

          // disable the gui
          this.guiEnabled = false;
        }
      }

      /**
       * create the div overlays that contain the DOM
       * @private
       */

    }, {
      key: '_createWrappers',
      value: function _createWrappers() {
        // load the manipulator HTML elements. All styling done in css.
        if (this.manipulationDiv === undefined) {
          this.manipulationDiv = document.createElement('div');
          this.manipulationDiv.className = 'vis-manipulation';
          if (this.editMode === true) {
            this.manipulationDiv.style.display = 'block';
          } else {
            this.manipulationDiv.style.display = 'none';
          }
          this.canvas.frame.appendChild(this.manipulationDiv);
        }

        // container for the edit button.
        if (this.editModeDiv === undefined) {
          this.editModeDiv = document.createElement('div');
          this.editModeDiv.className = 'vis-edit-mode';
          if (this.editMode === true) {
            this.editModeDiv.style.display = 'none';
          } else {
            this.editModeDiv.style.display = 'block';
          }
          this.canvas.frame.appendChild(this.editModeDiv);
        }

        // container for the close div button
        if (this.closeDiv === undefined) {
          this.closeDiv = document.createElement('div');
          this.closeDiv.className = 'vis-close';
          this.closeDiv.style.display = this.manipulationDiv.style.display;
          this.canvas.frame.appendChild(this.closeDiv);
        }
      }

      /**
       * generate a new target node. Used for creating new edges and editing edges
       * @param x
       * @param y
       * @returns {*}
       * @private
       */

    }, {
      key: '_getNewTargetNode',
      value: function _getNewTargetNode(x, y) {
        var controlNodeStyle = util.deepExtend({}, this.options.controlNodeStyle);

        controlNodeStyle.id = 'targetNode' + util.randomUUID();
        controlNodeStyle.hidden = false;
        controlNodeStyle.physics = false;
        controlNodeStyle.x = x;
        controlNodeStyle.y = y;

        // we have to define the bounding box in order for the nodes to be drawn immediately
        var node = this.body.functions.createNode(controlNodeStyle);
        node.shape.boundingBox = { left: x, right: x, top: y, bottom: y };

        return node;
      }

      /**
       * Create the edit button
       */

    }, {
      key: '_createEditButton',
      value: function _createEditButton() {
        // restore everything to it's original state (if applicable)
        this._clean();

        // reset the manipulationDOM
        this.manipulationDOM = {};

        // empty the editModeDiv
        util.recursiveDOMDelete(this.editModeDiv);

        // create the contents for the editMode button
        var locale = this.options.locales[this.options.locale];
        var button = this._createButton('editMode', 'vis-button vis-edit vis-edit-mode', locale['edit'] || this.options.locales['en']['edit']);
        this.editModeDiv.appendChild(button);

        // bind a hammer listener to the button, calling the function toggleEditMode.
        this._bindHammerToDiv(button, this.toggleEditMode.bind(this));
      }

      /**
       * this function cleans up after everything this module does. Temporary elements, functions and events are removed, physics restored, hammers removed.
       * @private
       */

    }, {
      key: '_clean',
      value: function _clean() {
        // not in mode
        this.inMode = false;

        // _clean the divs
        if (this.guiEnabled === true) {
          util.recursiveDOMDelete(this.editModeDiv);
          util.recursiveDOMDelete(this.manipulationDiv);

          // removes all the bindings and overloads
          this._cleanManipulatorHammers();
        }

        // remove temporary nodes and edges
        this._cleanupTemporaryNodesAndEdges();

        // restore overloaded UI functions
        this._unbindTemporaryUIs();

        // remove the temporaryEventFunctions
        this._unbindTemporaryEvents();

        // restore the physics if required
        this.body.emitter.emit('restorePhysics');
      }

      /**
       * Each dom element has it's own hammer. They are stored in this.manipulationHammers. This cleans them up.
       * @private
       */

    }, {
      key: '_cleanManipulatorHammers',
      value: function _cleanManipulatorHammers() {
        // _clean hammer bindings
        if (this.manipulationHammers.length != 0) {
          for (var i = 0; i < this.manipulationHammers.length; i++) {
            this.manipulationHammers[i].destroy();
          }
          this.manipulationHammers = [];
        }
      }

      /**
       * Remove all DOM elements created by this module.
       * @private
       */

    }, {
      key: '_removeManipulationDOM',
      value: function _removeManipulationDOM() {
        // removes all the bindings and overloads
        this._clean();

        // empty the manipulation divs
        util.recursiveDOMDelete(this.manipulationDiv);
        util.recursiveDOMDelete(this.editModeDiv);
        util.recursiveDOMDelete(this.closeDiv);

        // remove the manipulation divs
        if (this.manipulationDiv) {
          this.canvas.frame.removeChild(this.manipulationDiv);
        }
        if (this.editModeDiv) {
          this.canvas.frame.removeChild(this.editModeDiv);
        }
        if (this.closeDiv) {
          this.canvas.frame.removeChild(this.closeDiv);
        }

        // set the references to undefined
        this.manipulationDiv = undefined;
        this.editModeDiv = undefined;
        this.closeDiv = undefined;
      }

      /**
       * create a seperator line. the index is to differentiate in the manipulation dom
       * @param index
       * @private
       */

    }, {
      key: '_createSeperator',
      value: function _createSeperator() {
        var index = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];

        this.manipulationDOM['seperatorLineDiv' + index] = document.createElement('div');
        this.manipulationDOM['seperatorLineDiv' + index].className = 'vis-separator-line';
        this.manipulationDiv.appendChild(this.manipulationDOM['seperatorLineDiv' + index]);
      }

      // ----------------------    DOM functions for buttons    --------------------------//

    }, {
      key: '_createAddNodeButton',
      value: function _createAddNodeButton(locale) {
        var button = this._createButton('addNode', 'vis-button vis-add', locale['addNode'] || this.options.locales['en']['addNode']);
        this.manipulationDiv.appendChild(button);
        this._bindHammerToDiv(button, this.addNodeMode.bind(this));
      }
    }, {
      key: '_createAddEdgeButton',
      value: function _createAddEdgeButton(locale) {
        var button = this._createButton('addEdge', 'vis-button vis-connect', locale['addEdge'] || this.options.locales['en']['addEdge']);
        this.manipulationDiv.appendChild(button);
        this._bindHammerToDiv(button, this.addEdgeMode.bind(this));
      }
    }, {
      key: '_createEditNodeButton',
      value: function _createEditNodeButton(locale) {
        var button = this._createButton('editNode', 'vis-button vis-edit', locale['editNode'] || this.options.locales['en']['editNode']);
        this.manipulationDiv.appendChild(button);
        this._bindHammerToDiv(button, this.editNode.bind(this));
      }
    }, {
      key: '_createEditEdgeButton',
      value: function _createEditEdgeButton(locale) {
        var button = this._createButton('editEdge', 'vis-button vis-edit', locale['editEdge'] || this.options.locales['en']['editEdge']);
        this.manipulationDiv.appendChild(button);
        this._bindHammerToDiv(button, this.editEdgeMode.bind(this));
      }
    }, {
      key: '_createDeleteButton',
      value: function _createDeleteButton(locale) {
        if (this.options.rtl) {
          var deleteBtnClass = 'vis-button vis-delete-rtl';
        } else {
          var deleteBtnClass = 'vis-button vis-delete';
        }
        var button = this._createButton('delete', deleteBtnClass, locale['del'] || this.options.locales['en']['del']);
        this.manipulationDiv.appendChild(button);
        this._bindHammerToDiv(button, this.deleteSelected.bind(this));
      }
    }, {
      key: '_createBackButton',
      value: function _createBackButton(locale) {
        var button = this._createButton('back', 'vis-button vis-back', locale['back'] || this.options.locales['en']['back']);
        this.manipulationDiv.appendChild(button);
        this._bindHammerToDiv(button, this.showManipulatorToolbar.bind(this));
      }
    }, {
      key: '_createButton',
      value: function _createButton(id, className, label) {
        var labelClassName = arguments.length <= 3 || arguments[3] === undefined ? 'vis-label' : arguments[3];


        this.manipulationDOM[id + 'Div'] = document.createElement('div');
        this.manipulationDOM[id + 'Div'].className = className;
        this.manipulationDOM[id + 'Label'] = document.createElement('div');
        this.manipulationDOM[id + 'Label'].className = labelClassName;
        this.manipulationDOM[id + 'Label'].innerHTML = label;
        this.manipulationDOM[id + 'Div'].appendChild(this.manipulationDOM[id + 'Label']);
        return this.manipulationDOM[id + 'Div'];
      }
    }, {
      key: '_createDescription',
      value: function _createDescription(label) {
        this.manipulationDiv.appendChild(this._createButton('description', 'vis-button vis-none', label));
      }

      // -------------------------- End of DOM functions for buttons ------------------------------//

      /**
       * this binds an event until cleanup by the clean functions.
       * @param event
       * @param newFunction
       * @private
       */

    }, {
      key: '_temporaryBindEvent',
      value: function _temporaryBindEvent(event, newFunction) {
        this.temporaryEventFunctions.push({ event: event, boundFunction: newFunction });
        this.body.emitter.on(event, newFunction);
      }

      /**
       * this overrides an UI function until cleanup by the clean function
       * @param UIfunctionName
       * @param newFunction
       * @private
       */

    }, {
      key: '_temporaryBindUI',
      value: function _temporaryBindUI(UIfunctionName, newFunction) {
        if (this.body.eventListeners[UIfunctionName] !== undefined) {
          this.temporaryUIFunctions[UIfunctionName] = this.body.eventListeners[UIfunctionName];
          this.body.eventListeners[UIfunctionName] = newFunction;
        } else {
          throw new Error('This UI function does not exist. Typo? You tried: ' + UIfunctionName + ' possible are: ' + JSON.stringify(Object.keys(this.body.eventListeners)));
        }
      }

      /**
       * Restore the overridden UI functions to their original state.
       *
       * @private
       */

    }, {
      key: '_unbindTemporaryUIs',
      value: function _unbindTemporaryUIs() {
        for (var functionName in this.temporaryUIFunctions) {
          if (this.temporaryUIFunctions.hasOwnProperty(functionName)) {
            this.body.eventListeners[functionName] = this.temporaryUIFunctions[functionName];
            delete this.temporaryUIFunctions[functionName];
          }
        }
        this.temporaryUIFunctions = {};
      }

      /**
       * Unbind the events created by _temporaryBindEvent
       * @private
       */

    }, {
      key: '_unbindTemporaryEvents',
      value: function _unbindTemporaryEvents() {
        for (var i = 0; i < this.temporaryEventFunctions.length; i++) {
          var eventName = this.temporaryEventFunctions[i].event;
          var boundFunction = this.temporaryEventFunctions[i].boundFunction;
          this.body.emitter.off(eventName, boundFunction);
        }
        this.temporaryEventFunctions = [];
      }

      /**
       * Bind an hammer instance to a DOM element.
       * @param domElement
       * @param funct
       */

    }, {
      key: '_bindHammerToDiv',
      value: function _bindHammerToDiv(domElement, boundFunction) {
        var hammer = new Hammer(domElement, {});
        hammerUtil.onTouch(hammer, boundFunction);
        this.manipulationHammers.push(hammer);
      }

      /**
       * Neatly clean up temporary edges and nodes
       * @private
       */

    }, {
      key: '_cleanupTemporaryNodesAndEdges',
      value: function _cleanupTemporaryNodesAndEdges() {
        // _clean temporary edges
        for (var i = 0; i < this.temporaryIds.edges.length; i++) {
          this.body.edges[this.temporaryIds.edges[i]].disconnect();
          delete this.body.edges[this.temporaryIds.edges[i]];
          var indexTempEdge = this.body.edgeIndices.indexOf(this.temporaryIds.edges[i]);
          if (indexTempEdge !== -1) {
            this.body.edgeIndices.splice(indexTempEdge, 1);
          }
        }

        // _clean temporary nodes
        for (var _i = 0; _i < this.temporaryIds.nodes.length; _i++) {
          delete this.body.nodes[this.temporaryIds.nodes[_i]];
          var indexTempNode = this.body.nodeIndices.indexOf(this.temporaryIds.nodes[_i]);
          if (indexTempNode !== -1) {
            this.body.nodeIndices.splice(indexTempNode, 1);
          }
        }

        this.temporaryIds = { nodes: [], edges: [] };
      }

      // ------------------------------------------ EDIT EDGE FUNCTIONS -----------------------------------------//

      /**
       * the touch is used to get the position of the initial click
       * @param event
       * @private
       */

    }, {
      key: '_controlNodeTouch',
      value: function _controlNodeTouch(event) {
        this.selectionHandler.unselectAll();
        this.lastTouch = this.body.functions.getPointer(event.center);
        this.lastTouch.translation = util.extend({}, this.body.view.translation); // copy the object
      }

      /**
       * the drag start is used to mark one of the control nodes as selected.
       * @param event
       * @private
       */

    }, {
      key: '_controlNodeDragStart',
      value: function _controlNodeDragStart(event) {
        var pointer = this.lastTouch;
        var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);
        var from = this.body.nodes[this.temporaryIds.nodes[0]];
        var to = this.body.nodes[this.temporaryIds.nodes[1]];
        var edge = this.body.edges[this.edgeBeingEditedId];
        this.selectedControlNode = undefined;

        var fromSelect = from.isOverlappingWith(pointerObj);
        var toSelect = to.isOverlappingWith(pointerObj);

        if (fromSelect === true) {
          this.selectedControlNode = from;
          edge.edgeType.from = from;
        } else if (toSelect === true) {
          this.selectedControlNode = to;
          edge.edgeType.to = to;
        }

        // we use the selection to find the node that is being dragged. We explicitly select it here.
        if (this.selectedControlNode !== undefined) {
          this.selectionHandler.selectObject(this.selectedControlNode);
        }

        this.body.emitter.emit('_redraw');
      }

      /**
       * dragging the control nodes or the canvas
       * @param event
       * @private
       */

    }, {
      key: '_controlNodeDrag',
      value: function _controlNodeDrag(event) {
        this.body.emitter.emit('disablePhysics');
        var pointer = this.body.functions.getPointer(event.center);
        var pos = this.canvas.DOMtoCanvas(pointer);
        if (this.selectedControlNode !== undefined) {
          this.selectedControlNode.x = pos.x;
          this.selectedControlNode.y = pos.y;
        } else {
          // if the drag was not started properly because the click started outside the network div, start it now.
          var diffX = pointer.x - this.lastTouch.x;
          var diffY = pointer.y - this.lastTouch.y;
          this.body.view.translation = { x: this.lastTouch.translation.x + diffX, y: this.lastTouch.translation.y + diffY };
        }
        this.body.emitter.emit('_redraw');
      }

      /**
       * connecting or restoring the control nodes.
       * @param event
       * @private
       */

    }, {
      key: '_controlNodeDragEnd',
      value: function _controlNodeDragEnd(event) {
        var pointer = this.body.functions.getPointer(event.center);
        var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);
        var edge = this.body.edges[this.edgeBeingEditedId];
        // if the node that was dragged is not a control node, return
        if (this.selectedControlNode === undefined) {
          return;
        }

        // we use the selection to find the node that is being dragged. We explicitly DEselect the control node here.
        this.selectionHandler.unselectAll();
        var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);
        var node = undefined;
        for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {
          if (overlappingNodeIds[i] !== this.selectedControlNode.id) {
            node = this.body.nodes[overlappingNodeIds[i]];
            break;
          }
        }
        // perform the connection
        if (node !== undefined && this.selectedControlNode !== undefined) {
          if (node.isCluster === true) {
            alert(this.options.locales[this.options.locale]['createEdgeError'] || this.options.locales['en']['createEdgeError']);
          } else {
            var from = this.body.nodes[this.temporaryIds.nodes[0]];
            if (this.selectedControlNode.id === from.id) {
              this._performEditEdge(node.id, edge.to.id);
            } else {
              this._performEditEdge(edge.from.id, node.id);
            }
          }
        } else {
          edge.updateEdgeType();
          this.body.emitter.emit('restorePhysics');
        }
        this.body.emitter.emit('_redraw');
      }

      // ------------------------------------ END OF EDIT EDGE FUNCTIONS -----------------------------------------//

      // ------------------------------------------- ADD EDGE FUNCTIONS -----------------------------------------//
      /**
       * the function bound to the selection event. It checks if you want to connect a cluster and changes the description
       * to walk the user through the process.
       *
       * @private
       */

    }, {
      key: '_handleConnect',
      value: function _handleConnect(event) {
        // check to avoid double fireing of this function.
        if (new Date().valueOf() - this.touchTime > 100) {
          this.lastTouch = this.body.functions.getPointer(event.center);
          this.lastTouch.translation = util.extend({}, this.body.view.translation); // copy the object

          var pointer = this.lastTouch;
          var node = this.selectionHandler.getNodeAt(pointer);

          if (node !== undefined) {
            if (node.isCluster === true) {
              alert(this.options.locales[this.options.locale]['createEdgeError'] || this.options.locales['en']['createEdgeError']);
            } else {
              // create a node the temporary line can look at
              var targetNode = this._getNewTargetNode(node.x, node.y);
              this.body.nodes[targetNode.id] = targetNode;
              this.body.nodeIndices.push(targetNode.id);

              // create a temporary edge
              var connectionEdge = this.body.functions.createEdge({
                id: 'connectionEdge' + util.randomUUID(),
                from: node.id,
                to: targetNode.id,
                physics: false,
                smooth: {
                  enabled: true,
                  type: 'continuous',
                  roundness: 0.5
                }
              });
              this.body.edges[connectionEdge.id] = connectionEdge;
              this.body.edgeIndices.push(connectionEdge.id);

              this.temporaryIds.nodes.push(targetNode.id);
              this.temporaryIds.edges.push(connectionEdge.id);
            }
          }
          this.touchTime = new Date().valueOf();
        }
      }
    }, {
      key: '_dragControlNode',
      value: function _dragControlNode(event) {
        var pointer = this.body.functions.getPointer(event.center);
        if (this.temporaryIds.nodes[0] !== undefined) {
          var targetNode = this.body.nodes[this.temporaryIds.nodes[0]]; // there is only one temp node in the add edge mode.
          targetNode.x = this.canvas._XconvertDOMtoCanvas(pointer.x);
          targetNode.y = this.canvas._YconvertDOMtoCanvas(pointer.y);
          this.body.emitter.emit('_redraw');
        } else {
          var diffX = pointer.x - this.lastTouch.x;
          var diffY = pointer.y - this.lastTouch.y;
          this.body.view.translation = { x: this.lastTouch.translation.x + diffX, y: this.lastTouch.translation.y + diffY };
        }
      }

      /**
       * Connect the new edge to the target if one exists, otherwise remove temp line
       * @param event
       * @private
       */

    }, {
      key: '_finishConnect',
      value: function _finishConnect(event) {
        var pointer = this.body.functions.getPointer(event.center);
        var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);

        // remember the edge id
        var connectFromId = undefined;
        if (this.temporaryIds.edges[0] !== undefined) {
          connectFromId = this.body.edges[this.temporaryIds.edges[0]].fromId;
        }

        // get the overlapping node but NOT the temporary node;
        var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);
        var node = undefined;
        for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {
          // if the node id is NOT a temporary node, accept the node.
          if (this.temporaryIds.nodes.indexOf(overlappingNodeIds[i]) === -1) {
            node = this.body.nodes[overlappingNodeIds[i]];
            break;
          }
        }

        // clean temporary nodes and edges.
        this._cleanupTemporaryNodesAndEdges();

        // perform the connection
        if (node !== undefined) {
          if (node.isCluster === true) {
            alert(this.options.locales[this.options.locale]['createEdgeError'] || this.options.locales['en']['createEdgeError']);
          } else {
            if (this.body.nodes[connectFromId] !== undefined && this.body.nodes[node.id] !== undefined) {
              this._performAddEdge(connectFromId, node.id);
            }
          }
        }
        this.body.emitter.emit('_redraw');
      }

      // --------------------------------------- END OF ADD EDGE FUNCTIONS -------------------------------------//

      // ------------------------------ Performing all the actual data manipulation ------------------------//

      /**
       * Adds a node on the specified location
       */

    }, {
      key: '_performAddNode',
      value: function _performAddNode(clickData) {
        var _this5 = this;

        var defaultData = {
          id: util.randomUUID(),
          x: clickData.pointer.canvas.x,
          y: clickData.pointer.canvas.y,
          label: 'new'
        };

        if (typeof this.options.addNode === 'function') {
          if (this.options.addNode.length === 2) {
            this.options.addNode(defaultData, function (finalizedData) {
              if (finalizedData !== null && finalizedData !== undefined && _this5.inMode === 'addNode') {
                // if for whatever reason the mode has changes (due to dataset change) disregard the callback
                _this5.body.data.nodes.getDataSet().add(finalizedData);
                _this5.showManipulatorToolbar();
              }
            });
          } else {
            throw new Error('The function for add does not support two arguments (data,callback)');
            this.showManipulatorToolbar();
          }
        } else {
          this.body.data.nodes.getDataSet().add(defaultData);
          this.showManipulatorToolbar();
        }
      }

      /**
       * connect two nodes with a new edge.
       *
       * @private
       */

    }, {
      key: '_performAddEdge',
      value: function _performAddEdge(sourceNodeId, targetNodeId) {
        var _this6 = this;

        var defaultData = { from: sourceNodeId, to: targetNodeId };
        if (typeof this.options.addEdge === 'function') {
          if (this.options.addEdge.length === 2) {
            this.options.addEdge(defaultData, function (finalizedData) {
              if (finalizedData !== null && finalizedData !== undefined && _this6.inMode === 'addEdge') {
                // if for whatever reason the mode has changes (due to dataset change) disregard the callback
                _this6.body.data.edges.getDataSet().add(finalizedData);
                _this6.selectionHandler.unselectAll();
                _this6.showManipulatorToolbar();
              }
            });
          } else {
            throw new Error('The function for connect does not support two arguments (data,callback)');
          }
        } else {
          this.body.data.edges.getDataSet().add(defaultData);
          this.selectionHandler.unselectAll();
          this.showManipulatorToolbar();
        }
      }

      /**
       * connect two nodes with a new edge.
       *
       * @private
       */

    }, {
      key: '_performEditEdge',
      value: function _performEditEdge(sourceNodeId, targetNodeId) {
        var _this7 = this;

        var defaultData = { id: this.edgeBeingEditedId, from: sourceNodeId, to: targetNodeId };
        if (typeof this.options.editEdge === 'function') {
          if (this.options.editEdge.length === 2) {
            this.options.editEdge(defaultData, function (finalizedData) {
              if (finalizedData === null || finalizedData === undefined || _this7.inMode !== 'editEdge') {
                // if for whatever reason the mode has changes (due to dataset change) disregard the callback) {
                _this7.body.edges[defaultData.id].updateEdgeType();
                _this7.body.emitter.emit('_redraw');
              } else {
                _this7.body.data.edges.getDataSet().update(finalizedData);
                _this7.selectionHandler.unselectAll();
                _this7.showManipulatorToolbar();
              }
            });
          } else {
            throw new Error('The function for edit does not support two arguments (data, callback)');
          }
        } else {
          this.body.data.edges.getDataSet().update(defaultData);
          this.selectionHandler.unselectAll();
          this.showManipulatorToolbar();
        }
      }
    }]);

    return ManipulationSystem;
  }();

  exports.default = ManipulationSystem;

/***/ },
/* 114 */
/***/ function(module, exports) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  /**
   * This object contains all possible options. It will check if the types are correct, if required if the option is one
   * of the allowed values.
   *
   * __any__ means that the name of the property does not matter.
   * __type__ is a required field for all objects and contains the allowed types of all objects
   */
  var string = 'string';
  var boolean = 'boolean';
  var number = 'number';
  var array = 'array';
  var object = 'object'; // should only be in a __type__ property
  var dom = 'dom';
  var any = 'any';

  var allOptions = {
    configure: {
      enabled: { boolean: boolean },
      filter: { boolean: boolean, string: string, array: array, 'function': 'function' },
      container: { dom: dom },
      showButton: { boolean: boolean },
      __type__: { object: object, boolean: boolean, string: string, array: array, 'function': 'function' }
    },
    edges: {
      arrows: {
        to: { enabled: { boolean: boolean }, scaleFactor: { number: number }, __type__: { object: object, boolean: boolean } },
        middle: { enabled: { boolean: boolean }, scaleFactor: { number: number }, __type__: { object: object, boolean: boolean } },
        from: { enabled: { boolean: boolean }, scaleFactor: { number: number }, __type__: { object: object, boolean: boolean } },
        __type__: { string: ['from', 'to', 'middle'], object: object }
      },
      arrowStrikethrough: { boolean: boolean },
      color: {
        color: { string: string },
        highlight: { string: string },
        hover: { string: string },
        inherit: { string: ['from', 'to', 'both'], boolean: boolean },
        opacity: { number: number },
        __type__: { object: object, string: string }
      },
      dashes: { boolean: boolean, array: array },
      font: {
        color: { string: string },
        size: { number: number }, // px
        face: { string: string },
        background: { string: string },
        strokeWidth: { number: number }, // px
        strokeColor: { string: string },
        align: { string: ['horizontal', 'top', 'middle', 'bottom'] },
        __type__: { object: object, string: string }
      },
      hidden: { boolean: boolean },
      hoverWidth: { 'function': 'function', number: number },
      label: { string: string, 'undefined': 'undefined' },
      labelHighlightBold: { boolean: boolean },
      length: { number: number, 'undefined': 'undefined' },
      physics: { boolean: boolean },
      scaling: {
        min: { number: number },
        max: { number: number },
        label: {
          enabled: { boolean: boolean },
          min: { number: number },
          max: { number: number },
          maxVisible: { number: number },
          drawThreshold: { number: number },
          __type__: { object: object, boolean: boolean }
        },
        customScalingFunction: { 'function': 'function' },
        __type__: { object: object }
      },
      selectionWidth: { 'function': 'function', number: number },
      selfReferenceSize: { number: number },
      shadow: {
        enabled: { boolean: boolean },
        color: { string: string },
        size: { number: number },
        x: { number: number },
        y: { number: number },
        __type__: { object: object, boolean: boolean }
      },
      smooth: {
        enabled: { boolean: boolean },
        type: { string: ['dynamic', 'continuous', 'discrete', 'diagonalCross', 'straightCross', 'horizontal', 'vertical', 'curvedCW', 'curvedCCW', 'cubicBezier'] },
        roundness: { number: number },
        forceDirection: { string: ['horizontal', 'vertical', 'none'], boolean: boolean },
        __type__: { object: object, boolean: boolean }
      },
      title: { string: string, 'undefined': 'undefined' },
      width: { number: number },
      value: { number: number, 'undefined': 'undefined' },
      __type__: { object: object }
    },
    groups: {
      useDefaultGroups: { boolean: boolean },
      __any__: 'get from nodes, will be overwritten below',
      __type__: { object: object }
    },
    interaction: {
      dragNodes: { boolean: boolean },
      dragView: { boolean: boolean },
      hideEdgesOnDrag: { boolean: boolean },
      hideNodesOnDrag: { boolean: boolean },
      hover: { boolean: boolean },
      keyboard: {
        enabled: { boolean: boolean },
        speed: { x: { number: number }, y: { number: number }, zoom: { number: number }, __type__: { object: object } },
        bindToWindow: { boolean: boolean },
        __type__: { object: object, boolean: boolean }
      },
      multiselect: { boolean: boolean },
      navigationButtons: { boolean: boolean },
      selectable: { boolean: boolean },
      selectConnectedEdges: { boolean: boolean },
      hoverConnectedEdges: { boolean: boolean },
      tooltipDelay: { number: number },
      zoomView: { boolean: boolean },
      __type__: { object: object }
    },
    layout: {
      randomSeed: { 'undefined': 'undefined', number: number },
      improvedLayout: { boolean: boolean },
      hierarchical: {
        enabled: { boolean: boolean },
        levelSeparation: { number: number },
        nodeSpacing: { number: number },
        treeSpacing: { number: number },
        blockShifting: { boolean: boolean },
        edgeMinimization: { boolean: boolean },
        parentCentralization: { boolean: boolean },
        direction: { string: ['UD', 'DU', 'LR', 'RL'] }, // UD, DU, LR, RL
        sortMethod: { string: ['hubsize', 'directed'] }, // hubsize, directed
        __type__: { object: object, boolean: boolean }
      },
      __type__: { object: object }
    },
    manipulation: {
      enabled: { boolean: boolean },
      initiallyActive: { boolean: boolean },
      addNode: { boolean: boolean, 'function': 'function' },
      addEdge: { boolean: boolean, 'function': 'function' },
      editNode: { 'function': 'function' },
      editEdge: { boolean: boolean, 'function': 'function' },
      deleteNode: { boolean: boolean, 'function': 'function' },
      deleteEdge: { boolean: boolean, 'function': 'function' },
      controlNodeStyle: 'get from nodes, will be overwritten below',
      __type__: { object: object, boolean: boolean }
    },
    nodes: {
      borderWidth: { number: number },
      borderWidthSelected: { number: number, 'undefined': 'undefined' },
      brokenImage: { string: string, 'undefined': 'undefined' },
      color: {
        border: { string: string },
        background: { string: string },
        highlight: {
          border: { string: string },
          background: { string: string },
          __type__: { object: object, string: string }
        },
        hover: {
          border: { string: string },
          background: { string: string },
          __type__: { object: object, string: string }
        },
        __type__: { object: object, string: string }
      },
      fixed: {
        x: { boolean: boolean },
        y: { boolean: boolean },
        __type__: { object: object, boolean: boolean }
      },
      font: {
        align: { string: string },
        color: { string: string },
        size: { number: number }, // px
        face: { string: string },
        background: { string: string },
        strokeWidth: { number: number }, // px
        strokeColor: { string: string },
        __type__: { object: object, string: string }
      },
      group: { string: string, number: number, 'undefined': 'undefined' },
      hidden: { boolean: boolean },
      icon: {
        face: { string: string },
        code: { string: string }, //'\uf007',
        size: { number: number }, //50,
        color: { string: string },
        __type__: { object: object }
      },
      id: { string: string, number: number },
      image: { string: string, 'undefined': 'undefined' }, // --> URL
      label: { string: string, 'undefined': 'undefined' },
      labelHighlightBold: { boolean: boolean },
      level: { number: number, 'undefined': 'undefined' },
      mass: { number: number },
      physics: { boolean: boolean },
      scaling: {
        min: { number: number },
        max: { number: number },
        label: {
          enabled: { boolean: boolean },
          min: { number: number },
          max: { number: number },
          maxVisible: { number: number },
          drawThreshold: { number: number },
          __type__: { object: object, boolean: boolean }
        },
        customScalingFunction: { 'function': 'function' },
        __type__: { object: object }
      },
      shadow: {
        enabled: { boolean: boolean },
        color: { string: string },
        size: { number: number },
        x: { number: number },
        y: { number: number },
        __type__: { object: object, boolean: boolean }
      },
      shape: { string: ['ellipse', 'circle', 'database', 'box', 'text', 'image', 'circularImage', 'diamond', 'dot', 'star', 'triangle', 'triangleDown', 'square', 'icon'] },
      shapeProperties: {
        borderDashes: { boolean: boolean, array: array },
        borderRadius: { number: number },
        interpolation: { boolean: boolean },
        useImageSize: { boolean: boolean },
        useBorderWithImage: { boolean: boolean },
        __type__: { object: object }
      },
      size: { number: number },
      title: { string: string, 'undefined': 'undefined' },
      value: { number: number, 'undefined': 'undefined' },
      x: { number: number },
      y: { number: number },
      __type__: { object: object }
    },
    physics: {
      enabled: { boolean: boolean },
      barnesHut: {
        gravitationalConstant: { number: number },
        centralGravity: { number: number },
        springLength: { number: number },
        springConstant: { number: number },
        damping: { number: number },
        avoidOverlap: { number: number },
        __type__: { object: object }
      },
      forceAtlas2Based: {
        gravitationalConstant: { number: number },
        centralGravity: { number: number },
        springLength: { number: number },
        springConstant: { number: number },
        damping: { number: number },
        avoidOverlap: { number: number },
        __type__: { object: object }
      },
      repulsion: {
        centralGravity: { number: number },
        springLength: { number: number },
        springConstant: { number: number },
        nodeDistance: { number: number },
        damping: { number: number },
        __type__: { object: object }
      },
      hierarchicalRepulsion: {
        centralGravity: { number: number },
        springLength: { number: number },
        springConstant: { number: number },
        nodeDistance: { number: number },
        damping: { number: number },
        __type__: { object: object }
      },
      maxVelocity: { number: number },
      minVelocity: { number: number }, // px/s
      solver: { string: ['barnesHut', 'repulsion', 'hierarchicalRepulsion', 'forceAtlas2Based'] },
      stabilization: {
        enabled: { boolean: boolean },
        iterations: { number: number }, // maximum number of iteration to stabilize
        updateInterval: { number: number },
        onlyDynamicEdges: { boolean: boolean },
        fit: { boolean: boolean },
        __type__: { object: object, boolean: boolean }
      },
      timestep: { number: number },
      adaptiveTimestep: { boolean: boolean },
      __type__: { object: object, boolean: boolean }
    },

    //globals :
    autoResize: { boolean: boolean },
    clickToUse: { boolean: boolean },
    locale: { string: string },
    locales: {
      __any__: { any: any },
      __type__: { object: object }
    },
    height: { string: string },
    width: { string: string },
    __type__: { object: object }
  };

  allOptions.groups.__any__ = allOptions.nodes;
  allOptions.manipulation.controlNodeStyle = allOptions.nodes;

  var configureOptions = {
    nodes: {
      borderWidth: [1, 0, 10, 1],
      borderWidthSelected: [2, 0, 10, 1],
      color: {
        border: ['color', '#2B7CE9'],
        background: ['color', '#97C2FC'],
        highlight: {
          border: ['color', '#2B7CE9'],
          background: ['color', '#D2E5FF']
        },
        hover: {
          border: ['color', '#2B7CE9'],
          background: ['color', '#D2E5FF']
        }
      },
      fixed: {
        x: false,
        y: false
      },
      font: {
        color: ['color', '#343434'],
        size: [14, 0, 100, 1], // px
        face: ['arial', 'verdana', 'tahoma'],
        background: ['color', 'none'],
        strokeWidth: [0, 0, 50, 1], // px
        strokeColor: ['color', '#ffffff']
      },
      //group: 'string',
      hidden: false,
      labelHighlightBold: true,
      //icon: {
      //  face: 'string',  //'FontAwesome',
      //  code: 'string',  //'\uf007',
      //  size: [50, 0, 200, 1],  //50,
      //  color: ['color','#2B7CE9']   //'#aa00ff'
      //},
      //image: 'string', // --> URL
      physics: true,
      scaling: {
        min: [10, 0, 200, 1],
        max: [30, 0, 200, 1],
        label: {
          enabled: false,
          min: [14, 0, 200, 1],
          max: [30, 0, 200, 1],
          maxVisible: [30, 0, 200, 1],
          drawThreshold: [5, 0, 20, 1]
        }
      },
      shadow: {
        enabled: false,
        color: 'rgba(0,0,0,0.5)',
        size: [10, 0, 20, 1],
        x: [5, -30, 30, 1],
        y: [5, -30, 30, 1]
      },
      shape: ['ellipse', 'box', 'circle', 'database', 'diamond', 'dot', 'square', 'star', 'text', 'triangle', 'triangleDown'],
      shapeProperties: {
        borderDashes: false,
        borderRadius: [6, 0, 20, 1],
        interpolation: true,
        useImageSize: false
      },
      size: [25, 0, 200, 1]
    },
    edges: {
      arrows: {
        to: { enabled: false, scaleFactor: [1, 0, 3, 0.05] }, // boolean / {arrowScaleFactor:1} / {enabled: false, arrowScaleFactor:1}
        middle: { enabled: false, scaleFactor: [1, 0, 3, 0.05] },
        from: { enabled: false, scaleFactor: [1, 0, 3, 0.05] }
      },
      arrowStrikethrough: true,
      color: {
        color: ['color', '#848484'],
        highlight: ['color', '#848484'],
        hover: ['color', '#848484'],
        inherit: ['from', 'to', 'both', true, false],
        opacity: [1, 0, 1, 0.05]
      },
      dashes: false,
      font: {
        color: ['color', '#343434'],
        size: [14, 0, 100, 1], // px
        face: ['arial', 'verdana', 'tahoma'],
        background: ['color', 'none'],
        strokeWidth: [2, 0, 50, 1], // px
        strokeColor: ['color', '#ffffff'],
        align: ['horizontal', 'top', 'middle', 'bottom']
      },
      hidden: false,
      hoverWidth: [1.5, 0, 5, 0.1],
      labelHighlightBold: true,
      physics: true,
      scaling: {
        min: [1, 0, 100, 1],
        max: [15, 0, 100, 1],
        label: {
          enabled: true,
          min: [14, 0, 200, 1],
          max: [30, 0, 200, 1],
          maxVisible: [30, 0, 200, 1],
          drawThreshold: [5, 0, 20, 1]
        }
      },
      selectionWidth: [1.5, 0, 5, 0.1],
      selfReferenceSize: [20, 0, 200, 1],
      shadow: {
        enabled: false,
        color: 'rgba(0,0,0,0.5)',
        size: [10, 0, 20, 1],
        x: [5, -30, 30, 1],
        y: [5, -30, 30, 1]
      },
      smooth: {
        enabled: true,
        type: ['dynamic', 'continuous', 'discrete', 'diagonalCross', 'straightCross', 'horizontal', 'vertical', 'curvedCW', 'curvedCCW', 'cubicBezier'],
        forceDirection: ['horizontal', 'vertical', 'none'],
        roundness: [0.5, 0, 1, 0.05]
      },
      width: [1, 0, 30, 1]
    },
    layout: {
      //randomSeed: [0, 0, 500, 1],
      //improvedLayout: true,
      hierarchical: {
        enabled: false,
        levelSeparation: [150, 20, 500, 5],
        nodeSpacing: [100, 20, 500, 5],
        treeSpacing: [200, 20, 500, 5],
        blockShifting: true,
        edgeMinimization: true,
        parentCentralization: true,
        direction: ['UD', 'DU', 'LR', 'RL'], // UD, DU, LR, RL
        sortMethod: ['hubsize', 'directed'] // hubsize, directed
      }
    },
    interaction: {
      dragNodes: true,
      dragView: true,
      hideEdgesOnDrag: false,
      hideNodesOnDrag: false,
      hover: false,
      keyboard: {
        enabled: false,
        speed: { x: [10, 0, 40, 1], y: [10, 0, 40, 1], zoom: [0.02, 0, 0.1, 0.005] },
        bindToWindow: true
      },
      multiselect: false,
      navigationButtons: false,
      selectable: true,
      selectConnectedEdges: true,
      hoverConnectedEdges: true,
      tooltipDelay: [300, 0, 1000, 25],
      zoomView: true
    },
    manipulation: {
      enabled: false,
      initiallyActive: false
    },
    physics: {
      enabled: true,
      barnesHut: {
        //theta: [0.5, 0.1, 1, 0.05],
        gravitationalConstant: [-2000, -30000, 0, 50],
        centralGravity: [0.3, 0, 10, 0.05],
        springLength: [95, 0, 500, 5],
        springConstant: [0.04, 0, 1.2, 0.005],
        damping: [0.09, 0, 1, 0.01],
        avoidOverlap: [0, 0, 1, 0.01]
      },
      forceAtlas2Based: {
        //theta: [0.5, 0.1, 1, 0.05],
        gravitationalConstant: [-50, -500, 0, 1],
        centralGravity: [0.01, 0, 1, 0.005],
        springLength: [95, 0, 500, 5],
        springConstant: [0.08, 0, 1.2, 0.005],
        damping: [0.4, 0, 1, 0.01],
        avoidOverlap: [0, 0, 1, 0.01]
      },
      repulsion: {
        centralGravity: [0.2, 0, 10, 0.05],
        springLength: [200, 0, 500, 5],
        springConstant: [0.05, 0, 1.2, 0.005],
        nodeDistance: [100, 0, 500, 5],
        damping: [0.09, 0, 1, 0.01]
      },
      hierarchicalRepulsion: {
        centralGravity: [0.2, 0, 10, 0.05],
        springLength: [100, 0, 500, 5],
        springConstant: [0.01, 0, 1.2, 0.005],
        nodeDistance: [120, 0, 500, 5],
        damping: [0.09, 0, 1, 0.01]
      },
      maxVelocity: [50, 0, 150, 1],
      minVelocity: [0.1, 0.01, 0.5, 0.01],
      solver: ['barnesHut', 'forceAtlas2Based', 'repulsion', 'hierarchicalRepulsion'],
      timestep: [0.5, 0.01, 1, 0.01]
    },
    //adaptiveTimestep: true
    global: {
      locale: ['en', 'nl']
    }
  };

  exports.allOptions = allOptions;
  exports.configureOptions = configureOptions;

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // distance finding algorithm


  var _FloydWarshall = __webpack_require__(116);

  var _FloydWarshall2 = _interopRequireDefault(_FloydWarshall);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  /**
   * KamadaKawai positions the nodes initially based on
   *
   * "AN ALGORITHM FOR DRAWING GENERAL UNDIRECTED GRAPHS"
   * -- Tomihisa KAMADA and Satoru KAWAI in 1989
   *
   * Possible optimizations in the distance calculation can be implemented.
   */

  var KamadaKawai = function () {
    function KamadaKawai(body, edgeLength, edgeStrength) {
      _classCallCheck(this, KamadaKawai);

      this.body = body;
      this.springLength = edgeLength;
      this.springConstant = edgeStrength;
      this.distanceSolver = new _FloydWarshall2.default();
    }

    /**
     * Not sure if needed but can be used to update the spring length and spring constant
     * @param options
     */


    _createClass(KamadaKawai, [{
      key: "setOptions",
      value: function setOptions(options) {
        if (options) {
          if (options.springLength) {
            this.springLength = options.springLength;
          }
          if (options.springConstant) {
            this.springConstant = options.springConstant;
          }
        }
      }

      /**
       * Position the system
       * @param nodesArray
       * @param edgesArray
       */

    }, {
      key: "solve",
      value: function solve(nodesArray, edgesArray) {
        var ignoreClusters = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

        // get distance matrix
        var D_matrix = this.distanceSolver.getDistances(this.body, nodesArray, edgesArray); // distance matrix

        // get the L Matrix
        this._createL_matrix(D_matrix);

        // get the K Matrix
        this._createK_matrix(D_matrix);

        // calculate positions
        var threshold = 0.01;
        var innerThreshold = 1;
        var iterations = 0;
        var maxIterations = Math.max(1000, Math.min(10 * this.body.nodeIndices.length, 6000));
        var maxInnerIterations = 5;

        var maxEnergy = 1e9;
        var highE_nodeId = 0,
            dE_dx = 0,
            dE_dy = 0,
            delta_m = 0,
            subIterations = 0;

        while (maxEnergy > threshold && iterations < maxIterations) {
          iterations += 1;

          var _getHighestEnergyNode2 = this._getHighestEnergyNode(ignoreClusters);

          var _getHighestEnergyNode3 = _slicedToArray(_getHighestEnergyNode2, 4);

          highE_nodeId = _getHighestEnergyNode3[0];
          maxEnergy = _getHighestEnergyNode3[1];
          dE_dx = _getHighestEnergyNode3[2];
          dE_dy = _getHighestEnergyNode3[3];

          delta_m = maxEnergy;
          subIterations = 0;
          while (delta_m > innerThreshold && subIterations < maxInnerIterations) {
            subIterations += 1;
            this._moveNode(highE_nodeId, dE_dx, dE_dy);

            var _getEnergy2 = this._getEnergy(highE_nodeId);

            var _getEnergy3 = _slicedToArray(_getEnergy2, 3);

            delta_m = _getEnergy3[0];
            dE_dx = _getEnergy3[1];
            dE_dy = _getEnergy3[2];
          }
        }
      }

      /**
       * get the node with the highest energy
       * @returns {*[]}
       * @private
       */

    }, {
      key: "_getHighestEnergyNode",
      value: function _getHighestEnergyNode(ignoreClusters) {
        var nodesArray = this.body.nodeIndices;
        var nodes = this.body.nodes;
        var maxEnergy = 0;
        var maxEnergyNodeId = nodesArray[0];
        var dE_dx_max = 0,
            dE_dy_max = 0;

        for (var nodeIdx = 0; nodeIdx < nodesArray.length; nodeIdx++) {
          var m = nodesArray[nodeIdx];
          // by not evaluating nodes with predefined positions we should only move nodes that have no positions.
          if (nodes[m].predefinedPosition === false || nodes[m].isCluster === true && ignoreClusters === true || nodes[m].options.fixed.x === true || nodes[m].options.fixed.y === true) {
            var _getEnergy4 = this._getEnergy(m);

            var _getEnergy5 = _slicedToArray(_getEnergy4, 3);

            var delta_m = _getEnergy5[0];
            var dE_dx = _getEnergy5[1];
            var dE_dy = _getEnergy5[2];

            if (maxEnergy < delta_m) {
              maxEnergy = delta_m;
              maxEnergyNodeId = m;
              dE_dx_max = dE_dx;
              dE_dy_max = dE_dy;
            }
          }
        }

        return [maxEnergyNodeId, maxEnergy, dE_dx_max, dE_dy_max];
      }

      /**
       * calculate the energy of a single node
       * @param m
       * @returns {*[]}
       * @private
       */

    }, {
      key: "_getEnergy",
      value: function _getEnergy(m) {
        var nodesArray = this.body.nodeIndices;
        var nodes = this.body.nodes;

        var x_m = nodes[m].x;
        var y_m = nodes[m].y;
        var dE_dx = 0;
        var dE_dy = 0;
        for (var iIdx = 0; iIdx < nodesArray.length; iIdx++) {
          var i = nodesArray[iIdx];
          if (i !== m) {
            var x_i = nodes[i].x;
            var y_i = nodes[i].y;
            var denominator = 1.0 / Math.sqrt(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2));
            dE_dx += this.K_matrix[m][i] * (x_m - x_i - this.L_matrix[m][i] * (x_m - x_i) * denominator);
            dE_dy += this.K_matrix[m][i] * (y_m - y_i - this.L_matrix[m][i] * (y_m - y_i) * denominator);
          }
        }

        var delta_m = Math.sqrt(Math.pow(dE_dx, 2) + Math.pow(dE_dy, 2));
        return [delta_m, dE_dx, dE_dy];
      }

      /**
       * move the node based on it's energy
       * the dx and dy are calculated from the linear system proposed by Kamada and Kawai
       * @param m
       * @param dE_dx
       * @param dE_dy
       * @private
       */

    }, {
      key: "_moveNode",
      value: function _moveNode(m, dE_dx, dE_dy) {
        var nodesArray = this.body.nodeIndices;
        var nodes = this.body.nodes;
        var d2E_dx2 = 0;
        var d2E_dxdy = 0;
        var d2E_dy2 = 0;

        var x_m = nodes[m].x;
        var y_m = nodes[m].y;
        for (var iIdx = 0; iIdx < nodesArray.length; iIdx++) {
          var i = nodesArray[iIdx];
          if (i !== m) {
            var x_i = nodes[i].x;
            var y_i = nodes[i].y;
            var denominator = 1.0 / Math.pow(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2), 1.5);
            d2E_dx2 += this.K_matrix[m][i] * (1 - this.L_matrix[m][i] * Math.pow(y_m - y_i, 2) * denominator);
            d2E_dxdy += this.K_matrix[m][i] * (this.L_matrix[m][i] * (x_m - x_i) * (y_m - y_i) * denominator);
            d2E_dy2 += this.K_matrix[m][i] * (1 - this.L_matrix[m][i] * Math.pow(x_m - x_i, 2) * denominator);
          }
        }
        // make the variable names easier to make the solving of the linear system easier to read
        var A = d2E_dx2,
            B = d2E_dxdy,
            C = dE_dx,
            D = d2E_dy2,
            E = dE_dy;

        // solve the linear system for dx and dy
        var dy = (C / A + E / B) / (B / A - D / B);
        var dx = -(B * dy + C) / A;

        // move the node
        nodes[m].x += dx;
        nodes[m].y += dy;
      }

      /**
       * Create the L matrix: edge length times shortest path
       * @param D_matrix
       * @private
       */

    }, {
      key: "_createL_matrix",
      value: function _createL_matrix(D_matrix) {
        var nodesArray = this.body.nodeIndices;
        var edgeLength = this.springLength;

        this.L_matrix = [];
        for (var i = 0; i < nodesArray.length; i++) {
          this.L_matrix[nodesArray[i]] = {};
          for (var j = 0; j < nodesArray.length; j++) {
            this.L_matrix[nodesArray[i]][nodesArray[j]] = edgeLength * D_matrix[nodesArray[i]][nodesArray[j]];
          }
        }
      }

      /**
       * Create the K matrix: spring constants times shortest path
       * @param D_matrix
       * @private
       */

    }, {
      key: "_createK_matrix",
      value: function _createK_matrix(D_matrix) {
        var nodesArray = this.body.nodeIndices;
        var edgeStrength = this.springConstant;

        this.K_matrix = [];
        for (var i = 0; i < nodesArray.length; i++) {
          this.K_matrix[nodesArray[i]] = {};
          for (var j = 0; j < nodesArray.length; j++) {
            this.K_matrix[nodesArray[i]][nodesArray[j]] = edgeStrength * Math.pow(D_matrix[nodesArray[i]][nodesArray[j]], -2);
          }
        }
      }
    }]);

    return KamadaKawai;
  }();

  exports.default = KamadaKawai;

/***/ },
/* 116 */
/***/ function(module, exports) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  /**
   * Created by Alex on 10-Aug-15.
   */

  var FloydWarshall = function () {
    function FloydWarshall() {
      _classCallCheck(this, FloydWarshall);
    }

    _createClass(FloydWarshall, [{
      key: "getDistances",
      value: function getDistances(body, nodesArray, edgesArray) {
        var D_matrix = {};
        var edges = body.edges;

        // prepare matrix with large numbers
        for (var i = 0; i < nodesArray.length; i++) {
          D_matrix[nodesArray[i]] = {};
          D_matrix[nodesArray[i]] = {};
          for (var j = 0; j < nodesArray.length; j++) {
            D_matrix[nodesArray[i]][nodesArray[j]] = i == j ? 0 : 1e9;
            D_matrix[nodesArray[i]][nodesArray[j]] = i == j ? 0 : 1e9;
          }
        }

        // put the weights for the edges in. This assumes unidirectionality.
        for (var _i = 0; _i < edgesArray.length; _i++) {
          var edge = edges[edgesArray[_i]];
          // edge has to be connected if it counts to the distances. If it is connected to inner clusters it will crash so we also check if it is in the D_matrix
          if (edge.connected === true && D_matrix[edge.fromId] !== undefined && D_matrix[edge.toId] !== undefined) {
            D_matrix[edge.fromId][edge.toId] = 1;
            D_matrix[edge.toId][edge.fromId] = 1;
          }
        }

        var nodeCount = nodesArray.length;

        // Adapted FloydWarshall based on unidirectionality to greatly reduce complexity.
        for (var k = 0; k < nodeCount; k++) {
          for (var _i2 = 0; _i2 < nodeCount - 1; _i2++) {
            for (var _j = _i2 + 1; _j < nodeCount; _j++) {
              D_matrix[nodesArray[_i2]][nodesArray[_j]] = Math.min(D_matrix[nodesArray[_i2]][nodesArray[_j]], D_matrix[nodesArray[_i2]][nodesArray[k]] + D_matrix[nodesArray[k]][nodesArray[_j]]);
              D_matrix[nodesArray[_j]][nodesArray[_i2]] = D_matrix[nodesArray[_i2]][nodesArray[_j]];
            }
          }
        }

        return D_matrix;
      }
    }]);

    return FloydWarshall;
  }();

  exports.default = FloydWarshall;

/***/ },
/* 117 */
/***/ function(module, exports) {

  'use strict';

  /**
   * Canvas shapes used by Network
   */
  if (typeof CanvasRenderingContext2D !== 'undefined') {

    /**
     * Draw a circle shape
     */
    CanvasRenderingContext2D.prototype.circle = function (x, y, r) {
      this.beginPath();
      this.arc(x, y, r, 0, 2 * Math.PI, false);
      this.closePath();
    };

    /**
     * Draw a square shape
     * @param {Number} x horizontal center
     * @param {Number} y vertical center
     * @param {Number} r   size, width and height of the square
     */
    CanvasRenderingContext2D.prototype.square = function (x, y, r) {
      this.beginPath();
      this.rect(x - r, y - r, r * 2, r * 2);
      this.closePath();
    };

    /**
     * Draw a triangle shape
     * @param {Number} x horizontal center
     * @param {Number} y vertical center
     * @param {Number} r   radius, half the length of the sides of the triangle
     */
    CanvasRenderingContext2D.prototype.triangle = function (x, y, r) {
      // http://en.wikipedia.org/wiki/Equilateral_triangle
      this.beginPath();

      // the change in radius and the offset is here to center the shape
      r *= 1.15;
      y += 0.275 * r;

      var s = r * 2;
      var s2 = s / 2;
      var ir = Math.sqrt(3) / 6 * s; // radius of inner circle
      var h = Math.sqrt(s * s - s2 * s2); // height

      this.moveTo(x, y - (h - ir));
      this.lineTo(x + s2, y + ir);
      this.lineTo(x - s2, y + ir);
      this.lineTo(x, y - (h - ir));
      this.closePath();
    };

    /**
     * Draw a triangle shape in downward orientation
     * @param {Number} x horizontal center
     * @param {Number} y vertical center
     * @param {Number} r radius
     */
    CanvasRenderingContext2D.prototype.triangleDown = function (x, y, r) {
      // http://en.wikipedia.org/wiki/Equilateral_triangle
      this.beginPath();

      // the change in radius and the offset is here to center the shape
      r *= 1.15;
      y -= 0.275 * r;

      var s = r * 2;
      var s2 = s / 2;
      var ir = Math.sqrt(3) / 6 * s; // radius of inner circle
      var h = Math.sqrt(s * s - s2 * s2); // height

      this.moveTo(x, y + (h - ir));
      this.lineTo(x + s2, y - ir);
      this.lineTo(x - s2, y - ir);
      this.lineTo(x, y + (h - ir));
      this.closePath();
    };

    /**
     * Draw a star shape, a star with 5 points
     * @param {Number} x horizontal center
     * @param {Number} y vertical center
     * @param {Number} r   radius, half the length of the sides of the triangle
     */
    CanvasRenderingContext2D.prototype.star = function (x, y, r) {
      // http://www.html5canvastutorials.com/labs/html5-canvas-star-spinner/
      this.beginPath();

      // the change in radius and the offset is here to center the shape
      r *= 0.82;
      y += 0.1 * r;

      for (var n = 0; n < 10; n++) {
        var radius = n % 2 === 0 ? r * 1.3 : r * 0.5;
        this.lineTo(x + radius * Math.sin(n * 2 * Math.PI / 10), y - radius * Math.cos(n * 2 * Math.PI / 10));
      }

      this.closePath();
    };

    /**
     * Draw a Diamond shape
     * @param {Number} x horizontal center
     * @param {Number} y vertical center
     * @param {Number} r   radius, half the length of the sides of the triangle
     */
    CanvasRenderingContext2D.prototype.diamond = function (x, y, r) {
      // http://www.html5canvastutorials.com/labs/html5-canvas-star-spinner/
      this.beginPath();

      this.lineTo(x, y + r);
      this.lineTo(x + r, y);
      this.lineTo(x, y - r);
      this.lineTo(x - r, y);

      this.closePath();
    };

    /**
     * http://stackoverflow.com/questions/1255512/how-to-draw-a-rounded-rectangle-on-html-canvas
     */
    CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
      var r2d = Math.PI / 180;
      if (w - 2 * r < 0) {
        r = w / 2;
      } //ensure that the radius isn't too large for x
      if (h - 2 * r < 0) {
        r = h / 2;
      } //ensure that the radius isn't too large for y
      this.beginPath();
      this.moveTo(x + r, y);
      this.lineTo(x + w - r, y);
      this.arc(x + w - r, y + r, r, r2d * 270, r2d * 360, false);
      this.lineTo(x + w, y + h - r);
      this.arc(x + w - r, y + h - r, r, 0, r2d * 90, false);
      this.lineTo(x + r, y + h);
      this.arc(x + r, y + h - r, r, r2d * 90, r2d * 180, false);
      this.lineTo(x, y + r);
      this.arc(x + r, y + r, r, r2d * 180, r2d * 270, false);
      this.closePath();
    };

    /**
     * http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas
     */
    CanvasRenderingContext2D.prototype.ellipse = function (x, y, w, h) {
      var kappa = .5522848,
          ox = w / 2 * kappa,
          // control point offset horizontal
      oy = h / 2 * kappa,
          // control point offset vertical
      xe = x + w,
          // x-end
      ye = y + h,
          // y-end
      xm = x + w / 2,
          // x-middle
      ym = y + h / 2; // y-middle

      this.beginPath();
      this.moveTo(x, ym);
      this.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
      this.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
      this.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
      this.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
      this.closePath();
    };

    /**
     * http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas
     */
    CanvasRenderingContext2D.prototype.database = function (x, y, w, h) {
      var f = 1 / 3;
      var wEllipse = w;
      var hEllipse = h * f;

      var kappa = .5522848,
          ox = wEllipse / 2 * kappa,
          // control point offset horizontal
      oy = hEllipse / 2 * kappa,
          // control point offset vertical
      xe = x + wEllipse,
          // x-end
      ye = y + hEllipse,
          // y-end
      xm = x + wEllipse / 2,
          // x-middle
      ym = y + hEllipse / 2,
          // y-middle
      ymb = y + (h - hEllipse / 2),
          // y-midlle, bottom ellipse
      yeb = y + h; // y-end, bottom ellipse

      this.beginPath();
      this.moveTo(xe, ym);

      this.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
      this.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);

      this.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
      this.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);

      this.lineTo(xe, ymb);

      this.bezierCurveTo(xe, ymb + oy, xm + ox, yeb, xm, yeb);
      this.bezierCurveTo(xm - ox, yeb, x, ymb + oy, x, ymb);

      this.lineTo(x, ym);
    };

    /**
     * Draw an arrow point (no line)
     */
    CanvasRenderingContext2D.prototype.arrow = function (x, y, angle, length) {
      // tail
      var xt = x - length * Math.cos(angle);
      var yt = y - length * Math.sin(angle);

      // inner tail
      var xi = x - length * 0.9 * Math.cos(angle);
      var yi = y - length * 0.9 * Math.sin(angle);

      // left
      var xl = xt + length / 3 * Math.cos(angle + 0.5 * Math.PI);
      var yl = yt + length / 3 * Math.sin(angle + 0.5 * Math.PI);

      // right
      var xr = xt + length / 3 * Math.cos(angle - 0.5 * Math.PI);
      var yr = yt + length / 3 * Math.sin(angle - 0.5 * Math.PI);

      this.beginPath();
      this.moveTo(x, y);
      this.lineTo(xl, yl);
      this.lineTo(xi, yi);
      this.lineTo(xr, yr);
      this.closePath();
    };

    /**
     * Sets up the dashedLine functionality for drawing
     * Original code came from http://stackoverflow.com/questions/4576724/dotted-stroke-in-canvas
     * @author David Jordan
     * @date 2012-08-08
     */
    CanvasRenderingContext2D.prototype.dashedLine = function (x, y, x2, y2, pattern) {
      this.beginPath();
      this.moveTo(x, y);

      var patternLength = pattern.length;
      var dx = x2 - x;
      var dy = y2 - y;
      var slope = dy / dx;
      var distRemaining = Math.sqrt(dx * dx + dy * dy);
      var patternIndex = 0;
      var draw = true;
      var xStep = 0;
      var dashLength = pattern[0];

      while (distRemaining >= 0.1) {
        dashLength = pattern[patternIndex++ % patternLength];
        if (dashLength > distRemaining) {
          dashLength = distRemaining;
        }

        xStep = Math.sqrt(dashLength * dashLength / (1 + slope * slope));
        xStep = dx < 0 ? -xStep : xStep;
        x += xStep;
        y += slope * xStep;

        if (draw === true) {
          this.lineTo(x, y);
        } else {
          this.moveTo(x, y);
        }

        distRemaining -= dashLength;
        draw = !draw;
      }
    };
  }

/***/ },
/* 118 */
/***/ function(module, exports) {

  'use strict';

  /**
   * Parse a text source containing data in DOT language into a JSON object.
   * The object contains two lists: one with nodes and one with edges.
   *
   * DOT language reference: http://www.graphviz.org/doc/info/lang.html
   *
   * DOT language attributes: http://graphviz.org/content/attrs
   *
   * @param {String} data     Text containing a graph in DOT-notation
   * @return {Object} graph   An object containing two parameters:
   *                          {Object[]} nodes
   *                          {Object[]} edges
   */
  function parseDOT(data) {
    dot = data;
    return parseGraph();
  }

  // mapping of attributes from DOT (the keys) to vis.js (the values)
  var NODE_ATTR_MAPPING = {
    'fontsize': 'font.size',
    'fontcolor': 'font.color',
    'labelfontcolor': 'font.color',
    'fontname': 'font.face',
    'color': ['color.border', 'color.background'],
    'fillcolor': 'color.background',
    'tooltip': 'title',
    'labeltooltip': 'title'
  };
  var EDGE_ATTR_MAPPING = Object.create(NODE_ATTR_MAPPING);
  EDGE_ATTR_MAPPING.color = 'color.color';

  // token types enumeration
  var TOKENTYPE = {
    NULL: 0,
    DELIMITER: 1,
    IDENTIFIER: 2,
    UNKNOWN: 3
  };

  // map with all delimiters
  var DELIMITERS = {
    '{': true,
    '}': true,
    '[': true,
    ']': true,
    ';': true,
    '=': true,
    ',': true,

    '->': true,
    '--': true
  };

  var dot = ''; // current dot file
  var index = 0; // current index in dot file
  var c = ''; // current token character in expr
  var token = ''; // current token
  var tokenType = TOKENTYPE.NULL; // type of the token

  /**
   * Get the first character from the dot file.
   * The character is stored into the char c. If the end of the dot file is
   * reached, the function puts an empty string in c.
   */
  function first() {
    index = 0;
    c = dot.charAt(0);
  }

  /**
   * Get the next character from the dot file.
   * The character is stored into the char c. If the end of the dot file is
   * reached, the function puts an empty string in c.
   */
  function next() {
    index++;
    c = dot.charAt(index);
  }

  /**
   * Preview the next character from the dot file.
   * @return {String} cNext
   */
  function nextPreview() {
    return dot.charAt(index + 1);
  }

  /**
   * Test whether given character is alphabetic or numeric
   * @param {String} c
   * @return {Boolean} isAlphaNumeric
   */
  var regexAlphaNumeric = /[a-zA-Z_0-9.:#]/;
  function isAlphaNumeric(c) {
    return regexAlphaNumeric.test(c);
  }

  /**
   * Merge all options of object b into object b
   * @param {Object} a
   * @param {Object} b
   * @return {Object} a
   */
  function merge(a, b) {
    if (!a) {
      a = {};
    }

    if (b) {
      for (var name in b) {
        if (b.hasOwnProperty(name)) {
          a[name] = b[name];
        }
      }
    }
    return a;
  }

  /**
   * Set a value in an object, where the provided parameter name can be a
   * path with nested parameters. For example:
   *
   *     var obj = {a: 2};
   *     setValue(obj, 'b.c', 3);     // obj = {a: 2, b: {c: 3}}
   *
   * @param {Object} obj
   * @param {String} path  A parameter name or dot-separated parameter path,
   *                      like "color.highlight.border".
   * @param {*} value
   */
  function setValue(obj, path, value) {
    var keys = path.split('.');
    var o = obj;
    while (keys.length) {
      var key = keys.shift();
      if (keys.length) {
        // this isn't the end point
        if (!o[key]) {
          o[key] = {};
        }
        o = o[key];
      } else {
        // this is the end point
        o[key] = value;
      }
    }
  }

  /**
   * Add a node to a graph object. If there is already a node with
   * the same id, their attributes will be merged.
   * @param {Object} graph
   * @param {Object} node
   */
  function addNode(graph, node) {
    var i, len;
    var current = null;

    // find root graph (in case of subgraph)
    var graphs = [graph]; // list with all graphs from current graph to root graph
    var root = graph;
    while (root.parent) {
      graphs.push(root.parent);
      root = root.parent;
    }

    // find existing node (at root level) by its id
    if (root.nodes) {
      for (i = 0, len = root.nodes.length; i < len; i++) {
        if (node.id === root.nodes[i].id) {
          current = root.nodes[i];
          break;
        }
      }
    }

    if (!current) {
      // this is a new node
      current = {
        id: node.id
      };
      if (graph.node) {
        // clone default attributes
        current.attr = merge(current.attr, graph.node);
      }
    }

    // add node to this (sub)graph and all its parent graphs
    for (i = graphs.length - 1; i >= 0; i--) {
      var g = graphs[i];

      if (!g.nodes) {
        g.nodes = [];
      }
      if (g.nodes.indexOf(current) === -1) {
        g.nodes.push(current);
      }
    }

    // merge attributes
    if (node.attr) {
      current.attr = merge(current.attr, node.attr);
    }
  }

  /**
   * Add an edge to a graph object
   * @param {Object} graph
   * @param {Object} edge
   */
  function addEdge(graph, edge) {
    if (!graph.edges) {
      graph.edges = [];
    }
    graph.edges.push(edge);
    if (graph.edge) {
      var attr = merge({}, graph.edge); // clone default attributes
      edge.attr = merge(attr, edge.attr); // merge attributes
    }
  }

  /**
   * Create an edge to a graph object
   * @param {Object} graph
   * @param {String | Number | Object} from
   * @param {String | Number | Object} to
   * @param {String} type
   * @param {Object | null} attr
   * @return {Object} edge
   */
  function createEdge(graph, from, to, type, attr) {
    var edge = {
      from: from,
      to: to,
      type: type
    };

    if (graph.edge) {
      edge.attr = merge({}, graph.edge); // clone default attributes
    }
    edge.attr = merge(edge.attr || {}, attr); // merge attributes

    return edge;
  }

  /**
   * Get next token in the current dot file.
   * The token and token type are available as token and tokenType
   */
  function getToken() {
    tokenType = TOKENTYPE.NULL;
    token = '';

    // skip over whitespaces
    while (c === ' ' || c === '\t' || c === '\n' || c === '\r') {
      // space, tab, enter
      next();
    }

    do {
      var isComment = false;

      // skip comment
      if (c === '#') {
        // find the previous non-space character
        var i = index - 1;
        while (dot.charAt(i) === ' ' || dot.charAt(i) === '\t') {
          i--;
        }
        if (dot.charAt(i) === '\n' || dot.charAt(i) === '') {
          // the # is at the start of a line, this is indeed a line comment
          while (c != '' && c != '\n') {
            next();
          }
          isComment = true;
        }
      }
      if (c === '/' && nextPreview() === '/') {
        // skip line comment
        while (c != '' && c != '\n') {
          next();
        }
        isComment = true;
      }
      if (c === '/' && nextPreview() === '*') {
        // skip block comment
        while (c != '') {
          if (c === '*' && nextPreview() === '/') {
            // end of block comment found. skip these last two characters
            next();
            next();
            break;
          } else {
            next();
          }
        }
        isComment = true;
      }

      // skip over whitespaces
      while (c === ' ' || c === '\t' || c === '\n' || c === '\r') {
        // space, tab, enter
        next();
      }
    } while (isComment);

    // check for end of dot file
    if (c === '') {
      // token is still empty
      tokenType = TOKENTYPE.DELIMITER;
      return;
    }

    // check for delimiters consisting of 2 characters
    var c2 = c + nextPreview();
    if (DELIMITERS[c2]) {
      tokenType = TOKENTYPE.DELIMITER;
      token = c2;
      next();
      next();
      return;
    }

    // check for delimiters consisting of 1 character
    if (DELIMITERS[c]) {
      tokenType = TOKENTYPE.DELIMITER;
      token = c;
      next();
      return;
    }

    // check for an identifier (number or string)
    // TODO: more precise parsing of numbers/strings (and the port separator ':')
    if (isAlphaNumeric(c) || c === '-') {
      token += c;
      next();

      while (isAlphaNumeric(c)) {
        token += c;
        next();
      }
      if (token === 'false') {
        token = false; // convert to boolean
      } else if (token === 'true') {
          token = true; // convert to boolean
        } else if (!isNaN(Number(token))) {
            token = Number(token); // convert to number
          }
      tokenType = TOKENTYPE.IDENTIFIER;
      return;
    }

    // check for a string enclosed by double quotes
    if (c === '"') {
      next();
      while (c != '' && (c != '"' || c === '"' && nextPreview() === '"')) {
        token += c;
        if (c === '"') {
          // skip the escape character
          next();
        }
        next();
      }
      if (c != '"') {
        throw newSyntaxError('End of string " expected');
      }
      next();
      tokenType = TOKENTYPE.IDENTIFIER;
      return;
    }

    // something unknown is found, wrong characters, a syntax error
    tokenType = TOKENTYPE.UNKNOWN;
    while (c != '') {
      token += c;
      next();
    }
    throw new SyntaxError('Syntax error in part "' + chop(token, 30) + '"');
  }

  /**
   * Parse a graph.
   * @returns {Object} graph
   */
  function parseGraph() {
    var graph = {};

    first();
    getToken();

    // optional strict keyword
    if (token === 'strict') {
      graph.strict = true;
      getToken();
    }

    // graph or digraph keyword
    if (token === 'graph' || token === 'digraph') {
      graph.type = token;
      getToken();
    }

    // optional graph id
    if (tokenType === TOKENTYPE.IDENTIFIER) {
      graph.id = token;
      getToken();
    }

    // open angle bracket
    if (token != '{') {
      throw newSyntaxError('Angle bracket { expected');
    }
    getToken();

    // statements
    parseStatements(graph);

    // close angle bracket
    if (token != '}') {
      throw newSyntaxError('Angle bracket } expected');
    }
    getToken();

    // end of file
    if (token !== '') {
      throw newSyntaxError('End of file expected');
    }
    getToken();

    // remove temporary default options
    delete graph.node;
    delete graph.edge;
    delete graph.graph;

    return graph;
  }

  /**
   * Parse a list with statements.
   * @param {Object} graph
   */
  function parseStatements(graph) {
    while (token !== '' && token != '}') {
      parseStatement(graph);
      if (token === ';') {
        getToken();
      }
    }
  }

  /**
   * Parse a single statement. Can be a an attribute statement, node
   * statement, a series of node statements and edge statements, or a
   * parameter.
   * @param {Object} graph
   */
  function parseStatement(graph) {
    // parse subgraph
    var subgraph = parseSubgraph(graph);
    if (subgraph) {
      // edge statements
      parseEdge(graph, subgraph);

      return;
    }

    // parse an attribute statement
    var attr = parseAttributeStatement(graph);
    if (attr) {
      return;
    }

    // parse node
    if (tokenType != TOKENTYPE.IDENTIFIER) {
      throw newSyntaxError('Identifier expected');
    }
    var id = token; // id can be a string or a number
    getToken();

    if (token === '=') {
      // id statement
      getToken();
      if (tokenType != TOKENTYPE.IDENTIFIER) {
        throw newSyntaxError('Identifier expected');
      }
      graph[id] = token;
      getToken();
      // TODO: implement comma separated list with "a_list: ID=ID [','] [a_list] "
    } else {
        parseNodeStatement(graph, id);
      }
  }

  /**
   * Parse a subgraph
   * @param {Object} graph    parent graph object
   * @return {Object | null} subgraph
   */
  function parseSubgraph(graph) {
    var subgraph = null;

    // optional subgraph keyword
    if (token === 'subgraph') {
      subgraph = {};
      subgraph.type = 'subgraph';
      getToken();

      // optional graph id
      if (tokenType === TOKENTYPE.IDENTIFIER) {
        subgraph.id = token;
        getToken();
      }
    }

    // open angle bracket
    if (token === '{') {
      getToken();

      if (!subgraph) {
        subgraph = {};
      }
      subgraph.parent = graph;
      subgraph.node = graph.node;
      subgraph.edge = graph.edge;
      subgraph.graph = graph.graph;

      // statements
      parseStatements(subgraph);

      // close angle bracket
      if (token != '}') {
        throw newSyntaxError('Angle bracket } expected');
      }
      getToken();

      // remove temporary default options
      delete subgraph.node;
      delete subgraph.edge;
      delete subgraph.graph;
      delete subgraph.parent;

      // register at the parent graph
      if (!graph.subgraphs) {
        graph.subgraphs = [];
      }
      graph.subgraphs.push(subgraph);
    }

    return subgraph;
  }

  /**
   * parse an attribute statement like "node [shape=circle fontSize=16]".
   * Available keywords are 'node', 'edge', 'graph'.
   * The previous list with default attributes will be replaced
   * @param {Object} graph
   * @returns {String | null} keyword Returns the name of the parsed attribute
   *                                  (node, edge, graph), or null if nothing
   *                                  is parsed.
   */
  function parseAttributeStatement(graph) {
    // attribute statements
    if (token === 'node') {
      getToken();

      // node attributes
      graph.node = parseAttributeList();
      return 'node';
    } else if (token === 'edge') {
      getToken();

      // edge attributes
      graph.edge = parseAttributeList();
      return 'edge';
    } else if (token === 'graph') {
      getToken();

      // graph attributes
      graph.graph = parseAttributeList();
      return 'graph';
    }

    return null;
  }

  /**
   * parse a node statement
   * @param {Object} graph
   * @param {String | Number} id
   */
  function parseNodeStatement(graph, id) {
    // node statement
    var node = {
      id: id
    };
    var attr = parseAttributeList();
    if (attr) {
      node.attr = attr;
    }
    addNode(graph, node);

    // edge statements
    parseEdge(graph, id);
  }

  /**
   * Parse an edge or a series of edges
   * @param {Object} graph
   * @param {String | Number} from        Id of the from node
   */
  function parseEdge(graph, from) {
    while (token === '->' || token === '--') {
      var to;
      var type = token;
      getToken();

      var subgraph = parseSubgraph(graph);
      if (subgraph) {
        to = subgraph;
      } else {
        if (tokenType != TOKENTYPE.IDENTIFIER) {
          throw newSyntaxError('Identifier or subgraph expected');
        }
        to = token;
        addNode(graph, {
          id: to
        });
        getToken();
      }

      // parse edge attributes
      var attr = parseAttributeList();

      // create edge
      var edge = createEdge(graph, from, to, type, attr);
      addEdge(graph, edge);

      from = to;
    }
  }

  /**
   * Parse a set with attributes,
   * for example [label="1.000", shape=solid]
   * @return {Object | null} attr
   */
  function parseAttributeList() {
    var attr = null;

    while (token === '[') {
      getToken();
      attr = {};
      while (token !== '' && token != ']') {
        if (tokenType != TOKENTYPE.IDENTIFIER) {
          throw newSyntaxError('Attribute name expected');
        }
        var name = token;

        getToken();
        if (token != '=') {
          throw newSyntaxError('Equal sign = expected');
        }
        getToken();

        if (tokenType != TOKENTYPE.IDENTIFIER) {
          throw newSyntaxError('Attribute value expected');
        }
        var value = token;
        setValue(attr, name, value); // name can be a path

        getToken();
        if (token == ',') {
          getToken();
        }
      }

      if (token != ']') {
        throw newSyntaxError('Bracket ] expected');
      }
      getToken();
    }

    return attr;
  }

  /**
   * Create a syntax error with extra information on current token and index.
   * @param {String} message
   * @returns {SyntaxError} err
   */
  function newSyntaxError(message) {
    return new SyntaxError(message + ', got "' + chop(token, 30) + '" (char ' + index + ')');
  }

  /**
   * Chop off text after a maximum length
   * @param {String} text
   * @param {Number} maxLength
   * @returns {String}
   */
  function chop(text, maxLength) {
    return text.length <= maxLength ? text : text.substr(0, 27) + '...';
  }

  /**
   * Execute a function fn for each pair of elements in two arrays
   * @param {Array | *} array1
   * @param {Array | *} array2
   * @param {function} fn
   */
  function forEach2(array1, array2, fn) {
    if (Array.isArray(array1)) {
      array1.forEach(function (elem1) {
        if (Array.isArray(array2)) {
          array2.forEach(function (elem2) {
            fn(elem1, elem2);
          });
        } else {
          fn(elem1, array2);
        }
      });
    } else {
      if (Array.isArray(array2)) {
        array2.forEach(function (elem2) {
          fn(array1, elem2);
        });
      } else {
        fn(array1, array2);
      }
    }
  }

  /**
   * Set a nested property on an object
   * When nested objects are missing, they will be created.
   * For example setProp({}, 'font.color', 'red') will return {font: {color: 'red'}}
   * @param {Object} object
   * @param {string} path   A dot separated string like 'font.color'
   * @param {*} value       Value for the property
   * @return {Object} Returns the original object, allows for chaining.
   */
  function setProp(object, path, value) {
    var names = path.split('.');
    var prop = names.pop();

    // traverse over the nested objects
    var obj = object;
    for (var i = 0; i < names.length; i++) {
      var name = names[i];
      if (!(name in obj)) {
        obj[name] = {};
      }
      obj = obj[name];
    }

    // set the property value
    obj[prop] = value;

    return object;
  }

  /**
   * Convert an object with DOT attributes to their vis.js equivalents.
   * @param {Object} attr     Object with DOT attributes
   * @param {Object} mapping
   * @return {Object}         Returns an object with vis.js attributes
   */
  function convertAttr(attr, mapping) {
    var converted = {};

    for (var prop in attr) {
      if (attr.hasOwnProperty(prop)) {
        var visProp = mapping[prop];
        if (Array.isArray(visProp)) {
          visProp.forEach(function (visPropI) {
            setProp(converted, visPropI, attr[prop]);
          });
        } else if (typeof visProp === 'string') {
          setProp(converted, visProp, attr[prop]);
        } else {
          setProp(converted, prop, attr[prop]);
        }
      }
    }

    return converted;
  }

  /**
   * Convert a string containing a graph in DOT language into a map containing
   * with nodes and edges in the format of graph.
   * @param {String} data         Text containing a graph in DOT-notation
   * @return {Object} graphData
   */
  function DOTToGraph(data) {
    // parse the DOT file
    var dotData = parseDOT(data);
    var graphData = {
      nodes: [],
      edges: [],
      options: {}
    };

    // copy the nodes
    if (dotData.nodes) {
      dotData.nodes.forEach(function (dotNode) {
        var graphNode = {
          id: dotNode.id,
          label: String(dotNode.label || dotNode.id)
        };
        merge(graphNode, convertAttr(dotNode.attr, NODE_ATTR_MAPPING));
        if (graphNode.image) {
          graphNode.shape = 'image';
        }
        graphData.nodes.push(graphNode);
      });
    }

    // copy the edges
    if (dotData.edges) {
      /**
       * Convert an edge in DOT format to an edge with VisGraph format
       * @param {Object} dotEdge
       * @returns {Object} graphEdge
       */
      var convertEdge = function convertEdge(dotEdge) {
        var graphEdge = {
          from: dotEdge.from,
          to: dotEdge.to
        };
        merge(graphEdge, convertAttr(dotEdge.attr, EDGE_ATTR_MAPPING));
        graphEdge.arrows = dotEdge.type === '->' ? 'to' : undefined;

        return graphEdge;
      };

      dotData.edges.forEach(function (dotEdge) {
        var from, to;
        if (dotEdge.from instanceof Object) {
          from = dotEdge.from.nodes;
        } else {
          from = {
            id: dotEdge.from
          };
        }

        // TODO: support of solid/dotted/dashed edges (attr = 'style')
        // TODO: support for attributes 'dir' and 'arrowhead' (edge arrows)

        if (dotEdge.to instanceof Object) {
          to = dotEdge.to.nodes;
        } else {
          to = {
            id: dotEdge.to
          };
        }

        if (dotEdge.from instanceof Object && dotEdge.from.edges) {
          dotEdge.from.edges.forEach(function (subEdge) {
            var graphEdge = convertEdge(subEdge);
            graphData.edges.push(graphEdge);
          });
        }

        forEach2(from, to, function (from, to) {
          var subEdge = createEdge(graphData, from.id, to.id, dotEdge.type, dotEdge.attr);
          var graphEdge = convertEdge(subEdge);
          graphData.edges.push(graphEdge);
        });

        if (dotEdge.to instanceof Object && dotEdge.to.edges) {
          dotEdge.to.edges.forEach(function (subEdge) {
            var graphEdge = convertEdge(subEdge);
            graphData.edges.push(graphEdge);
          });
        }
      });
    }

    // copy the options
    if (dotData.attr) {
      graphData.options = dotData.attr;
    }

    return graphData;
  }

  // exports
  exports.parseDOT = parseDOT;
  exports.DOTToGraph = DOTToGraph;

/***/ },
/* 119 */
/***/ function(module, exports) {

  'use strict';

  function parseGephi(gephiJSON, optionsObj) {
    var edges = [];
    var nodes = [];
    var options = {
      edges: {
        inheritColor: false
      },
      nodes: {
        fixed: false,
        parseColor: false
      }
    };

    if (optionsObj !== undefined) {
      if (optionsObj.fixed !== undefined) {
        options.nodes.fixed = optionsObj.fixed;
      }
      if (optionsObj.parseColor !== undefined) {
        options.nodes.parseColor = optionsObj.parseColor;
      }
      if (optionsObj.inheritColor !== undefined) {
        options.edges.inheritColor = optionsObj.inheritColor;
      }
    }

    var gEdges = gephiJSON.edges;
    var gNodes = gephiJSON.nodes;
    for (var i = 0; i < gEdges.length; i++) {
      var edge = {};
      var gEdge = gEdges[i];
      edge['id'] = gEdge.id;
      edge['from'] = gEdge.source;
      edge['to'] = gEdge.target;
      edge['attributes'] = gEdge.attributes;
      edge['label'] = gEdge.label;
      edge['title'] = gEdge.attributes !== undefined ? gEdge.attributes.title : undefined;
      if (gEdge['type'] === 'Directed') {
        edge['arrows'] = 'to';
      }
      //    edge['value'] = gEdge.attributes !== undefined ? gEdge.attributes.Weight : undefined;
      //    edge['width'] = edge['value'] !== undefined ? undefined : edgegEdge.size;
      if (gEdge.color && options.inheritColor === false) {
        edge['color'] = gEdge.color;
      }
      edges.push(edge);
    }

    for (var i = 0; i < gNodes.length; i++) {
      var node = {};
      var gNode = gNodes[i];
      node['id'] = gNode.id;
      node['attributes'] = gNode.attributes;
      node['title'] = gNode.title;
      node['x'] = gNode.x;
      node['y'] = gNode.y;
      node['label'] = gNode.label;
      node['title'] = gNode.attributes !== undefined ? gNode.attributes.title : undefined;
      if (options.nodes.parseColor === true) {
        node['color'] = gNode.color;
      } else {
        node['color'] = gNode.color !== undefined ? { background: gNode.color, border: gNode.color, highlight: { background: gNode.color, border: gNode.color }, hover: { background: gNode.color, border: gNode.color } } : undefined;
      }
      node['size'] = gNode.size;
      node['fixed'] = options.nodes.fixed && gNode.x !== undefined && gNode.y !== undefined;
      nodes.push(node);
    }

    return { nodes: nodes, edges: edges };
  }

  exports.parseGephi = parseGephi;

/***/ },
/* 120 */
/***/ function(module, exports) {

  'use strict';

  // English
  exports['en'] = {
    edit: 'Edit',
    del: 'Delete selected',
    back: 'Back',
    addNode: 'Add Node',
    addEdge: 'Add Edge',
    editNode: 'Edit Node',
    editEdge: 'Edit Edge',
    addDescription: 'Click in an empty space to place a new node.',
    edgeDescription: 'Click on a node and drag the edge to another node to connect them.',
    editEdgeDescription: 'Click on the control points and drag them to a node to connect to it.',
    createEdgeError: 'Cannot link edges to a cluster.',
    deleteClusterError: 'Clusters cannot be deleted.',
    editClusterError: 'Clusters cannot be edited.'
  };
  exports['en_EN'] = exports['en'];
  exports['en_US'] = exports['en'];

  // German
  exports['de'] = {
    edit: 'Editieren',
    del: 'Lsche Auswahl',
    back: 'Zurck',
    addNode: 'Knoten hinzufgen',
    addEdge: 'Kante hinzufgen',
    editNode: 'Knoten editieren',
    editEdge: 'Kante editieren',
    addDescription: 'Klicke auf eine freie Stelle, um einen neuen Knoten zu plazieren.',
    edgeDescription: 'Klicke auf einen Knoten und ziehe die Kante zu einem anderen Knoten, um diese zu verbinden.',
    editEdgeDescription: 'Klicke auf die Verbindungspunkte und ziehe diese auf einen Knoten, um sie zu verbinden.',
    createEdgeError: 'Es ist nicht mglich, Kanten mit Clustern zu verbinden.',
    deleteClusterError: 'Cluster knnen nicht gelscht werden.',
    editClusterError: 'Cluster knnen nicht editiert werden.'
  };
  exports['de_DE'] = exports['de'];

  // Spanish
  exports['es'] = {
    edit: 'Editar',
    del: 'Eliminar seleccin',
    back: 'tras',
    addNode: 'Aadir nodo',
    addEdge: 'Aadir arista',
    editNode: 'Editar nodo',
    editEdge: 'Editar arista',
    addDescription: 'Haga clic en un lugar vaco para colocar un nuevo nodo.',
    edgeDescription: 'Haga clic en un nodo y arrastre la arista hacia otro nodo para conectarlos.',
    editEdgeDescription: 'Haga clic en un punto de control y arrastrelo a un nodo para conectarlo.',
    createEdgeError: 'No se puede conectar una arista a un grupo.',
    deleteClusterError: 'No es posible eliminar grupos.',
    editClusterError: 'No es posible editar grupos.'
  };
  exports['es_ES'] = exports['es'];

  // Dutch
  exports['nl'] = {
    edit: 'Wijzigen',
    del: 'Selectie verwijderen',
    back: 'Terug',
    addNode: 'Node toevoegen',
    addEdge: 'Link toevoegen',
    editNode: 'Node wijzigen',
    editEdge: 'Link wijzigen',
    addDescription: 'Klik op een leeg gebied om een nieuwe node te maken.',
    edgeDescription: 'Klik op een node en sleep de link naar een andere node om ze te verbinden.',
    editEdgeDescription: 'Klik op de verbindingspunten en sleep ze naar een node om daarmee te verbinden.',
    createEdgeError: 'Kan geen link maken naar een cluster.',
    deleteClusterError: 'Clusters kunnen niet worden verwijderd.',
    editClusterError: 'Clusters kunnen niet worden aangepast.'
  };
  exports['nl_NL'] = exports['nl'];
  exports['nl_BE'] = exports['nl'];

/***/ }
/******/ ])
});
;
},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy5ucG0tZ2xvYmFsL2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsImV4YW1wbGVzL2JuZi9pbmRleC5qcyIsImxpYi9EaWFncmFtLmpzIiwibGliL0dyYW1tYXIuanMiLCJsaWIvU3RhdGUuanMiLCJub2RlX21vZHVsZXMvdmlzL2Rpc3QvdmlzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsInZhciBHcmFtbWFyID0gcmVxdWlyZShcIi4uLy4uL2xpYi9HcmFtbWFyXCIpLFxuICAgIFN0YXRlID0gcmVxdWlyZShcIi4uLy4uL2xpYi9TdGF0ZVwiKSxcbiAgICBEaWFncmFtID0gcmVxdWlyZShcIi4uLy4uL2xpYi9EaWFncmFtXCIpO1xuXG5cbnZhciBnID0gbmV3IEdyYW1tYXIoW1wiPFwiLFwiPlwiLFwicnVsZS1uYW1lXCIsXCI6Oj1cIixcInxcIixcImxpbmUtZW5kXCIsXCJXU1wiLFwidGVybVwiXSk7XG5cbmcuYWRkUnVsZXMoe1xuICAgIFwic3ludGF4XCI6IFtbXCJydWxlXCIsXCJzeW50YXhcIl0sW1wicnVsZVwiXV0sXG4gICAgXCJydWxlXCI6IFtbXG4gICAgICAgIFwib3B0LXdoaXRlc3BhY2VcIixcIjxcIixcInJ1bGUtbmFtZVwiLFwiPlwiLFwib3B0LXdoaXRlc3BhY2VcIixcbiAgICAgICAgXCI6Oj1cIixcImV4cHJlc3Npb25cIixcImxpbmUtZW5kXCJcbiAgICBdXSxcbiAgICBcImV4cHJlc3Npb25cIjogW1tcImxpc3RcIl0sW1wibGlzdFwiLFwib3B0LXdoaXRlc3BhY2VcIixcInxcIixcImV4cHJlc3Npb25cIl1dLFxuICAgIFwibGlzdFwiOiBbW1widGVybVwiXSxbXCJ0ZXJtXCIsXCJvcHQtd2hpdGVzcGFjZVwiLFwibGlzdFwiXV0sXG4gICAgXCJvcHQtd2hpdGVzcGFjZVwiOiBbW1wiV1NcIixcIm9wdC13aGl0ZXNwYWNlXCJdLFtcIlwiXV1cbn0pO1xuXG5cbi8qZy5hZGRSdWxlcyh7XG4gICAgXCJzeW50YXhcIjogW1tcInJ1bGVcIixcInN5bnRheFwiXSxbXCJydWxlXCJdXSxcbiAgICBcInJ1bGVcIjogW1tcbiAgICAgICAgXCJvcHQtd2hpdGVzcGFjZVwiLFwibGluZS1lbmRcIlxuICAgIF1dLFxuICAgIFwib3B0LXdoaXRlc3BhY2VcIjogW1tcIldTXCIsXCJvcHQtd2hpdGVzcGFjZVwiXSxbXCJcIl1dXG59KTsqL1xuXG52YXIgc3RhcnQgPSBnLmJ1aWxkKCdzeW50YXgnKTtcblxuRGlhZ3JhbS5kcmF3U3RhdGVEaWFncmFtKHN0YXJ0LFxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250YWluZXInKSk7XG4iLCJ2YXIgdmlzID0gcmVxdWlyZShcInZpc1wiKTtcblxudmFyIERpYWdyYW0gPSB7fTtcblxuRGlhZ3JhbS5idWlsZERhdGEgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBsYWJlbEluZGV4ID0ge30sXG4gICAgICAgIG5vZGVzID0gW10sXG4gICAgICAgIGVkZ2VzID0gW107XG4gICAgZnVuY3Rpb24gYnVpbGRJbmRleChzdGF0ZSkge1xuICAgICAgICBpZih0eXBlb2YgbGFiZWxJbmRleFtzdGF0ZS5sYWJlbF0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGxhYmVsSW5kZXhbc3RhdGUubGFiZWxdID1cbiAgICAgICAgICAgICAgICB7aWQ6c3RhdGUubGFiZWwsIGxhYmVsOnN0YXRlLmxhYmVsfTtcbiAgICAgICAgICAgIG5vZGVzLnB1c2gobGFiZWxJbmRleFtzdGF0ZS5sYWJlbF0pO1xuICAgICAgICAgICAgZm9yKHZhciBpPTAsbD1zdGF0ZS5zdGF0ZXMubGVuZ3RoO2k8bDtpKyspIHtcbiAgICAgICAgICAgICAgICBlZGdlcy5wdXNoKHtmcm9tOnN0YXRlLmxhYmVsLHRvOnN0YXRlLnN0YXRlc1tpXS5sYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDpzdGF0ZS5zdGF0ZXNbaV0udGVybWluYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udDoge2FsaWduOiAnbWlkZGxlJ30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyb3dzOid0byd9KTtcbiAgICAgICAgICAgICAgICBidWlsZEluZGV4KHN0YXRlLnN0YXRlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYnVpbGRJbmRleChzdGF0ZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZXM6IG5vZGVzLFxuICAgICAgICBlZGdlczogZWRnZXNcbiAgICB9O1xufVxuXG5EaWFncmFtLmRyYXdGcm9tRGF0YSA9IGZ1bmN0aW9uKG5vZGVzLGVkZ2VzLGNvbnRhaW5lcikge1xuICAgIHZhciBuZXR3b3JrID0gbmV3IHZpcy5OZXR3b3JrKGNvbnRhaW5lcixcbiAgICAgICAge25vZGVzOm5vZGVzLGVkZ2VzOmVkZ2VzfSwge30pO1xuICAgIHJldHVybiBuZXR3b3JrO1xufVxuXG5EaWFncmFtLmRyYXdTdGF0ZURpYWdyYW0gPSBmdW5jdGlvbihzdGF0ZSxjb250YWluZXIpIHtcbiAgICAvLyBmaXJzdCBidWlsZCBub2RlcyB2YXJpYWJsZVxuICAgIHZhciBkYXRhID0gRGlhZ3JhbS5idWlsZERhdGEoc3RhdGUpO1xuICAgIHZhciBuZXR3b3JrID0gbmV3IHZpcy5OZXR3b3JrKGNvbnRhaW5lciwgZGF0YSwge30pO1xuICAgIHJldHVybiBuZXR3b3JrO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERpYWdyYW07XG4iLCJ2YXIgU3RhdGUgPSByZXF1aXJlKFwiLi9TdGF0ZS5qc1wiKTtcblxuZnVuY3Rpb24gR3JhbW1hcih0ZXJtaW5hbHMsIHJ1bGVzKSB7XG4gICAgdGhpcy50ZXJtaW5hbHMgPSBbXTtcbiAgICB0aGlzLnJ1bGVzID0ge307XG4gICAgdGhpcy51bnJlc29sdmVkU3RhdGVzID0gW107XG4gICAgdGhpcy5zdGF0ZU9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmFkZFRlcm1pbmFscyh0ZXJtaW5hbHMgfHwgW10pO1xuICAgIHRoaXMuYWRkUnVsZXMocnVsZXMgfHwge30pO1xufVxuXG5HcmFtbWFyLnByb3RvdHlwZSA9IHtcbiAgICBhZGRUZXJtaW5hbHMgOiBmdW5jdGlvbih0ZXJtaW5hbHMpIHtcbiAgICAgICAgdGhpcy50ZXJtaW5hbHMgPSB0aGlzLnRlcm1pbmFscy5jb25jYXQodGVybWluYWxzKTtcbiAgICB9LFxuICAgIGFkZFJ1bGVzIDogZnVuY3Rpb24ocnVsZXMpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLnJ1bGVzLCBydWxlcyk7XG4gICAgfSxcbiAgICBpc1Rlcm1pbmFsIDogZnVuY3Rpb24odCkge1xuICAgIFx0XHRyZXR1cm4gdGhpcy50ZXJtaW5hbHMuaW5kZXhPZih0KSA+IC0xO1xuICAgIH0sXG4gICAgZmlyc3RQYXNzIDogZnVuY3Rpb24ocnVsZSxydWxlTGFiZWwpIHtcbiAgICAgICAgLy8gd2FudCB0byBvdXRwdXQgdGhlIHJ1bGUncyBzdGF0ZXMsIG9uZSBmb3IgZWFjaCBvcHRpb25cbiAgICAgICAgLy8gYW5kIHJlbWVtYmVyIHdoZXJlIHRvIGluc2VydCBvdGhlciBydWxlcycgc3RhdGVzXG4gICAgICAgIC8vIHJ1bGUgaXMgYW4gYXJyYXkgb2Ygb3B0aW9uc1xuICAgICAgICBmb3IodmFyIGkgPSAwLCBybGVuID0gcnVsZS5sZW5ndGgsIG9wdGlvbiwgaiwgcywgbHMsIHJzPVtdO1xuICAgICAgICAgICAgaSA8IHJsZW47IGkrKykge1xuICAgICAgICAgICAgb3B0aW9uID0gcnVsZVtpXTtcbiAgICAgICAgICAgIC8vIG9wdGlvbiBpcyBhbiBhcnJheSBvZiB0ZXJtaW5hbHMgYW5kIHJ1bGUgbmFtZXNcbiAgICAgICAgICAgIC8vIHdhbnQgdG8gZ28gdGhyb3VnaCB0aGVtIGluIHJldmVyc2Ugb3JkZXJcbiAgICAgICAgICAgIGogPSBvcHRpb24ubGVuZ3RoO1xuICAgICAgICAgICAgbHMgPSBbXTtcbiAgICAgICAgICAgIHdoaWxlKGotLSkge1xuICAgICAgICAgICAgICAgIHMgPSBuZXcgU3RhdGUob3B0aW9uW2pdKTtcbiAgICAgICAgICAgICAgICBpZihsc1swXSAmJiBsc1swXS5kdW1teSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVucmVzb2x2ZWRTdGF0ZXMucHVzaChbbHNbMF0sc10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzLmFkZFN0YXRlcyhscyk7XG4gICAgICAgICAgICAgICAgbHMgPSBbc107XG4gICAgICAgICAgICAgICAgaWYoIXRoaXMuaXNUZXJtaW5hbChvcHRpb25bal0pICYmIG9wdGlvbltqXSAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyByZW1lbWJlciB0byBwdXQgaW4gdGhlIGNvcnJlY3Qgc3RhdGVzIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgIHMuZHVtbXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJzID0gU3RhdGUubWVyZ2UocnMsbHMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGVPcHRpb25zW3J1bGVMYWJlbF0gPSBycztcbiAgICAgICAgcmV0dXJuIHJzO1xuICAgIH0sXG4gICAgYnVpbGQgOiBmdW5jdGlvbihzdGFydFN5bWJvbCkge1xuICAgICAgICB2YXIgcmV0LCBzdGFydCA9IG5ldyBTdGF0ZShcIlwiLHN0YXJ0U3ltYm9sKTtcbiAgICAgICAgLy8gZWFjaCBydWxlIG5lZWRzIHRvIGhhdmUgaXQncyBmaXJzdCBwYXNzXG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMucnVsZXMpLmZvckVhY2goZnVuY3Rpb24ocnVsZUxhYmVsKXtcbiAgICAgICAgICAgIHRoaXMuZmlyc3RQYXNzKHRoaXMucnVsZXNbcnVsZUxhYmVsXSxydWxlTGFiZWwpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgc3RhcnQuYWRkU3RhdGVzKHRoaXMuYnVpbGRUcmF2ZXJzZShzdGFydFN5bWJvbCkpO1xuICAgICAgICByZXR1cm4gc3RhcnQ7XG4gICAgfSxcblxuICAgIC8qYnVpbGRUcmF2ZXJzZSA6IGZ1bmN0aW9uKHN0YXJ0U3ltYm9sLHJQLGVuZFN0YXRlcykge1xuICAgICAgICBpZih0eXBlb2YgdGhpcy5zdGF0ZU9wdGlvbnNbc3RhcnRTeW1ib2xdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVW5rbm93biBSdWxlIE5hbWU6IFwiK3N0YXJ0U3ltYm9sKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgclAgPSByUCB8fCB7fSxcbiAgICAgICAgICAgIGVuZFN0YXRlcyA9IGVuZFN0YXRlcyB8fCBbXSxcbiAgICAgICAgICAgIHJ1bGUgPSB0aGlzLnN0YXRlT3B0aW9uc1tzdGFydFN5bWJvbF0sXG4gICAgICAgICAgICByZXRTdGF0ZSA9IG5ldyBTdGF0ZShcIlwiLHN0YXJ0U3ltYm9sKSxcbiAgICAgICAgICAgIGxzID0gW107XG4gICAgICAgIHJQW3N0YXJ0U3ltYm9sXSA9IHJldFN0YXRlO1xuICAgICAgICBydWxlLmZvckVhY2goZnVuY3Rpb24oc3RhdGUpe1xuICAgICAgICAgICAgLy8gZ28gdGhyb3VnaCBzdGF0ZXNcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcywgYmxhbmthYmxlID0gZmFsc2U7XG4gICAgICAgICAgICBmdW5jdGlvbiBwcm9jZXNzU3RhdGUoc3RhdGUsbGFzdFN0YXRlLGxpKSB7XG4gICAgICAgICAgICAgICAgaWYoc3RhdGUuZHVtbXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cobGksbGFzdFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIGxpICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFN0YXRlLnN0YXRlcy5zcGxpY2UobGksMSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgYmxhbmthYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIHJQW3N0YXRlLnRlcm1pbmFsXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFN0YXRlLmFkZFN0YXRlcyhzZWxmLmJ1aWxkVHJhdmVyc2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUudGVybWluYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgclAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuc3RhdGVzXG4gICAgICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN0YXRlLnRlcm1pbmFsID09PSBzdGFydFN5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxzLnB1c2gobGFzdFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHN0YXRlLnN0YXRlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFN0YXRlLmFkZFN0YXRlcyhyUFtzdGF0ZS50ZXJtaW5hbF0uc3RhdGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZihzdGF0ZS50ZXJtaW5hbCA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICBsYXN0U3RhdGUuYWRkU3RhdGVzKGVuZFN0YXRlcyk7XG4gICAgICAgICAgICAgICAgICAgIGJsYW5rYWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYoc3RhdGUuc3RhdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zdGF0ZXMgPSBlbmRTdGF0ZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zdGF0ZXMuZm9yRWFjaChmdW5jdGlvbihzLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NTdGF0ZShzLHN0YXRlLGkpO1xuICAgICAgICAgICAgICAgICAgICB9LHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb2Nlc3NTdGF0ZShzdGF0ZSxyZXRTdGF0ZSk7XG4gICAgICAgICAgICBpZighYmxhbmthYmxlKSAgcmV0U3RhdGUuYWRkU3RhdGVzKFtzdGF0ZV0pO1xuICAgICAgICB9LHRoaXMpO1xuICAgICAgICBscy5mb3JFYWNoKGZ1bmN0aW9uKHMpe1xuICAgICAgICAgICAgcy5hZGRTdGF0ZXMoclBbc3RhcnRTeW1ib2xdLnN0YXRlcyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmV0U3RhdGUuc3RhdGVzO1xuICAgIH0sKi9cblxuICAgIGJ1aWxkVHJhdmVyc2U6IGZ1bmN0aW9uKHN5bWJvbCxlbmRTdGF0ZXMpIHtcbiAgICAgICAgdmFyIHJ1bGUgPSB0aGlzLnN0YXRlT3B0aW9ucyhzeW1ib2wpLFxuICAgICAgICAgICAgcmV0U3RhdGUgPSBuZXcgU3RhdGUoXCJcIixzeW1ib2wpO1xuICAgICAgICByZXRTdGF0ZS5hZGRTdGF0ZXMocnVsZSk7XG4gICAgICAgIGZvcih2YXIgb3B0aW9uSW5kZXggPSAwLCBvcHRpb25Db3VudCA9IHJ1bGUubGVuZ3RoO1xuICAgICAgICAgICAgb3B0aW9uSW5kZXggPCBvcHRpb25Db3VudDsgb3B0aW9uSW5kZXgrKykge1xuICAgICAgICAgICAgLy8gc3RlcCB0aHJvdWdoIHN0YXRlc1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gcmV0U3RhdGUuc3RhdGVzW29wdGlvbkluZGV4XSwgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBmdW5jdGlvbiBzdGVwKHN0YXRlLGxhc3RTdGF0ZSxzdGF0ZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRTdGF0ZXMgPSBzdGF0ZS5zdGF0ZXMubGVuZ3RoID4gMCA/XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnN0YXRlcyA6IGVuZFN0YXRlcztcbiAgICAgICAgICAgICAgICBpZihzdGF0ZS5kdW1teSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcnVsZVN0YXRlID0gc2VsZi5idWlsZFRyYXZlcnNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUudGVybWluYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRTdGF0ZXNcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFN0YXRlLnN0YXRlcy5zcGxpY2Uoc3RhdGVJbmRleCwxKTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFN0YXRlLmFkZFN0YXRlcyhydWxlU3RhdGUuc3RhdGVzKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBsYXN0U3RhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHN0YXRlIG11c3QgYmUgYSB0ZXJtaW5hbCBub3dcbiAgICAgICAgICAgICAgICBpZihzdGF0ZS50ZXJtaW5hbCA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICBsYXN0U3RhdGUuc3RhdGVzLnNwbGljZShzdGF0ZUluZGV4LDEpO1xuICAgICAgICAgICAgICAgICAgICBsYXN0U3RhdGUuYWRkU3RhdGVzKG5leHRTdGF0ZXMpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IGxhc3RTdGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gc3RhdGUgaXMgbm93IGEgbm9uLWVtcHR5IHRlcm1pbmFsXG4gICAgICAgICAgICAgICAgaWYoc3RhdGUuc3RhdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5hZGRTdGF0ZXMoZW5kU3RhdGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaT0wLGw9c3RhdGUuc3RhdGVzLmxlbmd0aDsgaTxsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXAoc3RhdGUuc3RhdGVzW2ldLHN0YXRlLGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbm1vZHVsZS5leHBvcnRzID0gR3JhbW1hcjtcbiIsInZhciBTdGF0ZUNvdW50ID0gMDtcblxuZnVuY3Rpb24gdW5pb25fYXJyYXlzICh4LCB5KSB7XG4gICAgdmFyIG9iaiA9IHt9O1xuICAgIGZvciAodmFyIGkgPSB4Lmxlbmd0aC0xOyBpID49IDA7IC0tIGkpXG4gICAgICAgb2JqW3hbaV1dID0geFtpXTtcbiAgICBmb3IgKHZhciBpID0geS5sZW5ndGgtMTsgaSA+PSAwOyAtLSBpKVxuICAgICAgIG9ialt5W2ldXSA9IHlbaV07XG4gICAgdmFyIHJlcyA9IFtdXG4gICAgZm9yICh2YXIgayBpbiBvYmopIHtcbiAgICAgICAgcmVzLnB1c2gob2JqW2tdKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gU3RhdGUodGVybWluYWwsbGFiZWwpIHtcblx0XHR0aGlzLnRlcm1pbmFsID0gdGVybWluYWw7XG5cdFx0dGhpcy5zdGF0ZXMgPSBbXTtcbiAgICB0aGlzLmxhYmVsID0gbGFiZWwgfHwgU3RhdGVDb3VudCsrO1xufVxuXG5TdGF0ZS5tZXJnZSA9IGZ1bmN0aW9uKHJldG9wcywgb3BzKSB7XG5cdFx0aWYodHlwZW9mIHJldG9wcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIFx0XHRyZXRvcHMgPSBbXTtcbiAgICB9XG4gICAgb3BzLmZvckVhY2goZnVuY3Rpb24ob3Ape1xuICAgIFx0XHRzdCA9IHJldG9wcy5maW5kKGZ1bmN0aW9uKHJvcCkge1xuICAgICAgICBcdFx0cmV0dXJuIHJvcC50ZXJtaW5hbCA9PT0gb3AudGVybWluYWw7XG4gICAgICAgIH0pO1xuICAgICAgICBpZih0eXBlb2Ygc3QgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgXHRcdHN0ID0gU3RhdGUubWVyZ2Uoc3Quc3RhdGVzLCBvcC5zdGF0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICBcdFx0cmV0b3BzLnB1c2gob3ApO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldG9wcztcbn1cblxuU3RhdGUuYWRkVG9FbmQgPSBmdW5jdGlvbih0YXJnZXRzLGluc2VydCkge1xuICAgIGZvcih2YXIgaT0wLGw9dGFyZ2V0cy5sZW5ndGg7IGk8bDsgaSsrKSB7XG4gICAgICAgIGlmKHRhcmdldHNbaV0uc3RhdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGFyZ2V0c1tpXS5zdGF0ZXMgPSBpbnNlcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBTdGF0ZS5hZGRUb0VuZCh0YXJnZXRzW2ldLnN0YXRlcyxpbnNlcnQpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5TdGF0ZS5wcm90b3R5cGUgPSB7XG5cdGFkZFN0YXRlcyA6IGZ1bmN0aW9uKHN0YXRlcyxjb3B5KSB7XG4gICAgICAgIGlmKGNvcHkpIHtcbiAgICAgICAgICAgIHZhciBuZXdTdGF0ZXMgPSBbXTtcbiAgICAgICAgICAgIHN0YXRlcy5mb3JFYWNoKGZ1bmN0aW9uKHMpe1xuICAgICAgICAgICAgICAgIG5ld1N0YXRlcy5wdXNoKHMuZGVlcENvcHkoKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN0YXRlcyA9IG5ld1N0YXRlcztcbiAgICAgICAgfVxuXHRcdHRoaXMuc3RhdGVzID0gU3RhdGUubWVyZ2UodGhpcy5zdGF0ZXMsIHN0YXRlcyk7XG4gICAgfSxcbiAgICBkZWVwQ29weSA6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcyA9IG5ldyBTdGF0ZSh0aGlzLnRlcm1pbmFsKSxcbiAgICAgICAgICAgIG9sZExhYmVscyA9IHt9O1xuICAgICAgICBmb3IodmFyIGk9MCxsPXRoaXMuc3RhdGVzLmxlbmd0aDtpPGw7aSsrKSB7XG4gICAgICAgICAgICBpZih0eXBlb2Ygb2xkTGFiZWxzW3RoaXMuc3RhdGVzW2ldLmxhYmVsXSA9PT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgICAgICYmICF0aGlzLnN0YXRlc1tpXS5kdW1teSkge1xuICAgICAgICAgICAgICAgIG9sZExhYmVsc1t0aGlzLnN0YXRlc1tpXS5sYWJlbF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHMuc3RhdGVzLnB1c2godGhpcy5zdGF0ZXNbaV0uZGVlcENvcHkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlO1xuIiwiLyoqXG4gKiB2aXMuanNcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hbG1lbmRlL3Zpc1xuICpcbiAqIEEgZHluYW1pYywgYnJvd3Nlci1iYXNlZCB2aXN1YWxpemF0aW9uIGxpYnJhcnkuXG4gKlxuICogQHZlcnNpb24gNC4xNi4xXG4gKiBAZGF0ZSAgICAyMDE2LTA0LTE4XG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoQykgMjAxMS0yMDE2IEFsbWVuZGUgQi5WLCBodHRwOi8vYWxtZW5kZS5jb21cbiAqXG4gKiBWaXMuanMgaXMgZHVhbCBsaWNlbnNlZCB1bmRlciBib3RoXG4gKlxuICogKiBUaGUgQXBhY2hlIDIuMCBMaWNlbnNlXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIGFuZFxuICpcbiAqICogVGhlIE1JVCBMaWNlbnNlXG4gKiAgIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqXG4gKiBWaXMuanMgbWF5IGJlIGRpc3RyaWJ1dGVkIHVuZGVyIGVpdGhlciBsaWNlbnNlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJ2aXNcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1widmlzXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4vKioqKioqLyBcdFx0fTtcblxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cblxuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbiAgLy8gR3JhcGgzZFxuICB1dGlsLmV4dGVuZChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpKTtcblxuICAvLyBUaW1lbGluZSAmIEdyYXBoMmRcbiAgdXRpbC5leHRlbmQoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXygyNCkpO1xuXG4gIC8vIE5ldHdvcmtcbiAgdXRpbC5leHRlbmQoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyg2MCkpO1xuXG4vKioqLyB9LFxuLyogMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG4gIC8vIHV0aWxpdHkgZnVuY3Rpb25zXG5cbiAgLy8gZmlyc3QgY2hlY2sgaWYgbW9tZW50LmpzIGlzIGFscmVhZHkgbG9hZGVkIGluIHRoZSBicm93c2VyIHdpbmRvdywgaWYgc28sXG4gIC8vIHVzZSB0aGlzIGluc3RhbmNlLiBFbHNlLCBsb2FkIHZpYSBjb21tb25qcy5cblxuICB2YXIgbW9tZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbiAgdmFyIHV1aWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG4gIC8qKlxuICAgKiBUZXN0IHdoZXRoZXIgZ2l2ZW4gb2JqZWN0IGlzIGEgbnVtYmVyXG4gICAqIEBwYXJhbSB7Kn0gb2JqZWN0XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGlzTnVtYmVyXG4gICAqL1xuICBleHBvcnRzLmlzTnVtYmVyID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBOdW1iZXIgfHwgdHlwZW9mIG9iamVjdCA9PSAnbnVtYmVyJztcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGV2ZXJ5dGhpbmcgaW4gdGhlIERPTSBvYmplY3RcbiAgICogQHBhcmFtIERPTW9iamVjdFxuICAgKi9cbiAgZXhwb3J0cy5yZWN1cnNpdmVET01EZWxldGUgPSBmdW5jdGlvbiAoRE9Nb2JqZWN0KSB7XG4gICAgaWYgKERPTW9iamVjdCkge1xuICAgICAgd2hpbGUgKERPTW9iamVjdC5oYXNDaGlsZE5vZGVzKCkgPT09IHRydWUpIHtcbiAgICAgICAgZXhwb3J0cy5yZWN1cnNpdmVET01EZWxldGUoRE9Nb2JqZWN0LmZpcnN0Q2hpbGQpO1xuICAgICAgICBET01vYmplY3QucmVtb3ZlQ2hpbGQoRE9Nb2JqZWN0LmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogdGhpcyBmdW5jdGlvbiBnaXZlcyB5b3UgYSByYW5nZSBiZXR3ZWVuIDAgYW5kIDEgYmFzZWQgb24gdGhlIG1pbiBhbmQgbWF4IHZhbHVlcyBpbiB0aGUgc2V0LCB0aGUgdG90YWwgc3VtIG9mIGFsbCB2YWx1ZXMgYW5kIHRoZSBjdXJyZW50IHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0gbWluXG4gICAqIEBwYXJhbSBtYXhcbiAgICogQHBhcmFtIHRvdGFsXG4gICAqIEBwYXJhbSB2YWx1ZVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZXhwb3J0cy5naXZlUmFuZ2UgPSBmdW5jdGlvbiAobWluLCBtYXgsIHRvdGFsLCB2YWx1ZSkge1xuICAgIGlmIChtYXggPT0gbWluKSB7XG4gICAgICByZXR1cm4gMC41O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2NhbGUgPSAxIC8gKG1heCAtIG1pbik7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoMCwgKHZhbHVlIC0gbWluKSAqIHNjYWxlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFRlc3Qgd2hldGhlciBnaXZlbiBvYmplY3QgaXMgYSBzdHJpbmdcbiAgICogQHBhcmFtIHsqfSBvYmplY3RcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gaXNTdHJpbmdcbiAgICovXG4gIGV4cG9ydHMuaXNTdHJpbmcgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIFN0cmluZyB8fCB0eXBlb2Ygb2JqZWN0ID09ICdzdHJpbmcnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUZXN0IHdoZXRoZXIgZ2l2ZW4gb2JqZWN0IGlzIGEgRGF0ZSwgb3IgYSBTdHJpbmcgY29udGFpbmluZyBhIERhdGVcbiAgICogQHBhcmFtIHtEYXRlIHwgU3RyaW5nfSBvYmplY3RcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gaXNEYXRlXG4gICAqL1xuICBleHBvcnRzLmlzRGF0ZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChleHBvcnRzLmlzU3RyaW5nKG9iamVjdCkpIHtcbiAgICAgIC8vIHRlc3Qgd2hldGhlciB0aGlzIHN0cmluZyBjb250YWlucyBhIGRhdGVcbiAgICAgIHZhciBtYXRjaCA9IEFTUERhdGVSZWdleC5leGVjKG9iamVjdCk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKCFpc05hTihEYXRlLnBhcnNlKG9iamVjdCkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgc2VtaSBVVUlEXG4gICAqIHNvdXJjZTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTA1MDc0LzEyNjI3NTNcbiAgICogQHJldHVybiB7U3RyaW5nfSB1dWlkXG4gICAqL1xuICBleHBvcnRzLnJhbmRvbVVVSUQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHV1aWQudjQoKTtcbiAgfTtcblxuICAvKipcbiAgICogYXNzaWduIGFsbCBrZXlzIG9mIGFuIG9iamVjdCB0aGF0IGFyZSBub3QgbmVzdGVkIG9iamVjdHMgdG8gYSBjZXJ0YWluIHZhbHVlICh1c2VkIGZvciBjb2xvciBvYmplY3RzKS5cbiAgICogQHBhcmFtIG9ialxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICovXG4gIGV4cG9ydHMuYXNzaWduQWxsS2V5cyA9IGZ1bmN0aW9uIChvYmosIHZhbHVlKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgaWYgKF90eXBlb2Yob2JqW3Byb3BdKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBvYmpbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRmlsbCBhbiBvYmplY3Qgd2l0aCBhIHBvc3NpYmx5IHBhcnRpYWxseSBkZWZpbmVkIG90aGVyIG9iamVjdC4gT25seSBjb3BpZXMgdmFsdWVzIGlmIHRoZSBhIG9iamVjdCBoYXMgYW4gb2JqZWN0IHJlcXVpcmluZyB2YWx1ZXMuXG4gICAqIFRoYXQgbWVhbnMgYW4gb2JqZWN0IGlzIG5vdCBjcmVhdGVkIG9uIGEgcHJvcGVydHkgaWYgb25seSB0aGUgYiBvYmplY3QgaGFzIGl0LlxuICAgKiBAcGFyYW0gb2JqXG4gICAqIEBwYXJhbSB2YWx1ZVxuICAgKi9cbiAgZXhwb3J0cy5maWxsSWZEZWZpbmVkID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICB2YXIgYWxsb3dEZWxldGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogYXJndW1lbnRzWzJdO1xuXG4gICAgZm9yICh2YXIgcHJvcCBpbiBhKSB7XG4gICAgICBpZiAoYltwcm9wXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChfdHlwZW9mKGJbcHJvcF0pICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGlmICgoYltwcm9wXSA9PT0gdW5kZWZpbmVkIHx8IGJbcHJvcF0gPT09IG51bGwpICYmIGFbcHJvcF0gIT09IHVuZGVmaW5lZCAmJiBhbGxvd0RlbGV0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICBkZWxldGUgYVtwcm9wXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYVtwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChfdHlwZW9mKGFbcHJvcF0pID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZXhwb3J0cy5maWxsSWZEZWZpbmVkKGFbcHJvcF0sIGJbcHJvcF0sIGFsbG93RGVsZXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRXh0ZW5kIG9iamVjdCBhIHdpdGggdGhlIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGIgb3IgYSBzZXJpZXMgb2Ygb2JqZWN0c1xuICAgKiBPbmx5IHByb3BlcnRpZXMgd2l0aCBkZWZpbmVkIHZhbHVlcyBhcmUgY29waWVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhXG4gICAqIEBwYXJhbSB7Li4uIE9iamVjdH0gYlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGFcbiAgICovXG4gIGV4cG9ydHMucHJvdG9FeHRlbmQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgb3RoZXIgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHZhciBwcm9wIGluIG90aGVyKSB7XG4gICAgICAgIGFbcHJvcF0gPSBvdGhlcltwcm9wXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4dGVuZCBvYmplY3QgYSB3aXRoIHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiIG9yIGEgc2VyaWVzIG9mIG9iamVjdHNcbiAgICogT25seSBwcm9wZXJ0aWVzIHdpdGggZGVmaW5lZCB2YWx1ZXMgYXJlIGNvcGllZFxuICAgKiBAcGFyYW0ge09iamVjdH0gYVxuICAgKiBAcGFyYW0gey4uLiBPYmplY3R9IGJcbiAgICogQHJldHVybiB7T2JqZWN0fSBhXG4gICAqL1xuICBleHBvcnRzLmV4dGVuZCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvdGhlciA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gb3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgYVtwcm9wXSA9IG90aGVyW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFeHRlbmQgb2JqZWN0IGEgd2l0aCBzZWxlY3RlZCBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiIG9yIGEgc2VyaWVzIG9mIG9iamVjdHNcbiAgICogT25seSBwcm9wZXJ0aWVzIHdpdGggZGVmaW5lZCB2YWx1ZXMgYXJlIGNvcGllZFxuICAgKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fSBwcm9wc1xuICAgKiBAcGFyYW0ge09iamVjdH0gYVxuICAgKiBAcGFyYW0ge09iamVjdH0gYlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGFcbiAgICovXG4gIGV4cG9ydHMuc2VsZWN0aXZlRXh0ZW5kID0gZnVuY3Rpb24gKHByb3BzLCBhLCBiKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcnJheSB3aXRoIHByb3BlcnR5IG5hbWVzIGV4cGVjdGVkIGFzIGZpcnN0IGFyZ3VtZW50Jyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvdGhlciA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCBwcm9wcy5sZW5ndGg7IHArKykge1xuICAgICAgICB2YXIgcHJvcCA9IHByb3BzW3BdO1xuICAgICAgICBpZiAob3RoZXIuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICBhW3Byb3BdID0gb3RoZXJbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4dGVuZCBvYmplY3QgYSB3aXRoIHNlbGVjdGVkIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGIgb3IgYSBzZXJpZXMgb2Ygb2JqZWN0c1xuICAgKiBPbmx5IHByb3BlcnRpZXMgd2l0aCBkZWZpbmVkIHZhbHVlcyBhcmUgY29waWVkXG4gICAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz59IHByb3BzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBiXG4gICAqIEByZXR1cm4ge09iamVjdH0gYVxuICAgKi9cbiAgZXhwb3J0cy5zZWxlY3RpdmVEZWVwRXh0ZW5kID0gZnVuY3Rpb24gKHByb3BzLCBhLCBiKSB7XG4gICAgdmFyIGFsbG93RGVsZXRpb24gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDMgfHwgYXJndW1lbnRzWzNdID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1szXTtcblxuICAgIC8vIFRPRE86IGFkZCBzdXBwb3J0IGZvciBBcnJheXMgdG8gZGVlcEV4dGVuZFxuICAgIGlmIChBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgZGVlcEV4dGVuZCcpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG90aGVyID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCBwcm9wcy5sZW5ndGg7IHArKykge1xuICAgICAgICB2YXIgcHJvcCA9IHByb3BzW3BdO1xuICAgICAgICBpZiAob3RoZXIuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICBpZiAoYltwcm9wXSAmJiBiW3Byb3BdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChhW3Byb3BdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgYVtwcm9wXSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFbcHJvcF0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICAgICAgICBleHBvcnRzLmRlZXBFeHRlbmQoYVtwcm9wXSwgYltwcm9wXSwgZmFsc2UsIGFsbG93RGVsZXRpb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGJbcHJvcF0gPT09IG51bGwgJiYgYVtwcm9wXSAhPT0gdW5kZWZpbmVkICYmIGFsbG93RGVsZXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgYVtwcm9wXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhW3Byb3BdID0gYltwcm9wXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShiW3Byb3BdKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXlzIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IGRlZXBFeHRlbmQnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGJbcHJvcF0gPT09IG51bGwgJiYgYVtwcm9wXSAhPT0gdW5kZWZpbmVkICYmIGFsbG93RGVsZXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIGFbcHJvcF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhW3Byb3BdID0gYltwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4dGVuZCBvYmplY3QgYSB3aXRoIHNlbGVjdGVkIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGIgb3IgYSBzZXJpZXMgb2Ygb2JqZWN0c1xuICAgKiBPbmx5IHByb3BlcnRpZXMgd2l0aCBkZWZpbmVkIHZhbHVlcyBhcmUgY29waWVkXG4gICAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz59IHByb3BzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBiXG4gICAqIEByZXR1cm4ge09iamVjdH0gYVxuICAgKi9cbiAgZXhwb3J0cy5zZWxlY3RpdmVOb3REZWVwRXh0ZW5kID0gZnVuY3Rpb24gKHByb3BzLCBhLCBiKSB7XG4gICAgdmFyIGFsbG93RGVsZXRpb24gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDMgfHwgYXJndW1lbnRzWzNdID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1szXTtcblxuICAgIC8vIFRPRE86IGFkZCBzdXBwb3J0IGZvciBBcnJheXMgdG8gZGVlcEV4dGVuZFxuICAgIGlmIChBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgZGVlcEV4dGVuZCcpO1xuICAgIH1cbiAgICBmb3IgKHZhciBwcm9wIGluIGIpIHtcbiAgICAgIGlmIChiLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgIGlmIChwcm9wcy5pbmRleE9mKHByb3ApID09IC0xKSB7XG4gICAgICAgICAgaWYgKGJbcHJvcF0gJiYgYltwcm9wXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoYVtwcm9wXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGFbcHJvcF0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhW3Byb3BdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICAgICAgZXhwb3J0cy5kZWVwRXh0ZW5kKGFbcHJvcF0sIGJbcHJvcF0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGJbcHJvcF0gPT09IG51bGwgJiYgYVtwcm9wXSAhPT0gdW5kZWZpbmVkICYmIGFsbG93RGVsZXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgYVtwcm9wXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhW3Byb3BdID0gYltwcm9wXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShiW3Byb3BdKSkge1xuICAgICAgICAgICAgYVtwcm9wXSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiW3Byb3BdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGFbcHJvcF0ucHVzaChiW3Byb3BdW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGJbcHJvcF0gPT09IG51bGwgJiYgYVtwcm9wXSAhPT0gdW5kZWZpbmVkICYmIGFsbG93RGVsZXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIGFbcHJvcF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhW3Byb3BdID0gYltwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlZXAgZXh0ZW5kIGFuIG9iamVjdCBhIHdpdGggdGhlIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGJcbiAgICogQHBhcmFtIHtPYmplY3R9IGFcbiAgICogQHBhcmFtIHtPYmplY3R9IGJcbiAgICogQHBhcmFtIFtCb29sZWFuXSBwcm90b0V4dGVuZCAtLT4gb3B0aW9uYWwgcGFyYW1ldGVyLiBJZiB0cnVlLCB0aGUgcHJvdG90eXBlIHZhbHVlcyB3aWxsIGFsc28gYmUgZXh0ZW5kZWQuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpZS4gdGhlIG9wdGlvbnMgb2JqZWN0cyB0aGF0IGluaGVyaXQgZnJvbSBvdGhlcnMgd2lsbCBhbHNvIGdldCB0aGUgaW5oZXJpdGVkIG9wdGlvbnMpXG4gICAqIEBwYXJhbSBbQm9vbGVhbl0gZ2xvYmFsICAgICAgLS0+IG9wdGlvbmFsIHBhcmFtZXRlci4gSWYgdHJ1ZSwgdGhlIHZhbHVlcyBvZiBmaWVsZHMgdGhhdCBhcmUgbnVsbCB3aWxsIG5vdCBkZWxldGVkXG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqL1xuICBleHBvcnRzLmRlZXBFeHRlbmQgPSBmdW5jdGlvbiAoYSwgYiwgcHJvdG9FeHRlbmQsIGFsbG93RGVsZXRpb24pIHtcbiAgICBmb3IgKHZhciBwcm9wIGluIGIpIHtcbiAgICAgIGlmIChiLmhhc093blByb3BlcnR5KHByb3ApIHx8IHByb3RvRXh0ZW5kID09PSB0cnVlKSB7XG4gICAgICAgIGlmIChiW3Byb3BdICYmIGJbcHJvcF0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICAgIGlmIChhW3Byb3BdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFbcHJvcF0gPSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGFbcHJvcF0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICAgICAgZXhwb3J0cy5kZWVwRXh0ZW5kKGFbcHJvcF0sIGJbcHJvcF0sIHByb3RvRXh0ZW5kKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGJbcHJvcF0gPT09IG51bGwgJiYgYVtwcm9wXSAhPT0gdW5kZWZpbmVkICYmIGFsbG93RGVsZXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIGFbcHJvcF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhW3Byb3BdID0gYltwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShiW3Byb3BdKSkge1xuICAgICAgICAgIGFbcHJvcF0gPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJbcHJvcF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFbcHJvcF0ucHVzaChiW3Byb3BdW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGJbcHJvcF0gPT09IG51bGwgJiYgYVtwcm9wXSAhPT0gdW5kZWZpbmVkICYmIGFsbG93RGVsZXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBhW3Byb3BdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhW3Byb3BdID0gYltwcm9wXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRlc3Qgd2hldGhlciBhbGwgZWxlbWVudHMgaW4gdHdvIGFycmF5cyBhcmUgZXF1YWwuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFcbiAgICogQHBhcmFtIHtBcnJheX0gYlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgYm90aCBhcnJheXMgaGF2ZSB0aGUgc2FtZSBsZW5ndGggYW5kIHNhbWVcbiAgICogICAgICAgICAgICAgICAgICAgZWxlbWVudHMuXG4gICAqL1xuICBleHBvcnRzLmVxdWFsQXJyYXkgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChhW2ldICE9IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydCBhbiBvYmplY3QgdG8gYW5vdGhlciB0eXBlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbiB8IE51bWJlciB8IFN0cmluZyB8IERhdGUgfCBNb21lbnQgfCBOdWxsIHwgdW5kZWZpbmVkfSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmcgfCB1bmRlZmluZWR9IHR5cGUgICBOYW1lIG9mIHRoZSB0eXBlLiBBdmFpbGFibGUgdHlwZXM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0Jvb2xlYW4nLCAnTnVtYmVyJywgJ1N0cmluZycsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0RhdGUnLCAnTW9tZW50JywgSVNPRGF0ZScsICdBU1BEYXRlJy5cbiAgICogQHJldHVybiB7Kn0gb2JqZWN0XG4gICAqIEB0aHJvd3MgRXJyb3JcbiAgICovXG4gIGV4cG9ydHMuY29udmVydCA9IGZ1bmN0aW9uIChvYmplY3QsIHR5cGUpIHtcbiAgICB2YXIgbWF0Y2g7XG5cbiAgICBpZiAob2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChvYmplY3QgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICghdHlwZSkge1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG4gICAgaWYgKCEodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSAmJiAhKHR5cGUgaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1R5cGUgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cblxuICAgIC8vbm9pbnNwZWN0aW9uIEZhbGx0aHJvdWdoSW5Td2l0Y2hTdGF0ZW1lbnRKU1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICBjYXNlICdCb29sZWFuJzpcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4ob2JqZWN0KTtcblxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICAgIHJldHVybiBOdW1iZXIob2JqZWN0LnZhbHVlT2YoKSk7XG5cbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICdTdHJpbmcnOlxuICAgICAgICByZXR1cm4gU3RyaW5nKG9iamVjdCk7XG5cbiAgICAgIGNhc2UgJ0RhdGUnOlxuICAgICAgICBpZiAoZXhwb3J0cy5pc051bWJlcihvYmplY3QpKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IERhdGUob2JqZWN0LnZhbHVlT2YoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAobW9tZW50LmlzTW9tZW50KG9iamVjdCkpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IERhdGUob2JqZWN0LnZhbHVlT2YoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cG9ydHMuaXNTdHJpbmcob2JqZWN0KSkge1xuICAgICAgICAgIG1hdGNoID0gQVNQRGF0ZVJlZ2V4LmV4ZWMob2JqZWN0KTtcbiAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIC8vIG9iamVjdCBpcyBhbiBBU1AgZGF0ZVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKE51bWJlcihtYXRjaFsxXSkpOyAvLyBwYXJzZSBudW1iZXJcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbW9tZW50KG9iamVjdCkudG9EYXRlKCk7IC8vIHBhcnNlIHN0cmluZ1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29udmVydCBvYmplY3Qgb2YgdHlwZSAnICsgZXhwb3J0cy5nZXRUeXBlKG9iamVjdCkgKyAnIHRvIHR5cGUgRGF0ZScpO1xuICAgICAgICAgIH1cblxuICAgICAgY2FzZSAnTW9tZW50JzpcbiAgICAgICAgaWYgKGV4cG9ydHMuaXNOdW1iZXIob2JqZWN0KSkge1xuICAgICAgICAgIHJldHVybiBtb21lbnQob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgIHJldHVybiBtb21lbnQob2JqZWN0LnZhbHVlT2YoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAobW9tZW50LmlzTW9tZW50KG9iamVjdCkpIHtcbiAgICAgICAgICByZXR1cm4gbW9tZW50KG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cG9ydHMuaXNTdHJpbmcob2JqZWN0KSkge1xuICAgICAgICAgIG1hdGNoID0gQVNQRGF0ZVJlZ2V4LmV4ZWMob2JqZWN0KTtcbiAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIC8vIG9iamVjdCBpcyBhbiBBU1AgZGF0ZVxuICAgICAgICAgICAgcmV0dXJuIG1vbWVudChOdW1iZXIobWF0Y2hbMV0pKTsgLy8gcGFyc2UgbnVtYmVyXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG1vbWVudChvYmplY3QpOyAvLyBwYXJzZSBzdHJpbmdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnZlcnQgb2JqZWN0IG9mIHR5cGUgJyArIGV4cG9ydHMuZ2V0VHlwZShvYmplY3QpICsgJyB0byB0eXBlIERhdGUnKTtcbiAgICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ0lTT0RhdGUnOlxuICAgICAgICBpZiAoZXhwb3J0cy5pc051bWJlcihvYmplY3QpKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG9iamVjdCk7XG4gICAgICAgIH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgIHJldHVybiBvYmplY3QudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmIChtb21lbnQuaXNNb21lbnQob2JqZWN0KSkge1xuICAgICAgICAgIHJldHVybiBvYmplY3QudG9EYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmIChleHBvcnRzLmlzU3RyaW5nKG9iamVjdCkpIHtcbiAgICAgICAgICBtYXRjaCA9IEFTUERhdGVSZWdleC5leGVjKG9iamVjdCk7XG4gICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAvLyBvYmplY3QgaXMgYW4gQVNQIGRhdGVcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShOdW1iZXIobWF0Y2hbMV0pKS50b0lTT1N0cmluZygpOyAvLyBwYXJzZSBudW1iZXJcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUob2JqZWN0KS50b0lTT1N0cmluZygpOyAvLyBwYXJzZSBzdHJpbmdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnZlcnQgb2JqZWN0IG9mIHR5cGUgJyArIGV4cG9ydHMuZ2V0VHlwZShvYmplY3QpICsgJyB0byB0eXBlIElTT0RhdGUnKTtcbiAgICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ0FTUERhdGUnOlxuICAgICAgICBpZiAoZXhwb3J0cy5pc051bWJlcihvYmplY3QpKSB7XG4gICAgICAgICAgcmV0dXJuICcvRGF0ZSgnICsgb2JqZWN0ICsgJykvJztcbiAgICAgICAgfSBlbHNlIGlmIChvYmplY3QgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgcmV0dXJuICcvRGF0ZSgnICsgb2JqZWN0LnZhbHVlT2YoKSArICcpLyc7XG4gICAgICAgIH0gZWxzZSBpZiAoZXhwb3J0cy5pc1N0cmluZyhvYmplY3QpKSB7XG4gICAgICAgICAgbWF0Y2ggPSBBU1BEYXRlUmVnZXguZXhlYyhvYmplY3QpO1xuICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIC8vIG9iamVjdCBpcyBhbiBBU1AgZGF0ZVxuICAgICAgICAgICAgdmFsdWUgPSBuZXcgRGF0ZShOdW1iZXIobWF0Y2hbMV0pKS52YWx1ZU9mKCk7IC8vIHBhcnNlIG51bWJlclxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUob2JqZWN0KS52YWx1ZU9mKCk7IC8vIHBhcnNlIHN0cmluZ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAnL0RhdGUoJyArIHZhbHVlICsgJykvJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IG9iamVjdCBvZiB0eXBlICcgKyBleHBvcnRzLmdldFR5cGUob2JqZWN0KSArICcgdG8gdHlwZSBBU1BEYXRlJyk7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGUgXCInICsgdHlwZSArICdcIicpO1xuICAgIH1cbiAgfTtcblxuICAvLyBwYXJzZSBBU1AuTmV0IERhdGUgcGF0dGVybixcbiAgLy8gZm9yIGV4YW1wbGUgJy9EYXRlKDExOTg5MDg3MTcwNTYpLycgb3IgJy9EYXRlKDExOTg5MDg3MTcwNTYtMDcwMCkvJ1xuICAvLyBjb2RlIGZyb20gaHR0cDovL21vbWVudGpzLmNvbS9cbiAgdmFyIEFTUERhdGVSZWdleCA9IC9eXFwvP0RhdGVcXCgoXFwtP1xcZCspL2k7XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdHlwZSBvZiBhbiBvYmplY3QsIGZvciBleGFtcGxlIGV4cG9ydHMuZ2V0VHlwZShbXSkgcmV0dXJucyAnQXJyYXknXG4gICAqIEBwYXJhbSB7Kn0gb2JqZWN0XG4gICAqIEByZXR1cm4ge1N0cmluZ30gdHlwZVxuICAgKi9cbiAgZXhwb3J0cy5nZXRUeXBlID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIG9iamVjdCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yob2JqZWN0KTtcblxuICAgIGlmICh0eXBlID09ICdvYmplY3QnKSB7XG4gICAgICBpZiAob2JqZWN0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgQm9vbGVhbikge1xuICAgICAgICByZXR1cm4gJ0Jvb2xlYW4nO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE51bWJlcikge1xuICAgICAgICByZXR1cm4gJ051bWJlcic7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiAnU3RyaW5nJztcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuICdBcnJheSc7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gJ0RhdGUnO1xuICAgICAgfVxuICAgICAgcmV0dXJuICdPYmplY3QnO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuICdOdW1iZXInO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PSAnYm9vbGVhbicpIHtcbiAgICAgIHJldHVybiAnQm9vbGVhbic7XG4gICAgfSBlbHNlIGlmICh0eXBlID09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gJ1N0cmluZyc7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfTtcblxuICAvKipcbiAgICogVXNlZCB0byBleHRlbmQgYW4gYXJyYXkgYW5kIGNvcHkgaXQuIFRoaXMgaXMgdXNlZCB0byBwcm9wYWdhdGUgcGF0aHMgcmVjdXJzaXZlbHkuXG4gICAqXG4gICAqIEBwYXJhbSBhcnJcbiAgICogQHBhcmFtIG5ld1ZhbHVlXG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICovXG4gIGV4cG9ydHMuY29weUFuZEV4dGVuZEFycmF5ID0gZnVuY3Rpb24gKGFyciwgbmV3VmFsdWUpIHtcbiAgICB2YXIgbmV3QXJyID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5ld0Fyci5wdXNoKGFycltpXSk7XG4gICAgfVxuICAgIG5ld0Fyci5wdXNoKG5ld1ZhbHVlKTtcbiAgICByZXR1cm4gbmV3QXJyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGV4dGVuZCBhbiBhcnJheSBhbmQgY29weSBpdC4gVGhpcyBpcyB1c2VkIHRvIHByb3BhZ2F0ZSBwYXRocyByZWN1cnNpdmVseS5cbiAgICpcbiAgICogQHBhcmFtIGFyclxuICAgKiBAcGFyYW0gbmV3VmFsdWVcbiAgICogQHJldHVybnMge0FycmF5fVxuICAgKi9cbiAgZXhwb3J0cy5jb3B5QXJyYXkgPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgdmFyIG5ld0FyciA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBuZXdBcnIucHVzaChhcnJbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3QXJyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgYWJzb2x1dGUgbGVmdCB2YWx1ZSBvZiBhIERPTSBlbGVtZW50XG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbSAgICAgICAgQSBkb20gZWxlbWVudCwgZm9yIGV4YW1wbGUgYSBkaXZcbiAgICogQHJldHVybiB7bnVtYmVyfSBsZWZ0ICAgICAgICBUaGUgYWJzb2x1dGUgbGVmdCBwb3NpdGlvbiBvZiB0aGlzIGVsZW1lbnRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiB0aGUgYnJvd3NlciBwYWdlLlxuICAgKi9cbiAgZXhwb3J0cy5nZXRBYnNvbHV0ZUxlZnQgPSBmdW5jdGlvbiAoZWxlbSkge1xuICAgIHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG4gIH07XG5cbiAgZXhwb3J0cy5nZXRBYnNvbHV0ZVJpZ2h0ID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICByZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5yaWdodDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlldmUgdGhlIGFic29sdXRlIHRvcCB2YWx1ZSBvZiBhIERPTSBlbGVtZW50XG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbSAgICAgICAgQSBkb20gZWxlbWVudCwgZm9yIGV4YW1wbGUgYSBkaXZcbiAgICogQHJldHVybiB7bnVtYmVyfSB0b3AgICAgICAgIFRoZSBhYnNvbHV0ZSB0b3AgcG9zaXRpb24gb2YgdGhpcyBlbGVtZW50XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gdGhlIGJyb3dzZXIgcGFnZS5cbiAgICovXG4gIGV4cG9ydHMuZ2V0QWJzb2x1dGVUb3AgPSBmdW5jdGlvbiAoZWxlbSkge1xuICAgIHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbiAgfTtcblxuICAvKipcbiAgICogYWRkIGEgY2xhc3NOYW1lIHRvIHRoZSBnaXZlbiBlbGVtZW50cyBzdHlsZVxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1cbiAgICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgZXhwb3J0cy5hZGRDbGFzc05hbWUgPSBmdW5jdGlvbiAoZWxlbSwgY2xhc3NOYW1lKSB7XG4gICAgdmFyIGNsYXNzZXMgPSBlbGVtLmNsYXNzTmFtZS5zcGxpdCgnICcpO1xuICAgIGlmIChjbGFzc2VzLmluZGV4T2YoY2xhc3NOYW1lKSA9PSAtMSkge1xuICAgICAgY2xhc3Nlcy5wdXNoKGNsYXNzTmFtZSk7IC8vIGFkZCB0aGUgY2xhc3MgdG8gdGhlIGFycmF5XG4gICAgICBlbGVtLmNsYXNzTmFtZSA9IGNsYXNzZXMuam9pbignICcpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogYWRkIGEgY2xhc3NOYW1lIHRvIHRoZSBnaXZlbiBlbGVtZW50cyBzdHlsZVxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1cbiAgICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgZXhwb3J0cy5yZW1vdmVDbGFzc05hbWUgPSBmdW5jdGlvbiAoZWxlbSwgY2xhc3NOYW1lKSB7XG4gICAgdmFyIGNsYXNzZXMgPSBlbGVtLmNsYXNzTmFtZS5zcGxpdCgnICcpO1xuICAgIHZhciBpbmRleCA9IGNsYXNzZXMuaW5kZXhPZihjbGFzc05hbWUpO1xuICAgIGlmIChpbmRleCAhPSAtMSkge1xuICAgICAgY2xhc3Nlcy5zcGxpY2UoaW5kZXgsIDEpOyAvLyByZW1vdmUgdGhlIGNsYXNzIGZyb20gdGhlIGFycmF5XG4gICAgICBlbGVtLmNsYXNzTmFtZSA9IGNsYXNzZXMuam9pbignICcpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRm9yIGVhY2ggbWV0aG9kIGZvciBib3RoIGFycmF5cyBhbmQgb2JqZWN0cy5cbiAgICogSW4gY2FzZSBvZiBhbiBhcnJheSwgdGhlIGJ1aWx0LWluIEFycmF5LmZvckVhY2goKSBpcyBhcHBsaWVkLlxuICAgKiBJbiBjYXNlIG9mIGFuIE9iamVjdCwgdGhlIG1ldGhvZCBsb29wcyBvdmVyIGFsbCBwcm9wZXJ0aWVzIG9mIHRoZSBvYmplY3QuXG4gICAqIEBwYXJhbSB7T2JqZWN0IHwgQXJyYXl9IG9iamVjdCAgIEFuIE9iamVjdCBvciBBcnJheVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAgICAgICBDYWxsYmFjayBtZXRob2QsIGNhbGxlZCBmb3IgZWFjaCBpdGVtIGluXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBvYmplY3Qgb3IgYXJyYXkgd2l0aCB0aHJlZSBwYXJhbWV0ZXJzOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIG9iamVjdClcbiAgICovXG4gIGV4cG9ydHMuZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGksIGxlbjtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAvLyBhcnJheVxuICAgICAgZm9yIChpID0gMCwgbGVuID0gb2JqZWN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNhbGxiYWNrKG9iamVjdFtpXSwgaSwgb2JqZWN0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb2JqZWN0XG4gICAgICBmb3IgKGkgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICBjYWxsYmFjayhvYmplY3RbaV0sIGksIG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYW4gb2JqZWN0IGludG8gYW4gYXJyYXk6IGFsbCBvYmplY3RzIHByb3BlcnRpZXMgYXJlIHB1dCBpbnRvIHRoZVxuICAgKiBhcnJheS4gVGhlIHJlc3VsdGluZyBhcnJheSBpcyB1bm9yZGVyZWQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAgICovXG4gIGV4cG9ydHMudG9BcnJheSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICB2YXIgYXJyYXkgPSBbXTtcblxuICAgIGZvciAodmFyIHByb3AgaW4gb2JqZWN0KSB7XG4gICAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KHByb3ApKSBhcnJheS5wdXNoKG9iamVjdFtwcm9wXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5O1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgYSBwcm9wZXJ0eSBpbiBhbiBvYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gY2hhbmdlZFxuICAgKi9cbiAgZXhwb3J0cy51cGRhdGVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICBpZiAob2JqZWN0W2tleV0gIT09IHZhbHVlKSB7XG4gICAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFRocm90dGxlIHRoZSBnaXZlbiBmdW5jdGlvbiB0byBiZSBvbmx5IGV4ZWN1dGVkIG9uY2UgZXZlcnkgYHdhaXRgIG1pbGxpc2Vjb25kc1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmblxuICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCAgICBUaW1lIGluIG1pbGxpc2Vjb25kc1xuICAgKiBAcmV0dXJucyB7ZnVuY3Rpb259IFJldHVybnMgdGhlIHRocm90dGxlZCBmdW5jdGlvblxuICAgKi9cbiAgZXhwb3J0cy50aHJvdHRsZSA9IGZ1bmN0aW9uIChmbiwgd2FpdCkge1xuICAgIHZhciB0aW1lb3V0ID0gbnVsbDtcbiAgICB2YXIgbmVlZEV4ZWN1dGlvbiA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHRocm90dGxlZCgpIHtcbiAgICAgIGlmICghdGltZW91dCkge1xuICAgICAgICBuZWVkRXhlY3V0aW9uID0gZmFsc2U7XG4gICAgICAgIGZuKCk7XG5cbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgIGlmIChuZWVkRXhlY3V0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdHRsZWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHdhaXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmVlZEV4ZWN1dGlvbiA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGFuZCBldmVudCBsaXN0ZW5lci4gV29ya3MgZm9yIGFsbCBicm93c2Vyc1xuICAgKiBAcGFyYW0ge0VsZW1lbnR9ICAgICBlbGVtZW50ICAgIEFuIGh0bWwgZWxlbWVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICBhY3Rpb24gICAgIFRoZSBhY3Rpb24sIGZvciBleGFtcGxlIFwiY2xpY2tcIixcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRob3V0IHRoZSBwcmVmaXggXCJvblwiXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259ICAgIGxpc3RlbmVyICAgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgIFt1c2VDYXB0dXJlXVxuICAgKi9cbiAgZXhwb3J0cy5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIGFjdGlvbiwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpIHtcbiAgICBpZiAoZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICBpZiAodXNlQ2FwdHVyZSA9PT0gdW5kZWZpbmVkKSB1c2VDYXB0dXJlID0gZmFsc2U7XG5cbiAgICAgIGlmIChhY3Rpb24gPT09IFwibW91c2V3aGVlbFwiICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIkZpcmVmb3hcIikgPj0gMCkge1xuICAgICAgICBhY3Rpb24gPSBcIkRPTU1vdXNlU2Nyb2xsXCI7IC8vIEZvciBGaXJlZm94XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihhY3Rpb24sIGxpc3RlbmVyLCB1c2VDYXB0dXJlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5hdHRhY2hFdmVudChcIm9uXCIgKyBhY3Rpb24sIGxpc3RlbmVyKTsgLy8gSUUgYnJvd3NlcnNcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBldmVudCBsaXN0ZW5lciBmcm9tIGFuIGVsZW1lbnRcbiAgICogQHBhcmFtIHtFbGVtZW50fSAgICAgZWxlbWVudCAgICAgICAgIEFuIGh0bWwgZG9tIGVsZW1lbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgYWN0aW9uICAgICAgICAgIFRoZSBuYW1lIG9mIHRoZSBldmVudCwgZm9yIGV4YW1wbGUgXCJtb3VzZWRvd25cIlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSAgICBsaXN0ZW5lciAgICAgICAgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgIFt1c2VDYXB0dXJlXVxuICAgKi9cbiAgZXhwb3J0cy5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIGFjdGlvbiwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpIHtcbiAgICBpZiAoZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICAvLyBub24tSUUgYnJvd3NlcnNcbiAgICAgIGlmICh1c2VDYXB0dXJlID09PSB1bmRlZmluZWQpIHVzZUNhcHR1cmUgPSBmYWxzZTtcblxuICAgICAgaWYgKGFjdGlvbiA9PT0gXCJtb3VzZXdoZWVsXCIgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiRmlyZWZveFwiKSA+PSAwKSB7XG4gICAgICAgIGFjdGlvbiA9IFwiRE9NTW91c2VTY3JvbGxcIjsgLy8gRm9yIEZpcmVmb3hcbiAgICAgIH1cblxuICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGFjdGlvbiwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJRSBicm93c2Vyc1xuICAgICAgZWxlbWVudC5kZXRhY2hFdmVudChcIm9uXCIgKyBhY3Rpb24sIGxpc3RlbmVyKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbmNlbHMgdGhlIGV2ZW50IGlmIGl0IGlzIGNhbmNlbGFibGUsIHdpdGhvdXQgc3RvcHBpbmcgZnVydGhlciBwcm9wYWdhdGlvbiBvZiB0aGUgZXZlbnQuXG4gICAqL1xuICBleHBvcnRzLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKCFldmVudCkgZXZlbnQgPSB3aW5kb3cuZXZlbnQ7XG5cbiAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIG5vbi1JRSBicm93c2Vyc1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7IC8vIElFIGJyb3dzZXJzXG4gICAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBIVE1MIGVsZW1lbnQgd2hpY2ggaXMgdGhlIHRhcmdldCBvZiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHJldHVybiB7RWxlbWVudH0gdGFyZ2V0IGVsZW1lbnRcbiAgICovXG4gIGV4cG9ydHMuZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gY29kZSBmcm9tIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvZXZlbnRzX3Byb3BlcnRpZXMuaHRtbFxuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIGV2ZW50ID0gd2luZG93LmV2ZW50O1xuICAgIH1cblxuICAgIHZhciB0YXJnZXQ7XG5cbiAgICBpZiAoZXZlbnQudGFyZ2V0KSB7XG4gICAgICB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgfSBlbHNlIGlmIChldmVudC5zcmNFbGVtZW50KSB7XG4gICAgICB0YXJnZXQgPSBldmVudC5zcmNFbGVtZW50O1xuICAgIH1cblxuICAgIGlmICh0YXJnZXQubm9kZVR5cGUgIT0gdW5kZWZpbmVkICYmIHRhcmdldC5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAvLyBkZWZlYXQgU2FmYXJpIGJ1Z1xuICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgZ2l2ZW4gZWxlbWVudCBjb250YWlucyBnaXZlbiBwYXJlbnQgc29tZXdoZXJlIGluIHRoZSBET00gdHJlZVxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtFbGVtZW50fSBwYXJlbnRcbiAgICovXG4gIGV4cG9ydHMuaGFzUGFyZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIHBhcmVudCkge1xuICAgIHZhciBlID0gZWxlbWVudDtcblxuICAgIHdoaWxlIChlKSB7XG4gICAgICBpZiAoZSA9PT0gcGFyZW50KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgZSA9IGUucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgZXhwb3J0cy5vcHRpb24gPSB7fTtcblxuICAvKipcbiAgICogQ29udmVydCBhIHZhbHVlIGludG8gYSBib29sZWFuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbiB8IGZ1bmN0aW9uIHwgdW5kZWZpbmVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtkZWZhdWx0VmFsdWVdXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBib29sXG4gICAqL1xuICBleHBvcnRzLm9wdGlvbi5hc0Jvb2xlYW4gPSBmdW5jdGlvbiAodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFsdWUgPSB2YWx1ZSgpO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gdmFsdWUgIT0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZSB8fCBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgdmFsdWUgaW50byBhIG51bWJlclxuICAgKiBAcGFyYW0ge0Jvb2xlYW4gfCBmdW5jdGlvbiB8IHVuZGVmaW5lZH0gdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWZhdWx0VmFsdWVdXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IG51bWJlclxuICAgKi9cbiAgZXhwb3J0cy5vcHRpb24uYXNOdW1iZXIgPSBmdW5jdGlvbiAodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFsdWUgPSB2YWx1ZSgpO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKSB8fCBkZWZhdWx0VmFsdWUgfHwgbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVmYXVsdFZhbHVlIHx8IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSB2YWx1ZSBpbnRvIGEgc3RyaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nIHwgZnVuY3Rpb24gfCB1bmRlZmluZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbZGVmYXVsdFZhbHVlXVxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJcbiAgICovXG4gIGV4cG9ydHMub3B0aW9uLmFzU3RyaW5nID0gZnVuY3Rpb24gKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUoKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZSB8fCBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgc2l6ZSBvciBsb2NhdGlvbiBpbnRvIGEgc3RyaW5nIHdpdGggcGl4ZWxzIG9yIGEgcGVyY2VudGFnZVxuICAgKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlciB8IGZ1bmN0aW9uIHwgdW5kZWZpbmVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2RlZmF1bHRWYWx1ZV1cbiAgICogQHJldHVybnMge1N0cmluZ30gc2l6ZVxuICAgKi9cbiAgZXhwb3J0cy5vcHRpb24uYXNTaXplID0gZnVuY3Rpb24gKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUoKTtcbiAgICB9XG5cbiAgICBpZiAoZXhwb3J0cy5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKGV4cG9ydHMuaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWUgKyAncHgnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlIHx8IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgdmFsdWUgaW50byBhIERPTSBlbGVtZW50XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBmdW5jdGlvbiB8IHVuZGVmaW5lZH0gdmFsdWVcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW2RlZmF1bHRWYWx1ZV1cbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50IHwgbnVsbH0gZG9tXG4gICAqL1xuICBleHBvcnRzLm9wdGlvbi5hc0VsZW1lbnQgPSBmdW5jdGlvbiAodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFsdWUgPSB2YWx1ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZSB8fCBkZWZhdWx0VmFsdWUgfHwgbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81NjIzODM4L3JnYi10by1oZXgtYW5kLWhleC10by1yZ2JcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGhleFxuICAgKiBAcmV0dXJucyB7e3I6ICosIGc6ICosIGI6ICp9fSB8IDI1NSByYW5nZVxuICAgKi9cbiAgZXhwb3J0cy5oZXhUb1JHQiA9IGZ1bmN0aW9uIChoZXgpIHtcbiAgICAvLyBFeHBhbmQgc2hvcnRoYW5kIGZvcm0gKGUuZy4gXCIwM0ZcIikgdG8gZnVsbCBmb3JtIChlLmcuIFwiMDAzM0ZGXCIpXG4gICAgdmFyIHNob3J0aGFuZFJlZ2V4ID0gL14jPyhbYS1mXFxkXSkoW2EtZlxcZF0pKFthLWZcXGRdKSQvaTtcbiAgICBoZXggPSBoZXgucmVwbGFjZShzaG9ydGhhbmRSZWdleCwgZnVuY3Rpb24gKG0sIHIsIGcsIGIpIHtcbiAgICAgIHJldHVybiByICsgciArIGcgKyBnICsgYiArIGI7XG4gICAgfSk7XG4gICAgdmFyIHJlc3VsdCA9IC9eIz8oW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkkL2kuZXhlYyhoZXgpO1xuICAgIHJldHVybiByZXN1bHQgPyB7XG4gICAgICByOiBwYXJzZUludChyZXN1bHRbMV0sIDE2KSxcbiAgICAgIGc6IHBhcnNlSW50KHJlc3VsdFsyXSwgMTYpLFxuICAgICAgYjogcGFyc2VJbnQocmVzdWx0WzNdLCAxNilcbiAgICB9IDogbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiB0YWtlcyBjb2xvciBpbiBoZXggZm9ybWF0IG9yIHJnYigpIG9yIHJnYmEoKSBmb3JtYXQgYW5kIG92ZXJyaWRlcyB0aGUgb3BhY2l0eS4gUmV0dXJucyByZ2JhKCkgc3RyaW5nLlxuICAgKiBAcGFyYW0gY29sb3JcbiAgICogQHBhcmFtIG9wYWNpdHlcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBleHBvcnRzLm92ZXJyaWRlT3BhY2l0eSA9IGZ1bmN0aW9uIChjb2xvciwgb3BhY2l0eSkge1xuICAgIGlmIChjb2xvci5pbmRleE9mKFwicmdiYVwiKSAhPSAtMSkge1xuICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH0gZWxzZSBpZiAoY29sb3IuaW5kZXhPZihcInJnYlwiKSAhPSAtMSkge1xuICAgICAgdmFyIHJnYiA9IGNvbG9yLnN1YnN0cihjb2xvci5pbmRleE9mKFwiKFwiKSArIDEpLnJlcGxhY2UoXCIpXCIsIFwiXCIpLnNwbGl0KFwiLFwiKTtcbiAgICAgIHJldHVybiBcInJnYmEoXCIgKyByZ2JbMF0gKyBcIixcIiArIHJnYlsxXSArIFwiLFwiICsgcmdiWzJdICsgXCIsXCIgKyBvcGFjaXR5ICsgXCIpXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZ2IgPSBleHBvcnRzLmhleFRvUkdCKGNvbG9yKTtcbiAgICAgIGlmIChyZ2IgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gY29sb3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gXCJyZ2JhKFwiICsgcmdiLnIgKyBcIixcIiArIHJnYi5nICsgXCIsXCIgKyByZ2IuYiArIFwiLFwiICsgb3BhY2l0eSArIFwiKVwiO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHJlZCAgICAgMCAtLSAyNTVcbiAgICogQHBhcmFtIGdyZWVuICAgMCAtLSAyNTVcbiAgICogQHBhcmFtIGJsdWUgICAgMCAtLSAyNTVcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBleHBvcnRzLlJHQlRvSGV4ID0gZnVuY3Rpb24gKHJlZCwgZ3JlZW4sIGJsdWUpIHtcbiAgICByZXR1cm4gXCIjXCIgKyAoKDEgPDwgMjQpICsgKHJlZCA8PCAxNikgKyAoZ3JlZW4gPDwgOCkgKyBibHVlKS50b1N0cmluZygxNikuc2xpY2UoMSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlIGEgY29sb3IgcHJvcGVydHkgaW50byBhbiBvYmplY3Qgd2l0aCBib3JkZXIsIGJhY2tncm91bmQsIGFuZFxuICAgKiBoaWdobGlnaHQgY29sb3JzXG4gICAqIEBwYXJhbSB7T2JqZWN0IHwgU3RyaW5nfSBjb2xvclxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGNvbG9yT2JqZWN0XG4gICAqL1xuICBleHBvcnRzLnBhcnNlQ29sb3IgPSBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICB2YXIgYztcbiAgICBpZiAoZXhwb3J0cy5pc1N0cmluZyhjb2xvcikgPT09IHRydWUpIHtcbiAgICAgIGlmIChleHBvcnRzLmlzVmFsaWRSR0IoY29sb3IpID09PSB0cnVlKSB7XG4gICAgICAgIHZhciByZ2IgPSBjb2xvci5zdWJzdHIoNCkuc3Vic3RyKDAsIGNvbG9yLmxlbmd0aCAtIDUpLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb2xvciA9IGV4cG9ydHMuUkdCVG9IZXgocmdiWzBdLCByZ2JbMV0sIHJnYlsyXSk7XG4gICAgICB9XG4gICAgICBpZiAoZXhwb3J0cy5pc1ZhbGlkSGV4KGNvbG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgaHN2ID0gZXhwb3J0cy5oZXhUb0hTVihjb2xvcik7XG4gICAgICAgIHZhciBsaWdodGVyQ29sb3JIU1YgPSB7IGg6IGhzdi5oLCBzOiBoc3YucyAqIDAuOCwgdjogTWF0aC5taW4oMSwgaHN2LnYgKiAxLjAyKSB9O1xuICAgICAgICB2YXIgZGFya2VyQ29sb3JIU1YgPSB7IGg6IGhzdi5oLCBzOiBNYXRoLm1pbigxLCBoc3YucyAqIDEuMjUpLCB2OiBoc3YudiAqIDAuOCB9O1xuICAgICAgICB2YXIgZGFya2VyQ29sb3JIZXggPSBleHBvcnRzLkhTVlRvSGV4KGRhcmtlckNvbG9ySFNWLmgsIGRhcmtlckNvbG9ySFNWLnMsIGRhcmtlckNvbG9ySFNWLnYpO1xuICAgICAgICB2YXIgbGlnaHRlckNvbG9ySGV4ID0gZXhwb3J0cy5IU1ZUb0hleChsaWdodGVyQ29sb3JIU1YuaCwgbGlnaHRlckNvbG9ySFNWLnMsIGxpZ2h0ZXJDb2xvckhTVi52KTtcbiAgICAgICAgYyA9IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBjb2xvcixcbiAgICAgICAgICBib3JkZXI6IGRhcmtlckNvbG9ySGV4LFxuICAgICAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICAgICAgYmFja2dyb3VuZDogbGlnaHRlckNvbG9ySGV4LFxuICAgICAgICAgICAgYm9yZGVyOiBkYXJrZXJDb2xvckhleFxuICAgICAgICAgIH0sXG4gICAgICAgICAgaG92ZXI6IHtcbiAgICAgICAgICAgIGJhY2tncm91bmQ6IGxpZ2h0ZXJDb2xvckhleCxcbiAgICAgICAgICAgIGJvcmRlcjogZGFya2VyQ29sb3JIZXhcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjID0ge1xuICAgICAgICAgIGJhY2tncm91bmQ6IGNvbG9yLFxuICAgICAgICAgIGJvcmRlcjogY29sb3IsXG4gICAgICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiBjb2xvcixcbiAgICAgICAgICAgIGJvcmRlcjogY29sb3JcbiAgICAgICAgICB9LFxuICAgICAgICAgIGhvdmVyOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiBjb2xvcixcbiAgICAgICAgICAgIGJvcmRlcjogY29sb3JcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGMgPSB7fTtcbiAgICAgIGMuYmFja2dyb3VuZCA9IGNvbG9yLmJhY2tncm91bmQgfHwgdW5kZWZpbmVkO1xuICAgICAgYy5ib3JkZXIgPSBjb2xvci5ib3JkZXIgfHwgdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoZXhwb3J0cy5pc1N0cmluZyhjb2xvci5oaWdobGlnaHQpKSB7XG4gICAgICAgIGMuaGlnaGxpZ2h0ID0ge1xuICAgICAgICAgIGJvcmRlcjogY29sb3IuaGlnaGxpZ2h0LFxuICAgICAgICAgIGJhY2tncm91bmQ6IGNvbG9yLmhpZ2hsaWdodFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYy5oaWdobGlnaHQgPSB7fTtcbiAgICAgICAgYy5oaWdobGlnaHQuYmFja2dyb3VuZCA9IGNvbG9yLmhpZ2hsaWdodCAmJiBjb2xvci5oaWdobGlnaHQuYmFja2dyb3VuZCB8fCB1bmRlZmluZWQ7XG4gICAgICAgIGMuaGlnaGxpZ2h0LmJvcmRlciA9IGNvbG9yLmhpZ2hsaWdodCAmJiBjb2xvci5oaWdobGlnaHQuYm9yZGVyIHx8IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgaWYgKGV4cG9ydHMuaXNTdHJpbmcoY29sb3IuaG92ZXIpKSB7XG4gICAgICAgIGMuaG92ZXIgPSB7XG4gICAgICAgICAgYm9yZGVyOiBjb2xvci5ob3ZlcixcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBjb2xvci5ob3ZlclxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYy5ob3ZlciA9IHt9O1xuICAgICAgICBjLmhvdmVyLmJhY2tncm91bmQgPSBjb2xvci5ob3ZlciAmJiBjb2xvci5ob3Zlci5iYWNrZ3JvdW5kIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgYy5ob3Zlci5ib3JkZXIgPSBjb2xvci5ob3ZlciAmJiBjb2xvci5ob3Zlci5ib3JkZXIgfHwgdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjO1xuICB9O1xuXG4gIC8qKlxuICAgKiBodHRwOi8vd3d3LmphdmFzY3JpcHRlci5uZXQvZmFxL3JnYjJoc3YuaHRtXG4gICAqXG4gICAqIEBwYXJhbSByZWRcbiAgICogQHBhcmFtIGdyZWVuXG4gICAqIEBwYXJhbSBibHVlXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGV4cG9ydHMuUkdCVG9IU1YgPSBmdW5jdGlvbiAocmVkLCBncmVlbiwgYmx1ZSkge1xuICAgIHJlZCA9IHJlZCAvIDI1NTtncmVlbiA9IGdyZWVuIC8gMjU1O2JsdWUgPSBibHVlIC8gMjU1O1xuICAgIHZhciBtaW5SR0IgPSBNYXRoLm1pbihyZWQsIE1hdGgubWluKGdyZWVuLCBibHVlKSk7XG4gICAgdmFyIG1heFJHQiA9IE1hdGgubWF4KHJlZCwgTWF0aC5tYXgoZ3JlZW4sIGJsdWUpKTtcblxuICAgIC8vIEJsYWNrLWdyYXktd2hpdGVcbiAgICBpZiAobWluUkdCID09IG1heFJHQikge1xuICAgICAgcmV0dXJuIHsgaDogMCwgczogMCwgdjogbWluUkdCIH07XG4gICAgfVxuXG4gICAgLy8gQ29sb3JzIG90aGVyIHRoYW4gYmxhY2stZ3JheS13aGl0ZTpcbiAgICB2YXIgZCA9IHJlZCA9PSBtaW5SR0IgPyBncmVlbiAtIGJsdWUgOiBibHVlID09IG1pblJHQiA/IHJlZCAtIGdyZWVuIDogYmx1ZSAtIHJlZDtcbiAgICB2YXIgaCA9IHJlZCA9PSBtaW5SR0IgPyAzIDogYmx1ZSA9PSBtaW5SR0IgPyAxIDogNTtcbiAgICB2YXIgaHVlID0gNjAgKiAoaCAtIGQgLyAobWF4UkdCIC0gbWluUkdCKSkgLyAzNjA7XG4gICAgdmFyIHNhdHVyYXRpb24gPSAobWF4UkdCIC0gbWluUkdCKSAvIG1heFJHQjtcbiAgICB2YXIgdmFsdWUgPSBtYXhSR0I7XG4gICAgcmV0dXJuIHsgaDogaHVlLCBzOiBzYXR1cmF0aW9uLCB2OiB2YWx1ZSB9O1xuICB9O1xuXG4gIHZhciBjc3NVdGlsID0ge1xuICAgIC8vIHNwbGl0IGEgc3RyaW5nIHdpdGggY3NzIHN0eWxlcyBpbnRvIGFuIG9iamVjdCB3aXRoIGtleS92YWx1ZXNcbiAgICBzcGxpdDogZnVuY3Rpb24gc3BsaXQoY3NzVGV4dCkge1xuICAgICAgdmFyIHN0eWxlcyA9IHt9O1xuXG4gICAgICBjc3NUZXh0LnNwbGl0KCc7JykuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICAgICAgaWYgKHN0eWxlLnRyaW0oKSAhPSAnJykge1xuICAgICAgICAgIHZhciBwYXJ0cyA9IHN0eWxlLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgdmFyIGtleSA9IHBhcnRzWzBdLnRyaW0oKTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJ0c1sxXS50cmltKCk7XG4gICAgICAgICAgc3R5bGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgfSxcblxuICAgIC8vIGJ1aWxkIGEgY3NzIHRleHQgc3RyaW5nIGZyb20gYW4gb2JqZWN0IHdpdGgga2V5L3ZhbHVlc1xuICAgIGpvaW46IGZ1bmN0aW9uIGpvaW4oc3R5bGVzKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMoc3R5bGVzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4ga2V5ICsgJzogJyArIHN0eWxlc1trZXldO1xuICAgICAgfSkuam9pbignOyAnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFwcGVuZCBhIHN0cmluZyB3aXRoIGNzcyBzdHlsZXMgdG8gYW4gZWxlbWVudFxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNzc1RleHRcbiAgICovXG4gIGV4cG9ydHMuYWRkQ3NzVGV4dCA9IGZ1bmN0aW9uIChlbGVtZW50LCBjc3NUZXh0KSB7XG4gICAgdmFyIGN1cnJlbnRTdHlsZXMgPSBjc3NVdGlsLnNwbGl0KGVsZW1lbnQuc3R5bGUuY3NzVGV4dCk7XG4gICAgdmFyIG5ld1N0eWxlcyA9IGNzc1V0aWwuc3BsaXQoY3NzVGV4dCk7XG4gICAgdmFyIHN0eWxlcyA9IGV4cG9ydHMuZXh0ZW5kKGN1cnJlbnRTdHlsZXMsIG5ld1N0eWxlcyk7XG5cbiAgICBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBjc3NVdGlsLmpvaW4oc3R5bGVzKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGEgc3RyaW5nIHdpdGggY3NzIHN0eWxlcyBmcm9tIGFuIGVsZW1lbnRcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjc3NUZXh0XG4gICAqL1xuICBleHBvcnRzLnJlbW92ZUNzc1RleHQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY3NzVGV4dCkge1xuICAgIHZhciBzdHlsZXMgPSBjc3NVdGlsLnNwbGl0KGVsZW1lbnQuc3R5bGUuY3NzVGV4dCk7XG4gICAgdmFyIHJlbW92ZVN0eWxlcyA9IGNzc1V0aWwuc3BsaXQoY3NzVGV4dCk7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gcmVtb3ZlU3R5bGVzKSB7XG4gICAgICBpZiAocmVtb3ZlU3R5bGVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgZGVsZXRlIHN0eWxlc1trZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IGNzc1V0aWwuam9pbihzdHlsZXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9tamlqYWNrc29uLzUzMTEyNTZcbiAgICogQHBhcmFtIGhcbiAgICogQHBhcmFtIHNcbiAgICogQHBhcmFtIHZcbiAgICogQHJldHVybnMge3tyOiBudW1iZXIsIGc6IG51bWJlciwgYjogbnVtYmVyfX1cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBleHBvcnRzLkhTVlRvUkdCID0gZnVuY3Rpb24gKGgsIHMsIHYpIHtcbiAgICB2YXIgciwgZywgYjtcblxuICAgIHZhciBpID0gTWF0aC5mbG9vcihoICogNik7XG4gICAgdmFyIGYgPSBoICogNiAtIGk7XG4gICAgdmFyIHAgPSB2ICogKDEgLSBzKTtcbiAgICB2YXIgcSA9IHYgKiAoMSAtIGYgKiBzKTtcbiAgICB2YXIgdCA9IHYgKiAoMSAtICgxIC0gZikgKiBzKTtcblxuICAgIHN3aXRjaCAoaSAlIDYpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgciA9IHYsIGcgPSB0LCBiID0gcDticmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgciA9IHEsIGcgPSB2LCBiID0gcDticmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgciA9IHAsIGcgPSB2LCBiID0gdDticmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgciA9IHAsIGcgPSBxLCBiID0gdjticmVhaztcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgciA9IHQsIGcgPSBwLCBiID0gdjticmVhaztcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgciA9IHYsIGcgPSBwLCBiID0gcTticmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4geyByOiBNYXRoLmZsb29yKHIgKiAyNTUpLCBnOiBNYXRoLmZsb29yKGcgKiAyNTUpLCBiOiBNYXRoLmZsb29yKGIgKiAyNTUpIH07XG4gIH07XG5cbiAgZXhwb3J0cy5IU1ZUb0hleCA9IGZ1bmN0aW9uIChoLCBzLCB2KSB7XG4gICAgdmFyIHJnYiA9IGV4cG9ydHMuSFNWVG9SR0IoaCwgcywgdik7XG4gICAgcmV0dXJuIGV4cG9ydHMuUkdCVG9IZXgocmdiLnIsIHJnYi5nLCByZ2IuYik7XG4gIH07XG5cbiAgZXhwb3J0cy5oZXhUb0hTViA9IGZ1bmN0aW9uIChoZXgpIHtcbiAgICB2YXIgcmdiID0gZXhwb3J0cy5oZXhUb1JHQihoZXgpO1xuICAgIHJldHVybiBleHBvcnRzLlJHQlRvSFNWKHJnYi5yLCByZ2IuZywgcmdiLmIpO1xuICB9O1xuXG4gIGV4cG9ydHMuaXNWYWxpZEhleCA9IGZ1bmN0aW9uIChoZXgpIHtcbiAgICB2YXIgaXNPayA9IC8oXiNbMC05QS1GXXs2fSQpfCheI1swLTlBLUZdezN9JCkvaS50ZXN0KGhleCk7XG4gICAgcmV0dXJuIGlzT2s7XG4gIH07XG5cbiAgZXhwb3J0cy5pc1ZhbGlkUkdCID0gZnVuY3Rpb24gKHJnYikge1xuICAgIHJnYiA9IHJnYi5yZXBsYWNlKFwiIFwiLCBcIlwiKTtcbiAgICB2YXIgaXNPayA9IC9yZ2JcXCgoXFxkezEsM30pLChcXGR7MSwzfSksKFxcZHsxLDN9KVxcKS9pLnRlc3QocmdiKTtcbiAgICByZXR1cm4gaXNPaztcbiAgfTtcbiAgZXhwb3J0cy5pc1ZhbGlkUkdCQSA9IGZ1bmN0aW9uIChyZ2JhKSB7XG4gICAgcmdiYSA9IHJnYmEucmVwbGFjZShcIiBcIiwgXCJcIik7XG4gICAgdmFyIGlzT2sgPSAvcmdiYVxcKChcXGR7MSwzfSksKFxcZHsxLDN9KSwoXFxkezEsM30pLCguezEsM30pXFwpL2kudGVzdChyZ2JhKTtcbiAgICByZXR1cm4gaXNPaztcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyByZWN1cnNpdmVseSByZWRpcmVjdHMgdGhlIHByb3RvdHlwZSBvZiBKU09OIG9iamVjdHMgdG8gdGhlIHJlZmVyZW5jZU9iamVjdFxuICAgKiBUaGlzIGlzIHVzZWQgZm9yIGRlZmF1bHQgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHJlZmVyZW5jZU9iamVjdFxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGV4cG9ydHMuc2VsZWN0aXZlQnJpZGdlT2JqZWN0ID0gZnVuY3Rpb24gKGZpZWxkcywgcmVmZXJlbmNlT2JqZWN0KSB7XG4gICAgaWYgKCh0eXBlb2YgcmVmZXJlbmNlT2JqZWN0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihyZWZlcmVuY2VPYmplY3QpKSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICB2YXIgb2JqZWN0VG8gPSBPYmplY3QuY3JlYXRlKHJlZmVyZW5jZU9iamVjdCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocmVmZXJlbmNlT2JqZWN0Lmhhc093blByb3BlcnR5KGZpZWxkc1tpXSkpIHtcbiAgICAgICAgICBpZiAoX3R5cGVvZihyZWZlcmVuY2VPYmplY3RbZmllbGRzW2ldXSkgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgb2JqZWN0VG9bZmllbGRzW2ldXSA9IGV4cG9ydHMuYnJpZGdlT2JqZWN0KHJlZmVyZW5jZU9iamVjdFtmaWVsZHNbaV1dKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3RUbztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIHJlY3Vyc2l2ZWx5IHJlZGlyZWN0cyB0aGUgcHJvdG90eXBlIG9mIEpTT04gb2JqZWN0cyB0byB0aGUgcmVmZXJlbmNlT2JqZWN0XG4gICAqIFRoaXMgaXMgdXNlZCBmb3IgZGVmYXVsdCBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gcmVmZXJlbmNlT2JqZWN0XG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgZXhwb3J0cy5icmlkZ2VPYmplY3QgPSBmdW5jdGlvbiAocmVmZXJlbmNlT2JqZWN0KSB7XG4gICAgaWYgKCh0eXBlb2YgcmVmZXJlbmNlT2JqZWN0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihyZWZlcmVuY2VPYmplY3QpKSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICB2YXIgb2JqZWN0VG8gPSBPYmplY3QuY3JlYXRlKHJlZmVyZW5jZU9iamVjdCk7XG4gICAgICBmb3IgKHZhciBpIGluIHJlZmVyZW5jZU9iamVjdCkge1xuICAgICAgICBpZiAocmVmZXJlbmNlT2JqZWN0Lmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgaWYgKF90eXBlb2YocmVmZXJlbmNlT2JqZWN0W2ldKSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBvYmplY3RUb1tpXSA9IGV4cG9ydHMuYnJpZGdlT2JqZWN0KHJlZmVyZW5jZU9iamVjdFtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0VG87XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgcHJvdmlkZXMgYSBzdGFibGUgc29ydCBpbXBsZW1lbnRhdGlvbiwgdmVyeSBmYXN0IGZvciBwcmVzb3J0ZWQgZGF0YVxuICAgKlxuICAgKiBAcGFyYW0gYSB0aGUgYXJyYXlcbiAgICogQHBhcmFtIGEgb3JkZXIgY29tcGFyYXRvclxuICAgKiBAcmV0dXJucyB7dGhlIGFycmF5fVxuICAgKi9cbiAgZXhwb3J0cy5pbnNlcnRTb3J0ID0gZnVuY3Rpb24gKGEsIGNvbXBhcmUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrID0gYVtpXTtcbiAgICAgIGZvciAodmFyIGogPSBpOyBqID4gMCAmJiBjb21wYXJlKGssIGFbaiAtIDFdKSA8IDA7IGotLSkge1xuICAgICAgICBhW2pdID0gYVtqIC0gMV07XG4gICAgICB9XG4gICAgICBhW2pdID0gaztcbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH07XG5cbiAgLyoqXG4gICAqIHRoaXMgaXMgdXNlZCB0byBzZXQgdGhlIG9wdGlvbnMgb2Ygc3Vib2JqZWN0cyBpbiB0aGUgb3B0aW9ucyBvYmplY3QuIEEgcmVxdWlyZW1lbnQgb2YgdGhlc2Ugc3Vib2JqZWN0c1xuICAgKiBpcyB0aGF0IHRoZXkgaGF2ZSBhbiAnZW5hYmxlZCcgZWxlbWVudCB3aGljaCBpcyBvcHRpb25hbCBmb3IgdGhlIHVzZXIgYnV0IG1hbmRhdG9yeSBmb3IgdGhlIHByb2dyYW0uXG4gICAqXG4gICAqIEBwYXJhbSBbb2JqZWN0XSBtZXJnZVRhcmdldCB8IHRoaXMgaXMgZWl0aGVyIHRoaXMub3B0aW9ucyBvciB0aGUgb3B0aW9ucyB1c2VkIGZvciB0aGUgZ3JvdXBzLlxuICAgKiBAcGFyYW0gW29iamVjdF0gb3B0aW9ucyAgICAgfCBvcHRpb25zXG4gICAqIEBwYXJhbSBbU3RyaW5nXSBvcHRpb24gICAgICB8IHRoaXMgaXMgdGhlIG9wdGlvbiBrZXkgaW4gdGhlIG9wdGlvbnMgYXJndW1lbnRcbiAgICovXG4gIGV4cG9ydHMubWVyZ2VPcHRpb25zID0gZnVuY3Rpb24gKG1lcmdlVGFyZ2V0LCBvcHRpb25zLCBvcHRpb24pIHtcbiAgICB2YXIgYWxsb3dEZWxldGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMyB8fCBhcmd1bWVudHNbM10gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogYXJndW1lbnRzWzNdO1xuICAgIHZhciBnbG9iYWxPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSA0IHx8IGFyZ3VtZW50c1s0XSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbNF07XG5cbiAgICBpZiAob3B0aW9uc1tvcHRpb25dID09PSBudWxsKSB7XG4gICAgICBtZXJnZVRhcmdldFtvcHRpb25dID0gT2JqZWN0LmNyZWF0ZShnbG9iYWxPcHRpb25zW29wdGlvbl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3B0aW9uc1tvcHRpb25dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zW29wdGlvbl0gPT09ICdib29sZWFuJykge1xuICAgICAgICAgIG1lcmdlVGFyZ2V0W29wdGlvbl0uZW5hYmxlZCA9IG9wdGlvbnNbb3B0aW9uXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAob3B0aW9uc1tvcHRpb25dLmVuYWJsZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbWVyZ2VUYXJnZXRbb3B0aW9uXS5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zW29wdGlvbl0pIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zW29wdGlvbl0uaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgbWVyZ2VUYXJnZXRbb3B0aW9uXVtwcm9wXSA9IG9wdGlvbnNbb3B0aW9uXVtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gZG9lcyBhIGJpbmFyeSBzZWFyY2ggZm9yIGEgdmlzaWJsZSBpdGVtIGluIGEgc29ydGVkIGxpc3QuIElmIHdlIGZpbmQgYSB2aXNpYmxlIGl0ZW0sIHRoZSBjb2RlIHRoYXQgdXNlc1xuICAgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgdGhlbiBpdGVyYXRlIGluIGJvdGggZGlyZWN0aW9ucyBvdmVyIHRoaXMgc29ydGVkIGxpc3QgdG8gZmluZCBhbGwgdmlzaWJsZSBpdGVtcy5cbiAgICpcbiAgICogQHBhcmFtIHtJdGVtW119IG9yZGVyZWRJdGVtcyAgICAgICB8IEl0ZW1zIG9yZGVyZWQgYnkgc3RhcnRcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcGFyYXRvciAgICAgICB8IC0xIGlzIGxvd2VyLCAwIGlzIGVxdWFsLCAxIGlzIGhpZ2hlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkMlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZXhwb3J0cy5iaW5hcnlTZWFyY2hDdXN0b20gPSBmdW5jdGlvbiAob3JkZXJlZEl0ZW1zLCBjb21wYXJhdG9yLCBmaWVsZCwgZmllbGQyKSB7XG4gICAgdmFyIG1heEl0ZXJhdGlvbnMgPSAxMDAwMDtcbiAgICB2YXIgaXRlcmF0aW9uID0gMDtcbiAgICB2YXIgbG93ID0gMDtcbiAgICB2YXIgaGlnaCA9IG9yZGVyZWRJdGVtcy5sZW5ndGggLSAxO1xuXG4gICAgd2hpbGUgKGxvdyA8PSBoaWdoICYmIGl0ZXJhdGlvbiA8IG1heEl0ZXJhdGlvbnMpIHtcbiAgICAgIHZhciBtaWRkbGUgPSBNYXRoLmZsb29yKChsb3cgKyBoaWdoKSAvIDIpO1xuXG4gICAgICB2YXIgaXRlbSA9IG9yZGVyZWRJdGVtc1ttaWRkbGVdO1xuICAgICAgdmFyIHZhbHVlID0gZmllbGQyID09PSB1bmRlZmluZWQgPyBpdGVtW2ZpZWxkXSA6IGl0ZW1bZmllbGRdW2ZpZWxkMl07XG5cbiAgICAgIHZhciBzZWFyY2hSZXN1bHQgPSBjb21wYXJhdG9yKHZhbHVlKTtcbiAgICAgIGlmIChzZWFyY2hSZXN1bHQgPT0gMCkge1xuICAgICAgICAvLyBqaWhhYSwgZm91bmQgYSB2aXNpYmxlIGl0ZW0hXG4gICAgICAgIHJldHVybiBtaWRkbGU7XG4gICAgICB9IGVsc2UgaWYgKHNlYXJjaFJlc3VsdCA9PSAtMSkge1xuICAgICAgICAvLyBpdCBpcyB0b28gc21hbGwgLS0+IGluY3JlYXNlIGxvd1xuICAgICAgICBsb3cgPSBtaWRkbGUgKyAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaXQgaXMgdG9vIGJpZyAtLT4gZGVjcmVhc2UgaGlnaFxuICAgICAgICBoaWdoID0gbWlkZGxlIC0gMTtcbiAgICAgIH1cblxuICAgICAgaXRlcmF0aW9uKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGRvZXMgYSBiaW5hcnkgc2VhcmNoIGZvciBhIHNwZWNpZmljIHZhbHVlIGluIGEgc29ydGVkIGFycmF5LiBJZiBpdCBkb2VzIG5vdCBleGlzdCBidXQgaXMgaW4gYmV0d2VlbiBvZlxuICAgKiB0d28gdmFsdWVzLCB3ZSByZXR1cm4gZWl0aGVyIHRoZSBvbmUgYmVmb3JlIG9yIHRoZSBvbmUgYWZ0ZXIsIGRlcGVuZGluZyBvbiB1c2VyIGlucHV0XG4gICAqIElmIGl0IGlzIGZvdW5kLCB3ZSByZXR1cm4gdGhlIGluZGV4LCBlbHNlIC0xLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBvcmRlcmVkSXRlbXNcbiAgICogQHBhcmFtIHt7c3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXJ9fSB0YXJnZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzaWRlUHJlZmVyZW5jZSAgICdiZWZvcmUnIG9yICdhZnRlcidcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcGFyYXRvciBhbiBvcHRpb25hbCBjb21wYXJhdG9yLCByZXR1cm5pbmcgLTEsMCwxIGZvciA8LD09LD4uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBleHBvcnRzLmJpbmFyeVNlYXJjaFZhbHVlID0gZnVuY3Rpb24gKG9yZGVyZWRJdGVtcywgdGFyZ2V0LCBmaWVsZCwgc2lkZVByZWZlcmVuY2UsIGNvbXBhcmF0b3IpIHtcbiAgICB2YXIgbWF4SXRlcmF0aW9ucyA9IDEwMDAwO1xuICAgIHZhciBpdGVyYXRpb24gPSAwO1xuICAgIHZhciBsb3cgPSAwO1xuICAgIHZhciBoaWdoID0gb3JkZXJlZEl0ZW1zLmxlbmd0aCAtIDE7XG4gICAgdmFyIHByZXZWYWx1ZSwgdmFsdWUsIG5leHRWYWx1ZSwgbWlkZGxlO1xuXG4gICAgdmFyIGNvbXBhcmF0b3IgPSBjb21wYXJhdG9yICE9IHVuZGVmaW5lZCA/IGNvbXBhcmF0b3IgOiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEgPT0gYiA/IDAgOiBhIDwgYiA/IC0xIDogMTtcbiAgICB9O1xuXG4gICAgd2hpbGUgKGxvdyA8PSBoaWdoICYmIGl0ZXJhdGlvbiA8IG1heEl0ZXJhdGlvbnMpIHtcbiAgICAgIC8vIGdldCBhIG5ldyBndWVzc1xuICAgICAgbWlkZGxlID0gTWF0aC5mbG9vcigwLjUgKiAoaGlnaCArIGxvdykpO1xuICAgICAgcHJldlZhbHVlID0gb3JkZXJlZEl0ZW1zW01hdGgubWF4KDAsIG1pZGRsZSAtIDEpXVtmaWVsZF07XG4gICAgICB2YWx1ZSA9IG9yZGVyZWRJdGVtc1ttaWRkbGVdW2ZpZWxkXTtcbiAgICAgIG5leHRWYWx1ZSA9IG9yZGVyZWRJdGVtc1tNYXRoLm1pbihvcmRlcmVkSXRlbXMubGVuZ3RoIC0gMSwgbWlkZGxlICsgMSldW2ZpZWxkXTtcblxuICAgICAgaWYgKGNvbXBhcmF0b3IodmFsdWUsIHRhcmdldCkgPT0gMCkge1xuICAgICAgICAvLyB3ZSBmb3VuZCB0aGUgdGFyZ2V0XG4gICAgICAgIHJldHVybiBtaWRkbGU7XG4gICAgICB9IGVsc2UgaWYgKGNvbXBhcmF0b3IocHJldlZhbHVlLCB0YXJnZXQpIDwgMCAmJiBjb21wYXJhdG9yKHZhbHVlLCB0YXJnZXQpID4gMCkge1xuICAgICAgICAvLyB0YXJnZXQgaXMgaW4gYmV0d2VlbiBvZiB0aGUgcHJldmlvdXMgYW5kIHRoZSBjdXJyZW50XG4gICAgICAgIHJldHVybiBzaWRlUHJlZmVyZW5jZSA9PSAnYmVmb3JlJyA/IE1hdGgubWF4KDAsIG1pZGRsZSAtIDEpIDogbWlkZGxlO1xuICAgICAgfSBlbHNlIGlmIChjb21wYXJhdG9yKHZhbHVlLCB0YXJnZXQpIDwgMCAmJiBjb21wYXJhdG9yKG5leHRWYWx1ZSwgdGFyZ2V0KSA+IDApIHtcbiAgICAgICAgLy8gdGFyZ2V0IGlzIGluIGJldHdlZW4gb2YgdGhlIGN1cnJlbnQgYW5kIHRoZSBuZXh0XG4gICAgICAgIHJldHVybiBzaWRlUHJlZmVyZW5jZSA9PSAnYmVmb3JlJyA/IG1pZGRsZSA6IE1hdGgubWluKG9yZGVyZWRJdGVtcy5sZW5ndGggLSAxLCBtaWRkbGUgKyAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRpZG50IGZpbmQgdGhlIHRhcmdldCwgd2UgbmVlZCB0byBjaGFuZ2Ugb3VyIGJvdW5kYXJpZXMuXG4gICAgICAgIGlmIChjb21wYXJhdG9yKHZhbHVlLCB0YXJnZXQpIDwgMCkge1xuICAgICAgICAgIC8vIGl0IGlzIHRvbyBzbWFsbCAtLT4gaW5jcmVhc2UgbG93XG4gICAgICAgICAgbG93ID0gbWlkZGxlICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpdCBpcyB0b28gYmlnIC0tPiBkZWNyZWFzZSBoaWdoXG4gICAgICAgICAgaGlnaCA9IG1pZGRsZSAtIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGl0ZXJhdGlvbisrO1xuICAgIH1cblxuICAgIC8vIGRpZG50IGZpbmQgYW55dGhpbmcuIFJldHVybiAtMS5cbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgLypcbiAgICogRWFzaW5nIEZ1bmN0aW9ucyAtIGluc3BpcmVkIGZyb20gaHR0cDovL2dpem1hLmNvbS9lYXNpbmcvXG4gICAqIG9ubHkgY29uc2lkZXJpbmcgdGhlIHQgdmFsdWUgZm9yIHRoZSByYW5nZSBbMCwgMV0gPT4gWzAsIDFdXG4gICAqIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2dyZS8xNjUwMjk0XG4gICAqL1xuICBleHBvcnRzLmVhc2luZ0Z1bmN0aW9ucyA9IHtcbiAgICAvLyBubyBlYXNpbmcsIG5vIGFjY2VsZXJhdGlvblxuICAgIGxpbmVhcjogZnVuY3Rpb24gbGluZWFyKHQpIHtcbiAgICAgIHJldHVybiB0O1xuICAgIH0sXG4gICAgLy8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxuICAgIGVhc2VJblF1YWQ6IGZ1bmN0aW9uIGVhc2VJblF1YWQodCkge1xuICAgICAgcmV0dXJuIHQgKiB0O1xuICAgIH0sXG4gICAgLy8gZGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcbiAgICBlYXNlT3V0UXVhZDogZnVuY3Rpb24gZWFzZU91dFF1YWQodCkge1xuICAgICAgcmV0dXJuIHQgKiAoMiAtIHQpO1xuICAgIH0sXG4gICAgLy8gYWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXG4gICAgZWFzZUluT3V0UXVhZDogZnVuY3Rpb24gZWFzZUluT3V0UXVhZCh0KSB7XG4gICAgICByZXR1cm4gdCA8IC41ID8gMiAqIHQgKiB0IDogLTEgKyAoNCAtIDIgKiB0KSAqIHQ7XG4gICAgfSxcbiAgICAvLyBhY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XG4gICAgZWFzZUluQ3ViaWM6IGZ1bmN0aW9uIGVhc2VJbkN1YmljKHQpIHtcbiAgICAgIHJldHVybiB0ICogdCAqIHQ7XG4gICAgfSxcbiAgICAvLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxuICAgIGVhc2VPdXRDdWJpYzogZnVuY3Rpb24gZWFzZU91dEN1YmljKHQpIHtcbiAgICAgIHJldHVybiAtLXQgKiB0ICogdCArIDE7XG4gICAgfSxcbiAgICAvLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbiAgICBlYXNlSW5PdXRDdWJpYzogZnVuY3Rpb24gZWFzZUluT3V0Q3ViaWModCkge1xuICAgICAgcmV0dXJuIHQgPCAuNSA/IDQgKiB0ICogdCAqIHQgOiAodCAtIDEpICogKDIgKiB0IC0gMikgKiAoMiAqIHQgLSAyKSArIDE7XG4gICAgfSxcbiAgICAvLyBhY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XG4gICAgZWFzZUluUXVhcnQ6IGZ1bmN0aW9uIGVhc2VJblF1YXJ0KHQpIHtcbiAgICAgIHJldHVybiB0ICogdCAqIHQgKiB0O1xuICAgIH0sXG4gICAgLy8gZGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcbiAgICBlYXNlT3V0UXVhcnQ6IGZ1bmN0aW9uIGVhc2VPdXRRdWFydCh0KSB7XG4gICAgICByZXR1cm4gMSAtIC0tdCAqIHQgKiB0ICogdDtcbiAgICB9LFxuICAgIC8vIGFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxuICAgIGVhc2VJbk91dFF1YXJ0OiBmdW5jdGlvbiBlYXNlSW5PdXRRdWFydCh0KSB7XG4gICAgICByZXR1cm4gdCA8IC41ID8gOCAqIHQgKiB0ICogdCAqIHQgOiAxIC0gOCAqIC0tdCAqIHQgKiB0ICogdDtcbiAgICB9LFxuICAgIC8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcbiAgICBlYXNlSW5RdWludDogZnVuY3Rpb24gZWFzZUluUXVpbnQodCkge1xuICAgICAgcmV0dXJuIHQgKiB0ICogdCAqIHQgKiB0O1xuICAgIH0sXG4gICAgLy8gZGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcbiAgICBlYXNlT3V0UXVpbnQ6IGZ1bmN0aW9uIGVhc2VPdXRRdWludCh0KSB7XG4gICAgICByZXR1cm4gMSArIC0tdCAqIHQgKiB0ICogdCAqIHQ7XG4gICAgfSxcbiAgICAvLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbiAgICBlYXNlSW5PdXRRdWludDogZnVuY3Rpb24gZWFzZUluT3V0UXVpbnQodCkge1xuICAgICAgcmV0dXJuIHQgPCAuNSA/IDE2ICogdCAqIHQgKiB0ICogdCAqIHQgOiAxICsgMTYgKiAtLXQgKiB0ICogdCAqIHQgKiB0O1xuICAgIH1cbiAgfTtcblxuLyoqKi8gfSxcbi8qIDIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBmaXJzdCBjaGVjayBpZiBtb21lbnQuanMgaXMgYWxyZWFkeSBsb2FkZWQgaW4gdGhlIGJyb3dzZXIgd2luZG93LCBpZiBzbyxcbiAgLy8gdXNlIHRoaXMgaW5zdGFuY2UuIEVsc2UsIGxvYWQgdmlhIGNvbW1vbmpzLlxuICBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvd1snbW9tZW50J10gfHwgX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuLyoqKi8gfSxcbi8qIDMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gIC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihtb2R1bGUpIHsvLyEgbW9tZW50LmpzXG4gIC8vISB2ZXJzaW9uIDogMi4xMy4wXG4gIC8vISBhdXRob3JzIDogVGltIFdvb2QsIElza3JlbiBDaGVybmV2LCBNb21lbnQuanMgY29udHJpYnV0b3JzXG4gIC8vISBsaWNlbnNlIDogTUlUXG4gIC8vISBtb21lbnRqcy5jb21cblxuICA7KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICAgICB0cnVlID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgICAgIGdsb2JhbC5tb21lbnQgPSBmYWN0b3J5KClcbiAgfSh0aGlzLCBmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgICAgdmFyIGhvb2tDYWxsYmFjaztcblxuICAgICAgZnVuY3Rpb24gdXRpbHNfaG9va3NfX2hvb2tzICgpIHtcbiAgICAgICAgICByZXR1cm4gaG9va0NhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoaXMgaXMgZG9uZSB0byByZWdpc3RlciB0aGUgbWV0aG9kIGNhbGxlZCB3aXRoIG1vbWVudCgpXG4gICAgICAvLyB3aXRob3V0IGNyZWF0aW5nIGNpcmN1bGFyIGRlcGVuZGVuY2llcy5cbiAgICAgIGZ1bmN0aW9uIHNldEhvb2tDYWxsYmFjayAoY2FsbGJhY2spIHtcbiAgICAgICAgICBob29rQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaXNBcnJheShpbnB1dCkge1xuICAgICAgICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIEFycmF5IHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzRGF0ZShpbnB1dCkge1xuICAgICAgICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIERhdGUgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBtYXAoYXJyLCBmbikge1xuICAgICAgICAgIHZhciByZXMgPSBbXSwgaTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIHJlcy5wdXNoKGZuKGFycltpXSwgaSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBoYXNPd25Qcm9wKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGIpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBleHRlbmQoYSwgYikge1xuICAgICAgICAgIGZvciAodmFyIGkgaW4gYikge1xuICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcChiLCBpKSkge1xuICAgICAgICAgICAgICAgICAgYVtpXSA9IGJbaV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaGFzT3duUHJvcChiLCAndG9TdHJpbmcnKSkge1xuICAgICAgICAgICAgICBhLnRvU3RyaW5nID0gYi50b1N0cmluZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaGFzT3duUHJvcChiLCAndmFsdWVPZicpKSB7XG4gICAgICAgICAgICAgIGEudmFsdWVPZiA9IGIudmFsdWVPZjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gYTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY3JlYXRlX3V0Y19fY3JlYXRlVVRDIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCB0cnVlKS51dGMoKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGVmYXVsdFBhcnNpbmdGbGFncygpIHtcbiAgICAgICAgICAvLyBXZSBuZWVkIHRvIGRlZXAgY2xvbmUgdGhpcyBvYmplY3QuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZW1wdHkgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICAgIHVudXNlZFRva2VucyAgICA6IFtdLFxuICAgICAgICAgICAgICB1bnVzZWRJbnB1dCAgICAgOiBbXSxcbiAgICAgICAgICAgICAgb3ZlcmZsb3cgICAgICAgIDogLTIsXG4gICAgICAgICAgICAgIGNoYXJzTGVmdE92ZXIgICA6IDAsXG4gICAgICAgICAgICAgIG51bGxJbnB1dCAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgICBpbnZhbGlkTW9udGggICAgOiBudWxsLFxuICAgICAgICAgICAgICBpbnZhbGlkRm9ybWF0ICAgOiBmYWxzZSxcbiAgICAgICAgICAgICAgdXNlckludmFsaWRhdGVkIDogZmFsc2UsXG4gICAgICAgICAgICAgIGlzbyAgICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgICBwYXJzZWREYXRlUGFydHMgOiBbXSxcbiAgICAgICAgICAgICAgbWVyaWRpZW0gICAgICAgIDogbnVsbFxuICAgICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldFBhcnNpbmdGbGFncyhtKSB7XG4gICAgICAgICAgaWYgKG0uX3BmID09IG51bGwpIHtcbiAgICAgICAgICAgICAgbS5fcGYgPSBkZWZhdWx0UGFyc2luZ0ZsYWdzKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtLl9wZjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNvbWU7XG4gICAgICBpZiAoQXJyYXkucHJvdG90eXBlLnNvbWUpIHtcbiAgICAgICAgICBzb21lID0gQXJyYXkucHJvdG90eXBlLnNvbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNvbWUgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgICAgICAgICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xuICAgICAgICAgICAgICB2YXIgbGVuID0gdC5sZW5ndGggPj4+IDA7XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgaWYgKGkgaW4gdCAmJiBmdW4uY2FsbCh0aGlzLCB0W2ldLCBpLCB0KSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHZhbGlkX19pc1ZhbGlkKG0pIHtcbiAgICAgICAgICBpZiAobS5faXNWYWxpZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciBmbGFncyA9IGdldFBhcnNpbmdGbGFncyhtKTtcbiAgICAgICAgICAgICAgdmFyIHBhcnNlZFBhcnRzID0gc29tZS5jYWxsKGZsYWdzLnBhcnNlZERhdGVQYXJ0cywgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpICE9IG51bGw7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBtLl9pc1ZhbGlkID0gIWlzTmFOKG0uX2QuZ2V0VGltZSgpKSAmJlxuICAgICAgICAgICAgICAgICAgZmxhZ3Mub3ZlcmZsb3cgPCAwICYmXG4gICAgICAgICAgICAgICAgICAhZmxhZ3MuZW1wdHkgJiZcbiAgICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkTW9udGggJiZcbiAgICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkV2Vla2RheSAmJlxuICAgICAgICAgICAgICAgICAgIWZsYWdzLm51bGxJbnB1dCAmJlxuICAgICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRGb3JtYXQgJiZcbiAgICAgICAgICAgICAgICAgICFmbGFncy51c2VySW52YWxpZGF0ZWQgJiZcbiAgICAgICAgICAgICAgICAgICghZmxhZ3MubWVyaWRpZW0gfHwgKGZsYWdzLm1lcmlkaWVtICYmIHBhcnNlZFBhcnRzKSk7XG5cbiAgICAgICAgICAgICAgaWYgKG0uX3N0cmljdCkge1xuICAgICAgICAgICAgICAgICAgbS5faXNWYWxpZCA9IG0uX2lzVmFsaWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICBmbGFncy5jaGFyc0xlZnRPdmVyID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgZmxhZ3MudW51c2VkVG9rZW5zLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgIGZsYWdzLmJpZ0hvdXIgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbS5faXNWYWxpZDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdmFsaWRfX2NyZWF0ZUludmFsaWQgKGZsYWdzKSB7XG4gICAgICAgICAgdmFyIG0gPSBjcmVhdGVfdXRjX19jcmVhdGVVVEMoTmFOKTtcbiAgICAgICAgICBpZiAoZmxhZ3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBleHRlbmQoZ2V0UGFyc2luZ0ZsYWdzKG0pLCBmbGFncyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkudXNlckludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaXNVbmRlZmluZWQoaW5wdXQpIHtcbiAgICAgICAgICByZXR1cm4gaW5wdXQgPT09IHZvaWQgMDtcbiAgICAgIH1cblxuICAgICAgLy8gUGx1Z2lucyB0aGF0IGFkZCBwcm9wZXJ0aWVzIHNob3VsZCBhbHNvIGFkZCB0aGUga2V5IGhlcmUgKG51bGwgdmFsdWUpLFxuICAgICAgLy8gc28gd2UgY2FuIHByb3Blcmx5IGNsb25lIG91cnNlbHZlcy5cbiAgICAgIHZhciBtb21lbnRQcm9wZXJ0aWVzID0gdXRpbHNfaG9va3NfX2hvb2tzLm1vbWVudFByb3BlcnRpZXMgPSBbXTtcblxuICAgICAgZnVuY3Rpb24gY29weUNvbmZpZyh0bywgZnJvbSkge1xuICAgICAgICAgIHZhciBpLCBwcm9wLCB2YWw7XG5cbiAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2lzQU1vbWVudE9iamVjdCkpIHtcbiAgICAgICAgICAgICAgdG8uX2lzQU1vbWVudE9iamVjdCA9IGZyb20uX2lzQU1vbWVudE9iamVjdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pKSkge1xuICAgICAgICAgICAgICB0by5faSA9IGZyb20uX2k7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fZikpIHtcbiAgICAgICAgICAgICAgdG8uX2YgPSBmcm9tLl9mO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2wpKSB7XG4gICAgICAgICAgICAgIHRvLl9sID0gZnJvbS5fbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9zdHJpY3QpKSB7XG4gICAgICAgICAgICAgIHRvLl9zdHJpY3QgPSBmcm9tLl9zdHJpY3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fdHptKSkge1xuICAgICAgICAgICAgICB0by5fdHptID0gZnJvbS5fdHptO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2lzVVRDKSkge1xuICAgICAgICAgICAgICB0by5faXNVVEMgPSBmcm9tLl9pc1VUQztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9vZmZzZXQpKSB7XG4gICAgICAgICAgICAgIHRvLl9vZmZzZXQgPSBmcm9tLl9vZmZzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fcGYpKSB7XG4gICAgICAgICAgICAgIHRvLl9wZiA9IGdldFBhcnNpbmdGbGFncyhmcm9tKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9sb2NhbGUpKSB7XG4gICAgICAgICAgICAgIHRvLl9sb2NhbGUgPSBmcm9tLl9sb2NhbGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG1vbWVudFByb3BlcnRpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBmb3IgKGkgaW4gbW9tZW50UHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgcHJvcCA9IG1vbWVudFByb3BlcnRpZXNbaV07XG4gICAgICAgICAgICAgICAgICB2YWwgPSBmcm9tW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdG9bcHJvcF0gPSB2YWw7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdG87XG4gICAgICB9XG5cbiAgICAgIHZhciB1cGRhdGVJblByb2dyZXNzID0gZmFsc2U7XG5cbiAgICAgIC8vIE1vbWVudCBwcm90b3R5cGUgb2JqZWN0XG4gICAgICBmdW5jdGlvbiBNb21lbnQoY29uZmlnKSB7XG4gICAgICAgICAgY29weUNvbmZpZyh0aGlzLCBjb25maWcpO1xuICAgICAgICAgIHRoaXMuX2QgPSBuZXcgRGF0ZShjb25maWcuX2QgIT0gbnVsbCA/IGNvbmZpZy5fZC5nZXRUaW1lKCkgOiBOYU4pO1xuICAgICAgICAgIC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcCBpbiBjYXNlIHVwZGF0ZU9mZnNldCBjcmVhdGVzIG5ldyBtb21lbnRcbiAgICAgICAgICAvLyBvYmplY3RzLlxuICAgICAgICAgIGlmICh1cGRhdGVJblByb2dyZXNzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaXNNb21lbnQgKG9iaikge1xuICAgICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBNb21lbnQgfHwgKG9iaiAhPSBudWxsICYmIG9iai5faXNBTW9tZW50T2JqZWN0ICE9IG51bGwpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBhYnNGbG9vciAobnVtYmVyKSB7XG4gICAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0b0ludChhcmd1bWVudEZvckNvZXJjaW9uKSB7XG4gICAgICAgICAgdmFyIGNvZXJjZWROdW1iZXIgPSArYXJndW1lbnRGb3JDb2VyY2lvbixcbiAgICAgICAgICAgICAgdmFsdWUgPSAwO1xuXG4gICAgICAgICAgaWYgKGNvZXJjZWROdW1iZXIgIT09IDAgJiYgaXNGaW5pdGUoY29lcmNlZE51bWJlcikpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBhYnNGbG9vcihjb2VyY2VkTnVtYmVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGNvbXBhcmUgdHdvIGFycmF5cywgcmV0dXJuIHRoZSBudW1iZXIgb2YgZGlmZmVyZW5jZXNcbiAgICAgIGZ1bmN0aW9uIGNvbXBhcmVBcnJheXMoYXJyYXkxLCBhcnJheTIsIGRvbnRDb252ZXJ0KSB7XG4gICAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKGFycmF5MS5sZW5ndGgsIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgICBsZW5ndGhEaWZmID0gTWF0aC5hYnMoYXJyYXkxLmxlbmd0aCAtIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgICBkaWZmcyA9IDAsXG4gICAgICAgICAgICAgIGk7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmICgoZG9udENvbnZlcnQgJiYgYXJyYXkxW2ldICE9PSBhcnJheTJbaV0pIHx8XG4gICAgICAgICAgICAgICAgICAoIWRvbnRDb252ZXJ0ICYmIHRvSW50KGFycmF5MVtpXSkgIT09IHRvSW50KGFycmF5MltpXSkpKSB7XG4gICAgICAgICAgICAgICAgICBkaWZmcysrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkaWZmcyArIGxlbmd0aERpZmY7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gICAgICAgICAgaWYgKHV0aWxzX2hvb2tzX19ob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgICAodHlwZW9mIGNvbnNvbGUgIT09ICAndW5kZWZpbmVkJykgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRpb24gd2FybmluZzogJyArIG1zZyk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkZXByZWNhdGUobXNnLCBmbikge1xuICAgICAgICAgIHZhciBmaXJzdFRpbWUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIGV4dGVuZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmICh1dGlsc19ob29rc19faG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobnVsbCwgbXNnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgICAgICAgICAgICB3YXJuKG1zZyArICdcXG5Bcmd1bWVudHM6ICcgKyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmpvaW4oJywgJykgKyAnXFxuJyArIChuZXcgRXJyb3IoKSkuc3RhY2spO1xuICAgICAgICAgICAgICAgICAgZmlyc3RUaW1lID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfSwgZm4pO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVwcmVjYXRpb25zID0ge307XG5cbiAgICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCBtc2cpIHtcbiAgICAgICAgICBpZiAodXRpbHNfaG9va3NfX2hvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobmFtZSwgbXNnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFkZXByZWNhdGlvbnNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgd2Fybihtc2cpO1xuICAgICAgICAgICAgICBkZXByZWNhdGlvbnNbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9IGZhbHNlO1xuICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciA9IG51bGw7XG5cbiAgICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBGdW5jdGlvbiB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc09iamVjdChpbnB1dCkge1xuICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBPYmplY3RdJztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbG9jYWxlX3NldF9fc2V0IChjb25maWcpIHtcbiAgICAgICAgICB2YXIgcHJvcCwgaTtcbiAgICAgICAgICBmb3IgKGkgaW4gY29uZmlnKSB7XG4gICAgICAgICAgICAgIHByb3AgPSBjb25maWdbaV07XG4gICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzW2ldID0gcHJvcDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRoaXNbJ18nICsgaV0gPSBwcm9wO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgICAvLyBMZW5pZW50IG9yZGluYWwgcGFyc2luZyBhY2NlcHRzIGp1c3QgYSBudW1iZXIgaW4gYWRkaXRpb24gdG9cbiAgICAgICAgICAvLyBudW1iZXIgKyAocG9zc2libHkpIHN0dWZmIGNvbWluZyBmcm9tIF9vcmRpbmFsUGFyc2VMZW5pZW50LlxuICAgICAgICAgIHRoaXMuX29yZGluYWxQYXJzZUxlbmllbnQgPSBuZXcgUmVnRXhwKHRoaXMuX29yZGluYWxQYXJzZS5zb3VyY2UgKyAnfCcgKyAoL1xcZHsxLDJ9Lykuc291cmNlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY2hpbGRDb25maWcpIHtcbiAgICAgICAgICB2YXIgcmVzID0gZXh0ZW5kKHt9LCBwYXJlbnRDb25maWcpLCBwcm9wO1xuICAgICAgICAgIGZvciAocHJvcCBpbiBjaGlsZENvbmZpZykge1xuICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChwYXJlbnRDb25maWdbcHJvcF0pICYmIGlzT2JqZWN0KGNoaWxkQ29uZmlnW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIHBhcmVudENvbmZpZ1twcm9wXSk7XG4gICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kKHJlc1twcm9wXSwgY2hpbGRDb25maWdbcHJvcF0pO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGlsZENvbmZpZ1twcm9wXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzW3Byb3BdID0gY2hpbGRDb25maWdbcHJvcF07XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXNbcHJvcF07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gTG9jYWxlKGNvbmZpZykge1xuICAgICAgICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aGlzLnNldChjb25maWcpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGtleXM7XG5cbiAgICAgIGlmIChPYmplY3Qua2V5cykge1xuICAgICAgICAgIGtleXMgPSBPYmplY3Qua2V5cztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAga2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgdmFyIGksIHJlcyA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcChvYmosIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBpbnRlcm5hbCBzdG9yYWdlIGZvciBsb2NhbGUgY29uZmlnIGZpbGVzXG4gICAgICB2YXIgbG9jYWxlcyA9IHt9O1xuICAgICAgdmFyIGdsb2JhbExvY2FsZTtcblxuICAgICAgZnVuY3Rpb24gbm9ybWFsaXplTG9jYWxlKGtleSkge1xuICAgICAgICAgIHJldHVybiBrZXkgPyBrZXkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdfJywgJy0nKSA6IGtleTtcbiAgICAgIH1cblxuICAgICAgLy8gcGljayB0aGUgbG9jYWxlIGZyb20gdGhlIGFycmF5XG4gICAgICAvLyB0cnkgWydlbi1hdScsICdlbi1nYiddIGFzICdlbi1hdScsICdlbi1nYicsICdlbicsIGFzIGluIG1vdmUgdGhyb3VnaCB0aGUgbGlzdCB0cnlpbmcgZWFjaFxuICAgICAgLy8gc3Vic3RyaW5nIGZyb20gbW9zdCBzcGVjaWZpYyB0byBsZWFzdCwgYnV0IG1vdmUgdG8gdGhlIG5leHQgYXJyYXkgaXRlbSBpZiBpdCdzIGEgbW9yZSBzcGVjaWZpYyB2YXJpYW50IHRoYW4gdGhlIGN1cnJlbnQgcm9vdFxuICAgICAgZnVuY3Rpb24gY2hvb3NlTG9jYWxlKG5hbWVzKSB7XG4gICAgICAgICAgdmFyIGkgPSAwLCBqLCBuZXh0LCBsb2NhbGUsIHNwbGl0O1xuXG4gICAgICAgICAgd2hpbGUgKGkgPCBuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgc3BsaXQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaV0pLnNwbGl0KCctJyk7XG4gICAgICAgICAgICAgIGogPSBzcGxpdC5sZW5ndGg7XG4gICAgICAgICAgICAgIG5leHQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaSArIDFdKTtcbiAgICAgICAgICAgICAgbmV4dCA9IG5leHQgPyBuZXh0LnNwbGl0KCctJykgOiBudWxsO1xuICAgICAgICAgICAgICB3aGlsZSAoaiA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoc3BsaXQuc2xpY2UoMCwgaikuam9pbignLScpKTtcbiAgICAgICAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKG5leHQgJiYgbmV4dC5sZW5ndGggPj0gaiAmJiBjb21wYXJlQXJyYXlzKHNwbGl0LCBuZXh0LCB0cnVlKSA+PSBqIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vdGhlIG5leHQgYXJyYXkgaXRlbSBpcyBiZXR0ZXIgdGhhbiBhIHNoYWxsb3dlciBzdWJzdHJpbmcgb2YgdGhpcyBvbmVcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBsb2FkTG9jYWxlKG5hbWUpIHtcbiAgICAgICAgICB2YXIgb2xkTG9jYWxlID0gbnVsbDtcbiAgICAgICAgICAvLyBUT0RPOiBGaW5kIGEgYmV0dGVyIHdheSB0byByZWdpc3RlciBhbmQgbG9hZCBhbGwgdGhlIGxvY2FsZXMgaW4gTm9kZVxuICAgICAgICAgIGlmICghbG9jYWxlc1tuYW1lXSAmJiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICAgICAgICBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIG9sZExvY2FsZSA9IGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICAgICAgICAgICAgICAgICEoZnVuY3Rpb24gd2VicGFja01pc3NpbmdNb2R1bGUoKSB7IHZhciBlID0gbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlIFxcXCIuL2xvY2FsZVxcXCJcIik7IGUuY29kZSA9ICdNT0RVTEVfTk9UX0ZPVU5EJzsgdGhyb3cgZTsgfSgpKTtcbiAgICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgZGVmaW5lTG9jYWxlIGN1cnJlbnRseSBhbHNvIHNldHMgdGhlIGdsb2JhbCBsb2NhbGUsIHdlXG4gICAgICAgICAgICAgICAgICAvLyB3YW50IHRvIHVuZG8gdGhhdCBmb3IgbGF6eSBsb2FkZWQgbG9jYWxlc1xuICAgICAgICAgICAgICAgICAgbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZShvbGRMb2NhbGUpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgICB9XG5cbiAgICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBsb2FkIGxvY2FsZSBhbmQgdGhlbiBzZXQgdGhlIGdsb2JhbCBsb2NhbGUuICBJZlxuICAgICAgLy8gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCBnbG9iYWxcbiAgICAgIC8vIGxvY2FsZSBrZXkuXG4gICAgICBmdW5jdGlvbiBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlIChrZXksIHZhbHVlcykge1xuICAgICAgICAgIHZhciBkYXRhO1xuICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICAgIGRhdGEgPSBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBkYXRhID0gZGVmaW5lTG9jYWxlKGtleSwgdmFsdWVzKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAvLyBtb21lbnQuZHVyYXRpb24uX2xvY2FsZSA9IG1vbWVudC5fbG9jYWxlID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgIGdsb2JhbExvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlLl9hYmJyO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkZWZpbmVMb2NhbGUgKG5hbWUsIGNvbmZpZykge1xuICAgICAgICAgIGlmIChjb25maWcgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgY29uZmlnLmFiYnIgPSBuYW1lO1xuICAgICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBkZXByZWNhdGVTaW1wbGUoJ2RlZmluZUxvY2FsZU92ZXJyaWRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZSBtb21lbnQudXBkYXRlTG9jYWxlKGxvY2FsZU5hbWUsIGNvbmZpZykgdG8gY2hhbmdlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYW4gZXhpc3RpbmcgbG9jYWxlLiBtb21lbnQuZGVmaW5lTG9jYWxlKGxvY2FsZU5hbWUsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnY29uZmlnKSBzaG91bGQgb25seSBiZSB1c2VkIGZvciBjcmVhdGluZyBhIG5ldyBsb2NhbGUnKTtcbiAgICAgICAgICAgICAgICAgIGNvbmZpZyA9IG1lcmdlQ29uZmlncyhsb2NhbGVzW25hbWVdLl9jb25maWcsIGNvbmZpZyk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobG9jYWxlc1tjb25maWcucGFyZW50TG9jYWxlXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uZmlnID0gbWVyZ2VDb25maWdzKGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0uX2NvbmZpZywgY29uZmlnKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gdHJlYXQgYXMgaWYgdGhlcmUgaXMgbm8gYmFzZSBjb25maWdcbiAgICAgICAgICAgICAgICAgICAgICBkZXByZWNhdGVTaW1wbGUoJ3BhcmVudExvY2FsZVVuZGVmaW5lZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc3BlY2lmaWVkIHBhcmVudExvY2FsZSBpcyBub3QgZGVmaW5lZCB5ZXQnKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbmV3IExvY2FsZShjb25maWcpO1xuXG4gICAgICAgICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXQgZm9yIG5vdzogYWxzbyBzZXQgdGhlIGxvY2FsZVxuICAgICAgICAgICAgICBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuXG4gICAgICAgICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHVzZWZ1bCBmb3IgdGVzdGluZ1xuICAgICAgICAgICAgICBkZWxldGUgbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB1cGRhdGVMb2NhbGUobmFtZSwgY29uZmlnKSB7XG4gICAgICAgICAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciBsb2NhbGU7XG4gICAgICAgICAgICAgIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGNvbmZpZyA9IG1lcmdlQ29uZmlncyhsb2NhbGVzW25hbWVdLl9jb25maWcsIGNvbmZpZyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbG9jYWxlID0gbmV3IExvY2FsZShjb25maWcpO1xuICAgICAgICAgICAgICBsb2NhbGUucGFyZW50TG9jYWxlID0gbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZTtcblxuICAgICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgICAgbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZShuYW1lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBwYXNzIG51bGwgZm9yIGNvbmZpZyB0byB1bnVwZGF0ZSwgdXNlZnVsIGZvciB0ZXN0c1xuICAgICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXS5wYXJlbnRMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgICB9XG5cbiAgICAgIC8vIHJldHVybnMgbG9jYWxlIGRhdGFcbiAgICAgIGZ1bmN0aW9uIGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUgKGtleSkge1xuICAgICAgICAgIHZhciBsb2NhbGU7XG5cbiAgICAgICAgICBpZiAoa2V5ICYmIGtleS5fbG9jYWxlICYmIGtleS5fbG9jYWxlLl9hYmJyKSB7XG4gICAgICAgICAgICAgIGtleSA9IGtleS5fbG9jYWxlLl9hYmJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFpc0FycmF5KGtleSkpIHtcbiAgICAgICAgICAgICAgLy9zaG9ydC1jaXJjdWl0IGV2ZXJ5dGhpbmcgZWxzZVxuICAgICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGtleSk7XG4gICAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAga2V5ID0gW2tleV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNob29zZUxvY2FsZShrZXkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBsb2NhbGVfbG9jYWxlc19fbGlzdExvY2FsZXMoKSB7XG4gICAgICAgICAgcmV0dXJuIGtleXMobG9jYWxlcyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBhbGlhc2VzID0ge307XG5cbiAgICAgIGZ1bmN0aW9uIGFkZFVuaXRBbGlhcyAodW5pdCwgc2hvcnRoYW5kKSB7XG4gICAgICAgICAgdmFyIGxvd2VyQ2FzZSA9IHVuaXQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBhbGlhc2VzW2xvd2VyQ2FzZV0gPSBhbGlhc2VzW2xvd2VyQ2FzZSArICdzJ10gPSBhbGlhc2VzW3Nob3J0aGFuZF0gPSB1bml0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBub3JtYWxpemVVbml0cyh1bml0cykge1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgdW5pdHMgPT09ICdzdHJpbmcnID8gYWxpYXNlc1t1bml0c10gfHwgYWxpYXNlc1t1bml0cy50b0xvd2VyQ2FzZSgpXSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbm9ybWFsaXplT2JqZWN0VW5pdHMoaW5wdXRPYmplY3QpIHtcbiAgICAgICAgICB2YXIgbm9ybWFsaXplZElucHV0ID0ge30sXG4gICAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wLFxuICAgICAgICAgICAgICBwcm9wO1xuXG4gICAgICAgICAgZm9yIChwcm9wIGluIGlucHV0T2JqZWN0KSB7XG4gICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGlucHV0T2JqZWN0LCBwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZFByb3AgPSBub3JtYWxpemVVbml0cyhwcm9wKTtcbiAgICAgICAgICAgICAgICAgIGlmIChub3JtYWxpemVkUHJvcCkge1xuICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnB1dFtub3JtYWxpemVkUHJvcF0gPSBpbnB1dE9iamVjdFtwcm9wXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBub3JtYWxpemVkSW5wdXQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG1ha2VHZXRTZXQgKHVuaXQsIGtlZXBUaW1lKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgZ2V0X3NldF9fc2V0KHRoaXMsIHVuaXQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQodGhpcywga2VlcFRpbWUpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0X3NldF9fZ2V0KHRoaXMsIHVuaXQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0X3NldF9fZ2V0IChtb20sIHVuaXQpIHtcbiAgICAgICAgICByZXR1cm4gbW9tLmlzVmFsaWQoKSA/XG4gICAgICAgICAgICAgIG1vbS5fZFsnZ2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSgpIDogTmFOO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRfc2V0X19zZXQgKG1vbSwgdW5pdCwgdmFsdWUpIHtcbiAgICAgICAgICBpZiAobW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0odmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gTU9NRU5UU1xuXG4gICAgICBmdW5jdGlvbiBnZXRTZXQgKHVuaXRzLCB2YWx1ZSkge1xuICAgICAgICAgIHZhciB1bml0O1xuICAgICAgICAgIGlmICh0eXBlb2YgdW5pdHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgIGZvciAodW5pdCBpbiB1bml0cykge1xuICAgICAgICAgICAgICAgICAgdGhpcy5zZXQodW5pdCwgdW5pdHNbdW5pdF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXNbdW5pdHNdKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKHZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gemVyb0ZpbGwobnVtYmVyLCB0YXJnZXRMZW5ndGgsIGZvcmNlU2lnbikge1xuICAgICAgICAgIHZhciBhYnNOdW1iZXIgPSAnJyArIE1hdGguYWJzKG51bWJlciksXG4gICAgICAgICAgICAgIHplcm9zVG9GaWxsID0gdGFyZ2V0TGVuZ3RoIC0gYWJzTnVtYmVyLmxlbmd0aCxcbiAgICAgICAgICAgICAgc2lnbiA9IG51bWJlciA+PSAwO1xuICAgICAgICAgIHJldHVybiAoc2lnbiA/IChmb3JjZVNpZ24gPyAnKycgOiAnJykgOiAnLScpICtcbiAgICAgICAgICAgICAgTWF0aC5wb3coMTAsIE1hdGgubWF4KDAsIHplcm9zVG9GaWxsKSkudG9TdHJpbmcoKS5zdWJzdHIoMSkgKyBhYnNOdW1iZXI7XG4gICAgICB9XG5cbiAgICAgIHZhciBmb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KFtIaF1tbShzcyk/fE1vfE1NP00/TT98RG98REREb3xERD9EP0Q/fGRkZD9kP3xkbz98d1tvfHddP3xXW298V10/fFFvP3xZWVlZWVl8WVlZWVl8WVlZWXxZWXxnZyhnZ2c/KT98R0coR0dHPyk/fGV8RXxhfEF8aGg/fEhIP3xraz98bW0/fHNzP3xTezEsOX18eHxYfHp6P3xaWj98LikvZztcblxuICAgICAgdmFyIGxvY2FsRm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhMVFN8TFR8TEw/TD9MP3xsezEsNH0pL2c7XG5cbiAgICAgIHZhciBmb3JtYXRGdW5jdGlvbnMgPSB7fTtcblxuICAgICAgdmFyIGZvcm1hdFRva2VuRnVuY3Rpb25zID0ge307XG5cbiAgICAgIC8vIHRva2VuOiAgICAnTSdcbiAgICAgIC8vIHBhZGRlZDogICBbJ01NJywgMl1cbiAgICAgIC8vIG9yZGluYWw6ICAnTW8nXG4gICAgICAvLyBjYWxsYmFjazogZnVuY3Rpb24gKCkgeyB0aGlzLm1vbnRoKCkgKyAxIH1cbiAgICAgIGZ1bmN0aW9uIGFkZEZvcm1hdFRva2VuICh0b2tlbiwgcGFkZGVkLCBvcmRpbmFsLCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciBmdW5jID0gY2FsbGJhY2s7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2NhbGxiYWNrXSgpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dID0gZnVuYztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBhZGRlZCkge1xuICAgICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1twYWRkZWRbMF1dID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHplcm9GaWxsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgcGFkZGVkWzFdLCBwYWRkZWRbMl0pO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3JkaW5hbCkge1xuICAgICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1tvcmRpbmFsXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5vcmRpbmFsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdG9rZW4pO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhpbnB1dCkge1xuICAgICAgICAgIGlmIChpbnB1dC5tYXRjaCgvXFxbW1xcc1xcU10vKSkge1xuICAgICAgICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXlxcW3xcXF0kL2csICcnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL1xcXFwvZywgJycpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgICAgICAgdmFyIGFycmF5ID0gZm9ybWF0Lm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpLCBpLCBsZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dKSB7XG4gICAgICAgICAgICAgICAgICBhcnJheVtpXSA9IGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGFycmF5W2ldID0gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhhcnJheVtpXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1vbSkge1xuICAgICAgICAgICAgICB2YXIgb3V0cHV0ID0gJycsIGk7XG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0ICs9IGFycmF5W2ldIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBhcnJheVtpXS5jYWxsKG1vbSwgZm9ybWF0KSA6IGFycmF5W2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gZm9ybWF0IGRhdGUgdXNpbmcgbmF0aXZlIGRhdGUgb2JqZWN0XG4gICAgICBmdW5jdGlvbiBmb3JtYXRNb21lbnQobSwgZm9ybWF0KSB7XG4gICAgICAgICAgaWYgKCFtLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICByZXR1cm4gbS5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3JtYXQgPSBleHBhbmRGb3JtYXQoZm9ybWF0LCBtLmxvY2FsZURhdGEoKSk7XG4gICAgICAgICAgZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gPSBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSB8fCBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KTtcblxuICAgICAgICAgIHJldHVybiBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XShtKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbG9jYWxlKSB7XG4gICAgICAgICAgdmFyIGkgPSA1O1xuXG4gICAgICAgICAgZnVuY3Rpb24gcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKGlucHV0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBsb2NhbGUubG9uZ0RhdGVGb3JtYXQoaW5wdXQpIHx8IGlucHV0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgIHdoaWxlIChpID49IDAgJiYgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLnRlc3QoZm9ybWF0KSkge1xuICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZShsb2NhbEZvcm1hdHRpbmdUb2tlbnMsIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2Vucyk7XG4gICAgICAgICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgICBpIC09IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICAgIH1cblxuICAgICAgdmFyIG1hdGNoMSAgICAgICAgID0gL1xcZC87ICAgICAgICAgICAgLy8gICAgICAgMCAtIDlcbiAgICAgIHZhciBtYXRjaDIgICAgICAgICA9IC9cXGRcXGQvOyAgICAgICAgICAvLyAgICAgIDAwIC0gOTlcbiAgICAgIHZhciBtYXRjaDMgICAgICAgICA9IC9cXGR7M30vOyAgICAgICAgIC8vICAgICAwMDAgLSA5OTlcbiAgICAgIHZhciBtYXRjaDQgICAgICAgICA9IC9cXGR7NH0vOyAgICAgICAgIC8vICAgIDAwMDAgLSA5OTk5XG4gICAgICB2YXIgbWF0Y2g2ICAgICAgICAgPSAvWystXT9cXGR7Nn0vOyAgICAvLyAtOTk5OTk5IC0gOTk5OTk5XG4gICAgICB2YXIgbWF0Y2gxdG8yICAgICAgPSAvXFxkXFxkPy87ICAgICAgICAgLy8gICAgICAgMCAtIDk5XG4gICAgICB2YXIgbWF0Y2gzdG80ICAgICAgPSAvXFxkXFxkXFxkXFxkPy87ICAgICAvLyAgICAgOTk5IC0gOTk5OVxuICAgICAgdmFyIG1hdGNoNXRvNiAgICAgID0gL1xcZFxcZFxcZFxcZFxcZFxcZD8vOyAvLyAgIDk5OTk5IC0gOTk5OTk5XG4gICAgICB2YXIgbWF0Y2gxdG8zICAgICAgPSAvXFxkezEsM30vOyAgICAgICAvLyAgICAgICAwIC0gOTk5XG4gICAgICB2YXIgbWF0Y2gxdG80ICAgICAgPSAvXFxkezEsNH0vOyAgICAgICAvLyAgICAgICAwIC0gOTk5OVxuICAgICAgdmFyIG1hdGNoMXRvNiAgICAgID0gL1srLV0/XFxkezEsNn0vOyAgLy8gLTk5OTk5OSAtIDk5OTk5OVxuXG4gICAgICB2YXIgbWF0Y2hVbnNpZ25lZCAgPSAvXFxkKy87ICAgICAgICAgICAvLyAgICAgICAwIC0gaW5mXG4gICAgICB2YXIgbWF0Y2hTaWduZWQgICAgPSAvWystXT9cXGQrLzsgICAgICAvLyAgICAtaW5mIC0gaW5mXG5cbiAgICAgIHZhciBtYXRjaE9mZnNldCAgICA9IC9afFsrLV1cXGRcXGQ6P1xcZFxcZC9naTsgLy8gKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG4gICAgICB2YXIgbWF0Y2hTaG9ydE9mZnNldCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/L2dpOyAvLyArMDAgLTAwICswMDowMCAtMDA6MDAgKzAwMDAgLTAwMDAgb3IgWlxuXG4gICAgICB2YXIgbWF0Y2hUaW1lc3RhbXAgPSAvWystXT9cXGQrKFxcLlxcZHsxLDN9KT8vOyAvLyAxMjM0NTY3ODkgMTIzNDU2Nzg5LjEyM1xuXG4gICAgICAvLyBhbnkgd29yZCAob3IgdHdvKSBjaGFyYWN0ZXJzIG9yIG51bWJlcnMgaW5jbHVkaW5nIHR3by90aHJlZSB3b3JkIG1vbnRoIGluIGFyYWJpYy5cbiAgICAgIC8vIGluY2x1ZGVzIHNjb3R0aXNoIGdhZWxpYyB0d28gd29yZCBhbmQgaHlwaGVuYXRlZCBtb250aHNcbiAgICAgIHZhciBtYXRjaFdvcmQgPSAvWzAtOV0qWydhLXpcXHUwMEEwLVxcdTA1RkZcXHUwNzAwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdK3xbXFx1MDYwMC1cXHUwNkZGXFwvXSsoXFxzKj9bXFx1MDYwMC1cXHUwNkZGXSspezEsMn0vaTtcblxuXG4gICAgICB2YXIgcmVnZXhlcyA9IHt9O1xuXG4gICAgICBmdW5jdGlvbiBhZGRSZWdleFRva2VuICh0b2tlbiwgcmVnZXgsIHN0cmljdFJlZ2V4KSB7XG4gICAgICAgICAgcmVnZXhlc1t0b2tlbl0gPSBpc0Z1bmN0aW9uKHJlZ2V4KSA/IHJlZ2V4IDogZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGVEYXRhKSB7XG4gICAgICAgICAgICAgIHJldHVybiAoaXNTdHJpY3QgJiYgc3RyaWN0UmVnZXgpID8gc3RyaWN0UmVnZXggOiByZWdleDtcbiAgICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4gKHRva2VuLCBjb25maWcpIHtcbiAgICAgICAgICBpZiAoIWhhc093blByb3AocmVnZXhlcywgdG9rZW4pKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHVuZXNjYXBlRm9ybWF0KHRva2VuKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJlZ2V4ZXNbdG9rZW5dKGNvbmZpZy5fc3RyaWN0LCBjb25maWcuX2xvY2FsZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIENvZGUgZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM1NjE0OTMvaXMtdGhlcmUtYS1yZWdleHAtZXNjYXBlLWZ1bmN0aW9uLWluLWphdmFzY3JpcHRcbiAgICAgIGZ1bmN0aW9uIHVuZXNjYXBlRm9ybWF0KHMpIHtcbiAgICAgICAgICByZXR1cm4gcmVnZXhFc2NhcGUocy5yZXBsYWNlKCdcXFxcJywgJycpLnJlcGxhY2UoL1xcXFwoXFxbKXxcXFxcKFxcXSl8XFxbKFteXFxdXFxbXSopXFxdfFxcXFwoLikvZywgZnVuY3Rpb24gKG1hdGNoZWQsIHAxLCBwMiwgcDMsIHA0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBwMSB8fCBwMiB8fCBwMyB8fCBwNDtcbiAgICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHJlZ2V4RXNjYXBlKHMpIHtcbiAgICAgICAgICByZXR1cm4gcy5yZXBsYWNlKC9bLVxcL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRva2VucyA9IHt9O1xuXG4gICAgICBmdW5jdGlvbiBhZGRQYXJzZVRva2VuICh0b2tlbiwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgaSwgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIHRva2VuID0gW3Rva2VuXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgIGFycmF5W2NhbGxiYWNrXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2VuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHRva2Vuc1t0b2tlbltpXV0gPSBmdW5jO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYWRkV2Vla1BhcnNlVG9rZW4gKHRva2VuLCBjYWxsYmFjaykge1xuICAgICAgICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgICAgICAgY29uZmlnLl93ID0gY29uZmlnLl93IHx8IHt9O1xuICAgICAgICAgICAgICBjYWxsYmFjayhpbnB1dCwgY29uZmlnLl93LCBjb25maWcsIHRva2VuKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIGlucHV0LCBjb25maWcpIHtcbiAgICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCAmJiBoYXNPd25Qcm9wKHRva2VucywgdG9rZW4pKSB7XG4gICAgICAgICAgICAgIHRva2Vuc1t0b2tlbl0oaW5wdXQsIGNvbmZpZy5fYSwgY29uZmlnLCB0b2tlbik7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgWUVBUiA9IDA7XG4gICAgICB2YXIgTU9OVEggPSAxO1xuICAgICAgdmFyIERBVEUgPSAyO1xuICAgICAgdmFyIEhPVVIgPSAzO1xuICAgICAgdmFyIE1JTlVURSA9IDQ7XG4gICAgICB2YXIgU0VDT05EID0gNTtcbiAgICAgIHZhciBNSUxMSVNFQ09ORCA9IDY7XG4gICAgICB2YXIgV0VFSyA9IDc7XG4gICAgICB2YXIgV0VFS0RBWSA9IDg7XG5cbiAgICAgIHZhciBpbmRleE9mO1xuXG4gICAgICBpZiAoQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIHtcbiAgICAgICAgICBpbmRleE9mID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2Y7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluZGV4T2YgPSBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgICAvLyBJIGtub3dcbiAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodGhpc1tpXSA9PT0gbykge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkYXlzSW5Nb250aCh5ZWFyLCBtb250aCkge1xuICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCArIDEsIDApKS5nZXRVVENEYXRlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEZPUk1BVFRJTkdcblxuICAgICAgYWRkRm9ybWF0VG9rZW4oJ00nLCBbJ01NJywgMl0sICdNbycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5tb250aCgpICsgMTtcbiAgICAgIH0pO1xuXG4gICAgICBhZGRGb3JtYXRUb2tlbignTU1NJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHNTaG9ydCh0aGlzLCBmb3JtYXQpO1xuICAgICAgfSk7XG5cbiAgICAgIGFkZEZvcm1hdFRva2VuKCdNTU1NJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHModGhpcywgZm9ybWF0KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBTElBU0VTXG5cbiAgICAgIGFkZFVuaXRBbGlhcygnbW9udGgnLCAnTScpO1xuXG4gICAgICAvLyBQQVJTSU5HXG5cbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ00nLCAgICBtYXRjaDF0bzIpO1xuICAgICAgYWRkUmVnZXhUb2tlbignTU0nLCAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ01NTScsICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICAgIHJldHVybiBsb2NhbGUubW9udGhzU2hvcnRSZWdleChpc1N0cmljdCk7XG4gICAgICB9KTtcbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ01NTU0nLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICAgIHJldHVybiBsb2NhbGUubW9udGhzUmVnZXgoaXNTdHJpY3QpO1xuICAgICAgfSk7XG5cbiAgICAgIGFkZFBhcnNlVG9rZW4oWydNJywgJ01NJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgICBhcnJheVtNT05USF0gPSB0b0ludChpbnB1dCkgLSAxO1xuICAgICAgfSk7XG5cbiAgICAgIGFkZFBhcnNlVG9rZW4oWydNTU0nLCAnTU1NTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgICAgdmFyIG1vbnRoID0gY29uZmlnLl9sb2NhbGUubW9udGhzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgICAgICAgLy8gaWYgd2UgZGlkbid0IGZpbmQgYSBtb250aCBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWQuXG4gICAgICAgICAgaWYgKG1vbnRoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgYXJyYXlbTU9OVEhdID0gbW9udGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZE1vbnRoID0gaW5wdXQ7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIExPQ0FMRVNcblxuICAgICAgdmFyIE1PTlRIU19JTl9GT1JNQVQgPSAvRFtvRF0/KFxcW1teXFxbXFxdXSpcXF18XFxzKykrTU1NTT8vO1xuICAgICAgdmFyIGRlZmF1bHRMb2NhbGVNb250aHMgPSAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoJ18nKTtcbiAgICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRocyAobSwgZm9ybWF0KSB7XG4gICAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKSA/IHRoaXMuX21vbnRoc1ttLm1vbnRoKCldIDpcbiAgICAgICAgICAgICAgdGhpcy5fbW9udGhzW01PTlRIU19JTl9GT1JNQVQudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSddW20ubW9udGgoKV07XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQgPSAnSmFuX0ZlYl9NYXJfQXByX01heV9KdW5fSnVsX0F1Z19TZXBfT2N0X05vdl9EZWMnLnNwbGl0KCdfJyk7XG4gICAgICBmdW5jdGlvbiBsb2NhbGVNb250aHNTaG9ydCAobSwgZm9ybWF0KSB7XG4gICAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzU2hvcnQpID8gdGhpcy5fbW9udGhzU2hvcnRbbS5tb250aCgpXSA6XG4gICAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0W01PTlRIU19JTl9GT1JNQVQudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSddW20ubW9udGgoKV07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHVuaXRzX21vbnRoX19oYW5kbGVTdHJpY3RQYXJzZShtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgICAgdmFyIGksIGlpLCBtb20sIGxsYyA9IG1vbnRoTmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgICAgICAgLy8gdGhpcyBpcyBub3QgdXNlZFxuICAgICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7ICsraSkge1xuICAgICAgICAgICAgICAgICAgbW9tID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gdGhpcy5tb250aHNTaG9ydChtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldID0gdGhpcy5tb250aHMobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ01NTScpIHtcbiAgICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdNTU0nKSB7XG4gICAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRoc1BhcnNlIChtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgICByZXR1cm4gdW5pdHNfbW9udGhfX2hhbmRsZVN0cmljdFBhcnNlLmNhbGwodGhpcywgbW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRPRE86IGFkZCBzb3J0aW5nXG4gICAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSBtb250aCAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlclxuICAgICAgICAgIC8vIHNlZSBzb3J0aW5nIGluIGNvbXB1dGVNb250aHNQYXJzZVxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgICBtb20gPSBjcmVhdGVfdXRjX19jcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFzdHJpY3QgJiYgIXRoaXMuX21vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgICByZWdleCA9ICdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ01NTU0nICYmIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdNTU0nICYmIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmIHRoaXMuX21vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE1PTUVOVFNcblxuICAgICAgZnVuY3Rpb24gc2V0TW9udGggKG1vbSwgdmFsdWUpIHtcbiAgICAgICAgICB2YXIgZGF5T2ZNb250aDtcblxuICAgICAgICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAvLyBObyBvcFxuICAgICAgICAgICAgICByZXR1cm4gbW9tO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGlmICgvXlxcZCskLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0b0ludCh2YWx1ZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IG1vbS5sb2NhbGVEYXRhKCkubW9udGhzUGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgLy8gVE9ETzogQW5vdGhlciBzaWxlbnQgZmFpbHVyZT9cbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vbTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGRheU9mTW9udGggPSBNYXRoLm1pbihtb20uZGF0ZSgpLCBkYXlzSW5Nb250aChtb20ueWVhcigpLCB2YWx1ZSkpO1xuICAgICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyAnTW9udGgnXSh2YWx1ZSwgZGF5T2ZNb250aCk7XG4gICAgICAgICAgcmV0dXJuIG1vbTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0U2V0TW9udGggKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgc2V0TW9udGgodGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0X3NldF9fZ2V0KHRoaXMsICdNb250aCcpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0RGF5c0luTW9udGggKCkge1xuICAgICAgICAgIHJldHVybiBkYXlzSW5Nb250aCh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRlZmF1bHRNb250aHNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgICAgZnVuY3Rpb24gbW9udGhzU2hvcnRSZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgICBjb21wdXRlTW9udGhzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4IDogdGhpcy5fbW9udGhzU2hvcnRSZWdleDtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWZhdWx0TW9udGhzUmVnZXggPSBtYXRjaFdvcmQ7XG4gICAgICBmdW5jdGlvbiBtb250aHNSZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgICBjb21wdXRlTW9udGhzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTdHJpY3RSZWdleDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNSZWdleDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNTdHJpY3RSZWdleCA6IHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY29tcHV0ZU1vbnRoc1BhcnNlICgpIHtcbiAgICAgICAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xuICAgICAgICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc2hvcnRQaWVjZXMgPSBbXSwgbG9uZ1BpZWNlcyA9IFtdLCBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgICBpLCBtb207XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICAgIG1vbSA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgICBzaG9ydFBpZWNlcy5wdXNoKHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykpO1xuICAgICAgICAgICAgICBsb25nUGllY2VzLnB1c2godGhpcy5tb250aHMobW9tLCAnJykpO1xuICAgICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHRoaXMubW9udGhzKG1vbSwgJycpKTtcbiAgICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaCh0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSBtb250aCAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlciBpdFxuICAgICAgICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cbiAgICAgICAgICBzaG9ydFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgICAgbG9uZ1BpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgICAgbWl4ZWRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAgIHNob3J0UGllY2VzW2ldID0gcmVnZXhFc2NhcGUoc2hvcnRQaWVjZXNbaV0pO1xuICAgICAgICAgICAgICBsb25nUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobG9uZ1BpZWNlc1tpXSk7XG4gICAgICAgICAgICAgIG1peGVkUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobWl4ZWRQaWVjZXNbaV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX21vbnRoc1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWl4ZWRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0UmVnZXggPSB0aGlzLl9tb250aHNSZWdleDtcbiAgICAgICAgICB0aGlzLl9tb250aHNTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBzaG9ydFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNoZWNrT3ZlcmZsb3cgKG0pIHtcbiAgICAgICAgICB2YXIgb3ZlcmZsb3c7XG4gICAgICAgICAgdmFyIGEgPSBtLl9hO1xuXG4gICAgICAgICAgaWYgKGEgJiYgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID09PSAtMikge1xuICAgICAgICAgICAgICBvdmVyZmxvdyA9XG4gICAgICAgICAgICAgICAgICBhW01PTlRIXSAgICAgICA8IDAgfHwgYVtNT05USF0gICAgICAgPiAxMSAgPyBNT05USCA6XG4gICAgICAgICAgICAgICAgICBhW0RBVEVdICAgICAgICA8IDEgfHwgYVtEQVRFXSAgICAgICAgPiBkYXlzSW5Nb250aChhW1lFQVJdLCBhW01PTlRIXSkgPyBEQVRFIDpcbiAgICAgICAgICAgICAgICAgIGFbSE9VUl0gICAgICAgIDwgMCB8fCBhW0hPVVJdICAgICAgICA+IDI0IHx8IChhW0hPVVJdID09PSAyNCAmJiAoYVtNSU5VVEVdICE9PSAwIHx8IGFbU0VDT05EXSAhPT0gMCB8fCBhW01JTExJU0VDT05EXSAhPT0gMCkpID8gSE9VUiA6XG4gICAgICAgICAgICAgICAgICBhW01JTlVURV0gICAgICA8IDAgfHwgYVtNSU5VVEVdICAgICAgPiA1OSAgPyBNSU5VVEUgOlxuICAgICAgICAgICAgICAgICAgYVtTRUNPTkRdICAgICAgPCAwIHx8IGFbU0VDT05EXSAgICAgID4gNTkgID8gU0VDT05EIDpcbiAgICAgICAgICAgICAgICAgIGFbTUlMTElTRUNPTkRdIDwgMCB8fCBhW01JTExJU0VDT05EXSA+IDk5OSA/IE1JTExJU0VDT05EIDpcbiAgICAgICAgICAgICAgICAgIC0xO1xuXG4gICAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93RGF5T2ZZZWFyICYmIChvdmVyZmxvdyA8IFlFQVIgfHwgb3ZlcmZsb3cgPiBEQVRFKSkge1xuICAgICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBEQVRFO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla3MgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IFdFRUs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrZGF5ICYmIG92ZXJmbG93ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLREFZO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG07XG4gICAgICB9XG5cbiAgICAgIC8vIGlzbyA4NjAxIHJlZ2V4XG4gICAgICAvLyAwMDAwLTAwLTAwIDAwMDAtVzAwIG9yIDAwMDAtVzAwLTAgKyBUICsgMDAgb3IgMDA6MDAgb3IgMDA6MDA6MDAgb3IgMDA6MDA6MDAuMDAwICsgKzAwOjAwIG9yICswMDAwIG9yICswMClcbiAgICAgIHZhciBleHRlbmRlZElzb1JlZ2V4ID0gL15cXHMqKCg/OlsrLV1cXGR7Nn18XFxkezR9KS0oPzpcXGRcXGQtXFxkXFxkfFdcXGRcXGQtXFxkfFdcXGRcXGR8XFxkXFxkXFxkfFxcZFxcZCkpKD86KFR8ICkoXFxkXFxkKD86OlxcZFxcZCg/OjpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoW1xcK1xcLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPy87XG4gICAgICB2YXIgYmFzaWNJc29SZWdleCA9IC9eXFxzKigoPzpbKy1dXFxkezZ9fFxcZHs0fSkoPzpcXGRcXGRcXGRcXGR8V1xcZFxcZFxcZHxXXFxkXFxkfFxcZFxcZFxcZHxcXGRcXGQpKSg/OihUfCApKFxcZFxcZCg/OlxcZFxcZCg/OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbXFwrXFwtXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/LztcblxuICAgICAgdmFyIHR6UmVnZXggPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy87XG5cbiAgICAgIHZhciBpc29EYXRlcyA9IFtcbiAgICAgICAgICBbJ1lZWVlZWS1NTS1ERCcsIC9bKy1dXFxkezZ9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICAgICAgICBbJ1lZWVktTU0tREQnLCAvXFxkezR9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICAgICAgICBbJ0dHR0ctW1ddV1ctRScsIC9cXGR7NH0tV1xcZFxcZC1cXGQvXSxcbiAgICAgICAgICBbJ0dHR0ctW1ddV1cnLCAvXFxkezR9LVdcXGRcXGQvLCBmYWxzZV0sXG4gICAgICAgICAgWydZWVlZLURERCcsIC9cXGR7NH0tXFxkezN9L10sXG4gICAgICAgICAgWydZWVlZLU1NJywgL1xcZHs0fS1cXGRcXGQvLCBmYWxzZV0sXG4gICAgICAgICAgWydZWVlZWVlNTUREJywgL1srLV1cXGR7MTB9L10sXG4gICAgICAgICAgWydZWVlZTU1ERCcsIC9cXGR7OH0vXSxcbiAgICAgICAgICAvLyBZWVlZTU0gaXMgTk9UIGFsbG93ZWQgYnkgdGhlIHN0YW5kYXJkXG4gICAgICAgICAgWydHR0dHW1ddV1dFJywgL1xcZHs0fVdcXGR7M30vXSxcbiAgICAgICAgICBbJ0dHR0dbV11XVycsIC9cXGR7NH1XXFxkezJ9LywgZmFsc2VdLFxuICAgICAgICAgIFsnWVlZWURERCcsIC9cXGR7N30vXVxuICAgICAgXTtcblxuICAgICAgLy8gaXNvIHRpbWUgZm9ybWF0cyBhbmQgcmVnZXhlc1xuICAgICAgdmFyIGlzb1RpbWVzID0gW1xuICAgICAgICAgIFsnSEg6bW06c3MuU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZFxcLlxcZCsvXSxcbiAgICAgICAgICBbJ0hIOm1tOnNzLFNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQsXFxkKy9dLFxuICAgICAgICAgIFsnSEg6bW06c3MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgICBbJ0hIOm1tJywgL1xcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgICBbJ0hIbW1zcy5TU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZFxcLlxcZCsvXSxcbiAgICAgICAgICBbJ0hIbW1zcyxTU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZCxcXGQrL10sXG4gICAgICAgICAgWydISG1tc3MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkL10sXG4gICAgICAgICAgWydISG1tJywgL1xcZFxcZFxcZFxcZC9dLFxuICAgICAgICAgIFsnSEgnLCAvXFxkXFxkL11cbiAgICAgIF07XG5cbiAgICAgIHZhciBhc3BOZXRKc29uUmVnZXggPSAvXlxcLz9EYXRlXFwoKFxcLT9cXGQrKS9pO1xuXG4gICAgICAvLyBkYXRlIGZyb20gaXNvIGZvcm1hdFxuICAgICAgZnVuY3Rpb24gY29uZmlnRnJvbUlTTyhjb25maWcpIHtcbiAgICAgICAgICB2YXIgaSwgbCxcbiAgICAgICAgICAgICAgc3RyaW5nID0gY29uZmlnLl9pLFxuICAgICAgICAgICAgICBtYXRjaCA9IGV4dGVuZGVkSXNvUmVnZXguZXhlYyhzdHJpbmcpIHx8IGJhc2ljSXNvUmVnZXguZXhlYyhzdHJpbmcpLFxuICAgICAgICAgICAgICBhbGxvd1RpbWUsIGRhdGVGb3JtYXQsIHRpbWVGb3JtYXQsIHR6Rm9ybWF0O1xuXG4gICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmlzbyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb0RhdGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgaWYgKGlzb0RhdGVzW2ldWzFdLmV4ZWMobWF0Y2hbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGF0ZUZvcm1hdCA9IGlzb0RhdGVzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICAgIGFsbG93VGltZSA9IGlzb0RhdGVzW2ldWzJdICE9PSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZGF0ZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobWF0Y2hbM10pIHtcbiAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29UaW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNvVGltZXNbaV1bMV0uZXhlYyhtYXRjaFszXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2hbMl0gc2hvdWxkIGJlICdUJyBvciBzcGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lRm9ybWF0ID0gKG1hdGNoWzJdIHx8ICcgJykgKyBpc29UaW1lc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHRpbWVGb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWFsbG93VGltZSAmJiB0aW1lRm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChtYXRjaFs0XSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR6UmVnZXguZXhlYyhtYXRjaFs0XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0ekZvcm1hdCA9ICdaJztcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbmZpZy5fZiA9IGRhdGVGb3JtYXQgKyAodGltZUZvcm1hdCB8fCAnJykgKyAodHpGb3JtYXQgfHwgJycpO1xuICAgICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBkYXRlIGZyb20gaXNvIGZvcm1hdCBvciBmYWxsYmFja1xuICAgICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZyhjb25maWcpIHtcbiAgICAgICAgICB2YXIgbWF0Y2hlZCA9IGFzcE5ldEpzb25SZWdleC5leGVjKGNvbmZpZy5faSk7XG5cbiAgICAgICAgICBpZiAobWF0Y2hlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgrbWF0Y2hlZFsxXSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgICAgICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5faXNWYWxpZDtcbiAgICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB1dGlsc19ob29rc19faG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2sgPSBkZXByZWNhdGUoXG4gICAgICAgICAgJ21vbWVudCBjb25zdHJ1Y3Rpb24gZmFsbHMgYmFjayB0byBqcyBEYXRlLiBUaGlzIGlzICcgK1xuICAgICAgICAgICdkaXNjb3VyYWdlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHVwY29taW5nIG1ham9yICcgK1xuICAgICAgICAgICdyZWxlYXNlLiBQbGVhc2UgcmVmZXIgdG8gJyArXG4gICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNDA3IGZvciBtb3JlIGluZm8uJyxcbiAgICAgICAgICBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5faSArIChjb25maWcuX3VzZVVUQyA/ICcgVVRDJyA6ICcnKSk7XG4gICAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgZnVuY3Rpb24gY3JlYXRlRGF0ZSAoeSwgbSwgZCwgaCwgTSwgcywgbXMpIHtcbiAgICAgICAgICAvL2Nhbid0IGp1c3QgYXBwbHkoKSB0byBjcmVhdGUgYSBkYXRlOlxuICAgICAgICAgIC8vaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xODEzNDgvaW5zdGFudGlhdGluZy1hLWphdmFzY3JpcHQtb2JqZWN0LWJ5LWNhbGxpbmctcHJvdG90eXBlLWNvbnN0cnVjdG9yLWFwcGx5XG4gICAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh5LCBtLCBkLCBoLCBNLCBzLCBtcyk7XG5cbiAgICAgICAgICAvL3RoZSBkYXRlIGNvbnN0cnVjdG9yIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCAmJiBpc0Zpbml0ZShkYXRlLmdldEZ1bGxZZWFyKCkpKSB7XG4gICAgICAgICAgICAgIGRhdGUuc2V0RnVsbFllYXIoeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjcmVhdGVVVENEYXRlICh5KSB7XG4gICAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQy5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcblxuICAgICAgICAgIC8vdGhlIERhdGUuVVRDIGZ1bmN0aW9uIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCAmJiBpc0Zpbml0ZShkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpKSB7XG4gICAgICAgICAgICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgfVxuXG4gICAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICAgIGFkZEZvcm1hdFRva2VuKCdZJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciB5ID0gdGhpcy55ZWFyKCk7XG4gICAgICAgICAgcmV0dXJuIHkgPD0gOTk5OSA/ICcnICsgeSA6ICcrJyArIHk7XG4gICAgICB9KTtcblxuICAgICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWScsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMueWVhcigpICUgMTAwO1xuICAgICAgfSk7XG5cbiAgICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWScsICAgNF0sICAgICAgIDAsICd5ZWFyJyk7XG4gICAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZJywgIDVdLCAgICAgICAwLCAneWVhcicpO1xuICAgICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWVknLCA2LCB0cnVlXSwgMCwgJ3llYXInKTtcblxuICAgICAgLy8gQUxJQVNFU1xuXG4gICAgICBhZGRVbml0QWxpYXMoJ3llYXInLCAneScpO1xuXG4gICAgICAvLyBQQVJTSU5HXG5cbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ1knLCAgICAgIG1hdGNoU2lnbmVkKTtcbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ1lZJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVknLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVlZJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVlZWScsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuICAgICAgYWRkUGFyc2VUb2tlbihbJ1lZWVlZJywgJ1lZWVlZWSddLCBZRUFSKTtcbiAgICAgIGFkZFBhcnNlVG9rZW4oJ1lZWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgICAgYXJyYXlbWUVBUl0gPSBpbnB1dC5sZW5ndGggPT09IDIgPyB1dGlsc19ob29rc19faG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpIDogdG9JbnQoaW5wdXQpO1xuICAgICAgfSk7XG4gICAgICBhZGRQYXJzZVRva2VuKCdZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgICBhcnJheVtZRUFSXSA9IHV0aWxzX2hvb2tzX19ob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgICB9KTtcbiAgICAgIGFkZFBhcnNlVG9rZW4oJ1knLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgICAgYXJyYXlbWUVBUl0gPSBwYXJzZUludChpbnB1dCwgMTApO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEhFTFBFUlNcblxuICAgICAgZnVuY3Rpb24gZGF5c0luWWVhcih5ZWFyKSB7XG4gICAgICAgICAgcmV0dXJuIGlzTGVhcFllYXIoeWVhcikgPyAzNjYgOiAzNjU7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuICAgICAgICAgIHJldHVybiAoeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCkgfHwgeWVhciAlIDQwMCA9PT0gMDtcbiAgICAgIH1cblxuICAgICAgLy8gSE9PS1NcblxuICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnBhcnNlVHdvRGlnaXRZZWFyID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgcmV0dXJuIHRvSW50KGlucHV0KSArICh0b0ludChpbnB1dCkgPiA2OCA/IDE5MDAgOiAyMDAwKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIE1PTUVOVFNcblxuICAgICAgdmFyIGdldFNldFllYXIgPSBtYWtlR2V0U2V0KCdGdWxsWWVhcicsIHRydWUpO1xuXG4gICAgICBmdW5jdGlvbiBnZXRJc0xlYXBZZWFyICgpIHtcbiAgICAgICAgICByZXR1cm4gaXNMZWFwWWVhcih0aGlzLnllYXIoKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHN0YXJ0LW9mLWZpcnN0LXdlZWsgLSBzdGFydC1vZi15ZWFyXG4gICAgICBmdW5jdGlvbiBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpIHtcbiAgICAgICAgICB2YXIgLy8gZmlyc3Qtd2VlayBkYXkgLS0gd2hpY2ggamFudWFyeSBpcyBhbHdheXMgaW4gdGhlIGZpcnN0IHdlZWsgKDQgZm9yIGlzbywgMSBmb3Igb3RoZXIpXG4gICAgICAgICAgICAgIGZ3ZCA9IDcgKyBkb3cgLSBkb3ksXG4gICAgICAgICAgICAgIC8vIGZpcnN0LXdlZWsgZGF5IGxvY2FsIHdlZWtkYXkgLS0gd2hpY2ggbG9jYWwgd2Vla2RheSBpcyBmd2RcbiAgICAgICAgICAgICAgZndkbHcgPSAoNyArIGNyZWF0ZVVUQ0RhdGUoeWVhciwgMCwgZndkKS5nZXRVVENEYXkoKSAtIGRvdykgJSA3O1xuXG4gICAgICAgICAgcmV0dXJuIC1md2RsdyArIGZ3ZCAtIDE7XG4gICAgICB9XG5cbiAgICAgIC8vaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlI0NhbGN1bGF0aW5nX2FfZGF0ZV9naXZlbl90aGVfeWVhci4yQ193ZWVrX251bWJlcl9hbmRfd2Vla2RheVxuICAgICAgZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtzKHllYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgICAgdmFyIGxvY2FsV2Vla2RheSA9ICg3ICsgd2Vla2RheSAtIGRvdykgJSA3LFxuICAgICAgICAgICAgICB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcbiAgICAgICAgICAgICAgZGF5T2ZZZWFyID0gMSArIDcgKiAod2VlayAtIDEpICsgbG9jYWxXZWVrZGF5ICsgd2Vla09mZnNldCxcbiAgICAgICAgICAgICAgcmVzWWVhciwgcmVzRGF5T2ZZZWFyO1xuXG4gICAgICAgICAgaWYgKGRheU9mWWVhciA8PSAwKSB7XG4gICAgICAgICAgICAgIHJlc1llYXIgPSB5ZWFyIC0gMTtcbiAgICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5c0luWWVhcihyZXNZZWFyKSArIGRheU9mWWVhcjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGRheU9mWWVhciA+IGRheXNJblllYXIoeWVhcikpIHtcbiAgICAgICAgICAgICAgcmVzWWVhciA9IHllYXIgKyAxO1xuICAgICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXIgLSBkYXlzSW5ZZWFyKHllYXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc1llYXIgPSB5ZWFyO1xuICAgICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgeWVhcjogcmVzWWVhcixcbiAgICAgICAgICAgICAgZGF5T2ZZZWFyOiByZXNEYXlPZlllYXJcbiAgICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB3ZWVrT2ZZZWFyKG1vbSwgZG93LCBkb3kpIHtcbiAgICAgICAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldChtb20ueWVhcigpLCBkb3csIGRveSksXG4gICAgICAgICAgICAgIHdlZWsgPSBNYXRoLmZsb29yKChtb20uZGF5T2ZZZWFyKCkgLSB3ZWVrT2Zmc2V0IC0gMSkgLyA3KSArIDEsXG4gICAgICAgICAgICAgIHJlc1dlZWssIHJlc1llYXI7XG5cbiAgICAgICAgICBpZiAod2VlayA8IDEpIHtcbiAgICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCkgLSAxO1xuICAgICAgICAgICAgICByZXNXZWVrID0gd2VlayArIHdlZWtzSW5ZZWFyKHJlc1llYXIsIGRvdywgZG95KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHdlZWsgPiB3ZWVrc0luWWVhcihtb20ueWVhcigpLCBkb3csIGRveSkpIHtcbiAgICAgICAgICAgICAgcmVzV2VlayA9IHdlZWsgLSB3ZWVrc0luWWVhcihtb20ueWVhcigpLCBkb3csIGRveSk7XG4gICAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpICsgMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKTtcbiAgICAgICAgICAgICAgcmVzV2VlayA9IHdlZWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgd2VlazogcmVzV2VlayxcbiAgICAgICAgICAgICAgeWVhcjogcmVzWWVhclxuICAgICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHdlZWtzSW5ZZWFyKHllYXIsIGRvdywgZG95KSB7XG4gICAgICAgICAgdmFyIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpLFxuICAgICAgICAgICAgICB3ZWVrT2Zmc2V0TmV4dCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyICsgMSwgZG93LCBkb3kpO1xuICAgICAgICAgIHJldHVybiAoZGF5c0luWWVhcih5ZWFyKSAtIHdlZWtPZmZzZXQgKyB3ZWVrT2Zmc2V0TmV4dCkgLyA3O1xuICAgICAgfVxuXG4gICAgICAvLyBQaWNrIHRoZSBmaXJzdCBkZWZpbmVkIG9mIHR3byBvciB0aHJlZSBhcmd1bWVudHMuXG4gICAgICBmdW5jdGlvbiBkZWZhdWx0cyhhLCBiLCBjKSB7XG4gICAgICAgICAgaWYgKGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGM7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGN1cnJlbnREYXRlQXJyYXkoY29uZmlnKSB7XG4gICAgICAgICAgLy8gaG9va3MgaXMgYWN0dWFsbHkgdGhlIGV4cG9ydGVkIG1vbWVudCBvYmplY3RcbiAgICAgICAgICB2YXIgbm93VmFsdWUgPSBuZXcgRGF0ZSh1dGlsc19ob29rc19faG9va3Mubm93KCkpO1xuICAgICAgICAgIGlmIChjb25maWcuX3VzZVVUQykge1xuICAgICAgICAgICAgICByZXR1cm4gW25vd1ZhbHVlLmdldFVUQ0Z1bGxZZWFyKCksIG5vd1ZhbHVlLmdldFVUQ01vbnRoKCksIG5vd1ZhbHVlLmdldFVUQ0RhdGUoKV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbbm93VmFsdWUuZ2V0RnVsbFllYXIoKSwgbm93VmFsdWUuZ2V0TW9udGgoKSwgbm93VmFsdWUuZ2V0RGF0ZSgpXTtcbiAgICAgIH1cblxuICAgICAgLy8gY29udmVydCBhbiBhcnJheSB0byBhIGRhdGUuXG4gICAgICAvLyB0aGUgYXJyYXkgc2hvdWxkIG1pcnJvciB0aGUgcGFyYW1ldGVycyBiZWxvd1xuICAgICAgLy8gbm90ZTogYWxsIHZhbHVlcyBwYXN0IHRoZSB5ZWFyIGFyZSBvcHRpb25hbCBhbmQgd2lsbCBkZWZhdWx0IHRvIHRoZSBsb3dlc3QgcG9zc2libGUgdmFsdWUuXG4gICAgICAvLyBbeWVhciwgbW9udGgsIGRheSAsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZF1cbiAgICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21BcnJheSAoY29uZmlnKSB7XG4gICAgICAgICAgdmFyIGksIGRhdGUsIGlucHV0ID0gW10sIGN1cnJlbnREYXRlLCB5ZWFyVG9Vc2U7XG5cbiAgICAgICAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdXJyZW50RGF0ZSA9IGN1cnJlbnREYXRlQXJyYXkoY29uZmlnKTtcblxuICAgICAgICAgIC8vY29tcHV0ZSBkYXkgb2YgdGhlIHllYXIgZnJvbSB3ZWVrcyBhbmQgd2Vla2RheXNcbiAgICAgICAgICBpZiAoY29uZmlnLl93ICYmIGNvbmZpZy5fYVtEQVRFXSA9PSBudWxsICYmIGNvbmZpZy5fYVtNT05USF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvL2lmIHRoZSBkYXkgb2YgdGhlIHllYXIgaXMgc2V0LCBmaWd1cmUgb3V0IHdoYXQgaXQgaXNcbiAgICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIpIHtcbiAgICAgICAgICAgICAgeWVhclRvVXNlID0gZGVmYXVsdHMoY29uZmlnLl9hW1lFQVJdLCBjdXJyZW50RGF0ZVtZRUFSXSk7XG5cbiAgICAgICAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyVG9Vc2UpKSB7XG4gICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dEYXlPZlllYXIgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZGF0ZSA9IGNyZWF0ZVVUQ0RhdGUoeWVhclRvVXNlLCAwLCBjb25maWcuX2RheU9mWWVhcik7XG4gICAgICAgICAgICAgIGNvbmZpZy5fYVtNT05USF0gPSBkYXRlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICAgIGNvbmZpZy5fYVtEQVRFXSA9IGRhdGUuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCBkYXRlLlxuICAgICAgICAgIC8vICogaWYgbm8geWVhciwgbW9udGgsIGRheSBvZiBtb250aCBhcmUgZ2l2ZW4sIGRlZmF1bHQgdG8gdG9kYXlcbiAgICAgICAgICAvLyAqIGlmIGRheSBvZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBtb250aCBhbmQgeWVhclxuICAgICAgICAgIC8vICogaWYgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgb25seSB5ZWFyXG4gICAgICAgICAgLy8gKiBpZiB5ZWFyIGlzIGdpdmVuLCBkb24ndCBkZWZhdWx0IGFueXRoaW5nXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IDMgJiYgY29uZmlnLl9hW2ldID09IG51bGw7ICsraSkge1xuICAgICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IGN1cnJlbnREYXRlW2ldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFplcm8gb3V0IHdoYXRldmVyIHdhcyBub3QgZGVmYXVsdGVkLCBpbmNsdWRpbmcgdGltZVxuICAgICAgICAgIGZvciAoOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID0gKGNvbmZpZy5fYVtpXSA9PSBudWxsKSA/IChpID09PSAyID8gMSA6IDApIDogY29uZmlnLl9hW2ldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENoZWNrIGZvciAyNDowMDowMC4wMDBcbiAgICAgICAgICBpZiAoY29uZmlnLl9hW0hPVVJdID09PSAyNCAmJlxuICAgICAgICAgICAgICAgICAgY29uZmlnLl9hW01JTlVURV0gPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtTRUNPTkRdID09PSAwICYmXG4gICAgICAgICAgICAgICAgICBjb25maWcuX2FbTUlMTElTRUNPTkRdID09PSAwKSB7XG4gICAgICAgICAgICAgIGNvbmZpZy5fbmV4dERheSA9IHRydWU7XG4gICAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uZmlnLl9kID0gKGNvbmZpZy5fdXNlVVRDID8gY3JlYXRlVVRDRGF0ZSA6IGNyZWF0ZURhdGUpLmFwcGx5KG51bGwsIGlucHV0KTtcbiAgICAgICAgICAvLyBBcHBseSB0aW1lem9uZSBvZmZzZXQgZnJvbSBpbnB1dC4gVGhlIGFjdHVhbCB1dGNPZmZzZXQgY2FuIGJlIGNoYW5nZWRcbiAgICAgICAgICAvLyB3aXRoIHBhcnNlWm9uZS5cbiAgICAgICAgICBpZiAoY29uZmlnLl90em0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjb25maWcuX25leHREYXkpIHtcbiAgICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMjQ7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKSB7XG4gICAgICAgICAgdmFyIHcsIHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSwgdGVtcCwgd2Vla2RheU92ZXJmbG93O1xuXG4gICAgICAgICAgdyA9IGNvbmZpZy5fdztcbiAgICAgICAgICBpZiAody5HRyAhPSBudWxsIHx8IHcuVyAhPSBudWxsIHx8IHcuRSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGRvdyA9IDE7XG4gICAgICAgICAgICAgIGRveSA9IDQ7XG5cbiAgICAgICAgICAgICAgLy8gVE9ETzogV2UgbmVlZCB0byB0YWtlIHRoZSBjdXJyZW50IGlzb1dlZWtZZWFyLCBidXQgdGhhdCBkZXBlbmRzIG9uXG4gICAgICAgICAgICAgIC8vIGhvdyB3ZSBpbnRlcnByZXQgbm93IChsb2NhbCwgdXRjLCBmaXhlZCBvZmZzZXQpLiBTbyBjcmVhdGVcbiAgICAgICAgICAgICAgLy8gYSBub3cgdmVyc2lvbiBvZiBjdXJyZW50IGNvbmZpZyAodGFrZSBsb2NhbC91dGMvb2Zmc2V0IGZsYWdzLCBhbmRcbiAgICAgICAgICAgICAgLy8gY3JlYXRlIG5vdykuXG4gICAgICAgICAgICAgIHdlZWtZZWFyID0gZGVmYXVsdHMody5HRywgY29uZmlnLl9hW1lFQVJdLCB3ZWVrT2ZZZWFyKGxvY2FsX19jcmVhdGVMb2NhbCgpLCAxLCA0KS55ZWFyKTtcbiAgICAgICAgICAgICAgd2VlayA9IGRlZmF1bHRzKHcuVywgMSk7XG4gICAgICAgICAgICAgIHdlZWtkYXkgPSBkZWZhdWx0cyh3LkUsIDEpO1xuICAgICAgICAgICAgICBpZiAod2Vla2RheSA8IDEgfHwgd2Vla2RheSA+IDcpIHtcbiAgICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkb3cgPSBjb25maWcuX2xvY2FsZS5fd2Vlay5kb3c7XG4gICAgICAgICAgICAgIGRveSA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRveTtcblxuICAgICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuZ2csIGNvbmZpZy5fYVtZRUFSXSwgd2Vla09mWWVhcihsb2NhbF9fY3JlYXRlTG9jYWwoKSwgZG93LCBkb3kpLnllYXIpO1xuICAgICAgICAgICAgICB3ZWVrID0gZGVmYXVsdHMody53LCAxKTtcblxuICAgICAgICAgICAgICBpZiAody5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIC8vIHdlZWtkYXkgLS0gbG93IGRheSBudW1iZXJzIGFyZSBjb25zaWRlcmVkIG5leHQgd2Vla1xuICAgICAgICAgICAgICAgICAgd2Vla2RheSA9IHcuZDtcbiAgICAgICAgICAgICAgICAgIGlmICh3ZWVrZGF5IDwgMCB8fCB3ZWVrZGF5ID4gNikge1xuICAgICAgICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAody5lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGxvY2FsIHdlZWtkYXkgLS0gY291bnRpbmcgc3RhcnRzIGZyb20gYmVnaW5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgICAgICAgd2Vla2RheSA9IHcuZSArIGRvdztcbiAgICAgICAgICAgICAgICAgIGlmICh3LmUgPCAwIHx8IHcuZSA+IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gZGVmYXVsdCB0byBiZWdpbmluZyBvZiB3ZWVrXG4gICAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gZG93O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh3ZWVrIDwgMSB8fCB3ZWVrID4gd2Vla3NJblllYXIod2Vla1llYXIsIGRvdywgZG95KSkge1xuICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dXZWVrcyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmICh3ZWVrZGF5T3ZlcmZsb3cgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dXZWVrZGF5ID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0ZW1wID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XG4gICAgICAgICAgICAgIGNvbmZpZy5fYVtZRUFSXSA9IHRlbXAueWVhcjtcbiAgICAgICAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0ZW1wLmRheU9mWWVhcjtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGNvbnN0YW50IHRoYXQgcmVmZXJzIHRvIHRoZSBJU08gc3RhbmRhcmRcbiAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5JU09fODYwMSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgICAvLyBkYXRlIGZyb20gc3RyaW5nIGFuZCBmb3JtYXQgc3RyaW5nXG4gICAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZykge1xuICAgICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyB0byBhbm90aGVyIHBhcnQgb2YgdGhlIGNyZWF0aW9uIGZsb3cgdG8gcHJldmVudCBjaXJjdWxhciBkZXBzXG4gICAgICAgICAgaWYgKGNvbmZpZy5fZiA9PT0gdXRpbHNfaG9va3NfX2hvb2tzLklTT184NjAxKSB7XG4gICAgICAgICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbmZpZy5fYSA9IFtdO1xuICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gdHJ1ZTtcblxuICAgICAgICAgIC8vIFRoaXMgYXJyYXkgaXMgdXNlZCB0byBtYWtlIGEgRGF0ZSwgZWl0aGVyIHdpdGggYG5ldyBEYXRlYCBvciBgRGF0ZS5VVENgXG4gICAgICAgICAgdmFyIHN0cmluZyA9ICcnICsgY29uZmlnLl9pLFxuICAgICAgICAgICAgICBpLCBwYXJzZWRJbnB1dCwgdG9rZW5zLCB0b2tlbiwgc2tpcHBlZCxcbiAgICAgICAgICAgICAgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCA9IDA7XG5cbiAgICAgICAgICB0b2tlbnMgPSBleHBhbmRGb3JtYXQoY29uZmlnLl9mLCBjb25maWcuX2xvY2FsZSkubWF0Y2goZm9ybWF0dGluZ1Rva2VucykgfHwgW107XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgICBwYXJzZWRJbnB1dCA9IChzdHJpbmcubWF0Y2goZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpKSB8fCBbXSlbMF07XG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCd0b2tlbicsIHRva2VuLCAncGFyc2VkSW5wdXQnLCBwYXJzZWRJbnB1dCxcbiAgICAgICAgICAgICAgLy8gICAgICAgICAncmVnZXgnLCBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykpO1xuICAgICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgIHNraXBwZWQgPSBzdHJpbmcuc3Vic3RyKDAsIHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSk7XG4gICAgICAgICAgICAgICAgICBpZiAoc2tpcHBlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChza2lwcGVkKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5zbGljZShzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkgKyBwYXJzZWRJbnB1dC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCArPSBwYXJzZWRJbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gZG9uJ3QgcGFyc2UgaWYgaXQncyBub3QgYSBrbm93biB0b2tlblxuICAgICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dKSB7XG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIHBhcnNlZElucHV0LCBjb25maWcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGNvbmZpZy5fc3RyaWN0ICYmICFwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gYWRkIHJlbWFpbmluZyB1bnBhcnNlZCBpbnB1dCBsZW5ndGggdG8gdGhlIHN0cmluZ1xuICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmNoYXJzTGVmdE92ZXIgPSBzdHJpbmdMZW5ndGggLSB0b3RhbFBhcnNlZElucHV0TGVuZ3RoO1xuICAgICAgICAgIGlmIChzdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHN0cmluZyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gY2xlYXIgXzEyaCBmbGFnIGlmIGhvdXIgaXMgPD0gMTJcbiAgICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdIDw9IDEyICYmXG4gICAgICAgICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPiAwKSB7XG4gICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykucGFyc2VkRGF0ZVBhcnRzID0gY29uZmlnLl9hLnNsaWNlKDApO1xuICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLm1lcmlkaWVtID0gY29uZmlnLl9tZXJpZGllbTtcbiAgICAgICAgICAvLyBoYW5kbGUgbWVyaWRpZW1cbiAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPSBtZXJpZGllbUZpeFdyYXAoY29uZmlnLl9sb2NhbGUsIGNvbmZpZy5fYVtIT1VSXSwgY29uZmlnLl9tZXJpZGllbSk7XG5cbiAgICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICAgICAgICBjaGVja092ZXJmbG93KGNvbmZpZyk7XG4gICAgICB9XG5cblxuICAgICAgZnVuY3Rpb24gbWVyaWRpZW1GaXhXcmFwIChsb2NhbGUsIGhvdXIsIG1lcmlkaWVtKSB7XG4gICAgICAgICAgdmFyIGlzUG07XG5cbiAgICAgICAgICBpZiAobWVyaWRpZW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBub3RoaW5nIHRvIGRvXG4gICAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobG9jYWxlLm1lcmlkaWVtSG91ciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBsb2NhbGUubWVyaWRpZW1Ib3VyKGhvdXIsIG1lcmlkaWVtKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxvY2FsZS5pc1BNICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gRmFsbGJhY2tcbiAgICAgICAgICAgICAgaXNQbSA9IGxvY2FsZS5pc1BNKG1lcmlkaWVtKTtcbiAgICAgICAgICAgICAgaWYgKGlzUG0gJiYgaG91ciA8IDEyKSB7XG4gICAgICAgICAgICAgICAgICBob3VyICs9IDEyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghaXNQbSAmJiBob3VyID09PSAxMikge1xuICAgICAgICAgICAgICAgICAgaG91ciA9IDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gdGhpcyBpcyBub3Qgc3VwcG9zZWQgdG8gaGFwcGVuXG4gICAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgYXJyYXkgb2YgZm9ybWF0IHN0cmluZ3NcbiAgICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpIHtcbiAgICAgICAgICB2YXIgdGVtcENvbmZpZyxcbiAgICAgICAgICAgICAgYmVzdE1vbWVudCxcblxuICAgICAgICAgICAgICBzY29yZVRvQmVhdCxcbiAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgY3VycmVudFNjb3JlO1xuXG4gICAgICAgICAgaWYgKGNvbmZpZy5fZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZEZvcm1hdCA9IHRydWU7XG4gICAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKE5hTik7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29uZmlnLl9mLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRTY29yZSA9IDA7XG4gICAgICAgICAgICAgIHRlbXBDb25maWcgPSBjb3B5Q29uZmlnKHt9LCBjb25maWcpO1xuICAgICAgICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgdGVtcENvbmZpZy5fdXNlVVRDID0gY29uZmlnLl91c2VVVEM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGVtcENvbmZpZy5fZiA9IGNvbmZpZy5fZltpXTtcbiAgICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdCh0ZW1wQ29uZmlnKTtcblxuICAgICAgICAgICAgICBpZiAoIXZhbGlkX19pc1ZhbGlkKHRlbXBDb25maWcpKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFueSBpbnB1dCB0aGF0IHdhcyBub3QgcGFyc2VkIGFkZCBhIHBlbmFsdHkgZm9yIHRoYXQgZm9ybWF0XG4gICAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuY2hhcnNMZWZ0T3ZlcjtcblxuICAgICAgICAgICAgICAvL29yIHRva2Vuc1xuICAgICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnVudXNlZFRva2Vucy5sZW5ndGggKiAxMDtcblxuICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuc2NvcmUgPSBjdXJyZW50U2NvcmU7XG5cbiAgICAgICAgICAgICAgaWYgKHNjb3JlVG9CZWF0ID09IG51bGwgfHwgY3VycmVudFNjb3JlIDwgc2NvcmVUb0JlYXQpIHtcbiAgICAgICAgICAgICAgICAgIHNjb3JlVG9CZWF0ID0gY3VycmVudFNjb3JlO1xuICAgICAgICAgICAgICAgICAgYmVzdE1vbWVudCA9IHRlbXBDb25maWc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHRlbmQoY29uZmlnLCBiZXN0TW9tZW50IHx8IHRlbXBDb25maWcpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjb25maWdGcm9tT2JqZWN0KGNvbmZpZykge1xuICAgICAgICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBpID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoY29uZmlnLl9pKTtcbiAgICAgICAgICBjb25maWcuX2EgPSBtYXAoW2kueWVhciwgaS5tb250aCwgaS5kYXkgfHwgaS5kYXRlLCBpLmhvdXIsIGkubWludXRlLCBpLnNlY29uZCwgaS5taWxsaXNlY29uZF0sIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiBwYXJzZUludChvYmosIDEwKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjcmVhdGVGcm9tQ29uZmlnIChjb25maWcpIHtcbiAgICAgICAgICB2YXIgcmVzID0gbmV3IE1vbWVudChjaGVja092ZXJmbG93KHByZXBhcmVDb25maWcoY29uZmlnKSkpO1xuICAgICAgICAgIGlmIChyZXMuX25leHREYXkpIHtcbiAgICAgICAgICAgICAgLy8gQWRkaW5nIGlzIHNtYXJ0IGVub3VnaCBhcm91bmQgRFNUXG4gICAgICAgICAgICAgIHJlcy5hZGQoMSwgJ2QnKTtcbiAgICAgICAgICAgICAgcmVzLl9uZXh0RGF5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHByZXBhcmVDb25maWcgKGNvbmZpZykge1xuICAgICAgICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faSxcbiAgICAgICAgICAgICAgZm9ybWF0ID0gY29uZmlnLl9mO1xuXG4gICAgICAgICAgY29uZmlnLl9sb2NhbGUgPSBjb25maWcuX2xvY2FsZSB8fCBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKGNvbmZpZy5fbCk7XG5cbiAgICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgKGZvcm1hdCA9PT0gdW5kZWZpbmVkICYmIGlucHV0ID09PSAnJykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkX19jcmVhdGVJbnZhbGlkKHtudWxsSW5wdXQ6IHRydWV9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb25maWcuX2kgPSBpbnB1dCA9IGNvbmZpZy5fbG9jYWxlLnByZXBhcnNlKGlucHV0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNNb21lbnQoaW5wdXQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3coaW5wdXQpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZm9ybWF0KSkge1xuICAgICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCkge1xuICAgICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XG4gICAgICAgICAgICAgIGNvbmZpZy5fZCA9IGlucHV0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghdmFsaWRfX2lzVmFsaWQoY29uZmlnKSkge1xuICAgICAgICAgICAgICBjb25maWcuX2QgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb25maWc7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpIHtcbiAgICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2k7XG4gICAgICAgICAgaWYgKGlucHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUodXRpbHNfaG9va3NfX2hvb2tzLm5vdygpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQudmFsdWVPZigpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZyhjb25maWcpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgICAgY29uZmlnLl9hID0gbWFwKGlucHV0LnNsaWNlKDApLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZihpbnB1dCkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgIGNvbmZpZ0Zyb21PYmplY3QoY29uZmlnKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZihpbnB1dCkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgIC8vIGZyb20gbWlsbGlzZWNvbmRzXG4gICAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZUxvY2FsT3JVVEMgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBpc1VUQykge1xuICAgICAgICAgIHZhciBjID0ge307XG5cbiAgICAgICAgICBpZiAodHlwZW9mKGxvY2FsZSkgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICBzdHJpY3QgPSBsb2NhbGU7XG4gICAgICAgICAgICAgIGxvY2FsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gb2JqZWN0IGNvbnN0cnVjdGlvbiBtdXN0IGJlIGRvbmUgdGhpcyB3YXkuXG4gICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE0MjNcbiAgICAgICAgICBjLl9pc0FNb21lbnRPYmplY3QgPSB0cnVlO1xuICAgICAgICAgIGMuX3VzZVVUQyA9IGMuX2lzVVRDID0gaXNVVEM7XG4gICAgICAgICAgYy5fbCA9IGxvY2FsZTtcbiAgICAgICAgICBjLl9pID0gaW5wdXQ7XG4gICAgICAgICAgYy5fZiA9IGZvcm1hdDtcbiAgICAgICAgICBjLl9zdHJpY3QgPSBzdHJpY3Q7XG5cbiAgICAgICAgICByZXR1cm4gY3JlYXRlRnJvbUNvbmZpZyhjKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbG9jYWxfX2NyZWF0ZUxvY2FsIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm90b3R5cGVNaW4gPSBkZXByZWNhdGUoXG4gICAgICAgICAgICdtb21lbnQoKS5taW4gaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5tYXggaW5zdGVhZC4gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE1NDgnLFxuICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBsb2NhbF9fY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXIgPCB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRfX2NyZWF0ZUludmFsaWQoKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuICAgICAgICk7XG5cbiAgICAgIHZhciBwcm90b3R5cGVNYXggPSBkZXByZWNhdGUoXG4gICAgICAgICAgJ21vbWVudCgpLm1heCBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1pbiBpbnN0ZWFkLiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTU0OCcsXG4gICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBsb2NhbF9fY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyID4gdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZF9fY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgLy8gUGljayBhIG1vbWVudCBtIGZyb20gbW9tZW50cyBzbyB0aGF0IG1bZm5dKG90aGVyKSBpcyB0cnVlIGZvciBhbGxcbiAgICAgIC8vIG90aGVyLiBUaGlzIHJlbGllcyBvbiB0aGUgZnVuY3Rpb24gZm4gdG8gYmUgdHJhbnNpdGl2ZS5cbiAgICAgIC8vXG4gICAgICAvLyBtb21lbnRzIHNob3VsZCBlaXRoZXIgYmUgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMgb3IgYW4gYXJyYXksIHdob3NlXG4gICAgICAvLyBmaXJzdCBlbGVtZW50IGlzIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzLlxuICAgICAgZnVuY3Rpb24gcGlja0J5KGZuLCBtb21lbnRzKSB7XG4gICAgICAgICAgdmFyIHJlcywgaTtcbiAgICAgICAgICBpZiAobW9tZW50cy5sZW5ndGggPT09IDEgJiYgaXNBcnJheShtb21lbnRzWzBdKSkge1xuICAgICAgICAgICAgICBtb21lbnRzID0gbW9tZW50c1swXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFtb21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm4gbG9jYWxfX2NyZWF0ZUxvY2FsKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlcyA9IG1vbWVudHNbMF07XG4gICAgICAgICAgZm9yIChpID0gMTsgaSA8IG1vbWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgaWYgKCFtb21lbnRzW2ldLmlzVmFsaWQoKSB8fCBtb21lbnRzW2ldW2ZuXShyZXMpKSB7XG4gICAgICAgICAgICAgICAgICByZXMgPSBtb21lbnRzW2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE86IFVzZSBbXS5zb3J0IGluc3RlYWQ/XG4gICAgICBmdW5jdGlvbiBtaW4gKCkge1xuICAgICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgICAgICAgcmV0dXJuIHBpY2tCeSgnaXNCZWZvcmUnLCBhcmdzKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbWF4ICgpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICAgIHJldHVybiBwaWNrQnkoJ2lzQWZ0ZXInLCBhcmdzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gRGF0ZS5ub3cgPyBEYXRlLm5vdygpIDogKyhuZXcgRGF0ZSgpKTtcbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIER1cmF0aW9uIChkdXJhdGlvbikge1xuICAgICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSBub3JtYWxpemVPYmplY3RVbml0cyhkdXJhdGlvbiksXG4gICAgICAgICAgICAgIHllYXJzID0gbm9ybWFsaXplZElucHV0LnllYXIgfHwgMCxcbiAgICAgICAgICAgICAgcXVhcnRlcnMgPSBub3JtYWxpemVkSW5wdXQucXVhcnRlciB8fCAwLFxuICAgICAgICAgICAgICBtb250aHMgPSBub3JtYWxpemVkSW5wdXQubW9udGggfHwgMCxcbiAgICAgICAgICAgICAgd2Vla3MgPSBub3JtYWxpemVkSW5wdXQud2VlayB8fCAwLFxuICAgICAgICAgICAgICBkYXlzID0gbm9ybWFsaXplZElucHV0LmRheSB8fCAwLFxuICAgICAgICAgICAgICBob3VycyA9IG5vcm1hbGl6ZWRJbnB1dC5ob3VyIHx8IDAsXG4gICAgICAgICAgICAgIG1pbnV0ZXMgPSBub3JtYWxpemVkSW5wdXQubWludXRlIHx8IDAsXG4gICAgICAgICAgICAgIHNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQuc2Vjb25kIHx8IDAsXG4gICAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5taWxsaXNlY29uZCB8fCAwO1xuXG4gICAgICAgICAgLy8gcmVwcmVzZW50YXRpb24gZm9yIGRhdGVBZGRSZW1vdmVcbiAgICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgPSArbWlsbGlzZWNvbmRzICtcbiAgICAgICAgICAgICAgc2Vjb25kcyAqIDFlMyArIC8vIDEwMDBcbiAgICAgICAgICAgICAgbWludXRlcyAqIDZlNCArIC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgICBob3VycyAqIDEwMDAgKiA2MCAqIDYwOyAvL3VzaW5nIDEwMDAgKiA2MCAqIDYwIGluc3RlYWQgb2YgMzZlNSB0byBhdm9pZCBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvcnMgaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzI5NzhcbiAgICAgICAgICAvLyBCZWNhdXNlIG9mIGRhdGVBZGRSZW1vdmUgdHJlYXRzIDI0IGhvdXJzIGFzIGRpZmZlcmVudCBmcm9tIGFcbiAgICAgICAgICAvLyBkYXkgd2hlbiB3b3JraW5nIGFyb3VuZCBEU1QsIHdlIG5lZWQgdG8gc3RvcmUgdGhlbSBzZXBhcmF0ZWx5XG4gICAgICAgICAgdGhpcy5fZGF5cyA9ICtkYXlzICtcbiAgICAgICAgICAgICAgd2Vla3MgKiA3O1xuICAgICAgICAgIC8vIEl0IGlzIGltcG9zc2libGUgdHJhbnNsYXRlIG1vbnRocyBpbnRvIGRheXMgd2l0aG91dCBrbm93aW5nXG4gICAgICAgICAgLy8gd2hpY2ggbW9udGhzIHlvdSBhcmUgYXJlIHRhbGtpbmcgYWJvdXQsIHNvIHdlIGhhdmUgdG8gc3RvcmVcbiAgICAgICAgICAvLyBpdCBzZXBhcmF0ZWx5LlxuICAgICAgICAgIHRoaXMuX21vbnRocyA9ICttb250aHMgK1xuICAgICAgICAgICAgICBxdWFydGVycyAqIDMgK1xuICAgICAgICAgICAgICB5ZWFycyAqIDEyO1xuXG4gICAgICAgICAgdGhpcy5fZGF0YSA9IHt9O1xuXG4gICAgICAgICAgdGhpcy5fbG9jYWxlID0gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZSgpO1xuXG4gICAgICAgICAgdGhpcy5fYnViYmxlKCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzRHVyYXRpb24gKG9iaikge1xuICAgICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBEdXJhdGlvbjtcbiAgICAgIH1cblxuICAgICAgLy8gRk9STUFUVElOR1xuXG4gICAgICBmdW5jdGlvbiBvZmZzZXQgKHRva2VuLCBzZXBhcmF0b3IpIHtcbiAgICAgICAgICBhZGRGb3JtYXRUb2tlbih0b2tlbiwgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy51dGNPZmZzZXQoKTtcbiAgICAgICAgICAgICAgdmFyIHNpZ24gPSAnKyc7XG4gICAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBvZmZzZXQgPSAtb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgc2lnbiA9ICctJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gc2lnbiArIHplcm9GaWxsKH5+KG9mZnNldCAvIDYwKSwgMikgKyBzZXBhcmF0b3IgKyB6ZXJvRmlsbCh+fihvZmZzZXQpICUgNjAsIDIpO1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBvZmZzZXQoJ1onLCAnOicpO1xuICAgICAgb2Zmc2V0KCdaWicsICcnKTtcblxuICAgICAgLy8gUEFSU0lOR1xuXG4gICAgICBhZGRSZWdleFRva2VuKCdaJywgIG1hdGNoU2hvcnRPZmZzZXQpO1xuICAgICAgYWRkUmVnZXhUb2tlbignWlonLCBtYXRjaFNob3J0T2Zmc2V0KTtcbiAgICAgIGFkZFBhcnNlVG9rZW4oWydaJywgJ1paJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICAgIGNvbmZpZy5fdXNlVVRDID0gdHJ1ZTtcbiAgICAgICAgICBjb25maWcuX3R6bSA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hTaG9ydE9mZnNldCwgaW5wdXQpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEhFTFBFUlNcblxuICAgICAgLy8gdGltZXpvbmUgY2h1bmtlclxuICAgICAgLy8gJysxMDowMCcgPiBbJzEwJywgICcwMCddXG4gICAgICAvLyAnLTE1MzAnICA+IFsnLTE1JywgJzMwJ11cbiAgICAgIHZhciBjaHVua09mZnNldCA9IC8oW1xcK1xcLV18XFxkXFxkKS9naTtcblxuICAgICAgZnVuY3Rpb24gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaGVyLCBzdHJpbmcpIHtcbiAgICAgICAgICB2YXIgbWF0Y2hlcyA9ICgoc3RyaW5nIHx8ICcnKS5tYXRjaChtYXRjaGVyKSB8fCBbXSk7XG4gICAgICAgICAgdmFyIGNodW5rICAgPSBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0gfHwgW107XG4gICAgICAgICAgdmFyIHBhcnRzICAgPSAoY2h1bmsgKyAnJykubWF0Y2goY2h1bmtPZmZzZXQpIHx8IFsnLScsIDAsIDBdO1xuICAgICAgICAgIHZhciBtaW51dGVzID0gKyhwYXJ0c1sxXSAqIDYwKSArIHRvSW50KHBhcnRzWzJdKTtcblxuICAgICAgICAgIHJldHVybiBwYXJ0c1swXSA9PT0gJysnID8gbWludXRlcyA6IC1taW51dGVzO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4gYSBtb21lbnQgZnJvbSBpbnB1dCwgdGhhdCBpcyBsb2NhbC91dGMvem9uZSBlcXVpdmFsZW50IHRvIG1vZGVsLlxuICAgICAgZnVuY3Rpb24gY2xvbmVXaXRoT2Zmc2V0KGlucHV0LCBtb2RlbCkge1xuICAgICAgICAgIHZhciByZXMsIGRpZmY7XG4gICAgICAgICAgaWYgKG1vZGVsLl9pc1VUQykge1xuICAgICAgICAgICAgICByZXMgPSBtb2RlbC5jbG9uZSgpO1xuICAgICAgICAgICAgICBkaWZmID0gKGlzTW9tZW50KGlucHV0KSB8fCBpc0RhdGUoaW5wdXQpID8gaW5wdXQudmFsdWVPZigpIDogbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KS52YWx1ZU9mKCkpIC0gcmVzLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgLy8gVXNlIGxvdy1sZXZlbCBhcGksIGJlY2F1c2UgdGhpcyBmbiBpcyBsb3ctbGV2ZWwgYXBpLlxuICAgICAgICAgICAgICByZXMuX2Quc2V0VGltZShyZXMuX2QudmFsdWVPZigpICsgZGlmZik7XG4gICAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQocmVzLCBmYWxzZSk7XG4gICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsX19jcmVhdGVMb2NhbChpbnB1dCkubG9jYWwoKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldERhdGVPZmZzZXQgKG0pIHtcbiAgICAgICAgICAvLyBPbiBGaXJlZm94LjI0IERhdGUjZ2V0VGltZXpvbmVPZmZzZXQgcmV0dXJucyBhIGZsb2F0aW5nIHBvaW50LlxuICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L3B1bGwvMTg3MVxuICAgICAgICAgIHJldHVybiAtTWF0aC5yb3VuZChtLl9kLmdldFRpbWV6b25lT2Zmc2V0KCkgLyAxNSkgKiAxNTtcbiAgICAgIH1cblxuICAgICAgLy8gSE9PS1NcblxuICAgICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciBhIG1vbWVudCBpcyBtdXRhdGVkLlxuICAgICAgLy8gSXQgaXMgaW50ZW5kZWQgdG8ga2VlcCB0aGUgb2Zmc2V0IGluIHN5bmMgd2l0aCB0aGUgdGltZXpvbmUuXG4gICAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0ID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAgIC8vIE1PTUVOVFNcblxuICAgICAgLy8ga2VlcExvY2FsVGltZSA9IHRydWUgbWVhbnMgb25seSBjaGFuZ2UgdGhlIHRpbWV6b25lLCB3aXRob3V0XG4gICAgICAvLyBhZmZlY3RpbmcgdGhlIGxvY2FsIGhvdXIuIFNvIDU6MzE6MjYgKzAzMDAgLS1bdXRjT2Zmc2V0KDIsIHRydWUpXS0tPlxuICAgICAgLy8gNTozMToyNiArMDIwMCBJdCBpcyBwb3NzaWJsZSB0aGF0IDU6MzE6MjYgZG9lc24ndCBleGlzdCB3aXRoIG9mZnNldFxuICAgICAgLy8gKzAyMDAsIHNvIHdlIGFkanVzdCB0aGUgdGltZSBhcyBuZWVkZWQsIHRvIGJlIHZhbGlkLlxuICAgICAgLy9cbiAgICAgIC8vIEtlZXBpbmcgdGhlIHRpbWUgYWN0dWFsbHkgYWRkcy9zdWJ0cmFjdHMgKG9uZSBob3VyKVxuICAgICAgLy8gZnJvbSB0aGUgYWN0dWFsIHJlcHJlc2VudGVkIHRpbWUuIFRoYXQgaXMgd2h5IHdlIGNhbGwgdXBkYXRlT2Zmc2V0XG4gICAgICAvLyBhIHNlY29uZCB0aW1lLiBJbiBjYXNlIGl0IHdhbnRzIHVzIHRvIGNoYW5nZSB0aGUgb2Zmc2V0IGFnYWluXG4gICAgICAvLyBfY2hhbmdlSW5Qcm9ncmVzcyA9PSB0cnVlIGNhc2UsIHRoZW4gd2UgaGF2ZSB0byBhZGp1c3QsIGJlY2F1c2VcbiAgICAgIC8vIHRoZXJlIGlzIG5vIHN1Y2ggdGltZSBpbiB0aGUgZ2l2ZW4gdGltZXpvbmUuXG4gICAgICBmdW5jdGlvbiBnZXRTZXRPZmZzZXQgKGlucHV0LCBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX29mZnNldCB8fCAwLFxuICAgICAgICAgICAgICBsb2NhbEFkanVzdDtcbiAgICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgIGlucHV0ID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaFNob3J0T2Zmc2V0LCBpbnB1dCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoaW5wdXQpIDwgMTYpIHtcbiAgICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQgKiA2MDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzVVRDICYmIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgIGxvY2FsQWRqdXN0ID0gZ2V0RGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbnB1dDtcbiAgICAgICAgICAgICAgdGhpcy5faXNVVEMgPSB0cnVlO1xuICAgICAgICAgICAgICBpZiAobG9jYWxBZGp1c3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5hZGQobG9jYWxBZGp1c3QsICdtJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG9mZnNldCAhPT0gaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgIGlmICgha2VlcExvY2FsVGltZSB8fCB0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkX3N1YnRyYWN0X19hZGRTdWJ0cmFjdCh0aGlzLCBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uKGlucHV0IC0gb2Zmc2V0LCAnbScpLCAxLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyBvZmZzZXQgOiBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0U2V0Wm9uZSAoaW5wdXQsIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgaW5wdXQgPSAtaW5wdXQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLnV0Y09mZnNldChpbnB1dCwga2VlcExvY2FsVGltZSk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIC10aGlzLnV0Y09mZnNldCgpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9VVEMgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvTG9jYWwgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICBpZiAodGhpcy5faXNVVEMpIHtcbiAgICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgICAgICAgICAgIHRoaXMuX2lzVVRDID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgaWYgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc3VidHJhY3QoZ2V0RGF0ZU9mZnNldCh0aGlzKSwgJ20nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQgKCkge1xuICAgICAgICAgIGlmICh0aGlzLl90em0pIHtcbiAgICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQodGhpcy5fdHptKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9pID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICB0aGlzLnV0Y09mZnNldChvZmZzZXRGcm9tU3RyaW5nKG1hdGNoT2Zmc2V0LCB0aGlzLl9pKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBoYXNBbGlnbmVkSG91ck9mZnNldCAoaW5wdXQpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5wdXQgPSBpbnB1dCA/IGxvY2FsX19jcmVhdGVMb2NhbChpbnB1dCkudXRjT2Zmc2V0KCkgOiAwO1xuXG4gICAgICAgICAgcmV0dXJuICh0aGlzLnV0Y09mZnNldCgpIC0gaW5wdXQpICUgNjAgPT09IDA7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lICgpIHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgpID4gdGhpcy5jbG9uZSgpLm1vbnRoKDApLnV0Y09mZnNldCgpIHx8XG4gICAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoNSkudXRjT2Zmc2V0KClcbiAgICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQgKCkge1xuICAgICAgICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5faXNEU1RTaGlmdGVkKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjID0ge307XG5cbiAgICAgICAgICBjb3B5Q29uZmlnKGMsIHRoaXMpO1xuICAgICAgICAgIGMgPSBwcmVwYXJlQ29uZmlnKGMpO1xuXG4gICAgICAgICAgaWYgKGMuX2EpIHtcbiAgICAgICAgICAgICAgdmFyIG90aGVyID0gYy5faXNVVEMgPyBjcmVhdGVfdXRjX19jcmVhdGVVVEMoYy5fYSkgOiBsb2NhbF9fY3JlYXRlTG9jYWwoYy5fYSk7XG4gICAgICAgICAgICAgIHRoaXMuX2lzRFNUU2hpZnRlZCA9IHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAgICAgICBjb21wYXJlQXJyYXlzKGMuX2EsIG90aGVyLnRvQXJyYXkoKSkgPiAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuX2lzRFNUU2hpZnRlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzTG9jYWwgKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/ICF0aGlzLl9pc1VUQyA6IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc1V0Y09mZnNldCAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5faXNVVEMgOiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaXNVdGMgKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2lzVVRDICYmIHRoaXMuX29mZnNldCA9PT0gMCA6IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBBU1AuTkVUIGpzb24gZGF0ZSBmb3JtYXQgcmVnZXhcbiAgICAgIHZhciBhc3BOZXRSZWdleCA9IC9eKFxcLSk/KD86KFxcZCopWy4gXSk/KFxcZCspXFw6KFxcZCspKD86XFw6KFxcZCspXFwuPyhcXGR7M30pP1xcZCopPyQvO1xuXG4gICAgICAvLyBmcm9tIGh0dHA6Ly9kb2NzLmNsb3N1cmUtbGlicmFyeS5nb29nbGVjb2RlLmNvbS9naXQvY2xvc3VyZV9nb29nX2RhdGVfZGF0ZS5qcy5zb3VyY2UuaHRtbFxuICAgICAgLy8gc29tZXdoYXQgbW9yZSBpbiBsaW5lIHdpdGggNC40LjMuMiAyMDA0IHNwZWMsIGJ1dCBhbGxvd3MgZGVjaW1hbCBhbnl3aGVyZVxuICAgICAgLy8gYW5kIGZ1cnRoZXIgbW9kaWZpZWQgdG8gYWxsb3cgZm9yIHN0cmluZ3MgY29udGFpbmluZyBib3RoIHdlZWsgYW5kIGRheVxuICAgICAgdmFyIGlzb1JlZ2V4ID0gL14oLSk/UCg/OigtP1swLTksLl0qKVkpPyg/OigtP1swLTksLl0qKU0pPyg/OigtP1swLTksLl0qKVcpPyg/OigtP1swLTksLl0qKUQpPyg/OlQoPzooLT9bMC05LC5dKilIKT8oPzooLT9bMC05LC5dKilNKT8oPzooLT9bMC05LC5dKilTKT8pPyQvO1xuXG4gICAgICBmdW5jdGlvbiBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uIChpbnB1dCwga2V5KSB7XG4gICAgICAgICAgdmFyIGR1cmF0aW9uID0gaW5wdXQsXG4gICAgICAgICAgICAgIC8vIG1hdGNoaW5nIGFnYWluc3QgcmVnZXhwIGlzIGV4cGVuc2l2ZSwgZG8gaXQgb24gZGVtYW5kXG4gICAgICAgICAgICAgIG1hdGNoID0gbnVsbCxcbiAgICAgICAgICAgICAgc2lnbixcbiAgICAgICAgICAgICAgcmV0LFxuICAgICAgICAgICAgICBkaWZmUmVzO1xuXG4gICAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpKSB7XG4gICAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgbXMgOiBpbnB1dC5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgICAgICAgZCAgOiBpbnB1dC5fZGF5cyxcbiAgICAgICAgICAgICAgICAgIE0gIDogaW5wdXQuX21vbnRoc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICBkdXJhdGlvbltrZXldID0gaW5wdXQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBkdXJhdGlvbi5taWxsaXNlY29uZHMgPSBpbnB1dDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoISEobWF0Y2ggPSBhc3BOZXRSZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgICAgICAgc2lnbiA9IChtYXRjaFsxXSA9PT0gJy0nKSA/IC0xIDogMTtcbiAgICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICB5ICA6IDAsXG4gICAgICAgICAgICAgICAgICBkICA6IHRvSW50KG1hdGNoW0RBVEVdKSAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgICAgaCAgOiB0b0ludChtYXRjaFtIT1VSXSkgICAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICAgIG0gIDogdG9JbnQobWF0Y2hbTUlOVVRFXSkgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgICBzICA6IHRvSW50KG1hdGNoW1NFQ09ORF0pICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgICAgbXMgOiB0b0ludChtYXRjaFtNSUxMSVNFQ09ORF0pICogc2lnblxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSBpZiAoISEobWF0Y2ggPSBpc29SZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgICAgICAgc2lnbiA9IChtYXRjaFsxXSA9PT0gJy0nKSA/IC0xIDogMTtcbiAgICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICB5IDogcGFyc2VJc28obWF0Y2hbMl0sIHNpZ24pLFxuICAgICAgICAgICAgICAgICAgTSA6IHBhcnNlSXNvKG1hdGNoWzNdLCBzaWduKSxcbiAgICAgICAgICAgICAgICAgIHcgOiBwYXJzZUlzbyhtYXRjaFs0XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgICBkIDogcGFyc2VJc28obWF0Y2hbNV0sIHNpZ24pLFxuICAgICAgICAgICAgICAgICAgaCA6IHBhcnNlSXNvKG1hdGNoWzZdLCBzaWduKSxcbiAgICAgICAgICAgICAgICAgIG0gOiBwYXJzZUlzbyhtYXRjaFs3XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgICBzIDogcGFyc2VJc28obWF0Y2hbOF0sIHNpZ24pXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7Ly8gY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGR1cmF0aW9uID09PSAnb2JqZWN0JyAmJiAoJ2Zyb20nIGluIGR1cmF0aW9uIHx8ICd0bycgaW4gZHVyYXRpb24pKSB7XG4gICAgICAgICAgICAgIGRpZmZSZXMgPSBtb21lbnRzRGlmZmVyZW5jZShsb2NhbF9fY3JlYXRlTG9jYWwoZHVyYXRpb24uZnJvbSksIGxvY2FsX19jcmVhdGVMb2NhbChkdXJhdGlvbi50bykpO1xuXG4gICAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgICAgICAgIGR1cmF0aW9uLm1zID0gZGlmZlJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgICAgICAgIGR1cmF0aW9uLk0gPSBkaWZmUmVzLm1vbnRocztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXQgPSBuZXcgRHVyYXRpb24oZHVyYXRpb24pO1xuXG4gICAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpICYmIGhhc093blByb3AoaW5wdXQsICdfbG9jYWxlJykpIHtcbiAgICAgICAgICAgICAgcmV0Ll9sb2NhbGUgPSBpbnB1dC5fbG9jYWxlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG5cbiAgICAgIGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24uZm4gPSBEdXJhdGlvbi5wcm90b3R5cGU7XG5cbiAgICAgIGZ1bmN0aW9uIHBhcnNlSXNvIChpbnAsIHNpZ24pIHtcbiAgICAgICAgICAvLyBXZSdkIG5vcm1hbGx5IHVzZSB+fmlucCBmb3IgdGhpcywgYnV0IHVuZm9ydHVuYXRlbHkgaXQgYWxzb1xuICAgICAgICAgIC8vIGNvbnZlcnRzIGZsb2F0cyB0byBpbnRzLlxuICAgICAgICAgIC8vIGlucCBtYXkgYmUgdW5kZWZpbmVkLCBzbyBjYXJlZnVsIGNhbGxpbmcgcmVwbGFjZSBvbiBpdC5cbiAgICAgICAgICB2YXIgcmVzID0gaW5wICYmIHBhcnNlRmxvYXQoaW5wLnJlcGxhY2UoJywnLCAnLicpKTtcbiAgICAgICAgICAvLyBhcHBseSBzaWduIHdoaWxlIHdlJ3JlIGF0IGl0XG4gICAgICAgICAgcmV0dXJuIChpc05hTihyZXMpID8gMCA6IHJlcykgKiBzaWduO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgICAgICAgdmFyIHJlcyA9IHttaWxsaXNlY29uZHM6IDAsIG1vbnRoczogMH07XG5cbiAgICAgICAgICByZXMubW9udGhzID0gb3RoZXIubW9udGgoKSAtIGJhc2UubW9udGgoKSArXG4gICAgICAgICAgICAgIChvdGhlci55ZWFyKCkgLSBiYXNlLnllYXIoKSkgKiAxMjtcbiAgICAgICAgICBpZiAoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpLmlzQWZ0ZXIob3RoZXIpKSB7XG4gICAgICAgICAgICAgIC0tcmVzLm1vbnRocztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gK290aGVyIC0gKyhiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJykpO1xuXG4gICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICAgICAgICB2YXIgcmVzO1xuICAgICAgICAgIGlmICghKGJhc2UuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHttaWxsaXNlY29uZHM6IDAsIG1vbnRoczogMH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb3RoZXIgPSBjbG9uZVdpdGhPZmZzZXQob3RoZXIsIGJhc2UpO1xuICAgICAgICAgIGlmIChiYXNlLmlzQmVmb3JlKG90aGVyKSkge1xuICAgICAgICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKG90aGVyLCBiYXNlKTtcbiAgICAgICAgICAgICAgcmVzLm1pbGxpc2Vjb25kcyA9IC1yZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgICByZXMubW9udGhzID0gLXJlcy5tb250aHM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYWJzUm91bmQgKG51bWJlcikge1xuICAgICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKC0xICogbnVtYmVyKSAqIC0xO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKG51bWJlcik7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUT0RPOiByZW1vdmUgJ25hbWUnIGFyZyBhZnRlciBkZXByZWNhdGlvbiBpcyByZW1vdmVkXG4gICAgICBmdW5jdGlvbiBjcmVhdGVBZGRlcihkaXJlY3Rpb24sIG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCwgcGVyaW9kKSB7XG4gICAgICAgICAgICAgIHZhciBkdXIsIHRtcDtcbiAgICAgICAgICAgICAgLy9pbnZlcnQgdGhlIGFyZ3VtZW50cywgYnV0IGNvbXBsYWluIGFib3V0IGl0XG4gICAgICAgICAgICAgIGlmIChwZXJpb2QgIT09IG51bGwgJiYgIWlzTmFOKCtwZXJpb2QpKSB7XG4gICAgICAgICAgICAgICAgICBkZXByZWNhdGVTaW1wbGUobmFtZSwgJ21vbWVudCgpLicgKyBuYW1lICArICcocGVyaW9kLCBudW1iZXIpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgbW9tZW50KCkuJyArIG5hbWUgKyAnKG51bWJlciwgcGVyaW9kKS4nKTtcbiAgICAgICAgICAgICAgICAgIHRtcCA9IHZhbDsgdmFsID0gcGVyaW9kOyBwZXJpb2QgPSB0bXA7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YWwgPSB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyA/ICt2YWwgOiB2YWw7XG4gICAgICAgICAgICAgIGR1ciA9IGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24odmFsLCBwZXJpb2QpO1xuICAgICAgICAgICAgICBhZGRfc3VidHJhY3RfX2FkZFN1YnRyYWN0KHRoaXMsIGR1ciwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYWRkX3N1YnRyYWN0X19hZGRTdWJ0cmFjdCAobW9tLCBkdXJhdGlvbiwgaXNBZGRpbmcsIHVwZGF0ZU9mZnNldCkge1xuICAgICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgICBkYXlzID0gYWJzUm91bmQoZHVyYXRpb24uX2RheXMpLFxuICAgICAgICAgICAgICBtb250aHMgPSBhYnNSb3VuZChkdXJhdGlvbi5fbW9udGhzKTtcblxuICAgICAgICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAvLyBObyBvcFxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdXBkYXRlT2Zmc2V0ID0gdXBkYXRlT2Zmc2V0ID09IG51bGwgPyB0cnVlIDogdXBkYXRlT2Zmc2V0O1xuXG4gICAgICAgICAgaWYgKG1pbGxpc2Vjb25kcykge1xuICAgICAgICAgICAgICBtb20uX2Quc2V0VGltZShtb20uX2QudmFsdWVPZigpICsgbWlsbGlzZWNvbmRzICogaXNBZGRpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGF5cykge1xuICAgICAgICAgICAgICBnZXRfc2V0X19zZXQobW9tLCAnRGF0ZScsIGdldF9zZXRfX2dldChtb20sICdEYXRlJykgKyBkYXlzICogaXNBZGRpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9udGhzKSB7XG4gICAgICAgICAgICAgIHNldE1vbnRoKG1vbSwgZ2V0X3NldF9fZ2V0KG1vbSwgJ01vbnRoJykgKyBtb250aHMgKiBpc0FkZGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldChtb20sIGRheXMgfHwgbW9udGhzKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBhZGRfc3VidHJhY3RfX2FkZCAgICAgID0gY3JlYXRlQWRkZXIoMSwgJ2FkZCcpO1xuICAgICAgdmFyIGFkZF9zdWJ0cmFjdF9fc3VidHJhY3QgPSBjcmVhdGVBZGRlcigtMSwgJ3N1YnRyYWN0Jyk7XG5cbiAgICAgIGZ1bmN0aW9uIG1vbWVudF9jYWxlbmRhcl9fY2FsZW5kYXIgKHRpbWUsIGZvcm1hdHMpIHtcbiAgICAgICAgICAvLyBXZSB3YW50IHRvIGNvbXBhcmUgdGhlIHN0YXJ0IG9mIHRvZGF5LCB2cyB0aGlzLlxuICAgICAgICAgIC8vIEdldHRpbmcgc3RhcnQtb2YtdG9kYXkgZGVwZW5kcyBvbiB3aGV0aGVyIHdlJ3JlIGxvY2FsL3V0Yy9vZmZzZXQgb3Igbm90LlxuICAgICAgICAgIHZhciBub3cgPSB0aW1lIHx8IGxvY2FsX19jcmVhdGVMb2NhbCgpLFxuICAgICAgICAgICAgICBzb2QgPSBjbG9uZVdpdGhPZmZzZXQobm93LCB0aGlzKS5zdGFydE9mKCdkYXknKSxcbiAgICAgICAgICAgICAgZGlmZiA9IHRoaXMuZGlmZihzb2QsICdkYXlzJywgdHJ1ZSksXG4gICAgICAgICAgICAgIGZvcm1hdCA9IGRpZmYgPCAtNiA/ICdzYW1lRWxzZScgOlxuICAgICAgICAgICAgICAgICAgZGlmZiA8IC0xID8gJ2xhc3RXZWVrJyA6XG4gICAgICAgICAgICAgICAgICBkaWZmIDwgMCA/ICdsYXN0RGF5JyA6XG4gICAgICAgICAgICAgICAgICBkaWZmIDwgMSA/ICdzYW1lRGF5JyA6XG4gICAgICAgICAgICAgICAgICBkaWZmIDwgMiA/ICduZXh0RGF5JyA6XG4gICAgICAgICAgICAgICAgICBkaWZmIDwgNyA/ICduZXh0V2VlaycgOiAnc2FtZUVsc2UnO1xuXG4gICAgICAgICAgdmFyIG91dHB1dCA9IGZvcm1hdHMgJiYgKGlzRnVuY3Rpb24oZm9ybWF0c1tmb3JtYXRdKSA/IGZvcm1hdHNbZm9ybWF0XSgpIDogZm9ybWF0c1tmb3JtYXRdKTtcblxuICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChvdXRwdXQgfHwgdGhpcy5sb2NhbGVEYXRhKCkuY2FsZW5kYXIoZm9ybWF0LCB0aGlzLCBsb2NhbF9fY3JlYXRlTG9jYWwobm93KSkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBNb21lbnQodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzQWZ0ZXIgKGlucHV0LCB1bml0cykge1xuICAgICAgICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHMoIWlzVW5kZWZpbmVkKHVuaXRzKSA/IHVuaXRzIDogJ21pbGxpc2Vjb25kJyk7XG4gICAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA+IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBsb2NhbElucHV0LnZhbHVlT2YoKSA8IHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKS52YWx1ZU9mKCk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc0JlZm9yZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGxvY2FsX19jcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyghaXNVbmRlZmluZWQodW5pdHMpID8gdW5pdHMgOiAnbWlsbGlzZWNvbmQnKTtcbiAgICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpIDwgbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpIDwgbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc0JldHdlZW4gKGZyb20sIHRvLCB1bml0cywgaW5jbHVzaXZpdHkpIHtcbiAgICAgICAgICBpbmNsdXNpdml0eSA9IGluY2x1c2l2aXR5IHx8ICcoKSc7XG4gICAgICAgICAgcmV0dXJuIChpbmNsdXNpdml0eVswXSA9PT0gJygnID8gdGhpcy5pc0FmdGVyKGZyb20sIHVuaXRzKSA6ICF0aGlzLmlzQmVmb3JlKGZyb20sIHVuaXRzKSkgJiZcbiAgICAgICAgICAgICAgKGluY2x1c2l2aXR5WzFdID09PSAnKScgPyB0aGlzLmlzQmVmb3JlKHRvLCB1bml0cykgOiAhdGhpcy5pc0FmdGVyKHRvLCB1bml0cykpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc1NhbWUgKGlucHV0LCB1bml0cykge1xuICAgICAgICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpLFxuICAgICAgICAgICAgICBpbnB1dE1zO1xuICAgICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMgfHwgJ21pbGxpc2Vjb25kJyk7XG4gICAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA9PT0gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaW5wdXRNcyA9IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKSA8PSBpbnB1dE1zICYmIGlucHV0TXMgPD0gdGhpcy5jbG9uZSgpLmVuZE9mKHVuaXRzKS52YWx1ZU9mKCk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc1NhbWVPckFmdGVyIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pc1NhbWUoaW5wdXQsIHVuaXRzKSB8fCB0aGlzLmlzQWZ0ZXIoaW5wdXQsdW5pdHMpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc1NhbWVPckJlZm9yZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaXNTYW1lKGlucHV0LCB1bml0cykgfHwgdGhpcy5pc0JlZm9yZShpbnB1dCx1bml0cyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRpZmYgKGlucHV0LCB1bml0cywgYXNGbG9hdCkge1xuICAgICAgICAgIHZhciB0aGF0LFxuICAgICAgICAgICAgICB6b25lRGVsdGEsXG4gICAgICAgICAgICAgIGRlbHRhLCBvdXRwdXQ7XG5cbiAgICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhhdCA9IGNsb25lV2l0aE9mZnNldChpbnB1dCwgdGhpcyk7XG5cbiAgICAgICAgICBpZiAoIXRoYXQuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgem9uZURlbHRhID0gKHRoYXQudXRjT2Zmc2V0KCkgLSB0aGlzLnV0Y09mZnNldCgpKSAqIDZlNDtcblxuICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuXG4gICAgICAgICAgaWYgKHVuaXRzID09PSAneWVhcicgfHwgdW5pdHMgPT09ICdtb250aCcgfHwgdW5pdHMgPT09ICdxdWFydGVyJykge1xuICAgICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCk7XG4gICAgICAgICAgICAgIGlmICh1bml0cyA9PT0gJ3F1YXJ0ZXInKSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgLyAzO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHVuaXRzID09PSAneWVhcicpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCAvIDEyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGVsdGEgPSB0aGlzIC0gdGhhdDtcbiAgICAgICAgICAgICAgb3V0cHV0ID0gdW5pdHMgPT09ICdzZWNvbmQnID8gZGVsdGEgLyAxZTMgOiAvLyAxMDAwXG4gICAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ21pbnV0ZScgPyBkZWx0YSAvIDZlNCA6IC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgICAgICAgdW5pdHMgPT09ICdob3VyJyA/IGRlbHRhIC8gMzZlNSA6IC8vIDEwMDAgKiA2MCAqIDYwXG4gICAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ2RheScgPyAoZGVsdGEgLSB6b25lRGVsdGEpIC8gODY0ZTUgOiAvLyAxMDAwICogNjAgKiA2MCAqIDI0LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ3dlZWsnID8gKGRlbHRhIC0gem9uZURlbHRhKSAvIDYwNDhlNSA6IC8vIDEwMDAgKiA2MCAqIDYwICogMjQgKiA3LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICAgICAgICBkZWx0YTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFzRmxvYXQgPyBvdXRwdXQgOiBhYnNGbG9vcihvdXRwdXQpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBtb250aERpZmYgKGEsIGIpIHtcbiAgICAgICAgICAvLyBkaWZmZXJlbmNlIGluIG1vbnRoc1xuICAgICAgICAgIHZhciB3aG9sZU1vbnRoRGlmZiA9ICgoYi55ZWFyKCkgLSBhLnllYXIoKSkgKiAxMikgKyAoYi5tb250aCgpIC0gYS5tb250aCgpKSxcbiAgICAgICAgICAgICAgLy8gYiBpcyBpbiAoYW5jaG9yIC0gMSBtb250aCwgYW5jaG9yICsgMSBtb250aClcbiAgICAgICAgICAgICAgYW5jaG9yID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiwgJ21vbnRocycpLFxuICAgICAgICAgICAgICBhbmNob3IyLCBhZGp1c3Q7XG5cbiAgICAgICAgICBpZiAoYiAtIGFuY2hvciA8IDApIHtcbiAgICAgICAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgLSAxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAgIC8vIGxpbmVhciBhY3Jvc3MgdGhlIG1vbnRoXG4gICAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IgLSBhbmNob3IyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhbmNob3IyID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiArIDEsICdtb250aHMnKTtcbiAgICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvcjIgLSBhbmNob3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vY2hlY2sgZm9yIG5lZ2F0aXZlIHplcm8sIHJldHVybiB6ZXJvIGlmIG5lZ2F0aXZlIHplcm9cbiAgICAgICAgICByZXR1cm4gLSh3aG9sZU1vbnRoRGlmZiArIGFkanVzdCkgfHwgMDtcbiAgICAgIH1cblxuICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLmRlZmF1bHRGb3JtYXQgPSAnWVlZWS1NTS1ERFRISDptbTpzc1onO1xuICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLmRlZmF1bHRGb3JtYXRVdGMgPSAnWVlZWS1NTS1ERFRISDptbTpzc1taXSc7XG5cbiAgICAgIGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmxvY2FsZSgnZW4nKS5mb3JtYXQoJ2RkZCBNTU0gREQgWVlZWSBISDptbTpzcyBbR01UXVpaJyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG1vbWVudF9mb3JtYXRfX3RvSVNPU3RyaW5nICgpIHtcbiAgICAgICAgICB2YXIgbSA9IHRoaXMuY2xvbmUoKS51dGMoKTtcbiAgICAgICAgICBpZiAoMCA8IG0ueWVhcigpICYmIG0ueWVhcigpIDw9IDk5OTkpIHtcbiAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAvLyBuYXRpdmUgaW1wbGVtZW50YXRpb24gaXMgfjUweCBmYXN0ZXIsIHVzZSBpdCB3aGVuIHdlIGNhblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9EYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQobSwgJ1lZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQobSwgJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXScpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZm9ybWF0IChpbnB1dFN0cmluZykge1xuICAgICAgICAgIGlmICghaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgICAgICAgaW5wdXRTdHJpbmcgPSB0aGlzLmlzVXRjKCkgPyB1dGlsc19ob29rc19faG9va3MuZGVmYXVsdEZvcm1hdFV0YyA6IHV0aWxzX2hvb2tzX19ob29rcy5kZWZhdWx0Rm9ybWF0O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgb3V0cHV0ID0gZm9ybWF0TW9tZW50KHRoaXMsIGlucHV0U3RyaW5nKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkucG9zdGZvcm1hdChvdXRwdXQpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBmcm9tICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fFxuICAgICAgICAgICAgICAgICAgIGxvY2FsX19jcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uKHt0bzogdGhpcywgZnJvbTogdGltZX0pLmxvY2FsZSh0aGlzLmxvY2FsZSgpKS5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBmcm9tTm93ICh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbShsb2NhbF9fY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRvICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fFxuICAgICAgICAgICAgICAgICAgIGxvY2FsX19jcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uKHtmcm9tOiB0aGlzLCB0bzogdGltZX0pLmxvY2FsZSh0aGlzLmxvY2FsZSgpKS5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0b05vdyAod2l0aG91dFN1ZmZpeCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRvKGxvY2FsX19jcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgcGFzc2VkIGEgbG9jYWxlIGtleSwgaXQgd2lsbCBzZXQgdGhlIGxvY2FsZSBmb3IgdGhpc1xuICAgICAgLy8gaW5zdGFuY2UuICBPdGhlcndpc2UsIGl0IHdpbGwgcmV0dXJuIHRoZSBsb2NhbGUgY29uZmlndXJhdGlvblxuICAgICAgLy8gdmFyaWFibGVzIGZvciB0aGlzIGluc3RhbmNlLlxuICAgICAgZnVuY3Rpb24gbG9jYWxlIChrZXkpIHtcbiAgICAgICAgICB2YXIgbmV3TG9jYWxlRGF0YTtcblxuICAgICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxlLl9hYmJyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld0xvY2FsZURhdGEgPSBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgICAgICAgIGlmIChuZXdMb2NhbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2xvY2FsZSA9IG5ld0xvY2FsZURhdGE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbGFuZyA9IGRlcHJlY2F0ZShcbiAgICAgICAgICAnbW9tZW50KCkubGFuZygpIGlzIGRlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZSBtb21lbnQoKS5sb2NhbGVEYXRhKCkgdG8gZ2V0IHRoZSBsYW5ndWFnZSBjb25maWd1cmF0aW9uLiBVc2UgbW9tZW50KCkubG9jYWxlKCkgdG8gY2hhbmdlIGxhbmd1YWdlcy4nLFxuICAgICAgICAgIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGUoa2V5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIGZ1bmN0aW9uIGxvY2FsZURhdGEgKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGU7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHN0YXJ0T2YgKHVuaXRzKSB7XG4gICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgICAgLy8gdGhlIGZvbGxvd2luZyBzd2l0Y2ggaW50ZW50aW9uYWxseSBvbWl0cyBicmVhayBrZXl3b3Jkc1xuICAgICAgICAgIC8vIHRvIHV0aWxpemUgZmFsbGluZyB0aHJvdWdoIHRoZSBjYXNlcy5cbiAgICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICAgIHRoaXMubW9udGgoMCk7XG4gICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICAgIHRoaXMuZGF0ZSgxKTtcbiAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgIGNhc2UgJ2lzb1dlZWsnOlxuICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICAgIHRoaXMuaG91cnMoMCk7XG4gICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgdGhpcy5taW51dGVzKDApO1xuICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICAgdGhpcy5zZWNvbmRzKDApO1xuICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgICAgdGhpcy5taWxsaXNlY29uZHMoMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gd2Vla3MgYXJlIGEgc3BlY2lhbCBjYXNlXG4gICAgICAgICAgaWYgKHVuaXRzID09PSAnd2VlaycpIHtcbiAgICAgICAgICAgICAgdGhpcy53ZWVrZGF5KDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodW5pdHMgPT09ICdpc29XZWVrJykge1xuICAgICAgICAgICAgICB0aGlzLmlzb1dlZWtkYXkoMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gcXVhcnRlcnMgYXJlIGFsc28gc3BlY2lhbFxuICAgICAgICAgIGlmICh1bml0cyA9PT0gJ3F1YXJ0ZXInKSB7XG4gICAgICAgICAgICAgIHRoaXMubW9udGgoTWF0aC5mbG9vcih0aGlzLm1vbnRoKCkgLyAzKSAqIDMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBlbmRPZiAodW5pdHMpIHtcbiAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgICBpZiAodW5pdHMgPT09IHVuZGVmaW5lZCB8fCB1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyAnZGF0ZScgaXMgYW4gYWxpYXMgZm9yICdkYXknLCBzbyBpdCBzaG91bGQgYmUgY29uc2lkZXJlZCBhcyBzdWNoLlxuICAgICAgICAgIGlmICh1bml0cyA9PT0gJ2RhdGUnKSB7XG4gICAgICAgICAgICAgIHVuaXRzID0gJ2RheSc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRPZih1bml0cykuYWRkKDEsICh1bml0cyA9PT0gJ2lzb1dlZWsnID8gJ3dlZWsnIDogdW5pdHMpKS5zdWJ0cmFjdCgxLCAnbXMnKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdG9fdHlwZV9fdmFsdWVPZiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2QudmFsdWVPZigpIC0gKCh0aGlzLl9vZmZzZXQgfHwgMCkgKiA2MDAwMCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHVuaXggKCkge1xuICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMudmFsdWVPZigpIC8gMTAwMCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRvRGF0ZSAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX29mZnNldCA/IG5ldyBEYXRlKHRoaXMudmFsdWVPZigpKSA6IHRoaXMuX2Q7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRvQXJyYXkgKCkge1xuICAgICAgICAgIHZhciBtID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gW20ueWVhcigpLCBtLm1vbnRoKCksIG0uZGF0ZSgpLCBtLmhvdXIoKSwgbS5taW51dGUoKSwgbS5zZWNvbmQoKSwgbS5taWxsaXNlY29uZCgpXTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdG9PYmplY3QgKCkge1xuICAgICAgICAgIHZhciBtID0gdGhpcztcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB5ZWFyczogbS55ZWFyKCksXG4gICAgICAgICAgICAgIG1vbnRoczogbS5tb250aCgpLFxuICAgICAgICAgICAgICBkYXRlOiBtLmRhdGUoKSxcbiAgICAgICAgICAgICAgaG91cnM6IG0uaG91cnMoKSxcbiAgICAgICAgICAgICAgbWludXRlczogbS5taW51dGVzKCksXG4gICAgICAgICAgICAgIHNlY29uZHM6IG0uc2Vjb25kcygpLFxuICAgICAgICAgICAgICBtaWxsaXNlY29uZHM6IG0ubWlsbGlzZWNvbmRzKClcbiAgICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0b0pTT04gKCkge1xuICAgICAgICAgIC8vIG5ldyBEYXRlKE5hTikudG9KU09OKCkgPT09IG51bGxcbiAgICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLnRvSVNPU3RyaW5nKCkgOiBudWxsO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBtb21lbnRfdmFsaWRfX2lzVmFsaWQgKCkge1xuICAgICAgICAgIHJldHVybiB2YWxpZF9faXNWYWxpZCh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcGFyc2luZ0ZsYWdzICgpIHtcbiAgICAgICAgICByZXR1cm4gZXh0ZW5kKHt9LCBnZXRQYXJzaW5nRmxhZ3ModGhpcykpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpbnZhbGlkQXQgKCkge1xuICAgICAgICAgIHJldHVybiBnZXRQYXJzaW5nRmxhZ3ModGhpcykub3ZlcmZsb3c7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNyZWF0aW9uRGF0YSgpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBpbnB1dDogdGhpcy5faSxcbiAgICAgICAgICAgICAgZm9ybWF0OiB0aGlzLl9mLFxuICAgICAgICAgICAgICBsb2NhbGU6IHRoaXMuX2xvY2FsZSxcbiAgICAgICAgICAgICAgaXNVVEM6IHRoaXMuX2lzVVRDLFxuICAgICAgICAgICAgICBzdHJpY3Q6IHRoaXMuX3N0cmljdFxuICAgICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIEZPUk1BVFRJTkdcblxuICAgICAgYWRkRm9ybWF0VG9rZW4oMCwgWydnZycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMud2Vla1llYXIoKSAlIDEwMDtcbiAgICAgIH0pO1xuXG4gICAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ0dHJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pc29XZWVrWWVhcigpICUgMTAwO1xuICAgICAgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4gKHRva2VuLCBnZXR0ZXIpIHtcbiAgICAgICAgICBhZGRGb3JtYXRUb2tlbigwLCBbdG9rZW4sIHRva2VuLmxlbmd0aF0sIDAsIGdldHRlcik7XG4gICAgICB9XG5cbiAgICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2cnLCAgICAgJ3dlZWtZZWFyJyk7XG4gICAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnZycsICAgICd3ZWVrWWVhcicpO1xuICAgICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignR0dHRycsICAnaXNvV2Vla1llYXInKTtcbiAgICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0dHJywgJ2lzb1dlZWtZZWFyJyk7XG5cbiAgICAgIC8vIEFMSUFTRVNcblxuICAgICAgYWRkVW5pdEFsaWFzKCd3ZWVrWWVhcicsICdnZycpO1xuICAgICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrWWVhcicsICdHRycpO1xuXG4gICAgICAvLyBQQVJTSU5HXG5cbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ0cnLCAgICAgIG1hdGNoU2lnbmVkKTtcbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ2cnLCAgICAgIG1hdGNoU2lnbmVkKTtcbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ0dHJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ2dnJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ0dHR0cnLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ2dnZ2cnLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ0dHR0dHJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ2dnZ2dnJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuICAgICAgYWRkV2Vla1BhcnNlVG9rZW4oWydnZ2dnJywgJ2dnZ2dnJywgJ0dHR0cnLCAnR0dHR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMildID0gdG9JbnQoaW5wdXQpO1xuICAgICAgfSk7XG5cbiAgICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZ2cnLCAnR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgICAgd2Vla1t0b2tlbl0gPSB1dGlsc19ob29rc19faG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIE1PTUVOVFNcblxuICAgICAgZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXIgKGlucHV0KSB7XG4gICAgICAgICAgcmV0dXJuIGdldFNldFdlZWtZZWFySGVscGVyLmNhbGwodGhpcyxcbiAgICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgICAgdGhpcy53ZWVrKCksXG4gICAgICAgICAgICAgICAgICB0aGlzLndlZWtkYXkoKSxcbiAgICAgICAgICAgICAgICAgIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdyxcbiAgICAgICAgICAgICAgICAgIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRveSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldFNldElTT1dlZWtZZWFyIChpbnB1dCkge1xuICAgICAgICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKHRoaXMsXG4gICAgICAgICAgICAgICAgICBpbnB1dCwgdGhpcy5pc29XZWVrKCksIHRoaXMuaXNvV2Vla2RheSgpLCAxLCA0KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0SVNPV2Vla3NJblllYXIgKCkge1xuICAgICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgMSwgNCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldFdlZWtzSW5ZZWFyICgpIHtcbiAgICAgICAgICB2YXIgd2Vla0luZm8gPSB0aGlzLmxvY2FsZURhdGEoKS5fd2VlaztcbiAgICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIHdlZWtJbmZvLmRvdywgd2Vla0luZm8uZG95KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXJIZWxwZXIoaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgICAgdmFyIHdlZWtzVGFyZ2V0O1xuICAgICAgICAgIGlmIChpbnB1dCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKHRoaXMsIGRvdywgZG95KS55ZWFyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdlZWtzVGFyZ2V0ID0gd2Vla3NJblllYXIoaW5wdXQsIGRvdywgZG95KTtcbiAgICAgICAgICAgICAgaWYgKHdlZWsgPiB3ZWVrc1RhcmdldCkge1xuICAgICAgICAgICAgICAgICAgd2VlayA9IHdlZWtzVGFyZ2V0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBzZXRXZWVrQWxsLmNhbGwodGhpcywgaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHNldFdlZWtBbGwod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgICAgdmFyIGRheU9mWWVhckRhdGEgPSBkYXlPZlllYXJGcm9tV2Vla3Mod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSxcbiAgICAgICAgICAgICAgZGF0ZSA9IGNyZWF0ZVVUQ0RhdGUoZGF5T2ZZZWFyRGF0YS55ZWFyLCAwLCBkYXlPZlllYXJEYXRhLmRheU9mWWVhcik7XG5cbiAgICAgICAgICB0aGlzLnllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpKTtcbiAgICAgICAgICB0aGlzLm1vbnRoKGRhdGUuZ2V0VVRDTW9udGgoKSk7XG4gICAgICAgICAgdGhpcy5kYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gRk9STUFUVElOR1xuXG4gICAgICBhZGRGb3JtYXRUb2tlbignUScsIDAsICdRbycsICdxdWFydGVyJyk7XG5cbiAgICAgIC8vIEFMSUFTRVNcblxuICAgICAgYWRkVW5pdEFsaWFzKCdxdWFydGVyJywgJ1EnKTtcblxuICAgICAgLy8gUEFSU0lOR1xuXG4gICAgICBhZGRSZWdleFRva2VuKCdRJywgbWF0Y2gxKTtcbiAgICAgIGFkZFBhcnNlVG9rZW4oJ1EnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgICAgYXJyYXlbTU9OVEhdID0gKHRvSW50KGlucHV0KSAtIDEpICogMztcbiAgICAgIH0pO1xuXG4gICAgICAvLyBNT01FTlRTXG5cbiAgICAgIGZ1bmN0aW9uIGdldFNldFF1YXJ0ZXIgKGlucHV0KSB7XG4gICAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBNYXRoLmNlaWwoKHRoaXMubW9udGgoKSArIDEpIC8gMykgOiB0aGlzLm1vbnRoKChpbnB1dCAtIDEpICogMyArIHRoaXMubW9udGgoKSAlIDMpO1xuICAgICAgfVxuXG4gICAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICAgIGFkZEZvcm1hdFRva2VuKCd3JywgWyd3dycsIDJdLCAnd28nLCAnd2VlaycpO1xuICAgICAgYWRkRm9ybWF0VG9rZW4oJ1cnLCBbJ1dXJywgMl0sICdXbycsICdpc29XZWVrJyk7XG5cbiAgICAgIC8vIEFMSUFTRVNcblxuICAgICAgYWRkVW5pdEFsaWFzKCd3ZWVrJywgJ3cnKTtcbiAgICAgIGFkZFVuaXRBbGlhcygnaXNvV2VlaycsICdXJyk7XG5cbiAgICAgIC8vIFBBUlNJTkdcblxuICAgICAgYWRkUmVnZXhUb2tlbigndycsICBtYXRjaDF0bzIpO1xuICAgICAgYWRkUmVnZXhUb2tlbignd3cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgICBhZGRSZWdleFRva2VuKCdXJywgIG1hdGNoMXRvMik7XG4gICAgICBhZGRSZWdleFRva2VuKCdXVycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuICAgICAgYWRkV2Vla1BhcnNlVG9rZW4oWyd3JywgJ3d3JywgJ1cnLCAnV1cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMSldID0gdG9JbnQoaW5wdXQpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEhFTFBFUlNcblxuICAgICAgLy8gTE9DQUxFU1xuXG4gICAgICBmdW5jdGlvbiBsb2NhbGVXZWVrIChtb20pIHtcbiAgICAgICAgICByZXR1cm4gd2Vla09mWWVhcihtb20sIHRoaXMuX3dlZWsuZG93LCB0aGlzLl93ZWVrLmRveSkud2VlaztcbiAgICAgIH1cblxuICAgICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrID0ge1xuICAgICAgICAgIGRvdyA6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgIGRveSA6IDYgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZXZWVrICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3c7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZZZWFyICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3k7XG4gICAgICB9XG5cbiAgICAgIC8vIE1PTUVOVFNcblxuICAgICAgZnVuY3Rpb24gZ2V0U2V0V2VlayAoaW5wdXQpIHtcbiAgICAgICAgICB2YXIgd2VlayA9IHRoaXMubG9jYWxlRGF0YSgpLndlZWsodGhpcyk7XG4gICAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRTZXRJU09XZWVrIChpbnB1dCkge1xuICAgICAgICAgIHZhciB3ZWVrID0gd2Vla09mWWVhcih0aGlzLCAxLCA0KS53ZWVrO1xuICAgICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbiAgICAgIH1cblxuICAgICAgLy8gRk9STUFUVElOR1xuXG4gICAgICBhZGRGb3JtYXRUb2tlbignRCcsIFsnREQnLCAyXSwgJ0RvJywgJ2RhdGUnKTtcblxuICAgICAgLy8gQUxJQVNFU1xuXG4gICAgICBhZGRVbml0QWxpYXMoJ2RhdGUnLCAnRCcpO1xuXG4gICAgICAvLyBQQVJTSU5HXG5cbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ0QnLCAgbWF0Y2gxdG8yKTtcbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ0REJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgICAgYWRkUmVnZXhUb2tlbignRG8nLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICAgIHJldHVybiBpc1N0cmljdCA/IGxvY2FsZS5fb3JkaW5hbFBhcnNlIDogbG9jYWxlLl9vcmRpbmFsUGFyc2VMZW5pZW50O1xuICAgICAgfSk7XG5cbiAgICAgIGFkZFBhcnNlVG9rZW4oWydEJywgJ0REJ10sIERBVEUpO1xuICAgICAgYWRkUGFyc2VUb2tlbignRG8nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgICAgYXJyYXlbREFURV0gPSB0b0ludChpbnB1dC5tYXRjaChtYXRjaDF0bzIpWzBdLCAxMCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gTU9NRU5UU1xuXG4gICAgICB2YXIgZ2V0U2V0RGF5T2ZNb250aCA9IG1ha2VHZXRTZXQoJ0RhdGUnLCB0cnVlKTtcblxuICAgICAgLy8gRk9STUFUVElOR1xuXG4gICAgICBhZGRGb3JtYXRUb2tlbignZCcsIDAsICdkbycsICdkYXknKTtcblxuICAgICAgYWRkRm9ybWF0VG9rZW4oJ2RkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c01pbih0aGlzLCBmb3JtYXQpO1xuICAgICAgfSk7XG5cbiAgICAgIGFkZEZvcm1hdFRva2VuKCdkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzU2hvcnQodGhpcywgZm9ybWF0KTtcbiAgICAgIH0pO1xuXG4gICAgICBhZGRGb3JtYXRUb2tlbignZGRkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXModGhpcywgZm9ybWF0KTtcbiAgICAgIH0pO1xuXG4gICAgICBhZGRGb3JtYXRUb2tlbignZScsIDAsIDAsICd3ZWVrZGF5Jyk7XG4gICAgICBhZGRGb3JtYXRUb2tlbignRScsIDAsIDAsICdpc29XZWVrZGF5Jyk7XG5cbiAgICAgIC8vIEFMSUFTRVNcblxuICAgICAgYWRkVW5pdEFsaWFzKCdkYXknLCAnZCcpO1xuICAgICAgYWRkVW5pdEFsaWFzKCd3ZWVrZGF5JywgJ2UnKTtcbiAgICAgIGFkZFVuaXRBbGlhcygnaXNvV2Vla2RheScsICdFJyk7XG5cbiAgICAgIC8vIFBBUlNJTkdcblxuICAgICAgYWRkUmVnZXhUb2tlbignZCcsICAgIG1hdGNoMXRvMik7XG4gICAgICBhZGRSZWdleFRva2VuKCdlJywgICAgbWF0Y2gxdG8yKTtcbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ0UnLCAgICBtYXRjaDF0bzIpO1xuICAgICAgYWRkUmVnZXhUb2tlbignZGQnLCAgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c01pblJlZ2V4KGlzU3RyaWN0KTtcbiAgICAgIH0pO1xuICAgICAgYWRkUmVnZXhUb2tlbignZGRkJywgICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbiAgICAgIH0pO1xuICAgICAgYWRkUmVnZXhUb2tlbignZGRkZCcsICAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzUmVnZXgoaXNTdHJpY3QpO1xuICAgICAgfSk7XG5cbiAgICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZGQnLCAnZGRkJywgJ2RkZGQnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgICAgdmFyIHdlZWtkYXkgPSBjb25maWcuX2xvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgICAgICAgIC8vIGlmIHdlIGRpZG4ndCBnZXQgYSB3ZWVrZGF5IG5hbWUsIG1hcmsgdGhlIGRhdGUgYXMgaW52YWxpZFxuICAgICAgICAgIGlmICh3ZWVrZGF5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgd2Vlay5kID0gd2Vla2RheTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkV2Vla2RheSA9IGlucHV0O1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2QnLCAnZScsICdFJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICAgIHdlZWtbdG9rZW5dID0gdG9JbnQoaW5wdXQpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEhFTFBFUlNcblxuICAgICAgZnVuY3Rpb24gcGFyc2VXZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFpc05hTihpbnB1dCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5wdXQgPSBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBMT0NBTEVTXG5cbiAgICAgIHZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXMgPSAnU3VuZGF5X01vbmRheV9UdWVzZGF5X1dlZG5lc2RheV9UaHVyc2RheV9GcmlkYXlfU2F0dXJkYXknLnNwbGl0KCdfJyk7XG4gICAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5cyAobSwgZm9ybWF0KSB7XG4gICAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fd2Vla2RheXMpID8gdGhpcy5fd2Vla2RheXNbbS5kYXkoKV0gOlxuICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1t0aGlzLl93ZWVrZGF5cy5pc0Zvcm1hdC50ZXN0KGZvcm1hdCkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ11bbS5kYXkoKV07XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCA9ICdTdW5fTW9uX1R1ZV9XZWRfVGh1X0ZyaV9TYXQnLnNwbGl0KCdfJyk7XG4gICAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1Nob3J0IChtKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRbbS5kYXkoKV07XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4gPSAnU3VfTW9fVHVfV2VfVGhfRnJfU2EnLnNwbGl0KCdfJyk7XG4gICAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c01pbiAobSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblttLmRheSgpXTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGF5X29mX3dlZWtfX2hhbmRsZVN0cmljdFBhcnNlKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICAgIHZhciBpLCBpaSwgbW9tLCBsbGMgPSB3ZWVrZGF5TmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlID0gW107XG5cbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7ICsraSkge1xuICAgICAgICAgICAgICAgICAgbW9tID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXMobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09ICdkZGQnKSB7XG4gICAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcbiAgICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzUGFyc2UgKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgICByZXR1cm4gZGF5X29mX3dlZWtfX2hhbmRsZVN0cmljdFBhcnNlLmNhbGwodGhpcywgd2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2UpIHtcbiAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG5cbiAgICAgICAgICAgICAgbW9tID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMud2Vla2RheXMobW9tLCAnJykucmVwbGFjZSgnLicsICdcXC4/JykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcLj8nKSArICckJywgJ2knKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykucmVwbGFjZSgnLicsICdcXC4/JykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgICByZWdleCA9ICdeJyArIHRoaXMud2Vla2RheXMobW9tLCAnJykgKyAnfF4nICsgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpICsgJ3xeJyArIHRoaXMud2Vla2RheXNNaW4obW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGRkZCcgJiYgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZGQnICYmIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkJyAmJiB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBNT01FTlRTXG5cbiAgICAgIGZ1bmN0aW9uIGdldFNldERheU9mV2VlayAoaW5wdXQpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGRheSA9IHRoaXMuX2lzVVRDID8gdGhpcy5fZC5nZXRVVENEYXkoKSA6IHRoaXMuX2QuZ2V0RGF5KCk7XG4gICAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgaW5wdXQgPSBwYXJzZVdlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGlucHV0IC0gZGF5LCAnZCcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBkYXk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRTZXRMb2NhbGVEYXlPZldlZWsgKGlucHV0KSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB3ZWVrZGF5ID0gKHRoaXMuZGF5KCkgKyA3IC0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93KSAlIDc7XG4gICAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrZGF5IDogdGhpcy5hZGQoaW5wdXQgLSB3ZWVrZGF5LCAnZCcpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRTZXRJU09EYXlPZldlZWsgKGlucHV0KSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGJlaGF2ZXMgdGhlIHNhbWUgYXMgbW9tZW50I2RheSBleGNlcHRcbiAgICAgICAgICAvLyBhcyBhIGdldHRlciwgcmV0dXJucyA3IGluc3RlYWQgb2YgMCAoMS03IHJhbmdlIGluc3RlYWQgb2YgMC02KVxuICAgICAgICAgIC8vIGFzIGEgc2V0dGVyLCBzdW5kYXkgc2hvdWxkIGJlbG9uZyB0byB0aGUgcHJldmlvdXMgd2Vlay5cbiAgICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHRoaXMuZGF5KCkgfHwgNyA6IHRoaXMuZGF5KHRoaXMuZGF5KCkgJSA3ID8gaW5wdXQgOiBpbnB1dCAtIDcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVmYXVsdFdlZWtkYXlzUmVnZXggPSBtYXRjaFdvcmQ7XG4gICAgICBmdW5jdGlvbiB3ZWVrZGF5c1JlZ2V4IChpc1N0cmljdCkge1xuICAgICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgICBjb21wdXRlV2Vla2RheXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXg7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggOiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXggPSBtYXRjaFdvcmQ7XG4gICAgICBmdW5jdGlvbiB3ZWVrZGF5c1Nob3J0UmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGRlZmF1bHRXZWVrZGF5c01pblJlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgICAgZnVuY3Rpb24gd2Vla2RheXNNaW5SZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgICB9XG4gICAgICB9XG5cblxuICAgICAgZnVuY3Rpb24gY29tcHV0ZVdlZWtkYXlzUGFyc2UgKCkge1xuICAgICAgICAgIGZ1bmN0aW9uIGNtcExlblJldihhLCBiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBtaW5QaWVjZXMgPSBbXSwgc2hvcnRQaWVjZXMgPSBbXSwgbG9uZ1BpZWNlcyA9IFtdLCBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgICBpLCBtb20sIG1pbnAsIHNob3J0cCwgbG9uZ3A7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgICAgbW9tID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgICBtaW5wID0gdGhpcy53ZWVrZGF5c01pbihtb20sICcnKTtcbiAgICAgICAgICAgICAgc2hvcnRwID0gdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpO1xuICAgICAgICAgICAgICBsb25ncCA9IHRoaXMud2Vla2RheXMobW9tLCAnJyk7XG4gICAgICAgICAgICAgIG1pblBpZWNlcy5wdXNoKG1pbnApO1xuICAgICAgICAgICAgICBzaG9ydFBpZWNlcy5wdXNoKHNob3J0cCk7XG4gICAgICAgICAgICAgIGxvbmdQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2gobWlucCk7XG4gICAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2goc2hvcnRwKTtcbiAgICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgd2Vla2RheSAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlciBpdFxuICAgICAgICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cbiAgICAgICAgICBtaW5QaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICAgIHNob3J0UGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgICBzaG9ydFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKHNob3J0UGllY2VzW2ldKTtcbiAgICAgICAgICAgICAgbG9uZ1BpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKGxvbmdQaWVjZXNbaV0pO1xuICAgICAgICAgICAgICBtaXhlZFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKG1peGVkUGllY2VzW2ldKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl93ZWVrZGF5c1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWl4ZWRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5SZWdleCA9IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG5cbiAgICAgICAgICB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbG9uZ1BpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICAgIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaW5QaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgfVxuXG4gICAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICAgIGFkZEZvcm1hdFRva2VuKCdEREQnLCBbJ0REREQnLCAzXSwgJ0RERG8nLCAnZGF5T2ZZZWFyJyk7XG5cbiAgICAgIC8vIEFMSUFTRVNcblxuICAgICAgYWRkVW5pdEFsaWFzKCdkYXlPZlllYXInLCAnREREJyk7XG5cbiAgICAgIC8vIFBBUlNJTkdcblxuICAgICAgYWRkUmVnZXhUb2tlbignREREJywgIG1hdGNoMXRvMyk7XG4gICAgICBhZGRSZWdleFRva2VuKCdEREREJywgbWF0Y2gzKTtcbiAgICAgIGFkZFBhcnNlVG9rZW4oWydEREQnLCAnRERERCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRvSW50KGlucHV0KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBIRUxQRVJTXG5cbiAgICAgIC8vIE1PTUVOVFNcblxuICAgICAgZnVuY3Rpb24gZ2V0U2V0RGF5T2ZZZWFyIChpbnB1dCkge1xuICAgICAgICAgIHZhciBkYXlPZlllYXIgPSBNYXRoLnJvdW5kKCh0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykgLSB0aGlzLmNsb25lKCkuc3RhcnRPZigneWVhcicpKSAvIDg2NGU1KSArIDE7XG4gICAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBkYXlPZlllYXIgOiB0aGlzLmFkZCgoaW5wdXQgLSBkYXlPZlllYXIpLCAnZCcpO1xuICAgICAgfVxuXG4gICAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICAgIGZ1bmN0aW9uIGhGb3JtYXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaG91cnMoKSAlIDEyIHx8IDEyO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBrRm9ybWF0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmhvdXJzKCkgfHwgMjQ7XG4gICAgICB9XG5cbiAgICAgIGFkZEZvcm1hdFRva2VuKCdIJywgWydISCcsIDJdLCAwLCAnaG91cicpO1xuICAgICAgYWRkRm9ybWF0VG9rZW4oJ2gnLCBbJ2hoJywgMl0sIDAsIGhGb3JtYXQpO1xuICAgICAgYWRkRm9ybWF0VG9rZW4oJ2snLCBbJ2trJywgMl0sIDAsIGtGb3JtYXQpO1xuXG4gICAgICBhZGRGb3JtYXRUb2tlbignaG1tJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiAnJyArIGhGb3JtYXQuYXBwbHkodGhpcykgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMik7XG4gICAgICB9KTtcblxuICAgICAgYWRkRm9ybWF0VG9rZW4oJ2htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiAnJyArIGhGb3JtYXQuYXBwbHkodGhpcykgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMikgK1xuICAgICAgICAgICAgICB6ZXJvRmlsbCh0aGlzLnNlY29uZHMoKSwgMik7XG4gICAgICB9KTtcblxuICAgICAgYWRkRm9ybWF0VG9rZW4oJ0htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gJycgKyB0aGlzLmhvdXJzKCkgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMik7XG4gICAgICB9KTtcblxuICAgICAgYWRkRm9ybWF0VG9rZW4oJ0htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiAnJyArIHRoaXMuaG91cnMoKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKSArXG4gICAgICAgICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKTtcbiAgICAgIH0pO1xuXG4gICAgICBmdW5jdGlvbiBtZXJpZGllbSAodG9rZW4sIGxvd2VyY2FzZSkge1xuICAgICAgICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tZXJpZGllbSh0aGlzLmhvdXJzKCksIHRoaXMubWludXRlcygpLCBsb3dlcmNhc2UpO1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBtZXJpZGllbSgnYScsIHRydWUpO1xuICAgICAgbWVyaWRpZW0oJ0EnLCBmYWxzZSk7XG5cbiAgICAgIC8vIEFMSUFTRVNcblxuICAgICAgYWRkVW5pdEFsaWFzKCdob3VyJywgJ2gnKTtcblxuICAgICAgLy8gUEFSU0lOR1xuXG4gICAgICBmdW5jdGlvbiBtYXRjaE1lcmlkaWVtIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgICAgcmV0dXJuIGxvY2FsZS5fbWVyaWRpZW1QYXJzZTtcbiAgICAgIH1cblxuICAgICAgYWRkUmVnZXhUb2tlbignYScsICBtYXRjaE1lcmlkaWVtKTtcbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ0EnLCAgbWF0Y2hNZXJpZGllbSk7XG4gICAgICBhZGRSZWdleFRva2VuKCdIJywgIG1hdGNoMXRvMik7XG4gICAgICBhZGRSZWdleFRva2VuKCdoJywgIG1hdGNoMXRvMik7XG4gICAgICBhZGRSZWdleFRva2VuKCdISCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ2hoJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuXG4gICAgICBhZGRSZWdleFRva2VuKCdobW0nLCBtYXRjaDN0bzQpO1xuICAgICAgYWRkUmVnZXhUb2tlbignaG1tc3MnLCBtYXRjaDV0bzYpO1xuICAgICAgYWRkUmVnZXhUb2tlbignSG1tJywgbWF0Y2gzdG80KTtcbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ0htbXNzJywgbWF0Y2g1dG82KTtcblxuICAgICAgYWRkUGFyc2VUb2tlbihbJ0gnLCAnSEgnXSwgSE9VUik7XG4gICAgICBhZGRQYXJzZVRva2VuKFsnYScsICdBJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICAgIGNvbmZpZy5faXNQbSA9IGNvbmZpZy5fbG9jYWxlLmlzUE0oaW5wdXQpO1xuICAgICAgICAgIGNvbmZpZy5fbWVyaWRpZW0gPSBpbnB1dDtcbiAgICAgIH0pO1xuICAgICAgYWRkUGFyc2VUb2tlbihbJ2gnLCAnaGgnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIGFkZFBhcnNlVG9rZW4oJ2htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvcykpO1xuICAgICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIGFkZFBhcnNlVG9rZW4oJ2htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgICAgdmFyIHBvczEgPSBpbnB1dC5sZW5ndGggLSA0O1xuICAgICAgICAgIHZhciBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MxLCAyKSk7XG4gICAgICAgICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIGFkZFBhcnNlVG9rZW4oJ0htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvcykpO1xuICAgICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgICB9KTtcbiAgICAgIGFkZFBhcnNlVG9rZW4oJ0htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgICAgdmFyIHBvczEgPSBpbnB1dC5sZW5ndGggLSA0O1xuICAgICAgICAgIHZhciBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MxLCAyKSk7XG4gICAgICAgICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gTE9DQUxFU1xuXG4gICAgICBmdW5jdGlvbiBsb2NhbGVJc1BNIChpbnB1dCkge1xuICAgICAgICAgIC8vIElFOCBRdWlya3MgTW9kZSAmIElFNyBTdGFuZGFyZHMgTW9kZSBkbyBub3QgYWxsb3cgYWNjZXNzaW5nIHN0cmluZ3MgbGlrZSBhcnJheXNcbiAgICAgICAgICAvLyBVc2luZyBjaGFyQXQgc2hvdWxkIGJlIG1vcmUgY29tcGF0aWJsZS5cbiAgICAgICAgICByZXR1cm4gKChpbnB1dCArICcnKS50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gJ3AnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlID0gL1thcF1cXC4/bT9cXC4/L2k7XG4gICAgICBmdW5jdGlvbiBsb2NhbGVNZXJpZGllbSAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICAgICAgICBpZiAoaG91cnMgPiAxMSkge1xuICAgICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdwbScgOiAnUE0nO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ2FtJyA6ICdBTSc7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG5cbiAgICAgIC8vIE1PTUVOVFNcblxuICAgICAgLy8gU2V0dGluZyB0aGUgaG91ciBzaG91bGQga2VlcCB0aGUgdGltZSwgYmVjYXVzZSB0aGUgdXNlciBleHBsaWNpdGx5XG4gICAgICAvLyBzcGVjaWZpZWQgd2hpY2ggaG91ciBoZSB3YW50cy4gU28gdHJ5aW5nIHRvIG1haW50YWluIHRoZSBzYW1lIGhvdXIgKGluXG4gICAgICAvLyBhIG5ldyB0aW1lem9uZSkgbWFrZXMgc2Vuc2UuIEFkZGluZy9zdWJ0cmFjdGluZyBob3VycyBkb2VzIG5vdCBmb2xsb3dcbiAgICAgIC8vIHRoaXMgcnVsZS5cbiAgICAgIHZhciBnZXRTZXRIb3VyID0gbWFrZUdldFNldCgnSG91cnMnLCB0cnVlKTtcblxuICAgICAgLy8gRk9STUFUVElOR1xuXG4gICAgICBhZGRGb3JtYXRUb2tlbignbScsIFsnbW0nLCAyXSwgMCwgJ21pbnV0ZScpO1xuXG4gICAgICAvLyBBTElBU0VTXG5cbiAgICAgIGFkZFVuaXRBbGlhcygnbWludXRlJywgJ20nKTtcblxuICAgICAgLy8gUEFSU0lOR1xuXG4gICAgICBhZGRSZWdleFRva2VuKCdtJywgIG1hdGNoMXRvMik7XG4gICAgICBhZGRSZWdleFRva2VuKCdtbScsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICAgIGFkZFBhcnNlVG9rZW4oWydtJywgJ21tJ10sIE1JTlVURSk7XG5cbiAgICAgIC8vIE1PTUVOVFNcblxuICAgICAgdmFyIGdldFNldE1pbnV0ZSA9IG1ha2VHZXRTZXQoJ01pbnV0ZXMnLCBmYWxzZSk7XG5cbiAgICAgIC8vIEZPUk1BVFRJTkdcblxuICAgICAgYWRkRm9ybWF0VG9rZW4oJ3MnLCBbJ3NzJywgMl0sIDAsICdzZWNvbmQnKTtcblxuICAgICAgLy8gQUxJQVNFU1xuXG4gICAgICBhZGRVbml0QWxpYXMoJ3NlY29uZCcsICdzJyk7XG5cbiAgICAgIC8vIFBBUlNJTkdcblxuICAgICAgYWRkUmVnZXhUb2tlbigncycsICBtYXRjaDF0bzIpO1xuICAgICAgYWRkUmVnZXhUb2tlbignc3MnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgICBhZGRQYXJzZVRva2VuKFsncycsICdzcyddLCBTRUNPTkQpO1xuXG4gICAgICAvLyBNT01FTlRTXG5cbiAgICAgIHZhciBnZXRTZXRTZWNvbmQgPSBtYWtlR2V0U2V0KCdTZWNvbmRzJywgZmFsc2UpO1xuXG4gICAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICAgIGFkZEZvcm1hdFRva2VuKCdTJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMDApO1xuICAgICAgfSk7XG5cbiAgICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1MnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMCk7XG4gICAgICB9KTtcblxuICAgICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1MnLCAzXSwgMCwgJ21pbGxpc2Vjb25kJyk7XG4gICAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1MnLCA0XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDtcbiAgICAgIH0pO1xuICAgICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTUycsIDVdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDtcbiAgICAgIH0pO1xuICAgICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1MnLCA2XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwO1xuICAgICAgfSk7XG4gICAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1MnLCA3XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDtcbiAgICAgIH0pO1xuICAgICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTUycsIDhdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDtcbiAgICAgIH0pO1xuICAgICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTU1MnLCA5XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDAwO1xuICAgICAgfSk7XG5cblxuICAgICAgLy8gQUxJQVNFU1xuXG4gICAgICBhZGRVbml0QWxpYXMoJ21pbGxpc2Vjb25kJywgJ21zJyk7XG5cbiAgICAgIC8vIFBBUlNJTkdcblxuICAgICAgYWRkUmVnZXhUb2tlbignUycsICAgIG1hdGNoMXRvMywgbWF0Y2gxKTtcbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ1NTJywgICBtYXRjaDF0bzMsIG1hdGNoMik7XG4gICAgICBhZGRSZWdleFRva2VuKCdTU1MnLCAgbWF0Y2gxdG8zLCBtYXRjaDMpO1xuXG4gICAgICB2YXIgdG9rZW47XG4gICAgICBmb3IgKHRva2VuID0gJ1NTU1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgICAgICAgYWRkUmVnZXhUb2tlbih0b2tlbiwgbWF0Y2hVbnNpZ25lZCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHBhcnNlTXMoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgICAgYXJyYXlbTUlMTElTRUNPTkRdID0gdG9JbnQoKCcwLicgKyBpbnB1dCkgKiAxMDAwKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh0b2tlbiA9ICdTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgICAgICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIHBhcnNlTXMpO1xuICAgICAgfVxuICAgICAgLy8gTU9NRU5UU1xuXG4gICAgICB2YXIgZ2V0U2V0TWlsbGlzZWNvbmQgPSBtYWtlR2V0U2V0KCdNaWxsaXNlY29uZHMnLCBmYWxzZSk7XG5cbiAgICAgIC8vIEZPUk1BVFRJTkdcblxuICAgICAgYWRkRm9ybWF0VG9rZW4oJ3onLCAgMCwgMCwgJ3pvbmVBYmJyJyk7XG4gICAgICBhZGRGb3JtYXRUb2tlbignenonLCAwLCAwLCAnem9uZU5hbWUnKTtcblxuICAgICAgLy8gTU9NRU5UU1xuXG4gICAgICBmdW5jdGlvbiBnZXRab25lQWJiciAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ1VUQycgOiAnJztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0Wm9uZU5hbWUgKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdDb29yZGluYXRlZCBVbml2ZXJzYWwgVGltZScgOiAnJztcbiAgICAgIH1cblxuICAgICAgdmFyIG1vbWVudFByb3RvdHlwZV9fcHJvdG8gPSBNb21lbnQucHJvdG90eXBlO1xuXG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmFkZCAgICAgICAgICAgICAgID0gYWRkX3N1YnRyYWN0X19hZGQ7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmNhbGVuZGFyICAgICAgICAgID0gbW9tZW50X2NhbGVuZGFyX19jYWxlbmRhcjtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uY2xvbmUgICAgICAgICAgICAgPSBjbG9uZTtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGlmZiAgICAgICAgICAgICAgPSBkaWZmO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5lbmRPZiAgICAgICAgICAgICA9IGVuZE9mO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5mb3JtYXQgICAgICAgICAgICA9IGZvcm1hdDtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZnJvbSAgICAgICAgICAgICAgPSBmcm9tO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5mcm9tTm93ICAgICAgICAgICA9IGZyb21Ob3c7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvICAgICAgICAgICAgICAgID0gdG87XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvTm93ICAgICAgICAgICAgID0gdG9Ob3c7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmdldCAgICAgICAgICAgICAgID0gZ2V0U2V0O1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pbnZhbGlkQXQgICAgICAgICA9IGludmFsaWRBdDtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNBZnRlciAgICAgICAgICAgPSBpc0FmdGVyO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0JlZm9yZSAgICAgICAgICA9IGlzQmVmb3JlO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0JldHdlZW4gICAgICAgICA9IGlzQmV0d2VlbjtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNTYW1lICAgICAgICAgICAgPSBpc1NhbWU7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzU2FtZU9yQWZ0ZXIgICAgID0gaXNTYW1lT3JBZnRlcjtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNTYW1lT3JCZWZvcmUgICAgPSBpc1NhbWVPckJlZm9yZTtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNWYWxpZCAgICAgICAgICAgPSBtb21lbnRfdmFsaWRfX2lzVmFsaWQ7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmxhbmcgICAgICAgICAgICAgID0gbGFuZztcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubG9jYWxlICAgICAgICAgICAgPSBsb2NhbGU7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmxvY2FsZURhdGEgICAgICAgID0gbG9jYWxlRGF0YTtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubWF4ICAgICAgICAgICAgICAgPSBwcm90b3R5cGVNYXg7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1pbiAgICAgICAgICAgICAgID0gcHJvdG90eXBlTWluO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5wYXJzaW5nRmxhZ3MgICAgICA9IHBhcnNpbmdGbGFncztcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uc2V0ICAgICAgICAgICAgICAgPSBnZXRTZXQ7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnN0YXJ0T2YgICAgICAgICAgID0gc3RhcnRPZjtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uc3VidHJhY3QgICAgICAgICAgPSBhZGRfc3VidHJhY3RfX3N1YnRyYWN0O1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by50b0FycmF5ICAgICAgICAgICA9IHRvQXJyYXk7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvT2JqZWN0ICAgICAgICAgID0gdG9PYmplY3Q7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvRGF0ZSAgICAgICAgICAgID0gdG9EYXRlO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by50b0lTT1N0cmluZyAgICAgICA9IG1vbWVudF9mb3JtYXRfX3RvSVNPU3RyaW5nO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by50b0pTT04gICAgICAgICAgICA9IHRvSlNPTjtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9TdHJpbmcgICAgICAgICAgPSB0b1N0cmluZztcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udW5peCAgICAgICAgICAgICAgPSB1bml4O1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by52YWx1ZU9mICAgICAgICAgICA9IHRvX3R5cGVfX3ZhbHVlT2Y7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmNyZWF0aW9uRGF0YSAgICAgID0gY3JlYXRpb25EYXRhO1xuXG4gICAgICAvLyBZZWFyXG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnllYXIgICAgICAgPSBnZXRTZXRZZWFyO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0xlYXBZZWFyID0gZ2V0SXNMZWFwWWVhcjtcblxuICAgICAgLy8gV2VlayBZZWFyXG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLndlZWtZZWFyICAgID0gZ2V0U2V0V2Vla1llYXI7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzb1dlZWtZZWFyID0gZ2V0U2V0SVNPV2Vla1llYXI7XG5cbiAgICAgIC8vIFF1YXJ0ZXJcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ucXVhcnRlciA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8ucXVhcnRlcnMgPSBnZXRTZXRRdWFydGVyO1xuXG4gICAgICAvLyBNb250aFxuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5tb250aCAgICAgICA9IGdldFNldE1vbnRoO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5kYXlzSW5Nb250aCA9IGdldERheXNJbk1vbnRoO1xuXG4gICAgICAvLyBXZWVrXG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLndlZWsgICAgICAgICAgID0gbW9tZW50UHJvdG90eXBlX19wcm90by53ZWVrcyAgICAgICAgPSBnZXRTZXRXZWVrO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc29XZWVrICAgICAgICA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNvV2Vla3MgICAgID0gZ2V0U2V0SVNPV2VlaztcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ud2Vla3NJblllYXIgICAgPSBnZXRXZWVrc0luWWVhcjtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNvV2Vla3NJblllYXIgPSBnZXRJU09XZWVrc0luWWVhcjtcblxuICAgICAgLy8gRGF5XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRhdGUgICAgICAgPSBnZXRTZXREYXlPZk1vbnRoO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5kYXkgICAgICAgID0gbW9tZW50UHJvdG90eXBlX19wcm90by5kYXlzICAgICAgICAgICAgID0gZ2V0U2V0RGF5T2ZXZWVrO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by53ZWVrZGF5ICAgID0gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc29XZWVrZGF5ID0gZ2V0U2V0SVNPRGF5T2ZXZWVrO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5kYXlPZlllYXIgID0gZ2V0U2V0RGF5T2ZZZWFyO1xuXG4gICAgICAvLyBIb3VyXG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmhvdXIgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmhvdXJzID0gZ2V0U2V0SG91cjtcblxuICAgICAgLy8gTWludXRlXG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1pbnV0ZSA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubWludXRlcyA9IGdldFNldE1pbnV0ZTtcblxuICAgICAgLy8gU2Vjb25kXG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnNlY29uZCA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8uc2Vjb25kcyA9IGdldFNldFNlY29uZDtcblxuICAgICAgLy8gTWlsbGlzZWNvbmRcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubWlsbGlzZWNvbmQgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1pbGxpc2Vjb25kcyA9IGdldFNldE1pbGxpc2Vjb25kO1xuXG4gICAgICAvLyBPZmZzZXRcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udXRjT2Zmc2V0ICAgICAgICAgICAgPSBnZXRTZXRPZmZzZXQ7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnV0YyAgICAgICAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9VVEM7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmxvY2FsICAgICAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9Mb2NhbDtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ucGFyc2Vab25lICAgICAgICAgICAgPSBzZXRPZmZzZXRUb1BhcnNlZE9mZnNldDtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaGFzQWxpZ25lZEhvdXJPZmZzZXQgPSBoYXNBbGlnbmVkSG91ck9mZnNldDtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNEU1QgICAgICAgICAgICAgICAgPSBpc0RheWxpZ2h0U2F2aW5nVGltZTtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNEU1RTaGlmdGVkICAgICAgICAgPSBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQ7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzTG9jYWwgICAgICAgICAgICAgID0gaXNMb2NhbDtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNVdGNPZmZzZXQgICAgICAgICAgPSBpc1V0Y09mZnNldDtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNVdGMgICAgICAgICAgICAgICAgPSBpc1V0YztcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNVVEMgICAgICAgICAgICAgICAgPSBpc1V0YztcblxuICAgICAgLy8gVGltZXpvbmVcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uem9uZUFiYnIgPSBnZXRab25lQWJicjtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uem9uZU5hbWUgPSBnZXRab25lTmFtZTtcblxuICAgICAgLy8gRGVwcmVjYXRpb25zXG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRhdGVzICA9IGRlcHJlY2F0ZSgnZGF0ZXMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIGRhdGUgaW5zdGVhZC4nLCBnZXRTZXREYXlPZk1vbnRoKTtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubW9udGhzID0gZGVwcmVjYXRlKCdtb250aHMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbnRoIGluc3RlYWQnLCBnZXRTZXRNb250aCk7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnllYXJzICA9IGRlcHJlY2F0ZSgneWVhcnMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIHllYXIgaW5zdGVhZCcsIGdldFNldFllYXIpO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by56b25lICAgPSBkZXByZWNhdGUoJ21vbWVudCgpLnpvbmUgaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudCgpLnV0Y09mZnNldCBpbnN0ZWFkLiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTc3OScsIGdldFNldFpvbmUpO1xuXG4gICAgICB2YXIgbW9tZW50UHJvdG90eXBlID0gbW9tZW50UHJvdG90eXBlX19wcm90bztcblxuICAgICAgZnVuY3Rpb24gbW9tZW50X19jcmVhdGVVbml4IChpbnB1dCkge1xuICAgICAgICAgIHJldHVybiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQgKiAxMDAwKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbW9tZW50X19jcmVhdGVJblpvbmUgKCkge1xuICAgICAgICAgIHJldHVybiBsb2NhbF9fY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5wYXJzZVpvbmUoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRlZmF1bHRDYWxlbmRhciA9IHtcbiAgICAgICAgICBzYW1lRGF5IDogJ1tUb2RheSBhdF0gTFQnLFxuICAgICAgICAgIG5leHREYXkgOiAnW1RvbW9ycm93IGF0XSBMVCcsXG4gICAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBbYXRdIExUJyxcbiAgICAgICAgICBsYXN0RGF5IDogJ1tZZXN0ZXJkYXkgYXRdIExUJyxcbiAgICAgICAgICBsYXN0V2VlayA6ICdbTGFzdF0gZGRkZCBbYXRdIExUJyxcbiAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgfTtcblxuICAgICAgZnVuY3Rpb24gbG9jYWxlX2NhbGVuZGFyX19jYWxlbmRhciAoa2V5LCBtb20sIG5vdykge1xuICAgICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9jYWxlbmRhcltrZXldO1xuICAgICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKG91dHB1dCkgPyBvdXRwdXQuY2FsbChtb20sIG5vdykgOiBvdXRwdXQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQgPSB7XG4gICAgICAgICAgTFRTICA6ICdoOm1tOnNzIEEnLFxuICAgICAgICAgIExUICAgOiAnaDptbSBBJyxcbiAgICAgICAgICBMICAgIDogJ01NL0REL1lZWVknLFxuICAgICAgICAgIExMICAgOiAnTU1NTSBELCBZWVlZJyxcbiAgICAgICAgICBMTEwgIDogJ01NTU0gRCwgWVlZWSBoOm1tIEEnLFxuICAgICAgICAgIExMTEwgOiAnZGRkZCwgTU1NTSBELCBZWVlZIGg6bW0gQSdcbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIGxvbmdEYXRlRm9ybWF0IChrZXkpIHtcbiAgICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSxcbiAgICAgICAgICAgICAgZm9ybWF0VXBwZXIgPSB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXkudG9VcHBlckNhc2UoKV07XG5cbiAgICAgICAgICBpZiAoZm9ybWF0IHx8ICFmb3JtYXRVcHBlcikge1xuICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0gPSBmb3JtYXRVcHBlci5yZXBsYWNlKC9NTU1NfE1NfEREfGRkZGQvZywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICByZXR1cm4gdmFsLnNsaWNlKDEpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV07XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWZhdWx0SW52YWxpZERhdGUgPSAnSW52YWxpZCBkYXRlJztcblxuICAgICAgZnVuY3Rpb24gaW52YWxpZERhdGUgKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9pbnZhbGlkRGF0ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRlZmF1bHRPcmRpbmFsID0gJyVkJztcbiAgICAgIHZhciBkZWZhdWx0T3JkaW5hbFBhcnNlID0gL1xcZHsxLDJ9LztcblxuICAgICAgZnVuY3Rpb24gb3JkaW5hbCAobnVtYmVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX29yZGluYWwucmVwbGFjZSgnJWQnLCBudW1iZXIpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwcmVQYXJzZVBvc3RGb3JtYXQgKHN0cmluZykge1xuICAgICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWZhdWx0UmVsYXRpdmVUaW1lID0ge1xuICAgICAgICAgIGZ1dHVyZSA6ICdpbiAlcycsXG4gICAgICAgICAgcGFzdCAgIDogJyVzIGFnbycsXG4gICAgICAgICAgcyAgOiAnYSBmZXcgc2Vjb25kcycsXG4gICAgICAgICAgbSAgOiAnYSBtaW51dGUnLFxuICAgICAgICAgIG1tIDogJyVkIG1pbnV0ZXMnLFxuICAgICAgICAgIGggIDogJ2FuIGhvdXInLFxuICAgICAgICAgIGhoIDogJyVkIGhvdXJzJyxcbiAgICAgICAgICBkICA6ICdhIGRheScsXG4gICAgICAgICAgZGQgOiAnJWQgZGF5cycsXG4gICAgICAgICAgTSAgOiAnYSBtb250aCcsXG4gICAgICAgICAgTU0gOiAnJWQgbW9udGhzJyxcbiAgICAgICAgICB5ICA6ICdhIHllYXInLFxuICAgICAgICAgIHl5IDogJyVkIHllYXJzJ1xuICAgICAgfTtcblxuICAgICAgZnVuY3Rpb24gcmVsYXRpdmVfX3JlbGF0aXZlVGltZSAobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSB7XG4gICAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuX3JlbGF0aXZlVGltZVtzdHJpbmddO1xuICAgICAgICAgIHJldHVybiAoaXNGdW5jdGlvbihvdXRwdXQpKSA/XG4gICAgICAgICAgICAgIG91dHB1dChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIDpcbiAgICAgICAgICAgICAgb3V0cHV0LnJlcGxhY2UoLyVkL2ksIG51bWJlcik7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHBhc3RGdXR1cmUgKGRpZmYsIG91dHB1dCkge1xuICAgICAgICAgIHZhciBmb3JtYXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbZGlmZiA+IDAgPyAnZnV0dXJlJyA6ICdwYXN0J107XG4gICAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oZm9ybWF0KSA/IGZvcm1hdChvdXRwdXQpIDogZm9ybWF0LnJlcGxhY2UoLyVzL2ksIG91dHB1dCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm90b3R5cGVfX3Byb3RvID0gTG9jYWxlLnByb3RvdHlwZTtcblxuICAgICAgcHJvdG90eXBlX19wcm90by5fY2FsZW5kYXIgICAgICAgPSBkZWZhdWx0Q2FsZW5kYXI7XG4gICAgICBwcm90b3R5cGVfX3Byb3RvLmNhbGVuZGFyICAgICAgICA9IGxvY2FsZV9jYWxlbmRhcl9fY2FsZW5kYXI7XG4gICAgICBwcm90b3R5cGVfX3Byb3RvLl9sb25nRGF0ZUZvcm1hdCA9IGRlZmF1bHRMb25nRGF0ZUZvcm1hdDtcbiAgICAgIHByb3RvdHlwZV9fcHJvdG8ubG9uZ0RhdGVGb3JtYXQgID0gbG9uZ0RhdGVGb3JtYXQ7XG4gICAgICBwcm90b3R5cGVfX3Byb3RvLl9pbnZhbGlkRGF0ZSAgICA9IGRlZmF1bHRJbnZhbGlkRGF0ZTtcbiAgICAgIHByb3RvdHlwZV9fcHJvdG8uaW52YWxpZERhdGUgICAgID0gaW52YWxpZERhdGU7XG4gICAgICBwcm90b3R5cGVfX3Byb3RvLl9vcmRpbmFsICAgICAgICA9IGRlZmF1bHRPcmRpbmFsO1xuICAgICAgcHJvdG90eXBlX19wcm90by5vcmRpbmFsICAgICAgICAgPSBvcmRpbmFsO1xuICAgICAgcHJvdG90eXBlX19wcm90by5fb3JkaW5hbFBhcnNlICAgPSBkZWZhdWx0T3JkaW5hbFBhcnNlO1xuICAgICAgcHJvdG90eXBlX19wcm90by5wcmVwYXJzZSAgICAgICAgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG4gICAgICBwcm90b3R5cGVfX3Byb3RvLnBvc3Rmb3JtYXQgICAgICA9IHByZVBhcnNlUG9zdEZvcm1hdDtcbiAgICAgIHByb3RvdHlwZV9fcHJvdG8uX3JlbGF0aXZlVGltZSAgID0gZGVmYXVsdFJlbGF0aXZlVGltZTtcbiAgICAgIHByb3RvdHlwZV9fcHJvdG8ucmVsYXRpdmVUaW1lICAgID0gcmVsYXRpdmVfX3JlbGF0aXZlVGltZTtcbiAgICAgIHByb3RvdHlwZV9fcHJvdG8ucGFzdEZ1dHVyZSAgICAgID0gcGFzdEZ1dHVyZTtcbiAgICAgIHByb3RvdHlwZV9fcHJvdG8uc2V0ICAgICAgICAgICAgID0gbG9jYWxlX3NldF9fc2V0O1xuXG4gICAgICAvLyBNb250aFxuICAgICAgcHJvdG90eXBlX19wcm90by5tb250aHMgICAgICAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHM7XG4gICAgICBwcm90b3R5cGVfX3Byb3RvLl9tb250aHMgICAgICAgICAgID0gZGVmYXVsdExvY2FsZU1vbnRocztcbiAgICAgIHByb3RvdHlwZV9fcHJvdG8ubW9udGhzU2hvcnQgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzU2hvcnQ7XG4gICAgICBwcm90b3R5cGVfX3Byb3RvLl9tb250aHNTaG9ydCAgICAgID0gZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0O1xuICAgICAgcHJvdG90eXBlX19wcm90by5tb250aHNQYXJzZSAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHNQYXJzZTtcbiAgICAgIHByb3RvdHlwZV9fcHJvdG8uX21vbnRoc1JlZ2V4ICAgICAgPSBkZWZhdWx0TW9udGhzUmVnZXg7XG4gICAgICBwcm90b3R5cGVfX3Byb3RvLm1vbnRoc1JlZ2V4ICAgICAgID0gbW9udGhzUmVnZXg7XG4gICAgICBwcm90b3R5cGVfX3Byb3RvLl9tb250aHNTaG9ydFJlZ2V4ID0gZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXg7XG4gICAgICBwcm90b3R5cGVfX3Byb3RvLm1vbnRoc1Nob3J0UmVnZXggID0gbW9udGhzU2hvcnRSZWdleDtcblxuICAgICAgLy8gV2Vla1xuICAgICAgcHJvdG90eXBlX19wcm90by53ZWVrID0gbG9jYWxlV2VlaztcbiAgICAgIHByb3RvdHlwZV9fcHJvdG8uX3dlZWsgPSBkZWZhdWx0TG9jYWxlV2VlaztcbiAgICAgIHByb3RvdHlwZV9fcHJvdG8uZmlyc3REYXlPZlllYXIgPSBsb2NhbGVGaXJzdERheU9mWWVhcjtcbiAgICAgIHByb3RvdHlwZV9fcHJvdG8uZmlyc3REYXlPZldlZWsgPSBsb2NhbGVGaXJzdERheU9mV2VlaztcblxuICAgICAgLy8gRGF5IG9mIFdlZWtcbiAgICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXMgICAgICAgPSAgICAgICAgbG9jYWxlV2Vla2RheXM7XG4gICAgICBwcm90b3R5cGVfX3Byb3RvLl93ZWVrZGF5cyAgICAgID0gZGVmYXVsdExvY2FsZVdlZWtkYXlzO1xuICAgICAgcHJvdG90eXBlX19wcm90by53ZWVrZGF5c01pbiAgICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c01pbjtcbiAgICAgIHByb3RvdHlwZV9fcHJvdG8uX3dlZWtkYXlzTWluICAgPSBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW47XG4gICAgICBwcm90b3R5cGVfX3Byb3RvLndlZWtkYXlzU2hvcnQgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzU2hvcnQ7XG4gICAgICBwcm90b3R5cGVfX3Byb3RvLl93ZWVrZGF5c1Nob3J0ID0gZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQ7XG4gICAgICBwcm90b3R5cGVfX3Byb3RvLndlZWtkYXlzUGFyc2UgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzUGFyc2U7XG5cbiAgICAgIHByb3RvdHlwZV9fcHJvdG8uX3dlZWtkYXlzUmVnZXggICAgICA9IGRlZmF1bHRXZWVrZGF5c1JlZ2V4O1xuICAgICAgcHJvdG90eXBlX19wcm90by53ZWVrZGF5c1JlZ2V4ICAgICAgID0gICAgICAgIHdlZWtkYXlzUmVnZXg7XG4gICAgICBwcm90b3R5cGVfX3Byb3RvLl93ZWVrZGF5c1Nob3J0UmVnZXggPSBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgcHJvdG90eXBlX19wcm90by53ZWVrZGF5c1Nob3J0UmVnZXggID0gICAgICAgIHdlZWtkYXlzU2hvcnRSZWdleDtcbiAgICAgIHByb3RvdHlwZV9fcHJvdG8uX3dlZWtkYXlzTWluUmVnZXggICA9IGRlZmF1bHRXZWVrZGF5c01pblJlZ2V4O1xuICAgICAgcHJvdG90eXBlX19wcm90by53ZWVrZGF5c01pblJlZ2V4ICAgID0gICAgICAgIHdlZWtkYXlzTWluUmVnZXg7XG5cbiAgICAgIC8vIEhvdXJzXG4gICAgICBwcm90b3R5cGVfX3Byb3RvLmlzUE0gPSBsb2NhbGVJc1BNO1xuICAgICAgcHJvdG90eXBlX19wcm90by5fbWVyaWRpZW1QYXJzZSA9IGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlO1xuICAgICAgcHJvdG90eXBlX19wcm90by5tZXJpZGllbSA9IGxvY2FsZU1lcmlkaWVtO1xuXG4gICAgICBmdW5jdGlvbiBsaXN0c19fZ2V0IChmb3JtYXQsIGluZGV4LCBmaWVsZCwgc2V0dGVyKSB7XG4gICAgICAgICAgdmFyIGxvY2FsZSA9IGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUoKTtcbiAgICAgICAgICB2YXIgdXRjID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKCkuc2V0KHNldHRlciwgaW5kZXgpO1xuICAgICAgICAgIHJldHVybiBsb2NhbGVbZmllbGRdKHV0YywgZm9ybWF0KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbGlzdE1vbnRoc0ltcGwgKGZvcm1hdCwgaW5kZXgsIGZpZWxkKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuXG4gICAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGxpc3RzX19nZXQoZm9ybWF0LCBpbmRleCwgZmllbGQsICdtb250aCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBpO1xuICAgICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgICBvdXRbaV0gPSBsaXN0c19fZ2V0KGZvcm1hdCwgaSwgZmllbGQsICdtb250aCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgfVxuXG4gICAgICAvLyAoKVxuICAgICAgLy8gKDUpXG4gICAgICAvLyAoZm10LCA1KVxuICAgICAgLy8gKGZtdClcbiAgICAgIC8vICh0cnVlKVxuICAgICAgLy8gKHRydWUsIDUpXG4gICAgICAvLyAodHJ1ZSwgZm10LCA1KVxuICAgICAgLy8gKHRydWUsIGZtdClcbiAgICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c0ltcGwgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgZmllbGQpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGxvY2FsZVNvcnRlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgZm9ybWF0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZm9ybWF0ID0gbG9jYWxlU29ydGVkO1xuICAgICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgICAgbG9jYWxlU29ydGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbG9jYWxlID0gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZSgpLFxuICAgICAgICAgICAgICBzaGlmdCA9IGxvY2FsZVNvcnRlZCA/IGxvY2FsZS5fd2Vlay5kb3cgOiAwO1xuXG4gICAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGxpc3RzX19nZXQoZm9ybWF0LCAoaW5kZXggKyBzaGlmdCkgJSA3LCBmaWVsZCwgJ2RheScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBpO1xuICAgICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICAgIG91dFtpXSA9IGxpc3RzX19nZXQoZm9ybWF0LCAoaSArIHNoaWZ0KSAlIDcsIGZpZWxkLCAnZGF5Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGxpc3RzX19saXN0TW9udGhzIChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHMnKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbGlzdHNfX2xpc3RNb250aHNTaG9ydCAoZm9ybWF0LCBpbmRleCkge1xuICAgICAgICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzU2hvcnQnKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbGlzdHNfX2xpc3RXZWVrZGF5cyAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXMnKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbGlzdHNfX2xpc3RXZWVrZGF5c1Nob3J0IChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c1Nob3J0Jyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGxpc3RzX19saXN0V2Vla2RheXNNaW4gKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzTWluJyk7XG4gICAgICB9XG5cbiAgICAgIGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGUoJ2VuJywge1xuICAgICAgICAgIG9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KHRofHN0fG5kfHJkKS8sXG4gICAgICAgICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgICAgdmFyIGIgPSBudW1iZXIgJSAxMCxcbiAgICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0b0ludChudW1iZXIgJSAxMDAgLyAxMCkgPT09IDEpID8gJ3RoJyA6XG4gICAgICAgICAgICAgICAgICAoYiA9PT0gMSkgPyAnc3QnIDpcbiAgICAgICAgICAgICAgICAgIChiID09PSAyKSA/ICduZCcgOlxuICAgICAgICAgICAgICAgICAgKGIgPT09IDMpID8gJ3JkJyA6ICd0aCc7XG4gICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcbiAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5sYW5nID0gZGVwcmVjYXRlKCdtb21lbnQubGFuZyBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZSBpbnN0ZWFkLicsIGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGUpO1xuICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLmxhbmdEYXRhID0gZGVwcmVjYXRlKCdtb21lbnQubGFuZ0RhdGEgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGVEYXRhIGluc3RlYWQuJywgbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZSk7XG5cbiAgICAgIHZhciBtYXRoQWJzID0gTWF0aC5hYnM7XG5cbiAgICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2Fic19fYWJzICgpIHtcbiAgICAgICAgICB2YXIgZGF0YSAgICAgICAgICAgPSB0aGlzLl9kYXRhO1xuXG4gICAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gbWF0aEFicyh0aGlzLl9taWxsaXNlY29uZHMpO1xuICAgICAgICAgIHRoaXMuX2RheXMgICAgICAgICA9IG1hdGhBYnModGhpcy5fZGF5cyk7XG4gICAgICAgICAgdGhpcy5fbW9udGhzICAgICAgID0gbWF0aEFicyh0aGlzLl9tb250aHMpO1xuXG4gICAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgID0gbWF0aEFicyhkYXRhLm1pbGxpc2Vjb25kcyk7XG4gICAgICAgICAgZGF0YS5zZWNvbmRzICAgICAgID0gbWF0aEFicyhkYXRhLnNlY29uZHMpO1xuICAgICAgICAgIGRhdGEubWludXRlcyAgICAgICA9IG1hdGhBYnMoZGF0YS5taW51dGVzKTtcbiAgICAgICAgICBkYXRhLmhvdXJzICAgICAgICAgPSBtYXRoQWJzKGRhdGEuaG91cnMpO1xuICAgICAgICAgIGRhdGEubW9udGhzICAgICAgICA9IG1hdGhBYnMoZGF0YS5tb250aHMpO1xuICAgICAgICAgIGRhdGEueWVhcnMgICAgICAgICA9IG1hdGhBYnMoZGF0YS55ZWFycyk7XG5cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19hZGRTdWJ0cmFjdCAoZHVyYXRpb24sIGlucHV0LCB2YWx1ZSwgZGlyZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlX19jcmVhdGVEdXJhdGlvbihpbnB1dCwgdmFsdWUpO1xuXG4gICAgICAgICAgZHVyYXRpb24uX21pbGxpc2Vjb25kcyArPSBkaXJlY3Rpb24gKiBvdGhlci5fbWlsbGlzZWNvbmRzO1xuICAgICAgICAgIGR1cmF0aW9uLl9kYXlzICAgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX2RheXM7XG4gICAgICAgICAgZHVyYXRpb24uX21vbnRocyAgICAgICArPSBkaXJlY3Rpb24gKiBvdGhlci5fbW9udGhzO1xuXG4gICAgICAgICAgcmV0dXJuIGR1cmF0aW9uLl9idWJibGUoKTtcbiAgICAgIH1cblxuICAgICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgYWRkKDEsICdzJykgb3IgYWRkKGR1cmF0aW9uKVxuICAgICAgZnVuY3Rpb24gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19hZGQgKGlucHV0LCB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX2FkZFN1YnRyYWN0KHRoaXMsIGlucHV0LCB2YWx1ZSwgMSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIHN1YnRyYWN0KDEsICdzJykgb3Igc3VidHJhY3QoZHVyYXRpb24pXG4gICAgICBmdW5jdGlvbiBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX3N1YnRyYWN0IChpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19hZGRTdWJ0cmFjdCh0aGlzLCBpbnB1dCwgdmFsdWUsIC0xKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYWJzQ2VpbCAobnVtYmVyKSB7XG4gICAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG51bWJlcik7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBidWJibGUgKCkge1xuICAgICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHM7XG4gICAgICAgICAgdmFyIGRheXMgICAgICAgICA9IHRoaXMuX2RheXM7XG4gICAgICAgICAgdmFyIG1vbnRocyAgICAgICA9IHRoaXMuX21vbnRocztcbiAgICAgICAgICB2YXIgZGF0YSAgICAgICAgID0gdGhpcy5fZGF0YTtcbiAgICAgICAgICB2YXIgc2Vjb25kcywgbWludXRlcywgaG91cnMsIHllYXJzLCBtb250aHNGcm9tRGF5cztcblxuICAgICAgICAgIC8vIGlmIHdlIGhhdmUgYSBtaXggb2YgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcywgYnViYmxlIGRvd24gZmlyc3RcbiAgICAgICAgICAvLyBjaGVjazogaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzIxNjZcbiAgICAgICAgICBpZiAoISgobWlsbGlzZWNvbmRzID49IDAgJiYgZGF5cyA+PSAwICYmIG1vbnRocyA+PSAwKSB8fFxuICAgICAgICAgICAgICAgICAgKG1pbGxpc2Vjb25kcyA8PSAwICYmIGRheXMgPD0gMCAmJiBtb250aHMgPD0gMCkpKSB7XG4gICAgICAgICAgICAgIG1pbGxpc2Vjb25kcyArPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHMpICsgZGF5cykgKiA4NjRlNTtcbiAgICAgICAgICAgICAgZGF5cyA9IDA7XG4gICAgICAgICAgICAgIG1vbnRocyA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBjb2RlIGJ1YmJsZXMgdXAgdmFsdWVzLCBzZWUgdGhlIHRlc3RzIGZvclxuICAgICAgICAgIC8vIGV4YW1wbGVzIG9mIHdoYXQgdGhhdCBtZWFucy5cbiAgICAgICAgICBkYXRhLm1pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kcyAlIDEwMDA7XG5cbiAgICAgICAgICBzZWNvbmRzICAgICAgICAgICA9IGFic0Zsb29yKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xuICAgICAgICAgIGRhdGEuc2Vjb25kcyAgICAgID0gc2Vjb25kcyAlIDYwO1xuXG4gICAgICAgICAgbWludXRlcyAgICAgICAgICAgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xuICAgICAgICAgIGRhdGEubWludXRlcyAgICAgID0gbWludXRlcyAlIDYwO1xuXG4gICAgICAgICAgaG91cnMgICAgICAgICAgICAgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgICAgICAgIGRhdGEuaG91cnMgICAgICAgID0gaG91cnMgJSAyNDtcblxuICAgICAgICAgIGRheXMgKz0gYWJzRmxvb3IoaG91cnMgLyAyNCk7XG5cbiAgICAgICAgICAvLyBjb252ZXJ0IGRheXMgdG8gbW9udGhzXG4gICAgICAgICAgbW9udGhzRnJvbURheXMgPSBhYnNGbG9vcihkYXlzVG9Nb250aHMoZGF5cykpO1xuICAgICAgICAgIG1vbnRocyArPSBtb250aHNGcm9tRGF5cztcbiAgICAgICAgICBkYXlzIC09IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRoc0Zyb21EYXlzKSk7XG5cbiAgICAgICAgICAvLyAxMiBtb250aHMgLT4gMSB5ZWFyXG4gICAgICAgICAgeWVhcnMgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgICAgICAgbW9udGhzICU9IDEyO1xuXG4gICAgICAgICAgZGF0YS5kYXlzICAgPSBkYXlzO1xuICAgICAgICAgIGRhdGEubW9udGhzID0gbW9udGhzO1xuICAgICAgICAgIGRhdGEueWVhcnMgID0geWVhcnM7XG5cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGF5c1RvTW9udGhzIChkYXlzKSB7XG4gICAgICAgICAgLy8gNDAwIHllYXJzIGhhdmUgMTQ2MDk3IGRheXMgKHRha2luZyBpbnRvIGFjY291bnQgbGVhcCB5ZWFyIHJ1bGVzKVxuICAgICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDEyIG1vbnRocyA9PT0gNDgwMFxuICAgICAgICAgIHJldHVybiBkYXlzICogNDgwMCAvIDE0NjA5NztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbW9udGhzVG9EYXlzIChtb250aHMpIHtcbiAgICAgICAgICAvLyB0aGUgcmV2ZXJzZSBvZiBkYXlzVG9Nb250aHNcbiAgICAgICAgICByZXR1cm4gbW9udGhzICogMTQ2MDk3IC8gNDgwMDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYXMgKHVuaXRzKSB7XG4gICAgICAgICAgdmFyIGRheXM7XG4gICAgICAgICAgdmFyIG1vbnRocztcbiAgICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzO1xuXG4gICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICAgICAgICBpZiAodW5pdHMgPT09ICdtb250aCcgfHwgdW5pdHMgPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgICBkYXlzICAgPSB0aGlzLl9kYXlzICAgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgICAgbW9udGhzID0gdGhpcy5fbW9udGhzICsgZGF5c1RvTW9udGhzKGRheXMpO1xuICAgICAgICAgICAgICByZXR1cm4gdW5pdHMgPT09ICdtb250aCcgPyBtb250aHMgOiBtb250aHMgLyAxMjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBoYW5kbGUgbWlsbGlzZWNvbmRzIHNlcGFyYXRlbHkgYmVjYXVzZSBvZiBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyAoaXNzdWUgIzE4NjcpXG4gICAgICAgICAgICAgIGRheXMgPSB0aGlzLl9kYXlzICsgTWF0aC5yb3VuZChtb250aHNUb0RheXModGhpcy5fbW9udGhzKSk7XG4gICAgICAgICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ3dlZWsnICAgOiByZXR1cm4gZGF5cyAvIDcgICAgICsgbWlsbGlzZWNvbmRzIC8gNjA0OGU1O1xuICAgICAgICAgICAgICAgICAgY2FzZSAnZGF5JyAgICA6IHJldHVybiBkYXlzICAgICAgICAgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ2hvdXInICAgOiByZXR1cm4gZGF5cyAqIDI0ICAgICsgbWlsbGlzZWNvbmRzIC8gMzZlNTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ21pbnV0ZScgOiByZXR1cm4gZGF5cyAqIDE0NDAgICsgbWlsbGlzZWNvbmRzIC8gNmU0O1xuICAgICAgICAgICAgICAgICAgY2FzZSAnc2Vjb25kJyA6IHJldHVybiBkYXlzICogODY0MDAgKyBtaWxsaXNlY29uZHMgLyAxMDAwO1xuICAgICAgICAgICAgICAgICAgLy8gTWF0aC5mbG9vciBwcmV2ZW50cyBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyBoZXJlXG4gICAgICAgICAgICAgICAgICBjYXNlICdtaWxsaXNlY29uZCc6IHJldHVybiBNYXRoLmZsb29yKGRheXMgKiA4NjRlNSkgKyBtaWxsaXNlY29uZHM7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdW5pdCAnICsgdW5pdHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUT0RPOiBVc2UgdGhpcy5hcygnbXMnKT9cbiAgICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2FzX192YWx1ZU9mICgpIHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgK1xuICAgICAgICAgICAgICB0aGlzLl9kYXlzICogODY0ZTUgK1xuICAgICAgICAgICAgICAodGhpcy5fbW9udGhzICUgMTIpICogMjU5MmU2ICtcbiAgICAgICAgICAgICAgdG9JbnQodGhpcy5fbW9udGhzIC8gMTIpICogMzE1MzZlNlxuICAgICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG1ha2VBcyAoYWxpYXMpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hcyhhbGlhcyk7XG4gICAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFzTWlsbGlzZWNvbmRzID0gbWFrZUFzKCdtcycpO1xuICAgICAgdmFyIGFzU2Vjb25kcyAgICAgID0gbWFrZUFzKCdzJyk7XG4gICAgICB2YXIgYXNNaW51dGVzICAgICAgPSBtYWtlQXMoJ20nKTtcbiAgICAgIHZhciBhc0hvdXJzICAgICAgICA9IG1ha2VBcygnaCcpO1xuICAgICAgdmFyIGFzRGF5cyAgICAgICAgID0gbWFrZUFzKCdkJyk7XG4gICAgICB2YXIgYXNXZWVrcyAgICAgICAgPSBtYWtlQXMoJ3cnKTtcbiAgICAgIHZhciBhc01vbnRocyAgICAgICA9IG1ha2VBcygnTScpO1xuICAgICAgdmFyIGFzWWVhcnMgICAgICAgID0gbWFrZUFzKCd5Jyk7XG5cbiAgICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2dldF9fZ2V0ICh1bml0cykge1xuICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICAgIHJldHVybiB0aGlzW3VuaXRzICsgJ3MnXSgpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBtYWtlR2V0dGVyKG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YVtuYW1lXTtcbiAgICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB2YXIgbWlsbGlzZWNvbmRzID0gbWFrZUdldHRlcignbWlsbGlzZWNvbmRzJyk7XG4gICAgICB2YXIgc2Vjb25kcyAgICAgID0gbWFrZUdldHRlcignc2Vjb25kcycpO1xuICAgICAgdmFyIG1pbnV0ZXMgICAgICA9IG1ha2VHZXR0ZXIoJ21pbnV0ZXMnKTtcbiAgICAgIHZhciBob3VycyAgICAgICAgPSBtYWtlR2V0dGVyKCdob3VycycpO1xuICAgICAgdmFyIGRheXMgICAgICAgICA9IG1ha2VHZXR0ZXIoJ2RheXMnKTtcbiAgICAgIHZhciBtb250aHMgICAgICAgPSBtYWtlR2V0dGVyKCdtb250aHMnKTtcbiAgICAgIHZhciB5ZWFycyAgICAgICAgPSBtYWtlR2V0dGVyKCd5ZWFycycpO1xuXG4gICAgICBmdW5jdGlvbiB3ZWVrcyAoKSB7XG4gICAgICAgICAgcmV0dXJuIGFic0Zsb29yKHRoaXMuZGF5cygpIC8gNyk7XG4gICAgICB9XG5cbiAgICAgIHZhciByb3VuZCA9IE1hdGgucm91bmQ7XG4gICAgICB2YXIgdGhyZXNob2xkcyA9IHtcbiAgICAgICAgICBzOiA0NSwgIC8vIHNlY29uZHMgdG8gbWludXRlXG4gICAgICAgICAgbTogNDUsICAvLyBtaW51dGVzIHRvIGhvdXJcbiAgICAgICAgICBoOiAyMiwgIC8vIGhvdXJzIHRvIGRheVxuICAgICAgICAgIGQ6IDI2LCAgLy8gZGF5cyB0byBtb250aFxuICAgICAgICAgIE06IDExICAgLy8gbW9udGhzIHRvIHllYXJcbiAgICAgIH07XG5cbiAgICAgIC8vIGhlbHBlciBmdW5jdGlvbiBmb3IgbW9tZW50LmZuLmZyb20sIG1vbWVudC5mbi5mcm9tTm93LCBhbmQgbW9tZW50LmR1cmF0aW9uLmZuLmh1bWFuaXplXG4gICAgICBmdW5jdGlvbiBzdWJzdGl0dXRlVGltZUFnbyhzdHJpbmcsIG51bWJlciwgd2l0aG91dFN1ZmZpeCwgaXNGdXR1cmUsIGxvY2FsZSkge1xuICAgICAgICAgIHJldHVybiBsb2NhbGUucmVsYXRpdmVUaW1lKG51bWJlciB8fCAxLCAhIXdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkdXJhdGlvbl9odW1hbml6ZV9fcmVsYXRpdmVUaW1lIChwb3NOZWdEdXJhdGlvbiwgd2l0aG91dFN1ZmZpeCwgbG9jYWxlKSB7XG4gICAgICAgICAgdmFyIGR1cmF0aW9uID0gY3JlYXRlX19jcmVhdGVEdXJhdGlvbihwb3NOZWdEdXJhdGlvbikuYWJzKCk7XG4gICAgICAgICAgdmFyIHNlY29uZHMgID0gcm91bmQoZHVyYXRpb24uYXMoJ3MnKSk7XG4gICAgICAgICAgdmFyIG1pbnV0ZXMgID0gcm91bmQoZHVyYXRpb24uYXMoJ20nKSk7XG4gICAgICAgICAgdmFyIGhvdXJzICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ2gnKSk7XG4gICAgICAgICAgdmFyIGRheXMgICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ2QnKSk7XG4gICAgICAgICAgdmFyIG1vbnRocyAgID0gcm91bmQoZHVyYXRpb24uYXMoJ00nKSk7XG4gICAgICAgICAgdmFyIHllYXJzICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ3knKSk7XG5cbiAgICAgICAgICB2YXIgYSA9IHNlY29uZHMgPCB0aHJlc2hvbGRzLnMgJiYgWydzJywgc2Vjb25kc10gIHx8XG4gICAgICAgICAgICAgICAgICBtaW51dGVzIDw9IDEgICAgICAgICAgICYmIFsnbSddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgICAgbWludXRlcyA8IHRocmVzaG9sZHMubSAmJiBbJ21tJywgbWludXRlc10gfHxcbiAgICAgICAgICAgICAgICAgIGhvdXJzICAgPD0gMSAgICAgICAgICAgJiYgWydoJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgICBob3VycyAgIDwgdGhyZXNob2xkcy5oICYmIFsnaGgnLCBob3Vyc10gICB8fFxuICAgICAgICAgICAgICAgICAgZGF5cyAgICA8PSAxICAgICAgICAgICAmJiBbJ2QnXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICAgIGRheXMgICAgPCB0aHJlc2hvbGRzLmQgJiYgWydkZCcsIGRheXNdICAgIHx8XG4gICAgICAgICAgICAgICAgICBtb250aHMgIDw9IDEgICAgICAgICAgICYmIFsnTSddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgICAgbW9udGhzICA8IHRocmVzaG9sZHMuTSAmJiBbJ01NJywgbW9udGhzXSAgfHxcbiAgICAgICAgICAgICAgICAgIHllYXJzICAgPD0gMSAgICAgICAgICAgJiYgWyd5J10gICAgICAgICAgIHx8IFsneXknLCB5ZWFyc107XG5cbiAgICAgICAgICBhWzJdID0gd2l0aG91dFN1ZmZpeDtcbiAgICAgICAgICBhWzNdID0gK3Bvc05lZ0R1cmF0aW9uID4gMDtcbiAgICAgICAgICBhWzRdID0gbG9jYWxlO1xuICAgICAgICAgIHJldHVybiBzdWJzdGl0dXRlVGltZUFnby5hcHBseShudWxsLCBhKTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCBhIHRocmVzaG9sZCBmb3IgcmVsYXRpdmUgdGltZSBzdHJpbmdzXG4gICAgICBmdW5jdGlvbiBkdXJhdGlvbl9odW1hbml6ZV9fZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkICh0aHJlc2hvbGQsIGxpbWl0KSB7XG4gICAgICAgICAgaWYgKHRocmVzaG9sZHNbdGhyZXNob2xkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxpbWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRocmVzaG9sZHNbdGhyZXNob2xkXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyZXNob2xkc1t0aHJlc2hvbGRdID0gbGltaXQ7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGh1bWFuaXplICh3aXRoU3VmZml4KSB7XG4gICAgICAgICAgdmFyIGxvY2FsZSA9IHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICAgIHZhciBvdXRwdXQgPSBkdXJhdGlvbl9odW1hbml6ZV9fcmVsYXRpdmVUaW1lKHRoaXMsICF3aXRoU3VmZml4LCBsb2NhbGUpO1xuXG4gICAgICAgICAgaWYgKHdpdGhTdWZmaXgpIHtcbiAgICAgICAgICAgICAgb3V0cHV0ID0gbG9jYWxlLnBhc3RGdXR1cmUoK3RoaXMsIG91dHB1dCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGxvY2FsZS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpc29fc3RyaW5nX19hYnMgPSBNYXRoLmFicztcblxuICAgICAgZnVuY3Rpb24gaXNvX3N0cmluZ19fdG9JU09TdHJpbmcoKSB7XG4gICAgICAgICAgLy8gZm9yIElTTyBzdHJpbmdzIHdlIGRvIG5vdCB1c2UgdGhlIG5vcm1hbCBidWJibGluZyBydWxlczpcbiAgICAgICAgICAvLyAgKiBtaWxsaXNlY29uZHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIGhvdXJzXG4gICAgICAgICAgLy8gICogZGF5cyBkbyBub3QgYnViYmxlIGF0IGFsbFxuICAgICAgICAgIC8vICAqIG1vbnRocyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgeWVhcnNcbiAgICAgICAgICAvLyBUaGlzIGlzIGJlY2F1c2UgdGhlcmUgaXMgbm8gY29udGV4dC1mcmVlIGNvbnZlcnNpb24gYmV0d2VlbiBob3VycyBhbmQgZGF5c1xuICAgICAgICAgIC8vICh0aGluayBvZiBjbG9jayBjaGFuZ2VzKVxuICAgICAgICAgIC8vIGFuZCBhbHNvIG5vdCBiZXR3ZWVuIGRheXMgYW5kIG1vbnRocyAoMjgtMzEgZGF5cyBwZXIgbW9udGgpXG4gICAgICAgICAgdmFyIHNlY29uZHMgPSBpc29fc3RyaW5nX19hYnModGhpcy5fbWlsbGlzZWNvbmRzKSAvIDEwMDA7XG4gICAgICAgICAgdmFyIGRheXMgICAgICAgICA9IGlzb19zdHJpbmdfX2Ficyh0aGlzLl9kYXlzKTtcbiAgICAgICAgICB2YXIgbW9udGhzICAgICAgID0gaXNvX3N0cmluZ19fYWJzKHRoaXMuX21vbnRocyk7XG4gICAgICAgICAgdmFyIG1pbnV0ZXMsIGhvdXJzLCB5ZWFycztcblxuICAgICAgICAgIC8vIDM2MDAgc2Vjb25kcyAtPiA2MCBtaW51dGVzIC0+IDEgaG91clxuICAgICAgICAgIG1pbnV0ZXMgICAgICAgICAgID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgICBob3VycyAgICAgICAgICAgICA9IGFic0Zsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgICAgc2Vjb25kcyAlPSA2MDtcbiAgICAgICAgICBtaW51dGVzICU9IDYwO1xuXG4gICAgICAgICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgICAgICAgIHllYXJzICA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICAgICAgICBtb250aHMgJT0gMTI7XG5cblxuICAgICAgICAgIC8vIGluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9kb3JkaWxsZS9tb21lbnQtaXNvZHVyYXRpb24vYmxvYi9tYXN0ZXIvbW9tZW50Lmlzb2R1cmF0aW9uLmpzXG4gICAgICAgICAgdmFyIFkgPSB5ZWFycztcbiAgICAgICAgICB2YXIgTSA9IG1vbnRocztcbiAgICAgICAgICB2YXIgRCA9IGRheXM7XG4gICAgICAgICAgdmFyIGggPSBob3VycztcbiAgICAgICAgICB2YXIgbSA9IG1pbnV0ZXM7XG4gICAgICAgICAgdmFyIHMgPSBzZWNvbmRzO1xuICAgICAgICAgIHZhciB0b3RhbCA9IHRoaXMuYXNTZWNvbmRzKCk7XG5cbiAgICAgICAgICBpZiAoIXRvdGFsKSB7XG4gICAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIHNhbWUgYXMgQyMncyAoTm9kYSkgYW5kIHB5dGhvbiAoaXNvZGF0ZSkuLi5cbiAgICAgICAgICAgICAgLy8gYnV0IG5vdCBvdGhlciBKUyAoZ29vZy5kYXRlKVxuICAgICAgICAgICAgICByZXR1cm4gJ1AwRCc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuICh0b3RhbCA8IDAgPyAnLScgOiAnJykgK1xuICAgICAgICAgICAgICAnUCcgK1xuICAgICAgICAgICAgICAoWSA/IFkgKyAnWScgOiAnJykgK1xuICAgICAgICAgICAgICAoTSA/IE0gKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgICAoRCA/IEQgKyAnRCcgOiAnJykgK1xuICAgICAgICAgICAgICAoKGggfHwgbSB8fCBzKSA/ICdUJyA6ICcnKSArXG4gICAgICAgICAgICAgIChoID8gaCArICdIJyA6ICcnKSArXG4gICAgICAgICAgICAgIChtID8gbSArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAgIChzID8gcyArICdTJyA6ICcnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8gPSBEdXJhdGlvbi5wcm90b3R5cGU7XG5cbiAgICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYWJzICAgICAgICAgICAgPSBkdXJhdGlvbl9hYnNfX2FicztcbiAgICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYWRkICAgICAgICAgICAgPSBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX2FkZDtcbiAgICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uc3VidHJhY3QgICAgICAgPSBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX3N1YnRyYWN0O1xuICAgICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hcyAgICAgICAgICAgICA9IGFzO1xuICAgICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc01pbGxpc2Vjb25kcyA9IGFzTWlsbGlzZWNvbmRzO1xuICAgICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc1NlY29uZHMgICAgICA9IGFzU2Vjb25kcztcbiAgICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNNaW51dGVzICAgICAgPSBhc01pbnV0ZXM7XG4gICAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzSG91cnMgICAgICAgID0gYXNIb3VycztcbiAgICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNEYXlzICAgICAgICAgPSBhc0RheXM7XG4gICAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzV2Vla3MgICAgICAgID0gYXNXZWVrcztcbiAgICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNNb250aHMgICAgICAgPSBhc01vbnRocztcbiAgICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNZZWFycyAgICAgICAgPSBhc1llYXJzO1xuICAgICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by52YWx1ZU9mICAgICAgICA9IGR1cmF0aW9uX2FzX192YWx1ZU9mO1xuICAgICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5fYnViYmxlICAgICAgICA9IGJ1YmJsZTtcbiAgICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uZ2V0ICAgICAgICAgICAgPSBkdXJhdGlvbl9nZXRfX2dldDtcbiAgICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubWlsbGlzZWNvbmRzICAgPSBtaWxsaXNlY29uZHM7XG4gICAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnNlY29uZHMgICAgICAgID0gc2Vjb25kcztcbiAgICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubWludXRlcyAgICAgICAgPSBtaW51dGVzO1xuICAgICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5ob3VycyAgICAgICAgICA9IGhvdXJzO1xuICAgICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5kYXlzICAgICAgICAgICA9IGRheXM7XG4gICAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLndlZWtzICAgICAgICAgID0gd2Vla3M7XG4gICAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLm1vbnRocyAgICAgICAgID0gbW9udGhzO1xuICAgICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by55ZWFycyAgICAgICAgICA9IHllYXJzO1xuICAgICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5odW1hbml6ZSAgICAgICA9IGh1bWFuaXplO1xuICAgICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by50b0lTT1N0cmluZyAgICA9IGlzb19zdHJpbmdfX3RvSVNPU3RyaW5nO1xuICAgICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by50b1N0cmluZyAgICAgICA9IGlzb19zdHJpbmdfX3RvSVNPU3RyaW5nO1xuICAgICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by50b0pTT04gICAgICAgICA9IGlzb19zdHJpbmdfX3RvSVNPU3RyaW5nO1xuICAgICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5sb2NhbGUgICAgICAgICA9IGxvY2FsZTtcbiAgICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubG9jYWxlRGF0YSAgICAgPSBsb2NhbGVEYXRhO1xuXG4gICAgICAvLyBEZXByZWNhdGlvbnNcbiAgICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8udG9Jc29TdHJpbmcgPSBkZXByZWNhdGUoJ3RvSXNvU3RyaW5nKCkgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSB0b0lTT1N0cmluZygpIGluc3RlYWQgKG5vdGljZSB0aGUgY2FwaXRhbHMpJywgaXNvX3N0cmluZ19fdG9JU09TdHJpbmcpO1xuICAgICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5sYW5nID0gbGFuZztcblxuICAgICAgLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuXG4gICAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICAgIGFkZEZvcm1hdFRva2VuKCdYJywgMCwgMCwgJ3VuaXgnKTtcbiAgICAgIGFkZEZvcm1hdFRva2VuKCd4JywgMCwgMCwgJ3ZhbHVlT2YnKTtcblxuICAgICAgLy8gUEFSU0lOR1xuXG4gICAgICBhZGRSZWdleFRva2VuKCd4JywgbWF0Y2hTaWduZWQpO1xuICAgICAgYWRkUmVnZXhUb2tlbignWCcsIG1hdGNoVGltZXN0YW1wKTtcbiAgICAgIGFkZFBhcnNlVG9rZW4oJ1gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShwYXJzZUZsb2F0KGlucHV0LCAxMCkgKiAxMDAwKTtcbiAgICAgIH0pO1xuICAgICAgYWRkUGFyc2VUb2tlbigneCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHRvSW50KGlucHV0KSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuXG5cbiAgICAgIHV0aWxzX2hvb2tzX19ob29rcy52ZXJzaW9uID0gJzIuMTMuMCc7XG5cbiAgICAgIHNldEhvb2tDYWxsYmFjayhsb2NhbF9fY3JlYXRlTG9jYWwpO1xuXG4gICAgICB1dGlsc19ob29rc19faG9va3MuZm4gICAgICAgICAgICAgICAgICAgID0gbW9tZW50UHJvdG90eXBlO1xuICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLm1pbiAgICAgICAgICAgICAgICAgICA9IG1pbjtcbiAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5tYXggICAgICAgICAgICAgICAgICAgPSBtYXg7XG4gICAgICB1dGlsc19ob29rc19faG9va3Mubm93ICAgICAgICAgICAgICAgICAgID0gbm93O1xuICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnV0YyAgICAgICAgICAgICAgICAgICA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQztcbiAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51bml4ICAgICAgICAgICAgICAgICAgPSBtb21lbnRfX2NyZWF0ZVVuaXg7XG4gICAgICB1dGlsc19ob29rc19faG9va3MubW9udGhzICAgICAgICAgICAgICAgID0gbGlzdHNfX2xpc3RNb250aHM7XG4gICAgICB1dGlsc19ob29rc19faG9va3MuaXNEYXRlICAgICAgICAgICAgICAgID0gaXNEYXRlO1xuICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLmxvY2FsZSAgICAgICAgICAgICAgICA9IGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGU7XG4gICAgICB1dGlsc19ob29rc19faG9va3MuaW52YWxpZCAgICAgICAgICAgICAgID0gdmFsaWRfX2NyZWF0ZUludmFsaWQ7XG4gICAgICB1dGlsc19ob29rc19faG9va3MuZHVyYXRpb24gICAgICAgICAgICAgID0gY3JlYXRlX19jcmVhdGVEdXJhdGlvbjtcbiAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5pc01vbWVudCAgICAgICAgICAgICAgPSBpc01vbWVudDtcbiAgICAgIHV0aWxzX2hvb2tzX19ob29rcy53ZWVrZGF5cyAgICAgICAgICAgICAgPSBsaXN0c19fbGlzdFdlZWtkYXlzO1xuICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnBhcnNlWm9uZSAgICAgICAgICAgICA9IG1vbWVudF9fY3JlYXRlSW5ab25lO1xuICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLmxvY2FsZURhdGEgICAgICAgICAgICA9IGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGU7XG4gICAgICB1dGlsc19ob29rc19faG9va3MuaXNEdXJhdGlvbiAgICAgICAgICAgID0gaXNEdXJhdGlvbjtcbiAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5tb250aHNTaG9ydCAgICAgICAgICAgPSBsaXN0c19fbGlzdE1vbnRoc1Nob3J0O1xuICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLndlZWtkYXlzTWluICAgICAgICAgICA9IGxpc3RzX19saXN0V2Vla2RheXNNaW47XG4gICAgICB1dGlsc19ob29rc19faG9va3MuZGVmaW5lTG9jYWxlICAgICAgICAgID0gZGVmaW5lTG9jYWxlO1xuICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZUxvY2FsZSAgICAgICAgICA9IHVwZGF0ZUxvY2FsZTtcbiAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5sb2NhbGVzICAgICAgICAgICAgICAgPSBsb2NhbGVfbG9jYWxlc19fbGlzdExvY2FsZXM7XG4gICAgICB1dGlsc19ob29rc19faG9va3Mud2Vla2RheXNTaG9ydCAgICAgICAgID0gbGlzdHNfX2xpc3RXZWVrZGF5c1Nob3J0O1xuICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLm5vcm1hbGl6ZVVuaXRzICAgICAgICA9IG5vcm1hbGl6ZVVuaXRzO1xuICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnJlbGF0aXZlVGltZVRocmVzaG9sZCA9IGR1cmF0aW9uX2h1bWFuaXplX19nZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQ7XG4gICAgICB1dGlsc19ob29rc19faG9va3MucHJvdG90eXBlICAgICAgICAgICAgID0gbW9tZW50UHJvdG90eXBlO1xuXG4gICAgICB2YXIgX21vbWVudCA9IHV0aWxzX2hvb2tzX19ob29rcztcblxuICAgICAgcmV0dXJuIF9tb21lbnQ7XG5cbiAgfSkpO1xuICAvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyg0KShtb2R1bGUpKSlcblxuLyoqKi8gfSxcbi8qIDQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gIFx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcbiAgXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xuICBcdFx0bW9kdWxlLnBhdGhzID0gW107XG4gIFx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcbiAgXHRcdG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuICBcdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG4gIFx0fVxuICBcdHJldHVybiBtb2R1bGU7XG4gIH1cblxuXG4vKioqLyB9LFxuLyogNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgZnVuY3Rpb24gd2VicGFja0NvbnRleHQocmVxKSB7XG4gIFx0dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIHJlcSArIFwiJy5cIik7XG4gIH1cbiAgd2VicGFja0NvbnRleHQua2V5cyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gW107IH07XG4gIHdlYnBhY2tDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrQ29udGV4dDtcbiAgbW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrQ29udGV4dDtcbiAgd2VicGFja0NvbnRleHQuaWQgPSA1O1xuXG5cbi8qKiovIH0sXG4vKiA2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuICAvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7J3VzZSBzdHJpY3QnO1xuXG4gIHZhciBfcm5nO1xuXG4gIHZhciBnbG9iYWxWYXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogbnVsbDtcblxuICBpZiAoZ2xvYmFsVmFyICYmIGdsb2JhbFZhci5jcnlwdG8gJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgIC8vIFdIQVRXRyBjcnlwdG8tYmFzZWQgUk5HIC0gaHR0cDovL3dpa2kud2hhdHdnLm9yZy93aWtpL0NyeXB0b1xuICAgIC8vIE1vZGVyYXRlbHkgZmFzdCwgaGlnaCBxdWFsaXR5XG4gICAgdmFyIF9ybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICBfcm5nID0gZnVuY3Rpb24gd2hhdHdnUk5HKCkge1xuICAgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhfcm5kczgpO1xuICAgICAgcmV0dXJuIF9ybmRzODtcbiAgICB9O1xuICB9XG5cbiAgaWYgKCFfcm5nKSB7XG4gICAgLy8gTWF0aC5yYW5kb20oKS1iYXNlZCAoUk5HKVxuICAgIC8vXG4gICAgLy8gSWYgYWxsIGVsc2UgZmFpbHMsIHVzZSBNYXRoLnJhbmRvbSgpLiAgSXQncyBmYXN0LCBidXQgaXMgb2YgdW5zcGVjaWZpZWRcbiAgICAvLyBxdWFsaXR5LlxuICAgIHZhciBfcm5kcyA9IG5ldyBBcnJheSgxNik7XG4gICAgX3JuZyA9IGZ1bmN0aW9uIF9ybmcoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgcjsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgaWYgKChpICYgMHgwMykgPT09IDApIHIgPSBNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDA7XG4gICAgICAgIF9ybmRzW2ldID0gciA+Pj4gKChpICYgMHgwMykgPDwgMykgJiAweGZmO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3JuZHM7XG4gICAgfTtcbiAgfVxuXG4gIC8vICAgICB1dWlkLmpzXG4gIC8vXG4gIC8vICAgICBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxMiBSb2JlcnQgS2llZmZlclxuICAvLyAgICAgTUlUIExpY2Vuc2UgLSBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cbiAgLy8gVW5pcXVlIElEIGNyZWF0aW9uIHJlcXVpcmVzIGEgaGlnaCBxdWFsaXR5IHJhbmRvbSAjIGdlbmVyYXRvci4gIFdlIGZlYXR1cmVcbiAgLy8gZGV0ZWN0IHRvIGRldGVybWluZSB0aGUgYmVzdCBSTkcgc291cmNlLCBub3JtYWxpemluZyB0byBhIGZ1bmN0aW9uIHRoYXRcbiAgLy8gcmV0dXJucyAxMjgtYml0cyBvZiByYW5kb21uZXNzLCBzaW5jZSB0aGF0J3Mgd2hhdCdzIHVzdWFsbHkgcmVxdWlyZWRcblxuICAvL3ZhciBfcm5nID0gcmVxdWlyZSgnLi9ybmcnKTtcblxuICAvLyBNYXBzIGZvciBudW1iZXIgPC0+IGhleCBzdHJpbmcgY29udmVyc2lvblxuICB2YXIgX2J5dGVUb0hleCA9IFtdO1xuICB2YXIgX2hleFRvQnl0ZSA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgX2J5dGVUb0hleFtpXSA9IChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSk7XG4gICAgX2hleFRvQnl0ZVtfYnl0ZVRvSGV4W2ldXSA9IGk7XG4gIH1cblxuICAvLyAqKmBwYXJzZSgpYCAtIFBhcnNlIGEgVVVJRCBpbnRvIGl0J3MgY29tcG9uZW50IGJ5dGVzKipcbiAgZnVuY3Rpb24gcGFyc2UocywgYnVmLCBvZmZzZXQpIHtcbiAgICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMCxcbiAgICAgICAgaWkgPSAwO1xuXG4gICAgYnVmID0gYnVmIHx8IFtdO1xuICAgIHMudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bMC05YS1mXXsyfS9nLCBmdW5jdGlvbiAob2N0KSB7XG4gICAgICBpZiAoaWkgPCAxNikge1xuICAgICAgICAvLyBEb24ndCBvdmVyZmxvdyFcbiAgICAgICAgYnVmW2kgKyBpaSsrXSA9IF9oZXhUb0J5dGVbb2N0XTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFplcm8gb3V0IHJlbWFpbmluZyBieXRlcyBpZiBzdHJpbmcgd2FzIHNob3J0XG4gICAgd2hpbGUgKGlpIDwgMTYpIHtcbiAgICAgIGJ1ZltpICsgaWkrK10gPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBidWY7XG4gIH1cblxuICAvLyAqKmB1bnBhcnNlKClgIC0gQ29udmVydCBVVUlEIGJ5dGUgYXJyYXkgKGFsYSBwYXJzZSgpKSBpbnRvIGEgc3RyaW5nKipcbiAgZnVuY3Rpb24gdW5wYXJzZShidWYsIG9mZnNldCkge1xuICAgIHZhciBpID0gb2Zmc2V0IHx8IDAsXG4gICAgICAgIGJ0aCA9IF9ieXRlVG9IZXg7XG4gICAgcmV0dXJuIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgKyBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgJy0nICsgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgKyBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV07XG4gIH1cblxuICAvLyAqKmB2MSgpYCAtIEdlbmVyYXRlIHRpbWUtYmFzZWQgVVVJRCoqXG4gIC8vXG4gIC8vIEluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9MaW9zSy9VVUlELmpzXG4gIC8vIGFuZCBodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvdXVpZC5odG1sXG5cbiAgLy8gcmFuZG9tICMncyB3ZSBuZWVkIHRvIGluaXQgbm9kZSBhbmQgY2xvY2tzZXFcbiAgdmFyIF9zZWVkQnl0ZXMgPSBfcm5nKCk7XG5cbiAgLy8gUGVyIDQuNSwgY3JlYXRlIGFuZCA0OC1iaXQgbm9kZSBpZCwgKDQ3IHJhbmRvbSBiaXRzICsgbXVsdGljYXN0IGJpdCA9IDEpXG4gIHZhciBfbm9kZUlkID0gW19zZWVkQnl0ZXNbMF0gfCAweDAxLCBfc2VlZEJ5dGVzWzFdLCBfc2VlZEJ5dGVzWzJdLCBfc2VlZEJ5dGVzWzNdLCBfc2VlZEJ5dGVzWzRdLCBfc2VlZEJ5dGVzWzVdXTtcblxuICAvLyBQZXIgNC4yLjIsIHJhbmRvbWl6ZSAoMTQgYml0KSBjbG9ja3NlcVxuICB2YXIgX2Nsb2Nrc2VxID0gKF9zZWVkQnl0ZXNbNl0gPDwgOCB8IF9zZWVkQnl0ZXNbN10pICYgMHgzZmZmO1xuXG4gIC8vIFByZXZpb3VzIHV1aWQgY3JlYXRpb24gdGltZVxuICB2YXIgX2xhc3RNU2VjcyA9IDAsXG4gICAgICBfbGFzdE5TZWNzID0gMDtcblxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2Jyb29mYS9ub2RlLXV1aWQgZm9yIEFQSSBkZXRhaWxzXG4gIGZ1bmN0aW9uIHYxKG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG4gICAgdmFyIGIgPSBidWYgfHwgW107XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciBjbG9ja3NlcSA9IG9wdGlvbnMuY2xvY2tzZXEgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2xvY2tzZXEgOiBfY2xvY2tzZXE7XG5cbiAgICAvLyBVVUlEIHRpbWVzdGFtcHMgYXJlIDEwMCBuYW5vLXNlY29uZCB1bml0cyBzaW5jZSB0aGUgR3JlZ29yaWFuIGVwb2NoLFxuICAgIC8vICgxNTgyLTEwLTE1IDAwOjAwKS4gIEpTTnVtYmVycyBhcmVuJ3QgcHJlY2lzZSBlbm91Z2ggZm9yIHRoaXMsIHNvXG4gICAgLy8gdGltZSBpcyBoYW5kbGVkIGludGVybmFsbHkgYXMgJ21zZWNzJyAoaW50ZWdlciBtaWxsaXNlY29uZHMpIGFuZCAnbnNlY3MnXG4gICAgLy8gKDEwMC1uYW5vc2Vjb25kcyBvZmZzZXQgZnJvbSBtc2Vjcykgc2luY2UgdW5peCBlcG9jaCwgMTk3MC0wMS0wMSAwMDowMC5cbiAgICB2YXIgbXNlY3MgPSBvcHRpb25zLm1zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1zZWNzIDogbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgICAvLyBQZXIgNC4yLjEuMiwgdXNlIGNvdW50IG9mIHV1aWQncyBnZW5lcmF0ZWQgZHVyaW5nIHRoZSBjdXJyZW50IGNsb2NrXG4gICAgLy8gY3ljbGUgdG8gc2ltdWxhdGUgaGlnaGVyIHJlc29sdXRpb24gY2xvY2tcbiAgICB2YXIgbnNlY3MgPSBvcHRpb25zLm5zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5zZWNzIDogX2xhc3ROU2VjcyArIDE7XG5cbiAgICAvLyBUaW1lIHNpbmNlIGxhc3QgdXVpZCBjcmVhdGlvbiAoaW4gbXNlY3MpXG4gICAgdmFyIGR0ID0gbXNlY3MgLSBfbGFzdE1TZWNzICsgKG5zZWNzIC0gX2xhc3ROU2VjcykgLyAxMDAwMDtcblxuICAgIC8vIFBlciA0LjIuMS4yLCBCdW1wIGNsb2Nrc2VxIG9uIGNsb2NrIHJlZ3Jlc3Npb25cbiAgICBpZiAoZHQgPCAwICYmIG9wdGlvbnMuY2xvY2tzZXEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xvY2tzZXEgPSBjbG9ja3NlcSArIDEgJiAweDNmZmY7XG4gICAgfVxuXG4gICAgLy8gUmVzZXQgbnNlY3MgaWYgY2xvY2sgcmVncmVzc2VzIChuZXcgY2xvY2tzZXEpIG9yIHdlJ3ZlIG1vdmVkIG9udG8gYSBuZXdcbiAgICAvLyB0aW1lIGludGVydmFsXG4gICAgaWYgKChkdCA8IDAgfHwgbXNlY3MgPiBfbGFzdE1TZWNzKSAmJiBvcHRpb25zLm5zZWNzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5zZWNzID0gMDtcbiAgICB9XG5cbiAgICAvLyBQZXIgNC4yLjEuMiBUaHJvdyBlcnJvciBpZiB0b28gbWFueSB1dWlkcyBhcmUgcmVxdWVzdGVkXG4gICAgaWYgKG5zZWNzID49IDEwMDAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3V1aWQudjEoKTogQ2FuXFwndCBjcmVhdGUgbW9yZSB0aGFuIDEwTSB1dWlkcy9zZWMnKTtcbiAgICB9XG5cbiAgICBfbGFzdE1TZWNzID0gbXNlY3M7XG4gICAgX2xhc3ROU2VjcyA9IG5zZWNzO1xuICAgIF9jbG9ja3NlcSA9IGNsb2Nrc2VxO1xuXG4gICAgLy8gUGVyIDQuMS40IC0gQ29udmVydCBmcm9tIHVuaXggZXBvY2ggdG8gR3JlZ29yaWFuIGVwb2NoXG4gICAgbXNlY3MgKz0gMTIyMTkyOTI4MDAwMDA7XG5cbiAgICAvLyBgdGltZV9sb3dgXG4gICAgdmFyIHRsID0gKChtc2VjcyAmIDB4ZmZmZmZmZikgKiAxMDAwMCArIG5zZWNzKSAlIDB4MTAwMDAwMDAwO1xuICAgIGJbaSsrXSA9IHRsID4+PiAyNCAmIDB4ZmY7XG4gICAgYltpKytdID0gdGwgPj4+IDE2ICYgMHhmZjtcbiAgICBiW2krK10gPSB0bCA+Pj4gOCAmIDB4ZmY7XG4gICAgYltpKytdID0gdGwgJiAweGZmO1xuXG4gICAgLy8gYHRpbWVfbWlkYFxuICAgIHZhciB0bWggPSBtc2VjcyAvIDB4MTAwMDAwMDAwICogMTAwMDAgJiAweGZmZmZmZmY7XG4gICAgYltpKytdID0gdG1oID4+PiA4ICYgMHhmZjtcbiAgICBiW2krK10gPSB0bWggJiAweGZmO1xuXG4gICAgLy8gYHRpbWVfaGlnaF9hbmRfdmVyc2lvbmBcbiAgICBiW2krK10gPSB0bWggPj4+IDI0ICYgMHhmIHwgMHgxMDsgLy8gaW5jbHVkZSB2ZXJzaW9uXG4gICAgYltpKytdID0gdG1oID4+PiAxNiAmIDB4ZmY7XG5cbiAgICAvLyBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGAgKFBlciA0LjIuMiAtIGluY2x1ZGUgdmFyaWFudClcbiAgICBiW2krK10gPSBjbG9ja3NlcSA+Pj4gOCB8IDB4ODA7XG5cbiAgICAvLyBgY2xvY2tfc2VxX2xvd2BcbiAgICBiW2krK10gPSBjbG9ja3NlcSAmIDB4ZmY7XG5cbiAgICAvLyBgbm9kZWBcbiAgICB2YXIgbm9kZSA9IG9wdGlvbnMubm9kZSB8fCBfbm9kZUlkO1xuICAgIGZvciAodmFyIG4gPSAwOyBuIDwgNjsgbisrKSB7XG4gICAgICBiW2kgKyBuXSA9IG5vZGVbbl07XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZiA/IGJ1ZiA6IHVucGFyc2UoYik7XG4gIH1cblxuICAvLyAqKmB2NCgpYCAtIEdlbmVyYXRlIHJhbmRvbSBVVUlEKipcblxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2Jyb29mYS9ub2RlLXV1aWQgZm9yIEFQSSBkZXRhaWxzXG4gIGZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgLy8gRGVwcmVjYXRlZCAtICdmb3JtYXQnIGFyZ3VtZW50LCBhcyBzdXBwb3J0ZWQgaW4gdjEuMlxuICAgIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09ICdzdHJpbmcnKSB7XG4gICAgICBidWYgPSBvcHRpb25zID09ICdiaW5hcnknID8gbmV3IEFycmF5KDE2KSA6IG51bGw7XG4gICAgICBvcHRpb25zID0gbnVsbDtcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXIgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBfcm5nKSgpO1xuXG4gICAgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuICAgIHJuZHNbNl0gPSBybmRzWzZdICYgMHgwZiB8IDB4NDA7XG4gICAgcm5kc1s4XSA9IHJuZHNbOF0gJiAweDNmIHwgMHg4MDtcblxuICAgIC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuICAgIGlmIChidWYpIHtcbiAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCAxNjsgaWkrKykge1xuICAgICAgICBidWZbaSArIGlpXSA9IHJuZHNbaWldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBidWYgfHwgdW5wYXJzZShybmRzKTtcbiAgfVxuXG4gIC8vIEV4cG9ydCBwdWJsaWMgQVBJXG4gIHZhciB1dWlkID0gdjQ7XG4gIHV1aWQudjEgPSB2MTtcbiAgdXVpZC52NCA9IHY0O1xuICB1dWlkLnBhcnNlID0gcGFyc2U7XG4gIHV1aWQudW5wYXJzZSA9IHVucGFyc2U7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSB1dWlkO1xuICAvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0sXG4vKiA3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gdXRpbHNcbiAgZXhwb3J0cy51dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbiAgZXhwb3J0cy5ET011dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxuICAvLyBkYXRhXG4gIGV4cG9ydHMuRGF0YVNldCA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG4gIGV4cG9ydHMuRGF0YVZpZXcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcbiAgZXhwb3J0cy5RdWV1ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXG4gIC8vIEdyYXBoM2RcbiAgZXhwb3J0cy5HcmFwaDNkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG4gIGV4cG9ydHMuZ3JhcGgzZCA9IHtcbiAgICBDYW1lcmE6IF9fd2VicGFja19yZXF1aXJlX18oMTYpLFxuICAgIEZpbHRlcjogX193ZWJwYWNrX3JlcXVpcmVfXygxNyksXG4gICAgUG9pbnQyZDogX193ZWJwYWNrX3JlcXVpcmVfXygxNSksXG4gICAgUG9pbnQzZDogX193ZWJwYWNrX3JlcXVpcmVfXygxNCksXG4gICAgU2xpZGVyOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KSxcbiAgICBTdGVwTnVtYmVyOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KVxuICB9O1xuXG4gIC8vIGJ1bmRsZWQgZXh0ZXJuYWwgbGlicmFyaWVzXG4gIGV4cG9ydHMubW9tZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbiAgZXhwb3J0cy5IYW1tZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcbiAgZXhwb3J0cy5rZXljaGFybSA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuXG4vKioqLyB9LFxuLyogOCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIERPTSB1dGlsaXR5IG1ldGhvZHNcblxuICAvKipcbiAgICogdGhpcyBwcmVwYXJlcyB0aGUgSlNPTiBjb250YWluZXIgZm9yIGFsbG9jYXRpbmcgU1ZHIGVsZW1lbnRzXG4gICAqIEBwYXJhbSBKU09OY29udGFpbmVyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBleHBvcnRzLnByZXBhcmVFbGVtZW50cyA9IGZ1bmN0aW9uIChKU09OY29udGFpbmVyKSB7XG4gICAgLy8gY2xlYW51cCB0aGUgcmVkdW5kYW50IHN2Z0VsZW1lbnRzO1xuICAgIGZvciAodmFyIGVsZW1lbnRUeXBlIGluIEpTT05jb250YWluZXIpIHtcbiAgICAgIGlmIChKU09OY29udGFpbmVyLmhhc093blByb3BlcnR5KGVsZW1lbnRUeXBlKSkge1xuICAgICAgICBKU09OY29udGFpbmVyW2VsZW1lbnRUeXBlXS5yZWR1bmRhbnQgPSBKU09OY29udGFpbmVyW2VsZW1lbnRUeXBlXS51c2VkO1xuICAgICAgICBKU09OY29udGFpbmVyW2VsZW1lbnRUeXBlXS51c2VkID0gW107XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiB0aGlzIGNsZWFucyB1cCBhbGwgdGhlIHVudXNlZCBTVkcgZWxlbWVudHMuIEJ5IGFza2luZyBmb3IgdGhlIHBhcmVudE5vZGUsIHdlIG9ubHkgbmVlZCB0byBzdXBwbHkgdGhlIEpTT04gY29udGFpbmVyIGZyb21cbiAgICogd2hpY2ggdG8gcmVtb3ZlIHRoZSByZWR1bmRhbnQgZWxlbWVudHMuXG4gICAqXG4gICAqIEBwYXJhbSBKU09OY29udGFpbmVyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBleHBvcnRzLmNsZWFudXBFbGVtZW50cyA9IGZ1bmN0aW9uIChKU09OY29udGFpbmVyKSB7XG4gICAgLy8gY2xlYW51cCB0aGUgcmVkdW5kYW50IHN2Z0VsZW1lbnRzO1xuICAgIGZvciAodmFyIGVsZW1lbnRUeXBlIGluIEpTT05jb250YWluZXIpIHtcbiAgICAgIGlmIChKU09OY29udGFpbmVyLmhhc093blByb3BlcnR5KGVsZW1lbnRUeXBlKSkge1xuICAgICAgICBpZiAoSlNPTmNvbnRhaW5lcltlbGVtZW50VHlwZV0ucmVkdW5kYW50KSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBKU09OY29udGFpbmVyW2VsZW1lbnRUeXBlXS5yZWR1bmRhbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIEpTT05jb250YWluZXJbZWxlbWVudFR5cGVdLnJlZHVuZGFudFtpXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKEpTT05jb250YWluZXJbZWxlbWVudFR5cGVdLnJlZHVuZGFudFtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIEpTT05jb250YWluZXJbZWxlbWVudFR5cGVdLnJlZHVuZGFudCA9IFtdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBFbnN1cmVzIHRoYXQgYWxsIGVsZW1lbnRzIGFyZSByZW1vdmVkIGZpcnN0IHVwIHNvIHRoZXkgY2FuIGJlIHJlY3JlYXRlZCBjbGVhbmx5XG4gICAqIEBwYXJhbSBKU09OY29udGFpbmVyXG4gICAqL1xuICBleHBvcnRzLnJlc2V0RWxlbWVudHMgPSBmdW5jdGlvbiAoSlNPTmNvbnRhaW5lcikge1xuICAgIGV4cG9ydHMucHJlcGFyZUVsZW1lbnRzKEpTT05jb250YWluZXIpO1xuICAgIGV4cG9ydHMuY2xlYW51cEVsZW1lbnRzKEpTT05jb250YWluZXIpO1xuICAgIGV4cG9ydHMucHJlcGFyZUVsZW1lbnRzKEpTT05jb250YWluZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBbGxvY2F0ZSBvciBnZW5lcmF0ZSBhbiBTVkcgZWxlbWVudCBpZiBuZWVkZWQuIFN0b3JlIGEgcmVmZXJlbmNlIHRvIGl0IGluIHRoZSBKU09OIGNvbnRhaW5lciBhbmQgZHJhdyBpdCBpbiB0aGUgc3ZnQ29udGFpbmVyXG4gICAqIHRoZSBKU09OIGNvbnRhaW5lciBhbmQgdGhlIFNWRyBjb250YWluZXIgaGF2ZSB0byBiZSBzdXBwbGllZCBzbyBvdGhlciBzdmcgY29udGFpbmVycyAobGlrZSB0aGUgbGVnZW5kKSBjYW4gdXNlIHRoaXMuXG4gICAqXG4gICAqIEBwYXJhbSBlbGVtZW50VHlwZVxuICAgKiBAcGFyYW0gSlNPTmNvbnRhaW5lclxuICAgKiBAcGFyYW0gc3ZnQ29udGFpbmVyXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZXhwb3J0cy5nZXRTVkdFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnRUeXBlLCBKU09OY29udGFpbmVyLCBzdmdDb250YWluZXIpIHtcbiAgICB2YXIgZWxlbWVudDtcbiAgICAvLyBhbGxvY2F0ZSBTVkcgZWxlbWVudCwgaWYgaXQgZG9lc250IHlldCBleGlzdCwgY3JlYXRlIG9uZS5cbiAgICBpZiAoSlNPTmNvbnRhaW5lci5oYXNPd25Qcm9wZXJ0eShlbGVtZW50VHlwZSkpIHtcbiAgICAgIC8vIHRoaXMgZWxlbWVudCBoYXMgYmVlbiBjcmVhdGVkIGJlZm9yZVxuICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgaXMgYW4gcmVkdW5kYW50IGVsZW1lbnRcbiAgICAgIGlmIChKU09OY29udGFpbmVyW2VsZW1lbnRUeXBlXS5yZWR1bmRhbnQubGVuZ3RoID4gMCkge1xuICAgICAgICBlbGVtZW50ID0gSlNPTmNvbnRhaW5lcltlbGVtZW50VHlwZV0ucmVkdW5kYW50WzBdO1xuICAgICAgICBKU09OY29udGFpbmVyW2VsZW1lbnRUeXBlXS5yZWR1bmRhbnQuc2hpZnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBlbGVtZW50IGFuZCBhZGQgaXQgdG8gdGhlIFNWR1xuICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIGVsZW1lbnRUeXBlKTtcbiAgICAgICAgc3ZnQ29udGFpbmVyLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjcmVhdGUgYSBuZXcgZWxlbWVudCBhbmQgYWRkIGl0IHRvIHRoZSBTVkcsIGFsc28gY3JlYXRlIGEgbmV3IG9iamVjdCBpbiB0aGUgc3ZnRWxlbWVudHMgdG8ga2VlcCB0cmFjayBvZiBpdC5cbiAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgZWxlbWVudFR5cGUpO1xuICAgICAgSlNPTmNvbnRhaW5lcltlbGVtZW50VHlwZV0gPSB7IHVzZWQ6IFtdLCByZWR1bmRhbnQ6IFtdIH07XG4gICAgICBzdmdDb250YWluZXIuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgfVxuICAgIEpTT05jb250YWluZXJbZWxlbWVudFR5cGVdLnVzZWQucHVzaChlbGVtZW50KTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfTtcblxuICAvKipcbiAgICogQWxsb2NhdGUgb3IgZ2VuZXJhdGUgYW4gU1ZHIGVsZW1lbnQgaWYgbmVlZGVkLiBTdG9yZSBhIHJlZmVyZW5jZSB0byBpdCBpbiB0aGUgSlNPTiBjb250YWluZXIgYW5kIGRyYXcgaXQgaW4gdGhlIHN2Z0NvbnRhaW5lclxuICAgKiB0aGUgSlNPTiBjb250YWluZXIgYW5kIHRoZSBTVkcgY29udGFpbmVyIGhhdmUgdG8gYmUgc3VwcGxpZWQgc28gb3RoZXIgc3ZnIGNvbnRhaW5lcnMgKGxpa2UgdGhlIGxlZ2VuZCkgY2FuIHVzZSB0aGlzLlxuICAgKlxuICAgKiBAcGFyYW0gZWxlbWVudFR5cGVcbiAgICogQHBhcmFtIEpTT05jb250YWluZXJcbiAgICogQHBhcmFtIERPTUNvbnRhaW5lclxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGV4cG9ydHMuZ2V0RE9NRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50VHlwZSwgSlNPTmNvbnRhaW5lciwgRE9NQ29udGFpbmVyLCBpbnNlcnRCZWZvcmUpIHtcbiAgICB2YXIgZWxlbWVudDtcbiAgICAvLyBhbGxvY2F0ZSBET00gZWxlbWVudCwgaWYgaXQgZG9lc250IHlldCBleGlzdCwgY3JlYXRlIG9uZS5cbiAgICBpZiAoSlNPTmNvbnRhaW5lci5oYXNPd25Qcm9wZXJ0eShlbGVtZW50VHlwZSkpIHtcbiAgICAgIC8vIHRoaXMgZWxlbWVudCBoYXMgYmVlbiBjcmVhdGVkIGJlZm9yZVxuICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgaXMgYW4gcmVkdW5kYW50IGVsZW1lbnRcbiAgICAgIGlmIChKU09OY29udGFpbmVyW2VsZW1lbnRUeXBlXS5yZWR1bmRhbnQubGVuZ3RoID4gMCkge1xuICAgICAgICBlbGVtZW50ID0gSlNPTmNvbnRhaW5lcltlbGVtZW50VHlwZV0ucmVkdW5kYW50WzBdO1xuICAgICAgICBKU09OY29udGFpbmVyW2VsZW1lbnRUeXBlXS5yZWR1bmRhbnQuc2hpZnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBlbGVtZW50IGFuZCBhZGQgaXQgdG8gdGhlIFNWR1xuICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlbGVtZW50VHlwZSk7XG4gICAgICAgIGlmIChpbnNlcnRCZWZvcmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIERPTUNvbnRhaW5lci5pbnNlcnRCZWZvcmUoZWxlbWVudCwgaW5zZXJ0QmVmb3JlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBET01Db250YWluZXIuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY3JlYXRlIGEgbmV3IGVsZW1lbnQgYW5kIGFkZCBpdCB0byB0aGUgU1ZHLCBhbHNvIGNyZWF0ZSBhIG5ldyBvYmplY3QgaW4gdGhlIHN2Z0VsZW1lbnRzIHRvIGtlZXAgdHJhY2sgb2YgaXQuXG4gICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlbGVtZW50VHlwZSk7XG4gICAgICBKU09OY29udGFpbmVyW2VsZW1lbnRUeXBlXSA9IHsgdXNlZDogW10sIHJlZHVuZGFudDogW10gfTtcbiAgICAgIGlmIChpbnNlcnRCZWZvcmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBET01Db250YWluZXIuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsIGluc2VydEJlZm9yZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBET01Db250YWluZXIuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIEpTT05jb250YWluZXJbZWxlbWVudFR5cGVdLnVzZWQucHVzaChlbGVtZW50KTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfTtcblxuICAvKipcbiAgICogRHJhdyBhIHBvaW50IG9iamVjdC4gVGhpcyBpcyBhIHNlcGFyYXRlIGZ1bmN0aW9uIGJlY2F1c2UgaXQgY2FuIGFsc28gYmUgY2FsbGVkIGJ5IHRoZSBsZWdlbmQuXG4gICAqIFRoZSByZWFzb24gdGhlIEpTT05jb250YWluZXIgYW5kIHRoZSB0YXJnZXQgU1ZHIHN2Z0NvbnRhaW5lciBoYXZlIHRvIGJlIHN1cHBsaWVkIGlzIHNvIHRoZSBsZWdlbmQgY2FuIHVzZSB0aGVzZSBmdW5jdGlvbnNcbiAgICogYXMgd2VsbC5cbiAgICpcbiAgICogQHBhcmFtIHhcbiAgICogQHBhcmFtIHlcbiAgICogQHBhcmFtIGdyb3VwVGVtcGxhdGU6IEEgdGVtcGxhdGUgY29udGFpbmluZyB0aGUgbmVjZXNzYXJ5IGluZm9ybWF0aW9uIHRvIGRyYXcgdGhlIGRhdGFwb2ludCBlLmcuLCB7c3R5bGU6ICdjaXJjbGUnLCBzaXplOiA1LCBjbGFzc05hbWU6ICdjbGFzc05hbWUnIH1cbiAgICogQHBhcmFtIEpTT05jb250YWluZXJcbiAgICogQHBhcmFtIHN2Z0NvbnRhaW5lclxuICAgKiBAcGFyYW0gbGFiZWxPYmpcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBleHBvcnRzLmRyYXdQb2ludCA9IGZ1bmN0aW9uICh4LCB5LCBncm91cFRlbXBsYXRlLCBKU09OY29udGFpbmVyLCBzdmdDb250YWluZXIsIGxhYmVsT2JqKSB7XG4gICAgdmFyIHBvaW50O1xuICAgIGlmIChncm91cFRlbXBsYXRlLnN0eWxlID09ICdjaXJjbGUnKSB7XG4gICAgICBwb2ludCA9IGV4cG9ydHMuZ2V0U1ZHRWxlbWVudCgnY2lyY2xlJywgSlNPTmNvbnRhaW5lciwgc3ZnQ29udGFpbmVyKTtcbiAgICAgIHBvaW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiY3hcIiwgeCk7XG4gICAgICBwb2ludC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImN5XCIsIHkpO1xuICAgICAgcG9pbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJyXCIsIDAuNSAqIGdyb3VwVGVtcGxhdGUuc2l6ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50ID0gZXhwb3J0cy5nZXRTVkdFbGVtZW50KCdyZWN0JywgSlNPTmNvbnRhaW5lciwgc3ZnQ29udGFpbmVyKTtcbiAgICAgIHBvaW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieFwiLCB4IC0gMC41ICogZ3JvdXBUZW1wbGF0ZS5zaXplKTtcbiAgICAgIHBvaW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCB5IC0gMC41ICogZ3JvdXBUZW1wbGF0ZS5zaXplKTtcbiAgICAgIHBvaW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwid2lkdGhcIiwgZ3JvdXBUZW1wbGF0ZS5zaXplKTtcbiAgICAgIHBvaW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiaGVpZ2h0XCIsIGdyb3VwVGVtcGxhdGUuc2l6ZSk7XG4gICAgfVxuXG4gICAgaWYgKGdyb3VwVGVtcGxhdGUuc3R5bGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHBvaW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwic3R5bGVcIiwgZ3JvdXBUZW1wbGF0ZS5zdHlsZXMpO1xuICAgIH1cbiAgICBwb2ludC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImNsYXNzXCIsIGdyb3VwVGVtcGxhdGUuY2xhc3NOYW1lICsgXCIgdmlzLXBvaW50XCIpO1xuICAgIC8vaGFuZGxlIGxhYmVsXG5cbiAgICBpZiAobGFiZWxPYmopIHtcbiAgICAgIHZhciBsYWJlbCA9IGV4cG9ydHMuZ2V0U1ZHRWxlbWVudCgndGV4dCcsIEpTT05jb250YWluZXIsIHN2Z0NvbnRhaW5lcik7XG4gICAgICBpZiAobGFiZWxPYmoueE9mZnNldCkge1xuICAgICAgICB4ID0geCArIGxhYmVsT2JqLnhPZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChsYWJlbE9iai55T2Zmc2V0KSB7XG4gICAgICAgIHkgPSB5ICsgbGFiZWxPYmoueU9mZnNldDtcbiAgICAgIH1cbiAgICAgIGlmIChsYWJlbE9iai5jb250ZW50KSB7XG4gICAgICAgIGxhYmVsLnRleHRDb250ZW50ID0gbGFiZWxPYmouY29udGVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKGxhYmVsT2JqLmNsYXNzTmFtZSkge1xuICAgICAgICBsYWJlbC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImNsYXNzXCIsIGxhYmVsT2JqLmNsYXNzTmFtZSArIFwiIHZpcy1sYWJlbFwiKTtcbiAgICAgIH1cbiAgICAgIGxhYmVsLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieFwiLCB4KTtcbiAgICAgIGxhYmVsLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCB5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9pbnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIGRyYXcgYSBiYXIgU1ZHIGVsZW1lbnQgY2VudGVyZWQgb24gdGhlIFggY29vcmRpbmF0ZVxuICAgKlxuICAgKiBAcGFyYW0geFxuICAgKiBAcGFyYW0geVxuICAgKiBAcGFyYW0gY2xhc3NOYW1lXG4gICAqL1xuICBleHBvcnRzLmRyYXdCYXIgPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCwgY2xhc3NOYW1lLCBKU09OY29udGFpbmVyLCBzdmdDb250YWluZXIsIHN0eWxlKSB7XG4gICAgaWYgKGhlaWdodCAhPSAwKSB7XG4gICAgICBpZiAoaGVpZ2h0IDwgMCkge1xuICAgICAgICBoZWlnaHQgKj0gLTE7XG4gICAgICAgIHkgLT0gaGVpZ2h0O1xuICAgICAgfVxuICAgICAgdmFyIHJlY3QgPSBleHBvcnRzLmdldFNWR0VsZW1lbnQoJ3JlY3QnLCBKU09OY29udGFpbmVyLCBzdmdDb250YWluZXIpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInhcIiwgeCAtIDAuNSAqIHdpZHRoKTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5XCIsIHkpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIndpZHRoXCIsIHdpZHRoKTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJoZWlnaHRcIiwgaGVpZ2h0KTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJjbGFzc1wiLCBjbGFzc05hbWUpO1xuICAgICAgaWYgKHN0eWxlKSB7XG4gICAgICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJzdHlsZVwiLCBzdHlsZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4vKioqLyB9LFxuLyogOSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbiAgdmFyIFF1ZXVlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cbiAgLyoqXG4gICAqIERhdGFTZXRcbiAgICpcbiAgICogVXNhZ2U6XG4gICAqICAgICB2YXIgZGF0YVNldCA9IG5ldyBEYXRhU2V0KHtcbiAgICogICAgICAgICBmaWVsZElkOiAnX2lkJyxcbiAgICogICAgICAgICB0eXBlOiB7XG4gICAqICAgICAgICAgICAgIC8vIC4uLlxuICAgKiAgICAgICAgIH1cbiAgICogICAgIH0pO1xuICAgKlxuICAgKiAgICAgZGF0YVNldC5hZGQoaXRlbSk7XG4gICAqICAgICBkYXRhU2V0LmFkZChkYXRhKTtcbiAgICogICAgIGRhdGFTZXQudXBkYXRlKGl0ZW0pO1xuICAgKiAgICAgZGF0YVNldC51cGRhdGUoZGF0YSk7XG4gICAqICAgICBkYXRhU2V0LnJlbW92ZShpZCk7XG4gICAqICAgICBkYXRhU2V0LnJlbW92ZShpZHMpO1xuICAgKiAgICAgdmFyIGRhdGEgPSBkYXRhU2V0LmdldCgpO1xuICAgKiAgICAgdmFyIGRhdGEgPSBkYXRhU2V0LmdldChpZCk7XG4gICAqICAgICB2YXIgZGF0YSA9IGRhdGFTZXQuZ2V0KGlkcyk7XG4gICAqICAgICB2YXIgZGF0YSA9IGRhdGFTZXQuZ2V0KGlkcywgb3B0aW9ucywgZGF0YSk7XG4gICAqICAgICBkYXRhU2V0LmNsZWFyKCk7XG4gICAqXG4gICAqIEEgZGF0YSBzZXQgY2FuOlxuICAgKiAtIGFkZC9yZW1vdmUvdXBkYXRlIGRhdGFcbiAgICogLSBnaXZlcyB0cmlnZ2VycyB1cG9uIGNoYW5nZXMgaW4gdGhlIGRhdGFcbiAgICogLSBjYW4gIGltcG9ydC9leHBvcnQgZGF0YSBpbiB2YXJpb3VzIGRhdGEgZm9ybWF0c1xuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBbZGF0YV0gICAgT3B0aW9uYWwgYXJyYXkgd2l0aCBpbml0aWFsIGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgIEF2YWlsYWJsZSBvcHRpb25zOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZ30gZmllbGRJZCBGaWVsZCBuYW1lIG9mIHRoZSBpZCBpbiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXMsICdpZCcgYnkgZGVmYXVsdC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtPYmplY3QuPFN0cmluZywgU3RyaW5nfSB0eXBlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEEgbWFwIHdpdGggZmllbGQgbmFtZXMgYXMga2V5LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgdGhlIGZpZWxkIHR5cGUgYXMgdmFsdWUuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0fSBxdWV1ZSAgIFF1ZXVlIGNoYW5nZXMgdG8gdGhlIERhdGFTZXQsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsdXNoIHRoZW0gYWxsIGF0IG9uY2UuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFF1ZXVlIG9wdGlvbnM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0ge251bWJlcn0gZGVsYXkgIERlbGF5IGluIG1zLCBudWxsIGJ5IGRlZmF1bHRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSB7bnVtYmVyfSBtYXggICAgTWF4aW11bSBudW1iZXIgb2YgZW50cmllcyBpbiB0aGUgcXVldWUsIEluZmluaXR5IGJ5IGRlZmF1bHRcbiAgICogQGNvbnN0cnVjdG9yIERhdGFTZXRcbiAgICovXG4gIC8vIFRPRE86IGFkZCBhIERhdGFTZXQgY29uc3RydWN0b3IgRGF0YVNldChkYXRhLCBvcHRpb25zKVxuICBmdW5jdGlvbiBEYXRhU2V0KGRhdGEsIG9wdGlvbnMpIHtcbiAgICAvLyBjb3JyZWN0bHkgcmVhZCBvcHRpb25hbCBhcmd1bWVudHNcbiAgICBpZiAoZGF0YSAmJiAhQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgb3B0aW9ucyA9IGRhdGE7XG4gICAgICBkYXRhID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLl9kYXRhID0ge307IC8vIG1hcCB3aXRoIGRhdGEgaW5kZXhlZCBieSBpZFxuICAgIHRoaXMubGVuZ3RoID0gMDsgLy8gbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBEYXRhU2V0XG4gICAgdGhpcy5fZmllbGRJZCA9IHRoaXMuX29wdGlvbnMuZmllbGRJZCB8fCAnaWQnOyAvLyBuYW1lIG9mIHRoZSBmaWVsZCBjb250YWluaW5nIGlkXG4gICAgdGhpcy5fdHlwZSA9IHt9OyAvLyBpbnRlcm5hbCBmaWVsZCB0eXBlcyAoTk9URTogdGhpcyBjYW4gZGlmZmVyIGZyb20gdGhpcy5fb3B0aW9ucy50eXBlKVxuXG4gICAgLy8gYWxsIHZhcmlhbnRzIG9mIGEgRGF0ZSBhcmUgaW50ZXJuYWxseSBzdG9yZWQgYXMgRGF0ZSwgc28gd2UgY2FuIGNvbnZlcnRcbiAgICAvLyBmcm9tIGV2ZXJ5dGhpbmcgdG8gZXZlcnl0aGluZyAoYWxzbyBmcm9tIElTT0RhdGUgdG8gTnVtYmVyIGZvciBleGFtcGxlKVxuICAgIGlmICh0aGlzLl9vcHRpb25zLnR5cGUpIHtcbiAgICAgIHZhciBmaWVsZHMgPSBPYmplY3Qua2V5cyh0aGlzLl9vcHRpb25zLnR5cGUpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGZpZWxkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgZmllbGQgPSBmaWVsZHNbaV07XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX29wdGlvbnMudHlwZVtmaWVsZF07XG4gICAgICAgIGlmICh2YWx1ZSA9PSAnRGF0ZScgfHwgdmFsdWUgPT0gJ0lTT0RhdGUnIHx8IHZhbHVlID09ICdBU1BEYXRlJykge1xuICAgICAgICAgIHRoaXMuX3R5cGVbZmllbGRdID0gJ0RhdGUnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3R5cGVbZmllbGRdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMS4xLjEgKG9yIDIuMC4wPylcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5jb252ZXJ0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbiBcImNvbnZlcnRcIiBpcyBkZXByZWNhdGVkLiBVc2UgXCJ0eXBlXCIgaW5zdGVhZC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zdWJzY3JpYmVycyA9IHt9OyAvLyBldmVudCBzdWJzY3JpYmVyc1xuXG4gICAgLy8gYWRkIGluaXRpYWwgZGF0YSB3aGVuIHByb3ZpZGVkXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIHRoaXMuYWRkKGRhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0fSBxdWV1ZSAgIFF1ZXVlIGNoYW5nZXMgdG8gdGhlIERhdGFTZXQsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsdXNoIHRoZW0gYWxsIGF0IG9uY2UuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFF1ZXVlIG9wdGlvbnM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0ge251bWJlcn0gZGVsYXkgIERlbGF5IGluIG1zLCBudWxsIGJ5IGRlZmF1bHRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSB7bnVtYmVyfSBtYXggICAgTWF4aW11bSBudW1iZXIgb2YgZW50cmllcyBpbiB0aGUgcXVldWUsIEluZmluaXR5IGJ5IGRlZmF1bHRcbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICovXG4gIERhdGFTZXQucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMucXVldWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKG9wdGlvbnMucXVldWUgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIGRlbGV0ZSBxdWV1ZSBpZiBsb2FkZWRcbiAgICAgICAgaWYgKHRoaXMuX3F1ZXVlKSB7XG4gICAgICAgICAgdGhpcy5fcXVldWUuZGVzdHJveSgpO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9xdWV1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY3JlYXRlIHF1ZXVlIGFuZCB1cGRhdGUgaXRzIG9wdGlvbnNcbiAgICAgICAgaWYgKCF0aGlzLl9xdWV1ZSkge1xuICAgICAgICAgIHRoaXMuX3F1ZXVlID0gUXVldWUuZXh0ZW5kKHRoaXMsIHtcbiAgICAgICAgICAgIHJlcGxhY2U6IFsnYWRkJywgJ3VwZGF0ZScsICdyZW1vdmUnXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF90eXBlb2Yob3B0aW9ucy5xdWV1ZSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdGhpcy5fcXVldWUuc2V0T3B0aW9ucyhvcHRpb25zLnF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU3Vic2NyaWJlIHRvIGFuIGV2ZW50LCBhZGQgYW4gZXZlbnQgbGlzdGVuZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50ICAgICAgICBFdmVudCBuYW1lLiBBdmFpbGFibGUgZXZlbnRzOiAncHV0JywgJ3VwZGF0ZScsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JlbW92ZSdcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgICBDYWxsYmFjayBtZXRob2QuIENhbGxlZCB3aXRoIHRocmVlIHBhcmFtZXRlcnM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmd9IGV2ZW50XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtPYmplY3QgfCBudWxsfSBwYXJhbXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZyB8IE51bWJlcn0gc2VuZGVySWRcbiAgICovXG4gIERhdGFTZXQucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50LCBjYWxsYmFjaykge1xuICAgIHZhciBzdWJzY3JpYmVycyA9IHRoaXMuX3N1YnNjcmliZXJzW2V2ZW50XTtcbiAgICBpZiAoIXN1YnNjcmliZXJzKSB7XG4gICAgICBzdWJzY3JpYmVycyA9IFtdO1xuICAgICAgdGhpcy5fc3Vic2NyaWJlcnNbZXZlbnRdID0gc3Vic2NyaWJlcnM7XG4gICAgfVxuXG4gICAgc3Vic2NyaWJlcnMucHVzaCh7XG4gICAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgICB9KTtcbiAgfTtcblxuICAvLyBUT0RPOiByZW1vdmUgdGhpcyBkZXByZWNhdGVkIGZ1bmN0aW9uIHNvbWUgZGF5IChyZXBsYWNlZCB3aXRoIGBvbmAgc2luY2UgdmVyc2lvbiAwLjUsIGRlcHJlY2F0ZWQgc2luY2UgdjQuMClcbiAgRGF0YVNldC5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRGF0YVNldC5zdWJzY3JpYmUgaXMgZGVwcmVjYXRlZC4gVXNlIERhdGFTZXQub24gaW5zdGVhZC4nKTtcbiAgfTtcblxuICAvKipcbiAgICogVW5zdWJzY3JpYmUgZnJvbSBhbiBldmVudCwgcmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgRGF0YVNldC5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBjYWxsYmFjaykge1xuICAgIHZhciBzdWJzY3JpYmVycyA9IHRoaXMuX3N1YnNjcmliZXJzW2V2ZW50XTtcbiAgICBpZiAoc3Vic2NyaWJlcnMpIHtcbiAgICAgIHRoaXMuX3N1YnNjcmliZXJzW2V2ZW50XSA9IHN1YnNjcmliZXJzLmZpbHRlcihmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RlbmVyLmNhbGxiYWNrICE9IGNhbGxiYWNrO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRPRE86IHJlbW92ZSB0aGlzIGRlcHJlY2F0ZWQgZnVuY3Rpb24gc29tZSBkYXkgKHJlcGxhY2VkIHdpdGggYG9uYCBzaW5jZSB2ZXJzaW9uIDAuNSwgZGVwcmVjYXRlZCBzaW5jZSB2NC4wKVxuICBEYXRhU2V0LnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGFTZXQudW5zdWJzY3JpYmUgaXMgZGVwcmVjYXRlZC4gVXNlIERhdGFTZXQub2ZmIGluc3RlYWQuJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRyaWdnZXIgYW4gZXZlbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0IHwgbnVsbH0gcGFyYW1zXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbc2VuZGVySWRdICAgICAgIE9wdGlvbmFsIGlkIG9mIHRoZSBzZW5kZXIuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBEYXRhU2V0LnByb3RvdHlwZS5fdHJpZ2dlciA9IGZ1bmN0aW9uIChldmVudCwgcGFyYW1zLCBzZW5kZXJJZCkge1xuICAgIGlmIChldmVudCA9PSAnKicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHRyaWdnZXIgZXZlbnQgKicpO1xuICAgIH1cblxuICAgIHZhciBzdWJzY3JpYmVycyA9IFtdO1xuICAgIGlmIChldmVudCBpbiB0aGlzLl9zdWJzY3JpYmVycykge1xuICAgICAgc3Vic2NyaWJlcnMgPSBzdWJzY3JpYmVycy5jb25jYXQodGhpcy5fc3Vic2NyaWJlcnNbZXZlbnRdKTtcbiAgICB9XG4gICAgaWYgKCcqJyBpbiB0aGlzLl9zdWJzY3JpYmVycykge1xuICAgICAgc3Vic2NyaWJlcnMgPSBzdWJzY3JpYmVycy5jb25jYXQodGhpcy5fc3Vic2NyaWJlcnNbJyonXSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHN1YnNjcmliZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgc3Vic2NyaWJlciA9IHN1YnNjcmliZXJzW2ldO1xuICAgICAgaWYgKHN1YnNjcmliZXIuY2FsbGJhY2spIHtcbiAgICAgICAgc3Vic2NyaWJlci5jYWxsYmFjayhldmVudCwgcGFyYW1zLCBzZW5kZXJJZCB8fCBudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBkYXRhLlxuICAgKiBBZGRpbmcgYW4gaXRlbSB3aWxsIGZhaWwgd2hlbiB0aGVyZSBhbHJlYWR5IGlzIGFuIGl0ZW0gd2l0aCB0aGUgc2FtZSBpZC5cbiAgICogQHBhcmFtIHtPYmplY3QgfCBBcnJheX0gZGF0YVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3NlbmRlcklkXSBPcHRpb25hbCBzZW5kZXIgaWRcbiAgICogQHJldHVybiB7QXJyYXl9IGFkZGVkSWRzICAgICAgQXJyYXkgd2l0aCB0aGUgaWRzIG9mIHRoZSBhZGRlZCBpdGVtc1xuICAgKi9cbiAgRGF0YVNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGRhdGEsIHNlbmRlcklkKSB7XG4gICAgdmFyIGFkZGVkSWRzID0gW10sXG4gICAgICAgIGlkLFxuICAgICAgICBtZSA9IHRoaXM7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgLy8gQXJyYXlcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlkID0gbWUuX2FkZEl0ZW0oZGF0YVtpXSk7XG4gICAgICAgIGFkZGVkSWRzLnB1c2goaWQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgLy8gU2luZ2xlIGl0ZW1cbiAgICAgIGlkID0gbWUuX2FkZEl0ZW0oZGF0YSk7XG4gICAgICBhZGRlZElkcy5wdXNoKGlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGRhdGFUeXBlJyk7XG4gICAgfVxuXG4gICAgaWYgKGFkZGVkSWRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fdHJpZ2dlcignYWRkJywgeyBpdGVtczogYWRkZWRJZHMgfSwgc2VuZGVySWQpO1xuICAgIH1cblxuICAgIHJldHVybiBhZGRlZElkcztcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIGV4aXN0aW5nIGl0ZW1zLiBXaGVuIGFuIGl0ZW0gZG9lcyBub3QgZXhpc3QsIGl0IHdpbGwgYmUgY3JlYXRlZFxuICAgKiBAcGFyYW0ge09iamVjdCB8IEFycmF5fSBkYXRhXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbc2VuZGVySWRdIE9wdGlvbmFsIHNlbmRlciBpZFxuICAgKiBAcmV0dXJuIHtBcnJheX0gdXBkYXRlZElkcyAgICAgVGhlIGlkcyBvZiB0aGUgYWRkZWQgb3IgdXBkYXRlZCBpdGVtc1xuICAgKi9cbiAgRGF0YVNldC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEsIHNlbmRlcklkKSB7XG4gICAgdmFyIGFkZGVkSWRzID0gW107XG4gICAgdmFyIHVwZGF0ZWRJZHMgPSBbXTtcbiAgICB2YXIgb2xkRGF0YSA9IFtdO1xuICAgIHZhciB1cGRhdGVkRGF0YSA9IFtdO1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdmFyIGZpZWxkSWQgPSBtZS5fZmllbGRJZDtcblxuICAgIHZhciBhZGRPclVwZGF0ZSA9IGZ1bmN0aW9uIGFkZE9yVXBkYXRlKGl0ZW0pIHtcbiAgICAgIHZhciBpZCA9IGl0ZW1bZmllbGRJZF07XG4gICAgICBpZiAobWUuX2RhdGFbaWRdKSB7XG4gICAgICAgIHZhciBvbGRJdGVtID0gdXRpbC5leHRlbmQoe30sIG1lLl9kYXRhW2lkXSk7XG4gICAgICAgIC8vIHVwZGF0ZSBpdGVtXG4gICAgICAgIGlkID0gbWUuX3VwZGF0ZUl0ZW0oaXRlbSk7XG4gICAgICAgIHVwZGF0ZWRJZHMucHVzaChpZCk7XG4gICAgICAgIHVwZGF0ZWREYXRhLnB1c2goaXRlbSk7XG4gICAgICAgIG9sZERhdGEucHVzaChvbGRJdGVtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGFkZCBuZXcgaXRlbVxuICAgICAgICBpZCA9IG1lLl9hZGRJdGVtKGl0ZW0pO1xuICAgICAgICBhZGRlZElkcy5wdXNoKGlkKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIC8vIEFycmF5XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoZGF0YVtpXSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgIGFkZE9yVXBkYXRlKGRhdGFbaV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybignSWdub3JpbmcgaW5wdXQgaXRlbSwgd2hpY2ggaXMgbm90IGFuIG9iamVjdCBhdCBpbmRleCAnICsgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgIC8vIFNpbmdsZSBpdGVtXG4gICAgICBhZGRPclVwZGF0ZShkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGRhdGFUeXBlJyk7XG4gICAgfVxuXG4gICAgaWYgKGFkZGVkSWRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fdHJpZ2dlcignYWRkJywgeyBpdGVtczogYWRkZWRJZHMgfSwgc2VuZGVySWQpO1xuICAgIH1cbiAgICBpZiAodXBkYXRlZElkcy5sZW5ndGgpIHtcbiAgICAgIHZhciBwcm9wcyA9IHsgaXRlbXM6IHVwZGF0ZWRJZHMsIG9sZERhdGE6IG9sZERhdGEsIGRhdGE6IHVwZGF0ZWREYXRhIH07XG4gICAgICAvLyBUT0RPOiByZW1vdmUgZGVwcmVjYXRlZCBwcm9wZXJ0eSAnZGF0YScgc29tZSBkYXlcbiAgICAgIC8vT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAnZGF0YScsIHtcbiAgICAgIC8vICAnZ2V0JzogKGZ1bmN0aW9uKCkge1xuICAgICAgLy8gICAgY29uc29sZS53YXJuKCdQcm9wZXJ0eSBkYXRhIGlzIGRlcHJlY2F0ZWQuIFVzZSBEYXRhU2V0LmdldChpZHMpIHRvIHJldHJpZXZlIHRoZSBuZXcgZGF0YSwgdXNlIHRoZSBvbGREYXRhIHByb3BlcnR5IG9uIHRoaXMgb2JqZWN0IHRvIGdldCB0aGUgb2xkIGRhdGEnKTtcbiAgICAgIC8vICAgIHJldHVybiB1cGRhdGVkRGF0YTtcbiAgICAgIC8vICB9KS5iaW5kKHRoaXMpXG4gICAgICAvL30pO1xuICAgICAgdGhpcy5fdHJpZ2dlcigndXBkYXRlJywgcHJvcHMsIHNlbmRlcklkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWRkZWRJZHMuY29uY2F0KHVwZGF0ZWRJZHMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSBkYXRhIGl0ZW0gb3IgbXVsdGlwbGUgaXRlbXMuXG4gICAqXG4gICAqIFVzYWdlOlxuICAgKlxuICAgKiAgICAgZ2V0KClcbiAgICogICAgIGdldChvcHRpb25zOiBPYmplY3QpXG4gICAqXG4gICAqICAgICBnZXQoaWQ6IE51bWJlciB8IFN0cmluZylcbiAgICogICAgIGdldChpZDogTnVtYmVyIHwgU3RyaW5nLCBvcHRpb25zOiBPYmplY3QpXG4gICAqXG4gICAqICAgICBnZXQoaWRzOiBOdW1iZXJbXSB8IFN0cmluZ1tdKVxuICAgKiAgICAgZ2V0KGlkczogTnVtYmVyW10gfCBTdHJpbmdbXSwgb3B0aW9uczogT2JqZWN0KVxuICAgKlxuICAgKiBXaGVyZTpcbiAgICpcbiAgICoge051bWJlciB8IFN0cmluZ30gaWQgICAgICAgICBUaGUgaWQgb2YgYW4gaXRlbVxuICAgKiB7TnVtYmVyW10gfCBTdHJpbmd7fX0gaWRzICAgIEFuIGFycmF5IHdpdGggaWRzIG9mIGl0ZW1zXG4gICAqIHtPYmplY3R9IG9wdGlvbnMgICAgICAgICAgICAgQW4gT2JqZWN0IHdpdGggb3B0aW9ucy4gQXZhaWxhYmxlIG9wdGlvbnM6XG4gICAqIHtTdHJpbmd9IFtyZXR1cm5UeXBlXSAgICAgICAgVHlwZSBvZiBkYXRhIHRvIGJlIHJldHVybmVkLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENhbiBiZSAnQXJyYXknIChkZWZhdWx0KSBvciAnT2JqZWN0Jy5cbiAgICoge09iamVjdC48U3RyaW5nLCBTdHJpbmc+fSBbdHlwZV1cbiAgICoge1N0cmluZ1tdfSBbZmllbGRzXSAgICAgICAgICBmaWVsZCBuYW1lcyB0byBiZSByZXR1cm5lZFxuICAgKiB7ZnVuY3Rpb259IFtmaWx0ZXJdICAgICAgICAgIGZpbHRlciBpdGVtc1xuICAgKiB7U3RyaW5nIHwgZnVuY3Rpb259IFtvcmRlcl0gIE9yZGVyIHRoZSBpdGVtcyBieSBhIGZpZWxkIG5hbWUgb3IgY3VzdG9tIHNvcnQgZnVuY3Rpb24uXG4gICAqIEB0aHJvd3MgRXJyb3JcbiAgICovXG4gIERhdGFTZXQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgdmFyIG1lID0gdGhpcztcblxuICAgIC8vIHBhcnNlIHRoZSBhcmd1bWVudHNcbiAgICB2YXIgaWQsIGlkcywgb3B0aW9ucztcbiAgICB2YXIgZmlyc3RUeXBlID0gdXRpbC5nZXRUeXBlKGFyZ3VtZW50c1swXSk7XG4gICAgaWYgKGZpcnN0VHlwZSA9PSAnU3RyaW5nJyB8fCBmaXJzdFR5cGUgPT0gJ051bWJlcicpIHtcbiAgICAgIC8vIGdldChpZCBbLCBvcHRpb25zXSlcbiAgICAgIGlkID0gYXJndW1lbnRzWzBdO1xuICAgICAgb3B0aW9ucyA9IGFyZ3VtZW50c1sxXTtcbiAgICB9IGVsc2UgaWYgKGZpcnN0VHlwZSA9PSAnQXJyYXknKSB7XG4gICAgICAvLyBnZXQoaWRzIFssIG9wdGlvbnNdKVxuICAgICAgaWRzID0gYXJndW1lbnRzWzBdO1xuICAgICAgb3B0aW9ucyA9IGFyZ3VtZW50c1sxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZ2V0KFssIG9wdGlvbnNdKVxuICAgICAgb3B0aW9ucyA9IGFyZ3VtZW50c1swXTtcbiAgICB9XG5cbiAgICAvLyBkZXRlcm1pbmUgdGhlIHJldHVybiB0eXBlXG4gICAgdmFyIHJldHVyblR5cGU7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZXR1cm5UeXBlKSB7XG4gICAgICB2YXIgYWxsb3dlZFZhbHVlcyA9IFsnQXJyYXknLCAnT2JqZWN0J107XG4gICAgICByZXR1cm5UeXBlID0gYWxsb3dlZFZhbHVlcy5pbmRleE9mKG9wdGlvbnMucmV0dXJuVHlwZSkgPT0gLTEgPyAnQXJyYXknIDogb3B0aW9ucy5yZXR1cm5UeXBlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm5UeXBlID0gJ0FycmF5JztcbiAgICB9XG5cbiAgICAvLyBidWlsZCBvcHRpb25zXG4gICAgdmFyIHR5cGUgPSBvcHRpb25zICYmIG9wdGlvbnMudHlwZSB8fCB0aGlzLl9vcHRpb25zLnR5cGU7XG4gICAgdmFyIGZpbHRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5maWx0ZXI7XG4gICAgdmFyIGl0ZW1zID0gW10sXG4gICAgICAgIGl0ZW0sXG4gICAgICAgIGl0ZW1JZHMsXG4gICAgICAgIGl0ZW1JZCxcbiAgICAgICAgaSxcbiAgICAgICAgbGVuO1xuXG4gICAgLy8gY29udmVydCBpdGVtc1xuICAgIGlmIChpZCAhPSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHJldHVybiBhIHNpbmdsZSBpdGVtXG4gICAgICBpdGVtID0gbWUuX2dldEl0ZW0oaWQsIHR5cGUpO1xuICAgICAgaWYgKGl0ZW0gJiYgZmlsdGVyICYmICFmaWx0ZXIoaXRlbSkpIHtcbiAgICAgICAgaXRlbSA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpZHMgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyByZXR1cm4gYSBzdWJzZXQgb2YgaXRlbXNcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpdGVtID0gbWUuX2dldEl0ZW0oaWRzW2ldLCB0eXBlKTtcbiAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGl0ZW0pKSB7XG4gICAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZXR1cm4gYWxsIGl0ZW1zXG4gICAgICBpdGVtSWRzID0gT2JqZWN0LmtleXModGhpcy5fZGF0YSk7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtSWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGl0ZW1JZCA9IGl0ZW1JZHNbaV07XG4gICAgICAgIGl0ZW0gPSBtZS5fZ2V0SXRlbShpdGVtSWQsIHR5cGUpO1xuICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoaXRlbSkpIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gb3JkZXIgdGhlIHJlc3VsdHNcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm9yZGVyICYmIGlkID09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fc29ydChpdGVtcywgb3B0aW9ucy5vcmRlcik7XG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIGZpZWxkcyBvZiB0aGUgaXRlbXNcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmZpZWxkcykge1xuICAgICAgdmFyIGZpZWxkcyA9IG9wdGlvbnMuZmllbGRzO1xuICAgICAgaWYgKGlkICE9IHVuZGVmaW5lZCkge1xuICAgICAgICBpdGVtID0gdGhpcy5fZmlsdGVyRmllbGRzKGl0ZW0sIGZpZWxkcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGl0ZW1zW2ldID0gdGhpcy5fZmlsdGVyRmllbGRzKGl0ZW1zW2ldLCBmaWVsZHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIHRoZSByZXN1bHRzXG4gICAgaWYgKHJldHVyblR5cGUgPT0gJ09iamVjdCcpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fSxcbiAgICAgICAgICByZXN1bHRhbnQ7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICByZXN1bHRhbnQgPSBpdGVtc1tpXTtcbiAgICAgICAgcmVzdWx0W3Jlc3VsdGFudC5pZF0gPSByZXN1bHRhbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaWQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGEgc2luZ2xlIGl0ZW1cbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBqdXN0IHJldHVybiBvdXIgYXJyYXlcbiAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IGlkcyBvZiBhbGwgaXRlbXMgb3IgZnJvbSBhIGZpbHRlcmVkIHNldCBvZiBpdGVtcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICBBbiBPYmplY3Qgd2l0aCBvcHRpb25zLiBBdmFpbGFibGUgb3B0aW9uczpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ZnVuY3Rpb259IFtmaWx0ZXJdIGZpbHRlciBpdGVtc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmcgfCBmdW5jdGlvbn0gW29yZGVyXSBPcmRlciB0aGUgaXRlbXMgYnlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBmaWVsZCBuYW1lIG9yIGN1c3RvbSBzb3J0IGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtBcnJheX0gaWRzXG4gICAqL1xuICBEYXRhU2V0LnByb3RvdHlwZS5nZXRJZHMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YSxcbiAgICAgICAgZmlsdGVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmZpbHRlcixcbiAgICAgICAgb3JkZXIgPSBvcHRpb25zICYmIG9wdGlvbnMub3JkZXIsXG4gICAgICAgIHR5cGUgPSBvcHRpb25zICYmIG9wdGlvbnMudHlwZSB8fCB0aGlzLl9vcHRpb25zLnR5cGUsXG4gICAgICAgIGl0ZW1JZHMgPSBPYmplY3Qua2V5cyhkYXRhKSxcbiAgICAgICAgaSxcbiAgICAgICAgbGVuLFxuICAgICAgICBpZCxcbiAgICAgICAgaXRlbSxcbiAgICAgICAgaXRlbXMsXG4gICAgICAgIGlkcyA9IFtdO1xuXG4gICAgaWYgKGZpbHRlcikge1xuICAgICAgLy8gZ2V0IGZpbHRlcmVkIGl0ZW1zXG4gICAgICBpZiAob3JkZXIpIHtcbiAgICAgICAgLy8gY3JlYXRlIG9yZGVyZWQgbGlzdFxuICAgICAgICBpdGVtcyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtSWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWQgPSBpdGVtSWRzW2ldO1xuICAgICAgICAgIGl0ZW0gPSB0aGlzLl9nZXRJdGVtKGlkLCB0eXBlKTtcbiAgICAgICAgICBpZiAoZmlsdGVyKGl0ZW0pKSB7XG4gICAgICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NvcnQoaXRlbXMsIG9yZGVyKTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlkcy5wdXNoKGl0ZW1zW2ldW3RoaXMuX2ZpZWxkSWRdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY3JlYXRlIHVub3JkZXJlZCBsaXN0XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1JZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZCA9IGl0ZW1JZHNbaV07XG4gICAgICAgICAgaXRlbSA9IHRoaXMuX2dldEl0ZW0oaWQsIHR5cGUpO1xuICAgICAgICAgIGlmIChmaWx0ZXIoaXRlbSkpIHtcbiAgICAgICAgICAgIGlkcy5wdXNoKGl0ZW1bdGhpcy5fZmllbGRJZF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBnZXQgYWxsIGl0ZW1zXG4gICAgICBpZiAob3JkZXIpIHtcbiAgICAgICAgLy8gY3JlYXRlIGFuIG9yZGVyZWQgbGlzdFxuICAgICAgICBpdGVtcyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtSWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWQgPSBpdGVtSWRzW2ldO1xuICAgICAgICAgIGl0ZW1zLnB1c2goZGF0YVtpZF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc29ydChpdGVtcywgb3JkZXIpO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWRzLnB1c2goaXRlbXNbaV1bdGhpcy5fZmllbGRJZF0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjcmVhdGUgdW5vcmRlcmVkIGxpc3RcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gaXRlbUlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlkID0gaXRlbUlkc1tpXTtcbiAgICAgICAgICBpdGVtID0gZGF0YVtpZF07XG4gICAgICAgICAgaWRzLnB1c2goaXRlbVt0aGlzLl9maWVsZElkXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaWRzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBEYXRhU2V0IGl0c2VsZi4gSXMgb3ZlcndyaXR0ZW4gZm9yIGV4YW1wbGUgYnkgdGhlIERhdGFWaWV3LFxuICAgKiB3aGljaCByZXR1cm5zIHRoZSBEYXRhU2V0IGl0IGlzIGNvbm5lY3RlZCB0byBpbnN0ZWFkLlxuICAgKi9cbiAgRGF0YVNldC5wcm90b3R5cGUuZ2V0RGF0YVNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogRXhlY3V0ZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBldmVyeSBpdGVtIGluIHRoZSBkYXRhc2V0LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgIEF2YWlsYWJsZSBvcHRpb25zOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtPYmplY3QuPFN0cmluZywgU3RyaW5nPn0gW3R5cGVdXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZ1tdfSBbZmllbGRzXSBmaWx0ZXIgZmllbGRzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2Z1bmN0aW9ufSBbZmlsdGVyXSBmaWx0ZXIgaXRlbXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nIHwgZnVuY3Rpb259IFtvcmRlcl0gT3JkZXIgdGhlIGl0ZW1zIGJ5XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgZmllbGQgbmFtZSBvciBjdXN0b20gc29ydCBmdW5jdGlvbi5cbiAgICovXG4gIERhdGFTZXQucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICB2YXIgZmlsdGVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmZpbHRlcixcbiAgICAgICAgdHlwZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy50eXBlIHx8IHRoaXMuX29wdGlvbnMudHlwZSxcbiAgICAgICAgZGF0YSA9IHRoaXMuX2RhdGEsXG4gICAgICAgIGl0ZW1JZHMgPSBPYmplY3Qua2V5cyhkYXRhKSxcbiAgICAgICAgaSxcbiAgICAgICAgbGVuLFxuICAgICAgICBpdGVtLFxuICAgICAgICBpZDtcblxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMub3JkZXIpIHtcbiAgICAgIC8vIGV4ZWN1dGUgZm9yRWFjaCBvbiBvcmRlcmVkIGxpc3RcbiAgICAgIHZhciBpdGVtcyA9IHRoaXMuZ2V0KG9wdGlvbnMpO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIGlkID0gaXRlbVt0aGlzLl9maWVsZElkXTtcbiAgICAgICAgY2FsbGJhY2soaXRlbSwgaWQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1bm9yZGVyZWRcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1JZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWQgPSBpdGVtSWRzW2ldO1xuICAgICAgICBpdGVtID0gdGhpcy5fZ2V0SXRlbShpZCwgdHlwZSk7XG4gICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlcihpdGVtKSkge1xuICAgICAgICAgIGNhbGxiYWNrKGl0ZW0sIGlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogTWFwIGV2ZXJ5IGl0ZW0gaW4gdGhlIGRhdGFzZXQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge09iamVjdC48U3RyaW5nLCBTdHJpbmc+fSBbdHlwZV1cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nW119IFtmaWVsZHNdIGZpbHRlciBmaWVsZHNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ZnVuY3Rpb259IFtmaWx0ZXJdIGZpbHRlciBpdGVtc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmcgfCBmdW5jdGlvbn0gW29yZGVyXSBPcmRlciB0aGUgaXRlbXMgYnlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBmaWVsZCBuYW1lIG9yIGN1c3RvbSBzb3J0IGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtPYmplY3RbXX0gbWFwcGVkSXRlbXNcbiAgICovXG4gIERhdGFTZXQucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIHZhciBmaWx0ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMuZmlsdGVyLFxuICAgICAgICB0eXBlID0gb3B0aW9ucyAmJiBvcHRpb25zLnR5cGUgfHwgdGhpcy5fb3B0aW9ucy50eXBlLFxuICAgICAgICBtYXBwZWRJdGVtcyA9IFtdLFxuICAgICAgICBkYXRhID0gdGhpcy5fZGF0YSxcbiAgICAgICAgaXRlbUlkcyA9IE9iamVjdC5rZXlzKGRhdGEpLFxuICAgICAgICBpLFxuICAgICAgICBsZW4sXG4gICAgICAgIGlkLFxuICAgICAgICBpdGVtO1xuXG4gICAgLy8gY29udmVydCBhbmQgZmlsdGVyIGl0ZW1zXG4gICAgZm9yIChpID0gMCwgbGVuID0gaXRlbUlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWQgPSBpdGVtSWRzW2ldO1xuICAgICAgaXRlbSA9IHRoaXMuX2dldEl0ZW0oaWQsIHR5cGUpO1xuICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGl0ZW0pKSB7XG4gICAgICAgIG1hcHBlZEl0ZW1zLnB1c2goY2FsbGJhY2soaXRlbSwgaWQpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBvcmRlciBpdGVtc1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMub3JkZXIpIHtcbiAgICAgIHRoaXMuX3NvcnQobWFwcGVkSXRlbXMsIG9wdGlvbnMub3JkZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXBwZWRJdGVtcztcbiAgfTtcblxuICAvKipcbiAgICogRmlsdGVyIHRoZSBmaWVsZHMgb2YgYW4gaXRlbVxuICAgKiBAcGFyYW0ge09iamVjdCB8IG51bGx9IGl0ZW1cbiAgICogQHBhcmFtIHtTdHJpbmdbXX0gZmllbGRzICAgICBGaWVsZCBuYW1lc1xuICAgKiBAcmV0dXJuIHtPYmplY3QgfCBudWxsfSBmaWx0ZXJlZEl0ZW0gb3IgbnVsbCBpZiBubyBpdGVtIGlzIHByb3ZpZGVkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBEYXRhU2V0LnByb3RvdHlwZS5fZmlsdGVyRmllbGRzID0gZnVuY3Rpb24gKGl0ZW0sIGZpZWxkcykge1xuICAgIGlmICghaXRlbSkge1xuICAgICAgLy8gaXRlbSBpcyBudWxsXG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG5cbiAgICB2YXIgZmlsdGVyZWRJdGVtID0ge30sXG4gICAgICAgIGl0ZW1GaWVsZHMgPSBPYmplY3Qua2V5cyhpdGVtKSxcbiAgICAgICAgbGVuID0gaXRlbUZpZWxkcy5sZW5ndGgsXG4gICAgICAgIGksXG4gICAgICAgIGZpZWxkO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZmllbGRzKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGZpZWxkID0gaXRlbUZpZWxkc1tpXTtcbiAgICAgICAgaWYgKGZpZWxkcy5pbmRleE9mKGZpZWxkKSAhPSAtMSkge1xuICAgICAgICAgIGZpbHRlcmVkSXRlbVtmaWVsZF0gPSBpdGVtW2ZpZWxkXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZmllbGQgPSBpdGVtRmllbGRzW2ldO1xuICAgICAgICBpZiAoZmllbGRzLmhhc093blByb3BlcnR5KGZpZWxkKSkge1xuICAgICAgICAgIGZpbHRlcmVkSXRlbVtmaWVsZHNbZmllbGRdXSA9IGl0ZW1bZmllbGRdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbHRlcmVkSXRlbTtcbiAgfTtcblxuICAvKipcbiAgICogU29ydCB0aGUgcHJvdmlkZWQgYXJyYXkgd2l0aCBpdGVtc1xuICAgKiBAcGFyYW0ge09iamVjdFtdfSBpdGVtc1xuICAgKiBAcGFyYW0ge1N0cmluZyB8IGZ1bmN0aW9ufSBvcmRlciAgICAgIEEgZmllbGQgbmFtZSBvciBjdXN0b20gc29ydCBmdW5jdGlvbi5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIERhdGFTZXQucHJvdG90eXBlLl9zb3J0ID0gZnVuY3Rpb24gKGl0ZW1zLCBvcmRlcikge1xuICAgIGlmICh1dGlsLmlzU3RyaW5nKG9yZGVyKSkge1xuICAgICAgLy8gb3JkZXIgYnkgcHJvdmlkZWQgZmllbGQgbmFtZVxuICAgICAgdmFyIG5hbWUgPSBvcmRlcjsgLy8gZmllbGQgbmFtZVxuICAgICAgaXRlbXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgYXYgPSBhW25hbWVdO1xuICAgICAgICB2YXIgYnYgPSBiW25hbWVdO1xuICAgICAgICByZXR1cm4gYXYgPiBidiA/IDEgOiBhdiA8IGJ2ID8gLTEgOiAwO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3JkZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIG9yZGVyIGJ5IHNvcnQgZnVuY3Rpb25cbiAgICAgIGl0ZW1zLnNvcnQob3JkZXIpO1xuICAgIH1cbiAgICAvLyBUT0RPOiBleHRlbmQgb3JkZXIgYnkgYW4gT2JqZWN0IHtmaWVsZDpTdHJpbmcsIGRpcmVjdGlvbjpTdHJpbmd9XG4gICAgLy8gICAgICAgd2hlcmUgZGlyZWN0aW9uIGNhbiBiZSAnYXNjJyBvciAnZGVzYydcbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT3JkZXIgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nJyk7XG4gICAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBvYmplY3QgYnkgcG9pbnRlciBvciBieSBpZFxuICAgKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlciB8IE9iamVjdCB8IEFycmF5fSBpZCBPYmplY3Qgb3IgaWQsIG9yIGFuIGFycmF5IHdpdGhcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0cyBvciBpZHMgdG8gYmUgcmVtb3ZlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3NlbmRlcklkXSBPcHRpb25hbCBzZW5kZXIgaWRcbiAgICogQHJldHVybiB7QXJyYXl9IHJlbW92ZWRJZHNcbiAgICovXG4gIERhdGFTZXQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChpZCwgc2VuZGVySWQpIHtcbiAgICB2YXIgcmVtb3ZlZElkcyA9IFtdLFxuICAgICAgICBpLFxuICAgICAgICBsZW4sXG4gICAgICAgIHJlbW92ZWRJZDtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGlkKSkge1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gaWQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcmVtb3ZlZElkID0gdGhpcy5fcmVtb3ZlKGlkW2ldKTtcbiAgICAgICAgaWYgKHJlbW92ZWRJZCAhPSBudWxsKSB7XG4gICAgICAgICAgcmVtb3ZlZElkcy5wdXNoKHJlbW92ZWRJZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlZElkID0gdGhpcy5fcmVtb3ZlKGlkKTtcbiAgICAgIGlmIChyZW1vdmVkSWQgIT0gbnVsbCkge1xuICAgICAgICByZW1vdmVkSWRzLnB1c2gocmVtb3ZlZElkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVtb3ZlZElkcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3RyaWdnZXIoJ3JlbW92ZScsIHsgaXRlbXM6IHJlbW92ZWRJZHMgfSwgc2VuZGVySWQpO1xuICAgIH1cblxuICAgIHJldHVybiByZW1vdmVkSWRzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gaXRlbSBieSBpdHMgaWRcbiAgICogQHBhcmFtIHtOdW1iZXIgfCBTdHJpbmcgfCBPYmplY3R9IGlkICAgaWQgb3IgaXRlbVxuICAgKiBAcmV0dXJucyB7TnVtYmVyIHwgU3RyaW5nIHwgbnVsbH0gaWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIERhdGFTZXQucHJvdG90eXBlLl9yZW1vdmUgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICBpZiAodXRpbC5pc051bWJlcihpZCkgfHwgdXRpbC5pc1N0cmluZyhpZCkpIHtcbiAgICAgIGlmICh0aGlzLl9kYXRhW2lkXSkge1xuICAgICAgICBkZWxldGUgdGhpcy5fZGF0YVtpZF07XG4gICAgICAgIHRoaXMubGVuZ3RoLS07XG4gICAgICAgIHJldHVybiBpZDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlkIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICB2YXIgaXRlbUlkID0gaWRbdGhpcy5fZmllbGRJZF07XG4gICAgICBpZiAoaXRlbUlkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fZGF0YVtpdGVtSWRdKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9kYXRhW2l0ZW1JZF07XG4gICAgICAgIHRoaXMubGVuZ3RoLS07XG4gICAgICAgIHJldHVybiBpdGVtSWQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhciB0aGUgZGF0YVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3NlbmRlcklkXSBPcHRpb25hbCBzZW5kZXIgaWRcbiAgICogQHJldHVybiB7QXJyYXl9IHJlbW92ZWRJZHMgICAgVGhlIGlkcyBvZiBhbGwgcmVtb3ZlZCBpdGVtc1xuICAgKi9cbiAgRGF0YVNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoc2VuZGVySWQpIHtcbiAgICB2YXIgaWRzID0gT2JqZWN0LmtleXModGhpcy5fZGF0YSk7XG5cbiAgICB0aGlzLl9kYXRhID0ge307XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuXG4gICAgdGhpcy5fdHJpZ2dlcigncmVtb3ZlJywgeyBpdGVtczogaWRzIH0sIHNlbmRlcklkKTtcblxuICAgIHJldHVybiBpZHM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpbmQgdGhlIGl0ZW0gd2l0aCBtYXhpbXVtIHZhbHVlIG9mIGEgc3BlY2lmaWVkIGZpZWxkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICAgKiBAcmV0dXJuIHtPYmplY3QgfCBudWxsfSBpdGVtICBJdGVtIGNvbnRhaW5pbmcgbWF4IHZhbHVlLCBvciBudWxsIGlmIG5vIGl0ZW1zXG4gICAqL1xuICBEYXRhU2V0LnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGEsXG4gICAgICAgIGl0ZW1JZHMgPSBPYmplY3Qua2V5cyhkYXRhKSxcbiAgICAgICAgbWF4ID0gbnVsbCxcbiAgICAgICAgbWF4RmllbGQgPSBudWxsLFxuICAgICAgICBpLFxuICAgICAgICBsZW47XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtSWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgaWQgPSBpdGVtSWRzW2ldO1xuICAgICAgdmFyIGl0ZW0gPSBkYXRhW2lkXTtcbiAgICAgIHZhciBpdGVtRmllbGQgPSBpdGVtW2ZpZWxkXTtcbiAgICAgIGlmIChpdGVtRmllbGQgIT0gbnVsbCAmJiAoIW1heCB8fCBpdGVtRmllbGQgPiBtYXhGaWVsZCkpIHtcbiAgICAgICAgbWF4ID0gaXRlbTtcbiAgICAgICAgbWF4RmllbGQgPSBpdGVtRmllbGQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heDtcbiAgfTtcblxuICAvKipcbiAgICogRmluZCB0aGUgaXRlbSB3aXRoIG1pbmltdW0gdmFsdWUgb2YgYSBzcGVjaWZpZWQgZmllbGRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gICAqIEByZXR1cm4ge09iamVjdCB8IG51bGx9IGl0ZW0gIEl0ZW0gY29udGFpbmluZyBtYXggdmFsdWUsIG9yIG51bGwgaWYgbm8gaXRlbXNcbiAgICovXG4gIERhdGFTZXQucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YSxcbiAgICAgICAgaXRlbUlkcyA9IE9iamVjdC5rZXlzKGRhdGEpLFxuICAgICAgICBtaW4gPSBudWxsLFxuICAgICAgICBtaW5GaWVsZCA9IG51bGwsXG4gICAgICAgIGksXG4gICAgICAgIGxlbjtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1JZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBpZCA9IGl0ZW1JZHNbaV07XG4gICAgICB2YXIgaXRlbSA9IGRhdGFbaWRdO1xuICAgICAgdmFyIGl0ZW1GaWVsZCA9IGl0ZW1bZmllbGRdO1xuICAgICAgaWYgKGl0ZW1GaWVsZCAhPSBudWxsICYmICghbWluIHx8IGl0ZW1GaWVsZCA8IG1pbkZpZWxkKSkge1xuICAgICAgICBtaW4gPSBpdGVtO1xuICAgICAgICBtaW5GaWVsZCA9IGl0ZW1GaWVsZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWluO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGaW5kIGFsbCBkaXN0aW5jdCB2YWx1ZXMgb2YgYSBzcGVjaWZpZWQgZmllbGRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gICAqIEByZXR1cm4ge0FycmF5fSB2YWx1ZXMgIEFycmF5IGNvbnRhaW5pbmcgYWxsIGRpc3RpbmN0IHZhbHVlcy4gSWYgZGF0YSBpdGVtc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBkbyBub3QgY29udGFpbiB0aGUgc3BlY2lmaWVkIGZpZWxkIGFyZSBpZ25vcmVkLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgcmV0dXJuZWQgYXJyYXkgaXMgdW5vcmRlcmVkLlxuICAgKi9cbiAgRGF0YVNldC5wcm90b3R5cGUuZGlzdGluY3QgPSBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgdmFyIGl0ZW1JZHMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgdmFyIGZpZWxkVHlwZSA9IHRoaXMuX29wdGlvbnMudHlwZSAmJiB0aGlzLl9vcHRpb25zLnR5cGVbZmllbGRdIHx8IG51bGw7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgaSwgaiwgbGVuO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gaXRlbUlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGlkID0gaXRlbUlkc1tpXTtcbiAgICAgIHZhciBpdGVtID0gZGF0YVtpZF07XG4gICAgICB2YXIgdmFsdWUgPSBpdGVtW2ZpZWxkXTtcbiAgICAgIHZhciBleGlzdHMgPSBmYWxzZTtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICAgIGlmICh2YWx1ZXNbal0gPT0gdmFsdWUpIHtcbiAgICAgICAgICBleGlzdHMgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWV4aXN0cyAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlc1tjb3VudF0gPSB2YWx1ZTtcbiAgICAgICAgY291bnQrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZmllbGRUeXBlKSB7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSB2YWx1ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFsdWVzW2ldID0gdXRpbC5jb252ZXJ0KHZhbHVlc1tpXSwgZmllbGRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSBzaW5nbGUgaXRlbS4gV2lsbCBmYWlsIHdoZW4gYW4gaXRlbSB3aXRoIHRoZSBzYW1lIGlkIGFscmVhZHkgZXhpc3RzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGlkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBEYXRhU2V0LnByb3RvdHlwZS5fYWRkSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgdmFyIGlkID0gaXRlbVt0aGlzLl9maWVsZElkXTtcblxuICAgIGlmIChpZCAhPSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGNoZWNrIHdoZXRoZXIgdGhpcyBpZCBpcyBhbHJlYWR5IHRha2VuXG4gICAgICBpZiAodGhpcy5fZGF0YVtpZF0pIHtcbiAgICAgICAgLy8gaXRlbSBhbHJlYWR5IGV4aXN0c1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhZGQgaXRlbTogaXRlbSB3aXRoIGlkICcgKyBpZCArICcgYWxyZWFkeSBleGlzdHMnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZ2VuZXJhdGUgYW4gaWRcbiAgICAgIGlkID0gdXRpbC5yYW5kb21VVUlEKCk7XG4gICAgICBpdGVtW3RoaXMuX2ZpZWxkSWRdID0gaWQ7XG4gICAgfVxuXG4gICAgdmFyIGQgPSB7fSxcbiAgICAgICAgZmllbGRzID0gT2JqZWN0LmtleXMoaXRlbSksXG4gICAgICAgIGksXG4gICAgICAgIGxlbjtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBmaWVsZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBmaWVsZCA9IGZpZWxkc1tpXTtcbiAgICAgIHZhciBmaWVsZFR5cGUgPSB0aGlzLl90eXBlW2ZpZWxkXTsgLy8gdHlwZSBtYXkgYmUgdW5kZWZpbmVkXG4gICAgICBkW2ZpZWxkXSA9IHV0aWwuY29udmVydChpdGVtW2ZpZWxkXSwgZmllbGRUeXBlKTtcbiAgICB9XG4gICAgdGhpcy5fZGF0YVtpZF0gPSBkO1xuICAgIHRoaXMubGVuZ3RoKys7XG5cbiAgICByZXR1cm4gaWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhbiBpdGVtLiBGaWVsZHMgY2FuIGJlIGNvbnZlcnRlZCB0byBhIHNwZWNpZmljIHR5cGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gICAqIEBwYXJhbSB7T2JqZWN0LjxTdHJpbmcsIFN0cmluZz59IFt0eXBlc10gIGZpZWxkIHR5cGVzIHRvIGNvbnZlcnRcbiAgICogQHJldHVybiB7T2JqZWN0IHwgbnVsbH0gaXRlbVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgRGF0YVNldC5wcm90b3R5cGUuX2dldEl0ZW0gPSBmdW5jdGlvbiAoaWQsIHR5cGVzKSB7XG4gICAgdmFyIGZpZWxkLCB2YWx1ZSwgaSwgbGVuO1xuXG4gICAgLy8gZ2V0IHRoZSBpdGVtIGZyb20gdGhlIGRhdGFzZXRcbiAgICB2YXIgcmF3ID0gdGhpcy5fZGF0YVtpZF07XG4gICAgaWYgKCFyYXcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgdGhlIGl0ZW1zIGZpZWxkIHR5cGVzXG4gICAgdmFyIGNvbnZlcnRlZCA9IHt9LFxuICAgICAgICBmaWVsZHMgPSBPYmplY3Qua2V5cyhyYXcpO1xuXG4gICAgaWYgKHR5cGVzKSB7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBmaWVsZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZmllbGQgPSBmaWVsZHNbaV07XG4gICAgICAgIHZhbHVlID0gcmF3W2ZpZWxkXTtcbiAgICAgICAgY29udmVydGVkW2ZpZWxkXSA9IHV0aWwuY29udmVydCh2YWx1ZSwgdHlwZXNbZmllbGRdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm8gZmllbGQgdHlwZXMgc3BlY2lmaWVkLCBubyBjb252ZXJ0aW5nIG5lZWRlZFxuICAgICAgZm9yIChpID0gMCwgbGVuID0gZmllbGRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGZpZWxkID0gZmllbGRzW2ldO1xuICAgICAgICB2YWx1ZSA9IHJhd1tmaWVsZF07XG4gICAgICAgIGNvbnZlcnRlZFtmaWVsZF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbnZlcnRlZDtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIGEgc2luZ2xlIGl0ZW06IG1lcmdlIHdpdGggZXhpc3RpbmcgaXRlbS5cbiAgICogV2lsbCBmYWlsIHdoZW4gdGhlIGl0ZW0gaGFzIG5vIGlkLCBvciB3aGVuIHRoZXJlIGRvZXMgbm90IGV4aXN0IGFuIGl0ZW1cbiAgICogd2l0aCB0aGUgc2FtZSBpZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cbiAgICogQHJldHVybiB7U3RyaW5nfSBpZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgRGF0YVNldC5wcm90b3R5cGUuX3VwZGF0ZUl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgIHZhciBpZCA9IGl0ZW1bdGhpcy5fZmllbGRJZF07XG4gICAgaWYgKGlkID09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdXBkYXRlIGl0ZW06IGl0ZW0gaGFzIG5vIGlkIChpdGVtOiAnICsgSlNPTi5zdHJpbmdpZnkoaXRlbSkgKyAnKScpO1xuICAgIH1cbiAgICB2YXIgZCA9IHRoaXMuX2RhdGFbaWRdO1xuICAgIGlmICghZCkge1xuICAgICAgLy8gaXRlbSBkb2Vzbid0IGV4aXN0XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1cGRhdGUgaXRlbTogbm8gaXRlbSB3aXRoIGlkICcgKyBpZCArICcgZm91bmQnKTtcbiAgICB9XG5cbiAgICAvLyBtZXJnZSB3aXRoIGN1cnJlbnQgaXRlbVxuICAgIHZhciBmaWVsZHMgPSBPYmplY3Qua2V5cyhpdGVtKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZmllbGRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgZmllbGQgPSBmaWVsZHNbaV07XG4gICAgICB2YXIgZmllbGRUeXBlID0gdGhpcy5fdHlwZVtmaWVsZF07IC8vIHR5cGUgbWF5IGJlIHVuZGVmaW5lZFxuICAgICAgZFtmaWVsZF0gPSB1dGlsLmNvbnZlcnQoaXRlbVtmaWVsZF0sIGZpZWxkVHlwZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlkO1xuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gRGF0YVNldDtcblxuLyoqKi8gfSxcbi8qIDEwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIEEgcXVldWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogICAgICAgICAgICBBdmFpbGFibGUgb3B0aW9uczpcbiAgICogICAgICAgICAgICAtIGRlbGF5OiBudW1iZXIgICAgV2hlbiBwcm92aWRlZCwgdGhlIHF1ZXVlIHdpbGwgYmUgZmx1c2hlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRvbWF0aWNhbGx5IGFmdGVyIGFuIGluYWN0aXZpdHkgb2YgdGhpcyBkZWxheVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiBtaWxsaXNlY29uZHMuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgdmFsdWUgaXMgbnVsbC5cbiAgICogICAgICAgICAgICAtIG1heDogbnVtYmVyICAgICAgV2hlbiB0aGUgcXVldWUgZXhjZWVkcyB0aGUgZ2l2ZW4gbWF4aW11bSBudW1iZXJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgZW50cmllcywgdGhlIHF1ZXVlIGlzIGZsdXNoZWQgYXV0b21hdGljYWxseS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCB2YWx1ZSBvZiBtYXggaXMgSW5maW5pdHkuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gUXVldWUob3B0aW9ucykge1xuICAgIC8vIG9wdGlvbnNcbiAgICB0aGlzLmRlbGF5ID0gbnVsbDtcbiAgICB0aGlzLm1heCA9IEluZmluaXR5O1xuXG4gICAgLy8gcHJvcGVydGllc1xuICAgIHRoaXMuX3F1ZXVlID0gW107XG4gICAgdGhpcy5fdGltZW91dCA9IG51bGw7XG4gICAgdGhpcy5fZXh0ZW5kZWQgPSBudWxsO1xuXG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgY29uZmlndXJhdGlvbiBvZiB0aGUgcXVldWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogICAgICAgICAgICBBdmFpbGFibGUgb3B0aW9uczpcbiAgICogICAgICAgICAgICAtIGRlbGF5OiBudW1iZXIgICAgV2hlbiBwcm92aWRlZCwgdGhlIHF1ZXVlIHdpbGwgYmUgZmx1c2hlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRvbWF0aWNhbGx5IGFmdGVyIGFuIGluYWN0aXZpdHkgb2YgdGhpcyBkZWxheVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiBtaWxsaXNlY29uZHMuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgdmFsdWUgaXMgbnVsbC5cbiAgICogICAgICAgICAgICAtIG1heDogbnVtYmVyICAgICAgV2hlbiB0aGUgcXVldWUgZXhjZWVkcyB0aGUgZ2l2ZW4gbWF4aW11bSBudW1iZXJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgZW50cmllcywgdGhlIHF1ZXVlIGlzIGZsdXNoZWQgYXV0b21hdGljYWxseS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCB2YWx1ZSBvZiBtYXggaXMgSW5maW5pdHkuXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqL1xuICBRdWV1ZS5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMuZGVsYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLmRlbGF5ID0gb3B0aW9ucy5kZWxheTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5tYXggPSBvcHRpb25zLm1heDtcbiAgICB9XG5cbiAgICB0aGlzLl9mbHVzaElmTmVlZGVkKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4dGVuZCBhbiBvYmplY3Qgd2l0aCBxdWV1aW5nIGZ1bmN0aW9uYWxpdHkuXG4gICAqIFRoZSBvYmplY3Qgd2lsbCBiZSBleHRlbmRlZCB3aXRoIGEgZnVuY3Rpb24gZmx1c2gsIGFuZCB0aGUgbWV0aG9kcyBwcm92aWRlZFxuICAgKiBpbiBvcHRpb25zLnJlcGxhY2Ugd2lsbCBiZSByZXBsYWNlZCB3aXRoIHF1ZXVlZCBvbmVzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqICAgICAgICAgICAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gICAqICAgICAgICAgICAgLSByZXBsYWNlOiBBcnJheS48c3RyaW5nPlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBIGxpc3Qgd2l0aCBtZXRob2QgbmFtZXMgb2YgdGhlIG1ldGhvZHNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb24gdGhlIG9iamVjdCB0byBiZSByZXBsYWNlZCB3aXRoIHF1ZXVlZCBvbmVzLlxuICAgKiAgICAgICAgICAgIC0gZGVsYXk6IG51bWJlciAgICBXaGVuIHByb3ZpZGVkLCB0aGUgcXVldWUgd2lsbCBiZSBmbHVzaGVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9tYXRpY2FsbHkgYWZ0ZXIgYW4gaW5hY3Rpdml0eSBvZiB0aGlzIGRlbGF5XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIG1pbGxpc2Vjb25kcy5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCB2YWx1ZSBpcyBudWxsLlxuICAgKiAgICAgICAgICAgIC0gbWF4OiBudW1iZXIgICAgICBXaGVuIHRoZSBxdWV1ZSBleGNlZWRzIHRoZSBnaXZlbiBtYXhpbXVtIG51bWJlclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiBlbnRyaWVzLCB0aGUgcXVldWUgaXMgZmx1c2hlZCBhdXRvbWF0aWNhbGx5LlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IHZhbHVlIG9mIG1heCBpcyBJbmZpbml0eS5cbiAgICogQHJldHVybiB7UXVldWV9IFJldHVybnMgdGhlIGNyZWF0ZWQgcXVldWVcbiAgICovXG4gIFF1ZXVlLmV4dGVuZCA9IGZ1bmN0aW9uIChvYmplY3QsIG9wdGlvbnMpIHtcbiAgICB2YXIgcXVldWUgPSBuZXcgUXVldWUob3B0aW9ucyk7XG5cbiAgICBpZiAob2JqZWN0LmZsdXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGFyZ2V0IG9iamVjdCBhbHJlYWR5IGhhcyBhIHByb3BlcnR5IGZsdXNoJyk7XG4gICAgfVxuICAgIG9iamVjdC5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHF1ZXVlLmZsdXNoKCk7XG4gICAgfTtcblxuICAgIHZhciBtZXRob2RzID0gW3tcbiAgICAgIG5hbWU6ICdmbHVzaCcsXG4gICAgICBvcmlnaW5hbDogdW5kZWZpbmVkXG4gICAgfV07XG5cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlcGxhY2UpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5yZXBsYWNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuYW1lID0gb3B0aW9ucy5yZXBsYWNlW2ldO1xuICAgICAgICBtZXRob2RzLnB1c2goe1xuICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgb3JpZ2luYWw6IG9iamVjdFtuYW1lXVxuICAgICAgICB9KTtcbiAgICAgICAgcXVldWUucmVwbGFjZShvYmplY3QsIG5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHF1ZXVlLl9leHRlbmRlZCA9IHtcbiAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgbWV0aG9kczogbWV0aG9kc1xuICAgIH07XG5cbiAgICByZXR1cm4gcXVldWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlc3Ryb3kgdGhlIHF1ZXVlLiBUaGUgcXVldWUgd2lsbCBmaXJzdCBmbHVzaCBhbGwgcXVldWVkIGFjdGlvbnMsIGFuZCBpblxuICAgKiBjYXNlIGl0IGhhcyBleHRlbmRlZCBhbiBvYmplY3QsIHdpbGwgcmVzdG9yZSB0aGUgb3JpZ2luYWwgb2JqZWN0LlxuICAgKi9cbiAgUXVldWUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mbHVzaCgpO1xuXG4gICAgaWYgKHRoaXMuX2V4dGVuZGVkKSB7XG4gICAgICB2YXIgb2JqZWN0ID0gdGhpcy5fZXh0ZW5kZWQub2JqZWN0O1xuICAgICAgdmFyIG1ldGhvZHMgPSB0aGlzLl9leHRlbmRlZC5tZXRob2RzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBtZXRob2RzW2ldO1xuICAgICAgICBpZiAobWV0aG9kLm9yaWdpbmFsKSB7XG4gICAgICAgICAgb2JqZWN0W21ldGhvZC5uYW1lXSA9IG1ldGhvZC5vcmlnaW5hbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgb2JqZWN0W21ldGhvZC5uYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fZXh0ZW5kZWQgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVwbGFjZSBhIG1ldGhvZCBvbiBhbiBvYmplY3Qgd2l0aCBhIHF1ZXVlZCB2ZXJzaW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgICBPYmplY3QgaGF2aW5nIHRoZSBtZXRob2RcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZCAgIFRoZSBtZXRob2QgbmFtZVxuICAgKi9cbiAgUXVldWUucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiAob2JqZWN0LCBtZXRob2QpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciBvcmlnaW5hbCA9IG9iamVjdFttZXRob2RdO1xuICAgIGlmICghb3JpZ2luYWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kICcgKyBtZXRob2QgKyAnIHVuZGVmaW5lZCcpO1xuICAgIH1cblxuICAgIG9iamVjdFttZXRob2RdID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gY3JlYXRlIGFuIEFycmF5IHdpdGggdGhlIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICB9XG5cbiAgICAgIC8vIGFkZCB0aGlzIGNhbGwgdG8gdGhlIHF1ZXVlXG4gICAgICBtZS5xdWV1ZSh7XG4gICAgICAgIGFyZ3M6IGFyZ3MsXG4gICAgICAgIGZuOiBvcmlnaW5hbCxcbiAgICAgICAgY29udGV4dDogdGhpc1xuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogUXVldWUgYSBjYWxsXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24gfCB7Zm46IGZ1bmN0aW9uLCBhcmdzOiBBcnJheX0gfCB7Zm46IGZ1bmN0aW9uLCBhcmdzOiBBcnJheSwgY29udGV4dDogT2JqZWN0fX0gZW50cnlcbiAgICovXG4gIFF1ZXVlLnByb3RvdHlwZS5xdWV1ZSA9IGZ1bmN0aW9uIChlbnRyeSkge1xuICAgIGlmICh0eXBlb2YgZW50cnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuX3F1ZXVlLnB1c2goeyBmbjogZW50cnkgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3F1ZXVlLnB1c2goZW50cnkpO1xuICAgIH1cblxuICAgIHRoaXMuX2ZsdXNoSWZOZWVkZWQoKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciB0aGUgcXVldWUgbmVlZHMgdG8gYmUgZmx1c2hlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgUXVldWUucHJvdG90eXBlLl9mbHVzaElmTmVlZGVkID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIGZsdXNoIHdoZW4gdGhlIG1heGltdW0gaXMgZXhjZWVkZWQuXG4gICAgaWYgKHRoaXMuX3F1ZXVlLmxlbmd0aCA+IHRoaXMubWF4KSB7XG4gICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfVxuXG4gICAgLy8gZmx1c2ggYWZ0ZXIgYSBwZXJpb2Qgb2YgaW5hY3Rpdml0eSB3aGVuIGEgZGVsYXkgaXMgY29uZmlndXJlZFxuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcbiAgICBpZiAodGhpcy5xdWV1ZS5sZW5ndGggPiAwICYmIHR5cGVvZiB0aGlzLmRlbGF5ID09PSAnbnVtYmVyJykge1xuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWUuZmx1c2goKTtcbiAgICAgIH0sIHRoaXMuZGVsYXkpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRmx1c2ggYWxsIHF1ZXVlZCBjYWxsc1xuICAgKi9cbiAgUXVldWUucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHdoaWxlICh0aGlzLl9xdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgZW50cnkgPSB0aGlzLl9xdWV1ZS5zaGlmdCgpO1xuICAgICAgZW50cnkuZm4uYXBwbHkoZW50cnkuY29udGV4dCB8fCBlbnRyeS5mbiwgZW50cnkuYXJncyB8fCBbXSk7XG4gICAgfVxuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gUXVldWU7XG5cbi8qKiovIH0sXG4vKiAxMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbiAgdmFyIERhdGFTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG4gIC8qKlxuICAgKiBEYXRhVmlld1xuICAgKlxuICAgKiBhIGRhdGF2aWV3IG9mZmVycyBhIGZpbHRlcmVkIHZpZXcgb24gYSBkYXRhc2V0IG9yIGFuIG90aGVyIGRhdGF2aWV3LlxuICAgKlxuICAgKiBAcGFyYW0ge0RhdGFTZXQgfCBEYXRhVmlld30gZGF0YVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgQXZhaWxhYmxlIG9wdGlvbnM6IHNlZSBtZXRob2QgZ2V0XG4gICAqXG4gICAqIEBjb25zdHJ1Y3RvciBEYXRhVmlld1xuICAgKi9cbiAgZnVuY3Rpb24gRGF0YVZpZXcoZGF0YSwgb3B0aW9ucykge1xuICAgIHRoaXMuX2RhdGEgPSBudWxsO1xuICAgIHRoaXMuX2lkcyA9IHt9OyAvLyBpZHMgb2YgdGhlIGl0ZW1zIGN1cnJlbnRseSBpbiBtZW1vcnkgKGp1c3QgY29udGFpbnMgYSBib29sZWFuIHRydWUpXG4gICAgdGhpcy5sZW5ndGggPSAwOyAvLyBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIERhdGFWaWV3XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5fZmllbGRJZCA9ICdpZCc7IC8vIG5hbWUgb2YgdGhlIGZpZWxkIGNvbnRhaW5pbmcgaWRcbiAgICB0aGlzLl9zdWJzY3JpYmVycyA9IHt9OyAvLyBldmVudCBzdWJzY3JpYmVyc1xuXG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB0aGlzLmxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgbWUuX29uRXZlbnQuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIHRoaXMuc2V0RGF0YShkYXRhKTtcbiAgfVxuXG4gIC8vIFRPRE86IGltcGxlbWVudCBhIGZ1bmN0aW9uIC5jb25maWcoKSB0byBkeW5hbWljYWxseSB1cGRhdGUgdGhpbmdzIGxpa2UgY29uZmlndXJlZCBmaWx0ZXJcbiAgLy8gYW5kIHRyaWdnZXIgY2hhbmdlcyBhY2NvcmRpbmdseVxuXG4gIC8qKlxuICAgKiBTZXQgYSBkYXRhIHNvdXJjZSBmb3IgdGhlIHZpZXdcbiAgICogQHBhcmFtIHtEYXRhU2V0IHwgRGF0YVZpZXd9IGRhdGFcbiAgICovXG4gIERhdGFWaWV3LnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgaWRzLCBpZCwgaSwgbGVuO1xuXG4gICAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICAgIC8vIHVuc3Vic2NyaWJlIGZyb20gY3VycmVudCBkYXRhc2V0XG4gICAgICBpZiAodGhpcy5fZGF0YS5vZmYpIHtcbiAgICAgICAgdGhpcy5fZGF0YS5vZmYoJyonLCB0aGlzLmxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgLy8gdHJpZ2dlciBhIHJlbW92ZSBvZiBhbGwgaXRlbXMgaW4gbWVtb3J5XG4gICAgICBpZHMgPSBPYmplY3Qua2V5cyh0aGlzLl9pZHMpO1xuICAgICAgdGhpcy5faWRzID0ge307XG4gICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLl90cmlnZ2VyKCdyZW1vdmUnLCB7IGl0ZW1zOiBpZHMgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGF0YSA9IGRhdGE7XG5cbiAgICBpZiAodGhpcy5fZGF0YSkge1xuICAgICAgLy8gdXBkYXRlIGZpZWxkSWRcbiAgICAgIHRoaXMuX2ZpZWxkSWQgPSB0aGlzLl9vcHRpb25zLmZpZWxkSWQgfHwgdGhpcy5fZGF0YSAmJiB0aGlzLl9kYXRhLm9wdGlvbnMgJiYgdGhpcy5fZGF0YS5vcHRpb25zLmZpZWxkSWQgfHwgJ2lkJztcblxuICAgICAgLy8gdHJpZ2dlciBhbiBhZGQgb2YgYWxsIGFkZGVkIGl0ZW1zXG4gICAgICBpZHMgPSB0aGlzLl9kYXRhLmdldElkcyh7IGZpbHRlcjogdGhpcy5fb3B0aW9ucyAmJiB0aGlzLl9vcHRpb25zLmZpbHRlciB9KTtcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZCA9IGlkc1tpXTtcbiAgICAgICAgdGhpcy5faWRzW2lkXSA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLmxlbmd0aCA9IGlkcy5sZW5ndGg7XG4gICAgICB0aGlzLl90cmlnZ2VyKCdhZGQnLCB7IGl0ZW1zOiBpZHMgfSk7XG5cbiAgICAgIC8vIHN1YnNjcmliZSB0byBuZXcgZGF0YXNldFxuICAgICAgaWYgKHRoaXMuX2RhdGEub24pIHtcbiAgICAgICAgdGhpcy5fZGF0YS5vbignKicsIHRoaXMubGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVmcmVzaCB0aGUgRGF0YVZpZXcuIFVzZWZ1bCB3aGVuIHRoZSBEYXRhVmlldyBoYXMgYSBmaWx0ZXIgZnVuY3Rpb25cbiAgICogY29udGFpbmluZyBhIHZhcmlhYmxlIHBhcmFtZXRlci5cbiAgICovXG4gIERhdGFWaWV3LnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpZCwgaSwgbGVuO1xuICAgIHZhciBpZHMgPSB0aGlzLl9kYXRhLmdldElkcyh7IGZpbHRlcjogdGhpcy5fb3B0aW9ucyAmJiB0aGlzLl9vcHRpb25zLmZpbHRlciB9KTtcbiAgICB2YXIgb2xkSWRzID0gT2JqZWN0LmtleXModGhpcy5faWRzKTtcbiAgICB2YXIgbmV3SWRzID0ge307XG4gICAgdmFyIGFkZGVkID0gW107XG4gICAgdmFyIHJlbW92ZWQgPSBbXTtcblxuICAgIC8vIGNoZWNrIGZvciBhZGRpdGlvbnNcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBpZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlkID0gaWRzW2ldO1xuICAgICAgbmV3SWRzW2lkXSA9IHRydWU7XG4gICAgICBpZiAoIXRoaXMuX2lkc1tpZF0pIHtcbiAgICAgICAgYWRkZWQucHVzaChpZCk7XG4gICAgICAgIHRoaXMuX2lkc1tpZF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNoZWNrIGZvciByZW1vdmFsc1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IG9sZElkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWQgPSBvbGRJZHNbaV07XG4gICAgICBpZiAoIW5ld0lkc1tpZF0pIHtcbiAgICAgICAgcmVtb3ZlZC5wdXNoKGlkKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2lkc1tpZF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggKz0gYWRkZWQubGVuZ3RoIC0gcmVtb3ZlZC5sZW5ndGg7XG5cbiAgICAvLyB0cmlnZ2VyIGV2ZW50c1xuICAgIGlmIChhZGRlZC5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3RyaWdnZXIoJ2FkZCcsIHsgaXRlbXM6IGFkZGVkIH0pO1xuICAgIH1cbiAgICBpZiAocmVtb3ZlZC5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3RyaWdnZXIoJ3JlbW92ZScsIHsgaXRlbXM6IHJlbW92ZWQgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgZGF0YSBmcm9tIHRoZSBkYXRhIHZpZXdcbiAgICpcbiAgICogVXNhZ2U6XG4gICAqXG4gICAqICAgICBnZXQoKVxuICAgKiAgICAgZ2V0KG9wdGlvbnM6IE9iamVjdClcbiAgICogICAgIGdldChvcHRpb25zOiBPYmplY3QsIGRhdGE6IEFycmF5IHwgRGF0YVRhYmxlKVxuICAgKlxuICAgKiAgICAgZ2V0KGlkOiBOdW1iZXIpXG4gICAqICAgICBnZXQoaWQ6IE51bWJlciwgb3B0aW9uczogT2JqZWN0KVxuICAgKiAgICAgZ2V0KGlkOiBOdW1iZXIsIG9wdGlvbnM6IE9iamVjdCwgZGF0YTogQXJyYXkgfCBEYXRhVGFibGUpXG4gICAqXG4gICAqICAgICBnZXQoaWRzOiBOdW1iZXJbXSlcbiAgICogICAgIGdldChpZHM6IE51bWJlcltdLCBvcHRpb25zOiBPYmplY3QpXG4gICAqICAgICBnZXQoaWRzOiBOdW1iZXJbXSwgb3B0aW9uczogT2JqZWN0LCBkYXRhOiBBcnJheSB8IERhdGFUYWJsZSlcbiAgICpcbiAgICogV2hlcmU6XG4gICAqXG4gICAqIHtOdW1iZXIgfCBTdHJpbmd9IGlkICAgICAgICAgVGhlIGlkIG9mIGFuIGl0ZW1cbiAgICoge051bWJlcltdIHwgU3RyaW5ne319IGlkcyAgICBBbiBhcnJheSB3aXRoIGlkcyBvZiBpdGVtc1xuICAgKiB7T2JqZWN0fSBvcHRpb25zICAgICAgICAgICAgIEFuIE9iamVjdCB3aXRoIG9wdGlvbnMuIEF2YWlsYWJsZSBvcHRpb25zOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmd9IFt0eXBlXSBUeXBlIG9mIGRhdGEgdG8gYmUgcmV0dXJuZWQuIENhblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZSAnRGF0YVRhYmxlJyBvciAnQXJyYXknIChkZWZhdWx0KVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtPYmplY3QuPFN0cmluZywgU3RyaW5nPn0gW2NvbnZlcnRdXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZ1tdfSBbZmllbGRzXSBmaWVsZCBuYW1lcyB0byBiZSByZXR1cm5lZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtmdW5jdGlvbn0gW2ZpbHRlcl0gZmlsdGVyIGl0ZW1zXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZyB8IGZ1bmN0aW9ufSBbb3JkZXJdIE9yZGVyIHRoZSBpdGVtcyBieVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIGZpZWxkIG5hbWUgb3IgY3VzdG9tIHNvcnQgZnVuY3Rpb24uXG4gICAqIHtBcnJheSB8IERhdGFUYWJsZX0gW2RhdGFdICAgSWYgcHJvdmlkZWQsIGl0ZW1zIHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5IG9yIHRhYmxlLiBSZXF1aXJlZCBpbiBjYXNlIG9mIEdvb2dsZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERhdGFUYWJsZS5cbiAgICogQHBhcmFtIGFyZ3NcbiAgICovXG4gIERhdGFWaWV3LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHZhciBtZSA9IHRoaXM7XG5cbiAgICAvLyBwYXJzZSB0aGUgYXJndW1lbnRzXG4gICAgdmFyIGlkcywgb3B0aW9ucywgZGF0YTtcbiAgICB2YXIgZmlyc3RUeXBlID0gdXRpbC5nZXRUeXBlKGFyZ3VtZW50c1swXSk7XG4gICAgaWYgKGZpcnN0VHlwZSA9PSAnU3RyaW5nJyB8fCBmaXJzdFR5cGUgPT0gJ051bWJlcicgfHwgZmlyc3RUeXBlID09ICdBcnJheScpIHtcbiAgICAgIC8vIGdldChpZChzKSBbLCBvcHRpb25zXSBbLCBkYXRhXSlcbiAgICAgIGlkcyA9IGFyZ3VtZW50c1swXTsgLy8gY2FuIGJlIGEgc2luZ2xlIGlkIG9yIGFuIGFycmF5IHdpdGggaWRzXG4gICAgICBvcHRpb25zID0gYXJndW1lbnRzWzFdO1xuICAgICAgZGF0YSA9IGFyZ3VtZW50c1syXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZ2V0KFssIG9wdGlvbnNdIFssIGRhdGFdKVxuICAgICAgb3B0aW9ucyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGRhdGEgPSBhcmd1bWVudHNbMV07XG4gICAgfVxuXG4gICAgLy8gZXh0ZW5kIHRoZSBvcHRpb25zIHdpdGggdGhlIGRlZmF1bHQgb3B0aW9ucyBhbmQgcHJvdmlkZWQgb3B0aW9uc1xuICAgIHZhciB2aWV3T3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLl9vcHRpb25zLCBvcHRpb25zKTtcblxuICAgIC8vIGNyZWF0ZSBhIGNvbWJpbmVkIGZpbHRlciBtZXRob2Qgd2hlbiBuZWVkZWRcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5maWx0ZXIgJiYgb3B0aW9ucyAmJiBvcHRpb25zLmZpbHRlcikge1xuICAgICAgdmlld09wdGlvbnMuZmlsdGVyID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIG1lLl9vcHRpb25zLmZpbHRlcihpdGVtKSAmJiBvcHRpb25zLmZpbHRlcihpdGVtKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gYnVpbGQgdXAgdGhlIGNhbGwgdG8gdGhlIGxpbmtlZCBkYXRhIHNldFxuICAgIHZhciBnZXRBcmd1bWVudHMgPSBbXTtcbiAgICBpZiAoaWRzICE9IHVuZGVmaW5lZCkge1xuICAgICAgZ2V0QXJndW1lbnRzLnB1c2goaWRzKTtcbiAgICB9XG4gICAgZ2V0QXJndW1lbnRzLnB1c2godmlld09wdGlvbnMpO1xuICAgIGdldEFyZ3VtZW50cy5wdXNoKGRhdGEpO1xuXG4gICAgcmV0dXJuIHRoaXMuX2RhdGEgJiYgdGhpcy5fZGF0YS5nZXQuYXBwbHkodGhpcy5fZGF0YSwgZ2V0QXJndW1lbnRzKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGlkcyBvZiBhbGwgaXRlbXMgb3IgZnJvbSBhIGZpbHRlcmVkIHNldCBvZiBpdGVtcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICBBbiBPYmplY3Qgd2l0aCBvcHRpb25zLiBBdmFpbGFibGUgb3B0aW9uczpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ZnVuY3Rpb259IFtmaWx0ZXJdIGZpbHRlciBpdGVtc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmcgfCBmdW5jdGlvbn0gW29yZGVyXSBPcmRlciB0aGUgaXRlbXMgYnlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBmaWVsZCBuYW1lIG9yIGN1c3RvbSBzb3J0IGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtBcnJheX0gaWRzXG4gICAqL1xuICBEYXRhVmlldy5wcm90b3R5cGUuZ2V0SWRzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgaWRzO1xuXG4gICAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICAgIHZhciBkZWZhdWx0RmlsdGVyID0gdGhpcy5fb3B0aW9ucy5maWx0ZXI7XG4gICAgICB2YXIgZmlsdGVyO1xuXG4gICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmZpbHRlcikge1xuICAgICAgICBpZiAoZGVmYXVsdEZpbHRlcikge1xuICAgICAgICAgIGZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlcihpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdEZpbHRlcihpdGVtKSAmJiBvcHRpb25zLmZpbHRlcihpdGVtKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaWx0ZXIgPSBkZWZhdWx0RmlsdGVyO1xuICAgICAgfVxuXG4gICAgICBpZHMgPSB0aGlzLl9kYXRhLmdldElkcyh7XG4gICAgICAgIGZpbHRlcjogZmlsdGVyLFxuICAgICAgICBvcmRlcjogb3B0aW9ucyAmJiBvcHRpb25zLm9yZGVyXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWRzID0gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIGlkcztcbiAgfTtcblxuICAvKipcbiAgICogTWFwIGV2ZXJ5IGl0ZW0gaW4gdGhlIGRhdGFzZXQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge09iamVjdC48U3RyaW5nLCBTdHJpbmc+fSBbdHlwZV1cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nW119IFtmaWVsZHNdIGZpbHRlciBmaWVsZHNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ZnVuY3Rpb259IFtmaWx0ZXJdIGZpbHRlciBpdGVtc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmcgfCBmdW5jdGlvbn0gW29yZGVyXSBPcmRlciB0aGUgaXRlbXMgYnlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBmaWVsZCBuYW1lIG9yIGN1c3RvbSBzb3J0IGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtPYmplY3RbXX0gbWFwcGVkSXRlbXNcbiAgICovXG4gIERhdGFWaWV3LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICB2YXIgbWFwcGVkSXRlbXMgPSBbXTtcbiAgICBpZiAodGhpcy5fZGF0YSkge1xuICAgICAgdmFyIGRlZmF1bHRGaWx0ZXIgPSB0aGlzLl9vcHRpb25zLmZpbHRlcjtcbiAgICAgIHZhciBmaWx0ZXI7XG5cbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZmlsdGVyKSB7XG4gICAgICAgIGlmIChkZWZhdWx0RmlsdGVyKSB7XG4gICAgICAgICAgZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0RmlsdGVyKGl0ZW0pICYmIG9wdGlvbnMuZmlsdGVyKGl0ZW0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpbHRlciA9IGRlZmF1bHRGaWx0ZXI7XG4gICAgICB9XG5cbiAgICAgIG1hcHBlZEl0ZW1zID0gdGhpcy5fZGF0YS5tYXAoY2FsbGJhY2ssIHtcbiAgICAgICAgZmlsdGVyOiBmaWx0ZXIsXG4gICAgICAgIG9yZGVyOiBvcHRpb25zICYmIG9wdGlvbnMub3JkZXJcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXBwZWRJdGVtcyA9IFtdO1xuICAgIH1cblxuICAgIHJldHVybiBtYXBwZWRJdGVtcztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBEYXRhU2V0IHRvIHdoaWNoIHRoaXMgRGF0YVZpZXcgaXMgY29ubmVjdGVkLiBJbiBjYXNlIHRoZXJlIGlzIGEgY2hhaW5cbiAgICogb2YgbXVsdGlwbGUgRGF0YVZpZXdzLCB0aGUgcm9vdCBEYXRhU2V0IG9mIHRoaXMgY2hhaW4gaXMgcmV0dXJuZWQuXG4gICAqIEByZXR1cm4ge0RhdGFTZXR9IGRhdGFTZXRcbiAgICovXG4gIERhdGFWaWV3LnByb3RvdHlwZS5nZXREYXRhU2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhU2V0ID0gdGhpcztcbiAgICB3aGlsZSAoZGF0YVNldCBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG4gICAgICBkYXRhU2V0ID0gZGF0YVNldC5fZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGFTZXQgfHwgbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogRXZlbnQgbGlzdGVuZXIuIFdpbGwgcHJvcGFnYXRlIGFsbCBldmVudHMgZnJvbSB0aGUgY29ubmVjdGVkIGRhdGEgc2V0IHRvXG4gICAqIHRoZSBzdWJzY3JpYmVycyBvZiB0aGUgRGF0YVZpZXcsIGJ1dCB3aWxsIGZpbHRlciB0aGUgaXRlbXMgYW5kIG9ubHkgdHJpZ2dlclxuICAgKiB3aGVuIHRoZXJlIGFyZSBjaGFuZ2VzIGluIHRoZSBmaWx0ZXJlZCBkYXRhIHNldC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0IHwgbnVsbH0gcGFyYW1zXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzZW5kZXJJZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgRGF0YVZpZXcucHJvdG90eXBlLl9vbkV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50LCBwYXJhbXMsIHNlbmRlcklkKSB7XG4gICAgdmFyIGksIGxlbiwgaWQsIGl0ZW07XG4gICAgdmFyIGlkcyA9IHBhcmFtcyAmJiBwYXJhbXMuaXRlbXM7XG4gICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgIHZhciB1cGRhdGVkRGF0YSA9IFtdO1xuICAgIHZhciBhZGRlZCA9IFtdO1xuICAgIHZhciB1cGRhdGVkID0gW107XG4gICAgdmFyIHJlbW92ZWQgPSBbXTtcblxuICAgIGlmIChpZHMgJiYgZGF0YSkge1xuICAgICAgc3dpdGNoIChldmVudCkge1xuICAgICAgICBjYXNlICdhZGQnOlxuICAgICAgICAgIC8vIGZpbHRlciB0aGUgaWRzIG9mIHRoZSBhZGRlZCBpdGVtc1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWQgPSBpZHNbaV07XG4gICAgICAgICAgICBpdGVtID0gdGhpcy5nZXQoaWQpO1xuICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgdGhpcy5faWRzW2lkXSA9IHRydWU7XG4gICAgICAgICAgICAgIGFkZGVkLnB1c2goaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3VwZGF0ZSc6XG4gICAgICAgICAgLy8gZGV0ZXJtaW5lIHRoZSBldmVudCBmcm9tIHRoZSB2aWV3cyB2aWV3cG9pbnQ6IGFuIHVwZGF0ZWRcbiAgICAgICAgICAvLyBpdGVtIGNhbiBiZSBhZGRlZCwgdXBkYXRlZCwgb3IgcmVtb3ZlZCBmcm9tIHRoaXMgdmlldy5cbiAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlkID0gaWRzW2ldO1xuICAgICAgICAgICAgaXRlbSA9IHRoaXMuZ2V0KGlkKTtcblxuICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2lkc1tpZF0pIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVkLnB1c2goaWQpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZWREYXRhLnB1c2gocGFyYW1zLmRhdGFbaV0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2lkc1tpZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGFkZGVkLnB1c2goaWQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAodGhpcy5faWRzW2lkXSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9pZHNbaWRdO1xuICAgICAgICAgICAgICAgIHJlbW92ZWQucHVzaChpZCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbm90aGluZyBpbnRlcmVzdGluZyBmb3IgbWUgOi0oXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdyZW1vdmUnOlxuICAgICAgICAgIC8vIGZpbHRlciB0aGUgaWRzIG9mIHRoZSByZW1vdmVkIGl0ZW1zXG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gaWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZCA9IGlkc1tpXTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pZHNbaWRdKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9pZHNbaWRdO1xuICAgICAgICAgICAgICByZW1vdmVkLnB1c2goaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxlbmd0aCArPSBhZGRlZC5sZW5ndGggLSByZW1vdmVkLmxlbmd0aDtcblxuICAgICAgaWYgKGFkZGVkLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl90cmlnZ2VyKCdhZGQnLCB7IGl0ZW1zOiBhZGRlZCB9LCBzZW5kZXJJZCk7XG4gICAgICB9XG4gICAgICBpZiAodXBkYXRlZC5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fdHJpZ2dlcigndXBkYXRlJywgeyBpdGVtczogdXBkYXRlZCwgZGF0YTogdXBkYXRlZERhdGEgfSwgc2VuZGVySWQpO1xuICAgICAgfVxuICAgICAgaWYgKHJlbW92ZWQubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX3RyaWdnZXIoJ3JlbW92ZScsIHsgaXRlbXM6IHJlbW92ZWQgfSwgc2VuZGVySWQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBjb3B5IHN1YnNjcmlwdGlvbiBmdW5jdGlvbmFsaXR5IGZyb20gRGF0YVNldFxuICBEYXRhVmlldy5wcm90b3R5cGUub24gPSBEYXRhU2V0LnByb3RvdHlwZS5vbjtcbiAgRGF0YVZpZXcucHJvdG90eXBlLm9mZiA9IERhdGFTZXQucHJvdG90eXBlLm9mZjtcbiAgRGF0YVZpZXcucHJvdG90eXBlLl90cmlnZ2VyID0gRGF0YVNldC5wcm90b3R5cGUuX3RyaWdnZXI7XG5cbiAgLy8gVE9ETzogbWFrZSB0aGVzZSBmdW5jdGlvbnMgZGVwcmVjYXRlZCAocmVwbGFjZWQgd2l0aCBgb25gIGFuZCBgb2ZmYCBzaW5jZSB2ZXJzaW9uIDAuNSlcbiAgRGF0YVZpZXcucHJvdG90eXBlLnN1YnNjcmliZSA9IERhdGFWaWV3LnByb3RvdHlwZS5vbjtcbiAgRGF0YVZpZXcucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gRGF0YVZpZXcucHJvdG90eXBlLm9mZjtcblxuICBtb2R1bGUuZXhwb3J0cyA9IERhdGFWaWV3O1xuXG4vKioqLyB9LFxuLyogMTIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuICB2YXIgRW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuICB2YXIgRGF0YVNldCA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG4gIHZhciBEYXRhVmlldyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4gIHZhciBQb2ludDNkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG4gIHZhciBQb2ludDJkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG4gIHZhciBDYW1lcmEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcbiAgdmFyIEZpbHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xuICB2YXIgU2xpZGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG4gIHZhciBTdGVwTnVtYmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvciBHcmFwaDNkXG4gICAqIEdyYXBoM2QgZGlzcGxheXMgZGF0YSBpbiAzZC5cbiAgICpcbiAgICogR3JhcGgzZCBpcyBkZXZlbG9wZWQgaW4gamF2YXNjcmlwdCBhcyBhIEdvb2dsZSBWaXN1YWxpemF0aW9uIENoYXJ0LlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRhaW5lciAgIFRoZSBET00gZWxlbWVudCBpbiB3aGljaCB0aGUgR3JhcGgzZCB3aWxsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmUgY3JlYXRlZC4gTm9ybWFsbHkgYSBkaXYgZWxlbWVudC5cbiAgICogQHBhcmFtIHtEYXRhU2V0IHwgRGF0YVZpZXcgfCBBcnJheX0gW2RhdGFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICovXG4gIGZ1bmN0aW9uIEdyYXBoM2QoY29udGFpbmVyLCBkYXRhLCBvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEdyYXBoM2QpKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0NvbnN0cnVjdG9yIG11c3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBvcGVyYXRvcicpO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSB2YXJpYWJsZXMgYW5kIHNldCBkZWZhdWx0IHZhbHVlc1xuICAgIHRoaXMuY29udGFpbmVyRWxlbWVudCA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLndpZHRoID0gJzQwMHB4JztcbiAgICB0aGlzLmhlaWdodCA9ICc0MDBweCc7XG4gICAgdGhpcy5tYXJnaW4gPSAxMDsgLy8gcHhcbiAgICB0aGlzLmRlZmF1bHRYQ2VudGVyID0gJzU1JSc7XG4gICAgdGhpcy5kZWZhdWx0WUNlbnRlciA9ICc1MCUnO1xuXG4gICAgdGhpcy54TGFiZWwgPSAneCc7XG4gICAgdGhpcy55TGFiZWwgPSAneSc7XG4gICAgdGhpcy56TGFiZWwgPSAneic7XG5cbiAgICB2YXIgcGFzc1ZhbHVlRm4gPSBmdW5jdGlvbiBwYXNzVmFsdWVGbih2KSB7XG4gICAgICByZXR1cm4gdjtcbiAgICB9O1xuICAgIHRoaXMueFZhbHVlTGFiZWwgPSBwYXNzVmFsdWVGbjtcbiAgICB0aGlzLnlWYWx1ZUxhYmVsID0gcGFzc1ZhbHVlRm47XG4gICAgdGhpcy56VmFsdWVMYWJlbCA9IHBhc3NWYWx1ZUZuO1xuXG4gICAgdGhpcy5maWx0ZXJMYWJlbCA9ICd0aW1lJztcbiAgICB0aGlzLmxlZ2VuZExhYmVsID0gJ3ZhbHVlJztcblxuICAgIHRoaXMuc3R5bGUgPSBHcmFwaDNkLlNUWUxFLkRPVDtcbiAgICB0aGlzLnNob3dQZXJzcGVjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5zaG93R3JpZCA9IHRydWU7XG4gICAgdGhpcy5rZWVwQXNwZWN0UmF0aW8gPSB0cnVlO1xuICAgIHRoaXMuc2hvd1NoYWRvdyA9IGZhbHNlO1xuICAgIHRoaXMuc2hvd0dyYXlCb3R0b20gPSBmYWxzZTsgLy8gVE9ETzogdGhpcyBkb2VzIG5vdCB3b3JrIGNvcnJlY3RseVxuICAgIHRoaXMuc2hvd1Rvb2x0aXAgPSBmYWxzZTtcbiAgICB0aGlzLnZlcnRpY2FsUmF0aW8gPSAwLjU7IC8vIDAuMSB0byAxLjAsIHdoZXJlIDEuMCByZXN1bHRzIGluIGEgJ2N1YmUnXG5cbiAgICB0aGlzLmFuaW1hdGlvbkludGVydmFsID0gMTAwMDsgLy8gbWlsbGlzZWNvbmRzXG4gICAgdGhpcy5hbmltYXRpb25QcmVsb2FkID0gZmFsc2U7XG5cbiAgICB0aGlzLmNhbWVyYSA9IG5ldyBDYW1lcmEoKTtcbiAgICB0aGlzLmNhbWVyYS5zZXRBcm1Sb3RhdGlvbigxLjAsIDAuNSk7XG4gICAgdGhpcy5jYW1lcmEuc2V0QXJtTGVuZ3RoKDEuNyk7XG4gICAgdGhpcy5leWUgPSBuZXcgUG9pbnQzZCgwLCAwLCAtMSk7IC8vIFRPRE86IHNldCBleWUueiBhYm91dCAzLzQgb2YgdGhlIHdpZHRoIG9mIHRoZSB3aW5kb3c/XG5cbiAgICB0aGlzLmRhdGFUYWJsZSA9IG51bGw7IC8vIFRoZSBvcmlnaW5hbCBkYXRhIHRhYmxlXG4gICAgdGhpcy5kYXRhUG9pbnRzID0gbnVsbDsgLy8gVGhlIHRhYmxlIHdpdGggcG9pbnQgb2JqZWN0c1xuXG4gICAgLy8gdGhlIGNvbHVtbiBpbmRleGVzXG4gICAgdGhpcy5jb2xYID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY29sWSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNvbFogPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jb2xWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNvbEZpbHRlciA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMueE1pbiA9IDA7XG4gICAgdGhpcy54U3RlcCA9IHVuZGVmaW5lZDsgLy8gYXV0byBieSBkZWZhdWx0XG4gICAgdGhpcy54TWF4ID0gMTtcbiAgICB0aGlzLnlNaW4gPSAwO1xuICAgIHRoaXMueVN0ZXAgPSB1bmRlZmluZWQ7IC8vIGF1dG8gYnkgZGVmYXVsdFxuICAgIHRoaXMueU1heCA9IDE7XG4gICAgdGhpcy56TWluID0gMDtcbiAgICB0aGlzLnpTdGVwID0gdW5kZWZpbmVkOyAvLyBhdXRvIGJ5IGRlZmF1bHRcbiAgICB0aGlzLnpNYXggPSAxO1xuICAgIHRoaXMudmFsdWVNaW4gPSAwO1xuICAgIHRoaXMudmFsdWVNYXggPSAxO1xuICAgIHRoaXMueEJhcldpZHRoID0gMTtcbiAgICB0aGlzLnlCYXJXaWR0aCA9IDE7XG4gICAgLy8gVE9ETzogY3VzdG9taXplIGF4aXMgcmFuZ2VcblxuICAgIC8vIGNvbG9yc1xuICAgIHRoaXMuYXhpc0NvbG9yID0gJyM0RDRENEQnO1xuICAgIHRoaXMuZ3JpZENvbG9yID0gJyNEM0QzRDMnO1xuICAgIHRoaXMuZGF0YUNvbG9yID0ge1xuICAgICAgZmlsbDogJyM3REMxRkYnLFxuICAgICAgc3Ryb2tlOiAnIzMyNjdEMicsXG4gICAgICBzdHJva2VXaWR0aDogMSAvLyBweFxuICAgIH07XG5cbiAgICB0aGlzLmRvdFNpemVSYXRpbyA9IDAuMDI7IC8vIHNpemUgb2YgdGhlIGRvdHMgYXMgYSBmcmFjdGlvbiBvZiB0aGUgZ3JhcGggd2lkdGhcblxuICAgIC8vIGNyZWF0ZSBhIGZyYW1lIGFuZCBjYW52YXNcbiAgICB0aGlzLmNyZWF0ZSgpO1xuXG4gICAgLy8gYXBwbHkgb3B0aW9ucyAoYWxzbyB3aGVuIHVuZGVmaW5lZClcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICAvLyBhcHBseSBkYXRhXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIHRoaXMuc2V0RGF0YShkYXRhKTtcbiAgICB9XG4gIH1cblxuICAvLyBFeHRlbmQgR3JhcGgzZCB3aXRoIGFuIEVtaXR0ZXIgbWl4aW5cbiAgRW1pdHRlcihHcmFwaDNkLnByb3RvdHlwZSk7XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgc2NhbGluZyB2YWx1ZXMsIGRlcGVuZGVudCBvbiB0aGUgcmFuZ2UgaW4geCwgeSwgYW5kIHogZGlyZWN0aW9uXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5fc2V0U2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zY2FsZSA9IG5ldyBQb2ludDNkKDEgLyAodGhpcy54TWF4IC0gdGhpcy54TWluKSwgMSAvICh0aGlzLnlNYXggLSB0aGlzLnlNaW4pLCAxIC8gKHRoaXMuek1heCAtIHRoaXMuek1pbikpO1xuXG4gICAgLy8ga2VlcCBhc3BlY3QgcmF0aW9uIGJldHdlZW4geCBhbmQgeSBzY2FsZSBpZiBkZXNpcmVkXG4gICAgaWYgKHRoaXMua2VlcEFzcGVjdFJhdGlvKSB7XG4gICAgICBpZiAodGhpcy5zY2FsZS54IDwgdGhpcy5zY2FsZS55KSB7XG4gICAgICAgIC8vbm9pbnNwZWN0aW9uIEpTU3VzcGljaW91c05hbWVDb21iaW5hdGlvblxuICAgICAgICB0aGlzLnNjYWxlLnkgPSB0aGlzLnNjYWxlLng7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvL25vaW5zcGVjdGlvbiBKU1N1c3BpY2lvdXNOYW1lQ29tYmluYXRpb25cbiAgICAgICAgdGhpcy5zY2FsZS54ID0gdGhpcy5zY2FsZS55O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNjYWxlIHRoZSB2ZXJ0aWNhbCBheGlzXG4gICAgdGhpcy5zY2FsZS56ICo9IHRoaXMudmVydGljYWxSYXRpbztcbiAgICAvLyBUT0RPOiBjYW4gdGhpcyBiZSBhdXRvbWF0ZWQ/IHZlcnRpY2FsUmF0aW8/XG5cbiAgICAvLyBkZXRlcm1pbmUgc2NhbGUgZm9yIChvcHRpb25hbCkgdmFsdWVcbiAgICB0aGlzLnNjYWxlLnZhbHVlID0gMSAvICh0aGlzLnZhbHVlTWF4IC0gdGhpcy52YWx1ZU1pbik7XG5cbiAgICAvLyBwb3NpdGlvbiB0aGUgY2FtZXJhIGFybVxuICAgIHZhciB4Q2VudGVyID0gKHRoaXMueE1heCArIHRoaXMueE1pbikgLyAyICogdGhpcy5zY2FsZS54O1xuICAgIHZhciB5Q2VudGVyID0gKHRoaXMueU1heCArIHRoaXMueU1pbikgLyAyICogdGhpcy5zY2FsZS55O1xuICAgIHZhciB6Q2VudGVyID0gKHRoaXMuek1heCArIHRoaXMuek1pbikgLyAyICogdGhpcy5zY2FsZS56O1xuICAgIHRoaXMuY2FtZXJhLnNldEFybUxvY2F0aW9uKHhDZW50ZXIsIHlDZW50ZXIsIHpDZW50ZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgM0QgbG9jYXRpb24gdG8gYSAyRCBsb2NhdGlvbiBvbiBzY3JlZW5cbiAgICogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS8zRF9wcm9qZWN0aW9uXG4gICAqIEBwYXJhbSB7UG9pbnQzZH0gcG9pbnQzZCAgIEEgM0QgcG9pbnQgd2l0aCBwYXJhbWV0ZXJzIHgsIHksIHpcbiAgICogQHJldHVybiB7UG9pbnQyZH0gcG9pbnQyZCAgQSAyRCBwb2ludCB3aXRoIHBhcmFtZXRlcnMgeCwgeVxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX2NvbnZlcnQzRHRvMkQgPSBmdW5jdGlvbiAocG9pbnQzZCkge1xuICAgIHZhciB0cmFuc2xhdGlvbiA9IHRoaXMuX2NvbnZlcnRQb2ludFRvVHJhbnNsYXRpb24ocG9pbnQzZCk7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnZlcnRUcmFuc2xhdGlvblRvU2NyZWVuKHRyYW5zbGF0aW9uKTtcbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydCBhIDNEIGxvY2F0aW9uIGl0cyB0cmFuc2xhdGlvbiBzZWVuIGZyb20gdGhlIGNhbWVyYVxuICAgKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpLzNEX3Byb2plY3Rpb25cbiAgICogQHBhcmFtIHtQb2ludDNkfSBwb2ludDNkICAgIEEgM0QgcG9pbnQgd2l0aCBwYXJhbWV0ZXJzIHgsIHksIHpcbiAgICogQHJldHVybiB7UG9pbnQzZH0gdHJhbnNsYXRpb24gQSAzRCBwb2ludCB3aXRoIHBhcmFtZXRlcnMgeCwgeSwgeiBUaGlzIGlzXG4gICAqICAgICAgICAgICAgICAgICAgIHRoZSB0cmFuc2xhdGlvbiBvZiB0aGUgcG9pbnQsIHNlZW4gZnJvbSB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgY2FtZXJhXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5fY29udmVydFBvaW50VG9UcmFuc2xhdGlvbiA9IGZ1bmN0aW9uIChwb2ludDNkKSB7XG4gICAgdmFyIGF4ID0gcG9pbnQzZC54ICogdGhpcy5zY2FsZS54LFxuICAgICAgICBheSA9IHBvaW50M2QueSAqIHRoaXMuc2NhbGUueSxcbiAgICAgICAgYXogPSBwb2ludDNkLnogKiB0aGlzLnNjYWxlLnosXG4gICAgICAgIGN4ID0gdGhpcy5jYW1lcmEuZ2V0Q2FtZXJhTG9jYXRpb24oKS54LFxuICAgICAgICBjeSA9IHRoaXMuY2FtZXJhLmdldENhbWVyYUxvY2F0aW9uKCkueSxcbiAgICAgICAgY3ogPSB0aGlzLmNhbWVyYS5nZXRDYW1lcmFMb2NhdGlvbigpLnosXG5cblxuICAgIC8vIGNhbGN1bGF0ZSBhbmdsZXNcbiAgICBzaW5UeCA9IE1hdGguc2luKHRoaXMuY2FtZXJhLmdldENhbWVyYVJvdGF0aW9uKCkueCksXG4gICAgICAgIGNvc1R4ID0gTWF0aC5jb3ModGhpcy5jYW1lcmEuZ2V0Q2FtZXJhUm90YXRpb24oKS54KSxcbiAgICAgICAgc2luVHkgPSBNYXRoLnNpbih0aGlzLmNhbWVyYS5nZXRDYW1lcmFSb3RhdGlvbigpLnkpLFxuICAgICAgICBjb3NUeSA9IE1hdGguY29zKHRoaXMuY2FtZXJhLmdldENhbWVyYVJvdGF0aW9uKCkueSksXG4gICAgICAgIHNpblR6ID0gTWF0aC5zaW4odGhpcy5jYW1lcmEuZ2V0Q2FtZXJhUm90YXRpb24oKS56KSxcbiAgICAgICAgY29zVHogPSBNYXRoLmNvcyh0aGlzLmNhbWVyYS5nZXRDYW1lcmFSb3RhdGlvbigpLnopLFxuXG5cbiAgICAvLyBjYWxjdWxhdGUgdHJhbnNsYXRpb25cbiAgICBkeCA9IGNvc1R5ICogKHNpblR6ICogKGF5IC0gY3kpICsgY29zVHogKiAoYXggLSBjeCkpIC0gc2luVHkgKiAoYXogLSBjeiksXG4gICAgICAgIGR5ID0gc2luVHggKiAoY29zVHkgKiAoYXogLSBjeikgKyBzaW5UeSAqIChzaW5UeiAqIChheSAtIGN5KSArIGNvc1R6ICogKGF4IC0gY3gpKSkgKyBjb3NUeCAqIChjb3NUeiAqIChheSAtIGN5KSAtIHNpblR6ICogKGF4IC0gY3gpKSxcbiAgICAgICAgZHogPSBjb3NUeCAqIChjb3NUeSAqIChheiAtIGN6KSArIHNpblR5ICogKHNpblR6ICogKGF5IC0gY3kpICsgY29zVHogKiAoYXggLSBjeCkpKSAtIHNpblR4ICogKGNvc1R6ICogKGF5IC0gY3kpIC0gc2luVHogKiAoYXggLSBjeCkpO1xuXG4gICAgcmV0dXJuIG5ldyBQb2ludDNkKGR4LCBkeSwgZHopO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgdHJhbnNsYXRpb24gcG9pbnQgdG8gYSBwb2ludCBvbiB0aGUgc2NyZWVuXG4gICAqIEBwYXJhbSB7UG9pbnQzZH0gdHJhbnNsYXRpb24gICBBIDNEIHBvaW50IHdpdGggcGFyYW1ldGVycyB4LCB5LCB6IFRoaXMgaXNcbiAgICogICAgICAgICAgICAgICAgICAgIHRoZSB0cmFuc2xhdGlvbiBvZiB0aGUgcG9pbnQsIHNlZW4gZnJvbSB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgIGNhbWVyYVxuICAgKiBAcmV0dXJuIHtQb2ludDJkfSBwb2ludDJkICAgIEEgMkQgcG9pbnQgd2l0aCBwYXJhbWV0ZXJzIHgsIHlcbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLl9jb252ZXJ0VHJhbnNsYXRpb25Ub1NjcmVlbiA9IGZ1bmN0aW9uICh0cmFuc2xhdGlvbikge1xuICAgIHZhciBleCA9IHRoaXMuZXllLngsXG4gICAgICAgIGV5ID0gdGhpcy5leWUueSxcbiAgICAgICAgZXogPSB0aGlzLmV5ZS56LFxuICAgICAgICBkeCA9IHRyYW5zbGF0aW9uLngsXG4gICAgICAgIGR5ID0gdHJhbnNsYXRpb24ueSxcbiAgICAgICAgZHogPSB0cmFuc2xhdGlvbi56O1xuXG4gICAgLy8gY2FsY3VsYXRlIHBvc2l0aW9uIG9uIHNjcmVlbiBmcm9tIHRyYW5zbGF0aW9uXG4gICAgdmFyIGJ4O1xuICAgIHZhciBieTtcbiAgICBpZiAodGhpcy5zaG93UGVyc3BlY3RpdmUpIHtcbiAgICAgIGJ4ID0gKGR4IC0gZXgpICogKGV6IC8gZHopO1xuICAgICAgYnkgPSAoZHkgLSBleSkgKiAoZXogLyBkeik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ4ID0gZHggKiAtKGV6IC8gdGhpcy5jYW1lcmEuZ2V0QXJtTGVuZ3RoKCkpO1xuICAgICAgYnkgPSBkeSAqIC0oZXogLyB0aGlzLmNhbWVyYS5nZXRBcm1MZW5ndGgoKSk7XG4gICAgfVxuXG4gICAgLy8gc2hpZnQgYW5kIHNjYWxlIHRoZSBwb2ludCB0byB0aGUgY2VudGVyIG9mIHRoZSBzY3JlZW5cbiAgICAvLyB1c2UgdGhlIHdpZHRoIG9mIHRoZSBncmFwaCB0byBzY2FsZSBib3RoIGhvcml6b250YWxseSBhbmQgdmVydGljYWxseS5cbiAgICByZXR1cm4gbmV3IFBvaW50MmQodGhpcy54Y2VudGVyICsgYnggKiB0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCwgdGhpcy55Y2VudGVyIC0gYnkgKiB0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgYmFja2dyb3VuZCBzdHlsaW5nIGZvciB0aGUgZ3JhcGhcbiAgICogQHBhcmFtIHtzdHJpbmcgfCB7ZmlsbDogc3RyaW5nLCBzdHJva2U6IHN0cmluZywgc3Ryb2tlV2lkdGg6IHN0cmluZ319IGJhY2tncm91bmRDb2xvclxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX3NldEJhY2tncm91bmRDb2xvciA9IGZ1bmN0aW9uIChiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICB2YXIgZmlsbCA9ICd3aGl0ZSc7XG4gICAgdmFyIHN0cm9rZSA9ICdncmF5JztcbiAgICB2YXIgc3Ryb2tlV2lkdGggPSAxO1xuXG4gICAgaWYgKHR5cGVvZiBiYWNrZ3JvdW5kQ29sb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICBmaWxsID0gYmFja2dyb3VuZENvbG9yO1xuICAgICAgc3Ryb2tlID0gJ25vbmUnO1xuICAgICAgc3Ryb2tlV2lkdGggPSAwO1xuICAgIH0gZWxzZSBpZiAoKHR5cGVvZiBiYWNrZ3JvdW5kQ29sb3IgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGJhY2tncm91bmRDb2xvcikpID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKGJhY2tncm91bmRDb2xvci5maWxsICE9PSB1bmRlZmluZWQpIGZpbGwgPSBiYWNrZ3JvdW5kQ29sb3IuZmlsbDtcbiAgICAgIGlmIChiYWNrZ3JvdW5kQ29sb3Iuc3Ryb2tlICE9PSB1bmRlZmluZWQpIHN0cm9rZSA9IGJhY2tncm91bmRDb2xvci5zdHJva2U7XG4gICAgICBpZiAoYmFja2dyb3VuZENvbG9yLnN0cm9rZVdpZHRoICE9PSB1bmRlZmluZWQpIHN0cm9rZVdpZHRoID0gYmFja2dyb3VuZENvbG9yLnN0cm9rZVdpZHRoO1xuICAgIH0gZWxzZSBpZiAoYmFja2dyb3VuZENvbG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHVzZSB1c2UgZGVmYXVsdHNcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyAnVW5zdXBwb3J0ZWQgdHlwZSBvZiBiYWNrZ3JvdW5kQ29sb3InO1xuICAgICAgfVxuXG4gICAgdGhpcy5mcmFtZS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBmaWxsO1xuICAgIHRoaXMuZnJhbWUuc3R5bGUuYm9yZGVyQ29sb3IgPSBzdHJva2U7XG4gICAgdGhpcy5mcmFtZS5zdHlsZS5ib3JkZXJXaWR0aCA9IHN0cm9rZVdpZHRoICsgJ3B4JztcbiAgICB0aGlzLmZyYW1lLnN0eWxlLmJvcmRlclN0eWxlID0gJ3NvbGlkJztcbiAgfTtcblxuICAvLy8gZW51bWVyYXRlIHRoZSBhdmFpbGFibGUgc3R5bGVzXG4gIEdyYXBoM2QuU1RZTEUgPSB7XG4gICAgQkFSOiAwLFxuICAgIEJBUkNPTE9SOiAxLFxuICAgIEJBUlNJWkU6IDIsXG4gICAgRE9UOiAzLFxuICAgIERPVExJTkU6IDQsXG4gICAgRE9UQ09MT1I6IDUsXG4gICAgRE9UU0laRTogNixcbiAgICBHUklEOiA3LFxuICAgIExJTkU6IDgsXG4gICAgU1VSRkFDRTogOVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgc3R5bGUgaW5kZXggZnJvbSBnaXZlbiBzdHlsZU5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0eWxlTmFtZSAgU3R5bGUgbmFtZSBzdWNoIGFzICdkb3QnLCAnZ3JpZCcsICdkb3QtbGluZSdcbiAgICogQHJldHVybiB7TnVtYmVyfSBzdHlsZU51bWJlciBFbnVtZXJhdGlvbiB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIHN0eWxlLCBvciAtMVxuICAgKiAgICAgICAgICAgICAgICB3aGVuIG5vdCBmb3VuZFxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX2dldFN0eWxlTnVtYmVyID0gZnVuY3Rpb24gKHN0eWxlTmFtZSkge1xuICAgIHN3aXRjaCAoc3R5bGVOYW1lKSB7XG4gICAgICBjYXNlICdkb3QnOlxuICAgICAgICByZXR1cm4gR3JhcGgzZC5TVFlMRS5ET1Q7XG4gICAgICBjYXNlICdkb3QtbGluZSc6XG4gICAgICAgIHJldHVybiBHcmFwaDNkLlNUWUxFLkRPVExJTkU7XG4gICAgICBjYXNlICdkb3QtY29sb3InOlxuICAgICAgICByZXR1cm4gR3JhcGgzZC5TVFlMRS5ET1RDT0xPUjtcbiAgICAgIGNhc2UgJ2RvdC1zaXplJzpcbiAgICAgICAgcmV0dXJuIEdyYXBoM2QuU1RZTEUuRE9UU0laRTtcbiAgICAgIGNhc2UgJ2xpbmUnOlxuICAgICAgICByZXR1cm4gR3JhcGgzZC5TVFlMRS5MSU5FO1xuICAgICAgY2FzZSAnZ3JpZCc6XG4gICAgICAgIHJldHVybiBHcmFwaDNkLlNUWUxFLkdSSUQ7XG4gICAgICBjYXNlICdzdXJmYWNlJzpcbiAgICAgICAgcmV0dXJuIEdyYXBoM2QuU1RZTEUuU1VSRkFDRTtcbiAgICAgIGNhc2UgJ2Jhcic6XG4gICAgICAgIHJldHVybiBHcmFwaDNkLlNUWUxFLkJBUjtcbiAgICAgIGNhc2UgJ2Jhci1jb2xvcic6XG4gICAgICAgIHJldHVybiBHcmFwaDNkLlNUWUxFLkJBUkNPTE9SO1xuICAgICAgY2FzZSAnYmFyLXNpemUnOlxuICAgICAgICByZXR1cm4gR3JhcGgzZC5TVFlMRS5CQVJTSVpFO1xuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHRoZSBpbmRleGVzIG9mIHRoZSBkYXRhIGNvbHVtbnMsIGJhc2VkIG9uIHRoZSBnaXZlbiBzdHlsZSBhbmQgZGF0YVxuICAgKiBAcGFyYW0ge0RhdGFTZXR9IGRhdGFcbiAgICogQHBhcmFtIHtOdW1iZXJ9ICBzdHlsZVxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX2RldGVybWluZUNvbHVtbkluZGV4ZXMgPSBmdW5jdGlvbiAoZGF0YSwgc3R5bGUpIHtcbiAgICBpZiAodGhpcy5zdHlsZSA9PT0gR3JhcGgzZC5TVFlMRS5ET1QgfHwgdGhpcy5zdHlsZSA9PT0gR3JhcGgzZC5TVFlMRS5ET1RMSU5FIHx8IHRoaXMuc3R5bGUgPT09IEdyYXBoM2QuU1RZTEUuTElORSB8fCB0aGlzLnN0eWxlID09PSBHcmFwaDNkLlNUWUxFLkdSSUQgfHwgdGhpcy5zdHlsZSA9PT0gR3JhcGgzZC5TVFlMRS5TVVJGQUNFIHx8IHRoaXMuc3R5bGUgPT09IEdyYXBoM2QuU1RZTEUuQkFSKSB7XG4gICAgICAvLyAzIGNvbHVtbnMgZXhwZWN0ZWQsIGFuZCBvcHRpb25hbGx5IGEgNHRoIHdpdGggZmlsdGVyIHZhbHVlc1xuICAgICAgdGhpcy5jb2xYID0gMDtcbiAgICAgIHRoaXMuY29sWSA9IDE7XG4gICAgICB0aGlzLmNvbFogPSAyO1xuICAgICAgdGhpcy5jb2xWYWx1ZSA9IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGRhdGEuZ2V0TnVtYmVyT2ZDb2x1bW5zKCkgPiAzKSB7XG4gICAgICAgIHRoaXMuY29sRmlsdGVyID0gMztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuc3R5bGUgPT09IEdyYXBoM2QuU1RZTEUuRE9UQ09MT1IgfHwgdGhpcy5zdHlsZSA9PT0gR3JhcGgzZC5TVFlMRS5ET1RTSVpFIHx8IHRoaXMuc3R5bGUgPT09IEdyYXBoM2QuU1RZTEUuQkFSQ09MT1IgfHwgdGhpcy5zdHlsZSA9PT0gR3JhcGgzZC5TVFlMRS5CQVJTSVpFKSB7XG4gICAgICAvLyA0IGNvbHVtbnMgZXhwZWN0ZWQsIGFuZCBvcHRpb25hbGx5IGEgNXRoIHdpdGggZmlsdGVyIHZhbHVlc1xuICAgICAgdGhpcy5jb2xYID0gMDtcbiAgICAgIHRoaXMuY29sWSA9IDE7XG4gICAgICB0aGlzLmNvbFogPSAyO1xuICAgICAgdGhpcy5jb2xWYWx1ZSA9IDM7XG5cbiAgICAgIGlmIChkYXRhLmdldE51bWJlck9mQ29sdW1ucygpID4gNCkge1xuICAgICAgICB0aGlzLmNvbEZpbHRlciA9IDQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93ICdVbmtub3duIHN0eWxlIFwiJyArIHRoaXMuc3R5bGUgKyAnXCInO1xuICAgIH1cbiAgfTtcblxuICBHcmFwaDNkLnByb3RvdHlwZS5nZXROdW1iZXJPZlJvd3MgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBkYXRhLmxlbmd0aDtcbiAgfTtcblxuICBHcmFwaDNkLnByb3RvdHlwZS5nZXROdW1iZXJPZkNvbHVtbnMgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBjb3VudGVyID0gMDtcbiAgICBmb3IgKHZhciBjb2x1bW4gaW4gZGF0YVswXSkge1xuICAgICAgaWYgKGRhdGFbMF0uaGFzT3duUHJvcGVydHkoY29sdW1uKSkge1xuICAgICAgICBjb3VudGVyKys7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb3VudGVyO1xuICB9O1xuXG4gIEdyYXBoM2QucHJvdG90eXBlLmdldERpc3RpbmN0VmFsdWVzID0gZnVuY3Rpb24gKGRhdGEsIGNvbHVtbikge1xuICAgIHZhciBkaXN0aW5jdFZhbHVlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGRpc3RpbmN0VmFsdWVzLmluZGV4T2YoZGF0YVtpXVtjb2x1bW5dKSA9PSAtMSkge1xuICAgICAgICBkaXN0aW5jdFZhbHVlcy5wdXNoKGRhdGFbaV1bY29sdW1uXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaXN0aW5jdFZhbHVlcztcbiAgfTtcblxuICBHcmFwaDNkLnByb3RvdHlwZS5nZXRDb2x1bW5SYW5nZSA9IGZ1bmN0aW9uIChkYXRhLCBjb2x1bW4pIHtcbiAgICB2YXIgbWluTWF4ID0geyBtaW46IGRhdGFbMF1bY29sdW1uXSwgbWF4OiBkYXRhWzBdW2NvbHVtbl0gfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChtaW5NYXgubWluID4gZGF0YVtpXVtjb2x1bW5dKSB7XG4gICAgICAgIG1pbk1heC5taW4gPSBkYXRhW2ldW2NvbHVtbl07XG4gICAgICB9XG4gICAgICBpZiAobWluTWF4Lm1heCA8IGRhdGFbaV1bY29sdW1uXSkge1xuICAgICAgICBtaW5NYXgubWF4ID0gZGF0YVtpXVtjb2x1bW5dO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWluTWF4O1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBkYXRhIGZyb20gdGhlIGRhdGEgdGFibGUuIENhbGN1bGF0ZSBtaW5pbXVtIGFuZCBtYXhpbXVtIHZhbHVlc1xuICAgKiBhbmQgY29sdW1uIGluZGV4IHZhbHVlc1xuICAgKiBAcGFyYW0ge0FycmF5IHwgRGF0YVNldCB8IERhdGFWaWV3fSByYXdEYXRhICAgVGhlIGRhdGEgY29udGFpbmluZyB0aGUgaXRlbXMgZm9yIHRoZSBHcmFwaC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9ICAgICBzdHlsZSAgIFN0eWxlIE51bWJlclxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX2RhdGFJbml0aWFsaXplID0gZnVuY3Rpb24gKHJhd0RhdGEsIHN0eWxlKSB7XG4gICAgdmFyIG1lID0gdGhpcztcblxuICAgIC8vIHVuc3Vic2NyaWJlIGZyb20gdGhlIGRhdGFUYWJsZVxuICAgIGlmICh0aGlzLmRhdGFTZXQpIHtcbiAgICAgIHRoaXMuZGF0YVNldC5vZmYoJyonLCB0aGlzLl9vbkNoYW5nZSk7XG4gICAgfVxuXG4gICAgaWYgKHJhd0RhdGEgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmF3RGF0YSkpIHtcbiAgICAgIHJhd0RhdGEgPSBuZXcgRGF0YVNldChyYXdEYXRhKTtcbiAgICB9XG5cbiAgICB2YXIgZGF0YTtcbiAgICBpZiAocmF3RGF0YSBpbnN0YW5jZW9mIERhdGFTZXQgfHwgcmF3RGF0YSBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG4gICAgICBkYXRhID0gcmF3RGF0YS5nZXQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcnJheSwgRGF0YVNldCwgb3IgRGF0YVZpZXcgZXhwZWN0ZWQnKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5sZW5ndGggPT0gMCkgcmV0dXJuO1xuXG4gICAgdGhpcy5kYXRhU2V0ID0gcmF3RGF0YTtcbiAgICB0aGlzLmRhdGFUYWJsZSA9IGRhdGE7XG5cbiAgICAvLyBzdWJzY3JpYmUgdG8gY2hhbmdlcyBpbiB0aGUgZGF0YXNldFxuICAgIHRoaXMuX29uQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgbWUuc2V0RGF0YShtZS5kYXRhU2V0KTtcbiAgICB9O1xuICAgIHRoaXMuZGF0YVNldC5vbignKicsIHRoaXMuX29uQ2hhbmdlKTtcblxuICAgIC8vIF9kZXRlcm1pbmVDb2x1bW5JbmRleGVzXG4gICAgLy8gZ2V0TnVtYmVyT2ZSb3dzIChwb2ludHMpXG4gICAgLy8gZ2V0TnVtYmVyT2ZDb2x1bW5zICh4LHkseix2LHQsdDEsdDIuLi4pXG4gICAgLy8gZ2V0RGlzdGluY3RWYWx1ZXMgKHVuaXF1ZSB2YWx1ZXM/KVxuICAgIC8vIGdldENvbHVtblJhbmdlXG5cbiAgICAvLyBkZXRlcm1pbmUgdGhlIGxvY2F0aW9uIG9mIHgseSx6LHZhbHVlLGZpbHRlciBjb2x1bW5zXG4gICAgdGhpcy5jb2xYID0gJ3gnO1xuICAgIHRoaXMuY29sWSA9ICd5JztcbiAgICB0aGlzLmNvbFogPSAneic7XG4gICAgdGhpcy5jb2xWYWx1ZSA9ICdzdHlsZSc7XG4gICAgdGhpcy5jb2xGaWx0ZXIgPSAnZmlsdGVyJztcblxuICAgIC8vIGNoZWNrIGlmIGEgZmlsdGVyIGNvbHVtbiBpcyBwcm92aWRlZFxuICAgIGlmIChkYXRhWzBdLmhhc093blByb3BlcnR5KCdmaWx0ZXInKSkge1xuICAgICAgaWYgKHRoaXMuZGF0YUZpbHRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZGF0YUZpbHRlciA9IG5ldyBGaWx0ZXIocmF3RGF0YSwgdGhpcy5jb2xGaWx0ZXIsIHRoaXMpO1xuICAgICAgICB0aGlzLmRhdGFGaWx0ZXIuc2V0T25Mb2FkQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG1lLnJlZHJhdygpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgd2l0aEJhcnMgPSB0aGlzLnN0eWxlID09IEdyYXBoM2QuU1RZTEUuQkFSIHx8IHRoaXMuc3R5bGUgPT0gR3JhcGgzZC5TVFlMRS5CQVJDT0xPUiB8fCB0aGlzLnN0eWxlID09IEdyYXBoM2QuU1RZTEUuQkFSU0laRTtcblxuICAgIC8vIGRldGVybWluZSBiYXJXaWR0aCBmcm9tIGRhdGFcbiAgICBpZiAod2l0aEJhcnMpIHtcbiAgICAgIGlmICh0aGlzLmRlZmF1bHRYQmFyV2lkdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnhCYXJXaWR0aCA9IHRoaXMuZGVmYXVsdFhCYXJXaWR0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkYXRhWCA9IHRoaXMuZ2V0RGlzdGluY3RWYWx1ZXMoZGF0YSwgdGhpcy5jb2xYKTtcbiAgICAgICAgdGhpcy54QmFyV2lkdGggPSBkYXRhWFsxXSAtIGRhdGFYWzBdIHx8IDE7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmRlZmF1bHRZQmFyV2lkdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnlCYXJXaWR0aCA9IHRoaXMuZGVmYXVsdFlCYXJXaWR0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkYXRhWSA9IHRoaXMuZ2V0RGlzdGluY3RWYWx1ZXMoZGF0YSwgdGhpcy5jb2xZKTtcbiAgICAgICAgdGhpcy55QmFyV2lkdGggPSBkYXRhWVsxXSAtIGRhdGFZWzBdIHx8IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2FsY3VsYXRlIG1pbmltdW1zIGFuZCBtYXhpbXVtc1xuICAgIHZhciB4UmFuZ2UgPSB0aGlzLmdldENvbHVtblJhbmdlKGRhdGEsIHRoaXMuY29sWCk7XG4gICAgaWYgKHdpdGhCYXJzKSB7XG4gICAgICB4UmFuZ2UubWluIC09IHRoaXMueEJhcldpZHRoIC8gMjtcbiAgICAgIHhSYW5nZS5tYXggKz0gdGhpcy54QmFyV2lkdGggLyAyO1xuICAgIH1cbiAgICB0aGlzLnhNaW4gPSB0aGlzLmRlZmF1bHRYTWluICE9PSB1bmRlZmluZWQgPyB0aGlzLmRlZmF1bHRYTWluIDogeFJhbmdlLm1pbjtcbiAgICB0aGlzLnhNYXggPSB0aGlzLmRlZmF1bHRYTWF4ICE9PSB1bmRlZmluZWQgPyB0aGlzLmRlZmF1bHRYTWF4IDogeFJhbmdlLm1heDtcbiAgICBpZiAodGhpcy54TWF4IDw9IHRoaXMueE1pbikgdGhpcy54TWF4ID0gdGhpcy54TWluICsgMTtcbiAgICB0aGlzLnhTdGVwID0gdGhpcy5kZWZhdWx0WFN0ZXAgIT09IHVuZGVmaW5lZCA/IHRoaXMuZGVmYXVsdFhTdGVwIDogKHRoaXMueE1heCAtIHRoaXMueE1pbikgLyA1O1xuXG4gICAgdmFyIHlSYW5nZSA9IHRoaXMuZ2V0Q29sdW1uUmFuZ2UoZGF0YSwgdGhpcy5jb2xZKTtcbiAgICBpZiAod2l0aEJhcnMpIHtcbiAgICAgIHlSYW5nZS5taW4gLT0gdGhpcy55QmFyV2lkdGggLyAyO1xuICAgICAgeVJhbmdlLm1heCArPSB0aGlzLnlCYXJXaWR0aCAvIDI7XG4gICAgfVxuICAgIHRoaXMueU1pbiA9IHRoaXMuZGVmYXVsdFlNaW4gIT09IHVuZGVmaW5lZCA/IHRoaXMuZGVmYXVsdFlNaW4gOiB5UmFuZ2UubWluO1xuICAgIHRoaXMueU1heCA9IHRoaXMuZGVmYXVsdFlNYXggIT09IHVuZGVmaW5lZCA/IHRoaXMuZGVmYXVsdFlNYXggOiB5UmFuZ2UubWF4O1xuICAgIGlmICh0aGlzLnlNYXggPD0gdGhpcy55TWluKSB0aGlzLnlNYXggPSB0aGlzLnlNaW4gKyAxO1xuICAgIHRoaXMueVN0ZXAgPSB0aGlzLmRlZmF1bHRZU3RlcCAhPT0gdW5kZWZpbmVkID8gdGhpcy5kZWZhdWx0WVN0ZXAgOiAodGhpcy55TWF4IC0gdGhpcy55TWluKSAvIDU7XG5cbiAgICB2YXIgelJhbmdlID0gdGhpcy5nZXRDb2x1bW5SYW5nZShkYXRhLCB0aGlzLmNvbFopO1xuICAgIHRoaXMuek1pbiA9IHRoaXMuZGVmYXVsdFpNaW4gIT09IHVuZGVmaW5lZCA/IHRoaXMuZGVmYXVsdFpNaW4gOiB6UmFuZ2UubWluO1xuICAgIHRoaXMuek1heCA9IHRoaXMuZGVmYXVsdFpNYXggIT09IHVuZGVmaW5lZCA/IHRoaXMuZGVmYXVsdFpNYXggOiB6UmFuZ2UubWF4O1xuICAgIGlmICh0aGlzLnpNYXggPD0gdGhpcy56TWluKSB0aGlzLnpNYXggPSB0aGlzLnpNaW4gKyAxO1xuICAgIHRoaXMuelN0ZXAgPSB0aGlzLmRlZmF1bHRaU3RlcCAhPT0gdW5kZWZpbmVkID8gdGhpcy5kZWZhdWx0WlN0ZXAgOiAodGhpcy56TWF4IC0gdGhpcy56TWluKSAvIDU7XG5cbiAgICBpZiAodGhpcy5jb2xWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgdmFsdWVSYW5nZSA9IHRoaXMuZ2V0Q29sdW1uUmFuZ2UoZGF0YSwgdGhpcy5jb2xWYWx1ZSk7XG4gICAgICB0aGlzLnZhbHVlTWluID0gdGhpcy5kZWZhdWx0VmFsdWVNaW4gIT09IHVuZGVmaW5lZCA/IHRoaXMuZGVmYXVsdFZhbHVlTWluIDogdmFsdWVSYW5nZS5taW47XG4gICAgICB0aGlzLnZhbHVlTWF4ID0gdGhpcy5kZWZhdWx0VmFsdWVNYXggIT09IHVuZGVmaW5lZCA/IHRoaXMuZGVmYXVsdFZhbHVlTWF4IDogdmFsdWVSYW5nZS5tYXg7XG4gICAgICBpZiAodGhpcy52YWx1ZU1heCA8PSB0aGlzLnZhbHVlTWluKSB0aGlzLnZhbHVlTWF4ID0gdGhpcy52YWx1ZU1pbiArIDE7XG4gICAgfVxuXG4gICAgLy8gc2V0IHRoZSBzY2FsZSBkZXBlbmRlbnQgb24gdGhlIHJhbmdlcy5cbiAgICB0aGlzLl9zZXRTY2FsZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGaWx0ZXIgdGhlIGRhdGEgYmFzZWQgb24gdGhlIGN1cnJlbnQgZmlsdGVyXG4gICAqIEBwYXJhbSB7QXJyYXl9IGRhdGFcbiAgICogQHJldHVybiB7QXJyYXl9IGRhdGFQb2ludHMgICBBcnJheSB3aXRoIHBvaW50IG9iamVjdHMgd2hpY2ggY2FuIGJlIGRyYXduIG9uIHNjcmVlblxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX2dldERhdGFQb2ludHMgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIC8vIFRPRE86IHN0b3JlIHRoZSBjcmVhdGVkIG1hdHJpeCBkYXRhUG9pbnRzIGluIHRoZSBmaWx0ZXJzIGluc3RlYWQgb2YgcmVsb2FkaW5nIGVhY2ggdGltZVxuICAgIHZhciB4LCB5LCBpLCB6LCBvYmosIHBvaW50O1xuXG4gICAgdmFyIGRhdGFQb2ludHMgPSBbXTtcblxuICAgIGlmICh0aGlzLnN0eWxlID09PSBHcmFwaDNkLlNUWUxFLkdSSUQgfHwgdGhpcy5zdHlsZSA9PT0gR3JhcGgzZC5TVFlMRS5TVVJGQUNFKSB7XG4gICAgICAvLyBjb3B5IGFsbCB2YWx1ZXMgZnJvbSB0aGUgZ29vZ2xlIGRhdGEgdGFibGUgdG8gYSBtYXRyaXhcbiAgICAgIC8vIHRoZSBwcm92aWRlZCB2YWx1ZXMgYXJlIHN1cHBvc2VkIHRvIGZvcm0gYSBncmlkIG9mICh4LHkpIHBvc2l0aW9uc1xuXG4gICAgICAvLyBjcmVhdGUgdHdvIGxpc3RzIHdpdGggYWxsIHByZXNlbnQgeCBhbmQgeSB2YWx1ZXNcbiAgICAgIHZhciBkYXRhWCA9IFtdO1xuICAgICAgdmFyIGRhdGFZID0gW107XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5nZXROdW1iZXJPZlJvd3MoZGF0YSk7IGkrKykge1xuICAgICAgICB4ID0gZGF0YVtpXVt0aGlzLmNvbFhdIHx8IDA7XG4gICAgICAgIHkgPSBkYXRhW2ldW3RoaXMuY29sWV0gfHwgMDtcblxuICAgICAgICBpZiAoZGF0YVguaW5kZXhPZih4KSA9PT0gLTEpIHtcbiAgICAgICAgICBkYXRhWC5wdXNoKHgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhWS5pbmRleE9mKHkpID09PSAtMSkge1xuICAgICAgICAgIGRhdGFZLnB1c2goeSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHNvcnROdW1iZXIgPSBmdW5jdGlvbiBzb3J0TnVtYmVyKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgfTtcbiAgICAgIGRhdGFYLnNvcnQoc29ydE51bWJlcik7XG4gICAgICBkYXRhWS5zb3J0KHNvcnROdW1iZXIpO1xuXG4gICAgICAvLyBjcmVhdGUgYSBncmlkLCBhIDJkIG1hdHJpeCwgd2l0aCBhbGwgdmFsdWVzLlxuICAgICAgdmFyIGRhdGFNYXRyaXggPSBbXTsgLy8gdGVtcG9yYXJ5IGRhdGEgbWF0cml4XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICB4ID0gZGF0YVtpXVt0aGlzLmNvbFhdIHx8IDA7XG4gICAgICAgIHkgPSBkYXRhW2ldW3RoaXMuY29sWV0gfHwgMDtcbiAgICAgICAgeiA9IGRhdGFbaV1bdGhpcy5jb2xaXSB8fCAwO1xuXG4gICAgICAgIHZhciB4SW5kZXggPSBkYXRhWC5pbmRleE9mKHgpOyAvLyBUT0RPOiBpbXBsZW1lbnQgQXJyYXkoKS5pbmRleE9mKCkgZm9yIEludGVybmV0IEV4cGxvcmVyXG4gICAgICAgIHZhciB5SW5kZXggPSBkYXRhWS5pbmRleE9mKHkpO1xuXG4gICAgICAgIGlmIChkYXRhTWF0cml4W3hJbmRleF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGRhdGFNYXRyaXhbeEluZGV4XSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBvaW50M2QgPSBuZXcgUG9pbnQzZCgpO1xuICAgICAgICBwb2ludDNkLnggPSB4O1xuICAgICAgICBwb2ludDNkLnkgPSB5O1xuICAgICAgICBwb2ludDNkLnogPSB6O1xuXG4gICAgICAgIG9iaiA9IHt9O1xuICAgICAgICBvYmoucG9pbnQgPSBwb2ludDNkO1xuICAgICAgICBvYmoudHJhbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIG9iai5zY3JlZW4gPSB1bmRlZmluZWQ7XG4gICAgICAgIG9iai5ib3R0b20gPSBuZXcgUG9pbnQzZCh4LCB5LCB0aGlzLnpNaW4pO1xuXG4gICAgICAgIGRhdGFNYXRyaXhbeEluZGV4XVt5SW5kZXhdID0gb2JqO1xuXG4gICAgICAgIGRhdGFQb2ludHMucHVzaChvYmopO1xuICAgICAgfVxuXG4gICAgICAvLyBmaWxsIGluIHRoZSBwb2ludGVycyB0byB0aGUgbmVpZ2hib3JzLlxuICAgICAgZm9yICh4ID0gMDsgeCA8IGRhdGFNYXRyaXgubGVuZ3RoOyB4KyspIHtcbiAgICAgICAgZm9yICh5ID0gMDsgeSA8IGRhdGFNYXRyaXhbeF0ubGVuZ3RoOyB5KyspIHtcbiAgICAgICAgICBpZiAoZGF0YU1hdHJpeFt4XVt5XSkge1xuICAgICAgICAgICAgZGF0YU1hdHJpeFt4XVt5XS5wb2ludFJpZ2h0ID0geCA8IGRhdGFNYXRyaXgubGVuZ3RoIC0gMSA/IGRhdGFNYXRyaXhbeCArIDFdW3ldIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgZGF0YU1hdHJpeFt4XVt5XS5wb2ludFRvcCA9IHkgPCBkYXRhTWF0cml4W3hdLmxlbmd0aCAtIDEgPyBkYXRhTWF0cml4W3hdW3kgKyAxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGRhdGFNYXRyaXhbeF1beV0ucG9pbnRDcm9zcyA9IHggPCBkYXRhTWF0cml4Lmxlbmd0aCAtIDEgJiYgeSA8IGRhdGFNYXRyaXhbeF0ubGVuZ3RoIC0gMSA/IGRhdGFNYXRyaXhbeCArIDFdW3kgKyAxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gJ2RvdCcsICdkb3QtbGluZScsIGV0Yy5cbiAgICAgIC8vIGNvcHkgYWxsIHZhbHVlcyBmcm9tIHRoZSBnb29nbGUgZGF0YSB0YWJsZSB0byBhIGxpc3Qgd2l0aCBQb2ludDNkIG9iamVjdHNcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBvaW50ID0gbmV3IFBvaW50M2QoKTtcbiAgICAgICAgcG9pbnQueCA9IGRhdGFbaV1bdGhpcy5jb2xYXSB8fCAwO1xuICAgICAgICBwb2ludC55ID0gZGF0YVtpXVt0aGlzLmNvbFldIHx8IDA7XG4gICAgICAgIHBvaW50LnogPSBkYXRhW2ldW3RoaXMuY29sWl0gfHwgMDtcblxuICAgICAgICBpZiAodGhpcy5jb2xWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcG9pbnQudmFsdWUgPSBkYXRhW2ldW3RoaXMuY29sVmFsdWVdIHx8IDA7XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSB7fTtcbiAgICAgICAgb2JqLnBvaW50ID0gcG9pbnQ7XG4gICAgICAgIG9iai5ib3R0b20gPSBuZXcgUG9pbnQzZChwb2ludC54LCBwb2ludC55LCB0aGlzLnpNaW4pO1xuICAgICAgICBvYmoudHJhbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIG9iai5zY3JlZW4gPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgZGF0YVBvaW50cy5wdXNoKG9iaik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGFQb2ludHM7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgbWFpbiBmcmFtZSBmb3IgdGhlIEdyYXBoM2QuXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgb25jZSB3aGVuIGEgR3JhcGgzZCBvYmplY3QgaXMgY3JlYXRlZC4gVGhlIGZyYW1lXG4gICAqIGNvbnRhaW5zIGEgY2FudmFzLCBhbmQgdGhpcyBjYW52YXMgY29udGFpbnMgYWxsIG9iamVjdHMgbGlrZSB0aGUgYXhpcyBhbmRcbiAgICogbm9kZXMuXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gcmVtb3ZlIGFsbCBlbGVtZW50cyBmcm9tIHRoZSBjb250YWluZXIgZWxlbWVudC5cbiAgICB3aGlsZSAodGhpcy5jb250YWluZXJFbGVtZW50Lmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgdGhpcy5jb250YWluZXJFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuY29udGFpbmVyRWxlbWVudC5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICB0aGlzLmZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5mcmFtZS5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgdGhpcy5mcmFtZS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuXG4gICAgLy8gY3JlYXRlIHRoZSBncmFwaCBjYW52YXMgKEhUTUwgY2FudmFzIGVsZW1lbnQpXG4gICAgdGhpcy5mcmFtZS5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB0aGlzLmZyYW1lLmNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmZyYW1lLmNhbnZhcyk7XG4gICAgLy9pZiAoIXRoaXMuZnJhbWUuY2FudmFzLmdldENvbnRleHQpIHtcbiAgICB7XG4gICAgICB2YXIgbm9DYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcbiAgICAgIG5vQ2FudmFzLnN0eWxlLmNvbG9yID0gJ3JlZCc7XG4gICAgICBub0NhbnZhcy5zdHlsZS5mb250V2VpZ2h0ID0gJ2JvbGQnO1xuICAgICAgbm9DYW52YXMuc3R5bGUucGFkZGluZyA9ICcxMHB4JztcbiAgICAgIG5vQ2FudmFzLmlubmVySFRNTCA9ICdFcnJvcjogeW91ciBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgSFRNTCBjYW52YXMnO1xuICAgICAgdGhpcy5mcmFtZS5jYW52YXMuYXBwZW5kQ2hpbGQobm9DYW52YXMpO1xuICAgIH1cblxuICAgIHRoaXMuZnJhbWUuZmlsdGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5mcmFtZS5maWx0ZXIuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIHRoaXMuZnJhbWUuZmlsdGVyLnN0eWxlLmJvdHRvbSA9ICcwcHgnO1xuICAgIHRoaXMuZnJhbWUuZmlsdGVyLnN0eWxlLmxlZnQgPSAnMHB4JztcbiAgICB0aGlzLmZyYW1lLmZpbHRlci5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuZnJhbWUuZmlsdGVyKTtcblxuICAgIC8vIGFkZCBldmVudCBsaXN0ZW5lcnMgdG8gaGFuZGxlIG1vdmluZyBhbmQgem9vbWluZyB0aGUgY29udGVudHNcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciBvbm1vdXNlZG93biA9IGZ1bmN0aW9uIG9ubW91c2Vkb3duKGV2ZW50KSB7XG4gICAgICBtZS5fb25Nb3VzZURvd24oZXZlbnQpO1xuICAgIH07XG4gICAgdmFyIG9udG91Y2hzdGFydCA9IGZ1bmN0aW9uIG9udG91Y2hzdGFydChldmVudCkge1xuICAgICAgbWUuX29uVG91Y2hTdGFydChldmVudCk7XG4gICAgfTtcbiAgICB2YXIgb25tb3VzZXdoZWVsID0gZnVuY3Rpb24gb25tb3VzZXdoZWVsKGV2ZW50KSB7XG4gICAgICBtZS5fb25XaGVlbChldmVudCk7XG4gICAgfTtcbiAgICB2YXIgb250b29sdGlwID0gZnVuY3Rpb24gb250b29sdGlwKGV2ZW50KSB7XG4gICAgICBtZS5fb25Ub29sdGlwKGV2ZW50KTtcbiAgICB9O1xuICAgIC8vIFRPRE86IHRoZXNlIGV2ZW50cyBhcmUgbmV2ZXIgY2xlYW5lZCB1cC4uLiBjYW4gZ2l2ZSBhICdtZW1vcnkgbGVha2FnZSdcblxuICAgIHV0aWwuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmZyYW1lLmNhbnZhcywgJ2tleWRvd24nLCBvbmtleWRvd24pO1xuICAgIHV0aWwuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmZyYW1lLmNhbnZhcywgJ21vdXNlZG93bicsIG9ubW91c2Vkb3duKTtcbiAgICB1dGlsLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5mcmFtZS5jYW52YXMsICd0b3VjaHN0YXJ0Jywgb250b3VjaHN0YXJ0KTtcbiAgICB1dGlsLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5mcmFtZS5jYW52YXMsICdtb3VzZXdoZWVsJywgb25tb3VzZXdoZWVsKTtcbiAgICB1dGlsLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5mcmFtZS5jYW52YXMsICdtb3VzZW1vdmUnLCBvbnRvb2x0aXApO1xuXG4gICAgLy8gYWRkIHRoZSBuZXcgZ3JhcGggdG8gdGhlIGNvbnRhaW5lciBlbGVtZW50XG4gICAgdGhpcy5jb250YWluZXJFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuZnJhbWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgYSBuZXcgc2l6ZSBmb3IgdGhlIGdyYXBoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB3aWR0aCAgIFdpZHRoIGluIHBpeGVscyBvciBwZXJjZW50YWdlIChmb3IgZXhhbXBsZSAnODAwcHgnXG4gICAqICAgICAgICAgICAgIG9yICc1MCUnKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGVpZ2h0ICBIZWlnaHQgaW4gcGl4ZWxzIG9yIHBlcmNlbnRhZ2UgIChmb3IgZXhhbXBsZSAnNDAwcHgnXG4gICAqICAgICAgICAgICAgIG9yICczMCUnKVxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuc2V0U2l6ZSA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy5mcmFtZS5zdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuZnJhbWUuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgdGhpcy5fcmVzaXplQ2FudmFzKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlc2l6ZSB0aGUgY2FudmFzIHRvIHRoZSBjdXJyZW50IHNpemUgb2YgdGhlIGZyYW1lXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5fcmVzaXplQ2FudmFzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnJhbWUuY2FudmFzLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgIHRoaXMuZnJhbWUuY2FudmFzLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcblxuICAgIHRoaXMuZnJhbWUuY2FudmFzLndpZHRoID0gdGhpcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGg7XG4gICAgdGhpcy5mcmFtZS5jYW52YXMuaGVpZ2h0ID0gdGhpcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0O1xuXG4gICAgLy8gYWRqdXN0IHdpdGggZm9yIG1hcmdpblxuICAgIHRoaXMuZnJhbWUuZmlsdGVyLnN0eWxlLndpZHRoID0gdGhpcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGggLSAyICogMTAgKyAncHgnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdGFydCBhbmltYXRpb25cbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLmFuaW1hdGlvblN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5mcmFtZS5maWx0ZXIgfHwgIXRoaXMuZnJhbWUuZmlsdGVyLnNsaWRlcikgdGhyb3cgJ05vIGFuaW1hdGlvbiBhdmFpbGFibGUnO1xuXG4gICAgdGhpcy5mcmFtZS5maWx0ZXIuc2xpZGVyLnBsYXkoKTtcbiAgfTtcblxuICAvKipcbiAgICogU3RvcCBhbmltYXRpb25cbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLmFuaW1hdGlvblN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmZyYW1lLmZpbHRlciB8fCAhdGhpcy5mcmFtZS5maWx0ZXIuc2xpZGVyKSByZXR1cm47XG5cbiAgICB0aGlzLmZyYW1lLmZpbHRlci5zbGlkZXIuc3RvcCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXNpemUgdGhlIGNlbnRlciBwb3NpdGlvbiBiYXNlZCBvbiB0aGUgY3VycmVudCB2YWx1ZXMgaW4gdGhpcy5kZWZhdWx0WENlbnRlclxuICAgKiBhbmQgdGhpcy5kZWZhdWx0WUNlbnRlciAod2hpY2ggYXJlIHN0cmluZ3Mgd2l0aCBhIHBlcmNlbnRhZ2Ugb3IgYSB2YWx1ZVxuICAgKiBpbiBwaXhlbHMpLiBUaGUgY2VudGVyIHBvc2l0aW9ucyBhcmUgdGhlIHZhcmlhYmxlcyB0aGlzLnhDZW50ZXJcbiAgICogYW5kIHRoaXMueUNlbnRlclxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX3Jlc2l6ZUNlbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBjYWxjdWxhdGUgdGhlIGhvcml6b250YWwgY2VudGVyIHBvc2l0aW9uXG4gICAgaWYgKHRoaXMuZGVmYXVsdFhDZW50ZXIuY2hhckF0KHRoaXMuZGVmYXVsdFhDZW50ZXIubGVuZ3RoIC0gMSkgPT09ICclJykge1xuICAgICAgdGhpcy54Y2VudGVyID0gcGFyc2VGbG9hdCh0aGlzLmRlZmF1bHRYQ2VudGVyKSAvIDEwMCAqIHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnhjZW50ZXIgPSBwYXJzZUZsb2F0KHRoaXMuZGVmYXVsdFhDZW50ZXIpOyAvLyBzdXBwb3NlZCB0byBiZSBpbiBweFxuICAgIH1cblxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgdmVydGljYWwgY2VudGVyIHBvc2l0aW9uXG4gICAgaWYgKHRoaXMuZGVmYXVsdFlDZW50ZXIuY2hhckF0KHRoaXMuZGVmYXVsdFlDZW50ZXIubGVuZ3RoIC0gMSkgPT09ICclJykge1xuICAgICAgdGhpcy55Y2VudGVyID0gcGFyc2VGbG9hdCh0aGlzLmRlZmF1bHRZQ2VudGVyKSAvIDEwMCAqICh0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHQgLSB0aGlzLmZyYW1lLmZpbHRlci5jbGllbnRIZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnljZW50ZXIgPSBwYXJzZUZsb2F0KHRoaXMuZGVmYXVsdFlDZW50ZXIpOyAvLyBzdXBwb3NlZCB0byBiZSBpbiBweFxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSByb3RhdGlvbiBhbmQgZGlzdGFuY2Ugb2YgdGhlIGNhbWVyYVxuICAgKiBAcGFyYW0ge09iamVjdH0gcG9zICAgQW4gb2JqZWN0IHdpdGggdGhlIGNhbWVyYSBwb3NpdGlvbi4gVGhlIG9iamVjdFxuICAgKiAgICAgICAgICAgICBjb250YWlucyB0aHJlZSBwYXJhbWV0ZXJzOlxuICAgKiAgICAgICAgICAgICAtIGhvcml6b250YWwge051bWJlcn1cbiAgICogICAgICAgICAgICAgVGhlIGhvcml6b250YWwgcm90YXRpb24sIGJldHdlZW4gMCBhbmQgMipQSS5cbiAgICogICAgICAgICAgICAgT3B0aW9uYWwsIGNhbiBiZSBsZWZ0IHVuZGVmaW5lZC5cbiAgICogICAgICAgICAgICAgLSB2ZXJ0aWNhbCB7TnVtYmVyfVxuICAgKiAgICAgICAgICAgICBUaGUgdmVydGljYWwgcm90YXRpb24sIGJldHdlZW4gMCBhbmQgMC41KlBJXG4gICAqICAgICAgICAgICAgIGlmIHZlcnRpY2FsPTAuNSpQSSwgdGhlIGdyYXBoIGlzIHNob3duIGZyb20gdGhlXG4gICAqICAgICAgICAgICAgIHRvcC4gT3B0aW9uYWwsIGNhbiBiZSBsZWZ0IHVuZGVmaW5lZC5cbiAgICogICAgICAgICAgICAgLSBkaXN0YW5jZSB7TnVtYmVyfVxuICAgKiAgICAgICAgICAgICBUaGUgKG5vcm1hbGl6ZWQpIGRpc3RhbmNlIG9mIHRoZSBjYW1lcmEgdG8gdGhlXG4gICAqICAgICAgICAgICAgIGNlbnRlciBvZiB0aGUgZ3JhcGgsIGEgdmFsdWUgYmV0d2VlbiAwLjcxIGFuZCA1LjAuXG4gICAqICAgICAgICAgICAgIE9wdGlvbmFsLCBjYW4gYmUgbGVmdCB1bmRlZmluZWQuXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5zZXRDYW1lcmFQb3NpdGlvbiA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICBpZiAocG9zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocG9zLmhvcml6b250YWwgIT09IHVuZGVmaW5lZCAmJiBwb3MudmVydGljYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5jYW1lcmEuc2V0QXJtUm90YXRpb24ocG9zLmhvcml6b250YWwsIHBvcy52ZXJ0aWNhbCk7XG4gICAgfVxuXG4gICAgaWYgKHBvcy5kaXN0YW5jZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmNhbWVyYS5zZXRBcm1MZW5ndGgocG9zLmRpc3RhbmNlKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlZHJhdygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgY3VycmVudCBjYW1lcmEgcm90YXRpb25cbiAgICogQHJldHVybiB7b2JqZWN0fSAgIEFuIG9iamVjdCB3aXRoIHBhcmFtZXRlcnMgaG9yaXpvbnRhbCwgdmVydGljYWwsIGFuZFxuICAgKiAgICAgICAgICBkaXN0YW5jZVxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuZ2V0Q2FtZXJhUG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBvcyA9IHRoaXMuY2FtZXJhLmdldEFybVJvdGF0aW9uKCk7XG4gICAgcG9zLmRpc3RhbmNlID0gdGhpcy5jYW1lcmEuZ2V0QXJtTGVuZ3RoKCk7XG4gICAgcmV0dXJuIHBvcztcbiAgfTtcblxuICAvKipcbiAgICogTG9hZCBkYXRhIGludG8gdGhlIDNEIEdyYXBoXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5fcmVhZERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIC8vIHJlYWQgdGhlIGRhdGFcbiAgICB0aGlzLl9kYXRhSW5pdGlhbGl6ZShkYXRhLCB0aGlzLnN0eWxlKTtcblxuICAgIGlmICh0aGlzLmRhdGFGaWx0ZXIpIHtcbiAgICAgIC8vIGFwcGx5IGZpbHRlcmluZ1xuICAgICAgdGhpcy5kYXRhUG9pbnRzID0gdGhpcy5kYXRhRmlsdGVyLl9nZXREYXRhUG9pbnRzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5vIGZpbHRlcmluZy4gbG9hZCBhbGwgZGF0YVxuICAgICAgdGhpcy5kYXRhUG9pbnRzID0gdGhpcy5fZ2V0RGF0YVBvaW50cyh0aGlzLmRhdGFUYWJsZSk7XG4gICAgfVxuXG4gICAgLy8gZHJhdyB0aGUgZmlsdGVyXG4gICAgdGhpcy5fcmVkcmF3RmlsdGVyKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcGxhY2UgdGhlIGRhdGFzZXQgb2YgdGhlIEdyYXBoM2RcbiAgICogQHBhcmFtIHtBcnJheSB8IERhdGFTZXQgfCBEYXRhVmlld30gZGF0YVxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdGhpcy5fcmVhZERhdGEoZGF0YSk7XG4gICAgdGhpcy5yZWRyYXcoKTtcblxuICAgIC8vIHN0YXJ0IGFuaW1hdGlvbiB3aGVuIG9wdGlvbiBpcyB0cnVlXG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uQXV0b1N0YXJ0ICYmIHRoaXMuZGF0YUZpbHRlcikge1xuICAgICAgdGhpcy5hbmltYXRpb25TdGFydCgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBvcHRpb25zLiBPcHRpb25zIHdpbGwgYmUgbWVyZ2VkIHdpdGggY3VycmVudCBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgY2FtZXJhUG9zaXRpb24gPSB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLmFuaW1hdGlvblN0b3AoKTtcblxuICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHJldHJpZXZlIHBhcmFtZXRlciB2YWx1ZXNcbiAgICAgIGlmIChvcHRpb25zLndpZHRoICE9PSB1bmRlZmluZWQpIHRoaXMud2lkdGggPSBvcHRpb25zLndpZHRoO1xuICAgICAgaWYgKG9wdGlvbnMuaGVpZ2h0ICE9PSB1bmRlZmluZWQpIHRoaXMuaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQ7XG5cbiAgICAgIGlmIChvcHRpb25zLnhDZW50ZXIgIT09IHVuZGVmaW5lZCkgdGhpcy5kZWZhdWx0WENlbnRlciA9IG9wdGlvbnMueENlbnRlcjtcbiAgICAgIGlmIChvcHRpb25zLnlDZW50ZXIgIT09IHVuZGVmaW5lZCkgdGhpcy5kZWZhdWx0WUNlbnRlciA9IG9wdGlvbnMueUNlbnRlcjtcblxuICAgICAgaWYgKG9wdGlvbnMuZmlsdGVyTGFiZWwgIT09IHVuZGVmaW5lZCkgdGhpcy5maWx0ZXJMYWJlbCA9IG9wdGlvbnMuZmlsdGVyTGFiZWw7XG4gICAgICBpZiAob3B0aW9ucy5sZWdlbmRMYWJlbCAhPT0gdW5kZWZpbmVkKSB0aGlzLmxlZ2VuZExhYmVsID0gb3B0aW9ucy5sZWdlbmRMYWJlbDtcbiAgICAgIGlmIChvcHRpb25zLnhMYWJlbCAhPT0gdW5kZWZpbmVkKSB0aGlzLnhMYWJlbCA9IG9wdGlvbnMueExhYmVsO1xuICAgICAgaWYgKG9wdGlvbnMueUxhYmVsICE9PSB1bmRlZmluZWQpIHRoaXMueUxhYmVsID0gb3B0aW9ucy55TGFiZWw7XG4gICAgICBpZiAob3B0aW9ucy56TGFiZWwgIT09IHVuZGVmaW5lZCkgdGhpcy56TGFiZWwgPSBvcHRpb25zLnpMYWJlbDtcblxuICAgICAgaWYgKG9wdGlvbnMueFZhbHVlTGFiZWwgIT09IHVuZGVmaW5lZCkgdGhpcy54VmFsdWVMYWJlbCA9IG9wdGlvbnMueFZhbHVlTGFiZWw7XG4gICAgICBpZiAob3B0aW9ucy55VmFsdWVMYWJlbCAhPT0gdW5kZWZpbmVkKSB0aGlzLnlWYWx1ZUxhYmVsID0gb3B0aW9ucy55VmFsdWVMYWJlbDtcbiAgICAgIGlmIChvcHRpb25zLnpWYWx1ZUxhYmVsICE9PSB1bmRlZmluZWQpIHRoaXMuelZhbHVlTGFiZWwgPSBvcHRpb25zLnpWYWx1ZUxhYmVsO1xuXG4gICAgICBpZiAob3B0aW9ucy5kb3RTaXplUmF0aW8gIT09IHVuZGVmaW5lZCkgdGhpcy5kb3RTaXplUmF0aW8gPSBvcHRpb25zLmRvdFNpemVSYXRpbztcblxuICAgICAgaWYgKG9wdGlvbnMuc3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgc3R5bGVOdW1iZXIgPSB0aGlzLl9nZXRTdHlsZU51bWJlcihvcHRpb25zLnN0eWxlKTtcbiAgICAgICAgaWYgKHN0eWxlTnVtYmVyICE9PSAtMSkge1xuICAgICAgICAgIHRoaXMuc3R5bGUgPSBzdHlsZU51bWJlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuc2hvd0dyaWQgIT09IHVuZGVmaW5lZCkgdGhpcy5zaG93R3JpZCA9IG9wdGlvbnMuc2hvd0dyaWQ7XG4gICAgICBpZiAob3B0aW9ucy5zaG93UGVyc3BlY3RpdmUgIT09IHVuZGVmaW5lZCkgdGhpcy5zaG93UGVyc3BlY3RpdmUgPSBvcHRpb25zLnNob3dQZXJzcGVjdGl2ZTtcbiAgICAgIGlmIChvcHRpb25zLnNob3dTaGFkb3cgIT09IHVuZGVmaW5lZCkgdGhpcy5zaG93U2hhZG93ID0gb3B0aW9ucy5zaG93U2hhZG93O1xuICAgICAgaWYgKG9wdGlvbnMudG9vbHRpcCAhPT0gdW5kZWZpbmVkKSB0aGlzLnNob3dUb29sdGlwID0gb3B0aW9ucy50b29sdGlwO1xuICAgICAgaWYgKG9wdGlvbnMuc2hvd0FuaW1hdGlvbkNvbnRyb2xzICE9PSB1bmRlZmluZWQpIHRoaXMuc2hvd0FuaW1hdGlvbkNvbnRyb2xzID0gb3B0aW9ucy5zaG93QW5pbWF0aW9uQ29udHJvbHM7XG4gICAgICBpZiAob3B0aW9ucy5rZWVwQXNwZWN0UmF0aW8gIT09IHVuZGVmaW5lZCkgdGhpcy5rZWVwQXNwZWN0UmF0aW8gPSBvcHRpb25zLmtlZXBBc3BlY3RSYXRpbztcbiAgICAgIGlmIChvcHRpb25zLnZlcnRpY2FsUmF0aW8gIT09IHVuZGVmaW5lZCkgdGhpcy52ZXJ0aWNhbFJhdGlvID0gb3B0aW9ucy52ZXJ0aWNhbFJhdGlvO1xuXG4gICAgICBpZiAob3B0aW9ucy5hbmltYXRpb25JbnRlcnZhbCAhPT0gdW5kZWZpbmVkKSB0aGlzLmFuaW1hdGlvbkludGVydmFsID0gb3B0aW9ucy5hbmltYXRpb25JbnRlcnZhbDtcbiAgICAgIGlmIChvcHRpb25zLmFuaW1hdGlvblByZWxvYWQgIT09IHVuZGVmaW5lZCkgdGhpcy5hbmltYXRpb25QcmVsb2FkID0gb3B0aW9ucy5hbmltYXRpb25QcmVsb2FkO1xuICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uQXV0b1N0YXJ0ICE9PSB1bmRlZmluZWQpIHRoaXMuYW5pbWF0aW9uQXV0b1N0YXJ0ID0gb3B0aW9ucy5hbmltYXRpb25BdXRvU3RhcnQ7XG5cbiAgICAgIGlmIChvcHRpb25zLnhCYXJXaWR0aCAhPT0gdW5kZWZpbmVkKSB0aGlzLmRlZmF1bHRYQmFyV2lkdGggPSBvcHRpb25zLnhCYXJXaWR0aDtcbiAgICAgIGlmIChvcHRpb25zLnlCYXJXaWR0aCAhPT0gdW5kZWZpbmVkKSB0aGlzLmRlZmF1bHRZQmFyV2lkdGggPSBvcHRpb25zLnlCYXJXaWR0aDtcblxuICAgICAgaWYgKG9wdGlvbnMueE1pbiAhPT0gdW5kZWZpbmVkKSB0aGlzLmRlZmF1bHRYTWluID0gb3B0aW9ucy54TWluO1xuICAgICAgaWYgKG9wdGlvbnMueFN0ZXAgIT09IHVuZGVmaW5lZCkgdGhpcy5kZWZhdWx0WFN0ZXAgPSBvcHRpb25zLnhTdGVwO1xuICAgICAgaWYgKG9wdGlvbnMueE1heCAhPT0gdW5kZWZpbmVkKSB0aGlzLmRlZmF1bHRYTWF4ID0gb3B0aW9ucy54TWF4O1xuICAgICAgaWYgKG9wdGlvbnMueU1pbiAhPT0gdW5kZWZpbmVkKSB0aGlzLmRlZmF1bHRZTWluID0gb3B0aW9ucy55TWluO1xuICAgICAgaWYgKG9wdGlvbnMueVN0ZXAgIT09IHVuZGVmaW5lZCkgdGhpcy5kZWZhdWx0WVN0ZXAgPSBvcHRpb25zLnlTdGVwO1xuICAgICAgaWYgKG9wdGlvbnMueU1heCAhPT0gdW5kZWZpbmVkKSB0aGlzLmRlZmF1bHRZTWF4ID0gb3B0aW9ucy55TWF4O1xuICAgICAgaWYgKG9wdGlvbnMuek1pbiAhPT0gdW5kZWZpbmVkKSB0aGlzLmRlZmF1bHRaTWluID0gb3B0aW9ucy56TWluO1xuICAgICAgaWYgKG9wdGlvbnMuelN0ZXAgIT09IHVuZGVmaW5lZCkgdGhpcy5kZWZhdWx0WlN0ZXAgPSBvcHRpb25zLnpTdGVwO1xuICAgICAgaWYgKG9wdGlvbnMuek1heCAhPT0gdW5kZWZpbmVkKSB0aGlzLmRlZmF1bHRaTWF4ID0gb3B0aW9ucy56TWF4O1xuICAgICAgaWYgKG9wdGlvbnMudmFsdWVNaW4gIT09IHVuZGVmaW5lZCkgdGhpcy5kZWZhdWx0VmFsdWVNaW4gPSBvcHRpb25zLnZhbHVlTWluO1xuICAgICAgaWYgKG9wdGlvbnMudmFsdWVNYXggIT09IHVuZGVmaW5lZCkgdGhpcy5kZWZhdWx0VmFsdWVNYXggPSBvcHRpb25zLnZhbHVlTWF4O1xuICAgICAgaWYgKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yICE9PSB1bmRlZmluZWQpIHRoaXMuX3NldEJhY2tncm91bmRDb2xvcihvcHRpb25zLmJhY2tncm91bmRDb2xvcik7XG5cbiAgICAgIGlmIChvcHRpb25zLmNhbWVyYVBvc2l0aW9uICE9PSB1bmRlZmluZWQpIGNhbWVyYVBvc2l0aW9uID0gb3B0aW9ucy5jYW1lcmFQb3NpdGlvbjtcblxuICAgICAgaWYgKGNhbWVyYVBvc2l0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5jYW1lcmEuc2V0QXJtUm90YXRpb24oY2FtZXJhUG9zaXRpb24uaG9yaXpvbnRhbCwgY2FtZXJhUG9zaXRpb24udmVydGljYWwpO1xuICAgICAgICB0aGlzLmNhbWVyYS5zZXRBcm1MZW5ndGgoY2FtZXJhUG9zaXRpb24uZGlzdGFuY2UpO1xuICAgICAgfVxuXG4gICAgICAvLyBjb2xvcnNcbiAgICAgIGlmIChvcHRpb25zLmF4aXNDb2xvciAhPT0gdW5kZWZpbmVkKSB0aGlzLmF4aXNDb2xvciA9IG9wdGlvbnMuYXhpc0NvbG9yO1xuICAgICAgaWYgKG9wdGlvbnMuZ3JpZENvbG9yICE9PSB1bmRlZmluZWQpIHRoaXMuZ3JpZENvbG9yID0gb3B0aW9ucy5ncmlkQ29sb3I7XG4gICAgICBpZiAob3B0aW9ucy5kYXRhQ29sb3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmRhdGFDb2xvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aGlzLmRhdGFDb2xvci5maWxsID0gb3B0aW9ucy5kYXRhQ29sb3I7XG4gICAgICAgICAgdGhpcy5kYXRhQ29sb3Iuc3Ryb2tlID0gb3B0aW9ucy5kYXRhQ29sb3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuZGF0YUNvbG9yLmZpbGwpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YUNvbG9yLmZpbGwgPSBvcHRpb25zLmRhdGFDb2xvci5maWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3B0aW9ucy5kYXRhQ29sb3Iuc3Ryb2tlKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFDb2xvci5zdHJva2UgPSBvcHRpb25zLmRhdGFDb2xvci5zdHJva2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRpb25zLmRhdGFDb2xvci5zdHJva2VXaWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFDb2xvci5zdHJva2VXaWR0aCA9IG9wdGlvbnMuZGF0YUNvbG9yLnN0cm9rZVdpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc2V0U2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cbiAgICAvLyByZS1sb2FkIHRoZSBkYXRhXG4gICAgaWYgKHRoaXMuZGF0YVRhYmxlKSB7XG4gICAgICB0aGlzLnNldERhdGEodGhpcy5kYXRhVGFibGUpO1xuICAgIH1cblxuICAgIC8vIHN0YXJ0IGFuaW1hdGlvbiB3aGVuIG9wdGlvbiBpcyB0cnVlXG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uQXV0b1N0YXJ0ICYmIHRoaXMuZGF0YUZpbHRlcikge1xuICAgICAgdGhpcy5hbmltYXRpb25TdGFydCgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVkcmF3IHRoZSBHcmFwaC5cbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5kYXRhUG9pbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93ICdFcnJvcjogZ3JhcGggZGF0YSBub3QgaW5pdGlhbGl6ZWQnO1xuICAgIH1cblxuICAgIHRoaXMuX3Jlc2l6ZUNhbnZhcygpO1xuICAgIHRoaXMuX3Jlc2l6ZUNlbnRlcigpO1xuICAgIHRoaXMuX3JlZHJhd1NsaWRlcigpO1xuICAgIHRoaXMuX3JlZHJhd0NsZWFyKCk7XG4gICAgdGhpcy5fcmVkcmF3QXhpcygpO1xuXG4gICAgaWYgKHRoaXMuc3R5bGUgPT09IEdyYXBoM2QuU1RZTEUuR1JJRCB8fCB0aGlzLnN0eWxlID09PSBHcmFwaDNkLlNUWUxFLlNVUkZBQ0UpIHtcbiAgICAgIHRoaXMuX3JlZHJhd0RhdGFHcmlkKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0eWxlID09PSBHcmFwaDNkLlNUWUxFLkxJTkUpIHtcbiAgICAgIHRoaXMuX3JlZHJhd0RhdGFMaW5lKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0eWxlID09PSBHcmFwaDNkLlNUWUxFLkJBUiB8fCB0aGlzLnN0eWxlID09PSBHcmFwaDNkLlNUWUxFLkJBUkNPTE9SIHx8IHRoaXMuc3R5bGUgPT09IEdyYXBoM2QuU1RZTEUuQkFSU0laRSkge1xuICAgICAgdGhpcy5fcmVkcmF3RGF0YUJhcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzdHlsZSBpcyBET1QsIERPVExJTkUsIERPVENPTE9SLCBET1RTSVpFXG4gICAgICB0aGlzLl9yZWRyYXdEYXRhRG90KCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVkcmF3SW5mbygpO1xuICAgIHRoaXMuX3JlZHJhd0xlZ2VuZCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhciB0aGUgY2FudmFzIGJlZm9yZSByZWRyYXdpbmdcbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLl9yZWRyYXdDbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FudmFzID0gdGhpcy5mcmFtZS5jYW52YXM7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWRyYXcgdGhlIGxlZ2VuZCBzaG93aW5nIHRoZSBjb2xvcnNcbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLl9yZWRyYXdMZWdlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHk7XG5cbiAgICBpZiAodGhpcy5zdHlsZSA9PT0gR3JhcGgzZC5TVFlMRS5ET1RDT0xPUiB8fCB0aGlzLnN0eWxlID09PSBHcmFwaDNkLlNUWUxFLkRPVFNJWkUpIHtcblxuICAgICAgdmFyIGRvdFNpemUgPSB0aGlzLmZyYW1lLmNsaWVudFdpZHRoICogdGhpcy5kb3RTaXplUmF0aW87XG5cbiAgICAgIHZhciB3aWR0aE1pbiwgd2lkdGhNYXg7XG4gICAgICBpZiAodGhpcy5zdHlsZSA9PT0gR3JhcGgzZC5TVFlMRS5ET1RTSVpFKSB7XG4gICAgICAgIHdpZHRoTWluID0gZG90U2l6ZSAvIDI7IC8vIHB4XG4gICAgICAgIHdpZHRoTWF4ID0gZG90U2l6ZSAvIDIgKyBkb3RTaXplICogMjsgLy8gVG9kbzogcHV0IHRoaXMgaW4gb25lIGZ1bmN0aW9uXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdpZHRoTWluID0gMjA7IC8vIHB4XG4gICAgICAgICAgd2lkdGhNYXggPSAyMDsgLy8gcHhcbiAgICAgICAgfVxuXG4gICAgICB2YXIgaGVpZ2h0ID0gTWF0aC5tYXgodGhpcy5mcmFtZS5jbGllbnRIZWlnaHQgKiAwLjI1LCAxMDApO1xuICAgICAgdmFyIHRvcCA9IHRoaXMubWFyZ2luO1xuICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5mcmFtZS5jbGllbnRXaWR0aCAtIHRoaXMubWFyZ2luO1xuICAgICAgdmFyIGxlZnQgPSByaWdodCAtIHdpZHRoTWF4O1xuICAgICAgdmFyIGJvdHRvbSA9IHRvcCArIGhlaWdodDtcbiAgICB9XG5cbiAgICB2YXIgY2FudmFzID0gdGhpcy5mcmFtZS5jYW52YXM7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgIGN0eC5mb250ID0gJzE0cHggYXJpYWwnOyAvLyBUT0RPOiBwdXQgaW4gb3B0aW9uc1xuXG4gICAgaWYgKHRoaXMuc3R5bGUgPT09IEdyYXBoM2QuU1RZTEUuRE9UQ09MT1IpIHtcbiAgICAgIC8vIGRyYXcgdGhlIGNvbG9yIGJhclxuICAgICAgdmFyIHltaW4gPSAwO1xuICAgICAgdmFyIHltYXggPSBoZWlnaHQ7IC8vIFRvZG86IG1ha2UgaGVpZ2h0IGN1c3RvbWl6YWJsZVxuICAgICAgZm9yICh5ID0geW1pbjsgeSA8IHltYXg7IHkrKykge1xuICAgICAgICB2YXIgZiA9ICh5IC0geW1pbikgLyAoeW1heCAtIHltaW4pO1xuXG4gICAgICAgIC8vdmFyIHdpZHRoID0gKGRvdFNpemUgLyAyICsgKDEtZikgKiBkb3RTaXplICogMik7IC8vIFRvZG86IHB1dCB0aGlzIGluIG9uZSBmdW5jdGlvblxuICAgICAgICB2YXIgaHVlID0gZiAqIDI0MDtcbiAgICAgICAgdmFyIGNvbG9yID0gdGhpcy5faHN2MnJnYihodWUsIDEsIDEpO1xuXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8obGVmdCwgdG9wICsgeSk7XG4gICAgICAgIGN0eC5saW5lVG8ocmlnaHQsIHRvcCArIHkpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuYXhpc0NvbG9yO1xuICAgICAgY3R4LnN0cm9rZVJlY3QobGVmdCwgdG9wLCB3aWR0aE1heCwgaGVpZ2h0KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdHlsZSA9PT0gR3JhcGgzZC5TVFlMRS5ET1RTSVpFKSB7XG4gICAgICAvLyBkcmF3IGJvcmRlciBhcm91bmQgY29sb3IgYmFyXG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmF4aXNDb2xvcjtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmRhdGFDb2xvci5maWxsO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyhsZWZ0LCB0b3ApO1xuICAgICAgY3R4LmxpbmVUbyhyaWdodCwgdG9wKTtcbiAgICAgIGN0eC5saW5lVG8ocmlnaHQgLSB3aWR0aE1heCArIHdpZHRoTWluLCBib3R0b20pO1xuICAgICAgY3R4LmxpbmVUbyhsZWZ0LCBib3R0b20pO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdHlsZSA9PT0gR3JhcGgzZC5TVFlMRS5ET1RDT0xPUiB8fCB0aGlzLnN0eWxlID09PSBHcmFwaDNkLlNUWUxFLkRPVFNJWkUpIHtcbiAgICAgIC8vIHByaW50IHZhbHVlcyBhbG9uZyB0aGUgY29sb3IgYmFyXG4gICAgICB2YXIgZ3JpZExpbmVMZW4gPSA1OyAvLyBweFxuICAgICAgdmFyIHN0ZXAgPSBuZXcgU3RlcE51bWJlcih0aGlzLnZhbHVlTWluLCB0aGlzLnZhbHVlTWF4LCAodGhpcy52YWx1ZU1heCAtIHRoaXMudmFsdWVNaW4pIC8gNSwgdHJ1ZSk7XG4gICAgICBzdGVwLnN0YXJ0KCk7XG4gICAgICBpZiAoc3RlcC5nZXRDdXJyZW50KCkgPCB0aGlzLnZhbHVlTWluKSB7XG4gICAgICAgIHN0ZXAubmV4dCgpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCFzdGVwLmVuZCgpKSB7XG4gICAgICAgIHkgPSBib3R0b20gLSAoc3RlcC5nZXRDdXJyZW50KCkgLSB0aGlzLnZhbHVlTWluKSAvICh0aGlzLnZhbHVlTWF4IC0gdGhpcy52YWx1ZU1pbikgKiBoZWlnaHQ7XG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKGxlZnQgLSBncmlkTGluZUxlbiwgeSk7XG4gICAgICAgIGN0eC5saW5lVG8obGVmdCwgeSk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgICBjdHgudGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5heGlzQ29sb3I7XG4gICAgICAgIGN0eC5maWxsVGV4dChzdGVwLmdldEN1cnJlbnQoKSwgbGVmdCAtIDIgKiBncmlkTGluZUxlbiwgeSk7XG5cbiAgICAgICAgc3RlcC5uZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC50ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICd0b3AnO1xuICAgICAgdmFyIGxhYmVsID0gdGhpcy5sZWdlbmRMYWJlbDtcbiAgICAgIGN0eC5maWxsVGV4dChsYWJlbCwgcmlnaHQsIGJvdHRvbSArIHRoaXMubWFyZ2luKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlZHJhdyB0aGUgZmlsdGVyXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5fcmVkcmF3RmlsdGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnJhbWUuZmlsdGVyLmlubmVySFRNTCA9ICcnO1xuXG4gICAgaWYgKHRoaXMuZGF0YUZpbHRlcikge1xuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICd2aXNpYmxlJzogdGhpcy5zaG93QW5pbWF0aW9uQ29udHJvbHNcbiAgICAgIH07XG4gICAgICB2YXIgc2xpZGVyID0gbmV3IFNsaWRlcih0aGlzLmZyYW1lLmZpbHRlciwgb3B0aW9ucyk7XG4gICAgICB0aGlzLmZyYW1lLmZpbHRlci5zbGlkZXIgPSBzbGlkZXI7XG5cbiAgICAgIC8vIFRPRE86IGNzcyBoZXJlIGlzIG5vdCBuaWNlIGhlcmUuLi5cbiAgICAgIHRoaXMuZnJhbWUuZmlsdGVyLnN0eWxlLnBhZGRpbmcgPSAnMTBweCc7XG4gICAgICAvL3RoaXMuZnJhbWUuZmlsdGVyLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcjRUZFRkVGJztcblxuICAgICAgc2xpZGVyLnNldFZhbHVlcyh0aGlzLmRhdGFGaWx0ZXIudmFsdWVzKTtcbiAgICAgIHNsaWRlci5zZXRQbGF5SW50ZXJ2YWwodGhpcy5hbmltYXRpb25JbnRlcnZhbCk7XG5cbiAgICAgIC8vIGNyZWF0ZSBhbiBldmVudCBoYW5kbGVyXG4gICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgdmFyIG9uY2hhbmdlID0gZnVuY3Rpb24gb25jaGFuZ2UoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHNsaWRlci5nZXRJbmRleCgpO1xuXG4gICAgICAgIG1lLmRhdGFGaWx0ZXIuc2VsZWN0VmFsdWUoaW5kZXgpO1xuICAgICAgICBtZS5kYXRhUG9pbnRzID0gbWUuZGF0YUZpbHRlci5fZ2V0RGF0YVBvaW50cygpO1xuXG4gICAgICAgIG1lLnJlZHJhdygpO1xuICAgICAgfTtcbiAgICAgIHNsaWRlci5zZXRPbkNoYW5nZUNhbGxiYWNrKG9uY2hhbmdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mcmFtZS5maWx0ZXIuc2xpZGVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVkcmF3IHRoZSBzbGlkZXJcbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLl9yZWRyYXdTbGlkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZnJhbWUuZmlsdGVyLnNsaWRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmZyYW1lLmZpbHRlci5zbGlkZXIucmVkcmF3KCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZWRyYXcgY29tbW9uIGluZm9ybWF0aW9uXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5fcmVkcmF3SW5mbyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5kYXRhRmlsdGVyKSB7XG4gICAgICB2YXIgY2FudmFzID0gdGhpcy5mcmFtZS5jYW52YXM7XG4gICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgIGN0eC5mb250ID0gJzE0cHggYXJpYWwnOyAvLyBUT0RPOiBwdXQgaW4gb3B0aW9uc1xuICAgICAgY3R4LmxpbmVTdHlsZSA9ICdncmF5JztcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAnZ3JheSc7XG4gICAgICBjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICd0b3AnO1xuXG4gICAgICB2YXIgeCA9IHRoaXMubWFyZ2luO1xuICAgICAgdmFyIHkgPSB0aGlzLm1hcmdpbjtcbiAgICAgIGN0eC5maWxsVGV4dCh0aGlzLmRhdGFGaWx0ZXIuZ2V0TGFiZWwoKSArICc6ICcgKyB0aGlzLmRhdGFGaWx0ZXIuZ2V0U2VsZWN0ZWRWYWx1ZSgpLCB4LCB5KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlZHJhdyB0aGUgYXhpc1xuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX3JlZHJhd0F4aXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhbnZhcyA9IHRoaXMuZnJhbWUuY2FudmFzLFxuICAgICAgICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgICAgZnJvbSxcbiAgICAgICAgdG8sXG4gICAgICAgIHN0ZXAsXG4gICAgICAgIHByZXR0eVN0ZXAsXG4gICAgICAgIHRleHQsXG4gICAgICAgIHhUZXh0LFxuICAgICAgICB5VGV4dCxcbiAgICAgICAgelRleHQsXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgeE9mZnNldCxcbiAgICAgICAgeU9mZnNldCxcbiAgICAgICAgeE1pbjJkLFxuICAgICAgICB4TWF4MmQ7XG5cbiAgICAvLyBUT0RPOiBnZXQgdGhlIGFjdHVhbCByZW5kZXJlZCBzdHlsZSBvZiB0aGUgY29udGFpbmVyRWxlbWVudFxuICAgIC8vY3R4LmZvbnQgPSB0aGlzLmNvbnRhaW5lckVsZW1lbnQuc3R5bGUuZm9udDtcbiAgICBjdHguZm9udCA9IDI0IC8gdGhpcy5jYW1lcmEuZ2V0QXJtTGVuZ3RoKCkgKyAncHggYXJpYWwnO1xuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBsZW5ndGggZm9yIHRoZSBzaG9ydCBncmlkIGxpbmVzXG4gICAgdmFyIGdyaWRMZW5YID0gMC4wMjUgLyB0aGlzLnNjYWxlLng7XG4gICAgdmFyIGdyaWRMZW5ZID0gMC4wMjUgLyB0aGlzLnNjYWxlLnk7XG4gICAgdmFyIHRleHRNYXJnaW4gPSA1IC8gdGhpcy5jYW1lcmEuZ2V0QXJtTGVuZ3RoKCk7IC8vIHB4XG4gICAgdmFyIGFybUFuZ2xlID0gdGhpcy5jYW1lcmEuZ2V0QXJtUm90YXRpb24oKS5ob3Jpem9udGFsO1xuXG4gICAgLy8gZHJhdyB4LWdyaWQgbGluZXNcbiAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICBwcmV0dHlTdGVwID0gdGhpcy5kZWZhdWx0WFN0ZXAgPT09IHVuZGVmaW5lZDtcbiAgICBzdGVwID0gbmV3IFN0ZXBOdW1iZXIodGhpcy54TWluLCB0aGlzLnhNYXgsIHRoaXMueFN0ZXAsIHByZXR0eVN0ZXApO1xuICAgIHN0ZXAuc3RhcnQoKTtcbiAgICBpZiAoc3RlcC5nZXRDdXJyZW50KCkgPCB0aGlzLnhNaW4pIHtcbiAgICAgIHN0ZXAubmV4dCgpO1xuICAgIH1cbiAgICB3aGlsZSAoIXN0ZXAuZW5kKCkpIHtcbiAgICAgIHZhciB4ID0gc3RlcC5nZXRDdXJyZW50KCk7XG5cbiAgICAgIGlmICh0aGlzLnNob3dHcmlkKSB7XG4gICAgICAgIGZyb20gPSB0aGlzLl9jb252ZXJ0M0R0bzJEKG5ldyBQb2ludDNkKHgsIHRoaXMueU1pbiwgdGhpcy56TWluKSk7XG4gICAgICAgIHRvID0gdGhpcy5fY29udmVydDNEdG8yRChuZXcgUG9pbnQzZCh4LCB0aGlzLnlNYXgsIHRoaXMuek1pbikpO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmdyaWRDb2xvcjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKGZyb20ueCwgZnJvbS55KTtcbiAgICAgICAgY3R4LmxpbmVUbyh0by54LCB0by55KTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJvbSA9IHRoaXMuX2NvbnZlcnQzRHRvMkQobmV3IFBvaW50M2QoeCwgdGhpcy55TWluLCB0aGlzLnpNaW4pKTtcbiAgICAgICAgdG8gPSB0aGlzLl9jb252ZXJ0M0R0bzJEKG5ldyBQb2ludDNkKHgsIHRoaXMueU1pbiArIGdyaWRMZW5YLCB0aGlzLnpNaW4pKTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5heGlzQ29sb3I7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhmcm9tLngsIGZyb20ueSk7XG4gICAgICAgIGN0eC5saW5lVG8odG8ueCwgdG8ueSk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgICBmcm9tID0gdGhpcy5fY29udmVydDNEdG8yRChuZXcgUG9pbnQzZCh4LCB0aGlzLnlNYXgsIHRoaXMuek1pbikpO1xuICAgICAgICB0byA9IHRoaXMuX2NvbnZlcnQzRHRvMkQobmV3IFBvaW50M2QoeCwgdGhpcy55TWF4IC0gZ3JpZExlblgsIHRoaXMuek1pbikpO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmF4aXNDb2xvcjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKGZyb20ueCwgZnJvbS55KTtcbiAgICAgICAgY3R4LmxpbmVUbyh0by54LCB0by55KTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfVxuXG4gICAgICB5VGV4dCA9IE1hdGguY29zKGFybUFuZ2xlKSA+IDAgPyB0aGlzLnlNaW4gOiB0aGlzLnlNYXg7XG4gICAgICB0ZXh0ID0gdGhpcy5fY29udmVydDNEdG8yRChuZXcgUG9pbnQzZCh4LCB5VGV4dCwgdGhpcy56TWluKSk7XG4gICAgICBpZiAoTWF0aC5jb3MoYXJtQW5nbGUgKiAyKSA+IDApIHtcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ3RvcCc7XG4gICAgICAgIHRleHQueSArPSB0ZXh0TWFyZ2luO1xuICAgICAgfSBlbHNlIGlmIChNYXRoLnNpbihhcm1BbmdsZSAqIDIpIDwgMCkge1xuICAgICAgICBjdHgudGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgfVxuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuYXhpc0NvbG9yO1xuICAgICAgY3R4LmZpbGxUZXh0KCcgICcgKyB0aGlzLnhWYWx1ZUxhYmVsKHN0ZXAuZ2V0Q3VycmVudCgpKSArICcgICcsIHRleHQueCwgdGV4dC55KTtcblxuICAgICAgc3RlcC5uZXh0KCk7XG4gICAgfVxuXG4gICAgLy8gZHJhdyB5LWdyaWQgbGluZXNcbiAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICBwcmV0dHlTdGVwID0gdGhpcy5kZWZhdWx0WVN0ZXAgPT09IHVuZGVmaW5lZDtcbiAgICBzdGVwID0gbmV3IFN0ZXBOdW1iZXIodGhpcy55TWluLCB0aGlzLnlNYXgsIHRoaXMueVN0ZXAsIHByZXR0eVN0ZXApO1xuICAgIHN0ZXAuc3RhcnQoKTtcbiAgICBpZiAoc3RlcC5nZXRDdXJyZW50KCkgPCB0aGlzLnlNaW4pIHtcbiAgICAgIHN0ZXAubmV4dCgpO1xuICAgIH1cbiAgICB3aGlsZSAoIXN0ZXAuZW5kKCkpIHtcbiAgICAgIGlmICh0aGlzLnNob3dHcmlkKSB7XG4gICAgICAgIGZyb20gPSB0aGlzLl9jb252ZXJ0M0R0bzJEKG5ldyBQb2ludDNkKHRoaXMueE1pbiwgc3RlcC5nZXRDdXJyZW50KCksIHRoaXMuek1pbikpO1xuICAgICAgICB0byA9IHRoaXMuX2NvbnZlcnQzRHRvMkQobmV3IFBvaW50M2QodGhpcy54TWF4LCBzdGVwLmdldEN1cnJlbnQoKSwgdGhpcy56TWluKSk7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuZ3JpZENvbG9yO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8oZnJvbS54LCBmcm9tLnkpO1xuICAgICAgICBjdHgubGluZVRvKHRvLngsIHRvLnkpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcm9tID0gdGhpcy5fY29udmVydDNEdG8yRChuZXcgUG9pbnQzZCh0aGlzLnhNaW4sIHN0ZXAuZ2V0Q3VycmVudCgpLCB0aGlzLnpNaW4pKTtcbiAgICAgICAgdG8gPSB0aGlzLl9jb252ZXJ0M0R0bzJEKG5ldyBQb2ludDNkKHRoaXMueE1pbiArIGdyaWRMZW5ZLCBzdGVwLmdldEN1cnJlbnQoKSwgdGhpcy56TWluKSk7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuYXhpc0NvbG9yO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8oZnJvbS54LCBmcm9tLnkpO1xuICAgICAgICBjdHgubGluZVRvKHRvLngsIHRvLnkpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgZnJvbSA9IHRoaXMuX2NvbnZlcnQzRHRvMkQobmV3IFBvaW50M2QodGhpcy54TWF4LCBzdGVwLmdldEN1cnJlbnQoKSwgdGhpcy56TWluKSk7XG4gICAgICAgIHRvID0gdGhpcy5fY29udmVydDNEdG8yRChuZXcgUG9pbnQzZCh0aGlzLnhNYXggLSBncmlkTGVuWSwgc3RlcC5nZXRDdXJyZW50KCksIHRoaXMuek1pbikpO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmF4aXNDb2xvcjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKGZyb20ueCwgZnJvbS55KTtcbiAgICAgICAgY3R4LmxpbmVUbyh0by54LCB0by55KTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfVxuXG4gICAgICB4VGV4dCA9IE1hdGguc2luKGFybUFuZ2xlKSA+IDAgPyB0aGlzLnhNaW4gOiB0aGlzLnhNYXg7XG4gICAgICB0ZXh0ID0gdGhpcy5fY29udmVydDNEdG8yRChuZXcgUG9pbnQzZCh4VGV4dCwgc3RlcC5nZXRDdXJyZW50KCksIHRoaXMuek1pbikpO1xuICAgICAgaWYgKE1hdGguY29zKGFybUFuZ2xlICogMikgPCAwKSB7XG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICd0b3AnO1xuICAgICAgICB0ZXh0LnkgKz0gdGV4dE1hcmdpbjtcbiAgICAgIH0gZWxzZSBpZiAoTWF0aC5zaW4oYXJtQW5nbGUgKiAyKSA+IDApIHtcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgIH1cbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmF4aXNDb2xvcjtcbiAgICAgIGN0eC5maWxsVGV4dCgnICAnICsgdGhpcy55VmFsdWVMYWJlbChzdGVwLmdldEN1cnJlbnQoKSkgKyAnICAnLCB0ZXh0LngsIHRleHQueSk7XG5cbiAgICAgIHN0ZXAubmV4dCgpO1xuICAgIH1cblxuICAgIC8vIGRyYXcgei1ncmlkIGxpbmVzIGFuZCBheGlzXG4gICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgcHJldHR5U3RlcCA9IHRoaXMuZGVmYXVsdFpTdGVwID09PSB1bmRlZmluZWQ7XG4gICAgc3RlcCA9IG5ldyBTdGVwTnVtYmVyKHRoaXMuek1pbiwgdGhpcy56TWF4LCB0aGlzLnpTdGVwLCBwcmV0dHlTdGVwKTtcbiAgICBzdGVwLnN0YXJ0KCk7XG4gICAgaWYgKHN0ZXAuZ2V0Q3VycmVudCgpIDwgdGhpcy56TWluKSB7XG4gICAgICBzdGVwLm5leHQoKTtcbiAgICB9XG4gICAgeFRleHQgPSBNYXRoLmNvcyhhcm1BbmdsZSkgPiAwID8gdGhpcy54TWluIDogdGhpcy54TWF4O1xuICAgIHlUZXh0ID0gTWF0aC5zaW4oYXJtQW5nbGUpIDwgMCA/IHRoaXMueU1pbiA6IHRoaXMueU1heDtcbiAgICB3aGlsZSAoIXN0ZXAuZW5kKCkpIHtcbiAgICAgIC8vIFRPRE86IG1ha2Ugei1ncmlkIGxpbmVzIHJlYWxseSAzZD9cbiAgICAgIGZyb20gPSB0aGlzLl9jb252ZXJ0M0R0bzJEKG5ldyBQb2ludDNkKHhUZXh0LCB5VGV4dCwgc3RlcC5nZXRDdXJyZW50KCkpKTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuYXhpc0NvbG9yO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyhmcm9tLngsIGZyb20ueSk7XG4gICAgICBjdHgubGluZVRvKGZyb20ueCAtIHRleHRNYXJnaW4sIGZyb20ueSk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgIGN0eC50ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuYXhpc0NvbG9yO1xuICAgICAgY3R4LmZpbGxUZXh0KHRoaXMuelZhbHVlTGFiZWwoc3RlcC5nZXRDdXJyZW50KCkpICsgJyAnLCBmcm9tLnggLSA1LCBmcm9tLnkpO1xuXG4gICAgICBzdGVwLm5leHQoKTtcbiAgICB9XG4gICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgZnJvbSA9IHRoaXMuX2NvbnZlcnQzRHRvMkQobmV3IFBvaW50M2QoeFRleHQsIHlUZXh0LCB0aGlzLnpNaW4pKTtcbiAgICB0byA9IHRoaXMuX2NvbnZlcnQzRHRvMkQobmV3IFBvaW50M2QoeFRleHQsIHlUZXh0LCB0aGlzLnpNYXgpKTtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmF4aXNDb2xvcjtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyhmcm9tLngsIGZyb20ueSk7XG4gICAgY3R4LmxpbmVUbyh0by54LCB0by55KTtcbiAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAvLyBkcmF3IHgtYXhpc1xuICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgIC8vIGxpbmUgYXQgeU1pblxuICAgIHhNaW4yZCA9IHRoaXMuX2NvbnZlcnQzRHRvMkQobmV3IFBvaW50M2QodGhpcy54TWluLCB0aGlzLnlNaW4sIHRoaXMuek1pbikpO1xuICAgIHhNYXgyZCA9IHRoaXMuX2NvbnZlcnQzRHRvMkQobmV3IFBvaW50M2QodGhpcy54TWF4LCB0aGlzLnlNaW4sIHRoaXMuek1pbikpO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuYXhpc0NvbG9yO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubW92ZVRvKHhNaW4yZC54LCB4TWluMmQueSk7XG4gICAgY3R4LmxpbmVUbyh4TWF4MmQueCwgeE1heDJkLnkpO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgICAvLyBsaW5lIGF0IHltYXhcbiAgICB4TWluMmQgPSB0aGlzLl9jb252ZXJ0M0R0bzJEKG5ldyBQb2ludDNkKHRoaXMueE1pbiwgdGhpcy55TWF4LCB0aGlzLnpNaW4pKTtcbiAgICB4TWF4MmQgPSB0aGlzLl9jb252ZXJ0M0R0bzJEKG5ldyBQb2ludDNkKHRoaXMueE1heCwgdGhpcy55TWF4LCB0aGlzLnpNaW4pKTtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmF4aXNDb2xvcjtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyh4TWluMmQueCwgeE1pbjJkLnkpO1xuICAgIGN0eC5saW5lVG8oeE1heDJkLngsIHhNYXgyZC55KTtcbiAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAvLyBkcmF3IHktYXhpc1xuICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgIC8vIGxpbmUgYXQgeE1pblxuICAgIGZyb20gPSB0aGlzLl9jb252ZXJ0M0R0bzJEKG5ldyBQb2ludDNkKHRoaXMueE1pbiwgdGhpcy55TWluLCB0aGlzLnpNaW4pKTtcbiAgICB0byA9IHRoaXMuX2NvbnZlcnQzRHRvMkQobmV3IFBvaW50M2QodGhpcy54TWluLCB0aGlzLnlNYXgsIHRoaXMuek1pbikpO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuYXhpc0NvbG9yO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubW92ZVRvKGZyb20ueCwgZnJvbS55KTtcbiAgICBjdHgubGluZVRvKHRvLngsIHRvLnkpO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgICAvLyBsaW5lIGF0IHhNYXhcbiAgICBmcm9tID0gdGhpcy5fY29udmVydDNEdG8yRChuZXcgUG9pbnQzZCh0aGlzLnhNYXgsIHRoaXMueU1pbiwgdGhpcy56TWluKSk7XG4gICAgdG8gPSB0aGlzLl9jb252ZXJ0M0R0bzJEKG5ldyBQb2ludDNkKHRoaXMueE1heCwgdGhpcy55TWF4LCB0aGlzLnpNaW4pKTtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmF4aXNDb2xvcjtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyhmcm9tLngsIGZyb20ueSk7XG4gICAgY3R4LmxpbmVUbyh0by54LCB0by55KTtcbiAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAvLyBkcmF3IHgtbGFiZWxcbiAgICB2YXIgeExhYmVsID0gdGhpcy54TGFiZWw7XG4gICAgaWYgKHhMYWJlbC5sZW5ndGggPiAwKSB7XG4gICAgICB5T2Zmc2V0ID0gMC4xIC8gdGhpcy5zY2FsZS55O1xuICAgICAgeFRleHQgPSAodGhpcy54TWluICsgdGhpcy54TWF4KSAvIDI7XG4gICAgICB5VGV4dCA9IE1hdGguY29zKGFybUFuZ2xlKSA+IDAgPyB0aGlzLnlNaW4gLSB5T2Zmc2V0IDogdGhpcy55TWF4ICsgeU9mZnNldDtcbiAgICAgIHRleHQgPSB0aGlzLl9jb252ZXJ0M0R0bzJEKG5ldyBQb2ludDNkKHhUZXh0LCB5VGV4dCwgdGhpcy56TWluKSk7XG4gICAgICBpZiAoTWF0aC5jb3MoYXJtQW5nbGUgKiAyKSA+IDApIHtcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ3RvcCc7XG4gICAgICB9IGVsc2UgaWYgKE1hdGguc2luKGFybUFuZ2xlICogMikgPCAwKSB7XG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICB9XG4gICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5heGlzQ29sb3I7XG4gICAgICBjdHguZmlsbFRleHQoeExhYmVsLCB0ZXh0LngsIHRleHQueSk7XG4gICAgfVxuXG4gICAgLy8gZHJhdyB5LWxhYmVsXG4gICAgdmFyIHlMYWJlbCA9IHRoaXMueUxhYmVsO1xuICAgIGlmICh5TGFiZWwubGVuZ3RoID4gMCkge1xuICAgICAgeE9mZnNldCA9IDAuMSAvIHRoaXMuc2NhbGUueDtcbiAgICAgIHhUZXh0ID0gTWF0aC5zaW4oYXJtQW5nbGUpID4gMCA/IHRoaXMueE1pbiAtIHhPZmZzZXQgOiB0aGlzLnhNYXggKyB4T2Zmc2V0O1xuICAgICAgeVRleHQgPSAodGhpcy55TWluICsgdGhpcy55TWF4KSAvIDI7XG4gICAgICB0ZXh0ID0gdGhpcy5fY29udmVydDNEdG8yRChuZXcgUG9pbnQzZCh4VGV4dCwgeVRleHQsIHRoaXMuek1pbikpO1xuICAgICAgaWYgKE1hdGguY29zKGFybUFuZ2xlICogMikgPCAwKSB7XG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICd0b3AnO1xuICAgICAgfSBlbHNlIGlmIChNYXRoLnNpbihhcm1BbmdsZSAqIDIpID4gMCkge1xuICAgICAgICBjdHgudGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgfVxuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuYXhpc0NvbG9yO1xuICAgICAgY3R4LmZpbGxUZXh0KHlMYWJlbCwgdGV4dC54LCB0ZXh0LnkpO1xuICAgIH1cblxuICAgIC8vIGRyYXcgei1sYWJlbFxuICAgIHZhciB6TGFiZWwgPSB0aGlzLnpMYWJlbDtcbiAgICBpZiAoekxhYmVsLmxlbmd0aCA+IDApIHtcbiAgICAgIG9mZnNldCA9IDMwOyAvLyBwaXhlbHMuICAvLyBUT0RPOiByZWxhdGUgdG8gdGhlIG1heCB3aWR0aCBvZiB0aGUgdmFsdWVzIG9uIHRoZSB6IGF4aXM/XG4gICAgICB4VGV4dCA9IE1hdGguY29zKGFybUFuZ2xlKSA+IDAgPyB0aGlzLnhNaW4gOiB0aGlzLnhNYXg7XG4gICAgICB5VGV4dCA9IE1hdGguc2luKGFybUFuZ2xlKSA8IDAgPyB0aGlzLnlNaW4gOiB0aGlzLnlNYXg7XG4gICAgICB6VGV4dCA9ICh0aGlzLnpNaW4gKyB0aGlzLnpNYXgpIC8gMjtcbiAgICAgIHRleHQgPSB0aGlzLl9jb252ZXJ0M0R0bzJEKG5ldyBQb2ludDNkKHhUZXh0LCB5VGV4dCwgelRleHQpKTtcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuYXhpc0NvbG9yO1xuICAgICAgY3R4LmZpbGxUZXh0KHpMYWJlbCwgdGV4dC54IC0gb2Zmc2V0LCB0ZXh0LnkpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBjb2xvciBiYXNlZCBvbiB0aGUgZ2l2ZW4gdmFsdWUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBIICAgSHVlLCBhIHZhbHVlIGJlIGJldHdlZW4gMCBhbmQgMzYwXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBTICAgU2F0dXJhdGlvbiwgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDFcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFYgICBWYWx1ZSwgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDFcbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLl9oc3YycmdiID0gZnVuY3Rpb24gKEgsIFMsIFYpIHtcbiAgICB2YXIgUiwgRywgQiwgQywgSGksIFg7XG5cbiAgICBDID0gViAqIFM7XG4gICAgSGkgPSBNYXRoLmZsb29yKEggLyA2MCk7IC8vIGhpID0gMCwxLDIsMyw0LDVcbiAgICBYID0gQyAqICgxIC0gTWF0aC5hYnMoSCAvIDYwICUgMiAtIDEpKTtcblxuICAgIHN3aXRjaCAoSGkpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgUiA9IEM7RyA9IFg7QiA9IDA7YnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIFIgPSBYO0cgPSBDO0IgPSAwO2JyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBSID0gMDtHID0gQztCID0gWDticmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgUiA9IDA7RyA9IFg7QiA9IEM7YnJlYWs7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIFIgPSBYO0cgPSAwO0IgPSBDO2JyZWFrO1xuICAgICAgY2FzZSA1OlxuICAgICAgICBSID0gQztHID0gMDtCID0gWDticmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgUiA9IDA7RyA9IDA7QiA9IDA7YnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuICdSR0IoJyArIHBhcnNlSW50KFIgKiAyNTUpICsgJywnICsgcGFyc2VJbnQoRyAqIDI1NSkgKyAnLCcgKyBwYXJzZUludChCICogMjU1KSArICcpJztcbiAgfTtcblxuICAvKipcbiAgICogRHJhdyBhbGwgZGF0YXBvaW50cyBhcyBhIGdyaWRcbiAgICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgdXNlZCB3aGVuIHRoZSBzdHlsZSBpcyAnZ3JpZCdcbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLl9yZWRyYXdEYXRhR3JpZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FudmFzID0gdGhpcy5mcmFtZS5jYW52YXMsXG4gICAgICAgIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLFxuICAgICAgICBwb2ludCxcbiAgICAgICAgcmlnaHQsXG4gICAgICAgIHRvcCxcbiAgICAgICAgY3Jvc3MsXG4gICAgICAgIGksXG4gICAgICAgIHRvcFNpZGVWaXNpYmxlLFxuICAgICAgICBmaWxsU3R5bGUsXG4gICAgICAgIHN0cm9rZVN0eWxlLFxuICAgICAgICBsaW5lV2lkdGgsXG4gICAgICAgIGgsXG4gICAgICAgIHMsXG4gICAgICAgIHYsXG4gICAgICAgIHpBdmc7XG5cbiAgICBjdHgubGluZUpvaW4gPSAncm91bmQnO1xuICAgIGN0eC5saW5lQ2FwID0gJ3JvdW5kJztcblxuICAgIGlmICh0aGlzLmRhdGFQb2ludHMgPT09IHVuZGVmaW5lZCB8fCB0aGlzLmRhdGFQb2ludHMubGVuZ3RoIDw9IDApIHJldHVybjsgLy8gVE9ETzogdGhyb3cgZXhjZXB0aW9uP1xuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSB0cmFuc2xhdGlvbnMgYW5kIHNjcmVlbiBwb3NpdGlvbiBvZiBhbGwgcG9pbnRzXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZGF0YVBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRyYW5zID0gdGhpcy5fY29udmVydFBvaW50VG9UcmFuc2xhdGlvbih0aGlzLmRhdGFQb2ludHNbaV0ucG9pbnQpO1xuICAgICAgdmFyIHNjcmVlbiA9IHRoaXMuX2NvbnZlcnRUcmFuc2xhdGlvblRvU2NyZWVuKHRyYW5zKTtcblxuICAgICAgdGhpcy5kYXRhUG9pbnRzW2ldLnRyYW5zID0gdHJhbnM7XG4gICAgICB0aGlzLmRhdGFQb2ludHNbaV0uc2NyZWVuID0gc2NyZWVuO1xuXG4gICAgICAvLyBjYWxjdWxhdGUgdGhlIHRyYW5zbGF0aW9uIG9mIHRoZSBwb2ludCBhdCB0aGUgYm90dG9tIChuZWVkZWQgZm9yIHNvcnRpbmcpXG4gICAgICB2YXIgdHJhbnNCb3R0b20gPSB0aGlzLl9jb252ZXJ0UG9pbnRUb1RyYW5zbGF0aW9uKHRoaXMuZGF0YVBvaW50c1tpXS5ib3R0b20pO1xuICAgICAgdGhpcy5kYXRhUG9pbnRzW2ldLmRpc3QgPSB0aGlzLnNob3dQZXJzcGVjdGl2ZSA/IHRyYW5zQm90dG9tLmxlbmd0aCgpIDogLXRyYW5zQm90dG9tLno7XG4gICAgfVxuXG4gICAgLy8gc29ydCB0aGUgcG9pbnRzIG9uIGRlcHRoIG9mIHRoZWlyICh4LHkpIHBvc2l0aW9uIChub3Qgb24geilcbiAgICB2YXIgc29ydERlcHRoID0gZnVuY3Rpb24gc29ydERlcHRoKGEsIGIpIHtcbiAgICAgIHJldHVybiBiLmRpc3QgLSBhLmRpc3Q7XG4gICAgfTtcbiAgICB0aGlzLmRhdGFQb2ludHMuc29ydChzb3J0RGVwdGgpO1xuXG4gICAgaWYgKHRoaXMuc3R5bGUgPT09IEdyYXBoM2QuU1RZTEUuU1VSRkFDRSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZGF0YVBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwb2ludCA9IHRoaXMuZGF0YVBvaW50c1tpXTtcbiAgICAgICAgcmlnaHQgPSB0aGlzLmRhdGFQb2ludHNbaV0ucG9pbnRSaWdodDtcbiAgICAgICAgdG9wID0gdGhpcy5kYXRhUG9pbnRzW2ldLnBvaW50VG9wO1xuICAgICAgICBjcm9zcyA9IHRoaXMuZGF0YVBvaW50c1tpXS5wb2ludENyb3NzO1xuXG4gICAgICAgIGlmIChwb2ludCAhPT0gdW5kZWZpbmVkICYmIHJpZ2h0ICE9PSB1bmRlZmluZWQgJiYgdG9wICE9PSB1bmRlZmluZWQgJiYgY3Jvc3MgIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgaWYgKHRoaXMuc2hvd0dyYXlCb3R0b20gfHwgdGhpcy5zaG93U2hhZG93KSB7XG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdGhlIHR3byB2ZWN0b3JzIGZyb20gY2VudGVyXG4gICAgICAgICAgICAvLyB0byBsZWZ0IGFuZCByaWdodCwgaW4gb3JkZXIgdG8ga25vdyB3aGV0aGVyIHdlIGFyZSBsb29raW5nIGF0IHRoZVxuICAgICAgICAgICAgLy8gYm90dG9tIG9yIGF0IHRoZSB0b3Agc2lkZS4gV2UgY2FuIGFsc28gdXNlIHRoZSBjcm9zcyBwcm9kdWN0XG4gICAgICAgICAgICAvLyBmb3IgY2FsY3VsYXRpbmcgbGlnaHQgaW50ZW5zaXR5XG4gICAgICAgICAgICB2YXIgYURpZmYgPSBQb2ludDNkLnN1YnRyYWN0KGNyb3NzLnRyYW5zLCBwb2ludC50cmFucyk7XG4gICAgICAgICAgICB2YXIgYkRpZmYgPSBQb2ludDNkLnN1YnRyYWN0KHRvcC50cmFucywgcmlnaHQudHJhbnMpO1xuICAgICAgICAgICAgdmFyIGNyb3NzcHJvZHVjdCA9IFBvaW50M2QuY3Jvc3NQcm9kdWN0KGFEaWZmLCBiRGlmZik7XG4gICAgICAgICAgICB2YXIgbGVuID0gY3Jvc3Nwcm9kdWN0Lmxlbmd0aCgpO1xuICAgICAgICAgICAgLy8gRklYTUU6IHRoZXJlIGlzIGEgYnVnIHdpdGggZGV0ZXJtaW5pbmcgdGhlIHN1cmZhY2Ugc2lkZSAoc2hhZG93IG9yIGNvbG9yZWQpXG5cbiAgICAgICAgICAgIHRvcFNpZGVWaXNpYmxlID0gY3Jvc3Nwcm9kdWN0LnogPiAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b3BTaWRlVmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRvcFNpZGVWaXNpYmxlKSB7XG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgSHVlIGZyb20gdGhlIGN1cnJlbnQgdmFsdWUuIEF0IHpNaW4gdGhlIGh1ZSBpcyAyNDAsIGF0IHpNYXggdGhlIGh1ZSBpcyAwXG4gICAgICAgICAgICB6QXZnID0gKHBvaW50LnBvaW50LnogKyByaWdodC5wb2ludC56ICsgdG9wLnBvaW50LnogKyBjcm9zcy5wb2ludC56KSAvIDQ7XG4gICAgICAgICAgICBoID0gKDEgLSAoekF2ZyAtIHRoaXMuek1pbikgKiB0aGlzLnNjYWxlLnogLyB0aGlzLnZlcnRpY2FsUmF0aW8pICogMjQwO1xuICAgICAgICAgICAgcyA9IDE7IC8vIHNhdHVyYXRpb25cblxuICAgICAgICAgICAgaWYgKHRoaXMuc2hvd1NoYWRvdykge1xuICAgICAgICAgICAgICB2ID0gTWF0aC5taW4oMSArIGNyb3NzcHJvZHVjdC54IC8gbGVuIC8gMiwgMSk7IC8vIHZhbHVlLiBUT0RPOiBzY2FsZVxuICAgICAgICAgICAgICBmaWxsU3R5bGUgPSB0aGlzLl9oc3YycmdiKGgsIHMsIHYpO1xuICAgICAgICAgICAgICBzdHJva2VTdHlsZSA9IGZpbGxTdHlsZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHYgPSAxO1xuICAgICAgICAgICAgICBmaWxsU3R5bGUgPSB0aGlzLl9oc3YycmdiKGgsIHMsIHYpO1xuICAgICAgICAgICAgICBzdHJva2VTdHlsZSA9IHRoaXMuYXhpc0NvbG9yOyAvLyBUT0RPOiBzaG91bGQgYmUgY3VzdG9taXphYmxlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZmlsbFN0eWxlID0gJ2dyYXknO1xuICAgICAgICAgICAgICBzdHJva2VTdHlsZSA9IHRoaXMuYXhpc0NvbG9yO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuX2dldFN0cm9rZVdpZHRoKHBvaW50KTtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbFN0eWxlO1xuICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICBjdHgubW92ZVRvKHBvaW50LnNjcmVlbi54LCBwb2ludC5zY3JlZW4ueSk7XG4gICAgICAgICAgY3R4LmxpbmVUbyhyaWdodC5zY3JlZW4ueCwgcmlnaHQuc2NyZWVuLnkpO1xuICAgICAgICAgIGN0eC5saW5lVG8oY3Jvc3Muc2NyZWVuLngsIGNyb3NzLnNjcmVlbi55KTtcbiAgICAgICAgICBjdHgubGluZVRvKHRvcC5zY3JlZW4ueCwgdG9wLnNjcmVlbi55KTtcbiAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICBjdHguc3Ryb2tlKCk7IC8vIFRPRE86IG9ubHkgZHJhdyBzdHJva2Ugd2hlbiBzdHJva2VXaWR0aCA+IDBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGdyaWQgc3R5bGVcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZGF0YVBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHBvaW50ID0gdGhpcy5kYXRhUG9pbnRzW2ldO1xuICAgICAgICAgIHJpZ2h0ID0gdGhpcy5kYXRhUG9pbnRzW2ldLnBvaW50UmlnaHQ7XG4gICAgICAgICAgdG9wID0gdGhpcy5kYXRhUG9pbnRzW2ldLnBvaW50VG9wO1xuXG4gICAgICAgICAgaWYgKHBvaW50ICE9PSB1bmRlZmluZWQgJiYgcmlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIEh1ZSBmcm9tIHRoZSBjdXJyZW50IHZhbHVlLiBBdCB6TWluIHRoZSBodWUgaXMgMjQwLCBhdCB6TWF4IHRoZSBodWUgaXMgMFxuICAgICAgICAgICAgekF2ZyA9IChwb2ludC5wb2ludC56ICsgcmlnaHQucG9pbnQueikgLyAyO1xuICAgICAgICAgICAgaCA9ICgxIC0gKHpBdmcgLSB0aGlzLnpNaW4pICogdGhpcy5zY2FsZS56IC8gdGhpcy52ZXJ0aWNhbFJhdGlvKSAqIDI0MDtcblxuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuX2dldFN0cm9rZVdpZHRoKHBvaW50KSAqIDI7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLl9oc3YycmdiKGgsIDEsIDEpO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyhwb2ludC5zY3JlZW4ueCwgcG9pbnQuc2NyZWVuLnkpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhyaWdodC5zY3JlZW4ueCwgcmlnaHQuc2NyZWVuLnkpO1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwb2ludCAhPT0gdW5kZWZpbmVkICYmIHRvcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgSHVlIGZyb20gdGhlIGN1cnJlbnQgdmFsdWUuIEF0IHpNaW4gdGhlIGh1ZSBpcyAyNDAsIGF0IHpNYXggdGhlIGh1ZSBpcyAwXG4gICAgICAgICAgICB6QXZnID0gKHBvaW50LnBvaW50LnogKyB0b3AucG9pbnQueikgLyAyO1xuICAgICAgICAgICAgaCA9ICgxIC0gKHpBdmcgLSB0aGlzLnpNaW4pICogdGhpcy5zY2FsZS56IC8gdGhpcy52ZXJ0aWNhbFJhdGlvKSAqIDI0MDtcblxuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuX2dldFN0cm9rZVdpZHRoKHBvaW50KSAqIDI7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLl9oc3YycmdiKGgsIDEsIDEpO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyhwb2ludC5zY3JlZW4ueCwgcG9pbnQuc2NyZWVuLnkpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh0b3Auc2NyZWVuLngsIHRvcC5zY3JlZW4ueSk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gIH07XG5cbiAgR3JhcGgzZC5wcm90b3R5cGUuX2dldFN0cm9rZVdpZHRoID0gZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgaWYgKHBvaW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0aGlzLnNob3dQZXJzcGVjdGl2ZSkge1xuICAgICAgICByZXR1cm4gMSAvIC1wb2ludC50cmFucy56ICogdGhpcy5kYXRhQ29sb3Iuc3Ryb2tlV2lkdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gLSh0aGlzLmV5ZS56IC8gdGhpcy5jYW1lcmEuZ2V0QXJtTGVuZ3RoKCkpICogdGhpcy5kYXRhQ29sb3Iuc3Ryb2tlV2lkdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZGF0YUNvbG9yLnN0cm9rZVdpZHRoO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEcmF3IGFsbCBkYXRhcG9pbnRzIGFzIGRvdHMuXG4gICAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgd2hlbiB0aGUgc3R5bGUgaXMgJ2RvdCcgb3IgJ2RvdC1saW5lJ1xuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX3JlZHJhd0RhdGFEb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhbnZhcyA9IHRoaXMuZnJhbWUuY2FudmFzO1xuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB2YXIgaTtcblxuICAgIGlmICh0aGlzLmRhdGFQb2ludHMgPT09IHVuZGVmaW5lZCB8fCB0aGlzLmRhdGFQb2ludHMubGVuZ3RoIDw9IDApIHJldHVybjsgLy8gVE9ETzogdGhyb3cgZXhjZXB0aW9uP1xuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSB0cmFuc2xhdGlvbnMgb2YgYWxsIHBvaW50c1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmRhdGFQb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0cmFucyA9IHRoaXMuX2NvbnZlcnRQb2ludFRvVHJhbnNsYXRpb24odGhpcy5kYXRhUG9pbnRzW2ldLnBvaW50KTtcbiAgICAgIHZhciBzY3JlZW4gPSB0aGlzLl9jb252ZXJ0VHJhbnNsYXRpb25Ub1NjcmVlbih0cmFucyk7XG4gICAgICB0aGlzLmRhdGFQb2ludHNbaV0udHJhbnMgPSB0cmFucztcbiAgICAgIHRoaXMuZGF0YVBvaW50c1tpXS5zY3JlZW4gPSBzY3JlZW47XG5cbiAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgcG9pbnQgYXQgdGhlIGJvdHRvbSB0byB0aGUgY2FtZXJhXG4gICAgICB2YXIgdHJhbnNCb3R0b20gPSB0aGlzLl9jb252ZXJ0UG9pbnRUb1RyYW5zbGF0aW9uKHRoaXMuZGF0YVBvaW50c1tpXS5ib3R0b20pO1xuICAgICAgdGhpcy5kYXRhUG9pbnRzW2ldLmRpc3QgPSB0aGlzLnNob3dQZXJzcGVjdGl2ZSA/IHRyYW5zQm90dG9tLmxlbmd0aCgpIDogLXRyYW5zQm90dG9tLno7XG4gICAgfVxuXG4gICAgLy8gb3JkZXIgdGhlIHRyYW5zbGF0ZWQgcG9pbnRzIGJ5IGRlcHRoXG4gICAgdmFyIHNvcnREZXB0aCA9IGZ1bmN0aW9uIHNvcnREZXB0aChhLCBiKSB7XG4gICAgICByZXR1cm4gYi5kaXN0IC0gYS5kaXN0O1xuICAgIH07XG4gICAgdGhpcy5kYXRhUG9pbnRzLnNvcnQoc29ydERlcHRoKTtcblxuICAgIC8vIGRyYXcgdGhlIGRhdGFwb2ludHMgYXMgY29sb3JlZCBjaXJjbGVzXG4gICAgdmFyIGRvdFNpemUgPSB0aGlzLmZyYW1lLmNsaWVudFdpZHRoICogdGhpcy5kb3RTaXplUmF0aW87IC8vIHB4XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZGF0YVBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHBvaW50ID0gdGhpcy5kYXRhUG9pbnRzW2ldO1xuXG4gICAgICBpZiAodGhpcy5zdHlsZSA9PT0gR3JhcGgzZC5TVFlMRS5ET1RMSU5FKSB7XG4gICAgICAgIC8vIGRyYXcgYSB2ZXJ0aWNhbCBsaW5lIGZyb20gdGhlIGJvdHRvbSB0byB0aGUgZ3JhcGggdmFsdWVcbiAgICAgICAgLy92YXIgZnJvbSA9IHRoaXMuX2NvbnZlcnQzRHRvMkQobmV3IFBvaW50M2QocG9pbnQucG9pbnQueCwgcG9pbnQucG9pbnQueSwgdGhpcy56TWluKSk7XG4gICAgICAgIHZhciBmcm9tID0gdGhpcy5fY29udmVydDNEdG8yRChwb2ludC5ib3R0b20pO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5ncmlkQ29sb3I7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhmcm9tLngsIGZyb20ueSk7XG4gICAgICAgIGN0eC5saW5lVG8ocG9pbnQuc2NyZWVuLngsIHBvaW50LnNjcmVlbi55KTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBjYWxjdWxhdGUgcmFkaXVzIGZvciB0aGUgY2lyY2xlXG4gICAgICB2YXIgc2l6ZTtcbiAgICAgIGlmICh0aGlzLnN0eWxlID09PSBHcmFwaDNkLlNUWUxFLkRPVFNJWkUpIHtcbiAgICAgICAgc2l6ZSA9IGRvdFNpemUgLyAyICsgMiAqIGRvdFNpemUgKiAocG9pbnQucG9pbnQudmFsdWUgLSB0aGlzLnZhbHVlTWluKSAvICh0aGlzLnZhbHVlTWF4IC0gdGhpcy52YWx1ZU1pbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaXplID0gZG90U2l6ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJhZGl1cztcbiAgICAgIGlmICh0aGlzLnNob3dQZXJzcGVjdGl2ZSkge1xuICAgICAgICByYWRpdXMgPSBzaXplIC8gLXBvaW50LnRyYW5zLno7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYWRpdXMgPSBzaXplICogLSh0aGlzLmV5ZS56IC8gdGhpcy5jYW1lcmEuZ2V0QXJtTGVuZ3RoKCkpO1xuICAgICAgfVxuICAgICAgaWYgKHJhZGl1cyA8IDApIHtcbiAgICAgICAgcmFkaXVzID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIGh1ZSwgY29sb3IsIGJvcmRlckNvbG9yO1xuICAgICAgaWYgKHRoaXMuc3R5bGUgPT09IEdyYXBoM2QuU1RZTEUuRE9UQ09MT1IpIHtcbiAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBjb2xvciBiYXNlZCBvbiB0aGUgdmFsdWVcbiAgICAgICAgaHVlID0gKDEgLSAocG9pbnQucG9pbnQudmFsdWUgLSB0aGlzLnZhbHVlTWluKSAqIHRoaXMuc2NhbGUudmFsdWUpICogMjQwO1xuICAgICAgICBjb2xvciA9IHRoaXMuX2hzdjJyZ2IoaHVlLCAxLCAxKTtcbiAgICAgICAgYm9yZGVyQ29sb3IgPSB0aGlzLl9oc3YycmdiKGh1ZSwgMSwgMC44KTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5zdHlsZSA9PT0gR3JhcGgzZC5TVFlMRS5ET1RTSVpFKSB7XG4gICAgICAgIGNvbG9yID0gdGhpcy5kYXRhQ29sb3IuZmlsbDtcbiAgICAgICAgYm9yZGVyQ29sb3IgPSB0aGlzLmRhdGFDb2xvci5zdHJva2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjYWxjdWxhdGUgSHVlIGZyb20gdGhlIGN1cnJlbnQgdmFsdWUuIEF0IHpNaW4gdGhlIGh1ZSBpcyAyNDAsIGF0IHpNYXggdGhlIGh1ZSBpcyAwXG4gICAgICAgIGh1ZSA9ICgxIC0gKHBvaW50LnBvaW50LnogLSB0aGlzLnpNaW4pICogdGhpcy5zY2FsZS56IC8gdGhpcy52ZXJ0aWNhbFJhdGlvKSAqIDI0MDtcbiAgICAgICAgY29sb3IgPSB0aGlzLl9oc3YycmdiKGh1ZSwgMSwgMSk7XG4gICAgICAgIGJvcmRlckNvbG9yID0gdGhpcy5faHN2MnJnYihodWUsIDEsIDAuOCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGRyYXcgdGhlIGNpcmNsZVxuICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuX2dldFN0cm9rZVdpZHRoKHBvaW50KTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGJvcmRlckNvbG9yO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LmFyYyhwb2ludC5zY3JlZW4ueCwgcG9pbnQuc2NyZWVuLnksIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIERyYXcgYWxsIGRhdGFwb2ludHMgYXMgYmFycy5cbiAgICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgdXNlZCB3aGVuIHRoZSBzdHlsZSBpcyAnYmFyJywgJ2Jhci1jb2xvcicsIG9yICdiYXItc2l6ZSdcbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLl9yZWRyYXdEYXRhQmFyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYW52YXMgPSB0aGlzLmZyYW1lLmNhbnZhcztcbiAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgdmFyIGksIGosIHN1cmZhY2UsIGNvcm5lcnM7XG5cbiAgICBpZiAodGhpcy5kYXRhUG9pbnRzID09PSB1bmRlZmluZWQgfHwgdGhpcy5kYXRhUG9pbnRzLmxlbmd0aCA8PSAwKSByZXR1cm47IC8vIFRPRE86IHRocm93IGV4Y2VwdGlvbj9cblxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgdHJhbnNsYXRpb25zIG9mIGFsbCBwb2ludHNcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5kYXRhUG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdHJhbnMgPSB0aGlzLl9jb252ZXJ0UG9pbnRUb1RyYW5zbGF0aW9uKHRoaXMuZGF0YVBvaW50c1tpXS5wb2ludCk7XG4gICAgICB2YXIgc2NyZWVuID0gdGhpcy5fY29udmVydFRyYW5zbGF0aW9uVG9TY3JlZW4odHJhbnMpO1xuICAgICAgdGhpcy5kYXRhUG9pbnRzW2ldLnRyYW5zID0gdHJhbnM7XG4gICAgICB0aGlzLmRhdGFQb2ludHNbaV0uc2NyZWVuID0gc2NyZWVuO1xuXG4gICAgICAvLyBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGZyb20gdGhlIHBvaW50IGF0IHRoZSBib3R0b20gdG8gdGhlIGNhbWVyYVxuICAgICAgdmFyIHRyYW5zQm90dG9tID0gdGhpcy5fY29udmVydFBvaW50VG9UcmFuc2xhdGlvbih0aGlzLmRhdGFQb2ludHNbaV0uYm90dG9tKTtcbiAgICAgIHRoaXMuZGF0YVBvaW50c1tpXS5kaXN0ID0gdGhpcy5zaG93UGVyc3BlY3RpdmUgPyB0cmFuc0JvdHRvbS5sZW5ndGgoKSA6IC10cmFuc0JvdHRvbS56O1xuICAgIH1cblxuICAgIC8vIG9yZGVyIHRoZSB0cmFuc2xhdGVkIHBvaW50cyBieSBkZXB0aFxuICAgIHZhciBzb3J0RGVwdGggPSBmdW5jdGlvbiBzb3J0RGVwdGgoYSwgYikge1xuICAgICAgcmV0dXJuIGIuZGlzdCAtIGEuZGlzdDtcbiAgICB9O1xuICAgIHRoaXMuZGF0YVBvaW50cy5zb3J0KHNvcnREZXB0aCk7XG5cbiAgICBjdHgubGluZUpvaW4gPSAncm91bmQnO1xuICAgIGN0eC5saW5lQ2FwID0gJ3JvdW5kJztcblxuICAgIC8vIGRyYXcgdGhlIGRhdGFwb2ludHMgYXMgYmFyc1xuICAgIHZhciB4V2lkdGggPSB0aGlzLnhCYXJXaWR0aCAvIDI7XG4gICAgdmFyIHlXaWR0aCA9IHRoaXMueUJhcldpZHRoIC8gMjtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5kYXRhUG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcG9pbnQgPSB0aGlzLmRhdGFQb2ludHNbaV07XG5cbiAgICAgIC8vIGRldGVybWluZSBjb2xvclxuICAgICAgdmFyIGh1ZSwgY29sb3IsIGJvcmRlckNvbG9yO1xuICAgICAgaWYgKHRoaXMuc3R5bGUgPT09IEdyYXBoM2QuU1RZTEUuQkFSQ09MT1IpIHtcbiAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBjb2xvciBiYXNlZCBvbiB0aGUgdmFsdWVcbiAgICAgICAgaHVlID0gKDEgLSAocG9pbnQucG9pbnQudmFsdWUgLSB0aGlzLnZhbHVlTWluKSAqIHRoaXMuc2NhbGUudmFsdWUpICogMjQwO1xuICAgICAgICBjb2xvciA9IHRoaXMuX2hzdjJyZ2IoaHVlLCAxLCAxKTtcbiAgICAgICAgYm9yZGVyQ29sb3IgPSB0aGlzLl9oc3YycmdiKGh1ZSwgMSwgMC44KTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5zdHlsZSA9PT0gR3JhcGgzZC5TVFlMRS5CQVJTSVpFKSB7XG4gICAgICAgIGNvbG9yID0gdGhpcy5kYXRhQ29sb3IuZmlsbDtcbiAgICAgICAgYm9yZGVyQ29sb3IgPSB0aGlzLmRhdGFDb2xvci5zdHJva2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjYWxjdWxhdGUgSHVlIGZyb20gdGhlIGN1cnJlbnQgdmFsdWUuIEF0IHpNaW4gdGhlIGh1ZSBpcyAyNDAsIGF0IHpNYXggdGhlIGh1ZSBpcyAwXG4gICAgICAgIGh1ZSA9ICgxIC0gKHBvaW50LnBvaW50LnogLSB0aGlzLnpNaW4pICogdGhpcy5zY2FsZS56IC8gdGhpcy52ZXJ0aWNhbFJhdGlvKSAqIDI0MDtcbiAgICAgICAgY29sb3IgPSB0aGlzLl9oc3YycmdiKGh1ZSwgMSwgMSk7XG4gICAgICAgIGJvcmRlckNvbG9yID0gdGhpcy5faHN2MnJnYihodWUsIDEsIDAuOCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNhbGN1bGF0ZSBzaXplIGZvciB0aGUgYmFyXG4gICAgICBpZiAodGhpcy5zdHlsZSA9PT0gR3JhcGgzZC5TVFlMRS5CQVJTSVpFKSB7XG4gICAgICAgIHhXaWR0aCA9IHRoaXMueEJhcldpZHRoIC8gMiAqICgocG9pbnQucG9pbnQudmFsdWUgLSB0aGlzLnZhbHVlTWluKSAvICh0aGlzLnZhbHVlTWF4IC0gdGhpcy52YWx1ZU1pbikgKiAwLjggKyAwLjIpO1xuICAgICAgICB5V2lkdGggPSB0aGlzLnlCYXJXaWR0aCAvIDIgKiAoKHBvaW50LnBvaW50LnZhbHVlIC0gdGhpcy52YWx1ZU1pbikgLyAodGhpcy52YWx1ZU1heCAtIHRoaXMudmFsdWVNaW4pICogMC44ICsgMC4yKTtcbiAgICAgIH1cblxuICAgICAgLy8gY2FsY3VsYXRlIGFsbCBjb3JuZXIgcG9pbnRzXG4gICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgdmFyIHBvaW50M2QgPSBwb2ludC5wb2ludDtcbiAgICAgIHZhciB0b3AgPSBbeyBwb2ludDogbmV3IFBvaW50M2QocG9pbnQzZC54IC0geFdpZHRoLCBwb2ludDNkLnkgLSB5V2lkdGgsIHBvaW50M2QueikgfSwgeyBwb2ludDogbmV3IFBvaW50M2QocG9pbnQzZC54ICsgeFdpZHRoLCBwb2ludDNkLnkgLSB5V2lkdGgsIHBvaW50M2QueikgfSwgeyBwb2ludDogbmV3IFBvaW50M2QocG9pbnQzZC54ICsgeFdpZHRoLCBwb2ludDNkLnkgKyB5V2lkdGgsIHBvaW50M2QueikgfSwgeyBwb2ludDogbmV3IFBvaW50M2QocG9pbnQzZC54IC0geFdpZHRoLCBwb2ludDNkLnkgKyB5V2lkdGgsIHBvaW50M2QueikgfV07XG4gICAgICB2YXIgYm90dG9tID0gW3sgcG9pbnQ6IG5ldyBQb2ludDNkKHBvaW50M2QueCAtIHhXaWR0aCwgcG9pbnQzZC55IC0geVdpZHRoLCB0aGlzLnpNaW4pIH0sIHsgcG9pbnQ6IG5ldyBQb2ludDNkKHBvaW50M2QueCArIHhXaWR0aCwgcG9pbnQzZC55IC0geVdpZHRoLCB0aGlzLnpNaW4pIH0sIHsgcG9pbnQ6IG5ldyBQb2ludDNkKHBvaW50M2QueCArIHhXaWR0aCwgcG9pbnQzZC55ICsgeVdpZHRoLCB0aGlzLnpNaW4pIH0sIHsgcG9pbnQ6IG5ldyBQb2ludDNkKHBvaW50M2QueCAtIHhXaWR0aCwgcG9pbnQzZC55ICsgeVdpZHRoLCB0aGlzLnpNaW4pIH1dO1xuXG4gICAgICAvLyBjYWxjdWxhdGUgc2NyZWVuIGxvY2F0aW9uIG9mIHRoZSBwb2ludHNcbiAgICAgIHRvcC5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgb2JqLnNjcmVlbiA9IG1lLl9jb252ZXJ0M0R0bzJEKG9iai5wb2ludCk7XG4gICAgICB9KTtcbiAgICAgIGJvdHRvbS5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgb2JqLnNjcmVlbiA9IG1lLl9jb252ZXJ0M0R0bzJEKG9iai5wb2ludCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gY3JlYXRlIGZpdmUgc2lkZXMsIGNhbGN1bGF0ZSBib3RoIGNvcm5lciBwb2ludHMgYW5kIGNlbnRlciBwb2ludHNcbiAgICAgIHZhciBzdXJmYWNlcyA9IFt7IGNvcm5lcnM6IHRvcCwgY2VudGVyOiBQb2ludDNkLmF2Zyhib3R0b21bMF0ucG9pbnQsIGJvdHRvbVsyXS5wb2ludCkgfSwgeyBjb3JuZXJzOiBbdG9wWzBdLCB0b3BbMV0sIGJvdHRvbVsxXSwgYm90dG9tWzBdXSwgY2VudGVyOiBQb2ludDNkLmF2Zyhib3R0b21bMV0ucG9pbnQsIGJvdHRvbVswXS5wb2ludCkgfSwgeyBjb3JuZXJzOiBbdG9wWzFdLCB0b3BbMl0sIGJvdHRvbVsyXSwgYm90dG9tWzFdXSwgY2VudGVyOiBQb2ludDNkLmF2Zyhib3R0b21bMl0ucG9pbnQsIGJvdHRvbVsxXS5wb2ludCkgfSwgeyBjb3JuZXJzOiBbdG9wWzJdLCB0b3BbM10sIGJvdHRvbVszXSwgYm90dG9tWzJdXSwgY2VudGVyOiBQb2ludDNkLmF2Zyhib3R0b21bM10ucG9pbnQsIGJvdHRvbVsyXS5wb2ludCkgfSwgeyBjb3JuZXJzOiBbdG9wWzNdLCB0b3BbMF0sIGJvdHRvbVswXSwgYm90dG9tWzNdXSwgY2VudGVyOiBQb2ludDNkLmF2Zyhib3R0b21bMF0ucG9pbnQsIGJvdHRvbVszXS5wb2ludCkgfV07XG4gICAgICBwb2ludC5zdXJmYWNlcyA9IHN1cmZhY2VzO1xuXG4gICAgICAvLyBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlIG9mIGVhY2ggb2YgdGhlIHN1cmZhY2UgY2VudGVycyB0byB0aGUgY2FtZXJhXG4gICAgICBmb3IgKGogPSAwOyBqIDwgc3VyZmFjZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgc3VyZmFjZSA9IHN1cmZhY2VzW2pdO1xuICAgICAgICB2YXIgdHJhbnNDZW50ZXIgPSB0aGlzLl9jb252ZXJ0UG9pbnRUb1RyYW5zbGF0aW9uKHN1cmZhY2UuY2VudGVyKTtcbiAgICAgICAgc3VyZmFjZS5kaXN0ID0gdGhpcy5zaG93UGVyc3BlY3RpdmUgPyB0cmFuc0NlbnRlci5sZW5ndGgoKSA6IC10cmFuc0NlbnRlci56O1xuICAgICAgICAvLyBUT0RPOiB0aGlzIGRlcHQgY2FsY3VsYXRpb24gZG9lc24ndCB3b3JrIDEwMCUgb2YgdGhlIGNhc2VzIGR1ZSB0byBwZXJzcGVjdGl2ZSxcbiAgICAgICAgLy8gICAgIGJ1dCB0aGUgY3VycmVudCBzb2x1dGlvbiBpcyBmYXN0L3NpbXBsZSBhbmQgd29ya3MgaW4gOTkuOSUgb2YgYWxsIGNhc2VzXG4gICAgICAgIC8vICAgICB0aGUgaXNzdWUgaXMgdmlzaWJsZSBpbiBleGFtcGxlIDE0LCB3aXRoIGdyYXBoLnNldENhbWVyYVBvc2l0aW9uKHtob3Jpem9udGFsOiAyLjk3LCB2ZXJ0aWNhbDogMC41LCBkaXN0YW5jZTogMC45fSlcbiAgICAgIH1cblxuICAgICAgLy8gb3JkZXIgdGhlIHN1cmZhY2VzIGJ5IHRoZWlyICh0cmFuc2xhdGVkKSBkZXB0aFxuICAgICAgc3VyZmFjZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgZGlmZiA9IGIuZGlzdCAtIGEuZGlzdDtcbiAgICAgICAgaWYgKGRpZmYpIHJldHVybiBkaWZmO1xuXG4gICAgICAgIC8vIGlmIGVxdWFsIGRlcHRoLCBzb3J0IHRoZSB0b3Agc3VyZmFjZSBsYXN0XG4gICAgICAgIGlmIChhLmNvcm5lcnMgPT09IHRvcCkgcmV0dXJuIDE7XG4gICAgICAgIGlmIChiLmNvcm5lcnMgPT09IHRvcCkgcmV0dXJuIC0xO1xuXG4gICAgICAgIC8vIGJvdGggYXJlIGVxdWFsXG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGRyYXcgdGhlIG9yZGVyZWQgc3VyZmFjZXNcbiAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLl9nZXRTdHJva2VXaWR0aChwb2ludCk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBib3JkZXJDb2xvcjtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgIC8vIE5PVEU6IHdlIHN0YXJ0IGF0IGo9MiBpbnN0ZWFkIG9mIGo9MCBhcyB3ZSBkb24ndCBuZWVkIHRvIGRyYXcgdGhlIHR3byBzdXJmYWNlcyBhdCB0aGUgYmFja3NpZGVcbiAgICAgIGZvciAoaiA9IDI7IGogPCBzdXJmYWNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBzdXJmYWNlID0gc3VyZmFjZXNbal07XG4gICAgICAgIGNvcm5lcnMgPSBzdXJmYWNlLmNvcm5lcnM7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhjb3JuZXJzWzNdLnNjcmVlbi54LCBjb3JuZXJzWzNdLnNjcmVlbi55KTtcbiAgICAgICAgY3R4LmxpbmVUbyhjb3JuZXJzWzBdLnNjcmVlbi54LCBjb3JuZXJzWzBdLnNjcmVlbi55KTtcbiAgICAgICAgY3R4LmxpbmVUbyhjb3JuZXJzWzFdLnNjcmVlbi54LCBjb3JuZXJzWzFdLnNjcmVlbi55KTtcbiAgICAgICAgY3R4LmxpbmVUbyhjb3JuZXJzWzJdLnNjcmVlbi54LCBjb3JuZXJzWzJdLnNjcmVlbi55KTtcbiAgICAgICAgY3R4LmxpbmVUbyhjb3JuZXJzWzNdLnNjcmVlbi54LCBjb3JuZXJzWzNdLnNjcmVlbi55KTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRHJhdyBhIGxpbmUgdGhyb3VnaCBhbGwgZGF0YXBvaW50cy5cbiAgICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgdXNlZCB3aGVuIHRoZSBzdHlsZSBpcyAnbGluZSdcbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLl9yZWRyYXdEYXRhTGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FudmFzID0gdGhpcy5mcmFtZS5jYW52YXMsXG4gICAgICAgIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLFxuICAgICAgICBwb2ludCxcbiAgICAgICAgaTtcblxuICAgIGlmICh0aGlzLmRhdGFQb2ludHMgPT09IHVuZGVmaW5lZCB8fCB0aGlzLmRhdGFQb2ludHMubGVuZ3RoIDw9IDApIHJldHVybjsgLy8gVE9ETzogdGhyb3cgZXhjZXB0aW9uP1xuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSB0cmFuc2xhdGlvbnMgb2YgYWxsIHBvaW50c1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmRhdGFQb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0cmFucyA9IHRoaXMuX2NvbnZlcnRQb2ludFRvVHJhbnNsYXRpb24odGhpcy5kYXRhUG9pbnRzW2ldLnBvaW50KTtcbiAgICAgIHZhciBzY3JlZW4gPSB0aGlzLl9jb252ZXJ0VHJhbnNsYXRpb25Ub1NjcmVlbih0cmFucyk7XG5cbiAgICAgIHRoaXMuZGF0YVBvaW50c1tpXS50cmFucyA9IHRyYW5zO1xuICAgICAgdGhpcy5kYXRhUG9pbnRzW2ldLnNjcmVlbiA9IHNjcmVlbjtcbiAgICB9XG5cbiAgICAvLyBzdGFydCB0aGUgbGluZVxuICAgIGlmICh0aGlzLmRhdGFQb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgcG9pbnQgPSB0aGlzLmRhdGFQb2ludHNbMF07XG5cbiAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLl9nZXRTdHJva2VXaWR0aChwb2ludCk7XG4gICAgICBjdHgubGluZUpvaW4gPSAncm91bmQnO1xuICAgICAgY3R4LmxpbmVDYXAgPSAncm91bmQnO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5kYXRhQ29sb3Iuc3Ryb2tlO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyhwb2ludC5zY3JlZW4ueCwgcG9pbnQuc2NyZWVuLnkpO1xuXG4gICAgICAvLyBkcmF3IHRoZSBkYXRhcG9pbnRzIGFzIGNvbG9yZWQgY2lyY2xlc1xuICAgICAgZm9yIChpID0gMTsgaSA8IHRoaXMuZGF0YVBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwb2ludCA9IHRoaXMuZGF0YVBvaW50c1tpXTtcbiAgICAgICAgY3R4LmxpbmVUbyhwb2ludC5zY3JlZW4ueCwgcG9pbnQuc2NyZWVuLnkpO1xuICAgICAgfVxuXG4gICAgICAvLyBmaW5pc2ggdGhlIGxpbmVcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGEgbW92aW5nIG9wZXJhdGlvbiBpbnNpZGUgdGhlIHByb3ZpZGVkIHBhcmVudCBlbGVtZW50XG4gICAqIEBwYXJhbSB7RXZlbnR9ICAgICBldmVudCAgICAgVGhlIGV2ZW50IHRoYXQgb2NjdXJyZWQgKHJlcXVpcmVkIGZvclxuICAgKiAgICAgICAgICAgICAgICAgIHJldHJpZXZpbmcgdGhlICBtb3VzZSBwb3NpdGlvbilcbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLl9vbk1vdXNlRG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGV2ZW50ID0gZXZlbnQgfHwgd2luZG93LmV2ZW50O1xuXG4gICAgLy8gY2hlY2sgaWYgbW91c2UgaXMgc3RpbGwgZG93biAobWF5IGJlIHVwIHdoZW4gZm9jdXMgaXMgbG9zdCBmb3IgZXhhbXBsZVxuICAgIC8vIGluIGFuIGlmcmFtZSlcbiAgICBpZiAodGhpcy5sZWZ0QnV0dG9uRG93bikge1xuICAgICAgdGhpcy5fb25Nb3VzZVVwKGV2ZW50KTtcbiAgICB9XG5cbiAgICAvLyBvbmx5IHJlYWN0IG9uIGxlZnQgbW91c2UgYnV0dG9uIGRvd25cbiAgICB0aGlzLmxlZnRCdXR0b25Eb3duID0gZXZlbnQud2hpY2ggPyBldmVudC53aGljaCA9PT0gMSA6IGV2ZW50LmJ1dHRvbiA9PT0gMTtcbiAgICBpZiAoIXRoaXMubGVmdEJ1dHRvbkRvd24gJiYgIXRoaXMudG91Y2hEb3duKSByZXR1cm47XG5cbiAgICAvLyBnZXQgbW91c2UgcG9zaXRpb24gKGRpZmZlcmVudCBjb2RlIGZvciBJRSBhbmQgYWxsIG90aGVyIGJyb3dzZXJzKVxuICAgIHRoaXMuc3RhcnRNb3VzZVggPSBnZXRNb3VzZVgoZXZlbnQpO1xuICAgIHRoaXMuc3RhcnRNb3VzZVkgPSBnZXRNb3VzZVkoZXZlbnQpO1xuXG4gICAgdGhpcy5zdGFydFN0YXJ0ID0gbmV3IERhdGUodGhpcy5zdGFydCk7XG4gICAgdGhpcy5zdGFydEVuZCA9IG5ldyBEYXRlKHRoaXMuZW5kKTtcbiAgICB0aGlzLnN0YXJ0QXJtUm90YXRpb24gPSB0aGlzLmNhbWVyYS5nZXRBcm1Sb3RhdGlvbigpO1xuXG4gICAgdGhpcy5mcmFtZS5zdHlsZS5jdXJzb3IgPSAnbW92ZSc7XG5cbiAgICAvLyBhZGQgZXZlbnQgbGlzdGVuZXJzIHRvIGhhbmRsZSBtb3ZpbmcgdGhlIGNvbnRlbnRzXG4gICAgLy8gd2Ugc3RvcmUgdGhlIGZ1bmN0aW9uIG9ubW91c2Vtb3ZlIGFuZCBvbm1vdXNldXAgaW4gdGhlIGdyYXBoLCBzbyB3ZSBjYW5cbiAgICAvLyByZW1vdmUgdGhlIGV2ZW50bGlzdGVuZXJzIGxhdGVyb24gaW4gdGhlIGZ1bmN0aW9uIG1vdXNlVXAoKVxuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdGhpcy5vbm1vdXNlbW92ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgbWUuX29uTW91c2VNb3ZlKGV2ZW50KTtcbiAgICB9O1xuICAgIHRoaXMub25tb3VzZXVwID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBtZS5fb25Nb3VzZVVwKGV2ZW50KTtcbiAgICB9O1xuICAgIHV0aWwuYWRkRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgJ21vdXNlbW92ZScsIG1lLm9ubW91c2Vtb3ZlKTtcbiAgICB1dGlsLmFkZEV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsICdtb3VzZXVwJywgbWUub25tb3VzZXVwKTtcbiAgICB1dGlsLnByZXZlbnREZWZhdWx0KGV2ZW50KTtcbiAgfTtcblxuICAvKipcbiAgICogUGVyZm9ybSBtb3Zpbmcgb3BlcmF0aW5nLlxuICAgKiBUaGlzIGZ1bmN0aW9uIGFjdGl2YXRlZCBmcm9tIHdpdGhpbiB0aGUgZnVuY2lvbiBHcmFwaC5tb3VzZURvd24oKS5cbiAgICogQHBhcmFtIHtFdmVudH0gICBldmVudCAgV2VsbCwgZWVoaCwgdGhlIGV2ZW50XG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5fb25Nb3VzZU1vdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBldmVudCA9IGV2ZW50IHx8IHdpbmRvdy5ldmVudDtcblxuICAgIC8vIGNhbGN1bGF0ZSBjaGFuZ2UgaW4gbW91c2UgcG9zaXRpb25cbiAgICB2YXIgZGlmZlggPSBwYXJzZUZsb2F0KGdldE1vdXNlWChldmVudCkpIC0gdGhpcy5zdGFydE1vdXNlWDtcbiAgICB2YXIgZGlmZlkgPSBwYXJzZUZsb2F0KGdldE1vdXNlWShldmVudCkpIC0gdGhpcy5zdGFydE1vdXNlWTtcblxuICAgIHZhciBob3Jpem9udGFsTmV3ID0gdGhpcy5zdGFydEFybVJvdGF0aW9uLmhvcml6b250YWwgKyBkaWZmWCAvIDIwMDtcbiAgICB2YXIgdmVydGljYWxOZXcgPSB0aGlzLnN0YXJ0QXJtUm90YXRpb24udmVydGljYWwgKyBkaWZmWSAvIDIwMDtcblxuICAgIHZhciBzbmFwQW5nbGUgPSA0OyAvLyBkZWdyZWVzXG4gICAgdmFyIHNuYXBWYWx1ZSA9IE1hdGguc2luKHNuYXBBbmdsZSAvIDM2MCAqIDIgKiBNYXRoLlBJKTtcblxuICAgIC8vIHNuYXAgaG9yaXpvbnRhbGx5IHRvIG5pY2UgYW5nbGVzIGF0IDBwaSwgMC41cGksIDFwaSwgMS41cGksIGV0Yy4uLlxuICAgIC8vIHRoZSAtMC4wMDEgaXMgdG8gdGFrZSBjYXJlIHRoYXQgdGhlIHZlcnRpY2FsIGF4aXMgaXMgYWx3YXlzIGRyYXduIGF0IHRoZSBsZWZ0IGZyb250IGNvcm5lclxuICAgIGlmIChNYXRoLmFicyhNYXRoLnNpbihob3Jpem9udGFsTmV3KSkgPCBzbmFwVmFsdWUpIHtcbiAgICAgIGhvcml6b250YWxOZXcgPSBNYXRoLnJvdW5kKGhvcml6b250YWxOZXcgLyBNYXRoLlBJKSAqIE1hdGguUEkgLSAwLjAwMTtcbiAgICB9XG4gICAgaWYgKE1hdGguYWJzKE1hdGguY29zKGhvcml6b250YWxOZXcpKSA8IHNuYXBWYWx1ZSkge1xuICAgICAgaG9yaXpvbnRhbE5ldyA9IChNYXRoLnJvdW5kKGhvcml6b250YWxOZXcgLyBNYXRoLlBJIC0gMC41KSArIDAuNSkgKiBNYXRoLlBJIC0gMC4wMDE7XG4gICAgfVxuXG4gICAgLy8gc25hcCB2ZXJ0aWNhbGx5IHRvIG5pY2UgYW5nbGVzXG4gICAgaWYgKE1hdGguYWJzKE1hdGguc2luKHZlcnRpY2FsTmV3KSkgPCBzbmFwVmFsdWUpIHtcbiAgICAgIHZlcnRpY2FsTmV3ID0gTWF0aC5yb3VuZCh2ZXJ0aWNhbE5ldyAvIE1hdGguUEkpICogTWF0aC5QSTtcbiAgICB9XG4gICAgaWYgKE1hdGguYWJzKE1hdGguY29zKHZlcnRpY2FsTmV3KSkgPCBzbmFwVmFsdWUpIHtcbiAgICAgIHZlcnRpY2FsTmV3ID0gKE1hdGgucm91bmQodmVydGljYWxOZXcgLyBNYXRoLlBJIC0gMC41KSArIDAuNSkgKiBNYXRoLlBJO1xuICAgIH1cblxuICAgIHRoaXMuY2FtZXJhLnNldEFybVJvdGF0aW9uKGhvcml6b250YWxOZXcsIHZlcnRpY2FsTmV3KTtcbiAgICB0aGlzLnJlZHJhdygpO1xuXG4gICAgLy8gZmlyZSBhIGNhbWVyYVBvc2l0aW9uQ2hhbmdlIGV2ZW50XG4gICAgdmFyIHBhcmFtZXRlcnMgPSB0aGlzLmdldENhbWVyYVBvc2l0aW9uKCk7XG4gICAgdGhpcy5lbWl0KCdjYW1lcmFQb3NpdGlvbkNoYW5nZScsIHBhcmFtZXRlcnMpO1xuXG4gICAgdXRpbC5wcmV2ZW50RGVmYXVsdChldmVudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0b3AgbW92aW5nIG9wZXJhdGluZy5cbiAgICogVGhpcyBmdW5jdGlvbiBhY3RpdmF0ZWQgZnJvbSB3aXRoaW4gdGhlIGZ1bmNpb24gR3JhcGgubW91c2VEb3duKCkuXG4gICAqIEBwYXJhbSB7ZXZlbnR9ICBldmVudCAgIFRoZSBldmVudFxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX29uTW91c2VVcCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHRoaXMuZnJhbWUuc3R5bGUuY3Vyc29yID0gJ2F1dG8nO1xuICAgIHRoaXMubGVmdEJ1dHRvbkRvd24gPSBmYWxzZTtcblxuICAgIC8vIHJlbW92ZSBldmVudCBsaXN0ZW5lcnMgaGVyZVxuICAgIHV0aWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMub25tb3VzZW1vdmUpO1xuICAgIHV0aWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgJ21vdXNldXAnLCB0aGlzLm9ubW91c2V1cCk7XG4gICAgdXRpbC5wcmV2ZW50RGVmYXVsdChldmVudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFmdGVyIGhhdmluZyBtb3ZlZCB0aGUgbW91c2UsIGEgdG9vbHRpcCBzaG91bGQgcG9wIHVwIHdoZW4gdGhlIG1vdXNlIGlzIHJlc3Rpbmcgb24gYSBkYXRhIHBvaW50XG4gICAqIEBwYXJhbSB7RXZlbnR9ICBldmVudCAgIEEgbW91c2UgbW92ZSBldmVudFxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX29uVG9vbHRpcCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBkZWxheSA9IDMwMDsgLy8gbXNcbiAgICB2YXIgYm91bmRpbmdSZWN0ID0gdGhpcy5mcmFtZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgbW91c2VYID0gZ2V0TW91c2VYKGV2ZW50KSAtIGJvdW5kaW5nUmVjdC5sZWZ0O1xuICAgIHZhciBtb3VzZVkgPSBnZXRNb3VzZVkoZXZlbnQpIC0gYm91bmRpbmdSZWN0LnRvcDtcblxuICAgIGlmICghdGhpcy5zaG93VG9vbHRpcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnRvb2x0aXBUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50b29sdGlwVGltZW91dCk7XG4gICAgfVxuXG4gICAgLy8gKGRlbGF5ZWQpIGRpc3BsYXkgb2YgYSB0b29sdGlwIG9ubHkgaWYgbm8gbW91c2UgYnV0dG9uIGlzIGRvd25cbiAgICBpZiAodGhpcy5sZWZ0QnV0dG9uRG93bikge1xuICAgICAgdGhpcy5faGlkZVRvb2x0aXAoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50b29sdGlwICYmIHRoaXMudG9vbHRpcC5kYXRhUG9pbnQpIHtcbiAgICAgIC8vIHRvb2x0aXAgaXMgY3VycmVudGx5IHZpc2libGVcbiAgICAgIHZhciBkYXRhUG9pbnQgPSB0aGlzLl9kYXRhUG9pbnRGcm9tWFkobW91c2VYLCBtb3VzZVkpO1xuICAgICAgaWYgKGRhdGFQb2ludCAhPT0gdGhpcy50b29sdGlwLmRhdGFQb2ludCkge1xuICAgICAgICAvLyBkYXRhcG9pbnQgY2hhbmdlZFxuICAgICAgICBpZiAoZGF0YVBvaW50KSB7XG4gICAgICAgICAgdGhpcy5fc2hvd1Rvb2x0aXAoZGF0YVBvaW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9oaWRlVG9vbHRpcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRvb2x0aXAgaXMgY3VycmVudGx5IG5vdCB2aXNpYmxlXG4gICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgdGhpcy50b29sdGlwVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBtZS50b29sdGlwVGltZW91dCA9IG51bGw7XG5cbiAgICAgICAgLy8gc2hvdyBhIHRvb2x0aXAgaWYgd2UgaGF2ZSBhIGRhdGEgcG9pbnRcbiAgICAgICAgdmFyIGRhdGFQb2ludCA9IG1lLl9kYXRhUG9pbnRGcm9tWFkobW91c2VYLCBtb3VzZVkpO1xuICAgICAgICBpZiAoZGF0YVBvaW50KSB7XG4gICAgICAgICAgbWUuX3Nob3dUb29sdGlwKGRhdGFQb2ludCk7XG4gICAgICAgIH1cbiAgICAgIH0sIGRlbGF5KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yIHRvdWNoc3RhcnQgZXZlbnQgb24gbW9iaWxlIGRldmljZXNcbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLl9vblRvdWNoU3RhcnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB0aGlzLnRvdWNoRG93biA9IHRydWU7XG5cbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHRoaXMub250b3VjaG1vdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIG1lLl9vblRvdWNoTW92ZShldmVudCk7XG4gICAgfTtcbiAgICB0aGlzLm9udG91Y2hlbmQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIG1lLl9vblRvdWNoRW5kKGV2ZW50KTtcbiAgICB9O1xuICAgIHV0aWwuYWRkRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgJ3RvdWNobW92ZScsIG1lLm9udG91Y2htb3ZlKTtcbiAgICB1dGlsLmFkZEV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsICd0b3VjaGVuZCcsIG1lLm9udG91Y2hlbmQpO1xuXG4gICAgdGhpcy5fb25Nb3VzZURvd24oZXZlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciB0b3VjaG1vdmUgZXZlbnQgb24gbW9iaWxlIGRldmljZXNcbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLl9vblRvdWNoTW92ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHRoaXMuX29uTW91c2VNb3ZlKGV2ZW50KTtcbiAgfTtcblxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBmb3IgdG91Y2hlbmQgZXZlbnQgb24gbW9iaWxlIGRldmljZXNcbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLl9vblRvdWNoRW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdGhpcy50b3VjaERvd24gPSBmYWxzZTtcblxuICAgIHV0aWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMub250b3VjaG1vdmUpO1xuICAgIHV0aWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5vbnRvdWNoZW5kKTtcblxuICAgIHRoaXMuX29uTW91c2VVcChldmVudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yIG1vdXNlIHdoZWVsIGV2ZW50LCB1c2VkIHRvIHpvb20gdGhlIGdyYXBoXG4gICAqIENvZGUgZnJvbSBodHRwOi8vYWRvbWFzLm9yZy9qYXZhc2NyaXB0LW1vdXNlLXdoZWVsL1xuICAgKiBAcGFyYW0ge2V2ZW50fSAgZXZlbnQgICBUaGUgZXZlbnRcbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLl9vbldoZWVsID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKCFldmVudCkgLyogRm9yIElFLiAqL1xuICAgICAgZXZlbnQgPSB3aW5kb3cuZXZlbnQ7XG5cbiAgICAvLyByZXRyaWV2ZSBkZWx0YVxuICAgIHZhciBkZWx0YSA9IDA7XG4gICAgaWYgKGV2ZW50LndoZWVsRGVsdGEpIHtcbiAgICAgIC8qIElFL09wZXJhLiAqL1xuICAgICAgZGVsdGEgPSBldmVudC53aGVlbERlbHRhIC8gMTIwO1xuICAgIH0gZWxzZSBpZiAoZXZlbnQuZGV0YWlsKSB7XG4gICAgICAvKiBNb3ppbGxhIGNhc2UuICovXG4gICAgICAvLyBJbiBNb3ppbGxhLCBzaWduIG9mIGRlbHRhIGlzIGRpZmZlcmVudCB0aGFuIGluIElFLlxuICAgICAgLy8gQWxzbywgZGVsdGEgaXMgbXVsdGlwbGUgb2YgMy5cbiAgICAgIGRlbHRhID0gLWV2ZW50LmRldGFpbCAvIDM7XG4gICAgfVxuXG4gICAgLy8gSWYgZGVsdGEgaXMgbm9uemVybywgaGFuZGxlIGl0LlxuICAgIC8vIEJhc2ljYWxseSwgZGVsdGEgaXMgbm93IHBvc2l0aXZlIGlmIHdoZWVsIHdhcyBzY3JvbGxlZCB1cCxcbiAgICAvLyBhbmQgbmVnYXRpdmUsIGlmIHdoZWVsIHdhcyBzY3JvbGxlZCBkb3duLlxuICAgIGlmIChkZWx0YSkge1xuICAgICAgdmFyIG9sZExlbmd0aCA9IHRoaXMuY2FtZXJhLmdldEFybUxlbmd0aCgpO1xuICAgICAgdmFyIG5ld0xlbmd0aCA9IG9sZExlbmd0aCAqICgxIC0gZGVsdGEgLyAxMCk7XG5cbiAgICAgIHRoaXMuY2FtZXJhLnNldEFybUxlbmd0aChuZXdMZW5ndGgpO1xuICAgICAgdGhpcy5yZWRyYXcoKTtcblxuICAgICAgdGhpcy5faGlkZVRvb2x0aXAoKTtcbiAgICB9XG5cbiAgICAvLyBmaXJlIGEgY2FtZXJhUG9zaXRpb25DaGFuZ2UgZXZlbnRcbiAgICB2YXIgcGFyYW1ldGVycyA9IHRoaXMuZ2V0Q2FtZXJhUG9zaXRpb24oKTtcbiAgICB0aGlzLmVtaXQoJ2NhbWVyYVBvc2l0aW9uQ2hhbmdlJywgcGFyYW1ldGVycyk7XG5cbiAgICAvLyBQcmV2ZW50IGRlZmF1bHQgYWN0aW9ucyBjYXVzZWQgYnkgbW91c2Ugd2hlZWwuXG4gICAgLy8gVGhhdCBtaWdodCBiZSB1Z2x5LCBidXQgd2UgaGFuZGxlIHNjcm9sbHMgc29tZWhvd1xuICAgIC8vIGFueXdheSwgc28gZG9uJ3QgYm90aGVyIGhlcmUuLlxuICAgIHV0aWwucHJldmVudERlZmF1bHQoZXZlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUZXN0IHdoZXRoZXIgYSBwb2ludCBsaWVzIGluc2lkZSBnaXZlbiAyRCB0cmlhbmdsZVxuICAgKiBAcGFyYW0ge1BvaW50MmR9IHBvaW50XG4gICAqIEBwYXJhbSB7UG9pbnQyZFtdfSB0cmlhbmdsZVxuICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgZ2l2ZW4gcG9pbnQgbGllcyBpbnNpZGUgb3Igb24gdGhlIGVkZ2Ugb2YgdGhlIHRyaWFuZ2xlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5faW5zaWRlVHJpYW5nbGUgPSBmdW5jdGlvbiAocG9pbnQsIHRyaWFuZ2xlKSB7XG4gICAgdmFyIGEgPSB0cmlhbmdsZVswXSxcbiAgICAgICAgYiA9IHRyaWFuZ2xlWzFdLFxuICAgICAgICBjID0gdHJpYW5nbGVbMl07XG5cbiAgICBmdW5jdGlvbiBzaWduKHgpIHtcbiAgICAgIHJldHVybiB4ID4gMCA/IDEgOiB4IDwgMCA/IC0xIDogMDtcbiAgICB9XG5cbiAgICB2YXIgYXMgPSBzaWduKChiLnggLSBhLngpICogKHBvaW50LnkgLSBhLnkpIC0gKGIueSAtIGEueSkgKiAocG9pbnQueCAtIGEueCkpO1xuICAgIHZhciBicyA9IHNpZ24oKGMueCAtIGIueCkgKiAocG9pbnQueSAtIGIueSkgLSAoYy55IC0gYi55KSAqIChwb2ludC54IC0gYi54KSk7XG4gICAgdmFyIGNzID0gc2lnbigoYS54IC0gYy54KSAqIChwb2ludC55IC0gYy55KSAtIChhLnkgLSBjLnkpICogKHBvaW50LnggLSBjLngpKTtcblxuICAgIC8vIGVhY2ggb2YgdGhlIHRocmVlIHNpZ25zIG11c3QgYmUgZWl0aGVyIGVxdWFsIHRvIGVhY2ggb3RoZXIgb3IgemVyb1xuICAgIHJldHVybiAoYXMgPT0gMCB8fCBicyA9PSAwIHx8IGFzID09IGJzKSAmJiAoYnMgPT0gMCB8fCBjcyA9PSAwIHx8IGJzID09IGNzKSAmJiAoYXMgPT0gMCB8fCBjcyA9PSAwIHx8IGFzID09IGNzKTtcbiAgfTtcblxuICAvKipcbiAgICogRmluZCBhIGRhdGEgcG9pbnQgY2xvc2UgdG8gZ2l2ZW4gc2NyZWVuIHBvc2l0aW9uICh4LCB5KVxuICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgKiBAcmV0dXJuIHtPYmplY3QgfCBudWxsfSBUaGUgY2xvc2VzdCBkYXRhIHBvaW50IG9yIG51bGwgaWYgbm90IGNsb3NlIHRvIGFueSBkYXRhIHBvaW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5fZGF0YVBvaW50RnJvbVhZID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgZGlzdE1heCA9IDEwMCxcbiAgICAgICAgLy8gcHhcbiAgICBkYXRhUG9pbnQgPSBudWxsLFxuICAgICAgICBjbG9zZXN0RGF0YVBvaW50ID0gbnVsbCxcbiAgICAgICAgY2xvc2VzdERpc3QgPSBudWxsLFxuICAgICAgICBjZW50ZXIgPSBuZXcgUG9pbnQyZCh4LCB5KTtcblxuICAgIGlmICh0aGlzLnN0eWxlID09PSBHcmFwaDNkLlNUWUxFLkJBUiB8fCB0aGlzLnN0eWxlID09PSBHcmFwaDNkLlNUWUxFLkJBUkNPTE9SIHx8IHRoaXMuc3R5bGUgPT09IEdyYXBoM2QuU1RZTEUuQkFSU0laRSkge1xuICAgICAgLy8gdGhlIGRhdGEgcG9pbnRzIGFyZSBvcmRlcmVkIGZyb20gZmFyIGF3YXkgdG8gY2xvc2VzdFxuICAgICAgZm9yIChpID0gdGhpcy5kYXRhUG9pbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGRhdGFQb2ludCA9IHRoaXMuZGF0YVBvaW50c1tpXTtcbiAgICAgICAgdmFyIHN1cmZhY2VzID0gZGF0YVBvaW50LnN1cmZhY2VzO1xuICAgICAgICBpZiAoc3VyZmFjZXMpIHtcbiAgICAgICAgICBmb3IgKHZhciBzID0gc3VyZmFjZXMubGVuZ3RoIC0gMTsgcyA+PSAwOyBzLS0pIHtcbiAgICAgICAgICAgIC8vIHNwbGl0IGVhY2ggc3VyZmFjZSBpbiB0d28gdHJpYW5nbGVzLCBhbmQgc2VlIGlmIHRoZSBjZW50ZXIgcG9pbnQgaXMgaW5zaWRlIG9uZSBvZiB0aGVzZVxuICAgICAgICAgICAgdmFyIHN1cmZhY2UgPSBzdXJmYWNlc1tzXTtcbiAgICAgICAgICAgIHZhciBjb3JuZXJzID0gc3VyZmFjZS5jb3JuZXJzO1xuICAgICAgICAgICAgdmFyIHRyaWFuZ2xlMSA9IFtjb3JuZXJzWzBdLnNjcmVlbiwgY29ybmVyc1sxXS5zY3JlZW4sIGNvcm5lcnNbMl0uc2NyZWVuXTtcbiAgICAgICAgICAgIHZhciB0cmlhbmdsZTIgPSBbY29ybmVyc1syXS5zY3JlZW4sIGNvcm5lcnNbM10uc2NyZWVuLCBjb3JuZXJzWzBdLnNjcmVlbl07XG4gICAgICAgICAgICBpZiAodGhpcy5faW5zaWRlVHJpYW5nbGUoY2VudGVyLCB0cmlhbmdsZTEpIHx8IHRoaXMuX2luc2lkZVRyaWFuZ2xlKGNlbnRlciwgdHJpYW5nbGUyKSkge1xuICAgICAgICAgICAgICAvLyByZXR1cm4gaW1tZWRpYXRlbHkgYXQgdGhlIGZpcnN0IGhpdFxuICAgICAgICAgICAgICByZXR1cm4gZGF0YVBvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmaW5kIHRoZSBjbG9zZXN0IGRhdGEgcG9pbnQsIHVzaW5nIGRpc3RhbmNlIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHBvaW50IG9uIDJkIHNjcmVlblxuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZGF0YVBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBkYXRhUG9pbnQgPSB0aGlzLmRhdGFQb2ludHNbaV07XG4gICAgICAgIHZhciBwb2ludCA9IGRhdGFQb2ludC5zY3JlZW47XG4gICAgICAgIGlmIChwb2ludCkge1xuICAgICAgICAgIHZhciBkaXN0WCA9IE1hdGguYWJzKHggLSBwb2ludC54KTtcbiAgICAgICAgICB2YXIgZGlzdFkgPSBNYXRoLmFicyh5IC0gcG9pbnQueSk7XG4gICAgICAgICAgdmFyIGRpc3QgPSBNYXRoLnNxcnQoZGlzdFggKiBkaXN0WCArIGRpc3RZICogZGlzdFkpO1xuXG4gICAgICAgICAgaWYgKChjbG9zZXN0RGlzdCA9PT0gbnVsbCB8fCBkaXN0IDwgY2xvc2VzdERpc3QpICYmIGRpc3QgPCBkaXN0TWF4KSB7XG4gICAgICAgICAgICBjbG9zZXN0RGlzdCA9IGRpc3Q7XG4gICAgICAgICAgICBjbG9zZXN0RGF0YVBvaW50ID0gZGF0YVBvaW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbG9zZXN0RGF0YVBvaW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBEaXNwbGF5IGEgdG9vbHRpcCBmb3IgZ2l2ZW4gZGF0YSBwb2ludFxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVBvaW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5fc2hvd1Rvb2x0aXAgPSBmdW5jdGlvbiAoZGF0YVBvaW50KSB7XG4gICAgdmFyIGNvbnRlbnQsIGxpbmUsIGRvdDtcblxuICAgIGlmICghdGhpcy50b29sdGlwKSB7XG4gICAgICBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBjb250ZW50LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgIGNvbnRlbnQuc3R5bGUucGFkZGluZyA9ICcxMHB4JztcbiAgICAgIGNvbnRlbnQuc3R5bGUuYm9yZGVyID0gJzFweCBzb2xpZCAjNGQ0ZDRkJztcbiAgICAgIGNvbnRlbnQuc3R5bGUuY29sb3IgPSAnIzFhMWExYSc7XG4gICAgICBjb250ZW50LnN0eWxlLmJhY2tncm91bmQgPSAncmdiYSgyNTUsMjU1LDI1NSwwLjcpJztcbiAgICAgIGNvbnRlbnQuc3R5bGUuYm9yZGVyUmFkaXVzID0gJzJweCc7XG4gICAgICBjb250ZW50LnN0eWxlLmJveFNoYWRvdyA9ICc1cHggNXB4IDEwcHggcmdiYSgxMjgsMTI4LDEyOCwwLjUpJztcblxuICAgICAgbGluZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgbGluZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICBsaW5lLnN0eWxlLmhlaWdodCA9ICc0MHB4JztcbiAgICAgIGxpbmUuc3R5bGUud2lkdGggPSAnMCc7XG4gICAgICBsaW5lLnN0eWxlLmJvcmRlckxlZnQgPSAnMXB4IHNvbGlkICM0ZDRkNGQnO1xuXG4gICAgICBkb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRvdC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICBkb3Quc3R5bGUuaGVpZ2h0ID0gJzAnO1xuICAgICAgZG90LnN0eWxlLndpZHRoID0gJzAnO1xuICAgICAgZG90LnN0eWxlLmJvcmRlciA9ICc1cHggc29saWQgIzRkNGQ0ZCc7XG4gICAgICBkb3Quc3R5bGUuYm9yZGVyUmFkaXVzID0gJzVweCc7XG5cbiAgICAgIHRoaXMudG9vbHRpcCA9IHtcbiAgICAgICAgZGF0YVBvaW50OiBudWxsLFxuICAgICAgICBkb206IHtcbiAgICAgICAgICBjb250ZW50OiBjb250ZW50LFxuICAgICAgICAgIGxpbmU6IGxpbmUsXG4gICAgICAgICAgZG90OiBkb3RcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudCA9IHRoaXMudG9vbHRpcC5kb20uY29udGVudDtcbiAgICAgIGxpbmUgPSB0aGlzLnRvb2x0aXAuZG9tLmxpbmU7XG4gICAgICBkb3QgPSB0aGlzLnRvb2x0aXAuZG9tLmRvdDtcbiAgICB9XG5cbiAgICB0aGlzLl9oaWRlVG9vbHRpcCgpO1xuXG4gICAgdGhpcy50b29sdGlwLmRhdGFQb2ludCA9IGRhdGFQb2ludDtcbiAgICBpZiAodHlwZW9mIHRoaXMuc2hvd1Rvb2x0aXAgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnRlbnQuaW5uZXJIVE1MID0gdGhpcy5zaG93VG9vbHRpcChkYXRhUG9pbnQucG9pbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZW50LmlubmVySFRNTCA9ICc8dGFibGU+JyArICc8dHI+PHRkPicgKyB0aGlzLnhMYWJlbCArICc6PC90ZD48dGQ+JyArIGRhdGFQb2ludC5wb2ludC54ICsgJzwvdGQ+PC90cj4nICsgJzx0cj48dGQ+JyArIHRoaXMueUxhYmVsICsgJzo8L3RkPjx0ZD4nICsgZGF0YVBvaW50LnBvaW50LnkgKyAnPC90ZD48L3RyPicgKyAnPHRyPjx0ZD4nICsgdGhpcy56TGFiZWwgKyAnOjwvdGQ+PHRkPicgKyBkYXRhUG9pbnQucG9pbnQueiArICc8L3RkPjwvdHI+JyArICc8L3RhYmxlPic7XG4gICAgfVxuXG4gICAgY29udGVudC5zdHlsZS5sZWZ0ID0gJzAnO1xuICAgIGNvbnRlbnQuc3R5bGUudG9wID0gJzAnO1xuICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZChsaW5lKTtcbiAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKGRvdCk7XG5cbiAgICAvLyBjYWxjdWxhdGUgc2l6ZXNcbiAgICB2YXIgY29udGVudFdpZHRoID0gY29udGVudC5vZmZzZXRXaWR0aDtcbiAgICB2YXIgY29udGVudEhlaWdodCA9IGNvbnRlbnQub2Zmc2V0SGVpZ2h0O1xuICAgIHZhciBsaW5lSGVpZ2h0ID0gbGluZS5vZmZzZXRIZWlnaHQ7XG4gICAgdmFyIGRvdFdpZHRoID0gZG90Lm9mZnNldFdpZHRoO1xuICAgIHZhciBkb3RIZWlnaHQgPSBkb3Qub2Zmc2V0SGVpZ2h0O1xuXG4gICAgdmFyIGxlZnQgPSBkYXRhUG9pbnQuc2NyZWVuLnggLSBjb250ZW50V2lkdGggLyAyO1xuICAgIGxlZnQgPSBNYXRoLm1pbihNYXRoLm1heChsZWZ0LCAxMCksIHRoaXMuZnJhbWUuY2xpZW50V2lkdGggLSAxMCAtIGNvbnRlbnRXaWR0aCk7XG5cbiAgICBsaW5lLnN0eWxlLmxlZnQgPSBkYXRhUG9pbnQuc2NyZWVuLnggKyAncHgnO1xuICAgIGxpbmUuc3R5bGUudG9wID0gZGF0YVBvaW50LnNjcmVlbi55IC0gbGluZUhlaWdodCArICdweCc7XG4gICAgY29udGVudC5zdHlsZS5sZWZ0ID0gbGVmdCArICdweCc7XG4gICAgY29udGVudC5zdHlsZS50b3AgPSBkYXRhUG9pbnQuc2NyZWVuLnkgLSBsaW5lSGVpZ2h0IC0gY29udGVudEhlaWdodCArICdweCc7XG4gICAgZG90LnN0eWxlLmxlZnQgPSBkYXRhUG9pbnQuc2NyZWVuLnggLSBkb3RXaWR0aCAvIDIgKyAncHgnO1xuICAgIGRvdC5zdHlsZS50b3AgPSBkYXRhUG9pbnQuc2NyZWVuLnkgLSBkb3RIZWlnaHQgLyAyICsgJ3B4JztcbiAgfTtcblxuICAvKipcbiAgICogSGlkZSB0aGUgdG9vbHRpcCB3aGVuIGRpc3BsYXllZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX2hpZGVUb29sdGlwID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnRvb2x0aXApIHtcbiAgICAgIHRoaXMudG9vbHRpcC5kYXRhUG9pbnQgPSBudWxsO1xuXG4gICAgICBmb3IgKHZhciBwcm9wIGluIHRoaXMudG9vbHRpcC5kb20pIHtcbiAgICAgICAgaWYgKHRoaXMudG9vbHRpcC5kb20uaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICB2YXIgZWxlbSA9IHRoaXMudG9vbHRpcC5kb21bcHJvcF07XG4gICAgICAgICAgaWYgKGVsZW0gJiYgZWxlbS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBlbGVtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKiovXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaG9yaXpvbnRhbCBtb3VzZSBwb3NpdGlvbiBmcm9tIGEgbW91c2UgZXZlbnRcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHJldHVybiB7TnVtYmVyfSBtb3VzZSB4XG4gICAqL1xuICBmdW5jdGlvbiBnZXRNb3VzZVgoZXZlbnQpIHtcbiAgICBpZiAoJ2NsaWVudFgnIGluIGV2ZW50KSByZXR1cm4gZXZlbnQuY2xpZW50WDtcbiAgICByZXR1cm4gZXZlbnQudGFyZ2V0VG91Y2hlc1swXSAmJiBldmVudC50YXJnZXRUb3VjaGVzWzBdLmNsaWVudFggfHwgMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZlcnRpY2FsIG1vdXNlIHBvc2l0aW9uIGZyb20gYSBtb3VzZSBldmVudFxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IG1vdXNlIHlcbiAgICovXG4gIGZ1bmN0aW9uIGdldE1vdXNlWShldmVudCkge1xuICAgIGlmICgnY2xpZW50WScgaW4gZXZlbnQpIHJldHVybiBldmVudC5jbGllbnRZO1xuICAgIHJldHVybiBldmVudC50YXJnZXRUb3VjaGVzWzBdICYmIGV2ZW50LnRhcmdldFRvdWNoZXNbMF0uY2xpZW50WSB8fCAwO1xuICB9XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBHcmFwaDNkO1xuXG4vKioqLyB9LFxuLyogMTMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gIFxuICAvKipcbiAgICogRXhwb3NlIGBFbWl0dGVyYC5cbiAgICovXG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cbiAgICpcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gRW1pdHRlcihvYmopIHtcbiAgICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcbiAgfTtcblxuICAvKipcbiAgICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBmdW5jdGlvbiBtaXhpbihvYmopIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcbiAgICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICogQHJldHVybiB7RW1pdHRlcn1cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgRW1pdHRlci5wcm90b3R5cGUub24gPVxuICBFbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gICAgKHRoaXMuX2NhbGxiYWNrc1tldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdIHx8IFtdKVxuICAgICAgLnB1c2goZm4pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcbiAgICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cbiAgICBmdW5jdGlvbiBvbigpIHtcbiAgICAgIHNlbGYub2ZmKGV2ZW50LCBvbik7XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIG9uLmZuID0gZm47XG4gICAgdGhpcy5vbihldmVudCwgb24pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxuICAgKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XG4gIEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG4gICAgLy8gYWxsXG4gICAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fY2FsbGJhY2tzID0ge307XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBzcGVjaWZpYyBldmVudFxuICAgIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xuICAgIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpcztcblxuICAgIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcbiAgICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXG4gICAgdmFyIGNiO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjYiA9IGNhbGxiYWNrc1tpXTtcbiAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge01peGVkfSAuLi5cbiAgICogQHJldHVybiB7RW1pdHRlcn1cbiAgICovXG5cbiAgRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcbiAgICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcblxuICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1tldmVudF0gfHwgW107XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcbiAgfTtcblxuXG4vKioqLyB9LFxuLyogMTQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIC8qKlxuICAgKiBAcHJvdG90eXBlIFBvaW50M2RcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt4XVxuICAgKiBAcGFyYW0ge051bWJlcn0gW3ldXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbel1cbiAgICovXG4gIGZ1bmN0aW9uIFBvaW50M2QoeCwgeSwgeikge1xuICAgIHRoaXMueCA9IHggIT09IHVuZGVmaW5lZCA/IHggOiAwO1xuICAgIHRoaXMueSA9IHkgIT09IHVuZGVmaW5lZCA/IHkgOiAwO1xuICAgIHRoaXMueiA9IHogIT09IHVuZGVmaW5lZCA/IHogOiAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdWJ0cmFjdCB0aGUgdHdvIHByb3ZpZGVkIHBvaW50cywgcmV0dXJucyBhLWJcbiAgICogQHBhcmFtIHtQb2ludDNkfSBhXG4gICAqIEBwYXJhbSB7UG9pbnQzZH0gYlxuICAgKiBAcmV0dXJuIHtQb2ludDNkfSBhLWJcbiAgICovXG4gIFBvaW50M2Quc3VidHJhY3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciBzdWIgPSBuZXcgUG9pbnQzZCgpO1xuICAgIHN1Yi54ID0gYS54IC0gYi54O1xuICAgIHN1Yi55ID0gYS55IC0gYi55O1xuICAgIHN1Yi56ID0gYS56IC0gYi56O1xuICAgIHJldHVybiBzdWI7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCB0aGUgdHdvIHByb3ZpZGVkIHBvaW50cywgcmV0dXJucyBhK2JcbiAgICogQHBhcmFtIHtQb2ludDNkfSBhXG4gICAqIEBwYXJhbSB7UG9pbnQzZH0gYlxuICAgKiBAcmV0dXJuIHtQb2ludDNkfSBhK2JcbiAgICovXG4gIFBvaW50M2QuYWRkID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICB2YXIgc3VtID0gbmV3IFBvaW50M2QoKTtcbiAgICBzdW0ueCA9IGEueCArIGIueDtcbiAgICBzdW0ueSA9IGEueSArIGIueTtcbiAgICBzdW0ueiA9IGEueiArIGIuejtcbiAgICByZXR1cm4gc3VtO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGF2ZXJhZ2Ugb2YgdHdvIDNkIHBvaW50c1xuICAgKiBAcGFyYW0ge1BvaW50M2R9IGFcbiAgICogQHBhcmFtIHtQb2ludDNkfSBiXG4gICAqIEByZXR1cm4ge1BvaW50M2R9IFRoZSBhdmVyYWdlLCAoYStiKS8yXG4gICAqL1xuICBQb2ludDNkLmF2ZyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIG5ldyBQb2ludDNkKChhLnggKyBiLngpIC8gMiwgKGEueSArIGIueSkgLyAyLCAoYS56ICsgYi56KSAvIDIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdGhlIHR3byBwcm92aWRlZCBwb2ludHMsIHJldHVybnMgYXhiXG4gICAqIERvY3VtZW50YXRpb246IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ3Jvc3NfcHJvZHVjdFxuICAgKiBAcGFyYW0ge1BvaW50M2R9IGFcbiAgICogQHBhcmFtIHtQb2ludDNkfSBiXG4gICAqIEByZXR1cm4ge1BvaW50M2R9IGNyb3NzIHByb2R1Y3QgYXhiXG4gICAqL1xuICBQb2ludDNkLmNyb3NzUHJvZHVjdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGNyb3NzcHJvZHVjdCA9IG5ldyBQb2ludDNkKCk7XG5cbiAgICBjcm9zc3Byb2R1Y3QueCA9IGEueSAqIGIueiAtIGEueiAqIGIueTtcbiAgICBjcm9zc3Byb2R1Y3QueSA9IGEueiAqIGIueCAtIGEueCAqIGIuejtcbiAgICBjcm9zc3Byb2R1Y3QueiA9IGEueCAqIGIueSAtIGEueSAqIGIueDtcblxuICAgIHJldHVybiBjcm9zc3Byb2R1Y3Q7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJ0cmlldmUgdGhlIGxlbmd0aCBvZiB0aGUgdmVjdG9yIChvciB0aGUgZGlzdGFuY2UgZnJvbSB0aGlzIHBvaW50IHRvIHRoZSBvcmlnaW5cbiAgICogQHJldHVybiB7TnVtYmVyfSAgbGVuZ3RoXG4gICAqL1xuICBQb2ludDNkLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnopO1xuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gUG9pbnQzZDtcblxuLyoqKi8gfSxcbi8qIDE1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuICBcInVzZSBzdHJpY3RcIjtcblxuICAvKipcbiAgICogQHByb3RvdHlwZSBQb2ludDJkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbeF1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt5XVxuICAgKi9cbiAgZnVuY3Rpb24gUG9pbnQyZCh4LCB5KSB7XG4gICAgdGhpcy54ID0geCAhPT0gdW5kZWZpbmVkID8geCA6IDA7XG4gICAgdGhpcy55ID0geSAhPT0gdW5kZWZpbmVkID8geSA6IDA7XG4gIH1cblxuICBtb2R1bGUuZXhwb3J0cyA9IFBvaW50MmQ7XG5cbi8qKiovIH0sXG4vKiAxNiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBQb2ludDNkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cbiAgLyoqXG4gICAqIEBjbGFzcyBDYW1lcmFcbiAgICogVGhlIGNhbWVyYSBpcyBtb3VudGVkIG9uIGEgKHZpcnR1YWwpIGNhbWVyYSBhcm0uIFRoZSBjYW1lcmEgYXJtIGNhbiByb3RhdGVcbiAgICogVGhlIGNhbWVyYSBpcyBhbHdheXMgbG9va2luZyBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBvcmlnaW4gb2YgdGhlIGFybS5cbiAgICogVGhpcyB3YXksIHRoZSBjYW1lcmEgYWx3YXlzIHJvdGF0ZXMgYXJvdW5kIG9uZSBmaXhlZCBwb2ludCwgdGhlIGxvY2F0aW9uXG4gICAqIG9mIHRoZSBjYW1lcmEgYXJtLlxuICAgKlxuICAgKiBEb2N1bWVudGF0aW9uOlxuICAgKiAgIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvM0RfcHJvamVjdGlvblxuICAgKi9cbiAgZnVuY3Rpb24gQ2FtZXJhKCkge1xuICAgIHRoaXMuYXJtTG9jYXRpb24gPSBuZXcgUG9pbnQzZCgpO1xuICAgIHRoaXMuYXJtUm90YXRpb24gPSB7fTtcbiAgICB0aGlzLmFybVJvdGF0aW9uLmhvcml6b250YWwgPSAwO1xuICAgIHRoaXMuYXJtUm90YXRpb24udmVydGljYWwgPSAwO1xuICAgIHRoaXMuYXJtTGVuZ3RoID0gMS43O1xuXG4gICAgdGhpcy5jYW1lcmFMb2NhdGlvbiA9IG5ldyBQb2ludDNkKCk7XG4gICAgdGhpcy5jYW1lcmFSb3RhdGlvbiA9IG5ldyBQb2ludDNkKDAuNSAqIE1hdGguUEksIDAsIDApO1xuXG4gICAgdGhpcy5jYWxjdWxhdGVDYW1lcmFPcmllbnRhdGlvbigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbG9jYXRpb24gKG9yaWdpbikgb2YgdGhlIGFybVxuICAgKiBAcGFyYW0ge051bWJlcn0geCAgTm9ybWFsaXplZCB2YWx1ZSBvZiB4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5ICBOb3JtYWxpemVkIHZhbHVlIG9mIHlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHogIE5vcm1hbGl6ZWQgdmFsdWUgb2YgelxuICAgKi9cbiAgQ2FtZXJhLnByb3RvdHlwZS5zZXRBcm1Mb2NhdGlvbiA9IGZ1bmN0aW9uICh4LCB5LCB6KSB7XG4gICAgdGhpcy5hcm1Mb2NhdGlvbi54ID0geDtcbiAgICB0aGlzLmFybUxvY2F0aW9uLnkgPSB5O1xuICAgIHRoaXMuYXJtTG9jYXRpb24ueiA9IHo7XG5cbiAgICB0aGlzLmNhbGN1bGF0ZUNhbWVyYU9yaWVudGF0aW9uKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcm90YXRpb24gb2YgdGhlIGNhbWVyYSBhcm1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhvcml6b250YWwgICBUaGUgaG9yaXpvbnRhbCByb3RhdGlvbiwgYmV0d2VlbiAwIGFuZCAyKlBJLlxuICAgKiAgICAgICAgICAgICAgICBPcHRpb25hbCwgY2FuIGJlIGxlZnQgdW5kZWZpbmVkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmVydGljYWwgICBUaGUgdmVydGljYWwgcm90YXRpb24sIGJldHdlZW4gMCBhbmQgMC41KlBJXG4gICAqICAgICAgICAgICAgICAgIGlmIHZlcnRpY2FsPTAuNSpQSSwgdGhlIGdyYXBoIGlzIHNob3duIGZyb20gdGhlXG4gICAqICAgICAgICAgICAgICAgIHRvcC4gT3B0aW9uYWwsIGNhbiBiZSBsZWZ0IHVuZGVmaW5lZC5cbiAgICovXG4gIENhbWVyYS5wcm90b3R5cGUuc2V0QXJtUm90YXRpb24gPSBmdW5jdGlvbiAoaG9yaXpvbnRhbCwgdmVydGljYWwpIHtcbiAgICBpZiAoaG9yaXpvbnRhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmFybVJvdGF0aW9uLmhvcml6b250YWwgPSBob3Jpem9udGFsO1xuICAgIH1cblxuICAgIGlmICh2ZXJ0aWNhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmFybVJvdGF0aW9uLnZlcnRpY2FsID0gdmVydGljYWw7XG4gICAgICBpZiAodGhpcy5hcm1Sb3RhdGlvbi52ZXJ0aWNhbCA8IDApIHRoaXMuYXJtUm90YXRpb24udmVydGljYWwgPSAwO1xuICAgICAgaWYgKHRoaXMuYXJtUm90YXRpb24udmVydGljYWwgPiAwLjUgKiBNYXRoLlBJKSB0aGlzLmFybVJvdGF0aW9uLnZlcnRpY2FsID0gMC41ICogTWF0aC5QSTtcbiAgICB9XG5cbiAgICBpZiAoaG9yaXpvbnRhbCAhPT0gdW5kZWZpbmVkIHx8IHZlcnRpY2FsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuY2FsY3VsYXRlQ2FtZXJhT3JpZW50YXRpb24oKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSBjdXJyZW50IGFybSByb3RhdGlvblxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgQW4gb2JqZWN0IHdpdGggcGFyYW1ldGVycyBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbFxuICAgKi9cbiAgQ2FtZXJhLnByb3RvdHlwZS5nZXRBcm1Sb3RhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcm90ID0ge307XG4gICAgcm90Lmhvcml6b250YWwgPSB0aGlzLmFybVJvdGF0aW9uLmhvcml6b250YWw7XG4gICAgcm90LnZlcnRpY2FsID0gdGhpcy5hcm1Sb3RhdGlvbi52ZXJ0aWNhbDtcblxuICAgIHJldHVybiByb3Q7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgKG5vcm1hbGl6ZWQpIGxlbmd0aCBvZiB0aGUgY2FtZXJhIGFybS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCBBIGxlbmd0aCBiZXR3ZWVuIDAuNzEgYW5kIDUuMFxuICAgKi9cbiAgQ2FtZXJhLnByb3RvdHlwZS5zZXRBcm1MZW5ndGggPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICB0aGlzLmFybUxlbmd0aCA9IGxlbmd0aDtcblxuICAgIC8vIFJhZGl1cyBtdXN0IGJlIGxhcmdlciB0aGFuIHRoZSBjb3JuZXIgb2YgdGhlIGdyYXBoLFxuICAgIC8vIHdoaWNoIGhhcyBhIGRpc3RhbmNlIG9mIHNxcnQoMC41XjIrMC41XjIpID0gMC43MSBmcm9tIHRoZSBjZW50ZXIgb2YgdGhlXG4gICAgLy8gZ3JhcGhcbiAgICBpZiAodGhpcy5hcm1MZW5ndGggPCAwLjcxKSB0aGlzLmFybUxlbmd0aCA9IDAuNzE7XG4gICAgaWYgKHRoaXMuYXJtTGVuZ3RoID4gNS4wKSB0aGlzLmFybUxlbmd0aCA9IDUuMDtcblxuICAgIHRoaXMuY2FsY3VsYXRlQ2FtZXJhT3JpZW50YXRpb24oKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlldmUgdGhlIGFybSBsZW5ndGhcbiAgICogQHJldHVybiB7TnVtYmVyfSBsZW5ndGhcbiAgICovXG4gIENhbWVyYS5wcm90b3R5cGUuZ2V0QXJtTGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmFybUxlbmd0aDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlldmUgdGhlIGNhbWVyYSBsb2NhdGlvblxuICAgKiBAcmV0dXJuIHtQb2ludDNkfSBjYW1lcmFMb2NhdGlvblxuICAgKi9cbiAgQ2FtZXJhLnByb3RvdHlwZS5nZXRDYW1lcmFMb2NhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jYW1lcmFMb2NhdGlvbjtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlldmUgdGhlIGNhbWVyYSByb3RhdGlvblxuICAgKiBAcmV0dXJuIHtQb2ludDNkfSBjYW1lcmFSb3RhdGlvblxuICAgKi9cbiAgQ2FtZXJhLnByb3RvdHlwZS5nZXRDYW1lcmFSb3RhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jYW1lcmFSb3RhdGlvbjtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBsb2NhdGlvbiBhbmQgcm90YXRpb24gb2YgdGhlIGNhbWVyYSBiYXNlZCBvbiB0aGVcbiAgICogcG9zaXRpb24gYW5kIG9yaWVudGF0aW9uIG9mIHRoZSBjYW1lcmEgYXJtXG4gICAqL1xuICBDYW1lcmEucHJvdG90eXBlLmNhbGN1bGF0ZUNhbWVyYU9yaWVudGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIGNhbGN1bGF0ZSBsb2NhdGlvbiBvZiB0aGUgY2FtZXJhXG4gICAgdGhpcy5jYW1lcmFMb2NhdGlvbi54ID0gdGhpcy5hcm1Mb2NhdGlvbi54IC0gdGhpcy5hcm1MZW5ndGggKiBNYXRoLnNpbih0aGlzLmFybVJvdGF0aW9uLmhvcml6b250YWwpICogTWF0aC5jb3ModGhpcy5hcm1Sb3RhdGlvbi52ZXJ0aWNhbCk7XG4gICAgdGhpcy5jYW1lcmFMb2NhdGlvbi55ID0gdGhpcy5hcm1Mb2NhdGlvbi55IC0gdGhpcy5hcm1MZW5ndGggKiBNYXRoLmNvcyh0aGlzLmFybVJvdGF0aW9uLmhvcml6b250YWwpICogTWF0aC5jb3ModGhpcy5hcm1Sb3RhdGlvbi52ZXJ0aWNhbCk7XG4gICAgdGhpcy5jYW1lcmFMb2NhdGlvbi56ID0gdGhpcy5hcm1Mb2NhdGlvbi56ICsgdGhpcy5hcm1MZW5ndGggKiBNYXRoLnNpbih0aGlzLmFybVJvdGF0aW9uLnZlcnRpY2FsKTtcblxuICAgIC8vIGNhbGN1bGF0ZSByb3RhdGlvbiBvZiB0aGUgY2FtZXJhXG4gICAgdGhpcy5jYW1lcmFSb3RhdGlvbi54ID0gTWF0aC5QSSAvIDIgLSB0aGlzLmFybVJvdGF0aW9uLnZlcnRpY2FsO1xuICAgIHRoaXMuY2FtZXJhUm90YXRpb24ueSA9IDA7XG4gICAgdGhpcy5jYW1lcmFSb3RhdGlvbi56ID0gLXRoaXMuYXJtUm90YXRpb24uaG9yaXpvbnRhbDtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IENhbWVyYTtcblxuLyoqKi8gfSxcbi8qIDE3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIERhdGFWaWV3ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cbiAgLyoqXG4gICAqIEBjbGFzcyBGaWx0ZXJcbiAgICpcbiAgICogQHBhcmFtIHtEYXRhU2V0fSBkYXRhIFRoZSBnb29nbGUgZGF0YSB0YWJsZVxuICAgKiBAcGFyYW0ge051bWJlcn0gIGNvbHVtbiAgICAgICAgICAgICBUaGUgaW5kZXggb2YgdGhlIGNvbHVtbiB0byBiZSBmaWx0ZXJlZFxuICAgKiBAcGFyYW0ge0dyYXBofSBncmFwaCAgICAgICAgICAgVGhlIGdyYXBoXG4gICAqL1xuICBmdW5jdGlvbiBGaWx0ZXIoZGF0YSwgY29sdW1uLCBncmFwaCkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgdGhpcy5ncmFwaCA9IGdyYXBoOyAvLyB0aGUgcGFyZW50IGdyYXBoXG5cbiAgICB0aGlzLmluZGV4ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudmFsdWUgPSB1bmRlZmluZWQ7XG5cbiAgICAvLyByZWFkIGFsbCBkaXN0aW5jdCB2YWx1ZXMgYW5kIHNlbGVjdCB0aGUgZmlyc3Qgb25lXG4gICAgdGhpcy52YWx1ZXMgPSBncmFwaC5nZXREaXN0aW5jdFZhbHVlcyhkYXRhLmdldCgpLCB0aGlzLmNvbHVtbik7XG5cbiAgICAvLyBzb3J0IGJvdGggbnVtZXJpYyBhbmQgc3RyaW5nIHZhbHVlcyBjb3JyZWN0bHlcbiAgICB0aGlzLnZhbHVlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYSA+IGIgPyAxIDogYSA8IGIgPyAtMSA6IDA7XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy52YWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5zZWxlY3RWYWx1ZSgwKTtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgYW4gYXJyYXkgd2l0aCB0aGUgZmlsdGVyZWQgZGF0YXBvaW50cy4gdGhpcyB3aWxsIGJlIGxvYWRlZCBhZnRlcndhcmRzXG4gICAgdGhpcy5kYXRhUG9pbnRzID0gW107XG5cbiAgICB0aGlzLmxvYWRlZCA9IGZhbHNlO1xuICAgIHRoaXMub25Mb2FkQ2FsbGJhY2sgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZ3JhcGguYW5pbWF0aW9uUHJlbG9hZCkge1xuICAgICAgdGhpcy5sb2FkZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMubG9hZEluQmFja2dyb3VuZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvYWRlZCA9IHRydWU7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGxhYmVsXG4gICAqIEByZXR1cm4ge3N0cmluZ30gbGFiZWxcbiAgICovXG4gIEZpbHRlci5wcm90b3R5cGUuaXNMb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubG9hZGVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGxvYWRlZCBwcm9ncmVzc1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHBlcmNlbnRhZ2UgYmV0d2VlbiAwIGFuZCAxMDBcbiAgICovXG4gIEZpbHRlci5wcm90b3R5cGUuZ2V0TG9hZGVkUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IHRoaXMudmFsdWVzLmxlbmd0aDtcblxuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAodGhpcy5kYXRhUG9pbnRzW2ldKSB7XG4gICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGgucm91bmQoaSAvIGxlbiAqIDEwMCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbGFiZWxcbiAgICogQHJldHVybiB7c3RyaW5nfSBsYWJlbFxuICAgKi9cbiAgRmlsdGVyLnByb3RvdHlwZS5nZXRMYWJlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5ncmFwaC5maWx0ZXJMYWJlbDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjb2x1bW5JbmRleCBvZiB0aGUgZmlsdGVyXG4gICAqIEByZXR1cm4ge051bWJlcn0gY29sdW1uSW5kZXhcbiAgICovXG4gIEZpbHRlci5wcm90b3R5cGUuZ2V0Q29sdW1uID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNvbHVtbjtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdmFsdWUuIFJldHVybnMgdW5kZWZpbmVkIGlmIHRoZXJlIGlzIG5vIHNlbGVjdGlvblxuICAgKiBAcmV0dXJuIHsqfSB2YWx1ZVxuICAgKi9cbiAgRmlsdGVyLnByb3RvdHlwZS5nZXRTZWxlY3RlZFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmluZGV4ID09PSB1bmRlZmluZWQpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICByZXR1cm4gdGhpcy52YWx1ZXNbdGhpcy5pbmRleF07XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIGFsbCB2YWx1ZXMgb2YgdGhlIGZpbHRlclxuICAgKiBAcmV0dXJuIHtBcnJheX0gdmFsdWVzXG4gICAqL1xuICBGaWx0ZXIucHJvdG90eXBlLmdldFZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIG9uZSB2YWx1ZSBvZiB0aGUgZmlsdGVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSAgaW5kZXhcbiAgICogQHJldHVybiB7Kn0gdmFsdWVcbiAgICovXG4gIEZpbHRlci5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPj0gdGhpcy52YWx1ZXMubGVuZ3RoKSB0aHJvdyAnRXJyb3I6IGluZGV4IG91dCBvZiByYW5nZSc7XG5cbiAgICByZXR1cm4gdGhpcy52YWx1ZXNbaW5kZXhdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgKGZpbHRlcmVkKSBkYXRhUG9pbnRzIGZvciB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGZpbHRlciBpbmRleFxuICAgKiBAcGFyYW0ge051bWJlcn0gW2luZGV4XSAob3B0aW9uYWwpXG4gICAqIEByZXR1cm4ge0FycmF5fSBkYXRhUG9pbnRzXG4gICAqL1xuICBGaWx0ZXIucHJvdG90eXBlLl9nZXREYXRhUG9pbnRzID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIGluZGV4ID0gdGhpcy5pbmRleDtcblxuICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gW107XG5cbiAgICB2YXIgZGF0YVBvaW50cztcbiAgICBpZiAodGhpcy5kYXRhUG9pbnRzW2luZGV4XSkge1xuICAgICAgZGF0YVBvaW50cyA9IHRoaXMuZGF0YVBvaW50c1tpbmRleF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBmID0ge307XG4gICAgICBmLmNvbHVtbiA9IHRoaXMuY29sdW1uO1xuICAgICAgZi52YWx1ZSA9IHRoaXMudmFsdWVzW2luZGV4XTtcblxuICAgICAgdmFyIGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHRoaXMuZGF0YSwgeyBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihpdGVtKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZW1bZi5jb2x1bW5dID09IGYudmFsdWU7XG4gICAgICAgIH0gfSkuZ2V0KCk7XG4gICAgICBkYXRhUG9pbnRzID0gdGhpcy5ncmFwaC5fZ2V0RGF0YVBvaW50cyhkYXRhVmlldyk7XG5cbiAgICAgIHRoaXMuZGF0YVBvaW50c1tpbmRleF0gPSBkYXRhUG9pbnRzO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhUG9pbnRzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgYSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIHRoZSBmaWx0ZXIgaXMgZnVsbHkgbG9hZGVkLlxuICAgKi9cbiAgRmlsdGVyLnByb3RvdHlwZS5zZXRPbkxvYWRDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHRoaXMub25Mb2FkQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGEgdmFsdWUgdG8gdGhlIGxpc3Qgd2l0aCBhdmFpbGFibGUgdmFsdWVzIGZvciB0aGlzIGZpbHRlclxuICAgKiBObyBkb3VibGUgZW50cmllcyB3aWxsIGJlIGNyZWF0ZWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKi9cbiAgRmlsdGVyLnByb3RvdHlwZS5zZWxlY3RWYWx1ZSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIGlmIChpbmRleCA+PSB0aGlzLnZhbHVlcy5sZW5ndGgpIHRocm93ICdFcnJvcjogaW5kZXggb3V0IG9mIHJhbmdlJztcblxuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZXNbaW5kZXhdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMb2FkIGFsbCBmaWx0ZXJlZCByb3dzIGluIHRoZSBiYWNrZ3JvdW5kIG9uZSBieSBvbmVcbiAgICogU3RhcnQgdGhpcyBtZXRob2Qgd2l0aG91dCBwcm92aWRpbmcgYW4gaW5kZXghXG4gICAqL1xuICBGaWx0ZXIucHJvdG90eXBlLmxvYWRJbkJhY2tncm91bmQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkgaW5kZXggPSAwO1xuXG4gICAgdmFyIGZyYW1lID0gdGhpcy5ncmFwaC5mcmFtZTtcblxuICAgIGlmIChpbmRleCA8IHRoaXMudmFsdWVzLmxlbmd0aCkge1xuICAgICAgdmFyIGRhdGFQb2ludHNUZW1wID0gdGhpcy5fZ2V0RGF0YVBvaW50cyhpbmRleCk7XG4gICAgICAvL3RoaXMuZ3JhcGgucmVkcmF3SW5mbygpOyAvLyBUT0RPOiBub3QgbmVhdFxuXG4gICAgICAvLyBjcmVhdGUgYSBwcm9ncmVzcyBib3hcbiAgICAgIGlmIChmcmFtZS5wcm9ncmVzcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZyYW1lLnByb2dyZXNzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XG4gICAgICAgIGZyYW1lLnByb2dyZXNzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgZnJhbWUucHJvZ3Jlc3Muc3R5bGUuY29sb3IgPSAnZ3JheSc7XG4gICAgICAgIGZyYW1lLmFwcGVuZENoaWxkKGZyYW1lLnByb2dyZXNzKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9ncmVzcyA9IHRoaXMuZ2V0TG9hZGVkUHJvZ3Jlc3MoKTtcbiAgICAgIGZyYW1lLnByb2dyZXNzLmlubmVySFRNTCA9ICdMb2FkaW5nIGFuaW1hdGlvbi4uLiAnICsgcHJvZ3Jlc3MgKyAnJSc7XG4gICAgICAvLyBUT0RPOiB0aGlzIGlzIG5vIG5pY2Ugc29sdXRpb24uLi5cbiAgICAgIGZyYW1lLnByb2dyZXNzLnN0eWxlLmJvdHRvbSA9IDYwICsgJ3B4JzsgLy8gVE9ETzogdXNlIGhlaWdodCBvZiBzbGlkZXJcbiAgICAgIGZyYW1lLnByb2dyZXNzLnN0eWxlLmxlZnQgPSAxMCArICdweCc7XG5cbiAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWUubG9hZEluQmFja2dyb3VuZChpbmRleCArIDEpO1xuICAgICAgfSwgMTApO1xuICAgICAgdGhpcy5sb2FkZWQgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2FkZWQgPSB0cnVlO1xuXG4gICAgICAvLyByZW1vdmUgdGhlIHByb2dyZXNzIGJveFxuICAgICAgaWYgKGZyYW1lLnByb2dyZXNzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZnJhbWUucmVtb3ZlQ2hpbGQoZnJhbWUucHJvZ3Jlc3MpO1xuICAgICAgICBmcmFtZS5wcm9ncmVzcyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub25Mb2FkQ2FsbGJhY2spIHRoaXMub25Mb2FkQ2FsbGJhY2soKTtcbiAgICB9XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBGaWx0ZXI7XG5cbi8qKiovIH0sXG4vKiAxOCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yIFNsaWRlclxuICAgKlxuICAgKiBBbiBodG1sIHNsaWRlciBjb250cm9sIHdpdGggc3RhcnQvc3RvcC9wcmV2L25leHQgYnV0dG9uc1xuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRhaW5lciAgVGhlIGVsZW1lbnQgd2hlcmUgdGhlIHNsaWRlciB3aWxsIGJlIGNyZWF0ZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgICBBdmFpbGFibGUgb3B0aW9uczpcbiAgICogICAgICAgICAgICAgICAgIHtib29sZWFufSB2aXNpYmxlICAgSWYgdHJ1ZSAoZGVmYXVsdCkgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xpZGVyIGlzIHZpc2libGUuXG4gICAqL1xuICBmdW5jdGlvbiBTbGlkZXIoY29udGFpbmVyLCBvcHRpb25zKSB7XG4gICAgaWYgKGNvbnRhaW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyAnRXJyb3I6IE5vIGNvbnRhaW5lciBlbGVtZW50IGRlZmluZWQnO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLnZpc2libGUgPSBvcHRpb25zICYmIG9wdGlvbnMudmlzaWJsZSAhPSB1bmRlZmluZWQgPyBvcHRpb25zLnZpc2libGUgOiB0cnVlO1xuXG4gICAgaWYgKHRoaXMudmlzaWJsZSkge1xuICAgICAgdGhpcy5mcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICAgICAgLy90aGlzLmZyYW1lLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcjRTVFNUU1JztcbiAgICAgIHRoaXMuZnJhbWUuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICB0aGlzLmZyYW1lLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZnJhbWUpO1xuXG4gICAgICB0aGlzLmZyYW1lLnByZXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdJTlBVVCcpO1xuICAgICAgdGhpcy5mcmFtZS5wcmV2LnR5cGUgPSAnQlVUVE9OJztcbiAgICAgIHRoaXMuZnJhbWUucHJldi52YWx1ZSA9ICdQcmV2JztcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5mcmFtZS5wcmV2KTtcblxuICAgICAgdGhpcy5mcmFtZS5wbGF5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnSU5QVVQnKTtcbiAgICAgIHRoaXMuZnJhbWUucGxheS50eXBlID0gJ0JVVFRPTic7XG4gICAgICB0aGlzLmZyYW1lLnBsYXkudmFsdWUgPSAnUGxheSc7XG4gICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuZnJhbWUucGxheSk7XG5cbiAgICAgIHRoaXMuZnJhbWUubmV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0lOUFVUJyk7XG4gICAgICB0aGlzLmZyYW1lLm5leHQudHlwZSA9ICdCVVRUT04nO1xuICAgICAgdGhpcy5mcmFtZS5uZXh0LnZhbHVlID0gJ05leHQnO1xuICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmZyYW1lLm5leHQpO1xuXG4gICAgICB0aGlzLmZyYW1lLmJhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0lOUFVUJyk7XG4gICAgICB0aGlzLmZyYW1lLmJhci50eXBlID0gJ0JVVFRPTic7XG4gICAgICB0aGlzLmZyYW1lLmJhci5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICB0aGlzLmZyYW1lLmJhci5zdHlsZS5ib3JkZXIgPSAnMXB4IHNvbGlkIHJlZCc7XG4gICAgICB0aGlzLmZyYW1lLmJhci5zdHlsZS53aWR0aCA9ICcxMDBweCc7XG4gICAgICB0aGlzLmZyYW1lLmJhci5zdHlsZS5oZWlnaHQgPSAnNnB4JztcbiAgICAgIHRoaXMuZnJhbWUuYmFyLnN0eWxlLmJvcmRlclJhZGl1cyA9ICcycHgnO1xuICAgICAgdGhpcy5mcmFtZS5iYXIuc3R5bGUuTW96Qm9yZGVyUmFkaXVzID0gJzJweCc7XG4gICAgICB0aGlzLmZyYW1lLmJhci5zdHlsZS5ib3JkZXIgPSAnMXB4IHNvbGlkICM3RjdGN0YnO1xuICAgICAgdGhpcy5mcmFtZS5iYXIuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyNFNUU1RTUnO1xuICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmZyYW1lLmJhcik7XG5cbiAgICAgIHRoaXMuZnJhbWUuc2xpZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdJTlBVVCcpO1xuICAgICAgdGhpcy5mcmFtZS5zbGlkZS50eXBlID0gJ0JVVFRPTic7XG4gICAgICB0aGlzLmZyYW1lLnNsaWRlLnN0eWxlLm1hcmdpbiA9ICcwcHgnO1xuICAgICAgdGhpcy5mcmFtZS5zbGlkZS52YWx1ZSA9ICcgJztcbiAgICAgIHRoaXMuZnJhbWUuc2xpZGUuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgdGhpcy5mcmFtZS5zbGlkZS5zdHlsZS5sZWZ0ID0gJy0xMDBweCc7XG4gICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuZnJhbWUuc2xpZGUpO1xuXG4gICAgICAvLyBjcmVhdGUgZXZlbnRzXG4gICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgdGhpcy5mcmFtZS5zbGlkZS5vbm1vdXNlZG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBtZS5fb25Nb3VzZURvd24oZXZlbnQpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuZnJhbWUucHJldi5vbmNsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIG1lLnByZXYoZXZlbnQpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuZnJhbWUucGxheS5vbmNsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIG1lLnRvZ2dsZVBsYXkoZXZlbnQpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuZnJhbWUubmV4dC5vbmNsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIG1lLm5leHQoZXZlbnQpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sgPSB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLnZhbHVlcyA9IFtdO1xuICAgIHRoaXMuaW5kZXggPSB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLnBsYXlUaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGxheUludGVydmFsID0gMTAwMDsgLy8gbWlsbGlzZWNvbmRzXG4gICAgdGhpcy5wbGF5TG9vcCA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogU2VsZWN0IHRoZSBwcmV2aW91cyBpbmRleFxuICAgKi9cbiAgU2xpZGVyLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbmRleCA9IHRoaXMuZ2V0SW5kZXgoKTtcbiAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICBpbmRleC0tO1xuICAgICAgdGhpcy5zZXRJbmRleChpbmRleCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZWxlY3QgdGhlIG5leHQgaW5kZXhcbiAgICovXG4gIFNsaWRlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmdldEluZGV4KCk7XG4gICAgaWYgKGluZGV4IDwgdGhpcy52YWx1ZXMubGVuZ3RoIC0gMSkge1xuICAgICAgaW5kZXgrKztcbiAgICAgIHRoaXMuc2V0SW5kZXgoaW5kZXgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2VsZWN0IHRoZSBuZXh0IGluZGV4XG4gICAqL1xuICBTbGlkZXIucHJvdG90eXBlLnBsYXlOZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGFydCA9IG5ldyBEYXRlKCk7XG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLmdldEluZGV4KCk7XG4gICAgaWYgKGluZGV4IDwgdGhpcy52YWx1ZXMubGVuZ3RoIC0gMSkge1xuICAgICAgaW5kZXgrKztcbiAgICAgIHRoaXMuc2V0SW5kZXgoaW5kZXgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wbGF5TG9vcCkge1xuICAgICAgLy8ganVtcCB0byB0aGUgc3RhcnRcbiAgICAgIGluZGV4ID0gMDtcbiAgICAgIHRoaXMuc2V0SW5kZXgoaW5kZXgpO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBuZXcgRGF0ZSgpO1xuICAgIHZhciBkaWZmID0gZW5kIC0gc3RhcnQ7XG5cbiAgICAvLyBjYWxjdWxhdGUgaG93IG11Y2ggdGltZSBpdCB0byB0byBzZXQgdGhlIGluZGV4IGFuZCB0byBleGVjdXRlIHRoZSBjYWxsYmFja1xuICAgIC8vIGZ1bmN0aW9uLlxuICAgIHZhciBpbnRlcnZhbCA9IE1hdGgubWF4KHRoaXMucGxheUludGVydmFsIC0gZGlmZiwgMCk7XG4gICAgLy8gZG9jdW1lbnQudGl0bGUgPSBkaWZmIC8vIFRPRE86IGNsZWFudXBcblxuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdGhpcy5wbGF5VGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgbWUucGxheU5leHQoKTtcbiAgICB9LCBpbnRlcnZhbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRvZ2dsZSBzdGFydCBvciBzdG9wIHBsYXlpbmdcbiAgICovXG4gIFNsaWRlci5wcm90b3R5cGUudG9nZ2xlUGxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5wbGF5VGltZW91dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnBsYXkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdG9wKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTdGFydCBwbGF5aW5nXG4gICAqL1xuICBTbGlkZXIucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gVGVzdCB3aGV0aGVyIGFscmVhZHkgcGxheWluZ1xuICAgIGlmICh0aGlzLnBsYXlUaW1lb3V0KSByZXR1cm47XG5cbiAgICB0aGlzLnBsYXlOZXh0KCk7XG5cbiAgICBpZiAodGhpcy5mcmFtZSkge1xuICAgICAgdGhpcy5mcmFtZS5wbGF5LnZhbHVlID0gJ1N0b3AnO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU3RvcCBwbGF5aW5nXG4gICAqL1xuICBTbGlkZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLnBsYXlUaW1lb3V0KTtcbiAgICB0aGlzLnBsYXlUaW1lb3V0ID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKHRoaXMuZnJhbWUpIHtcbiAgICAgIHRoaXMuZnJhbWUucGxheS52YWx1ZSA9ICdQbGF5JztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgdHJpZ2dlcmVkIHdoZW4gdGhlIHZhbHVlIG9mIHRoZVxuICAgKiBzbGlkZXIgYmFyIGhhcyBjaGFuZ2VkLlxuICAgKi9cbiAgU2xpZGVyLnByb3RvdHlwZS5zZXRPbkNoYW5nZUNhbGxiYWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgaW50ZXJ2YWwgZm9yIHBsYXlpbmcgdGhlIGxpc3RcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGludGVydmFsICAgVGhlIGludGVydmFsIGluIG1pbGxpc2Vjb25kc1xuICAgKi9cbiAgU2xpZGVyLnByb3RvdHlwZS5zZXRQbGF5SW50ZXJ2YWwgPSBmdW5jdGlvbiAoaW50ZXJ2YWwpIHtcbiAgICB0aGlzLnBsYXlJbnRlcnZhbCA9IGludGVydmFsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgY3VycmVudCBwbGF5IGludGVydmFsXG4gICAqIEByZXR1cm4ge051bWJlcn0gaW50ZXJ2YWwgICBUaGUgaW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzXG4gICAqL1xuICBTbGlkZXIucHJvdG90eXBlLmdldFBsYXlJbnRlcnZhbCA9IGZ1bmN0aW9uIChpbnRlcnZhbCkge1xuICAgIHJldHVybiB0aGlzLnBsYXlJbnRlcnZhbDtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGxvb3Bpbmcgb24gb3Igb2ZmXG4gICAqIEBwYXJhcm0ge2Jvb2xlYW59IGRvTG9vcCAgSWYgdHJ1ZSwgdGhlIHNsaWRlciB3aWxsIGp1bXAgdG8gdGhlIHN0YXJ0IHdoZW5cbiAgICogICAgICAgICAgICAgICB0aGUgZW5kIGlzIHBhc3NlZCwgYW5kIHdpbGwganVtcCB0byB0aGUgZW5kXG4gICAqICAgICAgICAgICAgICAgd2hlbiB0aGUgc3RhcnQgaXMgcGFzc2VkLlxuICAgKi9cbiAgU2xpZGVyLnByb3RvdHlwZS5zZXRQbGF5TG9vcCA9IGZ1bmN0aW9uIChkb0xvb3ApIHtcbiAgICB0aGlzLnBsYXlMb29wID0gZG9Mb29wO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFeGVjdXRlIHRoZSBvbmNoYW5nZSBjYWxsYmFjayBmdW5jdGlvblxuICAgKi9cbiAgU2xpZGVyLnByb3RvdHlwZS5vbkNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5vbkNoYW5nZUNhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogcmVkcmF3IHRoZSBzbGlkZXIgb24gdGhlIGNvcnJlY3QgcGxhY2VcbiAgICovXG4gIFNsaWRlci5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmZyYW1lKSB7XG4gICAgICAvLyByZXNpemUgdGhlIGJhclxuICAgICAgdGhpcy5mcmFtZS5iYXIuc3R5bGUudG9wID0gdGhpcy5mcmFtZS5jbGllbnRIZWlnaHQgLyAyIC0gdGhpcy5mcmFtZS5iYXIub2Zmc2V0SGVpZ2h0IC8gMiArICdweCc7XG4gICAgICB0aGlzLmZyYW1lLmJhci5zdHlsZS53aWR0aCA9IHRoaXMuZnJhbWUuY2xpZW50V2lkdGggLSB0aGlzLmZyYW1lLnByZXYuY2xpZW50V2lkdGggLSB0aGlzLmZyYW1lLnBsYXkuY2xpZW50V2lkdGggLSB0aGlzLmZyYW1lLm5leHQuY2xpZW50V2lkdGggLSAzMCArICdweCc7XG5cbiAgICAgIC8vIHBvc2l0aW9uIHRoZSBzbGlkZXIgYnV0dG9uXG4gICAgICB2YXIgbGVmdCA9IHRoaXMuaW5kZXhUb0xlZnQodGhpcy5pbmRleCk7XG4gICAgICB0aGlzLmZyYW1lLnNsaWRlLnN0eWxlLmxlZnQgPSBsZWZ0ICsgJ3B4JztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbGlzdCB3aXRoIHZhbHVlcyBmb3IgdGhlIHNsaWRlclxuICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgICBBIGphdmFzY3JpcHQgYXJyYXkgd2l0aCB2YWx1ZXMgKGFueSB0eXBlKVxuICAgKi9cbiAgU2xpZGVyLnByb3RvdHlwZS5zZXRWYWx1ZXMgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgICBpZiAodGhpcy52YWx1ZXMubGVuZ3RoID4gMCkgdGhpcy5zZXRJbmRleCgwKTtlbHNlIHRoaXMuaW5kZXggPSB1bmRlZmluZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNlbGVjdCBhIHZhbHVlIGJ5IGl0cyBpbmRleFxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICovXG4gIFNsaWRlci5wcm90b3R5cGUuc2V0SW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPCB0aGlzLnZhbHVlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcblxuICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICAgIHRoaXMub25DaGFuZ2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgJ0Vycm9yOiBpbmRleCBvdXQgb2YgcmFuZ2UnO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogcmV0cmlldmUgdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdmF1ZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGluZGV4XG4gICAqL1xuICBTbGlkZXIucHJvdG90eXBlLmdldEluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmluZGV4O1xuICB9O1xuXG4gIC8qKlxuICAgKiByZXRyaWV2ZSB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHZhbHVlXG4gICAqIEByZXR1cm4geyp9IHZhbHVlXG4gICAqL1xuICBTbGlkZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXNbdGhpcy5pbmRleF07XG4gIH07XG5cbiAgU2xpZGVyLnByb3RvdHlwZS5fb25Nb3VzZURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBvbmx5IHJlYWN0IG9uIGxlZnQgbW91c2UgYnV0dG9uIGRvd25cbiAgICB2YXIgbGVmdEJ1dHRvbkRvd24gPSBldmVudC53aGljaCA/IGV2ZW50LndoaWNoID09PSAxIDogZXZlbnQuYnV0dG9uID09PSAxO1xuICAgIGlmICghbGVmdEJ1dHRvbkRvd24pIHJldHVybjtcblxuICAgIHRoaXMuc3RhcnRDbGllbnRYID0gZXZlbnQuY2xpZW50WDtcbiAgICB0aGlzLnN0YXJ0U2xpZGVYID0gcGFyc2VGbG9hdCh0aGlzLmZyYW1lLnNsaWRlLnN0eWxlLmxlZnQpO1xuXG4gICAgdGhpcy5mcmFtZS5zdHlsZS5jdXJzb3IgPSAnbW92ZSc7XG5cbiAgICAvLyBhZGQgZXZlbnQgbGlzdGVuZXJzIHRvIGhhbmRsZSBtb3ZpbmcgdGhlIGNvbnRlbnRzXG4gICAgLy8gd2Ugc3RvcmUgdGhlIGZ1bmN0aW9uIG9ubW91c2Vtb3ZlIGFuZCBvbm1vdXNldXAgaW4gdGhlIGdyYXBoLCBzbyB3ZSBjYW5cbiAgICAvLyByZW1vdmUgdGhlIGV2ZW50bGlzdGVuZXJzIGxhdGVyb24gaW4gdGhlIGZ1bmN0aW9uIG1vdXNlVXAoKVxuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdGhpcy5vbm1vdXNlbW92ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgbWUuX29uTW91c2VNb3ZlKGV2ZW50KTtcbiAgICB9O1xuICAgIHRoaXMub25tb3VzZXVwID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBtZS5fb25Nb3VzZVVwKGV2ZW50KTtcbiAgICB9O1xuICAgIHV0aWwuYWRkRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMub25tb3VzZW1vdmUpO1xuICAgIHV0aWwuYWRkRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgJ21vdXNldXAnLCB0aGlzLm9ubW91c2V1cCk7XG4gICAgdXRpbC5wcmV2ZW50RGVmYXVsdChldmVudCk7XG4gIH07XG5cbiAgU2xpZGVyLnByb3RvdHlwZS5sZWZ0VG9JbmRleCA9IGZ1bmN0aW9uIChsZWZ0KSB7XG4gICAgdmFyIHdpZHRoID0gcGFyc2VGbG9hdCh0aGlzLmZyYW1lLmJhci5zdHlsZS53aWR0aCkgLSB0aGlzLmZyYW1lLnNsaWRlLmNsaWVudFdpZHRoIC0gMTA7XG4gICAgdmFyIHggPSBsZWZ0IC0gMztcblxuICAgIHZhciBpbmRleCA9IE1hdGgucm91bmQoeCAvIHdpZHRoICogKHRoaXMudmFsdWVzLmxlbmd0aCAtIDEpKTtcbiAgICBpZiAoaW5kZXggPCAwKSBpbmRleCA9IDA7XG4gICAgaWYgKGluZGV4ID4gdGhpcy52YWx1ZXMubGVuZ3RoIC0gMSkgaW5kZXggPSB0aGlzLnZhbHVlcy5sZW5ndGggLSAxO1xuXG4gICAgcmV0dXJuIGluZGV4O1xuICB9O1xuXG4gIFNsaWRlci5wcm90b3R5cGUuaW5kZXhUb0xlZnQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICB2YXIgd2lkdGggPSBwYXJzZUZsb2F0KHRoaXMuZnJhbWUuYmFyLnN0eWxlLndpZHRoKSAtIHRoaXMuZnJhbWUuc2xpZGUuY2xpZW50V2lkdGggLSAxMDtcblxuICAgIHZhciB4ID0gaW5kZXggLyAodGhpcy52YWx1ZXMubGVuZ3RoIC0gMSkgKiB3aWR0aDtcbiAgICB2YXIgbGVmdCA9IHggKyAzO1xuXG4gICAgcmV0dXJuIGxlZnQ7XG4gIH07XG5cbiAgU2xpZGVyLnByb3RvdHlwZS5fb25Nb3VzZU1vdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZGlmZiA9IGV2ZW50LmNsaWVudFggLSB0aGlzLnN0YXJ0Q2xpZW50WDtcbiAgICB2YXIgeCA9IHRoaXMuc3RhcnRTbGlkZVggKyBkaWZmO1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5sZWZ0VG9JbmRleCh4KTtcblxuICAgIHRoaXMuc2V0SW5kZXgoaW5kZXgpO1xuXG4gICAgdXRpbC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9O1xuXG4gIFNsaWRlci5wcm90b3R5cGUuX29uTW91c2VVcCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHRoaXMuZnJhbWUuc3R5bGUuY3Vyc29yID0gJ2F1dG8nO1xuXG4gICAgLy8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVyc1xuICAgIHV0aWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMub25tb3VzZW1vdmUpO1xuICAgIHV0aWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgJ21vdXNldXAnLCB0aGlzLm9ubW91c2V1cCk7XG5cbiAgICB1dGlsLnByZXZlbnREZWZhdWx0KCk7XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBTbGlkZXI7XG5cbi8qKiovIH0sXG4vKiAxOSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgLyoqXG4gICAqIEBwcm90b3R5cGUgU3RlcE51bWJlclxuICAgKiBUaGUgY2xhc3MgU3RlcE51bWJlciBpcyBhbiBpdGVyYXRvciBmb3IgTnVtYmVycy4gWW91IHByb3ZpZGUgYSBzdGFydCBhbmQgZW5kXG4gICAqIHZhbHVlLCBhbmQgYSBiZXN0IHN0ZXAgc2l6ZS4gU3RlcE51bWJlciBpdHNlbGYgcm91bmRzIHRvIGZpeGVkIHZhbHVlcyBhbmRcbiAgICogYSBmaW5kcyB0aGUgc3RlcCB0aGF0IGJlc3QgZml0cyB0aGUgcHJvdmlkZWQgc3RlcC5cbiAgICpcbiAgICogSWYgcHJldHR5U3RlcCBpcyB0cnVlLCB0aGUgc3RlcCBzaXplIGlzIGNob3NlbiBhcyBjbG9zZSBhcyBwb3NzaWJsZSB0byB0aGVcbiAgICogcHJvdmlkZWQgc3RlcCwgYnV0IGJlaW5nIGEgcm91bmQgdmFsdWUgbGlrZSAxLCAyLCA1LCAxMCwgMjAsIDUwLCAuLi4uXG4gICAqXG4gICAqIEV4YW1wbGUgdXNhZ2U6XG4gICAqICAgdmFyIHN0ZXAgPSBuZXcgU3RlcE51bWJlcigwLCAxMCwgMi41LCB0cnVlKTtcbiAgICogICBzdGVwLnN0YXJ0KCk7XG4gICAqICAgd2hpbGUgKCFzdGVwLmVuZCgpKSB7XG4gICAqICAgYWxlcnQoc3RlcC5nZXRDdXJyZW50KCkpO1xuICAgKiAgIHN0ZXAubmV4dCgpO1xuICAgKiAgIH1cbiAgICpcbiAgICogVmVyc2lvbjogMS4wXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCAgICAgVGhlIHN0YXJ0IHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgICAgIFRoZSBlbmQgdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0ZXAgICAgT3B0aW9uYWwuIFN0ZXAgc2l6ZS4gTXVzdCBiZSBhIHBvc2l0aXZlIHZhbHVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHByZXR0eVN0ZXAgT3B0aW9uYWwuIElmIHRydWUsIHRoZSBzdGVwIHNpemUgaXMgcm91bmRlZFxuICAgKiAgICAgICAgICAgICAgIFRvIGEgcHJldHR5IHN0ZXAgc2l6ZSAobGlrZSAxLCAyLCA1LCAxMCwgMjAsIDUwLCAuLi4pXG4gICAqL1xuICBmdW5jdGlvbiBTdGVwTnVtYmVyKHN0YXJ0LCBlbmQsIHN0ZXAsIHByZXR0eVN0ZXApIHtcbiAgICAvLyBzZXQgZGVmYXVsdCB2YWx1ZXNcbiAgICB0aGlzLl9zdGFydCA9IDA7XG4gICAgdGhpcy5fZW5kID0gMDtcbiAgICB0aGlzLl9zdGVwID0gMTtcbiAgICB0aGlzLnByZXR0eVN0ZXAgPSB0cnVlO1xuICAgIHRoaXMucHJlY2lzaW9uID0gNTtcblxuICAgIHRoaXMuX2N1cnJlbnQgPSAwO1xuICAgIHRoaXMuc2V0UmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCwgcHJldHR5U3RlcCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBhIG5ldyByYW5nZTogc3RhcnQsIGVuZCBhbmQgc3RlcC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0ICAgICBUaGUgc3RhcnQgdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZCAgICAgVGhlIGVuZCB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gc3RlcCAgICBPcHRpb25hbC4gU3RlcCBzaXplLiBNdXN0IGJlIGEgcG9zaXRpdmUgdmFsdWUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJldHR5U3RlcCBPcHRpb25hbC4gSWYgdHJ1ZSwgdGhlIHN0ZXAgc2l6ZSBpcyByb3VuZGVkXG4gICAqICAgICAgICAgICAgICAgVG8gYSBwcmV0dHkgc3RlcCBzaXplIChsaWtlIDEsIDIsIDUsIDEwLCAyMCwgNTAsIC4uLilcbiAgICovXG4gIFN0ZXBOdW1iZXIucHJvdG90eXBlLnNldFJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHN0ZXAsIHByZXR0eVN0ZXApIHtcbiAgICB0aGlzLl9zdGFydCA9IHN0YXJ0ID8gc3RhcnQgOiAwO1xuICAgIHRoaXMuX2VuZCA9IGVuZCA/IGVuZCA6IDA7XG5cbiAgICB0aGlzLnNldFN0ZXAoc3RlcCwgcHJldHR5U3RlcCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBhIG5ldyBzdGVwIHNpemVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0ZXAgICAgTmV3IHN0ZXAgc2l6ZS4gTXVzdCBiZSBhIHBvc2l0aXZlIHZhbHVlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJldHR5U3RlcCBPcHRpb25hbC4gSWYgdHJ1ZSwgdGhlIHByb3ZpZGVkIHN0ZXAgaXMgcm91bmRlZFxuICAgKiAgICAgICAgICAgICAgIHRvIGEgcHJldHR5IHN0ZXAgc2l6ZSAobGlrZSAxLCAyLCA1LCAxMCwgMjAsIDUwLCAuLi4pXG4gICAqL1xuICBTdGVwTnVtYmVyLnByb3RvdHlwZS5zZXRTdGVwID0gZnVuY3Rpb24gKHN0ZXAsIHByZXR0eVN0ZXApIHtcbiAgICBpZiAoc3RlcCA9PT0gdW5kZWZpbmVkIHx8IHN0ZXAgPD0gMCkgcmV0dXJuO1xuXG4gICAgaWYgKHByZXR0eVN0ZXAgIT09IHVuZGVmaW5lZCkgdGhpcy5wcmV0dHlTdGVwID0gcHJldHR5U3RlcDtcblxuICAgIGlmICh0aGlzLnByZXR0eVN0ZXAgPT09IHRydWUpIHRoaXMuX3N0ZXAgPSBTdGVwTnVtYmVyLmNhbGN1bGF0ZVByZXR0eVN0ZXAoc3RlcCk7ZWxzZSB0aGlzLl9zdGVwID0gc3RlcDtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIGEgbmljZSBzdGVwIHNpemUsIGNsb3Nlc3QgdG8gdGhlIGRlc2lyZWQgc3RlcCBzaXplLlxuICAgKiBSZXR1cm5zIGEgdmFsdWUgaW4gb25lIG9mIHRoZSByYW5nZXMgMSoxMF5uLCAyKjEwXm4sIG9yIDUqMTBebiwgd2hlcmUgbiBpcyBhblxuICAgKiBpbnRlZ2VyIE51bWJlci4gRm9yIGV4YW1wbGUgMSwgMiwgNSwgMTAsIDIwLCA1MCwgZXRjLi4uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSAgc3RlcCAgRGVzaXJlZCBzdGVwIHNpemVcbiAgICogQHJldHVybiB7TnVtYmVyfSAgICAgTmljZSBzdGVwIHNpemVcbiAgICovXG4gIFN0ZXBOdW1iZXIuY2FsY3VsYXRlUHJldHR5U3RlcCA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgdmFyIGxvZzEwID0gZnVuY3Rpb24gbG9nMTAoeCkge1xuICAgICAgcmV0dXJuIE1hdGgubG9nKHgpIC8gTWF0aC5MTjEwO1xuICAgIH07XG5cbiAgICAvLyB0cnkgdGhyZWUgc3RlcHMgKG11bHRpcGxlIG9mIDEsIDIsIG9yIDVcbiAgICB2YXIgc3RlcDEgPSBNYXRoLnBvdygxMCwgTWF0aC5yb3VuZChsb2cxMChzdGVwKSkpLFxuICAgICAgICBzdGVwMiA9IDIgKiBNYXRoLnBvdygxMCwgTWF0aC5yb3VuZChsb2cxMChzdGVwIC8gMikpKSxcbiAgICAgICAgc3RlcDUgPSA1ICogTWF0aC5wb3coMTAsIE1hdGgucm91bmQobG9nMTAoc3RlcCAvIDUpKSk7XG5cbiAgICAvLyBjaG9vc2UgdGhlIGJlc3Qgc3RlcCAoY2xvc2VzdCB0byBtaW5pbXVtIHN0ZXApXG4gICAgdmFyIHByZXR0eVN0ZXAgPSBzdGVwMTtcbiAgICBpZiAoTWF0aC5hYnMoc3RlcDIgLSBzdGVwKSA8PSBNYXRoLmFicyhwcmV0dHlTdGVwIC0gc3RlcCkpIHByZXR0eVN0ZXAgPSBzdGVwMjtcbiAgICBpZiAoTWF0aC5hYnMoc3RlcDUgLSBzdGVwKSA8PSBNYXRoLmFicyhwcmV0dHlTdGVwIC0gc3RlcCkpIHByZXR0eVN0ZXAgPSBzdGVwNTtcblxuICAgIC8vIGZvciBzYWZldHlcbiAgICBpZiAocHJldHR5U3RlcCA8PSAwKSB7XG4gICAgICBwcmV0dHlTdGVwID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJldHR5U3RlcDtcbiAgfTtcblxuICAvKipcbiAgICogcmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgc3RlcFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGN1cnJlbnQgdmFsdWVcbiAgICovXG4gIFN0ZXBOdW1iZXIucHJvdG90eXBlLmdldEN1cnJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodGhpcy5fY3VycmVudC50b1ByZWNpc2lvbih0aGlzLnByZWNpc2lvbikpO1xuICB9O1xuXG4gIC8qKlxuICAgKiByZXR1cm5zIHRoZSBjdXJyZW50IHN0ZXAgc2l6ZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGN1cnJlbnQgc3RlcCBzaXplXG4gICAqL1xuICBTdGVwTnVtYmVyLnByb3RvdHlwZS5nZXRTdGVwID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGVwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGN1cnJlbnQgdmFsdWUgdG8gdGhlIGxhcmdlc3QgdmFsdWUgc21hbGxlciB0aGFuIHN0YXJ0LCB3aGljaFxuICAgKiBpcyBhIG11bHRpcGxlIG9mIHRoZSBzdGVwIHNpemVcbiAgICovXG4gIFN0ZXBOdW1iZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2N1cnJlbnQgPSB0aGlzLl9zdGFydCAtIHRoaXMuX3N0YXJ0ICUgdGhpcy5fc3RlcDtcbiAgfTtcblxuICAvKipcbiAgICogRG8gYSBzdGVwLCBhZGQgdGhlIHN0ZXAgc2l6ZSB0byB0aGUgY3VycmVudCB2YWx1ZVxuICAgKi9cbiAgU3RlcE51bWJlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jdXJyZW50ICs9IHRoaXMuX3N0ZXA7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSB3aGV0aGVyIHRoZSBlbmQgaXMgcmVhY2hlZFxuICAgKiBAcmV0dXJuIHtib29sZWFufSAgVHJ1ZSBpZiB0aGUgY3VycmVudCB2YWx1ZSBoYXMgcGFzc2VkIHRoZSBlbmQgdmFsdWUuXG4gICAqL1xuICBTdGVwTnVtYmVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnQgPiB0aGlzLl9lbmQ7XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBTdGVwTnVtYmVyO1xuXG4vKioqLyB9LFxuLyogMjAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBPbmx5IGxvYWQgaGFtbWVyLmpzIHdoZW4gaW4gYSBicm93c2VyIGVudmlyb25tZW50XG4gIC8vIChsb2FkaW5nIGhhbW1lci5qcyBpbiBhIG5vZGUuanMgZW52aXJvbm1lbnQgZ2l2ZXMgZXJyb3JzKVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgcHJvcGFnYXRpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcbiAgICB2YXIgSGFtbWVyID0gd2luZG93WydIYW1tZXInXSB8fCBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHByb3BhZ2F0aW5nKEhhbW1lciwge1xuICAgICAgcHJldmVudERlZmF1bHQ6ICdtb3VzZSdcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IEVycm9yKCdoYW1tZXIuanMgaXMgb25seSBhdmFpbGFibGUgaW4gYSBicm93c2VyLCBub3QgaW4gbm9kZS5qcy4nKTtcbiAgICB9O1xuICB9XG5cbi8qKiovIH0sXG4vKiAyMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgdmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187J3VzZSBzdHJpY3QnO1xuXG4gIChmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgIGlmICh0cnVlKSB7XG4gICAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgICAhKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID0gKGZhY3RvcnkpLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9ICh0eXBlb2YgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID09PSAnZnVuY3Rpb24nID8gKF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXy5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSkgOiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18pLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIC8vIE5vZGUuIERvZXMgbm90IHdvcmsgd2l0aCBzdHJpY3QgQ29tbW9uSlMsIGJ1dFxuICAgICAgLy8gb25seSBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMsXG4gICAgICAvLyBsaWtlIE5vZGUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQnJvd3NlciBnbG9iYWxzIChyb290IGlzIHdpbmRvdylcbiAgICAgIHdpbmRvdy5wcm9wYWdhdGluZyA9IGZhY3RvcnkoKTtcbiAgICB9XG4gIH0oZnVuY3Rpb24gKCkge1xuICAgIHZhciBfZmlyc3RUYXJnZXQgPSBudWxsOyAvLyBzaW5nbGV0b24sIHdpbGwgY29udGFpbiB0aGUgdGFyZ2V0IGVsZW1lbnQgd2hlcmUgdGhlIHRvdWNoIGV2ZW50IHN0YXJ0ZWRcblxuICAgIC8qKlxuICAgICAqIEV4dGVuZCBhbiBIYW1tZXIuanMgaW5zdGFuY2Ugd2l0aCBldmVudCBwcm9wYWdhdGlvbi5cbiAgICAgKlxuICAgICAqIEZlYXR1cmVzOlxuICAgICAqIC0gRXZlbnRzIGVtaXR0ZWQgYnkgaGFtbWVyIHdpbGwgcHJvcGFnYXRlIGluIG9yZGVyIGZyb20gY2hpbGQgdG8gcGFyZW50XG4gICAgICogICBlbGVtZW50cy5cbiAgICAgKiAtIEV2ZW50cyBhcmUgZXh0ZW5kZWQgd2l0aCBhIGZ1bmN0aW9uIGBldmVudC5zdG9wUHJvcGFnYXRpb24oKWAgdG8gc3RvcFxuICAgICAqICAgcHJvcGFnYXRpb24gdG8gcGFyZW50IGVsZW1lbnRzLlxuICAgICAqIC0gQW4gb3B0aW9uIGBwcmV2ZW50RGVmYXVsdGAgdG8gc3RvcCBhbGwgZGVmYXVsdCBicm93c2VyIGJlaGF2aW9yLlxuICAgICAqXG4gICAgICogVXNhZ2U6XG4gICAgICogICB2YXIgaGFtbWVyID0gcHJvcGFnYXRpbmdIYW1tZXIobmV3IEhhbW1lcihlbGVtZW50KSk7XG4gICAgICogICB2YXIgaGFtbWVyID0gcHJvcGFnYXRpbmdIYW1tZXIobmV3IEhhbW1lcihlbGVtZW50KSwge3ByZXZlbnREZWZhdWx0OiB0cnVlfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hhbW1lci5NYW5hZ2VyfSBoYW1tZXIgICBBbiBoYW1tZXIgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICAgICAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBgcHJldmVudERlZmF1bHQ6IHRydWUgfCBmYWxzZSB8ICdtb3VzZScgfCAndG91Y2gnIHwgJ3BlbidgLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRW5mb3JjZSBwcmV2ZW50aW5nIHRoZSBkZWZhdWx0IGJyb3dzZXIgYmVoYXZpb3IuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDYW5ub3QgYmUgc2V0IHRvIGBmYWxzZWAuXG4gICAgICogQHJldHVybiB7SGFtbWVyLk1hbmFnZXJ9IFJldHVybnMgdGhlIHNhbWUgaGFtbWVyIGluc3RhbmNlIHdpdGggZXh0ZW5kZWRcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25hbGl0eVxuICAgICAqL1xuICAgIHJldHVybiBmdW5jdGlvbiBwcm9wYWdhdGluZyhoYW1tZXIsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMgfHwge1xuICAgICAgICBwcmV2ZW50RGVmYXVsdDogZmFsc2VcbiAgICAgIH07XG5cbiAgICAgIGlmIChoYW1tZXIuTWFuYWdlcikge1xuICAgICAgICAvLyBUaGlzIGxvb2tzIGxpa2UgdGhlIEhhbW1lciBjb25zdHJ1Y3Rvci5cbiAgICAgICAgLy8gT3ZlcmxvYWQgdGhlIGNvbnN0cnVjdG9ycyB3aXRoIG91ciBvd24uXG4gICAgICAgIHZhciBIYW1tZXIgPSBoYW1tZXI7XG5cbiAgICAgICAgdmFyIFByb3BhZ2F0aW5nSGFtbWVyID0gZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgICAgIHZhciBvID0gT2JqZWN0LmNyZWF0ZShfb3B0aW9ucyk7XG4gICAgICAgICAgaWYgKG9wdGlvbnMpIEhhbW1lci5hc3NpZ24obywgb3B0aW9ucyk7XG4gICAgICAgICAgcmV0dXJuIHByb3BhZ2F0aW5nKG5ldyBIYW1tZXIoZWxlbWVudCwgbyksIG8pO1xuICAgICAgICB9O1xuICAgICAgICBIYW1tZXIuYXNzaWduKFByb3BhZ2F0aW5nSGFtbWVyLCBIYW1tZXIpO1xuXG4gICAgICAgIFByb3BhZ2F0aW5nSGFtbWVyLk1hbmFnZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgICAgIHZhciBvID0gT2JqZWN0LmNyZWF0ZShfb3B0aW9ucyk7XG4gICAgICAgICAgaWYgKG9wdGlvbnMpIEhhbW1lci5hc3NpZ24obywgb3B0aW9ucyk7XG4gICAgICAgICAgcmV0dXJuIHByb3BhZ2F0aW5nKG5ldyBIYW1tZXIuTWFuYWdlcihlbGVtZW50LCBvKSwgbyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIFByb3BhZ2F0aW5nSGFtbWVyO1xuICAgICAgfVxuXG4gICAgICAvLyBjcmVhdGUgYSB3cmFwcGVyIG9iamVjdCB3aGljaCB3aWxsIG92ZXJyaWRlIHRoZSBmdW5jdGlvbnNcbiAgICAgIC8vIGBvbmAsIGBvZmZgLCBgZGVzdHJveWAsIGFuZCBgZW1pdGAgb2YgdGhlIGhhbW1lciBpbnN0YW5jZVxuICAgICAgdmFyIHdyYXBwZXIgPSBPYmplY3QuY3JlYXRlKGhhbW1lcik7XG5cbiAgICAgIC8vIGF0dGFjaCB0byBET00gZWxlbWVudFxuICAgICAgdmFyIGVsZW1lbnQgPSBoYW1tZXIuZWxlbWVudDtcblxuICAgICAgaWYoIWVsZW1lbnQuaGFtbWVyKSBlbGVtZW50LmhhbW1lciA9IFtdO1xuICAgICAgZWxlbWVudC5oYW1tZXIucHVzaCh3cmFwcGVyKTtcblxuICAgICAgLy8gcmVnaXN0ZXIgYW4gZXZlbnQgdG8gY2F0Y2ggdGhlIHN0YXJ0IG9mIGEgZ2VzdHVyZSBhbmQgc3RvcmUgdGhlXG4gICAgICAvLyB0YXJnZXQgaW4gYSBzaW5nbGV0b25cbiAgICAgIGhhbW1lci5vbignaGFtbWVyLmlucHV0JywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChfb3B0aW9ucy5wcmV2ZW50RGVmYXVsdCA9PT0gdHJ1ZSB8fCAoX29wdGlvbnMucHJldmVudERlZmF1bHQgPT09IGV2ZW50LnBvaW50ZXJUeXBlKSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LmlzRmlyc3QpIHtcbiAgICAgICAgICBfZmlyc3RUYXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvKiogQHR5cGUge09iamVjdC48U3RyaW5nLCBBcnJheS48ZnVuY3Rpb24+Pn0gKi9cbiAgICAgIHdyYXBwZXIuX2hhbmRsZXJzID0ge307XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVnaXN0ZXIgYSBoYW5kbGVyIGZvciBvbmUgb3IgbXVsdGlwbGUgZXZlbnRzXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRzICAgIEEgc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyB3aXRoIGV2ZW50c1xuICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciBBIGNhbGxiYWNrIGZ1bmN0aW9uLCBjYWxsZWQgYXMgaGFuZGxlcihldmVudClcbiAgICAgICAqIEByZXR1cm5zIHtIYW1tZXIuTWFuYWdlcn0gUmV0dXJucyB0aGUgaGFtbWVyIGluc3RhbmNlXG4gICAgICAgKi9cbiAgICAgIHdyYXBwZXIub24gPSBmdW5jdGlvbiAoZXZlbnRzLCBoYW5kbGVyKSB7XG4gICAgICAgIC8vIHJlZ2lzdGVyIHRoZSBoYW5kbGVyXG4gICAgICAgIHNwbGl0KGV2ZW50cykuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICB2YXIgX2hhbmRsZXJzID0gd3JhcHBlci5faGFuZGxlcnNbZXZlbnRdO1xuICAgICAgICAgIGlmICghX2hhbmRsZXJzKSB7XG4gICAgICAgICAgICB3cmFwcGVyLl9oYW5kbGVyc1tldmVudF0gPSBfaGFuZGxlcnMgPSBbXTtcblxuICAgICAgICAgICAgLy8gcmVnaXN0ZXIgdGhlIHN0YXRpYywgcHJvcGFnYXRlZCBoYW5kbGVyXG4gICAgICAgICAgICBoYW1tZXIub24oZXZlbnQsIHByb3BhZ2F0ZWRIYW5kbGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX2hhbmRsZXJzLnB1c2goaGFuZGxlcik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBVbnJlZ2lzdGVyIGEgaGFuZGxlciBmb3Igb25lIG9yIG11bHRpcGxlIGV2ZW50c1xuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50cyAgICAgIEEgc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyB3aXRoIGV2ZW50c1xuICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2hhbmRsZXJdIE9wdGlvbmFsLiBUaGUgcmVnaXN0ZXJlZCBoYW5kbGVyLiBJZiBub3RcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlZCwgYWxsIGhhbmRsZXJzIGZvciBnaXZlbiBldmVudHNcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmUgcmVtb3ZlZC5cbiAgICAgICAqIEByZXR1cm5zIHtIYW1tZXIuTWFuYWdlcn0gICBSZXR1cm5zIHRoZSBoYW1tZXIgaW5zdGFuY2VcbiAgICAgICAqL1xuICAgICAgd3JhcHBlci5vZmYgPSBmdW5jdGlvbiAoZXZlbnRzLCBoYW5kbGVyKSB7XG4gICAgICAgIC8vIHVucmVnaXN0ZXIgdGhlIGhhbmRsZXJcbiAgICAgICAgc3BsaXQoZXZlbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIHZhciBfaGFuZGxlcnMgPSB3cmFwcGVyLl9oYW5kbGVyc1tldmVudF07XG4gICAgICAgICAgaWYgKF9oYW5kbGVycykge1xuICAgICAgICAgICAgX2hhbmRsZXJzID0gaGFuZGxlciA/IF9oYW5kbGVycy5maWx0ZXIoZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGggIT09IGhhbmRsZXI7XG4gICAgICAgICAgICB9KSA6IFtdO1xuXG4gICAgICAgICAgICBpZiAoX2hhbmRsZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgd3JhcHBlci5faGFuZGxlcnNbZXZlbnRdID0gX2hhbmRsZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHJlbW92ZSBzdGF0aWMsIHByb3BhZ2F0ZWQgaGFuZGxlclxuICAgICAgICAgICAgICBoYW1tZXIub2ZmKGV2ZW50LCBwcm9wYWdhdGVkSGFuZGxlcik7XG4gICAgICAgICAgICAgIGRlbGV0ZSB3cmFwcGVyLl9oYW5kbGVyc1tldmVudF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogRW1pdCB0byB0aGUgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlXG4gICAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAgICovXG4gICAgICB3cmFwcGVyLmVtaXQgPSBmdW5jdGlvbihldmVudFR5cGUsIGV2ZW50KSB7XG4gICAgICAgIF9maXJzdFRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgaGFtbWVyLmVtaXQoZXZlbnRUeXBlLCBldmVudCk7XG4gICAgICB9O1xuXG4gICAgICB3cmFwcGVyLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIERldGFjaCBmcm9tIERPTSBlbGVtZW50XG4gICAgICAgIHZhciBoYW1tZXJzID0gaGFtbWVyLmVsZW1lbnQuaGFtbWVyO1xuICAgICAgICB2YXIgaWR4ID0gaGFtbWVycy5pbmRleE9mKHdyYXBwZXIpO1xuICAgICAgICBpZihpZHggIT09IC0xKSBoYW1tZXJzLnNwbGljZShpZHgsMSk7XG4gICAgICAgIGlmKCFoYW1tZXJzLmxlbmd0aCkgZGVsZXRlIGhhbW1lci5lbGVtZW50LmhhbW1lcjtcblxuICAgICAgICAvLyBjbGVhciBhbGwgaGFuZGxlcnNcbiAgICAgICAgd3JhcHBlci5faGFuZGxlcnMgPSB7fTtcblxuICAgICAgICAvLyBjYWxsIG9yaWdpbmFsIGhhbW1lciBkZXN0cm95XG4gICAgICAgIGhhbW1lci5kZXN0cm95KCk7XG4gICAgICB9O1xuXG4gICAgICAvLyBzcGxpdCBhIHN0cmluZyB3aXRoIHNwYWNlIHNlcGFyYXRlZCB3b3Jkc1xuICAgICAgZnVuY3Rpb24gc3BsaXQoZXZlbnRzKSB7XG4gICAgICAgIHJldHVybiBldmVudHMubWF0Y2goL1teIF0rL2cpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEEgc3RhdGljIGV2ZW50IGhhbmRsZXIsIGFwcGx5aW5nIGV2ZW50IHByb3BhZ2F0aW9uLlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIHByb3BhZ2F0ZWRIYW5kbGVyKGV2ZW50KSB7XG4gICAgICAgIC8vIGxldCBvbmx5IGEgc2luZ2xlIGhhbW1lciBpbnN0YW5jZSBoYW5kbGUgdGhpcyBldmVudFxuICAgICAgICBpZiAoZXZlbnQudHlwZSAhPT0gJ2hhbW1lci5pbnB1dCcpIHtcbiAgICAgICAgICAvLyBpdCBpcyBwb3NzaWJsZSB0aGF0IHRoZSBzYW1lIHNyY0V2ZW50IGlzIHVzZWQgd2l0aCBtdWx0aXBsZSBoYW1tZXIgZXZlbnRzLFxuICAgICAgICAgIC8vIHdlIGtlZXAgdHJhY2sgb24gd2hpY2ggZXZlbnRzIGFyZSBoYW5kbGVkIGluIGFuIG9iamVjdCBfaGFuZGxlZFxuICAgICAgICAgIGlmICghZXZlbnQuc3JjRXZlbnQuX2hhbmRsZWQpIHtcbiAgICAgICAgICAgIGV2ZW50LnNyY0V2ZW50Ll9oYW5kbGVkID0ge307XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGV2ZW50LnNyY0V2ZW50Ll9oYW5kbGVkW2V2ZW50LnR5cGVdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXZlbnQuc3JjRXZlbnQuX2hhbmRsZWRbZXZlbnQudHlwZV0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGF0dGFjaCBhIHN0b3BQcm9wYWdhdGlvbiBmdW5jdGlvbiB0byB0aGUgZXZlbnRcbiAgICAgICAgdmFyIHN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vd3JhcCB0aGUgc3JjRXZlbnQncyBzdG9wUHJvcGFnYXRpb24gdG8gYWxzbyBzdG9wIGhhbW1lciBwcm9wYWdhdGlvbjpcbiAgICAgICAgdmFyIHNyY1N0b3AgPSBldmVudC5zcmNFdmVudC5zdG9wUHJvcGFnYXRpb24uYmluZChldmVudC5zcmNFdmVudCk7XG4gICAgICAgIGlmKHR5cGVvZiBzcmNTdG9wID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGV2ZW50LnNyY0V2ZW50LnN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBzcmNTdG9wKCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhdHRhY2ggZmlyc3RUYXJnZXQgcHJvcGVydHkgdG8gdGhlIGV2ZW50XG4gICAgICAgIGV2ZW50LmZpcnN0VGFyZ2V0ID0gX2ZpcnN0VGFyZ2V0O1xuXG4gICAgICAgIC8vIHByb3BhZ2F0ZSBvdmVyIGFsbCBlbGVtZW50cyAodW50aWwgc3RvcHBlZClcbiAgICAgICAgdmFyIGVsZW0gPSBfZmlyc3RUYXJnZXQ7XG4gICAgICAgIHdoaWxlIChlbGVtICYmICFzdG9wcGVkKSB7XG4gICAgICAgICAgdmFyIGVsZW1IYW1tZXIgPSBlbGVtLmhhbW1lcjtcbiAgICAgICAgICBpZihlbGVtSGFtbWVyKXtcbiAgICAgICAgICAgIHZhciBfaGFuZGxlcnM7XG4gICAgICAgICAgICBmb3IodmFyIGsgPSAwOyBrIDwgZWxlbUhhbW1lci5sZW5ndGg7IGsrKyl7XG4gICAgICAgICAgICAgIF9oYW5kbGVycyA9IGVsZW1IYW1tZXJba10uX2hhbmRsZXJzW2V2ZW50LnR5cGVdO1xuICAgICAgICAgICAgICBpZihfaGFuZGxlcnMpIGZvciAodmFyIGkgPSAwOyBpIDwgX2hhbmRsZXJzLmxlbmd0aCAmJiAhc3RvcHBlZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgX2hhbmRsZXJzW2ldKGV2ZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbGVtID0gZWxlbS5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH07XG4gIH0pKTtcblxuXG4vKioqLyB9LFxuLyogMjIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gIHZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsvKiEgSGFtbWVyLkpTIC0gdjIuMC42IC0gMjAxNS0xMi0yM1xuICAgKiBodHRwOi8vaGFtbWVyanMuZ2l0aHViLmlvL1xuICAgKlxuICAgKiBDb3B5cmlnaHQgKGMpIDIwMTUgSm9yaWsgVGFuZ2VsZGVyO1xuICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgIGxpY2Vuc2UgKi9cbiAgKGZ1bmN0aW9uKHdpbmRvdywgZG9jdW1lbnQsIGV4cG9ydE5hbWUsIHVuZGVmaW5lZCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICB2YXIgVkVORE9SX1BSRUZJWEVTID0gWycnLCAnd2Via2l0JywgJ01veicsICdNUycsICdtcycsICdvJ107XG4gIHZhciBURVNUX0VMRU1FTlQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICB2YXIgVFlQRV9GVU5DVElPTiA9ICdmdW5jdGlvbic7XG5cbiAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbiAgdmFyIGFicyA9IE1hdGguYWJzO1xuICB2YXIgbm93ID0gRGF0ZS5ub3c7XG5cbiAgLyoqXG4gICAqIHNldCBhIHRpbWVvdXQgd2l0aCBhIGdpdmVuIHNjb3BlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lb3V0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBmdW5jdGlvbiBzZXRUaW1lb3V0Q29udGV4dChmbiwgdGltZW91dCwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHNldFRpbWVvdXQoYmluZEZuKGZuLCBjb250ZXh0KSwgdGltZW91dCk7XG4gIH1cblxuICAvKipcbiAgICogaWYgdGhlIGFyZ3VtZW50IGlzIGFuIGFycmF5LCB3ZSB3YW50IHRvIGV4ZWN1dGUgdGhlIGZuIG9uIGVhY2ggZW50cnlcbiAgICogaWYgaXQgYWludCBhbiBhcnJheSB3ZSBkb24ndCB3YW50IHRvIGRvIGEgdGhpbmcuXG4gICAqIHRoaXMgaXMgdXNlZCBieSBhbGwgdGhlIG1ldGhvZHMgdGhhdCBhY2NlcHQgYSBzaW5nbGUgYW5kIGFycmF5IGFyZ3VtZW50LlxuICAgKiBAcGFyYW0geyp8QXJyYXl9IGFyZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gZm5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XVxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIGZ1bmN0aW9uIGludm9rZUFycmF5QXJnKGFyZywgZm4sIGNvbnRleHQpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgICBlYWNoKGFyZywgY29udGV4dFtmbl0sIGNvbnRleHQpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIHdhbGsgb2JqZWN0cyBhbmQgYXJyYXlzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0b3JcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAgICovXG4gIGZ1bmN0aW9uIGVhY2gob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgICAgdmFyIGk7XG5cbiAgICAgIGlmICghb2JqKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAob2JqLmZvckVhY2gpIHtcbiAgICAgICAgICBvYmouZm9yRWFjaChpdGVyYXRvciwgY29udGV4dCk7XG4gICAgICB9IGVsc2UgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgIHdoaWxlIChpIDwgb2JqLmxlbmd0aCkge1xuICAgICAgICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICAgICAgICBvYmouaGFzT3duUHJvcGVydHkoaSkgJiYgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XG4gICAgICAgICAgfVxuICAgICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHdyYXAgYSBtZXRob2Qgd2l0aCBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgYW5kIHN0YWNrIHRyYWNlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldGhvZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgbmV3IGZ1bmN0aW9uIHdyYXBwaW5nIHRoZSBzdXBwbGllZCBtZXRob2QuXG4gICAqL1xuICBmdW5jdGlvbiBkZXByZWNhdGUobWV0aG9kLCBuYW1lLCBtZXNzYWdlKSB7XG4gICAgICB2YXIgZGVwcmVjYXRpb25NZXNzYWdlID0gJ0RFUFJFQ0FURUQgTUVUSE9EOiAnICsgbmFtZSArICdcXG4nICsgbWVzc2FnZSArICcgQVQgXFxuJztcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgZSA9IG5ldyBFcnJvcignZ2V0LXN0YWNrLXRyYWNlJyk7XG4gICAgICAgICAgdmFyIHN0YWNrID0gZSAmJiBlLnN0YWNrID8gZS5zdGFjay5yZXBsYWNlKC9eW15cXChdKz9bXFxuJF0vZ20sICcnKVxuICAgICAgICAgICAgICAucmVwbGFjZSgvXlxccythdFxccysvZ20sICcnKVxuICAgICAgICAgICAgICAucmVwbGFjZSgvXk9iamVjdC48YW5vbnltb3VzPlxccypcXCgvZ20sICd7YW5vbnltb3VzfSgpQCcpIDogJ1Vua25vd24gU3RhY2sgVHJhY2UnO1xuXG4gICAgICAgICAgdmFyIGxvZyA9IHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS53YXJuIHx8IHdpbmRvdy5jb25zb2xlLmxvZyk7XG4gICAgICAgICAgaWYgKGxvZykge1xuICAgICAgICAgICAgICBsb2cuY2FsbCh3aW5kb3cuY29uc29sZSwgZGVwcmVjYXRpb25NZXNzYWdlLCBzdGFjayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gIH1cblxuICAvKipcbiAgICogZXh0ZW5kIG9iamVjdC5cbiAgICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIGluIGRlc3Qgd2lsbCBiZSBvdmVyd3JpdHRlbiBieSB0aGUgb25lcyBpbiBzcmMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICogQHBhcmFtIHsuLi5PYmplY3R9IG9iamVjdHNfdG9fYXNzaWduXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IHRhcmdldFxuICAgKi9cbiAgdmFyIGFzc2lnbjtcbiAgaWYgKHR5cGVvZiBPYmplY3QuYXNzaWduICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhc3NpZ24gPSBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0KSB7XG4gICAgICAgICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3QnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgb3V0cHV0ID0gT2JqZWN0KHRhcmdldCk7XG4gICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgICAgICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCAmJiBzb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIG5leHRLZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShuZXh0S2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbbmV4dEtleV0gPSBzb3VyY2VbbmV4dEtleV07XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICB9O1xuICB9IGVsc2Uge1xuICAgICAgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBleHRlbmQgb2JqZWN0LlxuICAgKiBtZWFucyB0aGF0IHByb3BlcnRpZXMgaW4gZGVzdCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IHRoZSBvbmVzIGluIHNyYy5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRlc3RcbiAgICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICAgKiBAcGFyYW0ge0Jvb2xlYW49ZmFsc2V9IFttZXJnZV1cbiAgICogQHJldHVybnMge09iamVjdH0gZGVzdFxuICAgKi9cbiAgdmFyIGV4dGVuZCA9IGRlcHJlY2F0ZShmdW5jdGlvbiBleHRlbmQoZGVzdCwgc3JjLCBtZXJnZSkge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzcmMpO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgd2hpbGUgKGkgPCBrZXlzLmxlbmd0aCkge1xuICAgICAgICAgIGlmICghbWVyZ2UgfHwgKG1lcmdlICYmIGRlc3Rba2V5c1tpXV0gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgZGVzdFtrZXlzW2ldXSA9IHNyY1trZXlzW2ldXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaSsrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlc3Q7XG4gIH0sICdleHRlbmQnLCAnVXNlIGBhc3NpZ25gLicpO1xuXG4gIC8qKlxuICAgKiBtZXJnZSB0aGUgdmFsdWVzIGZyb20gc3JjIGluIHRoZSBkZXN0LlxuICAgKiBtZWFucyB0aGF0IHByb3BlcnRpZXMgdGhhdCBleGlzdCBpbiBkZXN0IHdpbGwgbm90IGJlIG92ZXJ3cml0dGVuIGJ5IHNyY1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGVzdFxuICAgKiBAcGFyYW0ge09iamVjdH0gc3JjXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IGRlc3RcbiAgICovXG4gIHZhciBtZXJnZSA9IGRlcHJlY2F0ZShmdW5jdGlvbiBtZXJnZShkZXN0LCBzcmMpIHtcbiAgICAgIHJldHVybiBleHRlbmQoZGVzdCwgc3JjLCB0cnVlKTtcbiAgfSwgJ21lcmdlJywgJ1VzZSBgYXNzaWduYC4nKTtcblxuICAvKipcbiAgICogc2ltcGxlIGNsYXNzIGluaGVyaXRhbmNlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNoaWxkXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGJhc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXVxuICAgKi9cbiAgZnVuY3Rpb24gaW5oZXJpdChjaGlsZCwgYmFzZSwgcHJvcGVydGllcykge1xuICAgICAgdmFyIGJhc2VQID0gYmFzZS5wcm90b3R5cGUsXG4gICAgICAgICAgY2hpbGRQO1xuXG4gICAgICBjaGlsZFAgPSBjaGlsZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGJhc2VQKTtcbiAgICAgIGNoaWxkUC5jb25zdHJ1Y3RvciA9IGNoaWxkO1xuICAgICAgY2hpbGRQLl9zdXBlciA9IGJhc2VQO1xuXG4gICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICAgIGFzc2lnbihjaGlsZFAsIHByb3BlcnRpZXMpO1xuICAgICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHNpbXBsZSBmdW5jdGlvbiBiaW5kXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAgICovXG4gIGZ1bmN0aW9uIGJpbmRGbihmbiwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGJvdW5kRm4oKSB7XG4gICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIGxldCBhIGJvb2xlYW4gdmFsdWUgYWxzbyBiZSBhIGZ1bmN0aW9uIHRoYXQgbXVzdCByZXR1cm4gYSBib29sZWFuXG4gICAqIHRoaXMgZmlyc3QgaXRlbSBpbiBhcmdzIHdpbGwgYmUgdXNlZCBhcyB0aGUgY29udGV4dFxuICAgKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IHZhbFxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnc11cbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuICBmdW5jdGlvbiBib29sT3JGbih2YWwsIGFyZ3MpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09IFRZUEVfRlVOQ1RJT04pIHtcbiAgICAgICAgICByZXR1cm4gdmFsLmFwcGx5KGFyZ3MgPyBhcmdzWzBdIHx8IHVuZGVmaW5lZCA6IHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgLyoqXG4gICAqIHVzZSB0aGUgdmFsMiB3aGVuIHZhbDEgaXMgdW5kZWZpbmVkXG4gICAqIEBwYXJhbSB7Kn0gdmFsMVxuICAgKiBAcGFyYW0geyp9IHZhbDJcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBmdW5jdGlvbiBpZlVuZGVmaW5lZCh2YWwxLCB2YWwyKSB7XG4gICAgICByZXR1cm4gKHZhbDEgPT09IHVuZGVmaW5lZCkgPyB2YWwyIDogdmFsMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBhZGRFdmVudExpc3RlbmVyIHdpdGggbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2VcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVycyh0YXJnZXQsIHR5cGVzLCBoYW5kbGVyKSB7XG4gICAgICBlYWNoKHNwbGl0U3RyKHR5cGVzKSwgZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIHJlbW92ZUV2ZW50TGlzdGVuZXIgd2l0aCBtdWx0aXBsZSBldmVudHMgYXQgb25jZVxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRhcmdldCwgdHlwZXMsIGhhbmRsZXIpIHtcbiAgICAgIGVhY2goc3BsaXRTdHIodHlwZXMpLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogZmluZCBpZiBhIG5vZGUgaXMgaW4gdGhlIGdpdmVuIHBhcmVudFxuICAgKiBAbWV0aG9kIGhhc1BhcmVudFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBmb3VuZFxuICAgKi9cbiAgZnVuY3Rpb24gaGFzUGFyZW50KG5vZGUsIHBhcmVudCkge1xuICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICBpZiAobm9kZSA9PSBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogc21hbGwgaW5kZXhPZiB3cmFwcGVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcbiAgICogQHJldHVybnMge0Jvb2xlYW59IGZvdW5kXG4gICAqL1xuICBmdW5jdGlvbiBpblN0cihzdHIsIGZpbmQpIHtcbiAgICAgIHJldHVybiBzdHIuaW5kZXhPZihmaW5kKSA+IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIHNwbGl0IHN0cmluZyBvbiB3aGl0ZXNwYWNlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAgICogQHJldHVybnMge0FycmF5fSB3b3Jkc1xuICAgKi9cbiAgZnVuY3Rpb24gc3BsaXRTdHIoc3RyKSB7XG4gICAgICByZXR1cm4gc3RyLnRyaW0oKS5zcGxpdCgvXFxzKy9nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBmaW5kIGlmIGEgYXJyYXkgY29udGFpbnMgdGhlIG9iamVjdCB1c2luZyBpbmRleE9mIG9yIGEgc2ltcGxlIHBvbHlGaWxsXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNyY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gZmluZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2ZpbmRCeUtleV1cbiAgICogQHJldHVybiB7Qm9vbGVhbnxOdW1iZXJ9IGZhbHNlIHdoZW4gbm90IGZvdW5kLCBvciB0aGUgaW5kZXhcbiAgICovXG4gIGZ1bmN0aW9uIGluQXJyYXkoc3JjLCBmaW5kLCBmaW5kQnlLZXkpIHtcbiAgICAgIGlmIChzcmMuaW5kZXhPZiAmJiAhZmluZEJ5S2V5KSB7XG4gICAgICAgICAgcmV0dXJuIHNyYy5pbmRleE9mKGZpbmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgd2hpbGUgKGkgPCBzcmMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGlmICgoZmluZEJ5S2V5ICYmIHNyY1tpXVtmaW5kQnlLZXldID09IGZpbmQpIHx8ICghZmluZEJ5S2V5ICYmIHNyY1tpXSA9PT0gZmluZCkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGNvbnZlcnQgYXJyYXktbGlrZSBvYmplY3RzIHRvIHJlYWwgYXJyYXlzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAgICogQHJldHVybnMge0FycmF5fVxuICAgKi9cbiAgZnVuY3Rpb24gdG9BcnJheShvYmopIHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmosIDApO1xuICB9XG5cbiAgLyoqXG4gICAqIHVuaXF1ZSBhcnJheSB3aXRoIG9iamVjdHMgYmFzZWQgb24gYSBrZXkgKGxpa2UgJ2lkJykgb3IganVzdCBieSB0aGUgYXJyYXkncyB2YWx1ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBzcmMgW3tpZDoxfSx7aWQ6Mn0se2lkOjF9XVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2tleV1cbiAgICogQHBhcmFtIHtCb29sZWFufSBbc29ydD1GYWxzZV1cbiAgICogQHJldHVybnMge0FycmF5fSBbe2lkOjF9LHtpZDoyfV1cbiAgICovXG4gIGZ1bmN0aW9uIHVuaXF1ZUFycmF5KHNyYywga2V5LCBzb3J0KSB7XG4gICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICB3aGlsZSAoaSA8IHNyYy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgdmFsID0ga2V5ID8gc3JjW2ldW2tleV0gOiBzcmNbaV07XG4gICAgICAgICAgaWYgKGluQXJyYXkodmFsdWVzLCB2YWwpIDwgMCkge1xuICAgICAgICAgICAgICByZXN1bHRzLnB1c2goc3JjW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWVzW2ldID0gdmFsO1xuICAgICAgICAgIGkrKztcbiAgICAgIH1cblxuICAgICAgaWYgKHNvcnQpIHtcbiAgICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5zb3J0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuc29ydChmdW5jdGlvbiBzb3J0VW5pcXVlQXJyYXkoYSwgYikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGFba2V5XSA+IGJba2V5XTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgdGhlIHByZWZpeGVkIHByb3BlcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEByZXR1cm5zIHtTdHJpbmd8VW5kZWZpbmVkfSBwcmVmaXhlZFxuICAgKi9cbiAgZnVuY3Rpb24gcHJlZml4ZWQob2JqLCBwcm9wZXJ0eSkge1xuICAgICAgdmFyIHByZWZpeCwgcHJvcDtcbiAgICAgIHZhciBjYW1lbFByb3AgPSBwcm9wZXJ0eVswXS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc2xpY2UoMSk7XG5cbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHdoaWxlIChpIDwgVkVORE9SX1BSRUZJWEVTLmxlbmd0aCkge1xuICAgICAgICAgIHByZWZpeCA9IFZFTkRPUl9QUkVGSVhFU1tpXTtcbiAgICAgICAgICBwcm9wID0gKHByZWZpeCkgPyBwcmVmaXggKyBjYW1lbFByb3AgOiBwcm9wZXJ0eTtcblxuICAgICAgICAgIGlmIChwcm9wIGluIG9iaikge1xuICAgICAgICAgICAgICByZXR1cm4gcHJvcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaSsrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgYSB1bmlxdWUgaWRcbiAgICogQHJldHVybnMge251bWJlcn0gdW5pcXVlSWRcbiAgICovXG4gIHZhciBfdW5pcXVlSWQgPSAxO1xuICBmdW5jdGlvbiB1bmlxdWVJZCgpIHtcbiAgICAgIHJldHVybiBfdW5pcXVlSWQrKztcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgdGhlIHdpbmRvdyBvYmplY3Qgb2YgYW4gZWxlbWVudFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEByZXR1cm5zIHtEb2N1bWVudFZpZXd8V2luZG93fVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0V2luZG93Rm9yRWxlbWVudChlbGVtZW50KSB7XG4gICAgICB2YXIgZG9jID0gZWxlbWVudC5vd25lckRvY3VtZW50IHx8IGVsZW1lbnQ7XG4gICAgICByZXR1cm4gKGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93IHx8IHdpbmRvdyk7XG4gIH1cblxuICB2YXIgTU9CSUxFX1JFR0VYID0gL21vYmlsZXx0YWJsZXR8aXAoYWR8aG9uZXxvZCl8YW5kcm9pZC9pO1xuXG4gIHZhciBTVVBQT1JUX1RPVUNIID0gKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyk7XG4gIHZhciBTVVBQT1JUX1BPSU5URVJfRVZFTlRTID0gcHJlZml4ZWQod2luZG93LCAnUG9pbnRlckV2ZW50JykgIT09IHVuZGVmaW5lZDtcbiAgdmFyIFNVUFBPUlRfT05MWV9UT1VDSCA9IFNVUFBPUlRfVE9VQ0ggJiYgTU9CSUxFX1JFR0VYLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbiAgdmFyIElOUFVUX1RZUEVfVE9VQ0ggPSAndG91Y2gnO1xuICB2YXIgSU5QVVRfVFlQRV9QRU4gPSAncGVuJztcbiAgdmFyIElOUFVUX1RZUEVfTU9VU0UgPSAnbW91c2UnO1xuICB2YXIgSU5QVVRfVFlQRV9LSU5FQ1QgPSAna2luZWN0JztcblxuICB2YXIgQ09NUFVURV9JTlRFUlZBTCA9IDI1O1xuXG4gIHZhciBJTlBVVF9TVEFSVCA9IDE7XG4gIHZhciBJTlBVVF9NT1ZFID0gMjtcbiAgdmFyIElOUFVUX0VORCA9IDQ7XG4gIHZhciBJTlBVVF9DQU5DRUwgPSA4O1xuXG4gIHZhciBESVJFQ1RJT05fTk9ORSA9IDE7XG4gIHZhciBESVJFQ1RJT05fTEVGVCA9IDI7XG4gIHZhciBESVJFQ1RJT05fUklHSFQgPSA0O1xuICB2YXIgRElSRUNUSU9OX1VQID0gODtcbiAgdmFyIERJUkVDVElPTl9ET1dOID0gMTY7XG5cbiAgdmFyIERJUkVDVElPTl9IT1JJWk9OVEFMID0gRElSRUNUSU9OX0xFRlQgfCBESVJFQ1RJT05fUklHSFQ7XG4gIHZhciBESVJFQ1RJT05fVkVSVElDQUwgPSBESVJFQ1RJT05fVVAgfCBESVJFQ1RJT05fRE9XTjtcbiAgdmFyIERJUkVDVElPTl9BTEwgPSBESVJFQ1RJT05fSE9SSVpPTlRBTCB8IERJUkVDVElPTl9WRVJUSUNBTDtcblxuICB2YXIgUFJPUFNfWFkgPSBbJ3gnLCAneSddO1xuICB2YXIgUFJPUFNfQ0xJRU5UX1hZID0gWydjbGllbnRYJywgJ2NsaWVudFknXTtcblxuICAvKipcbiAgICogY3JlYXRlIG5ldyBpbnB1dCB0eXBlIG1hbmFnZXJcbiAgICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtJbnB1dH1cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBJbnB1dChtYW5hZ2VyLCBjYWxsYmFjaykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIHRoaXMuZWxlbWVudCA9IG1hbmFnZXIuZWxlbWVudDtcbiAgICAgIHRoaXMudGFyZ2V0ID0gbWFuYWdlci5vcHRpb25zLmlucHV0VGFyZ2V0O1xuXG4gICAgICAvLyBzbWFsbGVyIHdyYXBwZXIgYXJvdW5kIHRoZSBoYW5kbGVyLCBmb3IgdGhlIHNjb3BlIGFuZCB0aGUgZW5hYmxlZCBzdGF0ZSBvZiB0aGUgbWFuYWdlcixcbiAgICAgIC8vIHNvIHdoZW4gZGlzYWJsZWQgdGhlIGlucHV0IGV2ZW50cyBhcmUgY29tcGxldGVseSBieXBhc3NlZC5cbiAgICAgIHRoaXMuZG9tSGFuZGxlciA9IGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgaWYgKGJvb2xPckZuKG1hbmFnZXIub3B0aW9ucy5lbmFibGUsIFttYW5hZ2VyXSkpIHtcbiAgICAgICAgICAgICAgc2VsZi5oYW5kbGVyKGV2KTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmluaXQoKTtcblxuICB9XG5cbiAgSW5wdXQucHJvdG90eXBlID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBzaG91bGQgaGFuZGxlIHRoZSBpbnB1dEV2ZW50IGRhdGEgYW5kIHRyaWdnZXIgdGhlIGNhbGxiYWNrXG4gICAgICAgKiBAdmlydHVhbFxuICAgICAgICovXG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbigpIHsgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBiaW5kIHRoZSBldmVudHNcbiAgICAgICAqL1xuICAgICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5ldkVsICYmIGFkZEV2ZW50TGlzdGVuZXJzKHRoaXMuZWxlbWVudCwgdGhpcy5ldkVsLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgICAgIHRoaXMuZXZUYXJnZXQgJiYgYWRkRXZlbnRMaXN0ZW5lcnModGhpcy50YXJnZXQsIHRoaXMuZXZUYXJnZXQsIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgICAgICAgdGhpcy5ldldpbiAmJiBhZGRFdmVudExpc3RlbmVycyhnZXRXaW5kb3dGb3JFbGVtZW50KHRoaXMuZWxlbWVudCksIHRoaXMuZXZXaW4sIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIHVuYmluZCB0aGUgZXZlbnRzXG4gICAgICAgKi9cbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuZXZFbCAmJiByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLmVsZW1lbnQsIHRoaXMuZXZFbCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgICAgICB0aGlzLmV2VGFyZ2V0ICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMudGFyZ2V0LCB0aGlzLmV2VGFyZ2V0LCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgICAgIHRoaXMuZXZXaW4gJiYgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoZ2V0V2luZG93Rm9yRWxlbWVudCh0aGlzLmVsZW1lbnQpLCB0aGlzLmV2V2luLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBjcmVhdGUgbmV3IGlucHV0IHR5cGUgbWFuYWdlclxuICAgKiBjYWxsZWQgYnkgdGhlIE1hbmFnZXIgY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtIYW1tZXJ9IG1hbmFnZXJcbiAgICogQHJldHVybnMge0lucHV0fVxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlSW5wdXRJbnN0YW5jZShtYW5hZ2VyKSB7XG4gICAgICB2YXIgVHlwZTtcbiAgICAgIHZhciBpbnB1dENsYXNzID0gbWFuYWdlci5vcHRpb25zLmlucHV0Q2xhc3M7XG5cbiAgICAgIGlmIChpbnB1dENsYXNzKSB7XG4gICAgICAgICAgVHlwZSA9IGlucHV0Q2xhc3M7XG4gICAgICB9IGVsc2UgaWYgKFNVUFBPUlRfUE9JTlRFUl9FVkVOVFMpIHtcbiAgICAgICAgICBUeXBlID0gUG9pbnRlckV2ZW50SW5wdXQ7XG4gICAgICB9IGVsc2UgaWYgKFNVUFBPUlRfT05MWV9UT1VDSCkge1xuICAgICAgICAgIFR5cGUgPSBUb3VjaElucHV0O1xuICAgICAgfSBlbHNlIGlmICghU1VQUE9SVF9UT1VDSCkge1xuICAgICAgICAgIFR5cGUgPSBNb3VzZUlucHV0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBUeXBlID0gVG91Y2hNb3VzZUlucHV0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyAoVHlwZSkobWFuYWdlciwgaW5wdXRIYW5kbGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBoYW5kbGUgaW5wdXQgZXZlbnRzXG4gICAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgKi9cbiAgZnVuY3Rpb24gaW5wdXRIYW5kbGVyKG1hbmFnZXIsIGV2ZW50VHlwZSwgaW5wdXQpIHtcbiAgICAgIHZhciBwb2ludGVyc0xlbiA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aDtcbiAgICAgIHZhciBjaGFuZ2VkUG9pbnRlcnNMZW4gPSBpbnB1dC5jaGFuZ2VkUG9pbnRlcnMubGVuZ3RoO1xuICAgICAgdmFyIGlzRmlyc3QgPSAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgKHBvaW50ZXJzTGVuIC0gY2hhbmdlZFBvaW50ZXJzTGVuID09PSAwKSk7XG4gICAgICB2YXIgaXNGaW5hbCA9IChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiAocG9pbnRlcnNMZW4gLSBjaGFuZ2VkUG9pbnRlcnNMZW4gPT09IDApKTtcblxuICAgICAgaW5wdXQuaXNGaXJzdCA9ICEhaXNGaXJzdDtcbiAgICAgIGlucHV0LmlzRmluYWwgPSAhIWlzRmluYWw7XG5cbiAgICAgIGlmIChpc0ZpcnN0KSB7XG4gICAgICAgICAgbWFuYWdlci5zZXNzaW9uID0ge307XG4gICAgICB9XG5cbiAgICAgIC8vIHNvdXJjZSBldmVudCBpcyB0aGUgbm9ybWFsaXplZCB2YWx1ZSBvZiB0aGUgZG9tRXZlbnRzXG4gICAgICAvLyBsaWtlICd0b3VjaHN0YXJ0LCBtb3VzZXVwLCBwb2ludGVyZG93bidcbiAgICAgIGlucHV0LmV2ZW50VHlwZSA9IGV2ZW50VHlwZTtcblxuICAgICAgLy8gY29tcHV0ZSBzY2FsZSwgcm90YXRpb24gZXRjXG4gICAgICBjb21wdXRlSW5wdXREYXRhKG1hbmFnZXIsIGlucHV0KTtcblxuICAgICAgLy8gZW1pdCBzZWNyZXQgZXZlbnRcbiAgICAgIG1hbmFnZXIuZW1pdCgnaGFtbWVyLmlucHV0JywgaW5wdXQpO1xuXG4gICAgICBtYW5hZ2VyLnJlY29nbml6ZShpbnB1dCk7XG4gICAgICBtYW5hZ2VyLnNlc3Npb24ucHJldklucHV0ID0gaW5wdXQ7XG4gIH1cblxuICAvKipcbiAgICogZXh0ZW5kIHRoZSBkYXRhIHdpdGggc29tZSB1c2FibGUgcHJvcGVydGllcyBsaWtlIHNjYWxlLCByb3RhdGUsIHZlbG9jaXR5IGV0Y1xuICAgKiBAcGFyYW0ge09iamVjdH0gbWFuYWdlclxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICovXG4gIGZ1bmN0aW9uIGNvbXB1dGVJbnB1dERhdGEobWFuYWdlciwgaW5wdXQpIHtcbiAgICAgIHZhciBzZXNzaW9uID0gbWFuYWdlci5zZXNzaW9uO1xuICAgICAgdmFyIHBvaW50ZXJzID0gaW5wdXQucG9pbnRlcnM7XG4gICAgICB2YXIgcG9pbnRlcnNMZW5ndGggPSBwb2ludGVycy5sZW5ndGg7XG5cbiAgICAgIC8vIHN0b3JlIHRoZSBmaXJzdCBpbnB1dCB0byBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGFuZCBkaXJlY3Rpb25cbiAgICAgIGlmICghc2Vzc2lvbi5maXJzdElucHV0KSB7XG4gICAgICAgICAgc2Vzc2lvbi5maXJzdElucHV0ID0gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpO1xuICAgICAgfVxuXG4gICAgICAvLyB0byBjb21wdXRlIHNjYWxlIGFuZCByb3RhdGlvbiB3ZSBuZWVkIHRvIHN0b3JlIHRoZSBtdWx0aXBsZSB0b3VjaGVzXG4gICAgICBpZiAocG9pbnRlcnNMZW5ndGggPiAxICYmICFzZXNzaW9uLmZpcnN0TXVsdGlwbGUpIHtcbiAgICAgICAgICBzZXNzaW9uLmZpcnN0TXVsdGlwbGUgPSBzaW1wbGVDbG9uZUlucHV0RGF0YShpbnB1dCk7XG4gICAgICB9IGVsc2UgaWYgKHBvaW50ZXJzTGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgc2Vzc2lvbi5maXJzdE11bHRpcGxlID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBmaXJzdElucHV0ID0gc2Vzc2lvbi5maXJzdElucHV0O1xuICAgICAgdmFyIGZpcnN0TXVsdGlwbGUgPSBzZXNzaW9uLmZpcnN0TXVsdGlwbGU7XG4gICAgICB2YXIgb2Zmc2V0Q2VudGVyID0gZmlyc3RNdWx0aXBsZSA/IGZpcnN0TXVsdGlwbGUuY2VudGVyIDogZmlyc3RJbnB1dC5jZW50ZXI7XG5cbiAgICAgIHZhciBjZW50ZXIgPSBpbnB1dC5jZW50ZXIgPSBnZXRDZW50ZXIocG9pbnRlcnMpO1xuICAgICAgaW5wdXQudGltZVN0YW1wID0gbm93KCk7XG4gICAgICBpbnB1dC5kZWx0YVRpbWUgPSBpbnB1dC50aW1lU3RhbXAgLSBmaXJzdElucHV0LnRpbWVTdGFtcDtcblxuICAgICAgaW5wdXQuYW5nbGUgPSBnZXRBbmdsZShvZmZzZXRDZW50ZXIsIGNlbnRlcik7XG4gICAgICBpbnB1dC5kaXN0YW5jZSA9IGdldERpc3RhbmNlKG9mZnNldENlbnRlciwgY2VudGVyKTtcblxuICAgICAgY29tcHV0ZURlbHRhWFkoc2Vzc2lvbiwgaW5wdXQpO1xuICAgICAgaW5wdXQub2Zmc2V0RGlyZWN0aW9uID0gZ2V0RGlyZWN0aW9uKGlucHV0LmRlbHRhWCwgaW5wdXQuZGVsdGFZKTtcblxuICAgICAgdmFyIG92ZXJhbGxWZWxvY2l0eSA9IGdldFZlbG9jaXR5KGlucHV0LmRlbHRhVGltZSwgaW5wdXQuZGVsdGFYLCBpbnB1dC5kZWx0YVkpO1xuICAgICAgaW5wdXQub3ZlcmFsbFZlbG9jaXR5WCA9IG92ZXJhbGxWZWxvY2l0eS54O1xuICAgICAgaW5wdXQub3ZlcmFsbFZlbG9jaXR5WSA9IG92ZXJhbGxWZWxvY2l0eS55O1xuICAgICAgaW5wdXQub3ZlcmFsbFZlbG9jaXR5ID0gKGFicyhvdmVyYWxsVmVsb2NpdHkueCkgPiBhYnMob3ZlcmFsbFZlbG9jaXR5LnkpKSA/IG92ZXJhbGxWZWxvY2l0eS54IDogb3ZlcmFsbFZlbG9jaXR5Lnk7XG5cbiAgICAgIGlucHV0LnNjYWxlID0gZmlyc3RNdWx0aXBsZSA/IGdldFNjYWxlKGZpcnN0TXVsdGlwbGUucG9pbnRlcnMsIHBvaW50ZXJzKSA6IDE7XG4gICAgICBpbnB1dC5yb3RhdGlvbiA9IGZpcnN0TXVsdGlwbGUgPyBnZXRSb3RhdGlvbihmaXJzdE11bHRpcGxlLnBvaW50ZXJzLCBwb2ludGVycykgOiAwO1xuXG4gICAgICBpbnB1dC5tYXhQb2ludGVycyA9ICFzZXNzaW9uLnByZXZJbnB1dCA/IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA6ICgoaW5wdXQucG9pbnRlcnMubGVuZ3RoID5cbiAgICAgICAgICBzZXNzaW9uLnByZXZJbnB1dC5tYXhQb2ludGVycykgPyBpbnB1dC5wb2ludGVycy5sZW5ndGggOiBzZXNzaW9uLnByZXZJbnB1dC5tYXhQb2ludGVycyk7XG5cbiAgICAgIGNvbXB1dGVJbnRlcnZhbElucHV0RGF0YShzZXNzaW9uLCBpbnB1dCk7XG5cbiAgICAgIC8vIGZpbmQgdGhlIGNvcnJlY3QgdGFyZ2V0XG4gICAgICB2YXIgdGFyZ2V0ID0gbWFuYWdlci5lbGVtZW50O1xuICAgICAgaWYgKGhhc1BhcmVudChpbnB1dC5zcmNFdmVudC50YXJnZXQsIHRhcmdldCkpIHtcbiAgICAgICAgICB0YXJnZXQgPSBpbnB1dC5zcmNFdmVudC50YXJnZXQ7XG4gICAgICB9XG4gICAgICBpbnB1dC50YXJnZXQgPSB0YXJnZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wdXRlRGVsdGFYWShzZXNzaW9uLCBpbnB1dCkge1xuICAgICAgdmFyIGNlbnRlciA9IGlucHV0LmNlbnRlcjtcbiAgICAgIHZhciBvZmZzZXQgPSBzZXNzaW9uLm9mZnNldERlbHRhIHx8IHt9O1xuICAgICAgdmFyIHByZXZEZWx0YSA9IHNlc3Npb24ucHJldkRlbHRhIHx8IHt9O1xuICAgICAgdmFyIHByZXZJbnB1dCA9IHNlc3Npb24ucHJldklucHV0IHx8IHt9O1xuXG4gICAgICBpZiAoaW5wdXQuZXZlbnRUeXBlID09PSBJTlBVVF9TVEFSVCB8fCBwcmV2SW5wdXQuZXZlbnRUeXBlID09PSBJTlBVVF9FTkQpIHtcbiAgICAgICAgICBwcmV2RGVsdGEgPSBzZXNzaW9uLnByZXZEZWx0YSA9IHtcbiAgICAgICAgICAgICAgeDogcHJldklucHV0LmRlbHRhWCB8fCAwLFxuICAgICAgICAgICAgICB5OiBwcmV2SW5wdXQuZGVsdGFZIHx8IDBcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgb2Zmc2V0ID0gc2Vzc2lvbi5vZmZzZXREZWx0YSA9IHtcbiAgICAgICAgICAgICAgeDogY2VudGVyLngsXG4gICAgICAgICAgICAgIHk6IGNlbnRlci55XG4gICAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaW5wdXQuZGVsdGFYID0gcHJldkRlbHRhLnggKyAoY2VudGVyLnggLSBvZmZzZXQueCk7XG4gICAgICBpbnB1dC5kZWx0YVkgPSBwcmV2RGVsdGEueSArIChjZW50ZXIueSAtIG9mZnNldC55KTtcbiAgfVxuXG4gIC8qKlxuICAgKiB2ZWxvY2l0eSBpcyBjYWxjdWxhdGVkIGV2ZXJ5IHggbXNcbiAgICogQHBhcmFtIHtPYmplY3R9IHNlc3Npb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAqL1xuICBmdW5jdGlvbiBjb21wdXRlSW50ZXJ2YWxJbnB1dERhdGEoc2Vzc2lvbiwgaW5wdXQpIHtcbiAgICAgIHZhciBsYXN0ID0gc2Vzc2lvbi5sYXN0SW50ZXJ2YWwgfHwgaW5wdXQsXG4gICAgICAgICAgZGVsdGFUaW1lID0gaW5wdXQudGltZVN0YW1wIC0gbGFzdC50aW1lU3RhbXAsXG4gICAgICAgICAgdmVsb2NpdHksIHZlbG9jaXR5WCwgdmVsb2NpdHlZLCBkaXJlY3Rpb247XG5cbiAgICAgIGlmIChpbnB1dC5ldmVudFR5cGUgIT0gSU5QVVRfQ0FOQ0VMICYmIChkZWx0YVRpbWUgPiBDT01QVVRFX0lOVEVSVkFMIHx8IGxhc3QudmVsb2NpdHkgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICB2YXIgZGVsdGFYID0gaW5wdXQuZGVsdGFYIC0gbGFzdC5kZWx0YVg7XG4gICAgICAgICAgdmFyIGRlbHRhWSA9IGlucHV0LmRlbHRhWSAtIGxhc3QuZGVsdGFZO1xuXG4gICAgICAgICAgdmFyIHYgPSBnZXRWZWxvY2l0eShkZWx0YVRpbWUsIGRlbHRhWCwgZGVsdGFZKTtcbiAgICAgICAgICB2ZWxvY2l0eVggPSB2Lng7XG4gICAgICAgICAgdmVsb2NpdHlZID0gdi55O1xuICAgICAgICAgIHZlbG9jaXR5ID0gKGFicyh2LngpID4gYWJzKHYueSkpID8gdi54IDogdi55O1xuICAgICAgICAgIGRpcmVjdGlvbiA9IGdldERpcmVjdGlvbihkZWx0YVgsIGRlbHRhWSk7XG5cbiAgICAgICAgICBzZXNzaW9uLmxhc3RJbnRlcnZhbCA9IGlucHV0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB1c2UgbGF0ZXN0IHZlbG9jaXR5IGluZm8gaWYgaXQgZG9lc24ndCBvdmVydGFrZSBhIG1pbmltdW0gcGVyaW9kXG4gICAgICAgICAgdmVsb2NpdHkgPSBsYXN0LnZlbG9jaXR5O1xuICAgICAgICAgIHZlbG9jaXR5WCA9IGxhc3QudmVsb2NpdHlYO1xuICAgICAgICAgIHZlbG9jaXR5WSA9IGxhc3QudmVsb2NpdHlZO1xuICAgICAgICAgIGRpcmVjdGlvbiA9IGxhc3QuZGlyZWN0aW9uO1xuICAgICAgfVxuXG4gICAgICBpbnB1dC52ZWxvY2l0eSA9IHZlbG9jaXR5O1xuICAgICAgaW5wdXQudmVsb2NpdHlYID0gdmVsb2NpdHlYO1xuICAgICAgaW5wdXQudmVsb2NpdHlZID0gdmVsb2NpdHlZO1xuICAgICAgaW5wdXQuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBhIHNpbXBsZSBjbG9uZSBmcm9tIHRoZSBpbnB1dCB1c2VkIGZvciBzdG9yYWdlIG9mIGZpcnN0SW5wdXQgYW5kIGZpcnN0TXVsdGlwbGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAqIEByZXR1cm5zIHtPYmplY3R9IGNsb25lZElucHV0RGF0YVxuICAgKi9cbiAgZnVuY3Rpb24gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpIHtcbiAgICAgIC8vIG1ha2UgYSBzaW1wbGUgY29weSBvZiB0aGUgcG9pbnRlcnMgYmVjYXVzZSB3ZSB3aWxsIGdldCBhIHJlZmVyZW5jZSBpZiB3ZSBkb24ndFxuICAgICAgLy8gd2Ugb25seSBuZWVkIGNsaWVudFhZIGZvciB0aGUgY2FsY3VsYXRpb25zXG4gICAgICB2YXIgcG9pbnRlcnMgPSBbXTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHdoaWxlIChpIDwgaW5wdXQucG9pbnRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgcG9pbnRlcnNbaV0gPSB7XG4gICAgICAgICAgICAgIGNsaWVudFg6IHJvdW5kKGlucHV0LnBvaW50ZXJzW2ldLmNsaWVudFgpLFxuICAgICAgICAgICAgICBjbGllbnRZOiByb3VuZChpbnB1dC5wb2ludGVyc1tpXS5jbGllbnRZKVxuICAgICAgICAgIH07XG4gICAgICAgICAgaSsrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHRpbWVTdGFtcDogbm93KCksXG4gICAgICAgICAgcG9pbnRlcnM6IHBvaW50ZXJzLFxuICAgICAgICAgIGNlbnRlcjogZ2V0Q2VudGVyKHBvaW50ZXJzKSxcbiAgICAgICAgICBkZWx0YVg6IGlucHV0LmRlbHRhWCxcbiAgICAgICAgICBkZWx0YVk6IGlucHV0LmRlbHRhWVxuICAgICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgdGhlIGNlbnRlciBvZiBhbGwgdGhlIHBvaW50ZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50ZXJzXG4gICAqIEByZXR1cm4ge09iamVjdH0gY2VudGVyIGNvbnRhaW5zIGB4YCBhbmQgYHlgIHByb3BlcnRpZXNcbiAgICovXG4gIGZ1bmN0aW9uIGdldENlbnRlcihwb2ludGVycykge1xuICAgICAgdmFyIHBvaW50ZXJzTGVuZ3RoID0gcG9pbnRlcnMubGVuZ3RoO1xuXG4gICAgICAvLyBubyBuZWVkIHRvIGxvb3Agd2hlbiBvbmx5IG9uZSB0b3VjaFxuICAgICAgaWYgKHBvaW50ZXJzTGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgeDogcm91bmQocG9pbnRlcnNbMF0uY2xpZW50WCksXG4gICAgICAgICAgICAgIHk6IHJvdW5kKHBvaW50ZXJzWzBdLmNsaWVudFkpXG4gICAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIHggPSAwLCB5ID0gMCwgaSA9IDA7XG4gICAgICB3aGlsZSAoaSA8IHBvaW50ZXJzTGVuZ3RoKSB7XG4gICAgICAgICAgeCArPSBwb2ludGVyc1tpXS5jbGllbnRYO1xuICAgICAgICAgIHkgKz0gcG9pbnRlcnNbaV0uY2xpZW50WTtcbiAgICAgICAgICBpKys7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogcm91bmQoeCAvIHBvaW50ZXJzTGVuZ3RoKSxcbiAgICAgICAgICB5OiByb3VuZCh5IC8gcG9pbnRlcnNMZW5ndGgpXG4gICAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB0aGUgdmVsb2NpdHkgYmV0d2VlbiB0d28gcG9pbnRzLiB1bml0IGlzIGluIHB4IHBlciBtcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhVGltZVxuICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IHZlbG9jaXR5IGB4YCBhbmQgYHlgXG4gICAqL1xuICBmdW5jdGlvbiBnZXRWZWxvY2l0eShkZWx0YVRpbWUsIHgsIHkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogeCAvIGRlbHRhVGltZSB8fCAwLFxuICAgICAgICAgIHk6IHkgLyBkZWx0YVRpbWUgfHwgMFxuICAgICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgdGhlIGRpcmVjdGlvbiBiZXR3ZWVuIHR3byBwb2ludHNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICogQHJldHVybiB7TnVtYmVyfSBkaXJlY3Rpb25cbiAgICovXG4gIGZ1bmN0aW9uIGdldERpcmVjdGlvbih4LCB5KSB7XG4gICAgICBpZiAoeCA9PT0geSkge1xuICAgICAgICAgIHJldHVybiBESVJFQ1RJT05fTk9ORTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFicyh4KSA+PSBhYnMoeSkpIHtcbiAgICAgICAgICByZXR1cm4geCA8IDAgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB5IDwgMCA/IERJUkVDVElPTl9VUCA6IERJUkVDVElPTl9ET1dOO1xuICB9XG5cbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB0aGUgYWJzb2x1dGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwMSB7eCwgeX1cbiAgICogQHBhcmFtIHtPYmplY3R9IHAyIHt4LCB5fVxuICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcHNdIGNvbnRhaW5pbmcgeCBhbmQgeSBrZXlzXG4gICAqIEByZXR1cm4ge051bWJlcn0gZGlzdGFuY2VcbiAgICovXG4gIGZ1bmN0aW9uIGdldERpc3RhbmNlKHAxLCBwMiwgcHJvcHMpIHtcbiAgICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgICBwcm9wcyA9IFBST1BTX1hZO1xuICAgICAgfVxuICAgICAgdmFyIHggPSBwMltwcm9wc1swXV0gLSBwMVtwcm9wc1swXV0sXG4gICAgICAgICAgeSA9IHAyW3Byb3BzWzFdXSAtIHAxW3Byb3BzWzFdXTtcblxuICAgICAgcmV0dXJuIE1hdGguc3FydCgoeCAqIHgpICsgKHkgKiB5KSk7XG4gIH1cblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSBhbmdsZSBiZXR3ZWVuIHR3byBjb29yZGluYXRlc1xuICAgKiBAcGFyYW0ge09iamVjdH0gcDFcbiAgICogQHBhcmFtIHtPYmplY3R9IHAyXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wc10gY29udGFpbmluZyB4IGFuZCB5IGtleXNcbiAgICogQHJldHVybiB7TnVtYmVyfSBhbmdsZVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0QW5nbGUocDEsIHAyLCBwcm9wcykge1xuICAgICAgaWYgKCFwcm9wcykge1xuICAgICAgICAgIHByb3BzID0gUFJPUFNfWFk7XG4gICAgICB9XG4gICAgICB2YXIgeCA9IHAyW3Byb3BzWzBdXSAtIHAxW3Byb3BzWzBdXSxcbiAgICAgICAgICB5ID0gcDJbcHJvcHNbMV1dIC0gcDFbcHJvcHNbMV1dO1xuICAgICAgcmV0dXJuIE1hdGguYXRhbjIoeSwgeCkgKiAxODAgLyBNYXRoLlBJO1xuICB9XG5cbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB0aGUgcm90YXRpb24gZGVncmVlcyBiZXR3ZWVuIHR3byBwb2ludGVyc2V0c1xuICAgKiBAcGFyYW0ge0FycmF5fSBzdGFydCBhcnJheSBvZiBwb2ludGVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgcG9pbnRlcnNcbiAgICogQHJldHVybiB7TnVtYmVyfSByb3RhdGlvblxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0Um90YXRpb24oc3RhcnQsIGVuZCkge1xuICAgICAgcmV0dXJuIGdldEFuZ2xlKGVuZFsxXSwgZW5kWzBdLCBQUk9QU19DTElFTlRfWFkpICsgZ2V0QW5nbGUoc3RhcnRbMV0sIHN0YXJ0WzBdLCBQUk9QU19DTElFTlRfWFkpO1xuICB9XG5cbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB0aGUgc2NhbGUgZmFjdG9yIGJldHdlZW4gdHdvIHBvaW50ZXJzZXRzXG4gICAqIG5vIHNjYWxlIGlzIDEsIGFuZCBnb2VzIGRvd24gdG8gMCB3aGVuIHBpbmNoZWQgdG9nZXRoZXIsIGFuZCBiaWdnZXIgd2hlbiBwaW5jaGVkIG91dFxuICAgKiBAcGFyYW0ge0FycmF5fSBzdGFydCBhcnJheSBvZiBwb2ludGVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgcG9pbnRlcnNcbiAgICogQHJldHVybiB7TnVtYmVyfSBzY2FsZVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0U2NhbGUoc3RhcnQsIGVuZCkge1xuICAgICAgcmV0dXJuIGdldERpc3RhbmNlKGVuZFswXSwgZW5kWzFdLCBQUk9QU19DTElFTlRfWFkpIC8gZ2V0RGlzdGFuY2Uoc3RhcnRbMF0sIHN0YXJ0WzFdLCBQUk9QU19DTElFTlRfWFkpO1xuICB9XG5cbiAgdmFyIE1PVVNFX0lOUFVUX01BUCA9IHtcbiAgICAgIG1vdXNlZG93bjogSU5QVVRfU1RBUlQsXG4gICAgICBtb3VzZW1vdmU6IElOUFVUX01PVkUsXG4gICAgICBtb3VzZXVwOiBJTlBVVF9FTkRcbiAgfTtcblxuICB2YXIgTU9VU0VfRUxFTUVOVF9FVkVOVFMgPSAnbW91c2Vkb3duJztcbiAgdmFyIE1PVVNFX1dJTkRPV19FVkVOVFMgPSAnbW91c2Vtb3ZlIG1vdXNldXAnO1xuXG4gIC8qKlxuICAgKiBNb3VzZSBldmVudHMgaW5wdXRcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIElucHV0XG4gICAqL1xuICBmdW5jdGlvbiBNb3VzZUlucHV0KCkge1xuICAgICAgdGhpcy5ldkVsID0gTU9VU0VfRUxFTUVOVF9FVkVOVFM7XG4gICAgICB0aGlzLmV2V2luID0gTU9VU0VfV0lORE9XX0VWRU5UUztcblxuICAgICAgdGhpcy5hbGxvdyA9IHRydWU7IC8vIHVzZWQgYnkgSW5wdXQuVG91Y2hNb3VzZSB0byBkaXNhYmxlIG1vdXNlIGV2ZW50c1xuICAgICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7IC8vIG1vdXNlZG93biBzdGF0ZVxuXG4gICAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgaW5oZXJpdChNb3VzZUlucHV0LCBJbnB1dCwge1xuICAgICAgLyoqXG4gICAgICAgKiBoYW5kbGUgbW91c2UgZXZlbnRzXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICAgICAqL1xuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gTUVoYW5kbGVyKGV2KSB7XG4gICAgICAgICAgdmFyIGV2ZW50VHlwZSA9IE1PVVNFX0lOUFVUX01BUFtldi50eXBlXTtcblxuICAgICAgICAgIC8vIG9uIHN0YXJ0IHdlIHdhbnQgdG8gaGF2ZSB0aGUgbGVmdCBtb3VzZSBidXR0b24gZG93blxuICAgICAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiBldi5idXR0b24gPT09IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5wcmVzc2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfTU9WRSAmJiBldi53aGljaCAhPT0gMSkge1xuICAgICAgICAgICAgICBldmVudFR5cGUgPSBJTlBVVF9FTkQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gbW91c2UgbXVzdCBiZSBkb3duLCBhbmQgbW91c2UgZXZlbnRzIGFyZSBhbGxvd2VkIChzZWUgdGhlIFRvdWNoTW91c2UgaW5wdXQpXG4gICAgICAgICAgaWYgKCF0aGlzLnByZXNzZWQgfHwgIXRoaXMuYWxsb3cpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgICAgICAgICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIGV2ZW50VHlwZSwge1xuICAgICAgICAgICAgICBwb2ludGVyczogW2V2XSxcbiAgICAgICAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiBbZXZdLFxuICAgICAgICAgICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9NT1VTRSxcbiAgICAgICAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gIH0pO1xuXG4gIHZhciBQT0lOVEVSX0lOUFVUX01BUCA9IHtcbiAgICAgIHBvaW50ZXJkb3duOiBJTlBVVF9TVEFSVCxcbiAgICAgIHBvaW50ZXJtb3ZlOiBJTlBVVF9NT1ZFLFxuICAgICAgcG9pbnRlcnVwOiBJTlBVVF9FTkQsXG4gICAgICBwb2ludGVyY2FuY2VsOiBJTlBVVF9DQU5DRUwsXG4gICAgICBwb2ludGVyb3V0OiBJTlBVVF9DQU5DRUxcbiAgfTtcblxuICAvLyBpbiBJRTEwIHRoZSBwb2ludGVyIHR5cGVzIGlzIGRlZmluZWQgYXMgYW4gZW51bVxuICB2YXIgSUUxMF9QT0lOVEVSX1RZUEVfRU5VTSA9IHtcbiAgICAgIDI6IElOUFVUX1RZUEVfVE9VQ0gsXG4gICAgICAzOiBJTlBVVF9UWVBFX1BFTixcbiAgICAgIDQ6IElOUFVUX1RZUEVfTU9VU0UsXG4gICAgICA1OiBJTlBVVF9UWVBFX0tJTkVDVCAvLyBzZWUgaHR0cHM6Ly90d2l0dGVyLmNvbS9qYWNvYnJvc3NpL3N0YXR1cy80ODA1OTY0Mzg0ODk4OTA4MTZcbiAgfTtcblxuICB2YXIgUE9JTlRFUl9FTEVNRU5UX0VWRU5UUyA9ICdwb2ludGVyZG93bic7XG4gIHZhciBQT0lOVEVSX1dJTkRPV19FVkVOVFMgPSAncG9pbnRlcm1vdmUgcG9pbnRlcnVwIHBvaW50ZXJjYW5jZWwnO1xuXG4gIC8vIElFMTAgaGFzIHByZWZpeGVkIHN1cHBvcnQsIGFuZCBjYXNlLXNlbnNpdGl2ZVxuICBpZiAod2luZG93Lk1TUG9pbnRlckV2ZW50ICYmICF3aW5kb3cuUG9pbnRlckV2ZW50KSB7XG4gICAgICBQT0lOVEVSX0VMRU1FTlRfRVZFTlRTID0gJ01TUG9pbnRlckRvd24nO1xuICAgICAgUE9JTlRFUl9XSU5ET1dfRVZFTlRTID0gJ01TUG9pbnRlck1vdmUgTVNQb2ludGVyVXAgTVNQb2ludGVyQ2FuY2VsJztcbiAgfVxuXG4gIC8qKlxuICAgKiBQb2ludGVyIGV2ZW50cyBpbnB1dFxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMgSW5wdXRcbiAgICovXG4gIGZ1bmN0aW9uIFBvaW50ZXJFdmVudElucHV0KCkge1xuICAgICAgdGhpcy5ldkVsID0gUE9JTlRFUl9FTEVNRU5UX0VWRU5UUztcbiAgICAgIHRoaXMuZXZXaW4gPSBQT0lOVEVSX1dJTkRPV19FVkVOVFM7XG5cbiAgICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgIHRoaXMuc3RvcmUgPSAodGhpcy5tYW5hZ2VyLnNlc3Npb24ucG9pbnRlckV2ZW50cyA9IFtdKTtcbiAgfVxuXG4gIGluaGVyaXQoUG9pbnRlckV2ZW50SW5wdXQsIElucHV0LCB7XG4gICAgICAvKipcbiAgICAgICAqIGhhbmRsZSBtb3VzZSBldmVudHNcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgICAgICovXG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBQRWhhbmRsZXIoZXYpIHtcbiAgICAgICAgICB2YXIgc3RvcmUgPSB0aGlzLnN0b3JlO1xuICAgICAgICAgIHZhciByZW1vdmVQb2ludGVyID0gZmFsc2U7XG5cbiAgICAgICAgICB2YXIgZXZlbnRUeXBlTm9ybWFsaXplZCA9IGV2LnR5cGUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdtcycsICcnKTtcbiAgICAgICAgICB2YXIgZXZlbnRUeXBlID0gUE9JTlRFUl9JTlBVVF9NQVBbZXZlbnRUeXBlTm9ybWFsaXplZF07XG4gICAgICAgICAgdmFyIHBvaW50ZXJUeXBlID0gSUUxMF9QT0lOVEVSX1RZUEVfRU5VTVtldi5wb2ludGVyVHlwZV0gfHwgZXYucG9pbnRlclR5cGU7XG5cbiAgICAgICAgICB2YXIgaXNUb3VjaCA9IChwb2ludGVyVHlwZSA9PSBJTlBVVF9UWVBFX1RPVUNIKTtcblxuICAgICAgICAgIC8vIGdldCBpbmRleCBvZiB0aGUgZXZlbnQgaW4gdGhlIHN0b3JlXG4gICAgICAgICAgdmFyIHN0b3JlSW5kZXggPSBpbkFycmF5KHN0b3JlLCBldi5wb2ludGVySWQsICdwb2ludGVySWQnKTtcblxuICAgICAgICAgIC8vIHN0YXJ0IGFuZCBtb3VzZSBtdXN0IGJlIGRvd25cbiAgICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgKGV2LmJ1dHRvbiA9PT0gMCB8fCBpc1RvdWNoKSkge1xuICAgICAgICAgICAgICBpZiAoc3RvcmVJbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICAgIHN0b3JlLnB1c2goZXYpO1xuICAgICAgICAgICAgICAgICAgc3RvcmVJbmRleCA9IHN0b3JlLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICAgICAgICAgIHJlbW92ZVBvaW50ZXIgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGl0IG5vdCBmb3VuZCwgc28gdGhlIHBvaW50ZXIgaGFzbid0IGJlZW4gZG93biAoc28gaXQncyBwcm9iYWJseSBhIGhvdmVyKVxuICAgICAgICAgIGlmIChzdG9yZUluZGV4IDwgMCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdXBkYXRlIHRoZSBldmVudCBpbiB0aGUgc3RvcmVcbiAgICAgICAgICBzdG9yZVtzdG9yZUluZGV4XSA9IGV2O1xuXG4gICAgICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIGV2ZW50VHlwZSwge1xuICAgICAgICAgICAgICBwb2ludGVyczogc3RvcmUsXG4gICAgICAgICAgICAgIGNoYW5nZWRQb2ludGVyczogW2V2XSxcbiAgICAgICAgICAgICAgcG9pbnRlclR5cGU6IHBvaW50ZXJUeXBlLFxuICAgICAgICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChyZW1vdmVQb2ludGVyKSB7XG4gICAgICAgICAgICAgIC8vIHJlbW92ZSBmcm9tIHRoZSBzdG9yZVxuICAgICAgICAgICAgICBzdG9yZS5zcGxpY2Uoc3RvcmVJbmRleCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICB9KTtcblxuICB2YXIgU0lOR0xFX1RPVUNIX0lOUFVUX01BUCA9IHtcbiAgICAgIHRvdWNoc3RhcnQ6IElOUFVUX1NUQVJULFxuICAgICAgdG91Y2htb3ZlOiBJTlBVVF9NT1ZFLFxuICAgICAgdG91Y2hlbmQ6IElOUFVUX0VORCxcbiAgICAgIHRvdWNoY2FuY2VsOiBJTlBVVF9DQU5DRUxcbiAgfTtcblxuICB2YXIgU0lOR0xFX1RPVUNIX1RBUkdFVF9FVkVOVFMgPSAndG91Y2hzdGFydCc7XG4gIHZhciBTSU5HTEVfVE9VQ0hfV0lORE9XX0VWRU5UUyA9ICd0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCc7XG5cbiAgLyoqXG4gICAqIFRvdWNoIGV2ZW50cyBpbnB1dFxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMgSW5wdXRcbiAgICovXG4gIGZ1bmN0aW9uIFNpbmdsZVRvdWNoSW5wdXQoKSB7XG4gICAgICB0aGlzLmV2VGFyZ2V0ID0gU0lOR0xFX1RPVUNIX1RBUkdFVF9FVkVOVFM7XG4gICAgICB0aGlzLmV2V2luID0gU0lOR0xFX1RPVUNIX1dJTkRPV19FVkVOVFM7XG4gICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcblxuICAgICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGluaGVyaXQoU2luZ2xlVG91Y2hJbnB1dCwgSW5wdXQsIHtcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIFRFaGFuZGxlcihldikge1xuICAgICAgICAgIHZhciB0eXBlID0gU0lOR0xFX1RPVUNIX0lOUFVUX01BUFtldi50eXBlXTtcblxuICAgICAgICAgIC8vIHNob3VsZCB3ZSBoYW5kbGUgdGhlIHRvdWNoIGV2ZW50cz9cbiAgICAgICAgICBpZiAodHlwZSA9PT0gSU5QVVRfU1RBUlQpIHtcbiAgICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHRvdWNoZXMgPSBub3JtYWxpemVTaW5nbGVUb3VjaGVzLmNhbGwodGhpcywgZXYsIHR5cGUpO1xuXG4gICAgICAgICAgLy8gd2hlbiBkb25lLCByZXNldCB0aGUgc3RhcnRlZCBzdGF0ZVxuICAgICAgICAgIGlmICh0eXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkgJiYgdG91Y2hlc1swXS5sZW5ndGggLSB0b3VjaGVzWzFdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgdHlwZSwge1xuICAgICAgICAgICAgICBwb2ludGVyczogdG91Y2hlc1swXSxcbiAgICAgICAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiB0b3VjaGVzWzFdLFxuICAgICAgICAgICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9UT1VDSCxcbiAgICAgICAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGhpcyB7VG91Y2hJbnB1dH1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0eXBlIGZsYWdcbiAgICogQHJldHVybnMge3VuZGVmaW5lZHxBcnJheX0gW2FsbCwgY2hhbmdlZF1cbiAgICovXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVNpbmdsZVRvdWNoZXMoZXYsIHR5cGUpIHtcbiAgICAgIHZhciBhbGwgPSB0b0FycmF5KGV2LnRvdWNoZXMpO1xuICAgICAgdmFyIGNoYW5nZWQgPSB0b0FycmF5KGV2LmNoYW5nZWRUb3VjaGVzKTtcblxuICAgICAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgICAgIGFsbCA9IHVuaXF1ZUFycmF5KGFsbC5jb25jYXQoY2hhbmdlZCksICdpZGVudGlmaWVyJywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbYWxsLCBjaGFuZ2VkXTtcbiAgfVxuXG4gIHZhciBUT1VDSF9JTlBVVF9NQVAgPSB7XG4gICAgICB0b3VjaHN0YXJ0OiBJTlBVVF9TVEFSVCxcbiAgICAgIHRvdWNobW92ZTogSU5QVVRfTU9WRSxcbiAgICAgIHRvdWNoZW5kOiBJTlBVVF9FTkQsXG4gICAgICB0b3VjaGNhbmNlbDogSU5QVVRfQ0FOQ0VMXG4gIH07XG5cbiAgdmFyIFRPVUNIX1RBUkdFVF9FVkVOVFMgPSAndG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWwnO1xuXG4gIC8qKlxuICAgKiBNdWx0aS11c2VyIHRvdWNoIGV2ZW50cyBpbnB1dFxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMgSW5wdXRcbiAgICovXG4gIGZ1bmN0aW9uIFRvdWNoSW5wdXQoKSB7XG4gICAgICB0aGlzLmV2VGFyZ2V0ID0gVE9VQ0hfVEFSR0VUX0VWRU5UUztcbiAgICAgIHRoaXMudGFyZ2V0SWRzID0ge307XG5cbiAgICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBpbmhlcml0KFRvdWNoSW5wdXQsIElucHV0LCB7XG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBNVEVoYW5kbGVyKGV2KSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBUT1VDSF9JTlBVVF9NQVBbZXYudHlwZV07XG4gICAgICAgICAgdmFyIHRvdWNoZXMgPSBnZXRUb3VjaGVzLmNhbGwodGhpcywgZXYsIHR5cGUpO1xuICAgICAgICAgIGlmICghdG91Y2hlcykge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIHR5cGUsIHtcbiAgICAgICAgICAgICAgcG9pbnRlcnM6IHRvdWNoZXNbMF0sXG4gICAgICAgICAgICAgIGNoYW5nZWRQb2ludGVyczogdG91Y2hlc1sxXSxcbiAgICAgICAgICAgICAgcG9pbnRlclR5cGU6IElOUFVUX1RZUEVfVE9VQ0gsXG4gICAgICAgICAgICAgIHNyY0V2ZW50OiBldlxuICAgICAgICAgIH0pO1xuICAgICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQHRoaXMge1RvdWNoSW5wdXR9XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKiBAcGFyYW0ge051bWJlcn0gdHlwZSBmbGFnXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR8QXJyYXl9IFthbGwsIGNoYW5nZWRdXG4gICAqL1xuICBmdW5jdGlvbiBnZXRUb3VjaGVzKGV2LCB0eXBlKSB7XG4gICAgICB2YXIgYWxsVG91Y2hlcyA9IHRvQXJyYXkoZXYudG91Y2hlcyk7XG4gICAgICB2YXIgdGFyZ2V0SWRzID0gdGhpcy50YXJnZXRJZHM7XG5cbiAgICAgIC8vIHdoZW4gdGhlcmUgaXMgb25seSBvbmUgdG91Y2gsIHRoZSBwcm9jZXNzIGNhbiBiZSBzaW1wbGlmaWVkXG4gICAgICBpZiAodHlwZSAmIChJTlBVVF9TVEFSVCB8IElOUFVUX01PVkUpICYmIGFsbFRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgdGFyZ2V0SWRzW2FsbFRvdWNoZXNbMF0uaWRlbnRpZmllcl0gPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBbYWxsVG91Y2hlcywgYWxsVG91Y2hlc107XG4gICAgICB9XG5cbiAgICAgIHZhciBpLFxuICAgICAgICAgIHRhcmdldFRvdWNoZXMsXG4gICAgICAgICAgY2hhbmdlZFRvdWNoZXMgPSB0b0FycmF5KGV2LmNoYW5nZWRUb3VjaGVzKSxcbiAgICAgICAgICBjaGFuZ2VkVGFyZ2V0VG91Y2hlcyA9IFtdLFxuICAgICAgICAgIHRhcmdldCA9IHRoaXMudGFyZ2V0O1xuXG4gICAgICAvLyBnZXQgdGFyZ2V0IHRvdWNoZXMgZnJvbSB0b3VjaGVzXG4gICAgICB0YXJnZXRUb3VjaGVzID0gYWxsVG91Y2hlcy5maWx0ZXIoZnVuY3Rpb24odG91Y2gpIHtcbiAgICAgICAgICByZXR1cm4gaGFzUGFyZW50KHRvdWNoLnRhcmdldCwgdGFyZ2V0KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBjb2xsZWN0IHRvdWNoZXNcbiAgICAgIGlmICh0eXBlID09PSBJTlBVVF9TVEFSVCkge1xuICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgIHdoaWxlIChpIDwgdGFyZ2V0VG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGFyZ2V0SWRzW3RhcmdldFRvdWNoZXNbaV0uaWRlbnRpZmllcl0gPSB0cnVlO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBmaWx0ZXIgY2hhbmdlZCB0b3VjaGVzIHRvIG9ubHkgY29udGFpbiB0b3VjaGVzIHRoYXQgZXhpc3QgaW4gdGhlIGNvbGxlY3RlZCB0YXJnZXQgaWRzXG4gICAgICBpID0gMDtcbiAgICAgIHdoaWxlIChpIDwgY2hhbmdlZFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKHRhcmdldElkc1tjaGFuZ2VkVG91Y2hlc1tpXS5pZGVudGlmaWVyXSkge1xuICAgICAgICAgICAgICBjaGFuZ2VkVGFyZ2V0VG91Y2hlcy5wdXNoKGNoYW5nZWRUb3VjaGVzW2ldKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBjbGVhbnVwIHJlbW92ZWQgdG91Y2hlc1xuICAgICAgICAgIGlmICh0eXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIHRhcmdldElkc1tjaGFuZ2VkVG91Y2hlc1tpXS5pZGVudGlmaWVyXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaSsrO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWNoYW5nZWRUYXJnZXRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAvLyBtZXJnZSB0YXJnZXRUb3VjaGVzIHdpdGggY2hhbmdlZFRhcmdldFRvdWNoZXMgc28gaXQgY29udGFpbnMgQUxMIHRvdWNoZXMsIGluY2x1ZGluZyAnZW5kJyBhbmQgJ2NhbmNlbCdcbiAgICAgICAgICB1bmlxdWVBcnJheSh0YXJnZXRUb3VjaGVzLmNvbmNhdChjaGFuZ2VkVGFyZ2V0VG91Y2hlcyksICdpZGVudGlmaWVyJywgdHJ1ZSksXG4gICAgICAgICAgY2hhbmdlZFRhcmdldFRvdWNoZXNcbiAgICAgIF07XG4gIH1cblxuICAvKipcbiAgICogQ29tYmluZWQgdG91Y2ggYW5kIG1vdXNlIGlucHV0XG4gICAqXG4gICAqIFRvdWNoIGhhcyBhIGhpZ2hlciBwcmlvcml0eSB0aGVuIG1vdXNlLCBhbmQgd2hpbGUgdG91Y2hpbmcgbm8gbW91c2UgZXZlbnRzIGFyZSBhbGxvd2VkLlxuICAgKiBUaGlzIGJlY2F1c2UgdG91Y2ggZGV2aWNlcyBhbHNvIGVtaXQgbW91c2UgZXZlbnRzIHdoaWxlIGRvaW5nIGEgdG91Y2guXG4gICAqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyBJbnB1dFxuICAgKi9cbiAgZnVuY3Rpb24gVG91Y2hNb3VzZUlucHV0KCkge1xuICAgICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgdmFyIGhhbmRsZXIgPSBiaW5kRm4odGhpcy5oYW5kbGVyLCB0aGlzKTtcbiAgICAgIHRoaXMudG91Y2ggPSBuZXcgVG91Y2hJbnB1dCh0aGlzLm1hbmFnZXIsIGhhbmRsZXIpO1xuICAgICAgdGhpcy5tb3VzZSA9IG5ldyBNb3VzZUlucHV0KHRoaXMubWFuYWdlciwgaGFuZGxlcik7XG4gIH1cblxuICBpbmhlcml0KFRvdWNoTW91c2VJbnB1dCwgSW5wdXQsIHtcbiAgICAgIC8qKlxuICAgICAgICogaGFuZGxlIG1vdXNlIGFuZCB0b3VjaCBldmVudHNcbiAgICAgICAqIEBwYXJhbSB7SGFtbWVyfSBtYW5hZ2VyXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXRFdmVudFxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAgICovXG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBUTUVoYW5kbGVyKG1hbmFnZXIsIGlucHV0RXZlbnQsIGlucHV0RGF0YSkge1xuICAgICAgICAgIHZhciBpc1RvdWNoID0gKGlucHV0RGF0YS5wb2ludGVyVHlwZSA9PSBJTlBVVF9UWVBFX1RPVUNIKSxcbiAgICAgICAgICAgICAgaXNNb3VzZSA9IChpbnB1dERhdGEucG9pbnRlclR5cGUgPT0gSU5QVVRfVFlQRV9NT1VTRSk7XG5cbiAgICAgICAgICAvLyB3aGVuIHdlJ3JlIGluIGEgdG91Y2ggZXZlbnQsIHNvICBibG9jayBhbGwgdXBjb21pbmcgbW91c2UgZXZlbnRzXG4gICAgICAgICAgLy8gbW9zdCBtb2JpbGUgYnJvd3NlciBhbHNvIGVtaXQgbW91c2VldmVudHMsIHJpZ2h0IGFmdGVyIHRvdWNoc3RhcnRcbiAgICAgICAgICBpZiAoaXNUb3VjaCkge1xuICAgICAgICAgICAgICB0aGlzLm1vdXNlLmFsbG93ID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc01vdXNlICYmICF0aGlzLm1vdXNlLmFsbG93KSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyByZXNldCB0aGUgYWxsb3dNb3VzZSB3aGVuIHdlJ3JlIGRvbmVcbiAgICAgICAgICBpZiAoaW5wdXRFdmVudCAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICAgICAgICAgIHRoaXMubW91c2UuYWxsb3cgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuY2FsbGJhY2sobWFuYWdlciwgaW5wdXRFdmVudCwgaW5wdXREYXRhKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogcmVtb3ZlIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAqL1xuICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgICB0aGlzLnRvdWNoLmRlc3Ryb3koKTtcbiAgICAgICAgICB0aGlzLm1vdXNlLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgfSk7XG5cbiAgdmFyIFBSRUZJWEVEX1RPVUNIX0FDVElPTiA9IHByZWZpeGVkKFRFU1RfRUxFTUVOVC5zdHlsZSwgJ3RvdWNoQWN0aW9uJyk7XG4gIHZhciBOQVRJVkVfVE9VQ0hfQUNUSU9OID0gUFJFRklYRURfVE9VQ0hfQUNUSU9OICE9PSB1bmRlZmluZWQ7XG5cbiAgLy8gbWFnaWNhbCB0b3VjaEFjdGlvbiB2YWx1ZVxuICB2YXIgVE9VQ0hfQUNUSU9OX0NPTVBVVEUgPSAnY29tcHV0ZSc7XG4gIHZhciBUT1VDSF9BQ1RJT05fQVVUTyA9ICdhdXRvJztcbiAgdmFyIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT04gPSAnbWFuaXB1bGF0aW9uJzsgLy8gbm90IGltcGxlbWVudGVkXG4gIHZhciBUT1VDSF9BQ1RJT05fTk9ORSA9ICdub25lJztcbiAgdmFyIFRPVUNIX0FDVElPTl9QQU5fWCA9ICdwYW4teCc7XG4gIHZhciBUT1VDSF9BQ1RJT05fUEFOX1kgPSAncGFuLXknO1xuXG4gIC8qKlxuICAgKiBUb3VjaCBBY3Rpb25cbiAgICogc2V0cyB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkgb3IgdXNlcyB0aGUganMgYWx0ZXJuYXRpdmVcbiAgICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIFRvdWNoQWN0aW9uKG1hbmFnZXIsIHZhbHVlKSB7XG4gICAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgICAgdGhpcy5zZXQodmFsdWUpO1xuICB9XG5cbiAgVG91Y2hBY3Rpb24ucHJvdG90eXBlID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBzZXQgdGhlIHRvdWNoQWN0aW9uIHZhbHVlIG9uIHRoZSBlbGVtZW50IG9yIGVuYWJsZSB0aGUgcG9seWZpbGxcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAgICovXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgLy8gZmluZCBvdXQgdGhlIHRvdWNoLWFjdGlvbiBieSB0aGUgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgICBpZiAodmFsdWUgPT0gVE9VQ0hfQUNUSU9OX0NPTVBVVEUpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmNvbXB1dGUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoTkFUSVZFX1RPVUNIX0FDVElPTiAmJiB0aGlzLm1hbmFnZXIuZWxlbWVudC5zdHlsZSkge1xuICAgICAgICAgICAgICB0aGlzLm1hbmFnZXIuZWxlbWVudC5zdHlsZVtQUkVGSVhFRF9UT1VDSF9BQ1RJT05dID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYWN0aW9ucyA9IHZhbHVlLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBqdXN0IHJlLXNldCB0aGUgdG91Y2hBY3Rpb24gdmFsdWVcbiAgICAgICAqL1xuICAgICAgdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLnNldCh0aGlzLm1hbmFnZXIub3B0aW9ucy50b3VjaEFjdGlvbik7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIGNvbXB1dGUgdGhlIHZhbHVlIGZvciB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkgYmFzZWQgb24gdGhlIHJlY29nbml6ZXIncyBzZXR0aW5nc1xuICAgICAgICogQHJldHVybnMge1N0cmluZ30gdmFsdWVcbiAgICAgICAqL1xuICAgICAgY29tcHV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGFjdGlvbnMgPSBbXTtcbiAgICAgICAgICBlYWNoKHRoaXMubWFuYWdlci5yZWNvZ25pemVycywgZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgICAgICAgICAgICBpZiAoYm9vbE9yRm4ocmVjb2duaXplci5vcHRpb25zLmVuYWJsZSwgW3JlY29nbml6ZXJdKSkge1xuICAgICAgICAgICAgICAgICAgYWN0aW9ucyA9IGFjdGlvbnMuY29uY2F0KHJlY29nbml6ZXIuZ2V0VG91Y2hBY3Rpb24oKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gY2xlYW5Ub3VjaEFjdGlvbnMoYWN0aW9ucy5qb2luKCcgJykpO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgb24gZWFjaCBpbnB1dCBjeWNsZSBhbmQgcHJvdmlkZXMgdGhlIHByZXZlbnRpbmcgb2YgdGhlIGJyb3dzZXIgYmVoYXZpb3JcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAgICovXG4gICAgICBwcmV2ZW50RGVmYXVsdHM6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgICAgLy8gbm90IG5lZWRlZCB3aXRoIG5hdGl2ZSBzdXBwb3J0IGZvciB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHlcbiAgICAgICAgICBpZiAoTkFUSVZFX1RPVUNIX0FDVElPTikge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHNyY0V2ZW50ID0gaW5wdXQuc3JjRXZlbnQ7XG4gICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGlucHV0Lm9mZnNldERpcmVjdGlvbjtcblxuICAgICAgICAgIC8vIGlmIHRoZSB0b3VjaCBhY3Rpb24gZGlkIHByZXZlbnRlZCBvbmNlIHRoaXMgc2Vzc2lvblxuICAgICAgICAgIGlmICh0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgICAgc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBhY3Rpb25zID0gdGhpcy5hY3Rpb25zO1xuICAgICAgICAgIHZhciBoYXNOb25lID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX05PTkUpO1xuICAgICAgICAgIHZhciBoYXNQYW5ZID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9ZKTtcbiAgICAgICAgICB2YXIgaGFzUGFuWCA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWCk7XG5cbiAgICAgICAgICBpZiAoaGFzTm9uZSkge1xuICAgICAgICAgICAgICAvL2RvIG5vdCBwcmV2ZW50IGRlZmF1bHRzIGlmIHRoaXMgaXMgYSB0YXAgZ2VzdHVyZVxuXG4gICAgICAgICAgICAgIHZhciBpc1RhcFBvaW50ZXIgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IDE7XG4gICAgICAgICAgICAgIHZhciBpc1RhcE1vdmVtZW50ID0gaW5wdXQuZGlzdGFuY2UgPCAyO1xuICAgICAgICAgICAgICB2YXIgaXNUYXBUb3VjaFRpbWUgPSBpbnB1dC5kZWx0YVRpbWUgPCAyNTA7XG5cbiAgICAgICAgICAgICAgaWYgKGlzVGFwUG9pbnRlciAmJiBpc1RhcE1vdmVtZW50ICYmIGlzVGFwVG91Y2hUaW1lKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaGFzUGFuWCAmJiBoYXNQYW5ZKSB7XG4gICAgICAgICAgICAgIC8vIGBwYW4teCBwYW4teWAgbWVhbnMgYnJvd3NlciBoYW5kbGVzIGFsbCBzY3JvbGxpbmcvcGFubmluZywgZG8gbm90IHByZXZlbnRcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChoYXNOb25lIHx8XG4gICAgICAgICAgICAgIChoYXNQYW5ZICYmIGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB8fFxuICAgICAgICAgICAgICAoaGFzUGFuWCAmJiBkaXJlY3Rpb24gJiBESVJFQ1RJT05fVkVSVElDQUwpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXZlbnRTcmMoc3JjRXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogY2FsbCBwcmV2ZW50RGVmYXVsdCB0byBwcmV2ZW50IHRoZSBicm93c2VyJ3MgZGVmYXVsdCBiZWhhdmlvciAoc2Nyb2xsaW5nIGluIG1vc3QgY2FzZXMpXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gc3JjRXZlbnRcbiAgICAgICAqL1xuICAgICAgcHJldmVudFNyYzogZnVuY3Rpb24oc3JjRXZlbnQpIHtcbiAgICAgICAgICB0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgICAgIHNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIHdoZW4gdGhlIHRvdWNoQWN0aW9ucyBhcmUgY29sbGVjdGVkIHRoZXkgYXJlIG5vdCBhIHZhbGlkIHZhbHVlLCBzbyB3ZSBuZWVkIHRvIGNsZWFuIHRoaW5ncyB1cC4gKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWN0aW9uc1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGZ1bmN0aW9uIGNsZWFuVG91Y2hBY3Rpb25zKGFjdGlvbnMpIHtcbiAgICAgIC8vIG5vbmVcbiAgICAgIGlmIChpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTk9ORSkpIHtcbiAgICAgICAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX05PTkU7XG4gICAgICB9XG5cbiAgICAgIHZhciBoYXNQYW5YID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9YKTtcbiAgICAgIHZhciBoYXNQYW5ZID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9ZKTtcblxuICAgICAgLy8gaWYgYm90aCBwYW4teCBhbmQgcGFuLXkgYXJlIHNldCAoZGlmZmVyZW50IHJlY29nbml6ZXJzXG4gICAgICAvLyBmb3IgZGlmZmVyZW50IGRpcmVjdGlvbnMsIGUuZy4gaG9yaXpvbnRhbCBwYW4gYnV0IHZlcnRpY2FsIHN3aXBlPylcbiAgICAgIC8vIHdlIG5lZWQgbm9uZSAoYXMgb3RoZXJ3aXNlIHdpdGggcGFuLXggcGFuLXkgY29tYmluZWQgbm9uZSBvZiB0aGVzZVxuICAgICAgLy8gcmVjb2duaXplcnMgd2lsbCB3b3JrLCBzaW5jZSB0aGUgYnJvd3NlciB3b3VsZCBoYW5kbGUgYWxsIHBhbm5pbmdcbiAgICAgIGlmIChoYXNQYW5YICYmIGhhc1BhblkpIHtcbiAgICAgICAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX05PTkU7XG4gICAgICB9XG5cbiAgICAgIC8vIHBhbi14IE9SIHBhbi15XG4gICAgICBpZiAoaGFzUGFuWCB8fCBoYXNQYW5ZKSB7XG4gICAgICAgICAgcmV0dXJuIGhhc1BhblggPyBUT1VDSF9BQ1RJT05fUEFOX1ggOiBUT1VDSF9BQ1RJT05fUEFOX1k7XG4gICAgICB9XG5cbiAgICAgIC8vIG1hbmlwdWxhdGlvblxuICAgICAgaWYgKGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT04pKSB7XG4gICAgICAgICAgcmV0dXJuIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT047XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBUT1VDSF9BQ1RJT05fQVVUTztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNvZ25pemVyIGZsb3cgZXhwbGFpbmVkOyAqXG4gICAqIEFsbCByZWNvZ25pemVycyBoYXZlIHRoZSBpbml0aWFsIHN0YXRlIG9mIFBPU1NJQkxFIHdoZW4gYSBpbnB1dCBzZXNzaW9uIHN0YXJ0cy5cbiAgICogVGhlIGRlZmluaXRpb24gb2YgYSBpbnB1dCBzZXNzaW9uIGlzIGZyb20gdGhlIGZpcnN0IGlucHV0IHVudGlsIHRoZSBsYXN0IGlucHV0LCB3aXRoIGFsbCBpdCdzIG1vdmVtZW50IGluIGl0LiAqXG4gICAqIEV4YW1wbGUgc2Vzc2lvbiBmb3IgbW91c2UtaW5wdXQ6IG1vdXNlZG93biAtPiBtb3VzZW1vdmUgLT4gbW91c2V1cFxuICAgKlxuICAgKiBPbiBlYWNoIHJlY29nbml6aW5nIGN5Y2xlIChzZWUgTWFuYWdlci5yZWNvZ25pemUpIHRoZSAucmVjb2duaXplKCkgbWV0aG9kIGlzIGV4ZWN1dGVkXG4gICAqIHdoaWNoIGRldGVybWluZXMgd2l0aCBzdGF0ZSBpdCBzaG91bGQgYmUuXG4gICAqXG4gICAqIElmIHRoZSByZWNvZ25pemVyIGhhcyB0aGUgc3RhdGUgRkFJTEVELCBDQU5DRUxMRUQgb3IgUkVDT0dOSVpFRCAoZXF1YWxzIEVOREVEKSwgaXQgaXMgcmVzZXQgdG9cbiAgICogUE9TU0lCTEUgdG8gZ2l2ZSBpdCBhbm90aGVyIGNoYW5nZSBvbiB0aGUgbmV4dCBjeWNsZS5cbiAgICpcbiAgICogICAgICAgICAgICAgICBQb3NzaWJsZVxuICAgKiAgICAgICAgICAgICAgICAgIHxcbiAgICogICAgICAgICAgICArLS0tLS0rLS0tLS0tLS0tLS0tLS0tK1xuICAgKiAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICB8XG4gICAqICAgICAgKy0tLS0tKy0tLS0tKyAgICAgICAgICAgICAgIHxcbiAgICogICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICAgICAgfFxuICAgKiAgIEZhaWxlZCAgICAgIENhbmNlbGxlZCAgICAgICAgICB8XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLSstLS0tLS0rXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8XG4gICAqICAgICAgICAgICAgICAgICAgICAgIFJlY29nbml6ZWQgICAgICAgQmVnYW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENoYW5nZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRW5kZWQvUmVjb2duaXplZFxuICAgKi9cbiAgdmFyIFNUQVRFX1BPU1NJQkxFID0gMTtcbiAgdmFyIFNUQVRFX0JFR0FOID0gMjtcbiAgdmFyIFNUQVRFX0NIQU5HRUQgPSA0O1xuICB2YXIgU1RBVEVfRU5ERUQgPSA4O1xuICB2YXIgU1RBVEVfUkVDT0dOSVpFRCA9IFNUQVRFX0VOREVEO1xuICB2YXIgU1RBVEVfQ0FOQ0VMTEVEID0gMTY7XG4gIHZhciBTVEFURV9GQUlMRUQgPSAzMjtcblxuICAvKipcbiAgICogUmVjb2duaXplclxuICAgKiBFdmVyeSByZWNvZ25pemVyIG5lZWRzIHRvIGV4dGVuZCBmcm9tIHRoaXMgY2xhc3MuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gUmVjb2duaXplcihvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBhc3NpZ24oe30sIHRoaXMuZGVmYXVsdHMsIG9wdGlvbnMgfHwge30pO1xuXG4gICAgICB0aGlzLmlkID0gdW5pcXVlSWQoKTtcblxuICAgICAgdGhpcy5tYW5hZ2VyID0gbnVsbDtcblxuICAgICAgLy8gZGVmYXVsdCBpcyBlbmFibGUgdHJ1ZVxuICAgICAgdGhpcy5vcHRpb25zLmVuYWJsZSA9IGlmVW5kZWZpbmVkKHRoaXMub3B0aW9ucy5lbmFibGUsIHRydWUpO1xuXG4gICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUE9TU0lCTEU7XG5cbiAgICAgIHRoaXMuc2ltdWx0YW5lb3VzID0ge307XG4gICAgICB0aGlzLnJlcXVpcmVGYWlsID0gW107XG4gIH1cblxuICBSZWNvZ25pemVyLnByb3RvdHlwZSA9IHtcbiAgICAgIC8qKlxuICAgICAgICogQHZpcnR1YWxcbiAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgKi9cbiAgICAgIGRlZmF1bHRzOiB7fSxcblxuICAgICAgLyoqXG4gICAgICAgKiBzZXQgb3B0aW9uc1xuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgICAqIEByZXR1cm4ge1JlY29nbml6ZXJ9XG4gICAgICAgKi9cbiAgICAgIHNldDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgIGFzc2lnbih0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgLy8gYWxzbyB1cGRhdGUgdGhlIHRvdWNoQWN0aW9uLCBpbiBjYXNlIHNvbWV0aGluZyBjaGFuZ2VkIGFib3V0IHRoZSBkaXJlY3Rpb25zL2VuYWJsZWQgc3RhdGVcbiAgICAgICAgICB0aGlzLm1hbmFnZXIgJiYgdGhpcy5tYW5hZ2VyLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiByZWNvZ25pemUgc2ltdWx0YW5lb3VzIHdpdGggYW4gb3RoZXIgcmVjb2duaXplci5cbiAgICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAgICovXG4gICAgICByZWNvZ25pemVXaXRoOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAncmVjb2duaXplV2l0aCcsIHRoaXMpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzaW11bHRhbmVvdXMgPSB0aGlzLnNpbXVsdGFuZW91cztcbiAgICAgICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgICAgICAgaWYgKCFzaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXSkge1xuICAgICAgICAgICAgICBzaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXSA9IG90aGVyUmVjb2duaXplcjtcbiAgICAgICAgICAgICAgb3RoZXJSZWNvZ25pemVyLnJlY29nbml6ZVdpdGgodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBkcm9wIHRoZSBzaW11bHRhbmVvdXMgbGluay4gaXQgZG9lc250IHJlbW92ZSB0aGUgbGluayBvbiB0aGUgb3RoZXIgcmVjb2duaXplci5cbiAgICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAgICovXG4gICAgICBkcm9wUmVjb2duaXplV2l0aDogZnVuY3Rpb24ob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ2Ryb3BSZWNvZ25pemVXaXRoJywgdGhpcykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiByZWNvZ25pemVyIGNhbiBvbmx5IHJ1biB3aGVuIGFuIG90aGVyIGlzIGZhaWxpbmdcbiAgICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAgICovXG4gICAgICByZXF1aXJlRmFpbHVyZTogZnVuY3Rpb24ob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ3JlcXVpcmVGYWlsdXJlJywgdGhpcykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJlcXVpcmVGYWlsID0gdGhpcy5yZXF1aXJlRmFpbDtcbiAgICAgICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgICAgICAgaWYgKGluQXJyYXkocmVxdWlyZUZhaWwsIG90aGVyUmVjb2duaXplcikgPT09IC0xKSB7XG4gICAgICAgICAgICAgIHJlcXVpcmVGYWlsLnB1c2gob3RoZXJSZWNvZ25pemVyKTtcbiAgICAgICAgICAgICAgb3RoZXJSZWNvZ25pemVyLnJlcXVpcmVGYWlsdXJlKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogZHJvcCB0aGUgcmVxdWlyZUZhaWx1cmUgbGluay4gaXQgZG9lcyBub3QgcmVtb3ZlIHRoZSBsaW5rIG9uIHRoZSBvdGhlciByZWNvZ25pemVyLlxuICAgICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAgICAgKi9cbiAgICAgIGRyb3BSZXF1aXJlRmFpbHVyZTogZnVuY3Rpb24ob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ2Ryb3BSZXF1aXJlRmFpbHVyZScsIHRoaXMpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcbiAgICAgICAgICB2YXIgaW5kZXggPSBpbkFycmF5KHRoaXMucmVxdWlyZUZhaWwsIG90aGVyUmVjb2duaXplcik7XG4gICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgdGhpcy5yZXF1aXJlRmFpbC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogaGFzIHJlcXVpcmUgZmFpbHVyZXMgYm9vbGVhblxuICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIGhhc1JlcXVpcmVGYWlsdXJlczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWlyZUZhaWwubGVuZ3RoID4gMDtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogaWYgdGhlIHJlY29nbml6ZXIgY2FuIHJlY29nbml6ZSBzaW11bHRhbmVvdXMgd2l0aCBhbiBvdGhlciByZWNvZ25pemVyXG4gICAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIGNhblJlY29nbml6ZVdpdGg6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICAgIHJldHVybiAhIXRoaXMuc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF07XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFlvdSBzaG91bGQgdXNlIGB0cnlFbWl0YCBpbnN0ZWFkIG9mIGBlbWl0YCBkaXJlY3RseSB0byBjaGVja1xuICAgICAgICogdGhhdCBhbGwgdGhlIG5lZWRlZCByZWNvZ25pemVycyBoYXMgZmFpbGVkIGJlZm9yZSBlbWl0dGluZy5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAgICovXG4gICAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuXG4gICAgICAgICAgZnVuY3Rpb24gZW1pdChldmVudCkge1xuICAgICAgICAgICAgICBzZWxmLm1hbmFnZXIuZW1pdChldmVudCwgaW5wdXQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vICdwYW5zdGFydCcgYW5kICdwYW5tb3ZlJ1xuICAgICAgICAgIGlmIChzdGF0ZSA8IFNUQVRFX0VOREVEKSB7XG4gICAgICAgICAgICAgIGVtaXQoc2VsZi5vcHRpb25zLmV2ZW50ICsgc3RhdGVTdHIoc3RhdGUpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCk7IC8vIHNpbXBsZSAnZXZlbnROYW1lJyBldmVudHNcblxuICAgICAgICAgIGlmIChpbnB1dC5hZGRpdGlvbmFsRXZlbnQpIHsgLy8gYWRkaXRpb25hbCBldmVudChwYW5sZWZ0LCBwYW5yaWdodCwgcGluY2hpbiwgcGluY2hvdXQuLi4pXG4gICAgICAgICAgICAgIGVtaXQoaW5wdXQuYWRkaXRpb25hbEV2ZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBwYW5lbmQgYW5kIHBhbmNhbmNlbFxuICAgICAgICAgIGlmIChzdGF0ZSA+PSBTVEFURV9FTkRFRCkge1xuICAgICAgICAgICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCArIHN0YXRlU3RyKHN0YXRlKSk7XG4gICAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBDaGVjayB0aGF0IGFsbCB0aGUgcmVxdWlyZSBmYWlsdXJlIHJlY29nbml6ZXJzIGhhcyBmYWlsZWQsXG4gICAgICAgKiBpZiB0cnVlLCBpdCBlbWl0cyBhIGdlc3R1cmUgZXZlbnQsXG4gICAgICAgKiBvdGhlcndpc2UsIHNldHVwIHRoZSBzdGF0ZSB0byBGQUlMRUQuXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICAgICAqL1xuICAgICAgdHJ5RW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgICBpZiAodGhpcy5jYW5FbWl0KCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChpbnB1dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGl0J3MgZmFpbGluZyBhbnl3YXlcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBjYW4gd2UgZW1pdD9cbiAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICovXG4gICAgICBjYW5FbWl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgd2hpbGUgKGkgPCB0aGlzLnJlcXVpcmVGYWlsLmxlbmd0aCkge1xuICAgICAgICAgICAgICBpZiAoISh0aGlzLnJlcXVpcmVGYWlsW2ldLnN0YXRlICYgKFNUQVRFX0ZBSUxFRCB8IFNUQVRFX1BPU1NJQkxFKSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiB1cGRhdGUgdGhlIHJlY29nbml6ZXJcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgICAqL1xuICAgICAgcmVjb2duaXplOiBmdW5jdGlvbihpbnB1dERhdGEpIHtcbiAgICAgICAgICAvLyBtYWtlIGEgbmV3IGNvcHkgb2YgdGhlIGlucHV0RGF0YVxuICAgICAgICAgIC8vIHNvIHdlIGNhbiBjaGFuZ2UgdGhlIGlucHV0RGF0YSB3aXRob3V0IG1lc3NpbmcgdXAgdGhlIG90aGVyIHJlY29nbml6ZXJzXG4gICAgICAgICAgdmFyIGlucHV0RGF0YUNsb25lID0gYXNzaWduKHt9LCBpbnB1dERhdGEpO1xuXG4gICAgICAgICAgLy8gaXMgaXMgZW5hYmxlZCBhbmQgYWxsb3cgcmVjb2duaXppbmc/XG4gICAgICAgICAgaWYgKCFib29sT3JGbih0aGlzLm9wdGlvbnMuZW5hYmxlLCBbdGhpcywgaW5wdXREYXRhQ2xvbmVdKSkge1xuICAgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyByZXNldCB3aGVuIHdlJ3ZlIHJlYWNoZWQgdGhlIGVuZFxuICAgICAgICAgIGlmICh0aGlzLnN0YXRlICYgKFNUQVRFX1JFQ09HTklaRUQgfCBTVEFURV9DQU5DRUxMRUQgfCBTVEFURV9GQUlMRUQpKSB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9QT1NTSUJMRTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5wcm9jZXNzKGlucHV0RGF0YUNsb25lKTtcblxuICAgICAgICAgIC8vIHRoZSByZWNvZ25pemVyIGhhcyByZWNvZ25pemVkIGEgZ2VzdHVyZVxuICAgICAgICAgIC8vIHNvIHRyaWdnZXIgYW4gZXZlbnRcbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZSAmIChTVEFURV9CRUdBTiB8IFNUQVRFX0NIQU5HRUQgfCBTVEFURV9FTkRFRCB8IFNUQVRFX0NBTkNFTExFRCkpIHtcbiAgICAgICAgICAgICAgdGhpcy50cnlFbWl0KGlucHV0RGF0YUNsb25lKTtcbiAgICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIHJldHVybiB0aGUgc3RhdGUgb2YgdGhlIHJlY29nbml6ZXJcbiAgICAgICAqIHRoZSBhY3R1YWwgcmVjb2duaXppbmcgaGFwcGVucyBpbiB0aGlzIG1ldGhvZFxuICAgICAgICogQHZpcnR1YWxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgICAqIEByZXR1cm5zIHtDb25zdH0gU1RBVEVcbiAgICAgICAqL1xuICAgICAgcHJvY2VzczogZnVuY3Rpb24oaW5wdXREYXRhKSB7IH0sIC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4gICAgICAvKipcbiAgICAgICAqIHJldHVybiB0aGUgcHJlZmVycmVkIHRvdWNoLWFjdGlvblxuICAgICAgICogQHZpcnR1YWxcbiAgICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgICAqL1xuICAgICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkgeyB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIGNhbGxlZCB3aGVuIHRoZSBnZXN0dXJlIGlzbid0IGFsbG93ZWQgdG8gcmVjb2duaXplXG4gICAgICAgKiBsaWtlIHdoZW4gYW5vdGhlciBpcyBiZWluZyByZWNvZ25pemVkIG9yIGl0IGlzIGRpc2FibGVkXG4gICAgICAgKiBAdmlydHVhbFxuICAgICAgICovXG4gICAgICByZXNldDogZnVuY3Rpb24oKSB7IH1cbiAgfTtcblxuICAvKipcbiAgICogZ2V0IGEgdXNhYmxlIHN0cmluZywgdXNlZCBhcyBldmVudCBwb3N0Zml4XG4gICAqIEBwYXJhbSB7Q29uc3R9IHN0YXRlXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IHN0YXRlXG4gICAqL1xuICBmdW5jdGlvbiBzdGF0ZVN0cihzdGF0ZSkge1xuICAgICAgaWYgKHN0YXRlICYgU1RBVEVfQ0FOQ0VMTEVEKSB7XG4gICAgICAgICAgcmV0dXJuICdjYW5jZWwnO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0VOREVEKSB7XG4gICAgICAgICAgcmV0dXJuICdlbmQnO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0NIQU5HRUQpIHtcbiAgICAgICAgICByZXR1cm4gJ21vdmUnO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0JFR0FOKSB7XG4gICAgICAgICAgcmV0dXJuICdzdGFydCc7XG4gICAgICB9XG4gICAgICByZXR1cm4gJyc7XG4gIH1cblxuICAvKipcbiAgICogZGlyZWN0aW9uIGNvbnMgdG8gc3RyaW5nXG4gICAqIEBwYXJhbSB7Q29uc3R9IGRpcmVjdGlvblxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKi9cbiAgZnVuY3Rpb24gZGlyZWN0aW9uU3RyKGRpcmVjdGlvbikge1xuICAgICAgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fRE9XTikge1xuICAgICAgICAgIHJldHVybiAnZG93bic7XG4gICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fVVApIHtcbiAgICAgICAgICByZXR1cm4gJ3VwJztcbiAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09IERJUkVDVElPTl9MRUZUKSB7XG4gICAgICAgICAgcmV0dXJuICdsZWZ0JztcbiAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09IERJUkVDVElPTl9SSUdIVCkge1xuICAgICAgICAgIHJldHVybiAncmlnaHQnO1xuICAgICAgfVxuICAgICAgcmV0dXJuICcnO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCBhIHJlY29nbml6ZXIgYnkgbmFtZSBpZiBpdCBpcyBib3VuZCB0byBhIG1hbmFnZXJcbiAgICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gb3RoZXJSZWNvZ25pemVyXG4gICAqIEBwYXJhbSB7UmVjb2duaXplcn0gcmVjb2duaXplclxuICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn1cbiAgICovXG4gIGZ1bmN0aW9uIGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCByZWNvZ25pemVyKSB7XG4gICAgICB2YXIgbWFuYWdlciA9IHJlY29nbml6ZXIubWFuYWdlcjtcbiAgICAgIGlmIChtYW5hZ2VyKSB7XG4gICAgICAgICAgcmV0dXJuIG1hbmFnZXIuZ2V0KG90aGVyUmVjb2duaXplcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3RoZXJSZWNvZ25pemVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgcmVjb2duaXplciBpcyBqdXN0IHVzZWQgYXMgYSBiYXNlIGZvciB0aGUgc2ltcGxlIGF0dHJpYnV0ZSByZWNvZ25pemVycy5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAgICovXG4gIGZ1bmN0aW9uIEF0dHJSZWNvZ25pemVyKCkge1xuICAgICAgUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgaW5oZXJpdChBdHRyUmVjb2duaXplciwgUmVjb2duaXplciwge1xuICAgICAgLyoqXG4gICAgICAgKiBAbmFtZXNwYWNlXG4gICAgICAgKiBAbWVtYmVyb2YgQXR0clJlY29nbml6ZXJcbiAgICAgICAqL1xuICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBwb2ludGVyczogMVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGNoZWNrIGlmIGl0IHRoZSByZWNvZ25pemVyIHJlY2VpdmVzIHZhbGlkIGlucHV0LCBsaWtlIGlucHV0LmRpc3RhbmNlID4gMTAuXG4gICAgICAgKiBAbWVtYmVyb2YgQXR0clJlY29nbml6ZXJcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAgICogQHJldHVybnMge0Jvb2xlYW59IHJlY29nbml6ZWRcbiAgICAgICAqL1xuICAgICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgICAgdmFyIG9wdGlvblBvaW50ZXJzID0gdGhpcy5vcHRpb25zLnBvaW50ZXJzO1xuICAgICAgICAgIHJldHVybiBvcHRpb25Qb2ludGVycyA9PT0gMCB8fCBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvblBvaW50ZXJzO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBQcm9jZXNzIHRoZSBpbnB1dCBhbmQgcmV0dXJuIHRoZSBzdGF0ZSBmb3IgdGhlIHJlY29nbml6ZXJcbiAgICAgICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICAgKiBAcmV0dXJucyB7Kn0gU3RhdGVcbiAgICAgICAqL1xuICAgICAgcHJvY2VzczogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICAgIHZhciBldmVudFR5cGUgPSBpbnB1dC5ldmVudFR5cGU7XG5cbiAgICAgICAgICB2YXIgaXNSZWNvZ25pemVkID0gc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEKTtcbiAgICAgICAgICB2YXIgaXNWYWxpZCA9IHRoaXMuYXR0clRlc3QoaW5wdXQpO1xuXG4gICAgICAgICAgLy8gb24gY2FuY2VsIGlucHV0IGFuZCB3ZSd2ZSByZWNvZ25pemVkIGJlZm9yZSwgcmV0dXJuIFNUQVRFX0NBTkNFTExFRFxuICAgICAgICAgIGlmIChpc1JlY29nbml6ZWQgJiYgKGV2ZW50VHlwZSAmIElOUFVUX0NBTkNFTCB8fCAhaXNWYWxpZCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfQ0FOQ0VMTEVEO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNSZWNvZ25pemVkIHx8IGlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfRU5ERUQ7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIShzdGF0ZSAmIFNUQVRFX0JFR0FOKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX0JFR0FOO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0NIQU5HRUQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gICAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBQYW5cbiAgICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvd24gYW5kIG1vdmVkIGluIHRoZSBhbGxvd2VkIGRpcmVjdGlvbi5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gICAqL1xuICBmdW5jdGlvbiBQYW5SZWNvZ25pemVyKCkge1xuICAgICAgQXR0clJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgdGhpcy5wWCA9IG51bGw7XG4gICAgICB0aGlzLnBZID0gbnVsbDtcbiAgfVxuXG4gIGluaGVyaXQoUGFuUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAgIC8qKlxuICAgICAgICogQG5hbWVzcGFjZVxuICAgICAgICogQG1lbWJlcm9mIFBhblJlY29nbml6ZXJcbiAgICAgICAqL1xuICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgICBldmVudDogJ3BhbicsXG4gICAgICAgICAgdGhyZXNob2xkOiAxMCxcbiAgICAgICAgICBwb2ludGVyczogMSxcbiAgICAgICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9BTExcbiAgICAgIH0sXG5cbiAgICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgICAgICAgICB2YXIgYWN0aW9ucyA9IFtdO1xuICAgICAgICAgIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICAgICAgICBhY3Rpb25zLnB1c2goVE9VQ0hfQUNUSU9OX1BBTl9ZKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkge1xuICAgICAgICAgICAgICBhY3Rpb25zLnB1c2goVE9VQ0hfQUNUSU9OX1BBTl9YKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFjdGlvbnM7XG4gICAgICB9LFxuXG4gICAgICBkaXJlY3Rpb25UZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAgIHZhciBoYXNNb3ZlZCA9IHRydWU7XG4gICAgICAgICAgdmFyIGRpc3RhbmNlID0gaW5wdXQuZGlzdGFuY2U7XG4gICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGlucHV0LmRpcmVjdGlvbjtcbiAgICAgICAgICB2YXIgeCA9IGlucHV0LmRlbHRhWDtcbiAgICAgICAgICB2YXIgeSA9IGlucHV0LmRlbHRhWTtcblxuICAgICAgICAgIC8vIGxvY2sgdG8gYXhpcz9cbiAgICAgICAgICBpZiAoIShkaXJlY3Rpb24gJiBvcHRpb25zLmRpcmVjdGlvbikpIHtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHtcbiAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9ICh4ID09PSAwKSA/IERJUkVDVElPTl9OT05FIDogKHggPCAwKSA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xuICAgICAgICAgICAgICAgICAgaGFzTW92ZWQgPSB4ICE9IHRoaXMucFg7XG4gICAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IE1hdGguYWJzKGlucHV0LmRlbHRhWCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSAoeSA9PT0gMCkgPyBESVJFQ1RJT05fTk9ORSA6ICh5IDwgMCkgPyBESVJFQ1RJT05fVVAgOiBESVJFQ1RJT05fRE9XTjtcbiAgICAgICAgICAgICAgICAgIGhhc01vdmVkID0geSAhPSB0aGlzLnBZO1xuICAgICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhpbnB1dC5kZWx0YVkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlucHV0LmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICAgICAgICByZXR1cm4gaGFzTW92ZWQgJiYgZGlzdGFuY2UgPiBvcHRpb25zLnRocmVzaG9sZCAmJiBkaXJlY3Rpb24gJiBvcHRpb25zLmRpcmVjdGlvbjtcbiAgICAgIH0sXG5cbiAgICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICAgIHJldHVybiBBdHRyUmVjb2duaXplci5wcm90b3R5cGUuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiZcbiAgICAgICAgICAgICAgKHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTiB8fCAoISh0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4pICYmIHRoaXMuZGlyZWN0aW9uVGVzdChpbnB1dCkpKTtcbiAgICAgIH0sXG5cbiAgICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG5cbiAgICAgICAgICB0aGlzLnBYID0gaW5wdXQuZGVsdGFYO1xuICAgICAgICAgIHRoaXMucFkgPSBpbnB1dC5kZWx0YVk7XG5cbiAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gZGlyZWN0aW9uU3RyKGlucHV0LmRpcmVjdGlvbik7XG5cbiAgICAgICAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgIGlucHV0LmFkZGl0aW9uYWxFdmVudCA9IHRoaXMub3B0aW9ucy5ldmVudCArIGRpcmVjdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fc3VwZXIuZW1pdC5jYWxsKHRoaXMsIGlucHV0KTtcbiAgICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFBpbmNoXG4gICAqIFJlY29nbml6ZWQgd2hlbiB0d28gb3IgbW9yZSBwb2ludGVycyBhcmUgbW92aW5nIHRvd2FyZCAoem9vbS1pbikgb3IgYXdheSBmcm9tIGVhY2ggb3RoZXIgKHpvb20tb3V0KS5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gICAqL1xuICBmdW5jdGlvbiBQaW5jaFJlY29nbml6ZXIoKSB7XG4gICAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgaW5oZXJpdChQaW5jaFJlY29nbml6ZXIsIEF0dHJSZWNvZ25pemVyLCB7XG4gICAgICAvKipcbiAgICAgICAqIEBuYW1lc3BhY2VcbiAgICAgICAqIEBtZW1iZXJvZiBQaW5jaFJlY29nbml6ZXJcbiAgICAgICAqL1xuICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgICBldmVudDogJ3BpbmNoJyxcbiAgICAgICAgICB0aHJlc2hvbGQ6IDAsXG4gICAgICAgICAgcG9pbnRlcnM6IDJcbiAgICAgIH0sXG5cbiAgICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9OT05FXTtcbiAgICAgIH0sXG5cbiAgICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zdXBlci5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJlxuICAgICAgICAgICAgICAoTWF0aC5hYnMoaW5wdXQuc2NhbGUgLSAxKSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgfHwgdGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKTtcbiAgICAgIH0sXG5cbiAgICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgICAgaWYgKGlucHV0LnNjYWxlICE9PSAxKSB7XG4gICAgICAgICAgICAgIHZhciBpbk91dCA9IGlucHV0LnNjYWxlIDwgMSA/ICdpbicgOiAnb3V0JztcbiAgICAgICAgICAgICAgaW5wdXQuYWRkaXRpb25hbEV2ZW50ID0gdGhpcy5vcHRpb25zLmV2ZW50ICsgaW5PdXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3N1cGVyLmVtaXQuY2FsbCh0aGlzLCBpbnB1dCk7XG4gICAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBQcmVzc1xuICAgKiBSZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgZG93biBmb3IgeCBtcyB3aXRob3V0IGFueSBtb3ZlbWVudC5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAgICovXG4gIGZ1bmN0aW9uIFByZXNzUmVjb2duaXplcigpIHtcbiAgICAgIFJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgICAgdGhpcy5faW5wdXQgPSBudWxsO1xuICB9XG5cbiAgaW5oZXJpdChQcmVzc1JlY29nbml6ZXIsIFJlY29nbml6ZXIsIHtcbiAgICAgIC8qKlxuICAgICAgICogQG5hbWVzcGFjZVxuICAgICAgICogQG1lbWJlcm9mIFByZXNzUmVjb2duaXplclxuICAgICAgICovXG4gICAgICBkZWZhdWx0czoge1xuICAgICAgICAgIGV2ZW50OiAncHJlc3MnLFxuICAgICAgICAgIHBvaW50ZXJzOiAxLFxuICAgICAgICAgIHRpbWU6IDI1MSwgLy8gbWluaW1hbCB0aW1lIG9mIHRoZSBwb2ludGVyIHRvIGJlIHByZXNzZWRcbiAgICAgICAgICB0aHJlc2hvbGQ6IDkgLy8gYSBtaW5pbWFsIG1vdmVtZW50IGlzIG9rLCBidXQga2VlcCBpdCBsb3dcbiAgICAgIH0sXG5cbiAgICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9BVVRPXTtcbiAgICAgIH0sXG5cbiAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgdmFyIHZhbGlkUG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvbnMucG9pbnRlcnM7XG4gICAgICAgICAgdmFyIHZhbGlkTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IG9wdGlvbnMudGhyZXNob2xkO1xuICAgICAgICAgIHZhciB2YWxpZFRpbWUgPSBpbnB1dC5kZWx0YVRpbWUgPiBvcHRpb25zLnRpbWU7XG5cbiAgICAgICAgICB0aGlzLl9pbnB1dCA9IGlucHV0O1xuXG4gICAgICAgICAgLy8gd2Ugb25seSBhbGxvdyBsaXR0bGUgbW92ZW1lbnRcbiAgICAgICAgICAvLyBhbmQgd2UndmUgcmVhY2hlZCBhbiBlbmQgZXZlbnQsIHNvIGEgdGFwIGlzIHBvc3NpYmxlXG4gICAgICAgICAgaWYgKCF2YWxpZE1vdmVtZW50IHx8ICF2YWxpZFBvaW50ZXJzIHx8IChpbnB1dC5ldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiAhdmFsaWRUaW1lKSkge1xuICAgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9TVEFSVCkge1xuICAgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dENvbnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICAgICAgICAgICAgICAgIHRoaXMudHJ5RW1pdCgpO1xuICAgICAgICAgICAgICB9LCBvcHRpb25zLnRpbWUsIHRoaXMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XG4gICAgICAgICAgICAgIHJldHVybiBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgICAgfSxcblxuICAgICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gICAgICB9LFxuXG4gICAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTVEFURV9SRUNPR05JWkVEKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaW5wdXQgJiYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50ICsgJ3VwJywgaW5wdXQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuX2lucHV0LnRpbWVTdGFtcCA9IG5vdygpO1xuICAgICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIHRoaXMuX2lucHV0KTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSb3RhdGVcbiAgICogUmVjb2duaXplZCB3aGVuIHR3byBvciBtb3JlIHBvaW50ZXIgYXJlIG1vdmluZyBpbiBhIGNpcmN1bGFyIG1vdGlvbi5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gICAqL1xuICBmdW5jdGlvbiBSb3RhdGVSZWNvZ25pemVyKCkge1xuICAgICAgQXR0clJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGluaGVyaXQoUm90YXRlUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAgIC8qKlxuICAgICAgICogQG5hbWVzcGFjZVxuICAgICAgICogQG1lbWJlcm9mIFJvdGF0ZVJlY29nbml6ZXJcbiAgICAgICAqL1xuICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgICBldmVudDogJ3JvdGF0ZScsXG4gICAgICAgICAgdGhyZXNob2xkOiAwLFxuICAgICAgICAgIHBvaW50ZXJzOiAyXG4gICAgICB9LFxuXG4gICAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTk9ORV07XG4gICAgICB9LFxuXG4gICAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc3VwZXIuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiZcbiAgICAgICAgICAgICAgKE1hdGguYWJzKGlucHV0LnJvdGF0aW9uKSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgfHwgdGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKTtcbiAgICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFN3aXBlXG4gICAqIFJlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBtb3ZpbmcgZmFzdCAodmVsb2NpdHkpLCB3aXRoIGVub3VnaCBkaXN0YW5jZSBpbiB0aGUgYWxsb3dlZCBkaXJlY3Rpb24uXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICAgKi9cbiAgZnVuY3Rpb24gU3dpcGVSZWNvZ25pemVyKCkge1xuICAgICAgQXR0clJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGluaGVyaXQoU3dpcGVSZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xuICAgICAgLyoqXG4gICAgICAgKiBAbmFtZXNwYWNlXG4gICAgICAgKiBAbWVtYmVyb2YgU3dpcGVSZWNvZ25pemVyXG4gICAgICAgKi9cbiAgICAgIGRlZmF1bHRzOiB7XG4gICAgICAgICAgZXZlbnQ6ICdzd2lwZScsXG4gICAgICAgICAgdGhyZXNob2xkOiAxMCxcbiAgICAgICAgICB2ZWxvY2l0eTogMC4zLFxuICAgICAgICAgIGRpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUwsXG4gICAgICAgICAgcG9pbnRlcnM6IDFcbiAgICAgIH0sXG5cbiAgICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gUGFuUmVjb2duaXplci5wcm90b3R5cGUuZ2V0VG91Y2hBY3Rpb24uY2FsbCh0aGlzKTtcbiAgICAgIH0sXG5cbiAgICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uO1xuICAgICAgICAgIHZhciB2ZWxvY2l0eTtcblxuICAgICAgICAgIGlmIChkaXJlY3Rpb24gJiAoRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUwpKSB7XG4gICAgICAgICAgICAgIHZlbG9jaXR5ID0gaW5wdXQub3ZlcmFsbFZlbG9jaXR5O1xuICAgICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHtcbiAgICAgICAgICAgICAgdmVsb2NpdHkgPSBpbnB1dC5vdmVyYWxsVmVsb2NpdHlYO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSB7XG4gICAgICAgICAgICAgIHZlbG9jaXR5ID0gaW5wdXQub3ZlcmFsbFZlbG9jaXR5WTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5fc3VwZXIuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiZcbiAgICAgICAgICAgICAgZGlyZWN0aW9uICYgaW5wdXQub2Zmc2V0RGlyZWN0aW9uICYmXG4gICAgICAgICAgICAgIGlucHV0LmRpc3RhbmNlID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCAmJlxuICAgICAgICAgICAgICBpbnB1dC5tYXhQb2ludGVycyA9PSB0aGlzLm9wdGlvbnMucG9pbnRlcnMgJiZcbiAgICAgICAgICAgICAgYWJzKHZlbG9jaXR5KSA+IHRoaXMub3B0aW9ucy52ZWxvY2l0eSAmJiBpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQ7XG4gICAgICB9LFxuXG4gICAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSBkaXJlY3Rpb25TdHIoaW5wdXQub2Zmc2V0RGlyZWN0aW9uKTtcbiAgICAgICAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCArIGRpcmVjdGlvbiwgaW5wdXQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgaW5wdXQpO1xuICAgICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQSB0YXAgaXMgZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgZG9pbmcgYSBzbWFsbCB0YXAvY2xpY2suIE11bHRpcGxlIHRhcHMgYXJlIHJlY29nbml6ZWQgaWYgdGhleSBvY2N1clxuICAgKiBiZXR3ZWVuIHRoZSBnaXZlbiBpbnRlcnZhbCBhbmQgcG9zaXRpb24uIFRoZSBkZWxheSBvcHRpb24gY2FuIGJlIHVzZWQgdG8gcmVjb2duaXplIG11bHRpLXRhcHMgd2l0aG91dCBmaXJpbmdcbiAgICogYSBzaW5nbGUgdGFwLlxuICAgKlxuICAgKiBUaGUgZXZlbnREYXRhIGZyb20gdGhlIGVtaXR0ZWQgZXZlbnQgY29udGFpbnMgdGhlIHByb3BlcnR5IGB0YXBDb3VudGAsIHdoaWNoIGNvbnRhaW5zIHRoZSBhbW91bnQgb2ZcbiAgICogbXVsdGktdGFwcyBiZWluZyByZWNvZ25pemVkLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMgUmVjb2duaXplclxuICAgKi9cbiAgZnVuY3Rpb24gVGFwUmVjb2duaXplcigpIHtcbiAgICAgIFJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgLy8gcHJldmlvdXMgdGltZSBhbmQgY2VudGVyLFxuICAgICAgLy8gdXNlZCBmb3IgdGFwIGNvdW50aW5nXG4gICAgICB0aGlzLnBUaW1lID0gZmFsc2U7XG4gICAgICB0aGlzLnBDZW50ZXIgPSBmYWxzZTtcblxuICAgICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgICAgdGhpcy5faW5wdXQgPSBudWxsO1xuICAgICAgdGhpcy5jb3VudCA9IDA7XG4gIH1cblxuICBpbmhlcml0KFRhcFJlY29nbml6ZXIsIFJlY29nbml6ZXIsIHtcbiAgICAgIC8qKlxuICAgICAgICogQG5hbWVzcGFjZVxuICAgICAgICogQG1lbWJlcm9mIFBpbmNoUmVjb2duaXplclxuICAgICAgICovXG4gICAgICBkZWZhdWx0czoge1xuICAgICAgICAgIGV2ZW50OiAndGFwJyxcbiAgICAgICAgICBwb2ludGVyczogMSxcbiAgICAgICAgICB0YXBzOiAxLFxuICAgICAgICAgIGludGVydmFsOiAzMDAsIC8vIG1heCB0aW1lIGJldHdlZW4gdGhlIG11bHRpLXRhcCB0YXBzXG4gICAgICAgICAgdGltZTogMjUwLCAvLyBtYXggdGltZSBvZiB0aGUgcG9pbnRlciB0byBiZSBkb3duIChsaWtlIGZpbmdlciBvbiB0aGUgc2NyZWVuKVxuICAgICAgICAgIHRocmVzaG9sZDogOSwgLy8gYSBtaW5pbWFsIG1vdmVtZW50IGlzIG9rLCBidXQga2VlcCBpdCBsb3dcbiAgICAgICAgICBwb3NUaHJlc2hvbGQ6IDEwIC8vIGEgbXVsdGktdGFwIGNhbiBiZSBhIGJpdCBvZmYgdGhlIGluaXRpYWwgcG9zaXRpb25cbiAgICAgIH0sXG5cbiAgICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9NQU5JUFVMQVRJT05dO1xuICAgICAgfSxcblxuICAgICAgcHJvY2VzczogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgICAgICAgIHZhciB2YWxpZFBvaW50ZXJzID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25zLnBvaW50ZXJzO1xuICAgICAgICAgIHZhciB2YWxpZE1vdmVtZW50ID0gaW5wdXQuZGlzdGFuY2UgPCBvcHRpb25zLnRocmVzaG9sZDtcbiAgICAgICAgICB2YXIgdmFsaWRUb3VjaFRpbWUgPSBpbnB1dC5kZWx0YVRpbWUgPCBvcHRpb25zLnRpbWU7XG5cbiAgICAgICAgICB0aGlzLnJlc2V0KCk7XG5cbiAgICAgICAgICBpZiAoKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX1NUQVJUKSAmJiAodGhpcy5jb3VudCA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmFpbFRpbWVvdXQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB3ZSBvbmx5IGFsbG93IGxpdHRsZSBtb3ZlbWVudFxuICAgICAgICAgIC8vIGFuZCB3ZSd2ZSByZWFjaGVkIGFuIGVuZCBldmVudCwgc28gYSB0YXAgaXMgcG9zc2libGVcbiAgICAgICAgICBpZiAodmFsaWRNb3ZlbWVudCAmJiB2YWxpZFRvdWNoVGltZSAmJiB2YWxpZFBvaW50ZXJzKSB7XG4gICAgICAgICAgICAgIGlmIChpbnB1dC5ldmVudFR5cGUgIT0gSU5QVVRfRU5EKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mYWlsVGltZW91dCgpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIHZhbGlkSW50ZXJ2YWwgPSB0aGlzLnBUaW1lID8gKGlucHV0LnRpbWVTdGFtcCAtIHRoaXMucFRpbWUgPCBvcHRpb25zLmludGVydmFsKSA6IHRydWU7XG4gICAgICAgICAgICAgIHZhciB2YWxpZE11bHRpVGFwID0gIXRoaXMucENlbnRlciB8fCBnZXREaXN0YW5jZSh0aGlzLnBDZW50ZXIsIGlucHV0LmNlbnRlcikgPCBvcHRpb25zLnBvc1RocmVzaG9sZDtcblxuICAgICAgICAgICAgICB0aGlzLnBUaW1lID0gaW5wdXQudGltZVN0YW1wO1xuICAgICAgICAgICAgICB0aGlzLnBDZW50ZXIgPSBpbnB1dC5jZW50ZXI7XG5cbiAgICAgICAgICAgICAgaWYgKCF2YWxpZE11bHRpVGFwIHx8ICF2YWxpZEludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmNvdW50ID0gMTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuY291bnQgKz0gMTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG5cbiAgICAgICAgICAgICAgLy8gaWYgdGFwIGNvdW50IG1hdGNoZXMgd2UgaGF2ZSByZWNvZ25pemVkIGl0LFxuICAgICAgICAgICAgICAvLyBlbHNlIGl0IGhhcyBiZWdhbiByZWNvZ25pemluZy4uLlxuICAgICAgICAgICAgICB2YXIgdGFwQ291bnQgPSB0aGlzLmNvdW50ICUgb3B0aW9ucy50YXBzO1xuICAgICAgICAgICAgICBpZiAodGFwQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIC8vIG5vIGZhaWxpbmcgcmVxdWlyZW1lbnRzLCBpbW1lZGlhdGVseSB0cmlnZ2VyIHRoZSB0YXAgZXZlbnRcbiAgICAgICAgICAgICAgICAgIC8vIG9yIHdhaXQgYXMgbG9uZyBhcyB0aGUgbXVsdGl0YXAgaW50ZXJ2YWwgdG8gdHJpZ2dlclxuICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmhhc1JlcXVpcmVGYWlsdXJlcygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dENvbnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyeUVtaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICB9LCBvcHRpb25zLmludGVydmFsLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfQkVHQU47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICAgIH0sXG5cbiAgICAgIGZhaWxUaW1lb3V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXRDb250ZXh0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xuICAgICAgICAgIH0sIHRoaXMub3B0aW9ucy5pbnRlcnZhbCwgdGhpcyk7XG4gICAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICAgIH0sXG5cbiAgICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICAgICAgfSxcblxuICAgICAgZW1pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT0gU1RBVEVfUkVDT0dOSVpFRCkge1xuICAgICAgICAgICAgICB0aGlzLl9pbnB1dC50YXBDb3VudCA9IHRoaXMuY291bnQ7XG4gICAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgdGhpcy5faW5wdXQpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFNpbXBsZSB3YXkgdG8gY3JlYXRlIGEgbWFuYWdlciB3aXRoIGEgZGVmYXVsdCBzZXQgb2YgcmVjb2duaXplcnMuXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIEhhbW1lcihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIG9wdGlvbnMucmVjb2duaXplcnMgPSBpZlVuZGVmaW5lZChvcHRpb25zLnJlY29nbml6ZXJzLCBIYW1tZXIuZGVmYXVsdHMucHJlc2V0KTtcbiAgICAgIHJldHVybiBuZXcgTWFuYWdlcihlbGVtZW50LCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAY29uc3Qge3N0cmluZ31cbiAgICovXG4gIEhhbW1lci5WRVJTSU9OID0gJzIuMC42JztcblxuICAvKipcbiAgICogZGVmYXVsdCBzZXR0aW5nc1xuICAgKiBAbmFtZXNwYWNlXG4gICAqL1xuICBIYW1tZXIuZGVmYXVsdHMgPSB7XG4gICAgICAvKipcbiAgICAgICAqIHNldCBpZiBET00gZXZlbnRzIGFyZSBiZWluZyB0cmlnZ2VyZWQuXG4gICAgICAgKiBCdXQgdGhpcyBpcyBzbG93ZXIgYW5kIHVudXNlZCBieSBzaW1wbGUgaW1wbGVtZW50YXRpb25zLCBzbyBkaXNhYmxlZCBieSBkZWZhdWx0LlxuICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICovXG4gICAgICBkb21FdmVudHM6IGZhbHNlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSB2YWx1ZSBmb3IgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5L2ZhbGxiYWNrLlxuICAgICAgICogV2hlbiBzZXQgdG8gYGNvbXB1dGVgIGl0IHdpbGwgbWFnaWNhbGx5IHNldCB0aGUgY29ycmVjdCB2YWx1ZSBiYXNlZCBvbiB0aGUgYWRkZWQgcmVjb2duaXplcnMuXG4gICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICogQGRlZmF1bHQgY29tcHV0ZVxuICAgICAgICovXG4gICAgICB0b3VjaEFjdGlvbjogVE9VQ0hfQUNUSU9OX0NPTVBVVEUsXG5cbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICAgKi9cbiAgICAgIGVuYWJsZTogdHJ1ZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBFWFBFUklNRU5UQUwgRkVBVFVSRSAtLSBjYW4gYmUgcmVtb3ZlZC9jaGFuZ2VkXG4gICAgICAgKiBDaGFuZ2UgdGhlIHBhcmVudCBpbnB1dCB0YXJnZXQgZWxlbWVudC5cbiAgICAgICAqIElmIE51bGwsIHRoZW4gaXQgaXMgYmVpbmcgc2V0IHRoZSB0byBtYWluIGVsZW1lbnQuXG4gICAgICAgKiBAdHlwZSB7TnVsbHxFdmVudFRhcmdldH1cbiAgICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgICAqL1xuICAgICAgaW5wdXRUYXJnZXQ6IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICogZm9yY2UgYW4gaW5wdXQgY2xhc3NcbiAgICAgICAqIEB0eXBlIHtOdWxsfEZ1bmN0aW9ufVxuICAgICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAgICovXG4gICAgICBpbnB1dENsYXNzOiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICAqIERlZmF1bHQgcmVjb2duaXplciBzZXR1cCB3aGVuIGNhbGxpbmcgYEhhbW1lcigpYFxuICAgICAgICogV2hlbiBjcmVhdGluZyBhIG5ldyBNYW5hZ2VyIHRoZXNlIHdpbGwgYmUgc2tpcHBlZC5cbiAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAqL1xuICAgICAgcHJlc2V0OiBbXG4gICAgICAgICAgLy8gUmVjb2duaXplckNsYXNzLCBvcHRpb25zLCBbcmVjb2duaXplV2l0aCwgLi4uXSwgW3JlcXVpcmVGYWlsdXJlLCAuLi5dXG4gICAgICAgICAgW1JvdGF0ZVJlY29nbml6ZXIsIHtlbmFibGU6IGZhbHNlfV0sXG4gICAgICAgICAgW1BpbmNoUmVjb2duaXplciwge2VuYWJsZTogZmFsc2V9LCBbJ3JvdGF0ZSddXSxcbiAgICAgICAgICBbU3dpcGVSZWNvZ25pemVyLCB7ZGlyZWN0aW9uOiBESVJFQ1RJT05fSE9SSVpPTlRBTH1dLFxuICAgICAgICAgIFtQYW5SZWNvZ25pemVyLCB7ZGlyZWN0aW9uOiBESVJFQ1RJT05fSE9SSVpPTlRBTH0sIFsnc3dpcGUnXV0sXG4gICAgICAgICAgW1RhcFJlY29nbml6ZXJdLFxuICAgICAgICAgIFtUYXBSZWNvZ25pemVyLCB7ZXZlbnQ6ICdkb3VibGV0YXAnLCB0YXBzOiAyfSwgWyd0YXAnXV0sXG4gICAgICAgICAgW1ByZXNzUmVjb2duaXplcl1cbiAgICAgIF0sXG5cbiAgICAgIC8qKlxuICAgICAgICogU29tZSBDU1MgcHJvcGVydGllcyBjYW4gYmUgdXNlZCB0byBpbXByb3ZlIHRoZSB3b3JraW5nIG9mIEhhbW1lci5cbiAgICAgICAqIEFkZCB0aGVtIHRvIHRoaXMgbWV0aG9kIGFuZCB0aGV5IHdpbGwgYmUgc2V0IHdoZW4gY3JlYXRpbmcgYSBuZXcgTWFuYWdlci5cbiAgICAgICAqIEBuYW1lc3BhY2VcbiAgICAgICAqL1xuICAgICAgY3NzUHJvcHM6IHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBEaXNhYmxlcyB0ZXh0IHNlbGVjdGlvbiB0byBpbXByb3ZlIHRoZSBkcmFnZ2luZyBnZXN0dXJlLiBNYWlubHkgZm9yIGRlc2t0b3AgYnJvd3NlcnMuXG4gICAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICAgKi9cbiAgICAgICAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBEaXNhYmxlIHRoZSBXaW5kb3dzIFBob25lIGdyaXBwZXJzIHdoZW4gcHJlc3NpbmcgYW4gZWxlbWVudC5cbiAgICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICAgICAqL1xuICAgICAgICAgIHRvdWNoU2VsZWN0OiAnbm9uZScsXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBEaXNhYmxlcyB0aGUgZGVmYXVsdCBjYWxsb3V0IHNob3duIHdoZW4geW91IHRvdWNoIGFuZCBob2xkIGEgdG91Y2ggdGFyZ2V0LlxuICAgICAgICAgICAqIE9uIGlPUywgd2hlbiB5b3UgdG91Y2ggYW5kIGhvbGQgYSB0b3VjaCB0YXJnZXQgc3VjaCBhcyBhIGxpbmssIFNhZmFyaSBkaXNwbGF5c1xuICAgICAgICAgICAqIGEgY2FsbG91dCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBsaW5rLiBUaGlzIHByb3BlcnR5IGFsbG93cyB5b3UgdG8gZGlzYWJsZSB0aGF0IGNhbGxvdXQuXG4gICAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICAgKi9cbiAgICAgICAgICB0b3VjaENhbGxvdXQ6ICdub25lJyxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFNwZWNpZmllcyB3aGV0aGVyIHpvb21pbmcgaXMgZW5hYmxlZC4gVXNlZCBieSBJRTEwPlxuICAgICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgICAgICovXG4gICAgICAgICAgY29udGVudFpvb21pbmc6ICdub25lJyxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFNwZWNpZmllcyB0aGF0IGFuIGVudGlyZSBlbGVtZW50IHNob3VsZCBiZSBkcmFnZ2FibGUgaW5zdGVhZCBvZiBpdHMgY29udGVudHMuIE1haW5seSBmb3IgZGVza3RvcCBicm93c2Vycy5cbiAgICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICAgICAqL1xuICAgICAgICAgIHVzZXJEcmFnOiAnbm9uZScsXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBPdmVycmlkZXMgdGhlIGhpZ2hsaWdodCBjb2xvciBzaG93biB3aGVuIHRoZSB1c2VyIHRhcHMgYSBsaW5rIG9yIGEgSmF2YVNjcmlwdFxuICAgICAgICAgICAqIGNsaWNrYWJsZSBlbGVtZW50IGluIGlPUy4gVGhpcyBwcm9wZXJ0eSBvYmV5cyB0aGUgYWxwaGEgdmFsdWUsIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgICAqIEBkZWZhdWx0ICdyZ2JhKDAsMCwwLDApJ1xuICAgICAgICAgICAqL1xuICAgICAgICAgIHRhcEhpZ2hsaWdodENvbG9yOiAncmdiYSgwLDAsMCwwKSdcbiAgICAgIH1cbiAgfTtcblxuICB2YXIgU1RPUCA9IDE7XG4gIHZhciBGT1JDRURfU1RPUCA9IDI7XG5cbiAgLyoqXG4gICAqIE1hbmFnZXJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gTWFuYWdlcihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBhc3NpZ24oe30sIEhhbW1lci5kZWZhdWx0cywgb3B0aW9ucyB8fCB7fSk7XG5cbiAgICAgIHRoaXMub3B0aW9ucy5pbnB1dFRhcmdldCA9IHRoaXMub3B0aW9ucy5pbnB1dFRhcmdldCB8fCBlbGVtZW50O1xuXG4gICAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgICB0aGlzLnNlc3Npb24gPSB7fTtcbiAgICAgIHRoaXMucmVjb2duaXplcnMgPSBbXTtcblxuICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHRoaXMuaW5wdXQgPSBjcmVhdGVJbnB1dEluc3RhbmNlKHRoaXMpO1xuICAgICAgdGhpcy50b3VjaEFjdGlvbiA9IG5ldyBUb3VjaEFjdGlvbih0aGlzLCB0aGlzLm9wdGlvbnMudG91Y2hBY3Rpb24pO1xuXG4gICAgICB0b2dnbGVDc3NQcm9wcyh0aGlzLCB0cnVlKTtcblxuICAgICAgZWFjaCh0aGlzLm9wdGlvbnMucmVjb2duaXplcnMsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICB2YXIgcmVjb2duaXplciA9IHRoaXMuYWRkKG5ldyAoaXRlbVswXSkoaXRlbVsxXSkpO1xuICAgICAgICAgIGl0ZW1bMl0gJiYgcmVjb2duaXplci5yZWNvZ25pemVXaXRoKGl0ZW1bMl0pO1xuICAgICAgICAgIGl0ZW1bM10gJiYgcmVjb2duaXplci5yZXF1aXJlRmFpbHVyZShpdGVtWzNdKTtcbiAgICAgIH0sIHRoaXMpO1xuICB9XG5cbiAgTWFuYWdlci5wcm90b3R5cGUgPSB7XG4gICAgICAvKipcbiAgICAgICAqIHNldCBvcHRpb25zXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAgICogQHJldHVybnMge01hbmFnZXJ9XG4gICAgICAgKi9cbiAgICAgIHNldDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgIGFzc2lnbih0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgLy8gT3B0aW9ucyB0aGF0IG5lZWQgYSBsaXR0bGUgbW9yZSBzZXR1cFxuICAgICAgICAgIGlmIChvcHRpb25zLnRvdWNoQWN0aW9uKSB7XG4gICAgICAgICAgICAgIHRoaXMudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRpb25zLmlucHV0VGFyZ2V0KSB7XG4gICAgICAgICAgICAgIC8vIENsZWFuIHVwIGV4aXN0aW5nIGV2ZW50IGxpc3RlbmVycyBhbmQgcmVpbml0aWFsaXplXG4gICAgICAgICAgICAgIHRoaXMuaW5wdXQuZGVzdHJveSgpO1xuICAgICAgICAgICAgICB0aGlzLmlucHV0LnRhcmdldCA9IG9wdGlvbnMuaW5wdXRUYXJnZXQ7XG4gICAgICAgICAgICAgIHRoaXMuaW5wdXQuaW5pdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogc3RvcCByZWNvZ25pemluZyBmb3IgdGhpcyBzZXNzaW9uLlxuICAgICAgICogVGhpcyBzZXNzaW9uIHdpbGwgYmUgZGlzY2FyZGVkLCB3aGVuIGEgbmV3IFtpbnB1dF1zdGFydCBldmVudCBpcyBmaXJlZC5cbiAgICAgICAqIFdoZW4gZm9yY2VkLCB0aGUgcmVjb2duaXplciBjeWNsZSBpcyBzdG9wcGVkIGltbWVkaWF0ZWx5LlxuICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2VdXG4gICAgICAgKi9cbiAgICAgIHN0b3A6IGZ1bmN0aW9uKGZvcmNlKSB7XG4gICAgICAgICAgdGhpcy5zZXNzaW9uLnN0b3BwZWQgPSBmb3JjZSA/IEZPUkNFRF9TVE9QIDogU1RPUDtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogcnVuIHRoZSByZWNvZ25pemVycyFcbiAgICAgICAqIGNhbGxlZCBieSB0aGUgaW5wdXRIYW5kbGVyIGZ1bmN0aW9uIG9uIGV2ZXJ5IG1vdmVtZW50IG9mIHRoZSBwb2ludGVycyAodG91Y2hlcylcbiAgICAgICAqIGl0IHdhbGtzIHRocm91Z2ggYWxsIHRoZSByZWNvZ25pemVycyBhbmQgdHJpZXMgdG8gZGV0ZWN0IHRoZSBnZXN0dXJlIHRoYXQgaXMgYmVpbmcgbWFkZVxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAgICovXG4gICAgICByZWNvZ25pemU6IGZ1bmN0aW9uKGlucHV0RGF0YSkge1xuICAgICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xuICAgICAgICAgIGlmIChzZXNzaW9uLnN0b3BwZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHJ1biB0aGUgdG91Y2gtYWN0aW9uIHBvbHlmaWxsXG4gICAgICAgICAgdGhpcy50b3VjaEFjdGlvbi5wcmV2ZW50RGVmYXVsdHMoaW5wdXREYXRhKTtcblxuICAgICAgICAgIHZhciByZWNvZ25pemVyO1xuICAgICAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XG5cbiAgICAgICAgICAvLyB0aGlzIGhvbGRzIHRoZSByZWNvZ25pemVyIHRoYXQgaXMgYmVpbmcgcmVjb2duaXplZC5cbiAgICAgICAgICAvLyBzbyB0aGUgcmVjb2duaXplcidzIHN0YXRlIG5lZWRzIHRvIGJlIEJFR0FOLCBDSEFOR0VELCBFTkRFRCBvciBSRUNPR05JWkVEXG4gICAgICAgICAgLy8gaWYgbm8gcmVjb2duaXplciBpcyBkZXRlY3RpbmcgYSB0aGluZywgaXQgaXMgc2V0IHRvIGBudWxsYFxuICAgICAgICAgIHZhciBjdXJSZWNvZ25pemVyID0gc2Vzc2lvbi5jdXJSZWNvZ25pemVyO1xuXG4gICAgICAgICAgLy8gcmVzZXQgd2hlbiB0aGUgbGFzdCByZWNvZ25pemVyIGlzIHJlY29nbml6ZWRcbiAgICAgICAgICAvLyBvciB3aGVuIHdlJ3JlIGluIGEgbmV3IHNlc3Npb25cbiAgICAgICAgICBpZiAoIWN1clJlY29nbml6ZXIgfHwgKGN1clJlY29nbml6ZXIgJiYgY3VyUmVjb2duaXplci5zdGF0ZSAmIFNUQVRFX1JFQ09HTklaRUQpKSB7XG4gICAgICAgICAgICAgIGN1clJlY29nbml6ZXIgPSBzZXNzaW9uLmN1clJlY29nbml6ZXIgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICB3aGlsZSAoaSA8IHJlY29nbml6ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZWNvZ25pemVyID0gcmVjb2duaXplcnNbaV07XG5cbiAgICAgICAgICAgICAgLy8gZmluZCBvdXQgaWYgd2UgYXJlIGFsbG93ZWQgdHJ5IHRvIHJlY29nbml6ZSB0aGUgaW5wdXQgZm9yIHRoaXMgb25lLlxuICAgICAgICAgICAgICAvLyAxLiAgIGFsbG93IGlmIHRoZSBzZXNzaW9uIGlzIE5PVCBmb3JjZWQgc3RvcHBlZCAoc2VlIHRoZSAuc3RvcCgpIG1ldGhvZClcbiAgICAgICAgICAgICAgLy8gMi4gICBhbGxvdyBpZiB3ZSBzdGlsbCBoYXZlbid0IHJlY29nbml6ZWQgYSBnZXN0dXJlIGluIHRoaXMgc2Vzc2lvbiwgb3IgdGhlIHRoaXMgcmVjb2duaXplciBpcyB0aGUgb25lXG4gICAgICAgICAgICAgIC8vICAgICAgdGhhdCBpcyBiZWluZyByZWNvZ25pemVkLlxuICAgICAgICAgICAgICAvLyAzLiAgIGFsbG93IGlmIHRoZSByZWNvZ25pemVyIGlzIGFsbG93ZWQgdG8gcnVuIHNpbXVsdGFuZW91cyB3aXRoIHRoZSBjdXJyZW50IHJlY29nbml6ZWQgcmVjb2duaXplci5cbiAgICAgICAgICAgICAgLy8gICAgICB0aGlzIGNhbiBiZSBzZXR1cCB3aXRoIHRoZSBgcmVjb2duaXplV2l0aCgpYCBtZXRob2Qgb24gdGhlIHJlY29nbml6ZXIuXG4gICAgICAgICAgICAgIGlmIChzZXNzaW9uLnN0b3BwZWQgIT09IEZPUkNFRF9TVE9QICYmICggLy8gMVxuICAgICAgICAgICAgICAgICAgICAgICFjdXJSZWNvZ25pemVyIHx8IHJlY29nbml6ZXIgPT0gY3VyUmVjb2duaXplciB8fCAvLyAyXG4gICAgICAgICAgICAgICAgICAgICAgcmVjb2duaXplci5jYW5SZWNvZ25pemVXaXRoKGN1clJlY29nbml6ZXIpKSkgeyAvLyAzXG4gICAgICAgICAgICAgICAgICByZWNvZ25pemVyLnJlY29nbml6ZShpbnB1dERhdGEpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmVjb2duaXplci5yZXNldCgpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gaWYgdGhlIHJlY29nbml6ZXIgaGFzIGJlZW4gcmVjb2duaXppbmcgdGhlIGlucHV0IGFzIGEgdmFsaWQgZ2VzdHVyZSwgd2Ugd2FudCB0byBzdG9yZSB0aGlzIG9uZSBhcyB0aGVcbiAgICAgICAgICAgICAgLy8gY3VycmVudCBhY3RpdmUgcmVjb2duaXplci4gYnV0IG9ubHkgaWYgd2UgZG9uJ3QgYWxyZWFkeSBoYXZlIGFuIGFjdGl2ZSByZWNvZ25pemVyXG4gICAgICAgICAgICAgIGlmICghY3VyUmVjb2duaXplciAmJiByZWNvZ25pemVyLnN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCB8IFNUQVRFX0VOREVEKSkge1xuICAgICAgICAgICAgICAgICAgY3VyUmVjb2duaXplciA9IHNlc3Npb24uY3VyUmVjb2duaXplciA9IHJlY29nbml6ZXI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogZ2V0IGEgcmVjb2duaXplciBieSBpdHMgZXZlbnQgbmFtZS5cbiAgICAgICAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IHJlY29nbml6ZXJcbiAgICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfE51bGx9XG4gICAgICAgKi9cbiAgICAgIGdldDogZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgICAgICAgIGlmIChyZWNvZ25pemVyIGluc3RhbmNlb2YgUmVjb2duaXplcikge1xuICAgICAgICAgICAgICByZXR1cm4gcmVjb2duaXplcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjb2duaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKHJlY29nbml6ZXJzW2ldLm9wdGlvbnMuZXZlbnQgPT0gcmVjb2duaXplcikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlY29nbml6ZXJzW2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBhZGQgYSByZWNvZ25pemVyIHRvIHRoZSBtYW5hZ2VyXG4gICAgICAgKiBleGlzdGluZyByZWNvZ25pemVycyB3aXRoIHRoZSBzYW1lIGV2ZW50IG5hbWUgd2lsbCBiZSByZW1vdmVkXG4gICAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IHJlY29nbml6ZXJcbiAgICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfE1hbmFnZXJ9XG4gICAgICAgKi9cbiAgICAgIGFkZDogZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhyZWNvZ25pemVyLCAnYWRkJywgdGhpcykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gcmVtb3ZlIGV4aXN0aW5nXG4gICAgICAgICAgdmFyIGV4aXN0aW5nID0gdGhpcy5nZXQocmVjb2duaXplci5vcHRpb25zLmV2ZW50KTtcbiAgICAgICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgICAgICAgdGhpcy5yZW1vdmUoZXhpc3RpbmcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMucmVjb2duaXplcnMucHVzaChyZWNvZ25pemVyKTtcbiAgICAgICAgICByZWNvZ25pemVyLm1hbmFnZXIgPSB0aGlzO1xuXG4gICAgICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgICAgICByZXR1cm4gcmVjb2duaXplcjtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogcmVtb3ZlIGEgcmVjb2duaXplciBieSBuYW1lIG9yIGluc3RhbmNlXG4gICAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSByZWNvZ25pemVyXG4gICAgICAgKiBAcmV0dXJucyB7TWFuYWdlcn1cbiAgICAgICAqL1xuICAgICAgcmVtb3ZlOiBmdW5jdGlvbihyZWNvZ25pemVyKSB7XG4gICAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsICdyZW1vdmUnLCB0aGlzKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZWNvZ25pemVyID0gdGhpcy5nZXQocmVjb2duaXplcik7XG5cbiAgICAgICAgICAvLyBsZXQncyBtYWtlIHN1cmUgdGhpcyByZWNvZ25pemVyIGV4aXN0c1xuICAgICAgICAgIGlmIChyZWNvZ25pemVyKSB7XG4gICAgICAgICAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XG4gICAgICAgICAgICAgIHZhciBpbmRleCA9IGluQXJyYXkocmVjb2duaXplcnMsIHJlY29nbml6ZXIpO1xuXG4gICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIHJlY29nbml6ZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIGJpbmQgZXZlbnRcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudHNcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICAgICAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IHRoaXNcbiAgICAgICAqL1xuICAgICAgb246IGZ1bmN0aW9uKGV2ZW50cywgaGFuZGxlcikge1xuICAgICAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnM7XG4gICAgICAgICAgZWFjaChzcGxpdFN0cihldmVudHMpLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICBoYW5kbGVyc1tldmVudF0gPSBoYW5kbGVyc1tldmVudF0gfHwgW107XG4gICAgICAgICAgICAgIGhhbmRsZXJzW2V2ZW50XS5wdXNoKGhhbmRsZXIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiB1bmJpbmQgZXZlbnQsIGxlYXZlIGVtaXQgYmxhbmsgdG8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50c1xuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hhbmRsZXJdXG4gICAgICAgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSB0aGlzXG4gICAgICAgKi9cbiAgICAgIG9mZjogZnVuY3Rpb24oZXZlbnRzLCBoYW5kbGVyKSB7XG4gICAgICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVycztcbiAgICAgICAgICBlYWNoKHNwbGl0U3RyKGV2ZW50cyksIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIGhhbmRsZXJzW2V2ZW50XTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGhhbmRsZXJzW2V2ZW50XSAmJiBoYW5kbGVyc1tldmVudF0uc3BsaWNlKGluQXJyYXkoaGFuZGxlcnNbZXZlbnRdLCBoYW5kbGVyKSwgMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogZW1pdCBldmVudCB0byB0aGUgbGlzdGVuZXJzXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICAgKi9cbiAgICAgIGVtaXQ6IGZ1bmN0aW9uKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgICAgLy8gd2UgYWxzbyB3YW50IHRvIHRyaWdnZXIgZG9tIGV2ZW50c1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZG9tRXZlbnRzKSB7XG4gICAgICAgICAgICAgIHRyaWdnZXJEb21FdmVudChldmVudCwgZGF0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gbm8gaGFuZGxlcnMsIHNvIHNraXAgaXQgYWxsXG4gICAgICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVyc1tldmVudF0gJiYgdGhpcy5oYW5kbGVyc1tldmVudF0uc2xpY2UoKTtcbiAgICAgICAgICBpZiAoIWhhbmRsZXJzIHx8ICFoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRhdGEudHlwZSA9IGV2ZW50O1xuICAgICAgICAgIGRhdGEucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgZGF0YS5zcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgd2hpbGUgKGkgPCBoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgaGFuZGxlcnNbaV0oZGF0YSk7XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIGRlc3Ryb3kgdGhlIG1hbmFnZXIgYW5kIHVuYmluZHMgYWxsIGV2ZW50c1xuICAgICAgICogaXQgZG9lc24ndCB1bmJpbmQgZG9tIGV2ZW50cywgdGhhdCBpcyB0aGUgdXNlciBvd24gcmVzcG9uc2liaWxpdHlcbiAgICAgICAqL1xuICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5lbGVtZW50ICYmIHRvZ2dsZUNzc1Byb3BzKHRoaXMsIGZhbHNlKTtcblxuICAgICAgICAgIHRoaXMuaGFuZGxlcnMgPSB7fTtcbiAgICAgICAgICB0aGlzLnNlc3Npb24gPSB7fTtcbiAgICAgICAgICB0aGlzLmlucHV0LmRlc3Ryb3koKTtcbiAgICAgICAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBhZGQvcmVtb3ZlIHRoZSBjc3MgcHJvcGVydGllcyBhcyBkZWZpbmVkIGluIG1hbmFnZXIub3B0aW9ucy5jc3NQcm9wc1xuICAgKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAgICogQHBhcmFtIHtCb29sZWFufSBhZGRcbiAgICovXG4gIGZ1bmN0aW9uIHRvZ2dsZUNzc1Byb3BzKG1hbmFnZXIsIGFkZCkge1xuICAgICAgdmFyIGVsZW1lbnQgPSBtYW5hZ2VyLmVsZW1lbnQ7XG4gICAgICBpZiAoIWVsZW1lbnQuc3R5bGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlYWNoKG1hbmFnZXIub3B0aW9ucy5jc3NQcm9wcywgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgICBlbGVtZW50LnN0eWxlW3ByZWZpeGVkKGVsZW1lbnQuc3R5bGUsIG5hbWUpXSA9IGFkZCA/IHZhbHVlIDogJyc7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiB0cmlnZ2VyIGRvbSBldmVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICovXG4gIGZ1bmN0aW9uIHRyaWdnZXJEb21FdmVudChldmVudCwgZGF0YSkge1xuICAgICAgdmFyIGdlc3R1cmVFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgZ2VzdHVyZUV2ZW50LmluaXRFdmVudChldmVudCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICBnZXN0dXJlRXZlbnQuZ2VzdHVyZSA9IGRhdGE7XG4gICAgICBkYXRhLnRhcmdldC5kaXNwYXRjaEV2ZW50KGdlc3R1cmVFdmVudCk7XG4gIH1cblxuICBhc3NpZ24oSGFtbWVyLCB7XG4gICAgICBJTlBVVF9TVEFSVDogSU5QVVRfU1RBUlQsXG4gICAgICBJTlBVVF9NT1ZFOiBJTlBVVF9NT1ZFLFxuICAgICAgSU5QVVRfRU5EOiBJTlBVVF9FTkQsXG4gICAgICBJTlBVVF9DQU5DRUw6IElOUFVUX0NBTkNFTCxcblxuICAgICAgU1RBVEVfUE9TU0lCTEU6IFNUQVRFX1BPU1NJQkxFLFxuICAgICAgU1RBVEVfQkVHQU46IFNUQVRFX0JFR0FOLFxuICAgICAgU1RBVEVfQ0hBTkdFRDogU1RBVEVfQ0hBTkdFRCxcbiAgICAgIFNUQVRFX0VOREVEOiBTVEFURV9FTkRFRCxcbiAgICAgIFNUQVRFX1JFQ09HTklaRUQ6IFNUQVRFX1JFQ09HTklaRUQsXG4gICAgICBTVEFURV9DQU5DRUxMRUQ6IFNUQVRFX0NBTkNFTExFRCxcbiAgICAgIFNUQVRFX0ZBSUxFRDogU1RBVEVfRkFJTEVELFxuXG4gICAgICBESVJFQ1RJT05fTk9ORTogRElSRUNUSU9OX05PTkUsXG4gICAgICBESVJFQ1RJT05fTEVGVDogRElSRUNUSU9OX0xFRlQsXG4gICAgICBESVJFQ1RJT05fUklHSFQ6IERJUkVDVElPTl9SSUdIVCxcbiAgICAgIERJUkVDVElPTl9VUDogRElSRUNUSU9OX1VQLFxuICAgICAgRElSRUNUSU9OX0RPV046IERJUkVDVElPTl9ET1dOLFxuICAgICAgRElSRUNUSU9OX0hPUklaT05UQUw6IERJUkVDVElPTl9IT1JJWk9OVEFMLFxuICAgICAgRElSRUNUSU9OX1ZFUlRJQ0FMOiBESVJFQ1RJT05fVkVSVElDQUwsXG4gICAgICBESVJFQ1RJT05fQUxMOiBESVJFQ1RJT05fQUxMLFxuXG4gICAgICBNYW5hZ2VyOiBNYW5hZ2VyLFxuICAgICAgSW5wdXQ6IElucHV0LFxuICAgICAgVG91Y2hBY3Rpb246IFRvdWNoQWN0aW9uLFxuXG4gICAgICBUb3VjaElucHV0OiBUb3VjaElucHV0LFxuICAgICAgTW91c2VJbnB1dDogTW91c2VJbnB1dCxcbiAgICAgIFBvaW50ZXJFdmVudElucHV0OiBQb2ludGVyRXZlbnRJbnB1dCxcbiAgICAgIFRvdWNoTW91c2VJbnB1dDogVG91Y2hNb3VzZUlucHV0LFxuICAgICAgU2luZ2xlVG91Y2hJbnB1dDogU2luZ2xlVG91Y2hJbnB1dCxcblxuICAgICAgUmVjb2duaXplcjogUmVjb2duaXplcixcbiAgICAgIEF0dHJSZWNvZ25pemVyOiBBdHRyUmVjb2duaXplcixcbiAgICAgIFRhcDogVGFwUmVjb2duaXplcixcbiAgICAgIFBhbjogUGFuUmVjb2duaXplcixcbiAgICAgIFN3aXBlOiBTd2lwZVJlY29nbml6ZXIsXG4gICAgICBQaW5jaDogUGluY2hSZWNvZ25pemVyLFxuICAgICAgUm90YXRlOiBSb3RhdGVSZWNvZ25pemVyLFxuICAgICAgUHJlc3M6IFByZXNzUmVjb2duaXplcixcblxuICAgICAgb246IGFkZEV2ZW50TGlzdGVuZXJzLFxuICAgICAgb2ZmOiByZW1vdmVFdmVudExpc3RlbmVycyxcbiAgICAgIGVhY2g6IGVhY2gsXG4gICAgICBtZXJnZTogbWVyZ2UsXG4gICAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICAgIGFzc2lnbjogYXNzaWduLFxuICAgICAgaW5oZXJpdDogaW5oZXJpdCxcbiAgICAgIGJpbmRGbjogYmluZEZuLFxuICAgICAgcHJlZml4ZWQ6IHByZWZpeGVkXG4gIH0pO1xuXG4gIC8vIHRoaXMgcHJldmVudHMgZXJyb3JzIHdoZW4gSGFtbWVyIGlzIGxvYWRlZCBpbiB0aGUgcHJlc2VuY2Ugb2YgYW4gQU1EXG4gIC8vICBzdHlsZSBsb2FkZXIgYnV0IGJ5IHNjcmlwdCB0YWcsIG5vdCBieSB0aGUgbG9hZGVyLlxuICB2YXIgZnJlZUdsb2JhbCA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6ICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge30pKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gIGZyZWVHbG9iYWwuSGFtbWVyID0gSGFtbWVyO1xuXG4gIGlmICh0cnVlKSB7XG4gICAgICAhKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIEhhbW1lcjtcbiAgICAgIH0uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBIYW1tZXI7XG4gIH0gZWxzZSB7XG4gICAgICB3aW5kb3dbZXhwb3J0TmFtZV0gPSBIYW1tZXI7XG4gIH1cblxuICB9KSh3aW5kb3csIGRvY3VtZW50LCAnSGFtbWVyJyk7XG5cblxuLyoqKi8gfSxcbi8qIDIzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICB2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXztcInVzZSBzdHJpY3RcIjtcbiAgLyoqXG4gICAqIENyZWF0ZWQgYnkgQWxleCBvbiAxMS82LzIwMTQuXG4gICAqL1xuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS91bWRqcy91bWQvYmxvYi9tYXN0ZXIvcmV0dXJuRXhwb3J0cy5qcyNMNDAtTDYwXG4gIC8vIGlmIHRoZSBtb2R1bGUgaGFzIG5vIGRlcGVuZGVuY2llcywgdGhlIGFib3ZlIHBhdHRlcm4gY2FuIGJlIHNpbXBsaWZpZWQgdG9cbiAgKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gICAgaWYgKHRydWUpIHtcbiAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICAgICEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtdLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPSAoZmFjdG9yeSksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKHR5cGVvZiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPT09ICdmdW5jdGlvbicgPyAoX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pKSA6IF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgLy8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XG4gICAgICAvLyBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cyxcbiAgICAgIC8vIGxpa2UgTm9kZS5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCcm93c2VyIGdsb2JhbHMgKHJvb3QgaXMgd2luZG93KVxuICAgICAgcm9vdC5rZXljaGFybSA9IGZhY3RvcnkoKTtcbiAgICB9XG4gIH0odGhpcywgZnVuY3Rpb24gKCkge1xuXG4gICAgZnVuY3Rpb24ga2V5Y2hhcm0ob3B0aW9ucykge1xuICAgICAgdmFyIHByZXZlbnREZWZhdWx0ID0gb3B0aW9ucyAmJiBvcHRpb25zLnByZXZlbnREZWZhdWx0IHx8IGZhbHNlO1xuXG4gICAgICB2YXIgY29udGFpbmVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvbnRhaW5lciB8fCB3aW5kb3c7XG5cbiAgICAgIHZhciBfZXhwb3J0RnVuY3Rpb25zID0ge307XG4gICAgICB2YXIgX2JvdW5kID0ge2tleWRvd246e30sIGtleXVwOnt9fTtcbiAgICAgIHZhciBfa2V5cyA9IHt9O1xuICAgICAgdmFyIGk7XG5cbiAgICAgIC8vIGEgLSB6XG4gICAgICBmb3IgKGkgPSA5NzsgaSA8PSAxMjI7IGkrKykge19rZXlzW1N0cmluZy5mcm9tQ2hhckNvZGUoaSldID0ge2NvZGU6NjUgKyAoaSAtIDk3KSwgc2hpZnQ6IGZhbHNlfTt9XG4gICAgICAvLyBBIC0gWlxuICAgICAgZm9yIChpID0gNjU7IGkgPD0gOTA7IGkrKykge19rZXlzW1N0cmluZy5mcm9tQ2hhckNvZGUoaSldID0ge2NvZGU6aSwgc2hpZnQ6IHRydWV9O31cbiAgICAgIC8vIDAgLSA5XG4gICAgICBmb3IgKGkgPSAwOyAgaSA8PSA5OyAgIGkrKykge19rZXlzWycnICsgaV0gPSB7Y29kZTo0OCArIGksIHNoaWZ0OiBmYWxzZX07fVxuICAgICAgLy8gRjEgLSBGMTJcbiAgICAgIGZvciAoaSA9IDE7ICBpIDw9IDEyOyAgIGkrKykge19rZXlzWydGJyArIGldID0ge2NvZGU6MTExICsgaSwgc2hpZnQ6IGZhbHNlfTt9XG4gICAgICAvLyBudW0wIC0gbnVtOVxuICAgICAgZm9yIChpID0gMDsgIGkgPD0gOTsgICBpKyspIHtfa2V5c1snbnVtJyArIGldID0ge2NvZGU6OTYgKyBpLCBzaGlmdDogZmFsc2V9O31cblxuICAgICAgLy8gbnVtcGFkIG1pc2NcbiAgICAgIF9rZXlzWydudW0qJ10gPSB7Y29kZToxMDYsIHNoaWZ0OiBmYWxzZX07XG4gICAgICBfa2V5c1snbnVtKyddID0ge2NvZGU6MTA3LCBzaGlmdDogZmFsc2V9O1xuICAgICAgX2tleXNbJ251bS0nXSA9IHtjb2RlOjEwOSwgc2hpZnQ6IGZhbHNlfTtcbiAgICAgIF9rZXlzWydudW0vJ10gPSB7Y29kZToxMTEsIHNoaWZ0OiBmYWxzZX07XG4gICAgICBfa2V5c1snbnVtLiddID0ge2NvZGU6MTEwLCBzaGlmdDogZmFsc2V9O1xuICAgICAgLy8gYXJyb3dzXG4gICAgICBfa2V5c1snbGVmdCddICA9IHtjb2RlOjM3LCBzaGlmdDogZmFsc2V9O1xuICAgICAgX2tleXNbJ3VwJ10gICAgPSB7Y29kZTozOCwgc2hpZnQ6IGZhbHNlfTtcbiAgICAgIF9rZXlzWydyaWdodCddID0ge2NvZGU6MzksIHNoaWZ0OiBmYWxzZX07XG4gICAgICBfa2V5c1snZG93biddICA9IHtjb2RlOjQwLCBzaGlmdDogZmFsc2V9O1xuICAgICAgLy8gZXh0cmEga2V5c1xuICAgICAgX2tleXNbJ3NwYWNlJ10gPSB7Y29kZTozMiwgc2hpZnQ6IGZhbHNlfTtcbiAgICAgIF9rZXlzWydlbnRlciddID0ge2NvZGU6MTMsIHNoaWZ0OiBmYWxzZX07XG4gICAgICBfa2V5c1snc2hpZnQnXSA9IHtjb2RlOjE2LCBzaGlmdDogdW5kZWZpbmVkfTtcbiAgICAgIF9rZXlzWydlc2MnXSAgID0ge2NvZGU6MjcsIHNoaWZ0OiBmYWxzZX07XG4gICAgICBfa2V5c1snYmFja3NwYWNlJ10gPSB7Y29kZTo4LCBzaGlmdDogZmFsc2V9O1xuICAgICAgX2tleXNbJ3RhYiddICAgICAgID0ge2NvZGU6OSwgc2hpZnQ6IGZhbHNlfTtcbiAgICAgIF9rZXlzWydjdHJsJ10gICAgICA9IHtjb2RlOjE3LCBzaGlmdDogZmFsc2V9O1xuICAgICAgX2tleXNbJ2FsdCddICAgICAgID0ge2NvZGU6MTgsIHNoaWZ0OiBmYWxzZX07XG4gICAgICBfa2V5c1snZGVsZXRlJ10gICAgPSB7Y29kZTo0Niwgc2hpZnQ6IGZhbHNlfTtcbiAgICAgIF9rZXlzWydwYWdldXAnXSAgICA9IHtjb2RlOjMzLCBzaGlmdDogZmFsc2V9O1xuICAgICAgX2tleXNbJ3BhZ2Vkb3duJ10gID0ge2NvZGU6MzQsIHNoaWZ0OiBmYWxzZX07XG4gICAgICAvLyBzeW1ib2xzXG4gICAgICBfa2V5c1snPSddICAgICA9IHtjb2RlOjE4Nywgc2hpZnQ6IGZhbHNlfTtcbiAgICAgIF9rZXlzWyctJ10gICAgID0ge2NvZGU6MTg5LCBzaGlmdDogZmFsc2V9O1xuICAgICAgX2tleXNbJ10nXSAgICAgPSB7Y29kZToyMjEsIHNoaWZ0OiBmYWxzZX07XG4gICAgICBfa2V5c1snWyddICAgICA9IHtjb2RlOjIxOSwgc2hpZnQ6IGZhbHNlfTtcblxuXG5cbiAgICAgIHZhciBkb3duID0gZnVuY3Rpb24oZXZlbnQpIHtoYW5kbGVFdmVudChldmVudCwna2V5ZG93bicpO307XG4gICAgICB2YXIgdXAgPSBmdW5jdGlvbihldmVudCkge2hhbmRsZUV2ZW50KGV2ZW50LCdrZXl1cCcpO307XG5cbiAgICAgIC8vIGhhbmRsZSB0aGUgYWN0dWFseSBib3VuZCBrZXkgd2l0aCB0aGUgZXZlbnRcbiAgICAgIHZhciBoYW5kbGVFdmVudCA9IGZ1bmN0aW9uKGV2ZW50LHR5cGUpIHtcbiAgICAgICAgaWYgKF9ib3VuZFt0eXBlXVtldmVudC5rZXlDb2RlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIGJvdW5kID0gX2JvdW5kW3R5cGVdW2V2ZW50LmtleUNvZGVdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChib3VuZFtpXS5zaGlmdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGJvdW5kW2ldLmZuKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJvdW5kW2ldLnNoaWZ0ID09IHRydWUgJiYgZXZlbnQuc2hpZnRLZXkgPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICBib3VuZFtpXS5mbihldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChib3VuZFtpXS5zaGlmdCA9PSBmYWxzZSAmJiBldmVudC5zaGlmdEtleSA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICBib3VuZFtpXS5mbihldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHByZXZlbnREZWZhdWx0ID09IHRydWUpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBiaW5kIGEga2V5IHRvIGEgY2FsbGJhY2tcbiAgICAgIF9leHBvcnRGdW5jdGlvbnMuYmluZCA9IGZ1bmN0aW9uKGtleSwgY2FsbGJhY2ssIHR5cGUpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHR5cGUgPSAna2V5ZG93bic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9rZXlzW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGtleTogXCIgKyBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfYm91bmRbdHlwZV1bX2tleXNba2V5XS5jb2RlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgX2JvdW5kW3R5cGVdW19rZXlzW2tleV0uY29kZV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBfYm91bmRbdHlwZV1bX2tleXNba2V5XS5jb2RlXS5wdXNoKHtmbjpjYWxsYmFjaywgc2hpZnQ6X2tleXNba2V5XS5zaGlmdH0pO1xuICAgICAgfTtcblxuXG4gICAgICAvLyBiaW5kIGFsbCBrZXlzIHRvIGEgY2FsbCBiYWNrIChkZW1vIHB1cnBvc2VzKVxuICAgICAgX2V4cG9ydEZ1bmN0aW9ucy5iaW5kQWxsID0gZnVuY3Rpb24oY2FsbGJhY2ssIHR5cGUpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHR5cGUgPSAna2V5ZG93bic7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIga2V5IGluIF9rZXlzKSB7XG4gICAgICAgICAgaWYgKF9rZXlzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIF9leHBvcnRGdW5jdGlvbnMuYmluZChrZXksY2FsbGJhY2ssdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBnZXQgdGhlIGtleSBsYWJlbCBmcm9tIGFuIGV2ZW50XG4gICAgICBfZXhwb3J0RnVuY3Rpb25zLmdldEtleSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBfa2V5cykge1xuICAgICAgICAgIGlmIChfa2V5cy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc2hpZnRLZXkgPT0gdHJ1ZSAmJiBfa2V5c1trZXldLnNoaWZ0ID09IHRydWUgJiYgZXZlbnQua2V5Q29kZSA9PSBfa2V5c1trZXldLmNvZGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LnNoaWZ0S2V5ID09IGZhbHNlICYmIF9rZXlzW2tleV0uc2hpZnQgPT0gZmFsc2UgJiYgZXZlbnQua2V5Q29kZSA9PSBfa2V5c1trZXldLmNvZGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gX2tleXNba2V5XS5jb2RlICYmIGtleSA9PSAnc2hpZnQnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcInVua25vd24ga2V5LCBjdXJyZW50bHkgbm90IHN1cHBvcnRlZFwiO1xuICAgICAgfTtcblxuICAgICAgLy8gdW5iaW5kIGVpdGhlciBhIHNwZWNpZmljIGNhbGxiYWNrIGZyb20gYSBrZXkgb3IgYWxsIG9mIHRoZW0gKGJ5IGxlYXZpbmcgY2FsbGJhY2sgdW5kZWZpbmVkKVxuICAgICAgX2V4cG9ydEZ1bmN0aW9ucy51bmJpbmQgPSBmdW5jdGlvbihrZXksIGNhbGxiYWNrLCB0eXBlKSB7XG4gICAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0eXBlID0gJ2tleWRvd24nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfa2V5c1trZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBrZXk6IFwiICsga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FsbGJhY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBuZXdCaW5kaW5ncyA9IFtdO1xuICAgICAgICAgIHZhciBib3VuZCA9IF9ib3VuZFt0eXBlXVtfa2V5c1trZXldLmNvZGVdO1xuICAgICAgICAgIGlmIChib3VuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmICghKGJvdW5kW2ldLmZuID09IGNhbGxiYWNrICYmIGJvdW5kW2ldLnNoaWZ0ID09IF9rZXlzW2tleV0uc2hpZnQpKSB7XG4gICAgICAgICAgICAgICAgbmV3QmluZGluZ3MucHVzaChfYm91bmRbdHlwZV1bX2tleXNba2V5XS5jb2RlXVtpXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgX2JvdW5kW3R5cGVdW19rZXlzW2tleV0uY29kZV0gPSBuZXdCaW5kaW5ncztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBfYm91bmRbdHlwZV1bX2tleXNba2V5XS5jb2RlXSA9IFtdO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyByZXNldCBhbGwgYm91bmQgdmFyaWFibGVzLlxuICAgICAgX2V4cG9ydEZ1bmN0aW9ucy5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBfYm91bmQgPSB7a2V5ZG93bjp7fSwga2V5dXA6e319O1xuICAgICAgfTtcblxuICAgICAgLy8gdW5iaW5kIGFsbCBsaXN0ZW5lcnMgYW5kIHJlc2V0IGFsbCB2YXJpYWJsZXMuXG4gICAgICBfZXhwb3J0RnVuY3Rpb25zLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgX2JvdW5kID0ge2tleWRvd246e30sIGtleXVwOnt9fTtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBkb3duLCB0cnVlKTtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdXAsIHRydWUpO1xuICAgICAgfTtcblxuICAgICAgLy8gY3JlYXRlIGxpc3RlbmVycy5cbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJyxkb3duLHRydWUpO1xuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJyx1cCx0cnVlKTtcblxuICAgICAgLy8gcmV0dXJuIHRoZSBwdWJsaWMgZnVuY3Rpb25zLlxuICAgICAgcmV0dXJuIF9leHBvcnRGdW5jdGlvbnM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleWNoYXJtO1xuICB9KSk7XG5cblxuXG5cbi8qKiovIH0sXG4vKiAyNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIHV0aWxzXG4gIGV4cG9ydHMudXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4gIGV4cG9ydHMuRE9NdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cbiAgLy8gZGF0YVxuICBleHBvcnRzLkRhdGFTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuICBleHBvcnRzLkRhdGFWaWV3ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG4gIGV4cG9ydHMuUXVldWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblxuICAvLyBUaW1lbGluZVxuICBleHBvcnRzLlRpbWVsaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XG4gIGV4cG9ydHMuR3JhcGgyZCA9IF9fd2VicGFja19yZXF1aXJlX18oNTApO1xuICBleHBvcnRzLnRpbWVsaW5lID0ge1xuICAgIENvcmU6IF9fd2VicGFja19yZXF1aXJlX18oMzMpLFxuICAgIERhdGVVdGlsOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKSxcbiAgICBSYW5nZTogX193ZWJwYWNrX3JlcXVpcmVfXygzMCksXG4gICAgc3RhY2s6IF9fd2VicGFja19yZXF1aXJlX18oMzcpLFxuICAgIFRpbWVTdGVwOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KSxcblxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgIGl0ZW1zOiB7XG4gICAgICAgIEl0ZW06IF9fd2VicGFja19yZXF1aXJlX18oMzkpLFxuICAgICAgICBCYWNrZ3JvdW5kSXRlbTogX193ZWJwYWNrX3JlcXVpcmVfXyg0MyksXG4gICAgICAgIEJveEl0ZW06IF9fd2VicGFja19yZXF1aXJlX18oNDEpLFxuICAgICAgICBQb2ludEl0ZW06IF9fd2VicGFja19yZXF1aXJlX18oNDIpLFxuICAgICAgICBSYW5nZUl0ZW06IF9fd2VicGFja19yZXF1aXJlX18oMzgpXG4gICAgICB9LFxuXG4gICAgICBCYWNrZ3JvdW5kR3JvdXA6IF9fd2VicGFja19yZXF1aXJlX18oNDApLFxuICAgICAgQ29tcG9uZW50OiBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKSxcbiAgICAgIEN1cnJlbnRUaW1lOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ4KSxcbiAgICAgIEN1c3RvbVRpbWU6IF9fd2VicGFja19yZXF1aXJlX18oNDYpLFxuICAgICAgRGF0YUF4aXM6IF9fd2VicGFja19yZXF1aXJlX18oNTIpLFxuICAgICAgRGF0YVNjYWxlOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDUzKSxcbiAgICAgIEdyYXBoR3JvdXA6IF9fd2VicGFja19yZXF1aXJlX18oNTQpLFxuICAgICAgR3JvdXA6IF9fd2VicGFja19yZXF1aXJlX18oMzYpLFxuICAgICAgSXRlbVNldDogX193ZWJwYWNrX3JlcXVpcmVfXygzNCksXG4gICAgICBMZWdlbmQ6IF9fd2VicGFja19yZXF1aXJlX18oNTgpLFxuICAgICAgTGluZUdyYXBoOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxKSxcbiAgICAgIFRpbWVBeGlzOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KVxuICAgIH1cbiAgfTtcblxuICAvLyBidW5kbGVkIGV4dGVybmFsIGxpYnJhcmllc1xuICBleHBvcnRzLm1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4gIGV4cG9ydHMuSGFtbWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG4gIGV4cG9ydHMua2V5Y2hhcm0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcblxuLyoqKi8gfSxcbi8qIDI1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIF9Db25maWd1cmF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcblxuICB2YXIgX0NvbmZpZ3VyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Db25maWd1cmF0b3IpO1xuXG4gIHZhciBfVmFsaWRhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSk7XG5cbiAgdmFyIF9WYWxpZGF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVmFsaWRhdG9yKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIHZhciBFbWl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG4gIHZhciBIYW1tZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcbiAgdmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbiAgdmFyIERhdGFTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuICB2YXIgRGF0YVZpZXcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcbiAgdmFyIFJhbmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMCk7XG4gIHZhciBDb3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG4gIHZhciBUaW1lQXhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oNDQpO1xuICB2YXIgQ3VycmVudFRpbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ4KTtcbiAgdmFyIEN1c3RvbVRpbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2KTtcbiAgdmFyIEl0ZW1TZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KTtcblxuICB2YXIgcHJpbnRTdHlsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpLnByaW50U3R5bGU7XG4gIHZhciBhbGxPcHRpb25zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OSkuYWxsT3B0aW9ucztcbiAgdmFyIGNvbmZpZ3VyZU9wdGlvbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5KS5jb25maWd1cmVPcHRpb25zO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSB0aW1lbGluZSB2aXN1YWxpemF0aW9uXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lclxuICAgKiBAcGFyYW0ge3Zpcy5EYXRhU2V0IHwgdmlzLkRhdGFWaWV3IHwgQXJyYXl9IFtpdGVtc11cbiAgICogQHBhcmFtIHt2aXMuRGF0YVNldCB8IHZpcy5EYXRhVmlldyB8IEFycmF5fSBbZ3JvdXBzXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICBTZWUgVGltZWxpbmUuc2V0T3B0aW9ucyBmb3IgdGhlIGF2YWlsYWJsZSBvcHRpb25zLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMgQ29yZVxuICAgKi9cbiAgZnVuY3Rpb24gVGltZWxpbmUoY29udGFpbmVyLCBpdGVtcywgZ3JvdXBzLCBvcHRpb25zKSB7XG5cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVGltZWxpbmUpKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0NvbnN0cnVjdG9yIG11c3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBvcGVyYXRvcicpO1xuICAgIH1cblxuICAgIC8vIGlmIHRoZSB0aGlyZCBlbGVtZW50IGlzIG9wdGlvbnMsIHRoZSBmb3J0aCBpcyBncm91cHMgKG9wdGlvbmFsbHkpO1xuICAgIGlmICghKEFycmF5LmlzQXJyYXkoZ3JvdXBzKSB8fCBncm91cHMgaW5zdGFuY2VvZiBEYXRhU2V0IHx8IGdyb3VwcyBpbnN0YW5jZW9mIERhdGFWaWV3KSAmJiBncm91cHMgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgIHZhciBmb3J0aEFyZ3VtZW50ID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSBncm91cHM7XG4gICAgICBncm91cHMgPSBmb3J0aEFyZ3VtZW50O1xuICAgIH1cblxuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIHN0YXJ0OiBudWxsLFxuICAgICAgZW5kOiBudWxsLFxuXG4gICAgICBhdXRvUmVzaXplOiB0cnVlLFxuICAgICAgdGhyb3R0bGVSZWRyYXc6IDAsIC8vIG1zXG5cbiAgICAgIG9yaWVudGF0aW9uOiB7XG4gICAgICAgIGF4aXM6ICdib3R0b20nLCAvLyBheGlzIG9yaWVudGF0aW9uOiAnYm90dG9tJywgJ3RvcCcsIG9yICdib3RoJ1xuICAgICAgICBpdGVtOiAnYm90dG9tJyAvLyBub3QgcmVsZXZhbnRcbiAgICAgIH0sXG4gICAgICBydGw6IGZhbHNlLFxuICAgICAgbW9tZW50OiBtb21lbnQsXG5cbiAgICAgIHdpZHRoOiBudWxsLFxuICAgICAgaGVpZ2h0OiBudWxsLFxuICAgICAgbWF4SGVpZ2h0OiBudWxsLFxuICAgICAgbWluSGVpZ2h0OiBudWxsXG4gICAgfTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1dGlsLmRlZXBFeHRlbmQoe30sIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSBET00sIHByb3BzLCBhbmQgZW1pdHRlclxuICAgIHRoaXMuX2NyZWF0ZShjb250YWluZXIpO1xuXG4gICAgLy8gYWxsIGNvbXBvbmVudHMgbGlzdGVkIGhlcmUgd2lsbCBiZSByZXBhaW50ZWQgYXV0b21hdGljYWxseVxuICAgIHRoaXMuY29tcG9uZW50cyA9IFtdO1xuXG4gICAgdGhpcy5ib2R5ID0ge1xuICAgICAgZG9tOiB0aGlzLmRvbSxcbiAgICAgIGRvbVByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgZW1pdHRlcjoge1xuICAgICAgICBvbjogdGhpcy5vbi5iaW5kKHRoaXMpLFxuICAgICAgICBvZmY6IHRoaXMub2ZmLmJpbmQodGhpcyksXG4gICAgICAgIGVtaXQ6IHRoaXMuZW1pdC5iaW5kKHRoaXMpXG4gICAgICB9LFxuICAgICAgaGlkZGVuRGF0ZXM6IFtdLFxuICAgICAgdXRpbDoge1xuICAgICAgICBnZXRTY2FsZTogZnVuY3Rpb24gZ2V0U2NhbGUoKSB7XG4gICAgICAgICAgcmV0dXJuIG1lLnRpbWVBeGlzLnN0ZXAuc2NhbGU7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFN0ZXA6IGZ1bmN0aW9uIGdldFN0ZXAoKSB7XG4gICAgICAgICAgcmV0dXJuIG1lLnRpbWVBeGlzLnN0ZXAuc3RlcDtcbiAgICAgICAgfSxcblxuICAgICAgICB0b1NjcmVlbjogbWUuX3RvU2NyZWVuLmJpbmQobWUpLFxuICAgICAgICB0b0dsb2JhbFNjcmVlbjogbWUuX3RvR2xvYmFsU2NyZWVuLmJpbmQobWUpLCAvLyB0aGlzIHJlZmVycyB0byB0aGUgcm9vdC53aWR0aFxuICAgICAgICB0b1RpbWU6IG1lLl90b1RpbWUuYmluZChtZSksXG4gICAgICAgIHRvR2xvYmFsVGltZTogbWUuX3RvR2xvYmFsVGltZS5iaW5kKG1lKVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyByYW5nZVxuICAgIHRoaXMucmFuZ2UgPSBuZXcgUmFuZ2UodGhpcy5ib2R5KTtcbiAgICB0aGlzLmNvbXBvbmVudHMucHVzaCh0aGlzLnJhbmdlKTtcbiAgICB0aGlzLmJvZHkucmFuZ2UgPSB0aGlzLnJhbmdlO1xuXG4gICAgLy8gdGltZSBheGlzXG4gICAgdGhpcy50aW1lQXhpcyA9IG5ldyBUaW1lQXhpcyh0aGlzLmJvZHkpO1xuICAgIHRoaXMudGltZUF4aXMyID0gbnVsbDsgLy8gdXNlZCBpbiBjYXNlIG9mIG9yaWVudGF0aW9uIG9wdGlvbiAnYm90aCdcbiAgICB0aGlzLmNvbXBvbmVudHMucHVzaCh0aGlzLnRpbWVBeGlzKTtcblxuICAgIC8vIGN1cnJlbnQgdGltZSBiYXJcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gbmV3IEN1cnJlbnRUaW1lKHRoaXMuYm9keSk7XG4gICAgdGhpcy5jb21wb25lbnRzLnB1c2godGhpcy5jdXJyZW50VGltZSk7XG5cbiAgICAvLyBpdGVtIHNldFxuICAgIHRoaXMuaXRlbVNldCA9IG5ldyBJdGVtU2V0KHRoaXMuYm9keSwgdGhpcy5vcHRpb25zKTtcbiAgICB0aGlzLmNvbXBvbmVudHMucHVzaCh0aGlzLml0ZW1TZXQpO1xuXG4gICAgdGhpcy5pdGVtc0RhdGEgPSBudWxsOyAvLyBEYXRhU2V0XG4gICAgdGhpcy5ncm91cHNEYXRhID0gbnVsbDsgLy8gRGF0YVNldFxuXG4gICAgdGhpcy5vbigndGFwJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBtZS5lbWl0KCdjbGljaycsIG1lLmdldEV2ZW50UHJvcGVydGllcyhldmVudCkpO1xuICAgIH0pO1xuICAgIHRoaXMub24oJ2RvdWJsZXRhcCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgbWUuZW1pdCgnZG91YmxlQ2xpY2snLCBtZS5nZXRFdmVudFByb3BlcnRpZXMoZXZlbnQpKTtcbiAgICB9KTtcbiAgICB0aGlzLmRvbS5yb290Lm9uY29udGV4dG1lbnUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIG1lLmVtaXQoJ2NvbnRleHRtZW51JywgbWUuZ2V0RXZlbnRQcm9wZXJ0aWVzKGV2ZW50KSk7XG4gICAgfTtcblxuICAgIC8vU2luZ2xlIHRpbWUgYXV0b3NjYWxlL2ZpdFxuICAgIHRoaXMuZml0RG9uZSA9IGZhbHNlO1xuICAgIHRoaXMub24oJ2NoYW5nZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5pdGVtc0RhdGEgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgaWYgKCFtZS5maXREb25lKSB7XG4gICAgICAgIG1lLmZpdERvbmUgPSB0cnVlO1xuICAgICAgICBpZiAobWUub3B0aW9ucy5zdGFydCAhPSB1bmRlZmluZWQgfHwgbWUub3B0aW9ucy5lbmQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKG1lLm9wdGlvbnMuc3RhcnQgPT0gdW5kZWZpbmVkIHx8IG1lLm9wdGlvbnMuZW5kID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gbWUuZ2V0SXRlbVJhbmdlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHN0YXJ0ID0gbWUub3B0aW9ucy5zdGFydCAhPSB1bmRlZmluZWQgPyBtZS5vcHRpb25zLnN0YXJ0IDogcmFuZ2UubWluO1xuICAgICAgICAgIHZhciBlbmQgPSBtZS5vcHRpb25zLmVuZCAhPSB1bmRlZmluZWQgPyBtZS5vcHRpb25zLmVuZCA6IHJhbmdlLm1heDtcblxuICAgICAgICAgIG1lLnNldFdpbmRvdyhzdGFydCwgZW5kLCB7IGFuaW1hdGlvbjogZmFsc2UgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWUuZml0KHsgYW5pbWF0aW9uOiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gYXBwbHkgb3B0aW9uc1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLy8gSU1QT1JUQU5UOiBUSElTIEhBUFBFTlMgQkVGT1JFIFNFVCBJVEVNUyFcbiAgICBpZiAoZ3JvdXBzKSB7XG4gICAgICB0aGlzLnNldEdyb3Vwcyhncm91cHMpO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBpdGVtc2V0XG4gICAgaWYgKGl0ZW1zKSB7XG4gICAgICB0aGlzLnNldEl0ZW1zKGl0ZW1zKTtcbiAgICB9XG5cbiAgICAvLyBkcmF3IGZvciB0aGUgZmlyc3QgdGltZVxuICAgIHRoaXMuX3JlZHJhdygpO1xuICB9XG5cbiAgLy8gRXh0ZW5kIHRoZSBmdW5jdGlvbmFsaXR5IGZyb20gQ29yZVxuICBUaW1lbGluZS5wcm90b3R5cGUgPSBuZXcgQ29yZSgpO1xuXG4gIC8qKlxuICAgKiBMb2FkIGEgY29uZmlndXJhdG9yXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFRpbWVsaW5lLnByb3RvdHlwZS5fY3JlYXRlQ29uZmlndXJhdG9yID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgX0NvbmZpZ3VyYXRvcjIuZGVmYXVsdCh0aGlzLCB0aGlzLmRvbS5jb250YWluZXIsIGNvbmZpZ3VyZU9wdGlvbnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGb3JjZSBhIHJlZHJhdy4gVGhlIHNpemUgb2YgYWxsIGl0ZW1zIHdpbGwgYmUgcmVjYWxjdWxhdGVkLlxuICAgKiBDYW4gYmUgdXNlZnVsIHRvIG1hbnVhbGx5IHJlZHJhdyB3aGVuIG9wdGlvbiBhdXRvUmVzaXplPWZhbHNlIGFuZCB0aGUgd2luZG93XG4gICAqIGhhcyBiZWVuIHJlc2l6ZWQsIG9yIHdoZW4gdGhlIGl0ZW1zIENTUyBoYXMgYmVlbiBjaGFuZ2VkLlxuICAgKlxuICAgKiBOb3RlOiB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgb3ZlcnJpZGRlbiBvbiBjb25zdHJ1Y3Rpb24gd2l0aCBhIHRyb3R0bGVkIHZlcnNpb25cbiAgICovXG4gIFRpbWVsaW5lLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pdGVtU2V0ICYmIHRoaXMuaXRlbVNldC5tYXJrRGlydHkoeyByZWZyZXNoSXRlbXM6IHRydWUgfSk7XG4gICAgdGhpcy5fcmVkcmF3KCk7XG4gIH07XG5cbiAgVGltZWxpbmUucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIC8vIHZhbGlkYXRlIG9wdGlvbnNcbiAgICB2YXIgZXJyb3JGb3VuZCA9IF9WYWxpZGF0b3IyLmRlZmF1bHQudmFsaWRhdGUob3B0aW9ucywgYWxsT3B0aW9ucyk7XG5cbiAgICBpZiAoZXJyb3JGb3VuZCA9PT0gdHJ1ZSkge1xuICAgICAgY29uc29sZS5sb2coJyVjRXJyb3JzIGhhdmUgYmVlbiBmb3VuZCBpbiB0aGUgc3VwcGxpZWQgb3B0aW9ucyBvYmplY3QuJywgcHJpbnRTdHlsZSk7XG4gICAgfVxuXG4gICAgQ29yZS5wcm90b3R5cGUuc2V0T3B0aW9ucy5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgaWYgKCd0eXBlJyBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucy50eXBlICE9PSB0aGlzLm9wdGlvbnMudHlwZSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMudHlwZSA9IG9wdGlvbnMudHlwZTtcblxuICAgICAgICAvLyBmb3JjZSByZWNyZWF0aW9uIG9mIGFsbCBpdGVtc1xuICAgICAgICB2YXIgaXRlbXNEYXRhID0gdGhpcy5pdGVtc0RhdGE7XG4gICAgICAgIGlmIChpdGVtc0RhdGEpIHtcbiAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICB0aGlzLnNldEl0ZW1zKG51bGwpOyAvLyByZW1vdmUgYWxsXG4gICAgICAgICAgdGhpcy5zZXRJdGVtcyhpdGVtc0RhdGEpOyAvLyBhZGQgYWxsXG4gICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTsgLy8gcmVzdG9yZSBzZWxlY3Rpb25cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0IGl0ZW1zXG4gICAqIEBwYXJhbSB7dmlzLkRhdGFTZXQgfCBBcnJheSB8IG51bGx9IGl0ZW1zXG4gICAqL1xuICBUaW1lbGluZS5wcm90b3R5cGUuc2V0SXRlbXMgPSBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgICAvLyBjb252ZXJ0IHRvIHR5cGUgRGF0YVNldCB3aGVuIG5lZWRlZFxuICAgIHZhciBuZXdEYXRhU2V0O1xuICAgIGlmICghaXRlbXMpIHtcbiAgICAgIG5ld0RhdGFTZXQgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAoaXRlbXMgaW5zdGFuY2VvZiBEYXRhU2V0IHx8IGl0ZW1zIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICAgIG5ld0RhdGFTZXQgPSBpdGVtcztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdHVybiBhbiBhcnJheSBpbnRvIGEgZGF0YXNldFxuICAgICAgbmV3RGF0YVNldCA9IG5ldyBEYXRhU2V0KGl0ZW1zLCB7XG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICBzdGFydDogJ0RhdGUnLFxuICAgICAgICAgIGVuZDogJ0RhdGUnXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHNldCBpdGVtc1xuICAgIHRoaXMuaXRlbXNEYXRhID0gbmV3RGF0YVNldDtcbiAgICB0aGlzLml0ZW1TZXQgJiYgdGhpcy5pdGVtU2V0LnNldEl0ZW1zKG5ld0RhdGFTZXQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgZ3JvdXBzXG4gICAqIEBwYXJhbSB7dmlzLkRhdGFTZXQgfCBBcnJheX0gZ3JvdXBzXG4gICAqL1xuICBUaW1lbGluZS5wcm90b3R5cGUuc2V0R3JvdXBzID0gZnVuY3Rpb24gKGdyb3Vwcykge1xuICAgIC8vIGNvbnZlcnQgdG8gdHlwZSBEYXRhU2V0IHdoZW4gbmVlZGVkXG4gICAgdmFyIG5ld0RhdGFTZXQ7XG4gICAgaWYgKCFncm91cHMpIHtcbiAgICAgIG5ld0RhdGFTZXQgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAoZ3JvdXBzIGluc3RhbmNlb2YgRGF0YVNldCB8fCBncm91cHMgaW5zdGFuY2VvZiBEYXRhVmlldykge1xuICAgICAgbmV3RGF0YVNldCA9IGdyb3VwcztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdHVybiBhbiBhcnJheSBpbnRvIGEgZGF0YXNldFxuICAgICAgbmV3RGF0YVNldCA9IG5ldyBEYXRhU2V0KGdyb3Vwcyk7XG4gICAgfVxuXG4gICAgdGhpcy5ncm91cHNEYXRhID0gbmV3RGF0YVNldDtcbiAgICB0aGlzLml0ZW1TZXQuc2V0R3JvdXBzKG5ld0RhdGFTZXQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgYm90aCBpdGVtcyBhbmQgZ3JvdXBzIGluIG9uZSBnb1xuICAgKiBAcGFyYW0ge3tpdGVtczogQXJyYXkgfCB2aXMuRGF0YVNldCwgZ3JvdXBzOiBBcnJheSB8IHZpcy5EYXRhU2V0fX0gZGF0YVxuICAgKi9cbiAgVGltZWxpbmUucHJvdG90eXBlLnNldERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGlmIChkYXRhICYmIGRhdGEuZ3JvdXBzKSB7XG4gICAgICB0aGlzLnNldEdyb3VwcyhkYXRhLmdyb3Vwcyk7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEgJiYgZGF0YS5pdGVtcykge1xuICAgICAgdGhpcy5zZXRJdGVtcyhkYXRhLml0ZW1zKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBzZWxlY3RlZCBpdGVtcyBieSB0aGVpciBpZC4gUmVwbGFjZXMgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG4gICAqIFVua25vd24gaWQncyBhcmUgc2lsZW50bHkgaWdub3JlZC5cbiAgICogQHBhcmFtIHtzdHJpbmdbXSB8IHN0cmluZ30gW2lkc10gIEFuIGFycmF5IHdpdGggemVybyBvciBtb3JlIGlkJ3Mgb2YgdGhlIGl0ZW1zIHRvIGJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZC4gSWYgaWRzIGlzIGFuIGVtcHR5IGFycmF5LCBhbGwgaXRlbXMgd2lsbCBiZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5zZWxlY3RlZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICAgIEF2YWlsYWJsZSBvcHRpb25zOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGZvY3VzOiBib29sZWFuYFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHRydWUsIGZvY3VzIHdpbGwgYmUgc2V0IHRvIHRoZSBzZWxlY3RlZCBpdGVtKHMpXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgYW5pbWF0aW9uOiBib29sZWFuIHwge2R1cmF0aW9uOiBudW1iZXIsIGVhc2luZ0Z1bmN0aW9uOiBzdHJpbmd9YFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHRydWUgKGRlZmF1bHQpLCB0aGUgcmFuZ2UgaXMgYW5pbWF0ZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbW9vdGhseSB0byB0aGUgbmV3IHdpbmRvdy4gQW4gb2JqZWN0IGNhbiBiZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVkIHRvIHNwZWNpZnkgZHVyYXRpb24gYW5kIGVhc2luZyBmdW5jdGlvbi5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IGR1cmF0aW9uIGlzIDUwMCBtcywgYW5kIGRlZmF1bHQgZWFzaW5nXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gaXMgJ2Vhc2VJbk91dFF1YWQnLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9ubHkgYXBwbGljYWJsZSB3aGVuIG9wdGlvbiBmb2N1cyBpcyB0cnVlLlxuICAgKi9cbiAgVGltZWxpbmUucHJvdG90eXBlLnNldFNlbGVjdGlvbiA9IGZ1bmN0aW9uIChpZHMsIG9wdGlvbnMpIHtcbiAgICB0aGlzLml0ZW1TZXQgJiYgdGhpcy5pdGVtU2V0LnNldFNlbGVjdGlvbihpZHMpO1xuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5mb2N1cykge1xuICAgICAgdGhpcy5mb2N1cyhpZHMsIG9wdGlvbnMpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBzZWxlY3RlZCBpdGVtcyBieSB0aGVpciBpZFxuICAgKiBAcmV0dXJuIHtBcnJheX0gaWRzICBUaGUgaWRzIG9mIHRoZSBzZWxlY3RlZCBpdGVtc1xuICAgKi9cbiAgVGltZWxpbmUucHJvdG90eXBlLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtU2V0ICYmIHRoaXMuaXRlbVNldC5nZXRTZWxlY3Rpb24oKSB8fCBbXTtcbiAgfTtcblxuICAvKipcbiAgICogQWRqdXN0IHRoZSB2aXNpYmxlIHdpbmRvdyBzdWNoIHRoYXQgdGhlIHNlbGVjdGVkIGl0ZW0gKG9yIG11bHRpcGxlIGl0ZW1zKVxuICAgKiBhcmUgY2VudGVyZWQgb24gc2NyZWVuLlxuICAgKiBAcGFyYW0ge1N0cmluZyB8IFN0cmluZ1tdfSBpZCAgICAgQW4gaXRlbSBpZCBvciBhcnJheSB3aXRoIGl0ZW0gaWRzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgICBBdmFpbGFibGUgb3B0aW9uczpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBhbmltYXRpb246IGJvb2xlYW4gfCB7ZHVyYXRpb246IG51bWJlciwgZWFzaW5nRnVuY3Rpb246IHN0cmluZ31gXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgdHJ1ZSAoZGVmYXVsdCksIHRoZSByYW5nZSBpcyBhbmltYXRlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtb290aGx5IHRvIHRoZSBuZXcgd2luZG93LiBBbiBvYmplY3QgY2FuIGJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZWQgdG8gc3BlY2lmeSBkdXJhdGlvbiBhbmQgZWFzaW5nIGZ1bmN0aW9uLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgZHVyYXRpb24gaXMgNTAwIG1zLCBhbmQgZGVmYXVsdCBlYXNpbmdcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBpcyAnZWFzZUluT3V0UXVhZCcuXG4gICAqL1xuICBUaW1lbGluZS5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoaWQsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuaXRlbXNEYXRhIHx8IGlkID09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgdmFyIGlkcyA9IEFycmF5LmlzQXJyYXkoaWQpID8gaWQgOiBbaWRdO1xuXG4gICAgLy8gZ2V0IHRoZSBzcGVjaWZpZWQgaXRlbShzKVxuICAgIHZhciBpdGVtc0RhdGEgPSB0aGlzLml0ZW1zRGF0YS5nZXREYXRhU2V0KCkuZ2V0KGlkcywge1xuICAgICAgdHlwZToge1xuICAgICAgICBzdGFydDogJ0RhdGUnLFxuICAgICAgICBlbmQ6ICdEYXRlJ1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gY2FsY3VsYXRlIG1pbmltdW0gc3RhcnQgYW5kIG1heGltdW0gZW5kIG9mIHNwZWNpZmllZCBpdGVtc1xuICAgIHZhciBzdGFydCA9IG51bGw7XG4gICAgdmFyIGVuZCA9IG51bGw7XG4gICAgaXRlbXNEYXRhLmZvckVhY2goZnVuY3Rpb24gKGl0ZW1EYXRhKSB7XG4gICAgICB2YXIgcyA9IGl0ZW1EYXRhLnN0YXJ0LnZhbHVlT2YoKTtcbiAgICAgIHZhciBlID0gJ2VuZCcgaW4gaXRlbURhdGEgPyBpdGVtRGF0YS5lbmQudmFsdWVPZigpIDogaXRlbURhdGEuc3RhcnQudmFsdWVPZigpO1xuXG4gICAgICBpZiAoc3RhcnQgPT09IG51bGwgfHwgcyA8IHN0YXJ0KSB7XG4gICAgICAgIHN0YXJ0ID0gcztcbiAgICAgIH1cblxuICAgICAgaWYgKGVuZCA9PT0gbnVsbCB8fCBlID4gZW5kKSB7XG4gICAgICAgIGVuZCA9IGU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoc3RhcnQgIT09IG51bGwgJiYgZW5kICE9PSBudWxsKSB7XG4gICAgICAvLyBjYWxjdWxhdGUgdGhlIG5ldyBtaWRkbGUgYW5kIGludGVydmFsIGZvciB0aGUgd2luZG93XG4gICAgICB2YXIgbWlkZGxlID0gKHN0YXJ0ICsgZW5kKSAvIDI7XG4gICAgICB2YXIgaW50ZXJ2YWwgPSBNYXRoLm1heCh0aGlzLnJhbmdlLmVuZCAtIHRoaXMucmFuZ2Uuc3RhcnQsIChlbmQgLSBzdGFydCkgKiAxLjEpO1xuXG4gICAgICB2YXIgYW5pbWF0aW9uID0gb3B0aW9ucyAmJiBvcHRpb25zLmFuaW1hdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5hbmltYXRpb24gOiB0cnVlO1xuICAgICAgdGhpcy5yYW5nZS5zZXRSYW5nZShtaWRkbGUgLSBpbnRlcnZhbCAvIDIsIG1pZGRsZSArIGludGVydmFsIC8gMiwgYW5pbWF0aW9uKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBUaW1lbGluZSB3aW5kb3cgc3VjaCB0aGF0IGl0IGZpdHMgYWxsIGl0ZW1zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gIEF2YWlsYWJsZSBvcHRpb25zOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGFuaW1hdGlvbjogYm9vbGVhbiB8IHtkdXJhdGlvbjogbnVtYmVyLCBlYXNpbmdGdW5jdGlvbjogc3RyaW5nfWBcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiB0cnVlIChkZWZhdWx0KSwgdGhlIHJhbmdlIGlzIGFuaW1hdGVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc21vb3RobHkgdG8gdGhlIG5ldyB3aW5kb3cuIEFuIG9iamVjdCBjYW4gYmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlZCB0byBzcGVjaWZ5IGR1cmF0aW9uIGFuZCBlYXNpbmcgZnVuY3Rpb24uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCBkdXJhdGlvbiBpcyA1MDAgbXMsIGFuZCBkZWZhdWx0IGVhc2luZ1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGlzICdlYXNlSW5PdXRRdWFkJy5cbiAgICovXG4gIFRpbWVsaW5lLnByb3RvdHlwZS5maXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBhbmltYXRpb24gPSBvcHRpb25zICYmIG9wdGlvbnMuYW5pbWF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmFuaW1hdGlvbiA6IHRydWU7XG4gICAgdmFyIHJhbmdlO1xuXG4gICAgdmFyIGRhdGFzZXQgPSB0aGlzLml0ZW1zRGF0YSAmJiB0aGlzLml0ZW1zRGF0YS5nZXREYXRhU2V0KCk7XG4gICAgaWYgKGRhdGFzZXQubGVuZ3RoID09PSAxICYmIGRhdGFzZXQuZ2V0KClbMF0uZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGEgc2luZ2xlIGl0ZW0gLT4gZG9uJ3QgZml0LCBqdXN0IHNob3cgYSByYW5nZSBhcm91bmQgdGhlIGl0ZW0gZnJvbSAtNCB0byArMyBkYXlzXG4gICAgICByYW5nZSA9IHRoaXMuZ2V0RGF0YVJhbmdlKCk7XG4gICAgICB0aGlzLm1vdmVUbyhyYW5nZS5taW4udmFsdWVPZigpLCB7IGFuaW1hdGlvbjogYW5pbWF0aW9uIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGFjdGx5IGZpdCB0aGUgaXRlbXMgKHBsdXMgYSBzbWFsbCBtYXJnaW4pXG4gICAgICByYW5nZSA9IHRoaXMuZ2V0SXRlbVJhbmdlKCk7XG4gICAgICB0aGlzLnJhbmdlLnNldFJhbmdlKHJhbmdlLm1pbiwgcmFuZ2UubWF4LCBhbmltYXRpb24pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHRoZSByYW5nZSBvZiB0aGUgaXRlbXMsIHRha2luZyBpbnRvIGFjY291bnQgdGhlaXIgYWN0dWFsIHdpZHRoXG4gICAqIGFuZCBhIG1hcmdpbiBvZiAxMCBwaXhlbHMgb24gYm90aCBzaWRlcy5cbiAgICogQHJldHVybiB7e21pbjogRGF0ZSB8IG51bGwsIG1heDogRGF0ZSB8IG51bGx9fVxuICAgKi9cbiAgVGltZWxpbmUucHJvdG90eXBlLmdldEl0ZW1SYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLy8gZ2V0IGEgcm91Z2ggYXBwcm94aW1hdGlvbiBmb3IgdGhlIHJhbmdlIGJhc2VkIG9uIHRoZSBpdGVtcyBzdGFydCBhbmQgZW5kIGRhdGVzXG4gICAgdmFyIHJhbmdlID0gdGhpcy5nZXREYXRhUmFuZ2UoKTtcbiAgICB2YXIgbWluID0gcmFuZ2UubWluICE9PSBudWxsID8gcmFuZ2UubWluLnZhbHVlT2YoKSA6IG51bGw7XG4gICAgdmFyIG1heCA9IHJhbmdlLm1heCAhPT0gbnVsbCA/IHJhbmdlLm1heC52YWx1ZU9mKCkgOiBudWxsO1xuICAgIHZhciBtaW5JdGVtID0gbnVsbDtcbiAgICB2YXIgbWF4SXRlbSA9IG51bGw7XG5cbiAgICBpZiAobWluICE9IG51bGwgJiYgbWF4ICE9IG51bGwpIHtcbiAgICAgIHZhciBpbnRlcnZhbDtcbiAgICAgIHZhciBmYWN0b3I7XG4gICAgICB2YXIgbGhzO1xuICAgICAgdmFyIHJocztcbiAgICAgIHZhciBkZWx0YTtcblxuICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGdldFN0YXJ0ID0gZnVuY3Rpb24gZ2V0U3RhcnQoaXRlbSkge1xuICAgICAgICAgIHJldHVybiB1dGlsLmNvbnZlcnQoaXRlbS5kYXRhLnN0YXJ0LCAnRGF0ZScpLnZhbHVlT2YoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZ2V0RW5kID0gZnVuY3Rpb24gZ2V0RW5kKGl0ZW0pIHtcbiAgICAgICAgICB2YXIgZW5kID0gaXRlbS5kYXRhLmVuZCAhPSB1bmRlZmluZWQgPyBpdGVtLmRhdGEuZW5kIDogaXRlbS5kYXRhLnN0YXJ0O1xuICAgICAgICAgIHJldHVybiB1dGlsLmNvbnZlcnQoZW5kLCAnRGF0ZScpLnZhbHVlT2YoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIGRhdGUgb2YgdGhlIGxlZnQgc2lkZSBhbmQgcmlnaHQgc2lkZSBvZiB0aGUgaXRlbXMgZ2l2ZW5cblxuXG4gICAgICAgIGludGVydmFsID0gbWF4IC0gbWluOyAvLyBtc1xuXG4gICAgICAgIGlmIChpbnRlcnZhbCA8PSAwKSB7XG4gICAgICAgICAgaW50ZXJ2YWwgPSAxMDtcbiAgICAgICAgfVxuICAgICAgICBmYWN0b3IgPSBpbnRlcnZhbCAvIF90aGlzLnByb3BzLmNlbnRlci53aWR0aDtcbiAgICAgICAgdXRpbC5mb3JFYWNoKF90aGlzLml0ZW1TZXQuaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgaXRlbS5zaG93KCk7XG4gICAgICAgICAgaXRlbS5yZXBvc2l0aW9uWCgpO1xuXG4gICAgICAgICAgdmFyIHN0YXJ0ID0gZ2V0U3RhcnQoaXRlbSk7XG4gICAgICAgICAgdmFyIGVuZCA9IGdldEVuZChpdGVtKTtcblxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucnRsKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRTaWRlID0gc3RhcnQgLSAoaXRlbS5nZXRXaWR0aFJpZ2h0KCkgKyAxMCkgKiBmYWN0b3I7XG4gICAgICAgICAgICB2YXIgZW5kU2lkZSA9IGVuZCArIChpdGVtLmdldFdpZHRoTGVmdCgpICsgMTApICogZmFjdG9yO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRTaWRlID0gc3RhcnQgLSAoaXRlbS5nZXRXaWR0aExlZnQoKSArIDEwKSAqIGZhY3RvcjtcbiAgICAgICAgICAgIHZhciBlbmRTaWRlID0gZW5kICsgKGl0ZW0uZ2V0V2lkdGhSaWdodCgpICsgMTApICogZmFjdG9yO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdGFydFNpZGUgPCBtaW4pIHtcbiAgICAgICAgICAgIG1pbiA9IHN0YXJ0U2lkZTtcbiAgICAgICAgICAgIG1pbkl0ZW0gPSBpdGVtO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZW5kU2lkZSA+IG1heCkge1xuICAgICAgICAgICAgbWF4ID0gZW5kU2lkZTtcbiAgICAgICAgICAgIG1heEl0ZW0gPSBpdGVtO1xuICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKF90aGlzKSk7XG5cbiAgICAgICAgaWYgKG1pbkl0ZW0gJiYgbWF4SXRlbSkge1xuICAgICAgICAgIGxocyA9IG1pbkl0ZW0uZ2V0V2lkdGhMZWZ0KCkgKyAxMDtcbiAgICAgICAgICByaHMgPSBtYXhJdGVtLmdldFdpZHRoUmlnaHQoKSArIDEwO1xuICAgICAgICAgIGRlbHRhID0gX3RoaXMucHJvcHMuY2VudGVyLndpZHRoIC0gbGhzIC0gcmhzOyAvLyBweFxuXG4gICAgICAgICAgaWYgKGRlbHRhID4gMCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMucnRsKSB7XG4gICAgICAgICAgICAgIG1pbiA9IGdldFN0YXJ0KG1pbkl0ZW0pIC0gcmhzICogaW50ZXJ2YWwgLyBkZWx0YTsgLy8gbXNcbiAgICAgICAgICAgICAgbWF4ID0gZ2V0RW5kKG1heEl0ZW0pICsgbGhzICogaW50ZXJ2YWwgLyBkZWx0YTsgLy8gbXNcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWluID0gZ2V0U3RhcnQobWluSXRlbSkgLSBsaHMgKiBpbnRlcnZhbCAvIGRlbHRhOyAvLyBtc1xuICAgICAgICAgICAgICAgIG1heCA9IGdldEVuZChtYXhJdGVtKSArIHJocyAqIGludGVydmFsIC8gZGVsdGE7IC8vIG1zXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbjogbWluICE9IG51bGwgPyBuZXcgRGF0ZShtaW4pIDogbnVsbCxcbiAgICAgIG1heDogbWF4ICE9IG51bGwgPyBuZXcgRGF0ZShtYXgpIDogbnVsbFxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgZGF0YSByYW5nZSBvZiB0aGUgaXRlbXMgc3RhcnQgYW5kIGVuZCBkYXRlc1xuICAgKiBAcmV0dXJucyB7e21pbjogRGF0ZSB8IG51bGwsIG1heDogRGF0ZSB8IG51bGx9fVxuICAgKi9cbiAgVGltZWxpbmUucHJvdG90eXBlLmdldERhdGFSYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbWluID0gbnVsbDtcbiAgICB2YXIgbWF4ID0gbnVsbDtcblxuICAgIHZhciBkYXRhc2V0ID0gdGhpcy5pdGVtc0RhdGEgJiYgdGhpcy5pdGVtc0RhdGEuZ2V0RGF0YVNldCgpO1xuICAgIGlmIChkYXRhc2V0KSB7XG4gICAgICBkYXRhc2V0LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdXRpbC5jb252ZXJ0KGl0ZW0uc3RhcnQsICdEYXRlJykudmFsdWVPZigpO1xuICAgICAgICB2YXIgZW5kID0gdXRpbC5jb252ZXJ0KGl0ZW0uZW5kICE9IHVuZGVmaW5lZCA/IGl0ZW0uZW5kIDogaXRlbS5zdGFydCwgJ0RhdGUnKS52YWx1ZU9mKCk7XG4gICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgc3RhcnQgPCBtaW4pIHtcbiAgICAgICAgICBtaW4gPSBzdGFydDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGVuZCA+IG1heCkge1xuICAgICAgICAgIG1heCA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbjogbWluICE9IG51bGwgPyBuZXcgRGF0ZShtaW4pIDogbnVsbCxcbiAgICAgIG1heDogbWF4ICE9IG51bGwgPyBuZXcgRGF0ZShtYXgpIDogbnVsbFxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIFRpbWVsaW5lIHJlbGF0ZWQgaW5mb3JtYXRpb24gZnJvbSBhbiBldmVudFxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIHJlbGF0ZWQgaW5mb3JtYXRpb24sIGxpa2Ugb24gd2hpY2ggYXJlYVxuICAgKiAgICAgICAgICAgICAgICAgIFRoZSBldmVudCBoYXBwZW5lZCwgd2hldGhlciBjbGlja2VkIG9uIGFuIGl0ZW0sIGV0Yy5cbiAgICovXG4gIFRpbWVsaW5lLnByb3RvdHlwZS5nZXRFdmVudFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgY2xpZW50WCA9IGV2ZW50LmNlbnRlciA/IGV2ZW50LmNlbnRlci54IDogZXZlbnQuY2xpZW50WDtcbiAgICB2YXIgY2xpZW50WSA9IGV2ZW50LmNlbnRlciA/IGV2ZW50LmNlbnRlci55IDogZXZlbnQuY2xpZW50WTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgdmFyIHggPSB1dGlsLmdldEFic29sdXRlUmlnaHQodGhpcy5kb20uY2VudGVyQ29udGFpbmVyKSAtIGNsaWVudFg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB4ID0gY2xpZW50WCAtIHV0aWwuZ2V0QWJzb2x1dGVMZWZ0KHRoaXMuZG9tLmNlbnRlckNvbnRhaW5lcik7XG4gICAgfVxuICAgIHZhciB5ID0gY2xpZW50WSAtIHV0aWwuZ2V0QWJzb2x1dGVUb3AodGhpcy5kb20uY2VudGVyQ29udGFpbmVyKTtcblxuICAgIHZhciBpdGVtID0gdGhpcy5pdGVtU2V0Lml0ZW1Gcm9tVGFyZ2V0KGV2ZW50KTtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLml0ZW1TZXQuZ3JvdXBGcm9tVGFyZ2V0KGV2ZW50KTtcbiAgICB2YXIgY3VzdG9tVGltZSA9IEN1c3RvbVRpbWUuY3VzdG9tVGltZUZyb21UYXJnZXQoZXZlbnQpO1xuXG4gICAgdmFyIHNuYXAgPSB0aGlzLml0ZW1TZXQub3B0aW9ucy5zbmFwIHx8IG51bGw7XG4gICAgdmFyIHNjYWxlID0gdGhpcy5ib2R5LnV0aWwuZ2V0U2NhbGUoKTtcbiAgICB2YXIgc3RlcCA9IHRoaXMuYm9keS51dGlsLmdldFN0ZXAoKTtcbiAgICB2YXIgdGltZSA9IHRoaXMuX3RvVGltZSh4KTtcbiAgICB2YXIgc25hcHBlZFRpbWUgPSBzbmFwID8gc25hcCh0aW1lLCBzY2FsZSwgc3RlcCkgOiB0aW1lO1xuXG4gICAgdmFyIGVsZW1lbnQgPSB1dGlsLmdldFRhcmdldChldmVudCk7XG4gICAgdmFyIHdoYXQgPSBudWxsO1xuICAgIGlmIChpdGVtICE9IG51bGwpIHtcbiAgICAgIHdoYXQgPSAnaXRlbSc7XG4gICAgfSBlbHNlIGlmIChjdXN0b21UaW1lICE9IG51bGwpIHtcbiAgICAgIHdoYXQgPSAnY3VzdG9tLXRpbWUnO1xuICAgIH0gZWxzZSBpZiAodXRpbC5oYXNQYXJlbnQoZWxlbWVudCwgdGhpcy50aW1lQXhpcy5kb20uZm9yZWdyb3VuZCkpIHtcbiAgICAgIHdoYXQgPSAnYXhpcyc7XG4gICAgfSBlbHNlIGlmICh0aGlzLnRpbWVBeGlzMiAmJiB1dGlsLmhhc1BhcmVudChlbGVtZW50LCB0aGlzLnRpbWVBeGlzMi5kb20uZm9yZWdyb3VuZCkpIHtcbiAgICAgIHdoYXQgPSAnYXhpcyc7XG4gICAgfSBlbHNlIGlmICh1dGlsLmhhc1BhcmVudChlbGVtZW50LCB0aGlzLml0ZW1TZXQuZG9tLmxhYmVsU2V0KSkge1xuICAgICAgd2hhdCA9ICdncm91cC1sYWJlbCc7XG4gICAgfSBlbHNlIGlmICh1dGlsLmhhc1BhcmVudChlbGVtZW50LCB0aGlzLmN1cnJlbnRUaW1lLmJhcikpIHtcbiAgICAgIHdoYXQgPSAnY3VycmVudC10aW1lJztcbiAgICB9IGVsc2UgaWYgKHV0aWwuaGFzUGFyZW50KGVsZW1lbnQsIHRoaXMuZG9tLmNlbnRlcikpIHtcbiAgICAgIHdoYXQgPSAnYmFja2dyb3VuZCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgIGl0ZW06IGl0ZW0gPyBpdGVtLmlkIDogbnVsbCxcbiAgICAgIGdyb3VwOiBncm91cCA/IGdyb3VwLmdyb3VwSWQgOiBudWxsLFxuICAgICAgd2hhdDogd2hhdCxcbiAgICAgIHBhZ2VYOiBldmVudC5zcmNFdmVudCA/IGV2ZW50LnNyY0V2ZW50LnBhZ2VYIDogZXZlbnQucGFnZVgsXG4gICAgICBwYWdlWTogZXZlbnQuc3JjRXZlbnQgPyBldmVudC5zcmNFdmVudC5wYWdlWSA6IGV2ZW50LnBhZ2VZLFxuICAgICAgeDogeCxcbiAgICAgIHk6IHksXG4gICAgICB0aW1lOiB0aW1lLFxuICAgICAgc25hcHBlZFRpbWU6IHNuYXBwZWRUaW1lXG4gICAgfTtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFRpbWVsaW5lO1xuXG4vKioqLyB9LFxuLyogMjYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIHZhciBfQ29sb3JQaWNrZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KTtcblxuICB2YXIgX0NvbG9yUGlja2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NvbG9yUGlja2VyKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgdmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4gIC8qKlxuICAgKiBUaGUgd2F5IHRoaXMgd29ya3MgaXMgZm9yIGFsbCBwcm9wZXJ0aWVzIG9mIHRoaXMucG9zc2libGUgb3B0aW9ucywgeW91IGNhbiBzdXBwbHkgdGhlIHByb3BlcnR5IG5hbWUgaW4gYW55IGZvcm0gdG8gbGlzdCB0aGUgb3B0aW9ucy5cbiAgICogQm9vbGVhbiBvcHRpb25zIGFyZSByZWNvZ25pc2VkIGFzIEJvb2xlYW5cbiAgICogTnVtYmVyIG9wdGlvbnMgc2hvdWxkIGJlIHdyaXR0ZW4gYXMgYXJyYXk6IFtkZWZhdWx0IHZhbHVlLCBtaW4gdmFsdWUsIG1heCB2YWx1ZSwgc3RlcHNpemVdXG4gICAqIENvbG9ycyBzaG91bGQgYmUgd3JpdHRlbiBhcyBhcnJheTogWydjb2xvcicsICcjZmZmZmZmJ11cbiAgICogU3RyaW5ncyB3aXRoIHNob3VsZCBiZSB3cml0dGVuIGFzIGFycmF5OiBbb3B0aW9uMSwgb3B0aW9uMiwgb3B0aW9uMywgLi5dXG4gICAqXG4gICAqIFRoZSBvcHRpb25zIGFyZSBtYXRjaGVkIHdpdGggdGhlaXIgY291bnRlcnBhcnRzIGluIGVhY2ggb2YgdGhlIG1vZHVsZXMgYW5kIHRoZSB2YWx1ZXMgdXNlZCBpbiB0aGUgY29uZmlndXJhdGlvbiBhcmVcbiAgICpcbiAgICogQHBhcmFtIHBhcmVudE1vZHVsZSAgICAgICAgfCB0aGUgbG9jYXRpb24gd2hlcmUgcGFyZW50TW9kdWxlLnNldE9wdGlvbnMoKSBjYW4gYmUgY2FsbGVkXG4gICAqIEBwYXJhbSBkZWZhdWx0Q29udGFpbmVyICAgIHwgdGhlIGRlZmF1bHQgY29udGFpbmVyIG9mIHRoZSBtb2R1bGVcbiAgICogQHBhcmFtIGNvbmZpZ3VyZU9wdGlvbnMgICAgfCB0aGUgZnVsbHkgY29uZmlndXJlZCBhbmQgcHJlZGVmaW5lZCBvcHRpb25zIHNldCBmb3VuZCBpbiBhbGxPcHRpb25zLmpzXG4gICAqIEBwYXJhbSBwaXhlbFJhdGlvICAgICAgICAgIHwgY2FudmFzIHBpeGVsIHJhdGlvXG4gICAqL1xuXG4gIHZhciBDb25maWd1cmF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29uZmlndXJhdG9yKHBhcmVudE1vZHVsZSwgZGVmYXVsdENvbnRhaW5lciwgY29uZmlndXJlT3B0aW9ucykge1xuICAgICAgdmFyIHBpeGVsUmF0aW8gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDMgfHwgYXJndW1lbnRzWzNdID09PSB1bmRlZmluZWQgPyAxIDogYXJndW1lbnRzWzNdO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29uZmlndXJhdG9yKTtcblxuICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnRNb2R1bGU7XG4gICAgICB0aGlzLmNoYW5nZWRPcHRpb25zID0gW107XG4gICAgICB0aGlzLmNvbnRhaW5lciA9IGRlZmF1bHRDb250YWluZXI7XG4gICAgICB0aGlzLmFsbG93Q3JlYXRpb24gPSBmYWxzZTtcblxuICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICB0aGlzLnBvcHVwQ291bnRlciA9IDA7XG4gICAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgZmlsdGVyOiB0cnVlLFxuICAgICAgICBjb250YWluZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgc2hvd0J1dHRvbjogdHJ1ZVxuICAgICAgfTtcbiAgICAgIHV0aWwuZXh0ZW5kKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgICAgIHRoaXMuY29uZmlndXJlT3B0aW9ucyA9IGNvbmZpZ3VyZU9wdGlvbnM7XG4gICAgICB0aGlzLm1vZHVsZU9wdGlvbnMgPSB7fTtcbiAgICAgIHRoaXMuZG9tRWxlbWVudHMgPSBbXTtcbiAgICAgIHRoaXMucG9wdXBEaXYgPSB7fTtcbiAgICAgIHRoaXMucG9wdXBMaW1pdCA9IDU7XG4gICAgICB0aGlzLnBvcHVwSGlzdG9yeSA9IHt9O1xuICAgICAgdGhpcy5jb2xvclBpY2tlciA9IG5ldyBfQ29sb3JQaWNrZXIyLmRlZmF1bHQocGl4ZWxSYXRpbyk7XG4gICAgICB0aGlzLndyYXBwZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmVmcmVzaCBhbGwgb3B0aW9ucy5cbiAgICAgKiBCZWNhdXNlIGFsbCBtb2R1bGVzIHBhcnNlIHRoZWlyIG9wdGlvbnMgYnkgdGhlbXNlbHZlcywgd2UganVzdCB1c2UgdGhlaXIgb3B0aW9ucy4gV2UgY29weSB0aGVtIGhlcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoQ29uZmlndXJhdG9yLCBbe1xuICAgICAga2V5OiAnc2V0T3B0aW9ucycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyByZXNldCB0aGUgcG9wdXAgaGlzdG9yeSBiZWNhdXNlIHRoZSBpbmRpY2VzIG1heSBoYXZlIGJlZW4gY2hhbmdlZC5cbiAgICAgICAgICB0aGlzLnBvcHVwSGlzdG9yeSA9IHt9O1xuICAgICAgICAgIHRoaXMuX3JlbW92ZVBvcHVwKCk7XG5cbiAgICAgICAgICB2YXIgZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmZpbHRlciA9IG9wdGlvbnM7XG4gICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5maWx0ZXIgPSBvcHRpb25zLmpvaW4oKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yob3B0aW9ucykpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY29udGFpbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmNvbnRhaW5lciA9IG9wdGlvbnMuY29udGFpbmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZmlsdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hvd0J1dHRvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zaG93QnV0dG9uID0gb3B0aW9ucy5zaG93QnV0dG9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZW5hYmxlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGVuYWJsZWQgPSBvcHRpb25zLmVuYWJsZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZmlsdGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIGVuYWJsZWQgPSBvcHRpb25zO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5maWx0ZXIgPSBvcHRpb25zO1xuICAgICAgICAgICAgZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZmlsdGVyID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMub3B0aW9ucy5lbmFibGVkID0gZW5hYmxlZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jbGVhbigpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NldE1vZHVsZU9wdGlvbnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE1vZHVsZU9wdGlvbnMobW9kdWxlT3B0aW9ucykge1xuICAgICAgICB0aGlzLm1vZHVsZU9wdGlvbnMgPSBtb2R1bGVPcHRpb25zO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLl9jbGVhbigpO1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29udGFpbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5vcHRpb25zLmNvbnRhaW5lcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fY3JlYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGUgYWxsIERPTSBlbGVtZW50c1xuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2NyZWF0ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB0aGlzLl9jbGVhbigpO1xuICAgICAgICB0aGlzLmNoYW5nZWRPcHRpb25zID0gW107XG5cbiAgICAgICAgdmFyIGZpbHRlciA9IHRoaXMub3B0aW9ucy5maWx0ZXI7XG4gICAgICAgIHZhciBjb3VudGVyID0gMDtcbiAgICAgICAgdmFyIHNob3cgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgb3B0aW9uIGluIHRoaXMuY29uZmlndXJlT3B0aW9ucykge1xuICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyZU9wdGlvbnMuaGFzT3duUHJvcGVydHkob3B0aW9uKSkge1xuICAgICAgICAgICAgdGhpcy5hbGxvd0NyZWF0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICBzaG93ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBzaG93ID0gZmlsdGVyKG9wdGlvbiwgW10pO1xuICAgICAgICAgICAgICBzaG93ID0gc2hvdyB8fCB0aGlzLl9oYW5kbGVPYmplY3QodGhpcy5jb25maWd1cmVPcHRpb25zW29wdGlvbl0sIFtvcHRpb25dLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZmlsdGVyID09PSB0cnVlIHx8IGZpbHRlci5pbmRleE9mKG9wdGlvbikgIT09IC0xKSB7XG4gICAgICAgICAgICAgIHNob3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2hvdyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgdGhpcy5hbGxvd0NyZWF0aW9uID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAvLyBsaW5lYnJlYWsgYmV0d2VlbiBjYXRlZ29yaWVzXG4gICAgICAgICAgICAgIGlmIChjb3VudGVyID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21ha2VJdGVtKFtdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBhIGhlYWRlciBmb3IgdGhlIGNhdGVnb3J5XG4gICAgICAgICAgICAgIHRoaXMuX21ha2VIZWFkZXIob3B0aW9uKTtcblxuICAgICAgICAgICAgICAvLyBnZXQgdGhlIHN1YiBvcHRpb25zXG4gICAgICAgICAgICAgIHRoaXMuX2hhbmRsZU9iamVjdCh0aGlzLmNvbmZpZ3VyZU9wdGlvbnNbb3B0aW9uXSwgW29wdGlvbl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY291bnRlcisrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd0J1dHRvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZ2VuZXJhdGVCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGdlbmVyYXRlQnV0dG9uLmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWJ1dHRvbic7XG4gICAgICAgICAgICBnZW5lcmF0ZUJ1dHRvbi5pbm5lckhUTUwgPSAnZ2VuZXJhdGUgb3B0aW9ucyc7XG4gICAgICAgICAgICBnZW5lcmF0ZUJ1dHRvbi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpcy5fcHJpbnRPcHRpb25zKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2VuZXJhdGVCdXR0b24ub25tb3VzZW92ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGdlbmVyYXRlQnV0dG9uLmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWJ1dHRvbiBob3Zlcic7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2VuZXJhdGVCdXR0b24ub25tb3VzZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgZ2VuZXJhdGVCdXR0b24uY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctYnV0dG9uJztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIF90aGlzLm9wdGlvbnNDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIF90aGlzLm9wdGlvbnNDb250YWluZXIuY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctb3B0aW9uLWNvbnRhaW5lcic7XG5cbiAgICAgICAgICAgIF90aGlzLmRvbUVsZW1lbnRzLnB1c2goX3RoaXMub3B0aW9uc0NvbnRhaW5lcik7XG4gICAgICAgICAgICBfdGhpcy5kb21FbGVtZW50cy5wdXNoKGdlbmVyYXRlQnV0dG9uKTtcbiAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcHVzaCgpO1xuICAgICAgICAvL34gdGhpcy5jb2xvclBpY2tlci5pbnNlcnRUbyh0aGlzLmNvbnRhaW5lcik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogZHJhdyBhbGwgRE9NIGVsZW1lbnRzIG9uIHRoZSBzY3JlZW5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19wdXNoJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcHVzaCgpIHtcbiAgICAgICAgdGhpcy53cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMud3JhcHBlci5jbGFzc05hbWUgPSAndmlzLWNvbmZpZ3VyYXRpb24td3JhcHBlcic7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMud3JhcHBlcik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kb21FbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMud3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLmRvbUVsZW1lbnRzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3Nob3dQb3B1cElmTmVlZGVkKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogZGVsZXRlIGFsbCBET00gZWxlbWVudHNcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19jbGVhbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NsZWFuKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZG9tRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLndyYXBwZXIucmVtb3ZlQ2hpbGQodGhpcy5kb21FbGVtZW50c1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy53cmFwcGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLndyYXBwZXIpO1xuICAgICAgICAgIHRoaXMud3JhcHBlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvbUVsZW1lbnRzID0gW107XG5cbiAgICAgICAgdGhpcy5fcmVtb3ZlUG9wdXAoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIGFjdHVhbE9wdGlvbnMgaWYgaXQgZXhpc3RzXG4gICAgICAgKiBAcGFyYW0ge2FycmF5fSBwYXRoICAgIHwgd2hlcmUgdG8gbG9vayBmb3IgdGhlIGFjdHVhbCBvcHRpb25cbiAgICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2dldFZhbHVlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VmFsdWUocGF0aCkge1xuICAgICAgICB2YXIgYmFzZSA9IHRoaXMubW9kdWxlT3B0aW9ucztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGJhc2VbcGF0aFtpXV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYmFzZSA9IGJhc2VbcGF0aFtpXV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJhc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogYWxsIG9wdGlvbiBlbGVtZW50cyBhcmUgd3JhcHBlZCBpbiBhbiBpdGVtXG4gICAgICAgKiBAcGFyYW0gcGF0aFxuICAgICAgICogQHBhcmFtIGRvbUVsZW1lbnRzXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfbWFrZUl0ZW0nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlSXRlbShwYXRoKSB7XG4gICAgICAgIHZhciBfYXJndW1lbnRzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgX3RoaXMyID0gdGhpcztcblxuICAgICAgICBpZiAodGhpcy5hbGxvd0NyZWF0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIF9sZW4sIGRvbUVsZW1lbnRzLCBfa2V5O1xuXG4gICAgICAgICAgdmFyIF9yZXQyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGl0ZW0uY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctaXRlbSB2aXMtY29uZmlnLXMnICsgcGF0aC5sZW5ndGg7XG5cbiAgICAgICAgICAgIGZvciAoX2xlbiA9IF9hcmd1bWVudHMubGVuZ3RoLCBkb21FbGVtZW50cyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICAgICAgZG9tRWxlbWVudHNbX2tleSAtIDFdID0gX2FyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZG9tRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICBpdGVtLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfdGhpczIuZG9tRWxlbWVudHMucHVzaChpdGVtKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHY6IF90aGlzMi5kb21FbGVtZW50cy5sZW5ndGhcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgaWYgKCh0eXBlb2YgX3JldDIgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKF9yZXQyKSkgPT09IFwib2JqZWN0XCIpIHJldHVybiBfcmV0Mi52O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGhlYWRlciBmb3IgbWFqb3Igc3ViamVjdHNcbiAgICAgICAqIEBwYXJhbSBuYW1lXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfbWFrZUhlYWRlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VIZWFkZXIobmFtZSkge1xuICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGRpdi5jbGFzc05hbWUgPSAndmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1oZWFkZXInO1xuICAgICAgICBkaXYuaW5uZXJIVE1MID0gbmFtZTtcbiAgICAgICAgdGhpcy5fbWFrZUl0ZW0oW10sIGRpdik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogbWFrZSBhIGxhYmVsLCBpZiBpdCBpcyBhbiBvYmplY3QgbGFiZWwsIGl0IGdldHMgZGlmZmVyZW50IHN0eWxpbmcuXG4gICAgICAgKiBAcGFyYW0gbmFtZVxuICAgICAgICogQHBhcmFtIHBhdGhcbiAgICAgICAqIEBwYXJhbSBvYmplY3RMYWJlbFxuICAgICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX21ha2VMYWJlbCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VMYWJlbChuYW1lLCBwYXRoKSB7XG4gICAgICAgIHZhciBvYmplY3RMYWJlbCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogYXJndW1lbnRzWzJdO1xuXG4gICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZGl2LmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWxhYmVsIHZpcy1jb25maWctcycgKyBwYXRoLmxlbmd0aDtcbiAgICAgICAgaWYgKG9iamVjdExhYmVsID09PSB0cnVlKSB7XG4gICAgICAgICAgZGl2LmlubmVySFRNTCA9ICc8aT48Yj4nICsgbmFtZSArICc6PC9iPjwvaT4nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSBuYW1lICsgJzonO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaXY7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogbWFrZSBhIGRyb3Bkb3duIGxpc3QgZm9yIG11bHRpcGxlIHBvc3NpYmxlIHN0cmluZyBvcHRvaW5zXG4gICAgICAgKiBAcGFyYW0gYXJyXG4gICAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgICAqIEBwYXJhbSBwYXRoXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfbWFrZURyb3Bkb3duJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZURyb3Bkb3duKGFyciwgdmFsdWUsIHBhdGgpIHtcbiAgICAgICAgdmFyIHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NlbGVjdCcpO1xuICAgICAgICBzZWxlY3QuY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctc2VsZWN0JztcbiAgICAgICAgdmFyIHNlbGVjdGVkVmFsdWUgPSAwO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChhcnIuaW5kZXhPZih2YWx1ZSkgIT09IC0xKSB7XG4gICAgICAgICAgICBzZWxlY3RlZFZhbHVlID0gYXJyLmluZGV4T2YodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgICAgICAgIG9wdGlvbi52YWx1ZSA9IGFycltpXTtcbiAgICAgICAgICBpZiAoaSA9PT0gc2VsZWN0ZWRWYWx1ZSkge1xuICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gJ3NlbGVjdGVkJztcbiAgICAgICAgICB9XG4gICAgICAgICAgb3B0aW9uLmlubmVySFRNTCA9IGFycltpXTtcbiAgICAgICAgICBzZWxlY3QuYXBwZW5kQ2hpbGQob3B0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHNlbGVjdC5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBtZS5fdXBkYXRlKHRoaXMudmFsdWUsIHBhdGgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBsYWJlbCA9IHRoaXMuX21ha2VMYWJlbChwYXRoW3BhdGgubGVuZ3RoIC0gMV0sIHBhdGgpO1xuICAgICAgICB0aGlzLl9tYWtlSXRlbShwYXRoLCBsYWJlbCwgc2VsZWN0KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBtYWtlIGEgcmFuZ2Ugb2JqZWN0IGZvciBudW1lcmljIG9wdGlvbnNcbiAgICAgICAqIEBwYXJhbSBhcnJcbiAgICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAgICogQHBhcmFtIHBhdGhcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19tYWtlUmFuZ2UnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlUmFuZ2UoYXJyLCB2YWx1ZSwgcGF0aCkge1xuICAgICAgICB2YXIgZGVmYXVsdFZhbHVlID0gYXJyWzBdO1xuICAgICAgICB2YXIgbWluID0gYXJyWzFdO1xuICAgICAgICB2YXIgbWF4ID0gYXJyWzJdO1xuICAgICAgICB2YXIgc3RlcCA9IGFyclszXTtcbiAgICAgICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgcmFuZ2UuY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctcmFuZ2UnO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJhbmdlLnR5cGUgPSAncmFuZ2UnOyAvLyBub3Qgc3VwcG9ydGVkIG9uIElFOVxuICAgICAgICAgIHJhbmdlLm1pbiA9IG1pbjtcbiAgICAgICAgICByYW5nZS5tYXggPSBtYXg7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgcmFuZ2Uuc3RlcCA9IHN0ZXA7XG5cbiAgICAgICAgLy8gc2V0IHVwIHRoZSBwb3B1cCBzZXR0aW5ncyBpbiBjYXNlIHRoZXkgYXJlIG5lZWRlZC5cbiAgICAgICAgdmFyIHBvcHVwU3RyaW5nID0gJyc7XG4gICAgICAgIHZhciBwb3B1cFZhbHVlID0gMDtcblxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBmYWN0b3IgPSAxLjIwO1xuICAgICAgICAgIGlmICh2YWx1ZSA8IDAgJiYgdmFsdWUgKiBmYWN0b3IgPCBtaW4pIHtcbiAgICAgICAgICAgIHJhbmdlLm1pbiA9IE1hdGguY2VpbCh2YWx1ZSAqIGZhY3Rvcik7XG4gICAgICAgICAgICBwb3B1cFZhbHVlID0gcmFuZ2UubWluO1xuICAgICAgICAgICAgcG9wdXBTdHJpbmcgPSAncmFuZ2UgaW5jcmVhc2VkJztcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIC8gZmFjdG9yIDwgbWluKSB7XG4gICAgICAgICAgICByYW5nZS5taW4gPSBNYXRoLmNlaWwodmFsdWUgLyBmYWN0b3IpO1xuICAgICAgICAgICAgcG9wdXBWYWx1ZSA9IHJhbmdlLm1pbjtcbiAgICAgICAgICAgIHBvcHVwU3RyaW5nID0gJ3JhbmdlIGluY3JlYXNlZCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZSAqIGZhY3RvciA+IG1heCAmJiBtYXggIT09IDEpIHtcbiAgICAgICAgICAgIHJhbmdlLm1heCA9IE1hdGguY2VpbCh2YWx1ZSAqIGZhY3Rvcik7XG4gICAgICAgICAgICBwb3B1cFZhbHVlID0gcmFuZ2UubWF4O1xuICAgICAgICAgICAgcG9wdXBTdHJpbmcgPSAncmFuZ2UgaW5jcmVhc2VkJztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmFuZ2UudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByYW5nZS52YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIGlucHV0LmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLXJhbmdlaW5wdXQnO1xuICAgICAgICBpbnB1dC52YWx1ZSA9IHJhbmdlLnZhbHVlO1xuXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHJhbmdlLm9uY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlucHV0LnZhbHVlID0gdGhpcy52YWx1ZTttZS5fdXBkYXRlKE51bWJlcih0aGlzLnZhbHVlKSwgcGF0aCk7XG4gICAgICAgIH07XG4gICAgICAgIHJhbmdlLm9uaW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaW5wdXQudmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBsYWJlbCA9IHRoaXMuX21ha2VMYWJlbChwYXRoW3BhdGgubGVuZ3RoIC0gMV0sIHBhdGgpO1xuICAgICAgICB2YXIgaXRlbUluZGV4ID0gdGhpcy5fbWFrZUl0ZW0ocGF0aCwgbGFiZWwsIHJhbmdlLCBpbnB1dCk7XG5cbiAgICAgICAgLy8gaWYgYSBwb3B1cCBpcyBuZWVkZWQgQU5EIGl0IGhhcyBub3QgYmVlbiBzaG93biBmb3IgdGhpcyB2YWx1ZSwgc2hvdyBpdC5cbiAgICAgICAgaWYgKHBvcHVwU3RyaW5nICE9PSAnJyAmJiB0aGlzLnBvcHVwSGlzdG9yeVtpdGVtSW5kZXhdICE9PSBwb3B1cFZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5wb3B1cEhpc3RvcnlbaXRlbUluZGV4XSA9IHBvcHVwVmFsdWU7XG4gICAgICAgICAgdGhpcy5fc2V0dXBQb3B1cChwb3B1cFN0cmluZywgaXRlbUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHByZXBhcmUgdGhlIHBvcHVwXG4gICAgICAgKiBAcGFyYW0gc3RyaW5nXG4gICAgICAgKiBAcGFyYW0gaW5kZXhcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19zZXR1cFBvcHVwJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXBQb3B1cChzdHJpbmcsIGluZGV4KSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxpemVkID09PSB0cnVlICYmIHRoaXMuYWxsb3dDcmVhdGlvbiA9PT0gdHJ1ZSAmJiB0aGlzLnBvcHVwQ291bnRlciA8IHRoaXMucG9wdXBMaW1pdCkge1xuICAgICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgIGRpdi5pZCA9IFwidmlzLWNvbmZpZ3VyYXRpb24tcG9wdXBcIjtcbiAgICAgICAgICBkaXYuY2xhc3NOYW1lID0gXCJ2aXMtY29uZmlndXJhdGlvbi1wb3B1cFwiO1xuICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSBzdHJpbmc7XG4gICAgICAgICAgZGl2Lm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMuX3JlbW92ZVBvcHVwKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLnBvcHVwQ291bnRlciArPSAxO1xuICAgICAgICAgIHRoaXMucG9wdXBEaXYgPSB7IGh0bWw6IGRpdiwgaW5kZXg6IGluZGV4IH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiByZW1vdmUgdGhlIHBvcHVwIGZyb20gdGhlIGRvbVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3JlbW92ZVBvcHVwJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlUG9wdXAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBvcHVwRGl2Lmh0bWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMucG9wdXBEaXYuaHRtbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMucG9wdXBEaXYuaHRtbCk7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucG9wdXBEaXYuaGlkZVRpbWVvdXQpO1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBvcHVwRGl2LmRlbGV0ZVRpbWVvdXQpO1xuICAgICAgICAgIHRoaXMucG9wdXBEaXYgPSB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNob3cgdGhlIHBvcHVwIGlmIGl0IGlzIG5lZWRlZC5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19zaG93UG9wdXBJZk5lZWRlZCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3Nob3dQb3B1cElmTmVlZGVkKCkge1xuICAgICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgICBpZiAodGhpcy5wb3B1cERpdi5odG1sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgY29ycmVzcG9uZGluZ0VsZW1lbnQgPSB0aGlzLmRvbUVsZW1lbnRzW3RoaXMucG9wdXBEaXYuaW5kZXhdO1xuICAgICAgICAgIHZhciByZWN0ID0gY29ycmVzcG9uZGluZ0VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgdGhpcy5wb3B1cERpdi5odG1sLnN0eWxlLmxlZnQgPSByZWN0LmxlZnQgKyBcInB4XCI7XG4gICAgICAgICAgdGhpcy5wb3B1cERpdi5odG1sLnN0eWxlLnRvcCA9IHJlY3QudG9wIC0gMzAgKyBcInB4XCI7IC8vIDMwIGlzIHRoZSBoZWlnaHQ7XG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLnBvcHVwRGl2Lmh0bWwpO1xuICAgICAgICAgIHRoaXMucG9wdXBEaXYuaGlkZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzNC5wb3B1cERpdi5odG1sLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgICAgIH0sIDE1MDApO1xuICAgICAgICAgIHRoaXMucG9wdXBEaXYuZGVsZXRlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXM0Ll9yZW1vdmVQb3B1cCgpO1xuICAgICAgICAgIH0sIDE4MDApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogbWFrZSBhIGNoZWNrYm94IGZvciBib29sZWFuIG9wdGlvbnMuXG4gICAgICAgKiBAcGFyYW0gZGVmYXVsdFZhbHVlXG4gICAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgICAqIEBwYXJhbSBwYXRoXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfbWFrZUNoZWNrYm94JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZUNoZWNrYm94KGRlZmF1bHRWYWx1ZSwgdmFsdWUsIHBhdGgpIHtcbiAgICAgICAgdmFyIGNoZWNrYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgY2hlY2tib3gudHlwZSA9ICdjaGVja2JveCc7XG4gICAgICAgIGNoZWNrYm94LmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWNoZWNrYm94JztcbiAgICAgICAgY2hlY2tib3guY2hlY2tlZCA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjaGVja2JveC5jaGVja2VkID0gdmFsdWU7XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgIGlmICgodHlwZW9mIGRlZmF1bHRWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoZGVmYXVsdFZhbHVlKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gZGVmYXVsdFZhbHVlLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZWRPcHRpb25zLnB1c2goeyBwYXRoOiBwYXRoLCB2YWx1ZTogdmFsdWUgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuY2hhbmdlZE9wdGlvbnMucHVzaCh7IHBhdGg6IHBhdGgsIHZhbHVlOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBjaGVja2JveC5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBtZS5fdXBkYXRlKHRoaXMuY2hlY2tlZCwgcGF0aCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGxhYmVsID0gdGhpcy5fbWFrZUxhYmVsKHBhdGhbcGF0aC5sZW5ndGggLSAxXSwgcGF0aCk7XG4gICAgICAgIHRoaXMuX21ha2VJdGVtKHBhdGgsIGxhYmVsLCBjaGVja2JveCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogbWFrZSBhIHRleHQgaW5wdXQgZmllbGQgZm9yIHN0cmluZyBvcHRpb25zLlxuICAgICAgICogQHBhcmFtIGRlZmF1bHRWYWx1ZVxuICAgICAgICogQHBhcmFtIHZhbHVlXG4gICAgICAgKiBAcGFyYW0gcGF0aFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX21ha2VUZXh0SW5wdXQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlVGV4dElucHV0KGRlZmF1bHRWYWx1ZSwgdmFsdWUsIHBhdGgpIHtcbiAgICAgICAgdmFyIGNoZWNrYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgY2hlY2tib3gudHlwZSA9ICd0ZXh0JztcbiAgICAgICAgY2hlY2tib3guY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctdGV4dCc7XG4gICAgICAgIGNoZWNrYm94LnZhbHVlID0gdmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5jaGFuZ2VkT3B0aW9ucy5wdXNoKHsgcGF0aDogcGF0aCwgdmFsdWU6IHZhbHVlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgY2hlY2tib3gub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbWUuX3VwZGF0ZSh0aGlzLnZhbHVlLCBwYXRoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbGFiZWwgPSB0aGlzLl9tYWtlTGFiZWwocGF0aFtwYXRoLmxlbmd0aCAtIDFdLCBwYXRoKTtcbiAgICAgICAgdGhpcy5fbWFrZUl0ZW0ocGF0aCwgbGFiZWwsIGNoZWNrYm94KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBtYWtlIGEgY29sb3IgZmllbGQgd2l0aCBhIGNvbG9yIHBpY2tlciBmb3IgY29sb3IgZmllbGRzXG4gICAgICAgKiBAcGFyYW0gYXJyXG4gICAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgICAqIEBwYXJhbSBwYXRoXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfbWFrZUNvbG9yRmllbGQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlQ29sb3JGaWVsZChhcnIsIHZhbHVlLCBwYXRoKSB7XG4gICAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICAgIHZhciBkZWZhdWx0Q29sb3IgPSBhcnJbMV07XG4gICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdENvbG9yIDogdmFsdWU7XG5cbiAgICAgICAgaWYgKHZhbHVlICE9PSAnbm9uZScpIHtcbiAgICAgICAgICBkaXYuY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctY29sb3JCbG9jayc7XG4gICAgICAgICAgZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpdi5jbGFzc05hbWUgPSAndmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1jb2xvckJsb2NrIG5vbmUnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdENvbG9yIDogdmFsdWU7XG4gICAgICAgIGRpdi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzNS5fc2hvd0NvbG9yUGlja2VyKHZhbHVlLCBkaXYsIHBhdGgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBsYWJlbCA9IHRoaXMuX21ha2VMYWJlbChwYXRoW3BhdGgubGVuZ3RoIC0gMV0sIHBhdGgpO1xuICAgICAgICB0aGlzLl9tYWtlSXRlbShwYXRoLCBsYWJlbCwgZGl2KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiB1c2VkIGJ5IHRoZSBjb2xvciBidXR0b25zIHRvIGNhbGwgdGhlIGNvbG9yIHBpY2tlci5cbiAgICAgICAqIEBwYXJhbSBldmVudFxuICAgICAgICogQHBhcmFtIHZhbHVlXG4gICAgICAgKiBAcGFyYW0gZGl2XG4gICAgICAgKiBAcGFyYW0gcGF0aFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3Nob3dDb2xvclBpY2tlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3Nob3dDb2xvclBpY2tlcih2YWx1ZSwgZGl2LCBwYXRoKSB7XG4gICAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICAgIC8vIGNsZWFyIHRoZSBjYWxsYmFjayBmcm9tIHRoaXMgZGl2XG4gICAgICAgIGRpdi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAgICAgdGhpcy5jb2xvclBpY2tlci5pbnNlcnRUbyhkaXYpO1xuICAgICAgICB0aGlzLmNvbG9yUGlja2VyLnNob3coKTtcblxuICAgICAgICB0aGlzLmNvbG9yUGlja2VyLnNldENvbG9yKHZhbHVlKTtcbiAgICAgICAgdGhpcy5jb2xvclBpY2tlci5zZXRVcGRhdGVDYWxsYmFjayhmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgICB2YXIgY29sb3JTdHJpbmcgPSAncmdiYSgnICsgY29sb3IuciArICcsJyArIGNvbG9yLmcgKyAnLCcgKyBjb2xvci5iICsgJywnICsgY29sb3IuYSArICcpJztcbiAgICAgICAgICBkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29sb3JTdHJpbmc7XG4gICAgICAgICAgX3RoaXM2Ll91cGRhdGUoY29sb3JTdHJpbmcsIHBhdGgpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBvbiBjbG9zZSBvZiB0aGUgY29sb3JwaWNrZXIsIHJlc3RvcmUgdGhlIGNhbGxiYWNrLlxuICAgICAgICB0aGlzLmNvbG9yUGlja2VyLnNldENsb3NlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRpdi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXM2Ll9zaG93Q29sb3JQaWNrZXIodmFsdWUsIGRpdiwgcGF0aCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogcGFyc2UgYW4gb2JqZWN0IGFuZCBkcmF3IHRoZSBjb3JyZWN0IGl0ZW1zXG4gICAgICAgKiBAcGFyYW0gb2JqXG4gICAgICAgKiBAcGFyYW0gcGF0aFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2hhbmRsZU9iamVjdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZU9iamVjdChvYmopIHtcbiAgICAgICAgdmFyIHBhdGggPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBbXSA6IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdmFyIGNoZWNrT25seSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogYXJndW1lbnRzWzJdO1xuXG4gICAgICAgIHZhciBzaG93ID0gZmFsc2U7XG4gICAgICAgIHZhciBmaWx0ZXIgPSB0aGlzLm9wdGlvbnMuZmlsdGVyO1xuICAgICAgICB2YXIgdmlzaWJsZUluU2V0ID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIHN1Yk9iaiBpbiBvYmopIHtcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHN1Yk9iaikpIHtcbiAgICAgICAgICAgIHNob3cgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBvYmpbc3ViT2JqXTtcbiAgICAgICAgICAgIHZhciBuZXdQYXRoID0gdXRpbC5jb3B5QW5kRXh0ZW5kQXJyYXkocGF0aCwgc3ViT2JqKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmlsdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHNob3cgPSBmaWx0ZXIoc3ViT2JqLCBwYXRoKTtcblxuICAgICAgICAgICAgICAvLyBpZiBuZWVkZWQgd2UgbXVzdCBnbyBkZWVwZXIgaW50byB0aGUgb2JqZWN0LlxuICAgICAgICAgICAgICBpZiAoc2hvdyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShpdGVtIGluc3RhbmNlb2YgQXJyYXkpICYmIHR5cGVvZiBpdGVtICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgaXRlbSAhPT0gJ2Jvb2xlYW4nICYmIGl0ZW0gaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuYWxsb3dDcmVhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgc2hvdyA9IHRoaXMuX2hhbmRsZU9iamVjdChpdGVtLCBuZXdQYXRoLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuYWxsb3dDcmVhdGlvbiA9IGNoZWNrT25seSA9PT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzaG93ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICB2aXNpYmxlSW5TZXQgPSB0cnVlO1xuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9nZXRWYWx1ZShuZXdQYXRoKTtcblxuICAgICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlQXJyYXkoaXRlbSwgdmFsdWUsIG5ld1BhdGgpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX21ha2VUZXh0SW5wdXQoaXRlbSwgdmFsdWUsIG5ld1BhdGgpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpdGVtID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYWtlQ2hlY2tib3goaXRlbSwgdmFsdWUsIG5ld1BhdGgpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0gaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAvLyBjb2xsYXBzZSB0aGUgcGh5c2ljcyBvcHRpb25zIHRoYXQgYXJlIG5vdCBlbmFibGVkXG4gICAgICAgICAgICAgICAgdmFyIGRyYXcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChwYXRoLmluZGV4T2YoJ3BoeXNpY3MnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1vZHVsZU9wdGlvbnMucGh5c2ljcy5zb2x2ZXIgIT09IHN1Yk9iaikge1xuICAgICAgICAgICAgICAgICAgICBkcmF3ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGRyYXcgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGluaXRpYWxseSBjb2xsYXBzZSBvcHRpb25zIHdpdGggYW4gZGlzYWJsZWQgZW5hYmxlZCBvcHRpb24uXG4gICAgICAgICAgICAgICAgICBpZiAoaXRlbS5lbmFibGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuYWJsZWRQYXRoID0gdXRpbC5jb3B5QW5kRXh0ZW5kQXJyYXkobmV3UGF0aCwgJ2VuYWJsZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuYWJsZWRWYWx1ZSA9IHRoaXMuX2dldFZhbHVlKGVuYWJsZWRQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuYWJsZWRWYWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBsYWJlbCA9IHRoaXMuX21ha2VMYWJlbChzdWJPYmosIG5ld1BhdGgsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21ha2VJdGVtKG5ld1BhdGgsIGxhYmVsKTtcbiAgICAgICAgICAgICAgICAgICAgICB2aXNpYmxlSW5TZXQgPSB0aGlzLl9oYW5kbGVPYmplY3QoaXRlbSwgbmV3UGF0aCkgfHwgdmlzaWJsZUluU2V0O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21ha2VDaGVja2JveChpdGVtLCBlbmFibGVkVmFsdWUsIG5ld1BhdGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2xhYmVsID0gdGhpcy5fbWFrZUxhYmVsKHN1Yk9iaiwgbmV3UGF0aCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21ha2VJdGVtKG5ld1BhdGgsIF9sYWJlbCk7XG4gICAgICAgICAgICAgICAgICAgIHZpc2libGVJblNldCA9IHRoaXMuX2hhbmRsZU9iamVjdChpdGVtLCBuZXdQYXRoKSB8fCB2aXNpYmxlSW5TZXQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2RvbnQga25vdyBob3cgdG8gaGFuZGxlJywgaXRlbSwgc3ViT2JqLCBuZXdQYXRoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlzaWJsZUluU2V0O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGhhbmRsZSB0aGUgYXJyYXkgdHlwZSBvZiBvcHRpb25cbiAgICAgICAqIEBwYXJhbSBvcHRpb25OYW1lXG4gICAgICAgKiBAcGFyYW0gYXJyXG4gICAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgICAqIEBwYXJhbSBwYXRoXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfaGFuZGxlQXJyYXknLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVBcnJheShhcnIsIHZhbHVlLCBwYXRoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYXJyWzBdID09PSAnc3RyaW5nJyAmJiBhcnJbMF0gPT09ICdjb2xvcicpIHtcbiAgICAgICAgICB0aGlzLl9tYWtlQ29sb3JGaWVsZChhcnIsIHZhbHVlLCBwYXRoKTtcbiAgICAgICAgICBpZiAoYXJyWzFdICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VkT3B0aW9ucy5wdXNoKHsgcGF0aDogcGF0aCwgdmFsdWU6IHZhbHVlIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJyWzBdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuX21ha2VEcm9wZG93bihhcnIsIHZhbHVlLCBwYXRoKTtcbiAgICAgICAgICBpZiAoYXJyWzBdICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VkT3B0aW9ucy5wdXNoKHsgcGF0aDogcGF0aCwgdmFsdWU6IHZhbHVlIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJyWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRoaXMuX21ha2VSYW5nZShhcnIsIHZhbHVlLCBwYXRoKTtcbiAgICAgICAgICBpZiAoYXJyWzBdICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VkT3B0aW9ucy5wdXNoKHsgcGF0aDogcGF0aCwgdmFsdWU6IE51bWJlcih2YWx1ZSkgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogY2FsbGVkIHRvIHVwZGF0ZSB0aGUgbmV0d29yayB3aXRoIHRoZSBuZXcgc2V0dGluZ3MuXG4gICAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgICAqIEBwYXJhbSBwYXRoXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfdXBkYXRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlKHZhbHVlLCBwYXRoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5fY29uc3RydWN0T3B0aW9ucyh2YWx1ZSwgcGF0aCk7XG5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50LmJvZHkgJiYgdGhpcy5wYXJlbnQuYm9keS5lbWl0dGVyICYmIHRoaXMucGFyZW50LmJvZHkuZW1pdHRlci5lbWl0KSB7XG4gICAgICAgICAgdGhpcy5wYXJlbnQuYm9keS5lbWl0dGVyLmVtaXQoXCJjb25maWdDaGFuZ2VcIiwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIHRoaXMucGFyZW50LnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2NvbnN0cnVjdE9wdGlvbnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jb25zdHJ1Y3RPcHRpb25zKHZhbHVlLCBwYXRoKSB7XG4gICAgICAgIHZhciBvcHRpb25zT2JqID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMl07XG5cbiAgICAgICAgdmFyIHBvaW50ZXIgPSBvcHRpb25zT2JqO1xuXG4gICAgICAgIC8vIHdoZW4gZHJvcGRvd24gYm94ZXMgY2FuIGJlIHN0cmluZyBvciBib29sZWFuLCB3ZSB0eXBlY2FzdCBpdCBpbnRvIGNvcnJlY3QgdHlwZXNcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gJ3RydWUnID8gdHJ1ZSA6IHZhbHVlO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlID09PSAnZmFsc2UnID8gZmFsc2UgOiB2YWx1ZTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAocGF0aFtpXSAhPT0gJ2dsb2JhbCcpIHtcbiAgICAgICAgICAgIGlmIChwb2ludGVyW3BhdGhbaV1dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcG9pbnRlcltwYXRoW2ldXSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgIT09IHBhdGgubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICBwb2ludGVyID0gcG9pbnRlcltwYXRoW2ldXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBvaW50ZXJbcGF0aFtpXV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdGlvbnNPYmo7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX3ByaW50T3B0aW9ucycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3ByaW50T3B0aW9ucygpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmdldE9wdGlvbnMoKTtcbiAgICAgICAgdGhpcy5vcHRpb25zQ29udGFpbmVyLmlubmVySFRNTCA9ICc8cHJlPnZhciBvcHRpb25zID0gJyArIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMsIG51bGwsIDIpICsgJzwvcHJlPic7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0T3B0aW9ucycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T3B0aW9ucygpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoYW5nZWRPcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5fY29uc3RydWN0T3B0aW9ucyh0aGlzLmNoYW5nZWRPcHRpb25zW2ldLnZhbHVlLCB0aGlzLmNoYW5nZWRPcHRpb25zW2ldLnBhdGgsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBDb25maWd1cmF0b3I7XG4gIH0oKTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBDb25maWd1cmF0b3I7XG5cbi8qKiovIH0sXG4vKiAyNyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICB2YXIgSGFtbWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG4gIHZhciBoYW1tZXJVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuICB2YXIgQ29sb3JQaWNrZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29sb3JQaWNrZXIoKSB7XG4gICAgICB2YXIgcGl4ZWxSYXRpbyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IDEgOiBhcmd1bWVudHNbMF07XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb2xvclBpY2tlcik7XG5cbiAgICAgIHRoaXMucGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG4gICAgICB0aGlzLmdlbmVyYXRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5jZW50ZXJDb29yZGluYXRlcyA9IHsgeDogMjg5IC8gMiwgeTogMjg5IC8gMiB9O1xuICAgICAgdGhpcy5yID0gMjg5ICogMC40OTtcbiAgICAgIHRoaXMuY29sb3IgPSB7IHI6IDI1NSwgZzogMjU1LCBiOiAyNTUsIGE6IDEuMCB9O1xuICAgICAgdGhpcy5odWVDaXJjbGUgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmluaXRpYWxDb2xvciA9IHsgcjogMjU1LCBnOiAyNTUsIGI6IDI1NSwgYTogMS4wIH07XG4gICAgICB0aGlzLnByZXZpb3VzQ29sb3IgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmFwcGxpZWQgPSBmYWxzZTtcblxuICAgICAgLy8gYm91bmQgYnlcbiAgICAgIHRoaXMudXBkYXRlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgIHRoaXMuY2xvc2VDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgICAvLyBjcmVhdGUgYWxsIERPTSBlbGVtZW50c1xuICAgICAgdGhpcy5fY3JlYXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdGhpcyBpbnNlcnRzIHRoZSBjb2xvclBpY2tlciBpbnRvIGEgZGl2IGZyb20gdGhlIERPTVxuICAgICAqIEBwYXJhbSBjb250YWluZXJcbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKENvbG9yUGlja2VyLCBbe1xuICAgICAga2V5OiAnaW5zZXJ0VG8nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydFRvKGNvbnRhaW5lcikge1xuICAgICAgICBpZiAodGhpcy5oYW1tZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuaGFtbWVyLmRlc3Ryb3koKTtcbiAgICAgICAgICB0aGlzLmhhbW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5mcmFtZSk7XG4gICAgICAgIHRoaXMuX2JpbmRIYW1tZXIoKTtcblxuICAgICAgICB0aGlzLl9zZXRTaXplKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogdGhlIGNhbGxiYWNrIGlzIGV4ZWN1dGVkIG9uIGFwcGx5IGFuZCBzYXZlLiBCaW5kIGl0IHRvIHRoZSBhcHBsaWNhdGlvblxuICAgICAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NldFVwZGF0ZUNhbGxiYWNrJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRVcGRhdGVDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIGF0dGVtcHRlZCB0byBzZXQgYXMgY29sb3JQaWNrZXIgdXBkYXRlIGNhbGxiYWNrIGlzIG5vdCBhIGZ1bmN0aW9uLlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHRoZSBjYWxsYmFjayBpcyBleGVjdXRlZCBvbiBhcHBseSBhbmQgc2F2ZS4gQmluZCBpdCB0byB0aGUgYXBwbGljYXRpb25cbiAgICAgICAqIEBwYXJhbSBjYWxsYmFja1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzZXRDbG9zZUNhbGxiYWNrJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDbG9zZUNhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzLmNsb3NlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBhdHRlbXB0ZWQgdG8gc2V0IGFzIGNvbG9yUGlja2VyIGNsb3NpbmcgY2FsbGJhY2sgaXMgbm90IGEgZnVuY3Rpb24uXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2lzQ29sb3JTdHJpbmcnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pc0NvbG9yU3RyaW5nKGNvbG9yKSB7XG4gICAgICAgIHZhciBodG1sQ29sb3JzID0geyBibGFjazogJyMwMDAwMDAnLCBuYXZ5OiAnIzAwMDA4MCcsIGRhcmtibHVlOiAnIzAwMDA4QicsIG1lZGl1bWJsdWU6ICcjMDAwMENEJywgYmx1ZTogJyMwMDAwRkYnLCBkYXJrZ3JlZW46ICcjMDA2NDAwJywgZ3JlZW46ICcjMDA4MDAwJywgdGVhbDogJyMwMDgwODAnLCBkYXJrY3lhbjogJyMwMDhCOEInLCBkZWVwc2t5Ymx1ZTogJyMwMEJGRkYnLCBkYXJrdHVycXVvaXNlOiAnIzAwQ0VEMScsIG1lZGl1bXNwcmluZ2dyZWVuOiAnIzAwRkE5QScsIGxpbWU6ICcjMDBGRjAwJywgc3ByaW5nZ3JlZW46ICcjMDBGRjdGJywgYXF1YTogJyMwMEZGRkYnLCBjeWFuOiAnIzAwRkZGRicsIG1pZG5pZ2h0Ymx1ZTogJyMxOTE5NzAnLCBkb2RnZXJibHVlOiAnIzFFOTBGRicsIGxpZ2h0c2VhZ3JlZW46ICcjMjBCMkFBJywgZm9yZXN0Z3JlZW46ICcjMjI4QjIyJywgc2VhZ3JlZW46ICcjMkU4QjU3JywgZGFya3NsYXRlZ3JheTogJyMyRjRGNEYnLCBsaW1lZ3JlZW46ICcjMzJDRDMyJywgbWVkaXVtc2VhZ3JlZW46ICcjM0NCMzcxJywgdHVycXVvaXNlOiAnIzQwRTBEMCcsIHJveWFsYmx1ZTogJyM0MTY5RTEnLCBzdGVlbGJsdWU6ICcjNDY4MkI0JywgZGFya3NsYXRlYmx1ZTogJyM0ODNEOEInLCBtZWRpdW10dXJxdW9pc2U6ICcjNDhEMUNDJywgaW5kaWdvOiAnIzRCMDA4MicsIGRhcmtvbGl2ZWdyZWVuOiAnIzU1NkIyRicsIGNhZGV0Ymx1ZTogJyM1RjlFQTAnLCBjb3JuZmxvd2VyYmx1ZTogJyM2NDk1RUQnLCBtZWRpdW1hcXVhbWFyaW5lOiAnIzY2Q0RBQScsIGRpbWdyYXk6ICcjNjk2OTY5Jywgc2xhdGVibHVlOiAnIzZBNUFDRCcsIG9saXZlZHJhYjogJyM2QjhFMjMnLCBzbGF0ZWdyYXk6ICcjNzA4MDkwJywgbGlnaHRzbGF0ZWdyYXk6ICcjNzc4ODk5JywgbWVkaXVtc2xhdGVibHVlOiAnIzdCNjhFRScsIGxhd25ncmVlbjogJyM3Q0ZDMDAnLCBjaGFydHJldXNlOiAnIzdGRkYwMCcsIGFxdWFtYXJpbmU6ICcjN0ZGRkQ0JywgbWFyb29uOiAnIzgwMDAwMCcsIHB1cnBsZTogJyM4MDAwODAnLCBvbGl2ZTogJyM4MDgwMDAnLCBncmF5OiAnIzgwODA4MCcsIHNreWJsdWU6ICcjODdDRUVCJywgbGlnaHRza3libHVlOiAnIzg3Q0VGQScsIGJsdWV2aW9sZXQ6ICcjOEEyQkUyJywgZGFya3JlZDogJyM4QjAwMDAnLCBkYXJrbWFnZW50YTogJyM4QjAwOEInLCBzYWRkbGVicm93bjogJyM4QjQ1MTMnLCBkYXJrc2VhZ3JlZW46ICcjOEZCQzhGJywgbGlnaHRncmVlbjogJyM5MEVFOTAnLCBtZWRpdW1wdXJwbGU6ICcjOTM3MEQ4JywgZGFya3Zpb2xldDogJyM5NDAwRDMnLCBwYWxlZ3JlZW46ICcjOThGQjk4JywgZGFya29yY2hpZDogJyM5OTMyQ0MnLCB5ZWxsb3dncmVlbjogJyM5QUNEMzInLCBzaWVubmE6ICcjQTA1MjJEJywgYnJvd246ICcjQTUyQTJBJywgZGFya2dyYXk6ICcjQTlBOUE5JywgbGlnaHRibHVlOiAnI0FERDhFNicsIGdyZWVueWVsbG93OiAnI0FERkYyRicsIHBhbGV0dXJxdW9pc2U6ICcjQUZFRUVFJywgbGlnaHRzdGVlbGJsdWU6ICcjQjBDNERFJywgcG93ZGVyYmx1ZTogJyNCMEUwRTYnLCBmaXJlYnJpY2s6ICcjQjIyMjIyJywgZGFya2dvbGRlbnJvZDogJyNCODg2MEInLCBtZWRpdW1vcmNoaWQ6ICcjQkE1NUQzJywgcm9zeWJyb3duOiAnI0JDOEY4RicsIGRhcmtraGFraTogJyNCREI3NkInLCBzaWx2ZXI6ICcjQzBDMEMwJywgbWVkaXVtdmlvbGV0cmVkOiAnI0M3MTU4NScsIGluZGlhbnJlZDogJyNDRDVDNUMnLCBwZXJ1OiAnI0NEODUzRicsIGNob2NvbGF0ZTogJyNEMjY5MUUnLCB0YW46ICcjRDJCNDhDJywgbGlnaHRncmV5OiAnI0QzRDNEMycsIHBhbGV2aW9sZXRyZWQ6ICcjRDg3MDkzJywgdGhpc3RsZTogJyNEOEJGRDgnLCBvcmNoaWQ6ICcjREE3MEQ2JywgZ29sZGVucm9kOiAnI0RBQTUyMCcsIGNyaW1zb246ICcjREMxNDNDJywgZ2FpbnNib3JvOiAnI0RDRENEQycsIHBsdW06ICcjRERBMEREJywgYnVybHl3b29kOiAnI0RFQjg4NycsIGxpZ2h0Y3lhbjogJyNFMEZGRkYnLCBsYXZlbmRlcjogJyNFNkU2RkEnLCBkYXJrc2FsbW9uOiAnI0U5OTY3QScsIHZpb2xldDogJyNFRTgyRUUnLCBwYWxlZ29sZGVucm9kOiAnI0VFRThBQScsIGxpZ2h0Y29yYWw6ICcjRjA4MDgwJywga2hha2k6ICcjRjBFNjhDJywgYWxpY2VibHVlOiAnI0YwRjhGRicsIGhvbmV5ZGV3OiAnI0YwRkZGMCcsIGF6dXJlOiAnI0YwRkZGRicsIHNhbmR5YnJvd246ICcjRjRBNDYwJywgd2hlYXQ6ICcjRjVERUIzJywgYmVpZ2U6ICcjRjVGNURDJywgd2hpdGVzbW9rZTogJyNGNUY1RjUnLCBtaW50Y3JlYW06ICcjRjVGRkZBJywgZ2hvc3R3aGl0ZTogJyNGOEY4RkYnLCBzYWxtb246ICcjRkE4MDcyJywgYW50aXF1ZXdoaXRlOiAnI0ZBRUJENycsIGxpbmVuOiAnI0ZBRjBFNicsIGxpZ2h0Z29sZGVucm9keWVsbG93OiAnI0ZBRkFEMicsIG9sZGxhY2U6ICcjRkRGNUU2JywgcmVkOiAnI0ZGMDAwMCcsIGZ1Y2hzaWE6ICcjRkYwMEZGJywgbWFnZW50YTogJyNGRjAwRkYnLCBkZWVwcGluazogJyNGRjE0OTMnLCBvcmFuZ2VyZWQ6ICcjRkY0NTAwJywgdG9tYXRvOiAnI0ZGNjM0NycsIGhvdHBpbms6ICcjRkY2OUI0JywgY29yYWw6ICcjRkY3RjUwJywgZGFya29yYW5nZTogJyNGRjhDMDAnLCBsaWdodHNhbG1vbjogJyNGRkEwN0EnLCBvcmFuZ2U6ICcjRkZBNTAwJywgbGlnaHRwaW5rOiAnI0ZGQjZDMScsIHBpbms6ICcjRkZDMENCJywgZ29sZDogJyNGRkQ3MDAnLCBwZWFjaHB1ZmY6ICcjRkZEQUI5JywgbmF2YWpvd2hpdGU6ICcjRkZERUFEJywgbW9jY2FzaW46ICcjRkZFNEI1JywgYmlzcXVlOiAnI0ZGRTRDNCcsIG1pc3R5cm9zZTogJyNGRkU0RTEnLCBibGFuY2hlZGFsbW9uZDogJyNGRkVCQ0QnLCBwYXBheWF3aGlwOiAnI0ZGRUZENScsIGxhdmVuZGVyYmx1c2g6ICcjRkZGMEY1Jywgc2Vhc2hlbGw6ICcjRkZGNUVFJywgY29ybnNpbGs6ICcjRkZGOERDJywgbGVtb25jaGlmZm9uOiAnI0ZGRkFDRCcsIGZsb3JhbHdoaXRlOiAnI0ZGRkFGMCcsIHNub3c6ICcjRkZGQUZBJywgeWVsbG93OiAnI0ZGRkYwMCcsIGxpZ2h0eWVsbG93OiAnI0ZGRkZFMCcsIGl2b3J5OiAnI0ZGRkZGMCcsIHdoaXRlOiAnI0ZGRkZGRicgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm4gaHRtbENvbG9yc1tjb2xvcl07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXQgdGhlIGNvbG9yIG9mIHRoZSBjb2xvclBpY2tlclxuICAgICAgICogU3VwcG9ydGVkIGZvcm1hdHM6XG4gICAgICAgKiAncmVkJyAgICAgICAgICAgICAgICAgICAtLT4gSFRNTCBjb2xvciBzdHJpbmdcbiAgICAgICAqICcjZmZmZmZmJyAgICAgICAgICAgICAgIC0tPiBoZXggc3RyaW5nXG4gICAgICAgKiAncmJnKDI1NSwyNTUsMjU1KScgICAgICAtLT4gcmdiIHN0cmluZ1xuICAgICAgICogJ3JnYmEoMjU1LDI1NSwyNTUsMS4wKScgLS0+IHJnYmEgc3RyaW5nXG4gICAgICAgKiB7cjoyNTUsZzoyNTUsYjoyNTV9ICAgICAtLT4gcmdiIG9iamVjdFxuICAgICAgICoge3I6MjU1LGc6MjU1LGI6MjU1LGE6MS4wfSAtLT4gcmdiYSBvYmplY3RcbiAgICAgICAqIEBwYXJhbSBjb2xvclxuICAgICAgICogQHBhcmFtIHNldEluaXRpYWxcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc2V0Q29sb3InLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldENvbG9yKGNvbG9yKSB7XG4gICAgICAgIHZhciBzZXRJbml0aWFsID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICBpZiAoY29sb3IgPT09ICdub25lJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZ2JhID0gdm9pZCAwO1xuXG4gICAgICAgIC8vIGlmIGEgaHRtbCBjb2xvciBzaG9ydGhhbmQgaXMgdXNlZCwgY29udmVydCB0byBoZXhcbiAgICAgICAgdmFyIGh0bWxDb2xvciA9IHRoaXMuX2lzQ29sb3JTdHJpbmcoY29sb3IpO1xuICAgICAgICBpZiAoaHRtbENvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb2xvciA9IGh0bWxDb2xvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGZvcm1hdFxuICAgICAgICBpZiAodXRpbC5pc1N0cmluZyhjb2xvcikgPT09IHRydWUpIHtcbiAgICAgICAgICBpZiAodXRpbC5pc1ZhbGlkUkdCKGNvbG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIHJnYmFBcnJheSA9IGNvbG9yLnN1YnN0cig0KS5zdWJzdHIoMCwgY29sb3IubGVuZ3RoIC0gNSkuc3BsaXQoJywnKTtcbiAgICAgICAgICAgIHJnYmEgPSB7IHI6IHJnYmFBcnJheVswXSwgZzogcmdiYUFycmF5WzFdLCBiOiByZ2JhQXJyYXlbMl0sIGE6IDEuMCB9O1xuICAgICAgICAgIH0gZWxzZSBpZiAodXRpbC5pc1ZhbGlkUkdCQShjb2xvcikgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBfcmdiYUFycmF5ID0gY29sb3Iuc3Vic3RyKDUpLnN1YnN0cigwLCBjb2xvci5sZW5ndGggLSA2KS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgcmdiYSA9IHsgcjogX3JnYmFBcnJheVswXSwgZzogX3JnYmFBcnJheVsxXSwgYjogX3JnYmFBcnJheVsyXSwgYTogX3JnYmFBcnJheVszXSB9O1xuICAgICAgICAgIH0gZWxzZSBpZiAodXRpbC5pc1ZhbGlkSGV4KGNvbG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIHJnYk9iaiA9IHV0aWwuaGV4VG9SR0IoY29sb3IpO1xuICAgICAgICAgICAgcmdiYSA9IHsgcjogcmdiT2JqLnIsIGc6IHJnYk9iai5nLCBiOiByZ2JPYmouYiwgYTogMS4wIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjb2xvciBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgICAgaWYgKGNvbG9yLnIgIT09IHVuZGVmaW5lZCAmJiBjb2xvci5nICE9PSB1bmRlZmluZWQgJiYgY29sb3IuYiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHZhciBhbHBoYSA9IGNvbG9yLmEgIT09IHVuZGVmaW5lZCA/IGNvbG9yLmEgOiAnMS4wJztcbiAgICAgICAgICAgICAgcmdiYSA9IHsgcjogY29sb3IuciwgZzogY29sb3IuZywgYjogY29sb3IuYiwgYTogYWxwaGEgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgY29sb3JcbiAgICAgICAgaWYgKHJnYmEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gY29sb3IgcGFzc2VkIHRvIHRoZSBjb2xvclBpY2tlci4gU3VwcG9ydGVkIGFyZSBzdHJpbmdzOiByZ2IsIGhleCwgcmdiYS4gT2JqZWN0OiByZ2IgKHtyOnIsZzpnLGI6YixbYTphXX0pLiBTdXBwbGllZDogXCIgKyBKU09OLnN0cmluZ2lmeShjb2xvcikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3NldENvbG9yKHJnYmEsIHNldEluaXRpYWwpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogdGhpcyBzaG93cyB0aGUgY29sb3IgcGlja2VyLlxuICAgICAgICogVGhlIGh1ZSBjaXJjbGUgaXMgY29uc3RydWN0ZWQgb25jZSBhbmQgc3RvcmVkLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzaG93JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgICBpZiAodGhpcy5jbG9zZUNhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmNsb3NlQ2FsbGJhY2soKTtcbiAgICAgICAgICB0aGlzLmNsb3NlQ2FsbGJhY2sgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFwcGxpZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5mcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgdGhpcy5fZ2VuZXJhdGVIdWVDaXJjbGUoKTtcbiAgICAgIH1cblxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFBSSVZBVEUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuICAgICAgLyoqXG4gICAgICAgKiBIaWRlIHRoZSBwaWNrZXIuIElzIGNhbGxlZCBieSB0aGUgY2FuY2VsIGJ1dHRvbi5cbiAgICAgICAqIE9wdGlvbmFsIGJvb2xlYW4gdG8gc3RvcmUgdGhlIHByZXZpb3VzIGNvbG9yIGZvciBlYXN5IGFjY2VzcyBsYXRlciBvbi5cbiAgICAgICAqIEBwYXJhbSBzdG9yZVByZXZpb3VzXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfaGlkZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hpZGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHN0b3JlUHJldmlvdXMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB0cnVlIDogYXJndW1lbnRzWzBdO1xuXG4gICAgICAgIC8vIHN0b3JlIHRoZSBwcmV2aW91cyBjb2xvciBmb3IgbmV4dCB0aW1lO1xuICAgICAgICBpZiAoc3RvcmVQcmV2aW91cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMucHJldmlvdXNDb2xvciA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLmNvbG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmFwcGxpZWQgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUNhbGxiYWNrKHRoaXMuaW5pdGlhbENvbG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgICAgICAvLyBjYWxsIHRoZSBjbG9zaW5nIGNhbGxiYWNrLCByZXN0b3JpbmcgdGhlIG9uY2xpY2sgbWV0aG9kLlxuICAgICAgICAvLyB0aGlzIGlzIGluIGEgc2V0VGltZW91dCBiZWNhdXNlIGl0IHdpbGwgdHJpZ2dlciB0aGUgc2hvdyBhZ2FpbiBiZWZvcmUgdGhlIGNsaWNrIGlzIGRvbmUuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChfdGhpcy5jbG9zZUNhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIF90aGlzLmNsb3NlQ2FsbGJhY2soKTtcbiAgICAgICAgICAgIF90aGlzLmNsb3NlQ2FsbGJhY2sgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBib3VuZCB0byB0aGUgc2F2ZSBidXR0b24uIFNhdmVzIGFuZCBoaWRlcy5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19zYXZlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2F2ZSgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVDYWxsYmFjayh0aGlzLmNvbG9yKTtcbiAgICAgICAgdGhpcy5hcHBsaWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2hpZGUoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBCb3VuZCB0byBhcHBseSBidXR0b24uIFNhdmVzIGJ1dCBkb2VzIG5vdCBjbG9zZS4gSXMgdW5kb25lIGJ5IHRoZSBjYW5jZWwgYnV0dG9uLlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2FwcGx5JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYXBwbHkoKSB7XG4gICAgICAgIHRoaXMuYXBwbGllZCA9IHRydWU7XG4gICAgICAgIHRoaXMudXBkYXRlQ2FsbGJhY2sodGhpcy5jb2xvcik7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVBpY2tlcih0aGlzLmNvbG9yKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBsb2FkIHRoZSBjb2xvciBmcm9tIHRoZSBwcmV2aW91cyBzZXNzaW9uLlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2xvYWRMYXN0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbG9hZExhc3QoKSB7XG4gICAgICAgIGlmICh0aGlzLnByZXZpb3VzQ29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuc2V0Q29sb3IodGhpcy5wcmV2aW91c0NvbG9yLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWxlcnQoXCJUaGVyZSBpcyBubyBsYXN0IGNvbG9yIHRvIGxvYWQuLi5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBzZXQgdGhlIGNvbG9yLCBwbGFjZSB0aGUgcGlja2VyXG4gICAgICAgKiBAcGFyYW0gcmdiYVxuICAgICAgICogQHBhcmFtIHNldEluaXRpYWxcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19zZXRDb2xvcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldENvbG9yKHJnYmEpIHtcbiAgICAgICAgdmFyIHNldEluaXRpYWwgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB0cnVlIDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgIC8vIHN0b3JlIHRoZSBpbml0aWFsIGNvbG9yXG4gICAgICAgIGlmIChzZXRJbml0aWFsID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5pbml0aWFsQ29sb3IgPSB1dGlsLmV4dGVuZCh7fSwgcmdiYSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbG9yID0gcmdiYTtcbiAgICAgICAgdmFyIGhzdiA9IHV0aWwuUkdCVG9IU1YocmdiYS5yLCByZ2JhLmcsIHJnYmEuYik7XG5cbiAgICAgICAgdmFyIGFuZ2xlQ29udmVydCA9IDIgKiBNYXRoLlBJO1xuICAgICAgICB2YXIgcmFkaXVzID0gdGhpcy5yICogaHN2LnM7XG4gICAgICAgIHZhciB4ID0gdGhpcy5jZW50ZXJDb29yZGluYXRlcy54ICsgcmFkaXVzICogTWF0aC5zaW4oYW5nbGVDb252ZXJ0ICogaHN2LmgpO1xuICAgICAgICB2YXIgeSA9IHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueSArIHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlQ29udmVydCAqIGhzdi5oKTtcblxuICAgICAgICB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3Iuc3R5bGUubGVmdCA9IHggLSAwLjUgKiB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3IuY2xpZW50V2lkdGggKyAncHgnO1xuICAgICAgICB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3Iuc3R5bGUudG9wID0geSAtIDAuNSAqIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5jbGllbnRIZWlnaHQgKyAncHgnO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZVBpY2tlcihyZ2JhKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBib3VuZCB0byBvcGFjaXR5IGNvbnRyb2xcbiAgICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3NldE9wYWNpdHknLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRPcGFjaXR5KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY29sb3IuYSA9IHZhbHVlIC8gMTAwO1xuICAgICAgICB0aGlzLl91cGRhdGVQaWNrZXIodGhpcy5jb2xvcik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogYm91bmQgdG8gYnJpZ2h0bmVzcyBjb250cm9sXG4gICAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19zZXRCcmlnaHRuZXNzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0QnJpZ2h0bmVzcyh2YWx1ZSkge1xuICAgICAgICB2YXIgaHN2ID0gdXRpbC5SR0JUb0hTVih0aGlzLmNvbG9yLnIsIHRoaXMuY29sb3IuZywgdGhpcy5jb2xvci5iKTtcbiAgICAgICAgaHN2LnYgPSB2YWx1ZSAvIDEwMDtcbiAgICAgICAgdmFyIHJnYmEgPSB1dGlsLkhTVlRvUkdCKGhzdi5oLCBoc3YucywgaHN2LnYpO1xuICAgICAgICByZ2JhWydhJ10gPSB0aGlzLmNvbG9yLmE7XG4gICAgICAgIHRoaXMuY29sb3IgPSByZ2JhO1xuICAgICAgICB0aGlzLl91cGRhdGVQaWNrZXIoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiB1cGRhdGUgdGhlIGNvbG9yIHBpY2tlci4gQSBibGFjayBjaXJjbGUgb3ZlcmxheXMgdGhlIGh1ZSBjaXJjbGUgdG8gbWltaWMgdGhlIGJyaWdodG5lc3MgZGVjcmVhc2luZy5cbiAgICAgICAqIEBwYXJhbSByZ2JhXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfdXBkYXRlUGlja2VyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlUGlja2VyKCkge1xuICAgICAgICB2YXIgcmdiYSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHRoaXMuY29sb3IgOiBhcmd1bWVudHNbMF07XG5cbiAgICAgICAgdmFyIGhzdiA9IHV0aWwuUkdCVG9IU1YocmdiYS5yLCByZ2JhLmcsIHJnYmEuYik7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGlmICh0aGlzLnBpeGVsUmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnBpeGVsUmF0aW8gPSAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkgLyAoY3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnNldFRyYW5zZm9ybSh0aGlzLnBpeGVsUmF0aW8sIDAsIDAsIHRoaXMucGl4ZWxSYXRpbywgMCwgMCk7XG5cbiAgICAgICAgLy8gY2xlYXIgdGhlIGNhbnZhc1xuICAgICAgICB2YXIgdyA9IHRoaXMuY29sb3JQaWNrZXJDYW52YXMuY2xpZW50V2lkdGg7XG4gICAgICAgIHZhciBoID0gdGhpcy5jb2xvclBpY2tlckNhbnZhcy5jbGllbnRIZWlnaHQ7XG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdywgaCk7XG5cbiAgICAgICAgY3R4LnB1dEltYWdlRGF0YSh0aGlzLmh1ZUNpcmNsZSwgMCwgMCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSAncmdiYSgwLDAsMCwnICsgKDEgLSBoc3YudikgKyAnKSc7XG4gICAgICAgIGN0eC5jaXJjbGUodGhpcy5jZW50ZXJDb29yZGluYXRlcy54LCB0aGlzLmNlbnRlckNvb3JkaW5hdGVzLnksIHRoaXMucik7XG4gICAgICAgIGN0eC5maWxsKCk7XG5cbiAgICAgICAgdGhpcy5icmlnaHRuZXNzUmFuZ2UudmFsdWUgPSAxMDAgKiBoc3YudjtcbiAgICAgICAgdGhpcy5vcGFjaXR5UmFuZ2UudmFsdWUgPSAxMDAgKiByZ2JhLmE7XG5cbiAgICAgICAgdGhpcy5pbml0aWFsQ29sb3JEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoJyArIHRoaXMuaW5pdGlhbENvbG9yLnIgKyAnLCcgKyB0aGlzLmluaXRpYWxDb2xvci5nICsgJywnICsgdGhpcy5pbml0aWFsQ29sb3IuYiArICcsJyArIHRoaXMuaW5pdGlhbENvbG9yLmEgKyAnKSc7XG4gICAgICAgIHRoaXMubmV3Q29sb3JEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoJyArIHRoaXMuY29sb3IuciArICcsJyArIHRoaXMuY29sb3IuZyArICcsJyArIHRoaXMuY29sb3IuYiArICcsJyArIHRoaXMuY29sb3IuYSArICcpJztcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiB1c2VkIGJ5IGNyZWF0ZSB0byBzZXQgdGhlIHNpemUgb2YgdGhlIGNhbnZhcy5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19zZXRTaXplJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0U2l6ZSgpIHtcbiAgICAgICAgdGhpcy5jb2xvclBpY2tlckNhbnZhcy5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgICAgdGhpcy5jb2xvclBpY2tlckNhbnZhcy5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG5cbiAgICAgICAgdGhpcy5jb2xvclBpY2tlckNhbnZhcy53aWR0aCA9IDI4OSAqIHRoaXMucGl4ZWxSYXRpbztcbiAgICAgICAgdGhpcy5jb2xvclBpY2tlckNhbnZhcy5oZWlnaHQgPSAyODkgKiB0aGlzLnBpeGVsUmF0aW87XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogY3JlYXRlIGFsbCBkb20gZWxlbWVudHNcbiAgICAgICAqIFRPRE86IGNsZWFudXAsIGxvdHMgb2Ygc2ltaWxhciBkb20gZWxlbWVudHNcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19jcmVhdGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGUoKSB7XG4gICAgICAgIHRoaXMuZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5mcmFtZS5jbGFzc05hbWUgPSAndmlzLWNvbG9yLXBpY2tlcic7XG5cbiAgICAgICAgdGhpcy5jb2xvclBpY2tlckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLmNsYXNzTmFtZSA9ICd2aXMtc2VsZWN0b3InO1xuICAgICAgICB0aGlzLmNvbG9yUGlja2VyRGl2LmFwcGVuZENoaWxkKHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvcik7XG5cbiAgICAgICAgdGhpcy5jb2xvclBpY2tlckNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICB0aGlzLmNvbG9yUGlja2VyRGl2LmFwcGVuZENoaWxkKHRoaXMuY29sb3JQaWNrZXJDYW52YXMpO1xuXG4gICAgICAgIGlmICghdGhpcy5jb2xvclBpY2tlckNhbnZhcy5nZXRDb250ZXh0KSB7XG4gICAgICAgICAgdmFyIG5vQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XG4gICAgICAgICAgbm9DYW52YXMuc3R5bGUuY29sb3IgPSAncmVkJztcbiAgICAgICAgICBub0NhbnZhcy5zdHlsZS5mb250V2VpZ2h0ID0gJ2JvbGQnO1xuICAgICAgICAgIG5vQ2FudmFzLnN0eWxlLnBhZGRpbmcgPSAnMTBweCc7XG4gICAgICAgICAgbm9DYW52YXMuaW5uZXJIVE1MID0gJ0Vycm9yOiB5b3VyIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBIVE1MIGNhbnZhcyc7XG4gICAgICAgICAgdGhpcy5jb2xvclBpY2tlckNhbnZhcy5hcHBlbmRDaGlsZChub0NhbnZhcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGN0eCA9IHRoaXMuY29sb3JQaWNrZXJDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICAgIHRoaXMucGl4ZWxSYXRpbyA9ICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSAvIChjdHgud2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHguYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCAxKTtcblxuICAgICAgICAgIHRoaXMuY29sb3JQaWNrZXJDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLnNldFRyYW5zZm9ybSh0aGlzLnBpeGVsUmF0aW8sIDAsIDAsIHRoaXMucGl4ZWxSYXRpbywgMCwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbG9yUGlja2VyRGl2LmNsYXNzTmFtZSA9ICd2aXMtY29sb3InO1xuXG4gICAgICAgIHRoaXMub3BhY2l0eURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLm9wYWNpdHlEaXYuY2xhc3NOYW1lID0gJ3Zpcy1vcGFjaXR5JztcblxuICAgICAgICB0aGlzLmJyaWdodG5lc3NEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5icmlnaHRuZXNzRGl2LmNsYXNzTmFtZSA9ICd2aXMtYnJpZ2h0bmVzcyc7XG5cbiAgICAgICAgdGhpcy5hcnJvd0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmFycm93RGl2LmNsYXNzTmFtZSA9ICd2aXMtYXJyb3cnO1xuXG4gICAgICAgIHRoaXMub3BhY2l0eVJhbmdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLm9wYWNpdHlSYW5nZS50eXBlID0gJ3JhbmdlJzsgLy8gTm90IHN1cHBvcnRlZCBvbiBJRTlcbiAgICAgICAgICB0aGlzLm9wYWNpdHlSYW5nZS5taW4gPSAnMCc7XG4gICAgICAgICAgdGhpcy5vcGFjaXR5UmFuZ2UubWF4ID0gJzEwMCc7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgdGhpcy5vcGFjaXR5UmFuZ2UudmFsdWUgPSAnMTAwJztcbiAgICAgICAgdGhpcy5vcGFjaXR5UmFuZ2UuY2xhc3NOYW1lID0gJ3Zpcy1yYW5nZSc7XG5cbiAgICAgICAgdGhpcy5icmlnaHRuZXNzUmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlLnR5cGUgPSAncmFuZ2UnOyAvLyBOb3Qgc3VwcG9ydGVkIG9uIElFOVxuICAgICAgICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlLm1pbiA9ICcwJztcbiAgICAgICAgICB0aGlzLmJyaWdodG5lc3NSYW5nZS5tYXggPSAnMTAwJztcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICB0aGlzLmJyaWdodG5lc3NSYW5nZS52YWx1ZSA9ICcxMDAnO1xuICAgICAgICB0aGlzLmJyaWdodG5lc3NSYW5nZS5jbGFzc05hbWUgPSAndmlzLXJhbmdlJztcblxuICAgICAgICB0aGlzLm9wYWNpdHlEaXYuYXBwZW5kQ2hpbGQodGhpcy5vcGFjaXR5UmFuZ2UpO1xuICAgICAgICB0aGlzLmJyaWdodG5lc3NEaXYuYXBwZW5kQ2hpbGQodGhpcy5icmlnaHRuZXNzUmFuZ2UpO1xuXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHRoaXMub3BhY2l0eVJhbmdlLm9uY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG1lLl9zZXRPcGFjaXR5KHRoaXMudmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9wYWNpdHlSYW5nZS5vbmlucHV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG1lLl9zZXRPcGFjaXR5KHRoaXMudmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJyaWdodG5lc3NSYW5nZS5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBtZS5fc2V0QnJpZ2h0bmVzcyh0aGlzLnZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5icmlnaHRuZXNzUmFuZ2Uub25pbnB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBtZS5fc2V0QnJpZ2h0bmVzcyh0aGlzLnZhbHVlKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmJyaWdodG5lc3NMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuYnJpZ2h0bmVzc0xhYmVsLmNsYXNzTmFtZSA9IFwidmlzLWxhYmVsIHZpcy1icmlnaHRuZXNzXCI7XG4gICAgICAgIHRoaXMuYnJpZ2h0bmVzc0xhYmVsLmlubmVySFRNTCA9ICdicmlnaHRuZXNzOic7XG5cbiAgICAgICAgdGhpcy5vcGFjaXR5TGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLm9wYWNpdHlMYWJlbC5jbGFzc05hbWUgPSBcInZpcy1sYWJlbCB2aXMtb3BhY2l0eVwiO1xuICAgICAgICB0aGlzLm9wYWNpdHlMYWJlbC5pbm5lckhUTUwgPSAnb3BhY2l0eTonO1xuXG4gICAgICAgIHRoaXMubmV3Q29sb3JEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLm5ld0NvbG9yRGl2LmNsYXNzTmFtZSA9IFwidmlzLW5ldy1jb2xvclwiO1xuICAgICAgICB0aGlzLm5ld0NvbG9yRGl2LmlubmVySFRNTCA9ICduZXcnO1xuXG4gICAgICAgIHRoaXMuaW5pdGlhbENvbG9yRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5pbml0aWFsQ29sb3JEaXYuY2xhc3NOYW1lID0gXCJ2aXMtaW5pdGlhbC1jb2xvclwiO1xuICAgICAgICB0aGlzLmluaXRpYWxDb2xvckRpdi5pbm5lckhUTUwgPSAnaW5pdGlhbCc7XG5cbiAgICAgICAgdGhpcy5jYW5jZWxCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmNhbmNlbEJ1dHRvbi5jbGFzc05hbWUgPSBcInZpcy1idXR0b24gdmlzLWNhbmNlbFwiO1xuICAgICAgICB0aGlzLmNhbmNlbEJ1dHRvbi5pbm5lckhUTUwgPSAnY2FuY2VsJztcbiAgICAgICAgdGhpcy5jYW5jZWxCdXR0b24ub25jbGljayA9IHRoaXMuX2hpZGUuYmluZCh0aGlzLCBmYWxzZSk7XG5cbiAgICAgICAgdGhpcy5hcHBseUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuYXBwbHlCdXR0b24uY2xhc3NOYW1lID0gXCJ2aXMtYnV0dG9uIHZpcy1hcHBseVwiO1xuICAgICAgICB0aGlzLmFwcGx5QnV0dG9uLmlubmVySFRNTCA9ICdhcHBseSc7XG4gICAgICAgIHRoaXMuYXBwbHlCdXR0b24ub25jbGljayA9IHRoaXMuX2FwcGx5LmJpbmQodGhpcyk7XG5cbiAgICAgICAgdGhpcy5zYXZlQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5zYXZlQnV0dG9uLmNsYXNzTmFtZSA9IFwidmlzLWJ1dHRvbiB2aXMtc2F2ZVwiO1xuICAgICAgICB0aGlzLnNhdmVCdXR0b24uaW5uZXJIVE1MID0gJ3NhdmUnO1xuICAgICAgICB0aGlzLnNhdmVCdXR0b24ub25jbGljayA9IHRoaXMuX3NhdmUuYmluZCh0aGlzKTtcblxuICAgICAgICB0aGlzLmxvYWRCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmxvYWRCdXR0b24uY2xhc3NOYW1lID0gXCJ2aXMtYnV0dG9uIHZpcy1sb2FkXCI7XG4gICAgICAgIHRoaXMubG9hZEJ1dHRvbi5pbm5lckhUTUwgPSAnbG9hZCBsYXN0JztcbiAgICAgICAgdGhpcy5sb2FkQnV0dG9uLm9uY2xpY2sgPSB0aGlzLl9sb2FkTGFzdC5iaW5kKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5jb2xvclBpY2tlckRpdik7XG4gICAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5hcnJvd0Rpdik7XG4gICAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5icmlnaHRuZXNzTGFiZWwpO1xuICAgICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuYnJpZ2h0bmVzc0Rpdik7XG4gICAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5vcGFjaXR5TGFiZWwpO1xuICAgICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMub3BhY2l0eURpdik7XG4gICAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5uZXdDb2xvckRpdik7XG4gICAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5pbml0aWFsQ29sb3JEaXYpO1xuXG4gICAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5jYW5jZWxCdXR0b24pO1xuICAgICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuYXBwbHlCdXR0b24pO1xuICAgICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuc2F2ZUJ1dHRvbik7XG4gICAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5sb2FkQnV0dG9uKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBiaW5kIGhhbW1lciB0byB0aGUgY29sb3IgcGlja2VyXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfYmluZEhhbW1lcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2JpbmRIYW1tZXIoKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuZHJhZyA9IHt9O1xuICAgICAgICB0aGlzLnBpbmNoID0ge307XG4gICAgICAgIHRoaXMuaGFtbWVyID0gbmV3IEhhbW1lcih0aGlzLmNvbG9yUGlja2VyQ2FudmFzKTtcbiAgICAgICAgdGhpcy5oYW1tZXIuZ2V0KCdwaW5jaCcpLnNldCh7IGVuYWJsZTogdHJ1ZSB9KTtcblxuICAgICAgICBoYW1tZXJVdGlsLm9uVG91Y2godGhpcy5oYW1tZXIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIF90aGlzMi5fbW92ZVNlbGVjdG9yKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGFtbWVyLm9uKCd0YXAnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBfdGhpczIuX21vdmVTZWxlY3RvcihldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhhbW1lci5vbigncGFuc3RhcnQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBfdGhpczIuX21vdmVTZWxlY3RvcihldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhhbW1lci5vbigncGFubW92ZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIF90aGlzMi5fbW92ZVNlbGVjdG9yKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGFtbWVyLm9uKCdwYW5lbmQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBfdGhpczIuX21vdmVTZWxlY3RvcihldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGdlbmVyYXRlIHRoZSBodWUgY2lyY2xlLiBUaGlzIGlzIHJlbGF0aXZlbHkgaGVhdnkgKDIwMG1zKSBhbmQgaXMgZG9uZSBvbmx5IG9uY2Ugb24gdGhlIGZpcnN0IHRpbWUgaXQgaXMgc2hvd24uXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZ2VuZXJhdGVIdWVDaXJjbGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZW5lcmF0ZUh1ZUNpcmNsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2VuZXJhdGVkID09PSBmYWxzZSkge1xuICAgICAgICAgIHZhciBjdHggPSB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgaWYgKHRoaXMucGl4ZWxSYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5waXhlbFJhdGlvID0gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIC8gKGN0eC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdHguc2V0VHJhbnNmb3JtKHRoaXMucGl4ZWxSYXRpbywgMCwgMCwgdGhpcy5waXhlbFJhdGlvLCAwLCAwKTtcblxuICAgICAgICAgIC8vIGNsZWFyIHRoZSBjYW52YXNcbiAgICAgICAgICB2YXIgdyA9IHRoaXMuY29sb3JQaWNrZXJDYW52YXMuY2xpZW50V2lkdGg7XG4gICAgICAgICAgdmFyIGggPSB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmNsaWVudEhlaWdodDtcbiAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHcsIGgpO1xuXG4gICAgICAgICAgLy8gZHJhdyBodWUgY2lyY2xlXG4gICAgICAgICAgdmFyIHggPSB2b2lkIDAsXG4gICAgICAgICAgICAgIHkgPSB2b2lkIDAsXG4gICAgICAgICAgICAgIGh1ZSA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgc2F0ID0gdm9pZCAwO1xuICAgICAgICAgIHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMgPSB7IHg6IHcgKiAwLjUsIHk6IGggKiAwLjUgfTtcbiAgICAgICAgICB0aGlzLnIgPSAwLjQ5ICogdztcbiAgICAgICAgICB2YXIgYW5nbGVDb252ZXJ0ID0gMiAqIE1hdGguUEkgLyAzNjA7XG4gICAgICAgICAgdmFyIGhmYWMgPSAxIC8gMzYwO1xuICAgICAgICAgIHZhciBzZmFjID0gMSAvIHRoaXMucjtcbiAgICAgICAgICB2YXIgcmdiID0gdm9pZCAwO1xuICAgICAgICAgIGZvciAoaHVlID0gMDsgaHVlIDwgMzYwOyBodWUrKykge1xuICAgICAgICAgICAgZm9yIChzYXQgPSAwOyBzYXQgPCB0aGlzLnI7IHNhdCsrKSB7XG4gICAgICAgICAgICAgIHggPSB0aGlzLmNlbnRlckNvb3JkaW5hdGVzLnggKyBzYXQgKiBNYXRoLnNpbihhbmdsZUNvbnZlcnQgKiBodWUpO1xuICAgICAgICAgICAgICB5ID0gdGhpcy5jZW50ZXJDb29yZGluYXRlcy55ICsgc2F0ICogTWF0aC5jb3MoYW5nbGVDb252ZXJ0ICogaHVlKTtcbiAgICAgICAgICAgICAgcmdiID0gdXRpbC5IU1ZUb1JHQihodWUgKiBoZmFjLCBzYXQgKiBzZmFjLCAxKTtcbiAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICdyZ2IoJyArIHJnYi5yICsgJywnICsgcmdiLmcgKyAnLCcgKyByZ2IuYiArICcpJztcbiAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KHggLSAwLjUsIHkgLSAwLjUsIDIsIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAncmdiYSgwLDAsMCwxKSc7XG4gICAgICAgICAgY3R4LmNpcmNsZSh0aGlzLmNlbnRlckNvb3JkaW5hdGVzLngsIHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueSwgdGhpcy5yKTtcbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgICB0aGlzLmh1ZUNpcmNsZSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgdywgaCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZW5lcmF0ZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIG1vdmUgdGhlIHNlbGVjdG9yLiBUaGlzIGlzIGNhbGxlZCBieSBoYW1tZXIgZnVuY3Rpb25zLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSBldmVudFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX21vdmVTZWxlY3RvcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX21vdmVTZWxlY3RvcihldmVudCkge1xuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuY29sb3JQaWNrZXJEaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBsZWZ0ID0gZXZlbnQuY2VudGVyLnggLSByZWN0LmxlZnQ7XG4gICAgICAgIHZhciB0b3AgPSBldmVudC5jZW50ZXIueSAtIHJlY3QudG9wO1xuXG4gICAgICAgIHZhciBjZW50ZXJZID0gMC41ICogdGhpcy5jb2xvclBpY2tlckRpdi5jbGllbnRIZWlnaHQ7XG4gICAgICAgIHZhciBjZW50ZXJYID0gMC41ICogdGhpcy5jb2xvclBpY2tlckRpdi5jbGllbnRXaWR0aDtcblxuICAgICAgICB2YXIgeCA9IGxlZnQgLSBjZW50ZXJYO1xuICAgICAgICB2YXIgeSA9IHRvcCAtIGNlbnRlclk7XG5cbiAgICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMih4LCB5KTtcbiAgICAgICAgdmFyIHJhZGl1cyA9IDAuOTggKiBNYXRoLm1pbihNYXRoLnNxcnQoeCAqIHggKyB5ICogeSksIGNlbnRlclgpO1xuXG4gICAgICAgIHZhciBuZXdUb3AgPSBNYXRoLmNvcyhhbmdsZSkgKiByYWRpdXMgKyBjZW50ZXJZO1xuICAgICAgICB2YXIgbmV3TGVmdCA9IE1hdGguc2luKGFuZ2xlKSAqIHJhZGl1cyArIGNlbnRlclg7XG5cbiAgICAgICAgdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLnN0eWxlLnRvcCA9IG5ld1RvcCAtIDAuNSAqIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5jbGllbnRIZWlnaHQgKyAncHgnO1xuICAgICAgICB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3Iuc3R5bGUubGVmdCA9IG5ld0xlZnQgLSAwLjUgKiB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3IuY2xpZW50V2lkdGggKyAncHgnO1xuXG4gICAgICAgIC8vIHNldCBjb2xvclxuICAgICAgICB2YXIgaCA9IGFuZ2xlIC8gKDIgKiBNYXRoLlBJKTtcbiAgICAgICAgaCA9IGggPCAwID8gaCArIDEgOiBoO1xuICAgICAgICB2YXIgcyA9IHJhZGl1cyAvIHRoaXMucjtcbiAgICAgICAgdmFyIGhzdiA9IHV0aWwuUkdCVG9IU1YodGhpcy5jb2xvci5yLCB0aGlzLmNvbG9yLmcsIHRoaXMuY29sb3IuYik7XG4gICAgICAgIGhzdi5oID0gaDtcbiAgICAgICAgaHN2LnMgPSBzO1xuICAgICAgICB2YXIgcmdiYSA9IHV0aWwuSFNWVG9SR0IoaHN2LmgsIGhzdi5zLCBoc3Yudik7XG4gICAgICAgIHJnYmFbJ2EnXSA9IHRoaXMuY29sb3IuYTtcbiAgICAgICAgdGhpcy5jb2xvciA9IHJnYmE7XG5cbiAgICAgICAgLy8gdXBkYXRlIHByZXZpZXdzXG4gICAgICAgIHRoaXMuaW5pdGlhbENvbG9yRGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdyZ2JhKCcgKyB0aGlzLmluaXRpYWxDb2xvci5yICsgJywnICsgdGhpcy5pbml0aWFsQ29sb3IuZyArICcsJyArIHRoaXMuaW5pdGlhbENvbG9yLmIgKyAnLCcgKyB0aGlzLmluaXRpYWxDb2xvci5hICsgJyknO1xuICAgICAgICB0aGlzLm5ld0NvbG9yRGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdyZ2JhKCcgKyB0aGlzLmNvbG9yLnIgKyAnLCcgKyB0aGlzLmNvbG9yLmcgKyAnLCcgKyB0aGlzLmNvbG9yLmIgKyAnLCcgKyB0aGlzLmNvbG9yLmEgKyAnKSc7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIENvbG9yUGlja2VyO1xuICB9KCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gQ29sb3JQaWNrZXI7XG5cbi8qKiovIH0sXG4vKiAyOCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBIYW1tZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSB0b3VjaCBldmVudCwgdGFraW5nIHBsYWNlIGJlZm9yZSBhIGdlc3R1cmVcbiAgICogQHBhcmFtIHtIYW1tZXJ9IGhhbW1lciAgICAgICBBIGhhbW1lciBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAgIENhbGxiYWNrLCBjYWxsZWQgYXMgY2FsbGJhY2soZXZlbnQpXG4gICAqL1xuICBleHBvcnRzLm9uVG91Y2ggPSBmdW5jdGlvbiAoaGFtbWVyLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrLmlucHV0SGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKGV2ZW50LmlzRmlyc3QpIHtcbiAgICAgICAgY2FsbGJhY2soZXZlbnQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBoYW1tZXIub24oJ2hhbW1lci5pbnB1dCcsIGNhbGxiYWNrLmlucHV0SGFuZGxlcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgcmVsZWFzZSBldmVudCwgdGFraW5nIHBsYWNlIGFmdGVyIGEgZ2VzdHVyZVxuICAgKiBAcGFyYW0ge0hhbW1lcn0gaGFtbWVyICAgICAgIEEgaGFtbWVyIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrICAgQ2FsbGJhY2ssIGNhbGxlZCBhcyBjYWxsYmFjayhldmVudClcbiAgICovXG4gIGV4cG9ydHMub25SZWxlYXNlID0gZnVuY3Rpb24gKGhhbW1lciwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjay5pbnB1dEhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5pc0ZpbmFsKSB7XG4gICAgICAgIGNhbGxiYWNrKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGhhbW1lci5vbignaGFtbWVyLmlucHV0JywgY2FsbGJhY2suaW5wdXRIYW5kbGVyKTtcbiAgfTtcblxuICAvKipcbiAgICogVW5yZWdpc3RlciBhIHRvdWNoIGV2ZW50LCB0YWtpbmcgcGxhY2UgYmVmb3JlIGEgZ2VzdHVyZVxuICAgKiBAcGFyYW0ge0hhbW1lcn0gaGFtbWVyICAgICAgIEEgaGFtbWVyIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrICAgQ2FsbGJhY2ssIGNhbGxlZCBhcyBjYWxsYmFjayhldmVudClcbiAgICovXG4gIGV4cG9ydHMub2ZmVG91Y2ggPSBmdW5jdGlvbiAoaGFtbWVyLCBjYWxsYmFjaykge1xuICAgIGhhbW1lci5vZmYoJ2hhbW1lci5pbnB1dCcsIGNhbGxiYWNrLmlucHV0SGFuZGxlcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVucmVnaXN0ZXIgYSByZWxlYXNlIGV2ZW50LCB0YWtpbmcgcGxhY2UgYmVmb3JlIGEgZ2VzdHVyZVxuICAgKiBAcGFyYW0ge0hhbW1lcn0gaGFtbWVyICAgICAgIEEgaGFtbWVyIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrICAgQ2FsbGJhY2ssIGNhbGxlZCBhcyBjYWxsYmFjayhldmVudClcbiAgICovXG4gIGV4cG9ydHMub2ZmUmVsZWFzZSA9IGV4cG9ydHMub2ZmVG91Y2g7XG5cbiAgLyoqXG4gICAqIEhhY2sgdGhlIFBpbmNoUmVjb2duaXplciBzdWNoIHRoYXQgaXQgZG9lc24ndCBwcmV2ZW50IGRlZmF1bHQgYmVoYXZpb3JcbiAgICogZm9yIHZlcnRpY2FsIHBhbm5pbmcuXG4gICAqXG4gICAqIFllYWggLi4uIHRoaXMgaXMgcXVpdGUgYSBoYWNrIC4uLiBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2hhbW1lcmpzL2hhbW1lci5qcy9pc3N1ZXMvOTMyXG4gICAqXG4gICAqIEBwYXJhbSB7SGFtbWVyLlBpbmNofSBwaW5jaFJlY29nbml6ZXJcbiAgICogQHJldHVybiB7SGFtbWVyLlBpbmNofSByZXR1cm5zIHRoZSBwaW5jaFJlY29nbml6ZXJcbiAgICovXG4gIGV4cG9ydHMuZGlzYWJsZVByZXZlbnREZWZhdWx0VmVydGljYWxseSA9IGZ1bmN0aW9uIChwaW5jaFJlY29nbml6ZXIpIHtcbiAgICB2YXIgVE9VQ0hfQUNUSU9OX1BBTl9ZID0gJ3Bhbi15JztcblxuICAgIHBpbmNoUmVjb2duaXplci5nZXRUb3VjaEFjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGRlZmF1bHQgbWV0aG9kIHJldHVybnMgW1RPVUNIX0FDVElPTl9OT05FXVxuICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fUEFOX1ldO1xuICAgIH07XG5cbiAgICByZXR1cm4gcGluY2hSZWNvZ25pemVyO1xuICB9O1xuXG4vKioqLyB9LFxuLyogMjkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgdmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4gIHZhciBlcnJvckZvdW5kID0gZmFsc2U7XG4gIHZhciBhbGxPcHRpb25zID0gdm9pZCAwO1xuICB2YXIgcHJpbnRTdHlsZSA9ICdiYWNrZ3JvdW5kOiAjRkZlZWVlOyBjb2xvcjogI2RkMDAwMCc7XG4gIC8qKlxuICAgKiAgVXNlZCB0byB2YWxpZGF0ZSBvcHRpb25zLlxuICAgKi9cblxuICB2YXIgVmFsaWRhdG9yID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZhbGlkYXRvcigpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBWYWxpZGF0b3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1haW4gZnVuY3Rpb24gdG8gYmUgY2FsbGVkXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gc3ViT2JqZWN0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhWYWxpZGF0b3IsIG51bGwsIFt7XG4gICAgICBrZXk6ICd2YWxpZGF0ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGUob3B0aW9ucywgcmVmZXJlbmNlT3B0aW9ucywgc3ViT2JqZWN0KSB7XG4gICAgICAgIGVycm9yRm91bmQgPSBmYWxzZTtcbiAgICAgICAgYWxsT3B0aW9ucyA9IHJlZmVyZW5jZU9wdGlvbnM7XG4gICAgICAgIHZhciB1c2VkT3B0aW9ucyA9IHJlZmVyZW5jZU9wdGlvbnM7XG4gICAgICAgIGlmIChzdWJPYmplY3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHVzZWRPcHRpb25zID0gcmVmZXJlbmNlT3B0aW9uc1tzdWJPYmplY3RdO1xuICAgICAgICB9XG4gICAgICAgIFZhbGlkYXRvci5wYXJzZShvcHRpb25zLCB1c2VkT3B0aW9ucywgW10pO1xuICAgICAgICByZXR1cm4gZXJyb3JGb3VuZDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBXaWxsIHRyYXZlcnNlIGFuIG9iamVjdCByZWN1cnNpdmVseSBhbmQgY2hlY2sgZXZlcnkgdmFsdWVcbiAgICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICAgKiBAcGFyYW0gcmVmZXJlbmNlT3B0aW9uc1xuICAgICAgICogQHBhcmFtIHBhdGhcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAncGFyc2UnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKG9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbnMsIHBhdGgpIHtcbiAgICAgICAgZm9yICh2YXIgb3B0aW9uIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShvcHRpb24pKSB7XG4gICAgICAgICAgICBWYWxpZGF0b3IuY2hlY2sob3B0aW9uLCBvcHRpb25zLCByZWZlcmVuY2VPcHRpb25zLCBwYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDaGVjayBldmVyeSB2YWx1ZS4gSWYgdGhlIHZhbHVlIGlzIGFuIG9iamVjdCwgY2FsbCB0aGUgcGFyc2UgZnVuY3Rpb24gb24gdGhhdCBvYmplY3QuXG4gICAgICAgKiBAcGFyYW0gb3B0aW9uXG4gICAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAgICogQHBhcmFtIHJlZmVyZW5jZU9wdGlvbnNcbiAgICAgICAqIEBwYXJhbSBwYXRoXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2NoZWNrJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVjayhvcHRpb24sIG9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbnMsIHBhdGgpIHtcbiAgICAgICAgaWYgKHJlZmVyZW5jZU9wdGlvbnNbb3B0aW9uXSA9PT0gdW5kZWZpbmVkICYmIHJlZmVyZW5jZU9wdGlvbnMuX19hbnlfXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgVmFsaWRhdG9yLmdldFN1Z2dlc3Rpb24ob3B0aW9uLCByZWZlcmVuY2VPcHRpb25zLCBwYXRoKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZWZlcmVuY2VPcHRpb25zW29wdGlvbl0gPT09IHVuZGVmaW5lZCAmJiByZWZlcmVuY2VPcHRpb25zLl9fYW55X18gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIF9fYW55X18gaXMgYSB3aWxkY2FyZC4gQW55IHZhbHVlIGlzIGFjY2VwdGVkIGFuZCB3aWxsIGJlIGZ1cnRoZXIgYW5hbHlzZWQgYnkgcmVmZXJlbmNlLlxuICAgICAgICAgIGlmIChWYWxpZGF0b3IuZ2V0VHlwZShvcHRpb25zW29wdGlvbl0pID09PSAnb2JqZWN0JyAmJiByZWZlcmVuY2VPcHRpb25zWydfX2FueV9fJ10uX190eXBlX18gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gaWYgdGhlIGFueSBzdWJncm91cCBpcyBub3QgYSBwcmVkZWZpbmVkIG9iamVjdCBpbnQgaGUgY29uZmlndXJhdG9yIHdlIGRvIG5vdCBsb29rIGRlZXBlciBpbnRvIHRoZSBvYmplY3QuXG4gICAgICAgICAgICBWYWxpZGF0b3IuY2hlY2tGaWVsZHMob3B0aW9uLCBvcHRpb25zLCByZWZlcmVuY2VPcHRpb25zLCAnX19hbnlfXycsIHJlZmVyZW5jZU9wdGlvbnNbJ19fYW55X18nXS5fX3R5cGVfXywgcGF0aCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFZhbGlkYXRvci5jaGVja0ZpZWxkcyhvcHRpb24sIG9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbnMsICdfX2FueV9fJywgcmVmZXJlbmNlT3B0aW9uc1snX19hbnlfXyddLCBwYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gU2luY2UgYWxsIG9wdGlvbnMgaW4gdGhlIHJlZmVyZW5jZSBhcmUgb2JqZWN0cywgd2UgY2FuIGNoZWNrIHdoZXRoZXIgdGhleSBhcmUgc3VwcG9zZWQgdG8gYmUgb2JqZWN0IHRvIGxvb2sgZm9yIHRoZSBfX3R5cGVfXyBmaWVsZC5cbiAgICAgICAgICBpZiAocmVmZXJlbmNlT3B0aW9uc1tvcHRpb25dLl9fdHlwZV9fICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoaXMgc2hvdWxkIGJlIGFuIG9iamVjdCwgd2UgY2hlY2sgaWYgdGhlIGNvcnJlY3QgdHlwZSBoYXMgYmVlbiBzdXBwbGllZCB0byBhY2NvdW50IGZvciBzaG9ydGhhbmQgb3B0aW9ucy5cbiAgICAgICAgICAgIFZhbGlkYXRvci5jaGVja0ZpZWxkcyhvcHRpb24sIG9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbnMsIG9wdGlvbiwgcmVmZXJlbmNlT3B0aW9uc1tvcHRpb25dLl9fdHlwZV9fLCBwYXRoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgVmFsaWRhdG9yLmNoZWNrRmllbGRzKG9wdGlvbiwgb3B0aW9ucywgcmVmZXJlbmNlT3B0aW9ucywgb3B0aW9uLCByZWZlcmVuY2VPcHRpb25zW29wdGlvbl0sIHBhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gIG9wdGlvbiAgICAgfCB0aGUgb3B0aW9uIHByb3BlcnR5XG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gIG9wdGlvbnMgICAgfCBUaGUgc3VwcGxpZWQgb3B0aW9ucyBvYmplY3RcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgcmVmZXJlbmNlT3B0aW9ucyAgICB8IFRoZSByZWZlcmVuY2Ugb3B0aW9ucyBjb250YWluaW5nIGFsbCBvcHRpb25zIGFuZCB0aGVpciBhbGxvd2VkIGZvcm1hdHNcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgcmVmZXJlbmNlT3B0aW9uICAgICB8IFVzdWFsbHkgdGhpcyBpcyB0aGUgc2FtZSBhcyBvcHRpb24sIGV4Y2VwdCB3aGVuIGhhbmRsaW5nIGFuIF9fYW55X18gdGFnLlxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9ICByZWZPcHRpb25UeXBlICAgICAgIHwgVGhpcyBpcyB0aGUgdHlwZSBvYmplY3QgZnJvbSB0aGUgcmVmZXJlbmNlIG9wdGlvbnNcbiAgICAgICAqIEBwYXJhbSB7QXJyYXl9ICAgcGF0aCAgICAgIHwgd2hlcmUgaW4gdGhlIG9iamVjdCBpcyB0aGUgb3B0aW9uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2NoZWNrRmllbGRzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0ZpZWxkcyhvcHRpb24sIG9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbiwgcmVmT3B0aW9uT2JqLCBwYXRoKSB7XG4gICAgICAgIHZhciBvcHRpb25UeXBlID0gVmFsaWRhdG9yLmdldFR5cGUob3B0aW9uc1tvcHRpb25dKTtcbiAgICAgICAgdmFyIHJlZk9wdGlvblR5cGUgPSByZWZPcHRpb25PYmpbb3B0aW9uVHlwZV07XG4gICAgICAgIGlmIChyZWZPcHRpb25UeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBpZiB0aGUgdHlwZSBpcyBjb3JyZWN0LCB3ZSBjaGVjayBpZiBpdCBpcyBzdXBwb3NlZCB0byBiZSBvbmUgb2YgYSBmZXcgc2VsZWN0IHZhbHVlc1xuICAgICAgICAgIGlmIChWYWxpZGF0b3IuZ2V0VHlwZShyZWZPcHRpb25UeXBlKSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgaWYgKHJlZk9wdGlvblR5cGUuaW5kZXhPZihvcHRpb25zW29wdGlvbl0pID09PSAtMSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnJWNJbnZhbGlkIG9wdGlvbiBkZXRlY3RlZCBpbiBcIicgKyBvcHRpb24gKyAnXCIuJyArICcgQWxsb3dlZCB2YWx1ZXMgYXJlOicgKyBWYWxpZGF0b3IucHJpbnQocmVmT3B0aW9uVHlwZSkgKyAnIG5vdCBcIicgKyBvcHRpb25zW29wdGlvbl0gKyAnXCIuICcgKyBWYWxpZGF0b3IucHJpbnRMb2NhdGlvbihwYXRoLCBvcHRpb24pLCBwcmludFN0eWxlKTtcbiAgICAgICAgICAgICAgZXJyb3JGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvblR5cGUgPT09ICdvYmplY3QnICYmIHJlZmVyZW5jZU9wdGlvbiAhPT0gXCJfX2FueV9fXCIpIHtcbiAgICAgICAgICAgICAgcGF0aCA9IHV0aWwuY29weUFuZEV4dGVuZEFycmF5KHBhdGgsIG9wdGlvbik7XG4gICAgICAgICAgICAgIFZhbGlkYXRvci5wYXJzZShvcHRpb25zW29wdGlvbl0sIHJlZmVyZW5jZU9wdGlvbnNbcmVmZXJlbmNlT3B0aW9uXSwgcGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25UeXBlID09PSAnb2JqZWN0JyAmJiByZWZlcmVuY2VPcHRpb24gIT09IFwiX19hbnlfX1wiKSB7XG4gICAgICAgICAgICBwYXRoID0gdXRpbC5jb3B5QW5kRXh0ZW5kQXJyYXkocGF0aCwgb3B0aW9uKTtcbiAgICAgICAgICAgIFZhbGlkYXRvci5wYXJzZShvcHRpb25zW29wdGlvbl0sIHJlZmVyZW5jZU9wdGlvbnNbcmVmZXJlbmNlT3B0aW9uXSwgcGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHJlZk9wdGlvbk9ialsnYW55J10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIHR5cGUgb2YgdGhlIGZpZWxkIGlzIGluY29ycmVjdCBhbmQgdGhlIGZpZWxkIGNhbm5vdCBiZSBhbnlcbiAgICAgICAgICBjb25zb2xlLmxvZygnJWNJbnZhbGlkIHR5cGUgcmVjZWl2ZWQgZm9yIFwiJyArIG9wdGlvbiArICdcIi4gRXhwZWN0ZWQ6ICcgKyBWYWxpZGF0b3IucHJpbnQoT2JqZWN0LmtleXMocmVmT3B0aW9uT2JqKSkgKyAnLiBSZWNlaXZlZCBbJyArIG9wdGlvblR5cGUgKyAnXSBcIicgKyBvcHRpb25zW29wdGlvbl0gKyAnXCInICsgVmFsaWRhdG9yLnByaW50TG9jYXRpb24ocGF0aCwgb3B0aW9uKSwgcHJpbnRTdHlsZSk7XG4gICAgICAgICAgZXJyb3JGb3VuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXRUeXBlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUeXBlKG9iamVjdCkge1xuICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiBvYmplY3QgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9iamVjdCk7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgaWYgKG9iamVjdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEJvb2xlYW4pIHtcbiAgICAgICAgICAgIHJldHVybiAnYm9vbGVhbic7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAnbnVtYmVyJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuICdzdHJpbmcnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2FycmF5JztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmplY3Qubm9kZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuICdkb20nO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqZWN0Ll9pc0FNb21lbnRPYmplY3QgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiAnbW9tZW50JztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICdvYmplY3QnO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgcmV0dXJuICdudW1iZXInO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgIHJldHVybiAnYm9vbGVhbic7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm4gJ3N0cmluZyc7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldFN1Z2dlc3Rpb24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN1Z2dlc3Rpb24ob3B0aW9uLCBvcHRpb25zLCBwYXRoKSB7XG4gICAgICAgIHZhciBsb2NhbFNlYXJjaCA9IFZhbGlkYXRvci5maW5kSW5PcHRpb25zKG9wdGlvbiwgb3B0aW9ucywgcGF0aCwgZmFsc2UpO1xuICAgICAgICB2YXIgZ2xvYmFsU2VhcmNoID0gVmFsaWRhdG9yLmZpbmRJbk9wdGlvbnMob3B0aW9uLCBhbGxPcHRpb25zLCBbXSwgdHJ1ZSk7XG5cbiAgICAgICAgdmFyIGxvY2FsU2VhcmNoVGhyZXNob2xkID0gODtcbiAgICAgICAgdmFyIGdsb2JhbFNlYXJjaFRocmVzaG9sZCA9IDQ7XG5cbiAgICAgICAgaWYgKGxvY2FsU2VhcmNoLmluZGV4TWF0Y2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCclY1Vua25vd24gb3B0aW9uIGRldGVjdGVkOiBcIicgKyBvcHRpb24gKyAnXCIgaW4gJyArIFZhbGlkYXRvci5wcmludExvY2F0aW9uKGxvY2FsU2VhcmNoLnBhdGgsIG9wdGlvbiwgJycpICsgJ1BlcmhhcHMgaXQgd2FzIGluY29tcGxldGU/IERpZCB5b3UgbWVhbjogXCInICsgbG9jYWxTZWFyY2guaW5kZXhNYXRjaCArICdcIj9cXG5cXG4nLCBwcmludFN0eWxlKTtcbiAgICAgICAgfSBlbHNlIGlmIChnbG9iYWxTZWFyY2guZGlzdGFuY2UgPD0gZ2xvYmFsU2VhcmNoVGhyZXNob2xkICYmIGxvY2FsU2VhcmNoLmRpc3RhbmNlID4gZ2xvYmFsU2VhcmNoLmRpc3RhbmNlKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJyVjVW5rbm93biBvcHRpb24gZGV0ZWN0ZWQ6IFwiJyArIG9wdGlvbiArICdcIiBpbiAnICsgVmFsaWRhdG9yLnByaW50TG9jYXRpb24obG9jYWxTZWFyY2gucGF0aCwgb3B0aW9uLCAnJykgKyAnUGVyaGFwcyBpdCB3YXMgbWlzcGxhY2VkPyBNYXRjaGluZyBvcHRpb24gZm91bmQgYXQ6ICcgKyBWYWxpZGF0b3IucHJpbnRMb2NhdGlvbihnbG9iYWxTZWFyY2gucGF0aCwgZ2xvYmFsU2VhcmNoLmNsb3Nlc3RNYXRjaCwgJycpLCBwcmludFN0eWxlKTtcbiAgICAgICAgfSBlbHNlIGlmIChsb2NhbFNlYXJjaC5kaXN0YW5jZSA8PSBsb2NhbFNlYXJjaFRocmVzaG9sZCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCclY1Vua25vd24gb3B0aW9uIGRldGVjdGVkOiBcIicgKyBvcHRpb24gKyAnXCIuIERpZCB5b3UgbWVhbiBcIicgKyBsb2NhbFNlYXJjaC5jbG9zZXN0TWF0Y2ggKyAnXCI/JyArIFZhbGlkYXRvci5wcmludExvY2F0aW9uKGxvY2FsU2VhcmNoLnBhdGgsIG9wdGlvbiksIHByaW50U3R5bGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCclY1Vua25vd24gb3B0aW9uIGRldGVjdGVkOiBcIicgKyBvcHRpb24gKyAnXCIuIERpZCB5b3UgbWVhbiBvbmUgb2YgdGhlc2U6ICcgKyBWYWxpZGF0b3IucHJpbnQoT2JqZWN0LmtleXMob3B0aW9ucykpICsgVmFsaWRhdG9yLnByaW50TG9jYXRpb24ocGF0aCwgb3B0aW9uKSwgcHJpbnRTdHlsZSk7XG4gICAgICAgIH1cblxuICAgICAgICBlcnJvckZvdW5kID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiB0cmF2ZXJzZSB0aGUgb3B0aW9ucyBpbiBzZWFyY2ggZm9yIGEgbWF0Y2guXG4gICAgICAgKiBAcGFyYW0gb3B0aW9uXG4gICAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAgICogQHBhcmFtIHBhdGhcbiAgICAgICAqIEBwYXJhbSByZWN1cnNpdmVcbiAgICAgICAqIEByZXR1cm5zIHt7Y2xvc2VzdE1hdGNoOiBzdHJpbmcsIHBhdGg6IEFycmF5LCBkaXN0YW5jZTogbnVtYmVyfX1cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZmluZEluT3B0aW9ucycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZmluZEluT3B0aW9ucyhvcHRpb24sIG9wdGlvbnMsIHBhdGgpIHtcbiAgICAgICAgdmFyIHJlY3Vyc2l2ZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMyB8fCBhcmd1bWVudHNbM10gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogYXJndW1lbnRzWzNdO1xuXG4gICAgICAgIHZhciBtaW4gPSAxZTk7XG4gICAgICAgIHZhciBjbG9zZXN0TWF0Y2ggPSAnJztcbiAgICAgICAgdmFyIGNsb3Nlc3RNYXRjaFBhdGggPSBbXTtcbiAgICAgICAgdmFyIGxvd2VyQ2FzZU9wdGlvbiA9IG9wdGlvbi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIgaW5kZXhNYXRjaCA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yICh2YXIgb3AgaW4gb3B0aW9ucykge1xuICAgICAgICAgIHZhciBkaXN0YW5jZSA9IHZvaWQgMDtcbiAgICAgICAgICBpZiAob3B0aW9uc1tvcF0uX190eXBlX18gIT09IHVuZGVmaW5lZCAmJiByZWN1cnNpdmUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBWYWxpZGF0b3IuZmluZEluT3B0aW9ucyhvcHRpb24sIG9wdGlvbnNbb3BdLCB1dGlsLmNvcHlBbmRFeHRlbmRBcnJheShwYXRoLCBvcCkpO1xuICAgICAgICAgICAgaWYgKG1pbiA+IHJlc3VsdC5kaXN0YW5jZSkge1xuICAgICAgICAgICAgICBjbG9zZXN0TWF0Y2ggPSByZXN1bHQuY2xvc2VzdE1hdGNoO1xuICAgICAgICAgICAgICBjbG9zZXN0TWF0Y2hQYXRoID0gcmVzdWx0LnBhdGg7XG4gICAgICAgICAgICAgIG1pbiA9IHJlc3VsdC5kaXN0YW5jZTtcbiAgICAgICAgICAgICAgaW5kZXhNYXRjaCA9IHJlc3VsdC5pbmRleE1hdGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAob3AudG9Mb3dlckNhc2UoKS5pbmRleE9mKGxvd2VyQ2FzZU9wdGlvbikgIT09IC0xKSB7XG4gICAgICAgICAgICAgIGluZGV4TWF0Y2ggPSBvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3RhbmNlID0gVmFsaWRhdG9yLmxldmVuc2h0ZWluRGlzdGFuY2Uob3B0aW9uLCBvcCk7XG4gICAgICAgICAgICBpZiAobWluID4gZGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgY2xvc2VzdE1hdGNoID0gb3A7XG4gICAgICAgICAgICAgIGNsb3Nlc3RNYXRjaFBhdGggPSB1dGlsLmNvcHlBcnJheShwYXRoKTtcbiAgICAgICAgICAgICAgbWluID0gZGlzdGFuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGNsb3Nlc3RNYXRjaDogY2xvc2VzdE1hdGNoLCBwYXRoOiBjbG9zZXN0TWF0Y2hQYXRoLCBkaXN0YW5jZTogbWluLCBpbmRleE1hdGNoOiBpbmRleE1hdGNoIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAncHJpbnRMb2NhdGlvbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcHJpbnRMb2NhdGlvbihwYXRoLCBvcHRpb24pIHtcbiAgICAgICAgdmFyIHByZWZpeCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/ICdQcm9ibGVtIHZhbHVlIGZvdW5kIGF0OiBcXG4nIDogYXJndW1lbnRzWzJdO1xuXG4gICAgICAgIHZhciBzdHIgPSAnXFxuXFxuJyArIHByZWZpeCArICdvcHRpb25zID0ge1xcbic7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaSArIDE7IGorKykge1xuICAgICAgICAgICAgc3RyICs9ICcgICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0ciArPSBwYXRoW2ldICsgJzoge1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IHBhdGgubGVuZ3RoICsgMTsgX2orKykge1xuICAgICAgICAgIHN0ciArPSAnICAnO1xuICAgICAgICB9XG4gICAgICAgIHN0ciArPSBvcHRpb24gKyAnXFxuJztcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHBhdGgubGVuZ3RoICsgMTsgX2krKykge1xuICAgICAgICAgIGZvciAodmFyIF9qMiA9IDA7IF9qMiA8IHBhdGgubGVuZ3RoIC0gX2k7IF9qMisrKSB7XG4gICAgICAgICAgICBzdHIgKz0gJyAgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RyICs9ICd9XFxuJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyICsgJ1xcblxcbic7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAncHJpbnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByaW50KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpLnJlcGxhY2UoLyhcXFwiKXwoXFxbKXwoXFxdKXwoLFwiX190eXBlX19cIikvZywgXCJcIikucmVwbGFjZSgvKFxcLCkvZywgJywgJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIENvbXB1dGUgdGhlIGVkaXQgZGlzdGFuY2UgYmV0d2VlbiB0aGUgdHdvIGdpdmVuIHN0cmluZ3NcbiAgICAgIC8vIGh0dHA6Ly9lbi53aWtpYm9va3Mub3JnL3dpa2kvQWxnb3JpdGhtX0ltcGxlbWVudGF0aW9uL1N0cmluZ3MvTGV2ZW5zaHRlaW5fZGlzdGFuY2UjSmF2YVNjcmlwdFxuICAgICAgLypcbiAgICAgICBDb3B5cmlnaHQgKGMpIDIwMTEgQW5kcmVpIE1hY2tlbnppZVxuICAgICAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICAgICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2xldmVuc2h0ZWluRGlzdGFuY2UnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxldmVuc2h0ZWluRGlzdGFuY2UoYSwgYikge1xuICAgICAgICBpZiAoYS5sZW5ndGggPT09IDApIHJldHVybiBiLmxlbmd0aDtcbiAgICAgICAgaWYgKGIubGVuZ3RoID09PSAwKSByZXR1cm4gYS5sZW5ndGg7XG5cbiAgICAgICAgdmFyIG1hdHJpeCA9IFtdO1xuXG4gICAgICAgIC8vIGluY3JlbWVudCBhbG9uZyB0aGUgZmlyc3QgY29sdW1uIG9mIGVhY2ggcm93XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDw9IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBtYXRyaXhbaV0gPSBbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbmNyZW1lbnQgZWFjaCBjb2x1bW4gaW4gdGhlIGZpcnN0IHJvd1xuICAgICAgICB2YXIgajtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8PSBhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgbWF0cml4WzBdW2pdID0gajtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbGwgaW4gdGhlIHJlc3Qgb2YgdGhlIG1hdHJpeFxuICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBmb3IgKGogPSAxOyBqIDw9IGEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChiLmNoYXJBdChpIC0gMSkgPT0gYS5jaGFyQXQoaiAtIDEpKSB7XG4gICAgICAgICAgICAgIG1hdHJpeFtpXVtqXSA9IG1hdHJpeFtpIC0gMV1baiAtIDFdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWF0cml4W2ldW2pdID0gTWF0aC5taW4obWF0cml4W2kgLSAxXVtqIC0gMV0gKyAxLCAvLyBzdWJzdGl0dXRpb25cbiAgICAgICAgICAgICAgTWF0aC5taW4obWF0cml4W2ldW2ogLSAxXSArIDEsIC8vIGluc2VydGlvblxuICAgICAgICAgICAgICBtYXRyaXhbaSAtIDFdW2pdICsgMSkpOyAvLyBkZWxldGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXRyaXhbYi5sZW5ndGhdW2EubGVuZ3RoXTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gVmFsaWRhdG9yO1xuICB9KCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gVmFsaWRhdG9yO1xuICBleHBvcnRzLnByaW50U3R5bGUgPSBwcmludFN0eWxlO1xuXG4vKioqLyB9LFxuLyogMzAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4gIHZhciBoYW1tZXJVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG4gIHZhciBtb21lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuICB2YXIgQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSk7XG4gIHZhciBEYXRlVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3IgUmFuZ2VcbiAgICogQSBSYW5nZSBjb250cm9scyBhIG51bWVyaWMgcmFuZ2Ugd2l0aCBhIHN0YXJ0IGFuZCBlbmQgdmFsdWUuXG4gICAqIFRoZSBSYW5nZSBhZGp1c3RzIHRoZSByYW5nZSBiYXNlZCBvbiBtb3VzZSBldmVudHMgb3IgcHJvZ3JhbW1hdGljIGNoYW5nZXMsXG4gICAqIGFuZCB0cmlnZ2VycyBldmVudHMgd2hlbiB0aGUgcmFuZ2UgaXMgY2hhbmdpbmcgb3IgaGFzIGJlZW4gY2hhbmdlZC5cbiAgICogQHBhcmFtIHt7ZG9tOiBPYmplY3QsIGRvbVByb3BzOiBPYmplY3QsIGVtaXR0ZXI6IEVtaXR0ZXJ9fSBib2R5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgU2VlIGRlc2NyaXB0aW9uIGF0IFJhbmdlLnNldE9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIFJhbmdlKGJvZHksIG9wdGlvbnMpIHtcbiAgICB2YXIgbm93ID0gbW9tZW50KCkuaG91cnMoMCkubWludXRlcygwKS5zZWNvbmRzKDApLm1pbGxpc2Vjb25kcygwKTtcbiAgICB0aGlzLnN0YXJ0ID0gbm93LmNsb25lKCkuYWRkKC0zLCAnZGF5cycpLnZhbHVlT2YoKTsgLy8gTnVtYmVyXG4gICAgdGhpcy5lbmQgPSBub3cuY2xvbmUoKS5hZGQoNCwgJ2RheXMnKS52YWx1ZU9mKCk7IC8vIE51bWJlclxuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmRlbHRhRGlmZmVyZW5jZSA9IDA7XG4gICAgdGhpcy5zY2FsZU9mZnNldCA9IDA7XG4gICAgdGhpcy5zdGFydFRvRnJvbnQgPSBmYWxzZTtcbiAgICB0aGlzLmVuZFRvRnJvbnQgPSB0cnVlO1xuXG4gICAgLy8gZGVmYXVsdCBvcHRpb25zXG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIHJ0bDogZmFsc2UsXG4gICAgICBzdGFydDogbnVsbCxcbiAgICAgIGVuZDogbnVsbCxcbiAgICAgIG1vbWVudDogbW9tZW50LFxuICAgICAgZGlyZWN0aW9uOiAnaG9yaXpvbnRhbCcsIC8vICdob3Jpem9udGFsJyBvciAndmVydGljYWwnXG4gICAgICBtb3ZlYWJsZTogdHJ1ZSxcbiAgICAgIHpvb21hYmxlOiB0cnVlLFxuICAgICAgbWluOiBudWxsLFxuICAgICAgbWF4OiBudWxsLFxuICAgICAgem9vbU1pbjogMTAsIC8vIG1pbGxpc2Vjb25kc1xuICAgICAgem9vbU1heDogMTAwMCAqIDYwICogNjAgKiAyNCAqIDM2NSAqIDEwMDAwIC8vIG1pbGxpc2Vjb25kc1xuICAgIH07XG4gICAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoe30sIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuICAgIHRoaXMucHJvcHMgPSB7XG4gICAgICB0b3VjaDoge31cbiAgICB9O1xuICAgIHRoaXMuYW5pbWF0aW9uVGltZXIgPSBudWxsO1xuXG4gICAgLy8gZHJhZyBsaXN0ZW5lcnMgZm9yIGRyYWdnaW5nXG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ3BhbnN0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ3Bhbm1vdmUnLCB0aGlzLl9vbkRyYWcuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ3BhbmVuZCcsIHRoaXMuX29uRHJhZ0VuZC5iaW5kKHRoaXMpKTtcblxuICAgIC8vIG1vdXNlIHdoZWVsIGZvciB6b29taW5nXG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ21vdXNld2hlZWwnLCB0aGlzLl9vbk1vdXNlV2hlZWwuYmluZCh0aGlzKSk7XG5cbiAgICAvLyBwaW5jaCB0byB6b29tXG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ3RvdWNoJywgdGhpcy5fb25Ub3VjaC5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5vbigncGluY2gnLCB0aGlzLl9vblBpbmNoLmJpbmQodGhpcykpO1xuXG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG5cbiAgUmFuZ2UucHJvdG90eXBlID0gbmV3IENvbXBvbmVudCgpO1xuXG4gIC8qKlxuICAgKiBTZXQgb3B0aW9ucyBmb3IgdGhlIHJhbmdlIGNvbnRyb2xsZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgICAgICBBdmFpbGFibGUgb3B0aW9uczpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyIHwgRGF0ZSB8IFN0cmluZ30gc3RhcnQgIFN0YXJ0IGRhdGUgZm9yIHRoZSByYW5nZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtOdW1iZXIgfCBEYXRlIHwgU3RyaW5nfSBlbmQgICAgRW5kIGRhdGUgZm9yIHRoZSByYW5nZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtOdW1iZXJ9IG1pbiAgICBNaW5pbXVtIHZhbHVlIGZvciBzdGFydFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtOdW1iZXJ9IG1heCAgICBNYXhpbXVtIHZhbHVlIGZvciBlbmRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyfSB6b29tTWluICAgIFNldCBhIG1pbmltdW0gdmFsdWUgZm9yXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZW5kIC0gc3RhcnQpLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtOdW1iZXJ9IHpvb21NYXggICAgU2V0IGEgbWF4aW11bSB2YWx1ZSBmb3JcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlbmQgLSBzdGFydCkuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0Jvb2xlYW59IG1vdmVhYmxlIEVuYWJsZSBtb3Zpbmcgb2YgdGhlIHJhbmdlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5IGRyYWdnaW5nLiBUcnVlIGJ5IGRlZmF1bHRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Qm9vbGVhbn0gem9vbWFibGUgRW5hYmxlIHpvb21pbmcgb2YgdGhlIHJhbmdlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5IHBpbmNoaW5nL3Njcm9sbGluZy4gVHJ1ZSBieSBkZWZhdWx0XG4gICAqL1xuICBSYW5nZS5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIC8vIGNvcHkgdGhlIG9wdGlvbnMgdGhhdCB3ZSBrbm93XG4gICAgICB2YXIgZmllbGRzID0gWydkaXJlY3Rpb24nLCAnbWluJywgJ21heCcsICd6b29tTWluJywgJ3pvb21NYXgnLCAnbW92ZWFibGUnLCAnem9vbWFibGUnLCAnbW9tZW50JywgJ2FjdGl2YXRlJywgJ2hpZGRlbkRhdGVzJywgJ3pvb21LZXknLCAncnRsJ107XG4gICAgICB1dGlsLnNlbGVjdGl2ZUV4dGVuZChmaWVsZHMsIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgIGlmICgnc3RhcnQnIGluIG9wdGlvbnMgfHwgJ2VuZCcgaW4gb3B0aW9ucykge1xuICAgICAgICAvLyBhcHBseSBhIG5ldyByYW5nZS4gYm90aCBzdGFydCBhbmQgZW5kIGFyZSBvcHRpb25hbFxuICAgICAgICB0aGlzLnNldFJhbmdlKG9wdGlvbnMuc3RhcnQsIG9wdGlvbnMuZW5kKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFRlc3Qgd2hldGhlciBkaXJlY3Rpb24gaGFzIGEgdmFsaWQgdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRpcmVjdGlvbiAgICAnaG9yaXpvbnRhbCcgb3IgJ3ZlcnRpY2FsJ1xuICAgKi9cbiAgZnVuY3Rpb24gdmFsaWRhdGVEaXJlY3Rpb24oZGlyZWN0aW9uKSB7XG4gICAgaWYgKGRpcmVjdGlvbiAhPSAnaG9yaXpvbnRhbCcgJiYgZGlyZWN0aW9uICE9ICd2ZXJ0aWNhbCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZGlyZWN0aW9uIFwiJyArIGRpcmVjdGlvbiArICdcIi4gJyArICdDaG9vc2UgXCJob3Jpem9udGFsXCIgb3IgXCJ2ZXJ0aWNhbFwiLicpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYSBuZXcgc3RhcnQgYW5kIGVuZCByYW5nZVxuICAgKiBAcGFyYW0ge0RhdGUgfCBOdW1iZXIgfCBTdHJpbmd9IFtzdGFydF1cbiAgICogQHBhcmFtIHtEYXRlIHwgTnVtYmVyIHwgU3RyaW5nfSBbZW5kXVxuICAgKiBAcGFyYW0ge2Jvb2xlYW4gfCB7ZHVyYXRpb246IG51bWJlciwgZWFzaW5nRnVuY3Rpb246IHN0cmluZ319IFthbmltYXRpb249ZmFsc2VdXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgdHJ1ZSAoZGVmYXVsdCksIHRoZSByYW5nZSBpcyBhbmltYXRlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtb290aGx5IHRvIHRoZSBuZXcgd2luZG93LiBBbiBvYmplY3QgY2FuIGJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZWQgdG8gc3BlY2lmeSBkdXJhdGlvbiBhbmQgZWFzaW5nIGZ1bmN0aW9uLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgZHVyYXRpb24gaXMgNTAwIG1zLCBhbmQgZGVmYXVsdCBlYXNpbmdcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBpcyAnZWFzZUluT3V0UXVhZCcuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2J5VXNlcj1mYWxzZV1cbiAgICpcbiAgICovXG4gIFJhbmdlLnByb3RvdHlwZS5zZXRSYW5nZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBhbmltYXRpb24sIGJ5VXNlcikge1xuICAgIGlmIChieVVzZXIgIT09IHRydWUpIHtcbiAgICAgIGJ5VXNlciA9IGZhbHNlO1xuICAgIH1cbiAgICB2YXIgZmluYWxTdGFydCA9IHN0YXJ0ICE9IHVuZGVmaW5lZCA/IHV0aWwuY29udmVydChzdGFydCwgJ0RhdGUnKS52YWx1ZU9mKCkgOiBudWxsO1xuICAgIHZhciBmaW5hbEVuZCA9IGVuZCAhPSB1bmRlZmluZWQgPyB1dGlsLmNvbnZlcnQoZW5kLCAnRGF0ZScpLnZhbHVlT2YoKSA6IG51bGw7XG4gICAgdGhpcy5fY2FuY2VsQW5pbWF0aW9uKCk7XG5cbiAgICBpZiAoYW5pbWF0aW9uKSB7XG4gICAgICAvLyB0cnVlIG9yIGFuIE9iamVjdFxuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIHZhciBpbml0U3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgICAgdmFyIGluaXRFbmQgPSB0aGlzLmVuZDtcbiAgICAgIHZhciBkdXJhdGlvbiA9ICh0eXBlb2YgYW5pbWF0aW9uID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihhbmltYXRpb24pKSA9PT0gJ29iamVjdCcgJiYgJ2R1cmF0aW9uJyBpbiBhbmltYXRpb24gPyBhbmltYXRpb24uZHVyYXRpb24gOiA1MDA7XG4gICAgICB2YXIgZWFzaW5nTmFtZSA9ICh0eXBlb2YgYW5pbWF0aW9uID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihhbmltYXRpb24pKSA9PT0gJ29iamVjdCcgJiYgJ2Vhc2luZ0Z1bmN0aW9uJyBpbiBhbmltYXRpb24gPyBhbmltYXRpb24uZWFzaW5nRnVuY3Rpb24gOiAnZWFzZUluT3V0UXVhZCc7XG4gICAgICB2YXIgZWFzaW5nRnVuY3Rpb24gPSB1dGlsLmVhc2luZ0Z1bmN0aW9uc1tlYXNpbmdOYW1lXTtcbiAgICAgIGlmICghZWFzaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVhc2luZyBmdW5jdGlvbiAnICsgSlNPTi5zdHJpbmdpZnkoZWFzaW5nTmFtZSkgKyAnLiAnICsgJ0Nob29zZSBmcm9tOiAnICsgT2JqZWN0LmtleXModXRpbC5lYXNpbmdGdW5jdGlvbnMpLmpvaW4oJywgJykpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5pdFRpbWUgPSBuZXcgRGF0ZSgpLnZhbHVlT2YoKTtcbiAgICAgIHZhciBhbnlDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgIHZhciBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgaWYgKCFtZS5wcm9wcy50b3VjaC5kcmFnZ2luZykge1xuICAgICAgICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpLnZhbHVlT2YoKTtcbiAgICAgICAgICB2YXIgdGltZSA9IG5vdyAtIGluaXRUaW1lO1xuICAgICAgICAgIHZhciBlYXNlID0gZWFzaW5nRnVuY3Rpb24odGltZSAvIGR1cmF0aW9uKTtcbiAgICAgICAgICB2YXIgZG9uZSA9IHRpbWUgPiBkdXJhdGlvbjtcbiAgICAgICAgICB2YXIgcyA9IGRvbmUgfHwgZmluYWxTdGFydCA9PT0gbnVsbCA/IGZpbmFsU3RhcnQgOiBpbml0U3RhcnQgKyAoZmluYWxTdGFydCAtIGluaXRTdGFydCkgKiBlYXNlO1xuICAgICAgICAgIHZhciBlID0gZG9uZSB8fCBmaW5hbEVuZCA9PT0gbnVsbCA/IGZpbmFsRW5kIDogaW5pdEVuZCArIChmaW5hbEVuZCAtIGluaXRFbmQpICogZWFzZTtcblxuICAgICAgICAgIGNoYW5nZWQgPSBtZS5fYXBwbHlSYW5nZShzLCBlKTtcbiAgICAgICAgICBEYXRlVXRpbC51cGRhdGVIaWRkZW5EYXRlcyhtZS5vcHRpb25zLm1vbWVudCwgbWUuYm9keSwgbWUub3B0aW9ucy5oaWRkZW5EYXRlcyk7XG4gICAgICAgICAgYW55Q2hhbmdlZCA9IGFueUNoYW5nZWQgfHwgY2hhbmdlZDtcbiAgICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgbWUuYm9keS5lbWl0dGVyLmVtaXQoJ3JhbmdlY2hhbmdlJywgeyBzdGFydDogbmV3IERhdGUobWUuc3RhcnQpLCBlbmQ6IG5ldyBEYXRlKG1lLmVuZCksIGJ5VXNlcjogYnlVc2VyIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICBpZiAoYW55Q2hhbmdlZCkge1xuICAgICAgICAgICAgICBtZS5ib2R5LmVtaXR0ZXIuZW1pdCgncmFuZ2VjaGFuZ2VkJywgeyBzdGFydDogbmV3IERhdGUobWUuc3RhcnQpLCBlbmQ6IG5ldyBEYXRlKG1lLmVuZCksIGJ5VXNlcjogYnlVc2VyIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBhbmltYXRlIHdpdGggYXMgaGlnaCBhcyBwb3NzaWJsZSBmcmFtZSByYXRlLCBsZWF2ZSAyMCBtcyBpbiBiZXR3ZWVuXG4gICAgICAgICAgICAvLyBlYWNoIHRvIHByZXZlbnQgdGhlIGJyb3dzZXIgZnJvbSBibG9ja2luZ1xuICAgICAgICAgICAgbWUuYW5pbWF0aW9uVGltZXIgPSBzZXRUaW1lb3V0KG5leHQsIDIwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjaGFuZ2VkID0gdGhpcy5fYXBwbHlSYW5nZShmaW5hbFN0YXJ0LCBmaW5hbEVuZCk7XG4gICAgICBEYXRlVXRpbC51cGRhdGVIaWRkZW5EYXRlcyh0aGlzLm9wdGlvbnMubW9tZW50LCB0aGlzLmJvZHksIHRoaXMub3B0aW9ucy5oaWRkZW5EYXRlcyk7XG4gICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICB2YXIgcGFyYW1zID0geyBzdGFydDogbmV3IERhdGUodGhpcy5zdGFydCksIGVuZDogbmV3IERhdGUodGhpcy5lbmQpLCBieVVzZXI6IGJ5VXNlciB9O1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdyYW5nZWNoYW5nZScsIHBhcmFtcyk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3JhbmdlY2hhbmdlZCcsIHBhcmFtcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTdG9wIGFuIGFuaW1hdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgUmFuZ2UucHJvdG90eXBlLl9jYW5jZWxBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uVGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmFuaW1hdGlvblRpbWVyKTtcbiAgICAgIHRoaXMuYW5pbWF0aW9uVGltZXIgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0IGEgbmV3IHN0YXJ0IGFuZCBlbmQgcmFuZ2UuIFRoaXMgbWV0aG9kIGlzIHRoZSBzYW1lIGFzIHNldFJhbmdlLCBidXRcbiAgICogZG9lcyBub3QgdHJpZ2dlciBhIHJhbmdlIGNoYW5nZSBhbmQgcmFuZ2UgY2hhbmdlZCBldmVudCwgYW5kIGl0IHJldHVybnNcbiAgICogdHJ1ZSB3aGVuIHRoZSByYW5nZSBpcyBjaGFuZ2VkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRdXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZW5kXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBjaGFuZ2VkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBSYW5nZS5wcm90b3R5cGUuX2FwcGx5UmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgIHZhciBuZXdTdGFydCA9IHN0YXJ0ICE9IG51bGwgPyB1dGlsLmNvbnZlcnQoc3RhcnQsICdEYXRlJykudmFsdWVPZigpIDogdGhpcy5zdGFydCxcbiAgICAgICAgbmV3RW5kID0gZW5kICE9IG51bGwgPyB1dGlsLmNvbnZlcnQoZW5kLCAnRGF0ZScpLnZhbHVlT2YoKSA6IHRoaXMuZW5kLFxuICAgICAgICBtYXggPSB0aGlzLm9wdGlvbnMubWF4ICE9IG51bGwgPyB1dGlsLmNvbnZlcnQodGhpcy5vcHRpb25zLm1heCwgJ0RhdGUnKS52YWx1ZU9mKCkgOiBudWxsLFxuICAgICAgICBtaW4gPSB0aGlzLm9wdGlvbnMubWluICE9IG51bGwgPyB1dGlsLmNvbnZlcnQodGhpcy5vcHRpb25zLm1pbiwgJ0RhdGUnKS52YWx1ZU9mKCkgOiBudWxsLFxuICAgICAgICBkaWZmO1xuXG4gICAgLy8gY2hlY2sgZm9yIHZhbGlkIG51bWJlclxuICAgIGlmIChpc05hTihuZXdTdGFydCkgfHwgbmV3U3RhcnQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGFydCBcIicgKyBzdGFydCArICdcIicpO1xuICAgIH1cbiAgICBpZiAoaXNOYU4obmV3RW5kKSB8fCBuZXdFbmQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBlbmQgXCInICsgZW5kICsgJ1wiJyk7XG4gICAgfVxuXG4gICAgLy8gcHJldmVudCBzdGFydCA8IGVuZFxuICAgIGlmIChuZXdFbmQgPCBuZXdTdGFydCkge1xuICAgICAgbmV3RW5kID0gbmV3U3RhcnQ7XG4gICAgfVxuXG4gICAgLy8gcHJldmVudCBzdGFydCA8IG1pblxuICAgIGlmIChtaW4gIT09IG51bGwpIHtcbiAgICAgIGlmIChuZXdTdGFydCA8IG1pbikge1xuICAgICAgICBkaWZmID0gbWluIC0gbmV3U3RhcnQ7XG4gICAgICAgIG5ld1N0YXJ0ICs9IGRpZmY7XG4gICAgICAgIG5ld0VuZCArPSBkaWZmO1xuXG4gICAgICAgIC8vIHByZXZlbnQgZW5kID4gbWF4XG4gICAgICAgIGlmIChtYXggIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChuZXdFbmQgPiBtYXgpIHtcbiAgICAgICAgICAgIG5ld0VuZCA9IG1heDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwcmV2ZW50IGVuZCA+IG1heFxuICAgIGlmIChtYXggIT09IG51bGwpIHtcbiAgICAgIGlmIChuZXdFbmQgPiBtYXgpIHtcbiAgICAgICAgZGlmZiA9IG5ld0VuZCAtIG1heDtcbiAgICAgICAgbmV3U3RhcnQgLT0gZGlmZjtcbiAgICAgICAgbmV3RW5kIC09IGRpZmY7XG5cbiAgICAgICAgLy8gcHJldmVudCBzdGFydCA8IG1pblxuICAgICAgICBpZiAobWluICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAobmV3U3RhcnQgPCBtaW4pIHtcbiAgICAgICAgICAgIG5ld1N0YXJ0ID0gbWluO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHByZXZlbnQgKGVuZC1zdGFydCkgPCB6b29tTWluXG4gICAgaWYgKHRoaXMub3B0aW9ucy56b29tTWluICE9PSBudWxsKSB7XG4gICAgICB2YXIgem9vbU1pbiA9IHBhcnNlRmxvYXQodGhpcy5vcHRpb25zLnpvb21NaW4pO1xuICAgICAgaWYgKHpvb21NaW4gPCAwKSB7XG4gICAgICAgIHpvb21NaW4gPSAwO1xuICAgICAgfVxuICAgICAgaWYgKG5ld0VuZCAtIG5ld1N0YXJ0IDwgem9vbU1pbikge1xuICAgICAgICBpZiAodGhpcy5lbmQgLSB0aGlzLnN0YXJ0ID09PSB6b29tTWluICYmIG5ld1N0YXJ0ID4gdGhpcy5zdGFydCAmJiBuZXdFbmQgPCB0aGlzLmVuZCkge1xuICAgICAgICAgIC8vIGlnbm9yZSB0aGlzIGFjdGlvbiwgd2UgYXJlIGFscmVhZHkgem9vbWVkIHRvIHRoZSBtaW5pbXVtXG4gICAgICAgICAgbmV3U3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgICAgICAgIG5ld0VuZCA9IHRoaXMuZW5kO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHpvb20gdG8gdGhlIG1pbmltdW1cbiAgICAgICAgICBkaWZmID0gem9vbU1pbiAtIChuZXdFbmQgLSBuZXdTdGFydCk7XG4gICAgICAgICAgbmV3U3RhcnQgLT0gZGlmZiAvIDI7XG4gICAgICAgICAgbmV3RW5kICs9IGRpZmYgLyAyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcHJldmVudCAoZW5kLXN0YXJ0KSA+IHpvb21NYXhcbiAgICBpZiAodGhpcy5vcHRpb25zLnpvb21NYXggIT09IG51bGwpIHtcbiAgICAgIHZhciB6b29tTWF4ID0gcGFyc2VGbG9hdCh0aGlzLm9wdGlvbnMuem9vbU1heCk7XG4gICAgICBpZiAoem9vbU1heCA8IDApIHtcbiAgICAgICAgem9vbU1heCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdFbmQgLSBuZXdTdGFydCA+IHpvb21NYXgpIHtcbiAgICAgICAgaWYgKHRoaXMuZW5kIC0gdGhpcy5zdGFydCA9PT0gem9vbU1heCAmJiBuZXdTdGFydCA8IHRoaXMuc3RhcnQgJiYgbmV3RW5kID4gdGhpcy5lbmQpIHtcbiAgICAgICAgICAvLyBpZ25vcmUgdGhpcyBhY3Rpb24sIHdlIGFyZSBhbHJlYWR5IHpvb21lZCB0byB0aGUgbWF4aW11bVxuICAgICAgICAgIG5ld1N0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICAgICAgICBuZXdFbmQgPSB0aGlzLmVuZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB6b29tIHRvIHRoZSBtYXhpbXVtXG4gICAgICAgICAgZGlmZiA9IG5ld0VuZCAtIG5ld1N0YXJ0IC0gem9vbU1heDtcbiAgICAgICAgICBuZXdTdGFydCArPSBkaWZmIC8gMjtcbiAgICAgICAgICBuZXdFbmQgLT0gZGlmZiAvIDI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hhbmdlZCA9IHRoaXMuc3RhcnQgIT0gbmV3U3RhcnQgfHwgdGhpcy5lbmQgIT0gbmV3RW5kO1xuXG4gICAgLy8gaWYgdGhlIG5ldyByYW5nZSBkb2VzIE5PVCBvdmVybGFwIHdpdGggdGhlIG9sZCByYW5nZSwgZW1pdCBjaGVja1JhbmdlZEl0ZW1zIHRvIGF2b2lkIG5vdCBzaG93aW5nIHJhbmdlZCBpdGVtcyAocmFuZ2VkIG1lYW5pbmcgaGFzIGVuZCB0aW1lLCBub3QgbmVjZXNzYXJpbHkgb2YgdHlwZSBSYW5nZSlcbiAgICBpZiAoIShuZXdTdGFydCA+PSB0aGlzLnN0YXJ0ICYmIG5ld1N0YXJ0IDw9IHRoaXMuZW5kIHx8IG5ld0VuZCA+PSB0aGlzLnN0YXJ0ICYmIG5ld0VuZCA8PSB0aGlzLmVuZCkgJiYgISh0aGlzLnN0YXJ0ID49IG5ld1N0YXJ0ICYmIHRoaXMuc3RhcnQgPD0gbmV3RW5kIHx8IHRoaXMuZW5kID49IG5ld1N0YXJ0ICYmIHRoaXMuZW5kIDw9IG5ld0VuZCkpIHtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ2NoZWNrUmFuZ2VkSXRlbXMnKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXJ0ID0gbmV3U3RhcnQ7XG4gICAgdGhpcy5lbmQgPSBuZXdFbmQ7XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSBjdXJyZW50IHJhbmdlLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIHN0YXJ0IGFuZCBlbmQgcHJvcGVydGllc1xuICAgKi9cbiAgUmFuZ2UucHJvdG90eXBlLmdldFJhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogdGhpcy5zdGFydCxcbiAgICAgIGVuZDogdGhpcy5lbmRcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGNvbnZlcnNpb24gb2Zmc2V0IGFuZCBzY2FsZSBmb3IgY3VycmVudCByYW5nZSwgYmFzZWQgb25cbiAgICogdGhlIHByb3ZpZGVkIHdpZHRoXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgKiBAcmV0dXJucyB7e29mZnNldDogbnVtYmVyLCBzY2FsZTogbnVtYmVyfX0gY29udmVyc2lvblxuICAgKi9cbiAgUmFuZ2UucHJvdG90eXBlLmNvbnZlcnNpb24gPSBmdW5jdGlvbiAod2lkdGgsIHRvdGFsSGlkZGVuKSB7XG4gICAgcmV0dXJuIFJhbmdlLmNvbnZlcnNpb24odGhpcy5zdGFydCwgdGhpcy5lbmQsIHdpZHRoLCB0b3RhbEhpZGRlbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0YXRpYyBtZXRob2QgdG8gY2FsY3VsYXRlIHRoZSBjb252ZXJzaW9uIG9mZnNldCBhbmQgc2NhbGUgZm9yIGEgcmFuZ2UsXG4gICAqIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBzdGFydCwgZW5kLCBhbmQgd2lkdGhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBlbmRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAqIEByZXR1cm5zIHt7b2Zmc2V0OiBudW1iZXIsIHNjYWxlOiBudW1iZXJ9fSBjb252ZXJzaW9uXG4gICAqL1xuICBSYW5nZS5jb252ZXJzaW9uID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHdpZHRoLCB0b3RhbEhpZGRlbikge1xuICAgIGlmICh0b3RhbEhpZGRlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0b3RhbEhpZGRlbiA9IDA7XG4gICAgfVxuICAgIGlmICh3aWR0aCAhPSAwICYmIGVuZCAtIHN0YXJ0ICE9IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9mZnNldDogc3RhcnQsXG4gICAgICAgIHNjYWxlOiB3aWR0aCAvIChlbmQgLSBzdGFydCAtIHRvdGFsSGlkZGVuKVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICBzY2FsZTogMVxuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGRyYWdnaW5nIGhvcml6b250YWxseSBvciB2ZXJ0aWNhbGx5XG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBSYW5nZS5wcm90b3R5cGUuX29uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdGhpcy5kZWx0YURpZmZlcmVuY2UgPSAwO1xuICAgIHRoaXMucHJldmlvdXNEZWx0YSA9IDA7XG5cbiAgICAvLyBvbmx5IGFsbG93IGRyYWdnaW5nIHdoZW4gY29uZmlndXJlZCBhcyBtb3ZhYmxlXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMubW92ZWFibGUpIHJldHVybjtcblxuICAgIC8vIG9ubHkgc3RhcnQgZHJhZ2dpbmcgd2hlbiB0aGUgbW91c2UgaXMgaW5zaWRlIHRoZSBjdXJyZW50IHJhbmdlXG4gICAgaWYgKCF0aGlzLl9pc0luc2lkZVJhbmdlKGV2ZW50KSkgcmV0dXJuO1xuXG4gICAgLy8gcmVmdXNlIHRvIGRyYWcgd2hlbiB3ZSB3aGVyZSBwaW5jaGluZyB0byBwcmV2ZW50IHRoZSB0aW1lbGluZSBtYWtlIGEganVtcFxuICAgIC8vIHdoZW4gcmVsZWFzaW5nIHRoZSBmaW5nZXJzIGluIG9wcG9zaXRlIG9yZGVyIGZyb20gdGhlIHRvdWNoIHNjcmVlblxuICAgIGlmICghdGhpcy5wcm9wcy50b3VjaC5hbGxvd0RyYWdnaW5nKSByZXR1cm47XG5cbiAgICB0aGlzLnByb3BzLnRvdWNoLnN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICB0aGlzLnByb3BzLnRvdWNoLmVuZCA9IHRoaXMuZW5kO1xuICAgIHRoaXMucHJvcHMudG91Y2guZHJhZ2dpbmcgPSB0cnVlO1xuXG4gICAgaWYgKHRoaXMuYm9keS5kb20ucm9vdCkge1xuICAgICAgdGhpcy5ib2R5LmRvbS5yb290LnN0eWxlLmN1cnNvciA9ICdtb3ZlJztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gZHJhZ2dpbmcgb3BlcmF0aW9uXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBSYW5nZS5wcm90b3R5cGUuX29uRHJhZyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmICghdGhpcy5wcm9wcy50b3VjaC5kcmFnZ2luZykgcmV0dXJuO1xuXG4gICAgLy8gb25seSBhbGxvdyBkcmFnZ2luZyB3aGVuIGNvbmZpZ3VyZWQgYXMgbW92YWJsZVxuICAgIGlmICghdGhpcy5vcHRpb25zLm1vdmVhYmxlKSByZXR1cm47XG5cbiAgICAvLyBUT0RPOiB0aGlzIG1heSBiZSByZWR1bmRhbnQgaW4gaGFtbWVyanMyXG4gICAgLy8gcmVmdXNlIHRvIGRyYWcgd2hlbiB3ZSB3aGVyZSBwaW5jaGluZyB0byBwcmV2ZW50IHRoZSB0aW1lbGluZSBtYWtlIGEganVtcFxuICAgIC8vIHdoZW4gcmVsZWFzaW5nIHRoZSBmaW5nZXJzIGluIG9wcG9zaXRlIG9yZGVyIGZyb20gdGhlIHRvdWNoIHNjcmVlblxuICAgIGlmICghdGhpcy5wcm9wcy50b3VjaC5hbGxvd0RyYWdnaW5nKSByZXR1cm47XG5cbiAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgICB2YWxpZGF0ZURpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIHZhciBkZWx0YSA9IGRpcmVjdGlvbiA9PSAnaG9yaXpvbnRhbCcgPyBldmVudC5kZWx0YVggOiBldmVudC5kZWx0YVk7XG4gICAgZGVsdGEgLT0gdGhpcy5kZWx0YURpZmZlcmVuY2U7XG4gICAgdmFyIGludGVydmFsID0gdGhpcy5wcm9wcy50b3VjaC5lbmQgLSB0aGlzLnByb3BzLnRvdWNoLnN0YXJ0O1xuXG4gICAgLy8gbm9ybWFsaXplIGRyYWdnaW5nIHNwZWVkIGlmIGN1dG91dCBpcyBpbiBiZXR3ZWVuLlxuICAgIHZhciBkdXJhdGlvbiA9IERhdGVVdGlsLmdldEhpZGRlbkR1cmF0aW9uQmV0d2Vlbih0aGlzLmJvZHkuaGlkZGVuRGF0ZXMsIHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcbiAgICBpbnRlcnZhbCAtPSBkdXJhdGlvbjtcblxuICAgIHZhciB3aWR0aCA9IGRpcmVjdGlvbiA9PSAnaG9yaXpvbnRhbCcgPyB0aGlzLmJvZHkuZG9tUHJvcHMuY2VudGVyLndpZHRoIDogdGhpcy5ib2R5LmRvbVByb3BzLmNlbnRlci5oZWlnaHQ7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgdmFyIGRpZmZSYW5nZSA9IGRlbHRhIC8gd2lkdGggKiBpbnRlcnZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRpZmZSYW5nZSA9IC1kZWx0YSAvIHdpZHRoICogaW50ZXJ2YWw7XG4gICAgfVxuXG4gICAgdmFyIG5ld1N0YXJ0ID0gdGhpcy5wcm9wcy50b3VjaC5zdGFydCArIGRpZmZSYW5nZTtcbiAgICB2YXIgbmV3RW5kID0gdGhpcy5wcm9wcy50b3VjaC5lbmQgKyBkaWZmUmFuZ2U7XG5cbiAgICAvLyBzbmFwcGluZyB0aW1lcyBhd2F5IGZyb20gaGlkZGVuIHpvbmVzXG4gICAgdmFyIHNhZmVTdGFydCA9IERhdGVVdGlsLnNuYXBBd2F5RnJvbUhpZGRlbih0aGlzLmJvZHkuaGlkZGVuRGF0ZXMsIG5ld1N0YXJ0LCB0aGlzLnByZXZpb3VzRGVsdGEgLSBkZWx0YSwgdHJ1ZSk7XG4gICAgdmFyIHNhZmVFbmQgPSBEYXRlVXRpbC5zbmFwQXdheUZyb21IaWRkZW4odGhpcy5ib2R5LmhpZGRlbkRhdGVzLCBuZXdFbmQsIHRoaXMucHJldmlvdXNEZWx0YSAtIGRlbHRhLCB0cnVlKTtcbiAgICBpZiAoc2FmZVN0YXJ0ICE9IG5ld1N0YXJ0IHx8IHNhZmVFbmQgIT0gbmV3RW5kKSB7XG4gICAgICB0aGlzLmRlbHRhRGlmZmVyZW5jZSArPSBkZWx0YTtcbiAgICAgIHRoaXMucHJvcHMudG91Y2guc3RhcnQgPSBzYWZlU3RhcnQ7XG4gICAgICB0aGlzLnByb3BzLnRvdWNoLmVuZCA9IHNhZmVFbmQ7XG4gICAgICB0aGlzLl9vbkRyYWcoZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucHJldmlvdXNEZWx0YSA9IGRlbHRhO1xuICAgIHRoaXMuX2FwcGx5UmFuZ2UobmV3U3RhcnQsIG5ld0VuZCk7XG5cbiAgICB2YXIgc3RhcnREYXRlID0gbmV3IERhdGUodGhpcy5zdGFydCk7XG4gICAgdmFyIGVuZERhdGUgPSBuZXcgRGF0ZSh0aGlzLmVuZCk7XG5cbiAgICAvLyBmaXJlIGEgcmFuZ2VjaGFuZ2UgZXZlbnRcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdyYW5nZWNoYW5nZScsIHtcbiAgICAgIHN0YXJ0OiBzdGFydERhdGUsXG4gICAgICBlbmQ6IGVuZERhdGUsXG4gICAgICBieVVzZXI6IHRydWVcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogU3RvcCBkcmFnZ2luZyBvcGVyYXRpb25cbiAgICogQHBhcmFtIHtldmVudH0gZXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFJhbmdlLnByb3RvdHlwZS5fb25EcmFnRW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLnByb3BzLnRvdWNoLmRyYWdnaW5nKSByZXR1cm47XG5cbiAgICAvLyBvbmx5IGFsbG93IGRyYWdnaW5nIHdoZW4gY29uZmlndXJlZCBhcyBtb3ZhYmxlXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMubW92ZWFibGUpIHJldHVybjtcblxuICAgIC8vIFRPRE86IHRoaXMgbWF5IGJlIHJlZHVuZGFudCBpbiBoYW1tZXJqczJcbiAgICAvLyByZWZ1c2UgdG8gZHJhZyB3aGVuIHdlIHdoZXJlIHBpbmNoaW5nIHRvIHByZXZlbnQgdGhlIHRpbWVsaW5lIG1ha2UgYSBqdW1wXG4gICAgLy8gd2hlbiByZWxlYXNpbmcgdGhlIGZpbmdlcnMgaW4gb3Bwb3NpdGUgb3JkZXIgZnJvbSB0aGUgdG91Y2ggc2NyZWVuXG4gICAgaWYgKCF0aGlzLnByb3BzLnRvdWNoLmFsbG93RHJhZ2dpbmcpIHJldHVybjtcblxuICAgIHRoaXMucHJvcHMudG91Y2guZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5ib2R5LmRvbS5yb290KSB7XG4gICAgICB0aGlzLmJvZHkuZG9tLnJvb3Quc3R5bGUuY3Vyc29yID0gJ2F1dG8nO1xuICAgIH1cblxuICAgIC8vIGZpcmUgYSByYW5nZWNoYW5nZWQgZXZlbnRcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdyYW5nZWNoYW5nZWQnLCB7XG4gICAgICBzdGFydDogbmV3IERhdGUodGhpcy5zdGFydCksXG4gICAgICBlbmQ6IG5ldyBEYXRlKHRoaXMuZW5kKSxcbiAgICAgIGJ5VXNlcjogdHJ1ZVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciBtb3VzZSB3aGVlbCBldmVudCwgdXNlZCB0byB6b29tXG4gICAqIENvZGUgZnJvbSBodHRwOi8vYWRvbWFzLm9yZy9qYXZhc2NyaXB0LW1vdXNlLXdoZWVsL1xuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgUmFuZ2UucHJvdG90eXBlLl9vbk1vdXNlV2hlZWwgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBvbmx5IGFsbG93IHpvb21pbmcgd2hlbiBjb25maWd1cmVkIGFzIHpvb21hYmxlIGFuZCBtb3ZlYWJsZVxuICAgIGlmICghKHRoaXMub3B0aW9ucy56b29tYWJsZSAmJiB0aGlzLm9wdGlvbnMubW92ZWFibGUpKSByZXR1cm47XG5cbiAgICAvLyBvbmx5IHpvb20gd2hlbiB0aGUgbW91c2UgaXMgaW5zaWRlIHRoZSBjdXJyZW50IHJhbmdlXG4gICAgaWYgKCF0aGlzLl9pc0luc2lkZVJhbmdlKGV2ZW50KSkgcmV0dXJuO1xuXG4gICAgLy8gb25seSB6b29tIHdoZW4gdGhlIGFjY29yZGluZyBrZXkgaXMgcHJlc3NlZCBhbmQgdGhlIHpvb21LZXkgb3B0aW9uIGlzIHNldFxuICAgIGlmICh0aGlzLm9wdGlvbnMuem9vbUtleSAmJiAhZXZlbnRbdGhpcy5vcHRpb25zLnpvb21LZXldKSByZXR1cm47XG5cbiAgICAvLyByZXRyaWV2ZSBkZWx0YVxuICAgIHZhciBkZWx0YSA9IDA7XG4gICAgaWYgKGV2ZW50LndoZWVsRGVsdGEpIHtcbiAgICAgIC8qIElFL09wZXJhLiAqL1xuICAgICAgZGVsdGEgPSBldmVudC53aGVlbERlbHRhIC8gMTIwO1xuICAgIH0gZWxzZSBpZiAoZXZlbnQuZGV0YWlsKSB7XG4gICAgICAvKiBNb3ppbGxhIGNhc2UuICovXG4gICAgICAvLyBJbiBNb3ppbGxhLCBzaWduIG9mIGRlbHRhIGlzIGRpZmZlcmVudCB0aGFuIGluIElFLlxuICAgICAgLy8gQWxzbywgZGVsdGEgaXMgbXVsdGlwbGUgb2YgMy5cbiAgICAgIGRlbHRhID0gLWV2ZW50LmRldGFpbCAvIDM7XG4gICAgfVxuXG4gICAgLy8gSWYgZGVsdGEgaXMgbm9uemVybywgaGFuZGxlIGl0LlxuICAgIC8vIEJhc2ljYWxseSwgZGVsdGEgaXMgbm93IHBvc2l0aXZlIGlmIHdoZWVsIHdhcyBzY3JvbGxlZCB1cCxcbiAgICAvLyBhbmQgbmVnYXRpdmUsIGlmIHdoZWVsIHdhcyBzY3JvbGxlZCBkb3duLlxuICAgIGlmIChkZWx0YSkge1xuICAgICAgLy8gcGVyZm9ybSB0aGUgem9vbSBhY3Rpb24uIERlbHRhIGlzIG5vcm1hbGx5IDEgb3IgLTFcblxuICAgICAgLy8gYWRqdXN0IGEgbmVnYXRpdmUgZGVsdGEgc3VjaCB0aGF0IHpvb21pbmcgaW4gd2l0aCBkZWx0YSAwLjFcbiAgICAgIC8vIGVxdWFscyB6b29taW5nIG91dCB3aXRoIGEgZGVsdGEgLTAuMVxuICAgICAgdmFyIHNjYWxlO1xuICAgICAgaWYgKGRlbHRhIDwgMCkge1xuICAgICAgICBzY2FsZSA9IDEgLSBkZWx0YSAvIDU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2FsZSA9IDEgLyAoMSArIGRlbHRhIC8gNSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNhbGN1bGF0ZSBjZW50ZXIsIHRoZSBkYXRlIHRvIHpvb20gYXJvdW5kXG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcih7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFkgfSwgdGhpcy5ib2R5LmRvbS5jZW50ZXIpO1xuICAgICAgdmFyIHBvaW50ZXJEYXRlID0gdGhpcy5fcG9pbnRlclRvRGF0ZShwb2ludGVyKTtcblxuICAgICAgdGhpcy56b29tKHNjYWxlLCBwb2ludGVyRGF0ZSwgZGVsdGEpO1xuICAgIH1cblxuICAgIC8vIFByZXZlbnQgZGVmYXVsdCBhY3Rpb25zIGNhdXNlZCBieSBtb3VzZSB3aGVlbFxuICAgIC8vIChlbHNlIHRoZSBwYWdlIGFuZCB0aW1lbGluZSBib3RoIHpvb20gYW5kIHNjcm9sbClcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdGFydCBvZiBhIHRvdWNoIGdlc3R1cmVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFJhbmdlLnByb3RvdHlwZS5fb25Ub3VjaCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHRoaXMucHJvcHMudG91Y2guc3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgIHRoaXMucHJvcHMudG91Y2guZW5kID0gdGhpcy5lbmQ7XG4gICAgdGhpcy5wcm9wcy50b3VjaC5hbGxvd0RyYWdnaW5nID0gdHJ1ZTtcbiAgICB0aGlzLnByb3BzLnRvdWNoLmNlbnRlciA9IG51bGw7XG4gICAgdGhpcy5zY2FsZU9mZnNldCA9IDA7XG4gICAgdGhpcy5kZWx0YURpZmZlcmVuY2UgPSAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgcGluY2ggZXZlbnRcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFJhbmdlLnByb3RvdHlwZS5fb25QaW5jaCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIG9ubHkgYWxsb3cgem9vbWluZyB3aGVuIGNvbmZpZ3VyZWQgYXMgem9vbWFibGUgYW5kIG1vdmVhYmxlXG4gICAgaWYgKCEodGhpcy5vcHRpb25zLnpvb21hYmxlICYmIHRoaXMub3B0aW9ucy5tb3ZlYWJsZSkpIHJldHVybjtcblxuICAgIHRoaXMucHJvcHMudG91Y2guYWxsb3dEcmFnZ2luZyA9IGZhbHNlO1xuXG4gICAgaWYgKCF0aGlzLnByb3BzLnRvdWNoLmNlbnRlcikge1xuICAgICAgdGhpcy5wcm9wcy50b3VjaC5jZW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyLCB0aGlzLmJvZHkuZG9tLmNlbnRlcik7XG4gICAgfVxuXG4gICAgdmFyIHNjYWxlID0gMSAvIChldmVudC5zY2FsZSArIHRoaXMuc2NhbGVPZmZzZXQpO1xuICAgIHZhciBjZW50ZXJEYXRlID0gdGhpcy5fcG9pbnRlclRvRGF0ZSh0aGlzLnByb3BzLnRvdWNoLmNlbnRlcik7XG5cbiAgICB2YXIgaGlkZGVuRHVyYXRpb24gPSBEYXRlVXRpbC5nZXRIaWRkZW5EdXJhdGlvbkJldHdlZW4odGhpcy5ib2R5LmhpZGRlbkRhdGVzLCB0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG4gICAgdmFyIGhpZGRlbkR1cmF0aW9uQmVmb3JlID0gRGF0ZVV0aWwuZ2V0SGlkZGVuRHVyYXRpb25CZWZvcmUodGhpcy5vcHRpb25zLm1vbWVudCwgdGhpcy5ib2R5LmhpZGRlbkRhdGVzLCB0aGlzLCBjZW50ZXJEYXRlKTtcbiAgICB2YXIgaGlkZGVuRHVyYXRpb25BZnRlciA9IGhpZGRlbkR1cmF0aW9uIC0gaGlkZGVuRHVyYXRpb25CZWZvcmU7XG5cbiAgICAvLyBjYWxjdWxhdGUgbmV3IHN0YXJ0IGFuZCBlbmRcbiAgICB2YXIgbmV3U3RhcnQgPSBjZW50ZXJEYXRlIC0gaGlkZGVuRHVyYXRpb25CZWZvcmUgKyAodGhpcy5wcm9wcy50b3VjaC5zdGFydCAtIChjZW50ZXJEYXRlIC0gaGlkZGVuRHVyYXRpb25CZWZvcmUpKSAqIHNjYWxlO1xuICAgIHZhciBuZXdFbmQgPSBjZW50ZXJEYXRlICsgaGlkZGVuRHVyYXRpb25BZnRlciArICh0aGlzLnByb3BzLnRvdWNoLmVuZCAtIChjZW50ZXJEYXRlICsgaGlkZGVuRHVyYXRpb25BZnRlcikpICogc2NhbGU7XG5cbiAgICAvLyBzbmFwcGluZyB0aW1lcyBhd2F5IGZyb20gaGlkZGVuIHpvbmVzXG4gICAgdGhpcy5zdGFydFRvRnJvbnQgPSAxIC0gc2NhbGUgPD0gMDsgLy8gdXNlZCB0byBkbyB0aGUgcmlnaHQgYXV0byBjb3JyZWN0aW9uIHdpdGggcGVyaW9kaWMgaGlkZGVuIHRpbWVzXG4gICAgdGhpcy5lbmRUb0Zyb250ID0gc2NhbGUgLSAxIDw9IDA7IC8vIHVzZWQgdG8gZG8gdGhlIHJpZ2h0IGF1dG8gY29ycmVjdGlvbiB3aXRoIHBlcmlvZGljIGhpZGRlbiB0aW1lc1xuXG4gICAgdmFyIHNhZmVTdGFydCA9IERhdGVVdGlsLnNuYXBBd2F5RnJvbUhpZGRlbih0aGlzLmJvZHkuaGlkZGVuRGF0ZXMsIG5ld1N0YXJ0LCAxIC0gc2NhbGUsIHRydWUpO1xuICAgIHZhciBzYWZlRW5kID0gRGF0ZVV0aWwuc25hcEF3YXlGcm9tSGlkZGVuKHRoaXMuYm9keS5oaWRkZW5EYXRlcywgbmV3RW5kLCBzY2FsZSAtIDEsIHRydWUpO1xuICAgIGlmIChzYWZlU3RhcnQgIT0gbmV3U3RhcnQgfHwgc2FmZUVuZCAhPSBuZXdFbmQpIHtcbiAgICAgIHRoaXMucHJvcHMudG91Y2guc3RhcnQgPSBzYWZlU3RhcnQ7XG4gICAgICB0aGlzLnByb3BzLnRvdWNoLmVuZCA9IHNhZmVFbmQ7XG4gICAgICB0aGlzLnNjYWxlT2Zmc2V0ID0gMSAtIGV2ZW50LnNjYWxlO1xuICAgICAgbmV3U3RhcnQgPSBzYWZlU3RhcnQ7XG4gICAgICBuZXdFbmQgPSBzYWZlRW5kO1xuICAgIH1cblxuICAgIHRoaXMuc2V0UmFuZ2UobmV3U3RhcnQsIG5ld0VuZCwgZmFsc2UsIHRydWUpO1xuXG4gICAgdGhpcy5zdGFydFRvRnJvbnQgPSBmYWxzZTsgLy8gcmV2ZXJ0IHRvIGRlZmF1bHRcbiAgICB0aGlzLmVuZFRvRnJvbnQgPSB0cnVlOyAvLyByZXZlcnQgdG8gZGVmYXVsdFxuICB9O1xuXG4gIC8qKlxuICAgKiBUZXN0IHdoZXRoZXIgdGhlIG1vdXNlIGZyb20gYSBtb3VzZSBldmVudCBpcyBpbnNpZGUgdGhlIHZpc2libGUgd2luZG93LFxuICAgKiBiZXR3ZWVuIHRoZSBjdXJyZW50IHN0YXJ0IGFuZCBlbmQgZGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIHdoZW4gaW5zaWRlIHRoZSB2aXNpYmxlIHdpbmRvd1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgUmFuZ2UucHJvdG90eXBlLl9pc0luc2lkZVJhbmdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gY2FsY3VsYXRlIHRoZSB0aW1lIHdoZXJlIHRoZSBtb3VzZSBpcywgY2hlY2sgd2hldGhlciBpbnNpZGVcbiAgICAvLyBhbmQgbm8gc2Nyb2xsIGFjdGlvbiBzaG91bGQgaGFwcGVuLlxuICAgIHZhciBjbGllbnRYID0gZXZlbnQuY2VudGVyID8gZXZlbnQuY2VudGVyLnggOiBldmVudC5jbGllbnRYO1xuICAgIGlmICh0aGlzLm9wdGlvbnMucnRsKSB7XG4gICAgICB2YXIgeCA9IGNsaWVudFggLSB1dGlsLmdldEFic29sdXRlTGVmdCh0aGlzLmJvZHkuZG9tLmNlbnRlckNvbnRhaW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB4ID0gdXRpbC5nZXRBYnNvbHV0ZVJpZ2h0KHRoaXMuYm9keS5kb20uY2VudGVyQ29udGFpbmVyKSAtIGNsaWVudFg7XG4gICAgfVxuICAgIHZhciB0aW1lID0gdGhpcy5ib2R5LnV0aWwudG9UaW1lKHgpO1xuXG4gICAgcmV0dXJuIHRpbWUgPj0gdGhpcy5zdGFydCAmJiB0aW1lIDw9IHRoaXMuZW5kO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gY2FsY3VsYXRlIHRoZSBjZW50ZXIgZGF0ZSBmb3Igem9vbWluZ1xuICAgKiBAcGFyYW0ge3t4OiBOdW1iZXIsIHk6IE51bWJlcn19IHBvaW50ZXJcbiAgICogQHJldHVybiB7bnVtYmVyfSBkYXRlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBSYW5nZS5wcm90b3R5cGUuX3BvaW50ZXJUb0RhdGUgPSBmdW5jdGlvbiAocG9pbnRlcikge1xuICAgIHZhciBjb252ZXJzaW9uO1xuICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uO1xuXG4gICAgdmFsaWRhdGVEaXJlY3Rpb24oZGlyZWN0aW9uKTtcblxuICAgIGlmIChkaXJlY3Rpb24gPT0gJ2hvcml6b250YWwnKSB7XG4gICAgICByZXR1cm4gdGhpcy5ib2R5LnV0aWwudG9UaW1lKHBvaW50ZXIueCkudmFsdWVPZigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5ib2R5LmRvbVByb3BzLmNlbnRlci5oZWlnaHQ7XG4gICAgICBjb252ZXJzaW9uID0gdGhpcy5jb252ZXJzaW9uKGhlaWdodCk7XG4gICAgICByZXR1cm4gcG9pbnRlci55IC8gY29udmVyc2lvbi5zY2FsZSArIGNvbnZlcnNpb24ub2Zmc2V0O1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBwb2ludGVyIGxvY2F0aW9uIHJlbGF0aXZlIHRvIHRoZSBsb2NhdGlvbiBvZiB0aGUgZG9tIGVsZW1lbnRcbiAgICogQHBhcmFtIHt7eDogTnVtYmVyLCB5OiBOdW1iZXJ9fSB0b3VjaFxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgICBIVE1MIERPTSBlbGVtZW50XG4gICAqIEByZXR1cm4ge3t4OiBOdW1iZXIsIHk6IE51bWJlcn19IHBvaW50ZXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFJhbmdlLnByb3RvdHlwZS5nZXRQb2ludGVyID0gZnVuY3Rpb24gKHRvdWNoLCBlbGVtZW50KSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHV0aWwuZ2V0QWJzb2x1dGVSaWdodChlbGVtZW50KSAtIHRvdWNoLngsXG4gICAgICAgIHk6IHRvdWNoLnkgLSB1dGlsLmdldEFic29sdXRlVG9wKGVsZW1lbnQpXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB0b3VjaC54IC0gdXRpbC5nZXRBYnNvbHV0ZUxlZnQoZWxlbWVudCksXG4gICAgICAgIHk6IHRvdWNoLnkgLSB1dGlsLmdldEFic29sdXRlVG9wKGVsZW1lbnQpXG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogWm9vbSB0aGUgcmFuZ2UgdGhlIGdpdmVuIHNjYWxlIGluIG9yIG91dC4gU3RhcnQgYW5kIGVuZCBkYXRlIHdpbGxcbiAgICogYmUgYWRqdXN0ZWQsIGFuZCB0aGUgdGltZWxpbmUgd2lsbCBiZSByZWRyYXduLiBZb3UgY2FuIG9wdGlvbmFsbHkgZ2l2ZSBhXG4gICAqIGRhdGUgYXJvdW5kIHdoaWNoIHRvIHpvb20uXG4gICAqIEZvciBleGFtcGxlLCB0cnkgc2NhbGUgPSAwLjkgb3IgMS4xXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSAgICAgIFNjYWxpbmcgZmFjdG9yLiBWYWx1ZXMgYWJvdmUgMSB3aWxsIHpvb20gb3V0LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgYmVsb3cgMSB3aWxsIHpvb20gaW4uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY2VudGVyXSAgIFZhbHVlIHJlcHJlc2VudGluZyBhIGRhdGUgYXJvdW5kIHdoaWNoIHdpbGxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgYmUgem9vbWVkLlxuICAgKi9cbiAgUmFuZ2UucHJvdG90eXBlLnpvb20gPSBmdW5jdGlvbiAoc2NhbGUsIGNlbnRlciwgZGVsdGEpIHtcbiAgICAvLyBpZiBjZW50ZXJEYXRlIGlzIG5vdCBwcm92aWRlZCwgdGFrZSBpdCBoYWxmIGJldHdlZW4gc3RhcnQgRGF0ZSBhbmQgZW5kIERhdGVcbiAgICBpZiAoY2VudGVyID09IG51bGwpIHtcbiAgICAgIGNlbnRlciA9ICh0aGlzLnN0YXJ0ICsgdGhpcy5lbmQpIC8gMjtcbiAgICB9XG5cbiAgICB2YXIgaGlkZGVuRHVyYXRpb24gPSBEYXRlVXRpbC5nZXRIaWRkZW5EdXJhdGlvbkJldHdlZW4odGhpcy5ib2R5LmhpZGRlbkRhdGVzLCB0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG4gICAgdmFyIGhpZGRlbkR1cmF0aW9uQmVmb3JlID0gRGF0ZVV0aWwuZ2V0SGlkZGVuRHVyYXRpb25CZWZvcmUodGhpcy5vcHRpb25zLm1vbWVudCwgdGhpcy5ib2R5LmhpZGRlbkRhdGVzLCB0aGlzLCBjZW50ZXIpO1xuICAgIHZhciBoaWRkZW5EdXJhdGlvbkFmdGVyID0gaGlkZGVuRHVyYXRpb24gLSBoaWRkZW5EdXJhdGlvbkJlZm9yZTtcblxuICAgIC8vIGNhbGN1bGF0ZSBuZXcgc3RhcnQgYW5kIGVuZFxuICAgIHZhciBuZXdTdGFydCA9IGNlbnRlciAtIGhpZGRlbkR1cmF0aW9uQmVmb3JlICsgKHRoaXMuc3RhcnQgLSAoY2VudGVyIC0gaGlkZGVuRHVyYXRpb25CZWZvcmUpKSAqIHNjYWxlO1xuICAgIHZhciBuZXdFbmQgPSBjZW50ZXIgKyBoaWRkZW5EdXJhdGlvbkFmdGVyICsgKHRoaXMuZW5kIC0gKGNlbnRlciArIGhpZGRlbkR1cmF0aW9uQWZ0ZXIpKSAqIHNjYWxlO1xuXG4gICAgLy8gc25hcHBpbmcgdGltZXMgYXdheSBmcm9tIGhpZGRlbiB6b25lc1xuICAgIHRoaXMuc3RhcnRUb0Zyb250ID0gZGVsdGEgPiAwID8gZmFsc2UgOiB0cnVlOyAvLyB1c2VkIHRvIGRvIHRoZSByaWdodCBhdXRvY29ycmVjdGlvbiB3aXRoIHBlcmlvZGljIGhpZGRlbiB0aW1lc1xuICAgIHRoaXMuZW5kVG9Gcm9udCA9IC1kZWx0YSA+IDAgPyBmYWxzZSA6IHRydWU7IC8vIHVzZWQgdG8gZG8gdGhlIHJpZ2h0IGF1dG9jb3JyZWN0aW9uIHdpdGggcGVyaW9kaWMgaGlkZGVuIHRpbWVzXG4gICAgdmFyIHNhZmVTdGFydCA9IERhdGVVdGlsLnNuYXBBd2F5RnJvbUhpZGRlbih0aGlzLmJvZHkuaGlkZGVuRGF0ZXMsIG5ld1N0YXJ0LCBkZWx0YSwgdHJ1ZSk7XG4gICAgdmFyIHNhZmVFbmQgPSBEYXRlVXRpbC5zbmFwQXdheUZyb21IaWRkZW4odGhpcy5ib2R5LmhpZGRlbkRhdGVzLCBuZXdFbmQsIC1kZWx0YSwgdHJ1ZSk7XG4gICAgaWYgKHNhZmVTdGFydCAhPSBuZXdTdGFydCB8fCBzYWZlRW5kICE9IG5ld0VuZCkge1xuICAgICAgbmV3U3RhcnQgPSBzYWZlU3RhcnQ7XG4gICAgICBuZXdFbmQgPSBzYWZlRW5kO1xuICAgIH1cblxuICAgIHRoaXMuc2V0UmFuZ2UobmV3U3RhcnQsIG5ld0VuZCwgZmFsc2UsIHRydWUpO1xuXG4gICAgdGhpcy5zdGFydFRvRnJvbnQgPSBmYWxzZTsgLy8gcmV2ZXJ0IHRvIGRlZmF1bHRcbiAgICB0aGlzLmVuZFRvRnJvbnQgPSB0cnVlOyAvLyByZXZlcnQgdG8gZGVmYXVsdFxuICB9O1xuXG4gIC8qKlxuICAgKiBNb3ZlIHRoZSByYW5nZSB3aXRoIGEgZ2l2ZW4gZGVsdGEgdG8gdGhlIGxlZnQgb3IgcmlnaHQuIFN0YXJ0IGFuZCBlbmRcbiAgICogdmFsdWUgd2lsbCBiZSBhZGp1c3RlZC4gRm9yIGV4YW1wbGUsIHRyeSBkZWx0YSA9IDAuMSBvciAtMC4xXG4gICAqIEBwYXJhbSB7TnVtYmVyfSAgZGVsdGEgICAgIE1vdmluZyBhbW91bnQuIFBvc2l0aXZlIHZhbHVlIHdpbGwgbW92ZSByaWdodCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVnYXRpdmUgdmFsdWUgd2lsbCBtb3ZlIGxlZnRcbiAgICovXG4gIFJhbmdlLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgLy8gem9vbSBzdGFydCBEYXRlIGFuZCBlbmQgRGF0ZSByZWxhdGl2ZSB0byB0aGUgY2VudGVyRGF0ZVxuICAgIHZhciBkaWZmID0gdGhpcy5lbmQgLSB0aGlzLnN0YXJ0O1xuXG4gICAgLy8gYXBwbHkgbmV3IHZhbHVlc1xuICAgIHZhciBuZXdTdGFydCA9IHRoaXMuc3RhcnQgKyBkaWZmICogZGVsdGE7XG4gICAgdmFyIG5ld0VuZCA9IHRoaXMuZW5kICsgZGlmZiAqIGRlbHRhO1xuXG4gICAgLy8gVE9ETzogcmVja29uIHdpdGggbWluIGFuZCBtYXggcmFuZ2VcblxuICAgIHRoaXMuc3RhcnQgPSBuZXdTdGFydDtcbiAgICB0aGlzLmVuZCA9IG5ld0VuZDtcbiAgfTtcblxuICAvKipcbiAgICogTW92ZSB0aGUgcmFuZ2UgdG8gYSBuZXcgY2VudGVyIHBvaW50XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtb3ZlVG8gICAgICBOZXcgY2VudGVyIHBvaW50IG9mIHRoZSByYW5nZVxuICAgKi9cbiAgUmFuZ2UucHJvdG90eXBlLm1vdmVUbyA9IGZ1bmN0aW9uIChtb3ZlVG8pIHtcbiAgICB2YXIgY2VudGVyID0gKHRoaXMuc3RhcnQgKyB0aGlzLmVuZCkgLyAyO1xuXG4gICAgdmFyIGRpZmYgPSBjZW50ZXIgLSBtb3ZlVG87XG5cbiAgICAvLyBjYWxjdWxhdGUgbmV3IHN0YXJ0IGFuZCBlbmRcbiAgICB2YXIgbmV3U3RhcnQgPSB0aGlzLnN0YXJ0IC0gZGlmZjtcbiAgICB2YXIgbmV3RW5kID0gdGhpcy5lbmQgLSBkaWZmO1xuXG4gICAgdGhpcy5zZXRSYW5nZShuZXdTdGFydCwgbmV3RW5kKTtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFJhbmdlO1xuXG4vKioqLyB9LFxuLyogMzEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIC8qKlxuICAgKiBQcm90b3R5cGUgZm9yIHZpc3VhbCBjb21wb25lbnRzXG4gICAqIEBwYXJhbSB7e2RvbTogT2JqZWN0LCBkb21Qcm9wczogT2JqZWN0LCBlbWl0dGVyOiBFbWl0dGVyLCByYW5nZTogUmFuZ2V9fSBbYm9keV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKi9cbiAgZnVuY3Rpb24gQ29tcG9uZW50KGJvZHksIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBudWxsO1xuICAgIHRoaXMucHJvcHMgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBvcHRpb25zIGZvciB0aGUgY29tcG9uZW50LiBUaGUgbmV3IG9wdGlvbnMgd2lsbCBiZSBtZXJnZWQgaW50byB0aGVcbiAgICogY3VycmVudCBvcHRpb25zLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgdXRpbC5leHRlbmQodGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcGFpbnQgdGhlIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGNvbXBvbmVudCBpcyByZXNpemVkXG4gICAqL1xuICBDb21wb25lbnQucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgYnkgdGhlIGNvbXBvbmVudFxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogRGVzdHJveSB0aGUgY29tcG9uZW50LiBDbGVhbnVwIERPTSBhbmQgZXZlbnQgbGlzdGVuZXJzXG4gICAqL1xuICBDb21wb25lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gc2hvdWxkIGJlIGltcGxlbWVudGVkIGJ5IHRoZSBjb21wb25lbnRcbiAgfTtcblxuICAvKipcbiAgICogVGVzdCB3aGV0aGVyIHRoZSBjb21wb25lbnQgaXMgcmVzaXplZCBzaW5jZSB0aGUgbGFzdCB0aW1lIF9pc1Jlc2l6ZWQoKSB3YXNcbiAgICogY2FsbGVkLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGNvbXBvbmVudCBpcyByZXNpemVkXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIENvbXBvbmVudC5wcm90b3R5cGUuX2lzUmVzaXplZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzaXplZCA9IHRoaXMucHJvcHMuX3ByZXZpb3VzV2lkdGggIT09IHRoaXMucHJvcHMud2lkdGggfHwgdGhpcy5wcm9wcy5fcHJldmlvdXNIZWlnaHQgIT09IHRoaXMucHJvcHMuaGVpZ2h0O1xuXG4gICAgdGhpcy5wcm9wcy5fcHJldmlvdXNXaWR0aCA9IHRoaXMucHJvcHMud2lkdGg7XG4gICAgdGhpcy5wcm9wcy5fcHJldmlvdXNIZWlnaHQgPSB0aGlzLnByb3BzLmhlaWdodDtcblxuICAgIHJldHVybiByZXNpemVkO1xuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50O1xuXG4vKioqLyB9LFxuLyogMzIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIC8qKlxuICAgKiB1c2VkIGluIENvcmUgdG8gY29udmVydCB0aGUgb3B0aW9ucyBpbnRvIGEgdm9sYXRpbGUgdmFyaWFibGVcbiAgICogXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1vbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0FycmF5IHwgT2JqZWN0fSBoaWRkZW5EYXRlc1xuICAgKi9cbiAgZXhwb3J0cy5jb252ZXJ0SGlkZGVuT3B0aW9ucyA9IGZ1bmN0aW9uIChtb21lbnQsIGJvZHksIGhpZGRlbkRhdGVzKSB7XG4gICAgaWYgKGhpZGRlbkRhdGVzICYmICFBcnJheS5pc0FycmF5KGhpZGRlbkRhdGVzKSkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuY29udmVydEhpZGRlbk9wdGlvbnMobW9tZW50LCBib2R5LCBbaGlkZGVuRGF0ZXNdKTtcbiAgICB9XG5cbiAgICBib2R5LmhpZGRlbkRhdGVzID0gW107XG4gICAgaWYgKGhpZGRlbkRhdGVzKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShoaWRkZW5EYXRlcykgPT0gdHJ1ZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhpZGRlbkRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGhpZGRlbkRhdGVzW2ldLnJlcGVhdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgZGF0ZUl0ZW0gPSB7fTtcbiAgICAgICAgICAgIGRhdGVJdGVtLnN0YXJ0ID0gbW9tZW50KGhpZGRlbkRhdGVzW2ldLnN0YXJ0KS50b0RhdGUoKS52YWx1ZU9mKCk7XG4gICAgICAgICAgICBkYXRlSXRlbS5lbmQgPSBtb21lbnQoaGlkZGVuRGF0ZXNbaV0uZW5kKS50b0RhdGUoKS52YWx1ZU9mKCk7XG4gICAgICAgICAgICBib2R5LmhpZGRlbkRhdGVzLnB1c2goZGF0ZUl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBib2R5LmhpZGRlbkRhdGVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gYS5zdGFydCAtIGIuc3RhcnQ7XG4gICAgICAgIH0pOyAvLyBzb3J0IGJ5IHN0YXJ0IHRpbWVcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBuZXcgZW50cmVlcyBmb3IgdGhlIHJlcGVhdGluZyBoaWRkZW4gZGF0ZXNcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gbW9tZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7QXJyYXkgfCBPYmplY3R9IGhpZGRlbkRhdGVzXG4gICAqL1xuICBleHBvcnRzLnVwZGF0ZUhpZGRlbkRhdGVzID0gZnVuY3Rpb24gKG1vbWVudCwgYm9keSwgaGlkZGVuRGF0ZXMpIHtcbiAgICBpZiAoaGlkZGVuRGF0ZXMgJiYgIUFycmF5LmlzQXJyYXkoaGlkZGVuRGF0ZXMpKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy51cGRhdGVIaWRkZW5EYXRlcyhtb21lbnQsIGJvZHksIFtoaWRkZW5EYXRlc10pO1xuICAgIH1cblxuICAgIGlmIChoaWRkZW5EYXRlcyAmJiBib2R5LmRvbVByb3BzLmNlbnRlckNvbnRhaW5lci53aWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBleHBvcnRzLmNvbnZlcnRIaWRkZW5PcHRpb25zKG1vbWVudCwgYm9keSwgaGlkZGVuRGF0ZXMpO1xuXG4gICAgICB2YXIgc3RhcnQgPSBtb21lbnQoYm9keS5yYW5nZS5zdGFydCk7XG4gICAgICB2YXIgZW5kID0gbW9tZW50KGJvZHkucmFuZ2UuZW5kKTtcblxuICAgICAgdmFyIHRvdGFsUmFuZ2UgPSBib2R5LnJhbmdlLmVuZCAtIGJvZHkucmFuZ2Uuc3RhcnQ7XG4gICAgICB2YXIgcGl4ZWxUaW1lID0gdG90YWxSYW5nZSAvIGJvZHkuZG9tUHJvcHMuY2VudGVyQ29udGFpbmVyLndpZHRoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhpZGRlbkRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChoaWRkZW5EYXRlc1tpXS5yZXBlYXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBzdGFydERhdGUgPSBtb21lbnQoaGlkZGVuRGF0ZXNbaV0uc3RhcnQpO1xuICAgICAgICAgIHZhciBlbmREYXRlID0gbW9tZW50KGhpZGRlbkRhdGVzW2ldLmVuZCk7XG5cbiAgICAgICAgICBpZiAoc3RhcnREYXRlLl9kID09IFwiSW52YWxpZCBEYXRlXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN1cHBsaWVkIHN0YXJ0IGRhdGUgaXMgbm90IHZhbGlkOiBcIiArIGhpZGRlbkRhdGVzW2ldLnN0YXJ0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVuZERhdGUuX2QgPT0gXCJJbnZhbGlkIERhdGVcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3VwcGxpZWQgZW5kIGRhdGUgaXMgbm90IHZhbGlkOiBcIiArIGhpZGRlbkRhdGVzW2ldLmVuZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGR1cmF0aW9uID0gZW5kRGF0ZSAtIHN0YXJ0RGF0ZTtcbiAgICAgICAgICBpZiAoZHVyYXRpb24gPj0gNCAqIHBpeGVsVGltZSkge1xuXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIHZhciBydW5VbnRpbCA9IGVuZC5jbG9uZSgpO1xuICAgICAgICAgICAgc3dpdGNoIChoaWRkZW5EYXRlc1tpXS5yZXBlYXQpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImRhaWx5XCI6XG4gICAgICAgICAgICAgICAgLy8gY2FzZSBvZiB0aW1lXG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0RGF0ZS5kYXkoKSAhPSBlbmREYXRlLmRheSgpKSB7XG4gICAgICAgICAgICAgICAgICBvZmZzZXQgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGFydERhdGUuZGF5T2ZZZWFyKHN0YXJ0LmRheU9mWWVhcigpKTtcbiAgICAgICAgICAgICAgICBzdGFydERhdGUueWVhcihzdGFydC55ZWFyKCkpO1xuICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS5zdWJ0cmFjdCg3LCAnZGF5cycpO1xuXG4gICAgICAgICAgICAgICAgZW5kRGF0ZS5kYXlPZlllYXIoc3RhcnQuZGF5T2ZZZWFyKCkpO1xuICAgICAgICAgICAgICAgIGVuZERhdGUueWVhcihzdGFydC55ZWFyKCkpO1xuICAgICAgICAgICAgICAgIGVuZERhdGUuc3VidHJhY3QoNyAtIG9mZnNldCwgJ2RheXMnKTtcblxuICAgICAgICAgICAgICAgIHJ1blVudGlsLmFkZCgxLCAnd2Vla3MnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcIndlZWtseVwiOlxuICAgICAgICAgICAgICAgIHZhciBkYXlPZmZzZXQgPSBlbmREYXRlLmRpZmYoc3RhcnREYXRlLCAnZGF5cycpO1xuICAgICAgICAgICAgICAgIHZhciBkYXkgPSBzdGFydERhdGUuZGF5KCk7XG5cbiAgICAgICAgICAgICAgICAvLyBzZXQgdGhlIHN0YXJ0IGRhdGUgdG8gdGhlIHJhbmdlLnN0YXJ0XG4gICAgICAgICAgICAgICAgc3RhcnREYXRlLmRhdGUoc3RhcnQuZGF0ZSgpKTtcbiAgICAgICAgICAgICAgICBzdGFydERhdGUubW9udGgoc3RhcnQubW9udGgoKSk7XG4gICAgICAgICAgICAgICAgc3RhcnREYXRlLnllYXIoc3RhcnQueWVhcigpKTtcbiAgICAgICAgICAgICAgICBlbmREYXRlID0gc3RhcnREYXRlLmNsb25lKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBmb3JjZVxuICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS5kYXkoZGF5KTtcbiAgICAgICAgICAgICAgICBlbmREYXRlLmRheShkYXkpO1xuICAgICAgICAgICAgICAgIGVuZERhdGUuYWRkKGRheU9mZnNldCwgJ2RheXMnKTtcblxuICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS5zdWJ0cmFjdCgxLCAnd2Vla3MnKTtcbiAgICAgICAgICAgICAgICBlbmREYXRlLnN1YnRyYWN0KDEsICd3ZWVrcycpO1xuXG4gICAgICAgICAgICAgICAgcnVuVW50aWwuYWRkKDEsICd3ZWVrcycpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwibW9udGhseVwiOlxuICAgICAgICAgICAgICAgIGlmIChzdGFydERhdGUubW9udGgoKSAhPSBlbmREYXRlLm1vbnRoKCkpIHtcbiAgICAgICAgICAgICAgICAgIG9mZnNldCA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS5tb250aChzdGFydC5tb250aCgpKTtcbiAgICAgICAgICAgICAgICBzdGFydERhdGUueWVhcihzdGFydC55ZWFyKCkpO1xuICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS5zdWJ0cmFjdCgxLCAnbW9udGhzJyk7XG5cbiAgICAgICAgICAgICAgICBlbmREYXRlLm1vbnRoKHN0YXJ0Lm1vbnRoKCkpO1xuICAgICAgICAgICAgICAgIGVuZERhdGUueWVhcihzdGFydC55ZWFyKCkpO1xuICAgICAgICAgICAgICAgIGVuZERhdGUuc3VidHJhY3QoMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgICAgIGVuZERhdGUuYWRkKG9mZnNldCwgJ21vbnRocycpO1xuXG4gICAgICAgICAgICAgICAgcnVuVW50aWwuYWRkKDEsICdtb250aHMnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcInllYXJseVwiOlxuICAgICAgICAgICAgICAgIGlmIChzdGFydERhdGUueWVhcigpICE9IGVuZERhdGUueWVhcigpKSB7XG4gICAgICAgICAgICAgICAgICBvZmZzZXQgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGFydERhdGUueWVhcihzdGFydC55ZWFyKCkpO1xuICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS5zdWJ0cmFjdCgxLCAneWVhcnMnKTtcbiAgICAgICAgICAgICAgICBlbmREYXRlLnllYXIoc3RhcnQueWVhcigpKTtcbiAgICAgICAgICAgICAgICBlbmREYXRlLnN1YnRyYWN0KDEsICd5ZWFycycpO1xuICAgICAgICAgICAgICAgIGVuZERhdGUuYWRkKG9mZnNldCwgJ3llYXJzJyk7XG5cbiAgICAgICAgICAgICAgICBydW5VbnRpbC5hZGQoMSwgJ3llYXJzJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJXcm9uZyByZXBlYXQgZm9ybWF0LCBhbGxvd2VkIGFyZTogZGFpbHksIHdlZWtseSwgbW9udGhseSwgeWVhcmx5LiBHaXZlbjpcIiwgaGlkZGVuRGF0ZXNbaV0ucmVwZWF0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoc3RhcnREYXRlIDwgcnVuVW50aWwpIHtcbiAgICAgICAgICAgICAgYm9keS5oaWRkZW5EYXRlcy5wdXNoKHsgc3RhcnQ6IHN0YXJ0RGF0ZS52YWx1ZU9mKCksIGVuZDogZW5kRGF0ZS52YWx1ZU9mKCkgfSk7XG4gICAgICAgICAgICAgIHN3aXRjaCAoaGlkZGVuRGF0ZXNbaV0ucmVwZWF0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImRhaWx5XCI6XG4gICAgICAgICAgICAgICAgICBzdGFydERhdGUuYWRkKDEsICdkYXlzJyk7XG4gICAgICAgICAgICAgICAgICBlbmREYXRlLmFkZCgxLCAnZGF5cycpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIndlZWtseVwiOlxuICAgICAgICAgICAgICAgICAgc3RhcnREYXRlLmFkZCgxLCAnd2Vla3MnKTtcbiAgICAgICAgICAgICAgICAgIGVuZERhdGUuYWRkKDEsICd3ZWVrcycpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm1vbnRobHlcIjpcbiAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS5hZGQoMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgICAgICAgZW5kRGF0ZS5hZGQoMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInllYXJseVwiOlxuICAgICAgICAgICAgICAgICAgc3RhcnREYXRlLmFkZCgxLCAneScpO1xuICAgICAgICAgICAgICAgICAgZW5kRGF0ZS5hZGQoMSwgJ3knKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIldyb25nIHJlcGVhdCBmb3JtYXQsIGFsbG93ZWQgYXJlOiBkYWlseSwgd2Vla2x5LCBtb250aGx5LCB5ZWFybHkuIEdpdmVuOlwiLCBoaWRkZW5EYXRlc1tpXS5yZXBlYXQpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib2R5LmhpZGRlbkRhdGVzLnB1c2goeyBzdGFydDogc3RhcnREYXRlLnZhbHVlT2YoKSwgZW5kOiBlbmREYXRlLnZhbHVlT2YoKSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIHJlbW92ZSBkdXBsaWNhdGVzLCBtZXJnZSB3aGVyZSBwb3NzaWJsZVxuICAgICAgZXhwb3J0cy5yZW1vdmVEdXBsaWNhdGVzKGJvZHkpO1xuICAgICAgLy8gZW5zdXJlIHRoZSBuZXcgcG9zaXRpb25zIGFyZSBub3Qgb24gaGlkZGVuIGRhdGVzXG4gICAgICB2YXIgc3RhcnRIaWRkZW4gPSBleHBvcnRzLmlzSGlkZGVuKGJvZHkucmFuZ2Uuc3RhcnQsIGJvZHkuaGlkZGVuRGF0ZXMpO1xuICAgICAgdmFyIGVuZEhpZGRlbiA9IGV4cG9ydHMuaXNIaWRkZW4oYm9keS5yYW5nZS5lbmQsIGJvZHkuaGlkZGVuRGF0ZXMpO1xuICAgICAgdmFyIHJhbmdlU3RhcnQgPSBib2R5LnJhbmdlLnN0YXJ0O1xuICAgICAgdmFyIHJhbmdlRW5kID0gYm9keS5yYW5nZS5lbmQ7XG4gICAgICBpZiAoc3RhcnRIaWRkZW4uaGlkZGVuID09IHRydWUpIHtcbiAgICAgICAgcmFuZ2VTdGFydCA9IGJvZHkucmFuZ2Uuc3RhcnRUb0Zyb250ID09IHRydWUgPyBzdGFydEhpZGRlbi5zdGFydERhdGUgLSAxIDogc3RhcnRIaWRkZW4uZW5kRGF0ZSArIDE7XG4gICAgICB9XG4gICAgICBpZiAoZW5kSGlkZGVuLmhpZGRlbiA9PSB0cnVlKSB7XG4gICAgICAgIHJhbmdlRW5kID0gYm9keS5yYW5nZS5lbmRUb0Zyb250ID09IHRydWUgPyBlbmRIaWRkZW4uc3RhcnREYXRlIC0gMSA6IGVuZEhpZGRlbi5lbmREYXRlICsgMTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydEhpZGRlbi5oaWRkZW4gPT0gdHJ1ZSB8fCBlbmRIaWRkZW4uaGlkZGVuID09IHRydWUpIHtcbiAgICAgICAgYm9keS5yYW5nZS5fYXBwbHlSYW5nZShyYW5nZVN0YXJ0LCByYW5nZUVuZCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiByZW1vdmUgZHVwbGljYXRlcyBmcm9tIHRoZSBoaWRkZW4gZGF0ZXMgbGlzdC4gRHVwbGljYXRlcyBhcmUgZXZpbC4gVGhleSBtZXNzIGV2ZXJ5dGhpbmcgdXAuXG4gICAqIFNjYWxlcyB3aXRoIE5eMlxuICAgKiBAcGFyYW0gYm9keVxuICAgKi9cbiAgZXhwb3J0cy5yZW1vdmVEdXBsaWNhdGVzID0gZnVuY3Rpb24gKGJvZHkpIHtcbiAgICB2YXIgaGlkZGVuRGF0ZXMgPSBib2R5LmhpZGRlbkRhdGVzO1xuICAgIHZhciBzYWZlRGF0ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhpZGRlbkRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGhpZGRlbkRhdGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChpICE9IGogJiYgaGlkZGVuRGF0ZXNbal0ucmVtb3ZlICE9IHRydWUgJiYgaGlkZGVuRGF0ZXNbaV0ucmVtb3ZlICE9IHRydWUpIHtcbiAgICAgICAgICAvLyBqIGluc2lkZSBpXG4gICAgICAgICAgaWYgKGhpZGRlbkRhdGVzW2pdLnN0YXJ0ID49IGhpZGRlbkRhdGVzW2ldLnN0YXJ0ICYmIGhpZGRlbkRhdGVzW2pdLmVuZCA8PSBoaWRkZW5EYXRlc1tpXS5lbmQpIHtcbiAgICAgICAgICAgIGhpZGRlbkRhdGVzW2pdLnJlbW92ZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGogc3RhcnQgaW5zaWRlIGlcbiAgICAgICAgICBlbHNlIGlmIChoaWRkZW5EYXRlc1tqXS5zdGFydCA+PSBoaWRkZW5EYXRlc1tpXS5zdGFydCAmJiBoaWRkZW5EYXRlc1tqXS5zdGFydCA8PSBoaWRkZW5EYXRlc1tpXS5lbmQpIHtcbiAgICAgICAgICAgICAgaGlkZGVuRGF0ZXNbaV0uZW5kID0gaGlkZGVuRGF0ZXNbal0uZW5kO1xuICAgICAgICAgICAgICBoaWRkZW5EYXRlc1tqXS5yZW1vdmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaiBlbmQgaW5zaWRlIGlcbiAgICAgICAgICAgIGVsc2UgaWYgKGhpZGRlbkRhdGVzW2pdLmVuZCA+PSBoaWRkZW5EYXRlc1tpXS5zdGFydCAmJiBoaWRkZW5EYXRlc1tqXS5lbmQgPD0gaGlkZGVuRGF0ZXNbaV0uZW5kKSB7XG4gICAgICAgICAgICAgICAgaGlkZGVuRGF0ZXNbaV0uc3RhcnQgPSBoaWRkZW5EYXRlc1tqXS5zdGFydDtcbiAgICAgICAgICAgICAgICBoaWRkZW5EYXRlc1tqXS5yZW1vdmUgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhpZGRlbkRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaGlkZGVuRGF0ZXNbaV0ucmVtb3ZlICE9PSB0cnVlKSB7XG4gICAgICAgIHNhZmVEYXRlcy5wdXNoKGhpZGRlbkRhdGVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBib2R5LmhpZGRlbkRhdGVzID0gc2FmZURhdGVzO1xuICAgIGJvZHkuaGlkZGVuRGF0ZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEuc3RhcnQgLSBiLnN0YXJ0O1xuICAgIH0pOyAvLyBzb3J0IGJ5IHN0YXJ0IHRpbWVcbiAgfTtcblxuICBleHBvcnRzLnByaW50RGF0ZXMgPSBmdW5jdGlvbiAoZGF0ZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zb2xlLmxvZyhpLCBuZXcgRGF0ZShkYXRlc1tpXS5zdGFydCksIG5ldyBEYXRlKGRhdGVzW2ldLmVuZCksIGRhdGVzW2ldLnN0YXJ0LCBkYXRlc1tpXS5lbmQsIGRhdGVzW2ldLnJlbW92ZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBVc2VkIGluIFRpbWVTdGVwIHRvIGF2b2lkIHRoZSBoaWRkZW4gdGltZXMuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1vbWVudFxuICAgKiBAcGFyYW0ge1RpbWVTdGVwfSB0aW1lU3RlcFxuICAgKiBAcGFyYW0gcHJldmlvdXNUaW1lXG4gICAqL1xuICBleHBvcnRzLnN0ZXBPdmVySGlkZGVuRGF0ZXMgPSBmdW5jdGlvbiAobW9tZW50LCB0aW1lU3RlcCwgcHJldmlvdXNUaW1lKSB7XG4gICAgdmFyIHN0ZXBJbkhpZGRlbiA9IGZhbHNlO1xuICAgIHZhciBjdXJyZW50VmFsdWUgPSB0aW1lU3RlcC5jdXJyZW50LnZhbHVlT2YoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpbWVTdGVwLmhpZGRlbkRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc3RhcnREYXRlID0gdGltZVN0ZXAuaGlkZGVuRGF0ZXNbaV0uc3RhcnQ7XG4gICAgICB2YXIgZW5kRGF0ZSA9IHRpbWVTdGVwLmhpZGRlbkRhdGVzW2ldLmVuZDtcbiAgICAgIGlmIChjdXJyZW50VmFsdWUgPj0gc3RhcnREYXRlICYmIGN1cnJlbnRWYWx1ZSA8IGVuZERhdGUpIHtcbiAgICAgICAgc3RlcEluSGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0ZXBJbkhpZGRlbiA9PSB0cnVlICYmIGN1cnJlbnRWYWx1ZSA8IHRpbWVTdGVwLl9lbmQudmFsdWVPZigpICYmIGN1cnJlbnRWYWx1ZSAhPSBwcmV2aW91c1RpbWUpIHtcbiAgICAgIHZhciBwcmV2VmFsdWUgPSBtb21lbnQocHJldmlvdXNUaW1lKTtcbiAgICAgIHZhciBuZXdWYWx1ZSA9IG1vbWVudChlbmREYXRlKTtcbiAgICAgIC8vY2hlY2sgaWYgdGhlIG5leHQgc3RlcCBzaG91bGQgYmUgbWFqb3JcbiAgICAgIGlmIChwcmV2VmFsdWUueWVhcigpICE9IG5ld1ZhbHVlLnllYXIoKSkge1xuICAgICAgICB0aW1lU3RlcC5zd2l0Y2hlZFllYXIgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChwcmV2VmFsdWUubW9udGgoKSAhPSBuZXdWYWx1ZS5tb250aCgpKSB7XG4gICAgICAgIHRpbWVTdGVwLnN3aXRjaGVkTW9udGggPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChwcmV2VmFsdWUuZGF5T2ZZZWFyKCkgIT0gbmV3VmFsdWUuZGF5T2ZZZWFyKCkpIHtcbiAgICAgICAgdGltZVN0ZXAuc3dpdGNoZWREYXkgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB0aW1lU3RlcC5jdXJyZW50ID0gbmV3VmFsdWU7XG4gICAgfVxuICB9O1xuXG4gIC8vLyoqXG4gIC8vICogVXNlZCBpbiBUaW1lU3RlcCB0byBhdm9pZCB0aGUgaGlkZGVuIHRpbWVzLlxuICAvLyAqIEBwYXJhbSB0aW1lU3RlcFxuICAvLyAqIEBwYXJhbSBwcmV2aW91c1RpbWVcbiAgLy8gKi9cbiAgLy9leHBvcnRzLmNoZWNrRmlyc3RTdGVwID0gZnVuY3Rpb24odGltZVN0ZXApIHtcbiAgLy8gIHZhciBzdGVwSW5IaWRkZW4gPSBmYWxzZTtcbiAgLy8gIHZhciBjdXJyZW50VmFsdWUgPSB0aW1lU3RlcC5jdXJyZW50LnZhbHVlT2YoKTtcbiAgLy8gIGZvciAodmFyIGkgPSAwOyBpIDwgdGltZVN0ZXAuaGlkZGVuRGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgLy8gICAgdmFyIHN0YXJ0RGF0ZSA9IHRpbWVTdGVwLmhpZGRlbkRhdGVzW2ldLnN0YXJ0O1xuICAvLyAgICB2YXIgZW5kRGF0ZSA9IHRpbWVTdGVwLmhpZGRlbkRhdGVzW2ldLmVuZDtcbiAgLy8gICAgaWYgKGN1cnJlbnRWYWx1ZSA+PSBzdGFydERhdGUgJiYgY3VycmVudFZhbHVlIDwgZW5kRGF0ZSkge1xuICAvLyAgICAgIHN0ZXBJbkhpZGRlbiA9IHRydWU7XG4gIC8vICAgICAgYnJlYWs7XG4gIC8vICAgIH1cbiAgLy8gIH1cbiAgLy9cbiAgLy8gIGlmIChzdGVwSW5IaWRkZW4gPT0gdHJ1ZSAmJiBjdXJyZW50VmFsdWUgPD0gdGltZVN0ZXAuX2VuZC52YWx1ZU9mKCkpIHtcbiAgLy8gICAgdmFyIG5ld1ZhbHVlID0gbW9tZW50KGVuZERhdGUpO1xuICAvLyAgICB0aW1lU3RlcC5jdXJyZW50ID0gbmV3VmFsdWUudG9EYXRlKCk7XG4gIC8vICB9XG4gIC8vfTtcblxuICAvKipcbiAgICogcmVwbGFjZXMgdGhlIENvcmUgdG9TY3JlZW4gbWV0aG9kc1xuICAgKiBAcGFyYW0gQ29yZVxuICAgKiBAcGFyYW0gdGltZVxuICAgKiBAcGFyYW0gd2lkdGhcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGV4cG9ydHMudG9TY3JlZW4gPSBmdW5jdGlvbiAoQ29yZSwgdGltZSwgd2lkdGgpIHtcbiAgICBpZiAoQ29yZS5ib2R5LmhpZGRlbkRhdGVzLmxlbmd0aCA9PSAwKSB7XG4gICAgICB2YXIgY29udmVyc2lvbiA9IENvcmUucmFuZ2UuY29udmVyc2lvbih3aWR0aCk7XG4gICAgICByZXR1cm4gKHRpbWUudmFsdWVPZigpIC0gY29udmVyc2lvbi5vZmZzZXQpICogY29udmVyc2lvbi5zY2FsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGhpZGRlbiA9IGV4cG9ydHMuaXNIaWRkZW4odGltZSwgQ29yZS5ib2R5LmhpZGRlbkRhdGVzKTtcbiAgICAgIGlmIChoaWRkZW4uaGlkZGVuID09IHRydWUpIHtcbiAgICAgICAgdGltZSA9IGhpZGRlbi5zdGFydERhdGU7XG4gICAgICB9XG5cbiAgICAgIHZhciBkdXJhdGlvbiA9IGV4cG9ydHMuZ2V0SGlkZGVuRHVyYXRpb25CZXR3ZWVuKENvcmUuYm9keS5oaWRkZW5EYXRlcywgQ29yZS5yYW5nZS5zdGFydCwgQ29yZS5yYW5nZS5lbmQpO1xuICAgICAgdGltZSA9IGV4cG9ydHMuY29ycmVjdFRpbWVGb3JIaWRkZW4oQ29yZS5vcHRpb25zLm1vbWVudCwgQ29yZS5ib2R5LmhpZGRlbkRhdGVzLCBDb3JlLnJhbmdlLCB0aW1lKTtcblxuICAgICAgdmFyIGNvbnZlcnNpb24gPSBDb3JlLnJhbmdlLmNvbnZlcnNpb24od2lkdGgsIGR1cmF0aW9uKTtcbiAgICAgIHJldHVybiAodGltZS52YWx1ZU9mKCkgLSBjb252ZXJzaW9uLm9mZnNldCkgKiBjb252ZXJzaW9uLnNjYWxlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVwbGFjZXMgdGhlIGNvcmUgdG9UaW1lIG1ldGhvZHNcbiAgICogQHBhcmFtIGJvZHlcbiAgICogQHBhcmFtIHJhbmdlXG4gICAqIEBwYXJhbSB4XG4gICAqIEBwYXJhbSB3aWR0aFxuICAgKiBAcmV0dXJucyB7RGF0ZX1cbiAgICovXG4gIGV4cG9ydHMudG9UaW1lID0gZnVuY3Rpb24gKENvcmUsIHgsIHdpZHRoKSB7XG4gICAgaWYgKENvcmUuYm9keS5oaWRkZW5EYXRlcy5sZW5ndGggPT0gMCkge1xuICAgICAgdmFyIGNvbnZlcnNpb24gPSBDb3JlLnJhbmdlLmNvbnZlcnNpb24od2lkdGgpO1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKHggLyBjb252ZXJzaW9uLnNjYWxlICsgY29udmVyc2lvbi5vZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaGlkZGVuRHVyYXRpb24gPSBleHBvcnRzLmdldEhpZGRlbkR1cmF0aW9uQmV0d2VlbihDb3JlLmJvZHkuaGlkZGVuRGF0ZXMsIENvcmUucmFuZ2Uuc3RhcnQsIENvcmUucmFuZ2UuZW5kKTtcbiAgICAgIHZhciB0b3RhbER1cmF0aW9uID0gQ29yZS5yYW5nZS5lbmQgLSBDb3JlLnJhbmdlLnN0YXJ0IC0gaGlkZGVuRHVyYXRpb247XG4gICAgICB2YXIgcGFydGlhbER1cmF0aW9uID0gdG90YWxEdXJhdGlvbiAqIHggLyB3aWR0aDtcbiAgICAgIHZhciBhY2N1bXVsYXRlZEhpZGRlbkR1cmF0aW9uID0gZXhwb3J0cy5nZXRBY2N1bXVsYXRlZEhpZGRlbkR1cmF0aW9uKENvcmUuYm9keS5oaWRkZW5EYXRlcywgQ29yZS5yYW5nZSwgcGFydGlhbER1cmF0aW9uKTtcblxuICAgICAgdmFyIG5ld1RpbWUgPSBuZXcgRGF0ZShhY2N1bXVsYXRlZEhpZGRlbkR1cmF0aW9uICsgcGFydGlhbER1cmF0aW9uICsgQ29yZS5yYW5nZS5zdGFydCk7XG4gICAgICByZXR1cm4gbmV3VGltZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFN1cHBvcnQgZnVuY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIGhpZGRlbkRhdGVzXG4gICAqIEBwYXJhbSByYW5nZVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZXhwb3J0cy5nZXRIaWRkZW5EdXJhdGlvbkJldHdlZW4gPSBmdW5jdGlvbiAoaGlkZGVuRGF0ZXMsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgZHVyYXRpb24gPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGlkZGVuRGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzdGFydERhdGUgPSBoaWRkZW5EYXRlc1tpXS5zdGFydDtcbiAgICAgIHZhciBlbmREYXRlID0gaGlkZGVuRGF0ZXNbaV0uZW5kO1xuICAgICAgLy8gaWYgdGltZSBhZnRlciB0aGUgY3V0b3V0LCBhbmQgdGhlXG4gICAgICBpZiAoc3RhcnREYXRlID49IHN0YXJ0ICYmIGVuZERhdGUgPCBlbmQpIHtcbiAgICAgICAgZHVyYXRpb24gKz0gZW5kRGF0ZSAtIHN0YXJ0RGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGR1cmF0aW9uO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdXBwb3J0IGZ1bmN0aW9uXG4gICAqIEBwYXJhbSBtb21lbnRcbiAgICogQHBhcmFtIGhpZGRlbkRhdGVzXG4gICAqIEBwYXJhbSByYW5nZVxuICAgKiBAcGFyYW0gdGltZVxuICAgKiBAcmV0dXJucyB7e2R1cmF0aW9uOiBudW1iZXIsIHRpbWU6ICosIG9mZnNldDogbnVtYmVyfX1cbiAgICovXG4gIGV4cG9ydHMuY29ycmVjdFRpbWVGb3JIaWRkZW4gPSBmdW5jdGlvbiAobW9tZW50LCBoaWRkZW5EYXRlcywgcmFuZ2UsIHRpbWUpIHtcbiAgICB0aW1lID0gbW9tZW50KHRpbWUpLnRvRGF0ZSgpLnZhbHVlT2YoKTtcbiAgICB0aW1lIC09IGV4cG9ydHMuZ2V0SGlkZGVuRHVyYXRpb25CZWZvcmUobW9tZW50LCBoaWRkZW5EYXRlcywgcmFuZ2UsIHRpbWUpO1xuICAgIHJldHVybiB0aW1lO1xuICB9O1xuXG4gIGV4cG9ydHMuZ2V0SGlkZGVuRHVyYXRpb25CZWZvcmUgPSBmdW5jdGlvbiAobW9tZW50LCBoaWRkZW5EYXRlcywgcmFuZ2UsIHRpbWUpIHtcbiAgICB2YXIgdGltZU9mZnNldCA9IDA7XG4gICAgdGltZSA9IG1vbWVudCh0aW1lKS50b0RhdGUoKS52YWx1ZU9mKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhpZGRlbkRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc3RhcnREYXRlID0gaGlkZGVuRGF0ZXNbaV0uc3RhcnQ7XG4gICAgICB2YXIgZW5kRGF0ZSA9IGhpZGRlbkRhdGVzW2ldLmVuZDtcbiAgICAgIC8vIGlmIHRpbWUgYWZ0ZXIgdGhlIGN1dG91dCwgYW5kIHRoZVxuICAgICAgaWYgKHN0YXJ0RGF0ZSA+PSByYW5nZS5zdGFydCAmJiBlbmREYXRlIDwgcmFuZ2UuZW5kKSB7XG4gICAgICAgIGlmICh0aW1lID49IGVuZERhdGUpIHtcbiAgICAgICAgICB0aW1lT2Zmc2V0ICs9IGVuZERhdGUgLSBzdGFydERhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRpbWVPZmZzZXQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIHN1bSB0aGUgZHVyYXRpb24gZnJvbSBzdGFydCB0byBmaW5pc2gsIGluY2x1ZGluZyB0aGUgaGlkZGVuIGR1cmF0aW9uLFxuICAgKiB1bnRpbCB0aGUgcmVxdWlyZWQgYW1vdW50IGhhcyBiZWVuIHJlYWNoZWQsIHJldHVybiB0aGUgYWNjdW11bGF0ZWQgaGlkZGVuIGR1cmF0aW9uXG4gICAqIEBwYXJhbSBoaWRkZW5EYXRlc1xuICAgKiBAcGFyYW0gcmFuZ2VcbiAgICogQHBhcmFtIHRpbWVcbiAgICogQHJldHVybnMge3tkdXJhdGlvbjogbnVtYmVyLCB0aW1lOiAqLCBvZmZzZXQ6IG51bWJlcn19XG4gICAqL1xuICBleHBvcnRzLmdldEFjY3VtdWxhdGVkSGlkZGVuRHVyYXRpb24gPSBmdW5jdGlvbiAoaGlkZGVuRGF0ZXMsIHJhbmdlLCByZXF1aXJlZER1cmF0aW9uKSB7XG4gICAgdmFyIGhpZGRlbkR1cmF0aW9uID0gMDtcbiAgICB2YXIgZHVyYXRpb24gPSAwO1xuICAgIHZhciBwcmV2aW91c1BvaW50ID0gcmFuZ2Uuc3RhcnQ7XG4gICAgLy9leHBvcnRzLnByaW50RGF0ZXMoaGlkZGVuRGF0ZXMpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoaWRkZW5EYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHN0YXJ0RGF0ZSA9IGhpZGRlbkRhdGVzW2ldLnN0YXJ0O1xuICAgICAgdmFyIGVuZERhdGUgPSBoaWRkZW5EYXRlc1tpXS5lbmQ7XG4gICAgICAvLyBpZiB0aW1lIGFmdGVyIHRoZSBjdXRvdXQsIGFuZCB0aGVcbiAgICAgIGlmIChzdGFydERhdGUgPj0gcmFuZ2Uuc3RhcnQgJiYgZW5kRGF0ZSA8IHJhbmdlLmVuZCkge1xuICAgICAgICBkdXJhdGlvbiArPSBzdGFydERhdGUgLSBwcmV2aW91c1BvaW50O1xuICAgICAgICBwcmV2aW91c1BvaW50ID0gZW5kRGF0ZTtcbiAgICAgICAgaWYgKGR1cmF0aW9uID49IHJlcXVpcmVkRHVyYXRpb24pIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoaWRkZW5EdXJhdGlvbiArPSBlbmREYXRlIC0gc3RhcnREYXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGhpZGRlbkR1cmF0aW9uO1xuICB9O1xuXG4gIC8qKlxuICAgKiB1c2VkIHRvIHN0ZXAgb3ZlciB0byBlaXRoZXIgc2lkZSBvZiBhIGhpZGRlbiBibG9jay4gQ29ycmVjdGlvbiBpcyBkaXNhYmxlZCBvbiB0YWJsZXRzLCBtaWdodCBiZSBzZXQgdG8gdHJ1ZVxuICAgKiBAcGFyYW0gaGlkZGVuRGF0ZXNcbiAgICogQHBhcmFtIHRpbWVcbiAgICogQHBhcmFtIGRpcmVjdGlvblxuICAgKiBAcGFyYW0gY29ycmVjdGlvbkVuYWJsZWRcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBleHBvcnRzLnNuYXBBd2F5RnJvbUhpZGRlbiA9IGZ1bmN0aW9uIChoaWRkZW5EYXRlcywgdGltZSwgZGlyZWN0aW9uLCBjb3JyZWN0aW9uRW5hYmxlZCkge1xuICAgIHZhciBpc0hpZGRlbiA9IGV4cG9ydHMuaXNIaWRkZW4odGltZSwgaGlkZGVuRGF0ZXMpO1xuICAgIGlmIChpc0hpZGRlbi5oaWRkZW4gPT0gdHJ1ZSkge1xuICAgICAgaWYgKGRpcmVjdGlvbiA8IDApIHtcbiAgICAgICAgaWYgKGNvcnJlY3Rpb25FbmFibGVkID09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm4gaXNIaWRkZW4uc3RhcnREYXRlIC0gKGlzSGlkZGVuLmVuZERhdGUgLSB0aW1lKSAtIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGlzSGlkZGVuLnN0YXJ0RGF0ZSAtIDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjb3JyZWN0aW9uRW5hYmxlZCA9PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuIGlzSGlkZGVuLmVuZERhdGUgKyAodGltZSAtIGlzSGlkZGVuLnN0YXJ0RGF0ZSkgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBpc0hpZGRlbi5lbmREYXRlICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGltZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGltZSBpcyBoaWRkZW5cbiAgICpcbiAgICogQHBhcmFtIHRpbWVcbiAgICogQHBhcmFtIGhpZGRlbkRhdGVzXG4gICAqIEByZXR1cm5zIHt7aGlkZGVuOiBib29sZWFuLCBzdGFydERhdGU6IFdpbmRvdy5zdGFydCwgZW5kRGF0ZTogKn19XG4gICAqL1xuICBleHBvcnRzLmlzSGlkZGVuID0gZnVuY3Rpb24gKHRpbWUsIGhpZGRlbkRhdGVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoaWRkZW5EYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHN0YXJ0RGF0ZSA9IGhpZGRlbkRhdGVzW2ldLnN0YXJ0O1xuICAgICAgdmFyIGVuZERhdGUgPSBoaWRkZW5EYXRlc1tpXS5lbmQ7XG5cbiAgICAgIGlmICh0aW1lID49IHN0YXJ0RGF0ZSAmJiB0aW1lIDwgZW5kRGF0ZSkge1xuICAgICAgICAvLyBpZiB0aGUgc3RhcnQgaXMgZW50ZXJpbmcgYSBoaWRkZW4gem9uZVxuICAgICAgICByZXR1cm4geyBoaWRkZW46IHRydWUsIHN0YXJ0RGF0ZTogc3RhcnREYXRlLCBlbmREYXRlOiBlbmREYXRlIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBoaWRkZW46IGZhbHNlLCBzdGFydERhdGU6IHN0YXJ0RGF0ZSwgZW5kRGF0ZTogZW5kRGF0ZSB9O1xuICB9O1xuXG4vKioqLyB9LFxuLyogMzMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuICB2YXIgRW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuICB2YXIgSGFtbWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG4gIHZhciBoYW1tZXJVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbiAgdmFyIERhdGFTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuICB2YXIgRGF0YVZpZXcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcbiAgdmFyIFJhbmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMCk7XG4gIHZhciBJdGVtU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XG4gIHZhciBUaW1lQXhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oNDQpO1xuICB2YXIgQWN0aXZhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NSk7XG4gIHZhciBEYXRlVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xuICB2YXIgQ3VzdG9tVGltZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDYpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSB0aW1lbGluZSB2aXN1YWxpemF0aW9uXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gQ29yZSgpIHt9XG5cbiAgLy8gdHVybiBDb3JlIGludG8gYW4gZXZlbnQgZW1pdHRlclxuICBFbWl0dGVyKENvcmUucHJvdG90eXBlKTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBtYWluIERPTSBmb3IgdGhlIENvcmU6IGEgcm9vdCBwYW5lbCBjb250YWluaW5nIGxlZnQsIHJpZ2h0LFxuICAgKiB0b3AsIGJvdHRvbSwgY29udGVudCwgYW5kIGJhY2tncm91bmQgcGFuZWwuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gY29udGFpbmVyICBUaGUgY29udGFpbmVyIGVsZW1lbnQgd2hlcmUgdGhlIENvcmUgd2lsbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmUgYXR0YWNoZWQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIENvcmUucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgdGhpcy5kb20gPSB7fTtcblxuICAgIHRoaXMuZG9tLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcblxuICAgIHRoaXMuZG9tLnJvb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmRvbS5iYWNrZ3JvdW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5kb20uYmFja2dyb3VuZFZlcnRpY2FsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5kb20uYmFja2dyb3VuZEhvcml6b250YWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmRvbS5jZW50ZXJDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmRvbS5sZWZ0Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5kb20ucmlnaHRDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmRvbS5jZW50ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmRvbS5sZWZ0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5kb20ucmlnaHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmRvbS50b3AgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmRvbS5ib3R0b20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmRvbS5zaGFkb3dUb3AgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmRvbS5zaGFkb3dCb3R0b20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmRvbS5zaGFkb3dUb3BMZWZ0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5kb20uc2hhZG93Qm90dG9tTGVmdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuZG9tLnNoYWRvd1RvcFJpZ2h0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5kb20uc2hhZG93Qm90dG9tUmlnaHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIHRoaXMuZG9tLnJvb3QuY2xhc3NOYW1lID0gJ3Zpcy10aW1lbGluZSc7XG4gICAgdGhpcy5kb20uYmFja2dyb3VuZC5jbGFzc05hbWUgPSAndmlzLXBhbmVsIHZpcy1iYWNrZ3JvdW5kJztcbiAgICB0aGlzLmRvbS5iYWNrZ3JvdW5kVmVydGljYWwuY2xhc3NOYW1lID0gJ3Zpcy1wYW5lbCB2aXMtYmFja2dyb3VuZCB2aXMtdmVydGljYWwnO1xuICAgIHRoaXMuZG9tLmJhY2tncm91bmRIb3Jpem9udGFsLmNsYXNzTmFtZSA9ICd2aXMtcGFuZWwgdmlzLWJhY2tncm91bmQgdmlzLWhvcml6b250YWwnO1xuICAgIHRoaXMuZG9tLmNlbnRlckNvbnRhaW5lci5jbGFzc05hbWUgPSAndmlzLXBhbmVsIHZpcy1jZW50ZXInO1xuICAgIHRoaXMuZG9tLmxlZnRDb250YWluZXIuY2xhc3NOYW1lID0gJ3Zpcy1wYW5lbCB2aXMtbGVmdCc7XG4gICAgdGhpcy5kb20ucmlnaHRDb250YWluZXIuY2xhc3NOYW1lID0gJ3Zpcy1wYW5lbCB2aXMtcmlnaHQnO1xuICAgIHRoaXMuZG9tLnRvcC5jbGFzc05hbWUgPSAndmlzLXBhbmVsIHZpcy10b3AnO1xuICAgIHRoaXMuZG9tLmJvdHRvbS5jbGFzc05hbWUgPSAndmlzLXBhbmVsIHZpcy1ib3R0b20nO1xuICAgIHRoaXMuZG9tLmxlZnQuY2xhc3NOYW1lID0gJ3Zpcy1jb250ZW50JztcbiAgICB0aGlzLmRvbS5jZW50ZXIuY2xhc3NOYW1lID0gJ3Zpcy1jb250ZW50JztcbiAgICB0aGlzLmRvbS5yaWdodC5jbGFzc05hbWUgPSAndmlzLWNvbnRlbnQnO1xuICAgIHRoaXMuZG9tLnNoYWRvd1RvcC5jbGFzc05hbWUgPSAndmlzLXNoYWRvdyB2aXMtdG9wJztcbiAgICB0aGlzLmRvbS5zaGFkb3dCb3R0b20uY2xhc3NOYW1lID0gJ3Zpcy1zaGFkb3cgdmlzLWJvdHRvbSc7XG4gICAgdGhpcy5kb20uc2hhZG93VG9wTGVmdC5jbGFzc05hbWUgPSAndmlzLXNoYWRvdyB2aXMtdG9wJztcbiAgICB0aGlzLmRvbS5zaGFkb3dCb3R0b21MZWZ0LmNsYXNzTmFtZSA9ICd2aXMtc2hhZG93IHZpcy1ib3R0b20nO1xuICAgIHRoaXMuZG9tLnNoYWRvd1RvcFJpZ2h0LmNsYXNzTmFtZSA9ICd2aXMtc2hhZG93IHZpcy10b3AnO1xuICAgIHRoaXMuZG9tLnNoYWRvd0JvdHRvbVJpZ2h0LmNsYXNzTmFtZSA9ICd2aXMtc2hhZG93IHZpcy1ib3R0b20nO1xuXG4gICAgdGhpcy5kb20ucm9vdC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5iYWNrZ3JvdW5kKTtcbiAgICB0aGlzLmRvbS5yb290LmFwcGVuZENoaWxkKHRoaXMuZG9tLmJhY2tncm91bmRWZXJ0aWNhbCk7XG4gICAgdGhpcy5kb20ucm9vdC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5iYWNrZ3JvdW5kSG9yaXpvbnRhbCk7XG4gICAgdGhpcy5kb20ucm9vdC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5jZW50ZXJDb250YWluZXIpO1xuICAgIHRoaXMuZG9tLnJvb3QuYXBwZW5kQ2hpbGQodGhpcy5kb20ubGVmdENvbnRhaW5lcik7XG4gICAgdGhpcy5kb20ucm9vdC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5yaWdodENvbnRhaW5lcik7XG4gICAgdGhpcy5kb20ucm9vdC5hcHBlbmRDaGlsZCh0aGlzLmRvbS50b3ApO1xuICAgIHRoaXMuZG9tLnJvb3QuYXBwZW5kQ2hpbGQodGhpcy5kb20uYm90dG9tKTtcblxuICAgIHRoaXMuZG9tLmNlbnRlckNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRvbS5jZW50ZXIpO1xuICAgIHRoaXMuZG9tLmxlZnRDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb20ubGVmdCk7XG4gICAgdGhpcy5kb20ucmlnaHRDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb20ucmlnaHQpO1xuXG4gICAgdGhpcy5kb20uY2VudGVyQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZG9tLnNoYWRvd1RvcCk7XG4gICAgdGhpcy5kb20uY2VudGVyQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZG9tLnNoYWRvd0JvdHRvbSk7XG4gICAgdGhpcy5kb20ubGVmdENvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRvbS5zaGFkb3dUb3BMZWZ0KTtcbiAgICB0aGlzLmRvbS5sZWZ0Q29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZG9tLnNoYWRvd0JvdHRvbUxlZnQpO1xuICAgIHRoaXMuZG9tLnJpZ2h0Q29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZG9tLnNoYWRvd1RvcFJpZ2h0KTtcbiAgICB0aGlzLmRvbS5yaWdodENvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRvbS5zaGFkb3dCb3R0b21SaWdodCk7XG5cbiAgICB0aGlzLm9uKCdyYW5nZWNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLmluaXRpYWxEcmF3RG9uZSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLl9yZWRyYXcoKTsgLy8gdGhpcyBhbGxvd3Mgb3ZlcnJpZGluZyB0aGUgX3JlZHJhdyBtZXRob2RcbiAgICAgIH1cbiAgICB9LmJpbmQodGhpcykpO1xuICAgIHRoaXMub24oJ3RvdWNoJywgdGhpcy5fb25Ub3VjaC5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLm9uKCdwYW4nLCB0aGlzLl9vbkRyYWcuYmluZCh0aGlzKSk7XG5cbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHRoaXMub24oJ19jaGFuZ2UnLCBmdW5jdGlvbiAocHJvcGVydGllcykge1xuICAgICAgaWYgKHByb3BlcnRpZXMgJiYgcHJvcGVydGllcy5xdWV1ZSA9PSB0cnVlKSB7XG4gICAgICAgIC8vIHJlZHJhdyBvbmNlIG9uIG5leHQgdGlja1xuICAgICAgICBpZiAoIW1lLl9yZWRyYXdUaW1lcikge1xuICAgICAgICAgIG1lLl9yZWRyYXdUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbWUuX3JlZHJhd1RpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIG1lLl9yZWRyYXcoKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVkcmF3IGltbWVkaWF0ZWx5XG4gICAgICAgIG1lLl9yZWRyYXcoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGNyZWF0ZSBldmVudCBsaXN0ZW5lcnMgZm9yIGFsbCBpbnRlcmVzdGluZyBldmVudHMsIHRoZXNlIGV2ZW50cyB3aWxsIGJlXG4gICAgLy8gZW1pdHRlZCB2aWEgZW1pdHRlclxuICAgIHRoaXMuaGFtbWVyID0gbmV3IEhhbW1lcih0aGlzLmRvbS5yb290KTtcbiAgICB2YXIgcGluY2hSZWNvZ25pemVyID0gdGhpcy5oYW1tZXIuZ2V0KCdwaW5jaCcpLnNldCh7IGVuYWJsZTogdHJ1ZSB9KTtcbiAgICBoYW1tZXJVdGlsLmRpc2FibGVQcmV2ZW50RGVmYXVsdFZlcnRpY2FsbHkocGluY2hSZWNvZ25pemVyKTtcbiAgICB0aGlzLmhhbW1lci5nZXQoJ3BhbicpLnNldCh7IHRocmVzaG9sZDogNSwgZGlyZWN0aW9uOiBIYW1tZXIuRElSRUNUSU9OX0hPUklaT05UQUwgfSk7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcblxuICAgIHZhciBldmVudHMgPSBbJ3RhcCcsICdkb3VibGV0YXAnLCAncHJlc3MnLCAncGluY2gnLCAncGFuJywgJ3BhbnN0YXJ0JywgJ3Bhbm1vdmUnLCAncGFuZW5kJ1xuICAgIC8vIFRPRE86IGNsZWFudXBcbiAgICAvLyd0b3VjaCcsICdwaW5jaCcsXG4gICAgLy8ndGFwJywgJ2RvdWJsZXRhcCcsICdob2xkJyxcbiAgICAvLydkcmFnc3RhcnQnLCAnZHJhZycsICdkcmFnZW5kJyxcbiAgICAvLydtb3VzZXdoZWVsJywgJ0RPTU1vdXNlU2Nyb2xsJyAvLyBET01Nb3VzZVNjcm9sbCBpcyBuZWVkZWQgZm9yIEZpcmVmb3hcbiAgICBdO1xuICAgIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiBsaXN0ZW5lcihldmVudCkge1xuICAgICAgICBpZiAobWUuaXNBY3RpdmUoKSkge1xuICAgICAgICAgIG1lLmVtaXQodHlwZSwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgbWUuaGFtbWVyLm9uKHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgIG1lLmxpc3RlbmVyc1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgIH0pO1xuXG4gICAgLy8gZW11bGF0ZSBhIHRvdWNoIGV2ZW50IChlbWl0dGVkIGJlZm9yZSB0aGUgc3RhcnQgb2YgYSBwYW4sIHBpbmNoLCB0YXAsIG9yIHByZXNzKVxuICAgIGhhbW1lclV0aWwub25Ub3VjaCh0aGlzLmhhbW1lciwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBtZS5lbWl0KCd0b3VjaCcsIGV2ZW50KTtcbiAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgLy8gZW11bGF0ZSBhIHJlbGVhc2UgZXZlbnQgKGVtaXR0ZWQgYWZ0ZXIgYSBwYW4sIHBpbmNoLCB0YXAsIG9yIHByZXNzKVxuICAgIGhhbW1lclV0aWwub25SZWxlYXNlKHRoaXMuaGFtbWVyLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIG1lLmVtaXQoJ3JlbGVhc2UnLCBldmVudCk7XG4gICAgfS5iaW5kKHRoaXMpKTtcblxuICAgIGZ1bmN0aW9uIG9uTW91c2VXaGVlbChldmVudCkge1xuICAgICAgaWYgKG1lLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgbWUuZW1pdCgnbW91c2V3aGVlbCcsIGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5kb20ucm9vdC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgb25Nb3VzZVdoZWVsKTtcbiAgICB0aGlzLmRvbS5yb290LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTU1vdXNlU2Nyb2xsJywgb25Nb3VzZVdoZWVsKTtcblxuICAgIC8vIHNpemUgcHJvcGVydGllcyBvZiBlYWNoIG9mIHRoZSBwYW5lbHNcbiAgICB0aGlzLnByb3BzID0ge1xuICAgICAgcm9vdDoge30sXG4gICAgICBiYWNrZ3JvdW5kOiB7fSxcbiAgICAgIGNlbnRlckNvbnRhaW5lcjoge30sXG4gICAgICBsZWZ0Q29udGFpbmVyOiB7fSxcbiAgICAgIHJpZ2h0Q29udGFpbmVyOiB7fSxcbiAgICAgIGNlbnRlcjoge30sXG4gICAgICBsZWZ0OiB7fSxcbiAgICAgIHJpZ2h0OiB7fSxcbiAgICAgIHRvcDoge30sXG4gICAgICBib3R0b206IHt9LFxuICAgICAgYm9yZGVyOiB7fSxcbiAgICAgIHNjcm9sbFRvcDogMCxcbiAgICAgIHNjcm9sbFRvcE1pbjogMFxuICAgIH07XG5cbiAgICB0aGlzLmN1c3RvbVRpbWVzID0gW107XG5cbiAgICAvLyBzdG9yZSBzdGF0ZSBpbmZvcm1hdGlvbiBuZWVkZWQgZm9yIHRvdWNoIGV2ZW50c1xuICAgIHRoaXMudG91Y2ggPSB7fTtcblxuICAgIHRoaXMucmVkcmF3Q291bnQgPSAwO1xuICAgIHRoaXMuaW5pdGlhbERyYXdEb25lID0gZmFsc2U7XG5cbiAgICAvLyBhdHRhY2ggdGhlIHJvb3QgcGFuZWwgdG8gdGhlIHByb3ZpZGVkIGNvbnRhaW5lclxuICAgIGlmICghY29udGFpbmVyKSB0aHJvdyBuZXcgRXJyb3IoJ05vIGNvbnRhaW5lciBwcm92aWRlZCcpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRvbS5yb290KTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IG9wdGlvbnMuIE9wdGlvbnMgd2lsbCBiZSBwYXNzZWQgdG8gYWxsIGNvbXBvbmVudHMgbG9hZGVkIGluIHRoZSBUaW1lbGluZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmd9IG9yaWVudGF0aW9uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVmVydGljYWwgb3JpZW50YXRpb24gZm9yIHRoZSBUaW1lbGluZSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW4gYmUgJ2JvdHRvbScgKGRlZmF1bHQpIG9yICd0b3AnLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmcgfCBOdW1iZXJ9IHdpZHRoXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgV2lkdGggZm9yIHRoZSB0aW1lbGluZSwgYSBudW1iZXIgaW4gcGl4ZWxzIG9yXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBjc3Mgc3RyaW5nIGxpa2UgJzEwMDBweCcgb3IgJzc1JScuICcxMDAlJyBieSBkZWZhdWx0LlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmcgfCBOdW1iZXJ9IGhlaWdodFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZpeGVkIGhlaWdodCBmb3IgdGhlIFRpbWVsaW5lLCBhIG51bWJlciBpbiBwaXhlbHMgb3JcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIGNzcyBzdHJpbmcgbGlrZSAnNDAwcHgnIG9yICc3NSUnLiBJZiB1bmRlZmluZWQsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIFRpbWVsaW5lIHdpbGwgYXV0b21hdGljYWxseSBzaXplIHN1Y2ggdGhhdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0cyBjb250ZW50cyBmaXQuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZyB8IE51bWJlcn0gbWluSGVpZ2h0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWluaW11bSBoZWlnaHQgZm9yIHRoZSBUaW1lbGluZSwgYSBudW1iZXIgaW4gcGl4ZWxzIG9yXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBjc3Mgc3RyaW5nIGxpa2UgJzQwMHB4JyBvciAnNzUlJy5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nIHwgTnVtYmVyfSBtYXhIZWlnaHRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXhpbXVtIGhlaWdodCBmb3IgdGhlIFRpbWVsaW5lLCBhIG51bWJlciBpbiBwaXhlbHMgb3JcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIGNzcyBzdHJpbmcgbGlrZSAnNDAwcHgnIG9yICc3NSUnLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtOdW1iZXIgfCBEYXRlIHwgU3RyaW5nfSBzdGFydFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN0YXJ0IGRhdGUgZm9yIHRoZSB2aXNpYmxlIHdpbmRvd1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtOdW1iZXIgfCBEYXRlIHwgU3RyaW5nfSBlbmRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFbmQgZGF0ZSBmb3IgdGhlIHZpc2libGUgd2luZG93XG4gICAqL1xuICBDb3JlLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgLy8gY29weSB0aGUga25vd24gb3B0aW9uc1xuICAgICAgdmFyIGZpZWxkcyA9IFsnd2lkdGgnLCAnaGVpZ2h0JywgJ21pbkhlaWdodCcsICdtYXhIZWlnaHQnLCAnYXV0b1Jlc2l6ZScsICdzdGFydCcsICdlbmQnLCAnY2xpY2tUb1VzZScsICdkYXRhQXR0cmlidXRlcycsICdoaWRkZW5EYXRlcycsICdsb2NhbGUnLCAnbG9jYWxlcycsICdtb21lbnQnLCAncnRsJywgJ3Rocm90dGxlUmVkcmF3J107XG4gICAgICB1dGlsLnNlbGVjdGl2ZUV4dGVuZChmaWVsZHMsIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucnRsKSB7XG4gICAgICAgIHZhciBjb250ZW50Q29udGFpbmVyID0gdGhpcy5kb20ubGVmdENvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5kb20ubGVmdENvbnRhaW5lciA9IHRoaXMuZG9tLnJpZ2h0Q29udGFpbmVyO1xuICAgICAgICB0aGlzLmRvbS5yaWdodENvbnRhaW5lciA9IGNvbnRlbnRDb250YWluZXI7XG4gICAgICAgIHRoaXMuZG9tLmNvbnRhaW5lci5zdHlsZS5kaXJlY3Rpb24gPSBcInJ0bFwiO1xuICAgICAgICB0aGlzLmRvbS5iYWNrZ3JvdW5kVmVydGljYWwuY2xhc3NOYW1lID0gJ3Zpcy1wYW5lbCB2aXMtYmFja2dyb3VuZCB2aXMtdmVydGljYWwtcnRsJztcbiAgICAgIH1cblxuICAgICAgdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uID0geyBpdGVtOiB1bmRlZmluZWQsIGF4aXM6IHVuZGVmaW5lZCB9O1xuICAgICAgaWYgKCdvcmllbnRhdGlvbicgaW4gb3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMub3JpZW50YXRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uID0ge1xuICAgICAgICAgICAgaXRlbTogb3B0aW9ucy5vcmllbnRhdGlvbixcbiAgICAgICAgICAgIGF4aXM6IG9wdGlvbnMub3JpZW50YXRpb25cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKF90eXBlb2Yob3B0aW9ucy5vcmllbnRhdGlvbikgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgaWYgKCdpdGVtJyBpbiBvcHRpb25zLm9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uaXRlbSA9IG9wdGlvbnMub3JpZW50YXRpb24uaXRlbTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCdheGlzJyBpbiBvcHRpb25zLm9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uYXhpcyA9IG9wdGlvbnMub3JpZW50YXRpb24uYXhpcztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5heGlzID09PSAnYm90aCcpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRpbWVBeGlzMikge1xuICAgICAgICAgIHZhciB0aW1lQXhpczIgPSB0aGlzLnRpbWVBeGlzMiA9IG5ldyBUaW1lQXhpcyh0aGlzLmJvZHkpO1xuICAgICAgICAgIHRpbWVBeGlzMi5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMgPyB1dGlsLmV4dGVuZCh7fSwgb3B0aW9ucykgOiB7fTtcbiAgICAgICAgICAgIF9vcHRpb25zLm9yaWVudGF0aW9uID0gJ3RvcCc7IC8vIG92ZXJyaWRlIHRoZSBvcmllbnRhdGlvbiBvcHRpb24sIGFsd2F5cyB0b3BcbiAgICAgICAgICAgIFRpbWVBeGlzLnByb3RvdHlwZS5zZXRPcHRpb25zLmNhbGwodGltZUF4aXMyLCBfb3B0aW9ucyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLmNvbXBvbmVudHMucHVzaCh0aW1lQXhpczIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy50aW1lQXhpczIpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmNvbXBvbmVudHMuaW5kZXhPZih0aGlzLnRpbWVBeGlzMik7XG4gICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMudGltZUF4aXMyLmRlc3Ryb3koKTtcbiAgICAgICAgICB0aGlzLnRpbWVBeGlzMiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gaWYgdGhlIGdyYXBoMmQncyBkcmF3UG9pbnRzIGlzIGEgZnVuY3Rpb24gZGVsZWdhdGUgdGhlIGNhbGxiYWNrIHRvIHRoZSBvblJlbmRlciBwcm9wZXJ0eVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmRyYXdQb2ludHMgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvcHRpb25zLmRyYXdQb2ludHMgPSB7XG4gICAgICAgICAgb25SZW5kZXI6IG9wdGlvbnMuZHJhd1BvaW50c1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoJ2hpZGRlbkRhdGVzJyBpbiB0aGlzLm9wdGlvbnMpIHtcbiAgICAgICAgRGF0ZVV0aWwuY29udmVydEhpZGRlbk9wdGlvbnModGhpcy5vcHRpb25zLm1vbWVudCwgdGhpcy5ib2R5LCB0aGlzLm9wdGlvbnMuaGlkZGVuRGF0ZXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoJ2NsaWNrVG9Vc2UnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuY2xpY2tUb1VzZSkge1xuICAgICAgICAgIGlmICghdGhpcy5hY3RpdmF0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdG9yID0gbmV3IEFjdGl2YXRvcih0aGlzLmRvbS5yb290KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuYWN0aXZhdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2YXRvci5kZXN0cm95KCk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5hY3RpdmF0b3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICgnc2hvd0N1c3RvbVRpbWUnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb24gYHNob3dDdXN0b21UaW1lYCBpcyBkZXByZWNhdGVkLiBDcmVhdGUgYSBjdXN0b20gdGltZSBiYXIgdmlhIHRpbWVsaW5lLmFkZEN1c3RvbVRpbWUodGltZSBbLCBpZF0pJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGVuYWJsZS9kaXNhYmxlIGF1dG9SZXNpemVcbiAgICAgIHRoaXMuX2luaXRBdXRvUmVzaXplKCk7XG4gICAgfVxuXG4gICAgLy8gcHJvcGFnYXRlIG9wdGlvbnMgdG8gYWxsIGNvbXBvbmVudHNcbiAgICB0aGlzLmNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICByZXR1cm4gY29tcG9uZW50LnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfSk7XG5cbiAgICAvLyBlbmFibGUvZGlzYWJsZSBjb25maWd1cmVcbiAgICBpZiAoJ2NvbmZpZ3VyZScgaW4gb3B0aW9ucykge1xuICAgICAgaWYgKCF0aGlzLmNvbmZpZ3VyYXRvcikge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRvciA9IHRoaXMuX2NyZWF0ZUNvbmZpZ3VyYXRvcigpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbmZpZ3VyYXRvci5zZXRPcHRpb25zKG9wdGlvbnMuY29uZmlndXJlKTtcblxuICAgICAgLy8gY29sbGVjdCB0aGUgc2V0dGluZ3Mgb2YgYWxsIGNvbXBvbmVudHMsIGFuZCBwYXNzIHRoZW0gdG8gdGhlIGNvbmZpZ3VyYXRpb24gc3lzdGVtXG4gICAgICB2YXIgYXBwbGllZE9wdGlvbnMgPSB1dGlsLmRlZXBFeHRlbmQoe30sIHRoaXMub3B0aW9ucyk7XG4gICAgICB0aGlzLmNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgIHV0aWwuZGVlcEV4dGVuZChhcHBsaWVkT3B0aW9ucywgY29tcG9uZW50Lm9wdGlvbnMpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmNvbmZpZ3VyYXRvci5zZXRNb2R1bGVPcHRpb25zKHsgZ2xvYmFsOiBhcHBsaWVkT3B0aW9ucyB9KTtcbiAgICB9XG5cbiAgICAvLyBvdmVycmlkZSByZWRyYXcgd2l0aCBhIHRocm90dGxlZCB2ZXJzaW9uXG4gICAgaWYgKCF0aGlzLl9vcmlnUmVkcmF3KSB7XG4gICAgICB0aGlzLl9vcmlnUmVkcmF3ID0gdGhpcy5fcmVkcmF3LmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9yZWRyYXcgPSB1dGlsLnRocm90dGxlKHRoaXMuX29yaWdSZWRyYXcsIHRoaXMub3B0aW9ucy50aHJvdHRsZVJlZHJhdyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vdCB0aGUgaW5pdGlhbCBydW46IHJlZHJhdyBldmVyeXRoaW5nXG4gICAgICB0aGlzLl9yZWRyYXcoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSBUaW1lbGluZSBpcyBhY3RpdmUuXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgQ29yZS5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICF0aGlzLmFjdGl2YXRvciB8fCB0aGlzLmFjdGl2YXRvci5hY3RpdmU7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlc3Ryb3kgdGhlIENvcmUsIGNsZWFuIHVwIGFsbCBET00gZWxlbWVudHMgYW5kIGV2ZW50IGxpc3RlbmVycy5cbiAgICovXG4gIENvcmUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gdW5iaW5kIGRhdGFzZXRzXG4gICAgdGhpcy5zZXRJdGVtcyhudWxsKTtcbiAgICB0aGlzLnNldEdyb3VwcyhudWxsKTtcblxuICAgIC8vIHJlbW92ZSBhbGwgZXZlbnQgbGlzdGVuZXJzXG4gICAgdGhpcy5vZmYoKTtcblxuICAgIC8vIHN0b3AgY2hlY2tpbmcgZm9yIGNoYW5nZWQgc2l6ZVxuICAgIHRoaXMuX3N0b3BBdXRvUmVzaXplKCk7XG5cbiAgICAvLyByZW1vdmUgZnJvbSBET01cbiAgICBpZiAodGhpcy5kb20ucm9vdC5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLmRvbS5yb290LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20ucm9vdCk7XG4gICAgfVxuICAgIHRoaXMuZG9tID0gbnVsbDtcblxuICAgIC8vIHJlbW92ZSBBY3RpdmF0b3JcbiAgICBpZiAodGhpcy5hY3RpdmF0b3IpIHtcbiAgICAgIHRoaXMuYWN0aXZhdG9yLmRlc3Ryb3koKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmFjdGl2YXRvcjtcbiAgICB9XG5cbiAgICAvLyBjbGVhbnVwIGhhbW1lciB0b3VjaCBldmVudHNcbiAgICBmb3IgKHZhciBldmVudCBpbiB0aGlzLmxpc3RlbmVycykge1xuICAgICAgaWYgKHRoaXMubGlzdGVuZXJzLmhhc093blByb3BlcnR5KGV2ZW50KSkge1xuICAgICAgICBkZWxldGUgdGhpcy5saXN0ZW5lcnNbZXZlbnRdO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxpc3RlbmVycyA9IG51bGw7XG4gICAgdGhpcy5oYW1tZXIgPSBudWxsO1xuXG4gICAgLy8gZ2l2ZSBhbGwgY29tcG9uZW50cyB0aGUgb3Bwb3J0dW5pdHkgdG8gY2xlYW51cFxuICAgIHRoaXMuY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgIHJldHVybiBjb21wb25lbnQuZGVzdHJveSgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5ib2R5ID0gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGEgY3VzdG9tIHRpbWUgYmFyXG4gICAqIEBwYXJhbSB7RGF0ZX0gdGltZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2lkPXVuZGVmaW5lZF0gT3B0aW9uYWwgaWQgb2YgdGhlIGN1c3RvbSB0aW1lIGJhciB0byBiZSBhZGp1c3RlZC5cbiAgICovXG4gIENvcmUucHJvdG90eXBlLnNldEN1c3RvbVRpbWUgPSBmdW5jdGlvbiAodGltZSwgaWQpIHtcbiAgICB2YXIgY3VzdG9tVGltZXMgPSB0aGlzLmN1c3RvbVRpbWVzLmZpbHRlcihmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICByZXR1cm4gaWQgPT09IGNvbXBvbmVudC5vcHRpb25zLmlkO1xuICAgIH0pO1xuXG4gICAgaWYgKGN1c3RvbVRpbWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjdXN0b20gdGltZSBiYXIgZm91bmQgd2l0aCBpZCAnICsgSlNPTi5zdHJpbmdpZnkoaWQpKTtcbiAgICB9XG5cbiAgICBpZiAoY3VzdG9tVGltZXMubGVuZ3RoID4gMCkge1xuICAgICAgY3VzdG9tVGltZXNbMF0uc2V0Q3VzdG9tVGltZSh0aW1lKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSBjdXJyZW50IGN1c3RvbSB0aW1lLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2lkPXVuZGVmaW5lZF0gICAgSWQgb2YgdGhlIGN1c3RvbSB0aW1lIGJhci5cbiAgICogQHJldHVybiB7RGF0ZSB8IHVuZGVmaW5lZH0gY3VzdG9tVGltZVxuICAgKi9cbiAgQ29yZS5wcm90b3R5cGUuZ2V0Q3VzdG9tVGltZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBjdXN0b21UaW1lcyA9IHRoaXMuY3VzdG9tVGltZXMuZmlsdGVyKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgIHJldHVybiBjb21wb25lbnQub3B0aW9ucy5pZCA9PT0gaWQ7XG4gICAgfSk7XG5cbiAgICBpZiAoY3VzdG9tVGltZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGN1c3RvbSB0aW1lIGJhciBmb3VuZCB3aXRoIGlkICcgKyBKU09OLnN0cmluZ2lmeShpZCkpO1xuICAgIH1cbiAgICByZXR1cm4gY3VzdG9tVGltZXNbMF0uZ2V0Q3VzdG9tVGltZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgYSBjdXN0b20gdGl0bGUgZm9yIHRoZSBjdXN0b20gdGltZSBiYXIuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbdGl0bGVdIEN1c3RvbSB0aXRsZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2lkPXVuZGVmaW5lZF0gICAgSWQgb2YgdGhlIGN1c3RvbSB0aW1lIGJhci5cbiAgICovXG4gIENvcmUucHJvdG90eXBlLnNldEN1c3RvbVRpbWVUaXRsZSA9IGZ1bmN0aW9uICh0aXRsZSwgaWQpIHtcbiAgICB2YXIgY3VzdG9tVGltZXMgPSB0aGlzLmN1c3RvbVRpbWVzLmZpbHRlcihmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICByZXR1cm4gY29tcG9uZW50Lm9wdGlvbnMuaWQgPT09IGlkO1xuICAgIH0pO1xuXG4gICAgaWYgKGN1c3RvbVRpbWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjdXN0b20gdGltZSBiYXIgZm91bmQgd2l0aCBpZCAnICsgSlNPTi5zdHJpbmdpZnkoaWQpKTtcbiAgICB9XG4gICAgaWYgKGN1c3RvbVRpbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBjdXN0b21UaW1lc1swXS5zZXRDdXN0b21UaXRsZSh0aXRsZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBtZXRhIGluZm9ybWF0aW9uIGZyb20gYW4gZXZlbnQuXG4gICAqIFNob3VsZCBiZSBvdmVycmlkZGVuIGJ5IGNsYXNzZXMgZXh0ZW5kaW5nIENvcmVcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCByZWxhdGVkIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgQ29yZS5wcm90b3R5cGUuZ2V0RXZlbnRQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIHsgZXZlbnQ6IGV2ZW50IH07XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBjdXN0b20gdmVydGljYWwgYmFyXG4gICAqIEBwYXJhbSB7RGF0ZSB8IFN0cmluZyB8IE51bWJlcn0gW3RpbWVdICBBIERhdGUsIHVuaXggdGltZXN0YW1wLCBvclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSVNPIGRhdGUgc3RyaW5nLiBUaW1lIHBvaW50IHdoZXJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgbmV3IGJhciBzaG91bGQgYmUgcGxhY2VkLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgbm90IHByb3ZpZGVkLCBgbmV3IERhdGUoKWAgd2lsbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmUgdXNlZC5cbiAgICogQHBhcmFtIHtOdW1iZXIgfCBTdHJpbmd9IFtpZD11bmRlZmluZWRdIElkIG9mIHRoZSBuZXcgYmFyLiBPcHRpb25hbFxuICAgKiBAcmV0dXJuIHtOdW1iZXIgfCBTdHJpbmd9ICAgICAgICAgICAgICAgUmV0dXJucyB0aGUgaWQgb2YgdGhlIG5ldyBiYXJcbiAgICovXG4gIENvcmUucHJvdG90eXBlLmFkZEN1c3RvbVRpbWUgPSBmdW5jdGlvbiAodGltZSwgaWQpIHtcbiAgICB2YXIgdGltZXN0YW1wID0gdGltZSAhPT0gdW5kZWZpbmVkID8gdXRpbC5jb252ZXJ0KHRpbWUsICdEYXRlJykudmFsdWVPZigpIDogbmV3IERhdGUoKTtcblxuICAgIHZhciBleGlzdHMgPSB0aGlzLmN1c3RvbVRpbWVzLnNvbWUoZnVuY3Rpb24gKGN1c3RvbVRpbWUpIHtcbiAgICAgIHJldHVybiBjdXN0b21UaW1lLm9wdGlvbnMuaWQgPT09IGlkO1xuICAgIH0pO1xuICAgIGlmIChleGlzdHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQSBjdXN0b20gdGltZSB3aXRoIGlkICcgKyBKU09OLnN0cmluZ2lmeShpZCkgKyAnIGFscmVhZHkgZXhpc3RzJyk7XG4gICAgfVxuXG4gICAgdmFyIGN1c3RvbVRpbWUgPSBuZXcgQ3VzdG9tVGltZSh0aGlzLmJvZHksIHV0aWwuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMsIHtcbiAgICAgIHRpbWU6IHRpbWVzdGFtcCxcbiAgICAgIGlkOiBpZFxuICAgIH0pKTtcblxuICAgIHRoaXMuY3VzdG9tVGltZXMucHVzaChjdXN0b21UaW1lKTtcbiAgICB0aGlzLmNvbXBvbmVudHMucHVzaChjdXN0b21UaW1lKTtcbiAgICB0aGlzLl9yZWRyYXcoKTtcblxuICAgIHJldHVybiBpZDtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIHByZXZpb3VzbHkgYWRkZWQgY3VzdG9tIGJhclxuICAgKiBAcGFyYW0ge2ludH0gaWQgSUQgb2YgdGhlIGN1c3RvbSBiYXIgdG8gYmUgcmVtb3ZlZFxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBiYXIgZXhpc3RzIGFuZCBpcyByZW1vdmVkLCBmYWxzZSBvdGhlcndpc2VcbiAgICovXG4gIENvcmUucHJvdG90eXBlLnJlbW92ZUN1c3RvbVRpbWUgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgY3VzdG9tVGltZXMgPSB0aGlzLmN1c3RvbVRpbWVzLmZpbHRlcihmdW5jdGlvbiAoYmFyKSB7XG4gICAgICByZXR1cm4gYmFyLm9wdGlvbnMuaWQgPT09IGlkO1xuICAgIH0pO1xuXG4gICAgaWYgKGN1c3RvbVRpbWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjdXN0b20gdGltZSBiYXIgZm91bmQgd2l0aCBpZCAnICsgSlNPTi5zdHJpbmdpZnkoaWQpKTtcbiAgICB9XG5cbiAgICBjdXN0b21UaW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChjdXN0b21UaW1lKSB7XG4gICAgICB0aGlzLmN1c3RvbVRpbWVzLnNwbGljZSh0aGlzLmN1c3RvbVRpbWVzLmluZGV4T2YoY3VzdG9tVGltZSksIDEpO1xuICAgICAgdGhpcy5jb21wb25lbnRzLnNwbGljZSh0aGlzLmNvbXBvbmVudHMuaW5kZXhPZihjdXN0b21UaW1lKSwgMSk7XG4gICAgICBjdXN0b21UaW1lLmRlc3Ryb3koKTtcbiAgICB9LmJpbmQodGhpcykpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGlkJ3Mgb2YgdGhlIGN1cnJlbnRseSB2aXNpYmxlIGl0ZW1zLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBpZHMgb2YgdGhlIHZpc2libGUgaXRlbXNcbiAgICovXG4gIENvcmUucHJvdG90eXBlLmdldFZpc2libGVJdGVtcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtU2V0ICYmIHRoaXMuaXRlbVNldC5nZXRWaXNpYmxlSXRlbXMoKSB8fCBbXTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IENvcmUgd2luZG93IHN1Y2ggdGhhdCBpdCBmaXRzIGFsbCBpdGVtc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICBBdmFpbGFibGUgb3B0aW9uczpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBhbmltYXRpb246IGJvb2xlYW4gfCB7ZHVyYXRpb246IG51bWJlciwgZWFzaW5nRnVuY3Rpb246IHN0cmluZ31gXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgdHJ1ZSAoZGVmYXVsdCksIHRoZSByYW5nZSBpcyBhbmltYXRlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtb290aGx5IHRvIHRoZSBuZXcgd2luZG93LiBBbiBvYmplY3QgY2FuIGJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZWQgdG8gc3BlY2lmeSBkdXJhdGlvbiBhbmQgZWFzaW5nIGZ1bmN0aW9uLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgZHVyYXRpb24gaXMgNTAwIG1zLCBhbmQgZGVmYXVsdCBlYXNpbmdcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBpcyAnZWFzZUluT3V0UXVhZCcuXG4gICAqL1xuICBDb3JlLnByb3RvdHlwZS5maXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0RGF0YVJhbmdlKCk7XG5cbiAgICAvLyBza2lwIHJhbmdlIHNldCBpZiB0aGVyZSBpcyBubyBtaW4gYW5kIG1heCBkYXRlXG4gICAgaWYgKHJhbmdlLm1pbiA9PT0gbnVsbCAmJiByYW5nZS5tYXggPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhIG1hcmdpbiBvZiAxJSBsZWZ0IGFuZCByaWdodCBvZiB0aGUgZGF0YVxuICAgIHZhciBpbnRlcnZhbCA9IHJhbmdlLm1heCAtIHJhbmdlLm1pbjtcbiAgICB2YXIgbWluID0gbmV3IERhdGUocmFuZ2UubWluLnZhbHVlT2YoKSAtIGludGVydmFsICogMC4wMSk7XG4gICAgdmFyIG1heCA9IG5ldyBEYXRlKHJhbmdlLm1heC52YWx1ZU9mKCkgKyBpbnRlcnZhbCAqIDAuMDEpO1xuICAgIHZhciBhbmltYXRpb24gPSBvcHRpb25zICYmIG9wdGlvbnMuYW5pbWF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmFuaW1hdGlvbiA6IHRydWU7XG4gICAgdGhpcy5yYW5nZS5zZXRSYW5nZShtaW4sIG1heCwgYW5pbWF0aW9uKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBkYXRhIHJhbmdlIG9mIHRoZSBpdGVtcyBzdGFydCBhbmQgZW5kIGRhdGVzXG4gICAqIEByZXR1cm5zIHt7bWluOiBEYXRlIHwgbnVsbCwgbWF4OiBEYXRlIHwgbnVsbH19XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIENvcmUucHJvdG90eXBlLmdldERhdGFSYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IFRpbWVsaW5lIGFuZCBHcmFwaDJkXG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52b2tlIGFic3RyYWN0IG1ldGhvZCBnZXREYXRhUmFuZ2UnKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSB2aXNpYmxlIHdpbmRvdy4gQm90aCBwYXJhbWV0ZXJzIGFyZSBvcHRpb25hbCwgeW91IGNhbiBjaGFuZ2Ugb25seVxuICAgKiBzdGFydCBvciBvbmx5IGVuZC4gU3ludGF4OlxuICAgKlxuICAgKiAgICAgVGltZUxpbmUuc2V0V2luZG93KHN0YXJ0LCBlbmQpXG4gICAqICAgICBUaW1lTGluZS5zZXRXaW5kb3coc3RhcnQsIGVuZCwgb3B0aW9ucylcbiAgICogICAgIFRpbWVMaW5lLnNldFdpbmRvdyhyYW5nZSlcbiAgICpcbiAgICogV2hlcmUgc3RhcnQgYW5kIGVuZCBjYW4gYmUgYSBEYXRlLCBudW1iZXIsIG9yIHN0cmluZywgYW5kIHJhbmdlIGlzIGFuXG4gICAqIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgc3RhcnQgYW5kIGVuZC5cbiAgICpcbiAgICogQHBhcmFtIHtEYXRlIHwgTnVtYmVyIHwgU3RyaW5nIHwgT2JqZWN0fSBbc3RhcnRdIFN0YXJ0IGRhdGUgb2YgdmlzaWJsZSB3aW5kb3dcbiAgICogQHBhcmFtIHtEYXRlIHwgTnVtYmVyIHwgU3RyaW5nfSBbZW5kXSAgICAgICAgICAgIEVuZCBkYXRlIG9mIHZpc2libGUgd2luZG93XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gIEF2YWlsYWJsZSBvcHRpb25zOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGFuaW1hdGlvbjogYm9vbGVhbiB8IHtkdXJhdGlvbjogbnVtYmVyLCBlYXNpbmdGdW5jdGlvbjogc3RyaW5nfWBcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiB0cnVlIChkZWZhdWx0KSwgdGhlIHJhbmdlIGlzIGFuaW1hdGVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc21vb3RobHkgdG8gdGhlIG5ldyB3aW5kb3cuIEFuIG9iamVjdCBjYW4gYmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlZCB0byBzcGVjaWZ5IGR1cmF0aW9uIGFuZCBlYXNpbmcgZnVuY3Rpb24uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCBkdXJhdGlvbiBpcyA1MDAgbXMsIGFuZCBkZWZhdWx0IGVhc2luZ1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGlzICdlYXNlSW5PdXRRdWFkJy5cbiAgICovXG4gIENvcmUucHJvdG90eXBlLnNldFdpbmRvdyA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBvcHRpb25zKSB7XG4gICAgdmFyIGFuaW1hdGlvbjtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBhcmd1bWVudHNbMF07XG4gICAgICBhbmltYXRpb24gPSByYW5nZS5hbmltYXRpb24gIT09IHVuZGVmaW5lZCA/IHJhbmdlLmFuaW1hdGlvbiA6IHRydWU7XG4gICAgICB0aGlzLnJhbmdlLnNldFJhbmdlKHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQsIGFuaW1hdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFuaW1hdGlvbiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5hbmltYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYW5pbWF0aW9uIDogdHJ1ZTtcbiAgICAgIHRoaXMucmFuZ2Uuc2V0UmFuZ2Uoc3RhcnQsIGVuZCwgYW5pbWF0aW9uKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIE1vdmUgdGhlIHdpbmRvdyBzdWNoIHRoYXQgZ2l2ZW4gdGltZSBpcyBjZW50ZXJlZCBvbiBzY3JlZW4uXG4gICAqIEBwYXJhbSB7RGF0ZSB8IE51bWJlciB8IFN0cmluZ30gdGltZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICBBdmFpbGFibGUgb3B0aW9uczpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBhbmltYXRpb246IGJvb2xlYW4gfCB7ZHVyYXRpb246IG51bWJlciwgZWFzaW5nRnVuY3Rpb246IHN0cmluZ31gXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgdHJ1ZSAoZGVmYXVsdCksIHRoZSByYW5nZSBpcyBhbmltYXRlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtb290aGx5IHRvIHRoZSBuZXcgd2luZG93LiBBbiBvYmplY3QgY2FuIGJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZWQgdG8gc3BlY2lmeSBkdXJhdGlvbiBhbmQgZWFzaW5nIGZ1bmN0aW9uLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgZHVyYXRpb24gaXMgNTAwIG1zLCBhbmQgZGVmYXVsdCBlYXNpbmdcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBpcyAnZWFzZUluT3V0UXVhZCcuXG4gICAqL1xuICBDb3JlLnByb3RvdHlwZS5tb3ZlVG8gPSBmdW5jdGlvbiAodGltZSwgb3B0aW9ucykge1xuICAgIHZhciBpbnRlcnZhbCA9IHRoaXMucmFuZ2UuZW5kIC0gdGhpcy5yYW5nZS5zdGFydDtcbiAgICB2YXIgdCA9IHV0aWwuY29udmVydCh0aW1lLCAnRGF0ZScpLnZhbHVlT2YoKTtcblxuICAgIHZhciBzdGFydCA9IHQgLSBpbnRlcnZhbCAvIDI7XG4gICAgdmFyIGVuZCA9IHQgKyBpbnRlcnZhbCAvIDI7XG4gICAgdmFyIGFuaW1hdGlvbiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5hbmltYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYW5pbWF0aW9uIDogdHJ1ZTtcblxuICAgIHRoaXMucmFuZ2Uuc2V0UmFuZ2Uoc3RhcnQsIGVuZCwgYW5pbWF0aW9uKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSB2aXNpYmxlIHdpbmRvd1xuICAgKiBAcmV0dXJuIHt7c3RhcnQ6IERhdGUsIGVuZDogRGF0ZX19ICAgVmlzaWJsZSByYW5nZVxuICAgKi9cbiAgQ29yZS5wcm90b3R5cGUuZ2V0V2luZG93ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByYW5nZSA9IHRoaXMucmFuZ2UuZ2V0UmFuZ2UoKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IG5ldyBEYXRlKHJhbmdlLnN0YXJ0KSxcbiAgICAgIGVuZDogbmV3IERhdGUocmFuZ2UuZW5kKVxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIEZvcmNlIGEgcmVkcmF3LiBDYW4gYmUgb3ZlcnJpZGRlbiBieSBpbXBsZW1lbnRhdGlvbnMgb2YgQ29yZVxuICAgKlxuICAgKiBOb3RlOiB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgb3ZlcnJpZGRlbiBvbiBjb25zdHJ1Y3Rpb24gd2l0aCBhIHRyb3R0bGVkIHZlcnNpb25cbiAgICovXG4gIENvcmUucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9yZWRyYXcoKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVkcmF3IGZvciBpbnRlcm5hbCB1c2UuIFJlZHJhd3MgYWxsIGNvbXBvbmVudHMuIFNlZSBhbHNvIHRoZSBwdWJsaWNcbiAgICogbWV0aG9kIHJlZHJhdy5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgQ29yZS5wcm90b3R5cGUuX3JlZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlZHJhd0NvdW50Kys7XG4gICAgdmFyIHJlc2l6ZWQgPSBmYWxzZTtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBkb20gPSB0aGlzLmRvbTtcblxuICAgIGlmICghZG9tIHx8ICFkb20uY29udGFpbmVyIHx8IGRvbS5yb290Lm9mZnNldFdpZHRoID09IDApIHJldHVybjsgLy8gd2hlbiBkZXN0cm95ZWQsIG9yIGludmlzaWJsZVxuXG4gICAgRGF0ZVV0aWwudXBkYXRlSGlkZGVuRGF0ZXModGhpcy5vcHRpb25zLm1vbWVudCwgdGhpcy5ib2R5LCB0aGlzLm9wdGlvbnMuaGlkZGVuRGF0ZXMpO1xuXG4gICAgLy8gdXBkYXRlIGNsYXNzIG5hbWVzXG4gICAgaWYgKG9wdGlvbnMub3JpZW50YXRpb24gPT0gJ3RvcCcpIHtcbiAgICAgIHV0aWwuYWRkQ2xhc3NOYW1lKGRvbS5yb290LCAndmlzLXRvcCcpO1xuICAgICAgdXRpbC5yZW1vdmVDbGFzc05hbWUoZG9tLnJvb3QsICd2aXMtYm90dG9tJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHV0aWwucmVtb3ZlQ2xhc3NOYW1lKGRvbS5yb290LCAndmlzLXRvcCcpO1xuICAgICAgdXRpbC5hZGRDbGFzc05hbWUoZG9tLnJvb3QsICd2aXMtYm90dG9tJyk7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIHJvb3Qgd2lkdGggYW5kIGhlaWdodCBvcHRpb25zXG4gICAgZG9tLnJvb3Quc3R5bGUubWF4SGVpZ2h0ID0gdXRpbC5vcHRpb24uYXNTaXplKG9wdGlvbnMubWF4SGVpZ2h0LCAnJyk7XG4gICAgZG9tLnJvb3Quc3R5bGUubWluSGVpZ2h0ID0gdXRpbC5vcHRpb24uYXNTaXplKG9wdGlvbnMubWluSGVpZ2h0LCAnJyk7XG4gICAgZG9tLnJvb3Quc3R5bGUud2lkdGggPSB1dGlsLm9wdGlvbi5hc1NpemUob3B0aW9ucy53aWR0aCwgJycpO1xuXG4gICAgLy8gY2FsY3VsYXRlIGJvcmRlciB3aWR0aHNcbiAgICBwcm9wcy5ib3JkZXIubGVmdCA9IChkb20uY2VudGVyQ29udGFpbmVyLm9mZnNldFdpZHRoIC0gZG9tLmNlbnRlckNvbnRhaW5lci5jbGllbnRXaWR0aCkgLyAyO1xuICAgIHByb3BzLmJvcmRlci5yaWdodCA9IHByb3BzLmJvcmRlci5sZWZ0O1xuICAgIHByb3BzLmJvcmRlci50b3AgPSAoZG9tLmNlbnRlckNvbnRhaW5lci5vZmZzZXRIZWlnaHQgLSBkb20uY2VudGVyQ29udGFpbmVyLmNsaWVudEhlaWdodCkgLyAyO1xuICAgIHByb3BzLmJvcmRlci5ib3R0b20gPSBwcm9wcy5ib3JkZXIudG9wO1xuICAgIHZhciBib3JkZXJSb290SGVpZ2h0ID0gZG9tLnJvb3Qub2Zmc2V0SGVpZ2h0IC0gZG9tLnJvb3QuY2xpZW50SGVpZ2h0O1xuICAgIHZhciBib3JkZXJSb290V2lkdGggPSBkb20ucm9vdC5vZmZzZXRXaWR0aCAtIGRvbS5yb290LmNsaWVudFdpZHRoO1xuXG4gICAgLy8gd29ya2Fyb3VuZCBmb3IgYSBidWcgaW4gSUU6IHRoZSBjbGllbnRXaWR0aCBvZiBhbiBlbGVtZW50IHdpdGhcbiAgICAvLyBhIGhlaWdodDowcHggYW5kIG92ZXJmbG93OmhpZGRlbiBpcyBub3QgY2FsY3VsYXRlZCBhbmQgYWx3YXlzIGhhcyB2YWx1ZSAwXG4gICAgaWYgKGRvbS5jZW50ZXJDb250YWluZXIuY2xpZW50SGVpZ2h0ID09PSAwKSB7XG4gICAgICBwcm9wcy5ib3JkZXIubGVmdCA9IHByb3BzLmJvcmRlci50b3A7XG4gICAgICBwcm9wcy5ib3JkZXIucmlnaHQgPSBwcm9wcy5ib3JkZXIubGVmdDtcbiAgICB9XG4gICAgaWYgKGRvbS5yb290LmNsaWVudEhlaWdodCA9PT0gMCkge1xuICAgICAgYm9yZGVyUm9vdFdpZHRoID0gYm9yZGVyUm9vdEhlaWdodDtcbiAgICB9XG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIGhlaWdodHMuIElmIGFueSBvZiB0aGUgc2lkZSBwYW5lbHMgaXMgZW1wdHksIHdlIHNldCB0aGUgaGVpZ2h0IHRvXG4gICAgLy8gbWludXMgdGhlIGJvcmRlciB3aWR0aCwgc3VjaCB0aGF0IHRoZSBib3JkZXIgd2lsbCBiZSBpbnZpc2libGVcbiAgICBwcm9wcy5jZW50ZXIuaGVpZ2h0ID0gZG9tLmNlbnRlci5vZmZzZXRIZWlnaHQ7XG4gICAgcHJvcHMubGVmdC5oZWlnaHQgPSBkb20ubGVmdC5vZmZzZXRIZWlnaHQ7XG4gICAgcHJvcHMucmlnaHQuaGVpZ2h0ID0gZG9tLnJpZ2h0Lm9mZnNldEhlaWdodDtcbiAgICBwcm9wcy50b3AuaGVpZ2h0ID0gZG9tLnRvcC5jbGllbnRIZWlnaHQgfHwgLXByb3BzLmJvcmRlci50b3A7XG4gICAgcHJvcHMuYm90dG9tLmhlaWdodCA9IGRvbS5ib3R0b20uY2xpZW50SGVpZ2h0IHx8IC1wcm9wcy5ib3JkZXIuYm90dG9tO1xuXG4gICAgLy8gVE9ETzogY29tcGVuc2F0ZSBib3JkZXJzIHdoZW4gYW55IG9mIHRoZSBwYW5lbHMgaXMgZW1wdHkuXG5cbiAgICAvLyBhcHBseSBhdXRvIGhlaWdodFxuICAgIC8vIFRPRE86IG9ubHkgY2FsY3VsYXRlIGF1dG9IZWlnaHQgd2hlbiBuZWVkZWQgKGVsc2Ugd2UgY2F1c2UgYW4gZXh0cmEgcmVmbG93L3JlcGFpbnQgb2YgdGhlIERPTSlcbiAgICB2YXIgY29udGVudEhlaWdodCA9IE1hdGgubWF4KHByb3BzLmxlZnQuaGVpZ2h0LCBwcm9wcy5jZW50ZXIuaGVpZ2h0LCBwcm9wcy5yaWdodC5oZWlnaHQpO1xuICAgIHZhciBhdXRvSGVpZ2h0ID0gcHJvcHMudG9wLmhlaWdodCArIGNvbnRlbnRIZWlnaHQgKyBwcm9wcy5ib3R0b20uaGVpZ2h0ICsgYm9yZGVyUm9vdEhlaWdodCArIHByb3BzLmJvcmRlci50b3AgKyBwcm9wcy5ib3JkZXIuYm90dG9tO1xuICAgIGRvbS5yb290LnN0eWxlLmhlaWdodCA9IHV0aWwub3B0aW9uLmFzU2l6ZShvcHRpb25zLmhlaWdodCwgYXV0b0hlaWdodCArICdweCcpO1xuXG4gICAgLy8gY2FsY3VsYXRlIGhlaWdodHMgb2YgdGhlIGNvbnRlbnQgcGFuZWxzXG4gICAgcHJvcHMucm9vdC5oZWlnaHQgPSBkb20ucm9vdC5vZmZzZXRIZWlnaHQ7XG4gICAgcHJvcHMuYmFja2dyb3VuZC5oZWlnaHQgPSBwcm9wcy5yb290LmhlaWdodCAtIGJvcmRlclJvb3RIZWlnaHQ7XG4gICAgdmFyIGNvbnRhaW5lckhlaWdodCA9IHByb3BzLnJvb3QuaGVpZ2h0IC0gcHJvcHMudG9wLmhlaWdodCAtIHByb3BzLmJvdHRvbS5oZWlnaHQgLSBib3JkZXJSb290SGVpZ2h0O1xuICAgIHByb3BzLmNlbnRlckNvbnRhaW5lci5oZWlnaHQgPSBjb250YWluZXJIZWlnaHQ7XG4gICAgcHJvcHMubGVmdENvbnRhaW5lci5oZWlnaHQgPSBjb250YWluZXJIZWlnaHQ7XG4gICAgcHJvcHMucmlnaHRDb250YWluZXIuaGVpZ2h0ID0gcHJvcHMubGVmdENvbnRhaW5lci5oZWlnaHQ7XG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIHdpZHRocyBvZiB0aGUgcGFuZWxzXG4gICAgcHJvcHMucm9vdC53aWR0aCA9IGRvbS5yb290Lm9mZnNldFdpZHRoO1xuICAgIHByb3BzLmJhY2tncm91bmQud2lkdGggPSBwcm9wcy5yb290LndpZHRoIC0gYm9yZGVyUm9vdFdpZHRoO1xuICAgIHByb3BzLmxlZnQud2lkdGggPSBkb20ubGVmdENvbnRhaW5lci5jbGllbnRXaWR0aCB8fCAtcHJvcHMuYm9yZGVyLmxlZnQ7XG4gICAgcHJvcHMubGVmdENvbnRhaW5lci53aWR0aCA9IHByb3BzLmxlZnQud2lkdGg7XG4gICAgcHJvcHMucmlnaHQud2lkdGggPSBkb20ucmlnaHRDb250YWluZXIuY2xpZW50V2lkdGggfHwgLXByb3BzLmJvcmRlci5yaWdodDtcbiAgICBwcm9wcy5yaWdodENvbnRhaW5lci53aWR0aCA9IHByb3BzLnJpZ2h0LndpZHRoO1xuICAgIHZhciBjZW50ZXJXaWR0aCA9IHByb3BzLnJvb3Qud2lkdGggLSBwcm9wcy5sZWZ0LndpZHRoIC0gcHJvcHMucmlnaHQud2lkdGggLSBib3JkZXJSb290V2lkdGg7XG4gICAgcHJvcHMuY2VudGVyLndpZHRoID0gY2VudGVyV2lkdGg7XG4gICAgcHJvcHMuY2VudGVyQ29udGFpbmVyLndpZHRoID0gY2VudGVyV2lkdGg7XG4gICAgcHJvcHMudG9wLndpZHRoID0gY2VudGVyV2lkdGg7XG4gICAgcHJvcHMuYm90dG9tLndpZHRoID0gY2VudGVyV2lkdGg7XG5cbiAgICAvLyByZXNpemUgdGhlIHBhbmVsc1xuICAgIGRvbS5iYWNrZ3JvdW5kLnN0eWxlLmhlaWdodCA9IHByb3BzLmJhY2tncm91bmQuaGVpZ2h0ICsgJ3B4JztcbiAgICBkb20uYmFja2dyb3VuZFZlcnRpY2FsLnN0eWxlLmhlaWdodCA9IHByb3BzLmJhY2tncm91bmQuaGVpZ2h0ICsgJ3B4JztcbiAgICBkb20uYmFja2dyb3VuZEhvcml6b250YWwuc3R5bGUuaGVpZ2h0ID0gcHJvcHMuY2VudGVyQ29udGFpbmVyLmhlaWdodCArICdweCc7XG4gICAgZG9tLmNlbnRlckNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBwcm9wcy5jZW50ZXJDb250YWluZXIuaGVpZ2h0ICsgJ3B4JztcbiAgICBkb20ubGVmdENvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBwcm9wcy5sZWZ0Q29udGFpbmVyLmhlaWdodCArICdweCc7XG4gICAgZG9tLnJpZ2h0Q29udGFpbmVyLnN0eWxlLmhlaWdodCA9IHByb3BzLnJpZ2h0Q29udGFpbmVyLmhlaWdodCArICdweCc7XG5cbiAgICBkb20uYmFja2dyb3VuZC5zdHlsZS53aWR0aCA9IHByb3BzLmJhY2tncm91bmQud2lkdGggKyAncHgnO1xuICAgIGRvbS5iYWNrZ3JvdW5kVmVydGljYWwuc3R5bGUud2lkdGggPSBwcm9wcy5jZW50ZXJDb250YWluZXIud2lkdGggKyAncHgnO1xuICAgIGRvbS5iYWNrZ3JvdW5kSG9yaXpvbnRhbC5zdHlsZS53aWR0aCA9IHByb3BzLmJhY2tncm91bmQud2lkdGggKyAncHgnO1xuICAgIGRvbS5jZW50ZXJDb250YWluZXIuc3R5bGUud2lkdGggPSBwcm9wcy5jZW50ZXIud2lkdGggKyAncHgnO1xuICAgIGRvbS50b3Auc3R5bGUud2lkdGggPSBwcm9wcy50b3Aud2lkdGggKyAncHgnO1xuICAgIGRvbS5ib3R0b20uc3R5bGUud2lkdGggPSBwcm9wcy5ib3R0b20ud2lkdGggKyAncHgnO1xuXG4gICAgLy8gcmVwb3NpdGlvbiB0aGUgcGFuZWxzXG4gICAgZG9tLmJhY2tncm91bmQuc3R5bGUubGVmdCA9ICcwJztcbiAgICBkb20uYmFja2dyb3VuZC5zdHlsZS50b3AgPSAnMCc7XG4gICAgZG9tLmJhY2tncm91bmRWZXJ0aWNhbC5zdHlsZS5sZWZ0ID0gcHJvcHMubGVmdC53aWR0aCArIHByb3BzLmJvcmRlci5sZWZ0ICsgJ3B4JztcbiAgICBkb20uYmFja2dyb3VuZFZlcnRpY2FsLnN0eWxlLnRvcCA9ICcwJztcbiAgICBkb20uYmFja2dyb3VuZEhvcml6b250YWwuc3R5bGUubGVmdCA9ICcwJztcbiAgICBkb20uYmFja2dyb3VuZEhvcml6b250YWwuc3R5bGUudG9wID0gcHJvcHMudG9wLmhlaWdodCArICdweCc7XG4gICAgZG9tLmNlbnRlckNvbnRhaW5lci5zdHlsZS5sZWZ0ID0gcHJvcHMubGVmdC53aWR0aCArICdweCc7XG4gICAgZG9tLmNlbnRlckNvbnRhaW5lci5zdHlsZS50b3AgPSBwcm9wcy50b3AuaGVpZ2h0ICsgJ3B4JztcbiAgICBkb20ubGVmdENvbnRhaW5lci5zdHlsZS5sZWZ0ID0gJzAnO1xuICAgIGRvbS5sZWZ0Q29udGFpbmVyLnN0eWxlLnRvcCA9IHByb3BzLnRvcC5oZWlnaHQgKyAncHgnO1xuICAgIGRvbS5yaWdodENvbnRhaW5lci5zdHlsZS5sZWZ0ID0gcHJvcHMubGVmdC53aWR0aCArIHByb3BzLmNlbnRlci53aWR0aCArICdweCc7XG4gICAgZG9tLnJpZ2h0Q29udGFpbmVyLnN0eWxlLnRvcCA9IHByb3BzLnRvcC5oZWlnaHQgKyAncHgnO1xuICAgIGRvbS50b3Auc3R5bGUubGVmdCA9IHByb3BzLmxlZnQud2lkdGggKyAncHgnO1xuICAgIGRvbS50b3Auc3R5bGUudG9wID0gJzAnO1xuICAgIGRvbS5ib3R0b20uc3R5bGUubGVmdCA9IHByb3BzLmxlZnQud2lkdGggKyAncHgnO1xuICAgIGRvbS5ib3R0b20uc3R5bGUudG9wID0gcHJvcHMudG9wLmhlaWdodCArIHByb3BzLmNlbnRlckNvbnRhaW5lci5oZWlnaHQgKyAncHgnO1xuXG4gICAgLy8gdXBkYXRlIHRoZSBzY3JvbGxUb3AsIGZlYXNpYmxlIHJhbmdlIGZvciB0aGUgb2Zmc2V0IGNhbiBiZSBjaGFuZ2VkXG4gICAgLy8gd2hlbiB0aGUgaGVpZ2h0IG9mIHRoZSBDb3JlIG9yIG9mIHRoZSBjb250ZW50cyBvZiB0aGUgY2VudGVyIGNoYW5nZWRcbiAgICB0aGlzLl91cGRhdGVTY3JvbGxUb3AoKTtcblxuICAgIC8vIHJlcG9zaXRpb24gdGhlIHNjcm9sbGFibGUgY29udGVudHNcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5wcm9wcy5zY3JvbGxUb3A7XG4gICAgaWYgKG9wdGlvbnMub3JpZW50YXRpb24uaXRlbSAhPSAndG9wJykge1xuICAgICAgb2Zmc2V0ICs9IE1hdGgubWF4KHRoaXMucHJvcHMuY2VudGVyQ29udGFpbmVyLmhlaWdodCAtIHRoaXMucHJvcHMuY2VudGVyLmhlaWdodCAtIHRoaXMucHJvcHMuYm9yZGVyLnRvcCAtIHRoaXMucHJvcHMuYm9yZGVyLmJvdHRvbSwgMCk7XG4gICAgfVxuICAgIGRvbS5jZW50ZXIuc3R5bGUubGVmdCA9ICcwJztcbiAgICBkb20uY2VudGVyLnN0eWxlLnRvcCA9IG9mZnNldCArICdweCc7XG4gICAgZG9tLmxlZnQuc3R5bGUubGVmdCA9ICcwJztcbiAgICBkb20ubGVmdC5zdHlsZS50b3AgPSBvZmZzZXQgKyAncHgnO1xuICAgIGRvbS5yaWdodC5zdHlsZS5sZWZ0ID0gJzAnO1xuICAgIGRvbS5yaWdodC5zdHlsZS50b3AgPSBvZmZzZXQgKyAncHgnO1xuXG4gICAgLy8gc2hvdyBzaGFkb3dzIHdoZW4gdmVydGljYWwgc2Nyb2xsaW5nIGlzIGF2YWlsYWJsZVxuICAgIHZhciB2aXNpYmlsaXR5VG9wID0gdGhpcy5wcm9wcy5zY3JvbGxUb3AgPT0gMCA/ICdoaWRkZW4nIDogJyc7XG4gICAgdmFyIHZpc2liaWxpdHlCb3R0b20gPSB0aGlzLnByb3BzLnNjcm9sbFRvcCA9PSB0aGlzLnByb3BzLnNjcm9sbFRvcE1pbiA/ICdoaWRkZW4nIDogJyc7XG4gICAgZG9tLnNoYWRvd1RvcC5zdHlsZS52aXNpYmlsaXR5ID0gdmlzaWJpbGl0eVRvcDtcbiAgICBkb20uc2hhZG93Qm90dG9tLnN0eWxlLnZpc2liaWxpdHkgPSB2aXNpYmlsaXR5Qm90dG9tO1xuICAgIGRvbS5zaGFkb3dUb3BMZWZ0LnN0eWxlLnZpc2liaWxpdHkgPSB2aXNpYmlsaXR5VG9wO1xuICAgIGRvbS5zaGFkb3dCb3R0b21MZWZ0LnN0eWxlLnZpc2liaWxpdHkgPSB2aXNpYmlsaXR5Qm90dG9tO1xuICAgIGRvbS5zaGFkb3dUb3BSaWdodC5zdHlsZS52aXNpYmlsaXR5ID0gdmlzaWJpbGl0eVRvcDtcbiAgICBkb20uc2hhZG93Qm90dG9tUmlnaHQuc3R5bGUudmlzaWJpbGl0eSA9IHZpc2liaWxpdHlCb3R0b207XG5cbiAgICAvLyBlbmFibGUvZGlzYWJsZSB2ZXJ0aWNhbCBwYW5uaW5nXG4gICAgdmFyIGNvbnRlbnRzT3ZlcmZsb3cgPSB0aGlzLnByb3BzLmNlbnRlci5oZWlnaHQgPiB0aGlzLnByb3BzLmNlbnRlckNvbnRhaW5lci5oZWlnaHQ7XG4gICAgdGhpcy5oYW1tZXIuZ2V0KCdwYW4nKS5zZXQoe1xuICAgICAgZGlyZWN0aW9uOiBjb250ZW50c092ZXJmbG93ID8gSGFtbWVyLkRJUkVDVElPTl9BTEwgOiBIYW1tZXIuRElSRUNUSU9OX0hPUklaT05UQUxcbiAgICB9KTtcblxuICAgIC8vIHJlZHJhdyBhbGwgY29tcG9uZW50c1xuICAgIHRoaXMuY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgIHJlc2l6ZWQgPSBjb21wb25lbnQucmVkcmF3KCkgfHwgcmVzaXplZDtcbiAgICB9KTtcbiAgICB2YXIgTUFYX1JFRFJBVyA9IDU7XG4gICAgaWYgKHJlc2l6ZWQpIHtcbiAgICAgIGlmICh0aGlzLnJlZHJhd0NvdW50IDwgTUFYX1JFRFJBVykge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfY2hhbmdlJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdXQVJOSU5HOiBpbmZpbml0ZSBsb29wIGluIHJlZHJhdz8nKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWRyYXdDb3VudCA9IDA7XG4gICAgfVxuICAgIHRoaXMuaW5pdGlhbERyYXdEb25lID0gdHJ1ZTtcblxuICAgIC8vRW1pdCBwdWJsaWMgJ2NoYW5nZWQnIGV2ZW50IGZvciBVSSB1cGRhdGVzLCBzZWUgaXNzdWUgIzE1OTJcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiY2hhbmdlZFwiKTtcbiAgfTtcblxuICAvLyBUT0RPOiBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMS4xLjAsIHJlbW92ZSBzb21lIGRheVxuICBDb3JlLnByb3RvdHlwZS5yZXBhaW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gcmVwYWludCBpcyBkZXByZWNhdGVkLiBVc2UgcmVkcmF3IGluc3RlYWQuJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBhIGN1cnJlbnQgdGltZS4gVGhpcyBjYW4gYmUgdXNlZCBmb3IgZXhhbXBsZSB0byBlbnN1cmUgdGhhdCBhIGNsaWVudCdzXG4gICAqIHRpbWUgaXMgc3luY2hyb25pemVkIHdpdGggYSBzaGFyZWQgc2VydmVyIHRpbWUuXG4gICAqIE9ubHkgYXBwbGljYWJsZSB3aGVuIG9wdGlvbiBgc2hvd0N1cnJlbnRUaW1lYCBpcyB0cnVlLlxuICAgKiBAcGFyYW0ge0RhdGUgfCBTdHJpbmcgfCBOdW1iZXJ9IHRpbWUgICAgIEEgRGF0ZSwgdW5peCB0aW1lc3RhbXAsIG9yXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSVNPIGRhdGUgc3RyaW5nLlxuICAgKi9cbiAgQ29yZS5wcm90b3R5cGUuc2V0Q3VycmVudFRpbWUgPSBmdW5jdGlvbiAodGltZSkge1xuICAgIGlmICghdGhpcy5jdXJyZW50VGltZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb24gc2hvd0N1cnJlbnRUaW1lIG11c3QgYmUgdHJ1ZScpO1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudFRpbWUuc2V0Q3VycmVudFRpbWUodGltZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCB0aW1lLlxuICAgKiBPbmx5IGFwcGxpY2FibGUgd2hlbiBvcHRpb24gYHNob3dDdXJyZW50VGltZWAgaXMgdHJ1ZS5cbiAgICogQHJldHVybiB7RGF0ZX0gUmV0dXJucyB0aGUgY3VycmVudCB0aW1lLlxuICAgKi9cbiAgQ29yZS5wcm90b3R5cGUuZ2V0Q3VycmVudFRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmN1cnJlbnRUaW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbiBzaG93Q3VycmVudFRpbWUgbXVzdCBiZSB0cnVlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFRpbWUuZ2V0Q3VycmVudFRpbWUoKTtcbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydCBhIHBvc2l0aW9uIG9uIHNjcmVlbiAocGl4ZWxzKSB0byBhIGRhdGV0aW1lXG4gICAqIEBwYXJhbSB7aW50fSAgICAgeCAgICBQb3NpdGlvbiBvbiB0aGUgc2NyZWVuIGluIHBpeGVsc1xuICAgKiBAcmV0dXJuIHtEYXRlfSAgIHRpbWUgVGhlIGRhdGV0aW1lIHRoZSBjb3JyZXNwb25kcyB3aXRoIGdpdmVuIHBvc2l0aW9uIHhcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgLy8gVE9ETzogbW92ZSB0aGlzIGZ1bmN0aW9uIHRvIFJhbmdlXG4gIENvcmUucHJvdG90eXBlLl90b1RpbWUgPSBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBEYXRlVXRpbC50b1RpbWUodGhpcywgeCwgdGhpcy5wcm9wcy5jZW50ZXIud2lkdGgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgcG9zaXRpb24gb24gdGhlIGdsb2JhbCBzY3JlZW4gKHBpeGVscykgdG8gYSBkYXRldGltZVxuICAgKiBAcGFyYW0ge2ludH0gICAgIHggICAgUG9zaXRpb24gb24gdGhlIHNjcmVlbiBpbiBwaXhlbHNcbiAgICogQHJldHVybiB7RGF0ZX0gICB0aW1lIFRoZSBkYXRldGltZSB0aGUgY29ycmVzcG9uZHMgd2l0aCBnaXZlbiBwb3NpdGlvbiB4XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIC8vIFRPRE86IG1vdmUgdGhpcyBmdW5jdGlvbiB0byBSYW5nZVxuICBDb3JlLnByb3RvdHlwZS5fdG9HbG9iYWxUaW1lID0gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gRGF0ZVV0aWwudG9UaW1lKHRoaXMsIHgsIHRoaXMucHJvcHMucm9vdC53aWR0aCk7XG4gICAgLy92YXIgY29udmVyc2lvbiA9IHRoaXMucmFuZ2UuY29udmVyc2lvbih0aGlzLnByb3BzLnJvb3Qud2lkdGgpO1xuICAgIC8vcmV0dXJuIG5ldyBEYXRlKHggLyBjb252ZXJzaW9uLnNjYWxlICsgY29udmVyc2lvbi5vZmZzZXQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgZGF0ZXRpbWUgKERhdGUgb2JqZWN0KSBpbnRvIGEgcG9zaXRpb24gb24gdGhlIHNjcmVlblxuICAgKiBAcGFyYW0ge0RhdGV9ICAgdGltZSBBIGRhdGVcbiAgICogQHJldHVybiB7aW50fSAgIHggICAgVGhlIHBvc2l0aW9uIG9uIHRoZSBzY3JlZW4gaW4gcGl4ZWxzIHdoaWNoIGNvcnJlc3BvbmRzXG4gICAqICAgICAgICAgICAgICAgICAgICAgIHdpdGggdGhlIGdpdmVuIGRhdGUuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIC8vIFRPRE86IG1vdmUgdGhpcyBmdW5jdGlvbiB0byBSYW5nZVxuICBDb3JlLnByb3RvdHlwZS5fdG9TY3JlZW4gPSBmdW5jdGlvbiAodGltZSkge1xuICAgIHJldHVybiBEYXRlVXRpbC50b1NjcmVlbih0aGlzLCB0aW1lLCB0aGlzLnByb3BzLmNlbnRlci53aWR0aCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBkYXRldGltZSAoRGF0ZSBvYmplY3QpIGludG8gYSBwb3NpdGlvbiBvbiB0aGUgcm9vdFxuICAgKiBUaGlzIGlzIHVzZWQgdG8gZ2V0IHRoZSBwaXhlbCBkZW5zaXR5IGVzdGltYXRlIGZvciB0aGUgc2NyZWVuLCBub3QgdGhlIGNlbnRlciBwYW5lbFxuICAgKiBAcGFyYW0ge0RhdGV9ICAgdGltZSBBIGRhdGVcbiAgICogQHJldHVybiB7aW50fSAgIHggICAgVGhlIHBvc2l0aW9uIG9uIHJvb3QgaW4gcGl4ZWxzIHdoaWNoIGNvcnJlc3BvbmRzXG4gICAqICAgICAgICAgICAgICAgICAgICAgIHdpdGggdGhlIGdpdmVuIGRhdGUuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIC8vIFRPRE86IG1vdmUgdGhpcyBmdW5jdGlvbiB0byBSYW5nZVxuICBDb3JlLnByb3RvdHlwZS5fdG9HbG9iYWxTY3JlZW4gPSBmdW5jdGlvbiAodGltZSkge1xuICAgIHJldHVybiBEYXRlVXRpbC50b1NjcmVlbih0aGlzLCB0aW1lLCB0aGlzLnByb3BzLnJvb3Qud2lkdGgpO1xuICAgIC8vdmFyIGNvbnZlcnNpb24gPSB0aGlzLnJhbmdlLmNvbnZlcnNpb24odGhpcy5wcm9wcy5yb290LndpZHRoKTtcbiAgICAvL3JldHVybiAodGltZS52YWx1ZU9mKCkgLSBjb252ZXJzaW9uLm9mZnNldCkgKiBjb252ZXJzaW9uLnNjYWxlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHdhdGNoaW5nIHdoZW4gb3B0aW9uIGF1dG9SZXNpemUgaXMgdHJ1ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQ29yZS5wcm90b3R5cGUuX2luaXRBdXRvUmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b1Jlc2l6ZSA9PSB0cnVlKSB7XG4gICAgICB0aGlzLl9zdGFydEF1dG9SZXNpemUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc3RvcEF1dG9SZXNpemUoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFdhdGNoIGZvciBjaGFuZ2VzIGluIHRoZSBzaXplIG9mIHRoZSBjb250YWluZXIuIE9uIHJlc2l6ZSwgdGhlIFBhbmVsIHdpbGxcbiAgICogYXV0b21hdGljYWxseSByZWRyYXcgaXRzZWxmLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQ29yZS5wcm90b3R5cGUuX3N0YXJ0QXV0b1Jlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuXG4gICAgdGhpcy5fc3RvcEF1dG9SZXNpemUoKTtcblxuICAgIHRoaXMuX29uUmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG1lLm9wdGlvbnMuYXV0b1Jlc2l6ZSAhPSB0cnVlKSB7XG4gICAgICAgIC8vIHN0b3Agd2F0Y2hpbmcgd2hlbiB0aGUgb3B0aW9uIGF1dG9SZXNpemUgaXMgY2hhbmdlZCB0byBmYWxzZVxuICAgICAgICBtZS5fc3RvcEF1dG9SZXNpemUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobWUuZG9tLnJvb3QpIHtcbiAgICAgICAgLy8gY2hlY2sgd2hldGhlciB0aGUgZnJhbWUgaXMgcmVzaXplZFxuICAgICAgICAvLyBOb3RlOiB3ZSBjb21wYXJlIG9mZnNldFdpZHRoIGhlcmUsIG5vdCBjbGllbnRXaWR0aC4gRm9yIHNvbWUgcmVhc29uLFxuICAgICAgICAvLyBJRSBkb2VzIG5vdCByZXN0b3JlIHRoZSBjbGllbnRXaWR0aCBmcm9tIDAgdG8gdGhlIGFjdHVhbCB3aWR0aCBhZnRlclxuICAgICAgICAvLyBjaGFuZ2luZyB0aGUgdGltZWxpbmUncyBjb250YWluZXIgZGlzcGxheSBzdHlsZSBmcm9tIG5vbmUgdG8gdmlzaWJsZVxuICAgICAgICBpZiAobWUuZG9tLnJvb3Qub2Zmc2V0V2lkdGggIT0gbWUucHJvcHMubGFzdFdpZHRoIHx8IG1lLmRvbS5yb290Lm9mZnNldEhlaWdodCAhPSBtZS5wcm9wcy5sYXN0SGVpZ2h0KSB7XG4gICAgICAgICAgbWUucHJvcHMubGFzdFdpZHRoID0gbWUuZG9tLnJvb3Qub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgbWUucHJvcHMubGFzdEhlaWdodCA9IG1lLmRvbS5yb290Lm9mZnNldEhlaWdodDtcblxuICAgICAgICAgIG1lLmJvZHkuZW1pdHRlci5lbWl0KCdfY2hhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gYWRkIGV2ZW50IGxpc3RlbmVyIHRvIHdpbmRvdyByZXNpemVcbiAgICB1dGlsLmFkZEV2ZW50TGlzdGVuZXIod2luZG93LCAncmVzaXplJywgdGhpcy5fb25SZXNpemUpO1xuXG4gICAgLy9QcmV2ZW50IGluaXRpYWwgdW5uZWNlc3NhcnkgcmVkcmF3XG4gICAgaWYgKG1lLmRvbS5yb290KSB7XG4gICAgICBtZS5wcm9wcy5sYXN0V2lkdGggPSBtZS5kb20ucm9vdC5vZmZzZXRXaWR0aDtcbiAgICAgIG1lLnByb3BzLmxhc3RIZWlnaHQgPSBtZS5kb20ucm9vdC5vZmZzZXRIZWlnaHQ7XG4gICAgfVxuXG4gICAgdGhpcy53YXRjaFRpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy5fb25SZXNpemUsIDEwMDApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdG9wIHdhdGNoaW5nIGZvciBhIHJlc2l6ZSBvZiB0aGUgZnJhbWUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBDb3JlLnByb3RvdHlwZS5fc3RvcEF1dG9SZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMud2F0Y2hUaW1lcikge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLndhdGNoVGltZXIpO1xuICAgICAgdGhpcy53YXRjaFRpbWVyID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBldmVudCBsaXN0ZW5lciBvbiB3aW5kb3cucmVzaXplXG4gICAgaWYgKHRoaXMuX29uUmVzaXplKSB7XG4gICAgICB1dGlsLnJlbW92ZUV2ZW50TGlzdGVuZXIod2luZG93LCAncmVzaXplJywgdGhpcy5fb25SZXNpemUpO1xuICAgICAgdGhpcy5fb25SZXNpemUgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU3RhcnQgbW92aW5nIHRoZSB0aW1lbGluZSB2ZXJ0aWNhbGx5XG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBDb3JlLnByb3RvdHlwZS5fb25Ub3VjaCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHRoaXMudG91Y2guYWxsb3dEcmFnZ2luZyA9IHRydWU7XG4gICAgdGhpcy50b3VjaC5pbml0aWFsU2Nyb2xsVG9wID0gdGhpcy5wcm9wcy5zY3JvbGxUb3A7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0YXJ0IG1vdmluZyB0aGUgdGltZWxpbmUgdmVydGljYWxseVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQ29yZS5wcm90b3R5cGUuX29uUGluY2ggPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB0aGlzLnRvdWNoLmFsbG93RHJhZ2dpbmcgPSBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogTW92ZSB0aGUgdGltZWxpbmUgdmVydGljYWxseVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQ29yZS5wcm90b3R5cGUuX29uRHJhZyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIHJlZnVzZSB0byBkcmFnIHdoZW4gd2Ugd2hlcmUgcGluY2hpbmcgdG8gcHJldmVudCB0aGUgdGltZWxpbmUgbWFrZSBhIGp1bXBcbiAgICAvLyB3aGVuIHJlbGVhc2luZyB0aGUgZmluZ2VycyBpbiBvcHBvc2l0ZSBvcmRlciBmcm9tIHRoZSB0b3VjaCBzY3JlZW5cbiAgICBpZiAoIXRoaXMudG91Y2guYWxsb3dEcmFnZ2luZykgcmV0dXJuO1xuXG4gICAgdmFyIGRlbHRhID0gZXZlbnQuZGVsdGFZO1xuXG4gICAgdmFyIG9sZFNjcm9sbFRvcCA9IHRoaXMuX2dldFNjcm9sbFRvcCgpO1xuICAgIHZhciBuZXdTY3JvbGxUb3AgPSB0aGlzLl9zZXRTY3JvbGxUb3AodGhpcy50b3VjaC5pbml0aWFsU2Nyb2xsVG9wICsgZGVsdGEpO1xuXG4gICAgaWYgKG5ld1Njcm9sbFRvcCAhPSBvbGRTY3JvbGxUb3ApIHtcbiAgICAgIHRoaXMuZW1pdChcInZlcnRpY2FsRHJhZ1wiKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFwcGx5IGEgc2Nyb2xsVG9wXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzY3JvbGxUb3BcbiAgICogQHJldHVybnMge051bWJlcn0gc2Nyb2xsVG9wICBSZXR1cm5zIHRoZSBhcHBsaWVkIHNjcm9sbFRvcFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQ29yZS5wcm90b3R5cGUuX3NldFNjcm9sbFRvcCA9IGZ1bmN0aW9uIChzY3JvbGxUb3ApIHtcbiAgICB0aGlzLnByb3BzLnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICB0aGlzLl91cGRhdGVTY3JvbGxUb3AoKTtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5zY3JvbGxUb3A7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgY3VycmVudCBzY3JvbGxUb3Agd2hlbiB0aGUgaGVpZ2h0IG9mICB0aGUgY29udGFpbmVycyBoYXMgYmVlbiBjaGFuZ2VkXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHNjcm9sbFRvcCAgUmV0dXJucyB0aGUgYXBwbGllZCBzY3JvbGxUb3BcbiAgICogQHByaXZhdGVcbiAgICovXG4gIENvcmUucHJvdG90eXBlLl91cGRhdGVTY3JvbGxUb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gcmVjYWxjdWxhdGUgdGhlIHNjcm9sbFRvcE1pblxuICAgIHZhciBzY3JvbGxUb3BNaW4gPSBNYXRoLm1pbih0aGlzLnByb3BzLmNlbnRlckNvbnRhaW5lci5oZWlnaHQgLSB0aGlzLnByb3BzLmNlbnRlci5oZWlnaHQsIDApOyAvLyBpcyBuZWdhdGl2ZSBvciB6ZXJvXG4gICAgaWYgKHNjcm9sbFRvcE1pbiAhPSB0aGlzLnByb3BzLnNjcm9sbFRvcE1pbikge1xuICAgICAgLy8gaW4gY2FzZSBvZiBib3R0b20gb3JpZW50YXRpb24sIGNoYW5nZSB0aGUgc2Nyb2xsVG9wIHN1Y2ggdGhhdCB0aGUgY29udGVudHNcbiAgICAgIC8vIGRvIG5vdCBtb3ZlIHJlbGF0aXZlIHRvIHRoZSB0aW1lIGF4aXMgYXQgdGhlIGJvdHRvbVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5pdGVtICE9ICd0b3AnKSB7XG4gICAgICAgIHRoaXMucHJvcHMuc2Nyb2xsVG9wICs9IHNjcm9sbFRvcE1pbiAtIHRoaXMucHJvcHMuc2Nyb2xsVG9wTWluO1xuICAgICAgfVxuICAgICAgdGhpcy5wcm9wcy5zY3JvbGxUb3BNaW4gPSBzY3JvbGxUb3BNaW47XG4gICAgfVxuXG4gICAgLy8gbGltaXQgdGhlIHNjcm9sbFRvcCB0byB0aGUgZmVhc2libGUgc2Nyb2xsIHJhbmdlXG4gICAgaWYgKHRoaXMucHJvcHMuc2Nyb2xsVG9wID4gMCkgdGhpcy5wcm9wcy5zY3JvbGxUb3AgPSAwO1xuICAgIGlmICh0aGlzLnByb3BzLnNjcm9sbFRvcCA8IHNjcm9sbFRvcE1pbikgdGhpcy5wcm9wcy5zY3JvbGxUb3AgPSBzY3JvbGxUb3BNaW47XG5cbiAgICByZXR1cm4gdGhpcy5wcm9wcy5zY3JvbGxUb3A7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBzY3JvbGxUb3BcbiAgICogQHJldHVybnMge251bWJlcn0gc2Nyb2xsVG9wXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBDb3JlLnByb3RvdHlwZS5fZ2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLnNjcm9sbFRvcDtcbiAgfTtcblxuICAvKipcbiAgICogTG9hZCBhIGNvbmZpZ3VyYXRvclxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBDb3JlLnByb3RvdHlwZS5fY3JlYXRlQ29uZmlndXJhdG9yID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludm9rZSBhYnN0cmFjdCBtZXRob2QgX2NyZWF0ZUNvbmZpZ3VyYXRvcicpO1xuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gQ29yZTtcblxuLyoqKi8gfSxcbi8qIDM0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbiAgdmFyIEhhbW1lciA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4gIHZhciBEYXRhU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcbiAgdmFyIERhdGFWaWV3ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG4gIHZhciBUaW1lU3RlcCA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpO1xuICB2YXIgQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSk7XG4gIHZhciBHcm91cCA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpO1xuICB2YXIgQmFja2dyb3VuZEdyb3VwID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MCk7XG4gIHZhciBCb3hJdGVtID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MSk7XG4gIHZhciBQb2ludEl0ZW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKTtcbiAgdmFyIFJhbmdlSXRlbSA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpO1xuICB2YXIgQmFja2dyb3VuZEl0ZW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzKTtcblxuICB2YXIgVU5HUk9VUEVEID0gJ19fdW5ncm91cGVkX18nOyAvLyByZXNlcnZlZCBncm91cCBpZCBmb3IgdW5ncm91cGVkIGl0ZW1zXG4gIHZhciBCQUNLR1JPVU5EID0gJ19fYmFja2dyb3VuZF9fJzsgLy8gcmVzZXJ2ZWQgZ3JvdXAgaWQgZm9yIGJhY2tncm91bmQgaXRlbXMgd2l0aG91dCBncm91cFxuXG4gIC8qKlxuICAgKiBBbiBJdGVtU2V0IGhvbGRzIGEgc2V0IG9mIGl0ZW1zIGFuZCByYW5nZXMgd2hpY2ggY2FuIGJlIGRpc3BsYXllZCBpbiBhXG4gICAqIHJhbmdlLiBUaGUgd2lkdGggaXMgZGV0ZXJtaW5lZCBieSB0aGUgcGFyZW50IG9mIHRoZSBJdGVtU2V0LCBhbmQgdGhlIGhlaWdodFxuICAgKiBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBzaXplIG9mIHRoZSBpdGVtcy5cbiAgICogQHBhcmFtIHt7ZG9tOiBPYmplY3QsIGRvbVByb3BzOiBPYmplY3QsIGVtaXR0ZXI6IEVtaXR0ZXIsIHJhbmdlOiBSYW5nZX19IGJvZHlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICAgIFNlZSBJdGVtU2V0LnNldE9wdGlvbnMgZm9yIHRoZSBhdmFpbGFibGUgb3B0aW9ucy5cbiAgICogQGNvbnN0cnVjdG9yIEl0ZW1TZXRcbiAgICogQGV4dGVuZHMgQ29tcG9uZW50XG4gICAqL1xuICBmdW5jdGlvbiBJdGVtU2V0KGJvZHksIG9wdGlvbnMpIHtcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBydGw6IGZhbHNlLFxuICAgICAgdHlwZTogbnVsbCwgLy8gJ2JveCcsICdwb2ludCcsICdyYW5nZScsICdiYWNrZ3JvdW5kJ1xuICAgICAgb3JpZW50YXRpb246IHtcbiAgICAgICAgaXRlbTogJ2JvdHRvbScgLy8gaXRlbSBvcmllbnRhdGlvbjogJ3RvcCcgb3IgJ2JvdHRvbSdcbiAgICAgIH0sXG4gICAgICBhbGlnbjogJ2F1dG8nLCAvLyBhbGlnbm1lbnQgb2YgYm94IGl0ZW1zXG4gICAgICBzdGFjazogdHJ1ZSxcbiAgICAgIGdyb3VwT3JkZXJTd2FwOiBmdW5jdGlvbiBncm91cE9yZGVyU3dhcChmcm9tR3JvdXAsIHRvR3JvdXAsIGdyb3Vwcykge1xuICAgICAgICB2YXIgdGFyZ2V0T3JkZXIgPSB0b0dyb3VwLm9yZGVyO1xuICAgICAgICB0b0dyb3VwLm9yZGVyID0gZnJvbUdyb3VwLm9yZGVyO1xuICAgICAgICBmcm9tR3JvdXAub3JkZXIgPSB0YXJnZXRPcmRlcjtcbiAgICAgIH0sXG4gICAgICBncm91cE9yZGVyOiAnb3JkZXInLFxuXG4gICAgICBzZWxlY3RhYmxlOiB0cnVlLFxuICAgICAgbXVsdGlzZWxlY3Q6IGZhbHNlLFxuICAgICAgaXRlbXNBbHdheXNEcmFnZ2FibGU6IGZhbHNlLFxuXG4gICAgICBlZGl0YWJsZToge1xuICAgICAgICB1cGRhdGVUaW1lOiBmYWxzZSxcbiAgICAgICAgdXBkYXRlR3JvdXA6IGZhbHNlLFxuICAgICAgICBhZGQ6IGZhbHNlLFxuICAgICAgICByZW1vdmU6IGZhbHNlXG4gICAgICB9LFxuXG4gICAgICBncm91cEVkaXRhYmxlOiB7XG4gICAgICAgIG9yZGVyOiBmYWxzZSxcbiAgICAgICAgYWRkOiBmYWxzZSxcbiAgICAgICAgcmVtb3ZlOiBmYWxzZVxuICAgICAgfSxcblxuICAgICAgc25hcDogVGltZVN0ZXAuc25hcCxcblxuICAgICAgb25BZGQ6IGZ1bmN0aW9uIG9uQWRkKGl0ZW0sIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKGl0ZW0pO1xuICAgICAgfSxcbiAgICAgIG9uVXBkYXRlOiBmdW5jdGlvbiBvblVwZGF0ZShpdGVtLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayhpdGVtKTtcbiAgICAgIH0sXG4gICAgICBvbk1vdmU6IGZ1bmN0aW9uIG9uTW92ZShpdGVtLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayhpdGVtKTtcbiAgICAgIH0sXG4gICAgICBvblJlbW92ZTogZnVuY3Rpb24gb25SZW1vdmUoaXRlbSwgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soaXRlbSk7XG4gICAgICB9LFxuICAgICAgb25Nb3Zpbmc6IGZ1bmN0aW9uIG9uTW92aW5nKGl0ZW0sIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKGl0ZW0pO1xuICAgICAgfSxcbiAgICAgIG9uQWRkR3JvdXA6IGZ1bmN0aW9uIG9uQWRkR3JvdXAoaXRlbSwgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soaXRlbSk7XG4gICAgICB9LFxuICAgICAgb25Nb3ZlR3JvdXA6IGZ1bmN0aW9uIG9uTW92ZUdyb3VwKGl0ZW0sIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKGl0ZW0pO1xuICAgICAgfSxcbiAgICAgIG9uUmVtb3ZlR3JvdXA6IGZ1bmN0aW9uIG9uUmVtb3ZlR3JvdXAoaXRlbSwgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soaXRlbSk7XG4gICAgICB9LFxuXG4gICAgICBtYXJnaW46IHtcbiAgICAgICAgaXRlbToge1xuICAgICAgICAgIGhvcml6b250YWw6IDEwLFxuICAgICAgICAgIHZlcnRpY2FsOiAxMFxuICAgICAgICB9LFxuICAgICAgICBheGlzOiAyMFxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBvcHRpb25zIGlzIHNoYXJlZCBieSB0aGlzIEl0ZW1TZXQgYW5kIGFsbCBpdHMgaXRlbXNcbiAgICB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgICAvLyBvcHRpb25zIGZvciBnZXR0aW5nIGl0ZW1zIGZyb20gdGhlIERhdGFTZXQgd2l0aCB0aGUgY29ycmVjdCB0eXBlXG4gICAgdGhpcy5pdGVtT3B0aW9ucyA9IHtcbiAgICAgIHR5cGU6IHsgc3RhcnQ6ICdEYXRlJywgZW5kOiAnRGF0ZScgfVxuICAgIH07XG5cbiAgICB0aGlzLmNvbnZlcnNpb24gPSB7XG4gICAgICB0b1NjcmVlbjogYm9keS51dGlsLnRvU2NyZWVuLFxuICAgICAgdG9UaW1lOiBib2R5LnV0aWwudG9UaW1lXG4gICAgfTtcbiAgICB0aGlzLmRvbSA9IHt9O1xuICAgIHRoaXMucHJvcHMgPSB7fTtcbiAgICB0aGlzLmhhbW1lciA9IG51bGw7XG5cbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHRoaXMuaXRlbXNEYXRhID0gbnVsbDsgLy8gRGF0YVNldFxuICAgIHRoaXMuZ3JvdXBzRGF0YSA9IG51bGw7IC8vIERhdGFTZXRcblxuICAgIC8vIGxpc3RlbmVycyBmb3IgdGhlIERhdGFTZXQgb2YgdGhlIGl0ZW1zXG4gICAgdGhpcy5pdGVtTGlzdGVuZXJzID0ge1xuICAgICAgJ2FkZCc6IGZ1bmN0aW9uIGFkZChldmVudCwgcGFyYW1zLCBzZW5kZXJJZCkge1xuICAgICAgICBtZS5fb25BZGQocGFyYW1zLml0ZW1zKTtcbiAgICAgIH0sXG4gICAgICAndXBkYXRlJzogZnVuY3Rpb24gdXBkYXRlKGV2ZW50LCBwYXJhbXMsIHNlbmRlcklkKSB7XG4gICAgICAgIG1lLl9vblVwZGF0ZShwYXJhbXMuaXRlbXMpO1xuICAgICAgfSxcbiAgICAgICdyZW1vdmUnOiBmdW5jdGlvbiByZW1vdmUoZXZlbnQsIHBhcmFtcywgc2VuZGVySWQpIHtcbiAgICAgICAgbWUuX29uUmVtb3ZlKHBhcmFtcy5pdGVtcyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIGxpc3RlbmVycyBmb3IgdGhlIERhdGFTZXQgb2YgdGhlIGdyb3Vwc1xuICAgIHRoaXMuZ3JvdXBMaXN0ZW5lcnMgPSB7XG4gICAgICAnYWRkJzogZnVuY3Rpb24gYWRkKGV2ZW50LCBwYXJhbXMsIHNlbmRlcklkKSB7XG4gICAgICAgIG1lLl9vbkFkZEdyb3VwcyhwYXJhbXMuaXRlbXMpO1xuICAgICAgfSxcbiAgICAgICd1cGRhdGUnOiBmdW5jdGlvbiB1cGRhdGUoZXZlbnQsIHBhcmFtcywgc2VuZGVySWQpIHtcbiAgICAgICAgbWUuX29uVXBkYXRlR3JvdXBzKHBhcmFtcy5pdGVtcyk7XG4gICAgICB9LFxuICAgICAgJ3JlbW92ZSc6IGZ1bmN0aW9uIHJlbW92ZShldmVudCwgcGFyYW1zLCBzZW5kZXJJZCkge1xuICAgICAgICBtZS5fb25SZW1vdmVHcm91cHMocGFyYW1zLml0ZW1zKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5pdGVtcyA9IHt9OyAvLyBvYmplY3Qgd2l0aCBhbiBJdGVtIGZvciBldmVyeSBkYXRhIGl0ZW1cbiAgICB0aGlzLmdyb3VwcyA9IHt9OyAvLyBHcm91cCBvYmplY3QgZm9yIGV2ZXJ5IGdyb3VwXG4gICAgdGhpcy5ncm91cElkcyA9IFtdO1xuXG4gICAgdGhpcy5zZWxlY3Rpb24gPSBbXTsgLy8gbGlzdCB3aXRoIHRoZSBpZHMgb2YgYWxsIHNlbGVjdGVkIG5vZGVzXG4gICAgdGhpcy5zdGFja0RpcnR5ID0gdHJ1ZTsgLy8gaWYgdHJ1ZSwgYWxsIGl0ZW1zIHdpbGwgYmUgcmVzdGFja2VkIG9uIG5leHQgcmVkcmF3XG5cbiAgICB0aGlzLnRvdWNoUGFyYW1zID0ge307IC8vIHN0b3JlcyBwcm9wZXJ0aWVzIHdoaWxlIGRyYWdnaW5nXG4gICAgdGhpcy5ncm91cFRvdWNoUGFyYW1zID0ge307XG4gICAgLy8gY3JlYXRlIHRoZSBIVE1MIERPTVxuXG4gICAgdGhpcy5fY3JlYXRlKCk7XG5cbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIH1cblxuICBJdGVtU2V0LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnQoKTtcblxuICAvLyBhdmFpbGFibGUgaXRlbSB0eXBlcyB3aWxsIGJlIHJlZ2lzdGVyZWQgaGVyZVxuICBJdGVtU2V0LnR5cGVzID0ge1xuICAgIGJhY2tncm91bmQ6IEJhY2tncm91bmRJdGVtLFxuICAgIGJveDogQm94SXRlbSxcbiAgICByYW5nZTogUmFuZ2VJdGVtLFxuICAgIHBvaW50OiBQb2ludEl0ZW1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBIVE1MIERPTSBmb3IgdGhlIEl0ZW1TZXRcbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZnJhbWUuY2xhc3NOYW1lID0gJ3Zpcy1pdGVtc2V0JztcbiAgICBmcmFtZVsndGltZWxpbmUtaXRlbXNldCddID0gdGhpcztcbiAgICB0aGlzLmRvbS5mcmFtZSA9IGZyYW1lO1xuXG4gICAgLy8gY3JlYXRlIGJhY2tncm91bmQgcGFuZWxcbiAgICB2YXIgYmFja2dyb3VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGJhY2tncm91bmQuY2xhc3NOYW1lID0gJ3Zpcy1iYWNrZ3JvdW5kJztcbiAgICBmcmFtZS5hcHBlbmRDaGlsZChiYWNrZ3JvdW5kKTtcbiAgICB0aGlzLmRvbS5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZDtcblxuICAgIC8vIGNyZWF0ZSBmb3JlZ3JvdW5kIHBhbmVsXG4gICAgdmFyIGZvcmVncm91bmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBmb3JlZ3JvdW5kLmNsYXNzTmFtZSA9ICd2aXMtZm9yZWdyb3VuZCc7XG4gICAgZnJhbWUuYXBwZW5kQ2hpbGQoZm9yZWdyb3VuZCk7XG4gICAgdGhpcy5kb20uZm9yZWdyb3VuZCA9IGZvcmVncm91bmQ7XG5cbiAgICAvLyBjcmVhdGUgYXhpcyBwYW5lbFxuICAgIHZhciBheGlzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgYXhpcy5jbGFzc05hbWUgPSAndmlzLWF4aXMnO1xuICAgIHRoaXMuZG9tLmF4aXMgPSBheGlzO1xuXG4gICAgLy8gY3JlYXRlIGxhYmVsc2V0XG4gICAgdmFyIGxhYmVsU2V0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgbGFiZWxTZXQuY2xhc3NOYW1lID0gJ3Zpcy1sYWJlbHNldCc7XG4gICAgdGhpcy5kb20ubGFiZWxTZXQgPSBsYWJlbFNldDtcblxuICAgIC8vIGNyZWF0ZSB1bmdyb3VwZWQgR3JvdXBcbiAgICB0aGlzLl91cGRhdGVVbmdyb3VwZWQoKTtcblxuICAgIC8vIGNyZWF0ZSBiYWNrZ3JvdW5kIEdyb3VwXG4gICAgdmFyIGJhY2tncm91bmRHcm91cCA9IG5ldyBCYWNrZ3JvdW5kR3JvdXAoQkFDS0dST1VORCwgbnVsbCwgdGhpcyk7XG4gICAgYmFja2dyb3VuZEdyb3VwLnNob3coKTtcbiAgICB0aGlzLmdyb3Vwc1tCQUNLR1JPVU5EXSA9IGJhY2tncm91bmRHcm91cDtcblxuICAgIC8vIGF0dGFjaCBldmVudCBsaXN0ZW5lcnNcbiAgICAvLyBOb3RlOiB3ZSBiaW5kIHRvIHRoZSBjZW50ZXJDb250YWluZXIgZm9yIHRoZSBjYXNlIHdoZXJlIHRoZSBoZWlnaHRcbiAgICAvLyAgICAgICBvZiB0aGUgY2VudGVyIGNvbnRhaW5lciBpcyBsYXJnZXIgdGhhbiBvZiB0aGUgSXRlbVNldCwgc28gd2VcbiAgICAvLyAgICAgICBjYW4gY2xpY2sgaW4gdGhlIGVtcHR5IGFyZWEgdG8gY3JlYXRlIGEgbmV3IGl0ZW0gb3IgZGVzZWxlY3QgYW4gaXRlbS5cbiAgICB0aGlzLmhhbW1lciA9IG5ldyBIYW1tZXIodGhpcy5ib2R5LmRvbS5jZW50ZXJDb250YWluZXIpO1xuXG4gICAgLy8gZHJhZyBpdGVtcyB3aGVuIHNlbGVjdGVkXG4gICAgdGhpcy5oYW1tZXIub24oJ2hhbW1lci5pbnB1dCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKGV2ZW50LmlzRmlyc3QpIHtcbiAgICAgICAgdGhpcy5fb25Ub3VjaChldmVudCk7XG4gICAgICB9XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmhhbW1lci5vbigncGFuc3RhcnQnLCB0aGlzLl9vbkRyYWdTdGFydC5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmhhbW1lci5vbigncGFubW92ZScsIHRoaXMuX29uRHJhZy5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmhhbW1lci5vbigncGFuZW5kJywgdGhpcy5fb25EcmFnRW5kLmJpbmQodGhpcykpO1xuICAgIHRoaXMuaGFtbWVyLmdldCgncGFuJykuc2V0KHsgdGhyZXNob2xkOiA1LCBkaXJlY3Rpb246IEhhbW1lci5ESVJFQ1RJT05fSE9SSVpPTlRBTCB9KTtcblxuICAgIC8vIHNpbmdsZSBzZWxlY3QgKG9yIHVuc2VsZWN0KSB3aGVuIHRhcHBpbmcgYW4gaXRlbVxuICAgIHRoaXMuaGFtbWVyLm9uKCd0YXAnLCB0aGlzLl9vblNlbGVjdEl0ZW0uYmluZCh0aGlzKSk7XG5cbiAgICAvLyBtdWx0aSBzZWxlY3Qgd2hlbiBob2xkaW5nIG1vdXNlL3RvdWNoLCBvciBvbiBjdHJsK2NsaWNrXG4gICAgdGhpcy5oYW1tZXIub24oJ3ByZXNzJywgdGhpcy5fb25NdWx0aVNlbGVjdEl0ZW0uYmluZCh0aGlzKSk7XG5cbiAgICAvLyBhZGQgaXRlbSBvbiBkb3VibGV0YXBcbiAgICB0aGlzLmhhbW1lci5vbignZG91YmxldGFwJywgdGhpcy5fb25BZGRJdGVtLmJpbmQodGhpcykpO1xuICAgIHRoaXMuZ3JvdXBIYW1tZXIgPSBuZXcgSGFtbWVyKHRoaXMuYm9keS5kb20ubGVmdENvbnRhaW5lcik7XG5cbiAgICB0aGlzLmdyb3VwSGFtbWVyLm9uKCdwYW5zdGFydCcsIHRoaXMuX29uR3JvdXBEcmFnU3RhcnQuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5ncm91cEhhbW1lci5vbigncGFubW92ZScsIHRoaXMuX29uR3JvdXBEcmFnLmJpbmQodGhpcykpO1xuICAgIHRoaXMuZ3JvdXBIYW1tZXIub24oJ3BhbmVuZCcsIHRoaXMuX29uR3JvdXBEcmFnRW5kLmJpbmQodGhpcykpO1xuICAgIHRoaXMuZ3JvdXBIYW1tZXIuZ2V0KCdwYW4nKS5zZXQoeyB0aHJlc2hvbGQ6IDUsIGRpcmVjdGlvbjogSGFtbWVyLkRJUkVDVElPTl9IT1JJWk9OVEFMIH0pO1xuXG4gICAgLy8gYXR0YWNoIHRvIHRoZSBET01cbiAgICB0aGlzLnNob3coKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IG9wdGlvbnMgZm9yIHRoZSBJdGVtU2V0LiBFeGlzdGluZyBvcHRpb25zIHdpbGwgYmUgZXh0ZW5kZWQvb3ZlcndyaXR0ZW4uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIGZvbGxvd2luZyBvcHRpb25zIGFyZSBhdmFpbGFibGU6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZ30gdHlwZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgdHlwZSBmb3IgdGhlIGl0ZW1zLiBDaG9vc2UgZnJvbSAnYm94J1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkZWZhdWx0KSwgJ3BvaW50JywgJ3JhbmdlJywgb3IgJ2JhY2tncm91bmQnLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBkZWZhdWx0IHN0eWxlIGNhbiBiZSBvdmVyd3JpdHRlbiBieVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGl2aWR1YWwgaXRlbXMuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZ30gYWxpZ25cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbGlnbm1lbnQgZm9yIHRoZSBpdGVtcywgb25seSBhcHBsaWNhYmxlIGZvclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJveEl0ZW0uIENob29zZSAnY2VudGVyJyAoZGVmYXVsdCksICdsZWZ0Jywgb3JcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncmlnaHQnLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmd9IG9yaWVudGF0aW9uLml0ZW1cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPcmllbnRhdGlvbiBvZiB0aGUgaXRlbSBzZXQuIENob29zZSAndG9wJyBvclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdib3R0b20nIChkZWZhdWx0KS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB7RnVuY3Rpb259IGdyb3VwT3JkZXJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBIHNvcnRpbmcgZnVuY3Rpb24gZm9yIG9yZGVyaW5nIGdyb3Vwc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtCb29sZWFufSBzdGFja1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHRydWUgKGRlZmF1bHQpLCBpdGVtcyB3aWxsIGJlIHN0YWNrZWQgb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3Agb2YgZWFjaCBvdGhlci5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyfSBtYXJnaW4uYXhpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hcmdpbiBiZXR3ZWVuIHRoZSBheGlzIGFuZCB0aGUgaXRlbXMgaW4gcGl4ZWxzLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgaXMgMjAuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAge051bWJlcn0gbWFyZ2luLml0ZW0uaG9yaXpvbnRhbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEhvcml6b250YWwgbWFyZ2luIGJldHdlZW4gaXRlbXMgaW4gcGl4ZWxzLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgaXMgMTAuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAge051bWJlcn0gbWFyZ2luLml0ZW0udmVydGljYWxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWZXJ0aWNhbCBNYXJnaW4gYmV0d2VlbiBpdGVtcyBpbiBwaXhlbHMuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCBpcyAxMC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyfSBtYXJnaW4uaXRlbVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hcmdpbiBiZXR3ZWVuIGl0ZW1zIGluIHBpeGVscyBpbiBib3RoIGhvcml6b250YWxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgdmVydGljYWwgZGlyZWN0aW9uLiBEZWZhdWx0IGlzIDEwLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtOdW1iZXJ9IG1hcmdpblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNldCBtYXJnaW4gZm9yIGJvdGggYXhpcyBhbmQgaXRlbXMgaW4gcGl4ZWxzLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtCb29sZWFufSBzZWxlY3RhYmxlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgdHJ1ZSAoZGVmYXVsdCksIGl0ZW1zIGNhbiBiZSBzZWxlY3RlZC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB7Qm9vbGVhbn0gbXVsdGlzZWxlY3RcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiB0cnVlLCBtdWx0aXBsZSBpdGVtcyBjYW4gYmUgc2VsZWN0ZWQuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRmFsc2UgYnkgZGVmYXVsdC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB7Qm9vbGVhbn0gZWRpdGFibGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXQgYWxsIGVkaXRhYmxlIG9wdGlvbnMgdG8gdHJ1ZSBvciBmYWxzZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtCb29sZWFufSBlZGl0YWJsZS51cGRhdGVUaW1lXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQWxsb3cgZHJhZ2dpbmcgYW4gaXRlbSB0byBhbiBvdGhlciBtb21lbnQgaW4gdGltZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtCb29sZWFufSBlZGl0YWJsZS51cGRhdGVHcm91cFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFsbG93IGRyYWdnaW5nIGFuIGl0ZW0gdG8gYW4gb3RoZXIgZ3JvdXBcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB7Qm9vbGVhbn0gZWRpdGFibGUuYWRkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQWxsb3cgY3JlYXRpbmcgbmV3IGl0ZW1zIG9uIGRvdWJsZSB0YXBcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB7Qm9vbGVhbn0gZWRpdGFibGUucmVtb3ZlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQWxsb3cgcmVtb3ZpbmcgaXRlbXMgYnkgY2xpY2tpbmcgdGhlIGRlbGV0ZSBidXR0b25cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3AgcmlnaHQgb2YgYSBzZWxlY3RlZCBpdGVtLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtGdW5jdGlvbihpdGVtOiBJdGVtLCBjYWxsYmFjazogRnVuY3Rpb24pfSBvbkFkZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENhbGxiYWNrIGZ1bmN0aW9uIHRyaWdnZXJlZCB3aGVuIGFuIGl0ZW0gaXMgYWJvdXQgdG8gYmUgYWRkZWQ6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlbiB0aGUgdXNlciBkb3VibGUgdGFwcyBhbiBlbXB0eSBzcGFjZSBpbiB0aGUgVGltZWxpbmUuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAge0Z1bmN0aW9uKGl0ZW06IEl0ZW0sIGNhbGxiYWNrOiBGdW5jdGlvbil9IG9uVXBkYXRlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2FsbGJhY2sgZnVuY3Rpb24gZmlyZWQgd2hlbiBhbiBpdGVtIGlzIGFib3V0IHRvIGJlIHVwZGF0ZWQuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhpcyBmdW5jdGlvbiB0eXBpY2FsbHkgaGFzIHRvIHNob3cgYSBkaWFsb2cgd2hlcmUgdGhlIHVzZXJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2UgdGhlIGl0ZW0uIElmIG5vdCBpbXBsZW1lbnRlZCwgbm90aGluZyBoYXBwZW5zLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtGdW5jdGlvbihpdGVtOiBJdGVtLCBjYWxsYmFjazogRnVuY3Rpb24pfSBvbk1vdmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGaXJlZCB3aGVuIGFuIGl0ZW0gaGFzIGJlZW4gbW92ZWQuIElmIG5vdCBpbXBsZW1lbnRlZCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgbW92ZSBhY3Rpb24gd2lsbCBiZSBhY2NlcHRlZC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB7RnVuY3Rpb24oaXRlbTogSXRlbSwgY2FsbGJhY2s6IEZ1bmN0aW9uKX0gb25SZW1vdmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGaXJlZCB3aGVuIGFuIGl0ZW0gaXMgYWJvdXQgdG8gYmUgZGVsZXRlZC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBub3QgaW1wbGVtZW50ZWQsIHRoZSBpdGVtIHdpbGwgYmUgYWx3YXlzIHJlbW92ZWQuXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgLy8gY29weSBhbGwgb3B0aW9ucyB0aGF0IHdlIGtub3dcbiAgICAgIHZhciBmaWVsZHMgPSBbJ3R5cGUnLCAncnRsJywgJ2FsaWduJywgJ29yZGVyJywgJ3N0YWNrJywgJ3NlbGVjdGFibGUnLCAnbXVsdGlzZWxlY3QnLCAnaXRlbXNBbHdheXNEcmFnZ2FibGUnLCAnbXVsdGlzZWxlY3RQZXJHcm91cCcsICdncm91cE9yZGVyJywgJ2RhdGFBdHRyaWJ1dGVzJywgJ3RlbXBsYXRlJywgJ2dyb3VwVGVtcGxhdGUnLCAnaGlkZScsICdzbmFwJywgJ2dyb3VwT3JkZXJTd2FwJ107XG4gICAgICB1dGlsLnNlbGVjdGl2ZUV4dGVuZChmaWVsZHMsIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgIGlmICgnb3JpZW50YXRpb24nIGluIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm9yaWVudGF0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5pdGVtID0gb3B0aW9ucy5vcmllbnRhdGlvbiA9PT0gJ3RvcCcgPyAndG9wJyA6ICdib3R0b20nO1xuICAgICAgICB9IGVsc2UgaWYgKF90eXBlb2Yob3B0aW9ucy5vcmllbnRhdGlvbikgPT09ICdvYmplY3QnICYmICdpdGVtJyBpbiBvcHRpb25zLm9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uLml0ZW0gPSBvcHRpb25zLm9yaWVudGF0aW9uLml0ZW07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCdtYXJnaW4nIGluIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm1hcmdpbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMubWFyZ2luLmF4aXMgPSBvcHRpb25zLm1hcmdpbjtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMubWFyZ2luLml0ZW0uaG9yaXpvbnRhbCA9IG9wdGlvbnMubWFyZ2luO1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5tYXJnaW4uaXRlbS52ZXJ0aWNhbCA9IG9wdGlvbnMubWFyZ2luO1xuICAgICAgICB9IGVsc2UgaWYgKF90eXBlb2Yob3B0aW9ucy5tYXJnaW4pID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHV0aWwuc2VsZWN0aXZlRXh0ZW5kKFsnYXhpcyddLCB0aGlzLm9wdGlvbnMubWFyZ2luLCBvcHRpb25zLm1hcmdpbik7XG4gICAgICAgICAgaWYgKCdpdGVtJyBpbiBvcHRpb25zLm1hcmdpbikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm1hcmdpbi5pdGVtID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMubWFyZ2luLml0ZW0uaG9yaXpvbnRhbCA9IG9wdGlvbnMubWFyZ2luLml0ZW07XG4gICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5tYXJnaW4uaXRlbS52ZXJ0aWNhbCA9IG9wdGlvbnMubWFyZ2luLml0ZW07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKF90eXBlb2Yob3B0aW9ucy5tYXJnaW4uaXRlbSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgIHV0aWwuc2VsZWN0aXZlRXh0ZW5kKFsnaG9yaXpvbnRhbCcsICd2ZXJ0aWNhbCddLCB0aGlzLm9wdGlvbnMubWFyZ2luLml0ZW0sIG9wdGlvbnMubWFyZ2luLml0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoJ2VkaXRhYmxlJyBpbiBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5lZGl0YWJsZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmVkaXRhYmxlLnVwZGF0ZVRpbWUgPSBvcHRpb25zLmVkaXRhYmxlO1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5lZGl0YWJsZS51cGRhdGVHcm91cCA9IG9wdGlvbnMuZWRpdGFibGU7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmVkaXRhYmxlLmFkZCA9IG9wdGlvbnMuZWRpdGFibGU7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmVkaXRhYmxlLnJlbW92ZSA9IG9wdGlvbnMuZWRpdGFibGU7XG4gICAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihvcHRpb25zLmVkaXRhYmxlKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB1dGlsLnNlbGVjdGl2ZUV4dGVuZChbJ3VwZGF0ZVRpbWUnLCAndXBkYXRlR3JvdXAnLCAnYWRkJywgJ3JlbW92ZSddLCB0aGlzLm9wdGlvbnMuZWRpdGFibGUsIG9wdGlvbnMuZWRpdGFibGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICgnZ3JvdXBFZGl0YWJsZScgaW4gb3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZ3JvdXBFZGl0YWJsZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmdyb3VwRWRpdGFibGUub3JkZXIgPSBvcHRpb25zLmdyb3VwRWRpdGFibGU7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmdyb3VwRWRpdGFibGUuYWRkID0gb3B0aW9ucy5ncm91cEVkaXRhYmxlO1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5ncm91cEVkaXRhYmxlLnJlbW92ZSA9IG9wdGlvbnMuZ3JvdXBFZGl0YWJsZTtcbiAgICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKG9wdGlvbnMuZ3JvdXBFZGl0YWJsZSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdXRpbC5zZWxlY3RpdmVFeHRlbmQoWydvcmRlcicsICdhZGQnLCAncmVtb3ZlJ10sIHRoaXMub3B0aW9ucy5ncm91cEVkaXRhYmxlLCBvcHRpb25zLmdyb3VwRWRpdGFibGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGNhbGxiYWNrIGZ1bmN0aW9uc1xuICAgICAgdmFyIGFkZENhbGxiYWNrID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIGZuID0gb3B0aW9uc1tuYW1lXTtcbiAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgaWYgKCEoZm4gaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9uICcgKyBuYW1lICsgJyBtdXN0IGJlIGEgZnVuY3Rpb24gJyArIG5hbWUgKyAnKGl0ZW0sIGNhbGxiYWNrKScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm9wdGlvbnNbbmFtZV0gPSBmbjtcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpO1xuICAgICAgWydvbkFkZCcsICdvblVwZGF0ZScsICdvblJlbW92ZScsICdvbk1vdmUnLCAnb25Nb3ZpbmcnLCAnb25BZGRHcm91cCcsICdvbk1vdmVHcm91cCcsICdvblJlbW92ZUdyb3VwJ10uZm9yRWFjaChhZGRDYWxsYmFjayk7XG5cbiAgICAgIC8vIGZvcmNlIHRoZSBpdGVtU2V0IHRvIHJlZnJlc2g6IG9wdGlvbnMgbGlrZSBvcmllbnRhdGlvbiBhbmQgbWFyZ2lucyBtYXkgYmUgY2hhbmdlZFxuICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIE1hcmsgdGhlIEl0ZW1TZXQgZGlydHkgc28gaXQgd2lsbCByZWZyZXNoIGV2ZXJ5dGhpbmcgd2l0aCBuZXh0IHJlZHJhdy5cbiAgICogT3B0aW9uYWxseSwgYWxsIGl0ZW1zIGNhbiBiZSBtYXJrZWQgYXMgZGlydHkgYW5kIGJlIHJlZnJlc2hlZC5cbiAgICogQHBhcmFtIHt7cmVmcmVzaEl0ZW1zOiBib29sZWFufX0gW29wdGlvbnNdXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5tYXJrRGlydHkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHRoaXMuZ3JvdXBJZHMgPSBbXTtcbiAgICB0aGlzLnN0YWNrRGlydHkgPSB0cnVlO1xuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWZyZXNoSXRlbXMpIHtcbiAgICAgIHV0aWwuZm9yRWFjaCh0aGlzLml0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpdGVtLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgaWYgKGl0ZW0uZGlzcGxheWVkKSBpdGVtLnJlZHJhdygpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBEZXN0cm95IHRoZSBJdGVtU2V0XG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaGlkZSgpO1xuICAgIHRoaXMuc2V0SXRlbXMobnVsbCk7XG4gICAgdGhpcy5zZXRHcm91cHMobnVsbCk7XG5cbiAgICB0aGlzLmhhbW1lciA9IG51bGw7XG5cbiAgICB0aGlzLmJvZHkgPSBudWxsO1xuICAgIHRoaXMuY29udmVyc2lvbiA9IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhpZGUgdGhlIGNvbXBvbmVudCBmcm9tIHRoZSBET01cbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gcmVtb3ZlIHRoZSBmcmFtZSBjb250YWluaW5nIHRoZSBpdGVtc1xuICAgIGlmICh0aGlzLmRvbS5mcmFtZS5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLmRvbS5mcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLmZyYW1lKTtcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgdGhlIGF4aXMgd2l0aCBkb3RzXG4gICAgaWYgKHRoaXMuZG9tLmF4aXMucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5kb20uYXhpcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLmF4aXMpO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSB0aGUgbGFiZWxzZXQgY29udGFpbmluZyBhbGwgZ3JvdXAgbGFiZWxzXG4gICAgaWYgKHRoaXMuZG9tLmxhYmVsU2V0LnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuZG9tLmxhYmVsU2V0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20ubGFiZWxTZXQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2hvdyB0aGUgY29tcG9uZW50IGluIHRoZSBET00gKHdoZW4gbm90IGFscmVhZHkgdmlzaWJsZSkuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGNoYW5nZWRcbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gc2hvdyBmcmFtZSBjb250YWluaW5nIHRoZSBpdGVtc1xuICAgIGlmICghdGhpcy5kb20uZnJhbWUucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5ib2R5LmRvbS5jZW50ZXIuYXBwZW5kQ2hpbGQodGhpcy5kb20uZnJhbWUpO1xuICAgIH1cblxuICAgIC8vIHNob3cgYXhpcyB3aXRoIGRvdHNcbiAgICBpZiAoIXRoaXMuZG9tLmF4aXMucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5ib2R5LmRvbS5iYWNrZ3JvdW5kVmVydGljYWwuYXBwZW5kQ2hpbGQodGhpcy5kb20uYXhpcyk7XG4gICAgfVxuXG4gICAgLy8gc2hvdyBsYWJlbHNldCBjb250YWluaW5nIGxhYmVsc1xuICAgIGlmICghdGhpcy5kb20ubGFiZWxTZXQucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5ib2R5LmRvbS5sZWZ0LmFwcGVuZENoaWxkKHRoaXMuZG9tLmxhYmVsU2V0KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBzZWxlY3RlZCBpdGVtcyBieSB0aGVpciBpZC4gUmVwbGFjZXMgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG4gICAqIFVua25vd24gaWQncyBhcmUgc2lsZW50bHkgaWdub3JlZC5cbiAgICogQHBhcmFtIHtzdHJpbmdbXSB8IHN0cmluZ30gW2lkc10gQW4gYXJyYXkgd2l0aCB6ZXJvIG9yIG1vcmUgaWQncyBvZiB0aGUgaXRlbXMgdG8gYmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQsIG9yIGEgc2luZ2xlIGl0ZW0gaWQuIElmIGlkcyBpcyB1bmRlZmluZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3IgYW4gZW1wdHkgYXJyYXksIGFsbCBpdGVtcyB3aWxsIGJlIHVuc2VsZWN0ZWQuXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5zZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoaWRzKSB7XG4gICAgdmFyIGksIGlpLCBpZCwgaXRlbTtcblxuICAgIGlmIChpZHMgPT0gdW5kZWZpbmVkKSBpZHMgPSBbXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaWRzKSkgaWRzID0gW2lkc107XG5cbiAgICAvLyB1bnNlbGVjdCBjdXJyZW50bHkgc2VsZWN0ZWQgaXRlbXNcbiAgICBmb3IgKGkgPSAwLCBpaSA9IHRoaXMuc2VsZWN0aW9uLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGlkID0gdGhpcy5zZWxlY3Rpb25baV07XG4gICAgICBpdGVtID0gdGhpcy5pdGVtc1tpZF07XG4gICAgICBpZiAoaXRlbSkgaXRlbS51bnNlbGVjdCgpO1xuICAgIH1cblxuICAgIC8vIHNlbGVjdCBpdGVtc1xuICAgIHRoaXMuc2VsZWN0aW9uID0gW107XG4gICAgZm9yIChpID0gMCwgaWkgPSBpZHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgaWQgPSBpZHNbaV07XG4gICAgICBpdGVtID0gdGhpcy5pdGVtc1tpZF07XG4gICAgICBpZiAoaXRlbSkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbi5wdXNoKGlkKTtcbiAgICAgICAgaXRlbS5zZWxlY3QoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2VsZWN0ZWQgaXRlbXMgYnkgdGhlaXIgaWRcbiAgICogQHJldHVybiB7QXJyYXl9IGlkcyAgVGhlIGlkcyBvZiB0aGUgc2VsZWN0ZWQgaXRlbXNcbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24uY29uY2F0KFtdKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBpZCdzIG9mIHRoZSBjdXJyZW50bHkgdmlzaWJsZSBpdGVtcy5cbiAgICogQHJldHVybnMge0FycmF5fSBUaGUgaWRzIG9mIHRoZSB2aXNpYmxlIGl0ZW1zXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5nZXRWaXNpYmxlSXRlbXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJhbmdlID0gdGhpcy5ib2R5LnJhbmdlLmdldFJhbmdlKCk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5ib2R5LnV0aWwudG9TY3JlZW4ocmFuZ2Uuc3RhcnQpO1xuICAgICAgdmFyIGxlZnQgPSB0aGlzLmJvZHkudXRpbC50b1NjcmVlbihyYW5nZS5lbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbGVmdCA9IHRoaXMuYm9keS51dGlsLnRvU2NyZWVuKHJhbmdlLnN0YXJ0KTtcbiAgICAgIHZhciByaWdodCA9IHRoaXMuYm9keS51dGlsLnRvU2NyZWVuKHJhbmdlLmVuZCk7XG4gICAgfVxuXG4gICAgdmFyIGlkcyA9IFtdO1xuICAgIGZvciAodmFyIGdyb3VwSWQgaW4gdGhpcy5ncm91cHMpIHtcbiAgICAgIGlmICh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShncm91cElkKSkge1xuICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3Vwc1tncm91cElkXTtcbiAgICAgICAgdmFyIHJhd1Zpc2libGVJdGVtcyA9IGdyb3VwLnZpc2libGVJdGVtcztcblxuICAgICAgICAvLyBmaWx0ZXIgdGhlIFwicmF3XCIgc2V0IHdpdGggdmlzaWJsZUl0ZW1zIGludG8gYSBzZXQgd2hpY2ggaXMgcmVhbGx5XG4gICAgICAgIC8vIHZpc2libGUgYnkgcGl4ZWxzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3VmlzaWJsZUl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSByYXdWaXNpYmxlSXRlbXNbaV07XG4gICAgICAgICAgLy8gVE9ETzogYWxzbyBjaGVjayB3aGV0aGVyIHZpc2libGUgdmVydGljYWxseVxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucnRsKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5yaWdodCA8IGxlZnQgJiYgaXRlbS5yaWdodCArIGl0ZW0ud2lkdGggPiByaWdodCkge1xuICAgICAgICAgICAgICBpZHMucHVzaChpdGVtLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGl0ZW0ubGVmdCA8IHJpZ2h0ICYmIGl0ZW0ubGVmdCArIGl0ZW0ud2lkdGggPiBsZWZ0KSB7XG4gICAgICAgICAgICAgIGlkcy5wdXNoKGl0ZW0uaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpZHM7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlc2VsZWN0IGEgc2VsZWN0ZWQgaXRlbVxuICAgKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlcn0gaWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLl9kZXNlbGVjdCA9IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbjtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBzZWxlY3Rpb24ubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgaWYgKHNlbGVjdGlvbltpXSA9PSBpZCkge1xuICAgICAgICAvLyBub24tc3RyaWN0IGNvbXBhcmlzb24hXG4gICAgICAgIHNlbGVjdGlvbi5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVwYWludCB0aGUgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgY29tcG9uZW50IGlzIHJlc2l6ZWRcbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbWFyZ2luID0gdGhpcy5vcHRpb25zLm1hcmdpbixcbiAgICAgICAgcmFuZ2UgPSB0aGlzLmJvZHkucmFuZ2UsXG4gICAgICAgIGFzU2l6ZSA9IHV0aWwub3B0aW9uLmFzU2l6ZSxcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgb3JpZW50YXRpb24gPSBvcHRpb25zLm9yaWVudGF0aW9uLml0ZW0sXG4gICAgICAgIHJlc2l6ZWQgPSBmYWxzZSxcbiAgICAgICAgZnJhbWUgPSB0aGlzLmRvbS5mcmFtZTtcblxuICAgIC8vIHJlY2FsY3VsYXRlIGFic29sdXRlIHBvc2l0aW9uIChiZWZvcmUgcmVkcmF3aW5nIGdyb3VwcylcbiAgICB0aGlzLnByb3BzLnRvcCA9IHRoaXMuYm9keS5kb21Qcm9wcy50b3AuaGVpZ2h0ICsgdGhpcy5ib2R5LmRvbVByb3BzLmJvcmRlci50b3A7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgdGhpcy5wcm9wcy5yaWdodCA9IHRoaXMuYm9keS5kb21Qcm9wcy5yaWdodC53aWR0aCArIHRoaXMuYm9keS5kb21Qcm9wcy5ib3JkZXIucmlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHJvcHMubGVmdCA9IHRoaXMuYm9keS5kb21Qcm9wcy5sZWZ0LndpZHRoICsgdGhpcy5ib2R5LmRvbVByb3BzLmJvcmRlci5sZWZ0O1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBjbGFzcyBuYW1lXG4gICAgZnJhbWUuY2xhc3NOYW1lID0gJ3Zpcy1pdGVtc2V0JztcblxuICAgIC8vIHJlb3JkZXIgdGhlIGdyb3VwcyAoaWYgbmVlZGVkKVxuICAgIHJlc2l6ZWQgPSB0aGlzLl9vcmRlckdyb3VwcygpIHx8IHJlc2l6ZWQ7XG5cbiAgICAvLyBjaGVjayB3aGV0aGVyIHpvb21lZCAoaW4gdGhhdCBjYXNlIHdlIG5lZWQgdG8gcmUtc3RhY2sgZXZlcnl0aGluZylcbiAgICAvLyBUT0RPOiB3b3VsZCBiZSBuaWNlciB0byBnZXQgdGhpcyBhcyBhIHRyaWdnZXIgZnJvbSBSYW5nZVxuICAgIHZhciB2aXNpYmxlSW50ZXJ2YWwgPSByYW5nZS5lbmQgLSByYW5nZS5zdGFydDtcbiAgICB2YXIgem9vbWVkID0gdmlzaWJsZUludGVydmFsICE9IHRoaXMubGFzdFZpc2libGVJbnRlcnZhbCB8fCB0aGlzLnByb3BzLndpZHRoICE9IHRoaXMucHJvcHMubGFzdFdpZHRoO1xuICAgIGlmICh6b29tZWQpIHRoaXMuc3RhY2tEaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5sYXN0VmlzaWJsZUludGVydmFsID0gdmlzaWJsZUludGVydmFsO1xuICAgIHRoaXMucHJvcHMubGFzdFdpZHRoID0gdGhpcy5wcm9wcy53aWR0aDtcblxuICAgIHZhciByZXN0YWNrID0gdGhpcy5zdGFja0RpcnR5O1xuICAgIHZhciBmaXJzdEdyb3VwID0gdGhpcy5fZmlyc3RHcm91cCgpO1xuICAgIHZhciBmaXJzdE1hcmdpbiA9IHtcbiAgICAgIGl0ZW06IG1hcmdpbi5pdGVtLFxuICAgICAgYXhpczogbWFyZ2luLmF4aXNcbiAgICB9O1xuICAgIHZhciBub25GaXJzdE1hcmdpbiA9IHtcbiAgICAgIGl0ZW06IG1hcmdpbi5pdGVtLFxuICAgICAgYXhpczogbWFyZ2luLml0ZW0udmVydGljYWwgLyAyXG4gICAgfTtcbiAgICB2YXIgaGVpZ2h0ID0gMDtcbiAgICB2YXIgbWluSGVpZ2h0ID0gbWFyZ2luLmF4aXMgKyBtYXJnaW4uaXRlbS52ZXJ0aWNhbDtcblxuICAgIC8vIHJlZHJhdyB0aGUgYmFja2dyb3VuZCBncm91cFxuICAgIHRoaXMuZ3JvdXBzW0JBQ0tHUk9VTkRdLnJlZHJhdyhyYW5nZSwgbm9uRmlyc3RNYXJnaW4sIHJlc3RhY2spO1xuXG4gICAgLy8gcmVkcmF3IGFsbCByZWd1bGFyIGdyb3Vwc1xuICAgIHV0aWwuZm9yRWFjaCh0aGlzLmdyb3VwcywgZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICB2YXIgZ3JvdXBNYXJnaW4gPSBncm91cCA9PSBmaXJzdEdyb3VwID8gZmlyc3RNYXJnaW4gOiBub25GaXJzdE1hcmdpbjtcbiAgICAgIHZhciBncm91cFJlc2l6ZWQgPSBncm91cC5yZWRyYXcocmFuZ2UsIGdyb3VwTWFyZ2luLCByZXN0YWNrKTtcbiAgICAgIHJlc2l6ZWQgPSBncm91cFJlc2l6ZWQgfHwgcmVzaXplZDtcbiAgICAgIGhlaWdodCArPSBncm91cC5oZWlnaHQ7XG4gICAgfSk7XG4gICAgaGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0LCBtaW5IZWlnaHQpO1xuICAgIHRoaXMuc3RhY2tEaXJ0eSA9IGZhbHNlO1xuXG4gICAgLy8gdXBkYXRlIGZyYW1lIGhlaWdodFxuICAgIGZyYW1lLnN0eWxlLmhlaWdodCA9IGFzU2l6ZShoZWlnaHQpO1xuXG4gICAgLy8gY2FsY3VsYXRlIGFjdHVhbCBzaXplXG4gICAgdGhpcy5wcm9wcy53aWR0aCA9IGZyYW1lLm9mZnNldFdpZHRoO1xuICAgIHRoaXMucHJvcHMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgLy8gcmVwb3NpdGlvbiBheGlzXG4gICAgdGhpcy5kb20uYXhpcy5zdHlsZS50b3AgPSBhc1NpemUob3JpZW50YXRpb24gPT0gJ3RvcCcgPyB0aGlzLmJvZHkuZG9tUHJvcHMudG9wLmhlaWdodCArIHRoaXMuYm9keS5kb21Qcm9wcy5ib3JkZXIudG9wIDogdGhpcy5ib2R5LmRvbVByb3BzLnRvcC5oZWlnaHQgKyB0aGlzLmJvZHkuZG9tUHJvcHMuY2VudGVyQ29udGFpbmVyLmhlaWdodCk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgIHRoaXMuZG9tLmF4aXMuc3R5bGUucmlnaHQgPSAnMCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZG9tLmF4aXMuc3R5bGUubGVmdCA9ICcwJztcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiB0aGlzIGNvbXBvbmVudCBpcyByZXNpemVkXG4gICAgcmVzaXplZCA9IHRoaXMuX2lzUmVzaXplZCgpIHx8IHJlc2l6ZWQ7XG5cbiAgICByZXR1cm4gcmVzaXplZDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBmaXJzdCBncm91cCwgYWxpZ25lZCB3aXRoIHRoZSBheGlzXG4gICAqIEByZXR1cm4ge0dyb3VwIHwgbnVsbH0gZmlyc3RHcm91cFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUuX2ZpcnN0R3JvdXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZpcnN0R3JvdXBJbmRleCA9IHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5pdGVtID09ICd0b3AnID8gMCA6IHRoaXMuZ3JvdXBJZHMubGVuZ3RoIC0gMTtcbiAgICB2YXIgZmlyc3RHcm91cElkID0gdGhpcy5ncm91cElkc1tmaXJzdEdyb3VwSW5kZXhdO1xuICAgIHZhciBmaXJzdEdyb3VwID0gdGhpcy5ncm91cHNbZmlyc3RHcm91cElkXSB8fCB0aGlzLmdyb3Vwc1tVTkdST1VQRURdO1xuXG4gICAgcmV0dXJuIGZpcnN0R3JvdXAgfHwgbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIG9yIGRlbGV0ZSB0aGUgZ3JvdXAgaG9sZGluZyBhbGwgdW5ncm91cGVkIGl0ZW1zLiBUaGlzIGdyb3VwIGlzIHVzZWQgd2hlblxuICAgKiB0aGVyZSBhcmUgbm8gZ3JvdXBzIHNwZWNpZmllZC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUuX3VwZGF0ZVVuZ3JvdXBlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdW5ncm91cGVkID0gdGhpcy5ncm91cHNbVU5HUk9VUEVEXTtcbiAgICB2YXIgYmFja2dyb3VuZCA9IHRoaXMuZ3JvdXBzW0JBQ0tHUk9VTkRdO1xuICAgIHZhciBpdGVtLCBpdGVtSWQ7XG5cbiAgICBpZiAodGhpcy5ncm91cHNEYXRhKSB7XG4gICAgICAvLyByZW1vdmUgdGhlIGdyb3VwIGhvbGRpbmcgYWxsIHVuZ3JvdXBlZCBpdGVtc1xuICAgICAgaWYgKHVuZ3JvdXBlZCkge1xuICAgICAgICB1bmdyb3VwZWQuaGlkZSgpO1xuICAgICAgICBkZWxldGUgdGhpcy5ncm91cHNbVU5HUk9VUEVEXTtcblxuICAgICAgICBmb3IgKGl0ZW1JZCBpbiB0aGlzLml0ZW1zKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaXRlbXMuaGFzT3duUHJvcGVydHkoaXRlbUlkKSkge1xuICAgICAgICAgICAgaXRlbSA9IHRoaXMuaXRlbXNbaXRlbUlkXTtcbiAgICAgICAgICAgIGl0ZW0ucGFyZW50ICYmIGl0ZW0ucGFyZW50LnJlbW92ZShpdGVtKTtcbiAgICAgICAgICAgIHZhciBncm91cElkID0gdGhpcy5fZ2V0R3JvdXBJZChpdGVtLmRhdGEpO1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cHNbZ3JvdXBJZF07XG4gICAgICAgICAgICBncm91cCAmJiBncm91cC5hZGQoaXRlbSkgfHwgaXRlbS5oaWRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNyZWF0ZSBhIGdyb3VwIGhvbGRpbmcgYWxsICh1bmZpbHRlcmVkKSBpdGVtc1xuICAgICAgaWYgKCF1bmdyb3VwZWQpIHtcbiAgICAgICAgdmFyIGlkID0gbnVsbDtcbiAgICAgICAgdmFyIGRhdGEgPSBudWxsO1xuICAgICAgICB1bmdyb3VwZWQgPSBuZXcgR3JvdXAoaWQsIGRhdGEsIHRoaXMpO1xuICAgICAgICB0aGlzLmdyb3Vwc1tVTkdST1VQRURdID0gdW5ncm91cGVkO1xuXG4gICAgICAgIGZvciAoaXRlbUlkIGluIHRoaXMuaXRlbXMpIHtcbiAgICAgICAgICBpZiAodGhpcy5pdGVtcy5oYXNPd25Qcm9wZXJ0eShpdGVtSWQpKSB7XG4gICAgICAgICAgICBpdGVtID0gdGhpcy5pdGVtc1tpdGVtSWRdO1xuICAgICAgICAgICAgdW5ncm91cGVkLmFkZChpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB1bmdyb3VwZWQuc2hvdygpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBlbGVtZW50IGZvciB0aGUgbGFiZWxzZXRcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9IGxhYmVsU2V0XG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5nZXRMYWJlbFNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5kb20ubGFiZWxTZXQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBpdGVtc1xuICAgKiBAcGFyYW0ge3Zpcy5EYXRhU2V0IHwgbnVsbH0gaXRlbXNcbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLnNldEl0ZW1zID0gZnVuY3Rpb24gKGl0ZW1zKSB7XG4gICAgdmFyIG1lID0gdGhpcyxcbiAgICAgICAgaWRzLFxuICAgICAgICBvbGRJdGVtc0RhdGEgPSB0aGlzLml0ZW1zRGF0YTtcblxuICAgIC8vIHJlcGxhY2UgdGhlIGRhdGFzZXRcbiAgICBpZiAoIWl0ZW1zKSB7XG4gICAgICB0aGlzLml0ZW1zRGF0YSA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChpdGVtcyBpbnN0YW5jZW9mIERhdGFTZXQgfHwgaXRlbXMgaW5zdGFuY2VvZiBEYXRhVmlldykge1xuICAgICAgdGhpcy5pdGVtc0RhdGEgPSBpdGVtcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRGF0YSBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIERhdGFTZXQgb3IgRGF0YVZpZXcnKTtcbiAgICB9XG5cbiAgICBpZiAob2xkSXRlbXNEYXRhKSB7XG4gICAgICAvLyB1bnN1YnNjcmliZSBmcm9tIG9sZCBkYXRhc2V0XG4gICAgICB1dGlsLmZvckVhY2godGhpcy5pdGVtTGlzdGVuZXJzLCBmdW5jdGlvbiAoY2FsbGJhY2ssIGV2ZW50KSB7XG4gICAgICAgIG9sZEl0ZW1zRGF0YS5vZmYoZXZlbnQsIGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyByZW1vdmUgYWxsIGRyYXduIGl0ZW1zXG4gICAgICBpZHMgPSBvbGRJdGVtc0RhdGEuZ2V0SWRzKCk7XG4gICAgICB0aGlzLl9vblJlbW92ZShpZHMpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLml0ZW1zRGF0YSkge1xuICAgICAgLy8gc3Vic2NyaWJlIHRvIG5ldyBkYXRhc2V0XG4gICAgICB2YXIgaWQgPSB0aGlzLmlkO1xuICAgICAgdXRpbC5mb3JFYWNoKHRoaXMuaXRlbUxpc3RlbmVycywgZnVuY3Rpb24gKGNhbGxiYWNrLCBldmVudCkge1xuICAgICAgICBtZS5pdGVtc0RhdGEub24oZXZlbnQsIGNhbGxiYWNrLCBpZCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gYWRkIGFsbCBuZXcgaXRlbXNcbiAgICAgIGlkcyA9IHRoaXMuaXRlbXNEYXRhLmdldElkcygpO1xuICAgICAgdGhpcy5fb25BZGQoaWRzKTtcblxuICAgICAgLy8gdXBkYXRlIHRoZSBncm91cCBob2xkaW5nIGFsbCB1bmdyb3VwZWQgaXRlbXNcbiAgICAgIHRoaXMuX3VwZGF0ZVVuZ3JvdXBlZCgpO1xuICAgIH1cblxuICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19jaGFuZ2UnLCB7IHF1ZXVlOiB0cnVlIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgaXRlbXNcbiAgICogQHJldHVybnMge3Zpcy5EYXRhU2V0IHwgbnVsbH1cbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLmdldEl0ZW1zID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLml0ZW1zRGF0YTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGdyb3Vwc1xuICAgKiBAcGFyYW0ge3Zpcy5EYXRhU2V0fSBncm91cHNcbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLnNldEdyb3VwcyA9IGZ1bmN0aW9uIChncm91cHMpIHtcbiAgICB2YXIgbWUgPSB0aGlzLFxuICAgICAgICBpZHM7XG5cbiAgICAvLyB1bnN1YnNjcmliZSBmcm9tIGN1cnJlbnQgZGF0YXNldFxuICAgIGlmICh0aGlzLmdyb3Vwc0RhdGEpIHtcbiAgICAgIHV0aWwuZm9yRWFjaCh0aGlzLmdyb3VwTGlzdGVuZXJzLCBmdW5jdGlvbiAoY2FsbGJhY2ssIGV2ZW50KSB7XG4gICAgICAgIG1lLmdyb3Vwc0RhdGEub2ZmKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgICB9KTtcblxuICAgICAgLy8gcmVtb3ZlIGFsbCBkcmF3biBncm91cHNcbiAgICAgIGlkcyA9IHRoaXMuZ3JvdXBzRGF0YS5nZXRJZHMoKTtcbiAgICAgIHRoaXMuZ3JvdXBzRGF0YSA9IG51bGw7XG4gICAgICB0aGlzLl9vblJlbW92ZUdyb3VwcyhpZHMpOyAvLyBub3RlOiB0aGlzIHdpbGwgY2F1c2UgYSByZWRyYXdcbiAgICB9XG5cbiAgICAvLyByZXBsYWNlIHRoZSBkYXRhc2V0XG4gICAgaWYgKCFncm91cHMpIHtcbiAgICAgIHRoaXMuZ3JvdXBzRGF0YSA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChncm91cHMgaW5zdGFuY2VvZiBEYXRhU2V0IHx8IGdyb3VwcyBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG4gICAgICB0aGlzLmdyb3Vwc0RhdGEgPSBncm91cHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0RhdGEgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBEYXRhU2V0IG9yIERhdGFWaWV3Jyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZ3JvdXBzRGF0YSkge1xuICAgICAgLy8gc3Vic2NyaWJlIHRvIG5ldyBkYXRhc2V0XG4gICAgICB2YXIgaWQgPSB0aGlzLmlkO1xuICAgICAgdXRpbC5mb3JFYWNoKHRoaXMuZ3JvdXBMaXN0ZW5lcnMsIGZ1bmN0aW9uIChjYWxsYmFjaywgZXZlbnQpIHtcbiAgICAgICAgbWUuZ3JvdXBzRGF0YS5vbihldmVudCwgY2FsbGJhY2ssIGlkKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBkcmF3IGFsbCBtc1xuICAgICAgaWRzID0gdGhpcy5ncm91cHNEYXRhLmdldElkcygpO1xuICAgICAgdGhpcy5fb25BZGRHcm91cHMoaWRzKTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgdGhlIGdyb3VwIGhvbGRpbmcgYWxsIHVuZ3JvdXBlZCBpdGVtc1xuICAgIHRoaXMuX3VwZGF0ZVVuZ3JvdXBlZCgpO1xuXG4gICAgLy8gdXBkYXRlIHRoZSBvcmRlciBvZiBhbGwgaXRlbXMgaW4gZWFjaCBncm91cFxuICAgIHRoaXMuX29yZGVyKCk7XG5cbiAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfY2hhbmdlJywgeyBxdWV1ZTogdHJ1ZSB9KTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IGdyb3Vwc1xuICAgKiBAcmV0dXJucyB7dmlzLkRhdGFTZXQgfCBudWxsfSBncm91cHNcbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLmdldEdyb3VwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5ncm91cHNEYXRhO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gaXRlbSBieSBpdHMgaWRcbiAgICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXJ9IGlkXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5yZW1vdmVJdGVtID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSB0aGlzLml0ZW1zRGF0YS5nZXQoaWQpLFxuICAgICAgICBkYXRhc2V0ID0gdGhpcy5pdGVtc0RhdGEuZ2V0RGF0YVNldCgpO1xuXG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIC8vIGNvbmZpcm0gZGVsZXRpb25cbiAgICAgIHRoaXMub3B0aW9ucy5vblJlbW92ZShpdGVtLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgIC8vIHJlbW92ZSBieSBpZCBoZXJlLCBpdCBpcyBwb3NzaWJsZSB0aGF0IGFuIGl0ZW0gaGFzIG5vIGlkIGRlZmluZWRcbiAgICAgICAgICAvLyBpdHNlbGYsIHNvIGJldHRlciBub3QgZGVsZXRlIGJ5IHRoZSBpdGVtIGl0c2VsZlxuICAgICAgICAgIGRhdGFzZXQucmVtb3ZlKGlkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRpbWUgb2YgYW4gaXRlbSBiYXNlZCBvbiBpdCdzIGRhdGEgYW5kIG9wdGlvbnMudHlwZVxuICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbURhdGFcbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHlwZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUuX2dldFR5cGUgPSBmdW5jdGlvbiAoaXRlbURhdGEpIHtcbiAgICByZXR1cm4gaXRlbURhdGEudHlwZSB8fCB0aGlzLm9wdGlvbnMudHlwZSB8fCAoaXRlbURhdGEuZW5kID8gJ3JhbmdlJyA6ICdib3gnKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBncm91cCBpZCBmb3IgYW4gaXRlbVxuICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbURhdGFcbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZ3JvdXBJZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUuX2dldEdyb3VwSWQgPSBmdW5jdGlvbiAoaXRlbURhdGEpIHtcbiAgICB2YXIgdHlwZSA9IHRoaXMuX2dldFR5cGUoaXRlbURhdGEpO1xuICAgIGlmICh0eXBlID09ICdiYWNrZ3JvdW5kJyAmJiBpdGVtRGF0YS5ncm91cCA9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBCQUNLR1JPVU5EO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5ncm91cHNEYXRhID8gaXRlbURhdGEuZ3JvdXAgOiBVTkdST1VQRUQ7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgdXBkYXRlZCBpdGVtc1xuICAgKiBAcGFyYW0ge051bWJlcltdfSBpZHNcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUuX29uVXBkYXRlID0gZnVuY3Rpb24gKGlkcykge1xuICAgIHZhciBtZSA9IHRoaXM7XG5cbiAgICBpZHMuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHZhciBpdGVtRGF0YSA9IG1lLml0ZW1zRGF0YS5nZXQoaWQsIG1lLml0ZW1PcHRpb25zKTtcbiAgICAgIHZhciBpdGVtID0gbWUuaXRlbXNbaWRdO1xuICAgICAgdmFyIHR5cGUgPSBtZS5fZ2V0VHlwZShpdGVtRGF0YSk7XG5cbiAgICAgIHZhciBjb25zdHJ1Y3RvciA9IEl0ZW1TZXQudHlwZXNbdHlwZV07XG4gICAgICB2YXIgc2VsZWN0ZWQ7XG5cbiAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgIC8vIHVwZGF0ZSBpdGVtXG4gICAgICAgIGlmICghY29uc3RydWN0b3IgfHwgIShpdGVtIGluc3RhbmNlb2YgY29uc3RydWN0b3IpKSB7XG4gICAgICAgICAgLy8gaXRlbSB0eXBlIGhhcyBjaGFuZ2VkLCBkZWxldGUgdGhlIGl0ZW0gYW5kIHJlY3JlYXRlIGl0XG4gICAgICAgICAgc2VsZWN0ZWQgPSBpdGVtLnNlbGVjdGVkOyAvLyBwcmVzZXJ2ZSBzZWxlY3Rpb24gb2YgdGhpcyBpdGVtXG4gICAgICAgICAgbWUuX3JlbW92ZUl0ZW0oaXRlbSk7XG4gICAgICAgICAgaXRlbSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWUuX3VwZGF0ZUl0ZW0oaXRlbSwgaXRlbURhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAvLyBjcmVhdGUgaXRlbVxuICAgICAgICBpZiAoY29uc3RydWN0b3IpIHtcbiAgICAgICAgICBpdGVtID0gbmV3IGNvbnN0cnVjdG9yKGl0ZW1EYXRhLCBtZS5jb252ZXJzaW9uLCBtZS5vcHRpb25zKTtcbiAgICAgICAgICBpdGVtLmlkID0gaWQ7IC8vIFRPRE86IG5vdCBzbyBuaWNlIHNldHRpbmcgaWQgYWZ0ZXJ3YXJkc1xuICAgICAgICAgIG1lLl9hZGRJdGVtKGl0ZW0pO1xuICAgICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24ucHVzaChpZCk7XG4gICAgICAgICAgICBpdGVtLnNlbGVjdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09ICdyYW5nZW92ZXJmbG93Jykge1xuICAgICAgICAgIC8vIFRPRE86IGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjEuMCAob3IgMy4wLjA/KS4gY2xlYW51cCBzb21lIGRheVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0l0ZW0gdHlwZSBcInJhbmdlb3ZlcmZsb3dcIiBpcyBkZXByZWNhdGVkLiBVc2UgY3NzIHN0eWxpbmcgaW5zdGVhZDogJyArICcudmlzLWl0ZW0udmlzLXJhbmdlIC52aXMtaXRlbS1jb250ZW50IHtvdmVyZmxvdzogdmlzaWJsZTt9Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBpdGVtIHR5cGUgXCInICsgdHlwZSArICdcIicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfS5iaW5kKHRoaXMpKTtcblxuICAgIHRoaXMuX29yZGVyKCk7XG4gICAgdGhpcy5zdGFja0RpcnR5ID0gdHJ1ZTsgLy8gZm9yY2UgcmUtc3RhY2tpbmcgb2YgYWxsIGl0ZW1zIG5leHQgcmVkcmF3XG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2NoYW5nZScsIHsgcXVldWU6IHRydWUgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhZGRlZCBpdGVtc1xuICAgKiBAcGFyYW0ge051bWJlcltdfSBpZHNcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUuX29uQWRkID0gSXRlbVNldC5wcm90b3R5cGUuX29uVXBkYXRlO1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgcmVtb3ZlZCBpdGVtc1xuICAgKiBAcGFyYW0ge051bWJlcltdfSBpZHNcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUuX29uUmVtb3ZlID0gZnVuY3Rpb24gKGlkcykge1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICBpZHMuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHZhciBpdGVtID0gbWUuaXRlbXNbaWRdO1xuICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgY291bnQrKztcbiAgICAgICAgbWUuX3JlbW92ZUl0ZW0oaXRlbSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoY291bnQpIHtcbiAgICAgIC8vIHVwZGF0ZSBvcmRlclxuICAgICAgdGhpcy5fb3JkZXIoKTtcbiAgICAgIHRoaXMuc3RhY2tEaXJ0eSA9IHRydWU7IC8vIGZvcmNlIHJlLXN0YWNraW5nIG9mIGFsbCBpdGVtcyBuZXh0IHJlZHJhd1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2NoYW5nZScsIHsgcXVldWU6IHRydWUgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIG9yZGVyIG9mIGl0ZW0gaW4gYWxsIGdyb3Vwc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUuX29yZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHJlb3JkZXIgdGhlIGl0ZW1zIGluIGFsbCBncm91cHNcbiAgICAvLyBUT0RPOiBvcHRpbWl6YXRpb246IG9ubHkgcmVvcmRlciBncm91cHMgYWZmZWN0ZWQgYnkgdGhlIGNoYW5nZWQgaXRlbXNcbiAgICB1dGlsLmZvckVhY2godGhpcy5ncm91cHMsIGZ1bmN0aW9uIChncm91cCkge1xuICAgICAgZ3JvdXAub3JkZXIoKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIHVwZGF0ZWQgZ3JvdXBzXG4gICAqIEBwYXJhbSB7TnVtYmVyW119IGlkc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUuX29uVXBkYXRlR3JvdXBzID0gZnVuY3Rpb24gKGlkcykge1xuICAgIHRoaXMuX29uQWRkR3JvdXBzKGlkcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBjaGFuZ2VkIGdyb3VwcyAoYWRkZWQgb3IgdXBkYXRlZClcbiAgICogQHBhcmFtIHtOdW1iZXJbXX0gaWRzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5fb25BZGRHcm91cHMgPSBmdW5jdGlvbiAoaWRzKSB7XG4gICAgdmFyIG1lID0gdGhpcztcblxuICAgIGlkcy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgdmFyIGdyb3VwRGF0YSA9IG1lLmdyb3Vwc0RhdGEuZ2V0KGlkKTtcbiAgICAgIHZhciBncm91cCA9IG1lLmdyb3Vwc1tpZF07XG5cbiAgICAgIGlmICghZ3JvdXApIHtcbiAgICAgICAgLy8gY2hlY2sgZm9yIHJlc2VydmVkIGlkc1xuICAgICAgICBpZiAoaWQgPT0gVU5HUk9VUEVEIHx8IGlkID09IEJBQ0tHUk9VTkQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgZ3JvdXAgaWQuICcgKyBpZCArICcgaXMgYSByZXNlcnZlZCBpZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBncm91cE9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG1lLm9wdGlvbnMpO1xuICAgICAgICB1dGlsLmV4dGVuZChncm91cE9wdGlvbnMsIHtcbiAgICAgICAgICBoZWlnaHQ6IG51bGxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZ3JvdXAgPSBuZXcgR3JvdXAoaWQsIGdyb3VwRGF0YSwgbWUpO1xuICAgICAgICBtZS5ncm91cHNbaWRdID0gZ3JvdXA7XG5cbiAgICAgICAgLy8gYWRkIGl0ZW1zIHdpdGggdGhpcyBncm91cElkIHRvIHRoZSBuZXcgZ3JvdXBcbiAgICAgICAgZm9yICh2YXIgaXRlbUlkIGluIG1lLml0ZW1zKSB7XG4gICAgICAgICAgaWYgKG1lLml0ZW1zLmhhc093blByb3BlcnR5KGl0ZW1JZCkpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gbWUuaXRlbXNbaXRlbUlkXTtcbiAgICAgICAgICAgIGlmIChpdGVtLmRhdGEuZ3JvdXAgPT0gaWQpIHtcbiAgICAgICAgICAgICAgZ3JvdXAuYWRkKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdyb3VwLm9yZGVyKCk7XG4gICAgICAgIGdyb3VwLnNob3coKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVwZGF0ZSBncm91cFxuICAgICAgICBncm91cC5zZXREYXRhKGdyb3VwRGF0YSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfY2hhbmdlJywgeyBxdWV1ZTogdHJ1ZSB9KTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIHJlbW92ZWQgZ3JvdXBzXG4gICAqIEBwYXJhbSB7TnVtYmVyW119IGlkc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUuX29uUmVtb3ZlR3JvdXBzID0gZnVuY3Rpb24gKGlkcykge1xuICAgIHZhciBncm91cHMgPSB0aGlzLmdyb3VwcztcbiAgICBpZHMuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHZhciBncm91cCA9IGdyb3Vwc1tpZF07XG5cbiAgICAgIGlmIChncm91cCkge1xuICAgICAgICBncm91cC5oaWRlKCk7XG4gICAgICAgIGRlbGV0ZSBncm91cHNbaWRdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5tYXJrRGlydHkoKTtcblxuICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19jaGFuZ2UnLCB7IHF1ZXVlOiB0cnVlIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW9yZGVyIHRoZSBncm91cHMgaWYgbmVlZGVkXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGNoYW5nZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLl9vcmRlckdyb3VwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5ncm91cHNEYXRhKSB7XG4gICAgICAvLyByZW9yZGVyIHRoZSBncm91cHNcbiAgICAgIHZhciBncm91cElkcyA9IHRoaXMuZ3JvdXBzRGF0YS5nZXRJZHMoe1xuICAgICAgICBvcmRlcjogdGhpcy5vcHRpb25zLmdyb3VwT3JkZXJcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgY2hhbmdlZCA9ICF1dGlsLmVxdWFsQXJyYXkoZ3JvdXBJZHMsIHRoaXMuZ3JvdXBJZHMpO1xuICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgLy8gaGlkZSBhbGwgZ3JvdXBzLCByZW1vdmVzIHRoZW0gZnJvbSB0aGUgRE9NXG4gICAgICAgIHZhciBncm91cHMgPSB0aGlzLmdyb3VwcztcbiAgICAgICAgZ3JvdXBJZHMuZm9yRWFjaChmdW5jdGlvbiAoZ3JvdXBJZCkge1xuICAgICAgICAgIGdyb3Vwc1tncm91cElkXS5oaWRlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHNob3cgdGhlIGdyb3VwcyBhZ2FpbiwgYXR0YWNoIHRoZW0gdG8gdGhlIERPTSBpbiBjb3JyZWN0IG9yZGVyXG4gICAgICAgIGdyb3VwSWRzLmZvckVhY2goZnVuY3Rpb24gKGdyb3VwSWQpIHtcbiAgICAgICAgICBncm91cHNbZ3JvdXBJZF0uc2hvdygpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmdyb3VwSWRzID0gZ3JvdXBJZHM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSBuZXcgaXRlbVxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLl9hZGRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICB0aGlzLml0ZW1zW2l0ZW0uaWRdID0gaXRlbTtcblxuICAgIC8vIGFkZCB0byBncm91cFxuICAgIHZhciBncm91cElkID0gdGhpcy5fZ2V0R3JvdXBJZChpdGVtLmRhdGEpO1xuICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXBzW2dyb3VwSWRdO1xuICAgIGlmIChncm91cCkgZ3JvdXAuYWRkKGl0ZW0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgYW4gZXhpc3RpbmcgaXRlbVxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1EYXRhXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5fdXBkYXRlSXRlbSA9IGZ1bmN0aW9uIChpdGVtLCBpdGVtRGF0YSkge1xuICAgIHZhciBvbGRHcm91cElkID0gaXRlbS5kYXRhLmdyb3VwO1xuICAgIHZhciBvbGRTdWJHcm91cElkID0gaXRlbS5kYXRhLnN1Ymdyb3VwO1xuXG4gICAgLy8gdXBkYXRlIHRoZSBpdGVtcyBkYXRhICh3aWxsIHJlZHJhdyB0aGUgaXRlbSB3aGVuIGRpc3BsYXllZClcbiAgICBpdGVtLnNldERhdGEoaXRlbURhdGEpO1xuXG4gICAgLy8gdXBkYXRlIGdyb3VwXG4gICAgaWYgKG9sZEdyb3VwSWQgIT0gaXRlbS5kYXRhLmdyb3VwIHx8IG9sZFN1Ykdyb3VwSWQgIT0gaXRlbS5kYXRhLnN1Ymdyb3VwKSB7XG4gICAgICB2YXIgb2xkR3JvdXAgPSB0aGlzLmdyb3Vwc1tvbGRHcm91cElkXTtcbiAgICAgIGlmIChvbGRHcm91cCkgb2xkR3JvdXAucmVtb3ZlKGl0ZW0pO1xuXG4gICAgICB2YXIgZ3JvdXBJZCA9IHRoaXMuX2dldEdyb3VwSWQoaXRlbS5kYXRhKTtcbiAgICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXBzW2dyb3VwSWRdO1xuICAgICAgaWYgKGdyb3VwKSBncm91cC5hZGQoaXRlbSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBEZWxldGUgYW4gaXRlbSBmcm9tIHRoZSBJdGVtU2V0OiByZW1vdmUgaXQgZnJvbSB0aGUgRE9NLCBmcm9tIHRoZSBtYXBcbiAgICogd2l0aCBpdGVtcywgYW5kIGZyb20gdGhlIG1hcCB3aXRoIHZpc2libGUgaXRlbXMsIGFuZCBmcm9tIHRoZSBzZWxlY3Rpb25cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5fcmVtb3ZlSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgLy8gcmVtb3ZlIGZyb20gRE9NXG4gICAgaXRlbS5oaWRlKCk7XG5cbiAgICAvLyByZW1vdmUgZnJvbSBpdGVtc1xuICAgIGRlbGV0ZSB0aGlzLml0ZW1zW2l0ZW0uaWRdO1xuXG4gICAgLy8gcmVtb3ZlIGZyb20gc2VsZWN0aW9uXG4gICAgdmFyIGluZGV4ID0gdGhpcy5zZWxlY3Rpb24uaW5kZXhPZihpdGVtLmlkKTtcbiAgICBpZiAoaW5kZXggIT0gLTEpIHRoaXMuc2VsZWN0aW9uLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAvLyByZW1vdmUgZnJvbSBncm91cFxuICAgIGl0ZW0ucGFyZW50ICYmIGl0ZW0ucGFyZW50LnJlbW92ZShpdGVtKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIGl0ZW1zIGJlaW5nIGEgcmFuZ2UgKGhhdmluZyBhbiBlbmQgZGF0ZSlcbiAgICogQHBhcmFtIGFycmF5XG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLl9jb25zdHJ1Y3RCeUVuZEFycmF5ID0gZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgdmFyIGVuZEFycmF5ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXJyYXlbaV0gaW5zdGFuY2VvZiBSYW5nZUl0ZW0pIHtcbiAgICAgICAgZW5kQXJyYXkucHVzaChhcnJheVtpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbmRBcnJheTtcbiAgfTtcblxuICAvKipcbiAgICogUmVnaXN0ZXIgdGhlIGNsaWNrZWQgaXRlbSBvbiB0b3VjaCwgYmVmb3JlIGRyYWdTdGFydCBpcyBpbml0aWF0ZWQuXG4gICAqXG4gICAqIGRyYWdTdGFydCBpcyBpbml0aWF0ZWQgZnJvbSBhIG1vdXNlbW92ZSBldmVudCwgQUZURVIgdGhlIG1vdXNlL3RvdWNoIGlzXG4gICAqIGFscmVhZHkgbW92aW5nLiBUaGVyZWZvcmUsIHRoZSBtb3VzZS90b3VjaCBjYW4gc29tZXRpbWVzIGJlIGFib3ZlIGFuIG90aGVyXG4gICAqIERPTSBlbGVtZW50IHRoYW4gdGhlIGl0ZW0gaXRzZWxmLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUuX29uVG91Y2ggPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBzdG9yZSB0aGUgdG91Y2hlZCBpdGVtLCB1c2VkIGluIF9vbkRyYWdTdGFydFxuICAgIHRoaXMudG91Y2hQYXJhbXMuaXRlbSA9IHRoaXMuaXRlbUZyb21UYXJnZXQoZXZlbnQpO1xuICAgIHRoaXMudG91Y2hQYXJhbXMuZHJhZ0xlZnRJdGVtID0gZXZlbnQudGFyZ2V0LmRyYWdMZWZ0SXRlbSB8fCBmYWxzZTtcbiAgICB0aGlzLnRvdWNoUGFyYW1zLmRyYWdSaWdodEl0ZW0gPSBldmVudC50YXJnZXQuZHJhZ1JpZ2h0SXRlbSB8fCBmYWxzZTtcbiAgICB0aGlzLnRvdWNoUGFyYW1zLml0ZW1Qcm9wcyA9IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdpdmVuIGFuIGdyb3VwIGlkLCByZXR1cm5zIHRoZSBpbmRleCBpdCBoYXMuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBncm91cElEXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5fZ2V0R3JvdXBJbmRleCA9IGZ1bmN0aW9uIChncm91cElkKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdyb3VwSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZ3JvdXBJZCA9PSB0aGlzLmdyb3VwSWRzW2ldKSByZXR1cm4gaTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGRyYWdnaW5nIHRoZSBzZWxlY3RlZCBldmVudHNcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLl9vbkRyYWdTdGFydCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBpdGVtID0gdGhpcy50b3VjaFBhcmFtcy5pdGVtIHx8IG51bGw7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgcHJvcHM7XG5cbiAgICBpZiAoaXRlbSAmJiAoaXRlbS5zZWxlY3RlZCB8fCB0aGlzLm9wdGlvbnMuaXRlbXNBbHdheXNEcmFnZ2FibGUpKSB7XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmVkaXRhYmxlLnVwZGF0ZVRpbWUgJiYgIXRoaXMub3B0aW9ucy5lZGl0YWJsZS51cGRhdGVHcm91cCAmJiAhaXRlbS5lZGl0YWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIG92ZXJyaWRlIG9wdGlvbnMuZWRpdGFibGVcbiAgICAgIGlmIChpdGVtLmVkaXRhYmxlID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBkcmFnTGVmdEl0ZW0gPSB0aGlzLnRvdWNoUGFyYW1zLmRyYWdMZWZ0SXRlbTtcbiAgICAgIHZhciBkcmFnUmlnaHRJdGVtID0gdGhpcy50b3VjaFBhcmFtcy5kcmFnUmlnaHRJdGVtO1xuXG4gICAgICBpZiAoZHJhZ0xlZnRJdGVtKSB7XG4gICAgICAgIHByb3BzID0ge1xuICAgICAgICAgIGl0ZW06IGRyYWdMZWZ0SXRlbSxcbiAgICAgICAgICBpbml0aWFsWDogZXZlbnQuY2VudGVyLngsXG4gICAgICAgICAgZHJhZ0xlZnQ6IHRydWUsXG4gICAgICAgICAgZGF0YTogdGhpcy5fY2xvbmVJdGVtRGF0YShpdGVtLmRhdGEpXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy50b3VjaFBhcmFtcy5pdGVtUHJvcHMgPSBbcHJvcHNdO1xuICAgICAgfSBlbHNlIGlmIChkcmFnUmlnaHRJdGVtKSB7XG4gICAgICAgIHByb3BzID0ge1xuICAgICAgICAgIGl0ZW06IGRyYWdSaWdodEl0ZW0sXG4gICAgICAgICAgaW5pdGlhbFg6IGV2ZW50LmNlbnRlci54LFxuICAgICAgICAgIGRyYWdSaWdodDogdHJ1ZSxcbiAgICAgICAgICBkYXRhOiB0aGlzLl9jbG9uZUl0ZW1EYXRhKGl0ZW0uZGF0YSlcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnRvdWNoUGFyYW1zLml0ZW1Qcm9wcyA9IFtwcm9wc107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRvdWNoUGFyYW1zLnNlbGVjdGVkSXRlbSA9IGl0ZW07XG5cbiAgICAgICAgdmFyIGJhc2VHcm91cEluZGV4ID0gdGhpcy5fZ2V0R3JvdXBJbmRleChpdGVtLmRhdGEuZ3JvdXApO1xuXG4gICAgICAgIHZhciBpdGVtc1RvRHJhZyA9IHRoaXMub3B0aW9ucy5pdGVtc0Fsd2F5c0RyYWdnYWJsZSAmJiAhaXRlbS5zZWxlY3RlZCA/IFtpdGVtLmlkXSA6IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgICAgdGhpcy50b3VjaFBhcmFtcy5pdGVtUHJvcHMgPSBpdGVtc1RvRHJhZy5tYXAoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSBtZS5pdGVtc1tpZF07XG4gICAgICAgICAgdmFyIGdyb3VwSW5kZXggPSBtZS5fZ2V0R3JvdXBJbmRleChpdGVtLmRhdGEuZ3JvdXApO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICAgICAgaW5pdGlhbFg6IGV2ZW50LmNlbnRlci54LFxuICAgICAgICAgICAgZ3JvdXBPZmZzZXQ6IGJhc2VHcm91cEluZGV4IC0gZ3JvdXBJbmRleCxcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuX2Nsb25lSXRlbURhdGEoaXRlbS5kYXRhKVxuICAgICAgICAgIH07XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICB9XG5cbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmVkaXRhYmxlLmFkZCAmJiAoZXZlbnQuc3JjRXZlbnQuY3RybEtleSB8fCBldmVudC5zcmNFdmVudC5tZXRhS2V5KSkge1xuICAgICAgLy8gY3JlYXRlIGEgbmV3IHJhbmdlIGl0ZW0gd2hlbiBkcmFnZ2luZyB3aXRoIGN0cmwga2V5IGRvd25cbiAgICAgIHRoaXMuX29uRHJhZ1N0YXJ0QWRkSXRlbShldmVudCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTdGFydCBjcmVhdGluZyBhIG5ldyByYW5nZSBpdGVtIGJ5IGRyYWdnaW5nLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUuX29uRHJhZ1N0YXJ0QWRkSXRlbSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBzbmFwID0gdGhpcy5vcHRpb25zLnNuYXAgfHwgbnVsbDtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMucnRsKSB7XG4gICAgICB2YXIgeEFicyA9IHV0aWwuZ2V0QWJzb2x1dGVSaWdodCh0aGlzLmRvbS5mcmFtZSk7XG4gICAgICB2YXIgeCA9IHhBYnMgLSBldmVudC5jZW50ZXIueCArIDEwOyAvLyBwbHVzIDEwIHRvIGNvbXBlbnNhdGUgZm9yIHRoZSBkcmFnIHN0YXJ0aW5nIGFzIHNvb24gYXMgeW91J3ZlIG1vdmVkIDEwcHhcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgeEFicyA9IHV0aWwuZ2V0QWJzb2x1dGVMZWZ0KHRoaXMuZG9tLmZyYW1lKTtcbiAgICAgICAgdmFyIHggPSBldmVudC5jZW50ZXIueCAtIHhBYnMgLSAxMDsgLy8gbWludXMgMTAgdG8gY29tcGVuc2F0ZSBmb3IgdGhlIGRyYWcgc3RhcnRpbmcgYXMgc29vbiBhcyB5b3UndmUgbW92ZWQgMTBweFxuICAgICAgfVxuXG4gICAgdmFyIHRpbWUgPSB0aGlzLmJvZHkudXRpbC50b1RpbWUoeCk7XG4gICAgdmFyIHNjYWxlID0gdGhpcy5ib2R5LnV0aWwuZ2V0U2NhbGUoKTtcbiAgICB2YXIgc3RlcCA9IHRoaXMuYm9keS51dGlsLmdldFN0ZXAoKTtcbiAgICB2YXIgc3RhcnQgPSBzbmFwID8gc25hcCh0aW1lLCBzY2FsZSwgc3RlcCkgOiB0aW1lO1xuICAgIHZhciBlbmQgPSBzdGFydDtcblxuICAgIHZhciBpdGVtRGF0YSA9IHtcbiAgICAgIHR5cGU6ICdyYW5nZScsXG4gICAgICBzdGFydDogc3RhcnQsXG4gICAgICBlbmQ6IGVuZCxcbiAgICAgIGNvbnRlbnQ6ICduZXcgaXRlbSdcbiAgICB9O1xuXG4gICAgdmFyIGlkID0gdXRpbC5yYW5kb21VVUlEKCk7XG4gICAgaXRlbURhdGFbdGhpcy5pdGVtc0RhdGEuX2ZpZWxkSWRdID0gaWQ7XG5cbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwRnJvbVRhcmdldChldmVudCk7XG4gICAgaWYgKGdyb3VwKSB7XG4gICAgICBpdGVtRGF0YS5ncm91cCA9IGdyb3VwLmdyb3VwSWQ7XG4gICAgfVxuICAgIHZhciBuZXdJdGVtID0gbmV3IFJhbmdlSXRlbShpdGVtRGF0YSwgdGhpcy5jb252ZXJzaW9uLCB0aGlzLm9wdGlvbnMpO1xuICAgIG5ld0l0ZW0uaWQgPSBpZDsgLy8gVE9ETzogbm90IHNvIG5pY2Ugc2V0dGluZyBpZCBhZnRlcndhcmRzXG4gICAgbmV3SXRlbS5kYXRhID0gdGhpcy5fY2xvbmVJdGVtRGF0YShpdGVtRGF0YSk7XG4gICAgdGhpcy5fYWRkSXRlbShuZXdJdGVtKTtcblxuICAgIHZhciBwcm9wcyA9IHtcbiAgICAgIGl0ZW06IG5ld0l0ZW0sXG4gICAgICBpbml0aWFsWDogZXZlbnQuY2VudGVyLngsXG4gICAgICBkYXRhOiBuZXdJdGVtLmRhdGFcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgIHByb3BzLmRyYWdMZWZ0ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvcHMuZHJhZ1JpZ2h0ID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy50b3VjaFBhcmFtcy5pdGVtUHJvcHMgPSBbcHJvcHNdO1xuXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERyYWcgc2VsZWN0ZWQgaXRlbXNcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLl9vbkRyYWcgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAodGhpcy50b3VjaFBhcmFtcy5pdGVtUHJvcHMpIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgdmFyIHNuYXAgPSB0aGlzLm9wdGlvbnMuc25hcCB8fCBudWxsO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgICB2YXIgeE9mZnNldCA9IHRoaXMuYm9keS5kb20ucm9vdC5vZmZzZXRMZWZ0ICsgdGhpcy5ib2R5LmRvbVByb3BzLnJpZ2h0LndpZHRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHhPZmZzZXQgPSB0aGlzLmJvZHkuZG9tLnJvb3Qub2Zmc2V0TGVmdCArIHRoaXMuYm9keS5kb21Qcm9wcy5sZWZ0LndpZHRoO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2NhbGUgPSB0aGlzLmJvZHkudXRpbC5nZXRTY2FsZSgpO1xuICAgICAgdmFyIHN0ZXAgPSB0aGlzLmJvZHkudXRpbC5nZXRTdGVwKCk7XG5cbiAgICAgIC8vb25seSBjYWxjdWxhdGUgdGhlIG5ldyBncm91cCBmb3IgdGhlIGl0ZW0gdGhhdCdzIGFjdHVhbGx5IGRyYWdnZWRcbiAgICAgIHZhciBzZWxlY3RlZEl0ZW0gPSB0aGlzLnRvdWNoUGFyYW1zLnNlbGVjdGVkSXRlbTtcbiAgICAgIHZhciB1cGRhdGVHcm91cEFsbG93ZWQgPSBtZS5vcHRpb25zLmVkaXRhYmxlLnVwZGF0ZUdyb3VwO1xuICAgICAgdmFyIG5ld0dyb3VwQmFzZSA9IG51bGw7XG4gICAgICBpZiAodXBkYXRlR3JvdXBBbGxvd2VkICYmIHNlbGVjdGVkSXRlbSkge1xuICAgICAgICBpZiAoc2VsZWN0ZWRJdGVtLmRhdGEuZ3JvdXAgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gZHJhZyBmcm9tIG9uZSBncm91cCB0byBhbm90aGVyXG4gICAgICAgICAgdmFyIGdyb3VwID0gbWUuZ3JvdXBGcm9tVGFyZ2V0KGV2ZW50KTtcbiAgICAgICAgICBpZiAoZ3JvdXApIHtcbiAgICAgICAgICAgIC8vd2Uga25vdyB0aGUgb2Zmc2V0IGZvciBhbGwgaXRlbXMsIHNvIHRoZSBuZXcgZ3JvdXAgZm9yIGFsbCBpdGVtc1xuICAgICAgICAgICAgLy93aWxsIGJlIHJlbGF0aXZlIHRvIHRoaXMgb25lLlxuICAgICAgICAgICAgbmV3R3JvdXBCYXNlID0gdGhpcy5fZ2V0R3JvdXBJbmRleChncm91cC5ncm91cElkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gbW92ZVxuICAgICAgdGhpcy50b3VjaFBhcmFtcy5pdGVtUHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBtZS5ib2R5LnV0aWwudG9UaW1lKGV2ZW50LmNlbnRlci54IC0geE9mZnNldCk7XG4gICAgICAgIHZhciBpbml0aWFsID0gbWUuYm9keS51dGlsLnRvVGltZShwcm9wcy5pbml0aWFsWCAtIHhPZmZzZXQpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucnRsKSB7XG4gICAgICAgICAgdmFyIG9mZnNldCA9IC0oY3VycmVudCAtIGluaXRpYWwpOyAvLyBtc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IGN1cnJlbnQgLSBpbml0aWFsOyAvLyBtc1xuICAgICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlbURhdGEgPSB0aGlzLl9jbG9uZUl0ZW1EYXRhKHByb3BzLml0ZW0uZGF0YSk7IC8vIGNsb25lIHRoZSBkYXRhXG4gICAgICAgIGlmIChwcm9wcy5pdGVtLmVkaXRhYmxlID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1cGRhdGVUaW1lQWxsb3dlZCA9IG1lLm9wdGlvbnMuZWRpdGFibGUudXBkYXRlVGltZSB8fCBwcm9wcy5pdGVtLmVkaXRhYmxlID09PSB0cnVlO1xuICAgICAgICBpZiAodXBkYXRlVGltZUFsbG93ZWQpIHtcbiAgICAgICAgICBpZiAocHJvcHMuZHJhZ0xlZnQpIHtcbiAgICAgICAgICAgIC8vIGRyYWcgbGVmdCBzaWRlIG9mIGEgcmFuZ2UgaXRlbVxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgICAgICAgICAgaWYgKGl0ZW1EYXRhLmVuZCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5pdGlhbEVuZCA9IHV0aWwuY29udmVydChwcm9wcy5kYXRhLmVuZCwgJ0RhdGUnKTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gbmV3IERhdGUoaW5pdGlhbEVuZC52YWx1ZU9mKCkgKyBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IHBhc3MgYSBNb21lbnQgaW5zdGVhZCBvZiBhIERhdGUgdG8gc25hcCgpLiAoQnJlYWtpbmcgY2hhbmdlKVxuICAgICAgICAgICAgICAgIGl0ZW1EYXRhLmVuZCA9IHNuYXAgPyBzbmFwKGVuZCwgc2NhbGUsIHN0ZXApIDogZW5kO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoaXRlbURhdGEuc3RhcnQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluaXRpYWxTdGFydCA9IHV0aWwuY29udmVydChwcm9wcy5kYXRhLnN0YXJ0LCAnRGF0ZScpO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IG5ldyBEYXRlKGluaXRpYWxTdGFydC52YWx1ZU9mKCkgKyBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IHBhc3MgYSBNb21lbnQgaW5zdGVhZCBvZiBhIERhdGUgdG8gc25hcCgpLiAoQnJlYWtpbmcgY2hhbmdlKVxuICAgICAgICAgICAgICAgIGl0ZW1EYXRhLnN0YXJ0ID0gc25hcCA/IHNuYXAoc3RhcnQsIHNjYWxlLCBzdGVwKSA6IHN0YXJ0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChwcm9wcy5kcmFnUmlnaHQpIHtcbiAgICAgICAgICAgIC8vIGRyYWcgcmlnaHQgc2lkZSBvZiBhIHJhbmdlIGl0ZW1cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucnRsKSB7XG4gICAgICAgICAgICAgIGlmIChpdGVtRGF0YS5zdGFydCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5pdGlhbFN0YXJ0ID0gdXRpbC5jb252ZXJ0KHByb3BzLmRhdGEuc3RhcnQsICdEYXRlJyk7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gbmV3IERhdGUoaW5pdGlhbFN0YXJ0LnZhbHVlT2YoKSArIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogcGFzcyBhIE1vbWVudCBpbnN0ZWFkIG9mIGEgRGF0ZSB0byBzbmFwKCkuIChCcmVha2luZyBjaGFuZ2UpXG4gICAgICAgICAgICAgICAgaXRlbURhdGEuc3RhcnQgPSBzbmFwID8gc25hcChzdGFydCwgc2NhbGUsIHN0ZXApIDogc3RhcnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChpdGVtRGF0YS5lbmQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluaXRpYWxFbmQgPSB1dGlsLmNvbnZlcnQocHJvcHMuZGF0YS5lbmQsICdEYXRlJyk7XG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IG5ldyBEYXRlKGluaXRpYWxFbmQudmFsdWVPZigpICsgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBwYXNzIGEgTW9tZW50IGluc3RlYWQgb2YgYSBEYXRlIHRvIHNuYXAoKS4gKEJyZWFraW5nIGNoYW5nZSlcbiAgICAgICAgICAgICAgICBpdGVtRGF0YS5lbmQgPSBzbmFwID8gc25hcChlbmQsIHNjYWxlLCBzdGVwKSA6IGVuZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBkcmFnIGJvdGggc3RhcnQgYW5kIGVuZFxuICAgICAgICAgICAgaWYgKGl0ZW1EYXRhLnN0YXJ0ICE9IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAgIHZhciBpbml0aWFsU3RhcnQgPSB1dGlsLmNvbnZlcnQocHJvcHMuZGF0YS5zdGFydCwgJ0RhdGUnKS52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgIHZhciBzdGFydCA9IG5ldyBEYXRlKGluaXRpYWxTdGFydCArIG9mZnNldCk7XG5cbiAgICAgICAgICAgICAgaWYgKGl0ZW1EYXRhLmVuZCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5pdGlhbEVuZCA9IHV0aWwuY29udmVydChwcm9wcy5kYXRhLmVuZCwgJ0RhdGUnKTtcbiAgICAgICAgICAgICAgICB2YXIgZHVyYXRpb24gPSBpbml0aWFsRW5kLnZhbHVlT2YoKSAtIGluaXRpYWxTdGFydC52YWx1ZU9mKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBwYXNzIGEgTW9tZW50IGluc3RlYWQgb2YgYSBEYXRlIHRvIHNuYXAoKS4gKEJyZWFraW5nIGNoYW5nZSlcbiAgICAgICAgICAgICAgICBpdGVtRGF0YS5zdGFydCA9IHNuYXAgPyBzbmFwKHN0YXJ0LCBzY2FsZSwgc3RlcCkgOiBzdGFydDtcbiAgICAgICAgICAgICAgICBpdGVtRGF0YS5lbmQgPSBuZXcgRGF0ZShpdGVtRGF0YS5zdGFydC52YWx1ZU9mKCkgKyBkdXJhdGlvbik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogcGFzcyBhIE1vbWVudCBpbnN0ZWFkIG9mIGEgRGF0ZSB0byBzbmFwKCkuIChCcmVha2luZyBjaGFuZ2UpXG4gICAgICAgICAgICAgICAgaXRlbURhdGEuc3RhcnQgPSBzbmFwID8gc25hcChzdGFydCwgc2NhbGUsIHN0ZXApIDogc3RhcnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdXBkYXRlR3JvdXBBbGxvd2VkID0gbWUub3B0aW9ucy5lZGl0YWJsZS51cGRhdGVHcm91cCB8fCBwcm9wcy5pdGVtLmVkaXRhYmxlID09PSB0cnVlO1xuXG4gICAgICAgIGlmICh1cGRhdGVHcm91cEFsbG93ZWQgJiYgIXByb3BzLmRyYWdMZWZ0ICYmICFwcm9wcy5kcmFnUmlnaHQgJiYgbmV3R3JvdXBCYXNlICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAoaXRlbURhdGEuZ3JvdXAgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgbmV3T2Zmc2V0ID0gbmV3R3JvdXBCYXNlIC0gcHJvcHMuZ3JvdXBPZmZzZXQ7XG5cbiAgICAgICAgICAgIC8vbWFrZSBzdXJlIHdlIHN0YXkgaW4gYm91bmRzXG4gICAgICAgICAgICBuZXdPZmZzZXQgPSBNYXRoLm1heCgwLCBuZXdPZmZzZXQpO1xuICAgICAgICAgICAgbmV3T2Zmc2V0ID0gTWF0aC5taW4obWUuZ3JvdXBJZHMubGVuZ3RoIC0gMSwgbmV3T2Zmc2V0KTtcblxuICAgICAgICAgICAgaXRlbURhdGEuZ3JvdXAgPSBtZS5ncm91cElkc1tuZXdPZmZzZXRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbmZpcm0gbW92aW5nIHRoZSBpdGVtXG4gICAgICAgIGl0ZW1EYXRhID0gdGhpcy5fY2xvbmVJdGVtRGF0YShpdGVtRGF0YSk7IC8vIGNvbnZlcnQgc3RhcnQgYW5kIGVuZCB0byB0aGUgY29ycmVjdCB0eXBlXG4gICAgICAgIG1lLm9wdGlvbnMub25Nb3ZpbmcoaXRlbURhdGEsIGZ1bmN0aW9uIChpdGVtRGF0YSkge1xuICAgICAgICAgIGlmIChpdGVtRGF0YSkge1xuICAgICAgICAgICAgcHJvcHMuaXRlbS5zZXREYXRhKHRoaXMuX2Nsb25lSXRlbURhdGEoaXRlbURhdGEsICdEYXRlJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgIHRoaXMuc3RhY2tEaXJ0eSA9IHRydWU7IC8vIGZvcmNlIHJlLXN0YWNraW5nIG9mIGFsbCBpdGVtcyBuZXh0IHJlZHJhd1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2NoYW5nZScpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogTW92ZSBhbiBpdGVtIHRvIGFub3RoZXIgZ3JvdXBcbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqIEBwYXJhbSB7U3RyaW5nIHwgTnVtYmVyfSBncm91cElkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5fbW92ZVRvR3JvdXAgPSBmdW5jdGlvbiAoaXRlbSwgZ3JvdXBJZCkge1xuICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXBzW2dyb3VwSWRdO1xuICAgIGlmIChncm91cCAmJiBncm91cC5ncm91cElkICE9IGl0ZW0uZGF0YS5ncm91cCkge1xuICAgICAgdmFyIG9sZEdyb3VwID0gaXRlbS5wYXJlbnQ7XG4gICAgICBvbGRHcm91cC5yZW1vdmUoaXRlbSk7XG4gICAgICBvbGRHcm91cC5vcmRlcigpO1xuICAgICAgZ3JvdXAuYWRkKGl0ZW0pO1xuICAgICAgZ3JvdXAub3JkZXIoKTtcblxuICAgICAgaXRlbS5kYXRhLmdyb3VwID0gZ3JvdXAuZ3JvdXBJZDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEVuZCBvZiBkcmFnZ2luZyBzZWxlY3RlZCBpdGVtc1xuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUuX29uRHJhZ0VuZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmICh0aGlzLnRvdWNoUGFyYW1zLml0ZW1Qcm9wcykge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICB2YXIgZGF0YXNldCA9IHRoaXMuaXRlbXNEYXRhLmdldERhdGFTZXQoKTtcbiAgICAgIHZhciBpdGVtUHJvcHMgPSB0aGlzLnRvdWNoUGFyYW1zLml0ZW1Qcm9wcztcbiAgICAgIHRoaXMudG91Y2hQYXJhbXMuaXRlbVByb3BzID0gbnVsbDtcblxuICAgICAgaXRlbVByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgIHZhciBpZCA9IHByb3BzLml0ZW0uaWQ7XG4gICAgICAgIHZhciBleGlzdHMgPSBtZS5pdGVtc0RhdGEuZ2V0KGlkLCBtZS5pdGVtT3B0aW9ucykgIT0gbnVsbDtcblxuICAgICAgICBpZiAoIWV4aXN0cykge1xuICAgICAgICAgIC8vIGFkZCBhIG5ldyBpdGVtXG4gICAgICAgICAgbWUub3B0aW9ucy5vbkFkZChwcm9wcy5pdGVtLmRhdGEsIGZ1bmN0aW9uIChpdGVtRGF0YSkge1xuICAgICAgICAgICAgbWUuX3JlbW92ZUl0ZW0ocHJvcHMuaXRlbSk7IC8vIHJlbW92ZSB0ZW1wb3JhcnkgaXRlbVxuICAgICAgICAgICAgaWYgKGl0ZW1EYXRhKSB7XG4gICAgICAgICAgICAgIG1lLml0ZW1zRGF0YS5nZXREYXRhU2V0KCkuYWRkKGl0ZW1EYXRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZm9yY2UgcmUtc3RhY2tpbmcgb2YgYWxsIGl0ZW1zIG5leHQgcmVkcmF3XG4gICAgICAgICAgICBtZS5zdGFja0RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIG1lLmJvZHkuZW1pdHRlci5lbWl0KCdfY2hhbmdlJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdXBkYXRlIGV4aXN0aW5nIGl0ZW1cbiAgICAgICAgICB2YXIgaXRlbURhdGEgPSB0aGlzLl9jbG9uZUl0ZW1EYXRhKHByb3BzLml0ZW0uZGF0YSk7IC8vIGNvbnZlcnQgc3RhcnQgYW5kIGVuZCB0byB0aGUgY29ycmVjdCB0eXBlXG4gICAgICAgICAgbWUub3B0aW9ucy5vbk1vdmUoaXRlbURhdGEsIGZ1bmN0aW9uIChpdGVtRGF0YSkge1xuICAgICAgICAgICAgaWYgKGl0ZW1EYXRhKSB7XG4gICAgICAgICAgICAgIC8vIGFwcGx5IGNoYW5nZXNcbiAgICAgICAgICAgICAgaXRlbURhdGFbZGF0YXNldC5fZmllbGRJZF0gPSBpZDsgLy8gZW5zdXJlIHRoZSBpdGVtIGNvbnRhaW5zIGl0cyBpZCAoY2FuIGJlIHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgZGF0YXNldC51cGRhdGUoaXRlbURhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gcmVzdG9yZSBvcmlnaW5hbCB2YWx1ZXNcbiAgICAgICAgICAgICAgcHJvcHMuaXRlbS5zZXREYXRhKHByb3BzLmRhdGEpO1xuXG4gICAgICAgICAgICAgIG1lLnN0YWNrRGlydHkgPSB0cnVlOyAvLyBmb3JjZSByZS1zdGFja2luZyBvZiBhbGwgaXRlbXMgbmV4dCByZWRyYXdcbiAgICAgICAgICAgICAgbWUuYm9keS5lbWl0dGVyLmVtaXQoJ19jaGFuZ2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gIH07XG5cbiAgSXRlbVNldC5wcm90b3R5cGUuX29uR3JvdXBEcmFnU3RhcnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmdyb3VwRWRpdGFibGUub3JkZXIpIHtcbiAgICAgIHRoaXMuZ3JvdXBUb3VjaFBhcmFtcy5ncm91cCA9IHRoaXMuZ3JvdXBGcm9tVGFyZ2V0KGV2ZW50KTtcblxuICAgICAgaWYgKHRoaXMuZ3JvdXBUb3VjaFBhcmFtcy5ncm91cCkge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICB0aGlzLmdyb3VwVG91Y2hQYXJhbXMub3JpZ2luYWxPcmRlciA9IHRoaXMuZ3JvdXBzRGF0YS5nZXRJZHMoe1xuICAgICAgICAgIG9yZGVyOiB0aGlzLm9wdGlvbnMuZ3JvdXBPcmRlclxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgSXRlbVNldC5wcm90b3R5cGUuX29uR3JvdXBEcmFnID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ncm91cEVkaXRhYmxlLm9yZGVyICYmIHRoaXMuZ3JvdXBUb3VjaFBhcmFtcy5ncm91cCkge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgIC8vIGRyYWcgZnJvbSBvbmUgZ3JvdXAgdG8gYW5vdGhlclxuICAgICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cEZyb21UYXJnZXQoZXZlbnQpO1xuXG4gICAgICAvLyB0cnkgdG8gYXZvaWQgdG9nZ2xpbmcgd2hlbiBncm91cHMgZGlmZmVyIGluIGhlaWdodFxuICAgICAgaWYgKGdyb3VwICYmIGdyb3VwLmhlaWdodCAhPSB0aGlzLmdyb3VwVG91Y2hQYXJhbXMuZ3JvdXAuaGVpZ2h0KSB7XG4gICAgICAgIHZhciBtb3ZpbmdVcCA9IGdyb3VwLnRvcCA8IHRoaXMuZ3JvdXBUb3VjaFBhcmFtcy5ncm91cC50b3A7XG4gICAgICAgIHZhciBjbGllbnRZID0gZXZlbnQuY2VudGVyID8gZXZlbnQuY2VudGVyLnkgOiBldmVudC5jbGllbnRZO1xuICAgICAgICB2YXIgdGFyZ2V0R3JvdXBUb3AgPSB1dGlsLmdldEFic29sdXRlVG9wKGdyb3VwLmRvbS5mb3JlZ3JvdW5kKTtcbiAgICAgICAgdmFyIGRyYWdnZWRHcm91cEhlaWdodCA9IHRoaXMuZ3JvdXBUb3VjaFBhcmFtcy5ncm91cC5oZWlnaHQ7XG4gICAgICAgIGlmIChtb3ZpbmdVcCkge1xuICAgICAgICAgIC8vIHNraXAgc3dhcHBpbmcgdGhlIGdyb3VwcyB3aGVuIHRoZSBkcmFnZ2VkIGdyb3VwIGlzIG5vdCBiZWxvdyBjbGllbnRZIGFmdGVyd2FyZHNcbiAgICAgICAgICBpZiAodGFyZ2V0R3JvdXBUb3AgKyBkcmFnZ2VkR3JvdXBIZWlnaHQgPCBjbGllbnRZKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB0YXJnZXRHcm91cEhlaWdodCA9IGdyb3VwLmhlaWdodDtcbiAgICAgICAgICAvLyBza2lwIHN3YXBwaW5nIHRoZSBncm91cHMgd2hlbiB0aGUgZHJhZ2dlZCBncm91cCBpcyBub3QgYmVsb3cgY2xpZW50WSBhZnRlcndhcmRzXG4gICAgICAgICAgaWYgKHRhcmdldEdyb3VwVG9wICsgdGFyZ2V0R3JvdXBIZWlnaHQgLSBkcmFnZ2VkR3JvdXBIZWlnaHQgPiBjbGllbnRZKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChncm91cCAmJiBncm91cCAhPSB0aGlzLmdyb3VwVG91Y2hQYXJhbXMuZ3JvdXApIHtcbiAgICAgICAgdmFyIGdyb3Vwc0RhdGEgPSB0aGlzLmdyb3Vwc0RhdGE7XG4gICAgICAgIHZhciB0YXJnZXRHcm91cCA9IGdyb3Vwc0RhdGEuZ2V0KGdyb3VwLmdyb3VwSWQpO1xuICAgICAgICB2YXIgZHJhZ2dlZEdyb3VwID0gZ3JvdXBzRGF0YS5nZXQodGhpcy5ncm91cFRvdWNoUGFyYW1zLmdyb3VwLmdyb3VwSWQpO1xuXG4gICAgICAgIC8vIHN3aXRjaCBncm91cHNcbiAgICAgICAgaWYgKGRyYWdnZWRHcm91cCAmJiB0YXJnZXRHcm91cCkge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5ncm91cE9yZGVyU3dhcChkcmFnZ2VkR3JvdXAsIHRhcmdldEdyb3VwLCB0aGlzLmdyb3Vwc0RhdGEpO1xuICAgICAgICAgIHRoaXMuZ3JvdXBzRGF0YS51cGRhdGUoZHJhZ2dlZEdyb3VwKTtcbiAgICAgICAgICB0aGlzLmdyb3Vwc0RhdGEudXBkYXRlKHRhcmdldEdyb3VwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZldGNoIGN1cnJlbnQgb3JkZXIgb2YgZ3JvdXBzXG4gICAgICAgIHZhciBuZXdPcmRlciA9IHRoaXMuZ3JvdXBzRGF0YS5nZXRJZHMoe1xuICAgICAgICAgIG9yZGVyOiB0aGlzLm9wdGlvbnMuZ3JvdXBPcmRlclxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBpbiBjYXNlIG9mIGNoYW5nZXMgc2luY2UgX29uR3JvdXBEcmFnU3RhcnRcbiAgICAgICAgaWYgKCF1dGlsLmVxdWFsQXJyYXkobmV3T3JkZXIsIHRoaXMuZ3JvdXBUb3VjaFBhcmFtcy5vcmlnaW5hbE9yZGVyKSkge1xuICAgICAgICAgIHZhciBncm91cHNEYXRhID0gdGhpcy5ncm91cHNEYXRhO1xuICAgICAgICAgIHZhciBvcmlnT3JkZXIgPSB0aGlzLmdyb3VwVG91Y2hQYXJhbXMub3JpZ2luYWxPcmRlcjtcbiAgICAgICAgICB2YXIgZHJhZ2dlZElkID0gdGhpcy5ncm91cFRvdWNoUGFyYW1zLmdyb3VwLmdyb3VwSWQ7XG4gICAgICAgICAgdmFyIG51bUdyb3VwcyA9IE1hdGgubWluKG9yaWdPcmRlci5sZW5ndGgsIG5ld09yZGVyLmxlbmd0aCk7XG4gICAgICAgICAgdmFyIGN1clBvcyA9IDA7XG4gICAgICAgICAgdmFyIG5ld09mZnNldCA9IDA7XG4gICAgICAgICAgdmFyIG9yZ09mZnNldCA9IDA7XG4gICAgICAgICAgd2hpbGUgKGN1clBvcyA8IG51bUdyb3Vwcykge1xuICAgICAgICAgICAgLy8gYXMgbG9uZyBhcyB0aGUgZ3JvdXBzIGFyZSB3aGVyZSB0aGV5IHNob3VsZCBiZSBzdGVwIGRvd24gYWxvbmcgdGhlIGdyb3VwcyBvcmRlclxuICAgICAgICAgICAgd2hpbGUgKGN1clBvcyArIG5ld09mZnNldCA8IG51bUdyb3VwcyAmJiBjdXJQb3MgKyBvcmdPZmZzZXQgPCBudW1Hcm91cHMgJiYgbmV3T3JkZXJbY3VyUG9zICsgbmV3T2Zmc2V0XSA9PSBvcmlnT3JkZXJbY3VyUG9zICsgb3JnT2Zmc2V0XSkge1xuICAgICAgICAgICAgICBjdXJQb3MrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYWxsIG9rXG4gICAgICAgICAgICBpZiAoY3VyUG9zICsgbmV3T2Zmc2V0ID49IG51bUdyb3Vwcykge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbm90IGFsbCBva1xuICAgICAgICAgICAgLy8gaWYgZHJhZ2dlZCBncm91cCB3YXMgbW92ZSB1cHdhcmRzIGV2ZXJ5dGhpbmcgYmVsb3cgc2hvdWxkIGhhdmUgYW4gb2Zmc2V0XG4gICAgICAgICAgICBpZiAobmV3T3JkZXJbY3VyUG9zICsgbmV3T2Zmc2V0XSA9PSBkcmFnZ2VkSWQpIHtcbiAgICAgICAgICAgICAgbmV3T2Zmc2V0ID0gMTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBkcmFnZ2VkIGdyb3VwIHdhcyBtb3ZlIGRvd253YXJkcyBldmVyeXRoaW5nIGFib3ZlIHNob3VsZCBoYXZlIGFuIG9mZnNldFxuICAgICAgICAgICAgZWxzZSBpZiAob3JpZ09yZGVyW2N1clBvcyArIG9yZ09mZnNldF0gPT0gZHJhZ2dlZElkKSB7XG4gICAgICAgICAgICAgICAgb3JnT2Zmc2V0ID0gMTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBmb3VuZCBhIGdyb3VwIChhcGFydCBmcm9tIGRyYWdnZWQgZ3JvdXApIHRoYXQgaGFzIHRoZSB3cm9uZyBwb3NpdGlvbiAtPiBzd2l0Y2ggd2l0aCB0aGVcbiAgICAgICAgICAgICAgLy8gZ3JvdXAgYXQgdGhlIHBvc2l0aW9uIHdoZXJlIG90aGVyIG9uZSBzaG91bGQgYmUsIGZpeCBpbmRleCBhcnJheXMgYW5kIGNvbnRpbnVlXG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIHNsaXBwZWRQb3NpdGlvbiA9IG5ld09yZGVyLmluZGV4T2Yob3JpZ09yZGVyW2N1clBvcyArIG9yZ09mZnNldF0pO1xuICAgICAgICAgICAgICAgICAgdmFyIHN3aXRjaEdyb3VwID0gZ3JvdXBzRGF0YS5nZXQobmV3T3JkZXJbY3VyUG9zICsgbmV3T2Zmc2V0XSk7XG4gICAgICAgICAgICAgICAgICB2YXIgc2hvdWxkQmVHcm91cCA9IGdyb3Vwc0RhdGEuZ2V0KG9yaWdPcmRlcltjdXJQb3MgKyBvcmdPZmZzZXRdKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5ncm91cE9yZGVyU3dhcChzd2l0Y2hHcm91cCwgc2hvdWxkQmVHcm91cCwgZ3JvdXBzRGF0YSk7XG4gICAgICAgICAgICAgICAgICBncm91cHNEYXRhLnVwZGF0ZShzd2l0Y2hHcm91cCk7XG4gICAgICAgICAgICAgICAgICBncm91cHNEYXRhLnVwZGF0ZShzaG91bGRCZUdyb3VwKTtcblxuICAgICAgICAgICAgICAgICAgdmFyIHN3aXRjaEdyb3VwSWQgPSBuZXdPcmRlcltjdXJQb3MgKyBuZXdPZmZzZXRdO1xuICAgICAgICAgICAgICAgICAgbmV3T3JkZXJbY3VyUG9zICsgbmV3T2Zmc2V0XSA9IG9yaWdPcmRlcltjdXJQb3MgKyBvcmdPZmZzZXRdO1xuICAgICAgICAgICAgICAgICAgbmV3T3JkZXJbc2xpcHBlZFBvc2l0aW9uXSA9IHN3aXRjaEdyb3VwSWQ7XG5cbiAgICAgICAgICAgICAgICAgIGN1clBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgSXRlbVNldC5wcm90b3R5cGUuX29uR3JvdXBEcmFnRW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ncm91cEVkaXRhYmxlLm9yZGVyICYmIHRoaXMuZ3JvdXBUb3VjaFBhcmFtcy5ncm91cCkge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgIC8vIHVwZGF0ZSBleGlzdGluZyBncm91cFxuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIHZhciBpZCA9IG1lLmdyb3VwVG91Y2hQYXJhbXMuZ3JvdXAuZ3JvdXBJZDtcbiAgICAgIHZhciBkYXRhc2V0ID0gbWUuZ3JvdXBzRGF0YS5nZXREYXRhU2V0KCk7XG4gICAgICB2YXIgZ3JvdXBEYXRhID0gdXRpbC5leHRlbmQoe30sIGRhdGFzZXQuZ2V0KGlkKSk7IC8vIGNsb25lIHRoZSBkYXRhXG4gICAgICBtZS5vcHRpb25zLm9uTW92ZUdyb3VwKGdyb3VwRGF0YSwgZnVuY3Rpb24gKGdyb3VwRGF0YSkge1xuICAgICAgICBpZiAoZ3JvdXBEYXRhKSB7XG4gICAgICAgICAgLy8gYXBwbHkgY2hhbmdlc1xuICAgICAgICAgIGdyb3VwRGF0YVtkYXRhc2V0Ll9maWVsZElkXSA9IGlkOyAvLyBlbnN1cmUgdGhlIGdyb3VwIGNvbnRhaW5zIGl0cyBpZCAoY2FuIGJlIHVuZGVmaW5lZClcbiAgICAgICAgICBkYXRhc2V0LnVwZGF0ZShncm91cERhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgLy8gZmV0Y2ggY3VycmVudCBvcmRlciBvZiBncm91cHNcbiAgICAgICAgICB2YXIgbmV3T3JkZXIgPSBkYXRhc2V0LmdldElkcyh7XG4gICAgICAgICAgICBvcmRlcjogbWUub3B0aW9ucy5ncm91cE9yZGVyXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyByZXN0b3JlIG9yaWdpbmFsIG9yZGVyXG4gICAgICAgICAgaWYgKCF1dGlsLmVxdWFsQXJyYXkobmV3T3JkZXIsIG1lLmdyb3VwVG91Y2hQYXJhbXMub3JpZ2luYWxPcmRlcikpIHtcbiAgICAgICAgICAgIHZhciBvcmlnT3JkZXIgPSBtZS5ncm91cFRvdWNoUGFyYW1zLm9yaWdpbmFsT3JkZXI7XG4gICAgICAgICAgICB2YXIgbnVtR3JvdXBzID0gTWF0aC5taW4ob3JpZ09yZGVyLmxlbmd0aCwgbmV3T3JkZXIubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciBjdXJQb3MgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGN1clBvcyA8IG51bUdyb3Vwcykge1xuICAgICAgICAgICAgICAvLyBhcyBsb25nIGFzIHRoZSBncm91cHMgYXJlIHdoZXJlIHRoZXkgc2hvdWxkIGJlIHN0ZXAgZG93biBhbG9uZyB0aGUgZ3JvdXBzIG9yZGVyXG4gICAgICAgICAgICAgIHdoaWxlIChjdXJQb3MgPCBudW1Hcm91cHMgJiYgbmV3T3JkZXJbY3VyUG9zXSA9PSBvcmlnT3JkZXJbY3VyUG9zXSkge1xuICAgICAgICAgICAgICAgIGN1clBvcysrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gYWxsIG9rXG4gICAgICAgICAgICAgIGlmIChjdXJQb3MgPj0gbnVtR3JvdXBzKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBmb3VuZCBhIGdyb3VwIHRoYXQgaGFzIHRoZSB3cm9uZyBwb3NpdGlvbiAtPiBzd2l0Y2ggd2l0aCB0aGVcbiAgICAgICAgICAgICAgLy8gZ3JvdXAgYXQgdGhlIHBvc2l0aW9uIHdoZXJlIG90aGVyIG9uZSBzaG91bGQgYmUsIGZpeCBpbmRleCBhcnJheXMgYW5kIGNvbnRpbnVlXG4gICAgICAgICAgICAgIHZhciBzbGlwcGVkUG9zaXRpb24gPSBuZXdPcmRlci5pbmRleE9mKG9yaWdPcmRlcltjdXJQb3NdKTtcbiAgICAgICAgICAgICAgdmFyIHN3aXRjaEdyb3VwID0gZGF0YXNldC5nZXQobmV3T3JkZXJbY3VyUG9zXSk7XG4gICAgICAgICAgICAgIHZhciBzaG91bGRCZUdyb3VwID0gZGF0YXNldC5nZXQob3JpZ09yZGVyW2N1clBvc10pO1xuICAgICAgICAgICAgICBtZS5vcHRpb25zLmdyb3VwT3JkZXJTd2FwKHN3aXRjaEdyb3VwLCBzaG91bGRCZUdyb3VwLCBkYXRhc2V0KTtcbiAgICAgICAgICAgICAgZ3JvdXBzRGF0YS51cGRhdGUoc3dpdGNoR3JvdXApO1xuICAgICAgICAgICAgICBncm91cHNEYXRhLnVwZGF0ZShzaG91bGRCZUdyb3VwKTtcblxuICAgICAgICAgICAgICB2YXIgc3dpdGNoR3JvdXBJZCA9IG5ld09yZGVyW2N1clBvc107XG4gICAgICAgICAgICAgIG5ld09yZGVyW2N1clBvc10gPSBvcmlnT3JkZXJbY3VyUG9zXTtcbiAgICAgICAgICAgICAgbmV3T3JkZXJbc2xpcHBlZFBvc2l0aW9uXSA9IHN3aXRjaEdyb3VwSWQ7XG5cbiAgICAgICAgICAgICAgY3VyUG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgbWUuYm9keS5lbWl0dGVyLmVtaXQoJ2dyb3VwRHJhZ2dlZCcsIHsgZ3JvdXBJZDogaWQgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgc2VsZWN0aW5nL2Rlc2VsZWN0aW5nIGFuIGl0ZW0gd2hlbiB0YXBwaW5nIGl0XG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5fb25TZWxlY3RJdGVtID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuc2VsZWN0YWJsZSkgcmV0dXJuO1xuXG4gICAgdmFyIGN0cmxLZXkgPSBldmVudC5zcmNFdmVudCAmJiAoZXZlbnQuc3JjRXZlbnQuY3RybEtleSB8fCBldmVudC5zcmNFdmVudC5tZXRhS2V5KTtcbiAgICB2YXIgc2hpZnRLZXkgPSBldmVudC5zcmNFdmVudCAmJiBldmVudC5zcmNFdmVudC5zaGlmdEtleTtcbiAgICBpZiAoY3RybEtleSB8fCBzaGlmdEtleSkge1xuICAgICAgdGhpcy5fb25NdWx0aVNlbGVjdEl0ZW0oZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBvbGRTZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbigpO1xuXG4gICAgdmFyIGl0ZW0gPSB0aGlzLml0ZW1Gcm9tVGFyZ2V0KGV2ZW50KTtcbiAgICB2YXIgc2VsZWN0aW9uID0gaXRlbSA/IFtpdGVtLmlkXSA6IFtdO1xuICAgIHRoaXMuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbik7XG5cbiAgICB2YXIgbmV3U2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcblxuICAgIC8vIGVtaXQgYSBzZWxlY3QgZXZlbnQsXG4gICAgLy8gZXhjZXB0IHdoZW4gb2xkIHNlbGVjdGlvbiBpcyBlbXB0eSBhbmQgbmV3IHNlbGVjdGlvbiBpcyBzdGlsbCBlbXB0eVxuICAgIGlmIChuZXdTZWxlY3Rpb24ubGVuZ3RoID4gMCB8fCBvbGRTZWxlY3Rpb24ubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnc2VsZWN0Jywge1xuICAgICAgICBpdGVtczogbmV3U2VsZWN0aW9uLFxuICAgICAgICBldmVudDogZXZlbnRcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGNyZWF0aW9uIGFuZCB1cGRhdGVzIG9mIGFuIGl0ZW0gb24gZG91YmxlIHRhcFxuICAgKiBAcGFyYW0gZXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLl9vbkFkZEl0ZW0gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5zZWxlY3RhYmxlKSByZXR1cm47XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuZWRpdGFibGUuYWRkKSByZXR1cm47XG5cbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciBzbmFwID0gdGhpcy5vcHRpb25zLnNuYXAgfHwgbnVsbDtcbiAgICB2YXIgaXRlbSA9IHRoaXMuaXRlbUZyb21UYXJnZXQoZXZlbnQpO1xuXG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIC8vIHVwZGF0ZSBpdGVtXG5cbiAgICAgIC8vIGV4ZWN1dGUgYXN5bmMgaGFuZGxlciB0byB1cGRhdGUgdGhlIGl0ZW0gKG9yIGNhbmNlbCBpdClcbiAgICAgIHZhciBpdGVtRGF0YSA9IG1lLml0ZW1zRGF0YS5nZXQoaXRlbS5pZCk7IC8vIGdldCBhIGNsb25lIG9mIHRoZSBkYXRhIGZyb20gdGhlIGRhdGFzZXRcbiAgICAgIHRoaXMub3B0aW9ucy5vblVwZGF0ZShpdGVtRGF0YSwgZnVuY3Rpb24gKGl0ZW1EYXRhKSB7XG4gICAgICAgIGlmIChpdGVtRGF0YSkge1xuICAgICAgICAgIG1lLml0ZW1zRGF0YS5nZXREYXRhU2V0KCkudXBkYXRlKGl0ZW1EYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGFkZCBpdGVtXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgICB2YXIgeEFicyA9IHV0aWwuZ2V0QWJzb2x1dGVSaWdodCh0aGlzLmRvbS5mcmFtZSk7XG4gICAgICAgIHZhciB4ID0geEFicyAtIGV2ZW50LmNlbnRlci54O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHhBYnMgPSB1dGlsLmdldEFic29sdXRlTGVmdCh0aGlzLmRvbS5mcmFtZSk7XG4gICAgICAgIHZhciB4ID0gZXZlbnQuY2VudGVyLnggLSB4QWJzO1xuICAgICAgfVxuICAgICAgLy8gdmFyIHhBYnMgPSB1dGlsLmdldEFic29sdXRlTGVmdCh0aGlzLmRvbS5mcmFtZSk7XG4gICAgICAvLyB2YXIgeCA9IGV2ZW50LmNlbnRlci54IC0geEFicztcbiAgICAgIHZhciBzdGFydCA9IHRoaXMuYm9keS51dGlsLnRvVGltZSh4KTtcbiAgICAgIHZhciBzY2FsZSA9IHRoaXMuYm9keS51dGlsLmdldFNjYWxlKCk7XG4gICAgICB2YXIgc3RlcCA9IHRoaXMuYm9keS51dGlsLmdldFN0ZXAoKTtcblxuICAgICAgdmFyIG5ld0l0ZW1EYXRhID0ge1xuICAgICAgICBzdGFydDogc25hcCA/IHNuYXAoc3RhcnQsIHNjYWxlLCBzdGVwKSA6IHN0YXJ0LFxuICAgICAgICBjb250ZW50OiAnbmV3IGl0ZW0nXG4gICAgICB9O1xuXG4gICAgICAvLyB3aGVuIGRlZmF1bHQgdHlwZSBpcyBhIHJhbmdlLCBhZGQgYSBkZWZhdWx0IGVuZCBkYXRlIHRvIHRoZSBuZXcgaXRlbVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy50eXBlID09PSAncmFuZ2UnKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLmJvZHkudXRpbC50b1RpbWUoeCArIHRoaXMucHJvcHMud2lkdGggLyA1KTtcbiAgICAgICAgbmV3SXRlbURhdGEuZW5kID0gc25hcCA/IHNuYXAoZW5kLCBzY2FsZSwgc3RlcCkgOiBlbmQ7XG4gICAgICB9XG5cbiAgICAgIG5ld0l0ZW1EYXRhW3RoaXMuaXRlbXNEYXRhLl9maWVsZElkXSA9IHV0aWwucmFuZG9tVVVJRCgpO1xuXG4gICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwRnJvbVRhcmdldChldmVudCk7XG4gICAgICBpZiAoZ3JvdXApIHtcbiAgICAgICAgbmV3SXRlbURhdGEuZ3JvdXAgPSBncm91cC5ncm91cElkO1xuICAgICAgfVxuXG4gICAgICAvLyBleGVjdXRlIGFzeW5jIGhhbmRsZXIgdG8gY3VzdG9taXplIChvciBjYW5jZWwpIGFkZGluZyBhbiBpdGVtXG4gICAgICBuZXdJdGVtRGF0YSA9IHRoaXMuX2Nsb25lSXRlbURhdGEobmV3SXRlbURhdGEpOyAvLyBjb252ZXJ0IHN0YXJ0IGFuZCBlbmQgdG8gdGhlIGNvcnJlY3QgdHlwZVxuICAgICAgdGhpcy5vcHRpb25zLm9uQWRkKG5ld0l0ZW1EYXRhLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgIG1lLml0ZW1zRGF0YS5nZXREYXRhU2V0KCkuYWRkKGl0ZW0pO1xuICAgICAgICAgIC8vIFRPRE86IG5lZWQgdG8gdHJpZ2dlciBhIHJlZHJhdz9cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgc2VsZWN0aW5nL2Rlc2VsZWN0aW5nIG11bHRpcGxlIGl0ZW1zIHdoZW4gaG9sZGluZyBhbiBpdGVtXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5fb25NdWx0aVNlbGVjdEl0ZW0gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5zZWxlY3RhYmxlKSByZXR1cm47XG5cbiAgICB2YXIgaXRlbSA9IHRoaXMuaXRlbUZyb21UYXJnZXQoZXZlbnQpO1xuXG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIC8vIG11bHRpIHNlbGVjdCBpdGVtcyAoaWYgYWxsb3dlZClcblxuICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMub3B0aW9ucy5tdWx0aXNlbGVjdCA/IHRoaXMuZ2V0U2VsZWN0aW9uKCkgLy8gdGFrZSBjdXJyZW50IHNlbGVjdGlvblxuICAgICAgOiBbXTsgLy8gZGVzZWxlY3QgY3VycmVudCBzZWxlY3Rpb25cblxuICAgICAgdmFyIHNoaWZ0S2V5ID0gZXZlbnQuc3JjRXZlbnQgJiYgZXZlbnQuc3JjRXZlbnQuc2hpZnRLZXkgfHwgZmFsc2U7XG5cbiAgICAgIGlmIChzaGlmdEtleSAmJiB0aGlzLm9wdGlvbnMubXVsdGlzZWxlY3QpIHtcbiAgICAgICAgLy8gc2VsZWN0IGFsbCBpdGVtcyBiZXR3ZWVuIHRoZSBvbGQgc2VsZWN0aW9uIGFuZCB0aGUgdGFwcGVkIGl0ZW1cbiAgICAgICAgdmFyIGl0ZW1Hcm91cCA9IHRoaXMuaXRlbXNEYXRhLmdldChpdGVtLmlkKS5ncm91cDtcblxuICAgICAgICAvLyB3aGVuIGZpbHRlcmluZyBnZXQgdGhlIGdyb3VwIG9mIHRoZSBsYXN0IHNlbGVjdGVkIGl0ZW1cbiAgICAgICAgdmFyIGxhc3RTZWxlY3RlZEdyb3VwID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm11bHRpc2VsZWN0UGVyR3JvdXApIHtcbiAgICAgICAgICBpZiAoc2VsZWN0aW9uLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxhc3RTZWxlY3RlZEdyb3VwID0gdGhpcy5pdGVtc0RhdGEuZ2V0KHNlbGVjdGlvblswXSkuZ3JvdXA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIHRoZSBzZWxlY3Rpb24gcmFuZ2VcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMubXVsdGlzZWxlY3RQZXJHcm91cCB8fCBsYXN0U2VsZWN0ZWRHcm91cCA9PSB1bmRlZmluZWQgfHwgbGFzdFNlbGVjdGVkR3JvdXAgPT0gaXRlbUdyb3VwKSB7XG4gICAgICAgICAgc2VsZWN0aW9uLnB1c2goaXRlbS5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJhbmdlID0gSXRlbVNldC5fZ2V0SXRlbVJhbmdlKHRoaXMuaXRlbXNEYXRhLmdldChzZWxlY3Rpb24sIHRoaXMuaXRlbU9wdGlvbnMpKTtcblxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5tdWx0aXNlbGVjdFBlckdyb3VwIHx8IGxhc3RTZWxlY3RlZEdyb3VwID09IGl0ZW1Hcm91cCkge1xuICAgICAgICAgIC8vIHNlbGVjdCBhbGwgaXRlbXMgd2l0aGluIHRoZSBzZWxlY3Rpb24gcmFuZ2VcbiAgICAgICAgICBzZWxlY3Rpb24gPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLml0ZW1zKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pdGVtcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgICAgdmFyIF9pdGVtID0gdGhpcy5pdGVtc1tpZF07XG4gICAgICAgICAgICAgIHZhciBzdGFydCA9IF9pdGVtLmRhdGEuc3RhcnQ7XG4gICAgICAgICAgICAgIHZhciBlbmQgPSBfaXRlbS5kYXRhLmVuZCAhPT0gdW5kZWZpbmVkID8gX2l0ZW0uZGF0YS5lbmQgOiBzdGFydDtcblxuICAgICAgICAgICAgICBpZiAoc3RhcnQgPj0gcmFuZ2UubWluICYmIGVuZCA8PSByYW5nZS5tYXggJiYgKCF0aGlzLm9wdGlvbnMubXVsdGlzZWxlY3RQZXJHcm91cCB8fCBsYXN0U2VsZWN0ZWRHcm91cCA9PSB0aGlzLml0ZW1zRGF0YS5nZXQoX2l0ZW0uaWQpLmdyb3VwKSAmJiAhKF9pdGVtIGluc3RhbmNlb2YgQmFja2dyb3VuZEl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLnB1c2goX2l0ZW0uaWQpOyAvLyBkbyBub3QgdXNlIGlkIGJ1dCBpdGVtLmlkLCBpZCBpdHNlbGYgaXMgc3RyaW5naWZpZWRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBhZGQvcmVtb3ZlIHRoaXMgaXRlbSBmcm9tIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuICAgICAgICAgIHZhciBpbmRleCA9IHNlbGVjdGlvbi5pbmRleE9mKGl0ZW0uaWQpO1xuICAgICAgICAgIGlmIChpbmRleCA9PSAtMSkge1xuICAgICAgICAgICAgLy8gaXRlbSBpcyBub3QgeWV0IHNlbGVjdGVkIC0+IHNlbGVjdCBpdFxuICAgICAgICAgICAgc2VsZWN0aW9uLnB1c2goaXRlbS5pZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGl0ZW0gaXMgYWxyZWFkeSBzZWxlY3RlZCAtPiBkZXNlbGVjdCBpdFxuICAgICAgICAgICAgc2VsZWN0aW9uLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbik7XG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3NlbGVjdCcsIHtcbiAgICAgICAgaXRlbXM6IHRoaXMuZ2V0U2VsZWN0aW9uKCksXG4gICAgICAgIGV2ZW50OiBldmVudFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIHRpbWUgcmFuZ2Ugb2YgYSBsaXN0IG9mIGl0ZW1zXG4gICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IGl0ZW1zRGF0YVxuICAgKiBAcmV0dXJuIHt7bWluOiBEYXRlLCBtYXg6IERhdGV9fSBSZXR1cm5zIHRoZSByYW5nZSBvZiB0aGUgcHJvdmlkZWQgaXRlbXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEl0ZW1TZXQuX2dldEl0ZW1SYW5nZSA9IGZ1bmN0aW9uIChpdGVtc0RhdGEpIHtcbiAgICB2YXIgbWF4ID0gbnVsbDtcbiAgICB2YXIgbWluID0gbnVsbDtcblxuICAgIGl0ZW1zRGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICBpZiAobWluID09IG51bGwgfHwgZGF0YS5zdGFydCA8IG1pbikge1xuICAgICAgICBtaW4gPSBkYXRhLnN0YXJ0O1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YS5lbmQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChtYXggPT0gbnVsbCB8fCBkYXRhLmVuZCA+IG1heCkge1xuICAgICAgICAgIG1heCA9IGRhdGEuZW5kO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobWF4ID09IG51bGwgfHwgZGF0YS5zdGFydCA+IG1heCkge1xuICAgICAgICAgIG1heCA9IGRhdGEuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICBtaW46IG1pbixcbiAgICAgIG1heDogbWF4XG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogRmluZCBhbiBpdGVtIGZyb20gYW4gZXZlbnQgdGFyZ2V0OlxuICAgKiBzZWFyY2hlcyBmb3IgdGhlIGF0dHJpYnV0ZSAndGltZWxpbmUtaXRlbScgaW4gdGhlIGV2ZW50IHRhcmdldCdzIGVsZW1lbnQgdHJlZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcmV0dXJuIHtJdGVtIHwgbnVsbH0gaXRlbVxuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUuaXRlbUZyb21UYXJnZXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgIHdoaWxlICh0YXJnZXQpIHtcbiAgICAgIGlmICh0YXJnZXQuaGFzT3duUHJvcGVydHkoJ3RpbWVsaW5lLWl0ZW0nKSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0Wyd0aW1lbGluZS1pdGVtJ107XG4gICAgICB9XG4gICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogRmluZCB0aGUgR3JvdXAgZnJvbSBhbiBldmVudCB0YXJnZXQ6XG4gICAqIHNlYXJjaGVzIGZvciB0aGUgYXR0cmlidXRlICd0aW1lbGluZS1ncm91cCcgaW4gdGhlIGV2ZW50IHRhcmdldCdzIGVsZW1lbnQgdHJlZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcmV0dXJuIHtHcm91cCB8IG51bGx9IGdyb3VwXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5ncm91cEZyb21UYXJnZXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgY2xpZW50WSA9IGV2ZW50LmNlbnRlciA/IGV2ZW50LmNlbnRlci55IDogZXZlbnQuY2xpZW50WTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZ3JvdXBJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBncm91cElkID0gdGhpcy5ncm91cElkc1tpXTtcbiAgICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXBzW2dyb3VwSWRdO1xuICAgICAgdmFyIGZvcmVncm91bmQgPSBncm91cC5kb20uZm9yZWdyb3VuZDtcbiAgICAgIHZhciB0b3AgPSB1dGlsLmdldEFic29sdXRlVG9wKGZvcmVncm91bmQpO1xuICAgICAgaWYgKGNsaWVudFkgPiB0b3AgJiYgY2xpZW50WSA8IHRvcCArIGZvcmVncm91bmQub2Zmc2V0SGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBncm91cDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5pdGVtID09PSAndG9wJykge1xuICAgICAgICBpZiAoaSA9PT0gdGhpcy5ncm91cElkcy5sZW5ndGggLSAxICYmIGNsaWVudFkgPiB0b3ApIHtcbiAgICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpID09PSAwICYmIGNsaWVudFkgPCB0b3AgKyBmb3JlZ3JvdW5kLm9mZnNldCkge1xuICAgICAgICAgIHJldHVybiBncm91cDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSBJdGVtU2V0IGZyb20gYW4gZXZlbnQgdGFyZ2V0OlxuICAgKiBzZWFyY2hlcyBmb3IgdGhlIGF0dHJpYnV0ZSAndGltZWxpbmUtaXRlbXNldCcgaW4gdGhlIGV2ZW50IHRhcmdldCdzIGVsZW1lbnQgdHJlZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcmV0dXJuIHtJdGVtU2V0IHwgbnVsbH0gaXRlbVxuICAgKi9cbiAgSXRlbVNldC5pdGVtU2V0RnJvbVRhcmdldCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgd2hpbGUgKHRhcmdldCkge1xuICAgICAgaWYgKHRhcmdldC5oYXNPd25Qcm9wZXJ0eSgndGltZWxpbmUtaXRlbXNldCcpKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXRbJ3RpbWVsaW5lLWl0ZW1zZXQnXTtcbiAgICAgIH1cbiAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbG9uZSB0aGUgZGF0YSBvZiBhbiBpdGVtLCBhbmQgXCJub3JtYWxpemVcIiBpdDogY29udmVydCB0aGUgc3RhcnQgYW5kIGVuZCBkYXRlXG4gICAqIHRvIHRoZSB0eXBlIChEYXRlLCBNb21lbnQsIC4uLikgY29uZmlndXJlZCBpbiB0aGUgRGF0YVNldC4gSWYgbm90IGNvbmZpZ3VyZWQsXG4gICAqIHN0YXJ0IGFuZCBlbmQgYXJlIGNvbnZlcnRlZCB0byBEYXRlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbURhdGEsIHR5cGljYWxseSBgaXRlbS5kYXRhYFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdICBPcHRpb25hbCBEYXRlIHR5cGUuIElmIG5vdCBwcm92aWRlZCwgdGhlIHR5cGUgZnJvbSB0aGUgRGF0YVNldCBpcyB0YWtlblxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjbG9uZWQgb2JqZWN0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5fY2xvbmVJdGVtRGF0YSA9IGZ1bmN0aW9uIChpdGVtRGF0YSwgdHlwZSkge1xuICAgIHZhciBjbG9uZSA9IHV0aWwuZXh0ZW5kKHt9LCBpdGVtRGF0YSk7XG5cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIC8vIGNvbnZlcnQgc3RhcnQgYW5kIGVuZCBkYXRlIHRvIHRoZSB0eXBlIChEYXRlLCBNb21lbnQsIC4uLikgY29uZmlndXJlZCBpbiB0aGUgRGF0YVNldFxuICAgICAgdHlwZSA9IHRoaXMuaXRlbXNEYXRhLmdldERhdGFTZXQoKS5fb3B0aW9ucy50eXBlO1xuICAgIH1cblxuICAgIGlmIChjbG9uZS5zdGFydCAhPSB1bmRlZmluZWQpIHtcbiAgICAgIGNsb25lLnN0YXJ0ID0gdXRpbC5jb252ZXJ0KGNsb25lLnN0YXJ0LCB0eXBlICYmIHR5cGUuc3RhcnQgfHwgJ0RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGNsb25lLmVuZCAhPSB1bmRlZmluZWQpIHtcbiAgICAgIGNsb25lLmVuZCA9IHV0aWwuY29udmVydChjbG9uZS5lbmQsIHR5cGUgJiYgdHlwZS5lbmQgfHwgJ0RhdGUnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2xvbmU7XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBJdGVtU2V0O1xuXG4vKioqLyB9LFxuLyogMzUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgbW9tZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbiAgdmFyIERhdGVVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yICBUaW1lU3RlcFxuICAgKiBUaGUgY2xhc3MgVGltZVN0ZXAgaXMgYW4gaXRlcmF0b3IgZm9yIGRhdGVzLiBZb3UgcHJvdmlkZSBhIHN0YXJ0IGRhdGUgYW5kIGFuXG4gICAqIGVuZCBkYXRlLiBUaGUgY2xhc3MgaXRzZWxmIGRldGVybWluZXMgdGhlIGJlc3Qgc2NhbGUgKHN0ZXAgc2l6ZSkgYmFzZWQgb24gdGhlXG4gICAqIHByb3ZpZGVkIHN0YXJ0IERhdGUsIGVuZCBEYXRlLCBhbmQgbWluaW11bVN0ZXAuXG4gICAqXG4gICAqIElmIG1pbmltdW1TdGVwIGlzIHByb3ZpZGVkLCB0aGUgc3RlcCBzaXplIGlzIGNob3NlbiBhcyBjbG9zZSBhcyBwb3NzaWJsZVxuICAgKiB0byB0aGUgbWluaW11bVN0ZXAgYnV0IGxhcmdlciB0aGFuIG1pbmltdW1TdGVwLiBJZiBtaW5pbXVtU3RlcCBpcyBub3RcbiAgICogcHJvdmlkZWQsIHRoZSBzY2FsZSBpcyBzZXQgdG8gMSBEQVkuXG4gICAqIFRoZSBtaW5pbXVtU3RlcCBzaG91bGQgY29ycmVzcG9uZCB3aXRoIHRoZSBvbnNjcmVlbiBzaXplIG9mIGFib3V0IDYgY2hhcmFjdGVyc1xuICAgKlxuICAgKiBBbHRlcm5hdGl2ZWx5LCB5b3UgY2FuIHNldCBhIHNjYWxlIGJ5IGhhbmQuXG4gICAqIEFmdGVyIGNyZWF0aW9uLCB5b3UgY2FuIGluaXRpYWxpemUgdGhlIGNsYXNzIGJ5IGV4ZWN1dGluZyBmaXJzdCgpLiBUaGVuIHlvdVxuICAgKiBjYW4gaXRlcmF0ZSBmcm9tIHRoZSBzdGFydCBkYXRlIHRvIHRoZSBlbmQgZGF0ZSB2aWEgbmV4dCgpLiBZb3UgY2FuIGNoZWNrIGlmXG4gICAqIHRoZSBlbmQgZGF0ZSBpcyByZWFjaGVkIHdpdGggdGhlIGZ1bmN0aW9uIGhhc05leHQoKS4gQWZ0ZXIgZWFjaCBzdGVwLCB5b3UgY2FuXG4gICAqIHJldHJpZXZlIHRoZSBjdXJyZW50IGRhdGUgdmlhIGdldEN1cnJlbnQoKS5cbiAgICogVGhlIFRpbWVTdGVwIGhhcyBzY2FsZXMgcmFuZ2luZyBmcm9tIG1pbGxpc2Vjb25kcywgc2Vjb25kcywgbWludXRlcywgaG91cnMsXG4gICAqIGRheXMsIHRvIHllYXJzLlxuICAgKlxuICAgKiBWZXJzaW9uOiAxLjJcbiAgICpcbiAgICogQHBhcmFtIHtEYXRlfSBbc3RhcnRdICAgICAgICAgVGhlIHN0YXJ0IGRhdGUsIGZvciBleGFtcGxlIG5ldyBEYXRlKDIwMTAsIDksIDIxKVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciBuZXcgRGF0ZSgyMDEwLCA5LCAyMSwgMjMsIDQ1LCAwMClcbiAgICogQHBhcmFtIHtEYXRlfSBbZW5kXSAgICAgICAgICAgVGhlIGVuZCBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbbWluaW11bVN0ZXBdIE9wdGlvbmFsLiBNaW5pbXVtIHN0ZXAgc2l6ZSBpbiBtaWxsaXNlY29uZHNcbiAgICovXG4gIGZ1bmN0aW9uIFRpbWVTdGVwKHN0YXJ0LCBlbmQsIG1pbmltdW1TdGVwLCBoaWRkZW5EYXRlcykge1xuICAgIHRoaXMubW9tZW50ID0gbW9tZW50O1xuXG4gICAgLy8gdmFyaWFibGVzXG4gICAgdGhpcy5jdXJyZW50ID0gdGhpcy5tb21lbnQoKTtcbiAgICB0aGlzLl9zdGFydCA9IHRoaXMubW9tZW50KCk7XG4gICAgdGhpcy5fZW5kID0gdGhpcy5tb21lbnQoKTtcblxuICAgIHRoaXMuYXV0b1NjYWxlID0gdHJ1ZTtcbiAgICB0aGlzLnNjYWxlID0gJ2RheSc7XG4gICAgdGhpcy5zdGVwID0gMTtcblxuICAgIC8vIGluaXRpYWxpemUgdGhlIHJhbmdlXG4gICAgdGhpcy5zZXRSYW5nZShzdGFydCwgZW5kLCBtaW5pbXVtU3RlcCk7XG5cbiAgICAvLyBoaWRkZW4gRGF0ZXMgb3B0aW9uc1xuICAgIHRoaXMuc3dpdGNoZWREYXkgPSBmYWxzZTtcbiAgICB0aGlzLnN3aXRjaGVkTW9udGggPSBmYWxzZTtcbiAgICB0aGlzLnN3aXRjaGVkWWVhciA9IGZhbHNlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhpZGRlbkRhdGVzKSkge1xuICAgICAgdGhpcy5oaWRkZW5EYXRlcyA9IGhpZGRlbkRhdGVzO1xuICAgIH0gZWxzZSBpZiAoaGlkZGVuRGF0ZXMgIT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmhpZGRlbkRhdGVzID0gW2hpZGRlbkRhdGVzXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oaWRkZW5EYXRlcyA9IFtdO1xuICAgIH1cblxuICAgIHRoaXMuZm9ybWF0ID0gVGltZVN0ZXAuRk9STUFUOyAvLyBkZWZhdWx0IGZvcm1hdHRpbmdcbiAgfVxuXG4gIC8vIFRpbWUgZm9ybWF0dGluZ1xuICBUaW1lU3RlcC5GT1JNQVQgPSB7XG4gICAgbWlub3JMYWJlbHM6IHtcbiAgICAgIG1pbGxpc2Vjb25kOiAnU1NTJyxcbiAgICAgIHNlY29uZDogJ3MnLFxuICAgICAgbWludXRlOiAnSEg6bW0nLFxuICAgICAgaG91cjogJ0hIOm1tJyxcbiAgICAgIHdlZWtkYXk6ICdkZGQgRCcsXG4gICAgICBkYXk6ICdEJyxcbiAgICAgIG1vbnRoOiAnTU1NJyxcbiAgICAgIHllYXI6ICdZWVlZJ1xuICAgIH0sXG4gICAgbWFqb3JMYWJlbHM6IHtcbiAgICAgIG1pbGxpc2Vjb25kOiAnSEg6bW06c3MnLFxuICAgICAgc2Vjb25kOiAnRCBNTU1NIEhIOm1tJyxcbiAgICAgIG1pbnV0ZTogJ2RkZCBEIE1NTU0nLFxuICAgICAgaG91cjogJ2RkZCBEIE1NTU0nLFxuICAgICAgd2Vla2RheTogJ01NTU0gWVlZWScsXG4gICAgICBkYXk6ICdNTU1NIFlZWVknLFxuICAgICAgbW9udGg6ICdZWVlZJyxcbiAgICAgIHllYXI6ICcnXG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgY3VzdG9tIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciBtb21lbnQuIENhbiBiZSB1c2VkIHRvIHNldCBkYXRlc1xuICAgKiB0byBVVEMgb3IgdG8gc2V0IGEgdXRjT2Zmc2V0LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBtb21lbnRcbiAgICovXG4gIFRpbWVTdGVwLnByb3RvdHlwZS5zZXRNb21lbnQgPSBmdW5jdGlvbiAobW9tZW50KSB7XG4gICAgdGhpcy5tb21lbnQgPSBtb21lbnQ7XG5cbiAgICAvLyB1cGRhdGUgdGhlIGRhdGUgcHJvcGVydGllcywgY2FuIGhhdmUgYSBuZXcgdXRjT2Zmc2V0XG4gICAgdGhpcy5jdXJyZW50ID0gdGhpcy5tb21lbnQodGhpcy5jdXJyZW50KTtcbiAgICB0aGlzLl9zdGFydCA9IHRoaXMubW9tZW50KHRoaXMuX3N0YXJ0KTtcbiAgICB0aGlzLl9lbmQgPSB0aGlzLm1vbWVudCh0aGlzLl9lbmQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgY3VzdG9tIGZvcm1hdHRpbmcgZm9yIHRoZSBtaW5vciBhbiBtYWpvciBsYWJlbHMgb2YgdGhlIFRpbWVTdGVwLlxuICAgKiBCb3RoIGBtaW5vckxhYmVsc2AgYW5kIGBtYWpvckxhYmVsc2AgYXJlIGFuIE9iamVjdCB3aXRoIHByb3BlcnRpZXM6XG4gICAqICdtaWxsaXNlY29uZCcsICdzZWNvbmQnLCAnbWludXRlJywgJ2hvdXInLCAnd2Vla2RheScsICdkYXknLCAnbW9udGgnLCAneWVhcicuXG4gICAqIEBwYXJhbSB7e21pbm9yTGFiZWxzOiBPYmplY3QsIG1ham9yTGFiZWxzOiBPYmplY3R9fSBmb3JtYXRcbiAgICovXG4gIFRpbWVTdGVwLnByb3RvdHlwZS5zZXRGb3JtYXQgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgdmFyIGRlZmF1bHRGb3JtYXQgPSB1dGlsLmRlZXBFeHRlbmQoe30sIFRpbWVTdGVwLkZPUk1BVCk7XG4gICAgdGhpcy5mb3JtYXQgPSB1dGlsLmRlZXBFeHRlbmQoZGVmYXVsdEZvcm1hdCwgZm9ybWF0KTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGEgbmV3IHJhbmdlXG4gICAqIElmIG1pbmltdW1TdGVwIGlzIHByb3ZpZGVkLCB0aGUgc3RlcCBzaXplIGlzIGNob3NlbiBhcyBjbG9zZSBhcyBwb3NzaWJsZVxuICAgKiB0byB0aGUgbWluaW11bVN0ZXAgYnV0IGxhcmdlciB0aGFuIG1pbmltdW1TdGVwLiBJZiBtaW5pbXVtU3RlcCBpcyBub3RcbiAgICogcHJvdmlkZWQsIHRoZSBzY2FsZSBpcyBzZXQgdG8gMSBEQVkuXG4gICAqIFRoZSBtaW5pbXVtU3RlcCBzaG91bGQgY29ycmVzcG9uZCB3aXRoIHRoZSBvbnNjcmVlbiBzaXplIG9mIGFib3V0IDYgY2hhcmFjdGVyc1xuICAgKiBAcGFyYW0ge0RhdGV9IFtzdGFydF0gICAgICBUaGUgc3RhcnQgZGF0ZSBhbmQgdGltZS5cbiAgICogQHBhcmFtIHtEYXRlfSBbZW5kXSAgICAgICAgVGhlIGVuZCBkYXRlIGFuZCB0aW1lLlxuICAgKiBAcGFyYW0ge2ludH0gW21pbmltdW1TdGVwXSBPcHRpb25hbC4gTWluaW11bSBzdGVwIHNpemUgaW4gbWlsbGlzZWNvbmRzXG4gICAqL1xuICBUaW1lU3RlcC5wcm90b3R5cGUuc2V0UmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgbWluaW11bVN0ZXApIHtcbiAgICBpZiAoIShzdGFydCBpbnN0YW5jZW9mIERhdGUpIHx8ICEoZW5kIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgIHRocm93IFwiTm8gbGVnYWwgc3RhcnQgb3IgZW5kIGRhdGUgaW4gbWV0aG9kIHNldFJhbmdlXCI7XG4gICAgfVxuXG4gICAgdGhpcy5fc3RhcnQgPSBzdGFydCAhPSB1bmRlZmluZWQgPyB0aGlzLm1vbWVudChzdGFydC52YWx1ZU9mKCkpIDogbmV3IERhdGUoKTtcbiAgICB0aGlzLl9lbmQgPSBlbmQgIT0gdW5kZWZpbmVkID8gdGhpcy5tb21lbnQoZW5kLnZhbHVlT2YoKSkgOiBuZXcgRGF0ZSgpO1xuXG4gICAgaWYgKHRoaXMuYXV0b1NjYWxlKSB7XG4gICAgICB0aGlzLnNldE1pbmltdW1TdGVwKG1pbmltdW1TdGVwKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcmFuZ2UgaXRlcmF0b3IgdG8gdGhlIHN0YXJ0IGRhdGUuXG4gICAqL1xuICBUaW1lU3RlcC5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jdXJyZW50ID0gdGhpcy5fc3RhcnQuY2xvbmUoKTtcbiAgICB0aGlzLnJvdW5kVG9NaW5vcigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSb3VuZCB0aGUgY3VycmVudCBkYXRlIHRvIHRoZSBmaXJzdCBtaW5vciBkYXRlIHZhbHVlXG4gICAqIFRoaXMgbXVzdCBiZSBleGVjdXRlZCBvbmNlIHdoZW4gdGhlIGN1cnJlbnQgZGF0ZSBpcyBzZXQgdG8gc3RhcnQgRGF0ZVxuICAgKi9cbiAgVGltZVN0ZXAucHJvdG90eXBlLnJvdW5kVG9NaW5vciA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyByb3VuZCB0byBmbG9vclxuICAgIC8vIElNUE9SVEFOVDogd2UgaGF2ZSBubyBicmVha3MgaW4gdGhpcyBzd2l0Y2ghICh0aGlzIGlzIG5vIGJ1ZylcbiAgICAvLyBub2luc3BlY3Rpb24gRmFsbFRocm91Z2hJblN3aXRjaFN0YXRlbWVudEpTXG4gICAgc3dpdGNoICh0aGlzLnNjYWxlKSB7XG4gICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgdGhpcy5jdXJyZW50LnllYXIodGhpcy5zdGVwICogTWF0aC5mbG9vcih0aGlzLmN1cnJlbnQueWVhcigpIC8gdGhpcy5zdGVwKSk7XG4gICAgICAgIHRoaXMuY3VycmVudC5tb250aCgwKTtcbiAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgdGhpcy5jdXJyZW50LmRhdGUoMSk7XG4gICAgICBjYXNlICdkYXknOiAvLyBpbnRlbnRpb25hbCBmYWxsIHRocm91Z2hcbiAgICAgIGNhc2UgJ3dlZWtkYXknOlxuICAgICAgICB0aGlzLmN1cnJlbnQuaG91cnMoMCk7XG4gICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgdGhpcy5jdXJyZW50Lm1pbnV0ZXMoMCk7XG4gICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICB0aGlzLmN1cnJlbnQuc2Vjb25kcygwKTtcbiAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgIHRoaXMuY3VycmVudC5taWxsaXNlY29uZHMoMCk7XG4gICAgICAvL2Nhc2UgJ21pbGxpc2Vjb25kJzogLy8gbm90aGluZyB0byBkbyBmb3IgbWlsbGlzZWNvbmRzXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3RlcCAhPSAxKSB7XG4gICAgICAvLyByb3VuZCBkb3duIHRvIHRoZSBmaXJzdCBtaW5vciB2YWx1ZSB0aGF0IGlzIGEgbXVsdGlwbGUgb2YgdGhlIGN1cnJlbnQgc3RlcCBzaXplXG4gICAgICBzd2l0Y2ggKHRoaXMuc2NhbGUpIHtcbiAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgICAgICAgIHRoaXMuY3VycmVudC5zdWJ0cmFjdCh0aGlzLmN1cnJlbnQubWlsbGlzZWNvbmRzKCkgJSB0aGlzLnN0ZXAsICdtaWxsaXNlY29uZHMnKTticmVhaztcbiAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuc3VidHJhY3QodGhpcy5jdXJyZW50LnNlY29uZHMoKSAlIHRoaXMuc3RlcCwgJ3NlY29uZHMnKTticmVhaztcbiAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuc3VidHJhY3QodGhpcy5jdXJyZW50Lm1pbnV0ZXMoKSAlIHRoaXMuc3RlcCwgJ21pbnV0ZXMnKTticmVhaztcbiAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgdGhpcy5jdXJyZW50LnN1YnRyYWN0KHRoaXMuY3VycmVudC5ob3VycygpICUgdGhpcy5zdGVwLCAnaG91cnMnKTticmVhaztcbiAgICAgICAgY2FzZSAnd2Vla2RheSc6IC8vIGludGVudGlvbmFsIGZhbGwgdGhyb3VnaFxuICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgIHRoaXMuY3VycmVudC5zdWJ0cmFjdCgodGhpcy5jdXJyZW50LmRhdGUoKSAtIDEpICUgdGhpcy5zdGVwLCAnZGF5Jyk7YnJlYWs7XG4gICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuc3VidHJhY3QodGhpcy5jdXJyZW50Lm1vbnRoKCkgJSB0aGlzLnN0ZXAsICdtb250aCcpO2JyZWFrO1xuICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuc3VidHJhY3QodGhpcy5jdXJyZW50LnllYXIoKSAlIHRoaXMuc3RlcCwgJ3llYXInKTticmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSB0aGVyZSBpcyBhIG5leHQgc3RlcFxuICAgKiBAcmV0dXJuIHtib29sZWFufSAgdHJ1ZSBpZiB0aGUgY3VycmVudCBkYXRlIGhhcyBub3QgcGFzc2VkIHRoZSBlbmQgZGF0ZVxuICAgKi9cbiAgVGltZVN0ZXAucHJvdG90eXBlLmhhc05leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudC52YWx1ZU9mKCkgPD0gdGhpcy5fZW5kLnZhbHVlT2YoKTtcbiAgfTtcblxuICAvKipcbiAgICogRG8gdGhlIG5leHQgc3RlcFxuICAgKi9cbiAgVGltZVN0ZXAucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByZXYgPSB0aGlzLmN1cnJlbnQudmFsdWVPZigpO1xuXG4gICAgLy8gVHdvIGNhc2VzLCBuZWVkZWQgdG8gcHJldmVudCBpc3N1ZXMgd2l0aCBzd2l0Y2hpbmcgZGF5bGlnaHQgc2F2aW5nc1xuICAgIC8vIChlbmQgb2YgTWFyY2ggYW5kIGVuZCBvZiBPY3RvYmVyKVxuICAgIGlmICh0aGlzLmN1cnJlbnQubW9udGgoKSA8IDYpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5zY2FsZSkge1xuICAgICAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgICAgICAgdGhpcy5jdXJyZW50LmFkZCh0aGlzLnN0ZXAsICdtaWxsaXNlY29uZCcpO2JyZWFrO1xuICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgIHRoaXMuY3VycmVudC5hZGQodGhpcy5zdGVwLCAnc2Vjb25kJyk7YnJlYWs7XG4gICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgdGhpcy5jdXJyZW50LmFkZCh0aGlzLnN0ZXAsICdtaW51dGUnKTticmVhaztcbiAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgdGhpcy5jdXJyZW50LmFkZCh0aGlzLnN0ZXAsICdob3VyJyk7XG4gICAgICAgICAgLy8gaW4gY2FzZSBvZiBza2lwcGluZyBhbiBob3VyIGZvciBkYXlsaWdodCBzYXZpbmdzLCBhZGp1c3QgdGhlIGhvdXIgYWdhaW4gKGVsc2UgeW91IGdldDogMGggNWggOWggLi4uIGluc3RlYWQgb2YgMGggNGggOGggLi4uKVxuICAgICAgICAgIC8vIFRPRE86IGlzIHRoaXMgc3RpbGwgbmVlZGVkIG5vdyB3ZSB1c2UgdGhlIGZ1bmN0aW9uIG9mIG1vbWVudC5qcz9cbiAgICAgICAgICB0aGlzLmN1cnJlbnQuc3VidHJhY3QodGhpcy5jdXJyZW50LmhvdXJzKCkgJSB0aGlzLnN0ZXAsICdob3VyJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3dlZWtkYXknOiAvLyBpbnRlbnRpb25hbCBmYWxsIHRocm91Z2hcbiAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuYWRkKHRoaXMuc3RlcCwgJ2RheScpO2JyZWFrO1xuICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgdGhpcy5jdXJyZW50LmFkZCh0aGlzLnN0ZXAsICdtb250aCcpO2JyZWFrO1xuICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuYWRkKHRoaXMuc3RlcCwgJ3llYXInKTticmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoICh0aGlzLnNjYWxlKSB7XG4gICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuYWRkKHRoaXMuc3RlcCwgJ21pbGxpc2Vjb25kJyk7YnJlYWs7XG4gICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgdGhpcy5jdXJyZW50LmFkZCh0aGlzLnN0ZXAsICdzZWNvbmQnKTticmVhaztcbiAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuYWRkKHRoaXMuc3RlcCwgJ21pbnV0ZScpO2JyZWFrO1xuICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuYWRkKHRoaXMuc3RlcCwgJ2hvdXInKTticmVhaztcbiAgICAgICAgY2FzZSAnd2Vla2RheSc6IC8vIGludGVudGlvbmFsIGZhbGwgdGhyb3VnaFxuICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgIHRoaXMuY3VycmVudC5hZGQodGhpcy5zdGVwLCAnZGF5Jyk7YnJlYWs7XG4gICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuYWRkKHRoaXMuc3RlcCwgJ21vbnRoJyk7YnJlYWs7XG4gICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgIHRoaXMuY3VycmVudC5hZGQodGhpcy5zdGVwLCAneWVhcicpO2JyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnN0ZXAgIT0gMSkge1xuICAgICAgLy8gcm91bmQgZG93biB0byB0aGUgY29ycmVjdCBtYWpvciB2YWx1ZVxuICAgICAgc3dpdGNoICh0aGlzLnNjYWxlKSB7XG4gICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICAgICAgICBpZiAodGhpcy5jdXJyZW50Lm1pbGxpc2Vjb25kcygpIDwgdGhpcy5zdGVwKSB0aGlzLmN1cnJlbnQubWlsbGlzZWNvbmRzKDApO2JyZWFrO1xuICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnQuc2Vjb25kcygpIDwgdGhpcy5zdGVwKSB0aGlzLmN1cnJlbnQuc2Vjb25kcygwKTticmVhaztcbiAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICBpZiAodGhpcy5jdXJyZW50Lm1pbnV0ZXMoKSA8IHRoaXMuc3RlcCkgdGhpcy5jdXJyZW50Lm1pbnV0ZXMoMCk7YnJlYWs7XG4gICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnQuaG91cnMoKSA8IHRoaXMuc3RlcCkgdGhpcy5jdXJyZW50LmhvdXJzKDApO2JyZWFrO1xuICAgICAgICBjYXNlICd3ZWVrZGF5JzogLy8gaW50ZW50aW9uYWwgZmFsbCB0aHJvdWdoXG4gICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgaWYgKHRoaXMuY3VycmVudC5kYXRlKCkgPCB0aGlzLnN0ZXAgKyAxKSB0aGlzLmN1cnJlbnQuZGF0ZSgxKTticmVhaztcbiAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnQubW9udGgoKSA8IHRoaXMuc3RlcCkgdGhpcy5jdXJyZW50Lm1vbnRoKDApO2JyZWFrO1xuICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICBicmVhazsgLy8gbm90aGluZyB0byBkbyBmb3IgeWVhclxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNhZmV0eSBtZWNoYW5pc206IGlmIGN1cnJlbnQgdGltZSBpcyBzdGlsbCB1bmNoYW5nZWQsIG1vdmUgdG8gdGhlIGVuZFxuICAgIGlmICh0aGlzLmN1cnJlbnQudmFsdWVPZigpID09IHByZXYpIHtcbiAgICAgIHRoaXMuY3VycmVudCA9IHRoaXMuX2VuZC5jbG9uZSgpO1xuICAgIH1cblxuICAgIERhdGVVdGlsLnN0ZXBPdmVySGlkZGVuRGF0ZXModGhpcy5tb21lbnQsIHRoaXMsIHByZXYpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgZGF0ZXRpbWVcbiAgICogQHJldHVybiB7TW9tZW50fSAgY3VycmVudCBUaGUgY3VycmVudCBkYXRlXG4gICAqL1xuICBUaW1lU3RlcC5wcm90b3R5cGUuZ2V0Q3VycmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgYSBjdXN0b20gc2NhbGUuIEF1dG9zY2FsaW5nIHdpbGwgYmUgZGlzYWJsZWQuXG4gICAqIEZvciBleGFtcGxlIHNldFNjYWxlKCdtaW51dGUnLCA1KSB3aWxsIHJlc3VsdFxuICAgKiBpbiBtaW5vciBzdGVwcyBvZiA1IG1pbnV0ZXMsIGFuZCBtYWpvciBzdGVwcyBvZiBhbiBob3VyLlxuICAgKlxuICAgKiBAcGFyYW0ge3tzY2FsZTogc3RyaW5nLCBzdGVwOiBudW1iZXJ9fSBwYXJhbXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdHdvIHByb3BlcnRpZXM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gQSBzdHJpbmcgJ3NjYWxlJy4gQ2hvb3NlIGZyb20gJ21pbGxpc2Vjb25kJywgJ3NlY29uZCcsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ21pbnV0ZScsICdob3VyJywgJ3dlZWtkYXknLCAnZGF5JywgJ21vbnRoJywgJ3llYXInLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIEEgbnVtYmVyICdzdGVwJy4gQSBzdGVwIHNpemUsIGJ5IGRlZmF1bHQgMS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDaG9vc2UgZm9yIGV4YW1wbGUgMSwgMiwgNSwgb3IgMTAuXG4gICAqL1xuICBUaW1lU3RlcC5wcm90b3R5cGUuc2V0U2NhbGUgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgaWYgKHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zLnNjYWxlID09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLnNjYWxlID0gcGFyYW1zLnNjYWxlO1xuICAgICAgdGhpcy5zdGVwID0gcGFyYW1zLnN0ZXAgPiAwID8gcGFyYW1zLnN0ZXAgOiAxO1xuICAgICAgdGhpcy5hdXRvU2NhbGUgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEVuYWJsZSBvciBkaXNhYmxlIGF1dG9zY2FsaW5nXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlICBJZiB0cnVlLCBhdXRvYXNjYWxpbmcgaXMgc2V0IHRydWVcbiAgICovXG4gIFRpbWVTdGVwLnByb3RvdHlwZS5zZXRBdXRvU2NhbGUgPSBmdW5jdGlvbiAoZW5hYmxlKSB7XG4gICAgdGhpcy5hdXRvU2NhbGUgPSBlbmFibGU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEF1dG9tYXRpY2FsbHkgZGV0ZXJtaW5lIHRoZSBzY2FsZSB0aGF0IGJlc3RzIGZpdHMgdGhlIHByb3ZpZGVkIG1pbmltdW0gc3RlcFxuICAgKiBAcGFyYW0ge051bWJlcn0gW21pbmltdW1TdGVwXSAgVGhlIG1pbmltdW0gc3RlcCBzaXplIGluIG1pbGxpc2Vjb25kc1xuICAgKi9cbiAgVGltZVN0ZXAucHJvdG90eXBlLnNldE1pbmltdW1TdGVwID0gZnVuY3Rpb24gKG1pbmltdW1TdGVwKSB7XG4gICAgaWYgKG1pbmltdW1TdGVwID09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vdmFyIGIgPSBhc2MgKyBkcztcblxuICAgIHZhciBzdGVwWWVhciA9IDEwMDAgKiA2MCAqIDYwICogMjQgKiAzMCAqIDEyO1xuICAgIHZhciBzdGVwTW9udGggPSAxMDAwICogNjAgKiA2MCAqIDI0ICogMzA7XG4gICAgdmFyIHN0ZXBEYXkgPSAxMDAwICogNjAgKiA2MCAqIDI0O1xuICAgIHZhciBzdGVwSG91ciA9IDEwMDAgKiA2MCAqIDYwO1xuICAgIHZhciBzdGVwTWludXRlID0gMTAwMCAqIDYwO1xuICAgIHZhciBzdGVwU2Vjb25kID0gMTAwMDtcbiAgICB2YXIgc3RlcE1pbGxpc2Vjb25kID0gMTtcblxuICAgIC8vIGZpbmQgdGhlIHNtYWxsZXN0IHN0ZXAgdGhhdCBpcyBsYXJnZXIgdGhhbiB0aGUgcHJvdmlkZWQgbWluaW11bVN0ZXBcbiAgICBpZiAoc3RlcFllYXIgKiAxMDAwID4gbWluaW11bVN0ZXApIHtcbiAgICAgIHRoaXMuc2NhbGUgPSAneWVhcic7dGhpcy5zdGVwID0gMTAwMDtcbiAgICB9XG4gICAgaWYgKHN0ZXBZZWFyICogNTAwID4gbWluaW11bVN0ZXApIHtcbiAgICAgIHRoaXMuc2NhbGUgPSAneWVhcic7dGhpcy5zdGVwID0gNTAwO1xuICAgIH1cbiAgICBpZiAoc3RlcFllYXIgKiAxMDAgPiBtaW5pbXVtU3RlcCkge1xuICAgICAgdGhpcy5zY2FsZSA9ICd5ZWFyJzt0aGlzLnN0ZXAgPSAxMDA7XG4gICAgfVxuICAgIGlmIChzdGVwWWVhciAqIDUwID4gbWluaW11bVN0ZXApIHtcbiAgICAgIHRoaXMuc2NhbGUgPSAneWVhcic7dGhpcy5zdGVwID0gNTA7XG4gICAgfVxuICAgIGlmIChzdGVwWWVhciAqIDEwID4gbWluaW11bVN0ZXApIHtcbiAgICAgIHRoaXMuc2NhbGUgPSAneWVhcic7dGhpcy5zdGVwID0gMTA7XG4gICAgfVxuICAgIGlmIChzdGVwWWVhciAqIDUgPiBtaW5pbXVtU3RlcCkge1xuICAgICAgdGhpcy5zY2FsZSA9ICd5ZWFyJzt0aGlzLnN0ZXAgPSA1O1xuICAgIH1cbiAgICBpZiAoc3RlcFllYXIgPiBtaW5pbXVtU3RlcCkge1xuICAgICAgdGhpcy5zY2FsZSA9ICd5ZWFyJzt0aGlzLnN0ZXAgPSAxO1xuICAgIH1cbiAgICBpZiAoc3RlcE1vbnRoICogMyA+IG1pbmltdW1TdGVwKSB7XG4gICAgICB0aGlzLnNjYWxlID0gJ21vbnRoJzt0aGlzLnN0ZXAgPSAzO1xuICAgIH1cbiAgICBpZiAoc3RlcE1vbnRoID4gbWluaW11bVN0ZXApIHtcbiAgICAgIHRoaXMuc2NhbGUgPSAnbW9udGgnO3RoaXMuc3RlcCA9IDE7XG4gICAgfVxuICAgIGlmIChzdGVwRGF5ICogNSA+IG1pbmltdW1TdGVwKSB7XG4gICAgICB0aGlzLnNjYWxlID0gJ2RheSc7dGhpcy5zdGVwID0gNTtcbiAgICB9XG4gICAgaWYgKHN0ZXBEYXkgKiAyID4gbWluaW11bVN0ZXApIHtcbiAgICAgIHRoaXMuc2NhbGUgPSAnZGF5Jzt0aGlzLnN0ZXAgPSAyO1xuICAgIH1cbiAgICBpZiAoc3RlcERheSA+IG1pbmltdW1TdGVwKSB7XG4gICAgICB0aGlzLnNjYWxlID0gJ2RheSc7dGhpcy5zdGVwID0gMTtcbiAgICB9XG4gICAgaWYgKHN0ZXBEYXkgLyAyID4gbWluaW11bVN0ZXApIHtcbiAgICAgIHRoaXMuc2NhbGUgPSAnd2Vla2RheSc7dGhpcy5zdGVwID0gMTtcbiAgICB9XG4gICAgaWYgKHN0ZXBIb3VyICogNCA+IG1pbmltdW1TdGVwKSB7XG4gICAgICB0aGlzLnNjYWxlID0gJ2hvdXInO3RoaXMuc3RlcCA9IDQ7XG4gICAgfVxuICAgIGlmIChzdGVwSG91ciA+IG1pbmltdW1TdGVwKSB7XG4gICAgICB0aGlzLnNjYWxlID0gJ2hvdXInO3RoaXMuc3RlcCA9IDE7XG4gICAgfVxuICAgIGlmIChzdGVwTWludXRlICogMTUgPiBtaW5pbXVtU3RlcCkge1xuICAgICAgdGhpcy5zY2FsZSA9ICdtaW51dGUnO3RoaXMuc3RlcCA9IDE1O1xuICAgIH1cbiAgICBpZiAoc3RlcE1pbnV0ZSAqIDEwID4gbWluaW11bVN0ZXApIHtcbiAgICAgIHRoaXMuc2NhbGUgPSAnbWludXRlJzt0aGlzLnN0ZXAgPSAxMDtcbiAgICB9XG4gICAgaWYgKHN0ZXBNaW51dGUgKiA1ID4gbWluaW11bVN0ZXApIHtcbiAgICAgIHRoaXMuc2NhbGUgPSAnbWludXRlJzt0aGlzLnN0ZXAgPSA1O1xuICAgIH1cbiAgICBpZiAoc3RlcE1pbnV0ZSA+IG1pbmltdW1TdGVwKSB7XG4gICAgICB0aGlzLnNjYWxlID0gJ21pbnV0ZSc7dGhpcy5zdGVwID0gMTtcbiAgICB9XG4gICAgaWYgKHN0ZXBTZWNvbmQgKiAxNSA+IG1pbmltdW1TdGVwKSB7XG4gICAgICB0aGlzLnNjYWxlID0gJ3NlY29uZCc7dGhpcy5zdGVwID0gMTU7XG4gICAgfVxuICAgIGlmIChzdGVwU2Vjb25kICogMTAgPiBtaW5pbXVtU3RlcCkge1xuICAgICAgdGhpcy5zY2FsZSA9ICdzZWNvbmQnO3RoaXMuc3RlcCA9IDEwO1xuICAgIH1cbiAgICBpZiAoc3RlcFNlY29uZCAqIDUgPiBtaW5pbXVtU3RlcCkge1xuICAgICAgdGhpcy5zY2FsZSA9ICdzZWNvbmQnO3RoaXMuc3RlcCA9IDU7XG4gICAgfVxuICAgIGlmIChzdGVwU2Vjb25kID4gbWluaW11bVN0ZXApIHtcbiAgICAgIHRoaXMuc2NhbGUgPSAnc2Vjb25kJzt0aGlzLnN0ZXAgPSAxO1xuICAgIH1cbiAgICBpZiAoc3RlcE1pbGxpc2Vjb25kICogMjAwID4gbWluaW11bVN0ZXApIHtcbiAgICAgIHRoaXMuc2NhbGUgPSAnbWlsbGlzZWNvbmQnO3RoaXMuc3RlcCA9IDIwMDtcbiAgICB9XG4gICAgaWYgKHN0ZXBNaWxsaXNlY29uZCAqIDEwMCA+IG1pbmltdW1TdGVwKSB7XG4gICAgICB0aGlzLnNjYWxlID0gJ21pbGxpc2Vjb25kJzt0aGlzLnN0ZXAgPSAxMDA7XG4gICAgfVxuICAgIGlmIChzdGVwTWlsbGlzZWNvbmQgKiA1MCA+IG1pbmltdW1TdGVwKSB7XG4gICAgICB0aGlzLnNjYWxlID0gJ21pbGxpc2Vjb25kJzt0aGlzLnN0ZXAgPSA1MDtcbiAgICB9XG4gICAgaWYgKHN0ZXBNaWxsaXNlY29uZCAqIDEwID4gbWluaW11bVN0ZXApIHtcbiAgICAgIHRoaXMuc2NhbGUgPSAnbWlsbGlzZWNvbmQnO3RoaXMuc3RlcCA9IDEwO1xuICAgIH1cbiAgICBpZiAoc3RlcE1pbGxpc2Vjb25kICogNSA+IG1pbmltdW1TdGVwKSB7XG4gICAgICB0aGlzLnNjYWxlID0gJ21pbGxpc2Vjb25kJzt0aGlzLnN0ZXAgPSA1O1xuICAgIH1cbiAgICBpZiAoc3RlcE1pbGxpc2Vjb25kID4gbWluaW11bVN0ZXApIHtcbiAgICAgIHRoaXMuc2NhbGUgPSAnbWlsbGlzZWNvbmQnO3RoaXMuc3RlcCA9IDE7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTbmFwIGEgZGF0ZSB0byBhIHJvdW5kZWQgdmFsdWUuXG4gICAqIFRoZSBzbmFwIGludGVydmFscyBhcmUgZGVwZW5kZW50IG9uIHRoZSBjdXJyZW50IHNjYWxlIGFuZCBzdGVwLlxuICAgKiBTdGF0aWMgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtEYXRlfSBkYXRlICAgIHRoZSBkYXRlIHRvIGJlIHNuYXBwZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzY2FsZSBDdXJyZW50IHNjYWxlLCBjYW4gYmUgJ21pbGxpc2Vjb25kJywgJ3NlY29uZCcsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAnbWludXRlJywgJ2hvdXInLCAnd2Vla2RheSwgJ2RheScsICdtb250aCcsICd5ZWFyJy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0ZXAgIEN1cnJlbnQgc3RlcCAoMSwgMiwgNCwgNSwgLi4uXG4gICAqIEByZXR1cm4ge0RhdGV9IHNuYXBwZWREYXRlXG4gICAqL1xuICBUaW1lU3RlcC5zbmFwID0gZnVuY3Rpb24gKGRhdGUsIHNjYWxlLCBzdGVwKSB7XG4gICAgdmFyIGNsb25lID0gbW9tZW50KGRhdGUpO1xuXG4gICAgaWYgKHNjYWxlID09ICd5ZWFyJykge1xuICAgICAgdmFyIHllYXIgPSBjbG9uZS55ZWFyKCkgKyBNYXRoLnJvdW5kKGNsb25lLm1vbnRoKCkgLyAxMik7XG4gICAgICBjbG9uZS55ZWFyKE1hdGgucm91bmQoeWVhciAvIHN0ZXApICogc3RlcCk7XG4gICAgICBjbG9uZS5tb250aCgwKTtcbiAgICAgIGNsb25lLmRhdGUoMCk7XG4gICAgICBjbG9uZS5ob3VycygwKTtcbiAgICAgIGNsb25lLm1pbnV0ZXMoMCk7XG4gICAgICBjbG9uZS5zZWNvbmRzKDApO1xuICAgICAgY2xvbmUubWlsbGlzZWNvbmRzKDApO1xuICAgIH0gZWxzZSBpZiAoc2NhbGUgPT0gJ21vbnRoJykge1xuICAgICAgaWYgKGNsb25lLmRhdGUoKSA+IDE1KSB7XG4gICAgICAgIGNsb25lLmRhdGUoMSk7XG4gICAgICAgIGNsb25lLmFkZCgxLCAnbW9udGgnKTtcbiAgICAgICAgLy8gaW1wb3J0YW50OiBmaXJzdCBzZXQgRGF0ZSB0byAxLCBhZnRlciB0aGF0IGNoYW5nZSB0aGUgbW9udGguXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsb25lLmRhdGUoMSk7XG4gICAgICAgIH1cblxuICAgICAgY2xvbmUuaG91cnMoMCk7XG4gICAgICBjbG9uZS5taW51dGVzKDApO1xuICAgICAgY2xvbmUuc2Vjb25kcygwKTtcbiAgICAgIGNsb25lLm1pbGxpc2Vjb25kcygwKTtcbiAgICB9IGVsc2UgaWYgKHNjYWxlID09ICdkYXknKSB7XG4gICAgICAvL25vaW5zcGVjdGlvbiBGYWxsdGhyb3VnaEluU3dpdGNoU3RhdGVtZW50SlNcbiAgICAgIHN3aXRjaCAoc3RlcCkge1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBjbG9uZS5ob3VycyhNYXRoLnJvdW5kKGNsb25lLmhvdXJzKCkgLyAyNCkgKiAyNCk7YnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY2xvbmUuaG91cnMoTWF0aC5yb3VuZChjbG9uZS5ob3VycygpIC8gMTIpICogMTIpO2JyZWFrO1xuICAgICAgfVxuICAgICAgY2xvbmUubWludXRlcygwKTtcbiAgICAgIGNsb25lLnNlY29uZHMoMCk7XG4gICAgICBjbG9uZS5taWxsaXNlY29uZHMoMCk7XG4gICAgfSBlbHNlIGlmIChzY2FsZSA9PSAnd2Vla2RheScpIHtcbiAgICAgIC8vbm9pbnNwZWN0aW9uIEZhbGx0aHJvdWdoSW5Td2l0Y2hTdGF0ZW1lbnRKU1xuICAgICAgc3dpdGNoIChzdGVwKSB7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGNsb25lLmhvdXJzKE1hdGgucm91bmQoY2xvbmUuaG91cnMoKSAvIDEyKSAqIDEyKTticmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjbG9uZS5ob3VycyhNYXRoLnJvdW5kKGNsb25lLmhvdXJzKCkgLyA2KSAqIDYpO2JyZWFrO1xuICAgICAgfVxuICAgICAgY2xvbmUubWludXRlcygwKTtcbiAgICAgIGNsb25lLnNlY29uZHMoMCk7XG4gICAgICBjbG9uZS5taWxsaXNlY29uZHMoMCk7XG4gICAgfSBlbHNlIGlmIChzY2FsZSA9PSAnaG91cicpIHtcbiAgICAgIHN3aXRjaCAoc3RlcCkge1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgY2xvbmUubWludXRlcyhNYXRoLnJvdW5kKGNsb25lLm1pbnV0ZXMoKSAvIDYwKSAqIDYwKTticmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjbG9uZS5taW51dGVzKE1hdGgucm91bmQoY2xvbmUubWludXRlcygpIC8gMzApICogMzApO2JyZWFrO1xuICAgICAgfVxuICAgICAgY2xvbmUuc2Vjb25kcygwKTtcbiAgICAgIGNsb25lLm1pbGxpc2Vjb25kcygwKTtcbiAgICB9IGVsc2UgaWYgKHNjYWxlID09ICdtaW51dGUnKSB7XG4gICAgICAvL25vaW5zcGVjdGlvbiBGYWxsdGhyb3VnaEluU3dpdGNoU3RhdGVtZW50SlNcbiAgICAgIHN3aXRjaCAoc3RlcCkge1xuICAgICAgICBjYXNlIDE1OlxuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIGNsb25lLm1pbnV0ZXMoTWF0aC5yb3VuZChjbG9uZS5taW51dGVzKCkgLyA1KSAqIDUpO1xuICAgICAgICAgIGNsb25lLnNlY29uZHMoMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBjbG9uZS5zZWNvbmRzKE1hdGgucm91bmQoY2xvbmUuc2Vjb25kcygpIC8gNjApICogNjApO2JyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNsb25lLnNlY29uZHMoTWF0aC5yb3VuZChjbG9uZS5zZWNvbmRzKCkgLyAzMCkgKiAzMCk7YnJlYWs7XG4gICAgICB9XG4gICAgICBjbG9uZS5taWxsaXNlY29uZHMoMCk7XG4gICAgfSBlbHNlIGlmIChzY2FsZSA9PSAnc2Vjb25kJykge1xuICAgICAgLy9ub2luc3BlY3Rpb24gRmFsbHRocm91Z2hJblN3aXRjaFN0YXRlbWVudEpTXG4gICAgICBzd2l0Y2ggKHN0ZXApIHtcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICBjbG9uZS5zZWNvbmRzKE1hdGgucm91bmQoY2xvbmUuc2Vjb25kcygpIC8gNSkgKiA1KTtcbiAgICAgICAgICBjbG9uZS5taWxsaXNlY29uZHMoMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBjbG9uZS5taWxsaXNlY29uZHMoTWF0aC5yb3VuZChjbG9uZS5taWxsaXNlY29uZHMoKSAvIDEwMDApICogMTAwMCk7YnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY2xvbmUubWlsbGlzZWNvbmRzKE1hdGgucm91bmQoY2xvbmUubWlsbGlzZWNvbmRzKCkgLyA1MDApICogNTAwKTticmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNjYWxlID09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgIHZhciBfc3RlcCA9IHN0ZXAgPiA1ID8gc3RlcCAvIDIgOiAxO1xuICAgICAgY2xvbmUubWlsbGlzZWNvbmRzKE1hdGgucm91bmQoY2xvbmUubWlsbGlzZWNvbmRzKCkgLyBfc3RlcCkgKiBfc3RlcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgY3VycmVudCB2YWx1ZSBpcyBhIG1ham9yIHZhbHVlIChmb3IgZXhhbXBsZSB3aGVuIHRoZSBzdGVwXG4gICAqIGlzIERBWSwgYSBtYWpvciB2YWx1ZSBpcyBlYWNoIGZpcnN0IGRheSBvZiB0aGUgTU9OVEgpXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgY3VycmVudCBkYXRlIGlzIG1ham9yLCBlbHNlIGZhbHNlLlxuICAgKi9cbiAgVGltZVN0ZXAucHJvdG90eXBlLmlzTWFqb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuc3dpdGNoZWRZZWFyID09IHRydWUpIHtcbiAgICAgIHRoaXMuc3dpdGNoZWRZZWFyID0gZmFsc2U7XG4gICAgICBzd2l0Y2ggKHRoaXMuc2NhbGUpIHtcbiAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgY2FzZSAnd2Vla2RheSc6XG4gICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5zd2l0Y2hlZE1vbnRoID09IHRydWUpIHtcbiAgICAgIHRoaXMuc3dpdGNoZWRNb250aCA9IGZhbHNlO1xuICAgICAgc3dpdGNoICh0aGlzLnNjYWxlKSB7XG4gICAgICAgIGNhc2UgJ3dlZWtkYXknOlxuICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuc3dpdGNoZWREYXkgPT0gdHJ1ZSkge1xuICAgICAgdGhpcy5zd2l0Y2hlZERheSA9IGZhbHNlO1xuICAgICAgc3dpdGNoICh0aGlzLnNjYWxlKSB7XG4gICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkYXRlID0gdGhpcy5tb21lbnQodGhpcy5jdXJyZW50KTtcbiAgICBzd2l0Y2ggKHRoaXMuc2NhbGUpIHtcbiAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICAgICAgcmV0dXJuIGRhdGUubWlsbGlzZWNvbmRzKCkgPT0gMDtcbiAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgIHJldHVybiBkYXRlLnNlY29uZHMoKSA9PSAwO1xuICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgcmV0dXJuIGRhdGUuaG91cnMoKSA9PSAwICYmIGRhdGUubWludXRlcygpID09IDA7XG4gICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgcmV0dXJuIGRhdGUuaG91cnMoKSA9PSAwO1xuICAgICAgY2FzZSAnd2Vla2RheSc6IC8vIGludGVudGlvbmFsIGZhbGwgdGhyb3VnaFxuICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgcmV0dXJuIGRhdGUuZGF0ZSgpID09IDE7XG4gICAgICBjYXNlICdtb250aCc6XG4gICAgICAgIHJldHVybiBkYXRlLm1vbnRoKCkgPT0gMDtcbiAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZvcm1hdHRlZCB0ZXh0IGZvciB0aGUgbWlub3IgYXhpc2xhYmVsLCBkZXBlbmRpbmcgb24gdGhlIGN1cnJlbnRcbiAgICogZGF0ZSBhbmQgdGhlIHNjYWxlLiBGb3IgZXhhbXBsZSB3aGVuIHNjYWxlIGlzIE1JTlVURSwgdGhlIGN1cnJlbnQgdGltZSBpc1xuICAgKiBmb3JtYXR0ZWQgYXMgXCJoaDptbVwiLlxuICAgKiBAcGFyYW0ge0RhdGV9IFtkYXRlXSBjdXN0b20gZGF0ZS4gaWYgbm90IHByb3ZpZGVkLCBjdXJyZW50IGRhdGUgaXMgdGFrZW5cbiAgICovXG4gIFRpbWVTdGVwLnByb3RvdHlwZS5nZXRMYWJlbE1pbm9yID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICBpZiAoZGF0ZSA9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRhdGUgPSB0aGlzLmN1cnJlbnQ7XG4gICAgfVxuXG4gICAgdmFyIGZvcm1hdCA9IHRoaXMuZm9ybWF0Lm1pbm9yTGFiZWxzW3RoaXMuc2NhbGVdO1xuICAgIHJldHVybiBmb3JtYXQgJiYgZm9ybWF0Lmxlbmd0aCA+IDAgPyB0aGlzLm1vbWVudChkYXRlKS5mb3JtYXQoZm9ybWF0KSA6ICcnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZvcm1hdHRlZCB0ZXh0IGZvciB0aGUgbWFqb3IgYXhpcyBsYWJlbCwgZGVwZW5kaW5nIG9uIHRoZSBjdXJyZW50XG4gICAqIGRhdGUgYW5kIHRoZSBzY2FsZS4gRm9yIGV4YW1wbGUgd2hlbiBzY2FsZSBpcyBNSU5VVEUsIHRoZSBtYWpvciBzY2FsZSBpc1xuICAgKiBob3VycywgYW5kIHRoZSBob3VyIHdpbGwgYmUgZm9ybWF0dGVkIGFzIFwiaGhcIi5cbiAgICogQHBhcmFtIHtEYXRlfSBbZGF0ZV0gY3VzdG9tIGRhdGUuIGlmIG5vdCBwcm92aWRlZCwgY3VycmVudCBkYXRlIGlzIHRha2VuXG4gICAqL1xuICBUaW1lU3RlcC5wcm90b3R5cGUuZ2V0TGFiZWxNYWpvciA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgaWYgKGRhdGUgPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkYXRlID0gdGhpcy5jdXJyZW50O1xuICAgIH1cblxuICAgIHZhciBmb3JtYXQgPSB0aGlzLmZvcm1hdC5tYWpvckxhYmVsc1t0aGlzLnNjYWxlXTtcbiAgICByZXR1cm4gZm9ybWF0ICYmIGZvcm1hdC5sZW5ndGggPiAwID8gdGhpcy5tb21lbnQoZGF0ZSkuZm9ybWF0KGZvcm1hdCkgOiAnJztcbiAgfTtcblxuICBUaW1lU3RlcC5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfbW9tZW50ID0gdGhpcy5tb21lbnQ7XG4gICAgdmFyIG0gPSB0aGlzLm1vbWVudCh0aGlzLmN1cnJlbnQpO1xuICAgIHZhciBjdXJyZW50ID0gbS5sb2NhbGUgPyBtLmxvY2FsZSgnZW4nKSA6IG0ubGFuZygnZW4nKTsgLy8gb2xkIHZlcnNpb25zIG9mIG1vbWVudCBoYXZlIC5sYW5nKCkgZnVuY3Rpb25cbiAgICB2YXIgc3RlcCA9IHRoaXMuc3RlcDtcblxuICAgIGZ1bmN0aW9uIGV2ZW4odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAvIHN0ZXAgJSAyID09IDAgPyAnIHZpcy1ldmVuJyA6ICcgdmlzLW9kZCc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9kYXkoZGF0ZSkge1xuICAgICAgaWYgKGRhdGUuaXNTYW1lKG5ldyBEYXRlKCksICdkYXknKSkge1xuICAgICAgICByZXR1cm4gJyB2aXMtdG9kYXknO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGUuaXNTYW1lKF9tb21lbnQoKS5hZGQoMSwgJ2RheScpLCAnZGF5JykpIHtcbiAgICAgICAgcmV0dXJuICcgdmlzLXRvbW9ycm93JztcbiAgICAgIH1cbiAgICAgIGlmIChkYXRlLmlzU2FtZShfbW9tZW50KCkuYWRkKC0xLCAnZGF5JyksICdkYXknKSkge1xuICAgICAgICByZXR1cm4gJyB2aXMteWVzdGVyZGF5JztcbiAgICAgIH1cbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjdXJyZW50V2VlayhkYXRlKSB7XG4gICAgICByZXR1cm4gZGF0ZS5pc1NhbWUobmV3IERhdGUoKSwgJ3dlZWsnKSA/ICcgdmlzLWN1cnJlbnQtd2VlaycgOiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjdXJyZW50TW9udGgoZGF0ZSkge1xuICAgICAgcmV0dXJuIGRhdGUuaXNTYW1lKG5ldyBEYXRlKCksICdtb250aCcpID8gJyB2aXMtY3VycmVudC1tb250aCcgOiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjdXJyZW50WWVhcihkYXRlKSB7XG4gICAgICByZXR1cm4gZGF0ZS5pc1NhbWUobmV3IERhdGUoKSwgJ3llYXInKSA/ICcgdmlzLWN1cnJlbnQteWVhcicgOiAnJztcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRoaXMuc2NhbGUpIHtcbiAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICAgICAgcmV0dXJuIGV2ZW4oY3VycmVudC5taWxsaXNlY29uZHMoKSkudHJpbSgpO1xuXG4gICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICByZXR1cm4gZXZlbihjdXJyZW50LnNlY29uZHMoKSkudHJpbSgpO1xuXG4gICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICByZXR1cm4gZXZlbihjdXJyZW50Lm1pbnV0ZXMoKSkudHJpbSgpO1xuXG4gICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgdmFyIGhvdXJzID0gY3VycmVudC5ob3VycygpO1xuICAgICAgICBpZiAodGhpcy5zdGVwID09IDQpIHtcbiAgICAgICAgICBob3VycyA9IGhvdXJzICsgJy1oJyArIChob3VycyArIDQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAndmlzLWgnICsgaG91cnMgKyB0b2RheShjdXJyZW50KSArIGV2ZW4oY3VycmVudC5ob3VycygpKTtcblxuICAgICAgY2FzZSAnd2Vla2RheSc6XG4gICAgICAgIHJldHVybiAndmlzLScgKyBjdXJyZW50LmZvcm1hdCgnZGRkZCcpLnRvTG93ZXJDYXNlKCkgKyB0b2RheShjdXJyZW50KSArIGN1cnJlbnRXZWVrKGN1cnJlbnQpICsgZXZlbihjdXJyZW50LmRhdGUoKSk7XG5cbiAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgIHZhciBkYXkgPSBjdXJyZW50LmRhdGUoKTtcbiAgICAgICAgdmFyIG1vbnRoID0gY3VycmVudC5mb3JtYXQoJ01NTU0nKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gJ3Zpcy1kYXknICsgZGF5ICsgJyB2aXMtJyArIG1vbnRoICsgY3VycmVudE1vbnRoKGN1cnJlbnQpICsgZXZlbihkYXkgLSAxKTtcblxuICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICByZXR1cm4gJ3Zpcy0nICsgY3VycmVudC5mb3JtYXQoJ01NTU0nKS50b0xvd2VyQ2FzZSgpICsgY3VycmVudE1vbnRoKGN1cnJlbnQpICsgZXZlbihjdXJyZW50Lm1vbnRoKCkpO1xuXG4gICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgdmFyIHllYXIgPSBjdXJyZW50LnllYXIoKTtcbiAgICAgICAgcmV0dXJuICd2aXMteWVhcicgKyB5ZWFyICsgY3VycmVudFllYXIoY3VycmVudCkgKyBldmVuKHllYXIpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gVGltZVN0ZXA7XG5cbi8qKiovIH0sXG4vKiAzNiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbiAgdmFyIHN0YWNrID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNyk7XG4gIHZhciBSYW5nZUl0ZW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KTtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yIEdyb3VwXG4gICAqIEBwYXJhbSB7TnVtYmVyIHwgU3RyaW5nfSBncm91cElkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEBwYXJhbSB7SXRlbVNldH0gaXRlbVNldFxuICAgKi9cbiAgZnVuY3Rpb24gR3JvdXAoZ3JvdXBJZCwgZGF0YSwgaXRlbVNldCkge1xuICAgIHRoaXMuZ3JvdXBJZCA9IGdyb3VwSWQ7XG4gICAgdGhpcy5zdWJncm91cHMgPSB7fTtcbiAgICB0aGlzLnN1Ymdyb3VwSW5kZXggPSAwO1xuICAgIHRoaXMuc3ViZ3JvdXBPcmRlcmVyID0gZGF0YSAmJiBkYXRhLnN1Ymdyb3VwT3JkZXI7XG4gICAgdGhpcy5pdGVtU2V0ID0gaXRlbVNldDtcblxuICAgIHRoaXMuZG9tID0ge307XG4gICAgdGhpcy5wcm9wcyA9IHtcbiAgICAgIGxhYmVsOiB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDBcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuY2xhc3NOYW1lID0gbnVsbDtcblxuICAgIHRoaXMuaXRlbXMgPSB7fTsgLy8gaXRlbXMgZmlsdGVyZWQgYnkgZ3JvdXBJZCBvZiB0aGlzIGdyb3VwXG4gICAgdGhpcy52aXNpYmxlSXRlbXMgPSBbXTsgLy8gaXRlbXMgY3VycmVudGx5IHZpc2libGUgaW4gd2luZG93XG4gICAgdGhpcy5vcmRlcmVkSXRlbXMgPSB7XG4gICAgICBieVN0YXJ0OiBbXSxcbiAgICAgIGJ5RW5kOiBbXVxuICAgIH07XG4gICAgdGhpcy5jaGVja1JhbmdlZEl0ZW1zID0gZmFsc2U7IC8vIG5lZWRlZCB0byByZWZyZXNoIHRoZSByYW5nZWQgaXRlbXMgaWYgdGhlIHdpbmRvdyBpcyBwcm9ncmFtYXRpY2FsbHkgY2hhbmdlZCB3aXRoIE5PIG92ZXJsYXAuXG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB0aGlzLml0ZW1TZXQuYm9keS5lbWl0dGVyLm9uKFwiY2hlY2tSYW5nZWRJdGVtc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBtZS5jaGVja1JhbmdlZEl0ZW1zID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2NyZWF0ZSgpO1xuXG4gICAgdGhpcy5zZXREYXRhKGRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBET00gZWxlbWVudHMgZm9yIHRoZSBncm91cFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgR3JvdXAucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgaWYgKHRoaXMuaXRlbVNldC5vcHRpb25zLmdyb3VwRWRpdGFibGUub3JkZXIpIHtcbiAgICAgIGxhYmVsLmNsYXNzTmFtZSA9ICd2aXMtbGFiZWwgZHJhZ2dhYmxlJztcbiAgICB9IGVsc2Uge1xuICAgICAgbGFiZWwuY2xhc3NOYW1lID0gJ3Zpcy1sYWJlbCc7XG4gICAgfVxuICAgIHRoaXMuZG9tLmxhYmVsID0gbGFiZWw7XG5cbiAgICB2YXIgaW5uZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBpbm5lci5jbGFzc05hbWUgPSAndmlzLWlubmVyJztcbiAgICBsYWJlbC5hcHBlbmRDaGlsZChpbm5lcik7XG4gICAgdGhpcy5kb20uaW5uZXIgPSBpbm5lcjtcblxuICAgIHZhciBmb3JlZ3JvdW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZm9yZWdyb3VuZC5jbGFzc05hbWUgPSAndmlzLWdyb3VwJztcbiAgICBmb3JlZ3JvdW5kWyd0aW1lbGluZS1ncm91cCddID0gdGhpcztcbiAgICB0aGlzLmRvbS5mb3JlZ3JvdW5kID0gZm9yZWdyb3VuZDtcblxuICAgIHRoaXMuZG9tLmJhY2tncm91bmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmRvbS5iYWNrZ3JvdW5kLmNsYXNzTmFtZSA9ICd2aXMtZ3JvdXAnO1xuXG4gICAgdGhpcy5kb20uYXhpcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuZG9tLmF4aXMuY2xhc3NOYW1lID0gJ3Zpcy1ncm91cCc7XG5cbiAgICAvLyBjcmVhdGUgYSBoaWRkZW4gbWFya2VyIHRvIGRldGVjdCB3aGVuIHRoZSBUaW1lbGluZXMgY29udGFpbmVyIGlzIGF0dGFjaGVkXG4gICAgLy8gdG8gdGhlIERPTSwgb3IgdGhlIHN0eWxlIG9mIGEgcGFyZW50IG9mIHRoZSBUaW1lbGluZSBpcyBjaGFuZ2VkIGZyb21cbiAgICAvLyBkaXNwbGF5Om5vbmUgaXMgY2hhbmdlZCB0byB2aXNpYmxlLlxuICAgIHRoaXMuZG9tLm1hcmtlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuZG9tLm1hcmtlci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgdGhpcy5kb20ubWFya2VyLmlubmVySFRNTCA9ICc/JztcbiAgICB0aGlzLmRvbS5iYWNrZ3JvdW5kLmFwcGVuZENoaWxkKHRoaXMuZG9tLm1hcmtlcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZ3JvdXAgZGF0YSBmb3IgdGhpcyBncm91cFxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAgIEdyb3VwIGRhdGEsIGNhbiBjb250YWluIHByb3BlcnRpZXMgY29udGVudCBhbmQgY2xhc3NOYW1lXG4gICAqL1xuICBHcm91cC5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgLy8gdXBkYXRlIGNvbnRlbnRzXG4gICAgdmFyIGNvbnRlbnQ7XG4gICAgaWYgKHRoaXMuaXRlbVNldC5vcHRpb25zICYmIHRoaXMuaXRlbVNldC5vcHRpb25zLmdyb3VwVGVtcGxhdGUpIHtcbiAgICAgIGNvbnRlbnQgPSB0aGlzLml0ZW1TZXQub3B0aW9ucy5ncm91cFRlbXBsYXRlKGRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZW50ID0gZGF0YSAmJiBkYXRhLmNvbnRlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICB0aGlzLmRvbS5pbm5lci5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICAgIHdoaWxlICh0aGlzLmRvbS5pbm5lci5maXJzdENoaWxkKSB7XG4gICAgICAgIHRoaXMuZG9tLmlubmVyLnJlbW92ZUNoaWxkKHRoaXMuZG9tLmlubmVyLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgICAgdGhpcy5kb20uaW5uZXIuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgfSBlbHNlIGlmIChjb250ZW50ICE9PSB1bmRlZmluZWQgJiYgY29udGVudCAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5kb20uaW5uZXIuaW5uZXJIVE1MID0gY29udGVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kb20uaW5uZXIuaW5uZXJIVE1MID0gdGhpcy5ncm91cElkIHx8ICcnOyAvLyBncm91cElkIGNhbiBiZSBudWxsXG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIHRpdGxlXG4gICAgdGhpcy5kb20ubGFiZWwudGl0bGUgPSBkYXRhICYmIGRhdGEudGl0bGUgfHwgJyc7XG5cbiAgICBpZiAoIXRoaXMuZG9tLmlubmVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgIHV0aWwuYWRkQ2xhc3NOYW1lKHRoaXMuZG9tLmlubmVyLCAndmlzLWhpZGRlbicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1dGlsLnJlbW92ZUNsYXNzTmFtZSh0aGlzLmRvbS5pbm5lciwgJ3Zpcy1oaWRkZW4nKTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgY2xhc3NOYW1lXG4gICAgdmFyIGNsYXNzTmFtZSA9IGRhdGEgJiYgZGF0YS5jbGFzc05hbWUgfHwgbnVsbDtcbiAgICBpZiAoY2xhc3NOYW1lICE9IHRoaXMuY2xhc3NOYW1lKSB7XG4gICAgICBpZiAodGhpcy5jbGFzc05hbWUpIHtcbiAgICAgICAgdXRpbC5yZW1vdmVDbGFzc05hbWUodGhpcy5kb20ubGFiZWwsIHRoaXMuY2xhc3NOYW1lKTtcbiAgICAgICAgdXRpbC5yZW1vdmVDbGFzc05hbWUodGhpcy5kb20uZm9yZWdyb3VuZCwgdGhpcy5jbGFzc05hbWUpO1xuICAgICAgICB1dGlsLnJlbW92ZUNsYXNzTmFtZSh0aGlzLmRvbS5iYWNrZ3JvdW5kLCB0aGlzLmNsYXNzTmFtZSk7XG4gICAgICAgIHV0aWwucmVtb3ZlQ2xhc3NOYW1lKHRoaXMuZG9tLmF4aXMsIHRoaXMuY2xhc3NOYW1lKTtcbiAgICAgIH1cbiAgICAgIHV0aWwuYWRkQ2xhc3NOYW1lKHRoaXMuZG9tLmxhYmVsLCBjbGFzc05hbWUpO1xuICAgICAgdXRpbC5hZGRDbGFzc05hbWUodGhpcy5kb20uZm9yZWdyb3VuZCwgY2xhc3NOYW1lKTtcbiAgICAgIHV0aWwuYWRkQ2xhc3NOYW1lKHRoaXMuZG9tLmJhY2tncm91bmQsIGNsYXNzTmFtZSk7XG4gICAgICB1dGlsLmFkZENsYXNzTmFtZSh0aGlzLmRvbS5heGlzLCBjbGFzc05hbWUpO1xuICAgICAgdGhpcy5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIHN0eWxlXG4gICAgaWYgKHRoaXMuc3R5bGUpIHtcbiAgICAgIHV0aWwucmVtb3ZlQ3NzVGV4dCh0aGlzLmRvbS5sYWJlbCwgdGhpcy5zdHlsZSk7XG4gICAgICB0aGlzLnN0eWxlID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGRhdGEgJiYgZGF0YS5zdHlsZSkge1xuICAgICAgdXRpbC5hZGRDc3NUZXh0KHRoaXMuZG9tLmxhYmVsLCBkYXRhLnN0eWxlKTtcbiAgICAgIHRoaXMuc3R5bGUgPSBkYXRhLnN0eWxlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSB3aWR0aCBvZiB0aGUgZ3JvdXAgbGFiZWxcbiAgICogQHJldHVybiB7bnVtYmVyfSB3aWR0aFxuICAgKi9cbiAgR3JvdXAucHJvdG90eXBlLmdldExhYmVsV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMubGFiZWwud2lkdGg7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcGFpbnQgdGhpcyBncm91cFxuICAgKiBAcGFyYW0ge3tzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcn19IHJhbmdlXG4gICAqIEBwYXJhbSB7e2l0ZW06IHtob3Jpem9udGFsOiBudW1iZXIsIHZlcnRpY2FsOiBudW1iZXJ9LCBheGlzOiBudW1iZXJ9fSBtYXJnaW5cbiAgICogQHBhcmFtIHtib29sZWFufSBbcmVzdGFjaz1mYWxzZV0gIEZvcmNlIHJlc3RhY2tpbmcgb2YgYWxsIGl0ZW1zXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgZ3JvdXAgaXMgcmVzaXplZFxuICAgKi9cbiAgR3JvdXAucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uIChyYW5nZSwgbWFyZ2luLCByZXN0YWNrKSB7XG4gICAgdmFyIHJlc2l6ZWQgPSBmYWxzZTtcblxuICAgIC8vIGZvcmNlIHJlY2FsY3VsYXRpb24gb2YgdGhlIGhlaWdodCBvZiB0aGUgaXRlbXMgd2hlbiB0aGUgbWFya2VyIGhlaWdodCBjaGFuZ2VkXG4gICAgLy8gKGR1ZSB0byB0aGUgVGltZWxpbmUgYmVpbmcgYXR0YWNoZWQgdG8gdGhlIERPTSBvciBjaGFuZ2VkIGZyb20gZGlzcGxheTpub25lIHRvIHZpc2libGUpXG4gICAgdmFyIG1hcmtlckhlaWdodCA9IHRoaXMuZG9tLm1hcmtlci5jbGllbnRIZWlnaHQ7XG4gICAgaWYgKG1hcmtlckhlaWdodCAhPSB0aGlzLmxhc3RNYXJrZXJIZWlnaHQpIHtcbiAgICAgIHRoaXMubGFzdE1hcmtlckhlaWdodCA9IG1hcmtlckhlaWdodDtcblxuICAgICAgdXRpbC5mb3JFYWNoKHRoaXMuaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGl0ZW0uZGlydHkgPSB0cnVlO1xuICAgICAgICBpZiAoaXRlbS5kaXNwbGF5ZWQpIGl0ZW0ucmVkcmF3KCk7XG4gICAgICB9KTtcblxuICAgICAgcmVzdGFjayA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gcmVjYWxjdWxhdGUgdGhlIGhlaWdodCBvZiB0aGUgc3ViZ3JvdXBzXG4gICAgdGhpcy5fY2FsY3VsYXRlU3ViR3JvdXBIZWlnaHRzKCk7XG5cbiAgICAvLyByZXBvc2l0aW9uIHZpc2libGUgaXRlbXMgdmVydGljYWxseVxuICAgIGlmICh0eXBlb2YgdGhpcy5pdGVtU2V0Lm9wdGlvbnMub3JkZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIGEgY3VzdG9tIG9yZGVyIGZ1bmN0aW9uXG5cbiAgICAgIGlmIChyZXN0YWNrKSB7XG4gICAgICAgIC8vIGJydXRlIGZvcmNlIHJlc3RhY2sgb2YgYWxsIGl0ZW1zXG5cbiAgICAgICAgLy8gc2hvdyBhbGwgaXRlbXNcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIGxpbWl0U2l6ZSA9IGZhbHNlO1xuICAgICAgICB1dGlsLmZvckVhY2godGhpcy5pdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICBpZiAoIWl0ZW0uZGlzcGxheWVkKSB7XG4gICAgICAgICAgICBpdGVtLnJlZHJhdygpO1xuICAgICAgICAgICAgbWUudmlzaWJsZUl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGl0ZW0ucmVwb3NpdGlvblgobGltaXRTaXplKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gb3JkZXIgYWxsIGl0ZW1zIGFuZCBmb3JjZSBhIHJlc3RhY2tpbmdcbiAgICAgICAgdmFyIGN1c3RvbU9yZGVyZWRJdGVtcyA9IHRoaXMub3JkZXJlZEl0ZW1zLmJ5U3RhcnQuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIG1lLml0ZW1TZXQub3B0aW9ucy5vcmRlcihhLmRhdGEsIGIuZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzdGFjay5zdGFjayhjdXN0b21PcmRlcmVkSXRlbXMsIG1hcmdpbiwgdHJ1ZSAvKiByZXN0YWNrPXRydWUgKi8pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnZpc2libGVJdGVtcyA9IHRoaXMuX3VwZGF0ZVZpc2libGVJdGVtcyh0aGlzLm9yZGVyZWRJdGVtcywgdGhpcy52aXNpYmxlSXRlbXMsIHJhbmdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm8gY3VzdG9tIG9yZGVyIGZ1bmN0aW9uLCBsYXp5IHN0YWNraW5nXG5cbiAgICAgIHRoaXMudmlzaWJsZUl0ZW1zID0gdGhpcy5fdXBkYXRlVmlzaWJsZUl0ZW1zKHRoaXMub3JkZXJlZEl0ZW1zLCB0aGlzLnZpc2libGVJdGVtcywgcmFuZ2UpO1xuICAgICAgaWYgKHRoaXMuaXRlbVNldC5vcHRpb25zLnN0YWNrKSB7XG4gICAgICAgIC8vIFRPRE86IHVnbHkgd2F5IHRvIGFjY2VzcyBvcHRpb25zLi4uXG4gICAgICAgIHN0YWNrLnN0YWNrKHRoaXMudmlzaWJsZUl0ZW1zLCBtYXJnaW4sIHJlc3RhY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm8gc3RhY2tpbmdcbiAgICAgICAgc3RhY2subm9zdGFjayh0aGlzLnZpc2libGVJdGVtcywgbWFyZ2luLCB0aGlzLnN1Ymdyb3Vwcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVjYWxjdWxhdGUgdGhlIGhlaWdodCBvZiB0aGUgZ3JvdXBcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5fY2FsY3VsYXRlSGVpZ2h0KG1hcmdpbik7XG5cbiAgICAvLyBjYWxjdWxhdGUgYWN0dWFsIHNpemUgYW5kIHBvc2l0aW9uXG4gICAgdmFyIGZvcmVncm91bmQgPSB0aGlzLmRvbS5mb3JlZ3JvdW5kO1xuICAgIHRoaXMudG9wID0gZm9yZWdyb3VuZC5vZmZzZXRUb3A7XG4gICAgdGhpcy5yaWdodCA9IGZvcmVncm91bmQub2Zmc2V0TGVmdDtcbiAgICB0aGlzLndpZHRoID0gZm9yZWdyb3VuZC5vZmZzZXRXaWR0aDtcbiAgICByZXNpemVkID0gdXRpbC51cGRhdGVQcm9wZXJ0eSh0aGlzLCAnaGVpZ2h0JywgaGVpZ2h0KSB8fCByZXNpemVkO1xuICAgIC8vIHJlY2FsY3VsYXRlIHNpemUgb2YgbGFiZWxcbiAgICByZXNpemVkID0gdXRpbC51cGRhdGVQcm9wZXJ0eSh0aGlzLnByb3BzLmxhYmVsLCAnd2lkdGgnLCB0aGlzLmRvbS5pbm5lci5jbGllbnRXaWR0aCkgfHwgcmVzaXplZDtcbiAgICByZXNpemVkID0gdXRpbC51cGRhdGVQcm9wZXJ0eSh0aGlzLnByb3BzLmxhYmVsLCAnaGVpZ2h0JywgdGhpcy5kb20uaW5uZXIuY2xpZW50SGVpZ2h0KSB8fCByZXNpemVkO1xuXG4gICAgLy8gYXBwbHkgbmV3IGhlaWdodFxuICAgIHRoaXMuZG9tLmJhY2tncm91bmQuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICB0aGlzLmRvbS5mb3JlZ3JvdW5kLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgdGhpcy5kb20ubGFiZWwuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcblxuICAgIC8vIHVwZGF0ZSB2ZXJ0aWNhbCBwb3NpdGlvbiBvZiBpdGVtcyBhZnRlciB0aGV5IGFyZSByZS1zdGFja2VkIGFuZCB0aGUgaGVpZ2h0IG9mIHRoZSBncm91cCBpcyBjYWxjdWxhdGVkXG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdGhpcy52aXNpYmxlSXRlbXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSB0aGlzLnZpc2libGVJdGVtc1tpXTtcbiAgICAgIGl0ZW0ucmVwb3NpdGlvblkobWFyZ2luKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzaXplZDtcbiAgfTtcblxuICAvKipcbiAgICogcmVjYWxjdWxhdGUgdGhlIGhlaWdodCBvZiB0aGUgc3ViZ3JvdXBzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBHcm91cC5wcm90b3R5cGUuX2NhbGN1bGF0ZVN1Ykdyb3VwSGVpZ2h0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoT2JqZWN0LmtleXModGhpcy5zdWJncm91cHMpLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBtZSA9IHRoaXM7XG5cbiAgICAgIHRoaXMucmVzZXRTdWJncm91cHMoKTtcblxuICAgICAgdXRpbC5mb3JFYWNoKHRoaXMudmlzaWJsZUl0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoaXRlbS5kYXRhLnN1Ymdyb3VwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBtZS5zdWJncm91cHNbaXRlbS5kYXRhLnN1Ymdyb3VwXS5oZWlnaHQgPSBNYXRoLm1heChtZS5zdWJncm91cHNbaXRlbS5kYXRhLnN1Ymdyb3VwXS5oZWlnaHQsIGl0ZW0uaGVpZ2h0KTtcbiAgICAgICAgICBtZS5zdWJncm91cHNbaXRlbS5kYXRhLnN1Ymdyb3VwXS52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiByZWNhbGN1bGF0ZSB0aGUgaGVpZ2h0IG9mIHRoZSBncm91cFxuICAgKiBAcGFyYW0ge3tpdGVtOiB7aG9yaXpvbnRhbDogbnVtYmVyLCB2ZXJ0aWNhbDogbnVtYmVyfSwgYXhpczogbnVtYmVyfX0gbWFyZ2luXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGhlaWdodFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgR3JvdXAucHJvdG90eXBlLl9jYWxjdWxhdGVIZWlnaHQgPSBmdW5jdGlvbiAobWFyZ2luKSB7XG4gICAgLy8gcmVjYWxjdWxhdGUgdGhlIGhlaWdodCBvZiB0aGUgZ3JvdXBcbiAgICB2YXIgaGVpZ2h0O1xuICAgIHZhciB2aXNpYmxlSXRlbXMgPSB0aGlzLnZpc2libGVJdGVtcztcbiAgICBpZiAodmlzaWJsZUl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBtaW4gPSB2aXNpYmxlSXRlbXNbMF0udG9wO1xuICAgICAgdmFyIG1heCA9IHZpc2libGVJdGVtc1swXS50b3AgKyB2aXNpYmxlSXRlbXNbMF0uaGVpZ2h0O1xuICAgICAgdXRpbC5mb3JFYWNoKHZpc2libGVJdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgbWluID0gTWF0aC5taW4obWluLCBpdGVtLnRvcCk7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgaXRlbS50b3AgKyBpdGVtLmhlaWdodCk7XG4gICAgICB9KTtcbiAgICAgIGlmIChtaW4gPiBtYXJnaW4uYXhpcykge1xuICAgICAgICAvLyB0aGVyZSBpcyBhbiBlbXB0eSBnYXAgYmV0d2VlbiB0aGUgbG93ZXN0IGl0ZW0gYW5kIHRoZSBheGlzXG4gICAgICAgIHZhciBvZmZzZXQgPSBtaW4gLSBtYXJnaW4uYXhpcztcbiAgICAgICAgbWF4IC09IG9mZnNldDtcbiAgICAgICAgdXRpbC5mb3JFYWNoKHZpc2libGVJdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICBpdGVtLnRvcCAtPSBvZmZzZXQ7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaGVpZ2h0ID0gbWF4ICsgbWFyZ2luLml0ZW0udmVydGljYWwgLyAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWlnaHQgPSAwO1xuICAgIH1cbiAgICBoZWlnaHQgPSBNYXRoLm1heChoZWlnaHQsIHRoaXMucHJvcHMubGFiZWwuaGVpZ2h0KTtcblxuICAgIHJldHVybiBoZWlnaHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNob3cgdGhpcyBncm91cDogYXR0YWNoIHRvIHRoZSBET01cbiAgICovXG4gIEdyb3VwLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5kb20ubGFiZWwucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5pdGVtU2V0LmRvbS5sYWJlbFNldC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5sYWJlbCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmRvbS5mb3JlZ3JvdW5kLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuaXRlbVNldC5kb20uZm9yZWdyb3VuZC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5mb3JlZ3JvdW5kKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZG9tLmJhY2tncm91bmQucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5pdGVtU2V0LmRvbS5iYWNrZ3JvdW5kLmFwcGVuZENoaWxkKHRoaXMuZG9tLmJhY2tncm91bmQpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5kb20uYXhpcy5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLml0ZW1TZXQuZG9tLmF4aXMuYXBwZW5kQ2hpbGQodGhpcy5kb20uYXhpcyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBIaWRlIHRoaXMgZ3JvdXA6IHJlbW92ZSBmcm9tIHRoZSBET01cbiAgICovXG4gIEdyb3VwLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsYWJlbCA9IHRoaXMuZG9tLmxhYmVsO1xuICAgIGlmIChsYWJlbC5wYXJlbnROb2RlKSB7XG4gICAgICBsYWJlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxhYmVsKTtcbiAgICB9XG5cbiAgICB2YXIgZm9yZWdyb3VuZCA9IHRoaXMuZG9tLmZvcmVncm91bmQ7XG4gICAgaWYgKGZvcmVncm91bmQucGFyZW50Tm9kZSkge1xuICAgICAgZm9yZWdyb3VuZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGZvcmVncm91bmQpO1xuICAgIH1cblxuICAgIHZhciBiYWNrZ3JvdW5kID0gdGhpcy5kb20uYmFja2dyb3VuZDtcbiAgICBpZiAoYmFja2dyb3VuZC5wYXJlbnROb2RlKSB7XG4gICAgICBiYWNrZ3JvdW5kLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYmFja2dyb3VuZCk7XG4gICAgfVxuXG4gICAgdmFyIGF4aXMgPSB0aGlzLmRvbS5heGlzO1xuICAgIGlmIChheGlzLnBhcmVudE5vZGUpIHtcbiAgICAgIGF4aXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChheGlzKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBpdGVtIHRvIHRoZSBncm91cFxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIEdyb3VwLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgIHRoaXMuaXRlbXNbaXRlbS5pZF0gPSBpdGVtO1xuICAgIGl0ZW0uc2V0UGFyZW50KHRoaXMpO1xuXG4gICAgLy8gYWRkIHRvXG4gICAgaWYgKGl0ZW0uZGF0YS5zdWJncm91cCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodGhpcy5zdWJncm91cHNbaXRlbS5kYXRhLnN1Ymdyb3VwXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuc3ViZ3JvdXBzW2l0ZW0uZGF0YS5zdWJncm91cF0gPSB7IGhlaWdodDogMCwgdmlzaWJsZTogZmFsc2UsIGluZGV4OiB0aGlzLnN1Ymdyb3VwSW5kZXgsIGl0ZW1zOiBbXSB9O1xuICAgICAgICB0aGlzLnN1Ymdyb3VwSW5kZXgrKztcbiAgICAgIH1cbiAgICAgIHRoaXMuc3ViZ3JvdXBzW2l0ZW0uZGF0YS5zdWJncm91cF0uaXRlbXMucHVzaChpdGVtKTtcbiAgICB9XG4gICAgdGhpcy5vcmRlclN1Ymdyb3VwcygpO1xuXG4gICAgaWYgKHRoaXMudmlzaWJsZUl0ZW1zLmluZGV4T2YoaXRlbSkgPT0gLTEpIHtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMuaXRlbVNldC5ib2R5LnJhbmdlOyAvLyBUT0RPOiBub3QgbmljZSBhY2Nlc3NpbmcgdGhlIHJhbmdlIGxpa2UgdGhpc1xuICAgICAgdGhpcy5fY2hlY2tJZlZpc2libGUoaXRlbSwgdGhpcy52aXNpYmxlSXRlbXMsIHJhbmdlKTtcbiAgICB9XG4gIH07XG5cbiAgR3JvdXAucHJvdG90eXBlLm9yZGVyU3ViZ3JvdXBzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnN1Ymdyb3VwT3JkZXJlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgc29ydEFycmF5ID0gW107XG4gICAgICBpZiAodHlwZW9mIHRoaXMuc3ViZ3JvdXBPcmRlcmVyID09ICdzdHJpbmcnKSB7XG4gICAgICAgIGZvciAodmFyIHN1Ymdyb3VwIGluIHRoaXMuc3ViZ3JvdXBzKSB7XG4gICAgICAgICAgc29ydEFycmF5LnB1c2goeyBzdWJncm91cDogc3ViZ3JvdXAsIHNvcnRGaWVsZDogdGhpcy5zdWJncm91cHNbc3ViZ3JvdXBdLml0ZW1zWzBdLmRhdGFbdGhpcy5zdWJncm91cE9yZGVyZXJdIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNvcnRBcnJheS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIGEuc29ydEZpZWxkIC0gYi5zb3J0RmllbGQ7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5zdWJncm91cE9yZGVyZXIgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmb3IgKHZhciBzdWJncm91cCBpbiB0aGlzLnN1Ymdyb3Vwcykge1xuICAgICAgICAgIHNvcnRBcnJheS5wdXNoKHRoaXMuc3ViZ3JvdXBzW3N1Ymdyb3VwXS5pdGVtc1swXS5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBzb3J0QXJyYXkuc29ydCh0aGlzLnN1Ymdyb3VwT3JkZXJlcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzb3J0QXJyYXkubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvcnRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuc3ViZ3JvdXBzW3NvcnRBcnJheVtpXS5zdWJncm91cF0uaW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEdyb3VwLnByb3RvdHlwZS5yZXNldFN1Ymdyb3VwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBzdWJncm91cCBpbiB0aGlzLnN1Ymdyb3Vwcykge1xuICAgICAgaWYgKHRoaXMuc3ViZ3JvdXBzLmhhc093blByb3BlcnR5KHN1Ymdyb3VwKSkge1xuICAgICAgICB0aGlzLnN1Ymdyb3Vwc1tzdWJncm91cF0udmlzaWJsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSB0aGUgZ3JvdXBcbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBHcm91cC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBkZWxldGUgdGhpcy5pdGVtc1tpdGVtLmlkXTtcbiAgICBpdGVtLnNldFBhcmVudChudWxsKTtcblxuICAgIC8vIHJlbW92ZSBmcm9tIHZpc2libGUgaXRlbXNcbiAgICB2YXIgaW5kZXggPSB0aGlzLnZpc2libGVJdGVtcy5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCAhPSAtMSkgdGhpcy52aXNpYmxlSXRlbXMuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgIGlmIChpdGVtLmRhdGEuc3ViZ3JvdXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHN1Ymdyb3VwID0gdGhpcy5zdWJncm91cHNbaXRlbS5kYXRhLnN1Ymdyb3VwXTtcbiAgICAgIGlmIChzdWJncm91cCkge1xuICAgICAgICB2YXIgaXRlbUluZGV4ID0gc3ViZ3JvdXAuaXRlbXMuaW5kZXhPZihpdGVtKTtcbiAgICAgICAgc3ViZ3JvdXAuaXRlbXMuc3BsaWNlKGl0ZW1JbmRleCwgMSk7XG4gICAgICAgIGlmICghc3ViZ3JvdXAuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuc3ViZ3JvdXBzW2l0ZW0uZGF0YS5zdWJncm91cF07XG4gICAgICAgICAgdGhpcy5zdWJncm91cEluZGV4LS07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcmRlclN1Ymdyb3VwcygpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSB0aGUgY29ycmVzcG9uZGluZyBEYXRhU2V0XG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgR3JvdXAucHJvdG90eXBlLnJlbW92ZUZyb21EYXRhU2V0ID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICB0aGlzLml0ZW1TZXQucmVtb3ZlSXRlbShpdGVtLmlkKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVvcmRlciB0aGUgaXRlbXNcbiAgICovXG4gIEdyb3VwLnByb3RvdHlwZS5vcmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJyYXkgPSB1dGlsLnRvQXJyYXkodGhpcy5pdGVtcyk7XG4gICAgdmFyIHN0YXJ0QXJyYXkgPSBbXTtcbiAgICB2YXIgZW5kQXJyYXkgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhcnJheVtpXS5kYXRhLmVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVuZEFycmF5LnB1c2goYXJyYXlbaV0pO1xuICAgICAgfVxuICAgICAgc3RhcnRBcnJheS5wdXNoKGFycmF5W2ldKTtcbiAgICB9XG4gICAgdGhpcy5vcmRlcmVkSXRlbXMgPSB7XG4gICAgICBieVN0YXJ0OiBzdGFydEFycmF5LFxuICAgICAgYnlFbmQ6IGVuZEFycmF5XG4gICAgfTtcblxuICAgIHN0YWNrLm9yZGVyQnlTdGFydCh0aGlzLm9yZGVyZWRJdGVtcy5ieVN0YXJ0KTtcbiAgICBzdGFjay5vcmRlckJ5RW5kKHRoaXMub3JkZXJlZEl0ZW1zLmJ5RW5kKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSB2aXNpYmxlIGl0ZW1zXG4gICAqIEBwYXJhbSB7e2J5U3RhcnQ6IEl0ZW1bXSwgYnlFbmQ6IEl0ZW1bXX19IG9yZGVyZWRJdGVtcyAgIEFsbCBpdGVtcyBvcmRlcmVkIGJ5IHN0YXJ0IGRhdGUgYW5kIGJ5IGVuZCBkYXRlXG4gICAqIEBwYXJhbSB7SXRlbVtdfSB2aXNpYmxlSXRlbXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBwcmV2aW91c2x5IHZpc2libGUgaXRlbXMuXG4gICAqIEBwYXJhbSB7e3N0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyfX0gcmFuZ2UgICAgICAgICAgICAgIFZpc2libGUgcmFuZ2VcbiAgICogQHJldHVybiB7SXRlbVtdfSB2aXNpYmxlSXRlbXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG5ldyB2aXNpYmxlIGl0ZW1zLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgR3JvdXAucHJvdG90eXBlLl91cGRhdGVWaXNpYmxlSXRlbXMgPSBmdW5jdGlvbiAob3JkZXJlZEl0ZW1zLCBvbGRWaXNpYmxlSXRlbXMsIHJhbmdlKSB7XG4gICAgdmFyIHZpc2libGVJdGVtcyA9IFtdO1xuICAgIHZhciB2aXNpYmxlSXRlbXNMb29rdXAgPSB7fTsgLy8gd2Uga2VlcCB0aGlzIHRvIHF1aWNrbHkgbG9vayB1cCBpZiBhbiBpdGVtIGFscmVhZHkgZXhpc3RzIGluIHRoZSBsaXN0IHdpdGhvdXQgdXNpbmcgaW5kZXhPZiBvbiB2aXNpYmxlSXRlbXNcbiAgICB2YXIgaW50ZXJ2YWwgPSAocmFuZ2UuZW5kIC0gcmFuZ2Uuc3RhcnQpIC8gNDtcbiAgICB2YXIgbG93ZXJCb3VuZCA9IHJhbmdlLnN0YXJ0IC0gaW50ZXJ2YWw7XG4gICAgdmFyIHVwcGVyQm91bmQgPSByYW5nZS5lbmQgKyBpbnRlcnZhbDtcbiAgICB2YXIgaXRlbSwgaTtcblxuICAgIC8vIHRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBkbyB0aGUgYmluYXJ5IHNlYXJjaC5cbiAgICB2YXIgc2VhcmNoRnVuY3Rpb24gPSBmdW5jdGlvbiBzZWFyY2hGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlIDwgbG93ZXJCb3VuZCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlIDw9IHVwcGVyQm91bmQpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gZmlyc3QgY2hlY2sgaWYgdGhlIGl0ZW1zIHRoYXQgd2VyZSBpbiB2aWV3IHByZXZpb3VzbHkgYXJlIHN0aWxsIGluIHZpZXcuXG4gICAgLy8gSU1QT1JUQU5UOiB0aGlzIGhhbmRsZXMgdGhlIGNhc2UgZm9yIHRoZSBpdGVtcyB3aXRoIHN0YXJ0ZGF0ZSBiZWZvcmUgdGhlIHdpbmRvdyBhbmQgZW5kZGF0ZSBhZnRlciB0aGUgd2luZG93IVxuICAgIC8vIGFsc28gY2xlYW5zIHVwIGludmlzaWJsZSBpdGVtcy5cbiAgICBpZiAob2xkVmlzaWJsZUl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBvbGRWaXNpYmxlSXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5fY2hlY2tJZlZpc2libGVXaXRoUmVmZXJlbmNlKG9sZFZpc2libGVJdGVtc1tpXSwgdmlzaWJsZUl0ZW1zLCB2aXNpYmxlSXRlbXNMb29rdXAsIHJhbmdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB3ZSBkbyBhIGJpbmFyeSBzZWFyY2ggZm9yIHRoZSBpdGVtcyB0aGF0IGhhdmUgb25seSBzdGFydCB2YWx1ZXMuXG4gICAgdmFyIGluaXRpYWxQb3NCeVN0YXJ0ID0gdXRpbC5iaW5hcnlTZWFyY2hDdXN0b20ob3JkZXJlZEl0ZW1zLmJ5U3RhcnQsIHNlYXJjaEZ1bmN0aW9uLCAnZGF0YScsICdzdGFydCcpO1xuXG4gICAgLy8gdHJhY2UgdGhlIHZpc2libGUgaXRlbXMgZnJvbSB0aGUgaW5pdGFsIHN0YXJ0IHBvcyBib3RoIHdheXMgdW50aWwgYW4gaW52aXNpYmxlIGl0ZW0gaXMgZm91bmQsIHdlIG9ubHkgbG9vayBhdCB0aGUgc3RhcnQgdmFsdWVzLlxuICAgIHRoaXMuX3RyYWNlVmlzaWJsZShpbml0aWFsUG9zQnlTdGFydCwgb3JkZXJlZEl0ZW1zLmJ5U3RhcnQsIHZpc2libGVJdGVtcywgdmlzaWJsZUl0ZW1zTG9va3VwLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0uZGF0YS5zdGFydCA8IGxvd2VyQm91bmQgfHwgaXRlbS5kYXRhLnN0YXJ0ID4gdXBwZXJCb3VuZDtcbiAgICB9KTtcblxuICAgIC8vIGlmIHRoZSB3aW5kb3cgaGFzIGNoYW5nZWQgcHJvZ3JhbW1hdGljYWxseSB3aXRob3V0IG92ZXJsYXBwaW5nIHRoZSBvbGQgd2luZG93LCB0aGUgcmFuZ2VkIGl0ZW1zIHdpdGggc3RhcnQgPCBsb3dlckJvdW5kIGFuZCBlbmQgPiB1cHBlcmJvdW5kIGFyZSBub3Qgc2hvd24uXG4gICAgLy8gV2UgdGhlcmVmb3JlIGhhdmUgdG8gYnJ1dGUgZm9yY2UgY2hlY2sgYWxsIGl0ZW1zIGluIHRoZSBieUVuZCBsaXN0XG4gICAgaWYgKHRoaXMuY2hlY2tSYW5nZWRJdGVtcyA9PSB0cnVlKSB7XG4gICAgICB0aGlzLmNoZWNrUmFuZ2VkSXRlbXMgPSBmYWxzZTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBvcmRlcmVkSXRlbXMuYnlFbmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5fY2hlY2tJZlZpc2libGVXaXRoUmVmZXJlbmNlKG9yZGVyZWRJdGVtcy5ieUVuZFtpXSwgdmlzaWJsZUl0ZW1zLCB2aXNpYmxlSXRlbXNMb29rdXAsIHJhbmdlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gd2UgZG8gYSBiaW5hcnkgc2VhcmNoIGZvciB0aGUgaXRlbXMgdGhhdCBoYXZlIGRlZmluZWQgZW5kIHRpbWVzLlxuICAgICAgdmFyIGluaXRpYWxQb3NCeUVuZCA9IHV0aWwuYmluYXJ5U2VhcmNoQ3VzdG9tKG9yZGVyZWRJdGVtcy5ieUVuZCwgc2VhcmNoRnVuY3Rpb24sICdkYXRhJywgJ2VuZCcpO1xuXG4gICAgICAvLyB0cmFjZSB0aGUgdmlzaWJsZSBpdGVtcyBmcm9tIHRoZSBpbml0YWwgc3RhcnQgcG9zIGJvdGggd2F5cyB1bnRpbCBhbiBpbnZpc2libGUgaXRlbSBpcyBmb3VuZCwgd2Ugb25seSBsb29rIGF0IHRoZSBlbmQgdmFsdWVzLlxuICAgICAgdGhpcy5fdHJhY2VWaXNpYmxlKGluaXRpYWxQb3NCeUVuZCwgb3JkZXJlZEl0ZW1zLmJ5RW5kLCB2aXNpYmxlSXRlbXMsIHZpc2libGVJdGVtc0xvb2t1cCwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0uZGF0YS5lbmQgPCBsb3dlckJvdW5kIHx8IGl0ZW0uZGF0YS5lbmQgPiB1cHBlckJvdW5kO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gZmluYWxseSwgd2UgcmVwb3NpdGlvbiBhbGwgdGhlIHZpc2libGUgaXRlbXMuXG4gICAgZm9yIChpID0gMDsgaSA8IHZpc2libGVJdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgaXRlbSA9IHZpc2libGVJdGVtc1tpXTtcbiAgICAgIGlmICghaXRlbS5kaXNwbGF5ZWQpIGl0ZW0uc2hvdygpO1xuICAgICAgLy8gcmVwb3NpdGlvbiBpdGVtIGhvcml6b250YWxseVxuICAgICAgaXRlbS5yZXBvc2l0aW9uWCgpO1xuICAgIH1cblxuICAgIC8vIGRlYnVnXG4gICAgLy9jb25zb2xlLmxvZyhcIm5ldyBsaW5lXCIpXG4gICAgLy9pZiAodGhpcy5ncm91cElkID09IG51bGwpIHtcbiAgICAvLyAgZm9yIChpID0gMDsgaSA8IG9yZGVyZWRJdGVtcy5ieVN0YXJ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gICAgaXRlbSA9IG9yZGVyZWRJdGVtcy5ieVN0YXJ0W2ldLmRhdGE7XG4gICAgLy8gICAgY29uc29sZS5sb2coJ3N0YXJ0JyxpLGluaXRpYWxQb3NCeVN0YXJ0LCBpdGVtLnN0YXJ0LnZhbHVlT2YoKSwgaXRlbS5jb250ZW50LCBpdGVtLnN0YXJ0ID49IGxvd2VyQm91bmQgJiYgaXRlbS5zdGFydCA8PSB1cHBlckJvdW5kLGkgPT0gaW5pdGlhbFBvc0J5U3RhcnQgPyBcIjwtLS0tLS0tLS0tLS0tLS0tLS0tIEhFUkVFRUVcIiA6IFwiXCIpXG4gICAgLy8gIH1cbiAgICAvLyAgZm9yIChpID0gMDsgaSA8IG9yZGVyZWRJdGVtcy5ieUVuZC5sZW5ndGg7IGkrKykge1xuICAgIC8vICAgIGl0ZW0gPSBvcmRlcmVkSXRlbXMuYnlFbmRbaV0uZGF0YTtcbiAgICAvLyAgICBjb25zb2xlLmxvZygncmFuZ2VFbmQnLGksaW5pdGlhbFBvc0J5RW5kLCBpdGVtLmVuZC52YWx1ZU9mKCksIGl0ZW0uY29udGVudCwgaXRlbS5lbmQgPj0gcmFuZ2Uuc3RhcnQgJiYgaXRlbS5lbmQgPD0gcmFuZ2UuZW5kLGkgPT0gaW5pdGlhbFBvc0J5RW5kID8gXCI8LS0tLS0tLS0tLS0tLS0tLS0tLSBIRVJFRUVFXCIgOiBcIlwiKVxuICAgIC8vICB9XG4gICAgLy99XG5cbiAgICByZXR1cm4gdmlzaWJsZUl0ZW1zO1xuICB9O1xuXG4gIEdyb3VwLnByb3RvdHlwZS5fdHJhY2VWaXNpYmxlID0gZnVuY3Rpb24gKGluaXRpYWxQb3MsIGl0ZW1zLCB2aXNpYmxlSXRlbXMsIHZpc2libGVJdGVtc0xvb2t1cCwgYnJlYWtDb25kaXRpb24pIHtcbiAgICB2YXIgaXRlbTtcbiAgICB2YXIgaTtcblxuICAgIGlmIChpbml0aWFsUG9zICE9IC0xKSB7XG4gICAgICBmb3IgKGkgPSBpbml0aWFsUG9zOyBpID49IDA7IGktLSkge1xuICAgICAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIGlmIChicmVha0NvbmRpdGlvbihpdGVtKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh2aXNpYmxlSXRlbXNMb29rdXBbaXRlbS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmlzaWJsZUl0ZW1zTG9va3VwW2l0ZW0uaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIHZpc2libGVJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSBpbml0aWFsUG9zICsgMTsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgaWYgKGJyZWFrQ29uZGl0aW9uKGl0ZW0pKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHZpc2libGVJdGVtc0xvb2t1cFtpdGVtLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2aXNpYmxlSXRlbXNMb29rdXBbaXRlbS5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgdmlzaWJsZUl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiB0aGlzIGZ1bmN0aW9uIGlzIHZlcnkgc2ltaWxhciB0byB0aGUgX2NoZWNrSWZJbnZpc2libGUoKSBidXQgaXQgZG9lcyBub3RcbiAgICogcmV0dXJuIGJvb2xlYW5zLCBoaWRlcyB0aGUgaXRlbSBpZiBpdCBzaG91bGQgbm90IGJlIHNlZW4gYW5kIGFsd2F5cyBhZGRzIHRvXG4gICAqIHRoZSB2aXNpYmxlSXRlbXMuXG4gICAqIHRoaXMgb25lIGlzIGZvciBicnV0ZSBmb3JjaW5nIGFuZCBoaWRpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKiBAcGFyYW0ge0FycmF5fSB2aXNpYmxlSXRlbXNcbiAgICogQHBhcmFtIHt7c3RhcnQ6bnVtYmVyLCBlbmQ6bnVtYmVyfX0gcmFuZ2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEdyb3VwLnByb3RvdHlwZS5fY2hlY2tJZlZpc2libGUgPSBmdW5jdGlvbiAoaXRlbSwgdmlzaWJsZUl0ZW1zLCByYW5nZSkge1xuICAgIGlmIChpdGVtLmlzVmlzaWJsZShyYW5nZSkpIHtcbiAgICAgIGlmICghaXRlbS5kaXNwbGF5ZWQpIGl0ZW0uc2hvdygpO1xuICAgICAgLy8gcmVwb3NpdGlvbiBpdGVtIGhvcml6b250YWxseVxuICAgICAgaXRlbS5yZXBvc2l0aW9uWCgpO1xuICAgICAgdmlzaWJsZUl0ZW1zLnB1c2goaXRlbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpdGVtLmRpc3BsYXllZCkgaXRlbS5oaWRlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiB0aGlzIGZ1bmN0aW9uIGlzIHZlcnkgc2ltaWxhciB0byB0aGUgX2NoZWNrSWZJbnZpc2libGUoKSBidXQgaXQgZG9lcyBub3RcbiAgICogcmV0dXJuIGJvb2xlYW5zLCBoaWRlcyB0aGUgaXRlbSBpZiBpdCBzaG91bGQgbm90IGJlIHNlZW4gYW5kIGFsd2F5cyBhZGRzIHRvXG4gICAqIHRoZSB2aXNpYmxlSXRlbXMuXG4gICAqIHRoaXMgb25lIGlzIGZvciBicnV0ZSBmb3JjaW5nIGFuZCBoaWRpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKiBAcGFyYW0ge0FycmF5fSB2aXNpYmxlSXRlbXNcbiAgICogQHBhcmFtIHt7c3RhcnQ6bnVtYmVyLCBlbmQ6bnVtYmVyfX0gcmFuZ2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEdyb3VwLnByb3RvdHlwZS5fY2hlY2tJZlZpc2libGVXaXRoUmVmZXJlbmNlID0gZnVuY3Rpb24gKGl0ZW0sIHZpc2libGVJdGVtcywgdmlzaWJsZUl0ZW1zTG9va3VwLCByYW5nZSkge1xuICAgIGlmIChpdGVtLmlzVmlzaWJsZShyYW5nZSkpIHtcbiAgICAgIGlmICh2aXNpYmxlSXRlbXNMb29rdXBbaXRlbS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2aXNpYmxlSXRlbXNMb29rdXBbaXRlbS5pZF0gPSB0cnVlO1xuICAgICAgICB2aXNpYmxlSXRlbXMucHVzaChpdGVtKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGl0ZW0uZGlzcGxheWVkKSBpdGVtLmhpZGUoKTtcbiAgICB9XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBHcm91cDtcblxuLyoqKi8gfSxcbi8qIDM3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gVXRpbGl0eSBmdW5jdGlvbnMgZm9yIG9yZGVyaW5nIGFuZCBzdGFja2luZyBvZiBpdGVtc1xuICB2YXIgRVBTSUxPTiA9IDAuMDAxOyAvLyB1c2VkIHdoZW4gY2hlY2tpbmcgY29sbGlzaW9ucywgdG8gcHJldmVudCByb3VuZC1vZmYgZXJyb3JzXG5cbiAgLyoqXG4gICAqIE9yZGVyIGl0ZW1zIGJ5IHRoZWlyIHN0YXJ0IGRhdGFcbiAgICogQHBhcmFtIHtJdGVtW119IGl0ZW1zXG4gICAqL1xuICBleHBvcnRzLm9yZGVyQnlTdGFydCA9IGZ1bmN0aW9uIChpdGVtcykge1xuICAgIGl0ZW1zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLmRhdGEuc3RhcnQgLSBiLmRhdGEuc3RhcnQ7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIE9yZGVyIGl0ZW1zIGJ5IHRoZWlyIGVuZCBkYXRlLiBJZiB0aGV5IGhhdmUgbm8gZW5kIGRhdGUsIHRoZWlyIHN0YXJ0IGRhdGVcbiAgICogaXMgdXNlZC5cbiAgICogQHBhcmFtIHtJdGVtW119IGl0ZW1zXG4gICAqL1xuICBleHBvcnRzLm9yZGVyQnlFbmQgPSBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgICBpdGVtcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICB2YXIgYVRpbWUgPSAnZW5kJyBpbiBhLmRhdGEgPyBhLmRhdGEuZW5kIDogYS5kYXRhLnN0YXJ0LFxuICAgICAgICAgIGJUaW1lID0gJ2VuZCcgaW4gYi5kYXRhID8gYi5kYXRhLmVuZCA6IGIuZGF0YS5zdGFydDtcblxuICAgICAgcmV0dXJuIGFUaW1lIC0gYlRpbWU7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkanVzdCB2ZXJ0aWNhbCBwb3NpdGlvbnMgb2YgdGhlIGl0ZW1zIHN1Y2ggdGhhdCB0aGV5IGRvbid0IG92ZXJsYXAgZWFjaFxuICAgKiBvdGhlci5cbiAgICogQHBhcmFtIHtJdGVtW119IGl0ZW1zXG4gICAqICAgICAgICAgICAgQWxsIHZpc2libGUgaXRlbXNcbiAgICogQHBhcmFtIHt7aXRlbToge2hvcml6b250YWw6IG51bWJlciwgdmVydGljYWw6IG51bWJlcn0sIGF4aXM6IG51bWJlcn19IG1hcmdpblxuICAgKiAgICAgICAgICAgIE1hcmdpbnMgYmV0d2VlbiBpdGVtcyBhbmQgYmV0d2VlbiBpdGVtcyBhbmQgdGhlIGF4aXMuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlPWZhbHNlXVxuICAgKiAgICAgICAgICAgIElmIHRydWUsIGFsbCBpdGVtcyB3aWxsIGJlIHJlcG9zaXRpb25lZC4gSWYgZmFsc2UgKGRlZmF1bHQpLCBvbmx5XG4gICAqICAgICAgICAgICAgaXRlbXMgaGF2aW5nIGEgdG9wPT09bnVsbCB3aWxsIGJlIHJlLXN0YWNrZWRcbiAgICovXG4gIGV4cG9ydHMuc3RhY2sgPSBmdW5jdGlvbiAoaXRlbXMsIG1hcmdpbiwgZm9yY2UpIHtcbiAgICB2YXIgaSwgaU1heDtcbiAgICBpZiAoZm9yY2UpIHtcbiAgICAgIC8vIHJlc2V0IHRvcCBwb3NpdGlvbiBvZiBhbGwgaXRlbXNcbiAgICAgIGZvciAoaSA9IDAsIGlNYXggPSBpdGVtcy5sZW5ndGg7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAgICAgaXRlbXNbaV0udG9wID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjYWxjdWxhdGUgbmV3LCBub24tb3ZlcmxhcHBpbmcgcG9zaXRpb25zXG4gICAgZm9yIChpID0gMCwgaU1heCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgIGlmIChpdGVtLnN0YWNrICYmIGl0ZW0udG9wID09PSBudWxsKSB7XG4gICAgICAgIC8vIGluaXRpYWxpemUgdG9wIHBvc2l0aW9uXG4gICAgICAgIGl0ZW0udG9wID0gbWFyZ2luLmF4aXM7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIC8vIFRPRE86IG9wdGltaXplIGNoZWNraW5nIGZvciBvdmVybGFwLiB3aGVuIHRoZXJlIGlzIGEgZ2FwIHdpdGhvdXQgaXRlbXMsXG4gICAgICAgICAgLy8gICAgICAgeW91IG9ubHkgbmVlZCB0byBjaGVjayBmb3IgaXRlbXMgZnJvbSB0aGUgbmV4dCBpdGVtIG9uLCBub3QgZnJvbSB6ZXJvXG4gICAgICAgICAgdmFyIGNvbGxpZGluZ0l0ZW0gPSBudWxsO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBqaiA9IGl0ZW1zLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBvdGhlciA9IGl0ZW1zW2pdO1xuICAgICAgICAgICAgaWYgKG90aGVyLnRvcCAhPT0gbnVsbCAmJiBvdGhlciAhPT0gaXRlbSAmJiBvdGhlci5zdGFjayAmJiBleHBvcnRzLmNvbGxpc2lvbihpdGVtLCBvdGhlciwgbWFyZ2luLml0ZW0sIG90aGVyLm9wdGlvbnMucnRsKSkge1xuICAgICAgICAgICAgICBjb2xsaWRpbmdJdGVtID0gb3RoZXI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjb2xsaWRpbmdJdGVtICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFRoZXJlIGlzIGEgY29sbGlzaW9uLiBSZXBvc2l0aW9uIHRoZSBpdGVtcyBhYm92ZSB0aGUgY29sbGlkaW5nIGVsZW1lbnRcbiAgICAgICAgICAgIGl0ZW0udG9wID0gY29sbGlkaW5nSXRlbS50b3AgKyBjb2xsaWRpbmdJdGVtLmhlaWdodCArIG1hcmdpbi5pdGVtLnZlcnRpY2FsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoY29sbGlkaW5nSXRlbSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBZGp1c3QgdmVydGljYWwgcG9zaXRpb25zIG9mIHRoZSBpdGVtcyB3aXRob3V0IHN0YWNraW5nIHRoZW1cbiAgICogQHBhcmFtIHtJdGVtW119IGl0ZW1zXG4gICAqICAgICAgICAgICAgQWxsIHZpc2libGUgaXRlbXNcbiAgICogQHBhcmFtIHt7aXRlbToge2hvcml6b250YWw6IG51bWJlciwgdmVydGljYWw6IG51bWJlcn0sIGF4aXM6IG51bWJlcn19IG1hcmdpblxuICAgKiAgICAgICAgICAgIE1hcmdpbnMgYmV0d2VlbiBpdGVtcyBhbmQgYmV0d2VlbiBpdGVtcyBhbmQgdGhlIGF4aXMuXG4gICAqL1xuICBleHBvcnRzLm5vc3RhY2sgPSBmdW5jdGlvbiAoaXRlbXMsIG1hcmdpbiwgc3ViZ3JvdXBzKSB7XG4gICAgdmFyIGksIGlNYXgsIG5ld1RvcDtcblxuICAgIC8vIHJlc2V0IHRvcCBwb3NpdGlvbiBvZiBhbGwgaXRlbXNcbiAgICBmb3IgKGkgPSAwLCBpTWF4ID0gaXRlbXMubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICBpZiAoaXRlbXNbaV0uZGF0YS5zdWJncm91cCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld1RvcCA9IG1hcmdpbi5heGlzO1xuICAgICAgICBmb3IgKHZhciBzdWJncm91cCBpbiBzdWJncm91cHMpIHtcbiAgICAgICAgICBpZiAoc3ViZ3JvdXBzLmhhc093blByb3BlcnR5KHN1Ymdyb3VwKSkge1xuICAgICAgICAgICAgaWYgKHN1Ymdyb3Vwc1tzdWJncm91cF0udmlzaWJsZSA9PSB0cnVlICYmIHN1Ymdyb3Vwc1tzdWJncm91cF0uaW5kZXggPCBzdWJncm91cHNbaXRlbXNbaV0uZGF0YS5zdWJncm91cF0uaW5kZXgpIHtcbiAgICAgICAgICAgICAgbmV3VG9wICs9IHN1Ymdyb3Vwc1tzdWJncm91cF0uaGVpZ2h0ICsgbWFyZ2luLml0ZW0udmVydGljYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGl0ZW1zW2ldLnRvcCA9IG5ld1RvcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZW1zW2ldLnRvcCA9IG1hcmdpbi5heGlzO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVGVzdCBpZiB0aGUgdHdvIHByb3ZpZGVkIGl0ZW1zIGNvbGxpZGVcbiAgICogVGhlIGl0ZW1zIG11c3QgaGF2ZSBwYXJhbWV0ZXJzIGxlZnQsIHdpZHRoLCB0b3AsIGFuZCBoZWlnaHQuXG4gICAqIEBwYXJhbSB7SXRlbX0gYSAgICAgICAgICBUaGUgZmlyc3QgaXRlbVxuICAgKiBAcGFyYW0ge0l0ZW19IGIgICAgICAgICAgVGhlIHNlY29uZCBpdGVtXG4gICAqIEBwYXJhbSB7e2hvcml6b250YWw6IG51bWJlciwgdmVydGljYWw6IG51bWJlcn19IG1hcmdpblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgYSBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bSByZXF1aXJlZCBtYXJnaW4uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcnRsXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59ICAgICAgICB0cnVlIGlmIGEgYW5kIGIgY29sbGlkZSwgZWxzZSBmYWxzZVxuICAgKi9cbiAgZXhwb3J0cy5jb2xsaXNpb24gPSBmdW5jdGlvbiAoYSwgYiwgbWFyZ2luLCBydGwpIHtcbiAgICBpZiAocnRsKSB7XG4gICAgICByZXR1cm4gYS5yaWdodCAtIG1hcmdpbi5ob3Jpem9udGFsICsgRVBTSUxPTiA8IGIucmlnaHQgKyBiLndpZHRoICYmIGEucmlnaHQgKyBhLndpZHRoICsgbWFyZ2luLmhvcml6b250YWwgLSBFUFNJTE9OID4gYi5yaWdodCAmJiBhLnRvcCAtIG1hcmdpbi52ZXJ0aWNhbCArIEVQU0lMT04gPCBiLnRvcCArIGIuaGVpZ2h0ICYmIGEudG9wICsgYS5oZWlnaHQgKyBtYXJnaW4udmVydGljYWwgLSBFUFNJTE9OID4gYi50b3A7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhLmxlZnQgLSBtYXJnaW4uaG9yaXpvbnRhbCArIEVQU0lMT04gPCBiLmxlZnQgKyBiLndpZHRoICYmIGEubGVmdCArIGEud2lkdGggKyBtYXJnaW4uaG9yaXpvbnRhbCAtIEVQU0lMT04gPiBiLmxlZnQgJiYgYS50b3AgLSBtYXJnaW4udmVydGljYWwgKyBFUFNJTE9OIDwgYi50b3AgKyBiLmhlaWdodCAmJiBhLnRvcCArIGEuaGVpZ2h0ICsgbWFyZ2luLnZlcnRpY2FsIC0gRVBTSUxPTiA+IGIudG9wO1xuICAgIH1cbiAgfTtcblxuLyoqKi8gfSxcbi8qIDM4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIEhhbW1lciA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuICB2YXIgSXRlbSA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3IgUmFuZ2VJdGVtXG4gICAqIEBleHRlbmRzIEl0ZW1cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgICAgICAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVycyBzdGFydCwgZW5kXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQsIGNsYXNzTmFtZS5cbiAgICogQHBhcmFtIHt7dG9TY3JlZW46IGZ1bmN0aW9uLCB0b1RpbWU6IGZ1bmN0aW9ufX0gY29udmVyc2lvblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb252ZXJzaW9uIGZ1bmN0aW9ucyBmcm9tIHRpbWUgdG8gc2NyZWVuIGFuZCB2aWNlIHZlcnNhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgICAgIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBkZXNjcmliZSBvcHRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBSYW5nZUl0ZW0oZGF0YSwgY29udmVyc2lvbiwgb3B0aW9ucykge1xuICAgIHRoaXMucHJvcHMgPSB7XG4gICAgICBjb250ZW50OiB7XG4gICAgICAgIHdpZHRoOiAwXG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLm92ZXJmbG93ID0gZmFsc2U7IC8vIGlmIGNvbnRlbnRzIGNhbiBvdmVyZmxvdyAoY3NzIHN0eWxpbmcpLCB0aGlzIGZsYWcgaXMgc2V0IHRvIHRydWVcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIC8vIHZhbGlkYXRlIGRhdGFcbiAgICBpZiAoZGF0YSkge1xuICAgICAgaWYgKGRhdGEuc3RhcnQgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvcGVydHkgXCJzdGFydFwiIG1pc3NpbmcgaW4gaXRlbSAnICsgZGF0YS5pZCk7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YS5lbmQgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvcGVydHkgXCJlbmRcIiBtaXNzaW5nIGluIGl0ZW0gJyArIGRhdGEuaWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIEl0ZW0uY2FsbCh0aGlzLCBkYXRhLCBjb252ZXJzaW9uLCBvcHRpb25zKTtcbiAgfVxuXG4gIFJhbmdlSXRlbS5wcm90b3R5cGUgPSBuZXcgSXRlbShudWxsLCBudWxsLCBudWxsKTtcblxuICBSYW5nZUl0ZW0ucHJvdG90eXBlLmJhc2VDbGFzc05hbWUgPSAndmlzLWl0ZW0gdmlzLXJhbmdlJztcblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciB0aGlzIGl0ZW0gaXMgdmlzaWJsZSBpbnNpZGUgZ2l2ZW4gcmFuZ2VcbiAgICogQHJldHVybnMge3tzdGFydDogTnVtYmVyLCBlbmQ6IE51bWJlcn19IHJhbmdlIHdpdGggYSB0aW1lc3RhbXAgZm9yIHN0YXJ0IGFuZCBlbmRcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmlzaWJsZVxuICAgKi9cbiAgUmFuZ2VJdGVtLnByb3RvdHlwZS5pc1Zpc2libGUgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAvLyBkZXRlcm1pbmUgdmlzaWJpbGl0eVxuICAgIHJldHVybiB0aGlzLmRhdGEuc3RhcnQgPCByYW5nZS5lbmQgJiYgdGhpcy5kYXRhLmVuZCA+IHJhbmdlLnN0YXJ0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXBhaW50IHRoZSBpdGVtXG4gICAqL1xuICBSYW5nZUl0ZW0ucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZG9tID0gdGhpcy5kb207XG4gICAgaWYgKCFkb20pIHtcbiAgICAgIC8vIGNyZWF0ZSBET01cbiAgICAgIHRoaXMuZG9tID0ge307XG4gICAgICBkb20gPSB0aGlzLmRvbTtcblxuICAgICAgLy8gYmFja2dyb3VuZCBib3hcbiAgICAgIGRvbS5ib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIC8vIGNsYXNzTmFtZSBpcyB1cGRhdGVkIGluIHJlZHJhdygpXG5cbiAgICAgIC8vIGZyYW1lIGJveCAodG8gcHJldmVudCB0aGUgaXRlbSBjb250ZW50cyBmcm9tIG92ZXJmbG93aW5nXG4gICAgICBkb20uZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRvbS5mcmFtZS5jbGFzc05hbWUgPSAndmlzLWl0ZW0tb3ZlcmZsb3cnO1xuICAgICAgZG9tLmJveC5hcHBlbmRDaGlsZChkb20uZnJhbWUpO1xuXG4gICAgICAvLyBjb250ZW50cyBib3hcbiAgICAgIGRvbS5jb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkb20uY29udGVudC5jbGFzc05hbWUgPSAndmlzLWl0ZW0tY29udGVudCc7XG4gICAgICBkb20uZnJhbWUuYXBwZW5kQ2hpbGQoZG9tLmNvbnRlbnQpO1xuXG4gICAgICAvLyBhdHRhY2ggdGhpcyBpdGVtIGFzIGF0dHJpYnV0ZVxuICAgICAgZG9tLmJveFsndGltZWxpbmUtaXRlbSddID0gdGhpcztcblxuICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gYXBwZW5kIERPTSB0byBwYXJlbnQgRE9NXG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVkcmF3IGl0ZW06IG5vIHBhcmVudCBhdHRhY2hlZCcpO1xuICAgIH1cbiAgICBpZiAoIWRvbS5ib3gucGFyZW50Tm9kZSkge1xuICAgICAgdmFyIGZvcmVncm91bmQgPSB0aGlzLnBhcmVudC5kb20uZm9yZWdyb3VuZDtcbiAgICAgIGlmICghZm9yZWdyb3VuZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWRyYXcgaXRlbTogcGFyZW50IGhhcyBubyBmb3JlZ3JvdW5kIGNvbnRhaW5lciBlbGVtZW50Jyk7XG4gICAgICB9XG4gICAgICBmb3JlZ3JvdW5kLmFwcGVuZENoaWxkKGRvbS5ib3gpO1xuICAgIH1cbiAgICB0aGlzLmRpc3BsYXllZCA9IHRydWU7XG5cbiAgICAvLyBVcGRhdGUgRE9NIHdoZW4gaXRlbSBpcyBtYXJrZWQgZGlydHkuIEFuIGl0ZW0gaXMgbWFya2VkIGRpcnR5IHdoZW46XG4gICAgLy8gLSB0aGUgaXRlbSBpcyBub3QgeWV0IHJlbmRlcmVkXG4gICAgLy8gLSB0aGUgaXRlbSdzIGRhdGEgaXMgY2hhbmdlZFxuICAgIC8vIC0gdGhlIGl0ZW0gaXMgc2VsZWN0ZWQvZGVzZWxlY3RlZFxuICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICB0aGlzLl91cGRhdGVDb250ZW50cyh0aGlzLmRvbS5jb250ZW50KTtcbiAgICAgIHRoaXMuX3VwZGF0ZVRpdGxlKHRoaXMuZG9tLmJveCk7XG4gICAgICB0aGlzLl91cGRhdGVEYXRhQXR0cmlidXRlcyh0aGlzLmRvbS5ib3gpO1xuICAgICAgdGhpcy5fdXBkYXRlU3R5bGUodGhpcy5kb20uYm94KTtcblxuICAgICAgdmFyIGVkaXRhYmxlID0gKHRoaXMub3B0aW9ucy5lZGl0YWJsZS51cGRhdGVUaW1lIHx8IHRoaXMub3B0aW9ucy5lZGl0YWJsZS51cGRhdGVHcm91cCB8fCB0aGlzLmVkaXRhYmxlID09PSB0cnVlKSAmJiB0aGlzLmVkaXRhYmxlICE9PSBmYWxzZTtcblxuICAgICAgLy8gdXBkYXRlIGNsYXNzXG4gICAgICB2YXIgY2xhc3NOYW1lID0gKHRoaXMuZGF0YS5jbGFzc05hbWUgPyAnICcgKyB0aGlzLmRhdGEuY2xhc3NOYW1lIDogJycpICsgKHRoaXMuc2VsZWN0ZWQgPyAnIHZpcy1zZWxlY3RlZCcgOiAnJykgKyAoZWRpdGFibGUgPyAnIHZpcy1lZGl0YWJsZScgOiAnIHZpcy1yZWFkb25seScpO1xuICAgICAgZG9tLmJveC5jbGFzc05hbWUgPSB0aGlzLmJhc2VDbGFzc05hbWUgKyBjbGFzc05hbWU7XG5cbiAgICAgIC8vIGRldGVybWluZSBmcm9tIGNzcyB3aGV0aGVyIHRoaXMgYm94IGhhcyBvdmVyZmxvd1xuICAgICAgdGhpcy5vdmVyZmxvdyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvbS5mcmFtZSkub3ZlcmZsb3cgIT09ICdoaWRkZW4nO1xuXG4gICAgICAvLyByZWNhbGN1bGF0ZSBzaXplXG4gICAgICAvLyB0dXJuIG9mZiBtYXgtd2lkdGggdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgdGhlIHJlYWwgd2lkdGhcbiAgICAgIC8vIHRoaXMgY2F1c2VzIGFuIGV4dHJhIGJyb3dzZXIgcmVwYWludC9yZWZsb3csIGJ1dCBzbyBiZSBpdFxuICAgICAgdGhpcy5kb20uY29udGVudC5zdHlsZS5tYXhXaWR0aCA9ICdub25lJztcbiAgICAgIHRoaXMucHJvcHMuY29udGVudC53aWR0aCA9IHRoaXMuZG9tLmNvbnRlbnQub2Zmc2V0V2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuZG9tLmJveC5vZmZzZXRIZWlnaHQ7XG4gICAgICB0aGlzLmRvbS5jb250ZW50LnN0eWxlLm1heFdpZHRoID0gJyc7XG5cbiAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5fcmVwYWludERlbGV0ZUJ1dHRvbihkb20uYm94KTtcbiAgICB0aGlzLl9yZXBhaW50RHJhZ0xlZnQoKTtcbiAgICB0aGlzLl9yZXBhaW50RHJhZ1JpZ2h0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNob3cgdGhlIGl0ZW0gaW4gdGhlIERPTSAod2hlbiBub3QgYWxyZWFkeSB2aXNpYmxlKS4gVGhlIGl0ZW1zIERPTSB3aWxsXG4gICAqIGJlIGNyZWF0ZWQgd2hlbiBuZWVkZWQuXG4gICAqL1xuICBSYW5nZUl0ZW0ucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmRpc3BsYXllZCkge1xuICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhpZGUgdGhlIGl0ZW0gZnJvbSB0aGUgRE9NICh3aGVuIHZpc2libGUpXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGNoYW5nZWRcbiAgICovXG4gIFJhbmdlSXRlbS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5kaXNwbGF5ZWQpIHtcbiAgICAgIHZhciBib3ggPSB0aGlzLmRvbS5ib3g7XG5cbiAgICAgIGlmIChib3gucGFyZW50Tm9kZSkge1xuICAgICAgICBib3gucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChib3gpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRpc3BsYXllZCA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVwb3NpdGlvbiB0aGUgaXRlbSBob3Jpem9udGFsbHlcbiAgICogQHBhcmFtIHtib29sZWFufSBbbGltaXRTaXplPXRydWVdIElmIHRydWUgKGRlZmF1bHQpLCB0aGUgd2lkdGggb2YgdGhlIHJhbmdlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtIHdpbGwgYmUgbGltaXRlZCwgYXMgdGhlIGJyb3dzZXIgY2Fubm90XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5IHZlcnkgd2lkZSBkaXZzLiBUaGlzIG1lYW5zIHRob3VnaFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdCB0aGUgYXBwbGllZCBsZWZ0IGFuZCB3aWR0aCBtYXlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdCBjb3JyZXNwb25kIHRvIHRoZSByYW5nZXMgc3RhcnQgYW5kIGVuZFxuICAgKiBAT3ZlcnJpZGVcbiAgICovXG4gIFJhbmdlSXRlbS5wcm90b3R5cGUucmVwb3NpdGlvblggPSBmdW5jdGlvbiAobGltaXRTaXplKSB7XG4gICAgdmFyIHBhcmVudFdpZHRoID0gdGhpcy5wYXJlbnQud2lkdGg7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5jb252ZXJzaW9uLnRvU2NyZWVuKHRoaXMuZGF0YS5zdGFydCk7XG4gICAgdmFyIGVuZCA9IHRoaXMuY29udmVyc2lvbi50b1NjcmVlbih0aGlzLmRhdGEuZW5kKTtcbiAgICB2YXIgY29udGVudFN0YXJ0UG9zaXRpb247XG4gICAgdmFyIGNvbnRlbnRXaWR0aDtcblxuICAgIC8vIGxpbWl0IHRoZSB3aWR0aCBvZiB0aGUgcmFuZ2UsIGFzIGJyb3dzZXJzIGNhbm5vdCBkcmF3IHZlcnkgd2lkZSBkaXZzXG4gICAgaWYgKGxpbWl0U2l6ZSA9PT0gdW5kZWZpbmVkIHx8IGxpbWl0U2l6ZSA9PT0gdHJ1ZSkge1xuICAgICAgaWYgKHN0YXJ0IDwgLXBhcmVudFdpZHRoKSB7XG4gICAgICAgIHN0YXJ0ID0gLXBhcmVudFdpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCA+IDIgKiBwYXJlbnRXaWR0aCkge1xuICAgICAgICBlbmQgPSAyICogcGFyZW50V2lkdGg7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBib3hXaWR0aCA9IE1hdGgubWF4KGVuZCAtIHN0YXJ0LCAxKTtcblxuICAgIGlmICh0aGlzLm92ZXJmbG93KSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgICB0aGlzLnJpZ2h0ID0gc3RhcnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxlZnQgPSBzdGFydDtcbiAgICAgIH1cbiAgICAgIHRoaXMud2lkdGggPSBib3hXaWR0aCArIHRoaXMucHJvcHMuY29udGVudC53aWR0aDtcbiAgICAgIGNvbnRlbnRXaWR0aCA9IHRoaXMucHJvcHMuY29udGVudC53aWR0aDtcblxuICAgICAgLy8gTm90ZTogVGhlIGNhbGN1bGF0aW9uIG9mIHdpZHRoIGlzIGFuIG9wdGltaXN0aWMgY2FsY3VsYXRpb24sIGdpdmluZ1xuICAgICAgLy8gICAgICAgYSB3aWR0aCB3aGljaCB3aWxsIG5vdCBjaGFuZ2Ugd2hlbiBtb3ZpbmcgdGhlIFRpbWVsaW5lXG4gICAgICAvLyAgICAgICBTbyBubyByZS1zdGFja2luZyBuZWVkZWQsIHdoaWNoIGlzIG5pY2VyIGZvciB0aGUgZXllO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucnRsKSB7XG4gICAgICAgICAgdGhpcy5yaWdodCA9IHN0YXJ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubGVmdCA9IHN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2lkdGggPSBib3hXaWR0aDtcbiAgICAgICAgY29udGVudFdpZHRoID0gTWF0aC5taW4oZW5kIC0gc3RhcnQsIHRoaXMucHJvcHMuY29udGVudC53aWR0aCk7XG4gICAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgdGhpcy5kb20uYm94LnN0eWxlLnJpZ2h0ID0gdGhpcy5yaWdodCArICdweCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZG9tLmJveC5zdHlsZS5sZWZ0ID0gdGhpcy5sZWZ0ICsgJ3B4JztcbiAgICB9XG4gICAgdGhpcy5kb20uYm94LnN0eWxlLndpZHRoID0gYm94V2lkdGggKyAncHgnO1xuXG4gICAgc3dpdGNoICh0aGlzLm9wdGlvbnMuYWxpZ24pIHtcbiAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgICAgIHRoaXMuZG9tLmNvbnRlbnQuc3R5bGUucmlnaHQgPSAnMCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kb20uY29udGVudC5zdHlsZS5sZWZ0ID0gJzAnO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucnRsKSB7XG4gICAgICAgICAgdGhpcy5kb20uY29udGVudC5zdHlsZS5yaWdodCA9IE1hdGgubWF4KGJveFdpZHRoIC0gY29udGVudFdpZHRoLCAwKSArICdweCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kb20uY29udGVudC5zdHlsZS5sZWZ0ID0gTWF0aC5tYXgoYm94V2lkdGggLSBjb250ZW50V2lkdGgsIDApICsgJ3B4JztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgICAgICB0aGlzLmRvbS5jb250ZW50LnN0eWxlLnJpZ2h0ID0gTWF0aC5tYXgoKGJveFdpZHRoIC0gY29udGVudFdpZHRoKSAvIDIsIDApICsgJ3B4JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRvbS5jb250ZW50LnN0eWxlLmxlZnQgPSBNYXRoLm1heCgoYm94V2lkdGggLSBjb250ZW50V2lkdGgpIC8gMiwgMCkgKyAncHgnO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vICdhdXRvJ1xuICAgICAgICAvLyB3aGVuIHJhbmdlIGV4Y2VlZHMgbGVmdCBvZiB0aGUgd2luZG93LCBwb3NpdGlvbiB0aGUgY29udGVudHMgYXQgdGhlIGxlZnQgb2YgdGhlIHZpc2libGUgYXJlYVxuICAgICAgICBpZiAodGhpcy5vdmVyZmxvdykge1xuICAgICAgICAgIGlmIChlbmQgPiAwKSB7XG4gICAgICAgICAgICBjb250ZW50U3RhcnRQb3NpdGlvbiA9IE1hdGgubWF4KC1zdGFydCwgMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRlbnRTdGFydFBvc2l0aW9uID0gLWNvbnRlbnRXaWR0aDsgLy8gZW5zdXJlIGl0J3Mgbm90IHZpc2libGUgYW55bW9yZVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgICAgY29udGVudFN0YXJ0UG9zaXRpb24gPSAtc3RhcnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb250ZW50U3RhcnRQb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgICAgIHRoaXMuZG9tLmNvbnRlbnQuc3R5bGUucmlnaHQgPSBjb250ZW50U3RhcnRQb3NpdGlvbiArICdweCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kb20uY29udGVudC5zdHlsZS5sZWZ0ID0gY29udGVudFN0YXJ0UG9zaXRpb24gKyAncHgnO1xuICAgICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXBvc2l0aW9uIHRoZSBpdGVtIHZlcnRpY2FsbHlcbiAgICogQE92ZXJyaWRlXG4gICAqL1xuICBSYW5nZUl0ZW0ucHJvdG90eXBlLnJlcG9zaXRpb25ZID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcmllbnRhdGlvbiA9IHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5pdGVtO1xuICAgIHZhciBib3ggPSB0aGlzLmRvbS5ib3g7XG5cbiAgICBpZiAob3JpZW50YXRpb24gPT0gJ3RvcCcpIHtcbiAgICAgIGJveC5zdHlsZS50b3AgPSB0aGlzLnRvcCArICdweCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJveC5zdHlsZS50b3AgPSB0aGlzLnBhcmVudC5oZWlnaHQgLSB0aGlzLnRvcCAtIHRoaXMuaGVpZ2h0ICsgJ3B4JztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcGFpbnQgYSBkcmFnIGFyZWEgb24gdGhlIGxlZnQgc2lkZSBvZiB0aGUgcmFuZ2Ugd2hlbiB0aGUgcmFuZ2UgaXMgc2VsZWN0ZWRcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgUmFuZ2VJdGVtLnByb3RvdHlwZS5fcmVwYWludERyYWdMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnNlbGVjdGVkICYmIHRoaXMub3B0aW9ucy5lZGl0YWJsZS51cGRhdGVUaW1lICYmICF0aGlzLmRvbS5kcmFnTGVmdCkge1xuICAgICAgLy8gY3JlYXRlIGFuZCBzaG93IGRyYWcgYXJlYVxuICAgICAgdmFyIGRyYWdMZWZ0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkcmFnTGVmdC5jbGFzc05hbWUgPSAndmlzLWRyYWctbGVmdCc7XG4gICAgICBkcmFnTGVmdC5kcmFnTGVmdEl0ZW0gPSB0aGlzO1xuXG4gICAgICB0aGlzLmRvbS5ib3guYXBwZW5kQ2hpbGQoZHJhZ0xlZnQpO1xuICAgICAgdGhpcy5kb20uZHJhZ0xlZnQgPSBkcmFnTGVmdDtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnNlbGVjdGVkICYmIHRoaXMuZG9tLmRyYWdMZWZ0KSB7XG4gICAgICAvLyBkZWxldGUgZHJhZyBhcmVhXG4gICAgICBpZiAodGhpcy5kb20uZHJhZ0xlZnQucGFyZW50Tm9kZSkge1xuICAgICAgICB0aGlzLmRvbS5kcmFnTGVmdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLmRyYWdMZWZ0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZG9tLmRyYWdMZWZ0ID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcGFpbnQgYSBkcmFnIGFyZWEgb24gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIHJhbmdlIHdoZW4gdGhlIHJhbmdlIGlzIHNlbGVjdGVkXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIFJhbmdlSXRlbS5wcm90b3R5cGUuX3JlcGFpbnREcmFnUmlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuc2VsZWN0ZWQgJiYgdGhpcy5vcHRpb25zLmVkaXRhYmxlLnVwZGF0ZVRpbWUgJiYgIXRoaXMuZG9tLmRyYWdSaWdodCkge1xuICAgICAgLy8gY3JlYXRlIGFuZCBzaG93IGRyYWcgYXJlYVxuICAgICAgdmFyIGRyYWdSaWdodCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZHJhZ1JpZ2h0LmNsYXNzTmFtZSA9ICd2aXMtZHJhZy1yaWdodCc7XG4gICAgICBkcmFnUmlnaHQuZHJhZ1JpZ2h0SXRlbSA9IHRoaXM7XG5cbiAgICAgIHRoaXMuZG9tLmJveC5hcHBlbmRDaGlsZChkcmFnUmlnaHQpO1xuICAgICAgdGhpcy5kb20uZHJhZ1JpZ2h0ID0gZHJhZ1JpZ2h0O1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuc2VsZWN0ZWQgJiYgdGhpcy5kb20uZHJhZ1JpZ2h0KSB7XG4gICAgICAvLyBkZWxldGUgZHJhZyBhcmVhXG4gICAgICBpZiAodGhpcy5kb20uZHJhZ1JpZ2h0LnBhcmVudE5vZGUpIHtcbiAgICAgICAgdGhpcy5kb20uZHJhZ1JpZ2h0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20uZHJhZ1JpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZG9tLmRyYWdSaWdodCA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gUmFuZ2VJdGVtO1xuXG4vKioqLyB9LFxuLyogMzkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgSGFtbWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yIEl0ZW1cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgICAgICAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgKG9wdGlvbmFsKSBwYXJhbWV0ZXJzIHR5cGUsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0LCBlbmQsIGNvbnRlbnQsIGdyb3VwLCBjbGFzc05hbWUuXG4gICAqIEBwYXJhbSB7e3RvU2NyZWVuOiBmdW5jdGlvbiwgdG9UaW1lOiBmdW5jdGlvbn19IGNvbnZlcnNpb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29udmVyc2lvbiBmdW5jdGlvbnMgZnJvbSB0aW1lIHRvIHNjcmVlbiBhbmQgdmljZSB2ZXJzYVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgICAgICAgICBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogZGVzY3JpYmUgYXZhaWxhYmxlIG9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIEl0ZW0oZGF0YSwgY29udmVyc2lvbiwgb3B0aW9ucykge1xuICAgIHRoaXMuaWQgPSBudWxsO1xuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuZG9tID0gbnVsbDtcbiAgICB0aGlzLmNvbnZlcnNpb24gPSBjb252ZXJzaW9uIHx8IHt9O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5kaXNwbGF5ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICAgIHRoaXMudG9wID0gbnVsbDtcbiAgICB0aGlzLnJpZ2h0ID0gbnVsbDtcbiAgICB0aGlzLmxlZnQgPSBudWxsO1xuICAgIHRoaXMud2lkdGggPSBudWxsO1xuICAgIHRoaXMuaGVpZ2h0ID0gbnVsbDtcblxuICAgIHRoaXMuZWRpdGFibGUgPSBudWxsO1xuICAgIGlmICh0aGlzLmRhdGEgJiYgdGhpcy5kYXRhLmhhc093blByb3BlcnR5KCdlZGl0YWJsZScpICYmIHR5cGVvZiB0aGlzLmRhdGEuZWRpdGFibGUgPT09ICdib29sZWFuJykge1xuICAgICAgdGhpcy5lZGl0YWJsZSA9IGRhdGEuZWRpdGFibGU7XG4gICAgfVxuICB9XG5cbiAgSXRlbS5wcm90b3R5cGUuc3RhY2sgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBTZWxlY3QgY3VycmVudCBpdGVtXG4gICAqL1xuICBJdGVtLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zZWxlY3RlZCA9IHRydWU7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgaWYgKHRoaXMuZGlzcGxheWVkKSB0aGlzLnJlZHJhdygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVbnNlbGVjdCBjdXJyZW50IGl0ZW1cbiAgICovXG4gIEl0ZW0ucHJvdG90eXBlLnVuc2VsZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5kaXNwbGF5ZWQpIHRoaXMucmVkcmF3KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBkYXRhIGZvciB0aGUgaXRlbS4gRXhpc3RpbmcgZGF0YSB3aWxsIGJlIHVwZGF0ZWQuIFRoZSBpZCBzaG91bGQgbm90XG4gICAqIGJlIGNoYW5nZWQuIFdoZW4gdGhlIGl0ZW0gaXMgZGlzcGxheWVkLCBpdCB3aWxsIGJlIHJlZHJhd24gaW1tZWRpYXRlbHkuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqL1xuICBJdGVtLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgZ3JvdXBDaGFuZ2VkID0gZGF0YS5ncm91cCAhPSB1bmRlZmluZWQgJiYgdGhpcy5kYXRhLmdyb3VwICE9IGRhdGEuZ3JvdXA7XG4gICAgaWYgKGdyb3VwQ2hhbmdlZCkge1xuICAgICAgdGhpcy5wYXJlbnQuaXRlbVNldC5fbW92ZVRvR3JvdXAodGhpcywgZGF0YS5ncm91cCk7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoJ2VkaXRhYmxlJykgJiYgdHlwZW9mIGRhdGEuZWRpdGFibGUgPT09ICdib29sZWFuJykge1xuICAgICAgdGhpcy5lZGl0YWJsZSA9IGRhdGEuZWRpdGFibGU7XG4gICAgfVxuXG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5kaXNwbGF5ZWQpIHRoaXMucmVkcmF3KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBhIHBhcmVudCBmb3IgdGhlIGl0ZW1cbiAgICogQHBhcmFtIHtJdGVtU2V0IHwgR3JvdXB9IHBhcmVudFxuICAgKi9cbiAgSXRlbS5wcm90b3R5cGUuc2V0UGFyZW50ID0gZnVuY3Rpb24gKHBhcmVudCkge1xuICAgIGlmICh0aGlzLmRpc3BsYXllZCkge1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoaXMgaXRlbSBpcyB2aXNpYmxlIGluc2lkZSBnaXZlbiByYW5nZVxuICAgKiBAcmV0dXJucyB7e3N0YXJ0OiBOdW1iZXIsIGVuZDogTnVtYmVyfX0gcmFuZ2Ugd2l0aCBhIHRpbWVzdGFtcCBmb3Igc3RhcnQgYW5kIGVuZFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2aXNpYmxlXG4gICAqL1xuICBJdGVtLnByb3RvdHlwZS5pc1Zpc2libGUgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAvLyBTaG91bGQgYmUgaW1wbGVtZW50ZWQgYnkgSXRlbSBpbXBsZW1lbnRhdGlvbnNcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNob3cgdGhlIEl0ZW0gaW4gdGhlIERPTSAod2hlbiBub3QgYWxyZWFkeSB2aXNpYmxlKVxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBjaGFuZ2VkXG4gICAqL1xuICBJdGVtLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogSGlkZSB0aGUgSXRlbSBmcm9tIHRoZSBET00gKHdoZW4gdmlzaWJsZSlcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gY2hhbmdlZFxuICAgKi9cbiAgSXRlbS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcGFpbnQgdGhlIGl0ZW1cbiAgICovXG4gIEl0ZW0ucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgYnkgdGhlIGl0ZW1cbiAgfTtcblxuICAvKipcbiAgICogUmVwb3NpdGlvbiB0aGUgSXRlbSBob3Jpem9udGFsbHlcbiAgICovXG4gIEl0ZW0ucHJvdG90eXBlLnJlcG9zaXRpb25YID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBieSB0aGUgaXRlbVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXBvc2l0aW9uIHRoZSBJdGVtIHZlcnRpY2FsbHlcbiAgICovXG4gIEl0ZW0ucHJvdG90eXBlLnJlcG9zaXRpb25ZID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBieSB0aGUgaXRlbVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXBhaW50IGEgZGVsZXRlIGJ1dHRvbiBvbiB0aGUgdG9wIHJpZ2h0IG9mIHRoZSBpdGVtIHdoZW4gdGhlIGl0ZW0gaXMgc2VsZWN0ZWRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gYW5jaG9yXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIEl0ZW0ucHJvdG90eXBlLl9yZXBhaW50RGVsZXRlQnV0dG9uID0gZnVuY3Rpb24gKGFuY2hvcikge1xuICAgIHZhciBlZGl0YWJsZSA9ICh0aGlzLm9wdGlvbnMuZWRpdGFibGUucmVtb3ZlIHx8IHRoaXMuZGF0YS5lZGl0YWJsZSA9PT0gdHJ1ZSkgJiYgdGhpcy5kYXRhLmVkaXRhYmxlICE9PSBmYWxzZTtcblxuICAgIGlmICh0aGlzLnNlbGVjdGVkICYmIGVkaXRhYmxlICYmICF0aGlzLmRvbS5kZWxldGVCdXR0b24pIHtcbiAgICAgIC8vIGNyZWF0ZSBhbmQgc2hvdyBidXR0b25cbiAgICAgIHZhciBtZSA9IHRoaXM7XG5cbiAgICAgIHZhciBkZWxldGVCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgICAgZGVsZXRlQnV0dG9uLmNsYXNzTmFtZSA9ICd2aXMtZGVsZXRlLXJ0bCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVCdXR0b24uY2xhc3NOYW1lID0gJ3Zpcy1kZWxldGUnO1xuICAgICAgfVxuICAgICAgZGVsZXRlQnV0dG9uLnRpdGxlID0gJ0RlbGV0ZSB0aGlzIGl0ZW0nO1xuXG4gICAgICAvLyBUT0RPOiBiZSBhYmxlIHRvIGRlc3Ryb3kgdGhlIGRlbGV0ZSBidXR0b25cbiAgICAgIG5ldyBIYW1tZXIoZGVsZXRlQnV0dG9uKS5vbigndGFwJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBtZS5wYXJlbnQucmVtb3ZlRnJvbURhdGFTZXQobWUpO1xuICAgICAgfSk7XG5cbiAgICAgIGFuY2hvci5hcHBlbmRDaGlsZChkZWxldGVCdXR0b24pO1xuICAgICAgdGhpcy5kb20uZGVsZXRlQnV0dG9uID0gZGVsZXRlQnV0dG9uO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuc2VsZWN0ZWQgJiYgdGhpcy5kb20uZGVsZXRlQnV0dG9uKSB7XG4gICAgICAvLyByZW1vdmUgYnV0dG9uXG4gICAgICBpZiAodGhpcy5kb20uZGVsZXRlQnV0dG9uLnBhcmVudE5vZGUpIHtcbiAgICAgICAgdGhpcy5kb20uZGVsZXRlQnV0dG9uLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20uZGVsZXRlQnV0dG9uKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZG9tLmRlbGV0ZUJ1dHRvbiA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgSFRNTCBjb250ZW50cyBmb3IgdGhlIGl0ZW1cbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50ICAgSFRNTCBlbGVtZW50IHRvIGZpbGwgd2l0aCB0aGUgY29udGVudHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEl0ZW0ucHJvdG90eXBlLl91cGRhdGVDb250ZW50cyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgdmFyIGNvbnRlbnQ7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50ZW1wbGF0ZSkge1xuICAgICAgdmFyIGl0ZW1EYXRhID0gdGhpcy5wYXJlbnQuaXRlbVNldC5pdGVtc0RhdGEuZ2V0KHRoaXMuaWQpOyAvLyBnZXQgYSBjbG9uZSBvZiB0aGUgZGF0YSBmcm9tIHRoZSBkYXRhc2V0XG4gICAgICBjb250ZW50ID0gdGhpcy5vcHRpb25zLnRlbXBsYXRlKGl0ZW1EYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudCA9IHRoaXMuZGF0YS5jb250ZW50O1xuICAgIH1cblxuICAgIHZhciBjaGFuZ2VkID0gdGhpcy5fY29udGVudFRvU3RyaW5nKHRoaXMuY29udGVudCkgIT09IHRoaXMuX2NvbnRlbnRUb1N0cmluZyhjb250ZW50KTtcbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgLy8gb25seSByZXBsYWNlIHRoZSBjb250ZW50IHdoZW4gY2hhbmdlZFxuICAgICAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgICB9IGVsc2UgaWYgKGNvbnRlbnQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gY29udGVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghKHRoaXMuZGF0YS50eXBlID09ICdiYWNrZ3JvdW5kJyAmJiB0aGlzLmRhdGEuY29udGVudCA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvcGVydHkgXCJjb250ZW50XCIgbWlzc2luZyBpbiBpdGVtICcgKyB0aGlzLmlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0IEhUTUwgY29udGVudHMgZm9yIHRoZSBpdGVtXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAgIEhUTUwgZWxlbWVudCB0byBmaWxsIHdpdGggdGhlIGNvbnRlbnRzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBJdGVtLnByb3RvdHlwZS5fdXBkYXRlVGl0bGUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIGlmICh0aGlzLmRhdGEudGl0bGUgIT0gbnVsbCkge1xuICAgICAgZWxlbWVudC50aXRsZSA9IHRoaXMuZGF0YS50aXRsZSB8fCAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3Zpcy10aXRsZScpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUHJvY2VzcyBkYXRhQXR0cmlidXRlcyB0aW1lbGluZSBvcHRpb24gYW5kIHNldCBhcyBkYXRhLSBhdHRyaWJ1dGVzIG9uIGRvbS5jb250ZW50XG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAgIEhUTUwgZWxlbWVudCB0byB3aGljaCB0aGUgYXR0cmlidXRlcyB3aWxsIGJlIGF0dGFjaGVkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBJdGVtLnByb3RvdHlwZS5fdXBkYXRlRGF0YUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZGF0YUF0dHJpYnV0ZXMgJiYgdGhpcy5vcHRpb25zLmRhdGFBdHRyaWJ1dGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gW107XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMub3B0aW9ucy5kYXRhQXR0cmlidXRlcykpIHtcbiAgICAgICAgYXR0cmlidXRlcyA9IHRoaXMub3B0aW9ucy5kYXRhQXR0cmlidXRlcztcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmRhdGFBdHRyaWJ1dGVzID09ICdhbGwnKSB7XG4gICAgICAgIGF0dHJpYnV0ZXMgPSBPYmplY3Qua2V5cyh0aGlzLmRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5hbWUgPSBhdHRyaWJ1dGVzW2ldO1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmRhdGFbbmFtZV07XG5cbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS0nICsgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdkYXRhLScgKyBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIGN1c3RvbSBzdHlsZXMgb2YgdGhlIGVsZW1lbnRcbiAgICogQHBhcmFtIGVsZW1lbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEl0ZW0ucHJvdG90eXBlLl91cGRhdGVTdHlsZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgLy8gcmVtb3ZlIG9sZCBzdHlsZXNcbiAgICBpZiAodGhpcy5zdHlsZSkge1xuICAgICAgdXRpbC5yZW1vdmVDc3NUZXh0KGVsZW1lbnQsIHRoaXMuc3R5bGUpO1xuICAgICAgdGhpcy5zdHlsZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gYXBwZW5kIG5ldyBzdHlsZXNcbiAgICBpZiAodGhpcy5kYXRhLnN0eWxlKSB7XG4gICAgICB1dGlsLmFkZENzc1RleHQoZWxlbWVudCwgdGhpcy5kYXRhLnN0eWxlKTtcbiAgICAgIHRoaXMuc3R5bGUgPSB0aGlzLmRhdGEuc3R5bGU7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTdHJpbmdpZnkgdGhlIGl0ZW1zIGNvbnRlbnRzXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgRWxlbWVudCB8IHVuZGVmaW5lZH0gY29udGVudFxuICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgSXRlbS5wcm90b3R5cGUuX2NvbnRlbnRUb1N0cmluZyA9IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgcmV0dXJuIGNvbnRlbnQ7XG4gICAgaWYgKGNvbnRlbnQgJiYgJ291dGVySFRNTCcgaW4gY29udGVudCkgcmV0dXJuIGNvbnRlbnQub3V0ZXJIVE1MO1xuICAgIHJldHVybiBjb250ZW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHdpZHRoIG9mIHRoZSBpdGVtIGxlZnQgZnJvbSBpdHMgc3RhcnQgZGF0ZVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBJdGVtLnByb3RvdHlwZS5nZXRXaWR0aExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIDA7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgd2lkdGggb2YgdGhlIGl0ZW0gcmlnaHQgZnJvbSB0aGUgbWF4IG9mIGl0cyBzdGFydCBhbmQgZW5kIGRhdGVcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgSXRlbS5wcm90b3R5cGUuZ2V0V2lkdGhSaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gMDtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IEl0ZW07XG5cbi8qKiovIH0sXG4vKiA0MCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbiAgdmFyIEdyb3VwID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNik7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvciBCYWNrZ3JvdW5kR3JvdXBcbiAgICogQHBhcmFtIHtOdW1iZXIgfCBTdHJpbmd9IGdyb3VwSWRcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogQHBhcmFtIHtJdGVtU2V0fSBpdGVtU2V0XG4gICAqL1xuICBmdW5jdGlvbiBCYWNrZ3JvdW5kR3JvdXAoZ3JvdXBJZCwgZGF0YSwgaXRlbVNldCkge1xuICAgIEdyb3VwLmNhbGwodGhpcywgZ3JvdXBJZCwgZGF0YSwgaXRlbVNldCk7XG5cbiAgICB0aGlzLndpZHRoID0gMDtcbiAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgdGhpcy50b3AgPSAwO1xuICAgIHRoaXMubGVmdCA9IDA7XG4gIH1cblxuICBCYWNrZ3JvdW5kR3JvdXAucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcm91cC5wcm90b3R5cGUpO1xuXG4gIC8qKlxuICAgKiBSZXBhaW50IHRoaXMgZ3JvdXBcbiAgICogQHBhcmFtIHt7c3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXJ9fSByYW5nZVxuICAgKiBAcGFyYW0ge3tpdGVtOiB7aG9yaXpvbnRhbDogbnVtYmVyLCB2ZXJ0aWNhbDogbnVtYmVyfSwgYXhpczogbnVtYmVyfX0gbWFyZ2luXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Jlc3RhY2s9ZmFsc2VdICBGb3JjZSByZXN0YWNraW5nIG9mIGFsbCBpdGVtc1xuICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGdyb3VwIGlzIHJlc2l6ZWRcbiAgICovXG4gIEJhY2tncm91bmRHcm91cC5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24gKHJhbmdlLCBtYXJnaW4sIHJlc3RhY2spIHtcbiAgICB2YXIgcmVzaXplZCA9IGZhbHNlO1xuXG4gICAgdGhpcy52aXNpYmxlSXRlbXMgPSB0aGlzLl91cGRhdGVWaXNpYmxlSXRlbXModGhpcy5vcmRlcmVkSXRlbXMsIHRoaXMudmlzaWJsZUl0ZW1zLCByYW5nZSk7XG5cbiAgICAvLyBjYWxjdWxhdGUgYWN0dWFsIHNpemVcbiAgICB0aGlzLndpZHRoID0gdGhpcy5kb20uYmFja2dyb3VuZC5vZmZzZXRXaWR0aDtcblxuICAgIC8vIGFwcGx5IG5ldyBoZWlnaHQgKGp1c3QgYWx3YXlzIHplcm8gZm9yIEJhY2tncm91bmRHcm91cFxuICAgIHRoaXMuZG9tLmJhY2tncm91bmQuc3R5bGUuaGVpZ2h0ID0gJzAnO1xuXG4gICAgLy8gdXBkYXRlIHZlcnRpY2FsIHBvc2l0aW9uIG9mIGl0ZW1zIGFmdGVyIHRoZXkgYXJlIHJlLXN0YWNrZWQgYW5kIHRoZSBoZWlnaHQgb2YgdGhlIGdyb3VwIGlzIGNhbGN1bGF0ZWRcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLnZpc2libGVJdGVtcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IHRoaXMudmlzaWJsZUl0ZW1zW2ldO1xuICAgICAgaXRlbS5yZXBvc2l0aW9uWShtYXJnaW4pO1xuICAgIH1cblxuICAgIHJldHVybiByZXNpemVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTaG93IHRoaXMgZ3JvdXA6IGF0dGFjaCB0byB0aGUgRE9NXG4gICAqL1xuICBCYWNrZ3JvdW5kR3JvdXAucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmRvbS5iYWNrZ3JvdW5kLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuaXRlbVNldC5kb20uYmFja2dyb3VuZC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5iYWNrZ3JvdW5kKTtcbiAgICB9XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBCYWNrZ3JvdW5kR3JvdXA7XG5cbi8qKiovIH0sXG4vKiA0MSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBJdGVtID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yIEJveEl0ZW1cbiAgICogQGV4dGVuZHMgSXRlbVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAgICAgICAgICAgICBPYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJzIHN0YXJ0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQsIGNsYXNzTmFtZS5cbiAgICogQHBhcmFtIHt7dG9TY3JlZW46IGZ1bmN0aW9uLCB0b1RpbWU6IGZ1bmN0aW9ufX0gY29udmVyc2lvblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb252ZXJzaW9uIGZ1bmN0aW9ucyBmcm9tIHRpbWUgdG8gc2NyZWVuIGFuZCB2aWNlIHZlcnNhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgICAgIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBkZXNjcmliZSBhdmFpbGFibGUgb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gQm94SXRlbShkYXRhLCBjb252ZXJzaW9uLCBvcHRpb25zKSB7XG4gICAgdGhpcy5wcm9wcyA9IHtcbiAgICAgIGRvdDoge1xuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwXG4gICAgICB9LFxuICAgICAgbGluZToge1xuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwXG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIC8vIHZhbGlkYXRlIGRhdGFcbiAgICBpZiAoZGF0YSkge1xuICAgICAgaWYgKGRhdGEuc3RhcnQgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvcGVydHkgXCJzdGFydFwiIG1pc3NpbmcgaW4gaXRlbSAnICsgZGF0YSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgSXRlbS5jYWxsKHRoaXMsIGRhdGEsIGNvbnZlcnNpb24sIG9wdGlvbnMpO1xuICB9XG5cbiAgQm94SXRlbS5wcm90b3R5cGUgPSBuZXcgSXRlbShudWxsLCBudWxsLCBudWxsKTtcblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciB0aGlzIGl0ZW0gaXMgdmlzaWJsZSBpbnNpZGUgZ2l2ZW4gcmFuZ2VcbiAgICogQHJldHVybnMge3tzdGFydDogTnVtYmVyLCBlbmQ6IE51bWJlcn19IHJhbmdlIHdpdGggYSB0aW1lc3RhbXAgZm9yIHN0YXJ0IGFuZCBlbmRcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmlzaWJsZVxuICAgKi9cbiAgQm94SXRlbS5wcm90b3R5cGUuaXNWaXNpYmxlID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgLy8gZGV0ZXJtaW5lIHZpc2liaWxpdHlcbiAgICAvLyBUT0RPOiBhY2NvdW50IGZvciB0aGUgcmVhbCB3aWR0aCBvZiB0aGUgaXRlbS4gUmlnaHQgbm93IHdlIGp1c3QgYWRkIDEvNCB0byB0aGUgd2luZG93XG4gICAgdmFyIGludGVydmFsID0gKHJhbmdlLmVuZCAtIHJhbmdlLnN0YXJ0KSAvIDQ7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zdGFydCA+IHJhbmdlLnN0YXJ0IC0gaW50ZXJ2YWwgJiYgdGhpcy5kYXRhLnN0YXJ0IDwgcmFuZ2UuZW5kICsgaW50ZXJ2YWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcGFpbnQgdGhlIGl0ZW1cbiAgICovXG4gIEJveEl0ZW0ucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZG9tID0gdGhpcy5kb207XG4gICAgaWYgKCFkb20pIHtcbiAgICAgIC8vIGNyZWF0ZSBET01cbiAgICAgIHRoaXMuZG9tID0ge307XG4gICAgICBkb20gPSB0aGlzLmRvbTtcblxuICAgICAgLy8gY3JlYXRlIG1haW4gYm94XG4gICAgICBkb20uYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XG5cbiAgICAgIC8vIGNvbnRlbnRzIGJveCAoaW5zaWRlIHRoZSBiYWNrZ3JvdW5kIGJveCkuIHVzZWQgZm9yIG1ha2luZyBtYXJnaW5zXG4gICAgICBkb20uY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICAgICAgZG9tLmNvbnRlbnQuY2xhc3NOYW1lID0gJ3Zpcy1pdGVtLWNvbnRlbnQnO1xuICAgICAgZG9tLmJveC5hcHBlbmRDaGlsZChkb20uY29udGVudCk7XG5cbiAgICAgIC8vIGxpbmUgdG8gYXhpc1xuICAgICAgZG9tLmxpbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcbiAgICAgIGRvbS5saW5lLmNsYXNzTmFtZSA9ICd2aXMtbGluZSc7XG5cbiAgICAgIC8vIGRvdCBvbiBheGlzXG4gICAgICBkb20uZG90ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XG4gICAgICBkb20uZG90LmNsYXNzTmFtZSA9ICd2aXMtZG90JztcblxuICAgICAgLy8gYXR0YWNoIHRoaXMgaXRlbSBhcyBhdHRyaWJ1dGVcbiAgICAgIGRvbS5ib3hbJ3RpbWVsaW5lLWl0ZW0nXSA9IHRoaXM7XG5cbiAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIGFwcGVuZCBET00gdG8gcGFyZW50IERPTVxuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlZHJhdyBpdGVtOiBubyBwYXJlbnQgYXR0YWNoZWQnKTtcbiAgICB9XG4gICAgaWYgKCFkb20uYm94LnBhcmVudE5vZGUpIHtcbiAgICAgIHZhciBmb3JlZ3JvdW5kID0gdGhpcy5wYXJlbnQuZG9tLmZvcmVncm91bmQ7XG4gICAgICBpZiAoIWZvcmVncm91bmQpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlZHJhdyBpdGVtOiBwYXJlbnQgaGFzIG5vIGZvcmVncm91bmQgY29udGFpbmVyIGVsZW1lbnQnKTtcbiAgICAgIGZvcmVncm91bmQuYXBwZW5kQ2hpbGQoZG9tLmJveCk7XG4gICAgfVxuICAgIGlmICghZG9tLmxpbmUucGFyZW50Tm9kZSkge1xuICAgICAgdmFyIGJhY2tncm91bmQgPSB0aGlzLnBhcmVudC5kb20uYmFja2dyb3VuZDtcbiAgICAgIGlmICghYmFja2dyb3VuZCkgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVkcmF3IGl0ZW06IHBhcmVudCBoYXMgbm8gYmFja2dyb3VuZCBjb250YWluZXIgZWxlbWVudCcpO1xuICAgICAgYmFja2dyb3VuZC5hcHBlbmRDaGlsZChkb20ubGluZSk7XG4gICAgfVxuICAgIGlmICghZG9tLmRvdC5wYXJlbnROb2RlKSB7XG4gICAgICB2YXIgYXhpcyA9IHRoaXMucGFyZW50LmRvbS5heGlzO1xuICAgICAgaWYgKCFiYWNrZ3JvdW5kKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWRyYXcgaXRlbTogcGFyZW50IGhhcyBubyBheGlzIGNvbnRhaW5lciBlbGVtZW50Jyk7XG4gICAgICBheGlzLmFwcGVuZENoaWxkKGRvbS5kb3QpO1xuICAgIH1cbiAgICB0aGlzLmRpc3BsYXllZCA9IHRydWU7XG5cbiAgICAvLyBVcGRhdGUgRE9NIHdoZW4gaXRlbSBpcyBtYXJrZWQgZGlydHkuIEFuIGl0ZW0gaXMgbWFya2VkIGRpcnR5IHdoZW46XG4gICAgLy8gLSB0aGUgaXRlbSBpcyBub3QgeWV0IHJlbmRlcmVkXG4gICAgLy8gLSB0aGUgaXRlbSdzIGRhdGEgaXMgY2hhbmdlZFxuICAgIC8vIC0gdGhlIGl0ZW0gaXMgc2VsZWN0ZWQvZGVzZWxlY3RlZFxuICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICB0aGlzLl91cGRhdGVDb250ZW50cyh0aGlzLmRvbS5jb250ZW50KTtcbiAgICAgIHRoaXMuX3VwZGF0ZVRpdGxlKHRoaXMuZG9tLmJveCk7XG4gICAgICB0aGlzLl91cGRhdGVEYXRhQXR0cmlidXRlcyh0aGlzLmRvbS5ib3gpO1xuICAgICAgdGhpcy5fdXBkYXRlU3R5bGUodGhpcy5kb20uYm94KTtcblxuICAgICAgdmFyIGVkaXRhYmxlID0gKHRoaXMub3B0aW9ucy5lZGl0YWJsZS51cGRhdGVUaW1lIHx8IHRoaXMub3B0aW9ucy5lZGl0YWJsZS51cGRhdGVHcm91cCB8fCB0aGlzLmVkaXRhYmxlID09PSB0cnVlKSAmJiB0aGlzLmVkaXRhYmxlICE9PSBmYWxzZTtcblxuICAgICAgLy8gdXBkYXRlIGNsYXNzXG4gICAgICB2YXIgY2xhc3NOYW1lID0gKHRoaXMuZGF0YS5jbGFzc05hbWUgPyAnICcgKyB0aGlzLmRhdGEuY2xhc3NOYW1lIDogJycpICsgKHRoaXMuc2VsZWN0ZWQgPyAnIHZpcy1zZWxlY3RlZCcgOiAnJykgKyAoZWRpdGFibGUgPyAnIHZpcy1lZGl0YWJsZScgOiAnIHZpcy1yZWFkb25seScpO1xuICAgICAgZG9tLmJveC5jbGFzc05hbWUgPSAndmlzLWl0ZW0gdmlzLWJveCcgKyBjbGFzc05hbWU7XG4gICAgICBkb20ubGluZS5jbGFzc05hbWUgPSAndmlzLWl0ZW0gdmlzLWxpbmUnICsgY2xhc3NOYW1lO1xuICAgICAgZG9tLmRvdC5jbGFzc05hbWUgPSAndmlzLWl0ZW0gdmlzLWRvdCcgKyBjbGFzc05hbWU7XG5cbiAgICAgIC8vIHJlY2FsY3VsYXRlIHNpemVcbiAgICAgIHRoaXMucHJvcHMuZG90LmhlaWdodCA9IGRvbS5kb3Qub2Zmc2V0SGVpZ2h0O1xuICAgICAgdGhpcy5wcm9wcy5kb3Qud2lkdGggPSBkb20uZG90Lm9mZnNldFdpZHRoO1xuICAgICAgdGhpcy5wcm9wcy5saW5lLndpZHRoID0gZG9tLmxpbmUub2Zmc2V0V2lkdGg7XG4gICAgICB0aGlzLndpZHRoID0gZG9tLmJveC5vZmZzZXRXaWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gZG9tLmJveC5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZXBhaW50RGVsZXRlQnV0dG9uKGRvbS5ib3gpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTaG93IHRoZSBpdGVtIGluIHRoZSBET00gKHdoZW4gbm90IGFscmVhZHkgZGlzcGxheWVkKS4gVGhlIGl0ZW1zIERPTSB3aWxsXG4gICAqIGJlIGNyZWF0ZWQgd2hlbiBuZWVkZWQuXG4gICAqL1xuICBCb3hJdGVtLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5kaXNwbGF5ZWQpIHtcbiAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBIaWRlIHRoZSBpdGVtIGZyb20gdGhlIERPTSAod2hlbiB2aXNpYmxlKVxuICAgKi9cbiAgQm94SXRlbS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5kaXNwbGF5ZWQpIHtcbiAgICAgIHZhciBkb20gPSB0aGlzLmRvbTtcblxuICAgICAgaWYgKGRvbS5ib3gucGFyZW50Tm9kZSkgZG9tLmJveC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRvbS5ib3gpO1xuICAgICAgaWYgKGRvbS5saW5lLnBhcmVudE5vZGUpIGRvbS5saW5lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZG9tLmxpbmUpO1xuICAgICAgaWYgKGRvbS5kb3QucGFyZW50Tm9kZSkgZG9tLmRvdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRvbS5kb3QpO1xuXG4gICAgICB0aGlzLmRpc3BsYXllZCA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVwb3NpdGlvbiB0aGUgaXRlbSBob3Jpem9udGFsbHlcbiAgICogQE92ZXJyaWRlXG4gICAqL1xuICBCb3hJdGVtLnByb3RvdHlwZS5yZXBvc2l0aW9uWCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLmNvbnZlcnNpb24udG9TY3JlZW4odGhpcy5kYXRhLnN0YXJ0KTtcbiAgICB2YXIgYWxpZ24gPSB0aGlzLm9wdGlvbnMuYWxpZ247XG5cbiAgICAvLyBjYWxjdWxhdGUgbGVmdCBwb3NpdGlvbiBvZiB0aGUgYm94XG4gICAgaWYgKGFsaWduID09ICdyaWdodCcpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucnRsKSB7XG4gICAgICAgIHRoaXMucmlnaHQgPSBzdGFydCAtIHRoaXMud2lkdGg7XG5cbiAgICAgICAgLy8gcmVwb3NpdGlvbiBib3gsIGxpbmUsIGFuZCBkb3RcbiAgICAgICAgdGhpcy5kb20uYm94LnN0eWxlLnJpZ2h0ID0gdGhpcy5yaWdodCArICdweCc7XG4gICAgICAgIHRoaXMuZG9tLmxpbmUuc3R5bGUucmlnaHQgPSBzdGFydCAtIHRoaXMucHJvcHMubGluZS53aWR0aCArICdweCc7XG4gICAgICAgIHRoaXMuZG9tLmRvdC5zdHlsZS5yaWdodCA9IHN0YXJ0IC0gdGhpcy5wcm9wcy5saW5lLndpZHRoIC8gMiAtIHRoaXMucHJvcHMuZG90LndpZHRoIC8gMiArICdweCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxlZnQgPSBzdGFydCAtIHRoaXMud2lkdGg7XG5cbiAgICAgICAgLy8gcmVwb3NpdGlvbiBib3gsIGxpbmUsIGFuZCBkb3RcbiAgICAgICAgdGhpcy5kb20uYm94LnN0eWxlLmxlZnQgPSB0aGlzLmxlZnQgKyAncHgnO1xuICAgICAgICB0aGlzLmRvbS5saW5lLnN0eWxlLmxlZnQgPSBzdGFydCAtIHRoaXMucHJvcHMubGluZS53aWR0aCArICdweCc7XG4gICAgICAgIHRoaXMuZG9tLmRvdC5zdHlsZS5sZWZ0ID0gc3RhcnQgLSB0aGlzLnByb3BzLmxpbmUud2lkdGggLyAyIC0gdGhpcy5wcm9wcy5kb3Qud2lkdGggLyAyICsgJ3B4JztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFsaWduID09ICdsZWZ0Jykge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgICAgdGhpcy5yaWdodCA9IHN0YXJ0O1xuXG4gICAgICAgIC8vIHJlcG9zaXRpb24gYm94LCBsaW5lLCBhbmQgZG90XG4gICAgICAgIHRoaXMuZG9tLmJveC5zdHlsZS5yaWdodCA9IHRoaXMucmlnaHQgKyAncHgnO1xuICAgICAgICB0aGlzLmRvbS5saW5lLnN0eWxlLnJpZ2h0ID0gc3RhcnQgKyAncHgnO1xuICAgICAgICB0aGlzLmRvbS5kb3Quc3R5bGUucmlnaHQgPSBzdGFydCArIHRoaXMucHJvcHMubGluZS53aWR0aCAvIDIgLSB0aGlzLnByb3BzLmRvdC53aWR0aCAvIDIgKyAncHgnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sZWZ0ID0gc3RhcnQ7XG5cbiAgICAgICAgLy8gcmVwb3NpdGlvbiBib3gsIGxpbmUsIGFuZCBkb3RcbiAgICAgICAgdGhpcy5kb20uYm94LnN0eWxlLmxlZnQgPSB0aGlzLmxlZnQgKyAncHgnO1xuICAgICAgICB0aGlzLmRvbS5saW5lLnN0eWxlLmxlZnQgPSBzdGFydCArICdweCc7XG4gICAgICAgIHRoaXMuZG9tLmRvdC5zdHlsZS5sZWZ0ID0gc3RhcnQgKyB0aGlzLnByb3BzLmxpbmUud2lkdGggLyAyIC0gdGhpcy5wcm9wcy5kb3Qud2lkdGggLyAyICsgJ3B4JztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZGVmYXVsdCBvciAnY2VudGVyJ1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgICAgdGhpcy5yaWdodCA9IHN0YXJ0IC0gdGhpcy53aWR0aCAvIDI7XG5cbiAgICAgICAgLy8gcmVwb3NpdGlvbiBib3gsIGxpbmUsIGFuZCBkb3RcbiAgICAgICAgdGhpcy5kb20uYm94LnN0eWxlLnJpZ2h0ID0gdGhpcy5yaWdodCArICdweCc7XG4gICAgICAgIHRoaXMuZG9tLmxpbmUuc3R5bGUucmlnaHQgPSBzdGFydCAtIHRoaXMucHJvcHMubGluZS53aWR0aCArICdweCc7XG4gICAgICAgIHRoaXMuZG9tLmRvdC5zdHlsZS5yaWdodCA9IHN0YXJ0IC0gdGhpcy5wcm9wcy5kb3Qud2lkdGggLyAyICsgJ3B4JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGVmdCA9IHN0YXJ0IC0gdGhpcy53aWR0aCAvIDI7XG5cbiAgICAgICAgLy8gcmVwb3NpdGlvbiBib3gsIGxpbmUsIGFuZCBkb3RcbiAgICAgICAgdGhpcy5kb20uYm94LnN0eWxlLmxlZnQgPSB0aGlzLmxlZnQgKyAncHgnO1xuICAgICAgICB0aGlzLmRvbS5saW5lLnN0eWxlLmxlZnQgPSBzdGFydCAtIHRoaXMucHJvcHMubGluZS53aWR0aCAvIDIgKyAncHgnO1xuICAgICAgICB0aGlzLmRvbS5kb3Quc3R5bGUubGVmdCA9IHN0YXJ0IC0gdGhpcy5wcm9wcy5kb3Qud2lkdGggLyAyICsgJ3B4JztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcG9zaXRpb24gdGhlIGl0ZW0gdmVydGljYWxseVxuICAgKiBAT3ZlcnJpZGVcbiAgICovXG4gIEJveEl0ZW0ucHJvdG90eXBlLnJlcG9zaXRpb25ZID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcmllbnRhdGlvbiA9IHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5pdGVtO1xuICAgIHZhciBib3ggPSB0aGlzLmRvbS5ib3g7XG4gICAgdmFyIGxpbmUgPSB0aGlzLmRvbS5saW5lO1xuICAgIHZhciBkb3QgPSB0aGlzLmRvbS5kb3Q7XG5cbiAgICBpZiAob3JpZW50YXRpb24gPT0gJ3RvcCcpIHtcbiAgICAgIGJveC5zdHlsZS50b3AgPSAodGhpcy50b3AgfHwgMCkgKyAncHgnO1xuXG4gICAgICBsaW5lLnN0eWxlLnRvcCA9ICcwJztcbiAgICAgIGxpbmUuc3R5bGUuaGVpZ2h0ID0gdGhpcy5wYXJlbnQudG9wICsgdGhpcy50b3AgKyAxICsgJ3B4JztcbiAgICAgIGxpbmUuc3R5bGUuYm90dG9tID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG9yaWVudGF0aW9uICdib3R0b20nXG4gICAgICB2YXIgaXRlbVNldEhlaWdodCA9IHRoaXMucGFyZW50Lml0ZW1TZXQucHJvcHMuaGVpZ2h0OyAvLyBUT0RPOiB0aGlzIGlzIG5hc3R5XG4gICAgICB2YXIgbGluZUhlaWdodCA9IGl0ZW1TZXRIZWlnaHQgLSB0aGlzLnBhcmVudC50b3AgLSB0aGlzLnBhcmVudC5oZWlnaHQgKyB0aGlzLnRvcDtcblxuICAgICAgYm94LnN0eWxlLnRvcCA9ICh0aGlzLnBhcmVudC5oZWlnaHQgLSB0aGlzLnRvcCAtIHRoaXMuaGVpZ2h0IHx8IDApICsgJ3B4JztcbiAgICAgIGxpbmUuc3R5bGUudG9wID0gaXRlbVNldEhlaWdodCAtIGxpbmVIZWlnaHQgKyAncHgnO1xuICAgICAgbGluZS5zdHlsZS5ib3R0b20gPSAnMCc7XG4gICAgfVxuXG4gICAgZG90LnN0eWxlLnRvcCA9IC10aGlzLnByb3BzLmRvdC5oZWlnaHQgLyAyICsgJ3B4JztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB3aWR0aCBvZiB0aGUgaXRlbSBsZWZ0IGZyb20gaXRzIHN0YXJ0IGRhdGVcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgQm94SXRlbS5wcm90b3R5cGUuZ2V0V2lkdGhMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLndpZHRoIC8gMjtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB3aWR0aCBvZiB0aGUgaXRlbSByaWdodCBmcm9tIGl0cyBzdGFydCBkYXRlXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIEJveEl0ZW0ucHJvdG90eXBlLmdldFdpZHRoUmlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMud2lkdGggLyAyO1xuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gQm94SXRlbTtcblxuLyoqKi8gfSxcbi8qIDQyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIEl0ZW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KTtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yIFBvaW50SXRlbVxuICAgKiBAZXh0ZW5kcyBJdGVtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICAgICAgICAgIE9iamVjdCBjb250YWluaW5nIHBhcmFtZXRlcnMgc3RhcnRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCwgY2xhc3NOYW1lLlxuICAgKiBAcGFyYW0ge3t0b1NjcmVlbjogZnVuY3Rpb24sIHRvVGltZTogZnVuY3Rpb259fSBjb252ZXJzaW9uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbnZlcnNpb24gZnVuY3Rpb25zIGZyb20gdGltZSB0byBzY3JlZW4gYW5kIHZpY2UgdmVyc2FcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICAgICAgQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGRlc2NyaWJlIGF2YWlsYWJsZSBvcHRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBQb2ludEl0ZW0oZGF0YSwgY29udmVyc2lvbiwgb3B0aW9ucykge1xuICAgIHRoaXMucHJvcHMgPSB7XG4gICAgICBkb3Q6IHtcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwXG4gICAgICB9LFxuICAgICAgY29udGVudDoge1xuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIG1hcmdpbkxlZnQ6IDAsXG4gICAgICAgIG1hcmdpblJpZ2h0OiAwXG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIC8vIHZhbGlkYXRlIGRhdGFcbiAgICBpZiAoZGF0YSkge1xuICAgICAgaWYgKGRhdGEuc3RhcnQgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvcGVydHkgXCJzdGFydFwiIG1pc3NpbmcgaW4gaXRlbSAnICsgZGF0YSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgSXRlbS5jYWxsKHRoaXMsIGRhdGEsIGNvbnZlcnNpb24sIG9wdGlvbnMpO1xuICB9XG5cbiAgUG9pbnRJdGVtLnByb3RvdHlwZSA9IG5ldyBJdGVtKG51bGwsIG51bGwsIG51bGwpO1xuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoaXMgaXRlbSBpcyB2aXNpYmxlIGluc2lkZSBnaXZlbiByYW5nZVxuICAgKiBAcmV0dXJucyB7e3N0YXJ0OiBOdW1iZXIsIGVuZDogTnVtYmVyfX0gcmFuZ2Ugd2l0aCBhIHRpbWVzdGFtcCBmb3Igc3RhcnQgYW5kIGVuZFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2aXNpYmxlXG4gICAqL1xuICBQb2ludEl0ZW0ucHJvdG90eXBlLmlzVmlzaWJsZSA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgIC8vIGRldGVybWluZSB2aXNpYmlsaXR5XG4gICAgLy8gVE9ETzogYWNjb3VudCBmb3IgdGhlIHJlYWwgd2lkdGggb2YgdGhlIGl0ZW0uIFJpZ2h0IG5vdyB3ZSBqdXN0IGFkZCAxLzQgdG8gdGhlIHdpbmRvd1xuICAgIHZhciBpbnRlcnZhbCA9IChyYW5nZS5lbmQgLSByYW5nZS5zdGFydCkgLyA0O1xuICAgIHJldHVybiB0aGlzLmRhdGEuc3RhcnQgPiByYW5nZS5zdGFydCAtIGludGVydmFsICYmIHRoaXMuZGF0YS5zdGFydCA8IHJhbmdlLmVuZCArIGludGVydmFsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXBhaW50IHRoZSBpdGVtXG4gICAqL1xuICBQb2ludEl0ZW0ucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZG9tID0gdGhpcy5kb207XG4gICAgaWYgKCFkb20pIHtcbiAgICAgIC8vIGNyZWF0ZSBET01cbiAgICAgIHRoaXMuZG9tID0ge307XG4gICAgICBkb20gPSB0aGlzLmRvbTtcblxuICAgICAgLy8gYmFja2dyb3VuZCBib3hcbiAgICAgIGRvbS5wb2ludCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgLy8gY2xhc3NOYW1lIGlzIHVwZGF0ZWQgaW4gcmVkcmF3KClcblxuICAgICAgLy8gY29udGVudHMgYm94LCByaWdodCBmcm9tIHRoZSBkb3RcbiAgICAgIGRvbS5jb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkb20uY29udGVudC5jbGFzc05hbWUgPSAndmlzLWl0ZW0tY29udGVudCc7XG4gICAgICBkb20ucG9pbnQuYXBwZW5kQ2hpbGQoZG9tLmNvbnRlbnQpO1xuXG4gICAgICAvLyBkb3QgYXQgc3RhcnRcbiAgICAgIGRvbS5kb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRvbS5wb2ludC5hcHBlbmRDaGlsZChkb20uZG90KTtcblxuICAgICAgLy8gYXR0YWNoIHRoaXMgaXRlbSBhcyBhdHRyaWJ1dGVcbiAgICAgIGRvbS5wb2ludFsndGltZWxpbmUtaXRlbSddID0gdGhpcztcblxuICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gYXBwZW5kIERPTSB0byBwYXJlbnQgRE9NXG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVkcmF3IGl0ZW06IG5vIHBhcmVudCBhdHRhY2hlZCcpO1xuICAgIH1cbiAgICBpZiAoIWRvbS5wb2ludC5wYXJlbnROb2RlKSB7XG4gICAgICB2YXIgZm9yZWdyb3VuZCA9IHRoaXMucGFyZW50LmRvbS5mb3JlZ3JvdW5kO1xuICAgICAgaWYgKCFmb3JlZ3JvdW5kKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlZHJhdyBpdGVtOiBwYXJlbnQgaGFzIG5vIGZvcmVncm91bmQgY29udGFpbmVyIGVsZW1lbnQnKTtcbiAgICAgIH1cbiAgICAgIGZvcmVncm91bmQuYXBwZW5kQ2hpbGQoZG9tLnBvaW50KTtcbiAgICB9XG4gICAgdGhpcy5kaXNwbGF5ZWQgPSB0cnVlO1xuXG4gICAgLy8gVXBkYXRlIERPTSB3aGVuIGl0ZW0gaXMgbWFya2VkIGRpcnR5LiBBbiBpdGVtIGlzIG1hcmtlZCBkaXJ0eSB3aGVuOlxuICAgIC8vIC0gdGhlIGl0ZW0gaXMgbm90IHlldCByZW5kZXJlZFxuICAgIC8vIC0gdGhlIGl0ZW0ncyBkYXRhIGlzIGNoYW5nZWRcbiAgICAvLyAtIHRoZSBpdGVtIGlzIHNlbGVjdGVkL2Rlc2VsZWN0ZWRcbiAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgdGhpcy5fdXBkYXRlQ29udGVudHModGhpcy5kb20uY29udGVudCk7XG4gICAgICB0aGlzLl91cGRhdGVUaXRsZSh0aGlzLmRvbS5wb2ludCk7XG4gICAgICB0aGlzLl91cGRhdGVEYXRhQXR0cmlidXRlcyh0aGlzLmRvbS5wb2ludCk7XG4gICAgICB0aGlzLl91cGRhdGVTdHlsZSh0aGlzLmRvbS5wb2ludCk7XG5cbiAgICAgIHZhciBlZGl0YWJsZSA9ICh0aGlzLm9wdGlvbnMuZWRpdGFibGUudXBkYXRlVGltZSB8fCB0aGlzLm9wdGlvbnMuZWRpdGFibGUudXBkYXRlR3JvdXAgfHwgdGhpcy5lZGl0YWJsZSA9PT0gdHJ1ZSkgJiYgdGhpcy5lZGl0YWJsZSAhPT0gZmFsc2U7XG5cbiAgICAgIC8vIHVwZGF0ZSBjbGFzc1xuICAgICAgdmFyIGNsYXNzTmFtZSA9ICh0aGlzLmRhdGEuY2xhc3NOYW1lID8gJyAnICsgdGhpcy5kYXRhLmNsYXNzTmFtZSA6ICcnKSArICh0aGlzLnNlbGVjdGVkID8gJyB2aXMtc2VsZWN0ZWQnIDogJycpICsgKGVkaXRhYmxlID8gJyB2aXMtZWRpdGFibGUnIDogJyB2aXMtcmVhZG9ubHknKTtcbiAgICAgIGRvbS5wb2ludC5jbGFzc05hbWUgPSAndmlzLWl0ZW0gdmlzLXBvaW50JyArIGNsYXNzTmFtZTtcbiAgICAgIGRvbS5kb3QuY2xhc3NOYW1lID0gJ3Zpcy1pdGVtIHZpcy1kb3QnICsgY2xhc3NOYW1lO1xuXG4gICAgICAvLyByZWNhbGN1bGF0ZSBzaXplIG9mIGRvdCBhbmQgY29udGVudHNcbiAgICAgIHRoaXMucHJvcHMuZG90LndpZHRoID0gZG9tLmRvdC5vZmZzZXRXaWR0aDtcbiAgICAgIHRoaXMucHJvcHMuZG90LmhlaWdodCA9IGRvbS5kb3Qub2Zmc2V0SGVpZ2h0O1xuICAgICAgdGhpcy5wcm9wcy5jb250ZW50LmhlaWdodCA9IGRvbS5jb250ZW50Lm9mZnNldEhlaWdodDtcblxuICAgICAgLy8gcmVzaXplIGNvbnRlbnRzXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgICBkb20uY29udGVudC5zdHlsZS5tYXJnaW5SaWdodCA9IDIgKiB0aGlzLnByb3BzLmRvdC53aWR0aCArICdweCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb20uY29udGVudC5zdHlsZS5tYXJnaW5MZWZ0ID0gMiAqIHRoaXMucHJvcHMuZG90LndpZHRoICsgJ3B4JztcbiAgICAgIH1cbiAgICAgIC8vZG9tLmNvbnRlbnQuc3R5bGUubWFyZ2luUmlnaHQgPSAuLi4gKyAncHgnOyAvLyBUT0RPOiBtYXJnaW4gcmlnaHRcblxuICAgICAgLy8gcmVjYWxjdWxhdGUgc2l6ZVxuICAgICAgdGhpcy53aWR0aCA9IGRvbS5wb2ludC5vZmZzZXRXaWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gZG9tLnBvaW50Lm9mZnNldEhlaWdodDtcblxuICAgICAgLy8gcmVwb3NpdGlvbiB0aGUgZG90XG4gICAgICBkb20uZG90LnN0eWxlLnRvcCA9ICh0aGlzLmhlaWdodCAtIHRoaXMucHJvcHMuZG90LmhlaWdodCkgLyAyICsgJ3B4JztcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucnRsKSB7XG4gICAgICAgIGRvbS5kb3Quc3R5bGUucmlnaHQgPSB0aGlzLnByb3BzLmRvdC53aWR0aCAvIDIgKyAncHgnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9tLmRvdC5zdHlsZS5sZWZ0ID0gdGhpcy5wcm9wcy5kb3Qud2lkdGggLyAyICsgJ3B4JztcbiAgICAgIH1cblxuICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuX3JlcGFpbnREZWxldGVCdXR0b24oZG9tLnBvaW50KTtcbiAgfTtcblxuICAvKipcbiAgICogU2hvdyB0aGUgaXRlbSBpbiB0aGUgRE9NICh3aGVuIG5vdCBhbHJlYWR5IHZpc2libGUpLiBUaGUgaXRlbXMgRE9NIHdpbGxcbiAgICogYmUgY3JlYXRlZCB3aGVuIG5lZWRlZC5cbiAgICovXG4gIFBvaW50SXRlbS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuZGlzcGxheWVkKSB7XG4gICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSGlkZSB0aGUgaXRlbSBmcm9tIHRoZSBET00gKHdoZW4gdmlzaWJsZSlcbiAgICovXG4gIFBvaW50SXRlbS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5kaXNwbGF5ZWQpIHtcbiAgICAgIGlmICh0aGlzLmRvbS5wb2ludC5wYXJlbnROb2RlKSB7XG4gICAgICAgIHRoaXMuZG9tLnBvaW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20ucG9pbnQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRpc3BsYXllZCA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVwb3NpdGlvbiB0aGUgaXRlbSBob3Jpem9udGFsbHlcbiAgICogQE92ZXJyaWRlXG4gICAqL1xuICBQb2ludEl0ZW0ucHJvdG90eXBlLnJlcG9zaXRpb25YID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMuY29udmVyc2lvbi50b1NjcmVlbih0aGlzLmRhdGEuc3RhcnQpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgIHRoaXMucmlnaHQgPSBzdGFydCAtIHRoaXMucHJvcHMuZG90LndpZHRoO1xuXG4gICAgICAvLyByZXBvc2l0aW9uIHBvaW50XG4gICAgICB0aGlzLmRvbS5wb2ludC5zdHlsZS5yaWdodCA9IHRoaXMucmlnaHQgKyAncHgnO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxlZnQgPSBzdGFydCAtIHRoaXMucHJvcHMuZG90LndpZHRoO1xuXG4gICAgICAvLyByZXBvc2l0aW9uIHBvaW50XG4gICAgICB0aGlzLmRvbS5wb2ludC5zdHlsZS5sZWZ0ID0gdGhpcy5sZWZ0ICsgJ3B4JztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcG9zaXRpb24gdGhlIGl0ZW0gdmVydGljYWxseVxuICAgKiBAT3ZlcnJpZGVcbiAgICovXG4gIFBvaW50SXRlbS5wcm90b3R5cGUucmVwb3NpdGlvblkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9yaWVudGF0aW9uID0gdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uLml0ZW07XG4gICAgdmFyIHBvaW50ID0gdGhpcy5kb20ucG9pbnQ7XG4gICAgaWYgKG9yaWVudGF0aW9uID09ICd0b3AnKSB7XG4gICAgICBwb2ludC5zdHlsZS50b3AgPSB0aGlzLnRvcCArICdweCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50LnN0eWxlLnRvcCA9IHRoaXMucGFyZW50LmhlaWdodCAtIHRoaXMudG9wIC0gdGhpcy5oZWlnaHQgKyAncHgnO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB3aWR0aCBvZiB0aGUgaXRlbSBsZWZ0IGZyb20gaXRzIHN0YXJ0IGRhdGVcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgUG9pbnRJdGVtLnByb3RvdHlwZS5nZXRXaWR0aExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMuZG90LndpZHRoO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHdpZHRoIG9mIHRoZSBpdGVtIHJpZ2h0IGZyb20gIGl0cyBzdGFydCBkYXRlXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIFBvaW50SXRlbS5wcm90b3R5cGUuZ2V0V2lkdGhSaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5kb3Qud2lkdGg7XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBQb2ludEl0ZW07XG5cbi8qKiovIH0sXG4vKiA0MyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBIYW1tZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcbiAgdmFyIEl0ZW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KTtcbiAgdmFyIEJhY2tncm91bmRHcm91cCA9IF9fd2VicGFja19yZXF1aXJlX18oNDApO1xuICB2YXIgUmFuZ2VJdGVtID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOCk7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvciBCYWNrZ3JvdW5kSXRlbVxuICAgKiBAZXh0ZW5kcyBJdGVtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICAgICAgICAgIE9iamVjdCBjb250YWluaW5nIHBhcmFtZXRlcnMgc3RhcnQsIGVuZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50LCBjbGFzc05hbWUuXG4gICAqIEBwYXJhbSB7e3RvU2NyZWVuOiBmdW5jdGlvbiwgdG9UaW1lOiBmdW5jdGlvbn19IGNvbnZlcnNpb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29udmVyc2lvbiBmdW5jdGlvbnMgZnJvbSB0aW1lIHRvIHNjcmVlbiBhbmQgdmljZSB2ZXJzYVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgICAgICBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogZGVzY3JpYmUgb3B0aW9uc1xuICAgKi9cbiAgLy8gVE9ETzogaW1wbGVtZW50IHN1cHBvcnQgZm9yIHRoZSBCYWNrZ3JvdW5kSXRlbSBqdXN0IGhhdmluZyBhIHN0YXJ0LCB0aGVuIGJlaW5nIGRpc3BsYXllZCBhcyBhIHNvcnQgb2YgYW4gYW5ub3RhdGlvblxuICBmdW5jdGlvbiBCYWNrZ3JvdW5kSXRlbShkYXRhLCBjb252ZXJzaW9uLCBvcHRpb25zKSB7XG4gICAgdGhpcy5wcm9wcyA9IHtcbiAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgd2lkdGg6IDBcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMub3ZlcmZsb3cgPSBmYWxzZTsgLy8gaWYgY29udGVudHMgY2FuIG92ZXJmbG93IChjc3Mgc3R5bGluZyksIHRoaXMgZmxhZyBpcyBzZXQgdG8gdHJ1ZVxuXG4gICAgLy8gdmFsaWRhdGUgZGF0YVxuICAgIGlmIChkYXRhKSB7XG4gICAgICBpZiAoZGF0YS5zdGFydCA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9wZXJ0eSBcInN0YXJ0XCIgbWlzc2luZyBpbiBpdGVtICcgKyBkYXRhLmlkKTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLmVuZCA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9wZXJ0eSBcImVuZFwiIG1pc3NpbmcgaW4gaXRlbSAnICsgZGF0YS5pZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgSXRlbS5jYWxsKHRoaXMsIGRhdGEsIGNvbnZlcnNpb24sIG9wdGlvbnMpO1xuICB9XG5cbiAgQmFja2dyb3VuZEl0ZW0ucHJvdG90eXBlID0gbmV3IEl0ZW0obnVsbCwgbnVsbCwgbnVsbCk7XG5cbiAgQmFja2dyb3VuZEl0ZW0ucHJvdG90eXBlLmJhc2VDbGFzc05hbWUgPSAndmlzLWl0ZW0gdmlzLWJhY2tncm91bmQnO1xuICBCYWNrZ3JvdW5kSXRlbS5wcm90b3R5cGUuc3RhY2sgPSBmYWxzZTtcblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciB0aGlzIGl0ZW0gaXMgdmlzaWJsZSBpbnNpZGUgZ2l2ZW4gcmFuZ2VcbiAgICogQHJldHVybnMge3tzdGFydDogTnVtYmVyLCBlbmQ6IE51bWJlcn19IHJhbmdlIHdpdGggYSB0aW1lc3RhbXAgZm9yIHN0YXJ0IGFuZCBlbmRcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmlzaWJsZVxuICAgKi9cbiAgQmFja2dyb3VuZEl0ZW0ucHJvdG90eXBlLmlzVmlzaWJsZSA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgIC8vIGRldGVybWluZSB2aXNpYmlsaXR5XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zdGFydCA8IHJhbmdlLmVuZCAmJiB0aGlzLmRhdGEuZW5kID4gcmFuZ2Uuc3RhcnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcGFpbnQgdGhlIGl0ZW1cbiAgICovXG4gIEJhY2tncm91bmRJdGVtLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRvbSA9IHRoaXMuZG9tO1xuICAgIGlmICghZG9tKSB7XG4gICAgICAvLyBjcmVhdGUgRE9NXG4gICAgICB0aGlzLmRvbSA9IHt9O1xuICAgICAgZG9tID0gdGhpcy5kb207XG5cbiAgICAgIC8vIGJhY2tncm91bmQgYm94XG4gICAgICBkb20uYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAvLyBjbGFzc05hbWUgaXMgdXBkYXRlZCBpbiByZWRyYXcoKVxuXG4gICAgICAvLyBmcmFtZSBib3ggKHRvIHByZXZlbnQgdGhlIGl0ZW0gY29udGVudHMgZnJvbSBvdmVyZmxvd2luZ1xuICAgICAgZG9tLmZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkb20uZnJhbWUuY2xhc3NOYW1lID0gJ3Zpcy1pdGVtLW92ZXJmbG93JztcbiAgICAgIGRvbS5ib3guYXBwZW5kQ2hpbGQoZG9tLmZyYW1lKTtcblxuICAgICAgLy8gY29udGVudHMgYm94XG4gICAgICBkb20uY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZG9tLmNvbnRlbnQuY2xhc3NOYW1lID0gJ3Zpcy1pdGVtLWNvbnRlbnQnO1xuICAgICAgZG9tLmZyYW1lLmFwcGVuZENoaWxkKGRvbS5jb250ZW50KTtcblxuICAgICAgLy8gTm90ZTogd2UgZG8gTk9UIGF0dGFjaCB0aGlzIGl0ZW0gYXMgYXR0cmlidXRlIHRvIHRoZSBET00sXG4gICAgICAvLyAgICAgICBzdWNoIHRoYXQgYmFja2dyb3VuZCBpdGVtcyBjYW5ub3QgYmUgc2VsZWN0ZWRcbiAgICAgIC8vZG9tLmJveFsndGltZWxpbmUtaXRlbSddID0gdGhpcztcblxuICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gYXBwZW5kIERPTSB0byBwYXJlbnQgRE9NXG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVkcmF3IGl0ZW06IG5vIHBhcmVudCBhdHRhY2hlZCcpO1xuICAgIH1cbiAgICBpZiAoIWRvbS5ib3gucGFyZW50Tm9kZSkge1xuICAgICAgdmFyIGJhY2tncm91bmQgPSB0aGlzLnBhcmVudC5kb20uYmFja2dyb3VuZDtcbiAgICAgIGlmICghYmFja2dyb3VuZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWRyYXcgaXRlbTogcGFyZW50IGhhcyBubyBiYWNrZ3JvdW5kIGNvbnRhaW5lciBlbGVtZW50Jyk7XG4gICAgICB9XG4gICAgICBiYWNrZ3JvdW5kLmFwcGVuZENoaWxkKGRvbS5ib3gpO1xuICAgIH1cbiAgICB0aGlzLmRpc3BsYXllZCA9IHRydWU7XG5cbiAgICAvLyBVcGRhdGUgRE9NIHdoZW4gaXRlbSBpcyBtYXJrZWQgZGlydHkuIEFuIGl0ZW0gaXMgbWFya2VkIGRpcnR5IHdoZW46XG4gICAgLy8gLSB0aGUgaXRlbSBpcyBub3QgeWV0IHJlbmRlcmVkXG4gICAgLy8gLSB0aGUgaXRlbSdzIGRhdGEgaXMgY2hhbmdlZFxuICAgIC8vIC0gdGhlIGl0ZW0gaXMgc2VsZWN0ZWQvZGVzZWxlY3RlZFxuICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICB0aGlzLl91cGRhdGVDb250ZW50cyh0aGlzLmRvbS5jb250ZW50KTtcbiAgICAgIHRoaXMuX3VwZGF0ZVRpdGxlKHRoaXMuZG9tLmNvbnRlbnQpO1xuICAgICAgdGhpcy5fdXBkYXRlRGF0YUF0dHJpYnV0ZXModGhpcy5kb20uY29udGVudCk7XG4gICAgICB0aGlzLl91cGRhdGVTdHlsZSh0aGlzLmRvbS5ib3gpO1xuXG4gICAgICAvLyB1cGRhdGUgY2xhc3NcbiAgICAgIHZhciBjbGFzc05hbWUgPSAodGhpcy5kYXRhLmNsYXNzTmFtZSA/ICcgJyArIHRoaXMuZGF0YS5jbGFzc05hbWUgOiAnJykgKyAodGhpcy5zZWxlY3RlZCA/ICcgdmlzLXNlbGVjdGVkJyA6ICcnKTtcbiAgICAgIGRvbS5ib3guY2xhc3NOYW1lID0gdGhpcy5iYXNlQ2xhc3NOYW1lICsgY2xhc3NOYW1lO1xuXG4gICAgICAvLyBkZXRlcm1pbmUgZnJvbSBjc3Mgd2hldGhlciB0aGlzIGJveCBoYXMgb3ZlcmZsb3dcbiAgICAgIHRoaXMub3ZlcmZsb3cgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb20uY29udGVudCkub3ZlcmZsb3cgIT09ICdoaWRkZW4nO1xuXG4gICAgICAvLyByZWNhbGN1bGF0ZSBzaXplXG4gICAgICB0aGlzLnByb3BzLmNvbnRlbnQud2lkdGggPSB0aGlzLmRvbS5jb250ZW50Lm9mZnNldFdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSAwOyAvLyBzZXQgaGVpZ2h0IHplcm8sIHNvIHRoaXMgaXRlbSB3aWxsIGJlIGlnbm9yZWQgd2hlbiBzdGFja2luZyBpdGVtc1xuXG4gICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTaG93IHRoZSBpdGVtIGluIHRoZSBET00gKHdoZW4gbm90IGFscmVhZHkgdmlzaWJsZSkuIFRoZSBpdGVtcyBET00gd2lsbFxuICAgKiBiZSBjcmVhdGVkIHdoZW4gbmVlZGVkLlxuICAgKi9cbiAgQmFja2dyb3VuZEl0ZW0ucHJvdG90eXBlLnNob3cgPSBSYW5nZUl0ZW0ucHJvdG90eXBlLnNob3c7XG5cbiAgLyoqXG4gICAqIEhpZGUgdGhlIGl0ZW0gZnJvbSB0aGUgRE9NICh3aGVuIHZpc2libGUpXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGNoYW5nZWRcbiAgICovXG4gIEJhY2tncm91bmRJdGVtLnByb3RvdHlwZS5oaWRlID0gUmFuZ2VJdGVtLnByb3RvdHlwZS5oaWRlO1xuXG4gIC8qKlxuICAgKiBSZXBvc2l0aW9uIHRoZSBpdGVtIGhvcml6b250YWxseVxuICAgKiBAT3ZlcnJpZGVcbiAgICovXG4gIEJhY2tncm91bmRJdGVtLnByb3RvdHlwZS5yZXBvc2l0aW9uWCA9IFJhbmdlSXRlbS5wcm90b3R5cGUucmVwb3NpdGlvblg7XG5cbiAgLyoqXG4gICAqIFJlcG9zaXRpb24gdGhlIGl0ZW0gdmVydGljYWxseVxuICAgKiBAT3ZlcnJpZGVcbiAgICovXG4gIEJhY2tncm91bmRJdGVtLnByb3RvdHlwZS5yZXBvc2l0aW9uWSA9IGZ1bmN0aW9uIChtYXJnaW4pIHtcbiAgICB2YXIgb25Ub3AgPSB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uaXRlbSA9PT0gJ3RvcCc7XG4gICAgdGhpcy5kb20uY29udGVudC5zdHlsZS50b3AgPSBvblRvcCA/ICcnIDogJzAnO1xuICAgIHRoaXMuZG9tLmNvbnRlbnQuc3R5bGUuYm90dG9tID0gb25Ub3AgPyAnMCcgOiAnJztcbiAgICB2YXIgaGVpZ2h0O1xuXG4gICAgLy8gc3BlY2lhbCBwb3NpdGlvbmluZyBmb3Igc3ViZ3JvdXBzXG4gICAgaWYgKHRoaXMuZGF0YS5zdWJncm91cCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBUT0RPOiBpbnN0ZWFkIG9mIGNhbGN1bGF0aW5nIHRoZSB0b3AgcG9zaXRpb24gb2YgdGhlIHN1Ymdyb3VwcyBoZXJlIGZvciBldmVyeSBCYWNrZ3JvdW5kSXRlbSwgY2FsY3VsYXRlIHRoZSB0b3Agb2YgdGhlIHN1Ymdyb3VwIG9uY2UgaW4gSXRlbXNldFxuXG4gICAgICB2YXIgaXRlbVN1Ymdyb3VwID0gdGhpcy5kYXRhLnN1Ymdyb3VwO1xuICAgICAgdmFyIHN1Ymdyb3VwcyA9IHRoaXMucGFyZW50LnN1Ymdyb3VwcztcbiAgICAgIHZhciBzdWJncm91cEluZGV4ID0gc3ViZ3JvdXBzW2l0ZW1TdWJncm91cF0uaW5kZXg7XG4gICAgICAvLyBpZiB0aGUgb3JpZW50YXRpb24gaXMgdG9wLCB3ZSBuZWVkIHRvIHRha2UgdGhlIGRpZmZlcmVuY2UgaW4gaGVpZ2h0IGludG8gYWNjb3VudC5cbiAgICAgIGlmIChvblRvcCA9PSB0cnVlKSB7XG4gICAgICAgIC8vIHRoZSBmaXJzdCBzdWJncm91cCB3aWxsIGhhdmUgdG8gYWNjb3VudCBmb3IgdGhlIGRpc3RhbmNlIGZyb20gdGhlIHRvcCB0byB0aGUgZmlyc3QgaXRlbS5cbiAgICAgICAgaGVpZ2h0ID0gdGhpcy5wYXJlbnQuc3ViZ3JvdXBzW2l0ZW1TdWJncm91cF0uaGVpZ2h0ICsgbWFyZ2luLml0ZW0udmVydGljYWw7XG4gICAgICAgIGhlaWdodCArPSBzdWJncm91cEluZGV4ID09IDAgPyBtYXJnaW4uYXhpcyAtIDAuNSAqIG1hcmdpbi5pdGVtLnZlcnRpY2FsIDogMDtcbiAgICAgICAgdmFyIG5ld1RvcCA9IHRoaXMucGFyZW50LnRvcDtcbiAgICAgICAgZm9yICh2YXIgc3ViZ3JvdXAgaW4gc3ViZ3JvdXBzKSB7XG4gICAgICAgICAgaWYgKHN1Ymdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShzdWJncm91cCkpIHtcbiAgICAgICAgICAgIGlmIChzdWJncm91cHNbc3ViZ3JvdXBdLnZpc2libGUgPT0gdHJ1ZSAmJiBzdWJncm91cHNbc3ViZ3JvdXBdLmluZGV4IDwgc3ViZ3JvdXBJbmRleCkge1xuICAgICAgICAgICAgICBuZXdUb3AgKz0gc3ViZ3JvdXBzW3N1Ymdyb3VwXS5oZWlnaHQgKyBtYXJnaW4uaXRlbS52ZXJ0aWNhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGUgb3RoZXJzIHdpbGwgaGF2ZSB0byBiZSBvZmZzZXQgZG93bndhcmRzIHdpdGggdGhpcyBzYW1lIGRpc3RhbmNlLlxuICAgICAgICBuZXdUb3AgKz0gc3ViZ3JvdXBJbmRleCAhPSAwID8gbWFyZ2luLmF4aXMgLSAwLjUgKiBtYXJnaW4uaXRlbS52ZXJ0aWNhbCA6IDA7XG4gICAgICAgIHRoaXMuZG9tLmJveC5zdHlsZS50b3AgPSBuZXdUb3AgKyAncHgnO1xuICAgICAgICB0aGlzLmRvbS5ib3guc3R5bGUuYm90dG9tID0gJyc7XG4gICAgICB9XG4gICAgICAvLyBhbmQgd2hlbiB0aGUgb3JpZW50YXRpb24gaXMgYm90dG9tOlxuICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIG5ld1RvcCA9IHRoaXMucGFyZW50LnRvcDtcbiAgICAgICAgICB2YXIgdG90YWxIZWlnaHQgPSAwO1xuICAgICAgICAgIGZvciAodmFyIHN1Ymdyb3VwIGluIHN1Ymdyb3Vwcykge1xuICAgICAgICAgICAgaWYgKHN1Ymdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShzdWJncm91cCkpIHtcbiAgICAgICAgICAgICAgaWYgKHN1Ymdyb3Vwc1tzdWJncm91cF0udmlzaWJsZSA9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0hlaWdodCA9IHN1Ymdyb3Vwc1tzdWJncm91cF0uaGVpZ2h0ICsgbWFyZ2luLml0ZW0udmVydGljYWw7XG4gICAgICAgICAgICAgICAgdG90YWxIZWlnaHQgKz0gbmV3SGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChzdWJncm91cHNbc3ViZ3JvdXBdLmluZGV4ID4gc3ViZ3JvdXBJbmRleCkge1xuICAgICAgICAgICAgICAgICAgbmV3VG9wICs9IG5ld0hlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaGVpZ2h0ID0gdGhpcy5wYXJlbnQuc3ViZ3JvdXBzW2l0ZW1TdWJncm91cF0uaGVpZ2h0ICsgbWFyZ2luLml0ZW0udmVydGljYWw7XG4gICAgICAgICAgdGhpcy5kb20uYm94LnN0eWxlLnRvcCA9IHRoaXMucGFyZW50LmhlaWdodCAtIHRvdGFsSGVpZ2h0ICsgbmV3VG9wICsgJ3B4JztcbiAgICAgICAgICB0aGlzLmRvbS5ib3guc3R5bGUuYm90dG9tID0gJyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYW5kIGluIHRoZSBjYXNlIG9mIG5vIHN1Ymdyb3VwczpcbiAgICBlbHNlIHtcbiAgICAgICAgLy8gd2Ugd2FudCBiYWNrZ3JvdW5kcyB3aXRoIGdyb3VwcyB0byBvbmx5IHNob3cgaW4gZ3JvdXBzLlxuICAgICAgICBpZiAodGhpcy5wYXJlbnQgaW5zdGFuY2VvZiBCYWNrZ3JvdW5kR3JvdXApIHtcbiAgICAgICAgICAvLyBpZiB0aGUgaXRlbSBpcyBub3QgaW4gYSBncm91cDpcbiAgICAgICAgICBoZWlnaHQgPSBNYXRoLm1heCh0aGlzLnBhcmVudC5oZWlnaHQsIHRoaXMucGFyZW50Lml0ZW1TZXQuYm9keS5kb21Qcm9wcy5jZW50ZXIuaGVpZ2h0LCB0aGlzLnBhcmVudC5pdGVtU2V0LmJvZHkuZG9tUHJvcHMuY2VudGVyQ29udGFpbmVyLmhlaWdodCk7XG4gICAgICAgICAgdGhpcy5kb20uYm94LnN0eWxlLnRvcCA9IG9uVG9wID8gJzAnIDogJyc7XG4gICAgICAgICAgdGhpcy5kb20uYm94LnN0eWxlLmJvdHRvbSA9IG9uVG9wID8gJycgOiAnMCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGVpZ2h0ID0gdGhpcy5wYXJlbnQuaGVpZ2h0O1xuICAgICAgICAgIC8vIHNhbWUgYWxpZ25tZW50IGZvciBpdGVtcyB3aGVuIG9yaWVudGF0aW9uIGlzIHRvcCBvciBib3R0b21cbiAgICAgICAgICB0aGlzLmRvbS5ib3guc3R5bGUudG9wID0gdGhpcy5wYXJlbnQudG9wICsgJ3B4JztcbiAgICAgICAgICB0aGlzLmRvbS5ib3guc3R5bGUuYm90dG9tID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB0aGlzLmRvbS5ib3guc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IEJhY2tncm91bmRJdGVtO1xuXG4vKioqLyB9LFxuLyogNDQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4gIHZhciBDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKTtcbiAgdmFyIFRpbWVTdGVwID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSk7XG4gIHZhciBEYXRlVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xuICB2YXIgbW9tZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxuICAvKipcbiAgICogQSBob3Jpem9udGFsIHRpbWUgYXhpc1xuICAgKiBAcGFyYW0ge3tkb206IE9iamVjdCwgZG9tUHJvcHM6IE9iamVjdCwgZW1pdHRlcjogRW1pdHRlciwgcmFuZ2U6IFJhbmdlfX0gYm9keVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgICAgICBTZWUgVGltZUF4aXMuc2V0T3B0aW9ucyBmb3IgdGhlIGF2YWlsYWJsZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLlxuICAgKiBAY29uc3RydWN0b3IgVGltZUF4aXNcbiAgICogQGV4dGVuZHMgQ29tcG9uZW50XG4gICAqL1xuICBmdW5jdGlvbiBUaW1lQXhpcyhib2R5LCBvcHRpb25zKSB7XG4gICAgdGhpcy5kb20gPSB7XG4gICAgICBmb3JlZ3JvdW5kOiBudWxsLFxuICAgICAgbGluZXM6IFtdLFxuICAgICAgbWFqb3JUZXh0czogW10sXG4gICAgICBtaW5vclRleHRzOiBbXSxcbiAgICAgIHJlZHVuZGFudDoge1xuICAgICAgICBsaW5lczogW10sXG4gICAgICAgIG1ham9yVGV4dHM6IFtdLFxuICAgICAgICBtaW5vclRleHRzOiBbXVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5wcm9wcyA9IHtcbiAgICAgIHJhbmdlOiB7XG4gICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICBlbmQ6IDAsXG4gICAgICAgIG1pbmltdW1TdGVwOiAwXG4gICAgICB9LFxuICAgICAgbGluZVRvcDogMFxuICAgIH07XG5cbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgb3JpZW50YXRpb246IHtcbiAgICAgICAgYXhpczogJ2JvdHRvbSdcbiAgICAgIH0sIC8vIGF4aXMgb3JpZW50YXRpb246ICd0b3AnIG9yICdib3R0b20nXG4gICAgICBzaG93TWlub3JMYWJlbHM6IHRydWUsXG4gICAgICBzaG93TWFqb3JMYWJlbHM6IHRydWUsXG4gICAgICBtYXhNaW5vckNoYXJzOiA3LFxuICAgICAgZm9ybWF0OiBUaW1lU3RlcC5GT1JNQVQsXG4gICAgICBtb21lbnQ6IG1vbWVudCxcbiAgICAgIHRpbWVBeGlzOiBudWxsXG4gICAgfTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuXG4gICAgLy8gY3JlYXRlIHRoZSBIVE1MIERPTVxuICAgIHRoaXMuX2NyZWF0ZSgpO1xuXG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG5cbiAgVGltZUF4aXMucHJvdG90eXBlID0gbmV3IENvbXBvbmVudCgpO1xuXG4gIC8qKlxuICAgKiBTZXQgb3B0aW9ucyBmb3IgdGhlIFRpbWVBeGlzLlxuICAgKiBQYXJhbWV0ZXJzIHdpbGwgYmUgbWVyZ2VkIGluIGN1cnJlbnQgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgIEF2YWlsYWJsZSBvcHRpb25zOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAge3N0cmluZ30gW29yaWVudGF0aW9uLmF4aXNdXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICB7Ym9vbGVhbn0gW3Nob3dNaW5vckxhYmVsc11cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHtib29sZWFufSBbc2hvd01ham9yTGFiZWxzXVxuICAgKi9cbiAgVGltZUF4aXMucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAvLyBjb3B5IGFsbCBvcHRpb25zIHRoYXQgd2Uga25vd1xuICAgICAgdXRpbC5zZWxlY3RpdmVFeHRlbmQoWydzaG93TWlub3JMYWJlbHMnLCAnc2hvd01ham9yTGFiZWxzJywgJ21heE1pbm9yQ2hhcnMnLCAnaGlkZGVuRGF0ZXMnLCAndGltZUF4aXMnLCAnbW9tZW50JywgJ3J0bCddLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBkZWVwIGNvcHkgdGhlIGZvcm1hdCBvcHRpb25zXG4gICAgICB1dGlsLnNlbGVjdGl2ZURlZXBFeHRlbmQoWydmb3JtYXQnXSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgaWYgKCdvcmllbnRhdGlvbicgaW4gb3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMub3JpZW50YXRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uLmF4aXMgPSBvcHRpb25zLm9yaWVudGF0aW9uO1xuICAgICAgICB9IGVsc2UgaWYgKF90eXBlb2Yob3B0aW9ucy5vcmllbnRhdGlvbikgPT09ICdvYmplY3QnICYmICdheGlzJyBpbiBvcHRpb25zLm9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uLmF4aXMgPSBvcHRpb25zLm9yaWVudGF0aW9uLmF4aXM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gYXBwbHkgbG9jYWxlIHRvIG1vbWVudC5qc1xuICAgICAgLy8gVE9ETzogbm90IHNvIG5pY2UsIHRoaXMgaXMgYXBwbGllZCBnbG9iYWxseSB0byBtb21lbnQuanNcbiAgICAgIGlmICgnbG9jYWxlJyBpbiBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbW9tZW50LmxvY2FsZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIG1vbWVudC5qcyAyLjguMStcbiAgICAgICAgICBtb21lbnQubG9jYWxlKG9wdGlvbnMubG9jYWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb21lbnQubGFuZyhvcHRpb25zLmxvY2FsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgSFRNTCBET00gZm9yIHRoZSBUaW1lQXhpc1xuICAgKi9cbiAgVGltZUF4aXMucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kb20uZm9yZWdyb3VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuZG9tLmJhY2tncm91bmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIHRoaXMuZG9tLmZvcmVncm91bmQuY2xhc3NOYW1lID0gJ3Zpcy10aW1lLWF4aXMgdmlzLWZvcmVncm91bmQnO1xuICAgIHRoaXMuZG9tLmJhY2tncm91bmQuY2xhc3NOYW1lID0gJ3Zpcy10aW1lLWF4aXMgdmlzLWJhY2tncm91bmQnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXN0cm95IHRoZSBUaW1lQXhpc1xuICAgKi9cbiAgVGltZUF4aXMucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gcmVtb3ZlIGZyb20gRE9NXG4gICAgaWYgKHRoaXMuZG9tLmZvcmVncm91bmQucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5kb20uZm9yZWdyb3VuZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLmZvcmVncm91bmQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5kb20uYmFja2dyb3VuZC5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLmRvbS5iYWNrZ3JvdW5kLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20uYmFja2dyb3VuZCk7XG4gICAgfVxuXG4gICAgdGhpcy5ib2R5ID0gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogUmVwYWludCB0aGUgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgY29tcG9uZW50IGlzIHJlc2l6ZWRcbiAgICovXG4gIFRpbWVBeGlzLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgZm9yZWdyb3VuZCA9IHRoaXMuZG9tLmZvcmVncm91bmQ7XG4gICAgdmFyIGJhY2tncm91bmQgPSB0aGlzLmRvbS5iYWNrZ3JvdW5kO1xuXG4gICAgLy8gZGV0ZXJtaW5lIHRoZSBjb3JyZWN0IHBhcmVudCBET00gZWxlbWVudCAoZGVwZW5kaW5nIG9uIG9wdGlvbiBvcmllbnRhdGlvbilcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uLmF4aXMgPT0gJ3RvcCcgPyB0aGlzLmJvZHkuZG9tLnRvcCA6IHRoaXMuYm9keS5kb20uYm90dG9tO1xuICAgIHZhciBwYXJlbnRDaGFuZ2VkID0gZm9yZWdyb3VuZC5wYXJlbnROb2RlICE9PSBwYXJlbnQ7XG5cbiAgICAvLyBjYWxjdWxhdGUgY2hhcmFjdGVyIHdpZHRoIGFuZCBoZWlnaHRcbiAgICB0aGlzLl9jYWxjdWxhdGVDaGFyU2l6ZSgpO1xuXG4gICAgLy8gVE9ETzogcmVjYWxjdWxhdGUgc2l6ZXMgb25seSBuZWVkZWQgd2hlbiBwYXJlbnQgaXMgcmVzaXplZCBvciBvcHRpb25zIGlzIGNoYW5nZWRcbiAgICB2YXIgc2hvd01pbm9yTGFiZWxzID0gdGhpcy5vcHRpb25zLnNob3dNaW5vckxhYmVscyAmJiB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uYXhpcyAhPT0gJ25vbmUnO1xuICAgIHZhciBzaG93TWFqb3JMYWJlbHMgPSB0aGlzLm9wdGlvbnMuc2hvd01ham9yTGFiZWxzICYmIHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5heGlzICE9PSAnbm9uZSc7XG5cbiAgICAvLyBkZXRlcm1pbmUgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIGVsZW1lbnMgZm9yIHRoZSBheGlzXG4gICAgcHJvcHMubWlub3JMYWJlbEhlaWdodCA9IHNob3dNaW5vckxhYmVscyA/IHByb3BzLm1pbm9yQ2hhckhlaWdodCA6IDA7XG4gICAgcHJvcHMubWFqb3JMYWJlbEhlaWdodCA9IHNob3dNYWpvckxhYmVscyA/IHByb3BzLm1ham9yQ2hhckhlaWdodCA6IDA7XG4gICAgcHJvcHMuaGVpZ2h0ID0gcHJvcHMubWlub3JMYWJlbEhlaWdodCArIHByb3BzLm1ham9yTGFiZWxIZWlnaHQ7XG4gICAgcHJvcHMud2lkdGggPSBmb3JlZ3JvdW5kLm9mZnNldFdpZHRoO1xuXG4gICAgcHJvcHMubWlub3JMaW5lSGVpZ2h0ID0gdGhpcy5ib2R5LmRvbVByb3BzLnJvb3QuaGVpZ2h0IC0gcHJvcHMubWFqb3JMYWJlbEhlaWdodCAtICh0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uYXhpcyA9PSAndG9wJyA/IHRoaXMuYm9keS5kb21Qcm9wcy5ib3R0b20uaGVpZ2h0IDogdGhpcy5ib2R5LmRvbVByb3BzLnRvcC5oZWlnaHQpO1xuICAgIHByb3BzLm1pbm9yTGluZVdpZHRoID0gMTsgLy8gVE9ETzogcmVhbGx5IGNhbGN1bGF0ZSB3aWR0aFxuICAgIHByb3BzLm1ham9yTGluZUhlaWdodCA9IHByb3BzLm1pbm9yTGluZUhlaWdodCArIHByb3BzLm1ham9yTGFiZWxIZWlnaHQ7XG4gICAgcHJvcHMubWFqb3JMaW5lV2lkdGggPSAxOyAvLyBUT0RPOiByZWFsbHkgY2FsY3VsYXRlIHdpZHRoXG5cbiAgICAvLyAgdGFrZSBmb3JlZ3JvdW5kIGFuZCBiYWNrZ3JvdW5kIG9mZmxpbmUgd2hpbGUgdXBkYXRpbmcgKGlzIGFsbW9zdCB0d2ljZSBhcyBmYXN0KVxuICAgIHZhciBmb3JlZ3JvdW5kTmV4dFNpYmxpbmcgPSBmb3JlZ3JvdW5kLm5leHRTaWJsaW5nO1xuICAgIHZhciBiYWNrZ3JvdW5kTmV4dFNpYmxpbmcgPSBiYWNrZ3JvdW5kLm5leHRTaWJsaW5nO1xuICAgIGZvcmVncm91bmQucGFyZW50Tm9kZSAmJiBmb3JlZ3JvdW5kLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZm9yZWdyb3VuZCk7XG4gICAgYmFja2dyb3VuZC5wYXJlbnROb2RlICYmIGJhY2tncm91bmQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiYWNrZ3JvdW5kKTtcblxuICAgIGZvcmVncm91bmQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5wcm9wcy5oZWlnaHQgKyAncHgnO1xuXG4gICAgdGhpcy5fcmVwYWludExhYmVscygpO1xuXG4gICAgLy8gcHV0IERPTSBvbmxpbmUgYWdhaW4gKGF0IHRoZSBzYW1lIHBsYWNlKVxuICAgIGlmIChmb3JlZ3JvdW5kTmV4dFNpYmxpbmcpIHtcbiAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoZm9yZWdyb3VuZCwgZm9yZWdyb3VuZE5leHRTaWJsaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGZvcmVncm91bmQpO1xuICAgIH1cbiAgICBpZiAoYmFja2dyb3VuZE5leHRTaWJsaW5nKSB7XG4gICAgICB0aGlzLmJvZHkuZG9tLmJhY2tncm91bmRWZXJ0aWNhbC5pbnNlcnRCZWZvcmUoYmFja2dyb3VuZCwgYmFja2dyb3VuZE5leHRTaWJsaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ib2R5LmRvbS5iYWNrZ3JvdW5kVmVydGljYWwuYXBwZW5kQ2hpbGQoYmFja2dyb3VuZCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9pc1Jlc2l6ZWQoKSB8fCBwYXJlbnRDaGFuZ2VkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXBhaW50IG1ham9yIGFuZCBtaW5vciB0ZXh0IGxhYmVscyBhbmQgdmVydGljYWwgZ3JpZCBsaW5lc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgVGltZUF4aXMucHJvdG90eXBlLl9yZXBhaW50TGFiZWxzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcmllbnRhdGlvbiA9IHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5heGlzO1xuXG4gICAgLy8gY2FsY3VsYXRlIHJhbmdlIGFuZCBzdGVwIChzdGVwIHN1Y2ggdGhhdCB3ZSBoYXZlIHNwYWNlIGZvciA3IGNoYXJhY3RlcnMgcGVyIGxhYmVsKVxuICAgIHZhciBzdGFydCA9IHV0aWwuY29udmVydCh0aGlzLmJvZHkucmFuZ2Uuc3RhcnQsICdOdW1iZXInKTtcbiAgICB2YXIgZW5kID0gdXRpbC5jb252ZXJ0KHRoaXMuYm9keS5yYW5nZS5lbmQsICdOdW1iZXInKTtcbiAgICB2YXIgdGltZUxhYmVsc2l6ZSA9IHRoaXMuYm9keS51dGlsLnRvVGltZSgodGhpcy5wcm9wcy5taW5vckNoYXJXaWR0aCB8fCAxMCkgKiB0aGlzLm9wdGlvbnMubWF4TWlub3JDaGFycykudmFsdWVPZigpO1xuICAgIHZhciBtaW5pbXVtU3RlcCA9IHRpbWVMYWJlbHNpemUgLSBEYXRlVXRpbC5nZXRIaWRkZW5EdXJhdGlvbkJlZm9yZSh0aGlzLm9wdGlvbnMubW9tZW50LCB0aGlzLmJvZHkuaGlkZGVuRGF0ZXMsIHRoaXMuYm9keS5yYW5nZSwgdGltZUxhYmVsc2l6ZSk7XG4gICAgbWluaW11bVN0ZXAgLT0gdGhpcy5ib2R5LnV0aWwudG9UaW1lKDApLnZhbHVlT2YoKTtcblxuICAgIHZhciBzdGVwID0gbmV3IFRpbWVTdGVwKG5ldyBEYXRlKHN0YXJ0KSwgbmV3IERhdGUoZW5kKSwgbWluaW11bVN0ZXAsIHRoaXMuYm9keS5oaWRkZW5EYXRlcyk7XG4gICAgc3RlcC5zZXRNb21lbnQodGhpcy5vcHRpb25zLm1vbWVudCk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5mb3JtYXQpIHtcbiAgICAgIHN0ZXAuc2V0Rm9ybWF0KHRoaXMub3B0aW9ucy5mb3JtYXQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnRpbWVBeGlzKSB7XG4gICAgICBzdGVwLnNldFNjYWxlKHRoaXMub3B0aW9ucy50aW1lQXhpcyk7XG4gICAgfVxuICAgIHRoaXMuc3RlcCA9IHN0ZXA7XG5cbiAgICAvLyBNb3ZlIGFsbCBET00gZWxlbWVudHMgdG8gYSBcInJlZHVuZGFudFwiIGxpc3QsIHdoZXJlIHRoZXlcbiAgICAvLyBjYW4gYmUgcGlja2VkIGZvciByZS11c2UsIGFuZCBjbGVhciB0aGUgbGlzdHMgd2l0aCBsaW5lcyBhbmQgdGV4dHMuXG4gICAgLy8gQXQgdGhlIGVuZCBvZiB0aGUgZnVuY3Rpb24gX3JlcGFpbnRMYWJlbHMsIGxlZnQgb3ZlciBlbGVtZW50cyB3aWxsIGJlIGNsZWFuZWQgdXBcbiAgICB2YXIgZG9tID0gdGhpcy5kb207XG4gICAgZG9tLnJlZHVuZGFudC5saW5lcyA9IGRvbS5saW5lcztcbiAgICBkb20ucmVkdW5kYW50Lm1ham9yVGV4dHMgPSBkb20ubWFqb3JUZXh0cztcbiAgICBkb20ucmVkdW5kYW50Lm1pbm9yVGV4dHMgPSBkb20ubWlub3JUZXh0cztcbiAgICBkb20ubGluZXMgPSBbXTtcbiAgICBkb20ubWFqb3JUZXh0cyA9IFtdO1xuICAgIGRvbS5taW5vclRleHRzID0gW107XG5cbiAgICB2YXIgY3VycmVudDtcbiAgICB2YXIgbmV4dDtcbiAgICB2YXIgeDtcbiAgICB2YXIgeE5leHQ7XG4gICAgdmFyIGlzTWFqb3IsIG5leHRJc01ham9yO1xuICAgIHZhciB3aWR0aCA9IDAsXG4gICAgICAgIHByZXZXaWR0aDtcbiAgICB2YXIgbGluZTtcbiAgICB2YXIgbGFiZWxNaW5vcjtcbiAgICB2YXIgeEZpcnN0TWFqb3JMYWJlbCA9IHVuZGVmaW5lZDtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBNQVggPSAxMDAwO1xuICAgIHZhciBjbGFzc05hbWU7XG5cbiAgICBzdGVwLnN0YXJ0KCk7XG4gICAgbmV4dCA9IHN0ZXAuZ2V0Q3VycmVudCgpO1xuICAgIHhOZXh0ID0gdGhpcy5ib2R5LnV0aWwudG9TY3JlZW4obmV4dCk7XG4gICAgd2hpbGUgKHN0ZXAuaGFzTmV4dCgpICYmIGNvdW50IDwgTUFYKSB7XG4gICAgICBjb3VudCsrO1xuXG4gICAgICBpc01ham9yID0gc3RlcC5pc01ham9yKCk7XG4gICAgICBjbGFzc05hbWUgPSBzdGVwLmdldENsYXNzTmFtZSgpO1xuICAgICAgbGFiZWxNaW5vciA9IHN0ZXAuZ2V0TGFiZWxNaW5vcigpO1xuXG4gICAgICBjdXJyZW50ID0gbmV4dDtcbiAgICAgIHggPSB4TmV4dDtcblxuICAgICAgc3RlcC5uZXh0KCk7XG4gICAgICBuZXh0ID0gc3RlcC5nZXRDdXJyZW50KCk7XG4gICAgICBuZXh0SXNNYWpvciA9IHN0ZXAuaXNNYWpvcigpO1xuICAgICAgeE5leHQgPSB0aGlzLmJvZHkudXRpbC50b1NjcmVlbihuZXh0KTtcblxuICAgICAgcHJldldpZHRoID0gd2lkdGg7XG4gICAgICB3aWR0aCA9IHhOZXh0IC0geDtcbiAgICAgIHZhciBzaG93TWlub3JHcmlkID0gd2lkdGggPj0gcHJldldpZHRoICogMC40OyAvLyBwcmV2ZW50IGRpc3BsYXlpbmcgb2YgdGhlIDMxdGggb2YgdGhlIG1vbnRoIG9uIGEgc2NhbGUgb2YgNSBkYXlzXG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd01pbm9yTGFiZWxzICYmIHNob3dNaW5vckdyaWQpIHtcbiAgICAgICAgdmFyIGxhYmVsID0gdGhpcy5fcmVwYWludE1pbm9yVGV4dCh4LCBsYWJlbE1pbm9yLCBvcmllbnRhdGlvbiwgY2xhc3NOYW1lKTtcbiAgICAgICAgbGFiZWwuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7IC8vIHNldCB3aWR0aCB0byBwcmV2ZW50IG92ZXJmbG93XG4gICAgICB9XG5cbiAgICAgIGlmIChpc01ham9yICYmIHRoaXMub3B0aW9ucy5zaG93TWFqb3JMYWJlbHMpIHtcbiAgICAgICAgaWYgKHggPiAwKSB7XG4gICAgICAgICAgaWYgKHhGaXJzdE1ham9yTGFiZWwgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB4Rmlyc3RNYWpvckxhYmVsID0geDtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGFiZWwgPSB0aGlzLl9yZXBhaW50TWFqb3JUZXh0KHgsIHN0ZXAuZ2V0TGFiZWxNYWpvcigpLCBvcmllbnRhdGlvbiwgY2xhc3NOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBsaW5lID0gdGhpcy5fcmVwYWludE1ham9yTGluZSh4LCB3aWR0aCwgb3JpZW50YXRpb24sIGNsYXNzTmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBtaW5vciBsaW5lXG4gICAgICAgIGlmIChzaG93TWlub3JHcmlkKSB7XG4gICAgICAgICAgbGluZSA9IHRoaXMuX3JlcGFpbnRNaW5vckxpbmUoeCwgd2lkdGgsIG9yaWVudGF0aW9uLCBjbGFzc05hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChsaW5lKSB7XG4gICAgICAgICAgICAvLyBhZGp1c3QgdGhlIHdpZHRoIG9mIHRoZSBwcmV2aW91cyBncmlkXG4gICAgICAgICAgICBsaW5lLnN0eWxlLndpZHRoID0gcGFyc2VJbnQobGluZS5zdHlsZS53aWR0aCkgKyB3aWR0aCArICdweCc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvdW50ID09PSBNQVggJiYgIXdhcm5lZEZvck92ZXJmbG93KSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1NvbWV0aGluZyBpcyB3cm9uZyB3aXRoIHRoZSBUaW1lbGluZSBzY2FsZS4gTGltaXRlZCBkcmF3aW5nIG9mIGdyaWQgbGluZXMgdG8gJyArIE1BWCArICcgbGluZXMuJyk7XG4gICAgICB3YXJuZWRGb3JPdmVyZmxvdyA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIGEgbWFqb3IgbGFiZWwgb24gdGhlIGxlZnQgd2hlbiBuZWVkZWRcbiAgICBpZiAodGhpcy5vcHRpb25zLnNob3dNYWpvckxhYmVscykge1xuICAgICAgdmFyIGxlZnRUaW1lID0gdGhpcy5ib2R5LnV0aWwudG9UaW1lKDApLFxuICAgICAgICAgIGxlZnRUZXh0ID0gc3RlcC5nZXRMYWJlbE1ham9yKGxlZnRUaW1lKSxcbiAgICAgICAgICB3aWR0aFRleHQgPSBsZWZ0VGV4dC5sZW5ndGggKiAodGhpcy5wcm9wcy5tYWpvckNoYXJXaWR0aCB8fCAxMCkgKyAxMDsgLy8gdXBwZXIgYm91bmQgZXN0aW1hdGlvblxuXG4gICAgICBpZiAoeEZpcnN0TWFqb3JMYWJlbCA9PSB1bmRlZmluZWQgfHwgd2lkdGhUZXh0IDwgeEZpcnN0TWFqb3JMYWJlbCkge1xuICAgICAgICB0aGlzLl9yZXBhaW50TWFqb3JUZXh0KDAsIGxlZnRUZXh0LCBvcmllbnRhdGlvbiwgY2xhc3NOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDbGVhbnVwIGxlZnRvdmVyIERPTSBlbGVtZW50cyBmcm9tIHRoZSByZWR1bmRhbnQgbGlzdFxuICAgIHV0aWwuZm9yRWFjaCh0aGlzLmRvbS5yZWR1bmRhbnQsIGZ1bmN0aW9uIChhcnIpIHtcbiAgICAgIHdoaWxlIChhcnIubGVuZ3RoKSB7XG4gICAgICAgIHZhciBlbGVtID0gYXJyLnBvcCgpO1xuICAgICAgICBpZiAoZWxlbSAmJiBlbGVtLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBlbGVtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbWlub3IgbGFiZWwgZm9yIHRoZSBheGlzIGF0IHBvc2l0aW9uIHhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRleHRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWVudGF0aW9uICAgXCJ0b3BcIiBvciBcImJvdHRvbVwiIChkZWZhdWx0KVxuICAgKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9IFJldHVybnMgdGhlIEhUTUwgZWxlbWVudCBvZiB0aGUgY3JlYXRlZCBsYWJlbFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgVGltZUF4aXMucHJvdG90eXBlLl9yZXBhaW50TWlub3JUZXh0ID0gZnVuY3Rpb24gKHgsIHRleHQsIG9yaWVudGF0aW9uLCBjbGFzc05hbWUpIHtcbiAgICAvLyByZXVzZSByZWR1bmRhbnQgbGFiZWxcbiAgICB2YXIgbGFiZWwgPSB0aGlzLmRvbS5yZWR1bmRhbnQubWlub3JUZXh0cy5zaGlmdCgpO1xuXG4gICAgaWYgKCFsYWJlbCkge1xuICAgICAgLy8gY3JlYXRlIG5ldyBsYWJlbFxuICAgICAgdmFyIGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgICBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgbGFiZWwuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgICB0aGlzLmRvbS5mb3JlZ3JvdW5kLmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgICB9XG4gICAgdGhpcy5kb20ubWlub3JUZXh0cy5wdXNoKGxhYmVsKTtcblxuICAgIGxhYmVsLmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlID0gdGV4dDtcblxuICAgIGxhYmVsLnN0eWxlLnRvcCA9IG9yaWVudGF0aW9uID09ICd0b3AnID8gdGhpcy5wcm9wcy5tYWpvckxhYmVsSGVpZ2h0ICsgJ3B4JyA6ICcwJztcblxuICAgIGlmICh0aGlzLm9wdGlvbnMucnRsKSB7XG4gICAgICBsYWJlbC5zdHlsZS5sZWZ0ID0gXCJcIjtcbiAgICAgIGxhYmVsLnN0eWxlLnJpZ2h0ID0geCArICdweCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhYmVsLnN0eWxlLmxlZnQgPSB4ICsgJ3B4JztcbiAgICB9O1xuICAgIGxhYmVsLmNsYXNzTmFtZSA9ICd2aXMtdGV4dCB2aXMtbWlub3IgJyArIGNsYXNzTmFtZTtcbiAgICAvL2xhYmVsLnRpdGxlID0gdGl0bGU7ICAvLyBUT0RPOiB0aGlzIGlzIGEgaGVhdnkgb3BlcmF0aW9uXG5cbiAgICByZXR1cm4gbGFiZWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIE1ham9yIGxhYmVsIGZvciB0aGUgYXhpcyBhdCBwb3NpdGlvbiB4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcmllbnRhdGlvbiAgIFwidG9wXCIgb3IgXCJib3R0b21cIiAoZGVmYXVsdClcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZVxuICAgKiBAcmV0dXJuIHtFbGVtZW50fSBSZXR1cm5zIHRoZSBIVE1MIGVsZW1lbnQgb2YgdGhlIGNyZWF0ZWQgbGFiZWxcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFRpbWVBeGlzLnByb3RvdHlwZS5fcmVwYWludE1ham9yVGV4dCA9IGZ1bmN0aW9uICh4LCB0ZXh0LCBvcmllbnRhdGlvbiwgY2xhc3NOYW1lKSB7XG4gICAgLy8gcmV1c2UgcmVkdW5kYW50IGxhYmVsXG4gICAgdmFyIGxhYmVsID0gdGhpcy5kb20ucmVkdW5kYW50Lm1ham9yVGV4dHMuc2hpZnQoKTtcblxuICAgIGlmICghbGFiZWwpIHtcbiAgICAgIC8vIGNyZWF0ZSBsYWJlbFxuICAgICAgdmFyIGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbiAgICAgIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBsYWJlbC5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICAgIHRoaXMuZG9tLmZvcmVncm91bmQuYXBwZW5kQ2hpbGQobGFiZWwpO1xuICAgIH1cbiAgICB0aGlzLmRvbS5tYWpvclRleHRzLnB1c2gobGFiZWwpO1xuXG4gICAgbGFiZWwuY2hpbGROb2Rlc1swXS5ub2RlVmFsdWUgPSB0ZXh0O1xuICAgIGxhYmVsLmNsYXNzTmFtZSA9ICd2aXMtdGV4dCB2aXMtbWFqb3IgJyArIGNsYXNzTmFtZTtcbiAgICAvL2xhYmVsLnRpdGxlID0gdGl0bGU7IC8vIFRPRE86IHRoaXMgaXMgYSBoZWF2eSBvcGVyYXRpb25cblxuICAgIGxhYmVsLnN0eWxlLnRvcCA9IG9yaWVudGF0aW9uID09ICd0b3AnID8gJzAnIDogdGhpcy5wcm9wcy5taW5vckxhYmVsSGVpZ2h0ICsgJ3B4JztcbiAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgbGFiZWwuc3R5bGUubGVmdCA9IFwiXCI7XG4gICAgICBsYWJlbC5zdHlsZS5yaWdodCA9IHggKyAncHgnO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYWJlbC5zdHlsZS5sZWZ0ID0geCArICdweCc7XG4gICAgfTtcblxuICAgIHJldHVybiBsYWJlbDtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbWlub3IgbGluZSBmb3IgdGhlIGF4aXMgYXQgcG9zaXRpb24geFxuICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWVudGF0aW9uICAgXCJ0b3BcIiBvciBcImJvdHRvbVwiIChkZWZhdWx0KVxuICAgKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9IFJldHVybnMgdGhlIGNyZWF0ZWQgbGluZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgVGltZUF4aXMucHJvdG90eXBlLl9yZXBhaW50TWlub3JMaW5lID0gZnVuY3Rpb24gKHgsIHdpZHRoLCBvcmllbnRhdGlvbiwgY2xhc3NOYW1lKSB7XG4gICAgLy8gcmV1c2UgcmVkdW5kYW50IGxpbmVcbiAgICB2YXIgbGluZSA9IHRoaXMuZG9tLnJlZHVuZGFudC5saW5lcy5zaGlmdCgpO1xuICAgIGlmICghbGluZSkge1xuICAgICAgLy8gY3JlYXRlIHZlcnRpY2FsIGxpbmVcbiAgICAgIGxpbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMuZG9tLmJhY2tncm91bmQuYXBwZW5kQ2hpbGQobGluZSk7XG4gICAgfVxuICAgIHRoaXMuZG9tLmxpbmVzLnB1c2gobGluZSk7XG5cbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIGlmIChvcmllbnRhdGlvbiA9PSAndG9wJykge1xuICAgICAgbGluZS5zdHlsZS50b3AgPSBwcm9wcy5tYWpvckxhYmVsSGVpZ2h0ICsgJ3B4JztcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZS5zdHlsZS50b3AgPSB0aGlzLmJvZHkuZG9tUHJvcHMudG9wLmhlaWdodCArICdweCc7XG4gICAgfVxuICAgIGxpbmUuc3R5bGUuaGVpZ2h0ID0gcHJvcHMubWlub3JMaW5lSGVpZ2h0ICsgJ3B4JztcbiAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgbGluZS5zdHlsZS5sZWZ0ID0gXCJcIjtcbiAgICAgIGxpbmUuc3R5bGUucmlnaHQgPSB4IC0gcHJvcHMubWlub3JMaW5lV2lkdGggLyAyICsgJ3B4JztcbiAgICAgIGxpbmUuY2xhc3NOYW1lID0gJ3Zpcy1ncmlkIHZpcy12ZXJ0aWNhbC1ydGwgdmlzLW1pbm9yICcgKyBjbGFzc05hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmUuc3R5bGUubGVmdCA9IHggLSBwcm9wcy5taW5vckxpbmVXaWR0aCAvIDIgKyAncHgnO1xuICAgICAgbGluZS5jbGFzc05hbWUgPSAndmlzLWdyaWQgdmlzLXZlcnRpY2FsIHZpcy1taW5vciAnICsgY2xhc3NOYW1lO1xuICAgIH07XG4gICAgbGluZS5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcblxuICAgIHJldHVybiBsaW5lO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBNYWpvciBsaW5lIGZvciB0aGUgYXhpcyBhdCBwb3NpdGlvbiB4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZW50YXRpb24gICBcInRvcFwiIG9yIFwiYm90dG9tXCIgKGRlZmF1bHQpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWVcbiAgICogQHJldHVybiB7RWxlbWVudH0gUmV0dXJucyB0aGUgY3JlYXRlZCBsaW5lXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBUaW1lQXhpcy5wcm90b3R5cGUuX3JlcGFpbnRNYWpvckxpbmUgPSBmdW5jdGlvbiAoeCwgd2lkdGgsIG9yaWVudGF0aW9uLCBjbGFzc05hbWUpIHtcbiAgICAvLyByZXVzZSByZWR1bmRhbnQgbGluZVxuICAgIHZhciBsaW5lID0gdGhpcy5kb20ucmVkdW5kYW50LmxpbmVzLnNoaWZ0KCk7XG4gICAgaWYgKCFsaW5lKSB7XG4gICAgICAvLyBjcmVhdGUgdmVydGljYWwgbGluZVxuICAgICAgbGluZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5kb20uYmFja2dyb3VuZC5hcHBlbmRDaGlsZChsaW5lKTtcbiAgICB9XG4gICAgdGhpcy5kb20ubGluZXMucHVzaChsaW5lKTtcblxuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgaWYgKG9yaWVudGF0aW9uID09ICd0b3AnKSB7XG4gICAgICBsaW5lLnN0eWxlLnRvcCA9ICcwJztcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZS5zdHlsZS50b3AgPSB0aGlzLmJvZHkuZG9tUHJvcHMudG9wLmhlaWdodCArICdweCc7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgIGxpbmUuc3R5bGUubGVmdCA9IFwiXCI7XG4gICAgICBsaW5lLnN0eWxlLnJpZ2h0ID0geCAtIHByb3BzLm1ham9yTGluZVdpZHRoIC8gMiArICdweCc7XG4gICAgICBsaW5lLmNsYXNzTmFtZSA9ICd2aXMtZ3JpZCB2aXMtdmVydGljYWwtcnRsIHZpcy1tYWpvciAnICsgY2xhc3NOYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lLnN0eWxlLmxlZnQgPSB4IC0gcHJvcHMubWFqb3JMaW5lV2lkdGggLyAyICsgJ3B4JztcbiAgICAgIGxpbmUuY2xhc3NOYW1lID0gJ3Zpcy1ncmlkIHZpcy12ZXJ0aWNhbCB2aXMtbWFqb3IgJyArIGNsYXNzTmFtZTtcbiAgICB9XG5cbiAgICBsaW5lLnN0eWxlLmhlaWdodCA9IHByb3BzLm1ham9yTGluZUhlaWdodCArICdweCc7XG4gICAgbGluZS5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcblxuICAgIHJldHVybiBsaW5lO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgdGhlIHNpemUgb2YgdGV4dCBvbiB0aGUgYXhpcyAoYm90aCBtYWpvciBhbmQgbWlub3IgYXhpcykuXG4gICAqIFRoZSBzaXplIGlzIGNhbGN1bGF0ZWQgb25seSBvbmNlIGFuZCB0aGVuIGNhY2hlZCBpbiB0aGlzLnByb3BzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgVGltZUF4aXMucHJvdG90eXBlLl9jYWxjdWxhdGVDaGFyU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBOb3RlOiBXZSBjYWxjdWxhdGUgY2hhciBzaXplIHdpdGggZXZlcnkgcmVkcmF3LiBTaXplIG1heSBjaGFuZ2UsIGZvclxuICAgIC8vIGV4YW1wbGUgd2hlbiBhbnkgb2YgdGhlIHRpbWVsaW5lcyBwYXJlbnRzIGhhZCBkaXNwbGF5Om5vbmUgZm9yIGV4YW1wbGUuXG5cbiAgICAvLyBkZXRlcm1pbmUgdGhlIGNoYXIgd2lkdGggYW5kIGhlaWdodCBvbiB0aGUgbWlub3IgYXhpc1xuICAgIGlmICghdGhpcy5kb20ubWVhc3VyZUNoYXJNaW5vcikge1xuICAgICAgdGhpcy5kb20ubWVhc3VyZUNoYXJNaW5vciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICAgICAgdGhpcy5kb20ubWVhc3VyZUNoYXJNaW5vci5jbGFzc05hbWUgPSAndmlzLXRleHQgdmlzLW1pbm9yIHZpcy1tZWFzdXJlJztcbiAgICAgIHRoaXMuZG9tLm1lYXN1cmVDaGFyTWlub3Iuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuXG4gICAgICB0aGlzLmRvbS5tZWFzdXJlQ2hhck1pbm9yLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcwJykpO1xuICAgICAgdGhpcy5kb20uZm9yZWdyb3VuZC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5tZWFzdXJlQ2hhck1pbm9yKTtcbiAgICB9XG4gICAgdGhpcy5wcm9wcy5taW5vckNoYXJIZWlnaHQgPSB0aGlzLmRvbS5tZWFzdXJlQ2hhck1pbm9yLmNsaWVudEhlaWdodDtcbiAgICB0aGlzLnByb3BzLm1pbm9yQ2hhcldpZHRoID0gdGhpcy5kb20ubWVhc3VyZUNoYXJNaW5vci5jbGllbnRXaWR0aDtcblxuICAgIC8vIGRldGVybWluZSB0aGUgY2hhciB3aWR0aCBhbmQgaGVpZ2h0IG9uIHRoZSBtYWpvciBheGlzXG4gICAgaWYgKCF0aGlzLmRvbS5tZWFzdXJlQ2hhck1ham9yKSB7XG4gICAgICB0aGlzLmRvbS5tZWFzdXJlQ2hhck1ham9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XG4gICAgICB0aGlzLmRvbS5tZWFzdXJlQ2hhck1ham9yLmNsYXNzTmFtZSA9ICd2aXMtdGV4dCB2aXMtbWFqb3IgdmlzLW1lYXN1cmUnO1xuICAgICAgdGhpcy5kb20ubWVhc3VyZUNoYXJNYWpvci5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG5cbiAgICAgIHRoaXMuZG9tLm1lYXN1cmVDaGFyTWFqb3IuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJzAnKSk7XG4gICAgICB0aGlzLmRvbS5mb3JlZ3JvdW5kLmFwcGVuZENoaWxkKHRoaXMuZG9tLm1lYXN1cmVDaGFyTWFqb3IpO1xuICAgIH1cbiAgICB0aGlzLnByb3BzLm1ham9yQ2hhckhlaWdodCA9IHRoaXMuZG9tLm1lYXN1cmVDaGFyTWFqb3IuY2xpZW50SGVpZ2h0O1xuICAgIHRoaXMucHJvcHMubWFqb3JDaGFyV2lkdGggPSB0aGlzLmRvbS5tZWFzdXJlQ2hhck1ham9yLmNsaWVudFdpZHRoO1xuICB9O1xuXG4gIHZhciB3YXJuZWRGb3JPdmVyZmxvdyA9IGZhbHNlO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gVGltZUF4aXM7XG5cbi8qKiovIH0sXG4vKiA0NSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBrZXljaGFybSA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuICB2YXIgRW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuICB2YXIgSGFtbWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuICAvKipcbiAgICogVHVybiBhbiBlbGVtZW50IGludG8gYW4gY2xpY2tUb1VzZSBlbGVtZW50LlxuICAgKiBXaGVuIG5vdCBhY3RpdmUsIHRoZSBlbGVtZW50IGhhcyBhIHRyYW5zcGFyZW50IG92ZXJsYXkuIFdoZW4gdGhlIG92ZXJsYXkgaXNcbiAgICogY2xpY2tlZCwgdGhlIG1vZGUgaXMgY2hhbmdlZCB0byBhY3RpdmUuXG4gICAqIFdoZW4gYWN0aXZlLCB0aGUgZWxlbWVudCBpcyBkaXNwbGF5ZWQgd2l0aCBhIGJsdWUgYm9yZGVyIGFyb3VuZCBpdCwgYW5kXG4gICAqIHRoZSBpbnRlcmFjdGl2ZSBjb250ZW50cyBvZiB0aGUgZWxlbWVudCBjYW4gYmUgdXNlZC4gV2hlbiBjbGlja2VkIG91dHNpZGVcbiAgICogdGhlIGVsZW1lbnQsIHRoZSBlbGVtZW50cyBtb2RlIGlzIGNoYW5nZWQgdG8gaW5hY3RpdmUuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gY29udGFpbmVyXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gQWN0aXZhdG9yKGNvbnRhaW5lcikge1xuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG5cbiAgICB0aGlzLmRvbSA9IHtcbiAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyXG4gICAgfTtcblxuICAgIHRoaXMuZG9tLm92ZXJsYXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmRvbS5vdmVybGF5LmNsYXNzTmFtZSA9ICd2aXMtb3ZlcmxheSc7XG5cbiAgICB0aGlzLmRvbS5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb20ub3ZlcmxheSk7XG5cbiAgICB0aGlzLmhhbW1lciA9IEhhbW1lcih0aGlzLmRvbS5vdmVybGF5KTtcbiAgICB0aGlzLmhhbW1lci5vbigndGFwJywgdGhpcy5fb25UYXBPdmVybGF5LmJpbmQodGhpcykpO1xuXG4gICAgLy8gYmxvY2sgYWxsIHRvdWNoIGV2ZW50cyAoZXhjZXB0IHRhcClcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciBldmVudHMgPSBbJ3RhcCcsICdkb3VibGV0YXAnLCAncHJlc3MnLCAncGluY2gnLCAncGFuJywgJ3BhbnN0YXJ0JywgJ3Bhbm1vdmUnLCAncGFuZW5kJ107XG4gICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBtZS5oYW1tZXIub24oZXZlbnQsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gYXR0YWNoIGEgY2xpY2sgZXZlbnQgdG8gdGhlIHdpbmRvdywgaW4gb3JkZXIgdG8gZGVhY3RpdmF0ZSB3aGVuIGNsaWNraW5nIG91dHNpZGUgdGhlIHRpbWVsaW5lXG4gICAgaWYgKGRvY3VtZW50ICYmIGRvY3VtZW50LmJvZHkpIHtcbiAgICAgIHRoaXMub25DbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoIV9oYXNQYXJlbnQoZXZlbnQudGFyZ2V0LCBjb250YWluZXIpKSB7XG4gICAgICAgICAgbWUuZGVhY3RpdmF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25DbGljayk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMua2V5Y2hhcm0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5rZXljaGFybS5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMua2V5Y2hhcm0gPSBrZXljaGFybSgpO1xuXG4gICAgLy8ga2V5Y2hhcm0gbGlzdGVuZXIgb25seSBib3VuZGVkIHdoZW4gYWN0aXZlKVxuICAgIHRoaXMuZXNjTGlzdGVuZXIgPSB0aGlzLmRlYWN0aXZhdGUuYmluZCh0aGlzKTtcbiAgfVxuXG4gIC8vIHR1cm4gaW50byBhbiBldmVudCBlbWl0dGVyXG4gIEVtaXR0ZXIoQWN0aXZhdG9yLnByb3RvdHlwZSk7XG5cbiAgLy8gVGhlIGN1cnJlbnRseSBhY3RpdmUgYWN0aXZhdG9yXG4gIEFjdGl2YXRvci5jdXJyZW50ID0gbnVsbDtcblxuICAvKipcbiAgICogRGVzdHJveSB0aGUgYWN0aXZhdG9yLiBDbGVhbnMgdXAgYWxsIGNyZWF0ZWQgRE9NIGFuZCBldmVudCBsaXN0ZW5lcnNcbiAgICovXG4gIEFjdGl2YXRvci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRlYWN0aXZhdGUoKTtcblxuICAgIC8vIHJlbW92ZSBkb21cbiAgICB0aGlzLmRvbS5vdmVybGF5LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20ub3ZlcmxheSk7XG5cbiAgICAvLyByZW1vdmUgZ2xvYmFsIGV2ZW50IGxpc3RlbmVyXG4gICAgaWYgKHRoaXMub25DbGljaykge1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25DbGljayk7XG4gICAgfVxuXG4gICAgLy8gY2xlYW51cCBoYW1tZXIgaW5zdGFuY2VzXG4gICAgdGhpcy5oYW1tZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuaGFtbWVyID0gbnVsbDtcbiAgICAvLyBGSVhNRTogY2xlYW5pbmcgdXAgaGFtbWVyIGluc3RhbmNlcyBkb2Vzbid0IHdvcmsgKFRpbWVsaW5lIG5vdCByZW1vdmVkIGZyb20gbWVtb3J5KVxuICB9O1xuXG4gIC8qKlxuICAgKiBBY3RpdmF0ZSB0aGUgZWxlbWVudFxuICAgKiBPdmVybGF5IGlzIGhpZGRlbiwgZWxlbWVudCBpcyBkZWNvcmF0ZWQgd2l0aCBhIGJsdWUgc2hhZG93IGJvcmRlclxuICAgKi9cbiAgQWN0aXZhdG9yLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyB3ZSBhbGxvdyBvbmx5IG9uZSBhY3RpdmUgYWN0aXZhdG9yIGF0IGEgdGltZVxuICAgIGlmIChBY3RpdmF0b3IuY3VycmVudCkge1xuICAgICAgQWN0aXZhdG9yLmN1cnJlbnQuZGVhY3RpdmF0ZSgpO1xuICAgIH1cbiAgICBBY3RpdmF0b3IuY3VycmVudCA9IHRoaXM7XG5cbiAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5kb20ub3ZlcmxheS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIHV0aWwuYWRkQ2xhc3NOYW1lKHRoaXMuZG9tLmNvbnRhaW5lciwgJ3Zpcy1hY3RpdmUnKTtcblxuICAgIHRoaXMuZW1pdCgnY2hhbmdlJyk7XG4gICAgdGhpcy5lbWl0KCdhY3RpdmF0ZScpO1xuXG4gICAgLy8gdWdseSBoYWNrOiBiaW5kIEVTQyBhZnRlciBlbWl0dGluZyB0aGUgZXZlbnRzLCBhcyB0aGUgTmV0d29yayByZWJpbmRzIGFsbFxuICAgIC8vIGtleWJvYXJkIGV2ZW50cyBvbiBhICdjaGFuZ2UnIGV2ZW50XG4gICAgdGhpcy5rZXljaGFybS5iaW5kKCdlc2MnLCB0aGlzLmVzY0xpc3RlbmVyKTtcbiAgfTtcblxuICAvKipcbiAgICogRGVhY3RpdmF0ZSB0aGUgZWxlbWVudFxuICAgKiBPdmVybGF5IGlzIGRpc3BsYXllZCBvbiB0b3Agb2YgdGhlIGVsZW1lbnRcbiAgICovXG4gIEFjdGl2YXRvci5wcm90b3R5cGUuZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuZG9tLm92ZXJsYXkuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgIHV0aWwucmVtb3ZlQ2xhc3NOYW1lKHRoaXMuZG9tLmNvbnRhaW5lciwgJ3Zpcy1hY3RpdmUnKTtcbiAgICB0aGlzLmtleWNoYXJtLnVuYmluZCgnZXNjJywgdGhpcy5lc2NMaXN0ZW5lcik7XG5cbiAgICB0aGlzLmVtaXQoJ2NoYW5nZScpO1xuICAgIHRoaXMuZW1pdCgnZGVhY3RpdmF0ZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSB0YXAgZXZlbnQ6IGFjdGl2YXRlIHRoZSBjb250YWluZXJcbiAgICogQHBhcmFtIGV2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBBY3RpdmF0b3IucHJvdG90eXBlLl9vblRhcE92ZXJsYXkgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBhY3RpdmF0ZSB0aGUgY29udGFpbmVyXG4gICAgdGhpcy5hY3RpdmF0ZSgpO1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUZXN0IHdoZXRoZXIgdGhlIGVsZW1lbnQgaGFzIHRoZSByZXF1ZXN0ZWQgcGFyZW50IGVsZW1lbnQgc29tZXdoZXJlIGluXG4gICAqIGl0cyBjaGFpbiBvZiBwYXJlbnQgbm9kZXMuXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50XG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgd2hlbiB0aGUgcGFyZW50IGlzIGZvdW5kIHNvbWV3aGVyZSBpbiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgIGNoYWluIG9mIHBhcmVudCBub2Rlcy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9oYXNQYXJlbnQoZWxlbWVudCwgcGFyZW50KSB7XG4gICAgd2hpbGUgKGVsZW1lbnQpIHtcbiAgICAgIGlmIChlbGVtZW50ID09PSBwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBtb2R1bGUuZXhwb3J0cyA9IEFjdGl2YXRvcjtcblxuLyoqKi8gfSxcbi8qIDQ2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIEhhbW1lciA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4gIHZhciBDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKTtcbiAgdmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4gIHZhciBsb2NhbGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nyk7XG5cbiAgLyoqXG4gICAqIEEgY3VzdG9tIHRpbWUgYmFyXG4gICAqIEBwYXJhbSB7e3JhbmdlOiBSYW5nZSwgZG9tOiBPYmplY3R9fSBib2R5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgICAgIEF2YWlsYWJsZSBwYXJhbWV0ZXJzOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bnVtYmVyIHwgc3RyaW5nfSBpZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nfSBsb2NhbGVzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmd9IGxvY2FsZVxuICAgKiBAY29uc3RydWN0b3IgQ3VzdG9tVGltZVxuICAgKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAgICovXG5cbiAgZnVuY3Rpb24gQ3VzdG9tVGltZShib2R5LCBvcHRpb25zKSB7XG4gICAgdGhpcy5ib2R5ID0gYm9keTtcblxuICAgIC8vIGRlZmF1bHQgb3B0aW9uc1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBtb21lbnQ6IG1vbWVudCxcbiAgICAgIGxvY2FsZXM6IGxvY2FsZXMsXG4gICAgICBsb2NhbGU6ICdlbicsXG4gICAgICBpZDogdW5kZWZpbmVkLFxuICAgICAgdGl0bGU6IHVuZGVmaW5lZFxuICAgIH07XG4gICAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoe30sIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy50aW1lKSB7XG4gICAgICB0aGlzLmN1c3RvbVRpbWUgPSBvcHRpb25zLnRpbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3VzdG9tVGltZSA9IG5ldyBEYXRlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5ldmVudFBhcmFtcyA9IHt9OyAvLyBzdG9yZXMgc3RhdGUgcGFyYW1ldGVycyB3aGlsZSBkcmFnZ2luZyB0aGUgYmFyXG5cbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICAvLyBjcmVhdGUgdGhlIERPTVxuICAgIHRoaXMuX2NyZWF0ZSgpO1xuICB9XG5cbiAgQ3VzdG9tVGltZS5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50KCk7XG5cbiAgLyoqXG4gICAqIFNldCBvcHRpb25zIGZvciB0aGUgY29tcG9uZW50LiBPcHRpb25zIHdpbGwgYmUgbWVyZ2VkIGluIGN1cnJlbnQgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgIEF2YWlsYWJsZSBwYXJhbWV0ZXJzOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bnVtYmVyIHwgc3RyaW5nfSBpZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nfSBsb2NhbGVzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmd9IGxvY2FsZVxuICAgKi9cbiAgQ3VzdG9tVGltZS5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIC8vIGNvcHkgYWxsIG9wdGlvbnMgdGhhdCB3ZSBrbm93XG4gICAgICB1dGlsLnNlbGVjdGl2ZUV4dGVuZChbJ21vbWVudCcsICdsb2NhbGUnLCAnbG9jYWxlcycsICdpZCddLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBET00gZm9yIHRoZSBjdXN0b20gdGltZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQ3VzdG9tVGltZS5wcm90b3R5cGUuX2NyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgYmFyWydjdXN0b20tdGltZSddID0gdGhpcztcbiAgICBiYXIuY2xhc3NOYW1lID0gJ3Zpcy1jdXN0b20tdGltZSAnICsgKHRoaXMub3B0aW9ucy5pZCB8fCAnJyk7XG4gICAgYmFyLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBiYXIuc3R5bGUudG9wID0gJzBweCc7XG4gICAgYmFyLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICB0aGlzLmJhciA9IGJhcjtcblxuICAgIHZhciBkcmFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZHJhZy5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgZHJhZy5zdHlsZS50b3AgPSAnMHB4JztcbiAgICBkcmFnLnN0eWxlLmxlZnQgPSAnLTEwcHgnO1xuICAgIGRyYWcuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgIGRyYWcuc3R5bGUud2lkdGggPSAnMjBweCc7XG4gICAgYmFyLmFwcGVuZENoaWxkKGRyYWcpO1xuXG4gICAgLy8gYXR0YWNoIGV2ZW50IGxpc3RlbmVyc1xuICAgIHRoaXMuaGFtbWVyID0gbmV3IEhhbW1lcihkcmFnKTtcbiAgICB0aGlzLmhhbW1lci5vbigncGFuc3RhcnQnLCB0aGlzLl9vbkRyYWdTdGFydC5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmhhbW1lci5vbigncGFubW92ZScsIHRoaXMuX29uRHJhZy5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmhhbW1lci5vbigncGFuZW5kJywgdGhpcy5fb25EcmFnRW5kLmJpbmQodGhpcykpO1xuICAgIHRoaXMuaGFtbWVyLmdldCgncGFuJykuc2V0KHsgdGhyZXNob2xkOiA1LCBkaXJlY3Rpb246IEhhbW1lci5ESVJFQ1RJT05fSE9SSVpPTlRBTCB9KTtcbiAgfTtcblxuICAvKipcbiAgICogRGVzdHJveSB0aGUgQ3VzdG9tVGltZSBiYXJcbiAgICovXG4gIEN1c3RvbVRpbWUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5oaWRlKCk7XG5cbiAgICB0aGlzLmhhbW1lci5kZXN0cm95KCk7XG4gICAgdGhpcy5oYW1tZXIgPSBudWxsO1xuXG4gICAgdGhpcy5ib2R5ID0gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogUmVwYWludCB0aGUgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgY29tcG9uZW50IGlzIHJlc2l6ZWRcbiAgICovXG4gIEN1c3RvbVRpbWUucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5ib2R5LmRvbS5iYWNrZ3JvdW5kVmVydGljYWw7XG4gICAgaWYgKHRoaXMuYmFyLnBhcmVudE5vZGUgIT0gcGFyZW50KSB7XG4gICAgICAvLyBhdHRhY2ggdG8gdGhlIGRvbVxuICAgICAgaWYgKHRoaXMuYmFyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgdGhpcy5iYXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmJhcik7XG4gICAgICB9XG4gICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5iYXIpO1xuICAgIH1cblxuICAgIHZhciB4ID0gdGhpcy5ib2R5LnV0aWwudG9TY3JlZW4odGhpcy5jdXN0b21UaW1lKTtcblxuICAgIHZhciBsb2NhbGUgPSB0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXTtcbiAgICBpZiAoIWxvY2FsZSkge1xuICAgICAgaWYgKCF0aGlzLndhcm5lZCkge1xuICAgICAgICBjb25zb2xlLmxvZygnV0FSTklORzogb3B0aW9ucy5sb2NhbGVzW1xcJycgKyB0aGlzLm9wdGlvbnMubG9jYWxlICsgJ1xcJ10gbm90IGZvdW5kLiBTZWUgaHR0cDovL3Zpc2pzLm9yZy9kb2NzL3RpbWVsaW5lLmh0bWwjTG9jYWxpemF0aW9uJyk7XG4gICAgICAgIHRoaXMud2FybmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGxvY2FsZSA9IHRoaXMub3B0aW9ucy5sb2NhbGVzWydlbiddOyAvLyBmYWxsIGJhY2sgb24gZW5nbGlzaCB3aGVuIG5vdCBhdmFpbGFibGVcbiAgICB9XG5cbiAgICB2YXIgdGl0bGUgPSB0aGlzLm9wdGlvbnMudGl0bGU7XG4gICAgLy8gVG8gaGlkZSB0aGUgdGl0bGUgY29tcGxldGVseSB1c2UgZW1wdHkgc3RyaW5nICcnLlxuICAgIGlmICh0aXRsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aXRsZSA9IGxvY2FsZS50aW1lICsgJzogJyArIHRoaXMub3B0aW9ucy5tb21lbnQodGhpcy5jdXN0b21UaW1lKS5mb3JtYXQoJ2RkZGQsIE1NTU0gRG8gWVlZWSwgSDptbTpzcycpO1xuICAgICAgdGl0bGUgPSB0aXRsZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRpdGxlLnN1YnN0cmluZygxKTtcbiAgICB9XG5cbiAgICB0aGlzLmJhci5zdHlsZS5sZWZ0ID0geCArICdweCc7XG4gICAgdGhpcy5iYXIudGl0bGUgPSB0aXRsZTtcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBDdXN0b21UaW1lIGZyb20gdGhlIERPTVxuICAgKi9cbiAgQ3VzdG9tVGltZS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyByZW1vdmUgdGhlIGxpbmUgZnJvbSB0aGUgRE9NXG4gICAgaWYgKHRoaXMuYmFyLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuYmFyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5iYXIpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0IGN1c3RvbSB0aW1lLlxuICAgKiBAcGFyYW0ge0RhdGUgfCBudW1iZXIgfCBzdHJpbmd9IHRpbWVcbiAgICovXG4gIEN1c3RvbVRpbWUucHJvdG90eXBlLnNldEN1c3RvbVRpbWUgPSBmdW5jdGlvbiAodGltZSkge1xuICAgIHRoaXMuY3VzdG9tVGltZSA9IHV0aWwuY29udmVydCh0aW1lLCAnRGF0ZScpO1xuICAgIHRoaXMucmVkcmF3KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSBjdXJyZW50IGN1c3RvbSB0aW1lLlxuICAgKiBAcmV0dXJuIHtEYXRlfSBjdXN0b21UaW1lXG4gICAqL1xuICBDdXN0b21UaW1lLnByb3RvdHlwZS5nZXRDdXN0b21UaW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLmN1c3RvbVRpbWUudmFsdWVPZigpKTtcbiAgfTtcblxuICAvKipcbiAgICAqIFNldCBjdXN0b20gdGl0bGUuXG4gICAgKiBAcGFyYW0ge0RhdGUgfCBudW1iZXIgfCBzdHJpbmd9IHRpdGxlXG4gICAgKi9cbiAgQ3VzdG9tVGltZS5wcm90b3R5cGUuc2V0Q3VzdG9tVGl0bGUgPSBmdW5jdGlvbiAodGl0bGUpIHtcbiAgICB0aGlzLm9wdGlvbnMudGl0bGUgPSB0aXRsZTtcbiAgfTtcblxuICAvKipcbiAgICogU3RhcnQgbW92aW5nIGhvcml6b250YWxseVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQ3VzdG9tVGltZS5wcm90b3R5cGUuX29uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdGhpcy5ldmVudFBhcmFtcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgdGhpcy5ldmVudFBhcmFtcy5jdXN0b21UaW1lID0gdGhpcy5jdXN0b21UaW1lO1xuXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gbW92aW5nIG9wZXJhdGluZy5cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEN1c3RvbVRpbWUucHJvdG90eXBlLl9vbkRyYWcgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZXZlbnRQYXJhbXMuZHJhZ2dpbmcpIHJldHVybjtcblxuICAgIHZhciB4ID0gdGhpcy5ib2R5LnV0aWwudG9TY3JlZW4odGhpcy5ldmVudFBhcmFtcy5jdXN0b21UaW1lKSArIGV2ZW50LmRlbHRhWDtcbiAgICB2YXIgdGltZSA9IHRoaXMuYm9keS51dGlsLnRvVGltZSh4KTtcblxuICAgIHRoaXMuc2V0Q3VzdG9tVGltZSh0aW1lKTtcblxuICAgIC8vIGZpcmUgYSB0aW1lY2hhbmdlIGV2ZW50XG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgndGltZWNoYW5nZScsIHtcbiAgICAgIGlkOiB0aGlzLm9wdGlvbnMuaWQsXG4gICAgICB0aW1lOiBuZXcgRGF0ZSh0aGlzLmN1c3RvbVRpbWUudmFsdWVPZigpKVxuICAgIH0pO1xuXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0b3AgbW92aW5nIG9wZXJhdGluZy5cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEN1c3RvbVRpbWUucHJvdG90eXBlLl9vbkRyYWdFbmQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZXZlbnRQYXJhbXMuZHJhZ2dpbmcpIHJldHVybjtcblxuICAgIC8vIGZpcmUgYSB0aW1lY2hhbmdlZCBldmVudFxuICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3RpbWVjaGFuZ2VkJywge1xuICAgICAgaWQ6IHRoaXMub3B0aW9ucy5pZCxcbiAgICAgIHRpbWU6IG5ldyBEYXRlKHRoaXMuY3VzdG9tVGltZS52YWx1ZU9mKCkpXG4gICAgfSk7XG5cbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfTtcblxuICAvKipcbiAgICogRmluZCBhIGN1c3RvbSB0aW1lIGZyb20gYW4gZXZlbnQgdGFyZ2V0OlxuICAgKiBzZWFyY2hlcyBmb3IgdGhlIGF0dHJpYnV0ZSAnY3VzdG9tLXRpbWUnIGluIHRoZSBldmVudCB0YXJnZXQncyBlbGVtZW50IHRyZWVcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHJldHVybiB7Q3VzdG9tVGltZSB8IG51bGx9IGN1c3RvbVRpbWVcbiAgICovXG4gIEN1c3RvbVRpbWUuY3VzdG9tVGltZUZyb21UYXJnZXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgIHdoaWxlICh0YXJnZXQpIHtcbiAgICAgIGlmICh0YXJnZXQuaGFzT3duUHJvcGVydHkoJ2N1c3RvbS10aW1lJykpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldFsnY3VzdG9tLXRpbWUnXTtcbiAgICAgIH1cbiAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gQ3VzdG9tVGltZTtcblxuLyoqKi8gfSxcbi8qIDQ3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gRW5nbGlzaFxuICBleHBvcnRzWydlbiddID0ge1xuICAgIGN1cnJlbnQ6ICdjdXJyZW50JyxcbiAgICB0aW1lOiAndGltZSdcbiAgfTtcbiAgZXhwb3J0c1snZW5fRU4nXSA9IGV4cG9ydHNbJ2VuJ107XG4gIGV4cG9ydHNbJ2VuX1VTJ10gPSBleHBvcnRzWydlbiddO1xuXG4gIC8vIER1dGNoXG4gIGV4cG9ydHNbJ25sJ10gPSB7XG4gICAgY3VycmVudDogJ2h1aWRpZ2UnLFxuICAgIHRpbWU6ICd0aWpkJ1xuICB9O1xuICBleHBvcnRzWydubF9OTCddID0gZXhwb3J0c1snbmwnXTtcbiAgZXhwb3J0c1snbmxfQkUnXSA9IGV4cG9ydHNbJ25sJ107XG5cbi8qKiovIH0sXG4vKiA0OCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbiAgdmFyIENvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xuICB2YXIgbW9tZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbiAgdmFyIGxvY2FsZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KTtcblxuICAvKipcbiAgICogQSBjdXJyZW50IHRpbWUgYmFyXG4gICAqIEBwYXJhbSB7e3JhbmdlOiBSYW5nZSwgZG9tOiBPYmplY3QsIGRvbVByb3BzOiBPYmplY3R9fSBib2R5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgICAgIEF2YWlsYWJsZSBwYXJhbWV0ZXJzOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Qm9vbGVhbn0gW3Nob3dDdXJyZW50VGltZV1cbiAgICogQGNvbnN0cnVjdG9yIEN1cnJlbnRUaW1lXG4gICAqIEBleHRlbmRzIENvbXBvbmVudFxuICAgKi9cbiAgZnVuY3Rpb24gQ3VycmVudFRpbWUoYm9keSwgb3B0aW9ucykge1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG5cbiAgICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgcnRsOiBmYWxzZSxcbiAgICAgIHNob3dDdXJyZW50VGltZTogdHJ1ZSxcblxuICAgICAgbW9tZW50OiBtb21lbnQsXG4gICAgICBsb2NhbGVzOiBsb2NhbGVzLFxuICAgICAgbG9jYWxlOiAnZW4nXG4gICAgfTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG4gICAgdGhpcy5vZmZzZXQgPSAwO1xuXG4gICAgdGhpcy5fY3JlYXRlKCk7XG5cbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIH1cblxuICBDdXJyZW50VGltZS5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50KCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgSFRNTCBET00gZm9yIHRoZSBjdXJyZW50IHRpbWUgYmFyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBDdXJyZW50VGltZS5wcm90b3R5cGUuX2NyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgYmFyLmNsYXNzTmFtZSA9ICd2aXMtY3VycmVudC10aW1lJztcbiAgICBiYXIuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGJhci5zdHlsZS50b3AgPSAnMHB4JztcbiAgICBiYXIuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuXG4gICAgdGhpcy5iYXIgPSBiYXI7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlc3Ryb3kgdGhlIEN1cnJlbnRUaW1lIGJhclxuICAgKi9cbiAgQ3VycmVudFRpbWUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5vcHRpb25zLnNob3dDdXJyZW50VGltZSA9IGZhbHNlO1xuICAgIHRoaXMucmVkcmF3KCk7IC8vIHdpbGwgcmVtb3ZlIHRoZSBiYXIgZnJvbSB0aGUgRE9NIGFuZCBzdG9wIHJlZnJlc2hpbmdcblxuICAgIHRoaXMuYm9keSA9IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBvcHRpb25zIGZvciB0aGUgY29tcG9uZW50LiBPcHRpb25zIHdpbGwgYmUgbWVyZ2VkIGluIGN1cnJlbnQgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgIEF2YWlsYWJsZSBwYXJhbWV0ZXJzOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAge2Jvb2xlYW59IFtzaG93Q3VycmVudFRpbWVdXG4gICAqL1xuICBDdXJyZW50VGltZS5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIC8vIGNvcHkgYWxsIG9wdGlvbnMgdGhhdCB3ZSBrbm93XG4gICAgICB1dGlsLnNlbGVjdGl2ZUV4dGVuZChbJ3J0bCcsICdzaG93Q3VycmVudFRpbWUnLCAnbW9tZW50JywgJ2xvY2FsZScsICdsb2NhbGVzJ10sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXBhaW50IHRoZSBjb21wb25lbnRcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBjb21wb25lbnQgaXMgcmVzaXplZFxuICAgKi9cbiAgQ3VycmVudFRpbWUucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnNob3dDdXJyZW50VGltZSkge1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXMuYm9keS5kb20uYmFja2dyb3VuZFZlcnRpY2FsO1xuICAgICAgaWYgKHRoaXMuYmFyLnBhcmVudE5vZGUgIT0gcGFyZW50KSB7XG4gICAgICAgIC8vIGF0dGFjaCB0byB0aGUgZG9tXG4gICAgICAgIGlmICh0aGlzLmJhci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgdGhpcy5iYXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmJhcik7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHRoaXMuYmFyKTtcblxuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBub3cgPSB0aGlzLm9wdGlvbnMubW9tZW50KG5ldyBEYXRlKCkudmFsdWVPZigpICsgdGhpcy5vZmZzZXQpO1xuICAgICAgdmFyIHggPSB0aGlzLmJvZHkudXRpbC50b1NjcmVlbihub3cpO1xuXG4gICAgICB2YXIgbG9jYWxlID0gdGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV07XG4gICAgICBpZiAoIWxvY2FsZSkge1xuICAgICAgICBpZiAoIXRoaXMud2FybmVkKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1dBUk5JTkc6IG9wdGlvbnMubG9jYWxlc1tcXCcnICsgdGhpcy5vcHRpb25zLmxvY2FsZSArICdcXCddIG5vdCBmb3VuZC4gU2VlIGh0dHA6Ly92aXNqcy5vcmcvZG9jcy90aW1lbGluZS8jTG9jYWxpemF0aW9uJyk7XG4gICAgICAgICAgdGhpcy53YXJuZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxvY2FsZSA9IHRoaXMub3B0aW9ucy5sb2NhbGVzWydlbiddOyAvLyBmYWxsIGJhY2sgb24gZW5nbGlzaCB3aGVuIG5vdCBhdmFpbGFibGVcbiAgICAgIH1cbiAgICAgIHZhciB0aXRsZSA9IGxvY2FsZS5jdXJyZW50ICsgJyAnICsgbG9jYWxlLnRpbWUgKyAnOiAnICsgbm93LmZvcm1hdCgnZGRkZCwgTU1NTSBEbyBZWVlZLCBIOm1tOnNzJyk7XG4gICAgICB0aXRsZSA9IHRpdGxlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGl0bGUuc3Vic3RyaW5nKDEpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgICB0aGlzLmJhci5zdHlsZS5yaWdodCA9IHggKyAncHgnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5iYXIuc3R5bGUubGVmdCA9IHggKyAncHgnO1xuICAgICAgfVxuICAgICAgdGhpcy5iYXIudGl0bGUgPSB0aXRsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVtb3ZlIHRoZSBsaW5lIGZyb20gdGhlIERPTVxuICAgICAgaWYgKHRoaXMuYmFyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgdGhpcy5iYXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmJhcik7XG4gICAgICB9XG4gICAgICB0aGlzLnN0b3AoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGF1dG8gcmVmcmVzaGluZyB0aGUgY3VycmVudCB0aW1lIGJhclxuICAgKi9cbiAgQ3VycmVudFRpbWUucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtZSA9IHRoaXM7XG5cbiAgICBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICBtZS5zdG9wKCk7XG5cbiAgICAgIC8vIGRldGVybWluZSBpbnRlcnZhbCB0byByZWZyZXNoXG4gICAgICB2YXIgc2NhbGUgPSBtZS5ib2R5LnJhbmdlLmNvbnZlcnNpb24obWUuYm9keS5kb21Qcm9wcy5jZW50ZXIud2lkdGgpLnNjYWxlO1xuICAgICAgdmFyIGludGVydmFsID0gMSAvIHNjYWxlIC8gMTA7XG4gICAgICBpZiAoaW50ZXJ2YWwgPCAzMCkgaW50ZXJ2YWwgPSAzMDtcbiAgICAgIGlmIChpbnRlcnZhbCA+IDEwMDApIGludGVydmFsID0gMTAwMDtcblxuICAgICAgbWUucmVkcmF3KCk7XG4gICAgICBtZS5ib2R5LmVtaXR0ZXIuZW1pdCgnY3VycmVudFRpbWVUaWNrJyk7XG5cbiAgICAgIC8vIHN0YXJ0IGEgcmVuZGVyVGltZXIgdG8gYWRqdXN0IGZvciB0aGUgbmV3IHRpbWVcbiAgICAgIG1lLmN1cnJlbnRUaW1lVGltZXIgPSBzZXRUaW1lb3V0KHVwZGF0ZSwgaW50ZXJ2YWwpO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdG9wIGF1dG8gcmVmcmVzaGluZyB0aGUgY3VycmVudCB0aW1lIGJhclxuICAgKi9cbiAgQ3VycmVudFRpbWUucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudFRpbWVUaW1lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5jdXJyZW50VGltZVRpbWVyKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmN1cnJlbnRUaW1lVGltZXI7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgYSBjdXJyZW50IHRpbWUuIFRoaXMgY2FuIGJlIHVzZWQgZm9yIGV4YW1wbGUgdG8gZW5zdXJlIHRoYXQgYSBjbGllbnQnc1xuICAgKiB0aW1lIGlzIHN5bmNocm9uaXplZCB3aXRoIGEgc2hhcmVkIHNlcnZlciB0aW1lLlxuICAgKiBAcGFyYW0ge0RhdGUgfCBTdHJpbmcgfCBOdW1iZXJ9IHRpbWUgICAgIEEgRGF0ZSwgdW5peCB0aW1lc3RhbXAsIG9yXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSVNPIGRhdGUgc3RyaW5nLlxuICAgKi9cbiAgQ3VycmVudFRpbWUucHJvdG90eXBlLnNldEN1cnJlbnRUaW1lID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICB2YXIgdCA9IHV0aWwuY29udmVydCh0aW1lLCAnRGF0ZScpLnZhbHVlT2YoKTtcbiAgICB2YXIgbm93ID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG4gICAgdGhpcy5vZmZzZXQgPSB0IC0gbm93O1xuICAgIHRoaXMucmVkcmF3KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCB0aW1lLlxuICAgKiBAcmV0dXJuIHtEYXRlfSBSZXR1cm5zIHRoZSBjdXJyZW50IHRpbWUuXG4gICAqL1xuICBDdXJyZW50VGltZS5wcm90b3R5cGUuZ2V0Q3VycmVudFRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKG5ldyBEYXRlKCkudmFsdWVPZigpICsgdGhpcy5vZmZzZXQpO1xuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gQ3VycmVudFRpbWU7XG5cbi8qKiovIH0sXG4vKiA0OSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuICAvKipcbiAgICogVGhpcyBvYmplY3QgY29udGFpbnMgYWxsIHBvc3NpYmxlIG9wdGlvbnMuIEl0IHdpbGwgY2hlY2sgaWYgdGhlIHR5cGVzIGFyZSBjb3JyZWN0LCBpZiByZXF1aXJlZCBpZiB0aGUgb3B0aW9uIGlzIG9uZVxuICAgKiBvZiB0aGUgYWxsb3dlZCB2YWx1ZXMuXG4gICAqXG4gICAqIF9fYW55X18gbWVhbnMgdGhhdCB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgZG9lcyBub3QgbWF0dGVyLlxuICAgKiBfX3R5cGVfXyBpcyBhIHJlcXVpcmVkIGZpZWxkIGZvciBhbGwgb2JqZWN0cyBhbmQgY29udGFpbnMgdGhlIGFsbG93ZWQgdHlwZXMgb2YgYWxsIG9iamVjdHNcbiAgICovXG4gIHZhciBzdHJpbmcgPSAnc3RyaW5nJztcbiAgdmFyIGJvb2xlYW4gPSAnYm9vbGVhbic7XG4gIHZhciBudW1iZXIgPSAnbnVtYmVyJztcbiAgdmFyIGFycmF5ID0gJ2FycmF5JztcbiAgdmFyIGRhdGUgPSAnZGF0ZSc7XG4gIHZhciBvYmplY3QgPSAnb2JqZWN0JzsgLy8gc2hvdWxkIG9ubHkgYmUgaW4gYSBfX3R5cGVfXyBwcm9wZXJ0eVxuICB2YXIgZG9tID0gJ2RvbSc7XG4gIHZhciBtb21lbnQgPSAnbW9tZW50JztcbiAgdmFyIGFueSA9ICdhbnknO1xuXG4gIHZhciBhbGxPcHRpb25zID0ge1xuICAgIGNvbmZpZ3VyZToge1xuICAgICAgZW5hYmxlZDogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICBmaWx0ZXI6IHsgYm9vbGVhbjogYm9vbGVhbiwgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgICAgY29udGFpbmVyOiB7IGRvbTogZG9tIH0sXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgYm9vbGVhbjogYm9vbGVhbiwgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9XG4gICAgfSxcblxuICAgIC8vZ2xvYmFscyA6XG4gICAgYWxpZ246IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICBydGw6IHsgYm9vbGVhbjogYm9vbGVhbiwgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgYXV0b1Jlc2l6ZTogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgdGhyb3R0bGVSZWRyYXc6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICBjbGlja1RvVXNlOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICBkYXRhQXR0cmlidXRlczogeyBzdHJpbmc6IHN0cmluZywgYXJyYXk6IGFycmF5IH0sXG4gICAgZWRpdGFibGU6IHtcbiAgICAgIGFkZDogeyBib29sZWFuOiBib29sZWFuLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgIHJlbW92ZTogeyBib29sZWFuOiBib29sZWFuLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgIHVwZGF0ZUdyb3VwOiB7IGJvb2xlYW46IGJvb2xlYW4sICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgdXBkYXRlVGltZTogeyBib29sZWFuOiBib29sZWFuLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgIF9fdHlwZV9fOiB7IGJvb2xlYW46IGJvb2xlYW4sIG9iamVjdDogb2JqZWN0IH1cbiAgICB9LFxuICAgIGVuZDogeyBudW1iZXI6IG51bWJlciwgZGF0ZTogZGF0ZSwgc3RyaW5nOiBzdHJpbmcsIG1vbWVudDogbW9tZW50IH0sXG4gICAgZm9ybWF0OiB7XG4gICAgICBtaW5vckxhYmVsczoge1xuICAgICAgICBtaWxsaXNlY29uZDogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICAgIHNlY29uZDogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICAgIG1pbnV0ZTogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICAgIGhvdXI6IHsgc3RyaW5nOiBzdHJpbmcsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgICB3ZWVrZGF5OiB7IHN0cmluZzogc3RyaW5nLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgICAgZGF5OiB7IHN0cmluZzogc3RyaW5nLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgICAgbW9udGg6IHsgc3RyaW5nOiBzdHJpbmcsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgICB5ZWFyOiB7IHN0cmluZzogc3RyaW5nLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICAgICAgfSxcbiAgICAgIG1ham9yTGFiZWxzOiB7XG4gICAgICAgIG1pbGxpc2Vjb25kOiB7IHN0cmluZzogc3RyaW5nLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgICAgc2Vjb25kOiB7IHN0cmluZzogc3RyaW5nLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgICAgbWludXRlOiB7IHN0cmluZzogc3RyaW5nLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgICAgaG91cjogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICAgIHdlZWtkYXk6IHsgc3RyaW5nOiBzdHJpbmcsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgICBkYXk6IHsgc3RyaW5nOiBzdHJpbmcsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgICBtb250aDogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICAgIHllYXI6IHsgc3RyaW5nOiBzdHJpbmcsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gICAgICB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICAgIH0sXG4gICAgbW9tZW50OiB7ICdmdW5jdGlvbic6ICdmdW5jdGlvbicgfSxcbiAgICBncm91cE9yZGVyOiB7IHN0cmluZzogc3RyaW5nLCAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH0sXG4gICAgZ3JvdXBFZGl0YWJsZToge1xuICAgICAgYWRkOiB7IGJvb2xlYW46IGJvb2xlYW4sICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgcmVtb3ZlOiB7IGJvb2xlYW46IGJvb2xlYW4sICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgb3JkZXI6IHsgYm9vbGVhbjogYm9vbGVhbiwgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICBfX3R5cGVfXzogeyBib29sZWFuOiBib29sZWFuLCBvYmplY3Q6IG9iamVjdCB9XG4gICAgfSxcbiAgICBncm91cE9yZGVyU3dhcDogeyAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH0sXG4gICAgaGVpZ2h0OiB7IHN0cmluZzogc3RyaW5nLCBudW1iZXI6IG51bWJlciB9LFxuICAgIGhpZGRlbkRhdGVzOiB7XG4gICAgICBzdGFydDogeyBkYXRlOiBkYXRlLCBudW1iZXI6IG51bWJlciwgc3RyaW5nOiBzdHJpbmcsIG1vbWVudDogbW9tZW50IH0sXG4gICAgICBlbmQ6IHsgZGF0ZTogZGF0ZSwgbnVtYmVyOiBudW1iZXIsIHN0cmluZzogc3RyaW5nLCBtb21lbnQ6IG1vbWVudCB9LFxuICAgICAgcmVwZWF0OiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgYXJyYXk6IGFycmF5IH1cbiAgICB9LFxuICAgIGl0ZW1zQWx3YXlzRHJhZ2dhYmxlOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICBsb2NhbGU6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICBsb2NhbGVzOiB7XG4gICAgICBfX2FueV9fOiB7IGFueTogYW55IH0sXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gICAgfSxcbiAgICBtYXJnaW46IHtcbiAgICAgIGF4aXM6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIGl0ZW06IHtcbiAgICAgICAgaG9yaXpvbnRhbDogeyBudW1iZXI6IG51bWJlciwgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICAgIHZlcnRpY2FsOiB7IG51bWJlcjogbnVtYmVyLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIG51bWJlcjogbnVtYmVyIH1cbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgbnVtYmVyOiBudW1iZXIgfVxuICAgIH0sXG4gICAgbWF4OiB7IGRhdGU6IGRhdGUsIG51bWJlcjogbnVtYmVyLCBzdHJpbmc6IHN0cmluZywgbW9tZW50OiBtb21lbnQgfSxcbiAgICBtYXhIZWlnaHQ6IHsgbnVtYmVyOiBudW1iZXIsIHN0cmluZzogc3RyaW5nIH0sXG4gICAgbWF4TWlub3JDaGFyczogeyBudW1iZXI6IG51bWJlciB9LFxuICAgIG1pbjogeyBkYXRlOiBkYXRlLCBudW1iZXI6IG51bWJlciwgc3RyaW5nOiBzdHJpbmcsIG1vbWVudDogbW9tZW50IH0sXG4gICAgbWluSGVpZ2h0OiB7IG51bWJlcjogbnVtYmVyLCBzdHJpbmc6IHN0cmluZyB9LFxuICAgIG1vdmVhYmxlOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICBtdWx0aXNlbGVjdDogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgbXVsdGlzZWxlY3RQZXJHcm91cDogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgb25BZGQ6IHsgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgIG9uVXBkYXRlOiB7ICdmdW5jdGlvbic6ICdmdW5jdGlvbicgfSxcbiAgICBvbk1vdmU6IHsgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgIG9uTW92aW5nOiB7ICdmdW5jdGlvbic6ICdmdW5jdGlvbicgfSxcbiAgICBvblJlbW92ZTogeyAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH0sXG4gICAgb25BZGRHcm91cDogeyAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH0sXG4gICAgb25Nb3ZlR3JvdXA6IHsgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgIG9uUmVtb3ZlR3JvdXA6IHsgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgIG9yZGVyOiB7ICdmdW5jdGlvbic6ICdmdW5jdGlvbicgfSxcbiAgICBvcmllbnRhdGlvbjoge1xuICAgICAgYXhpczogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICBpdGVtOiB7IHN0cmluZzogc3RyaW5nLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgIF9fdHlwZV9fOiB7IHN0cmluZzogc3RyaW5nLCBvYmplY3Q6IG9iamVjdCB9XG4gICAgfSxcbiAgICBzZWxlY3RhYmxlOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICBzaG93Q3VycmVudFRpbWU6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgIHNob3dNYWpvckxhYmVsczogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgc2hvd01pbm9yTGFiZWxzOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICBzdGFjazogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgc25hcDogeyAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nLCAnbnVsbCc6ICdudWxsJyB9LFxuICAgIHN0YXJ0OiB7IGRhdGU6IGRhdGUsIG51bWJlcjogbnVtYmVyLCBzdHJpbmc6IHN0cmluZywgbW9tZW50OiBtb21lbnQgfSxcbiAgICB0ZW1wbGF0ZTogeyAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH0sXG4gICAgZ3JvdXBUZW1wbGF0ZTogeyAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH0sXG4gICAgdGltZUF4aXM6IHtcbiAgICAgIHNjYWxlOiB7IHN0cmluZzogc3RyaW5nLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgIHN0ZXA6IHsgbnVtYmVyOiBudW1iZXIsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICAgIH0sXG4gICAgdHlwZTogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgIHdpZHRoOiB7IHN0cmluZzogc3RyaW5nLCBudW1iZXI6IG51bWJlciB9LFxuICAgIHpvb21hYmxlOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICB6b29tS2V5OiB7IHN0cmluZzogWydjdHJsS2V5JywgJ2FsdEtleScsICdtZXRhS2V5JywgJyddIH0sXG4gICAgem9vbU1heDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgIHpvb21NaW46IHsgbnVtYmVyOiBudW1iZXIgfSxcblxuICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0IH1cbiAgfTtcblxuICB2YXIgY29uZmlndXJlT3B0aW9ucyA9IHtcbiAgICBnbG9iYWw6IHtcbiAgICAgIGFsaWduOiBbJ2NlbnRlcicsICdsZWZ0JywgJ3JpZ2h0J10sXG4gICAgICBkaXJlY3Rpb246IGZhbHNlLFxuICAgICAgYXV0b1Jlc2l6ZTogdHJ1ZSxcbiAgICAgIHRocm90dGxlUmVkcmF3OiBbMTAsIDAsIDEwMDAsIDEwXSxcbiAgICAgIGNsaWNrVG9Vc2U6IGZhbHNlLFxuICAgICAgLy8gZGF0YUF0dHJpYnV0ZXM6IFsnYWxsJ10sIC8vIEZJWE1FOiBjYW4gYmUgJ2FsbCcgb3Igc3RyaW5nW11cbiAgICAgIGVkaXRhYmxlOiB7XG4gICAgICAgIGFkZDogZmFsc2UsXG4gICAgICAgIHJlbW92ZTogZmFsc2UsXG4gICAgICAgIHVwZGF0ZUdyb3VwOiBmYWxzZSxcbiAgICAgICAgdXBkYXRlVGltZTogZmFsc2VcbiAgICAgIH0sXG4gICAgICBlbmQ6ICcnLFxuICAgICAgZm9ybWF0OiB7XG4gICAgICAgIG1pbm9yTGFiZWxzOiB7XG4gICAgICAgICAgbWlsbGlzZWNvbmQ6ICdTU1MnLFxuICAgICAgICAgIHNlY29uZDogJ3MnLFxuICAgICAgICAgIG1pbnV0ZTogJ0hIOm1tJyxcbiAgICAgICAgICBob3VyOiAnSEg6bW0nLFxuICAgICAgICAgIHdlZWtkYXk6ICdkZGQgRCcsXG4gICAgICAgICAgZGF5OiAnRCcsXG4gICAgICAgICAgbW9udGg6ICdNTU0nLFxuICAgICAgICAgIHllYXI6ICdZWVlZJ1xuICAgICAgICB9LFxuICAgICAgICBtYWpvckxhYmVsczoge1xuICAgICAgICAgIG1pbGxpc2Vjb25kOiAnSEg6bW06c3MnLFxuICAgICAgICAgIHNlY29uZDogJ0QgTU1NTSBISDptbScsXG4gICAgICAgICAgbWludXRlOiAnZGRkIEQgTU1NTScsXG4gICAgICAgICAgaG91cjogJ2RkZCBEIE1NTU0nLFxuICAgICAgICAgIHdlZWtkYXk6ICdNTU1NIFlZWVknLFxuICAgICAgICAgIGRheTogJ01NTU0gWVlZWScsXG4gICAgICAgICAgbW9udGg6ICdZWVlZJyxcbiAgICAgICAgICB5ZWFyOiAnJ1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvL2dyb3VwT3JkZXI6IHtzdHJpbmcsICdmdW5jdGlvbic6ICdmdW5jdGlvbid9LFxuICAgICAgZ3JvdXBzRHJhZ2dhYmxlOiBmYWxzZSxcbiAgICAgIGhlaWdodDogJycsXG4gICAgICAvL2hpZGRlbkRhdGVzOiB7b2JqZWN0LCBhcnJheX0sXG4gICAgICBsb2NhbGU6ICcnLFxuICAgICAgbWFyZ2luOiB7XG4gICAgICAgIGF4aXM6IFsyMCwgMCwgMTAwLCAxXSxcbiAgICAgICAgaXRlbToge1xuICAgICAgICAgIGhvcml6b250YWw6IFsxMCwgMCwgMTAwLCAxXSxcbiAgICAgICAgICB2ZXJ0aWNhbDogWzEwLCAwLCAxMDAsIDFdXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtYXg6ICcnLFxuICAgICAgbWF4SGVpZ2h0OiAnJyxcbiAgICAgIG1heE1pbm9yQ2hhcnM6IFs3LCAwLCAyMCwgMV0sXG4gICAgICBtaW46ICcnLFxuICAgICAgbWluSGVpZ2h0OiAnJyxcbiAgICAgIG1vdmVhYmxlOiBmYWxzZSxcbiAgICAgIG11bHRpc2VsZWN0OiBmYWxzZSxcbiAgICAgIG11bHRpc2VsZWN0UGVyR3JvdXA6IGZhbHNlLFxuICAgICAgLy9vbkFkZDogeydmdW5jdGlvbic6ICdmdW5jdGlvbid9LFxuICAgICAgLy9vblVwZGF0ZTogeydmdW5jdGlvbic6ICdmdW5jdGlvbid9LFxuICAgICAgLy9vbk1vdmU6IHsnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgICAgIC8vb25Nb3Zpbmc6IHsnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgICAgIC8vb25SZW5hbWU6IHsnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgICAgIC8vb3JkZXI6IHsnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgICAgIG9yaWVudGF0aW9uOiB7XG4gICAgICAgIGF4aXM6IFsnYm90aCcsICdib3R0b20nLCAndG9wJ10sXG4gICAgICAgIGl0ZW06IFsnYm90dG9tJywgJ3RvcCddXG4gICAgICB9LFxuICAgICAgc2VsZWN0YWJsZTogdHJ1ZSxcbiAgICAgIHNob3dDdXJyZW50VGltZTogZmFsc2UsXG4gICAgICBzaG93TWFqb3JMYWJlbHM6IHRydWUsXG4gICAgICBzaG93TWlub3JMYWJlbHM6IHRydWUsXG4gICAgICBzdGFjazogdHJ1ZSxcbiAgICAgIC8vc25hcDogeydmdW5jdGlvbic6ICdmdW5jdGlvbicsIG5hZGF9LFxuICAgICAgc3RhcnQ6ICcnLFxuICAgICAgLy90ZW1wbGF0ZTogeydmdW5jdGlvbic6ICdmdW5jdGlvbid9LFxuICAgICAgLy90aW1lQXhpczoge1xuICAgICAgLy8gIHNjYWxlOiBbJ21pbGxpc2Vjb25kJywgJ3NlY29uZCcsICdtaW51dGUnLCAnaG91cicsICd3ZWVrZGF5JywgJ2RheScsICdtb250aCcsICd5ZWFyJ10sXG4gICAgICAvLyAgc3RlcDogWzEsIDEsIDEwLCAxXVxuICAgICAgLy99LFxuICAgICAgdHlwZTogWydib3gnLCAncG9pbnQnLCAncmFuZ2UnLCAnYmFja2dyb3VuZCddLFxuICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgIHpvb21hYmxlOiB0cnVlLFxuICAgICAgem9vbUtleTogWydjdHJsS2V5JywgJ2FsdEtleScsICdtZXRhS2V5JywgJyddLFxuICAgICAgem9vbU1heDogWzMxNTM2MDAwMDAwMDAwMCwgMTAsIDMxNTM2MDAwMDAwMDAwMCwgMV0sXG4gICAgICB6b29tTWluOiBbMTAsIDEwLCAzMTUzNjAwMDAwMDAwMDAsIDFdXG4gICAgfVxuICB9O1xuXG4gIGV4cG9ydHMuYWxsT3B0aW9ucyA9IGFsbE9wdGlvbnM7XG4gIGV4cG9ydHMuY29uZmlndXJlT3B0aW9ucyA9IGNvbmZpZ3VyZU9wdGlvbnM7XG5cbi8qKiovIH0sXG4vKiA1MCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBfQ29uZmlndXJhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XG5cbiAgdmFyIF9Db25maWd1cmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ29uZmlndXJhdG9yKTtcblxuICB2YXIgX1ZhbGlkYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xuXG4gIHZhciBfVmFsaWRhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1ZhbGlkYXRvcik7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuICB2YXIgRW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuICB2YXIgSGFtbWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG4gIHZhciBtb21lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4gIHZhciBEYXRhU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcbiAgdmFyIERhdGFWaWV3ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG4gIHZhciBSYW5nZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzApO1xuICB2YXIgQ29yZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xuICB2YXIgVGltZUF4aXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KTtcbiAgdmFyIEN1cnJlbnRUaW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OCk7XG4gIHZhciBDdXN0b21UaW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nik7XG4gIHZhciBMaW5lR3JhcGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxKTtcblxuICB2YXIgcHJpbnRTdHlsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpLnByaW50U3R5bGU7XG4gIHZhciBhbGxPcHRpb25zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OSkuYWxsT3B0aW9ucztcbiAgdmFyIGNvbmZpZ3VyZU9wdGlvbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5KS5jb25maWd1cmVPcHRpb25zO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSB0aW1lbGluZSB2aXN1YWxpemF0aW9uXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lclxuICAgKiBAcGFyYW0ge3Zpcy5EYXRhU2V0IHwgQXJyYXl9IFtpdGVtc11cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgU2VlIEdyYXBoMmQuc2V0T3B0aW9ucyBmb3IgdGhlIGF2YWlsYWJsZSBvcHRpb25zLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMgQ29yZVxuICAgKi9cbiAgZnVuY3Rpb24gR3JhcGgyZChjb250YWluZXIsIGl0ZW1zLCBncm91cHMsIG9wdGlvbnMpIHtcbiAgICAvLyBpZiB0aGUgdGhpcmQgZWxlbWVudCBpcyBvcHRpb25zLCB0aGUgZm9ydGggaXMgZ3JvdXBzIChvcHRpb25hbGx5KTtcbiAgICBpZiAoIShBcnJheS5pc0FycmF5KGdyb3VwcykgfHwgZ3JvdXBzIGluc3RhbmNlb2YgRGF0YVNldCB8fCBncm91cHMgaW5zdGFuY2VvZiBEYXRhVmlldykgJiYgZ3JvdXBzIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICB2YXIgZm9ydGhBcmd1bWVudCA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0gZ3JvdXBzO1xuICAgICAgZ3JvdXBzID0gZm9ydGhBcmd1bWVudDtcbiAgICB9XG5cbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBzdGFydDogbnVsbCxcbiAgICAgIGVuZDogbnVsbCxcblxuICAgICAgYXV0b1Jlc2l6ZTogdHJ1ZSxcblxuICAgICAgb3JpZW50YXRpb246IHtcbiAgICAgICAgYXhpczogJ2JvdHRvbScsIC8vIGF4aXMgb3JpZW50YXRpb246ICdib3R0b20nLCAndG9wJywgb3IgJ2JvdGgnXG4gICAgICAgIGl0ZW06ICdib3R0b20nIC8vIG5vdCByZWxldmFudCBmb3IgR3JhcGgyZFxuICAgICAgfSxcblxuICAgICAgbW9tZW50OiBtb21lbnQsXG5cbiAgICAgIHdpZHRoOiBudWxsLFxuICAgICAgaGVpZ2h0OiBudWxsLFxuICAgICAgbWF4SGVpZ2h0OiBudWxsLFxuICAgICAgbWluSGVpZ2h0OiBudWxsXG4gICAgfTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1dGlsLmRlZXBFeHRlbmQoe30sIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSBET00sIHByb3BzLCBhbmQgZW1pdHRlclxuICAgIHRoaXMuX2NyZWF0ZShjb250YWluZXIpO1xuXG4gICAgLy8gYWxsIGNvbXBvbmVudHMgbGlzdGVkIGhlcmUgd2lsbCBiZSByZXBhaW50ZWQgYXV0b21hdGljYWxseVxuICAgIHRoaXMuY29tcG9uZW50cyA9IFtdO1xuXG4gICAgdGhpcy5ib2R5ID0ge1xuICAgICAgZG9tOiB0aGlzLmRvbSxcbiAgICAgIGRvbVByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgZW1pdHRlcjoge1xuICAgICAgICBvbjogdGhpcy5vbi5iaW5kKHRoaXMpLFxuICAgICAgICBvZmY6IHRoaXMub2ZmLmJpbmQodGhpcyksXG4gICAgICAgIGVtaXQ6IHRoaXMuZW1pdC5iaW5kKHRoaXMpXG4gICAgICB9LFxuICAgICAgaGlkZGVuRGF0ZXM6IFtdLFxuICAgICAgdXRpbDoge1xuICAgICAgICB0b1NjcmVlbjogbWUuX3RvU2NyZWVuLmJpbmQobWUpLFxuICAgICAgICB0b0dsb2JhbFNjcmVlbjogbWUuX3RvR2xvYmFsU2NyZWVuLmJpbmQobWUpLCAvLyB0aGlzIHJlZmVycyB0byB0aGUgcm9vdC53aWR0aFxuICAgICAgICB0b1RpbWU6IG1lLl90b1RpbWUuYmluZChtZSksXG4gICAgICAgIHRvR2xvYmFsVGltZTogbWUuX3RvR2xvYmFsVGltZS5iaW5kKG1lKVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyByYW5nZVxuICAgIHRoaXMucmFuZ2UgPSBuZXcgUmFuZ2UodGhpcy5ib2R5KTtcbiAgICB0aGlzLmNvbXBvbmVudHMucHVzaCh0aGlzLnJhbmdlKTtcbiAgICB0aGlzLmJvZHkucmFuZ2UgPSB0aGlzLnJhbmdlO1xuXG4gICAgLy8gdGltZSBheGlzXG4gICAgdGhpcy50aW1lQXhpcyA9IG5ldyBUaW1lQXhpcyh0aGlzLmJvZHkpO1xuICAgIHRoaXMuY29tcG9uZW50cy5wdXNoKHRoaXMudGltZUF4aXMpO1xuICAgIC8vdGhpcy5ib2R5LnV0aWwuc25hcCA9IHRoaXMudGltZUF4aXMuc25hcC5iaW5kKHRoaXMudGltZUF4aXMpO1xuXG4gICAgLy8gY3VycmVudCB0aW1lIGJhclxuICAgIHRoaXMuY3VycmVudFRpbWUgPSBuZXcgQ3VycmVudFRpbWUodGhpcy5ib2R5KTtcbiAgICB0aGlzLmNvbXBvbmVudHMucHVzaCh0aGlzLmN1cnJlbnRUaW1lKTtcblxuICAgIC8vIGl0ZW0gc2V0XG4gICAgdGhpcy5saW5lZ3JhcGggPSBuZXcgTGluZUdyYXBoKHRoaXMuYm9keSk7XG5cbiAgICB0aGlzLmNvbXBvbmVudHMucHVzaCh0aGlzLmxpbmVncmFwaCk7XG5cbiAgICB0aGlzLml0ZW1zRGF0YSA9IG51bGw7IC8vIERhdGFTZXRcbiAgICB0aGlzLmdyb3Vwc0RhdGEgPSBudWxsOyAvLyBEYXRhU2V0XG5cbiAgICB0aGlzLm9uKCd0YXAnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIG1lLmVtaXQoJ2NsaWNrJywgbWUuZ2V0RXZlbnRQcm9wZXJ0aWVzKGV2ZW50KSk7XG4gICAgfSk7XG4gICAgdGhpcy5vbignZG91YmxldGFwJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBtZS5lbWl0KCdkb3VibGVDbGljaycsIG1lLmdldEV2ZW50UHJvcGVydGllcyhldmVudCkpO1xuICAgIH0pO1xuICAgIHRoaXMuZG9tLnJvb3Qub25jb250ZXh0bWVudSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgbWUuZW1pdCgnY29udGV4dG1lbnUnLCBtZS5nZXRFdmVudFByb3BlcnRpZXMoZXZlbnQpKTtcbiAgICB9O1xuXG4gICAgLy8gYXBwbHkgb3B0aW9uc1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLy8gSU1QT1JUQU5UOiBUSElTIEhBUFBFTlMgQkVGT1JFIFNFVCBJVEVNUyFcbiAgICBpZiAoZ3JvdXBzKSB7XG4gICAgICB0aGlzLnNldEdyb3Vwcyhncm91cHMpO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBpdGVtc2V0XG4gICAgaWYgKGl0ZW1zKSB7XG4gICAgICB0aGlzLnNldEl0ZW1zKGl0ZW1zKTtcbiAgICB9XG5cbiAgICAvLyBkcmF3IGZvciB0aGUgZmlyc3QgdGltZVxuICAgIHRoaXMuX3JlZHJhdygpO1xuICB9XG5cbiAgLy8gRXh0ZW5kIHRoZSBmdW5jdGlvbmFsaXR5IGZyb20gQ29yZVxuICBHcmFwaDJkLnByb3RvdHlwZSA9IG5ldyBDb3JlKCk7XG5cbiAgR3JhcGgyZC5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgLy8gdmFsaWRhdGUgb3B0aW9uc1xuICAgIHZhciBlcnJvckZvdW5kID0gX1ZhbGlkYXRvcjIuZGVmYXVsdC52YWxpZGF0ZShvcHRpb25zLCBhbGxPcHRpb25zKTtcbiAgICBpZiAoZXJyb3JGb3VuZCA9PT0gdHJ1ZSkge1xuICAgICAgY29uc29sZS5sb2coJyVjRXJyb3JzIGhhdmUgYmVlbiBmb3VuZCBpbiB0aGUgc3VwcGxpZWQgb3B0aW9ucyBvYmplY3QuJywgcHJpbnRTdHlsZSk7XG4gICAgfVxuXG4gICAgQ29yZS5wcm90b3R5cGUuc2V0T3B0aW9ucy5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgaXRlbXNcbiAgICogQHBhcmFtIHt2aXMuRGF0YVNldCB8IEFycmF5IHwgbnVsbH0gaXRlbXNcbiAgICovXG4gIEdyYXBoMmQucHJvdG90eXBlLnNldEl0ZW1zID0gZnVuY3Rpb24gKGl0ZW1zKSB7XG4gICAgdmFyIGluaXRpYWxMb2FkID0gdGhpcy5pdGVtc0RhdGEgPT0gbnVsbDtcblxuICAgIC8vIGNvbnZlcnQgdG8gdHlwZSBEYXRhU2V0IHdoZW4gbmVlZGVkXG4gICAgdmFyIG5ld0RhdGFTZXQ7XG4gICAgaWYgKCFpdGVtcykge1xuICAgICAgbmV3RGF0YVNldCA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChpdGVtcyBpbnN0YW5jZW9mIERhdGFTZXQgfHwgaXRlbXMgaW5zdGFuY2VvZiBEYXRhVmlldykge1xuICAgICAgbmV3RGF0YVNldCA9IGl0ZW1zO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0dXJuIGFuIGFycmF5IGludG8gYSBkYXRhc2V0XG4gICAgICBuZXdEYXRhU2V0ID0gbmV3IERhdGFTZXQoaXRlbXMsIHtcbiAgICAgICAgdHlwZToge1xuICAgICAgICAgIHN0YXJ0OiAnRGF0ZScsXG4gICAgICAgICAgZW5kOiAnRGF0ZSdcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gc2V0IGl0ZW1zXG4gICAgdGhpcy5pdGVtc0RhdGEgPSBuZXdEYXRhU2V0O1xuICAgIHRoaXMubGluZWdyYXBoICYmIHRoaXMubGluZWdyYXBoLnNldEl0ZW1zKG5ld0RhdGFTZXQpO1xuXG4gICAgaWYgKGluaXRpYWxMb2FkKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnN0YXJ0ICE9IHVuZGVmaW5lZCB8fCB0aGlzLm9wdGlvbnMuZW5kICE9IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLm9wdGlvbnMuc3RhcnQgIT0gdW5kZWZpbmVkID8gdGhpcy5vcHRpb25zLnN0YXJ0IDogbnVsbDtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMub3B0aW9ucy5lbmQgIT0gdW5kZWZpbmVkID8gdGhpcy5vcHRpb25zLmVuZCA6IG51bGw7XG4gICAgICAgIHRoaXMuc2V0V2luZG93KHN0YXJ0LCBlbmQsIHsgYW5pbWF0aW9uOiBmYWxzZSB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZml0KHsgYW5pbWF0aW9uOiBmYWxzZSB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBncm91cHNcbiAgICogQHBhcmFtIHt2aXMuRGF0YVNldCB8IEFycmF5fSBncm91cHNcbiAgICovXG4gIEdyYXBoMmQucHJvdG90eXBlLnNldEdyb3VwcyA9IGZ1bmN0aW9uIChncm91cHMpIHtcbiAgICAvLyBjb252ZXJ0IHRvIHR5cGUgRGF0YVNldCB3aGVuIG5lZWRlZFxuICAgIHZhciBuZXdEYXRhU2V0O1xuICAgIGlmICghZ3JvdXBzKSB7XG4gICAgICBuZXdEYXRhU2V0ID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGdyb3VwcyBpbnN0YW5jZW9mIERhdGFTZXQgfHwgZ3JvdXBzIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICAgIG5ld0RhdGFTZXQgPSBncm91cHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHR1cm4gYW4gYXJyYXkgaW50byBhIGRhdGFzZXRcbiAgICAgIG5ld0RhdGFTZXQgPSBuZXcgRGF0YVNldChncm91cHMpO1xuICAgIH1cblxuICAgIHRoaXMuZ3JvdXBzRGF0YSA9IG5ld0RhdGFTZXQ7XG4gICAgdGhpcy5saW5lZ3JhcGguc2V0R3JvdXBzKG5ld0RhdGFTZXQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIGFuIFNWRyBlbGVtZW50IHdpdGggdGhlIGljb24gb2YgdGhlIGdyb3VwIChzaXplIGRldGVybWluZWQgYnkgaWNvbldpZHRoIGFuZCBpY29uSGVpZ2h0KSwgdGhlIGxhYmVsIG9mIHRoZSBncm91cCAoY29udGVudCkgYW5kIHRoZSB5QXhpc09yaWVudGF0aW9uIG9mIHRoZSBncm91cCAobGVmdCBvciByaWdodCkuXG4gICAqIEBwYXJhbSBncm91cElkXG4gICAqIEBwYXJhbSB3aWR0aFxuICAgKiBAcGFyYW0gaGVpZ2h0XG4gICAqL1xuICBHcmFwaDJkLnByb3RvdHlwZS5nZXRMZWdlbmQgPSBmdW5jdGlvbiAoZ3JvdXBJZCwgd2lkdGgsIGhlaWdodCkge1xuICAgIGlmICh3aWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB3aWR0aCA9IDE1O1xuICAgIH1cbiAgICBpZiAoaGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGhlaWdodCA9IDE1O1xuICAgIH1cbiAgICBpZiAodGhpcy5saW5lZ3JhcGguZ3JvdXBzW2dyb3VwSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmxpbmVncmFwaC5ncm91cHNbZ3JvdXBJZF0uZ2V0TGVnZW5kKHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJjYW5ub3QgZmluZCBncm91cDonXCIgKyBncm91cElkICsgXCInXCI7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGNoZWNrcyBpZiB0aGUgdmlzaWJsZSBvcHRpb24gb2YgdGhlIHN1cHBsaWVkIGdyb3VwIChieSBJRCkgaXMgdHJ1ZSBvciBmYWxzZS5cbiAgICogQHBhcmFtIGdyb3VwSWRcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBHcmFwaDJkLnByb3RvdHlwZS5pc0dyb3VwVmlzaWJsZSA9IGZ1bmN0aW9uIChncm91cElkKSB7XG4gICAgaWYgKHRoaXMubGluZWdyYXBoLmdyb3Vwc1tncm91cElkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5saW5lZ3JhcGguZ3JvdXBzW2dyb3VwSWRdLnZpc2libGUgJiYgKHRoaXMubGluZWdyYXBoLm9wdGlvbnMuZ3JvdXBzLnZpc2liaWxpdHlbZ3JvdXBJZF0gPT09IHVuZGVmaW5lZCB8fCB0aGlzLmxpbmVncmFwaC5vcHRpb25zLmdyb3Vwcy52aXNpYmlsaXR5W2dyb3VwSWRdID09IHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRhdGEgcmFuZ2Ugb2YgdGhlIGl0ZW0gc2V0LlxuICAgKiBAcmV0dXJucyB7e21pbjogRGF0ZSwgbWF4OiBEYXRlfX0gcmFuZ2UgIEEgcmFuZ2Ugd2l0aCBhIHN0YXJ0IGFuZCBlbmQgRGF0ZS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBXaGVuIG5vIG1pbmltdW0gaXMgZm91bmQsIG1pbj09bnVsbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdoZW4gbm8gbWF4aW11bSBpcyBmb3VuZCwgbWF4PT1udWxsXG4gICAqL1xuICBHcmFwaDJkLnByb3RvdHlwZS5nZXREYXRhUmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1pbiA9IG51bGw7XG4gICAgdmFyIG1heCA9IG51bGw7XG5cbiAgICAvLyBjYWxjdWxhdGUgbWluIGZyb20gc3RhcnQgZmlsZWRcbiAgICBmb3IgKHZhciBncm91cElkIGluIHRoaXMubGluZWdyYXBoLmdyb3Vwcykge1xuICAgICAgaWYgKHRoaXMubGluZWdyYXBoLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShncm91cElkKSkge1xuICAgICAgICBpZiAodGhpcy5saW5lZ3JhcGguZ3JvdXBzW2dyb3VwSWRdLnZpc2libGUgPT0gdHJ1ZSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saW5lZ3JhcGguZ3JvdXBzW2dyb3VwSWRdLml0ZW1zRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmxpbmVncmFwaC5ncm91cHNbZ3JvdXBJZF0uaXRlbXNEYXRhW2ldO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdXRpbC5jb252ZXJ0KGl0ZW0ueCwgJ0RhdGUnKS52YWx1ZU9mKCk7XG4gICAgICAgICAgICBtaW4gPSBtaW4gPT0gbnVsbCA/IHZhbHVlIDogbWluID4gdmFsdWUgPyB2YWx1ZSA6IG1pbjtcbiAgICAgICAgICAgIG1heCA9IG1heCA9PSBudWxsID8gdmFsdWUgOiBtYXggPCB2YWx1ZSA/IHZhbHVlIDogbWF4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBtaW46IG1pbiAhPSBudWxsID8gbmV3IERhdGUobWluKSA6IG51bGwsXG4gICAgICBtYXg6IG1heCAhPSBudWxsID8gbmV3IERhdGUobWF4KSA6IG51bGxcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBUaW1lbGluZSByZWxhdGVkIGluZm9ybWF0aW9uIGZyb20gYW4gZXZlbnRcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCByZWxhdGVkIGluZm9ybWF0aW9uLCBsaWtlIG9uIHdoaWNoIGFyZWFcbiAgICogICAgICAgICAgICAgICAgICBUaGUgZXZlbnQgaGFwcGVuZWQsIHdoZXRoZXIgY2xpY2tlZCBvbiBhbiBpdGVtLCBldGMuXG4gICAqL1xuICBHcmFwaDJkLnByb3RvdHlwZS5nZXRFdmVudFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgY2xpZW50WCA9IGV2ZW50LmNlbnRlciA/IGV2ZW50LmNlbnRlci54IDogZXZlbnQuY2xpZW50WDtcbiAgICB2YXIgY2xpZW50WSA9IGV2ZW50LmNlbnRlciA/IGV2ZW50LmNlbnRlci55IDogZXZlbnQuY2xpZW50WTtcbiAgICB2YXIgeCA9IGNsaWVudFggLSB1dGlsLmdldEFic29sdXRlTGVmdCh0aGlzLmRvbS5jZW50ZXJDb250YWluZXIpO1xuICAgIHZhciB5ID0gY2xpZW50WSAtIHV0aWwuZ2V0QWJzb2x1dGVUb3AodGhpcy5kb20uY2VudGVyQ29udGFpbmVyKTtcbiAgICB2YXIgdGltZSA9IHRoaXMuX3RvVGltZSh4KTtcblxuICAgIHZhciBjdXN0b21UaW1lID0gQ3VzdG9tVGltZS5jdXN0b21UaW1lRnJvbVRhcmdldChldmVudCk7XG5cbiAgICB2YXIgZWxlbWVudCA9IHV0aWwuZ2V0VGFyZ2V0KGV2ZW50KTtcbiAgICB2YXIgd2hhdCA9IG51bGw7XG4gICAgaWYgKHV0aWwuaGFzUGFyZW50KGVsZW1lbnQsIHRoaXMudGltZUF4aXMuZG9tLmZvcmVncm91bmQpKSB7XG4gICAgICB3aGF0ID0gJ2F4aXMnO1xuICAgIH0gZWxzZSBpZiAodGhpcy50aW1lQXhpczIgJiYgdXRpbC5oYXNQYXJlbnQoZWxlbWVudCwgdGhpcy50aW1lQXhpczIuZG9tLmZvcmVncm91bmQpKSB7XG4gICAgICB3aGF0ID0gJ2F4aXMnO1xuICAgIH0gZWxzZSBpZiAodXRpbC5oYXNQYXJlbnQoZWxlbWVudCwgdGhpcy5saW5lZ3JhcGgueUF4aXNMZWZ0LmRvbS5mcmFtZSkpIHtcbiAgICAgIHdoYXQgPSAnZGF0YS1heGlzJztcbiAgICB9IGVsc2UgaWYgKHV0aWwuaGFzUGFyZW50KGVsZW1lbnQsIHRoaXMubGluZWdyYXBoLnlBeGlzUmlnaHQuZG9tLmZyYW1lKSkge1xuICAgICAgd2hhdCA9ICdkYXRhLWF4aXMnO1xuICAgIH0gZWxzZSBpZiAodXRpbC5oYXNQYXJlbnQoZWxlbWVudCwgdGhpcy5saW5lZ3JhcGgubGVnZW5kTGVmdC5kb20uZnJhbWUpKSB7XG4gICAgICB3aGF0ID0gJ2xlZ2VuZCc7XG4gICAgfSBlbHNlIGlmICh1dGlsLmhhc1BhcmVudChlbGVtZW50LCB0aGlzLmxpbmVncmFwaC5sZWdlbmRSaWdodC5kb20uZnJhbWUpKSB7XG4gICAgICB3aGF0ID0gJ2xlZ2VuZCc7XG4gICAgfSBlbHNlIGlmIChjdXN0b21UaW1lICE9IG51bGwpIHtcbiAgICAgIHdoYXQgPSAnY3VzdG9tLXRpbWUnO1xuICAgIH0gZWxzZSBpZiAodXRpbC5oYXNQYXJlbnQoZWxlbWVudCwgdGhpcy5jdXJyZW50VGltZS5iYXIpKSB7XG4gICAgICB3aGF0ID0gJ2N1cnJlbnQtdGltZSc7XG4gICAgfSBlbHNlIGlmICh1dGlsLmhhc1BhcmVudChlbGVtZW50LCB0aGlzLmRvbS5jZW50ZXIpKSB7XG4gICAgICB3aGF0ID0gJ2JhY2tncm91bmQnO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IFtdO1xuICAgIHZhciB5QXhpc0xlZnQgPSB0aGlzLmxpbmVncmFwaC55QXhpc0xlZnQ7XG4gICAgdmFyIHlBeGlzUmlnaHQgPSB0aGlzLmxpbmVncmFwaC55QXhpc1JpZ2h0O1xuICAgIGlmICgheUF4aXNMZWZ0LmhpZGRlbikge1xuICAgICAgdmFsdWUucHVzaCh5QXhpc0xlZnQuc2NyZWVuVG9WYWx1ZSh5KSk7XG4gICAgfVxuICAgIGlmICgheUF4aXNSaWdodC5oaWRkZW4pIHtcbiAgICAgIHZhbHVlLnB1c2goeUF4aXNSaWdodC5zY3JlZW5Ub1ZhbHVlKHkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgd2hhdDogd2hhdCxcbiAgICAgIHBhZ2VYOiBldmVudC5zcmNFdmVudCA/IGV2ZW50LnNyY0V2ZW50LnBhZ2VYIDogZXZlbnQucGFnZVgsXG4gICAgICBwYWdlWTogZXZlbnQuc3JjRXZlbnQgPyBldmVudC5zcmNFdmVudC5wYWdlWSA6IGV2ZW50LnBhZ2VZLFxuICAgICAgeDogeCxcbiAgICAgIHk6IHksXG4gICAgICB0aW1lOiB0aW1lLFxuICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogTG9hZCBhIGNvbmZpZ3VyYXRvclxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBHcmFwaDJkLnByb3RvdHlwZS5fY3JlYXRlQ29uZmlndXJhdG9yID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgX0NvbmZpZ3VyYXRvcjIuZGVmYXVsdCh0aGlzLCB0aGlzLmRvbS5jb250YWluZXIsIGNvbmZpZ3VyZU9wdGlvbnMpO1xuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gR3JhcGgyZDtcblxuLyoqKi8gfSxcbi8qIDUxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbiAgdmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuICB2YXIgRE9NdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG4gIHZhciBEYXRhU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcbiAgdmFyIERhdGFWaWV3ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG4gIHZhciBDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKTtcbiAgdmFyIERhdGFBeGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Mik7XG4gIHZhciBHcmFwaEdyb3VwID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NCk7XG4gIHZhciBMZWdlbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU4KTtcbiAgdmFyIEJhcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1KTtcbiAgdmFyIExpbmVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nyk7XG4gIHZhciBQb2ludHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2KTtcblxuICB2YXIgVU5HUk9VUEVEID0gJ19fdW5ncm91cGVkX18nOyAvLyByZXNlcnZlZCBncm91cCBpZCBmb3IgdW5ncm91cGVkIGl0ZW1zXG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgdGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBMaW5lR3JhcGguIEl0IHJlcXVpcmVzIGEgVGltZWxpbmUgYm9keSBhbmQgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIGJvZHlcbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBMaW5lR3JhcGgoYm9keSwgb3B0aW9ucykge1xuICAgIHRoaXMuaWQgPSB1dGlsLnJhbmRvbVVVSUQoKTtcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuXG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIHlBeGlzT3JpZW50YXRpb246ICdsZWZ0JyxcbiAgICAgIGRlZmF1bHRHcm91cDogJ2RlZmF1bHQnLFxuICAgICAgc29ydDogdHJ1ZSxcbiAgICAgIHNhbXBsaW5nOiB0cnVlLFxuICAgICAgc3RhY2s6IGZhbHNlLFxuICAgICAgZ3JhcGhIZWlnaHQ6ICc0MDBweCcsXG4gICAgICBzaGFkZWQ6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIG9yaWVudGF0aW9uOiAnYm90dG9tJyAvLyB0b3AsIGJvdHRvbSwgemVyb1xuICAgICAgfSxcbiAgICAgIHN0eWxlOiAnbGluZScsIC8vIGxpbmUsIGJhclxuICAgICAgYmFyQ2hhcnQ6IHtcbiAgICAgICAgd2lkdGg6IDUwLFxuICAgICAgICBzaWRlQnlTaWRlOiBmYWxzZSxcbiAgICAgICAgYWxpZ246ICdjZW50ZXInIC8vIGxlZnQsIGNlbnRlciwgcmlnaHRcbiAgICAgIH0sXG4gICAgICBpbnRlcnBvbGF0aW9uOiB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIHBhcmFtZXRyaXphdGlvbjogJ2NlbnRyaXBldGFsJywgLy8gdW5pZm9ybSAoYWxwaGEgPSAwLjApLCBjaG9yZGFsIChhbHBoYSA9IDEuMCksIGNlbnRyaXBldGFsIChhbHBoYSA9IDAuNSlcbiAgICAgICAgYWxwaGE6IDAuNVxuICAgICAgfSxcbiAgICAgIGRyYXdQb2ludHM6IHtcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgc2l6ZTogNixcbiAgICAgICAgc3R5bGU6ICdzcXVhcmUnIC8vIHNxdWFyZSwgY2lyY2xlXG4gICAgICB9LFxuICAgICAgZGF0YUF4aXM6IHt9LCAvL0RlZmF1bHRzIGFyZSBkb25lIG9uIERhdGFBeGlzIGxldmVsXG4gICAgICBsZWdlbmQ6IHt9LCAvL0RlZmF1bHRzIGFyZSBkb25lIG9uIExlZ2VuZCBsZXZlbFxuICAgICAgZ3JvdXBzOiB7XG4gICAgICAgIHZpc2liaWxpdHk6IHt9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIG9wdGlvbnMgaXMgc2hhcmVkIGJ5IHRoaXMgbGluZUdyYXBoIGFuZCBhbGwgaXRzIGl0ZW1zXG4gICAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoe30sIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuICAgIHRoaXMuZG9tID0ge307XG4gICAgdGhpcy5wcm9wcyA9IHt9O1xuICAgIHRoaXMuaGFtbWVyID0gbnVsbDtcbiAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgIHRoaXMuYWJvcnRlZEdyYXBoVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy51cGRhdGVTVkdoZWlnaHQgPSBmYWxzZTtcbiAgICB0aGlzLnVwZGF0ZVNWR2hlaWdodE9uUmVzaXplID0gZmFsc2U7XG4gICAgdGhpcy5mb3JjZUdyYXBoVXBkYXRlID0gdHJ1ZTtcblxuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdGhpcy5pdGVtc0RhdGEgPSBudWxsOyAvLyBEYXRhU2V0XG4gICAgdGhpcy5ncm91cHNEYXRhID0gbnVsbDsgLy8gRGF0YVNldFxuXG4gICAgLy8gbGlzdGVuZXJzIGZvciB0aGUgRGF0YVNldCBvZiB0aGUgaXRlbXNcbiAgICB0aGlzLml0ZW1MaXN0ZW5lcnMgPSB7XG4gICAgICAnYWRkJzogZnVuY3Rpb24gYWRkKGV2ZW50LCBwYXJhbXMsIHNlbmRlcklkKSB7XG4gICAgICAgIG1lLl9vbkFkZChwYXJhbXMuaXRlbXMpO1xuICAgICAgfSxcbiAgICAgICd1cGRhdGUnOiBmdW5jdGlvbiB1cGRhdGUoZXZlbnQsIHBhcmFtcywgc2VuZGVySWQpIHtcbiAgICAgICAgbWUuX29uVXBkYXRlKHBhcmFtcy5pdGVtcyk7XG4gICAgICB9LFxuICAgICAgJ3JlbW92ZSc6IGZ1bmN0aW9uIHJlbW92ZShldmVudCwgcGFyYW1zLCBzZW5kZXJJZCkge1xuICAgICAgICBtZS5fb25SZW1vdmUocGFyYW1zLml0ZW1zKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gbGlzdGVuZXJzIGZvciB0aGUgRGF0YVNldCBvZiB0aGUgZ3JvdXBzXG4gICAgdGhpcy5ncm91cExpc3RlbmVycyA9IHtcbiAgICAgICdhZGQnOiBmdW5jdGlvbiBhZGQoZXZlbnQsIHBhcmFtcywgc2VuZGVySWQpIHtcbiAgICAgICAgbWUuX29uQWRkR3JvdXBzKHBhcmFtcy5pdGVtcyk7XG4gICAgICB9LFxuICAgICAgJ3VwZGF0ZSc6IGZ1bmN0aW9uIHVwZGF0ZShldmVudCwgcGFyYW1zLCBzZW5kZXJJZCkge1xuICAgICAgICBtZS5fb25VcGRhdGVHcm91cHMocGFyYW1zLml0ZW1zKTtcbiAgICAgIH0sXG4gICAgICAncmVtb3ZlJzogZnVuY3Rpb24gcmVtb3ZlKGV2ZW50LCBwYXJhbXMsIHNlbmRlcklkKSB7XG4gICAgICAgIG1lLl9vblJlbW92ZUdyb3VwcyhwYXJhbXMuaXRlbXMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLml0ZW1zID0ge307IC8vIG9iamVjdCB3aXRoIGFuIEl0ZW0gZm9yIGV2ZXJ5IGRhdGEgaXRlbVxuICAgIHRoaXMuc2VsZWN0aW9uID0gW107IC8vIGxpc3Qgd2l0aCB0aGUgaWRzIG9mIGFsbCBzZWxlY3RlZCBub2Rlc1xuICAgIHRoaXMubGFzdFN0YXJ0ID0gdGhpcy5ib2R5LnJhbmdlLnN0YXJ0O1xuICAgIHRoaXMudG91Y2hQYXJhbXMgPSB7fTsgLy8gc3RvcmVzIHByb3BlcnRpZXMgd2hpbGUgZHJhZ2dpbmdcblxuICAgIHRoaXMuc3ZnRWxlbWVudHMgPSB7fTtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgdGhpcy5ncm91cHNVc2luZ0RlZmF1bHRTdHlsZXMgPSBbMF07XG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ3JhbmdlY2hhbmdlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIG1lLmxhc3RTdGFydCA9IG1lLmJvZHkucmFuZ2Uuc3RhcnQ7XG4gICAgICBtZS5zdmcuc3R5bGUubGVmdCA9IHV0aWwub3B0aW9uLmFzU2l6ZSgtbWUucHJvcHMud2lkdGgpO1xuXG4gICAgICBtZS5mb3JjZUdyYXBoVXBkYXRlID0gdHJ1ZTtcbiAgICAgIC8vSXMgdGhpcyBsb2NhbCByZWRyYXcgbmVjZXNzYXJ5PyAoQ29yZSBhbHNvIGRvZXMgYSBjaGFuZ2UgZXZlbnQhKVxuICAgICAgbWUucmVkcmF3LmNhbGwobWUpO1xuICAgIH0pO1xuXG4gICAgLy8gY3JlYXRlIHRoZSBIVE1MIERPTVxuICAgIHRoaXMuX2NyZWF0ZSgpO1xuICAgIHRoaXMuZnJhbWV3b3JrID0geyBzdmc6IHRoaXMuc3ZnLCBzdmdFbGVtZW50czogdGhpcy5zdmdFbGVtZW50cywgb3B0aW9uczogdGhpcy5vcHRpb25zLCBncm91cHM6IHRoaXMuZ3JvdXBzIH07XG4gIH1cblxuICBMaW5lR3JhcGgucHJvdG90eXBlID0gbmV3IENvbXBvbmVudCgpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIEhUTUwgRE9NIGZvciB0aGUgSXRlbVNldFxuICAgKi9cbiAgTGluZUdyYXBoLnByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGZyYW1lLmNsYXNzTmFtZSA9ICd2aXMtbGluZS1ncmFwaCc7XG4gICAgdGhpcy5kb20uZnJhbWUgPSBmcmFtZTtcblxuICAgIC8vIGNyZWF0ZSBzdmcgZWxlbWVudCBmb3IgZ3JhcGggZHJhd2luZy5cbiAgICB0aGlzLnN2ZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAnc3ZnJyk7XG4gICAgdGhpcy5zdmcuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgIHRoaXMuc3ZnLnN0eWxlLmhlaWdodCA9ICgnJyArIHRoaXMub3B0aW9ucy5ncmFwaEhlaWdodCkucmVwbGFjZSgncHgnLCAnJykgKyAncHgnO1xuICAgIHRoaXMuc3ZnLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIGZyYW1lLmFwcGVuZENoaWxkKHRoaXMuc3ZnKTtcblxuICAgIC8vIGRhdGEgYXhpc1xuICAgIHRoaXMub3B0aW9ucy5kYXRhQXhpcy5vcmllbnRhdGlvbiA9ICdsZWZ0JztcbiAgICB0aGlzLnlBeGlzTGVmdCA9IG5ldyBEYXRhQXhpcyh0aGlzLmJvZHksIHRoaXMub3B0aW9ucy5kYXRhQXhpcywgdGhpcy5zdmcsIHRoaXMub3B0aW9ucy5ncm91cHMpO1xuXG4gICAgdGhpcy5vcHRpb25zLmRhdGFBeGlzLm9yaWVudGF0aW9uID0gJ3JpZ2h0JztcbiAgICB0aGlzLnlBeGlzUmlnaHQgPSBuZXcgRGF0YUF4aXModGhpcy5ib2R5LCB0aGlzLm9wdGlvbnMuZGF0YUF4aXMsIHRoaXMuc3ZnLCB0aGlzLm9wdGlvbnMuZ3JvdXBzKTtcbiAgICBkZWxldGUgdGhpcy5vcHRpb25zLmRhdGFBeGlzLm9yaWVudGF0aW9uO1xuXG4gICAgLy8gbGVnZW5kc1xuICAgIHRoaXMubGVnZW5kTGVmdCA9IG5ldyBMZWdlbmQodGhpcy5ib2R5LCB0aGlzLm9wdGlvbnMubGVnZW5kLCAnbGVmdCcsIHRoaXMub3B0aW9ucy5ncm91cHMpO1xuICAgIHRoaXMubGVnZW5kUmlnaHQgPSBuZXcgTGVnZW5kKHRoaXMuYm9keSwgdGhpcy5vcHRpb25zLmxlZ2VuZCwgJ3JpZ2h0JywgdGhpcy5vcHRpb25zLmdyb3Vwcyk7XG5cbiAgICB0aGlzLnNob3coKTtcbiAgfTtcblxuICAvKipcbiAgICogc2V0IHRoZSBvcHRpb25zIG9mIHRoZSBMaW5lR3JhcGguIHRoZSBtZXJnZU9wdGlvbnMgaXMgdXNlZCBmb3Igc3ViT2JqZWN0cyB0aGF0IGhhdmUgYW4gZW5hYmxlZCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgTGluZUdyYXBoLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgdmFyIGZpZWxkcyA9IFsnc2FtcGxpbmcnLCAnZGVmYXVsdEdyb3VwJywgJ3N0YWNrJywgJ2hlaWdodCcsICdncmFwaEhlaWdodCcsICd5QXhpc09yaWVudGF0aW9uJywgJ3N0eWxlJywgJ2JhckNoYXJ0JywgJ2RhdGFBeGlzJywgJ3NvcnQnLCAnZ3JvdXBzJ107XG4gICAgICBpZiAob3B0aW9ucy5ncmFwaEhlaWdodCA9PT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuaGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy51cGRhdGVTVkdoZWlnaHQgPSB0cnVlO1xuICAgICAgICB0aGlzLnVwZGF0ZVNWR2hlaWdodE9uUmVzaXplID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5ib2R5LmRvbVByb3BzLmNlbnRlckNvbnRhaW5lci5oZWlnaHQgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmdyYXBoSGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHBhcnNlSW50KChvcHRpb25zLmdyYXBoSGVpZ2h0ICsgJycpLnJlcGxhY2UoXCJweFwiLCAnJykpIDwgdGhpcy5ib2R5LmRvbVByb3BzLmNlbnRlckNvbnRhaW5lci5oZWlnaHQpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZVNWR2hlaWdodCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHV0aWwuc2VsZWN0aXZlRGVlcEV4dGVuZChmaWVsZHMsIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICB1dGlsLm1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMsICdpbnRlcnBvbGF0aW9uJyk7XG4gICAgICB1dGlsLm1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMsICdkcmF3UG9pbnRzJyk7XG4gICAgICB1dGlsLm1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMsICdzaGFkZWQnKTtcbiAgICAgIHV0aWwubWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgb3B0aW9ucywgJ2xlZ2VuZCcpO1xuXG4gICAgICBpZiAob3B0aW9ucy5pbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgIGlmIChfdHlwZW9mKG9wdGlvbnMuaW50ZXJwb2xhdGlvbikgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5pbnRlcnBvbGF0aW9uLnBhcmFtZXRyaXphdGlvbikge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaW50ZXJwb2xhdGlvbi5wYXJhbWV0cml6YXRpb24gPT0gJ3VuaWZvcm0nKSB7XG4gICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmFscGhhID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5pbnRlcnBvbGF0aW9uLnBhcmFtZXRyaXphdGlvbiA9PSAnY2hvcmRhbCcpIHtcbiAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmludGVycG9sYXRpb24uYWxwaGEgPSAxLjA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5wYXJhbWV0cml6YXRpb24gPSAnY2VudHJpcGV0YWwnO1xuICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5hbHBoYSA9IDAuNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMueUF4aXNMZWZ0KSB7XG4gICAgICAgIGlmIChvcHRpb25zLmRhdGFBeGlzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnlBeGlzTGVmdC5zZXRPcHRpb25zKHRoaXMub3B0aW9ucy5kYXRhQXhpcyk7XG4gICAgICAgICAgdGhpcy55QXhpc1JpZ2h0LnNldE9wdGlvbnModGhpcy5vcHRpb25zLmRhdGFBeGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5sZWdlbmRMZWZ0KSB7XG4gICAgICAgIGlmIChvcHRpb25zLmxlZ2VuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5sZWdlbmRMZWZ0LnNldE9wdGlvbnModGhpcy5vcHRpb25zLmxlZ2VuZCk7XG4gICAgICAgICAgdGhpcy5sZWdlbmRSaWdodC5zZXRPcHRpb25zKHRoaXMub3B0aW9ucy5sZWdlbmQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShVTkdST1VQRUQpKSB7XG4gICAgICAgIHRoaXMuZ3JvdXBzW1VOR1JPVVBFRF0uc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0aGlzIGlzIHVzZWQgdG8gcmVkcmF3IHRoZSBncmFwaCBpZiB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZ3JvdXBzIGlzIGNoYW5nZWQuXG4gICAgaWYgKHRoaXMuZG9tLmZyYW1lKSB7XG4gICAgICAvL25vdCBvbiBpbml0aWFsIHJ1bj9cbiAgICAgIHRoaXMuZm9yY2VHcmFwaFVwZGF0ZSA9IHRydWU7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2NoYW5nZVwiLCB7IHF1ZXVlOiB0cnVlIH0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSGlkZSB0aGUgY29tcG9uZW50IGZyb20gdGhlIERPTVxuICAgKi9cbiAgTGluZUdyYXBoLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHJlbW92ZSB0aGUgZnJhbWUgY29udGFpbmluZyB0aGUgaXRlbXNcbiAgICBpZiAodGhpcy5kb20uZnJhbWUucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5kb20uZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbS5mcmFtZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTaG93IHRoZSBjb21wb25lbnQgaW4gdGhlIERPTSAod2hlbiBub3QgYWxyZWFkeSB2aXNpYmxlKS5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gY2hhbmdlZFxuICAgKi9cbiAgTGluZUdyYXBoLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHNob3cgZnJhbWUgY29udGFpbmluZyB0aGUgaXRlbXNcbiAgICBpZiAoIXRoaXMuZG9tLmZyYW1lLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuYm9keS5kb20uY2VudGVyLmFwcGVuZENoaWxkKHRoaXMuZG9tLmZyYW1lKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBpdGVtc1xuICAgKiBAcGFyYW0ge3Zpcy5EYXRhU2V0IHwgbnVsbH0gaXRlbXNcbiAgICovXG4gIExpbmVHcmFwaC5wcm90b3R5cGUuc2V0SXRlbXMgPSBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgICB2YXIgbWUgPSB0aGlzLFxuICAgICAgICBpZHMsXG4gICAgICAgIG9sZEl0ZW1zRGF0YSA9IHRoaXMuaXRlbXNEYXRhO1xuXG4gICAgLy8gcmVwbGFjZSB0aGUgZGF0YXNldFxuICAgIGlmICghaXRlbXMpIHtcbiAgICAgIHRoaXMuaXRlbXNEYXRhID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGl0ZW1zIGluc3RhbmNlb2YgRGF0YVNldCB8fCBpdGVtcyBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG4gICAgICB0aGlzLml0ZW1zRGF0YSA9IGl0ZW1zO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdEYXRhIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgRGF0YVNldCBvciBEYXRhVmlldycpO1xuICAgIH1cblxuICAgIGlmIChvbGRJdGVtc0RhdGEpIHtcbiAgICAgIC8vIHVuc3Vic2NyaWJlIGZyb20gb2xkIGRhdGFzZXRcbiAgICAgIHV0aWwuZm9yRWFjaCh0aGlzLml0ZW1MaXN0ZW5lcnMsIGZ1bmN0aW9uIChjYWxsYmFjaywgZXZlbnQpIHtcbiAgICAgICAgb2xkSXRlbXNEYXRhLm9mZihldmVudCwgY2FsbGJhY2spO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHJlbW92ZSBhbGwgZHJhd24gaXRlbXNcbiAgICAgIGlkcyA9IG9sZEl0ZW1zRGF0YS5nZXRJZHMoKTtcbiAgICAgIHRoaXMuX29uUmVtb3ZlKGlkcyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXRlbXNEYXRhKSB7XG4gICAgICAvLyBzdWJzY3JpYmUgdG8gbmV3IGRhdGFzZXRcbiAgICAgIHZhciBpZCA9IHRoaXMuaWQ7XG4gICAgICB1dGlsLmZvckVhY2godGhpcy5pdGVtTGlzdGVuZXJzLCBmdW5jdGlvbiAoY2FsbGJhY2ssIGV2ZW50KSB7XG4gICAgICAgIG1lLml0ZW1zRGF0YS5vbihldmVudCwgY2FsbGJhY2ssIGlkKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBhZGQgYWxsIG5ldyBpdGVtc1xuICAgICAgaWRzID0gdGhpcy5pdGVtc0RhdGEuZ2V0SWRzKCk7XG4gICAgICB0aGlzLl9vbkFkZChpZHMpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0IGdyb3Vwc1xuICAgKiBAcGFyYW0ge3Zpcy5EYXRhU2V0fSBncm91cHNcbiAgICovXG4gIExpbmVHcmFwaC5wcm90b3R5cGUuc2V0R3JvdXBzID0gZnVuY3Rpb24gKGdyb3Vwcykge1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdmFyIGlkcztcblxuICAgIC8vIHVuc3Vic2NyaWJlIGZyb20gY3VycmVudCBkYXRhc2V0XG4gICAgaWYgKHRoaXMuZ3JvdXBzRGF0YSkge1xuICAgICAgdXRpbC5mb3JFYWNoKHRoaXMuZ3JvdXBMaXN0ZW5lcnMsIGZ1bmN0aW9uIChjYWxsYmFjaywgZXZlbnQpIHtcbiAgICAgICAgbWUuZ3JvdXBzRGF0YS5vZmYoZXZlbnQsIGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyByZW1vdmUgYWxsIGRyYXduIGdyb3Vwc1xuICAgICAgaWRzID0gdGhpcy5ncm91cHNEYXRhLmdldElkcygpO1xuICAgICAgdGhpcy5ncm91cHNEYXRhID0gbnVsbDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZUdyb3VwKGlkc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVwbGFjZSB0aGUgZGF0YXNldFxuICAgIGlmICghZ3JvdXBzKSB7XG4gICAgICB0aGlzLmdyb3Vwc0RhdGEgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAoZ3JvdXBzIGluc3RhbmNlb2YgRGF0YVNldCB8fCBncm91cHMgaW5zdGFuY2VvZiBEYXRhVmlldykge1xuICAgICAgdGhpcy5ncm91cHNEYXRhID0gZ3JvdXBzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdEYXRhIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgRGF0YVNldCBvciBEYXRhVmlldycpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmdyb3Vwc0RhdGEpIHtcbiAgICAgIC8vIHN1YnNjcmliZSB0byBuZXcgZGF0YXNldFxuICAgICAgdmFyIGlkID0gdGhpcy5pZDtcbiAgICAgIHV0aWwuZm9yRWFjaCh0aGlzLmdyb3VwTGlzdGVuZXJzLCBmdW5jdGlvbiAoY2FsbGJhY2ssIGV2ZW50KSB7XG4gICAgICAgIG1lLmdyb3Vwc0RhdGEub24oZXZlbnQsIGNhbGxiYWNrLCBpZCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gZHJhdyBhbGwgbXNcbiAgICAgIGlkcyA9IHRoaXMuZ3JvdXBzRGF0YS5nZXRJZHMoKTtcbiAgICAgIHRoaXMuX29uQWRkR3JvdXBzKGlkcyk7XG4gICAgfVxuICB9O1xuXG4gIExpbmVHcmFwaC5wcm90b3R5cGUuX29uVXBkYXRlID0gZnVuY3Rpb24gKGlkcykge1xuICAgIHRoaXMuX3VwZGF0ZUFsbEdyb3VwRGF0YSgpO1xuICB9O1xuICBMaW5lR3JhcGgucHJvdG90eXBlLl9vbkFkZCA9IGZ1bmN0aW9uIChpZHMpIHtcbiAgICB0aGlzLl9vblVwZGF0ZShpZHMpO1xuICB9O1xuICBMaW5lR3JhcGgucHJvdG90eXBlLl9vblJlbW92ZSA9IGZ1bmN0aW9uIChpZHMpIHtcbiAgICB0aGlzLl9vblVwZGF0ZShpZHMpO1xuICB9O1xuICBMaW5lR3JhcGgucHJvdG90eXBlLl9vblVwZGF0ZUdyb3VwcyA9IGZ1bmN0aW9uIChncm91cElkcykge1xuICAgIHRoaXMuX3VwZGF0ZUFsbEdyb3VwRGF0YSgpO1xuICB9O1xuICBMaW5lR3JhcGgucHJvdG90eXBlLl9vbkFkZEdyb3VwcyA9IGZ1bmN0aW9uIChncm91cElkcykge1xuICAgIHRoaXMuX29uVXBkYXRlR3JvdXBzKGdyb3VwSWRzKTtcbiAgfTtcblxuICAvKipcbiAgICogdGhpcyBjbGVhbnMgdGhlIGdyb3VwIG91dCBvZmYgdGhlIGxlZ2VuZHMgYW5kIHRoZSBkYXRhYXhpcywgdXBkYXRlcyB0aGUgdW5ncm91cGVkIGFuZCB1cGRhdGVzIHRoZSBncmFwaFxuICAgKiBAcGFyYW0ge0FycmF5fSBncm91cElkc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTGluZUdyYXBoLnByb3RvdHlwZS5fb25SZW1vdmVHcm91cHMgPSBmdW5jdGlvbiAoZ3JvdXBJZHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9yZW1vdmVHcm91cChncm91cElkc1tpXSk7XG4gICAgfVxuICAgIHRoaXMuZm9yY2VHcmFwaFVwZGF0ZSA9IHRydWU7XG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9jaGFuZ2VcIiwgeyBxdWV1ZTogdHJ1ZSB9KTtcbiAgfTtcblxuICAvKipcbiAgICogdGhpcyBjbGVhbnMgdGhlIGdyb3VwIG91dCBvZmYgdGhlIGxlZ2VuZHMgYW5kIHRoZSBkYXRhYXhpc1xuICAgKiBAcGFyYW0gZ3JvdXBJZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTGluZUdyYXBoLnByb3RvdHlwZS5fcmVtb3ZlR3JvdXAgPSBmdW5jdGlvbiAoZ3JvdXBJZCkge1xuICAgIGlmICh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShncm91cElkKSkge1xuICAgICAgaWYgKHRoaXMuZ3JvdXBzW2dyb3VwSWRdLm9wdGlvbnMueUF4aXNPcmllbnRhdGlvbiA9PSAncmlnaHQnKSB7XG4gICAgICAgIHRoaXMueUF4aXNSaWdodC5yZW1vdmVHcm91cChncm91cElkKTtcbiAgICAgICAgdGhpcy5sZWdlbmRSaWdodC5yZW1vdmVHcm91cChncm91cElkKTtcbiAgICAgICAgdGhpcy5sZWdlbmRSaWdodC5yZWRyYXcoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMueUF4aXNMZWZ0LnJlbW92ZUdyb3VwKGdyb3VwSWQpO1xuICAgICAgICB0aGlzLmxlZ2VuZExlZnQucmVtb3ZlR3JvdXAoZ3JvdXBJZCk7XG4gICAgICAgIHRoaXMubGVnZW5kTGVmdC5yZWRyYXcoKTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSB0aGlzLmdyb3Vwc1tncm91cElkXTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIHVwZGF0ZSBhIGdyb3VwIG9iamVjdCB3aXRoIHRoZSBncm91cCBkYXRhc2V0IGVudHJlZVxuICAgKlxuICAgKiBAcGFyYW0gZ3JvdXBcbiAgICogQHBhcmFtIGdyb3VwSWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIExpbmVHcmFwaC5wcm90b3R5cGUuX3VwZGF0ZUdyb3VwID0gZnVuY3Rpb24gKGdyb3VwLCBncm91cElkKSB7XG4gICAgaWYgKCF0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShncm91cElkKSkge1xuICAgICAgdGhpcy5ncm91cHNbZ3JvdXBJZF0gPSBuZXcgR3JhcGhHcm91cChncm91cCwgZ3JvdXBJZCwgdGhpcy5vcHRpb25zLCB0aGlzLmdyb3Vwc1VzaW5nRGVmYXVsdFN0eWxlcyk7XG4gICAgICBpZiAodGhpcy5ncm91cHNbZ3JvdXBJZF0ub3B0aW9ucy55QXhpc09yaWVudGF0aW9uID09ICdyaWdodCcpIHtcbiAgICAgICAgdGhpcy55QXhpc1JpZ2h0LmFkZEdyb3VwKGdyb3VwSWQsIHRoaXMuZ3JvdXBzW2dyb3VwSWRdKTtcbiAgICAgICAgdGhpcy5sZWdlbmRSaWdodC5hZGRHcm91cChncm91cElkLCB0aGlzLmdyb3Vwc1tncm91cElkXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnlBeGlzTGVmdC5hZGRHcm91cChncm91cElkLCB0aGlzLmdyb3Vwc1tncm91cElkXSk7XG4gICAgICAgIHRoaXMubGVnZW5kTGVmdC5hZGRHcm91cChncm91cElkLCB0aGlzLmdyb3Vwc1tncm91cElkXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwSWRdLnVwZGF0ZShncm91cCk7XG4gICAgICBpZiAodGhpcy5ncm91cHNbZ3JvdXBJZF0ub3B0aW9ucy55QXhpc09yaWVudGF0aW9uID09ICdyaWdodCcpIHtcbiAgICAgICAgdGhpcy55QXhpc1JpZ2h0LnVwZGF0ZUdyb3VwKGdyb3VwSWQsIHRoaXMuZ3JvdXBzW2dyb3VwSWRdKTtcbiAgICAgICAgdGhpcy5sZWdlbmRSaWdodC51cGRhdGVHcm91cChncm91cElkLCB0aGlzLmdyb3Vwc1tncm91cElkXSk7XG4gICAgICAgIC8vSWYgeUF4aXNPcmllbnRhdGlvbiBjaGFuZ2VkLCBjbGVhbiBvdXQgdGhlIGdyb3VwIGZyb20gdGhlIG90aGVyIGF4aXMuXG4gICAgICAgIHRoaXMueUF4aXNMZWZ0LnJlbW92ZUdyb3VwKGdyb3VwSWQpO1xuICAgICAgICB0aGlzLmxlZ2VuZExlZnQucmVtb3ZlR3JvdXAoZ3JvdXBJZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnlBeGlzTGVmdC51cGRhdGVHcm91cChncm91cElkLCB0aGlzLmdyb3Vwc1tncm91cElkXSk7XG4gICAgICAgIHRoaXMubGVnZW5kTGVmdC51cGRhdGVHcm91cChncm91cElkLCB0aGlzLmdyb3Vwc1tncm91cElkXSk7XG4gICAgICAgIC8vSWYgeUF4aXNPcmllbnRhdGlvbiBjaGFuZ2VkLCBjbGVhbiBvdXQgdGhlIGdyb3VwIGZyb20gdGhlIG90aGVyIGF4aXMuXG4gICAgICAgIHRoaXMueUF4aXNSaWdodC5yZW1vdmVHcm91cChncm91cElkKTtcbiAgICAgICAgdGhpcy5sZWdlbmRSaWdodC5yZW1vdmVHcm91cChncm91cElkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5sZWdlbmRMZWZ0LnJlZHJhdygpO1xuICAgIHRoaXMubGVnZW5kUmlnaHQucmVkcmF3KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIHRoaXMgdXBkYXRlcyBhbGwgZ3JvdXBzLCBpdCBpcyB1c2VkIHdoZW4gdGhlcmUgaXMgYW4gdXBkYXRlIHRoZSB0aGUgaXRlbXNldC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIExpbmVHcmFwaC5wcm90b3R5cGUuX3VwZGF0ZUFsbEdyb3VwRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pdGVtc0RhdGEgIT0gbnVsbCkge1xuICAgICAgdmFyIGdyb3Vwc0NvbnRlbnQgPSB7fTtcbiAgICAgIHZhciBpdGVtcyA9IHRoaXMuaXRlbXNEYXRhLmdldCgpO1xuICAgICAgLy9wcmUtRGV0ZXJtaW5lIGFycmF5IHNpemVzLCBmb3IgbW9yZSBlZmZpY2llbnQgbWVtb3J5IGNsYWltXG4gICAgICB2YXIgZ3JvdXBDb3VudHMgPSB7fTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgdmFyIGdyb3VwSWQgPSBpdGVtLmdyb3VwO1xuICAgICAgICBpZiAoZ3JvdXBJZCA9PT0gbnVsbCB8fCBncm91cElkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBncm91cElkID0gVU5HUk9VUEVEO1xuICAgICAgICB9XG4gICAgICAgIGdyb3VwQ291bnRzLmhhc093blByb3BlcnR5KGdyb3VwSWQpID8gZ3JvdXBDb3VudHNbZ3JvdXBJZF0rKyA6IGdyb3VwQ291bnRzW2dyb3VwSWRdID0gMTtcbiAgICAgIH1cbiAgICAgIC8vTm93IGluc2VydCBkYXRhIGludG8gdGhlIGFycmF5cy5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgdmFyIGdyb3VwSWQgPSBpdGVtLmdyb3VwO1xuICAgICAgICBpZiAoZ3JvdXBJZCA9PT0gbnVsbCB8fCBncm91cElkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBncm91cElkID0gVU5HUk9VUEVEO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZ3JvdXBzQ29udGVudC5oYXNPd25Qcm9wZXJ0eShncm91cElkKSkge1xuICAgICAgICAgIGdyb3Vwc0NvbnRlbnRbZ3JvdXBJZF0gPSBuZXcgQXJyYXkoZ3JvdXBDb3VudHNbZ3JvdXBJZF0pO1xuICAgICAgICB9XG4gICAgICAgIC8vQ29weSBkYXRhIChiZWNhdXNlIG9mIHVubW9kaWZpYWJsZSBEYXRhVmlldyBpbnB1dC5cbiAgICAgICAgdmFyIGV4dGVuZGVkID0gdXRpbC5icmlkZ2VPYmplY3QoaXRlbSk7XG4gICAgICAgIGV4dGVuZGVkLnggPSB1dGlsLmNvbnZlcnQoaXRlbS54LCAnRGF0ZScpO1xuICAgICAgICBleHRlbmRlZC5vcmdpbmFsWSA9IGl0ZW0ueTsgLy9yZWFsIFlcbiAgICAgICAgZXh0ZW5kZWQueSA9IE51bWJlcihpdGVtLnkpO1xuXG4gICAgICAgIHZhciBpbmRleCA9IGdyb3Vwc0NvbnRlbnRbZ3JvdXBJZF0ubGVuZ3RoIC0gZ3JvdXBDb3VudHNbZ3JvdXBJZF0tLTtcbiAgICAgICAgZ3JvdXBzQ29udGVudFtncm91cElkXVtpbmRleF0gPSBleHRlbmRlZDtcbiAgICAgIH1cblxuICAgICAgLy9NYWtlIHN1cmUgYWxsIGdyb3VwcyBhcmUgcHJlc2VudCwgdG8gYWxsb3cgcmVtb3ZhbCBvZiBvbGQgZ3JvdXBzXG4gICAgICBmb3IgKHZhciBncm91cElkIGluIHRoaXMuZ3JvdXBzKSB7XG4gICAgICAgIGlmICh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShncm91cElkKSkge1xuICAgICAgICAgIGlmICghZ3JvdXBzQ29udGVudC5oYXNPd25Qcm9wZXJ0eShncm91cElkKSkge1xuICAgICAgICAgICAgZ3JvdXBzQ29udGVudFtncm91cElkXSA9IG5ldyBBcnJheSgwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy9VcGRhdGUgbGVnZW5kYXMsIHN0eWxlIGFuZCBheGlzXG4gICAgICBmb3IgKHZhciBncm91cElkIGluIGdyb3Vwc0NvbnRlbnQpIHtcbiAgICAgICAgaWYgKGdyb3Vwc0NvbnRlbnQuaGFzT3duUHJvcGVydHkoZ3JvdXBJZCkpIHtcbiAgICAgICAgICBpZiAoZ3JvdXBzQ29udGVudFtncm91cElkXS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KGdyb3VwSWQpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUdyb3VwKGdyb3VwSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodGhpcy5ncm91cHNEYXRhICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBncm91cCA9IHRoaXMuZ3JvdXBzRGF0YS5nZXQoZ3JvdXBJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGdyb3VwID0geyBpZDogZ3JvdXBJZCwgY29udGVudDogdGhpcy5vcHRpb25zLmRlZmF1bHRHcm91cCArIGdyb3VwSWQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUdyb3VwKGdyb3VwLCBncm91cElkKTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwSWRdLnNldEl0ZW1zKGdyb3Vwc0NvbnRlbnRbZ3JvdXBJZF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5mb3JjZUdyYXBoVXBkYXRlID0gdHJ1ZTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfY2hhbmdlXCIsIHsgcXVldWU6IHRydWUgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZWRyYXcgdGhlIGNvbXBvbmVudCwgbWFuZGF0b3J5IGZ1bmN0aW9uXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgY29tcG9uZW50IGlzIHJlc2l6ZWRcbiAgICovXG4gIExpbmVHcmFwaC5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXNpemVkID0gZmFsc2U7XG5cbiAgICAvLyBjYWxjdWxhdGUgYWN0dWFsIHNpemUgYW5kIHBvc2l0aW9uXG4gICAgdGhpcy5wcm9wcy53aWR0aCA9IHRoaXMuZG9tLmZyYW1lLm9mZnNldFdpZHRoO1xuICAgIHRoaXMucHJvcHMuaGVpZ2h0ID0gdGhpcy5ib2R5LmRvbVByb3BzLmNlbnRlckNvbnRhaW5lci5oZWlnaHQgLSB0aGlzLmJvZHkuZG9tUHJvcHMuYm9yZGVyLnRvcCAtIHRoaXMuYm9keS5kb21Qcm9wcy5ib3JkZXIuYm90dG9tO1xuXG4gICAgLy8gY2hlY2sgaWYgdGhpcyBjb21wb25lbnQgaXMgcmVzaXplZFxuICAgIHJlc2l6ZWQgPSB0aGlzLl9pc1Jlc2l6ZWQoKSB8fCByZXNpemVkO1xuXG4gICAgLy8gY2hlY2sgd2hldGhlciB6b29tZWQgKGluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIHJlLXN0YWNrIGV2ZXJ5dGhpbmcpXG4gICAgdmFyIHZpc2libGVJbnRlcnZhbCA9IHRoaXMuYm9keS5yYW5nZS5lbmQgLSB0aGlzLmJvZHkucmFuZ2Uuc3RhcnQ7XG4gICAgdmFyIHpvb21lZCA9IHZpc2libGVJbnRlcnZhbCAhPSB0aGlzLmxhc3RWaXNpYmxlSW50ZXJ2YWw7XG4gICAgdGhpcy5sYXN0VmlzaWJsZUludGVydmFsID0gdmlzaWJsZUludGVydmFsO1xuXG4gICAgLy8gdGhlIHN2ZyBlbGVtZW50IGlzIHRocmVlIHRpbWVzIGFzIGJpZyBhcyB0aGUgd2lkdGgsIHRoaXMgYWxsb3dzIGZvciBmdWxseSBkcmFnZ2luZyBsZWZ0IGFuZCByaWdodFxuICAgIC8vIHdpdGhvdXQgcmVsb2FkaW5nIHRoZSBncmFwaC4gdGhlIGNvbnRyb2xzIGZvciB0aGlzIGFyZSBib3VuZCB0byBldmVudHMgaW4gdGhlIGNvbnN0cnVjdG9yXG4gICAgaWYgKHJlc2l6ZWQgPT0gdHJ1ZSkge1xuICAgICAgdGhpcy5zdmcuc3R5bGUud2lkdGggPSB1dGlsLm9wdGlvbi5hc1NpemUoMyAqIHRoaXMucHJvcHMud2lkdGgpO1xuICAgICAgdGhpcy5zdmcuc3R5bGUubGVmdCA9IHV0aWwub3B0aW9uLmFzU2l6ZSgtdGhpcy5wcm9wcy53aWR0aCk7XG5cbiAgICAgIC8vIGlmIHRoZSBoZWlnaHQgb2YgdGhlIGdyYXBoIGlzIHNldCBhcyBwcm9wb3J0aW9uYWwsIGNoYW5nZSB0aGUgaGVpZ2h0IG9mIHRoZSBzdmdcbiAgICAgIGlmICgodGhpcy5vcHRpb25zLmhlaWdodCArICcnKS5pbmRleE9mKFwiJVwiKSAhPSAtMSB8fCB0aGlzLnVwZGF0ZVNWR2hlaWdodE9uUmVzaXplID09IHRydWUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVTVkdoZWlnaHQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHVwZGF0ZSB0aGUgaGVpZ2h0IG9mIHRoZSBncmFwaCBvbiBlYWNoIHJlZHJhdyBvZiB0aGUgZ3JhcGguXG4gICAgaWYgKHRoaXMudXBkYXRlU1ZHaGVpZ2h0ID09IHRydWUpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZ3JhcGhIZWlnaHQgIT0gdGhpcy5wcm9wcy5oZWlnaHQgKyAncHgnKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5ncmFwaEhlaWdodCA9IHRoaXMucHJvcHMuaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgdGhpcy5zdmcuc3R5bGUuaGVpZ2h0ID0gdGhpcy5wcm9wcy5oZWlnaHQgKyAncHgnO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVTVkdoZWlnaHQgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdmcuc3R5bGUuaGVpZ2h0ID0gKCcnICsgdGhpcy5vcHRpb25zLmdyYXBoSGVpZ2h0KS5yZXBsYWNlKCdweCcsICcnKSArICdweCc7XG4gICAgfVxuXG4gICAgLy8gem9vbWVkIGlzIGhlcmUgdG8gZW5zdXJlIHRoYXQgYW5pbWF0aW9ucyBhcmUgc2hvd24gY29ycmVjdGx5LlxuICAgIGlmIChyZXNpemVkID09IHRydWUgfHwgem9vbWVkID09IHRydWUgfHwgdGhpcy5hYm9ydGVkR3JhcGhVcGRhdGUgPT0gdHJ1ZSB8fCB0aGlzLmZvcmNlR3JhcGhVcGRhdGUgPT0gdHJ1ZSkge1xuICAgICAgcmVzaXplZCA9IHRoaXMuX3VwZGF0ZUdyYXBoKCkgfHwgcmVzaXplZDtcbiAgICAgIHRoaXMuZm9yY2VHcmFwaFVwZGF0ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBtb3ZlIHRoZSB3aG9sZSBzdmcgd2hpbGUgZHJhZ2dpbmdcbiAgICAgIGlmICh0aGlzLmxhc3RTdGFydCAhPSAwKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLmJvZHkucmFuZ2Uuc3RhcnQgLSB0aGlzLmxhc3RTdGFydDtcbiAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5ib2R5LnJhbmdlLmVuZCAtIHRoaXMuYm9keS5yYW5nZS5zdGFydDtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMud2lkdGggIT0gMCkge1xuICAgICAgICAgIHZhciByYW5nZVBlclBpeGVsSW52ID0gdGhpcy5wcm9wcy53aWR0aCAvIHJhbmdlO1xuICAgICAgICAgIHZhciB4T2Zmc2V0ID0gb2Zmc2V0ICogcmFuZ2VQZXJQaXhlbEludjtcbiAgICAgICAgICB0aGlzLnN2Zy5zdHlsZS5sZWZ0ID0gLXRoaXMucHJvcHMud2lkdGggLSB4T2Zmc2V0ICsgJ3B4JztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxlZ2VuZExlZnQucmVkcmF3KCk7XG4gICAgdGhpcy5sZWdlbmRSaWdodC5yZWRyYXcoKTtcbiAgICByZXR1cm4gcmVzaXplZDtcbiAgfTtcblxuICBMaW5lR3JhcGgucHJvdG90eXBlLl9nZXRTb3J0ZWRHcm91cElkcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBnZXR0aW5nIGdyb3VwIElkc1xuICAgIHZhciBncm91cGxpc3QgPSBbXTtcbiAgICBmb3IgKHZhciBncm91cElkIGluIHRoaXMuZ3JvdXBzKSB7XG4gICAgICBpZiAodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkoZ3JvdXBJZCkpIHtcbiAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cHNbZ3JvdXBJZF07XG4gICAgICAgIGlmIChncm91cC52aXNpYmxlID09IHRydWUgJiYgKHRoaXMub3B0aW9ucy5ncm91cHMudmlzaWJpbGl0eVtncm91cElkXSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMub3B0aW9ucy5ncm91cHMudmlzaWJpbGl0eVtncm91cElkXSA9PSB0cnVlKSkge1xuICAgICAgICAgIGdyb3VwbGlzdC5wdXNoKHsgaWQ6IGdyb3VwSWQsIHpJbmRleDogZ3JvdXAub3B0aW9ucy56SW5kZXggfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdXRpbC5pbnNlcnRTb3J0KGdyb3VwbGlzdCwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHZhciBheiA9IGEuekluZGV4O1xuICAgICAgdmFyIGJ6ID0gYi56SW5kZXg7XG4gICAgICBpZiAoYXogPT09IHVuZGVmaW5lZCkgYXogPSAwO1xuICAgICAgaWYgKGJ6ID09PSB1bmRlZmluZWQpIGJ6ID0gMDtcbiAgICAgIHJldHVybiBheiA9PSBieiA/IDAgOiBheiA8IGJ6ID8gLTEgOiAxO1xuICAgIH0pO1xuICAgIHZhciBncm91cElkcyA9IG5ldyBBcnJheShncm91cGxpc3QubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgZ3JvdXBJZHNbaV0gPSBncm91cGxpc3RbaV0uaWQ7XG4gICAgfVxuICAgIHJldHVybiBncm91cElkcztcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIGFuZCByZWRyYXcgdGhlIGdyYXBoLlxuICAgKlxuICAgKi9cbiAgTGluZUdyYXBoLnByb3RvdHlwZS5fdXBkYXRlR3JhcGggPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gcmVzZXQgdGhlIHN2ZyBlbGVtZW50c1xuICAgIERPTXV0aWwucHJlcGFyZUVsZW1lbnRzKHRoaXMuc3ZnRWxlbWVudHMpO1xuICAgIGlmICh0aGlzLnByb3BzLndpZHRoICE9IDAgJiYgdGhpcy5pdGVtc0RhdGEgIT0gbnVsbCkge1xuICAgICAgdmFyIGdyb3VwLCBpO1xuICAgICAgdmFyIGdyb3VwUmFuZ2VzID0ge307XG4gICAgICB2YXIgY2hhbmdlQ2FsbGVkID0gZmFsc2U7XG4gICAgICAvLyB0aGlzIGlzIHRoZSByYW5nZSBvZiB0aGUgU1ZHIGNhbnZhc1xuICAgICAgdmFyIG1pbkRhdGUgPSB0aGlzLmJvZHkudXRpbC50b0dsb2JhbFRpbWUoLXRoaXMuYm9keS5kb21Qcm9wcy5yb290LndpZHRoKTtcbiAgICAgIHZhciBtYXhEYXRlID0gdGhpcy5ib2R5LnV0aWwudG9HbG9iYWxUaW1lKDIgKiB0aGlzLmJvZHkuZG9tUHJvcHMucm9vdC53aWR0aCk7XG5cbiAgICAgIC8vIGdldHRpbmcgZ3JvdXAgSWRzXG4gICAgICB2YXIgZ3JvdXBJZHMgPSB0aGlzLl9nZXRTb3J0ZWRHcm91cElkcygpO1xuICAgICAgaWYgKGdyb3VwSWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGdyb3Vwc0RhdGEgPSB7fTtcblxuICAgICAgICAvLyBmaWxsIGdyb3VwcyBkYXRhLCB0aGlzIG9ubHkgbG9hZHMgdGhlIGRhdGEgd2UgcmVxdWlyZSBiYXNlZCBvbiB0aGUgdGltZXdpbmRvd1xuICAgICAgICB0aGlzLl9nZXRSZWxldmFudERhdGEoZ3JvdXBJZHMsIGdyb3Vwc0RhdGEsIG1pbkRhdGUsIG1heERhdGUpO1xuXG4gICAgICAgIC8vIGFwcGx5IHNhbXBsaW5nLCBpZiBkaXNhYmxlZCwgaXQgd2lsbCBwYXNzIHRocm91Z2ggdGhpcyBmdW5jdGlvbi5cbiAgICAgICAgdGhpcy5fYXBwbHlTYW1wbGluZyhncm91cElkcywgZ3JvdXBzRGF0YSk7XG5cbiAgICAgICAgLy8gd2UgdHJhbnNmb3JtIHRoZSBYIGNvb3JkaW5hdGVzIHRvIGRldGVjdCBjb2xsaXNpb25zXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBncm91cElkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuX2NvbnZlcnRYY29vcmRpbmF0ZXMoZ3JvdXBzRGF0YVtncm91cElkc1tpXV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm93IGFsbCBuZWVkZWQgZGF0YSBoYXMgYmVlbiBjb2xsZWN0ZWQgd2Ugc3RhcnQgdGhlIHByb2Nlc3NpbmcuXG4gICAgICAgIHRoaXMuX2dldFlSYW5nZXMoZ3JvdXBJZHMsIGdyb3Vwc0RhdGEsIGdyb3VwUmFuZ2VzKTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIFkgYXhpcyBmaXJzdCwgd2UgdXNlIHRoaXMgZGF0YSB0byBkcmF3IGF0IHRoZSBjb3JyZWN0IFkgcG9pbnRzXG4gICAgICAgIGNoYW5nZUNhbGxlZCA9IHRoaXMuX3VwZGF0ZVlBeGlzKGdyb3VwSWRzLCBncm91cFJhbmdlcyk7XG5cbiAgICAgICAgLy8gIGF0IGNoYW5nZUNhbGxlZCwgYWJvcnQgdGhpcyB1cGRhdGUgY3ljbGUgYXMgdGhlIGdyYXBoIG5lZWRzIGFub3RoZXIgdXBkYXRlIHdpdGggbmV3IFdpZHRoIGlucHV0IGZyb20gdGhlIFJlZHJhdyBjb250YWluZXIuXG4gICAgICAgIC8vICBDbGVhbnVwIFNWRyBlbGVtZW50cyBvbiBhYm9ydC5cbiAgICAgICAgaWYgKGNoYW5nZUNhbGxlZCA9PSB0cnVlKSB7XG4gICAgICAgICAgRE9NdXRpbC5jbGVhbnVwRWxlbWVudHModGhpcy5zdmdFbGVtZW50cyk7XG4gICAgICAgICAgdGhpcy5hYm9ydGVkR3JhcGhVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWJvcnRlZEdyYXBoVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgICAgLy8gV2l0aCB0aGUgeUF4aXMgc2NhbGVkIGNvcnJlY3RseSwgdXNlIHRoaXMgdG8gZ2V0IHRoZSBZIHZhbHVlcyBvZiB0aGUgcG9pbnRzLlxuICAgICAgICB2YXIgYmVsb3cgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBncm91cElkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGdyb3VwID0gdGhpcy5ncm91cHNbZ3JvdXBJZHNbaV1dO1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RhY2sgPT09IHRydWUgJiYgdGhpcy5vcHRpb25zLnN0eWxlID09PSAnbGluZScpIHtcbiAgICAgICAgICAgIGlmIChncm91cC5vcHRpb25zLmV4Y2x1ZGVGcm9tU3RhY2tpbmcgPT0gdW5kZWZpbmVkIHx8ICFncm91cC5vcHRpb25zLmV4Y2x1ZGVGcm9tU3RhY2tpbmcpIHtcbiAgICAgICAgICAgICAgaWYgKGJlbG93ICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrKGdyb3Vwc0RhdGFbZ3JvdXAuaWRdLCBncm91cHNEYXRhW2JlbG93LmlkXSk7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwLm9wdGlvbnMuc2hhZGVkLmVuYWJsZWQgPT0gdHJ1ZSAmJiBncm91cC5vcHRpb25zLnNoYWRlZC5vcmllbnRhdGlvbiAhPT0gXCJncm91cFwiKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZ3JvdXAub3B0aW9ucy5zaGFkZWQub3JpZW50YXRpb24gPT0gXCJ0b3BcIiAmJiBiZWxvdy5vcHRpb25zLnNoYWRlZC5vcmllbnRhdGlvbiAhPT0gXCJncm91cFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlbG93Lm9wdGlvbnMuc2hhZGVkLm9yaWVudGF0aW9uID0gXCJncm91cFwiO1xuICAgICAgICAgICAgICAgICAgICBiZWxvdy5vcHRpb25zLnNoYWRlZC5ncm91cElkID0gZ3JvdXAuaWQ7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBncm91cC5vcHRpb25zLnNoYWRlZC5vcmllbnRhdGlvbiA9IFwiZ3JvdXBcIjtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAub3B0aW9ucy5zaGFkZWQuZ3JvdXBJZCA9IGJlbG93LmlkO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBiZWxvdyA9IGdyb3VwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9jb252ZXJ0WWNvb3JkaW5hdGVzKGdyb3Vwc0RhdGFbZ3JvdXBJZHNbaV1dLCBncm91cCk7XG4gICAgICAgIH1cblxuICAgICAgICAvL1ByZWNhbGN1bGF0ZSBwYXRocyBhbmQgZHJhdyBzaGFkaW5nIGlmIGFwcHJvcHJpYXRlLiBUaGlzIHdpbGwgbWFrZSBzdXJlIHRoZSBzaGFkaW5nIGlzIGFsd2F5cyBiZWhpbmQgYW55IGxpbmVzLlxuICAgICAgICB2YXIgcGF0aHMgPSB7fTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGdyb3VwSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZ3JvdXAgPSB0aGlzLmdyb3Vwc1tncm91cElkc1tpXV07XG4gICAgICAgICAgaWYgKGdyb3VwLm9wdGlvbnMuc3R5bGUgPT09ICdsaW5lJyAmJiBncm91cC5vcHRpb25zLnNoYWRlZC5lbmFibGVkID09IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBkYXRhc2V0ID0gZ3JvdXBzRGF0YVtncm91cElkc1tpXV07XG4gICAgICAgICAgICBpZiAoZGF0YXNldCA9PSBudWxsIHx8IGRhdGFzZXQubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXBhdGhzLmhhc093blByb3BlcnR5KGdyb3VwSWRzW2ldKSkge1xuICAgICAgICAgICAgICBwYXRoc1tncm91cElkc1tpXV0gPSBMaW5lcy5jYWxjUGF0aChkYXRhc2V0LCBncm91cCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JvdXAub3B0aW9ucy5zaGFkZWQub3JpZW50YXRpb24gPT09IFwiZ3JvdXBcIikge1xuICAgICAgICAgICAgICB2YXIgc3ViR3JvdXBJZCA9IGdyb3VwLm9wdGlvbnMuc2hhZGVkLmdyb3VwSWQ7XG4gICAgICAgICAgICAgIGlmIChncm91cElkcy5pbmRleE9mKHN1Ykdyb3VwSWQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGdyb3VwLmlkICsgXCI6IFVua25vd24gc2hhZGluZyBncm91cCB0YXJnZXQgZ2l2ZW46XCIgKyBzdWJHcm91cElkKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIXBhdGhzLmhhc093blByb3BlcnR5KHN1Ykdyb3VwSWQpKSB7XG4gICAgICAgICAgICAgICAgcGF0aHNbc3ViR3JvdXBJZF0gPSBMaW5lcy5jYWxjUGF0aChncm91cHNEYXRhW3N1Ykdyb3VwSWRdLCB0aGlzLmdyb3Vwc1tzdWJHcm91cElkXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgTGluZXMuZHJhd1NoYWRpbmcocGF0aHNbZ3JvdXBJZHNbaV1dLCBncm91cCwgcGF0aHNbc3ViR3JvdXBJZF0sIHRoaXMuZnJhbWV3b3JrKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIExpbmVzLmRyYXdTaGFkaW5nKHBhdGhzW2dyb3VwSWRzW2ldXSwgZ3JvdXAsIHVuZGVmaW5lZCwgdGhpcy5mcmFtZXdvcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRyYXcgdGhlIGdyb3VwcywgY2FsY3VsYXRpbmcgcGF0aHMgaWYgc3RpbGwgbmVjZXNzYXJ5LlxuICAgICAgICBCYXJzLmRyYXcoZ3JvdXBJZHMsIGdyb3Vwc0RhdGEsIHRoaXMuZnJhbWV3b3JrKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGdyb3VwSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZ3JvdXAgPSB0aGlzLmdyb3Vwc1tncm91cElkc1tpXV07XG4gICAgICAgICAgaWYgKGdyb3Vwc0RhdGFbZ3JvdXBJZHNbaV1dLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZ3JvdXAub3B0aW9ucy5zdHlsZSkge1xuICAgICAgICAgICAgICBjYXNlIFwibGluZVwiOlxuICAgICAgICAgICAgICAgIGlmICghcGF0aHMuaGFzT3duUHJvcGVydHkoZ3JvdXBJZHNbaV0pKSB7XG4gICAgICAgICAgICAgICAgICBwYXRoc1tncm91cElkc1tpXV0gPSBMaW5lcy5jYWxjUGF0aChncm91cHNEYXRhW2dyb3VwSWRzW2ldXSwgZ3JvdXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBMaW5lcy5kcmF3KHBhdGhzW2dyb3VwSWRzW2ldXSwgZ3JvdXAsIHRoaXMuZnJhbWV3b3JrKTtcbiAgICAgICAgICAgICAgLy9leHBsaWNpdCBubyBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcInBvaW50XCI6XG4gICAgICAgICAgICAgIC8vZXhwbGljaXQgbm8gYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJwb2ludHNcIjpcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXAub3B0aW9ucy5zdHlsZSA9PSBcInBvaW50XCIgfHwgZ3JvdXAub3B0aW9ucy5zdHlsZSA9PSBcInBvaW50c1wiIHx8IGdyb3VwLm9wdGlvbnMuZHJhd1BvaW50cy5lbmFibGVkID09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIFBvaW50cy5kcmF3KGdyb3Vwc0RhdGFbZ3JvdXBJZHNbaV1dLCBncm91cCwgdGhpcy5mcmFtZXdvcmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImJhclwiOlxuICAgICAgICAgICAgICAvLyBiYXIgbmVlZHMgdG8gYmUgZHJhd24gZW5tYXNzZVxuICAgICAgICAgICAgICAvL2V4cGxpY2l0IG5vIGJyZWFrXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vZG8gbm90aGluZy4uLlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNsZWFudXAgdW51c2VkIHN2ZyBlbGVtZW50c1xuICAgIERPTXV0aWwuY2xlYW51cEVsZW1lbnRzKHRoaXMuc3ZnRWxlbWVudHMpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBMaW5lR3JhcGgucHJvdG90eXBlLl9zdGFjayA9IGZ1bmN0aW9uIChkYXRhLCBzdWJEYXRhKSB7XG4gICAgdmFyIGluZGV4LCBkeCwgZHksIHN1YlByZXZQb2ludCwgc3ViTmV4dFBvaW50O1xuICAgIGluZGV4ID0gMDtcbiAgICAvLyBmb3IgZWFjaCBkYXRhIHBvaW50IHdlIGxvb2sgZm9yIGEgbWF0Y2hpbmcgb24gaW4gdGhlIHNldCBiZWxvd1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGF0YS5sZW5ndGg7IGorKykge1xuICAgICAgc3ViUHJldlBvaW50ID0gdW5kZWZpbmVkO1xuICAgICAgc3ViTmV4dFBvaW50ID0gdW5kZWZpbmVkO1xuICAgICAgLy8gd2UgbG9vayBmb3IgdGltZSBtYXRjaGVzIG9yIGEgYmVmb3JlLWFmdGVyIHBvaW50XG4gICAgICBmb3IgKHZhciBrID0gaW5kZXg7IGsgPCBzdWJEYXRhLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIC8vIGlmIHRpbWVzIG1hdGNoIGV4YWN0bHlcbiAgICAgICAgaWYgKHN1YkRhdGFba10ueCA9PT0gZGF0YVtqXS54KSB7XG4gICAgICAgICAgc3ViUHJldlBvaW50ID0gc3ViRGF0YVtrXTtcbiAgICAgICAgICBzdWJOZXh0UG9pbnQgPSBzdWJEYXRhW2tdO1xuICAgICAgICAgIGluZGV4ID0gaztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmIChzdWJEYXRhW2tdLnggPiBkYXRhW2pdLngpIHtcbiAgICAgICAgICAvLyBvdmVyc2hvb3RcbiAgICAgICAgICBzdWJOZXh0UG9pbnQgPSBzdWJEYXRhW2tdO1xuICAgICAgICAgIGlmIChrID09IDApIHtcbiAgICAgICAgICAgIHN1YlByZXZQb2ludCA9IHN1Yk5leHRQb2ludDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3ViUHJldlBvaW50ID0gc3ViRGF0YVtrIC0gMV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGluZGV4ID0gaztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gaW4gY2FzZSB0aGUgbGFzdCBkYXRhIHBvaW50IGhhcyBiZWVuIHVzZWQsIHdlIGFzc3VtZSBpdCBzdGF5cyBsaWtlIHRoaXMuXG4gICAgICBpZiAoc3ViTmV4dFBvaW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3ViUHJldlBvaW50ID0gc3ViRGF0YVtzdWJEYXRhLmxlbmd0aCAtIDFdO1xuICAgICAgICBzdWJOZXh0UG9pbnQgPSBzdWJEYXRhW3N1YkRhdGEubGVuZ3RoIC0gMV07XG4gICAgICB9XG4gICAgICAvLyBsaW5lYXIgaW50ZXJwb2xhdGlvblxuICAgICAgZHggPSBzdWJOZXh0UG9pbnQueCAtIHN1YlByZXZQb2ludC54O1xuICAgICAgZHkgPSBzdWJOZXh0UG9pbnQueSAtIHN1YlByZXZQb2ludC55O1xuICAgICAgaWYgKGR4ID09IDApIHtcbiAgICAgICAgZGF0YVtqXS55ID0gZGF0YVtqXS5vcmdpbmFsWSArIHN1Yk5leHRQb2ludC55O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YVtqXS55ID0gZGF0YVtqXS5vcmdpbmFsWSArIGR5IC8gZHggKiAoZGF0YVtqXS54IC0gc3ViUHJldlBvaW50LngpICsgc3ViUHJldlBvaW50Lnk7IC8vIGF4ICsgYiB3aGVyZSBiIGlzIGRhdGFbal0ueVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogZmlyc3Qgc2VsZWN0IGFuZCBwcmVwcm9jZXNzIHRoZSBkYXRhIGZyb20gdGhlIGRhdGFzZXRzLlxuICAgKiB0aGUgZ3JvdXBzIGhhdmUgdGhlaXIgcHJlc2VsZWN0aW9uIG9mIGRhdGEsIHdlIG5vdyBsb29wIG92ZXIgdGhpcyBkYXRhIHRvIHNlZVxuICAgKiB3aGF0IGRhdGEgd2UgbmVlZCB0byBkcmF3LiBTb3J0ZWQgZGF0YSBpcyBtdWNoIGZhc3Rlci5cbiAgICogbW9yZSBvcHRpbWl6YXRpb24gaXMgcG9zc2libGUgYnkgZG9pbmcgdGhlIHNhbXBsaW5nIGJlZm9yZSBhbmQgdXNpbmcgdGhlIGJpbmFyeSBzZWFyY2hcbiAgICogdG8gZmluZCB0aGUgZW5kIGRhdGUgdG8gZGV0ZXJtaW5lIHRoZSBpbmNyZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7YXJyYXl9ICBncm91cElkc1xuICAgKiBAcGFyYW0ge29iamVjdH0gZ3JvdXBzRGF0YVxuICAgKiBAcGFyYW0ge2RhdGV9ICAgbWluRGF0ZVxuICAgKiBAcGFyYW0ge2RhdGV9ICAgbWF4RGF0ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTGluZUdyYXBoLnByb3RvdHlwZS5fZ2V0UmVsZXZhbnREYXRhID0gZnVuY3Rpb24gKGdyb3VwSWRzLCBncm91cHNEYXRhLCBtaW5EYXRlLCBtYXhEYXRlKSB7XG4gICAgdmFyIGdyb3VwLCBpLCBqLCBpdGVtO1xuICAgIGlmIChncm91cElkcy5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZ3JvdXBJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZ3JvdXAgPSB0aGlzLmdyb3Vwc1tncm91cElkc1tpXV07XG4gICAgICAgIHZhciBpdGVtc0RhdGEgPSBncm91cC5nZXRJdGVtcygpO1xuICAgICAgICAvLyBvcHRpbWl6YXRpb24gZm9yIHNvcnRlZCBkYXRhXG4gICAgICAgIGlmIChncm91cC5vcHRpb25zLnNvcnQgPT0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBkYXRlQ29tcGFyYXRvciA9IGZ1bmN0aW9uIGRhdGVDb21wYXJhdG9yKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhLmdldFRpbWUoKSA9PSBiLmdldFRpbWUoKSA/IDAgOiBhIDwgYiA/IC0xIDogMTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBmaXJzdCA9IE1hdGgubWF4KDAsIHV0aWwuYmluYXJ5U2VhcmNoVmFsdWUoaXRlbXNEYXRhLCBtaW5EYXRlLCAneCcsICdiZWZvcmUnLCBkYXRlQ29tcGFyYXRvcikpO1xuICAgICAgICAgIHZhciBsYXN0ID0gTWF0aC5taW4oaXRlbXNEYXRhLmxlbmd0aCwgdXRpbC5iaW5hcnlTZWFyY2hWYWx1ZShpdGVtc0RhdGEsIG1heERhdGUsICd4JywgJ2FmdGVyJywgZGF0ZUNvbXBhcmF0b3IpICsgMSk7XG4gICAgICAgICAgaWYgKGxhc3QgPD0gMCkge1xuICAgICAgICAgICAgbGFzdCA9IGl0ZW1zRGF0YS5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBkYXRhQ29udGFpbmVyID0gbmV3IEFycmF5KGxhc3QgLSBmaXJzdCk7XG4gICAgICAgICAgZm9yIChqID0gZmlyc3Q7IGogPCBsYXN0OyBqKyspIHtcbiAgICAgICAgICAgIGl0ZW0gPSBncm91cC5pdGVtc0RhdGFbal07XG4gICAgICAgICAgICBkYXRhQ29udGFpbmVyW2ogLSBmaXJzdF0gPSBpdGVtO1xuICAgICAgICAgIH1cbiAgICAgICAgICBncm91cHNEYXRhW2dyb3VwSWRzW2ldXSA9IGRhdGFDb250YWluZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWYgdW5zb3J0ZWQgZGF0YSwgYWxsIGRhdGEgaXMgcmVsZXZhbnQsIGp1c3QgcmV0dXJuaW5nIGVudGlyZSBzdHJ1Y3R1cmVcbiAgICAgICAgICBncm91cHNEYXRhW2dyb3VwSWRzW2ldXSA9IGdyb3VwLml0ZW1zRGF0YTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIGdyb3VwSWRzXG4gICAqIEBwYXJhbSBncm91cHNEYXRhXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBMaW5lR3JhcGgucHJvdG90eXBlLl9hcHBseVNhbXBsaW5nID0gZnVuY3Rpb24gKGdyb3VwSWRzLCBncm91cHNEYXRhKSB7XG4gICAgdmFyIGdyb3VwO1xuICAgIGlmIChncm91cElkcy5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGdyb3VwID0gdGhpcy5ncm91cHNbZ3JvdXBJZHNbaV1dO1xuICAgICAgICBpZiAoZ3JvdXAub3B0aW9ucy5zYW1wbGluZyA9PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIGRhdGFDb250YWluZXIgPSBncm91cHNEYXRhW2dyb3VwSWRzW2ldXTtcbiAgICAgICAgICBpZiAoZGF0YUNvbnRhaW5lci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgaW5jcmVtZW50ID0gMTtcbiAgICAgICAgICAgIHZhciBhbW91bnRPZlBvaW50cyA9IGRhdGFDb250YWluZXIubGVuZ3RoO1xuXG4gICAgICAgICAgICAvLyB0aGUgZ2xvYmFsIHNjcmVlbiBpcyB1c2VkIGJlY2F1c2UgY2hhbmdpbmcgdGhlIHdpZHRoIG9mIHRoZSB5QXhpcyBtYXkgYWZmZWN0IHRoZSBpbmNyZW1lbnQsIHJlc3VsdGluZyBpbiBhbiBlbmRsZXNzIGxvb3BcbiAgICAgICAgICAgIC8vIG9mIHdpZHRoIGNoYW5naW5nIG9mIHRoZSB5QXhpcy5cbiAgICAgICAgICAgIHZhciB4RGlzdGFuY2UgPSB0aGlzLmJvZHkudXRpbC50b0dsb2JhbFNjcmVlbihkYXRhQ29udGFpbmVyW2RhdGFDb250YWluZXIubGVuZ3RoIC0gMV0ueCkgLSB0aGlzLmJvZHkudXRpbC50b0dsb2JhbFNjcmVlbihkYXRhQ29udGFpbmVyWzBdLngpO1xuICAgICAgICAgICAgdmFyIHBvaW50c1BlclBpeGVsID0gYW1vdW50T2ZQb2ludHMgLyB4RGlzdGFuY2U7XG4gICAgICAgICAgICBpbmNyZW1lbnQgPSBNYXRoLm1pbihNYXRoLmNlaWwoMC4yICogYW1vdW50T2ZQb2ludHMpLCBNYXRoLm1heCgxLCBNYXRoLnJvdW5kKHBvaW50c1BlclBpeGVsKSkpO1xuXG4gICAgICAgICAgICB2YXIgc2FtcGxlZERhdGEgPSBuZXcgQXJyYXkoYW1vdW50T2ZQb2ludHMpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhbW91bnRPZlBvaW50czsgaiArPSBpbmNyZW1lbnQpIHtcbiAgICAgICAgICAgICAgdmFyIGlkeCA9IE1hdGgucm91bmQoaiAvIGluY3JlbWVudCk7XG4gICAgICAgICAgICAgIHNhbXBsZWREYXRhW2lkeF0gPSBkYXRhQ29udGFpbmVyW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ3JvdXBzRGF0YVtncm91cElkc1tpXV0gPSBzYW1wbGVkRGF0YS5zcGxpY2UoMCwgTWF0aC5yb3VuZChhbW91bnRPZlBvaW50cyAvIGluY3JlbWVudCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICpcbiAgICpcbiAgICogQHBhcmFtIHthcnJheX0gIGdyb3VwSWRzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBncm91cHNEYXRhXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBncm91cFJhbmdlcyAgfCB0aGlzIGlzIGJlaW5nIGZpbGxlZCBoZXJlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBMaW5lR3JhcGgucHJvdG90eXBlLl9nZXRZUmFuZ2VzID0gZnVuY3Rpb24gKGdyb3VwSWRzLCBncm91cHNEYXRhLCBncm91cFJhbmdlcykge1xuICAgIHZhciBncm91cERhdGEsIGdyb3VwLCBpO1xuICAgIHZhciBjb21iaW5lZERhdGFMZWZ0ID0gW107XG4gICAgdmFyIGNvbWJpbmVkRGF0YVJpZ2h0ID0gW107XG4gICAgdmFyIG9wdGlvbnM7XG4gICAgaWYgKGdyb3VwSWRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBncm91cElkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBncm91cERhdGEgPSBncm91cHNEYXRhW2dyb3VwSWRzW2ldXTtcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMuZ3JvdXBzW2dyb3VwSWRzW2ldXS5vcHRpb25zO1xuICAgICAgICBpZiAoZ3JvdXBEYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBncm91cCA9IHRoaXMuZ3JvdXBzW2dyb3VwSWRzW2ldXTtcbiAgICAgICAgICAvLyBpZiBiYXIgZ3JhcGhzIGFyZSBzdGFja2VkLCB0aGVpciByYW5nZSBuZWVkIHRvIGJlIGhhbmRsZWQgZGlmZmVyZW50bHkgYW5kIGFjY3VtdWxhdGVkIG92ZXIgYWxsIGdyb3Vwcy5cbiAgICAgICAgICBpZiAob3B0aW9ucy5zdGFjayA9PT0gdHJ1ZSAmJiBvcHRpb25zLnN0eWxlID09PSAnYmFyJykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMueUF4aXNPcmllbnRhdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICAgIGNvbWJpbmVkRGF0YUxlZnQgPSBjb21iaW5lZERhdGFMZWZ0LmNvbmNhdChncm91cC5nZXRJdGVtcygpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbWJpbmVkRGF0YVJpZ2h0ID0gY29tYmluZWREYXRhUmlnaHQuY29uY2F0KGdyb3VwLmdldEl0ZW1zKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBncm91cFJhbmdlc1tncm91cElkc1tpXV0gPSBncm91cC5nZXRZUmFuZ2UoZ3JvdXBEYXRhLCBncm91cElkc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIGJhciBncmFwaHMgYXJlIHN0YWNrZWQsIHRoZWlyIHJhbmdlIG5lZWQgdG8gYmUgaGFuZGxlZCBkaWZmZXJlbnRseSBhbmQgYWNjdW11bGF0ZWQgb3ZlciBhbGwgZ3JvdXBzLlxuICAgICAgQmFycy5nZXRTdGFja2VkWVJhbmdlKGNvbWJpbmVkRGF0YUxlZnQsIGdyb3VwUmFuZ2VzLCBncm91cElkcywgJ19fYmFyU3RhY2tMZWZ0JywgJ2xlZnQnKTtcbiAgICAgIEJhcnMuZ2V0U3RhY2tlZFlSYW5nZShjb21iaW5lZERhdGFSaWdodCwgZ3JvdXBSYW5nZXMsIGdyb3VwSWRzLCAnX19iYXJTdGFja1JpZ2h0JywgJ3JpZ2h0Jyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiB0aGlzIHNldHMgdGhlIFkgcmFuZ2VzIGZvciB0aGUgWSBheGlzLiBJdCBhbHNvIGRldGVybWluZXMgd2hpY2ggb2YgdGhlIGF4aXMgc2hvdWxkIGJlIHNob3duIG9yIGhpZGRlbi5cbiAgICogQHBhcmFtIHtBcnJheX0gZ3JvdXBJZHNcbiAgICogQHBhcmFtIHtPYmplY3R9IGdyb3VwUmFuZ2VzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBMaW5lR3JhcGgucHJvdG90eXBlLl91cGRhdGVZQXhpcyA9IGZ1bmN0aW9uIChncm91cElkcywgZ3JvdXBSYW5nZXMpIHtcbiAgICB2YXIgcmVzaXplZCA9IGZhbHNlO1xuICAgIHZhciB5QXhpc0xlZnRVc2VkID0gZmFsc2U7XG4gICAgdmFyIHlBeGlzUmlnaHRVc2VkID0gZmFsc2U7XG4gICAgdmFyIG1pbkxlZnQgPSAxZTksXG4gICAgICAgIG1pblJpZ2h0ID0gMWU5LFxuICAgICAgICBtYXhMZWZ0ID0gLTFlOSxcbiAgICAgICAgbWF4UmlnaHQgPSAtMWU5LFxuICAgICAgICBtaW5WYWwsXG4gICAgICAgIG1heFZhbDtcbiAgICAvLyBpZiBncm91cHMgYXJlIHByZXNlbnRcbiAgICBpZiAoZ3JvdXBJZHMubGVuZ3RoID4gMCkge1xuICAgICAgLy8gdGhpcyBpcyBoZXJlIHRvIG1ha2Ugc3VyZSB0aGF0IGlmIHRoZXJlIGFyZSBubyBpdGVtcyBpbiB0aGUgYXhpcyBidXQgdGhlcmUgYXJlIGdyb3VwcywgdGhhdCB0aGVyZSBpcyBubyBpbmZpbml0ZSBkcmF3L3JlZHJhdyBsb29wLlxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cElkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3Vwc1tncm91cElkc1tpXV07XG4gICAgICAgIGlmIChncm91cCAmJiBncm91cC5vcHRpb25zLnlBeGlzT3JpZW50YXRpb24gIT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIHlBeGlzTGVmdFVzZWQgPSB0cnVlO1xuICAgICAgICAgIG1pbkxlZnQgPSAxZTk7XG4gICAgICAgICAgbWF4TGVmdCA9IC0xZTk7XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JvdXAgJiYgZ3JvdXAub3B0aW9ucy55QXhpc09yaWVudGF0aW9uKSB7XG4gICAgICAgICAgeUF4aXNSaWdodFVzZWQgPSB0cnVlO1xuICAgICAgICAgIG1pblJpZ2h0ID0gMWU5O1xuICAgICAgICAgIG1heFJpZ2h0ID0gLTFlOTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBpZiB0aGVyZSBhcmUgaXRlbXM6XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChncm91cFJhbmdlcy5oYXNPd25Qcm9wZXJ0eShncm91cElkc1tpXSkpIHtcbiAgICAgICAgICBpZiAoZ3JvdXBSYW5nZXNbZ3JvdXBJZHNbaV1dLmlnbm9yZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgbWluVmFsID0gZ3JvdXBSYW5nZXNbZ3JvdXBJZHNbaV1dLm1pbjtcbiAgICAgICAgICAgIG1heFZhbCA9IGdyb3VwUmFuZ2VzW2dyb3VwSWRzW2ldXS5tYXg7XG5cbiAgICAgICAgICAgIGlmIChncm91cFJhbmdlc1tncm91cElkc1tpXV0ueUF4aXNPcmllbnRhdGlvbiAhPSAncmlnaHQnKSB7XG4gICAgICAgICAgICAgIHlBeGlzTGVmdFVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBtaW5MZWZ0ID0gbWluTGVmdCA+IG1pblZhbCA/IG1pblZhbCA6IG1pbkxlZnQ7XG4gICAgICAgICAgICAgIG1heExlZnQgPSBtYXhMZWZ0IDwgbWF4VmFsID8gbWF4VmFsIDogbWF4TGVmdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHlBeGlzUmlnaHRVc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgbWluUmlnaHQgPSBtaW5SaWdodCA+IG1pblZhbCA/IG1pblZhbCA6IG1pblJpZ2h0O1xuICAgICAgICAgICAgICBtYXhSaWdodCA9IG1heFJpZ2h0IDwgbWF4VmFsID8gbWF4VmFsIDogbWF4UmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh5QXhpc0xlZnRVc2VkID09IHRydWUpIHtcbiAgICAgICAgdGhpcy55QXhpc0xlZnQuc2V0UmFuZ2UobWluTGVmdCwgbWF4TGVmdCk7XG4gICAgICB9XG4gICAgICBpZiAoeUF4aXNSaWdodFVzZWQgPT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnlBeGlzUmlnaHQuc2V0UmFuZ2UobWluUmlnaHQsIG1heFJpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzaXplZCA9IHRoaXMuX3RvZ2dsZUF4aXNWaXNpYmxpdHkoeUF4aXNMZWZ0VXNlZCwgdGhpcy55QXhpc0xlZnQpIHx8IHJlc2l6ZWQ7XG4gICAgcmVzaXplZCA9IHRoaXMuX3RvZ2dsZUF4aXNWaXNpYmxpdHkoeUF4aXNSaWdodFVzZWQsIHRoaXMueUF4aXNSaWdodCkgfHwgcmVzaXplZDtcblxuICAgIGlmICh5QXhpc1JpZ2h0VXNlZCA9PSB0cnVlICYmIHlBeGlzTGVmdFVzZWQgPT0gdHJ1ZSkge1xuICAgICAgdGhpcy55QXhpc0xlZnQuZHJhd0ljb25zID0gdHJ1ZTtcbiAgICAgIHRoaXMueUF4aXNSaWdodC5kcmF3SWNvbnMgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnlBeGlzTGVmdC5kcmF3SWNvbnMgPSBmYWxzZTtcbiAgICAgIHRoaXMueUF4aXNSaWdodC5kcmF3SWNvbnMgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy55QXhpc1JpZ2h0Lm1hc3RlciA9ICF5QXhpc0xlZnRVc2VkO1xuICAgIHRoaXMueUF4aXNSaWdodC5tYXN0ZXJBeGlzID0gdGhpcy55QXhpc0xlZnQ7XG5cbiAgICBpZiAodGhpcy55QXhpc1JpZ2h0Lm1hc3RlciA9PSBmYWxzZSkge1xuICAgICAgaWYgKHlBeGlzUmlnaHRVc2VkID09IHRydWUpIHtcbiAgICAgICAgdGhpcy55QXhpc0xlZnQubGluZU9mZnNldCA9IHRoaXMueUF4aXNSaWdodC53aWR0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMueUF4aXNMZWZ0LmxpbmVPZmZzZXQgPSAwO1xuICAgICAgfVxuXG4gICAgICByZXNpemVkID0gdGhpcy55QXhpc0xlZnQucmVkcmF3KCkgfHwgcmVzaXplZDtcbiAgICAgIHJlc2l6ZWQgPSB0aGlzLnlBeGlzUmlnaHQucmVkcmF3KCkgfHwgcmVzaXplZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzaXplZCA9IHRoaXMueUF4aXNSaWdodC5yZWRyYXcoKSB8fCByZXNpemVkO1xuICAgIH1cblxuICAgIC8vIGNsZWFuIHRoZSBhY2N1bXVsYXRlZCBsaXN0c1xuICAgIHZhciB0ZW1wR3JvdXBzID0gWydfX2JhclN0YWNrTGVmdCcsICdfX2JhclN0YWNrUmlnaHQnLCAnX19saW5lU3RhY2tMZWZ0JywgJ19fbGluZVN0YWNrUmlnaHQnXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlbXBHcm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChncm91cElkcy5pbmRleE9mKHRlbXBHcm91cHNbaV0pICE9IC0xKSB7XG4gICAgICAgIGdyb3VwSWRzLnNwbGljZShncm91cElkcy5pbmRleE9mKHRlbXBHcm91cHNbaV0pLCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzaXplZDtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBzaG93cyBvciBoaWRlcyB0aGUgWSBheGlzIGlmIG5lZWRlZC4gSWYgdGhlcmUgaXMgYSBjaGFuZ2UsIHRoZSBjaGFuZ2VkIGV2ZW50IGlzIGVtaXR0ZWQgYnkgdGhlIHVwZGF0ZVlBeGlzIGZ1bmN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gYXhpc1VzZWRcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSBheGlzXG4gICAqL1xuICBMaW5lR3JhcGgucHJvdG90eXBlLl90b2dnbGVBeGlzVmlzaWJsaXR5ID0gZnVuY3Rpb24gKGF4aXNVc2VkLCBheGlzKSB7XG4gICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICBpZiAoYXhpc1VzZWQgPT0gZmFsc2UpIHtcbiAgICAgIGlmIChheGlzLmRvbS5mcmFtZS5wYXJlbnROb2RlICYmIGF4aXMuaGlkZGVuID09IGZhbHNlKSB7XG4gICAgICAgIGF4aXMuaGlkZSgpO1xuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFheGlzLmRvbS5mcmFtZS5wYXJlbnROb2RlICYmIGF4aXMuaGlkZGVuID09IHRydWUpIHtcbiAgICAgICAgYXhpcy5zaG93KCk7XG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyB1c2VzIHRoZSBEYXRhQXhpcyBvYmplY3QgdG8gZ2VuZXJhdGUgdGhlIGNvcnJlY3QgWCBjb29yZGluYXRlIG9uIHRoZSBTVkcgd2luZG93LiBJdCB1c2VzIHRoZVxuICAgKiB1dGlsIGZ1bmN0aW9uIHRvU2NyZWVuIHRvIGdldCB0aGUgeCBjb29yZGluYXRlIGZyb20gdGhlIHRpbWVzdGFtcC4gSXQgYWxzbyBwcmUtZmlsdGVycyB0aGUgZGF0YSBhbmQgZ2V0IHRoZSBtaW5NYXggcmFuZ2VzIGZvclxuICAgKiB0aGUgeUF4aXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhcG9pbnRzXG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIExpbmVHcmFwaC5wcm90b3R5cGUuX2NvbnZlcnRYY29vcmRpbmF0ZXMgPSBmdW5jdGlvbiAoZGF0YXBvaW50cykge1xuICAgIHZhciB0b1NjcmVlbiA9IHRoaXMuYm9keS51dGlsLnRvU2NyZWVuO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YXBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgZGF0YXBvaW50c1tpXS5zY3JlZW5feCA9IHRvU2NyZWVuKGRhdGFwb2ludHNbaV0ueCkgKyB0aGlzLnByb3BzLndpZHRoO1xuICAgICAgZGF0YXBvaW50c1tpXS5zY3JlZW5feSA9IGRhdGFwb2ludHNbaV0ueTsgLy9zdGFydGluZyBwb2ludCBmb3IgcmFuZ2UgY2FsY3VsYXRpb25zXG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIHVzZXMgdGhlIERhdGFBeGlzIG9iamVjdCB0byBnZW5lcmF0ZSB0aGUgY29ycmVjdCBYIGNvb3JkaW5hdGUgb24gdGhlIFNWRyB3aW5kb3cuIEl0IHVzZXMgdGhlXG4gICAqIHV0aWwgZnVuY3Rpb24gdG9TY3JlZW4gdG8gZ2V0IHRoZSB4IGNvb3JkaW5hdGUgZnJvbSB0aGUgdGltZXN0YW1wLiBJdCBhbHNvIHByZS1maWx0ZXJzIHRoZSBkYXRhIGFuZCBnZXQgdGhlIG1pbk1heCByYW5nZXMgZm9yXG4gICAqIHRoZSB5QXhpcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGFwb2ludHNcbiAgICogQHBhcmFtIGdyb3VwXG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIExpbmVHcmFwaC5wcm90b3R5cGUuX2NvbnZlcnRZY29vcmRpbmF0ZXMgPSBmdW5jdGlvbiAoZGF0YXBvaW50cywgZ3JvdXApIHtcbiAgICB2YXIgYXhpcyA9IHRoaXMueUF4aXNMZWZ0O1xuICAgIHZhciBzdmdIZWlnaHQgPSBOdW1iZXIodGhpcy5zdmcuc3R5bGUuaGVpZ2h0LnJlcGxhY2UoJ3B4JywgJycpKTtcbiAgICBpZiAoZ3JvdXAub3B0aW9ucy55QXhpc09yaWVudGF0aW9uID09ICdyaWdodCcpIHtcbiAgICAgIGF4aXMgPSB0aGlzLnlBeGlzUmlnaHQ7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YXBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgZGF0YXBvaW50c1tpXS5zY3JlZW5feSA9IE1hdGgucm91bmQoYXhpcy5jb252ZXJ0VmFsdWUoZGF0YXBvaW50c1tpXS55KSk7XG4gICAgfVxuICAgIGdyb3VwLnNldFplcm9Qb3NpdGlvbihNYXRoLm1pbihzdmdIZWlnaHQsIGF4aXMuY29udmVydFZhbHVlKDApKSk7XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBMaW5lR3JhcGg7XG5cbi8qKiovIH0sXG4vKiA1MiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbiAgdmFyIERPTXV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuICB2YXIgQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSk7XG4gIHZhciBEYXRhU2NhbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUzKTtcbiAgLyoqXG4gICAqIEEgaG9yaXpvbnRhbCB0aW1lIGF4aXNcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICAgICAgU2VlIERhdGFBeGlzLnNldE9wdGlvbnMgZm9yIHRoZSBhdmFpbGFibGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5cbiAgICogQGNvbnN0cnVjdG9yIERhdGFBeGlzXG4gICAqIEBleHRlbmRzIENvbXBvbmVudFxuICAgKiBAcGFyYW0gYm9keVxuICAgKi9cbiAgZnVuY3Rpb24gRGF0YUF4aXMoYm9keSwgb3B0aW9ucywgc3ZnLCBsaW5lZ3JhcGhPcHRpb25zKSB7XG4gICAgdGhpcy5pZCA9IHV0aWwucmFuZG9tVVVJRCgpO1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG5cbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgb3JpZW50YXRpb246ICdsZWZ0JywgLy8gc3VwcG9ydGVkOiAnbGVmdCcsICdyaWdodCdcbiAgICAgIHNob3dNaW5vckxhYmVsczogdHJ1ZSxcbiAgICAgIHNob3dNYWpvckxhYmVsczogdHJ1ZSxcbiAgICAgIGljb25zOiBmYWxzZSxcbiAgICAgIG1ham9yTGluZXNPZmZzZXQ6IDcsXG4gICAgICBtaW5vckxpbmVzT2Zmc2V0OiA0LFxuICAgICAgbGFiZWxPZmZzZXRYOiAxMCxcbiAgICAgIGxhYmVsT2Zmc2V0WTogMixcbiAgICAgIGljb25XaWR0aDogMjAsXG4gICAgICB3aWR0aDogJzQwcHgnLFxuICAgICAgdmlzaWJsZTogdHJ1ZSxcbiAgICAgIGFsaWduWmVyb3M6IHRydWUsXG4gICAgICBsZWZ0OiB7XG4gICAgICAgIHJhbmdlOiB7IG1pbjogdW5kZWZpbmVkLCBtYXg6IHVuZGVmaW5lZCB9LFxuICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uIGZvcm1hdCh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiAnJyArIHBhcnNlRmxvYXQodmFsdWUudG9QcmVjaXNpb24oMykpO1xuICAgICAgICB9LFxuICAgICAgICB0aXRsZTogeyB0ZXh0OiB1bmRlZmluZWQsIHN0eWxlOiB1bmRlZmluZWQgfVxuICAgICAgfSxcbiAgICAgIHJpZ2h0OiB7XG4gICAgICAgIHJhbmdlOiB7IG1pbjogdW5kZWZpbmVkLCBtYXg6IHVuZGVmaW5lZCB9LFxuICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uIGZvcm1hdCh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiAnJyArIHBhcnNlRmxvYXQodmFsdWUudG9QcmVjaXNpb24oMykpO1xuICAgICAgICB9LFxuICAgICAgICB0aXRsZTogeyB0ZXh0OiB1bmRlZmluZWQsIHN0eWxlOiB1bmRlZmluZWQgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmxpbmVncmFwaE9wdGlvbnMgPSBsaW5lZ3JhcGhPcHRpb25zO1xuICAgIHRoaXMubGluZWdyYXBoU1ZHID0gc3ZnO1xuICAgIHRoaXMucHJvcHMgPSB7fTtcbiAgICB0aGlzLkRPTWVsZW1lbnRzID0geyAvLyBkeW5hbWljIGVsZW1lbnRzXG4gICAgICBsaW5lczoge30sXG4gICAgICBsYWJlbHM6IHt9LFxuICAgICAgdGl0bGU6IHt9XG4gICAgfTtcblxuICAgIHRoaXMuZG9tID0ge307XG4gICAgdGhpcy5zY2FsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJhbmdlID0geyBzdGFydDogMCwgZW5kOiAwIH07XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG4gICAgdGhpcy5jb252ZXJzaW9uRmFjdG9yID0gMTtcblxuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB0aGlzLndpZHRoID0gTnVtYmVyKCgnJyArIHRoaXMub3B0aW9ucy53aWR0aCkucmVwbGFjZShcInB4XCIsIFwiXCIpKTtcbiAgICB0aGlzLm1pbldpZHRoID0gdGhpcy53aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IHRoaXMubGluZWdyYXBoU1ZHLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICB0aGlzLmhpZGRlbiA9IGZhbHNlO1xuXG4gICAgdGhpcy5zdGVwUGl4ZWxzID0gMjU7XG4gICAgdGhpcy56ZXJvQ3Jvc3NpbmcgPSAtMTtcbiAgICB0aGlzLmFtb3VudE9mU3RlcHMgPSAtMTtcblxuICAgIHRoaXMubGluZU9mZnNldCA9IDA7XG4gICAgdGhpcy5tYXN0ZXIgPSB0cnVlO1xuICAgIHRoaXMubWFzdGVyQXhpcyA9IG51bGw7XG4gICAgdGhpcy5zdmdFbGVtZW50cyA9IHt9O1xuICAgIHRoaXMuaWNvbnNSZW1vdmVkID0gZmFsc2U7XG5cbiAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgIHRoaXMuYW1vdW50T2ZHcm91cHMgPSAwO1xuXG4gICAgLy8gY3JlYXRlIHRoZSBIVE1MIERPTVxuICAgIHRoaXMuX2NyZWF0ZSgpO1xuICAgIHRoaXMuZnJhbWV3b3JrID0geyBzdmc6IHRoaXMuc3ZnLCBzdmdFbGVtZW50czogdGhpcy5zdmdFbGVtZW50cywgb3B0aW9uczogdGhpcy5vcHRpb25zLCBncm91cHM6IHRoaXMuZ3JvdXBzIH07XG5cbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwidmVydGljYWxEcmFnXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIG1lLmRvbS5saW5lQ29udGFpbmVyLnN0eWxlLnRvcCA9IG1lLmJvZHkuZG9tUHJvcHMuc2Nyb2xsVG9wICsgJ3B4JztcbiAgICB9KTtcbiAgfVxuXG4gIERhdGFBeGlzLnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnQoKTtcblxuICBEYXRhQXhpcy5wcm90b3R5cGUuYWRkR3JvdXAgPSBmdW5jdGlvbiAobGFiZWwsIGdyYXBoT3B0aW9ucykge1xuICAgIGlmICghdGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobGFiZWwpKSB7XG4gICAgICB0aGlzLmdyb3Vwc1tsYWJlbF0gPSBncmFwaE9wdGlvbnM7XG4gICAgfVxuICAgIHRoaXMuYW1vdW50T2ZHcm91cHMgKz0gMTtcbiAgfTtcblxuICBEYXRhQXhpcy5wcm90b3R5cGUudXBkYXRlR3JvdXAgPSBmdW5jdGlvbiAobGFiZWwsIGdyYXBoT3B0aW9ucykge1xuICAgIGlmICghdGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobGFiZWwpKSB7XG4gICAgICB0aGlzLmFtb3VudE9mR3JvdXBzICs9IDE7XG4gICAgfVxuICAgIHRoaXMuZ3JvdXBzW2xhYmVsXSA9IGdyYXBoT3B0aW9ucztcbiAgfTtcblxuICBEYXRhQXhpcy5wcm90b3R5cGUucmVtb3ZlR3JvdXAgPSBmdW5jdGlvbiAobGFiZWwpIHtcbiAgICBpZiAodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkobGFiZWwpKSB7XG4gICAgICBkZWxldGUgdGhpcy5ncm91cHNbbGFiZWxdO1xuICAgICAgdGhpcy5hbW91bnRPZkdyb3VwcyAtPSAxO1xuICAgIH1cbiAgfTtcblxuICBEYXRhQXhpcy5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIHZhciByZWRyYXcgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub3JpZW50YXRpb24gIT0gb3B0aW9ucy5vcmllbnRhdGlvbiAmJiBvcHRpb25zLm9yaWVudGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVkcmF3ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBmaWVsZHMgPSBbJ29yaWVudGF0aW9uJywgJ3Nob3dNaW5vckxhYmVscycsICdzaG93TWFqb3JMYWJlbHMnLCAnaWNvbnMnLCAnbWFqb3JMaW5lc09mZnNldCcsICdtaW5vckxpbmVzT2Zmc2V0JywgJ2xhYmVsT2Zmc2V0WCcsICdsYWJlbE9mZnNldFknLCAnaWNvbldpZHRoJywgJ3dpZHRoJywgJ3Zpc2libGUnLCAnbGVmdCcsICdyaWdodCcsICdhbGlnblplcm9zJ107XG4gICAgICB1dGlsLnNlbGVjdGl2ZURlZXBFeHRlbmQoZmllbGRzLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICB0aGlzLm1pbldpZHRoID0gTnVtYmVyKCgnJyArIHRoaXMub3B0aW9ucy53aWR0aCkucmVwbGFjZShcInB4XCIsIFwiXCIpKTtcbiAgICAgIGlmIChyZWRyYXcgPT09IHRydWUgJiYgdGhpcy5kb20uZnJhbWUpIHtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBIVE1MIERPTSBmb3IgdGhlIERhdGFBeGlzXG4gICAqL1xuICBEYXRhQXhpcy5wcm90b3R5cGUuX2NyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRvbS5mcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuZG9tLmZyYW1lLnN0eWxlLndpZHRoID0gdGhpcy5vcHRpb25zLndpZHRoO1xuICAgIHRoaXMuZG9tLmZyYW1lLnN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuXG4gICAgdGhpcy5kb20ubGluZUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuZG9tLmxpbmVDb250YWluZXIuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgdGhpcy5kb20ubGluZUNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICB0aGlzLmRvbS5saW5lQ29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcblxuICAgIC8vIGNyZWF0ZSBzdmcgZWxlbWVudCBmb3IgZ3JhcGggZHJhd2luZy5cbiAgICB0aGlzLnN2ZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCBcInN2Z1wiKTtcbiAgICB0aGlzLnN2Zy5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICB0aGlzLnN2Zy5zdHlsZS50b3AgPSAnMHB4JztcbiAgICB0aGlzLnN2Zy5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgdGhpcy5zdmcuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgdGhpcy5zdmcuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICB0aGlzLmRvbS5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLnN2Zyk7XG4gIH07XG5cbiAgRGF0YUF4aXMucHJvdG90eXBlLl9yZWRyYXdHcm91cEljb25zID0gZnVuY3Rpb24gKCkge1xuICAgIERPTXV0aWwucHJlcGFyZUVsZW1lbnRzKHRoaXMuc3ZnRWxlbWVudHMpO1xuXG4gICAgdmFyIHg7XG4gICAgdmFyIGljb25XaWR0aCA9IHRoaXMub3B0aW9ucy5pY29uV2lkdGg7XG4gICAgdmFyIGljb25IZWlnaHQgPSAxNTtcbiAgICB2YXIgaWNvbk9mZnNldCA9IDQ7XG4gICAgdmFyIHkgPSBpY29uT2Zmc2V0ICsgMC41ICogaWNvbkhlaWdodDtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMub3JpZW50YXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgeCA9IGljb25PZmZzZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSB0aGlzLndpZHRoIC0gaWNvbldpZHRoIC0gaWNvbk9mZnNldDtcbiAgICB9XG5cbiAgICB2YXIgZ3JvdXBBcnJheSA9IE9iamVjdC5rZXlzKHRoaXMuZ3JvdXBzKTtcbiAgICBncm91cEFycmF5LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhIDwgYiA/IC0xIDogMTtcbiAgICB9KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGdyb3VwSWQgPSBncm91cEFycmF5W2ldO1xuICAgICAgaWYgKHRoaXMuZ3JvdXBzW2dyb3VwSWRdLnZpc2libGUgPT09IHRydWUgJiYgKHRoaXMubGluZWdyYXBoT3B0aW9ucy52aXNpYmlsaXR5W2dyb3VwSWRdID09PSB1bmRlZmluZWQgfHwgdGhpcy5saW5lZ3JhcGhPcHRpb25zLnZpc2liaWxpdHlbZ3JvdXBJZF0gPT09IHRydWUpKSB7XG4gICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwSWRdLmdldExlZ2VuZChpY29uV2lkdGgsIGljb25IZWlnaHQsIHRoaXMuZnJhbWV3b3JrLCB4LCB5KTtcbiAgICAgICAgeSArPSBpY29uSGVpZ2h0ICsgaWNvbk9mZnNldDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBET011dGlsLmNsZWFudXBFbGVtZW50cyh0aGlzLnN2Z0VsZW1lbnRzKTtcbiAgICB0aGlzLmljb25zUmVtb3ZlZCA9IGZhbHNlO1xuICB9O1xuXG4gIERhdGFBeGlzLnByb3RvdHlwZS5fY2xlYW51cEljb25zID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmljb25zUmVtb3ZlZCA9PT0gZmFsc2UpIHtcbiAgICAgIERPTXV0aWwucHJlcGFyZUVsZW1lbnRzKHRoaXMuc3ZnRWxlbWVudHMpO1xuICAgICAgRE9NdXRpbC5jbGVhbnVwRWxlbWVudHModGhpcy5zdmdFbGVtZW50cyk7XG4gICAgICB0aGlzLmljb25zUmVtb3ZlZCA9IHRydWU7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIEhUTUwgRE9NIGZvciB0aGUgRGF0YUF4aXNcbiAgICovXG4gIERhdGFBeGlzLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaGlkZGVuID0gZmFsc2U7XG4gICAgaWYgKCF0aGlzLmRvbS5mcmFtZS5wYXJlbnROb2RlKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgICB0aGlzLmJvZHkuZG9tLmxlZnQuYXBwZW5kQ2hpbGQodGhpcy5kb20uZnJhbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ib2R5LmRvbS5sZWZ0LmFwcGVuZENoaWxkKHRoaXMuZG9tLmZyYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZG9tLmxpbmVDb250YWluZXIucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5ib2R5LmRvbS5iYWNrZ3JvdW5kSG9yaXpvbnRhbC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5saW5lQ29udGFpbmVyKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgSFRNTCBET00gZm9yIHRoZSBEYXRhQXhpc1xuICAgKi9cbiAgRGF0YUF4aXMucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5oaWRkZW4gPSB0cnVlO1xuICAgIGlmICh0aGlzLmRvbS5mcmFtZS5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLmRvbS5mcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLmZyYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5kb20ubGluZUNvbnRhaW5lci5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLmRvbS5saW5lQ29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20ubGluZUNvbnRhaW5lcik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgYSByYW5nZSAoc3RhcnQgYW5kIGVuZClcbiAgICogQHBhcmFtIGVuZFxuICAgKiBAcGFyYW0gc3RhcnRcbiAgICogQHBhcmFtIGVuZFxuICAgKi9cbiAgRGF0YUF4aXMucHJvdG90eXBlLnNldFJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICB0aGlzLnJhbmdlLnN0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5yYW5nZS5lbmQgPSBlbmQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcGFpbnQgdGhlIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGNvbXBvbmVudCBpcyByZXNpemVkXG4gICAqL1xuICBEYXRhQXhpcy5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXNpemVkID0gZmFsc2U7XG4gICAgdmFyIGFjdGl2ZUdyb3VwcyA9IDA7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlIGxpbmUgY29udGFpbmVyIGFkaGVyZXMgdG8gdGhlIHZlcnRpY2FsIHNjcm9sbGluZy5cbiAgICB0aGlzLmRvbS5saW5lQ29udGFpbmVyLnN0eWxlLnRvcCA9IHRoaXMuYm9keS5kb21Qcm9wcy5zY3JvbGxUb3AgKyAncHgnO1xuXG4gICAgZm9yICh2YXIgZ3JvdXBJZCBpbiB0aGlzLmdyb3Vwcykge1xuICAgICAgaWYgKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KGdyb3VwSWQpKSB7XG4gICAgICAgIGlmICh0aGlzLmdyb3Vwc1tncm91cElkXS52aXNpYmxlID09PSB0cnVlICYmICh0aGlzLmxpbmVncmFwaE9wdGlvbnMudmlzaWJpbGl0eVtncm91cElkXSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMubGluZWdyYXBoT3B0aW9ucy52aXNpYmlsaXR5W2dyb3VwSWRdID09PSB0cnVlKSkge1xuICAgICAgICAgIGFjdGl2ZUdyb3VwcysrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmFtb3VudE9mR3JvdXBzID09PSAwIHx8IGFjdGl2ZUdyb3VwcyA9PT0gMCkge1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgdGhpcy5oZWlnaHQgPSBOdW1iZXIodGhpcy5saW5lZ3JhcGhTVkcuc3R5bGUuaGVpZ2h0LnJlcGxhY2UoXCJweFwiLCBcIlwiKSk7XG5cbiAgICAgIC8vIHN2ZyBvZmZzZXRoZWlnaHQgZGlkIG5vdCB3b3JrIGluIGZpcmVmb3ggYW5kIGV4cGxvcmVyLi4uXG4gICAgICB0aGlzLmRvbS5saW5lQ29udGFpbmVyLnN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgJ3B4JztcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLm9wdGlvbnMudmlzaWJsZSA9PT0gdHJ1ZSA/IE51bWJlcigoJycgKyB0aGlzLm9wdGlvbnMud2lkdGgpLnJlcGxhY2UoXCJweFwiLCBcIlwiKSkgOiAwO1xuXG4gICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgdmFyIGZyYW1lID0gdGhpcy5kb20uZnJhbWU7XG5cbiAgICAgIC8vIHVwZGF0ZSBjbGFzc25hbWVcbiAgICAgIGZyYW1lLmNsYXNzTmFtZSA9ICd2aXMtZGF0YS1heGlzJztcblxuICAgICAgLy8gY2FsY3VsYXRlIGNoYXJhY3RlciB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICB0aGlzLl9jYWxjdWxhdGVDaGFyU2l6ZSgpO1xuXG4gICAgICB2YXIgb3JpZW50YXRpb24gPSB0aGlzLm9wdGlvbnMub3JpZW50YXRpb247XG4gICAgICB2YXIgc2hvd01pbm9yTGFiZWxzID0gdGhpcy5vcHRpb25zLnNob3dNaW5vckxhYmVscztcbiAgICAgIHZhciBzaG93TWFqb3JMYWJlbHMgPSB0aGlzLm9wdGlvbnMuc2hvd01ham9yTGFiZWxzO1xuXG4gICAgICAvLyBkZXRlcm1pbmUgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIGVsZW1lbnRzIGZvciB0aGUgYXhpc1xuICAgICAgcHJvcHMubWlub3JMYWJlbEhlaWdodCA9IHNob3dNaW5vckxhYmVscyA/IHByb3BzLm1pbm9yQ2hhckhlaWdodCA6IDA7XG4gICAgICBwcm9wcy5tYWpvckxhYmVsSGVpZ2h0ID0gc2hvd01ham9yTGFiZWxzID8gcHJvcHMubWFqb3JDaGFySGVpZ2h0IDogMDtcblxuICAgICAgcHJvcHMubWlub3JMaW5lV2lkdGggPSB0aGlzLmJvZHkuZG9tLmJhY2tncm91bmRIb3Jpem9udGFsLm9mZnNldFdpZHRoIC0gdGhpcy5saW5lT2Zmc2V0IC0gdGhpcy53aWR0aCArIDIgKiB0aGlzLm9wdGlvbnMubWlub3JMaW5lc09mZnNldDtcbiAgICAgIHByb3BzLm1pbm9yTGluZUhlaWdodCA9IDE7XG4gICAgICBwcm9wcy5tYWpvckxpbmVXaWR0aCA9IHRoaXMuYm9keS5kb20uYmFja2dyb3VuZEhvcml6b250YWwub2Zmc2V0V2lkdGggLSB0aGlzLmxpbmVPZmZzZXQgLSB0aGlzLndpZHRoICsgMiAqIHRoaXMub3B0aW9ucy5tYWpvckxpbmVzT2Zmc2V0O1xuICAgICAgcHJvcHMubWFqb3JMaW5lSGVpZ2h0ID0gMTtcblxuICAgICAgLy8gIHRha2UgZnJhbWUgb2ZmbGluZSB3aGlsZSB1cGRhdGluZyAoaXMgYWxtb3N0IHR3aWNlIGFzIGZhc3QpXG4gICAgICBpZiAob3JpZW50YXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICBmcmFtZS5zdHlsZS50b3AgPSAnMCc7XG4gICAgICAgIGZyYW1lLnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgICAgIGZyYW1lLnN0eWxlLmJvdHRvbSA9ICcnO1xuICAgICAgICBmcmFtZS5zdHlsZS53aWR0aCA9IHRoaXMud2lkdGggKyAncHgnO1xuICAgICAgICBmcmFtZS5zdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodCArIFwicHhcIjtcbiAgICAgICAgdGhpcy5wcm9wcy53aWR0aCA9IHRoaXMuYm9keS5kb21Qcm9wcy5sZWZ0LndpZHRoO1xuICAgICAgICB0aGlzLnByb3BzLmhlaWdodCA9IHRoaXMuYm9keS5kb21Qcm9wcy5sZWZ0LmhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJpZ2h0XG4gICAgICAgIGZyYW1lLnN0eWxlLnRvcCA9ICcnO1xuICAgICAgICBmcmFtZS5zdHlsZS5ib3R0b20gPSAnMCc7XG4gICAgICAgIGZyYW1lLnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgICAgIGZyYW1lLnN0eWxlLndpZHRoID0gdGhpcy53aWR0aCArICdweCc7XG4gICAgICAgIGZyYW1lLnN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICB0aGlzLnByb3BzLndpZHRoID0gdGhpcy5ib2R5LmRvbVByb3BzLnJpZ2h0LndpZHRoO1xuICAgICAgICB0aGlzLnByb3BzLmhlaWdodCA9IHRoaXMuYm9keS5kb21Qcm9wcy5yaWdodC5oZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIHJlc2l6ZWQgPSB0aGlzLl9yZWRyYXdMYWJlbHMoKTtcbiAgICAgIHJlc2l6ZWQgPSB0aGlzLl9pc1Jlc2l6ZWQoKSB8fCByZXNpemVkO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmljb25zID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX3JlZHJhd0dyb3VwSWNvbnMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NsZWFudXBJY29ucygpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZWRyYXdUaXRsZShvcmllbnRhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiByZXNpemVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXBhaW50IG1ham9yIGFuZCBtaW5vciB0ZXh0IGxhYmVscyBhbmQgdmVydGljYWwgZ3JpZCBsaW5lc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgRGF0YUF4aXMucHJvdG90eXBlLl9yZWRyYXdMYWJlbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciByZXNpemVkID0gZmFsc2U7XG4gICAgRE9NdXRpbC5wcmVwYXJlRWxlbWVudHModGhpcy5ET01lbGVtZW50cy5saW5lcyk7XG4gICAgRE9NdXRpbC5wcmVwYXJlRWxlbWVudHModGhpcy5ET01lbGVtZW50cy5sYWJlbHMpO1xuICAgIHZhciBvcmllbnRhdGlvbiA9IHRoaXMub3B0aW9uc1snb3JpZW50YXRpb24nXTtcbiAgICB2YXIgY3VzdG9tUmFuZ2UgPSB0aGlzLm9wdGlvbnNbb3JpZW50YXRpb25dLnJhbmdlICE9IHVuZGVmaW5lZCA/IHRoaXMub3B0aW9uc1tvcmllbnRhdGlvbl0ucmFuZ2UgOiB7fTtcblxuICAgIC8vT3ZlcnJpZGUgcmFuZ2Ugd2l0aCBtYW51YWwgb3B0aW9uczpcbiAgICB2YXIgYXV0b1NjYWxlRW5kID0gdHJ1ZTtcbiAgICBpZiAoY3VzdG9tUmFuZ2UubWF4ICE9IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5yYW5nZS5lbmQgPSBjdXN0b21SYW5nZS5tYXg7XG4gICAgICBhdXRvU2NhbGVFbmQgPSBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGF1dG9TY2FsZVN0YXJ0ID0gdHJ1ZTtcbiAgICBpZiAoY3VzdG9tUmFuZ2UubWluICE9IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5yYW5nZS5zdGFydCA9IGN1c3RvbVJhbmdlLm1pbjtcbiAgICAgIGF1dG9TY2FsZVN0YXJ0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5zY2FsZSA9IG5ldyBEYXRhU2NhbGUodGhpcy5yYW5nZS5zdGFydCwgdGhpcy5yYW5nZS5lbmQsIGF1dG9TY2FsZVN0YXJ0LCBhdXRvU2NhbGVFbmQsIHRoaXMuZG9tLmZyYW1lLm9mZnNldEhlaWdodCwgdGhpcy5wcm9wcy5tYWpvckNoYXJIZWlnaHQsIHRoaXMub3B0aW9ucy5hbGlnblplcm9zLCB0aGlzLm9wdGlvbnNbb3JpZW50YXRpb25dLmZvcm1hdCk7XG5cbiAgICBpZiAodGhpcy5tYXN0ZXIgPT09IGZhbHNlICYmIHRoaXMubWFzdGVyQXhpcyAhPSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuc2NhbGUuZm9sbG93U2NhbGUodGhpcy5tYXN0ZXJBeGlzLnNjYWxlKTtcbiAgICB9XG5cbiAgICAvL0lzIHVwZGF0ZWQgaW4gc2lkZS1lZmZlY3Qgb2YgX3JlZHJhd0xhYmVsKCk6XG4gICAgdGhpcy5tYXhMYWJlbFNpemUgPSAwO1xuXG4gICAgdmFyIGxpbmVzID0gdGhpcy5zY2FsZS5nZXRMaW5lcygpO1xuICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIHZhciB5ID0gbGluZS55O1xuICAgICAgdmFyIGlzTWFqb3IgPSBsaW5lLm1ham9yO1xuICAgICAgaWYgKF90aGlzLm9wdGlvbnNbJ3Nob3dNaW5vckxhYmVscyddICYmIGlzTWFqb3IgPT09IGZhbHNlKSB7XG4gICAgICAgIF90aGlzLl9yZWRyYXdMYWJlbCh5IC0gMiwgbGluZS52YWwsIG9yaWVudGF0aW9uLCAndmlzLXktYXhpcyB2aXMtbWlub3InLCBfdGhpcy5wcm9wcy5taW5vckNoYXJIZWlnaHQpO1xuICAgICAgfVxuICAgICAgaWYgKGlzTWFqb3IpIHtcbiAgICAgICAgaWYgKHkgPj0gMCkge1xuICAgICAgICAgIF90aGlzLl9yZWRyYXdMYWJlbCh5IC0gMiwgbGluZS52YWwsIG9yaWVudGF0aW9uLCAndmlzLXktYXhpcyB2aXMtbWFqb3InLCBfdGhpcy5wcm9wcy5tYWpvckNoYXJIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoX3RoaXMubWFzdGVyID09PSB0cnVlKSB7XG4gICAgICAgIGlmIChpc01ham9yKSB7XG4gICAgICAgICAgX3RoaXMuX3JlZHJhd0xpbmUoeSwgb3JpZW50YXRpb24sICd2aXMtZ3JpZCB2aXMtaG9yaXpvbnRhbCB2aXMtbWFqb3InLCBfdGhpcy5vcHRpb25zLm1ham9yTGluZXNPZmZzZXQsIF90aGlzLnByb3BzLm1ham9yTGluZVdpZHRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpcy5fcmVkcmF3TGluZSh5LCBvcmllbnRhdGlvbiwgJ3Zpcy1ncmlkIHZpcy1ob3Jpem9udGFsIHZpcy1taW5vcicsIF90aGlzLm9wdGlvbnMubWlub3JMaW5lc09mZnNldCwgX3RoaXMucHJvcHMubWlub3JMaW5lV2lkdGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBOb3RlIHRoYXQgdGl0bGUgaXMgcm90YXRlZCwgc28gd2UncmUgdXNpbmcgdGhlIGhlaWdodCwgbm90IHdpZHRoIVxuICAgIHZhciB0aXRsZVdpZHRoID0gMDtcbiAgICBpZiAodGhpcy5vcHRpb25zW29yaWVudGF0aW9uXS50aXRsZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMub3B0aW9uc1tvcmllbnRhdGlvbl0udGl0bGUudGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aXRsZVdpZHRoID0gdGhpcy5wcm9wcy50aXRsZUNoYXJIZWlnaHQ7XG4gICAgfVxuICAgIHZhciBvZmZzZXQgPSB0aGlzLm9wdGlvbnMuaWNvbnMgPT09IHRydWUgPyBNYXRoLm1heCh0aGlzLm9wdGlvbnMuaWNvbldpZHRoLCB0aXRsZVdpZHRoKSArIHRoaXMub3B0aW9ucy5sYWJlbE9mZnNldFggKyAxNSA6IHRpdGxlV2lkdGggKyB0aGlzLm9wdGlvbnMubGFiZWxPZmZzZXRYICsgMTU7XG5cbiAgICAvLyB0aGlzIHdpbGwgcmVzaXplIHRoZSB5QXhpcyB0byBhY2NvbW1vZGF0ZSB0aGUgbGFiZWxzLlxuICAgIGlmICh0aGlzLm1heExhYmVsU2l6ZSA+IHRoaXMud2lkdGggLSBvZmZzZXQgJiYgdGhpcy5vcHRpb25zLnZpc2libGUgPT09IHRydWUpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLm1heExhYmVsU2l6ZSArIG9mZnNldDtcbiAgICAgIHRoaXMub3B0aW9ucy53aWR0aCA9IHRoaXMud2lkdGggKyBcInB4XCI7XG4gICAgICBET011dGlsLmNsZWFudXBFbGVtZW50cyh0aGlzLkRPTWVsZW1lbnRzLmxpbmVzKTtcbiAgICAgIERPTXV0aWwuY2xlYW51cEVsZW1lbnRzKHRoaXMuRE9NZWxlbWVudHMubGFiZWxzKTtcbiAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgICByZXNpemVkID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gdGhpcyB3aWxsIHJlc2l6ZSB0aGUgeUF4aXMgaWYgaXQgaXMgdG9vIGJpZyBmb3IgdGhlIGxhYmVscy5cbiAgICBlbHNlIGlmICh0aGlzLm1heExhYmVsU2l6ZSA8IHRoaXMud2lkdGggLSBvZmZzZXQgJiYgdGhpcy5vcHRpb25zLnZpc2libGUgPT09IHRydWUgJiYgdGhpcy53aWR0aCA+IHRoaXMubWluV2lkdGgpIHtcbiAgICAgICAgdGhpcy53aWR0aCA9IE1hdGgubWF4KHRoaXMubWluV2lkdGgsIHRoaXMubWF4TGFiZWxTaXplICsgb2Zmc2V0KTtcbiAgICAgICAgdGhpcy5vcHRpb25zLndpZHRoID0gdGhpcy53aWR0aCArIFwicHhcIjtcbiAgICAgICAgRE9NdXRpbC5jbGVhbnVwRWxlbWVudHModGhpcy5ET01lbGVtZW50cy5saW5lcyk7XG4gICAgICAgIERPTXV0aWwuY2xlYW51cEVsZW1lbnRzKHRoaXMuRE9NZWxlbWVudHMubGFiZWxzKTtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICAgICAgcmVzaXplZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBET011dGlsLmNsZWFudXBFbGVtZW50cyh0aGlzLkRPTWVsZW1lbnRzLmxpbmVzKTtcbiAgICAgICAgRE9NdXRpbC5jbGVhbnVwRWxlbWVudHModGhpcy5ET01lbGVtZW50cy5sYWJlbHMpO1xuICAgICAgICByZXNpemVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICByZXR1cm4gcmVzaXplZDtcbiAgfTtcblxuICBEYXRhQXhpcy5wcm90b3R5cGUuY29udmVydFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NhbGUuY29udmVydFZhbHVlKHZhbHVlKTtcbiAgfTtcblxuICBEYXRhQXhpcy5wcm90b3R5cGUuc2NyZWVuVG9WYWx1ZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIHRoaXMuc2NhbGUuc2NyZWVuVG9WYWx1ZSh4KTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbGFiZWwgZm9yIHRoZSBheGlzIGF0IHBvc2l0aW9uIHhcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHlcbiAgICogQHBhcmFtIHRleHRcbiAgICogQHBhcmFtIG9yaWVudGF0aW9uXG4gICAqIEBwYXJhbSBjbGFzc05hbWVcbiAgICogQHBhcmFtIGNoYXJhY3RlckhlaWdodFxuICAgKi9cbiAgRGF0YUF4aXMucHJvdG90eXBlLl9yZWRyYXdMYWJlbCA9IGZ1bmN0aW9uICh5LCB0ZXh0LCBvcmllbnRhdGlvbiwgY2xhc3NOYW1lLCBjaGFyYWN0ZXJIZWlnaHQpIHtcbiAgICAvLyByZXVzZSByZWR1bmRhbnQgbGFiZWxcbiAgICB2YXIgbGFiZWwgPSBET011dGlsLmdldERPTUVsZW1lbnQoJ2RpdicsIHRoaXMuRE9NZWxlbWVudHMubGFiZWxzLCB0aGlzLmRvbS5mcmFtZSk7IC8vdGhpcy5kb20ucmVkdW5kYW50LmxhYmVscy5zaGlmdCgpO1xuICAgIGxhYmVsLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICBsYWJlbC5pbm5lckhUTUwgPSB0ZXh0O1xuICAgIGlmIChvcmllbnRhdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICBsYWJlbC5zdHlsZS5sZWZ0ID0gJy0nICsgdGhpcy5vcHRpb25zLmxhYmVsT2Zmc2V0WCArICdweCc7XG4gICAgICBsYWJlbC5zdHlsZS50ZXh0QWxpZ24gPSBcInJpZ2h0XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhYmVsLnN0eWxlLnJpZ2h0ID0gJy0nICsgdGhpcy5vcHRpb25zLmxhYmVsT2Zmc2V0WCArICdweCc7XG4gICAgICBsYWJlbC5zdHlsZS50ZXh0QWxpZ24gPSBcImxlZnRcIjtcbiAgICB9XG5cbiAgICBsYWJlbC5zdHlsZS50b3AgPSB5IC0gMC41ICogY2hhcmFjdGVySGVpZ2h0ICsgdGhpcy5vcHRpb25zLmxhYmVsT2Zmc2V0WSArICdweCc7XG5cbiAgICB0ZXh0ICs9ICcnO1xuXG4gICAgdmFyIGxhcmdlc3RXaWR0aCA9IE1hdGgubWF4KHRoaXMucHJvcHMubWFqb3JDaGFyV2lkdGgsIHRoaXMucHJvcHMubWlub3JDaGFyV2lkdGgpO1xuICAgIGlmICh0aGlzLm1heExhYmVsU2l6ZSA8IHRleHQubGVuZ3RoICogbGFyZ2VzdFdpZHRoKSB7XG4gICAgICB0aGlzLm1heExhYmVsU2l6ZSA9IHRleHQubGVuZ3RoICogbGFyZ2VzdFdpZHRoO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbWlub3IgbGluZSBmb3IgdGhlIGF4aXMgYXQgcG9zaXRpb24geVxuICAgKiBAcGFyYW0geVxuICAgKiBAcGFyYW0gb3JpZW50YXRpb25cbiAgICogQHBhcmFtIGNsYXNzTmFtZVxuICAgKiBAcGFyYW0gb2Zmc2V0XG4gICAqIEBwYXJhbSB3aWR0aFxuICAgKi9cbiAgRGF0YUF4aXMucHJvdG90eXBlLl9yZWRyYXdMaW5lID0gZnVuY3Rpb24gKHksIG9yaWVudGF0aW9uLCBjbGFzc05hbWUsIG9mZnNldCwgd2lkdGgpIHtcbiAgICBpZiAodGhpcy5tYXN0ZXIgPT09IHRydWUpIHtcbiAgICAgIHZhciBsaW5lID0gRE9NdXRpbC5nZXRET01FbGVtZW50KCdkaXYnLCB0aGlzLkRPTWVsZW1lbnRzLmxpbmVzLCB0aGlzLmRvbS5saW5lQ29udGFpbmVyKTsgLy90aGlzLmRvbS5yZWR1bmRhbnQubGluZXMuc2hpZnQoKTtcbiAgICAgIGxpbmUuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgbGluZS5pbm5lckhUTUwgPSAnJztcblxuICAgICAgaWYgKG9yaWVudGF0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgbGluZS5zdHlsZS5sZWZ0ID0gdGhpcy53aWR0aCAtIG9mZnNldCArICdweCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW5lLnN0eWxlLnJpZ2h0ID0gdGhpcy53aWR0aCAtIG9mZnNldCArICdweCc7XG4gICAgICB9XG5cbiAgICAgIGxpbmUuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICBsaW5lLnN0eWxlLnRvcCA9IHkgKyAncHgnO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgdGl0bGUgZm9yIHRoZSBheGlzXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSBvcmllbnRhdGlvblxuICAgKi9cbiAgRGF0YUF4aXMucHJvdG90eXBlLl9yZWRyYXdUaXRsZSA9IGZ1bmN0aW9uIChvcmllbnRhdGlvbikge1xuICAgIERPTXV0aWwucHJlcGFyZUVsZW1lbnRzKHRoaXMuRE9NZWxlbWVudHMudGl0bGUpO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIHRpdGxlIGlzIGRlZmluZWQgZm9yIHRoaXMgYXhlc1xuICAgIGlmICh0aGlzLm9wdGlvbnNbb3JpZW50YXRpb25dLnRpdGxlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5vcHRpb25zW29yaWVudGF0aW9uXS50aXRsZS50ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciB0aXRsZSA9IERPTXV0aWwuZ2V0RE9NRWxlbWVudCgnZGl2JywgdGhpcy5ET01lbGVtZW50cy50aXRsZSwgdGhpcy5kb20uZnJhbWUpO1xuICAgICAgdGl0bGUuY2xhc3NOYW1lID0gJ3Zpcy15LWF4aXMgdmlzLXRpdGxlIHZpcy0nICsgb3JpZW50YXRpb247XG4gICAgICB0aXRsZS5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnNbb3JpZW50YXRpb25dLnRpdGxlLnRleHQ7XG5cbiAgICAgIC8vIEFkZCBzdHlsZSAtIGlmIHByb3ZpZGVkXG4gICAgICBpZiAodGhpcy5vcHRpb25zW29yaWVudGF0aW9uXS50aXRsZS5zdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHV0aWwuYWRkQ3NzVGV4dCh0aXRsZSwgdGhpcy5vcHRpb25zW29yaWVudGF0aW9uXS50aXRsZS5zdHlsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcmllbnRhdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHRpdGxlLnN0eWxlLmxlZnQgPSB0aGlzLnByb3BzLnRpdGxlQ2hhckhlaWdodCArICdweCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aXRsZS5zdHlsZS5yaWdodCA9IHRoaXMucHJvcHMudGl0bGVDaGFySGVpZ2h0ICsgJ3B4JztcbiAgICAgIH1cblxuICAgICAgdGl0bGUuc3R5bGUud2lkdGggPSB0aGlzLmhlaWdodCArICdweCc7XG4gICAgfVxuXG4gICAgLy8gd2UgbmVlZCB0byBjbGVhbiB1cCBpbiBjYXNlIHdlIGRpZCBub3QgdXNlIGFsbCBlbGVtZW50cy5cbiAgICBET011dGlsLmNsZWFudXBFbGVtZW50cyh0aGlzLkRPTWVsZW1lbnRzLnRpdGxlKTtcbiAgfTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHRoZSBzaXplIG9mIHRleHQgb24gdGhlIGF4aXMgKGJvdGggbWFqb3IgYW5kIG1pbm9yIGF4aXMpLlxuICAgKiBUaGUgc2l6ZSBpcyBjYWxjdWxhdGVkIG9ubHkgb25jZSBhbmQgdGhlbiBjYWNoZWQgaW4gdGhpcy5wcm9wcy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIERhdGFBeGlzLnByb3RvdHlwZS5fY2FsY3VsYXRlQ2hhclNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gZGV0ZXJtaW5lIHRoZSBjaGFyIHdpZHRoIGFuZCBoZWlnaHQgb24gdGhlIG1pbm9yIGF4aXNcbiAgICBpZiAoISgnbWlub3JDaGFySGVpZ2h0JyBpbiB0aGlzLnByb3BzKSkge1xuICAgICAgdmFyIHRleHRNaW5vciA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcwJyk7XG4gICAgICB2YXIgbWVhc3VyZUNoYXJNaW5vciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgbWVhc3VyZUNoYXJNaW5vci5jbGFzc05hbWUgPSAndmlzLXktYXhpcyB2aXMtbWlub3IgdmlzLW1lYXN1cmUnO1xuICAgICAgbWVhc3VyZUNoYXJNaW5vci5hcHBlbmRDaGlsZCh0ZXh0TWlub3IpO1xuICAgICAgdGhpcy5kb20uZnJhbWUuYXBwZW5kQ2hpbGQobWVhc3VyZUNoYXJNaW5vcik7XG5cbiAgICAgIHRoaXMucHJvcHMubWlub3JDaGFySGVpZ2h0ID0gbWVhc3VyZUNoYXJNaW5vci5jbGllbnRIZWlnaHQ7XG4gICAgICB0aGlzLnByb3BzLm1pbm9yQ2hhcldpZHRoID0gbWVhc3VyZUNoYXJNaW5vci5jbGllbnRXaWR0aDtcblxuICAgICAgdGhpcy5kb20uZnJhbWUucmVtb3ZlQ2hpbGQobWVhc3VyZUNoYXJNaW5vcik7XG4gICAgfVxuXG4gICAgaWYgKCEoJ21ham9yQ2hhckhlaWdodCcgaW4gdGhpcy5wcm9wcykpIHtcbiAgICAgIHZhciB0ZXh0TWFqb3IgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnMCcpO1xuICAgICAgdmFyIG1lYXN1cmVDaGFyTWFqb3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIG1lYXN1cmVDaGFyTWFqb3IuY2xhc3NOYW1lID0gJ3Zpcy15LWF4aXMgdmlzLW1ham9yIHZpcy1tZWFzdXJlJztcbiAgICAgIG1lYXN1cmVDaGFyTWFqb3IuYXBwZW5kQ2hpbGQodGV4dE1ham9yKTtcbiAgICAgIHRoaXMuZG9tLmZyYW1lLmFwcGVuZENoaWxkKG1lYXN1cmVDaGFyTWFqb3IpO1xuXG4gICAgICB0aGlzLnByb3BzLm1ham9yQ2hhckhlaWdodCA9IG1lYXN1cmVDaGFyTWFqb3IuY2xpZW50SGVpZ2h0O1xuICAgICAgdGhpcy5wcm9wcy5tYWpvckNoYXJXaWR0aCA9IG1lYXN1cmVDaGFyTWFqb3IuY2xpZW50V2lkdGg7XG5cbiAgICAgIHRoaXMuZG9tLmZyYW1lLnJlbW92ZUNoaWxkKG1lYXN1cmVDaGFyTWFqb3IpO1xuICAgIH1cblxuICAgIGlmICghKCd0aXRsZUNoYXJIZWlnaHQnIGluIHRoaXMucHJvcHMpKSB7XG4gICAgICB2YXIgdGV4dFRpdGxlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJzAnKTtcbiAgICAgIHZhciBtZWFzdXJlQ2hhclRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBtZWFzdXJlQ2hhclRpdGxlLmNsYXNzTmFtZSA9ICd2aXMteS1heGlzIHZpcy10aXRsZSB2aXMtbWVhc3VyZSc7XG4gICAgICBtZWFzdXJlQ2hhclRpdGxlLmFwcGVuZENoaWxkKHRleHRUaXRsZSk7XG4gICAgICB0aGlzLmRvbS5mcmFtZS5hcHBlbmRDaGlsZChtZWFzdXJlQ2hhclRpdGxlKTtcblxuICAgICAgdGhpcy5wcm9wcy50aXRsZUNoYXJIZWlnaHQgPSBtZWFzdXJlQ2hhclRpdGxlLmNsaWVudEhlaWdodDtcbiAgICAgIHRoaXMucHJvcHMudGl0bGVDaGFyV2lkdGggPSBtZWFzdXJlQ2hhclRpdGxlLmNsaWVudFdpZHRoO1xuXG4gICAgICB0aGlzLmRvbS5mcmFtZS5yZW1vdmVDaGlsZChtZWFzdXJlQ2hhclRpdGxlKTtcbiAgICB9XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBEYXRhQXhpcztcblxuLyoqKi8gfSxcbi8qIDUzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIENyZWF0ZWQgYnkgbHVkbyBvbiAyNS0xLTE2LlxuICAgKi9cblxuICBmdW5jdGlvbiBEYXRhU2NhbGUoc3RhcnQsIGVuZCwgYXV0b1NjYWxlU3RhcnQsIGF1dG9TY2FsZUVuZCwgY29udGFpbmVySGVpZ2h0LCBtYWpvckNoYXJIZWlnaHQpIHtcbiAgICB2YXIgemVyb0FsaWduID0gYXJndW1lbnRzLmxlbmd0aCA8PSA2IHx8IGFyZ3VtZW50c1s2XSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBhcmd1bWVudHNbNl07XG4gICAgdmFyIGZvcm1hdHRpbmdGdW5jdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gNyB8fCBhcmd1bWVudHNbN10gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogYXJndW1lbnRzWzddO1xuXG4gICAgdGhpcy5tYWpvclN0ZXBzID0gWzEsIDIsIDUsIDEwXTtcbiAgICB0aGlzLm1pbm9yU3RlcHMgPSBbMC4yNSwgMC41LCAxLCAyXTtcbiAgICB0aGlzLmN1c3RvbUxpbmVzID0gbnVsbDtcblxuICAgIHRoaXMuY29udGFpbmVySGVpZ2h0ID0gY29udGFpbmVySGVpZ2h0O1xuICAgIHRoaXMubWFqb3JDaGFySGVpZ2h0ID0gbWFqb3JDaGFySGVpZ2h0O1xuICAgIHRoaXMuX3N0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5fZW5kID0gZW5kO1xuXG4gICAgdGhpcy5zY2FsZSA9IDE7XG4gICAgdGhpcy5taW5vclN0ZXBJZHggPSAtMTtcbiAgICB0aGlzLm1hZ25pdHVkZWZhY3RvciA9IDE7XG4gICAgdGhpcy5kZXRlcm1pbmVTY2FsZSgpO1xuXG4gICAgdGhpcy56ZXJvQWxpZ24gPSB6ZXJvQWxpZ247XG4gICAgdGhpcy5hdXRvU2NhbGVTdGFydCA9IGF1dG9TY2FsZVN0YXJ0O1xuICAgIHRoaXMuYXV0b1NjYWxlRW5kID0gYXV0b1NjYWxlRW5kO1xuXG4gICAgdGhpcy5mb3JtYXR0aW5nRnVuY3Rpb24gPSBmb3JtYXR0aW5nRnVuY3Rpb247XG5cbiAgICBpZiAoYXV0b1NjYWxlU3RhcnQgfHwgYXV0b1NjYWxlRW5kKSB7XG4gICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgdmFyIHJvdW5kVG9NaW5vciA9IGZ1bmN0aW9uIHJvdW5kVG9NaW5vcih2YWx1ZSkge1xuICAgICAgICB2YXIgcm91bmRlZCA9IHZhbHVlIC0gdmFsdWUgJSAobWUubWFnbml0dWRlZmFjdG9yICogbWUubWlub3JTdGVwc1ttZS5taW5vclN0ZXBJZHhdKTtcbiAgICAgICAgaWYgKHZhbHVlICUgKG1lLm1hZ25pdHVkZWZhY3RvciAqIG1lLm1pbm9yU3RlcHNbbWUubWlub3JTdGVwSWR4XSkgPiAwLjUgKiAobWUubWFnbml0dWRlZmFjdG9yICogbWUubWlub3JTdGVwc1ttZS5taW5vclN0ZXBJZHhdKSkge1xuICAgICAgICAgIHJldHVybiByb3VuZGVkICsgbWUubWFnbml0dWRlZmFjdG9yICogbWUubWlub3JTdGVwc1ttZS5taW5vclN0ZXBJZHhdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiByb3VuZGVkO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKGF1dG9TY2FsZVN0YXJ0KSB7XG4gICAgICAgIHRoaXMuX3N0YXJ0IC09IHRoaXMubWFnbml0dWRlZmFjdG9yICogMiAqIHRoaXMubWlub3JTdGVwc1t0aGlzLm1pbm9yU3RlcElkeF07XG4gICAgICAgIHRoaXMuX3N0YXJ0ID0gcm91bmRUb01pbm9yKHRoaXMuX3N0YXJ0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGF1dG9TY2FsZUVuZCkge1xuICAgICAgICB0aGlzLl9lbmQgKz0gdGhpcy5tYWduaXR1ZGVmYWN0b3IgKiB0aGlzLm1pbm9yU3RlcHNbdGhpcy5taW5vclN0ZXBJZHhdO1xuICAgICAgICB0aGlzLl9lbmQgPSByb3VuZFRvTWlub3IodGhpcy5fZW5kKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGV0ZXJtaW5lU2NhbGUoKTtcbiAgICB9XG4gIH1cblxuICBEYXRhU2NhbGUucHJvdG90eXBlLnNldENoYXJIZWlnaHQgPSBmdW5jdGlvbiAobWFqb3JDaGFySGVpZ2h0KSB7XG4gICAgdGhpcy5tYWpvckNoYXJIZWlnaHQgPSBtYWpvckNoYXJIZWlnaHQ7XG4gIH07XG5cbiAgRGF0YVNjYWxlLnByb3RvdHlwZS5zZXRIZWlnaHQgPSBmdW5jdGlvbiAoY29udGFpbmVySGVpZ2h0KSB7XG4gICAgdGhpcy5jb250YWluZXJIZWlnaHQgPSBjb250YWluZXJIZWlnaHQ7XG4gIH07XG5cbiAgRGF0YVNjYWxlLnByb3RvdHlwZS5kZXRlcm1pbmVTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmFuZ2UgPSB0aGlzLl9lbmQgLSB0aGlzLl9zdGFydDtcbiAgICB0aGlzLnNjYWxlID0gdGhpcy5jb250YWluZXJIZWlnaHQgLyByYW5nZTtcbiAgICB2YXIgbWluaW11bVN0ZXBWYWx1ZSA9IHRoaXMubWFqb3JDaGFySGVpZ2h0IC8gdGhpcy5zY2FsZTtcbiAgICB2YXIgb3JkZXJPZk1hZ25pdHVkZSA9IHJhbmdlID4gMCA/IE1hdGgucm91bmQoTWF0aC5sb2cocmFuZ2UpIC8gTWF0aC5MTjEwKSA6IDA7XG5cbiAgICB0aGlzLm1pbm9yU3RlcElkeCA9IC0xO1xuICAgIHRoaXMubWFnbml0dWRlZmFjdG9yID0gTWF0aC5wb3coMTAsIG9yZGVyT2ZNYWduaXR1ZGUpO1xuXG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBpZiAob3JkZXJPZk1hZ25pdHVkZSA8IDApIHtcbiAgICAgIHN0YXJ0ID0gb3JkZXJPZk1hZ25pdHVkZTtcbiAgICB9XG5cbiAgICB2YXIgc29sdXRpb25Gb3VuZCA9IGZhbHNlO1xuICAgIGZvciAodmFyIGwgPSBzdGFydDsgTWF0aC5hYnMobCkgPD0gTWF0aC5hYnMob3JkZXJPZk1hZ25pdHVkZSk7IGwrKykge1xuICAgICAgdGhpcy5tYWduaXR1ZGVmYWN0b3IgPSBNYXRoLnBvdygxMCwgbCk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMubWlub3JTdGVwcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgc3RlcFNpemUgPSB0aGlzLm1hZ25pdHVkZWZhY3RvciAqIHRoaXMubWlub3JTdGVwc1tqXTtcbiAgICAgICAgaWYgKHN0ZXBTaXplID49IG1pbmltdW1TdGVwVmFsdWUpIHtcbiAgICAgICAgICBzb2x1dGlvbkZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLm1pbm9yU3RlcElkeCA9IGo7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzb2x1dGlvbkZvdW5kID09PSB0cnVlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBEYXRhU2NhbGUucHJvdG90eXBlLmlzX21ham9yID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICUgKHRoaXMubWFnbml0dWRlZmFjdG9yICogdGhpcy5tYWpvclN0ZXBzW3RoaXMubWlub3JTdGVwSWR4XSkgPT09IDA7XG4gIH07XG5cbiAgRGF0YVNjYWxlLnByb3RvdHlwZS5nZXRTdGVwID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1hZ25pdHVkZWZhY3RvciAqIHRoaXMubWlub3JTdGVwc1t0aGlzLm1pbm9yU3RlcElkeF07XG4gIH07XG5cbiAgRGF0YVNjYWxlLnByb3RvdHlwZS5nZXRGaXJzdE1ham9yID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtYWpvclN0ZXAgPSB0aGlzLm1hZ25pdHVkZWZhY3RvciAqIHRoaXMubWFqb3JTdGVwc1t0aGlzLm1pbm9yU3RlcElkeF07XG4gICAgcmV0dXJuIHRoaXMuY29udmVydFZhbHVlKHRoaXMuX3N0YXJ0ICsgKG1ham9yU3RlcCAtIHRoaXMuX3N0YXJ0ICUgbWFqb3JTdGVwKSAlIG1ham9yU3RlcCk7XG4gIH07XG5cbiAgRGF0YVNjYWxlLnByb3RvdHlwZS5mb3JtYXRWYWx1ZSA9IGZ1bmN0aW9uIChjdXJyZW50KSB7XG4gICAgdmFyIHJldHVyblZhbHVlID0gY3VycmVudC50b1ByZWNpc2lvbig1KTtcbiAgICBpZiAodHlwZW9mIHRoaXMuZm9ybWF0dGluZ0Z1bmN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm5WYWx1ZSA9IHRoaXMuZm9ybWF0dGluZ0Z1bmN0aW9uKGN1cnJlbnQpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcmV0dXJuVmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gJycgKyByZXR1cm5WYWx1ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXR1cm5WYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN1cnJlbnQudG9QcmVjaXNpb24oNSk7XG4gICAgfVxuICB9O1xuXG4gIERhdGFTY2FsZS5wcm90b3R5cGUuZ2V0TGluZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxpbmVzID0gW107XG4gICAgdmFyIHN0ZXAgPSB0aGlzLmdldFN0ZXAoKTtcbiAgICB2YXIgYm90dG9tT2Zmc2V0ID0gKHN0ZXAgLSB0aGlzLl9zdGFydCAlIHN0ZXApICUgc3RlcDtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5fc3RhcnQgKyBib3R0b21PZmZzZXQ7IHRoaXMuX2VuZCAtIGkgPiAwLjAwMDAxOyBpICs9IHN0ZXApIHtcbiAgICAgIGlmIChpICE9IHRoaXMuX3N0YXJ0KSB7XG4gICAgICAgIC8vU2tpcCB0aGUgYm90dG9tIGxpbmVcbiAgICAgICAgbGluZXMucHVzaCh7IG1ham9yOiB0aGlzLmlzX21ham9yKGkpLCB5OiB0aGlzLmNvbnZlcnRWYWx1ZShpKSwgdmFsOiB0aGlzLmZvcm1hdFZhbHVlKGkpIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGluZXM7XG4gIH07XG5cbiAgRGF0YVNjYWxlLnByb3RvdHlwZS5mb2xsb3dTY2FsZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgIHZhciBvbGRTdGVwSWR4ID0gdGhpcy5taW5vclN0ZXBJZHg7XG4gICAgdmFyIG9sZFN0YXJ0ID0gdGhpcy5fc3RhcnQ7XG4gICAgdmFyIG9sZEVuZCA9IHRoaXMuX2VuZDtcblxuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdmFyIGluY3JlYXNlTWFnbml0dWRlID0gZnVuY3Rpb24gaW5jcmVhc2VNYWduaXR1ZGUoKSB7XG4gICAgICBtZS5tYWduaXR1ZGVmYWN0b3IgKj0gMjtcbiAgICB9O1xuICAgIHZhciBkZWNyZWFzZU1hZ25pdHVkZSA9IGZ1bmN0aW9uIGRlY3JlYXNlTWFnbml0dWRlKCkge1xuICAgICAgbWUubWFnbml0dWRlZmFjdG9yIC89IDI7XG4gICAgfTtcblxuICAgIGlmIChvdGhlci5taW5vclN0ZXBJZHggPD0gMSAmJiB0aGlzLm1pbm9yU3RlcElkeCA8PSAxIHx8IG90aGVyLm1pbm9yU3RlcElkeCA+IDEgJiYgdGhpcy5taW5vclN0ZXBJZHggPiAxKSB7XG4gICAgICAvL2Vhc3ksIG5vIG5lZWQgdG8gY2hhbmdlIHN0ZXBJZHggbm9yIG11bHRpcGxpY2F0aW9uIGZhY3RvclxuICAgIH0gZWxzZSBpZiAob3RoZXIubWlub3JTdGVwSWR4IDwgdGhpcy5taW5vclN0ZXBJZHgpIHtcbiAgICAgICAgLy9JJ20gNSwgdGhleSBhcmUgNCBwZXIgbWFqb3IuXG4gICAgICAgIHRoaXMubWlub3JTdGVwSWR4ID0gMTtcbiAgICAgICAgaWYgKG9sZFN0ZXBJZHggPT0gMikge1xuICAgICAgICAgIGluY3JlYXNlTWFnbml0dWRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5jcmVhc2VNYWduaXR1ZGUoKTtcbiAgICAgICAgICBpbmNyZWFzZU1hZ25pdHVkZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvL0knbSA0LCB0aGV5IGFyZSA1IHBlciBtYWpvclxuICAgICAgICB0aGlzLm1pbm9yU3RlcElkeCA9IDI7XG4gICAgICAgIGlmIChvbGRTdGVwSWR4ID09IDEpIHtcbiAgICAgICAgICBkZWNyZWFzZU1hZ25pdHVkZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlY3JlYXNlTWFnbml0dWRlKCk7XG4gICAgICAgICAgZGVjcmVhc2VNYWduaXR1ZGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgLy9HZXQgbWFzdGVycyBzdGF0czpcbiAgICB2YXIgbGluZXMgPSBvdGhlci5nZXRMaW5lcygpO1xuICAgIHZhciBvdGhlclplcm8gPSBvdGhlci5jb252ZXJ0VmFsdWUoMCk7XG4gICAgdmFyIG90aGVyU3RlcCA9IG90aGVyLmdldFN0ZXAoKSAqIG90aGVyLnNjYWxlO1xuXG4gICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIC8vTG9vcCB1bnRpbCBtYWduaXR1ZGUgaXMgY29ycmVjdCBmb3IgZ2l2ZW4gY29uc3RyYWlucy5cbiAgICB3aGlsZSAoIWRvbmUgJiYgY291bnQrKyA8IDUpIHtcblxuICAgICAgLy9HZXQgbXkgc3RhdHM6XG4gICAgICB0aGlzLnNjYWxlID0gb3RoZXJTdGVwIC8gKHRoaXMubWlub3JTdGVwc1t0aGlzLm1pbm9yU3RlcElkeF0gKiB0aGlzLm1hZ25pdHVkZWZhY3Rvcik7XG4gICAgICB2YXIgbmV3UmFuZ2UgPSB0aGlzLmNvbnRhaW5lckhlaWdodCAvIHRoaXMuc2NhbGU7XG5cbiAgICAgIC8vRm9yIHRoZSBjYXNlIHRoZSBtYWduaXR1ZGVmYWN0b3IgaGFzIGNoYW5nZWQ6XG4gICAgICB0aGlzLl9zdGFydCA9IG9sZFN0YXJ0O1xuICAgICAgdGhpcy5fZW5kID0gdGhpcy5fc3RhcnQgKyBuZXdSYW5nZTtcblxuICAgICAgdmFyIG15T3JpZ2luYWxaZXJvID0gdGhpcy5fZW5kICogdGhpcy5zY2FsZTtcbiAgICAgIHZhciBtYWpvclN0ZXAgPSB0aGlzLm1hZ25pdHVkZWZhY3RvciAqIHRoaXMubWFqb3JTdGVwc1t0aGlzLm1pbm9yU3RlcElkeF07XG4gICAgICB2YXIgbWFqb3JPZmZzZXQgPSB0aGlzLmdldEZpcnN0TWFqb3IoKSAtIG90aGVyLmdldEZpcnN0TWFqb3IoKTtcblxuICAgICAgaWYgKHRoaXMuemVyb0FsaWduKSB7XG4gICAgICAgIHZhciB6ZXJvT2Zmc2V0ID0gb3RoZXJaZXJvIC0gbXlPcmlnaW5hbFplcm87XG4gICAgICAgIHRoaXMuX2VuZCArPSB6ZXJvT2Zmc2V0IC8gdGhpcy5zY2FsZTtcbiAgICAgICAgdGhpcy5fc3RhcnQgPSB0aGlzLl9lbmQgLSBuZXdSYW5nZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdGhpcy5hdXRvU2NhbGVTdGFydCkge1xuICAgICAgICAgIHRoaXMuX3N0YXJ0ICs9IG1ham9yU3RlcCAtIG1ham9yT2Zmc2V0IC8gdGhpcy5zY2FsZTtcbiAgICAgICAgICB0aGlzLl9lbmQgPSB0aGlzLl9zdGFydCArIG5ld1JhbmdlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3N0YXJ0IC09IG1ham9yT2Zmc2V0IC8gdGhpcy5zY2FsZTtcbiAgICAgICAgICB0aGlzLl9lbmQgPSB0aGlzLl9zdGFydCArIG5ld1JhbmdlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuYXV0b1NjYWxlRW5kICYmIHRoaXMuX2VuZCA+IG9sZEVuZCArIDAuMDAwMDEpIHtcbiAgICAgICAgLy9OZWVkIHRvIGRlY3JlYXNlIG1hZ25pdHVkZSB0byBwcmV2ZW50IHNjYWxlIG92ZXJzaG9vdCEgKGVuZClcbiAgICAgICAgZGVjcmVhc2VNYWduaXR1ZGUoKTtcbiAgICAgICAgZG9uZSA9IGZhbHNlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5hdXRvU2NhbGVTdGFydCAmJiB0aGlzLl9zdGFydCA8IG9sZFN0YXJ0IC0gMC4wMDAwMSkge1xuICAgICAgICBpZiAodGhpcy56ZXJvQWxpZ24gJiYgb2xkU3RhcnQgPj0gMCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIkNhbid0IGFkaGVyZSB0byBnaXZlbiAnbWluJyByYW5nZSwgZHVlIHRvIHplcm9hbGlnblwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvL05lZWQgdG8gZGVjcmVhc2UgbWFnbml0dWRlIHRvIHByZXZlbnQgc2NhbGUgb3ZlcnNob290ISAoc3RhcnQpXG4gICAgICAgICAgZGVjcmVhc2VNYWduaXR1ZGUoKTtcbiAgICAgICAgICBkb25lID0gZmFsc2U7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmF1dG9TY2FsZVN0YXJ0ICYmIHRoaXMuYXV0b1NjYWxlRW5kICYmIG5ld1JhbmdlIDwgb2xkRW5kIC0gb2xkU3RhcnQpIHtcbiAgICAgICAgaW5jcmVhc2VNYWduaXR1ZGUoKTtcbiAgICAgICAgZG9uZSA9IGZhbHNlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGRvbmUgPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuICBEYXRhU2NhbGUucHJvdG90eXBlLmNvbnZlcnRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lckhlaWdodCAtICh2YWx1ZSAtIHRoaXMuX3N0YXJ0KSAqIHRoaXMuc2NhbGU7XG4gIH07XG5cbiAgRGF0YVNjYWxlLnByb3RvdHlwZS5zY3JlZW5Ub1ZhbHVlID0gZnVuY3Rpb24gKHBpeGVscykge1xuICAgIHJldHVybiAodGhpcy5jb250YWluZXJIZWlnaHQgLSBwaXhlbHMpIC8gdGhpcy5zY2FsZSArIHRoaXMuX3N0YXJ0O1xuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gRGF0YVNjYWxlO1xuXG4vKioqLyB9LFxuLyogNTQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4gIHZhciBET011dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbiAgdmFyIEJhcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1KTtcbiAgdmFyIExpbmVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nyk7XG4gIHZhciBQb2ludHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2KTtcblxuICAvKipcbiAgICogLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBncm91cCAgICAgICAgICAgIHwgdGhlIG9iamVjdCBvZiB0aGUgZ3JvdXAgZnJvbSB0aGUgZGF0YXNldFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZ3JvdXBJZCAgICAgICAgICB8IElEIG9mIHRoZSBncm91cFxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAgICAgICAgICB8IHRoZSBkZWZhdWx0IG9wdGlvbnNcbiAgICogQHBhcmFtIHthcnJheX0gZ3JvdXBzVXNpbmdEZWZhdWx0U3R5bGVzICB8IHRoaXMgYXJyYXkgaGFzIG9uZSBlbnRyZWUuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJdCBpcyBwYXNzZWQgYXMgYW4gYXJyYXkgc28gaXQgaXMgcGFzc2VkIGJ5IHJlZmVyZW5jZS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEl0IGVudW1lcmF0ZXMgdGhyb3VnaCB0aGUgZGVmYXVsdCBzdHlsZXNcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBHcmFwaEdyb3VwKGdyb3VwLCBncm91cElkLCBvcHRpb25zLCBncm91cHNVc2luZ0RlZmF1bHRTdHlsZXMpIHtcbiAgICB0aGlzLmlkID0gZ3JvdXBJZDtcbiAgICB2YXIgZmllbGRzID0gWydzYW1wbGluZycsICdzdHlsZScsICdzb3J0JywgJ3lBeGlzT3JpZW50YXRpb24nLCAnYmFyQ2hhcnQnLCAnZHJhd1BvaW50cycsICdzaGFkZWQnLCAnaW50ZXJwb2xhdGlvbicsICd6SW5kZXgnLCAnZXhjbHVkZUZyb21TdGFja2luZycsICdleGNsdWRlRnJvbUxlZ2VuZCddO1xuICAgIHRoaXMub3B0aW9ucyA9IHV0aWwuc2VsZWN0aXZlQnJpZGdlT2JqZWN0KGZpZWxkcywgb3B0aW9ucyk7XG4gICAgdGhpcy51c2luZ0RlZmF1bHRTdHlsZSA9IGdyb3VwLmNsYXNzTmFtZSA9PT0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZ3JvdXBzVXNpbmdEZWZhdWx0U3R5bGVzID0gZ3JvdXBzVXNpbmdEZWZhdWx0U3R5bGVzO1xuICAgIHRoaXMuemVyb1Bvc2l0aW9uID0gMDtcbiAgICB0aGlzLnVwZGF0ZShncm91cCk7XG4gICAgaWYgKHRoaXMudXNpbmdEZWZhdWx0U3R5bGUgPT0gdHJ1ZSkge1xuICAgICAgdGhpcy5ncm91cHNVc2luZ0RlZmF1bHRTdHlsZXNbMF0gKz0gMTtcbiAgICB9XG4gICAgdGhpcy5pdGVtc0RhdGEgPSBbXTtcbiAgICB0aGlzLnZpc2libGUgPSBncm91cC52aXNpYmxlID09PSB1bmRlZmluZWQgPyB0cnVlIDogZ3JvdXAudmlzaWJsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiB0aGlzIGxvYWRzIGEgcmVmZXJlbmNlIHRvIGFsbCBpdGVtcyBpbiB0aGlzIGdyb3VwIGludG8gdGhpcyBncm91cC5cbiAgICogQHBhcmFtIHthcnJheX0gaXRlbXNcbiAgICovXG4gIEdyYXBoR3JvdXAucHJvdG90eXBlLnNldEl0ZW1zID0gZnVuY3Rpb24gKGl0ZW1zKSB7XG4gICAgaWYgKGl0ZW1zICE9IG51bGwpIHtcbiAgICAgIHRoaXMuaXRlbXNEYXRhID0gaXRlbXM7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNvcnQgPT0gdHJ1ZSkge1xuICAgICAgICB1dGlsLmluc2VydFNvcnQodGhpcy5pdGVtc0RhdGEsIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIGEueCA+IGIueCA/IDEgOiAtMTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaXRlbXNEYXRhID0gW107XG4gICAgfVxuICB9O1xuXG4gIEdyYXBoR3JvdXAucHJvdG90eXBlLmdldEl0ZW1zID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLml0ZW1zRGF0YTtcbiAgfTtcblxuICAvKipcbiAgICogdGhpcyBpcyB1c2VkIGZvciBiYXJjaGFydHMgYW5kIHNoYWRpbmcsIHRoaXMgd2F5LCB3ZSBvbmx5IGhhdmUgdG8gY2FsY3VsYXRlIGl0IG9uY2UuXG4gICAqIEBwYXJhbSBwb3NcbiAgICovXG4gIEdyYXBoR3JvdXAucHJvdG90eXBlLnNldFplcm9Qb3NpdGlvbiA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICB0aGlzLnplcm9Qb3NpdGlvbiA9IHBvcztcbiAgfTtcblxuICAvKipcbiAgICogc2V0IHRoZSBvcHRpb25zIG9mIHRoZSBncmFwaCBncm91cCBvdmVyIHRoZSBkZWZhdWx0IG9wdGlvbnMuXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqL1xuICBHcmFwaEdyb3VwLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgZmllbGRzID0gWydzYW1wbGluZycsICdzdHlsZScsICdzb3J0JywgJ3lBeGlzT3JpZW50YXRpb24nLCAnYmFyQ2hhcnQnLCAnekluZGV4JywgJ2V4Y2x1ZGVGcm9tU3RhY2tpbmcnLCAnZXhjbHVkZUZyb21MZWdlbmQnXTtcbiAgICAgIHV0aWwuc2VsZWN0aXZlRGVlcEV4dGVuZChmaWVsZHMsIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgIC8vIGlmIHRoZSBncm91cCdzIGRyYXdQb2ludHMgaXMgYSBmdW5jdGlvbiBkZWxlZ2F0ZSB0aGUgY2FsbGJhY2sgdG8gdGhlIG9uUmVuZGVyIHByb3BlcnR5XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZHJhd1BvaW50cyA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9wdGlvbnMuZHJhd1BvaW50cyA9IHtcbiAgICAgICAgICBvblJlbmRlcjogb3B0aW9ucy5kcmF3UG9pbnRzXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHV0aWwubWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgb3B0aW9ucywgJ2ludGVycG9sYXRpb24nKTtcbiAgICAgIHV0aWwubWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgb3B0aW9ucywgJ2RyYXdQb2ludHMnKTtcbiAgICAgIHV0aWwubWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgb3B0aW9ucywgJ3NoYWRlZCcpO1xuXG4gICAgICBpZiAob3B0aW9ucy5pbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgIGlmIChfdHlwZW9mKG9wdGlvbnMuaW50ZXJwb2xhdGlvbikgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5pbnRlcnBvbGF0aW9uLnBhcmFtZXRyaXphdGlvbikge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaW50ZXJwb2xhdGlvbi5wYXJhbWV0cml6YXRpb24gPT0gJ3VuaWZvcm0nKSB7XG4gICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmFscGhhID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5pbnRlcnBvbGF0aW9uLnBhcmFtZXRyaXphdGlvbiA9PSAnY2hvcmRhbCcpIHtcbiAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmludGVycG9sYXRpb24uYWxwaGEgPSAxLjA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5wYXJhbWV0cml6YXRpb24gPSAnY2VudHJpcGV0YWwnO1xuICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5hbHBoYSA9IDAuNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIHRoaXMgdXBkYXRlcyB0aGUgY3VycmVudCBncm91cCBjbGFzcyB3aXRoIHRoZSBsYXRlc3QgZ3JvdXAgZGF0YXNldCBlbnRyZWUsIHVzZWQgaW4gX3VwZGF0ZUdyb3VwIGluIGxpbmVncmFwaFxuICAgKiBAcGFyYW0gZ3JvdXBcbiAgICovXG4gIEdyYXBoR3JvdXAucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChncm91cCkge1xuICAgIHRoaXMuZ3JvdXAgPSBncm91cDtcbiAgICB0aGlzLmNvbnRlbnQgPSBncm91cC5jb250ZW50IHx8ICdncmFwaCc7XG4gICAgdGhpcy5jbGFzc05hbWUgPSBncm91cC5jbGFzc05hbWUgfHwgdGhpcy5jbGFzc05hbWUgfHwgJ3Zpcy1ncmFwaC1ncm91cCcgKyB0aGlzLmdyb3Vwc1VzaW5nRGVmYXVsdFN0eWxlc1swXSAlIDEwO1xuICAgIHRoaXMudmlzaWJsZSA9IGdyb3VwLnZpc2libGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBncm91cC52aXNpYmxlO1xuICAgIHRoaXMuc3R5bGUgPSBncm91cC5zdHlsZTtcbiAgICB0aGlzLnNldE9wdGlvbnMoZ3JvdXAub3B0aW9ucyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIHJldHVybiB0aGUgbGVnZW5kIGVudHJlZSBmb3IgdGhpcyBncm91cC5cbiAgICpcbiAgICogQHBhcmFtIGljb25XaWR0aFxuICAgKiBAcGFyYW0gaWNvbkhlaWdodFxuICAgKiBAcmV0dXJucyB7e2ljb246IEhUTUxFbGVtZW50LCBsYWJlbDogKGdyb3VwLmNvbnRlbnR8KnxzdHJpbmcpLCBvcmllbnRhdGlvbjogKC5vcHRpb25zLnlBeGlzT3JpZW50YXRpb258Kil9fVxuICAgKi9cbiAgR3JhcGhHcm91cC5wcm90b3R5cGUuZ2V0TGVnZW5kID0gZnVuY3Rpb24gKGljb25XaWR0aCwgaWNvbkhlaWdodCwgZnJhbWV3b3JrLCB4LCB5KSB7XG4gICAgaWYgKGZyYW1ld29yayA9PSB1bmRlZmluZWQgfHwgZnJhbWV3b3JrID09IG51bGwpIHtcbiAgICAgIHZhciBzdmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgXCJzdmdcIik7XG4gICAgICBmcmFtZXdvcmsgPSB7IHN2Zzogc3ZnLCBzdmdFbGVtZW50czoge30sIG9wdGlvbnM6IHRoaXMub3B0aW9ucywgZ3JvdXBzOiBbdGhpc10gfTtcbiAgICB9XG4gICAgaWYgKHggPT0gdW5kZWZpbmVkIHx8IHggPT0gbnVsbCkge1xuICAgICAgeCA9IDA7XG4gICAgfVxuICAgIGlmICh5ID09IHVuZGVmaW5lZCB8fCB5ID09IG51bGwpIHtcbiAgICAgIHkgPSAwLjUgKiBpY29uSGVpZ2h0O1xuICAgIH1cbiAgICBzd2l0Y2ggKHRoaXMub3B0aW9ucy5zdHlsZSkge1xuICAgICAgY2FzZSBcImxpbmVcIjpcbiAgICAgICAgTGluZXMuZHJhd0ljb24odGhpcywgeCwgeSwgaWNvbldpZHRoLCBpY29uSGVpZ2h0LCBmcmFtZXdvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJwb2ludHNcIjogLy9leHBsaWNpdCBubyBicmVha1xuICAgICAgY2FzZSBcInBvaW50XCI6XG4gICAgICAgIFBvaW50cy5kcmF3SWNvbih0aGlzLCB4LCB5LCBpY29uV2lkdGgsIGljb25IZWlnaHQsIGZyYW1ld29yayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJhclwiOlxuICAgICAgICBCYXJzLmRyYXdJY29uKHRoaXMsIHgsIHksIGljb25XaWR0aCwgaWNvbkhlaWdodCwgZnJhbWV3b3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiB7IGljb246IGZyYW1ld29yay5zdmcsIGxhYmVsOiB0aGlzLmNvbnRlbnQsIG9yaWVudGF0aW9uOiB0aGlzLm9wdGlvbnMueUF4aXNPcmllbnRhdGlvbiB9O1xuICB9O1xuXG4gIEdyYXBoR3JvdXAucHJvdG90eXBlLmdldFlSYW5nZSA9IGZ1bmN0aW9uIChncm91cERhdGEpIHtcbiAgICB2YXIgeU1pbiA9IGdyb3VwRGF0YVswXS55O1xuICAgIHZhciB5TWF4ID0gZ3JvdXBEYXRhWzBdLnk7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBncm91cERhdGEubGVuZ3RoOyBqKyspIHtcbiAgICAgIHlNaW4gPSB5TWluID4gZ3JvdXBEYXRhW2pdLnkgPyBncm91cERhdGFbal0ueSA6IHlNaW47XG4gICAgICB5TWF4ID0geU1heCA8IGdyb3VwRGF0YVtqXS55ID8gZ3JvdXBEYXRhW2pdLnkgOiB5TWF4O1xuICAgIH1cbiAgICByZXR1cm4geyBtaW46IHlNaW4sIG1heDogeU1heCwgeUF4aXNPcmllbnRhdGlvbjogdGhpcy5vcHRpb25zLnlBeGlzT3JpZW50YXRpb24gfTtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IEdyYXBoR3JvdXA7XG5cbi8qKiovIH0sXG4vKiA1NSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBET011dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbiAgdmFyIFBvaW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oNTYpO1xuXG4gIGZ1bmN0aW9uIEJhcmdyYXBoKGdyb3VwSWQsIG9wdGlvbnMpIHt9XG5cbiAgQmFyZ3JhcGguZHJhd0ljb24gPSBmdW5jdGlvbiAoZ3JvdXAsIHgsIHksIGljb25XaWR0aCwgaWNvbkhlaWdodCwgZnJhbWV3b3JrKSB7XG4gICAgdmFyIGZpbGxIZWlnaHQgPSBpY29uSGVpZ2h0ICogMC41O1xuICAgIHZhciBwYXRoLCBmaWxsUGF0aDtcblxuICAgIHZhciBvdXRsaW5lID0gRE9NdXRpbC5nZXRTVkdFbGVtZW50KFwicmVjdFwiLCBmcmFtZXdvcmsuc3ZnRWxlbWVudHMsIGZyYW1ld29yay5zdmcpO1xuICAgIG91dGxpbmUuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ4XCIsIHgpO1xuICAgIG91dGxpbmUuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5XCIsIHkgLSBmaWxsSGVpZ2h0KTtcbiAgICBvdXRsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwid2lkdGhcIiwgaWNvbldpZHRoKTtcbiAgICBvdXRsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiaGVpZ2h0XCIsIDIgKiBmaWxsSGVpZ2h0KTtcbiAgICBvdXRsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiY2xhc3NcIiwgXCJ2aXMtb3V0bGluZVwiKTtcblxuICAgIHZhciBiYXJXaWR0aCA9IE1hdGgucm91bmQoMC4zICogaWNvbldpZHRoKTtcbiAgICB2YXIgb3JpZ2luYWxXaWR0aCA9IGdyb3VwLm9wdGlvbnMuYmFyQ2hhcnQud2lkdGg7XG4gICAgdmFyIHNjYWxlID0gb3JpZ2luYWxXaWR0aCAvIGJhcldpZHRoO1xuICAgIHZhciBiYXIxSGVpZ2h0ID0gTWF0aC5yb3VuZCgwLjQgKiBpY29uSGVpZ2h0KTtcbiAgICB2YXIgYmFyMkhlaWdodCA9IE1hdGgucm91bmQoMC43NSAqIGljb25IZWlnaHQpO1xuXG4gICAgdmFyIG9mZnNldCA9IE1hdGgucm91bmQoKGljb25XaWR0aCAtIDIgKiBiYXJXaWR0aCkgLyAzKTtcblxuICAgIERPTXV0aWwuZHJhd0Jhcih4ICsgMC41ICogYmFyV2lkdGggKyBvZmZzZXQsIHkgKyBmaWxsSGVpZ2h0IC0gYmFyMUhlaWdodCAtIDEsIGJhcldpZHRoLCBiYXIxSGVpZ2h0LCBncm91cC5jbGFzc05hbWUgKyAnIHZpcy1iYXInLCBmcmFtZXdvcmsuc3ZnRWxlbWVudHMsIGZyYW1ld29yay5zdmcsIGdyb3VwLnN0eWxlKTtcbiAgICBET011dGlsLmRyYXdCYXIoeCArIDEuNSAqIGJhcldpZHRoICsgb2Zmc2V0ICsgMiwgeSArIGZpbGxIZWlnaHQgLSBiYXIySGVpZ2h0IC0gMSwgYmFyV2lkdGgsIGJhcjJIZWlnaHQsIGdyb3VwLmNsYXNzTmFtZSArICcgdmlzLWJhcicsIGZyYW1ld29yay5zdmdFbGVtZW50cywgZnJhbWV3b3JrLnN2ZywgZ3JvdXAuc3R5bGUpO1xuXG4gICAgaWYgKGdyb3VwLm9wdGlvbnMuZHJhd1BvaW50cy5lbmFibGVkID09IHRydWUpIHtcbiAgICAgIHZhciBncm91cFRlbXBsYXRlID0ge1xuICAgICAgICBzdHlsZTogZ3JvdXAub3B0aW9ucy5kcmF3UG9pbnRzLnN0eWxlLFxuICAgICAgICBzdHlsZXM6IGdyb3VwLm9wdGlvbnMuZHJhd1BvaW50cy5zdHlsZXMsXG4gICAgICAgIHNpemU6IGdyb3VwLm9wdGlvbnMuZHJhd1BvaW50cy5zaXplIC8gc2NhbGUsXG4gICAgICAgIGNsYXNzTmFtZTogZ3JvdXAuY2xhc3NOYW1lXG4gICAgICB9O1xuICAgICAgRE9NdXRpbC5kcmF3UG9pbnQoeCArIDAuNSAqIGJhcldpZHRoICsgb2Zmc2V0LCB5ICsgZmlsbEhlaWdodCAtIGJhcjFIZWlnaHQgLSAxLCBncm91cFRlbXBsYXRlLCBmcmFtZXdvcmsuc3ZnRWxlbWVudHMsIGZyYW1ld29yay5zdmcpO1xuICAgICAgRE9NdXRpbC5kcmF3UG9pbnQoeCArIDEuNSAqIGJhcldpZHRoICsgb2Zmc2V0ICsgMiwgeSArIGZpbGxIZWlnaHQgLSBiYXIySGVpZ2h0IC0gMSwgZ3JvdXBUZW1wbGF0ZSwgZnJhbWV3b3JrLnN2Z0VsZW1lbnRzLCBmcmFtZXdvcmsuc3ZnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIGRyYXcgYSBiYXIgZ3JhcGhcbiAgICpcbiAgICogQHBhcmFtIGdyb3VwSWRzXG4gICAqIEBwYXJhbSBwcm9jZXNzZWRHcm91cERhdGFcbiAgICovXG4gIEJhcmdyYXBoLmRyYXcgPSBmdW5jdGlvbiAoZ3JvdXBJZHMsIHByb2Nlc3NlZEdyb3VwRGF0YSwgZnJhbWV3b3JrKSB7XG4gICAgdmFyIGNvbWJpbmVkRGF0YSA9IFtdO1xuICAgIHZhciBpbnRlcnNlY3Rpb25zID0ge307XG4gICAgdmFyIGNvcmVEaXN0YW5jZTtcbiAgICB2YXIga2V5LCBkcmF3RGF0YTtcbiAgICB2YXIgZ3JvdXA7XG4gICAgdmFyIGksIGo7XG4gICAgdmFyIGJhclBvaW50cyA9IDA7XG5cbiAgICAvLyBjb21iaW5lIGFsbCBiYXJjaGFydCBkYXRhXG4gICAgZm9yIChpID0gMDsgaSA8IGdyb3VwSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBncm91cCA9IGZyYW1ld29yay5ncm91cHNbZ3JvdXBJZHNbaV1dO1xuICAgICAgaWYgKGdyb3VwLm9wdGlvbnMuc3R5bGUgPT09ICdiYXInKSB7XG4gICAgICAgIGlmIChncm91cC52aXNpYmxlID09PSB0cnVlICYmIChmcmFtZXdvcmsub3B0aW9ucy5ncm91cHMudmlzaWJpbGl0eVtncm91cElkc1tpXV0gPT09IHVuZGVmaW5lZCB8fCBmcmFtZXdvcmsub3B0aW9ucy5ncm91cHMudmlzaWJpbGl0eVtncm91cElkc1tpXV0gPT09IHRydWUpKSB7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IHByb2Nlc3NlZEdyb3VwRGF0YVtncm91cElkc1tpXV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvbWJpbmVkRGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgc2NyZWVuX3g6IHByb2Nlc3NlZEdyb3VwRGF0YVtncm91cElkc1tpXV1bal0uc2NyZWVuX3gsXG4gICAgICAgICAgICAgIHNjcmVlbl95OiBwcm9jZXNzZWRHcm91cERhdGFbZ3JvdXBJZHNbaV1dW2pdLnNjcmVlbl95LFxuICAgICAgICAgICAgICB4OiBwcm9jZXNzZWRHcm91cERhdGFbZ3JvdXBJZHNbaV1dW2pdLngsXG4gICAgICAgICAgICAgIHk6IHByb2Nlc3NlZEdyb3VwRGF0YVtncm91cElkc1tpXV1bal0ueSxcbiAgICAgICAgICAgICAgZ3JvdXBJZDogZ3JvdXBJZHNbaV0sXG4gICAgICAgICAgICAgIGxhYmVsOiBwcm9jZXNzZWRHcm91cERhdGFbZ3JvdXBJZHNbaV1dW2pdLmxhYmVsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJhclBvaW50cyArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChiYXJQb2ludHMgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBzb3J0IGJ5IHRpbWUgYW5kIGJ5IGdyb3VwXG4gICAgY29tYmluZWREYXRhLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIGlmIChhLnNjcmVlbl94ID09PSBiLnNjcmVlbl94KSB7XG4gICAgICAgIHJldHVybiBhLmdyb3VwSWQgPCBiLmdyb3VwSWQgPyAtMSA6IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYS5zY3JlZW5feCAtIGIuc2NyZWVuX3g7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBnZXQgaW50ZXJzZWN0aW9uc1xuICAgIEJhcmdyYXBoLl9nZXREYXRhSW50ZXJzZWN0aW9ucyhpbnRlcnNlY3Rpb25zLCBjb21iaW5lZERhdGEpO1xuXG4gICAgLy8gcGxvdCBiYXJjaGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBjb21iaW5lZERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGdyb3VwID0gZnJhbWV3b3JrLmdyb3Vwc1tjb21iaW5lZERhdGFbaV0uZ3JvdXBJZF07XG4gICAgICB2YXIgbWluV2lkdGggPSBncm91cC5vcHRpb25zLmJhckNoYXJ0Lm1pbldpZHRoICE9IHVuZGVmaW5lZCA/IGdyb3VwLm9wdGlvbnMuYmFyQ2hhcnQubWluV2lkdGggOiAwLjEgKiBncm91cC5vcHRpb25zLmJhckNoYXJ0LndpZHRoO1xuXG4gICAgICBrZXkgPSBjb21iaW5lZERhdGFbaV0uc2NyZWVuX3g7XG4gICAgICB2YXIgaGVpZ2h0T2Zmc2V0ID0gMDtcbiAgICAgIGlmIChpbnRlcnNlY3Rpb25zW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaSArIDEgPCBjb21iaW5lZERhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgY29yZURpc3RhbmNlID0gTWF0aC5hYnMoY29tYmluZWREYXRhW2kgKyAxXS5zY3JlZW5feCAtIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZHJhd0RhdGEgPSBCYXJncmFwaC5fZ2V0U2FmZURyYXdEYXRhKGNvcmVEaXN0YW5jZSwgZ3JvdXAsIG1pbldpZHRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBuZXh0S2V5ID0gaSArIChpbnRlcnNlY3Rpb25zW2tleV0uYW1vdW50IC0gaW50ZXJzZWN0aW9uc1trZXldLnJlc29sdmVkKTtcbiAgICAgICAgdmFyIHByZXZLZXkgPSBpIC0gKGludGVyc2VjdGlvbnNba2V5XS5yZXNvbHZlZCArIDEpO1xuICAgICAgICBpZiAobmV4dEtleSA8IGNvbWJpbmVkRGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICBjb3JlRGlzdGFuY2UgPSBNYXRoLmFicyhjb21iaW5lZERhdGFbbmV4dEtleV0uc2NyZWVuX3ggLSBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGRyYXdEYXRhID0gQmFyZ3JhcGguX2dldFNhZmVEcmF3RGF0YShjb3JlRGlzdGFuY2UsIGdyb3VwLCBtaW5XaWR0aCk7XG4gICAgICAgIGludGVyc2VjdGlvbnNba2V5XS5yZXNvbHZlZCArPSAxO1xuXG4gICAgICAgIGlmIChncm91cC5vcHRpb25zLnN0YWNrID09PSB0cnVlICYmIGdyb3VwLm9wdGlvbnMuZXhjbHVkZUZyb21TdGFja2luZyAhPT0gdHJ1ZSkge1xuICAgICAgICAgIGlmIChjb21iaW5lZERhdGFbaV0uc2NyZWVuX3kgPCBncm91cC56ZXJvUG9zaXRpb24pIHtcbiAgICAgICAgICAgIGhlaWdodE9mZnNldCA9IGludGVyc2VjdGlvbnNba2V5XS5hY2N1bXVsYXRlZE5lZ2F0aXZlO1xuICAgICAgICAgICAgaW50ZXJzZWN0aW9uc1trZXldLmFjY3VtdWxhdGVkTmVnYXRpdmUgKz0gZ3JvdXAuemVyb1Bvc2l0aW9uIC0gY29tYmluZWREYXRhW2ldLnNjcmVlbl95O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoZWlnaHRPZmZzZXQgPSBpbnRlcnNlY3Rpb25zW2tleV0uYWNjdW11bGF0ZWRQb3NpdGl2ZTtcbiAgICAgICAgICAgIGludGVyc2VjdGlvbnNba2V5XS5hY2N1bXVsYXRlZFBvc2l0aXZlICs9IGdyb3VwLnplcm9Qb3NpdGlvbiAtIGNvbWJpbmVkRGF0YVtpXS5zY3JlZW5feTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JvdXAub3B0aW9ucy5iYXJDaGFydC5zaWRlQnlTaWRlID09PSB0cnVlKSB7XG4gICAgICAgICAgZHJhd0RhdGEud2lkdGggPSBkcmF3RGF0YS53aWR0aCAvIGludGVyc2VjdGlvbnNba2V5XS5hbW91bnQ7XG4gICAgICAgICAgZHJhd0RhdGEub2Zmc2V0ICs9IGludGVyc2VjdGlvbnNba2V5XS5yZXNvbHZlZCAqIGRyYXdEYXRhLndpZHRoIC0gMC41ICogZHJhd0RhdGEud2lkdGggKiAoaW50ZXJzZWN0aW9uc1trZXldLmFtb3VudCArIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBET011dGlsLmRyYXdCYXIoY29tYmluZWREYXRhW2ldLnNjcmVlbl94ICsgZHJhd0RhdGEub2Zmc2V0LCBjb21iaW5lZERhdGFbaV0uc2NyZWVuX3kgLSBoZWlnaHRPZmZzZXQsIGRyYXdEYXRhLndpZHRoLCBncm91cC56ZXJvUG9zaXRpb24gLSBjb21iaW5lZERhdGFbaV0uc2NyZWVuX3ksIGdyb3VwLmNsYXNzTmFtZSArICcgdmlzLWJhcicsIGZyYW1ld29yay5zdmdFbGVtZW50cywgZnJhbWV3b3JrLnN2ZywgZ3JvdXAuc3R5bGUpO1xuICAgICAgLy8gZHJhdyBwb2ludHNcbiAgICAgIGlmIChncm91cC5vcHRpb25zLmRyYXdQb2ludHMuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgcG9pbnREYXRhID0ge1xuICAgICAgICAgIHNjcmVlbl94OiBjb21iaW5lZERhdGFbaV0uc2NyZWVuX3gsXG4gICAgICAgICAgc2NyZWVuX3k6IGNvbWJpbmVkRGF0YVtpXS5zY3JlZW5feSAtIGhlaWdodE9mZnNldCxcbiAgICAgICAgICB4OiBjb21iaW5lZERhdGFbaV0ueCxcbiAgICAgICAgICB5OiBjb21iaW5lZERhdGFbaV0ueSxcbiAgICAgICAgICBncm91cElkOiBjb21iaW5lZERhdGFbaV0uZ3JvdXBJZCxcbiAgICAgICAgICBsYWJlbDogY29tYmluZWREYXRhW2ldLmxhYmVsXG4gICAgICAgIH07XG4gICAgICAgIFBvaW50cy5kcmF3KFtwb2ludERhdGFdLCBncm91cCwgZnJhbWV3b3JrLCBkcmF3RGF0YS5vZmZzZXQpO1xuICAgICAgICAvL0RPTXV0aWwuZHJhd1BvaW50KGNvbWJpbmVkRGF0YVtpXS54ICsgZHJhd0RhdGEub2Zmc2V0LCBjb21iaW5lZERhdGFbaV0ueSwgZ3JvdXAsIGZyYW1ld29yay5zdmdFbGVtZW50cywgZnJhbWV3b3JrLnN2Zyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBGaWxsIHRoZSBpbnRlcnNlY3Rpb25zIG9iamVjdCB3aXRoIGNvdW50ZXJzIG9mIGhvdyBtYW55IGRhdGFwb2ludHMgc2hhcmUgdGhlIHNhbWUgeCBjb29yZGluYXRlc1xuICAgKiBAcGFyYW0gaW50ZXJzZWN0aW9uc1xuICAgKiBAcGFyYW0gY29tYmluZWREYXRhXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBCYXJncmFwaC5fZ2V0RGF0YUludGVyc2VjdGlvbnMgPSBmdW5jdGlvbiAoaW50ZXJzZWN0aW9ucywgY29tYmluZWREYXRhKSB7XG4gICAgLy8gZ2V0IGludGVyc2VjdGlvbnNcbiAgICB2YXIgY29yZURpc3RhbmNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tYmluZWREYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaSArIDEgPCBjb21iaW5lZERhdGEubGVuZ3RoKSB7XG4gICAgICAgIGNvcmVEaXN0YW5jZSA9IE1hdGguYWJzKGNvbWJpbmVkRGF0YVtpICsgMV0uc2NyZWVuX3ggLSBjb21iaW5lZERhdGFbaV0uc2NyZWVuX3gpO1xuICAgICAgfVxuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIGNvcmVEaXN0YW5jZSA9IE1hdGgubWluKGNvcmVEaXN0YW5jZSwgTWF0aC5hYnMoY29tYmluZWREYXRhW2kgLSAxXS5zY3JlZW5feCAtIGNvbWJpbmVkRGF0YVtpXS5zY3JlZW5feCkpO1xuICAgICAgfVxuICAgICAgaWYgKGNvcmVEaXN0YW5jZSA9PT0gMCkge1xuICAgICAgICBpZiAoaW50ZXJzZWN0aW9uc1tjb21iaW5lZERhdGFbaV0uc2NyZWVuX3hdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpbnRlcnNlY3Rpb25zW2NvbWJpbmVkRGF0YVtpXS5zY3JlZW5feF0gPSB7XG4gICAgICAgICAgICBhbW91bnQ6IDAsXG4gICAgICAgICAgICByZXNvbHZlZDogMCxcbiAgICAgICAgICAgIGFjY3VtdWxhdGVkUG9zaXRpdmU6IDAsXG4gICAgICAgICAgICBhY2N1bXVsYXRlZE5lZ2F0aXZlOiAwXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpbnRlcnNlY3Rpb25zW2NvbWJpbmVkRGF0YVtpXS5zY3JlZW5feF0uYW1vdW50ICs9IDE7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHdpZHRoIGFuZCBvZmZzZXQgZm9yIGJhcmdyYXBocyBiYXNlZCBvbiB0aGUgY29yZWRpc3RhbmNlIGJldHdlZW4gZGF0YXBvaW50c1xuICAgKlxuICAgKiBAcGFyYW0gY29yZURpc3RhbmNlXG4gICAqIEBwYXJhbSBncm91cFxuICAgKiBAcGFyYW0gbWluV2lkdGhcbiAgICogQHJldHVybnMge3t3aWR0aDogTnVtYmVyLCBvZmZzZXQ6IE51bWJlcn19XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBCYXJncmFwaC5fZ2V0U2FmZURyYXdEYXRhID0gZnVuY3Rpb24gKGNvcmVEaXN0YW5jZSwgZ3JvdXAsIG1pbldpZHRoKSB7XG4gICAgdmFyIHdpZHRoLCBvZmZzZXQ7XG4gICAgaWYgKGNvcmVEaXN0YW5jZSA8IGdyb3VwLm9wdGlvbnMuYmFyQ2hhcnQud2lkdGggJiYgY29yZURpc3RhbmNlID4gMCkge1xuICAgICAgd2lkdGggPSBjb3JlRGlzdGFuY2UgPCBtaW5XaWR0aCA/IG1pbldpZHRoIDogY29yZURpc3RhbmNlO1xuXG4gICAgICBvZmZzZXQgPSAwOyAvLyByZWNhbGN1bGF0ZSBvZmZzZXQgd2l0aCB0aGUgbmV3IHdpZHRoO1xuICAgICAgaWYgKGdyb3VwLm9wdGlvbnMuYmFyQ2hhcnQuYWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICBvZmZzZXQgLT0gMC41ICogY29yZURpc3RhbmNlO1xuICAgICAgfSBlbHNlIGlmIChncm91cC5vcHRpb25zLmJhckNoYXJ0LmFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgIG9mZnNldCArPSAwLjUgKiBjb3JlRGlzdGFuY2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGRlZmF1bHQgc2V0dGluZ3NcbiAgICAgIHdpZHRoID0gZ3JvdXAub3B0aW9ucy5iYXJDaGFydC53aWR0aDtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgICBpZiAoZ3JvdXAub3B0aW9ucy5iYXJDaGFydC5hbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIG9mZnNldCAtPSAwLjUgKiBncm91cC5vcHRpb25zLmJhckNoYXJ0LndpZHRoO1xuICAgICAgfSBlbHNlIGlmIChncm91cC5vcHRpb25zLmJhckNoYXJ0LmFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgIG9mZnNldCArPSAwLjUgKiBncm91cC5vcHRpb25zLmJhckNoYXJ0LndpZHRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IHdpZHRoOiB3aWR0aCwgb2Zmc2V0OiBvZmZzZXQgfTtcbiAgfTtcblxuICBCYXJncmFwaC5nZXRTdGFja2VkWVJhbmdlID0gZnVuY3Rpb24gKGNvbWJpbmVkRGF0YSwgZ3JvdXBSYW5nZXMsIGdyb3VwSWRzLCBncm91cExhYmVsLCBvcmllbnRhdGlvbikge1xuICAgIGlmIChjb21iaW5lZERhdGEubGVuZ3RoID4gMCkge1xuICAgICAgLy8gc29ydCBieSB0aW1lIGFuZCBieSBncm91cFxuICAgICAgY29tYmluZWREYXRhLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgaWYgKGEuc2NyZWVuX3ggPT09IGIuc2NyZWVuX3gpIHtcbiAgICAgICAgICByZXR1cm4gYS5ncm91cElkIDwgYi5ncm91cElkID8gLTEgOiAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBhLnNjcmVlbl94IC0gYi5zY3JlZW5feDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgaW50ZXJzZWN0aW9ucyA9IHt9O1xuXG4gICAgICBCYXJncmFwaC5fZ2V0RGF0YUludGVyc2VjdGlvbnMoaW50ZXJzZWN0aW9ucywgY29tYmluZWREYXRhKTtcbiAgICAgIGdyb3VwUmFuZ2VzW2dyb3VwTGFiZWxdID0gQmFyZ3JhcGguX2dldFN0YWNrZWRZUmFuZ2UoaW50ZXJzZWN0aW9ucywgY29tYmluZWREYXRhKTtcbiAgICAgIGdyb3VwUmFuZ2VzW2dyb3VwTGFiZWxdLnlBeGlzT3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcbiAgICAgIGdyb3VwSWRzLnB1c2goZ3JvdXBMYWJlbCk7XG4gICAgfVxuICB9O1xuXG4gIEJhcmdyYXBoLl9nZXRTdGFja2VkWVJhbmdlID0gZnVuY3Rpb24gKGludGVyc2VjdGlvbnMsIGNvbWJpbmVkRGF0YSkge1xuICAgIHZhciBrZXk7XG4gICAgdmFyIHlNaW4gPSBjb21iaW5lZERhdGFbMF0uc2NyZWVuX3k7XG4gICAgdmFyIHlNYXggPSBjb21iaW5lZERhdGFbMF0uc2NyZWVuX3k7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21iaW5lZERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IGNvbWJpbmVkRGF0YVtpXS5zY3JlZW5feDtcbiAgICAgIGlmIChpbnRlcnNlY3Rpb25zW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB5TWluID0geU1pbiA+IGNvbWJpbmVkRGF0YVtpXS5zY3JlZW5feSA/IGNvbWJpbmVkRGF0YVtpXS5zY3JlZW5feSA6IHlNaW47XG4gICAgICAgIHlNYXggPSB5TWF4IDwgY29tYmluZWREYXRhW2ldLnNjcmVlbl95ID8gY29tYmluZWREYXRhW2ldLnNjcmVlbl95IDogeU1heDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjb21iaW5lZERhdGFbaV0uc2NyZWVuX3kgPCAwKSB7XG4gICAgICAgICAgaW50ZXJzZWN0aW9uc1trZXldLmFjY3VtdWxhdGVkTmVnYXRpdmUgKz0gY29tYmluZWREYXRhW2ldLnNjcmVlbl95O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGludGVyc2VjdGlvbnNba2V5XS5hY2N1bXVsYXRlZFBvc2l0aXZlICs9IGNvbWJpbmVkRGF0YVtpXS5zY3JlZW5feTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciB4cG9zIGluIGludGVyc2VjdGlvbnMpIHtcbiAgICAgIGlmIChpbnRlcnNlY3Rpb25zLmhhc093blByb3BlcnR5KHhwb3MpKSB7XG4gICAgICAgIHlNaW4gPSB5TWluID4gaW50ZXJzZWN0aW9uc1t4cG9zXS5hY2N1bXVsYXRlZE5lZ2F0aXZlID8gaW50ZXJzZWN0aW9uc1t4cG9zXS5hY2N1bXVsYXRlZE5lZ2F0aXZlIDogeU1pbjtcbiAgICAgICAgeU1pbiA9IHlNaW4gPiBpbnRlcnNlY3Rpb25zW3hwb3NdLmFjY3VtdWxhdGVkUG9zaXRpdmUgPyBpbnRlcnNlY3Rpb25zW3hwb3NdLmFjY3VtdWxhdGVkUG9zaXRpdmUgOiB5TWluO1xuICAgICAgICB5TWF4ID0geU1heCA8IGludGVyc2VjdGlvbnNbeHBvc10uYWNjdW11bGF0ZWROZWdhdGl2ZSA/IGludGVyc2VjdGlvbnNbeHBvc10uYWNjdW11bGF0ZWROZWdhdGl2ZSA6IHlNYXg7XG4gICAgICAgIHlNYXggPSB5TWF4IDwgaW50ZXJzZWN0aW9uc1t4cG9zXS5hY2N1bXVsYXRlZFBvc2l0aXZlID8gaW50ZXJzZWN0aW9uc1t4cG9zXS5hY2N1bXVsYXRlZFBvc2l0aXZlIDogeU1heDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyBtaW46IHlNaW4sIG1heDogeU1heCB9O1xuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gQmFyZ3JhcGg7XG5cbi8qKiovIH0sXG4vKiA1NiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG4gIHZhciBET011dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxuICBmdW5jdGlvbiBQb2ludHMoZ3JvdXBJZCwgb3B0aW9ucykge31cblxuICAvKipcbiAgICogZHJhdyB0aGUgZGF0YSBwb2ludHNcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gZGF0YXNldFxuICAgKiBAcGFyYW0ge09iamVjdH0gSlNPTmNvbnRhaW5lclxuICAgKiBAcGFyYW0ge09iamVjdH0gc3ZnICAgICAgICAgICAgfCBTVkcgRE9NIGVsZW1lbnRcbiAgICogQHBhcmFtIHtHcmFwaEdyb3VwfSBncm91cFxuICAgKiBAcGFyYW0ge051bWJlcn0gW29mZnNldF1cbiAgICovXG4gIFBvaW50cy5kcmF3ID0gZnVuY3Rpb24gKGRhdGFzZXQsIGdyb3VwLCBmcmFtZXdvcmssIG9mZnNldCkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICAgIHZhciBjYWxsYmFjayA9IGdldENhbGxiYWNrKGZyYW1ld29yaywgZ3JvdXApO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgIC8vIGRyYXcgdGhlIHBvaW50IHRoZSBzaW1wbGUgd2F5LlxuICAgICAgICBET011dGlsLmRyYXdQb2ludChkYXRhc2V0W2ldLnNjcmVlbl94ICsgb2Zmc2V0LCBkYXRhc2V0W2ldLnNjcmVlbl95LCBnZXRHcm91cFRlbXBsYXRlKGdyb3VwKSwgZnJhbWV3b3JrLnN2Z0VsZW1lbnRzLCBmcmFtZXdvcmsuc3ZnLCBkYXRhc2V0W2ldLmxhYmVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjYWxsYmFja1Jlc3VsdCA9IGNhbGxiYWNrKGRhdGFzZXRbaV0sIGdyb3VwKTsgLy8gcmVzdWx0IG1pZ2h0IGJlIHRydWUsIGZhbHNlIG9yIGFuIG9iamVjdFxuICAgICAgICBpZiAoY2FsbGJhY2tSZXN1bHQgPT09IHRydWUgfHwgKHR5cGVvZiBjYWxsYmFja1Jlc3VsdCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoY2FsbGJhY2tSZXN1bHQpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBET011dGlsLmRyYXdQb2ludChkYXRhc2V0W2ldLnNjcmVlbl94ICsgb2Zmc2V0LCBkYXRhc2V0W2ldLnNjcmVlbl95LCBnZXRHcm91cFRlbXBsYXRlKGdyb3VwLCBjYWxsYmFja1Jlc3VsdCksIGZyYW1ld29yay5zdmdFbGVtZW50cywgZnJhbWV3b3JrLnN2ZywgZGF0YXNldFtpXS5sYWJlbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgUG9pbnRzLmRyYXdJY29uID0gZnVuY3Rpb24gKGdyb3VwLCB4LCB5LCBpY29uV2lkdGgsIGljb25IZWlnaHQsIGZyYW1ld29yaykge1xuICAgIHZhciBmaWxsSGVpZ2h0ID0gaWNvbkhlaWdodCAqIDAuNTtcbiAgICB2YXIgcGF0aCwgZmlsbFBhdGg7XG5cbiAgICB2YXIgb3V0bGluZSA9IERPTXV0aWwuZ2V0U1ZHRWxlbWVudChcInJlY3RcIiwgZnJhbWV3b3JrLnN2Z0VsZW1lbnRzLCBmcmFtZXdvcmsuc3ZnKTtcbiAgICBvdXRsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieFwiLCB4KTtcbiAgICBvdXRsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCB5IC0gZmlsbEhlaWdodCk7XG4gICAgb3V0bGluZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIndpZHRoXCIsIGljb25XaWR0aCk7XG4gICAgb3V0bGluZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImhlaWdodFwiLCAyICogZmlsbEhlaWdodCk7XG4gICAgb3V0bGluZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImNsYXNzXCIsIFwidmlzLW91dGxpbmVcIik7XG5cbiAgICAvL0Rvbid0IGNhbGwgY2FsbGJhY2sgb24gaWNvblxuICAgIERPTXV0aWwuZHJhd1BvaW50KHggKyAwLjUgKiBpY29uV2lkdGgsIHksIGdldEdyb3VwVGVtcGxhdGUoZ3JvdXApLCBmcmFtZXdvcmsuc3ZnRWxlbWVudHMsIGZyYW1ld29yay5zdmcpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGdldEdyb3VwVGVtcGxhdGUoZ3JvdXAsIGNhbGxiYWNrUmVzdWx0KSB7XG4gICAgY2FsbGJhY2tSZXN1bHQgPSB0eXBlb2YgY2FsbGJhY2tSZXN1bHQgPT09ICd1bmRlZmluZWQnID8ge30gOiBjYWxsYmFja1Jlc3VsdDtcbiAgICByZXR1cm4ge1xuICAgICAgc3R5bGU6IGNhbGxiYWNrUmVzdWx0LnN0eWxlIHx8IGdyb3VwLm9wdGlvbnMuZHJhd1BvaW50cy5zdHlsZSxcbiAgICAgIHN0eWxlczogY2FsbGJhY2tSZXN1bHQuc3R5bGVzIHx8IGdyb3VwLm9wdGlvbnMuZHJhd1BvaW50cy5zdHlsZXMsXG4gICAgICBzaXplOiBjYWxsYmFja1Jlc3VsdC5zaXplIHx8IGdyb3VwLm9wdGlvbnMuZHJhd1BvaW50cy5zaXplLFxuICAgICAgY2xhc3NOYW1lOiBjYWxsYmFja1Jlc3VsdC5jbGFzc05hbWUgfHwgZ3JvdXAuY2xhc3NOYW1lXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENhbGxiYWNrKGZyYW1ld29yaywgZ3JvdXApIHtcbiAgICB2YXIgY2FsbGJhY2sgPSB1bmRlZmluZWQ7XG4gICAgLy8gY2hlY2sgZm9yIHRoZSBncmFwaDJkIG9uUmVuZGVyXG4gICAgaWYgKGZyYW1ld29yay5vcHRpb25zICYmIGZyYW1ld29yay5vcHRpb25zLmRyYXdQb2ludHMgJiYgZnJhbWV3b3JrLm9wdGlvbnMuZHJhd1BvaW50cy5vblJlbmRlciAmJiB0eXBlb2YgZnJhbWV3b3JrLm9wdGlvbnMuZHJhd1BvaW50cy5vblJlbmRlciA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IGZyYW1ld29yay5vcHRpb25zLmRyYXdQb2ludHMub25SZW5kZXI7XG4gICAgfVxuXG4gICAgLy8gb3ZlcnJpZGUgaXQgd2l0aCB0aGUgZ3JvdXAgb25SZW5kZXIgaWYgZGVmaW5lZFxuICAgIGlmIChncm91cC5ncm91cC5vcHRpb25zICYmIGdyb3VwLmdyb3VwLm9wdGlvbnMuZHJhd1BvaW50cyAmJiBncm91cC5ncm91cC5vcHRpb25zLmRyYXdQb2ludHMub25SZW5kZXIgJiYgdHlwZW9mIGdyb3VwLmdyb3VwLm9wdGlvbnMuZHJhd1BvaW50cy5vblJlbmRlciA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IGdyb3VwLmdyb3VwLm9wdGlvbnMuZHJhd1BvaW50cy5vblJlbmRlcjtcbiAgICB9XG4gICAgcmV0dXJuIGNhbGxiYWNrO1xuICB9XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBQb2ludHM7XG5cbi8qKiovIH0sXG4vKiA1NyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIERPTXV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG4gIGZ1bmN0aW9uIExpbmUoZ3JvdXBJZCwgb3B0aW9ucykge31cblxuICBMaW5lLmNhbGNQYXRoID0gZnVuY3Rpb24gKGRhdGFzZXQsIGdyb3VwKSB7XG4gICAgICBpZiAoZGF0YXNldCAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKGRhdGFzZXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB2YXIgZCA9IFtdO1xuXG4gICAgICAgICAgICAgIC8vIGNvbnN0cnVjdCBwYXRoIGZyb20gZGF0YXNldFxuICAgICAgICAgICAgICBpZiAoZ3JvdXAub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmVuYWJsZWQgPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgZCA9IExpbmUuX2NhdG11bGxSb20oZGF0YXNldCwgZ3JvdXApO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZCA9IExpbmUuX2xpbmVhcihkYXRhc2V0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICB9XG4gICAgICB9XG4gIH07XG5cbiAgTGluZS5kcmF3SWNvbiA9IGZ1bmN0aW9uIChncm91cCwgeCwgeSwgaWNvbldpZHRoLCBpY29uSGVpZ2h0LCBmcmFtZXdvcmspIHtcbiAgICAgIHZhciBmaWxsSGVpZ2h0ID0gaWNvbkhlaWdodCAqIDAuNTtcbiAgICAgIHZhciBwYXRoLCBmaWxsUGF0aDtcblxuICAgICAgdmFyIG91dGxpbmUgPSBET011dGlsLmdldFNWR0VsZW1lbnQoXCJyZWN0XCIsIGZyYW1ld29yay5zdmdFbGVtZW50cywgZnJhbWV3b3JrLnN2Zyk7XG4gICAgICBvdXRsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieFwiLCB4KTtcbiAgICAgIG91dGxpbmUuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5XCIsIHkgLSBmaWxsSGVpZ2h0KTtcbiAgICAgIG91dGxpbmUuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ3aWR0aFwiLCBpY29uV2lkdGgpO1xuICAgICAgb3V0bGluZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImhlaWdodFwiLCAyICogZmlsbEhlaWdodCk7XG4gICAgICBvdXRsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiY2xhc3NcIiwgXCJ2aXMtb3V0bGluZVwiKTtcblxuICAgICAgcGF0aCA9IERPTXV0aWwuZ2V0U1ZHRWxlbWVudChcInBhdGhcIiwgZnJhbWV3b3JrLnN2Z0VsZW1lbnRzLCBmcmFtZXdvcmsuc3ZnKTtcbiAgICAgIHBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgXCJjbGFzc1wiLCBncm91cC5jbGFzc05hbWUpO1xuICAgICAgaWYgKGdyb3VwLnN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwic3R5bGVcIiwgZ3JvdXAuc3R5bGUpO1xuICAgICAgfVxuXG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZFwiLCBcIk1cIiArIHggKyBcIixcIiArIHkgKyBcIiBMXCIgKyAoeCArIGljb25XaWR0aCkgKyBcIixcIiArIHkgKyBcIlwiKTtcbiAgICAgIGlmIChncm91cC5vcHRpb25zLnNoYWRlZC5lbmFibGVkID09IHRydWUpIHtcbiAgICAgICAgICBmaWxsUGF0aCA9IERPTXV0aWwuZ2V0U1ZHRWxlbWVudChcInBhdGhcIiwgZnJhbWV3b3JrLnN2Z0VsZW1lbnRzLCBmcmFtZXdvcmsuc3ZnKTtcbiAgICAgICAgICBpZiAoZ3JvdXAub3B0aW9ucy5zaGFkZWQub3JpZW50YXRpb24gPT0gJ3RvcCcpIHtcbiAgICAgICAgICAgICAgZmlsbFBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgXCJkXCIsIFwiTVwiICsgeCArIFwiLCBcIiArICh5IC0gZmlsbEhlaWdodCkgKyBcIkxcIiArIHggKyBcIixcIiArIHkgKyBcIiBMXCIgKyAoeCArIGljb25XaWR0aCkgKyBcIixcIiArIHkgKyBcIiBMXCIgKyAoeCArIGljb25XaWR0aCkgKyBcIixcIiArICh5IC0gZmlsbEhlaWdodCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZpbGxQYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZFwiLCBcIk1cIiArIHggKyBcIixcIiArIHkgKyBcIiBcIiArIFwiTFwiICsgeCArIFwiLFwiICsgKHkgKyBmaWxsSGVpZ2h0KSArIFwiIFwiICsgXCJMXCIgKyAoeCArIGljb25XaWR0aCkgKyBcIixcIiArICh5ICsgZmlsbEhlaWdodCkgKyBcIkxcIiArICh4ICsgaWNvbldpZHRoKSArIFwiLFwiICsgeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpbGxQYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiY2xhc3NcIiwgZ3JvdXAuY2xhc3NOYW1lICsgXCIgdmlzLWljb24tZmlsbFwiKTtcbiAgICAgICAgICBpZiAoZ3JvdXAub3B0aW9ucy5zaGFkZWQuc3R5bGUgIT09IHVuZGVmaW5lZCAmJiBncm91cC5vcHRpb25zLnNoYWRlZC5zdHlsZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgICBmaWxsUGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInN0eWxlXCIsIGdyb3VwLm9wdGlvbnMuc2hhZGVkLnN0eWxlKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChncm91cC5vcHRpb25zLmRyYXdQb2ludHMuZW5hYmxlZCA9PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIGdyb3VwVGVtcGxhdGUgPSB7XG4gICAgICAgICAgICAgIHN0eWxlOiBncm91cC5vcHRpb25zLmRyYXdQb2ludHMuc3R5bGUsXG4gICAgICAgICAgICAgIHN0eWxlczogZ3JvdXAub3B0aW9ucy5kcmF3UG9pbnRzLnN0eWxlcyxcbiAgICAgICAgICAgICAgc2l6ZTogZ3JvdXAub3B0aW9ucy5kcmF3UG9pbnRzLnNpemUsXG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogZ3JvdXAuY2xhc3NOYW1lXG4gICAgICAgICAgfTtcbiAgICAgICAgICBET011dGlsLmRyYXdQb2ludCh4ICsgMC41ICogaWNvbldpZHRoLCB5LCBncm91cFRlbXBsYXRlLCBmcmFtZXdvcmsuc3ZnRWxlbWVudHMsIGZyYW1ld29yay5zdmcpO1xuICAgICAgfVxuICB9O1xuXG4gIExpbmUuZHJhd1NoYWRpbmcgPSBmdW5jdGlvbiAocGF0aEFycmF5LCBncm91cCwgc3ViUGF0aEFycmF5LCBmcmFtZXdvcmspIHtcbiAgICAgIC8vIGFwcGVuZCBzaGFkaW5nIHRvIHRoZSBwYXRoXG4gICAgICBpZiAoZ3JvdXAub3B0aW9ucy5zaGFkZWQuZW5hYmxlZCA9PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIHN2Z0hlaWdodCA9IE51bWJlcihmcmFtZXdvcmsuc3ZnLnN0eWxlLmhlaWdodC5yZXBsYWNlKCdweCcsICcnKSk7XG4gICAgICAgICAgdmFyIGZpbGxQYXRoID0gRE9NdXRpbC5nZXRTVkdFbGVtZW50KCdwYXRoJywgZnJhbWV3b3JrLnN2Z0VsZW1lbnRzLCBmcmFtZXdvcmsuc3ZnKTtcbiAgICAgICAgICB2YXIgdHlwZSA9IFwiTFwiO1xuICAgICAgICAgIGlmIChncm91cC5vcHRpb25zLmludGVycG9sYXRpb24uZW5hYmxlZCA9PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHR5cGUgPSBcIkNcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGRGaWxsO1xuICAgICAgICAgIHZhciB6ZXJvID0gMDtcbiAgICAgICAgICBpZiAoZ3JvdXAub3B0aW9ucy5zaGFkZWQub3JpZW50YXRpb24gPT0gJ3RvcCcpIHtcbiAgICAgICAgICAgICAgemVybyA9IDA7XG4gICAgICAgICAgfSBlbHNlIGlmIChncm91cC5vcHRpb25zLnNoYWRlZC5vcmllbnRhdGlvbiA9PSAnYm90dG9tJykge1xuICAgICAgICAgICAgICB6ZXJvID0gc3ZnSGVpZ2h0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHplcm8gPSBNYXRoLm1pbihNYXRoLm1heCgwLCBncm91cC56ZXJvUG9zaXRpb24pLCBzdmdIZWlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZ3JvdXAub3B0aW9ucy5zaGFkZWQub3JpZW50YXRpb24gPT0gJ2dyb3VwJyAmJiBzdWJQYXRoQXJyYXkgIT0gbnVsbCAmJiBzdWJQYXRoQXJyYXkgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGRGaWxsID0gJ00nICsgcGF0aEFycmF5WzBdWzBdICsgXCIsXCIgKyBwYXRoQXJyYXlbMF1bMV0gKyBcIiBcIiArIHRoaXMuc2VyaWFsaXplUGF0aChwYXRoQXJyYXksIHR5cGUsIGZhbHNlKSArICcgTCcgKyBzdWJQYXRoQXJyYXlbc3ViUGF0aEFycmF5Lmxlbmd0aCAtIDFdWzBdICsgXCIsXCIgKyBzdWJQYXRoQXJyYXlbc3ViUGF0aEFycmF5Lmxlbmd0aCAtIDFdWzFdICsgXCIgXCIgKyB0aGlzLnNlcmlhbGl6ZVBhdGgoc3ViUGF0aEFycmF5LCB0eXBlLCB0cnVlKSArIHN1YlBhdGhBcnJheVswXVswXSArIFwiLFwiICsgc3ViUGF0aEFycmF5WzBdWzFdICsgXCIgWlwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRGaWxsID0gJ00nICsgcGF0aEFycmF5WzBdWzBdICsgXCIsXCIgKyBwYXRoQXJyYXlbMF1bMV0gKyBcIiBcIiArIHRoaXMuc2VyaWFsaXplUGF0aChwYXRoQXJyYXksIHR5cGUsIGZhbHNlKSArICcgVicgKyB6ZXJvICsgJyBIJyArIHBhdGhBcnJheVswXVswXSArIFwiIFpcIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmaWxsUGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnY2xhc3MnLCBncm91cC5jbGFzc05hbWUgKyAnIHZpcy1maWxsJyk7XG4gICAgICAgICAgaWYgKGdyb3VwLm9wdGlvbnMuc2hhZGVkLnN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZmlsbFBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgJ3N0eWxlJywgZ3JvdXAub3B0aW9ucy5zaGFkZWQuc3R5bGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmaWxsUGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZCcsIGRGaWxsKTtcbiAgICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogZHJhdyBhIGxpbmUgZ3JhcGhcbiAgICpcbiAgICogQHBhcmFtIGRhdGFzZXRcbiAgICogQHBhcmFtIGdyb3VwXG4gICAqL1xuICBMaW5lLmRyYXcgPSBmdW5jdGlvbiAocGF0aEFycmF5LCBncm91cCwgZnJhbWV3b3JrKSB7XG4gICAgICBpZiAocGF0aEFycmF5ICE9IG51bGwgJiYgcGF0aEFycmF5ICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBwYXRoID0gRE9NdXRpbC5nZXRTVkdFbGVtZW50KCdwYXRoJywgZnJhbWV3b3JrLnN2Z0VsZW1lbnRzLCBmcmFtZXdvcmsuc3ZnKTtcbiAgICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiY2xhc3NcIiwgZ3JvdXAuY2xhc3NOYW1lKTtcbiAgICAgICAgICBpZiAoZ3JvdXAuc3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwic3R5bGVcIiwgZ3JvdXAuc3R5bGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB0eXBlID0gXCJMXCI7XG4gICAgICAgICAgaWYgKGdyb3VwLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5lbmFibGVkID09IHRydWUpIHtcbiAgICAgICAgICAgICAgdHlwZSA9IFwiQ1wiO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBjb3B5IHByb3BlcnRpZXMgdG8gcGF0aCBmb3IgZHJhd2luZy5cbiAgICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkJywgJ00nICsgcGF0aEFycmF5WzBdWzBdICsgXCIsXCIgKyBwYXRoQXJyYXlbMF1bMV0gKyBcIiBcIiArIHRoaXMuc2VyaWFsaXplUGF0aChwYXRoQXJyYXksIHR5cGUsIGZhbHNlKSk7XG4gICAgICB9XG4gIH07XG5cbiAgTGluZS5zZXJpYWxpemVQYXRoID0gZnVuY3Rpb24gKHBhdGhBcnJheSwgdHlwZSwgaW52ZXJzZSkge1xuICAgICAgaWYgKHBhdGhBcnJheS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgLy9Ub28gbGl0dGxlIGRhdGEgdG8gY3JlYXRlIGEgcGF0aC5cbiAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICAgIHZhciBkID0gdHlwZTtcbiAgICAgIGlmIChpbnZlcnNlKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IHBhdGhBcnJheS5sZW5ndGggLSAyOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICAgIGQgKz0gcGF0aEFycmF5W2ldWzBdICsgXCIsXCIgKyBwYXRoQXJyYXlbaV1bMV0gKyBcIiBcIjtcbiAgICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcGF0aEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGQgKz0gcGF0aEFycmF5W2ldWzBdICsgXCIsXCIgKyBwYXRoQXJyYXlbaV1bMV0gKyBcIiBcIjtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZDtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyB1c2VzIGFuIHVuaWZvcm0gcGFyYW1ldHJpemF0aW9uIG9mIHRoZSBpbnRlcnBvbGF0aW9uIGFsZ29yaXRobTpcbiAgICogJ09uIHRoZSBQYXJhbWV0ZXJpemF0aW9uIG9mIENhdG11bGwtUm9tIEN1cnZlcycgYnkgQ2VtIFl1a3NlbCBldCBhbC5cbiAgICogQHBhcmFtIGRhdGFcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIExpbmUuX2NhdG11bGxSb21Vbmlmb3JtID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIC8vIGNhdG11bGwgcm9tXG4gICAgICB2YXIgcDAsIHAxLCBwMiwgcDMsIGJwMSwgYnAyO1xuICAgICAgdmFyIGQgPSBbXTtcbiAgICAgIGQucHVzaChbTWF0aC5yb3VuZChkYXRhWzBdLnNjcmVlbl94KSwgTWF0aC5yb3VuZChkYXRhWzBdLnNjcmVlbl95KV0pO1xuICAgICAgdmFyIG5vcm1hbGl6YXRpb24gPSAxIC8gNjtcbiAgICAgIHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoIC0gMTsgaSsrKSB7XG5cbiAgICAgICAgICBwMCA9IGkgPT0gMCA/IGRhdGFbMF0gOiBkYXRhW2kgLSAxXTtcbiAgICAgICAgICBwMSA9IGRhdGFbaV07XG4gICAgICAgICAgcDIgPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgICBwMyA9IGkgKyAyIDwgbGVuZ3RoID8gZGF0YVtpICsgMl0gOiBwMjtcblxuICAgICAgICAgIC8vIENhdG11bGwtUm9tIHRvIEN1YmljIEJlemllciBjb252ZXJzaW9uIG1hdHJpeFxuICAgICAgICAgIC8vICAgIDAgICAgICAgMSAgICAgICAwICAgICAgIDBcbiAgICAgICAgICAvLyAgLTEvNiAgICAgIDEgICAgICAxLzYgICAgICAwXG4gICAgICAgICAgLy8gICAgMCAgICAgIDEvNiAgICAgIDEgICAgIC0xLzZcbiAgICAgICAgICAvLyAgICAwICAgICAgIDAgICAgICAgMSAgICAgICAwXG5cbiAgICAgICAgICAvLyAgICBicDAgPSB7IHg6IHAxLngsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHAxLnkgfTtcbiAgICAgICAgICBicDEgPSB7XG4gICAgICAgICAgICAgIHNjcmVlbl94OiAoLXAwLnNjcmVlbl94ICsgNiAqIHAxLnNjcmVlbl94ICsgcDIuc2NyZWVuX3gpICogbm9ybWFsaXphdGlvbixcbiAgICAgICAgICAgICAgc2NyZWVuX3k6ICgtcDAuc2NyZWVuX3kgKyA2ICogcDEuc2NyZWVuX3kgKyBwMi5zY3JlZW5feSkgKiBub3JtYWxpemF0aW9uXG4gICAgICAgICAgfTtcbiAgICAgICAgICBicDIgPSB7XG4gICAgICAgICAgICAgIHNjcmVlbl94OiAocDEuc2NyZWVuX3ggKyA2ICogcDIuc2NyZWVuX3ggLSBwMy5zY3JlZW5feCkgKiBub3JtYWxpemF0aW9uLFxuICAgICAgICAgICAgICBzY3JlZW5feTogKHAxLnNjcmVlbl95ICsgNiAqIHAyLnNjcmVlbl95IC0gcDMuc2NyZWVuX3kpICogbm9ybWFsaXphdGlvblxuICAgICAgICAgIH07XG4gICAgICAgICAgLy8gICAgYnAwID0geyB4OiBwMi54LCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBwMi55IH07XG5cbiAgICAgICAgICBkLnB1c2goW2JwMS5zY3JlZW5feCwgYnAxLnNjcmVlbl95XSk7XG4gICAgICAgICAgZC5wdXNoKFticDIuc2NyZWVuX3gsIGJwMi5zY3JlZW5feV0pO1xuICAgICAgICAgIGQucHVzaChbcDIuc2NyZWVuX3gsIHAyLnNjcmVlbl95XSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIHVzZXMgZWl0aGVyIHRoZSBjaG9yZGFsIG9yIGNlbnRyaXBldGFsIHBhcmFtZXRlcml6YXRpb24gb2YgdGhlIGNhdG11bGwtcm9tIGFsZ29yaXRobS5cbiAgICogQnkgZGVmYXVsdCwgdGhlIGNlbnRyaXBldGFsIHBhcmFtZXRlcml6YXRpb24gaXMgdXNlZCBiZWNhdXNlIHRoaXMgZ2l2ZXMgdGhlIG5pY2VzdCByZXN1bHRzLlxuICAgKiBUaGVzZSBwYXJhbWV0ZXJpemF0aW9ucyBhcmUgcmVsYXRpdmVseSBoZWF2eSBiZWNhdXNlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIDQgcG9pbnRzIGhhdmUgdG8gYmUgY2FsY3VsYXRlZC5cbiAgICpcbiAgICogT25lIG9wdGltaXphdGlvbiBjYW4gYmUgdXNlZCB0byByZXVzZSBkaXN0YW5jZXMgc2luY2UgdGhpcyBpcyBhIHNsaWRpbmcgd2luZG93IGFwcHJvYWNoLlxuICAgKiBAcGFyYW0gZGF0YVxuICAgKiBAcGFyYW0gZ3JvdXBcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIExpbmUuX2NhdG11bGxSb20gPSBmdW5jdGlvbiAoZGF0YSwgZ3JvdXApIHtcbiAgICAgIHZhciBhbHBoYSA9IGdyb3VwLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5hbHBoYTtcbiAgICAgIGlmIChhbHBoYSA9PSAwIHx8IGFscGhhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY2F0bXVsbFJvbVVuaWZvcm0oZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwMCwgcDEsIHAyLCBwMywgYnAxLCBicDIsIGQxLCBkMiwgZDMsIEEsIEIsIE4sIE07XG4gICAgICAgICAgdmFyIGQzcG93QSwgZDJwb3dBLCBkM3BvdzJBLCBkMnBvdzJBLCBkMXBvdzJBLCBkMXBvd0E7XG4gICAgICAgICAgdmFyIGQgPSBbXTtcbiAgICAgICAgICBkLnB1c2goW01hdGgucm91bmQoZGF0YVswXS5zY3JlZW5feCksIE1hdGgucm91bmQoZGF0YVswXS5zY3JlZW5feSldKTtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGggLSAxOyBpKyspIHtcblxuICAgICAgICAgICAgICBwMCA9IGkgPT0gMCA/IGRhdGFbMF0gOiBkYXRhW2kgLSAxXTtcbiAgICAgICAgICAgICAgcDEgPSBkYXRhW2ldO1xuICAgICAgICAgICAgICBwMiA9IGRhdGFbaSArIDFdO1xuICAgICAgICAgICAgICBwMyA9IGkgKyAyIDwgbGVuZ3RoID8gZGF0YVtpICsgMl0gOiBwMjtcblxuICAgICAgICAgICAgICBkMSA9IE1hdGguc3FydChNYXRoLnBvdyhwMC5zY3JlZW5feCAtIHAxLnNjcmVlbl94LCAyKSArIE1hdGgucG93KHAwLnNjcmVlbl95IC0gcDEuc2NyZWVuX3ksIDIpKTtcbiAgICAgICAgICAgICAgZDIgPSBNYXRoLnNxcnQoTWF0aC5wb3cocDEuc2NyZWVuX3ggLSBwMi5zY3JlZW5feCwgMikgKyBNYXRoLnBvdyhwMS5zY3JlZW5feSAtIHAyLnNjcmVlbl95LCAyKSk7XG4gICAgICAgICAgICAgIGQzID0gTWF0aC5zcXJ0KE1hdGgucG93KHAyLnNjcmVlbl94IC0gcDMuc2NyZWVuX3gsIDIpICsgTWF0aC5wb3cocDIuc2NyZWVuX3kgLSBwMy5zY3JlZW5feSwgMikpO1xuXG4gICAgICAgICAgICAgIC8vIENhdG11bGwtUm9tIHRvIEN1YmljIEJlemllciBjb252ZXJzaW9uIG1hdHJpeFxuXG4gICAgICAgICAgICAgIC8vIEEgPSAyZDFeMmEgKyAzZDFeYSAqIGQyXmEgKyBkM14yYVxuICAgICAgICAgICAgICAvLyBCID0gMmQzXjJhICsgM2QzXmEgKiBkMl5hICsgZDJeMmFcblxuICAgICAgICAgICAgICAvLyBbICAgMCAgICAgICAgICAgICAxICAgICAgICAgICAgMCAgICAgICAgICAwICAgICAgICAgIF1cbiAgICAgICAgICAgICAgLy8gWyAgIC1kMl4yYSAvTiAgICAgQS9OICAgICAgICAgIGQxXjJhIC9OICAgMCAgICAgICAgICBdXG4gICAgICAgICAgICAgIC8vIFsgICAwICAgICAgICAgICAgIGQzXjJhIC9NICAgICBCL00gICAgICAgIC1kMl4yYSAvTSAgXVxuICAgICAgICAgICAgICAvLyBbICAgMCAgICAgICAgICAgICAwICAgICAgICAgICAgMSAgICAgICAgICAwICAgICAgICAgIF1cblxuICAgICAgICAgICAgICBkM3Bvd0EgPSBNYXRoLnBvdyhkMywgYWxwaGEpO1xuICAgICAgICAgICAgICBkM3BvdzJBID0gTWF0aC5wb3coZDMsIDIgKiBhbHBoYSk7XG4gICAgICAgICAgICAgIGQycG93QSA9IE1hdGgucG93KGQyLCBhbHBoYSk7XG4gICAgICAgICAgICAgIGQycG93MkEgPSBNYXRoLnBvdyhkMiwgMiAqIGFscGhhKTtcbiAgICAgICAgICAgICAgZDFwb3dBID0gTWF0aC5wb3coZDEsIGFscGhhKTtcbiAgICAgICAgICAgICAgZDFwb3cyQSA9IE1hdGgucG93KGQxLCAyICogYWxwaGEpO1xuXG4gICAgICAgICAgICAgIEEgPSAyICogZDFwb3cyQSArIDMgKiBkMXBvd0EgKiBkMnBvd0EgKyBkMnBvdzJBO1xuICAgICAgICAgICAgICBCID0gMiAqIGQzcG93MkEgKyAzICogZDNwb3dBICogZDJwb3dBICsgZDJwb3cyQTtcbiAgICAgICAgICAgICAgTiA9IDMgKiBkMXBvd0EgKiAoZDFwb3dBICsgZDJwb3dBKTtcbiAgICAgICAgICAgICAgaWYgKE4gPiAwKSB7XG4gICAgICAgICAgICAgICAgICBOID0gMSAvIE47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgTSA9IDMgKiBkM3Bvd0EgKiAoZDNwb3dBICsgZDJwb3dBKTtcbiAgICAgICAgICAgICAgaWYgKE0gPiAwKSB7XG4gICAgICAgICAgICAgICAgICBNID0gMSAvIE07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicDEgPSB7XG4gICAgICAgICAgICAgICAgICBzY3JlZW5feDogKC1kMnBvdzJBICogcDAuc2NyZWVuX3ggKyBBICogcDEuc2NyZWVuX3ggKyBkMXBvdzJBICogcDIuc2NyZWVuX3gpICogTixcbiAgICAgICAgICAgICAgICAgIHNjcmVlbl95OiAoLWQycG93MkEgKiBwMC5zY3JlZW5feSArIEEgKiBwMS5zY3JlZW5feSArIGQxcG93MkEgKiBwMi5zY3JlZW5feSkgKiBOXG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgYnAyID0ge1xuICAgICAgICAgICAgICAgICAgc2NyZWVuX3g6IChkM3BvdzJBICogcDEuc2NyZWVuX3ggKyBCICogcDIuc2NyZWVuX3ggLSBkMnBvdzJBICogcDMuc2NyZWVuX3gpICogTSxcbiAgICAgICAgICAgICAgICAgIHNjcmVlbl95OiAoZDNwb3cyQSAqIHAxLnNjcmVlbl95ICsgQiAqIHAyLnNjcmVlbl95IC0gZDJwb3cyQSAqIHAzLnNjcmVlbl95KSAqIE1cbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBpZiAoYnAxLnNjcmVlbl94ID09IDAgJiYgYnAxLnNjcmVlbl95ID09IDApIHtcbiAgICAgICAgICAgICAgICAgIGJwMSA9IHAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChicDIuc2NyZWVuX3ggPT0gMCAmJiBicDIuc2NyZWVuX3kgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgYnAyID0gcDI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZC5wdXNoKFticDEuc2NyZWVuX3gsIGJwMS5zY3JlZW5feV0pO1xuICAgICAgICAgICAgICBkLnB1c2goW2JwMi5zY3JlZW5feCwgYnAyLnNjcmVlbl95XSk7XG4gICAgICAgICAgICAgIGQucHVzaChbcDIuc2NyZWVuX3gsIHAyLnNjcmVlbl95XSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIHRoaXMgZ2VuZXJhdGVzIHRoZSBTVkcgcGF0aCBmb3IgYSBsaW5lYXIgZHJhd2luZyBiZXR3ZWVuIGRhdGFwb2ludHMuXG4gICAqIEBwYXJhbSBkYXRhXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBMaW5lLl9saW5lYXIgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgLy8gbGluZWFyXG4gICAgICB2YXIgZCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZC5wdXNoKFtkYXRhW2ldLnNjcmVlbl94LCBkYXRhW2ldLnNjcmVlbl95XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZDtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IExpbmU7XG5cbi8qKiovIH0sXG4vKiA1OCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbiAgdmFyIERPTXV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuICB2YXIgQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSk7XG5cbiAgLyoqXG4gICAqIExlZ2VuZCBmb3IgR3JhcGgyZFxuICAgKi9cbiAgZnVuY3Rpb24gTGVnZW5kKGJvZHksIG9wdGlvbnMsIHNpZGUsIGxpbmVncmFwaE9wdGlvbnMpIHtcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIGljb25zOiB0cnVlLFxuICAgICAgaWNvblNpemU6IDIwLFxuICAgICAgaWNvblNwYWNpbmc6IDYsXG4gICAgICBsZWZ0OiB7XG4gICAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICAgIHBvc2l0aW9uOiAndG9wLWxlZnQnIC8vIHRvcC9ib3R0b20gLSBsZWZ0LGNlbnRlcixyaWdodFxuICAgICAgfSxcbiAgICAgIHJpZ2h0OiB7XG4gICAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICAgIHBvc2l0aW9uOiAndG9wLXJpZ2h0JyAvLyB0b3AvYm90dG9tIC0gbGVmdCxjZW50ZXIscmlnaHRcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5zaWRlID0gc2lkZTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG4gICAgdGhpcy5saW5lZ3JhcGhPcHRpb25zID0gbGluZWdyYXBoT3B0aW9ucztcblxuICAgIHRoaXMuc3ZnRWxlbWVudHMgPSB7fTtcbiAgICB0aGlzLmRvbSA9IHt9O1xuICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgdGhpcy5hbW91bnRPZkdyb3VwcyA9IDA7XG4gICAgdGhpcy5fY3JlYXRlKCk7XG4gICAgdGhpcy5mcmFtZXdvcmsgPSB7IHN2ZzogdGhpcy5zdmcsIHN2Z0VsZW1lbnRzOiB0aGlzLnN2Z0VsZW1lbnRzLCBvcHRpb25zOiB0aGlzLm9wdGlvbnMsIGdyb3VwczogdGhpcy5ncm91cHMgfTtcblxuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIExlZ2VuZC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50KCk7XG5cbiAgTGVnZW5kLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgIHRoaXMuYW1vdW50T2ZHcm91cHMgPSAwO1xuICB9O1xuXG4gIExlZ2VuZC5wcm90b3R5cGUuYWRkR3JvdXAgPSBmdW5jdGlvbiAobGFiZWwsIGdyYXBoT3B0aW9ucykge1xuXG4gICAgLy8gSW5jbHVkZSBhIGdyb3VwIG9ubHkgaWYgdGhlIGdyb3VwIG9wdGlvbiAnZXhjbHVkZUZyb21MZWdlbmQ6IGZhbHNlJyBpcyBub3Qgc2V0LlxuICAgIGlmIChncmFwaE9wdGlvbnMub3B0aW9ucy5leGNsdWRlRnJvbUxlZ2VuZCAhPSB0cnVlKSB7XG4gICAgICBpZiAoIXRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KGxhYmVsKSkge1xuICAgICAgICB0aGlzLmdyb3Vwc1tsYWJlbF0gPSBncmFwaE9wdGlvbnM7XG4gICAgICB9XG4gICAgICB0aGlzLmFtb3VudE9mR3JvdXBzICs9IDE7XG4gICAgfVxuICB9O1xuXG4gIExlZ2VuZC5wcm90b3R5cGUudXBkYXRlR3JvdXAgPSBmdW5jdGlvbiAobGFiZWwsIGdyYXBoT3B0aW9ucykge1xuICAgIHRoaXMuZ3JvdXBzW2xhYmVsXSA9IGdyYXBoT3B0aW9ucztcbiAgfTtcblxuICBMZWdlbmQucHJvdG90eXBlLnJlbW92ZUdyb3VwID0gZnVuY3Rpb24gKGxhYmVsKSB7XG4gICAgaWYgKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KGxhYmVsKSkge1xuICAgICAgZGVsZXRlIHRoaXMuZ3JvdXBzW2xhYmVsXTtcbiAgICAgIHRoaXMuYW1vdW50T2ZHcm91cHMgLT0gMTtcbiAgICB9XG4gIH07XG5cbiAgTGVnZW5kLnByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZG9tLmZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5kb20uZnJhbWUuY2xhc3NOYW1lID0gJ3Zpcy1sZWdlbmQnO1xuICAgIHRoaXMuZG9tLmZyYW1lLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgIHRoaXMuZG9tLmZyYW1lLnN0eWxlLnRvcCA9IFwiMTBweFwiO1xuICAgIHRoaXMuZG9tLmZyYW1lLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG5cbiAgICB0aGlzLmRvbS50ZXh0QXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuZG9tLnRleHRBcmVhLmNsYXNzTmFtZSA9ICd2aXMtbGVnZW5kLXRleHQnO1xuICAgIHRoaXMuZG9tLnRleHRBcmVhLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgIHRoaXMuZG9tLnRleHRBcmVhLnN0eWxlLnRvcCA9IFwiMHB4XCI7XG5cbiAgICB0aGlzLnN2ZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCBcInN2Z1wiKTtcbiAgICB0aGlzLnN2Zy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgdGhpcy5zdmcuc3R5bGUudG9wID0gMCArICdweCc7XG4gICAgdGhpcy5zdmcuc3R5bGUud2lkdGggPSB0aGlzLm9wdGlvbnMuaWNvblNpemUgKyA1ICsgJ3B4JztcbiAgICB0aGlzLnN2Zy5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG5cbiAgICB0aGlzLmRvbS5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLnN2Zyk7XG4gICAgdGhpcy5kb20uZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5kb20udGV4dEFyZWEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIaWRlIHRoZSBjb21wb25lbnQgZnJvbSB0aGUgRE9NXG4gICAqL1xuICBMZWdlbmQucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gcmVtb3ZlIHRoZSBmcmFtZSBjb250YWluaW5nIHRoZSBpdGVtc1xuICAgIGlmICh0aGlzLmRvbS5mcmFtZS5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLmRvbS5mcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLmZyYW1lKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNob3cgdGhlIGNvbXBvbmVudCBpbiB0aGUgRE9NICh3aGVuIG5vdCBhbHJlYWR5IHZpc2libGUpLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBjaGFuZ2VkXG4gICAqL1xuICBMZWdlbmQucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gc2hvdyBmcmFtZSBjb250YWluaW5nIHRoZSBpdGVtc1xuICAgIGlmICghdGhpcy5kb20uZnJhbWUucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5ib2R5LmRvbS5jZW50ZXIuYXBwZW5kQ2hpbGQodGhpcy5kb20uZnJhbWUpO1xuICAgIH1cbiAgfTtcblxuICBMZWdlbmQucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBmaWVsZHMgPSBbJ2VuYWJsZWQnLCAnb3JpZW50YXRpb24nLCAnaWNvbnMnLCAnbGVmdCcsICdyaWdodCddO1xuICAgIHV0aWwuc2VsZWN0aXZlRGVlcEV4dGVuZChmaWVsZHMsIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gIH07XG5cbiAgTGVnZW5kLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFjdGl2ZUdyb3VwcyA9IDA7XG4gICAgdmFyIGdyb3VwQXJyYXkgPSBPYmplY3Qua2V5cyh0aGlzLmdyb3Vwcyk7XG4gICAgZ3JvdXBBcnJheS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IDE7XG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBncm91cElkID0gZ3JvdXBBcnJheVtpXTtcbiAgICAgIGlmICh0aGlzLmdyb3Vwc1tncm91cElkXS52aXNpYmxlID09IHRydWUgJiYgKHRoaXMubGluZWdyYXBoT3B0aW9ucy52aXNpYmlsaXR5W2dyb3VwSWRdID09PSB1bmRlZmluZWQgfHwgdGhpcy5saW5lZ3JhcGhPcHRpb25zLnZpc2liaWxpdHlbZ3JvdXBJZF0gPT0gdHJ1ZSkpIHtcbiAgICAgICAgYWN0aXZlR3JvdXBzKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9uc1t0aGlzLnNpZGVdLnZpc2libGUgPT0gZmFsc2UgfHwgdGhpcy5hbW91bnRPZkdyb3VwcyA9PSAwIHx8IHRoaXMub3B0aW9ucy5lbmFibGVkID09IGZhbHNlIHx8IGFjdGl2ZUdyb3VwcyA9PSAwKSB7XG4gICAgICB0aGlzLmhpZGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zaG93KCk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zW3RoaXMuc2lkZV0ucG9zaXRpb24gPT0gJ3RvcC1sZWZ0JyB8fCB0aGlzLm9wdGlvbnNbdGhpcy5zaWRlXS5wb3NpdGlvbiA9PSAnYm90dG9tLWxlZnQnKSB7XG4gICAgICAgIHRoaXMuZG9tLmZyYW1lLnN0eWxlLmxlZnQgPSAnNHB4JztcbiAgICAgICAgdGhpcy5kb20uZnJhbWUuc3R5bGUudGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgICAgIHRoaXMuZG9tLnRleHRBcmVhLnN0eWxlLnRleHRBbGlnbiA9IFwibGVmdFwiO1xuICAgICAgICB0aGlzLmRvbS50ZXh0QXJlYS5zdHlsZS5sZWZ0ID0gdGhpcy5vcHRpb25zLmljb25TaXplICsgMTUgKyAncHgnO1xuICAgICAgICB0aGlzLmRvbS50ZXh0QXJlYS5zdHlsZS5yaWdodCA9ICcnO1xuICAgICAgICB0aGlzLnN2Zy5zdHlsZS5sZWZ0ID0gMCArICdweCc7XG4gICAgICAgIHRoaXMuc3ZnLnN0eWxlLnJpZ2h0ID0gJyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRvbS5mcmFtZS5zdHlsZS5yaWdodCA9ICc0cHgnO1xuICAgICAgICB0aGlzLmRvbS5mcmFtZS5zdHlsZS50ZXh0QWxpZ24gPSBcInJpZ2h0XCI7XG4gICAgICAgIHRoaXMuZG9tLnRleHRBcmVhLnN0eWxlLnRleHRBbGlnbiA9IFwicmlnaHRcIjtcbiAgICAgICAgdGhpcy5kb20udGV4dEFyZWEuc3R5bGUucmlnaHQgPSB0aGlzLm9wdGlvbnMuaWNvblNpemUgKyAxNSArICdweCc7XG4gICAgICAgIHRoaXMuZG9tLnRleHRBcmVhLnN0eWxlLmxlZnQgPSAnJztcbiAgICAgICAgdGhpcy5zdmcuc3R5bGUucmlnaHQgPSAwICsgJ3B4JztcbiAgICAgICAgdGhpcy5zdmcuc3R5bGUubGVmdCA9ICcnO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zW3RoaXMuc2lkZV0ucG9zaXRpb24gPT0gJ3RvcC1sZWZ0JyB8fCB0aGlzLm9wdGlvbnNbdGhpcy5zaWRlXS5wb3NpdGlvbiA9PSAndG9wLXJpZ2h0Jykge1xuICAgICAgICB0aGlzLmRvbS5mcmFtZS5zdHlsZS50b3AgPSA0IC0gTnVtYmVyKHRoaXMuYm9keS5kb20uY2VudGVyLnN0eWxlLnRvcC5yZXBsYWNlKFwicHhcIiwgXCJcIikpICsgJ3B4JztcbiAgICAgICAgdGhpcy5kb20uZnJhbWUuc3R5bGUuYm90dG9tID0gJyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc2Nyb2xsYWJsZUhlaWdodCA9IHRoaXMuYm9keS5kb21Qcm9wcy5jZW50ZXIuaGVpZ2h0IC0gdGhpcy5ib2R5LmRvbVByb3BzLmNlbnRlckNvbnRhaW5lci5oZWlnaHQ7XG4gICAgICAgIHRoaXMuZG9tLmZyYW1lLnN0eWxlLmJvdHRvbSA9IDQgKyBzY3JvbGxhYmxlSGVpZ2h0ICsgTnVtYmVyKHRoaXMuYm9keS5kb20uY2VudGVyLnN0eWxlLnRvcC5yZXBsYWNlKFwicHhcIiwgXCJcIikpICsgJ3B4JztcbiAgICAgICAgdGhpcy5kb20uZnJhbWUuc3R5bGUudG9wID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaWNvbnMgPT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5kb20uZnJhbWUuc3R5bGUud2lkdGggPSB0aGlzLmRvbS50ZXh0QXJlYS5vZmZzZXRXaWR0aCArIDEwICsgJ3B4JztcbiAgICAgICAgdGhpcy5kb20udGV4dEFyZWEuc3R5bGUucmlnaHQgPSAnJztcbiAgICAgICAgdGhpcy5kb20udGV4dEFyZWEuc3R5bGUubGVmdCA9ICcnO1xuICAgICAgICB0aGlzLnN2Zy5zdHlsZS53aWR0aCA9ICcwcHgnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kb20uZnJhbWUuc3R5bGUud2lkdGggPSB0aGlzLm9wdGlvbnMuaWNvblNpemUgKyAxNSArIHRoaXMuZG9tLnRleHRBcmVhLm9mZnNldFdpZHRoICsgMTAgKyAncHgnO1xuICAgICAgICB0aGlzLmRyYXdMZWdlbmRJY29ucygpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGVudCA9ICcnO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBncm91cElkID0gZ3JvdXBBcnJheVtpXTtcbiAgICAgICAgaWYgKHRoaXMuZ3JvdXBzW2dyb3VwSWRdLnZpc2libGUgPT0gdHJ1ZSAmJiAodGhpcy5saW5lZ3JhcGhPcHRpb25zLnZpc2liaWxpdHlbZ3JvdXBJZF0gPT09IHVuZGVmaW5lZCB8fCB0aGlzLmxpbmVncmFwaE9wdGlvbnMudmlzaWJpbGl0eVtncm91cElkXSA9PSB0cnVlKSkge1xuICAgICAgICAgIGNvbnRlbnQgKz0gdGhpcy5ncm91cHNbZ3JvdXBJZF0uY29udGVudCArICc8YnIgLz4nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmRvbS50ZXh0QXJlYS5pbm5lckhUTUwgPSBjb250ZW50O1xuICAgICAgdGhpcy5kb20udGV4dEFyZWEuc3R5bGUubGluZUhlaWdodCA9IDAuNzUgKiB0aGlzLm9wdGlvbnMuaWNvblNpemUgKyB0aGlzLm9wdGlvbnMuaWNvblNwYWNpbmcgKyAncHgnO1xuICAgIH1cbiAgfTtcblxuICBMZWdlbmQucHJvdG90eXBlLmRyYXdMZWdlbmRJY29ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5kb20uZnJhbWUucGFyZW50Tm9kZSkge1xuICAgICAgdmFyIGdyb3VwQXJyYXkgPSBPYmplY3Qua2V5cyh0aGlzLmdyb3Vwcyk7XG4gICAgICBncm91cEFycmF5LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiAxO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHRoaXMgcmVzZXRzIHRoZSBlbGVtZW50cyBzbyB0aGUgb3JkZXIgaXMgbWFpbnRhaW5lZFxuICAgICAgRE9NdXRpbC5yZXNldEVsZW1lbnRzKHRoaXMuc3ZnRWxlbWVudHMpO1xuXG4gICAgICB2YXIgcGFkZGluZyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZG9tLmZyYW1lKS5wYWRkaW5nVG9wO1xuICAgICAgdmFyIGljb25PZmZzZXQgPSBOdW1iZXIocGFkZGluZy5yZXBsYWNlKCdweCcsICcnKSk7XG4gICAgICB2YXIgeCA9IGljb25PZmZzZXQ7XG4gICAgICB2YXIgaWNvbldpZHRoID0gdGhpcy5vcHRpb25zLmljb25TaXplO1xuICAgICAgdmFyIGljb25IZWlnaHQgPSAwLjc1ICogdGhpcy5vcHRpb25zLmljb25TaXplO1xuICAgICAgdmFyIHkgPSBpY29uT2Zmc2V0ICsgMC41ICogaWNvbkhlaWdodCArIDM7XG5cbiAgICAgIHRoaXMuc3ZnLnN0eWxlLndpZHRoID0gaWNvbldpZHRoICsgNSArIGljb25PZmZzZXQgKyAncHgnO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGdyb3VwSWQgPSBncm91cEFycmF5W2ldO1xuICAgICAgICBpZiAodGhpcy5ncm91cHNbZ3JvdXBJZF0udmlzaWJsZSA9PSB0cnVlICYmICh0aGlzLmxpbmVncmFwaE9wdGlvbnMudmlzaWJpbGl0eVtncm91cElkXSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMubGluZWdyYXBoT3B0aW9ucy52aXNpYmlsaXR5W2dyb3VwSWRdID09IHRydWUpKSB7XG4gICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBJZF0uZ2V0TGVnZW5kKGljb25XaWR0aCwgaWNvbkhlaWdodCwgdGhpcy5mcmFtZXdvcmssIHgsIHkpO1xuICAgICAgICAgIHkgKz0gaWNvbkhlaWdodCArIHRoaXMub3B0aW9ucy5pY29uU3BhY2luZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IExlZ2VuZDtcblxuLyoqKi8gfSxcbi8qIDU5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG4gIC8qKlxuICAgKiBUaGlzIG9iamVjdCBjb250YWlucyBhbGwgcG9zc2libGUgb3B0aW9ucy4gSXQgd2lsbCBjaGVjayBpZiB0aGUgdHlwZXMgYXJlIGNvcnJlY3QsIGlmIHJlcXVpcmVkIGlmIHRoZSBvcHRpb24gaXMgb25lXG4gICAqIG9mIHRoZSBhbGxvd2VkIHZhbHVlcy5cbiAgICpcbiAgICogX19hbnlfXyBtZWFucyB0aGF0IHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSBkb2VzIG5vdCBtYXR0ZXIuXG4gICAqIF9fdHlwZV9fIGlzIGEgcmVxdWlyZWQgZmllbGQgZm9yIGFsbCBvYmplY3RzIGFuZCBjb250YWlucyB0aGUgYWxsb3dlZCB0eXBlcyBvZiBhbGwgb2JqZWN0c1xuICAgKi9cbiAgdmFyIHN0cmluZyA9ICdzdHJpbmcnO1xuICB2YXIgYm9vbGVhbiA9ICdib29sZWFuJztcbiAgdmFyIG51bWJlciA9ICdudW1iZXInO1xuICB2YXIgYXJyYXkgPSAnYXJyYXknO1xuICB2YXIgZGF0ZSA9ICdkYXRlJztcbiAgdmFyIG9iamVjdCA9ICdvYmplY3QnOyAvLyBzaG91bGQgb25seSBiZSBpbiBhIF9fdHlwZV9fIHByb3BlcnR5XG4gIHZhciBkb20gPSAnZG9tJztcbiAgdmFyIG1vbWVudCA9ICdtb21lbnQnO1xuICB2YXIgYW55ID0gJ2FueSc7XG5cbiAgdmFyIGFsbE9wdGlvbnMgPSB7XG4gICAgY29uZmlndXJlOiB7XG4gICAgICBlbmFibGVkOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgIGZpbHRlcjogeyBib29sZWFuOiBib29sZWFuLCAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH0sXG4gICAgICBjb250YWluZXI6IHsgZG9tOiBkb20gfSxcbiAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBib29sZWFuOiBib29sZWFuLCAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH1cbiAgICB9LFxuXG4gICAgLy9nbG9iYWxzIDpcbiAgICB5QXhpc09yaWVudGF0aW9uOiB7IHN0cmluZzogWydsZWZ0JywgJ3JpZ2h0J10gfSxcbiAgICBkZWZhdWx0R3JvdXA6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICBzb3J0OiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICBzYW1wbGluZzogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgc3RhY2s6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgIGdyYXBoSGVpZ2h0OiB7IHN0cmluZzogc3RyaW5nLCBudW1iZXI6IG51bWJlciB9LFxuICAgIHNoYWRlZDoge1xuICAgICAgZW5hYmxlZDogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICBvcmllbnRhdGlvbjogeyBzdHJpbmc6IFsnYm90dG9tJywgJ3RvcCcsICd6ZXJvJywgJ2dyb3VwJ10gfSwgLy8gdG9wLCBib3R0b20sIHplcm8sIGdyb3VwXG4gICAgICBncm91cElkOiB7IG9iamVjdDogb2JqZWN0IH0sXG4gICAgICBfX3R5cGVfXzogeyBib29sZWFuOiBib29sZWFuLCBvYmplY3Q6IG9iamVjdCB9XG4gICAgfSxcbiAgICBzdHlsZTogeyBzdHJpbmc6IFsnbGluZScsICdiYXInLCAncG9pbnRzJ10gfSwgLy8gbGluZSwgYmFyXG4gICAgYmFyQ2hhcnQ6IHtcbiAgICAgIHdpZHRoOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICBtaW5XaWR0aDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgc2lkZUJ5U2lkZTogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICBhbGlnbjogeyBzdHJpbmc6IFsnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnXSB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICAgIH0sXG4gICAgaW50ZXJwb2xhdGlvbjoge1xuICAgICAgZW5hYmxlZDogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICBwYXJhbWV0cml6YXRpb246IHsgc3RyaW5nOiBbJ2NlbnRyaXBldGFsJywgJ2Nob3JkYWwnLCAndW5pZm9ybSddIH0sIC8vIHVuaWZvcm0gKGFscGhhID0gMC4wKSwgY2hvcmRhbCAoYWxwaGEgPSAxLjApLCBjZW50cmlwZXRhbCAoYWxwaGEgPSAwLjUpXG4gICAgICBhbHBoYTogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIGJvb2xlYW46IGJvb2xlYW4gfVxuICAgIH0sXG4gICAgZHJhd1BvaW50czoge1xuICAgICAgZW5hYmxlZDogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICBvblJlbmRlcjogeyAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH0sXG4gICAgICBzaXplOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICBzdHlsZTogeyBzdHJpbmc6IFsnc3F1YXJlJywgJ2NpcmNsZSddIH0sIC8vIHNxdWFyZSwgY2lyY2xlXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgYm9vbGVhbjogYm9vbGVhbiwgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9XG4gICAgfSxcbiAgICBkYXRhQXhpczoge1xuICAgICAgc2hvd01pbm9yTGFiZWxzOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgIHNob3dNYWpvckxhYmVsczogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICBpY29uczogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICB3aWR0aDogeyBzdHJpbmc6IHN0cmluZywgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIHZpc2libGU6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgYWxpZ25aZXJvczogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICBsZWZ0OiB7XG4gICAgICAgIHJhbmdlOiB7IG1pbjogeyBudW1iZXI6IG51bWJlciB9LCBtYXg6IHsgbnVtYmVyOiBudW1iZXIgfSwgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfSB9LFxuICAgICAgICBmb3JtYXQ6IHsgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgICAgICB0aXRsZTogeyB0ZXh0OiB7IHN0cmluZzogc3RyaW5nLCBudW1iZXI6IG51bWJlciB9LCBzdHlsZTogeyBzdHJpbmc6IHN0cmluZyB9LCBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9IH0sXG4gICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0IH1cbiAgICAgIH0sXG4gICAgICByaWdodDoge1xuICAgICAgICByYW5nZTogeyBtaW46IHsgbnVtYmVyOiBudW1iZXIgfSwgbWF4OiB7IG51bWJlcjogbnVtYmVyIH0sIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0IH0gfSxcbiAgICAgICAgZm9ybWF0OiB7ICdmdW5jdGlvbic6ICdmdW5jdGlvbicgfSxcbiAgICAgICAgdGl0bGU6IHsgdGV4dDogeyBzdHJpbmc6IHN0cmluZywgbnVtYmVyOiBudW1iZXIgfSwgc3R5bGU6IHsgc3RyaW5nOiBzdHJpbmcgfSwgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfSB9LFxuICAgICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gICAgICB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICAgIH0sXG4gICAgbGVnZW5kOiB7XG4gICAgICBlbmFibGVkOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgIGljb25zOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgIGxlZnQ6IHtcbiAgICAgICAgdmlzaWJsZTogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICAgIHBvc2l0aW9uOiB7IHN0cmluZzogWyd0b3AtcmlnaHQnLCAnYm90dG9tLXJpZ2h0JywgJ3RvcC1sZWZ0JywgJ2JvdHRvbS1sZWZ0J10gfSxcbiAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICAgICAgfSxcbiAgICAgIHJpZ2h0OiB7XG4gICAgICAgIHZpc2libGU6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgICBwb3NpdGlvbjogeyBzdHJpbmc6IFsndG9wLXJpZ2h0JywgJ2JvdHRvbS1yaWdodCcsICd0b3AtbGVmdCcsICdib3R0b20tbGVmdCddIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0IH1cbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgYm9vbGVhbjogYm9vbGVhbiB9XG4gICAgfSxcbiAgICBncm91cHM6IHtcbiAgICAgIHZpc2liaWxpdHk6IHsgYW55OiBhbnkgfSxcbiAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0IH1cbiAgICB9LFxuXG4gICAgYXV0b1Jlc2l6ZTogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgdGhyb3R0bGVSZWRyYXc6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICBjbGlja1RvVXNlOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICBlbmQ6IHsgbnVtYmVyOiBudW1iZXIsIGRhdGU6IGRhdGUsIHN0cmluZzogc3RyaW5nLCBtb21lbnQ6IG1vbWVudCB9LFxuICAgIGZvcm1hdDoge1xuICAgICAgbWlub3JMYWJlbHM6IHtcbiAgICAgICAgbWlsbGlzZWNvbmQ6IHsgc3RyaW5nOiBzdHJpbmcsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgICBzZWNvbmQ6IHsgc3RyaW5nOiBzdHJpbmcsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgICBtaW51dGU6IHsgc3RyaW5nOiBzdHJpbmcsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgICBob3VyOiB7IHN0cmluZzogc3RyaW5nLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgICAgd2Vla2RheTogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICAgIGRheTogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICAgIG1vbnRoOiB7IHN0cmluZzogc3RyaW5nLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgICAgeWVhcjogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0IH1cbiAgICAgIH0sXG4gICAgICBtYWpvckxhYmVsczoge1xuICAgICAgICBtaWxsaXNlY29uZDogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICAgIHNlY29uZDogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICAgIG1pbnV0ZTogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICAgIGhvdXI6IHsgc3RyaW5nOiBzdHJpbmcsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgICB3ZWVrZGF5OiB7IHN0cmluZzogc3RyaW5nLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgICAgZGF5OiB7IHN0cmluZzogc3RyaW5nLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgICAgbW9udGg6IHsgc3RyaW5nOiBzdHJpbmcsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgICB5ZWFyOiB7IHN0cmluZzogc3RyaW5nLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0IH1cbiAgICB9LFxuICAgIG1vbWVudDogeyAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH0sXG4gICAgaGVpZ2h0OiB7IHN0cmluZzogc3RyaW5nLCBudW1iZXI6IG51bWJlciB9LFxuICAgIGhpZGRlbkRhdGVzOiB7XG4gICAgICBzdGFydDogeyBkYXRlOiBkYXRlLCBudW1iZXI6IG51bWJlciwgc3RyaW5nOiBzdHJpbmcsIG1vbWVudDogbW9tZW50IH0sXG4gICAgICBlbmQ6IHsgZGF0ZTogZGF0ZSwgbnVtYmVyOiBudW1iZXIsIHN0cmluZzogc3RyaW5nLCBtb21lbnQ6IG1vbWVudCB9LFxuICAgICAgcmVwZWF0OiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgYXJyYXk6IGFycmF5IH1cbiAgICB9LFxuICAgIGxvY2FsZTogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgIGxvY2FsZXM6IHtcbiAgICAgIF9fYW55X186IHsgYW55OiBhbnkgfSxcbiAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0IH1cbiAgICB9LFxuICAgIG1heDogeyBkYXRlOiBkYXRlLCBudW1iZXI6IG51bWJlciwgc3RyaW5nOiBzdHJpbmcsIG1vbWVudDogbW9tZW50IH0sXG4gICAgbWF4SGVpZ2h0OiB7IG51bWJlcjogbnVtYmVyLCBzdHJpbmc6IHN0cmluZyB9LFxuICAgIG1heE1pbm9yQ2hhcnM6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICBtaW46IHsgZGF0ZTogZGF0ZSwgbnVtYmVyOiBudW1iZXIsIHN0cmluZzogc3RyaW5nLCBtb21lbnQ6IG1vbWVudCB9LFxuICAgIG1pbkhlaWdodDogeyBudW1iZXI6IG51bWJlciwgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICBtb3ZlYWJsZTogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgbXVsdGlzZWxlY3Q6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgIG9yaWVudGF0aW9uOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgc2hvd0N1cnJlbnRUaW1lOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICBzaG93TWFqb3JMYWJlbHM6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgIHNob3dNaW5vckxhYmVsczogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgc3RhcnQ6IHsgZGF0ZTogZGF0ZSwgbnVtYmVyOiBudW1iZXIsIHN0cmluZzogc3RyaW5nLCBtb21lbnQ6IG1vbWVudCB9LFxuICAgIHRpbWVBeGlzOiB7XG4gICAgICBzY2FsZTogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICBzdGVwOiB7IG51bWJlcjogbnVtYmVyLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0IH1cbiAgICB9LFxuICAgIHdpZHRoOiB7IHN0cmluZzogc3RyaW5nLCBudW1iZXI6IG51bWJlciB9LFxuICAgIHpvb21hYmxlOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICB6b29tS2V5OiB7IHN0cmluZzogWydjdHJsS2V5JywgJ2FsdEtleScsICdtZXRhS2V5JywgJyddIH0sXG4gICAgem9vbU1heDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgIHpvb21NaW46IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICB6SW5kZXg6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gIH07XG5cbiAgdmFyIGNvbmZpZ3VyZU9wdGlvbnMgPSB7XG4gICAgZ2xvYmFsOiB7XG4gICAgICAvL3lBeGlzT3JpZW50YXRpb246IFsnbGVmdCcsJ3JpZ2h0J10sIC8vIFRET086IGVuYWJsZSBhcyBzb29uIGFzIEdyYWhwMmQgZG9lc24ndCBjcmFzaCB3aGVuIGNoYW5naW5nIHRoaXMgb24gdGhlIGZseVxuICAgICAgc29ydDogdHJ1ZSxcbiAgICAgIHNhbXBsaW5nOiB0cnVlLFxuICAgICAgc3RhY2s6IGZhbHNlLFxuICAgICAgc2hhZGVkOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBvcmllbnRhdGlvbjogWyd6ZXJvJywgJ3RvcCcsICdib3R0b20nLCAnZ3JvdXAnXSAvLyB6ZXJvLCB0b3AsIGJvdHRvbVxuICAgICAgfSxcbiAgICAgIHN0eWxlOiBbJ2xpbmUnLCAnYmFyJywgJ3BvaW50cyddLCAvLyBsaW5lLCBiYXJcbiAgICAgIGJhckNoYXJ0OiB7XG4gICAgICAgIHdpZHRoOiBbNTAsIDUsIDEwMCwgNV0sXG4gICAgICAgIG1pbldpZHRoOiBbNTAsIDUsIDEwMCwgNV0sXG4gICAgICAgIHNpZGVCeVNpZGU6IGZhbHNlLFxuICAgICAgICBhbGlnbjogWydsZWZ0JywgJ2NlbnRlcicsICdyaWdodCddIC8vIGxlZnQsIGNlbnRlciwgcmlnaHRcbiAgICAgIH0sXG4gICAgICBpbnRlcnBvbGF0aW9uOiB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIHBhcmFtZXRyaXphdGlvbjogWydjZW50cmlwZXRhbCcsICdjaG9yZGFsJywgJ3VuaWZvcm0nXSAvLyB1bmlmb3JtIChhbHBoYSA9IDAuMCksIGNob3JkYWwgKGFscGhhID0gMS4wKSwgY2VudHJpcGV0YWwgKGFscGhhID0gMC41KVxuICAgICAgfSxcbiAgICAgIGRyYXdQb2ludHM6IHtcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgc2l6ZTogWzYsIDIsIDMwLCAxXSxcbiAgICAgICAgc3R5bGU6IFsnc3F1YXJlJywgJ2NpcmNsZSddIC8vIHNxdWFyZSwgY2lyY2xlXG4gICAgICB9LFxuICAgICAgZGF0YUF4aXM6IHtcbiAgICAgICAgc2hvd01pbm9yTGFiZWxzOiB0cnVlLFxuICAgICAgICBzaG93TWFqb3JMYWJlbHM6IHRydWUsXG4gICAgICAgIGljb25zOiBmYWxzZSxcbiAgICAgICAgd2lkdGg6IFs0MCwgMCwgMjAwLCAxXSxcbiAgICAgICAgdmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgYWxpZ25aZXJvczogdHJ1ZSxcbiAgICAgICAgbGVmdDoge1xuICAgICAgICAgIC8vcmFuZ2U6IHttaW46J3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnaW5lZCxtYXg6J3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnaW5lZH0sXG4gICAgICAgICAgLy9mb3JtYXQ6IGZ1bmN0aW9uICh2YWx1ZSkge3JldHVybiB2YWx1ZTt9LFxuICAgICAgICAgIHRpdGxlOiB7IHRleHQ6ICcnLCBzdHlsZTogJycgfVxuICAgICAgICB9LFxuICAgICAgICByaWdodDoge1xuICAgICAgICAgIC8vcmFuZ2U6IHttaW46J3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnaW5lZCxtYXg6J3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnaW5lZH0sXG4gICAgICAgICAgLy9mb3JtYXQ6IGZ1bmN0aW9uICh2YWx1ZSkge3JldHVybiB2YWx1ZTt9LFxuICAgICAgICAgIHRpdGxlOiB7IHRleHQ6ICcnLCBzdHlsZTogJycgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBpY29uczogdHJ1ZSxcbiAgICAgICAgbGVmdDoge1xuICAgICAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICAgICAgcG9zaXRpb246IFsndG9wLXJpZ2h0JywgJ2JvdHRvbS1yaWdodCcsICd0b3AtbGVmdCcsICdib3R0b20tbGVmdCddIC8vIHRvcC9ib3R0b20gLSBsZWZ0LHJpZ2h0XG4gICAgICAgIH0sXG4gICAgICAgIHJpZ2h0OiB7XG4gICAgICAgICAgdmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgICBwb3NpdGlvbjogWyd0b3AtcmlnaHQnLCAnYm90dG9tLXJpZ2h0JywgJ3RvcC1sZWZ0JywgJ2JvdHRvbS1sZWZ0J10gLy8gdG9wL2JvdHRvbSAtIGxlZnQscmlnaHRcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgYXV0b1Jlc2l6ZTogdHJ1ZSxcbiAgICAgIHRocm90dGxlUmVkcmF3OiBbMTAsIDAsIDEwMDAsIDEwXSxcbiAgICAgIGNsaWNrVG9Vc2U6IGZhbHNlLFxuICAgICAgZW5kOiAnJyxcbiAgICAgIGZvcm1hdDoge1xuICAgICAgICBtaW5vckxhYmVsczoge1xuICAgICAgICAgIG1pbGxpc2Vjb25kOiAnU1NTJyxcbiAgICAgICAgICBzZWNvbmQ6ICdzJyxcbiAgICAgICAgICBtaW51dGU6ICdISDptbScsXG4gICAgICAgICAgaG91cjogJ0hIOm1tJyxcbiAgICAgICAgICB3ZWVrZGF5OiAnZGRkIEQnLFxuICAgICAgICAgIGRheTogJ0QnLFxuICAgICAgICAgIG1vbnRoOiAnTU1NJyxcbiAgICAgICAgICB5ZWFyOiAnWVlZWSdcbiAgICAgICAgfSxcbiAgICAgICAgbWFqb3JMYWJlbHM6IHtcbiAgICAgICAgICBtaWxsaXNlY29uZDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICBzZWNvbmQ6ICdEIE1NTU0gSEg6bW0nLFxuICAgICAgICAgIG1pbnV0ZTogJ2RkZCBEIE1NTU0nLFxuICAgICAgICAgIGhvdXI6ICdkZGQgRCBNTU1NJyxcbiAgICAgICAgICB3ZWVrZGF5OiAnTU1NTSBZWVlZJyxcbiAgICAgICAgICBkYXk6ICdNTU1NIFlZWVknLFxuICAgICAgICAgIG1vbnRoOiAnWVlZWScsXG4gICAgICAgICAgeWVhcjogJydcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgaGVpZ2h0OiAnJyxcbiAgICAgIGxvY2FsZTogJycsXG4gICAgICBtYXg6ICcnLFxuICAgICAgbWF4SGVpZ2h0OiAnJyxcbiAgICAgIG1heE1pbm9yQ2hhcnM6IFs3LCAwLCAyMCwgMV0sXG4gICAgICBtaW46ICcnLFxuICAgICAgbWluSGVpZ2h0OiAnJyxcbiAgICAgIG1vdmVhYmxlOiB0cnVlLFxuICAgICAgb3JpZW50YXRpb246IFsnYm90aCcsICdib3R0b20nLCAndG9wJ10sXG4gICAgICBzaG93Q3VycmVudFRpbWU6IGZhbHNlLFxuICAgICAgc2hvd01ham9yTGFiZWxzOiB0cnVlLFxuICAgICAgc2hvd01pbm9yTGFiZWxzOiB0cnVlLFxuICAgICAgc3RhcnQ6ICcnLFxuICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgIHpvb21hYmxlOiB0cnVlLFxuICAgICAgem9vbUtleTogWydjdHJsS2V5JywgJ2FsdEtleScsICdtZXRhS2V5JywgJyddLFxuICAgICAgem9vbU1heDogWzMxNTM2MDAwMDAwMDAwMCwgMTAsIDMxNTM2MDAwMDAwMDAwMCwgMV0sXG4gICAgICB6b29tTWluOiBbMTAsIDEwLCAzMTUzNjAwMDAwMDAwMDAsIDFdLFxuICAgICAgekluZGV4OiAwXG4gICAgfVxuICB9O1xuXG4gIGV4cG9ydHMuYWxsT3B0aW9ucyA9IGFsbE9wdGlvbnM7XG4gIGV4cG9ydHMuY29uZmlndXJlT3B0aW9ucyA9IGNvbmZpZ3VyZU9wdGlvbnM7XG5cbi8qKiovIH0sXG4vKiA2MCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIHV0aWxzXG4gIGV4cG9ydHMudXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4gIGV4cG9ydHMuRE9NdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cbiAgLy8gZGF0YVxuICBleHBvcnRzLkRhdGFTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuICBleHBvcnRzLkRhdGFWaWV3ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG4gIGV4cG9ydHMuUXVldWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblxuICAvLyBOZXR3b3JrXG4gIGV4cG9ydHMuTmV0d29yayA9IF9fd2VicGFja19yZXF1aXJlX18oNjEpO1xuICBleHBvcnRzLm5ldHdvcmsgPSB7XG4gICAgSW1hZ2VzOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDYyKSxcbiAgICBkb3RwYXJzZXI6IF9fd2VicGFja19yZXF1aXJlX18oMTE4KSxcbiAgICBnZXBoaVBhcnNlcjogX193ZWJwYWNrX3JlcXVpcmVfXygxMTkpLFxuICAgIGFsbE9wdGlvbnM6IF9fd2VicGFja19yZXF1aXJlX18oMTE0KVxuICB9O1xuICBleHBvcnRzLm5ldHdvcmsuY29udmVydERvdCA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHJldHVybiBleHBvcnRzLm5ldHdvcmsuZG90cGFyc2VyLkRPVFRvR3JhcGgoaW5wdXQpO1xuICB9O1xuICBleHBvcnRzLm5ldHdvcmsuY29udmVydEdlcGhpID0gZnVuY3Rpb24gKGlucHV0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMubmV0d29yay5nZXBoaVBhcnNlci5wYXJzZUdlcGhpKGlucHV0LCBvcHRpb25zKTtcbiAgfTtcblxuICAvLyBidW5kbGVkIGV4dGVybmFsIGxpYnJhcmllc1xuICBleHBvcnRzLm1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4gIGV4cG9ydHMuSGFtbWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG4gIGV4cG9ydHMua2V5Y2hhcm0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcblxuLyoqKi8gfSxcbi8qIDYxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIF9JbWFnZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYyKTtcblxuICB2YXIgX0ltYWdlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9JbWFnZXMpO1xuXG4gIHZhciBfR3JvdXBzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Myk7XG5cbiAgdmFyIF9Hcm91cHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfR3JvdXBzKTtcblxuICB2YXIgX05vZGVzSGFuZGxlciA9IF9fd2VicGFja19yZXF1aXJlX18oNjQpO1xuXG4gIHZhciBfTm9kZXNIYW5kbGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX05vZGVzSGFuZGxlcik7XG5cbiAgdmFyIF9FZGdlc0hhbmRsZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0KTtcblxuICB2YXIgX0VkZ2VzSGFuZGxlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9FZGdlc0hhbmRsZXIpO1xuXG4gIHZhciBfUGh5c2ljc0VuZ2luZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTMpO1xuXG4gIHZhciBfUGh5c2ljc0VuZ2luZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9QaHlzaWNzRW5naW5lKTtcblxuICB2YXIgX0NsdXN0ZXJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMik7XG5cbiAgdmFyIF9DbHVzdGVyaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NsdXN0ZXJpbmcpO1xuXG4gIHZhciBfQ2FudmFzUmVuZGVyZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNSk7XG5cbiAgdmFyIF9DYW52YXNSZW5kZXJlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DYW52YXNSZW5kZXJlcik7XG5cbiAgdmFyIF9DYW52YXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNik7XG5cbiAgdmFyIF9DYW52YXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2FudmFzKTtcblxuICB2YXIgX1ZpZXcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNyk7XG5cbiAgdmFyIF9WaWV3MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1ZpZXcpO1xuXG4gIHZhciBfSW50ZXJhY3Rpb25IYW5kbGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDgpO1xuXG4gIHZhciBfSW50ZXJhY3Rpb25IYW5kbGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0ludGVyYWN0aW9uSGFuZGxlcik7XG5cbiAgdmFyIF9TZWxlY3Rpb25IYW5kbGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTEpO1xuXG4gIHZhciBfU2VsZWN0aW9uSGFuZGxlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TZWxlY3Rpb25IYW5kbGVyKTtcblxuICB2YXIgX0xheW91dEVuZ2luZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEyKTtcblxuICB2YXIgX0xheW91dEVuZ2luZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9MYXlvdXRFbmdpbmUpO1xuXG4gIHZhciBfTWFuaXB1bGF0aW9uU3lzdGVtID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTMpO1xuXG4gIHZhciBfTWFuaXB1bGF0aW9uU3lzdGVtMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01hbmlwdWxhdGlvblN5c3RlbSk7XG5cbiAgdmFyIF9Db25maWd1cmF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcblxuICB2YXIgX0NvbmZpZ3VyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Db25maWd1cmF0b3IpO1xuXG4gIHZhciBfVmFsaWRhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSk7XG5cbiAgdmFyIF9WYWxpZGF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVmFsaWRhdG9yKTtcblxuICB2YXIgX29wdGlvbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExNCk7XG5cbiAgdmFyIF9LYW1hZGFLYXdhaSA9IF9fd2VicGFja19yZXF1aXJlX18oMTE1KTtcblxuICB2YXIgX0thbWFkYUthd2FpMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0thbWFkYUthd2FpKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIC8vIExvYWQgY3VzdG9tIHNoYXBlcyBpbnRvIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRFxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDExNyk7XG5cbiAgdmFyIEVtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcbiAgdmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuICB2YXIgRGF0YVNldCA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG4gIHZhciBEYXRhVmlldyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuICB2YXIgZG90cGFyc2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTgpO1xuICB2YXIgZ2VwaGlQYXJzZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExOSk7XG4gIHZhciBBY3RpdmF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1KTtcbiAgdmFyIGxvY2FsZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyMCk7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvciBOZXR3b3JrXG4gICAqIENyZWF0ZSBhIG5ldHdvcmsgdmlzdWFsaXphdGlvbiwgZGlzcGxheWluZyBub2RlcyBhbmQgZWRnZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gY29udGFpbmVyICAgVGhlIERPTSBlbGVtZW50IGluIHdoaWNoIHRoZSBOZXR3b3JrIHdpbGxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmUgY3JlYXRlZC4gTm9ybWFsbHkgYSBkaXYgZWxlbWVudC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgICAgICAgICBBbiBvYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0FycmF5fSBub2Rlc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtBcnJheX0gZWRnZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgICAgICBPcHRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBOZXR3b3JrKGNvbnRhaW5lciwgZGF0YSwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTmV0d29yaykpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQ29uc3RydWN0b3IgbXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgbmV3IG9wZXJhdG9yJyk7XG4gICAgfVxuXG4gICAgLy8gc2V0IGNvbnN0YW50IHZhbHVlc1xuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBsb2NhbGU6ICdlbicsXG4gICAgICBsb2NhbGVzOiBsb2NhbGVzLFxuICAgICAgY2xpY2tUb1VzZTogZmFsc2VcbiAgICB9O1xuICAgIHV0aWwuZXh0ZW5kKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgICAvLyBjb250YWluZXJzIGZvciBub2RlcyBhbmQgZWRnZXNcbiAgICB0aGlzLmJvZHkgPSB7XG4gICAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgIG5vZGVzOiB7fSxcbiAgICAgIG5vZGVJbmRpY2VzOiBbXSxcbiAgICAgIGVkZ2VzOiB7fSxcbiAgICAgIGVkZ2VJbmRpY2VzOiBbXSxcbiAgICAgIGVtaXR0ZXI6IHtcbiAgICAgICAgb246IHRoaXMub24uYmluZCh0aGlzKSxcbiAgICAgICAgb2ZmOiB0aGlzLm9mZi5iaW5kKHRoaXMpLFxuICAgICAgICBlbWl0OiB0aGlzLmVtaXQuYmluZCh0aGlzKSxcbiAgICAgICAgb25jZTogdGhpcy5vbmNlLmJpbmQodGhpcylcbiAgICAgIH0sXG4gICAgICBldmVudExpc3RlbmVyczoge1xuICAgICAgICBvblRhcDogZnVuY3Rpb24gb25UYXAoKSB7fSxcbiAgICAgICAgb25Ub3VjaDogZnVuY3Rpb24gb25Ub3VjaCgpIHt9LFxuICAgICAgICBvbkRvdWJsZVRhcDogZnVuY3Rpb24gb25Eb3VibGVUYXAoKSB7fSxcbiAgICAgICAgb25Ib2xkOiBmdW5jdGlvbiBvbkhvbGQoKSB7fSxcbiAgICAgICAgb25EcmFnU3RhcnQ6IGZ1bmN0aW9uIG9uRHJhZ1N0YXJ0KCkge30sXG4gICAgICAgIG9uRHJhZzogZnVuY3Rpb24gb25EcmFnKCkge30sXG4gICAgICAgIG9uRHJhZ0VuZDogZnVuY3Rpb24gb25EcmFnRW5kKCkge30sXG4gICAgICAgIG9uTW91c2VXaGVlbDogZnVuY3Rpb24gb25Nb3VzZVdoZWVsKCkge30sXG4gICAgICAgIG9uUGluY2g6IGZ1bmN0aW9uIG9uUGluY2goKSB7fSxcbiAgICAgICAgb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIG9uTW91c2VNb3ZlKCkge30sXG4gICAgICAgIG9uUmVsZWFzZTogZnVuY3Rpb24gb25SZWxlYXNlKCkge30sXG4gICAgICAgIG9uQ29udGV4dDogZnVuY3Rpb24gb25Db250ZXh0KCkge31cbiAgICAgIH0sXG4gICAgICBkYXRhOiB7XG4gICAgICAgIG5vZGVzOiBudWxsLCAvLyBBIERhdGFTZXQgb3IgRGF0YVZpZXdcbiAgICAgICAgZWRnZXM6IG51bGwgLy8gQSBEYXRhU2V0IG9yIERhdGFWaWV3XG4gICAgICB9LFxuICAgICAgZnVuY3Rpb25zOiB7XG4gICAgICAgIGNyZWF0ZU5vZGU6IGZ1bmN0aW9uIGNyZWF0ZU5vZGUoKSB7fSxcbiAgICAgICAgY3JlYXRlRWRnZTogZnVuY3Rpb24gY3JlYXRlRWRnZSgpIHt9LFxuICAgICAgICBnZXRQb2ludGVyOiBmdW5jdGlvbiBnZXRQb2ludGVyKCkge31cbiAgICAgIH0sXG4gICAgICBtb2R1bGVzOiB7fSxcbiAgICAgIHZpZXc6IHtcbiAgICAgICAgc2NhbGU6IDEsXG4gICAgICAgIHRyYW5zbGF0aW9uOiB7IHg6IDAsIHk6IDAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBiaW5kIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICB0aGlzLmJpbmRFdmVudExpc3RlbmVycygpO1xuXG4gICAgLy8gc2V0dGluZyB1cCBhbGwgbW9kdWxlc1xuICAgIHRoaXMuaW1hZ2VzID0gbmV3IF9JbWFnZXMyLmRlZmF1bHQoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIik7XG4gICAgfSk7IC8vIG9iamVjdCB3aXRoIGltYWdlc1xuICAgIHRoaXMuZ3JvdXBzID0gbmV3IF9Hcm91cHMyLmRlZmF1bHQoKTsgLy8gb2JqZWN0IHdpdGggZ3JvdXBzXG4gICAgdGhpcy5jYW52YXMgPSBuZXcgX0NhbnZhczIuZGVmYXVsdCh0aGlzLmJvZHkpOyAvLyBET00gaGFuZGxlclxuICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlciA9IG5ldyBfU2VsZWN0aW9uSGFuZGxlcjIuZGVmYXVsdCh0aGlzLmJvZHksIHRoaXMuY2FudmFzKTsgLy8gU2VsZWN0aW9uIGhhbmRsZXJcbiAgICB0aGlzLmludGVyYWN0aW9uSGFuZGxlciA9IG5ldyBfSW50ZXJhY3Rpb25IYW5kbGVyMi5kZWZhdWx0KHRoaXMuYm9keSwgdGhpcy5jYW52YXMsIHRoaXMuc2VsZWN0aW9uSGFuZGxlcik7IC8vIEludGVyYWN0aW9uIGhhbmRsZXIgaGFuZGxlcyBhbGwgdGhlIGhhbW1lciBiaW5kaW5ncyAodGhhdCBhcmUgYm91bmQgYnkgY2FudmFzKSwga2V5XG4gICAgdGhpcy52aWV3ID0gbmV3IF9WaWV3Mi5kZWZhdWx0KHRoaXMuYm9keSwgdGhpcy5jYW52YXMpOyAvLyBjYW1lcmEgaGFuZGxlciwgZG9lcyBhbmltYXRpb25zIGFuZCB6b29tc1xuICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgX0NhbnZhc1JlbmRlcmVyMi5kZWZhdWx0KHRoaXMuYm9keSwgdGhpcy5jYW52YXMpOyAvLyByZW5kZXJlciwgc3RhcnRzIHJlbmRlcmxvb3AsIGhhcyBldmVudHMgdGhhdCBtb2R1bGVzIGNhbiBob29rIGludG9cbiAgICB0aGlzLnBoeXNpY3MgPSBuZXcgX1BoeXNpY3NFbmdpbmUyLmRlZmF1bHQodGhpcy5ib2R5KTsgLy8gcGh5c2ljcyBlbmdpbmUsIGRvZXMgYWxsIHRoZSBzaW11bGF0aW9uc1xuICAgIHRoaXMubGF5b3V0RW5naW5lID0gbmV3IF9MYXlvdXRFbmdpbmUyLmRlZmF1bHQodGhpcy5ib2R5KTsgLy8gbGF5b3V0IGVuZ2luZSBmb3IgaW5pdGFsIGxheW91dCBhbmQgaGllcmFyY2hpY2FsIGxheW91dFxuICAgIHRoaXMuY2x1c3RlcmluZyA9IG5ldyBfQ2x1c3RlcmluZzIuZGVmYXVsdCh0aGlzLmJvZHkpOyAvLyBjbHVzdGVyaW5nIGFwaVxuICAgIHRoaXMubWFuaXB1bGF0aW9uID0gbmV3IF9NYW5pcHVsYXRpb25TeXN0ZW0yLmRlZmF1bHQodGhpcy5ib2R5LCB0aGlzLmNhbnZhcywgdGhpcy5zZWxlY3Rpb25IYW5kbGVyKTsgLy8gZGF0YSBtYW5pcHVsYXRpb24gc3lzdGVtXG5cbiAgICB0aGlzLm5vZGVzSGFuZGxlciA9IG5ldyBfTm9kZXNIYW5kbGVyMi5kZWZhdWx0KHRoaXMuYm9keSwgdGhpcy5pbWFnZXMsIHRoaXMuZ3JvdXBzLCB0aGlzLmxheW91dEVuZ2luZSk7IC8vIEhhbmRsZSBhZGRpbmcsIGRlbGV0aW5nIGFuZCB1cGRhdGluZyBvZiBub2RlcyBhcyB3ZWxsIGFzIGdsb2JhbCBvcHRpb25zXG4gICAgdGhpcy5lZGdlc0hhbmRsZXIgPSBuZXcgX0VkZ2VzSGFuZGxlcjIuZGVmYXVsdCh0aGlzLmJvZHksIHRoaXMuaW1hZ2VzLCB0aGlzLmdyb3Vwcyk7IC8vIEhhbmRsZSBhZGRpbmcsIGRlbGV0aW5nIGFuZCB1cGRhdGluZyBvZiBlZGdlcyBhcyB3ZWxsIGFzIGdsb2JhbCBvcHRpb25zXG5cbiAgICB0aGlzLmJvZHkubW9kdWxlc1tcImthbWFkYUthd2FpXCJdID0gbmV3IF9LYW1hZGFLYXdhaTIuZGVmYXVsdCh0aGlzLmJvZHksIDE1MCwgMC4wNSk7IC8vIExheW91dGluZyBhbGdvcml0aG0uXG4gICAgdGhpcy5ib2R5Lm1vZHVsZXNbXCJjbHVzdGVyaW5nXCJdID0gdGhpcy5jbHVzdGVyaW5nO1xuXG4gICAgLy8gY3JlYXRlIHRoZSBET00gZWxlbWVudHNcbiAgICB0aGlzLmNhbnZhcy5fY3JlYXRlKCk7XG5cbiAgICAvLyBhcHBseSBvcHRpb25zXG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgLy8gbG9hZCBkYXRhICh0aGUgZGlzYWJsZSBzdGFydCB2YXJpYWJsZSB3aWxsIGJlIHRoZSBzYW1lIGFzIHRoZSBlbmFibGVkIGNsdXN0ZXJpbmcpXG4gICAgdGhpcy5zZXREYXRhKGRhdGEpO1xuICB9XG5cbiAgLy8gRXh0ZW5kIE5ldHdvcmsgd2l0aCBhbiBFbWl0dGVyIG1peGluXG4gIEVtaXR0ZXIoTmV0d29yay5wcm90b3R5cGUpO1xuXG4gIC8qKlxuICAgKiBTZXQgb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgTmV0d29yay5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgZXJyb3JGb3VuZCA9IF9WYWxpZGF0b3IyLmRlZmF1bHQudmFsaWRhdGUob3B0aW9ucywgX29wdGlvbnMuYWxsT3B0aW9ucyk7XG4gICAgICBpZiAoZXJyb3JGb3VuZCA9PT0gdHJ1ZSkge1xuICAgICAgICBjb25zb2xlLmxvZygnJWNFcnJvcnMgaGF2ZSBiZWVuIGZvdW5kIGluIHRoZSBzdXBwbGllZCBvcHRpb25zIG9iamVjdC4nLCBfVmFsaWRhdG9yLnByaW50U3R5bGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBjb3B5IHRoZSBnbG9iYWwgZmllbGRzIG92ZXJcbiAgICAgIHZhciBmaWVsZHMgPSBbJ2xvY2FsZScsICdsb2NhbGVzJywgJ2NsaWNrVG9Vc2UnXTtcbiAgICAgIHV0aWwuc2VsZWN0aXZlRGVlcEV4dGVuZChmaWVsZHMsIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgIC8vIHRoZSBoaWVyYXJjaGljYWwgc3lzdGVtIGNhbiBhZGFwdCB0aGUgZWRnZXMgYW5kIHRoZSBwaHlzaWNzIHRvIGl0J3Mgb3duIG9wdGlvbnMgYmVjYXVzZSBub3QgYWxsIGNvbWJpbmF0aW9ucyB3b3JrIHdpdGggdGhlIGhpZXJhcmljaGljYWwgc3lzdGVtLlxuICAgICAgb3B0aW9ucyA9IHRoaXMubGF5b3V0RW5naW5lLnNldE9wdGlvbnMob3B0aW9ucy5sYXlvdXQsIG9wdGlvbnMpO1xuXG4gICAgICB0aGlzLmNhbnZhcy5zZXRPcHRpb25zKG9wdGlvbnMpOyAvLyBvcHRpb25zIGZvciBjYW52YXMgYXJlIGluIGdsb2JhbHNcblxuICAgICAgLy8gcGFzcyB0aGUgb3B0aW9ucyB0byB0aGUgbW9kdWxlc1xuICAgICAgdGhpcy5ncm91cHMuc2V0T3B0aW9ucyhvcHRpb25zLmdyb3Vwcyk7XG4gICAgICB0aGlzLm5vZGVzSGFuZGxlci5zZXRPcHRpb25zKG9wdGlvbnMubm9kZXMpO1xuICAgICAgdGhpcy5lZGdlc0hhbmRsZXIuc2V0T3B0aW9ucyhvcHRpb25zLmVkZ2VzKTtcbiAgICAgIHRoaXMucGh5c2ljcy5zZXRPcHRpb25zKG9wdGlvbnMucGh5c2ljcyk7XG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbi5zZXRPcHRpb25zKG9wdGlvbnMubWFuaXB1bGF0aW9uLCBvcHRpb25zLCB0aGlzLm9wdGlvbnMpOyAvLyBtYW5pcHVsYXRpb24gdXNlcyB0aGUgbG9jYWxlcyBpbiB0aGUgZ2xvYmFsc1xuXG4gICAgICB0aGlzLmludGVyYWN0aW9uSGFuZGxlci5zZXRPcHRpb25zKG9wdGlvbnMuaW50ZXJhY3Rpb24pO1xuICAgICAgdGhpcy5yZW5kZXJlci5zZXRPcHRpb25zKG9wdGlvbnMuaW50ZXJhY3Rpb24pOyAvLyBvcHRpb25zIGZvciByZW5kZXJpbmcgYXJlIGluIGludGVyYWN0aW9uXG4gICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuc2V0T3B0aW9ucyhvcHRpb25zLmludGVyYWN0aW9uKTsgLy8gb3B0aW9ucyBmb3Igc2VsZWN0aW9uIGFyZSBpbiBpbnRlcmFjdGlvblxuXG4gICAgICAvLyByZWxvYWQgdGhlIHNldHRpbmdzIG9mIHRoZSBub2RlcyB0byBhcHBseSBjaGFuZ2VzIGluIGdyb3VwcyB0aGF0IGFyZSBub3QgcmVmZXJlbmNlZCBieSBwb2ludGVyLlxuICAgICAgaWYgKG9wdGlvbnMuZ3JvdXBzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInJlZnJlc2hOb2Rlc1wiKTtcbiAgICAgIH1cbiAgICAgIC8vIHRoZXNlIHR3byBkbyBub3QgaGF2ZSBvcHRpb25zIGF0IHRoZSBtb21lbnQsIGhlcmUgZm9yIGNvbXBsZXRlbmVzc1xuICAgICAgLy90aGlzLnZpZXcuc2V0T3B0aW9ucyhvcHRpb25zLnZpZXcpO1xuICAgICAgLy90aGlzLmNsdXN0ZXJpbmcuc2V0T3B0aW9ucyhvcHRpb25zLmNsdXN0ZXJpbmcpO1xuXG4gICAgICBpZiAoJ2NvbmZpZ3VyZScgaW4gb3B0aW9ucykge1xuICAgICAgICBpZiAoIXRoaXMuY29uZmlndXJhdG9yKSB7XG4gICAgICAgICAgdGhpcy5jb25maWd1cmF0b3IgPSBuZXcgX0NvbmZpZ3VyYXRvcjIuZGVmYXVsdCh0aGlzLCB0aGlzLmJvZHkuY29udGFpbmVyLCBfb3B0aW9ucy5jb25maWd1cmVPcHRpb25zLCB0aGlzLmNhbnZhcy5waXhlbFJhdGlvKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29uZmlndXJhdG9yLnNldE9wdGlvbnMob3B0aW9ucy5jb25maWd1cmUpO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiB0aGUgY29uZmlndXJhdGlvbiBzeXN0ZW0gaXMgZW5hYmxlZCwgY29weSBhbGwgb3B0aW9ucyBhbmQgcHV0IHRoZW0gaW50byB0aGUgY29uZmlnIHN5c3RlbVxuICAgICAgaWYgKHRoaXMuY29uZmlndXJhdG9yICYmIHRoaXMuY29uZmlndXJhdG9yLm9wdGlvbnMuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgbmV0d29ya09wdGlvbnMgPSB7IG5vZGVzOiB7fSwgZWRnZXM6IHt9LCBsYXlvdXQ6IHt9LCBpbnRlcmFjdGlvbjoge30sIG1hbmlwdWxhdGlvbjoge30sIHBoeXNpY3M6IHt9LCBnbG9iYWw6IHt9IH07XG4gICAgICAgIHV0aWwuZGVlcEV4dGVuZChuZXR3b3JrT3B0aW9ucy5ub2RlcywgdGhpcy5ub2Rlc0hhbmRsZXIub3B0aW9ucyk7XG4gICAgICAgIHV0aWwuZGVlcEV4dGVuZChuZXR3b3JrT3B0aW9ucy5lZGdlcywgdGhpcy5lZGdlc0hhbmRsZXIub3B0aW9ucyk7XG4gICAgICAgIHV0aWwuZGVlcEV4dGVuZChuZXR3b3JrT3B0aW9ucy5sYXlvdXQsIHRoaXMubGF5b3V0RW5naW5lLm9wdGlvbnMpO1xuICAgICAgICAvLyBsb2FkIHRoZSBzZWxlY3Rpb25IYW5kbGVyIGFuZCByZW5kZXIgZGVmYXVsdCBvcHRpb25zIGluIHRvIHRoZSBpbnRlcmFjdGlvbiBncm91cFxuICAgICAgICB1dGlsLmRlZXBFeHRlbmQobmV0d29ya09wdGlvbnMuaW50ZXJhY3Rpb24sIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5vcHRpb25zKTtcbiAgICAgICAgdXRpbC5kZWVwRXh0ZW5kKG5ldHdvcmtPcHRpb25zLmludGVyYWN0aW9uLCB0aGlzLnJlbmRlcmVyLm9wdGlvbnMpO1xuXG4gICAgICAgIHV0aWwuZGVlcEV4dGVuZChuZXR3b3JrT3B0aW9ucy5pbnRlcmFjdGlvbiwgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXIub3B0aW9ucyk7XG4gICAgICAgIHV0aWwuZGVlcEV4dGVuZChuZXR3b3JrT3B0aW9ucy5tYW5pcHVsYXRpb24sIHRoaXMubWFuaXB1bGF0aW9uLm9wdGlvbnMpO1xuICAgICAgICB1dGlsLmRlZXBFeHRlbmQobmV0d29ya09wdGlvbnMucGh5c2ljcywgdGhpcy5waHlzaWNzLm9wdGlvbnMpO1xuXG4gICAgICAgIC8vIGxvYWQgZ2xvYmFscyBpbnRvIHRoZSBnbG9iYWwgb2JqZWN0XG4gICAgICAgIHV0aWwuZGVlcEV4dGVuZChuZXR3b3JrT3B0aW9ucy5nbG9iYWwsIHRoaXMuY2FudmFzLm9wdGlvbnMpO1xuICAgICAgICB1dGlsLmRlZXBFeHRlbmQobmV0d29ya09wdGlvbnMuZ2xvYmFsLCB0aGlzLm9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuY29uZmlndXJhdG9yLnNldE1vZHVsZU9wdGlvbnMobmV0d29ya09wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICAvLyBoYW5kbGUgbmV0d29yayBnbG9iYWwgb3B0aW9uc1xuICAgICAgaWYgKG9wdGlvbnMuY2xpY2tUb1VzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmNsaWNrVG9Vc2UgPT09IHRydWUpIHtcbiAgICAgICAgICBpZiAodGhpcy5hY3RpdmF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmF0b3IgPSBuZXcgQWN0aXZhdG9yKHRoaXMuY2FudmFzLmZyYW1lKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdG9yLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzMi5ib2R5LmVtaXR0ZXIuZW1pdChcImFjdGl2YXRlXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLmFjdGl2YXRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2YXRvci5kZXN0cm95KCk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5hY3RpdmF0b3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJhY3RpdmF0ZVwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImFjdGl2YXRlXCIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNhbnZhcy5zZXRTaXplKCk7XG4gICAgICAvLyBzdGFydCB0aGUgcGh5c2ljcyBzaW11bGF0aW9uLiBDYW4gYmUgc2FmZWx5IGNhbGxlZCBtdWx0aXBsZSB0aW1lcy5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJzdGFydFNpbXVsYXRpb25cIik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHRoaXMuYm9keS5ub2RlSW5kaWNlcyB3aXRoIHRoZSBtb3N0IHJlY2VudCBub2RlIGluZGV4IGxpc3RcbiAgICogQHByaXZhdGVcbiAgICovXG4gIE5ldHdvcmsucHJvdG90eXBlLl91cGRhdGVWaXNpYmxlSW5kaWNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuICAgIHRoaXMuYm9keS5ub2RlSW5kaWNlcyA9IFtdO1xuICAgIHRoaXMuYm9keS5lZGdlSW5kaWNlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgbm9kZUlkIGluIG5vZGVzKSB7XG4gICAgICBpZiAobm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICBpZiAobm9kZXNbbm9kZUlkXS5vcHRpb25zLmhpZGRlbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLmJvZHkubm9kZUluZGljZXMucHVzaChub2Rlc1tub2RlSWRdLmlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGVkZ2VJZCBpbiBlZGdlcykge1xuICAgICAgaWYgKGVkZ2VzLmhhc093blByb3BlcnR5KGVkZ2VJZCkpIHtcbiAgICAgICAgaWYgKGVkZ2VzW2VkZ2VJZF0ub3B0aW9ucy5oaWRkZW4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVkZ2VJbmRpY2VzLnB1c2goZWRnZXNbZWRnZUlkXS5pZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEJpbmQgYWxsIGV2ZW50c1xuICAgKi9cbiAgTmV0d29yay5wcm90b3R5cGUuYmluZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgLy8gdGhpcyBldmVudCB3aWxsIHRyaWdnZXIgYSByZWJ1aWxkaW5nIG9mIHRoZSBjYWNoZSBldmVyeXRoaW5nLiBVc2VkIHdoZW4gbm9kZXMgb3IgZWRnZXMgaGF2ZSBiZWVuIGFkZGVkIG9yIHJlbW92ZWQuXG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfZGF0YUNoYW5nZWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgLy8gdXBkYXRlIHNob3J0Y3V0IGxpc3RzXG4gICAgICBfdGhpczMuX3VwZGF0ZVZpc2libGVJbmRpY2VzKCk7XG4gICAgICBfdGhpczMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKTtcbiAgICAgIC8vIGNhbGwgdGhlIGRhdGFVcGRhdGVkIGV2ZW50IGJlY2F1c2UgdGhlIG9ubHkgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSB0d28gaXMgdGhlIHVwZGF0aW5nIG9mIHRoZSBpbmRpY2VzXG4gICAgICBfdGhpczMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YVVwZGF0ZWRcIik7XG4gICAgfSk7XG5cbiAgICAvLyB0aGlzIGlzIGNhbGxlZCB3aGVuIG9wdGlvbnMgb2YgRVhJU1RJTkcgbm9kZXMgb3IgZWRnZXMgaGF2ZSBjaGFuZ2VkLlxuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2RhdGFVcGRhdGVkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIHVwZGF0ZSB2YWx1ZXNcbiAgICAgIF90aGlzMy5fdXBkYXRlVmFsdWVSYW5nZShfdGhpczMuYm9keS5ub2Rlcyk7XG4gICAgICBfdGhpczMuX3VwZGF0ZVZhbHVlUmFuZ2UoX3RoaXMzLmJvZHkuZWRnZXMpO1xuICAgICAgLy8gc3RhcnQgc2ltdWxhdGlvbiAoY2FuIGJlIGNhbGxlZCBzYWZlbHksIGV2ZW4gaWYgYWxyZWFkeSBydW5uaW5nKVxuICAgICAgX3RoaXMzLmJvZHkuZW1pdHRlci5lbWl0KFwic3RhcnRTaW11bGF0aW9uXCIpO1xuICAgICAgX3RoaXMzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIik7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBub2RlcyBhbmQgZWRnZXMsIGFuZCBvcHRpb25hbGx5IG9wdGlvbnMgYXMgd2VsbC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgICAgICAgICAgICAgIE9iamVjdCBjb250YWluaW5nIHBhcmFtZXRlcnM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7QXJyYXkgfCBEYXRhU2V0IHwgRGF0YVZpZXd9IFtub2Rlc10gQXJyYXkgd2l0aCBub2Rlc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0FycmF5IHwgRGF0YVNldCB8IERhdGFWaWV3fSBbZWRnZXNdIEFycmF5IHdpdGggZWRnZXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmd9IFtkb3RdIFN0cmluZyBjb250YWluaW5nIGRhdGEgaW4gRE9UIGZvcm1hdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZ30gW2dlcGhpXSBTdHJpbmcgY29udGFpbmluZyBkYXRhIGluIGdlcGhpIEpTT04gZm9ybWF0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7T3B0aW9uc30gW29wdGlvbnNdIE9iamVjdCB3aXRoIG9wdGlvbnNcbiAgICovXG4gIE5ldHdvcmsucHJvdG90eXBlLnNldERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIC8vIHJlc2V0IHRoZSBwaHlzaWNzIGVuZ2luZS5cbiAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwicmVzZXRQaHlzaWNzXCIpO1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVzZXREYXRhXCIpO1xuXG4gICAgLy8gdW5zZWxlY3QgYWxsIHRvIGVuc3VyZSBubyBzZWxlY3Rpb25zIGZyb20gb2xkIGRhdGEgYXJlIGNhcnJpZWQgb3Zlci5cbiAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIudW5zZWxlY3RBbGwoKTtcblxuICAgIGlmIChkYXRhICYmIGRhdGEuZG90ICYmIChkYXRhLm5vZGVzIHx8IGRhdGEuZWRnZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0RhdGEgbXVzdCBjb250YWluIGVpdGhlciBwYXJhbWV0ZXIgXCJkb3RcIiBvciAnICsgJyBwYXJhbWV0ZXIgcGFpciBcIm5vZGVzXCIgYW5kIFwiZWRnZXNcIiwgYnV0IG5vdCBib3RoLicpO1xuICAgIH1cblxuICAgIC8vIHNldCBvcHRpb25zXG4gICAgdGhpcy5zZXRPcHRpb25zKGRhdGEgJiYgZGF0YS5vcHRpb25zKTtcbiAgICAvLyBzZXQgYWxsIGRhdGFcbiAgICBpZiAoZGF0YSAmJiBkYXRhLmRvdCkge1xuICAgICAgY29uc29sZS5sb2coJ1RoZSBkb3QgcHJvcGVydHkgaGFzIGJlZW4gZGVwcmljYXRlZC4gUGxlYXNlIHVzZSB0aGUgc3RhdGljIGNvbnZlcnREb3QgbWV0aG9kIHRvIGNvbnZlcnQgRE9UIGludG8gdmlzLm5ldHdvcmsgZm9ybWF0IGFuZCB1c2UgdGhlIG5vcm1hbCBkYXRhIGZvcm1hdCB3aXRoIG5vZGVzIGFuZCBlZGdlcy4gVGhpcyBjb252ZXJ0ZXIgaXMgdXNlZCBsaWtlIHRoaXM6IHZhciBkYXRhID0gdmlzLm5ldHdvcmsuY29udmVydERvdChkb3RTdHJpbmcpOycpO1xuICAgICAgLy8gcGFyc2UgRE9UIGZpbGVcbiAgICAgIHZhciBkb3REYXRhID0gZG90cGFyc2VyLkRPVFRvR3JhcGgoZGF0YS5kb3QpO1xuICAgICAgdGhpcy5zZXREYXRhKGRvdERhdGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoZGF0YSAmJiBkYXRhLmdlcGhpKSB7XG4gICAgICAvLyBwYXJzZSBET1QgZmlsZVxuICAgICAgY29uc29sZS5sb2coJ1RoZSBnZXBoaSBwcm9wZXJ0eSBoYXMgYmVlbiBkZXByaWNhdGVkLiBQbGVhc2UgdXNlIHRoZSBzdGF0aWMgY29udmVydEdlcGhpIG1ldGhvZCB0byBjb252ZXJ0IGdlcGhpIGludG8gdmlzLm5ldHdvcmsgZm9ybWF0IGFuZCB1c2UgdGhlIG5vcm1hbCBkYXRhIGZvcm1hdCB3aXRoIG5vZGVzIGFuZCBlZGdlcy4gVGhpcyBjb252ZXJ0ZXIgaXMgdXNlZCBsaWtlIHRoaXM6IHZhciBkYXRhID0gdmlzLm5ldHdvcmsuY29udmVydEdlcGhpKGdlcGhpSnNvbik7Jyk7XG4gICAgICB2YXIgZ2VwaGlEYXRhID0gZ2VwaGlQYXJzZXIucGFyc2VHZXBoaShkYXRhLmdlcGhpKTtcbiAgICAgIHRoaXMuc2V0RGF0YShnZXBoaURhdGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5vZGVzSGFuZGxlci5zZXREYXRhKGRhdGEgJiYgZGF0YS5ub2RlcywgdHJ1ZSk7XG4gICAgICB0aGlzLmVkZ2VzSGFuZGxlci5zZXREYXRhKGRhdGEgJiYgZGF0YS5lZGdlcywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLy8gZW1pdCBjaGFuZ2UgaW4gZGF0YVxuICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG5cbiAgICAvLyBlbWl0IGRhdGEgbG9hZGVkXG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhTG9hZGVkXCIpO1xuXG4gICAgLy8gZmluZCBhIHN0YWJsZSBwb3NpdGlvbiBvciBzdGFydCBhbmltYXRpbmcgdG8gYSBzdGFibGUgcG9zaXRpb25cbiAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiaW5pdFBoeXNpY3NcIik7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsZWFucyB1cCBhbGwgYmluZGluZ3Mgb2YgdGhlIG5ldHdvcmssIHJlbW92aW5nIGl0IGZ1bGx5IGZyb20gdGhlIG1lbW9yeSBJRiB0aGUgdmFyaWFibGUgaXMgc2V0IHRvIG51bGwgYWZ0ZXIgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLlxuICAgKiB2YXIgbmV0d29yayA9IG5ldyB2aXMuTmV0d29yayguLik7XG4gICAqIG5ldHdvcmsuZGVzdHJveSgpO1xuICAgKiBuZXR3b3JrID0gbnVsbDtcbiAgICovXG4gIE5ldHdvcmsucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImRlc3Ryb3lcIik7XG4gICAgLy8gY2xlYXIgZXZlbnRzXG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIub2ZmKCk7XG4gICAgdGhpcy5vZmYoKTtcblxuICAgIC8vIGRlbGV0ZSBtb2R1bGVzXG4gICAgZGVsZXRlIHRoaXMuZ3JvdXBzO1xuICAgIGRlbGV0ZSB0aGlzLmNhbnZhcztcbiAgICBkZWxldGUgdGhpcy5zZWxlY3Rpb25IYW5kbGVyO1xuICAgIGRlbGV0ZSB0aGlzLmludGVyYWN0aW9uSGFuZGxlcjtcbiAgICBkZWxldGUgdGhpcy52aWV3O1xuICAgIGRlbGV0ZSB0aGlzLnJlbmRlcmVyO1xuICAgIGRlbGV0ZSB0aGlzLnBoeXNpY3M7XG4gICAgZGVsZXRlIHRoaXMubGF5b3V0RW5naW5lO1xuICAgIGRlbGV0ZSB0aGlzLmNsdXN0ZXJpbmc7XG4gICAgZGVsZXRlIHRoaXMubWFuaXB1bGF0aW9uO1xuICAgIGRlbGV0ZSB0aGlzLm5vZGVzSGFuZGxlcjtcbiAgICBkZWxldGUgdGhpcy5lZGdlc0hhbmRsZXI7XG4gICAgZGVsZXRlIHRoaXMuY29uZmlndXJhdG9yO1xuICAgIGRlbGV0ZSB0aGlzLmltYWdlcztcblxuICAgIGZvciAodmFyIG5vZGVJZCBpbiB0aGlzLmJvZHkubm9kZXMpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICB9XG4gICAgZm9yICh2YXIgZWRnZUlkIGluIHRoaXMuYm9keS5lZGdlcykge1xuICAgICAgZGVsZXRlIHRoaXMuYm9keS5lZGdlc1tlZGdlSWRdO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSB0aGUgY29udGFpbmVyIGFuZCBldmVyeXRoaW5nIGluc2lkZSBpdCByZWN1cnNpdmVseVxuICAgIHV0aWwucmVjdXJzaXZlRE9NRGVsZXRlKHRoaXMuYm9keS5jb250YWluZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHZhbHVlcyBvZiBhbGwgb2JqZWN0IGluIHRoZSBnaXZlbiBhcnJheSBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnRcbiAgICogdmFsdWUgcmFuZ2Ugb2YgdGhlIG9iamVjdHMgaW4gdGhlIGFycmF5LlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqICAgIEFuIG9iamVjdCBjb250YWluaW5nIGEgc2V0IG9mIEVkZ2VzIG9yIE5vZGVzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG9iamVjdHMgbXVzdCBoYXZlIGEgbWV0aG9kIGdldFZhbHVlKCkgYW5kXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWVSYW5nZShtaW4sIG1heCkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBOZXR3b3JrLnByb3RvdHlwZS5fdXBkYXRlVmFsdWVSYW5nZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgaWQ7XG5cbiAgICAvLyBkZXRlcm1pbmUgdGhlIHJhbmdlIG9mIHRoZSBvYmplY3RzXG4gICAgdmFyIHZhbHVlTWluID0gdW5kZWZpbmVkO1xuICAgIHZhciB2YWx1ZU1heCA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdmFsdWVUb3RhbCA9IDA7XG4gICAgZm9yIChpZCBpbiBvYmopIHtcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG9ialtpZF0uZ2V0VmFsdWUoKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YWx1ZU1pbiA9IHZhbHVlTWluID09PSB1bmRlZmluZWQgPyB2YWx1ZSA6IE1hdGgubWluKHZhbHVlLCB2YWx1ZU1pbik7XG4gICAgICAgICAgdmFsdWVNYXggPSB2YWx1ZU1heCA9PT0gdW5kZWZpbmVkID8gdmFsdWUgOiBNYXRoLm1heCh2YWx1ZSwgdmFsdWVNYXgpO1xuICAgICAgICAgIHZhbHVlVG90YWwgKz0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhZGp1c3QgdGhlIHJhbmdlIG9mIGFsbCBvYmplY3RzXG4gICAgaWYgKHZhbHVlTWluICE9PSB1bmRlZmluZWQgJiYgdmFsdWVNYXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgZm9yIChpZCBpbiBvYmopIHtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICBvYmpbaWRdLnNldFZhbHVlUmFuZ2UodmFsdWVNaW4sIHZhbHVlTWF4LCB2YWx1ZVRvdGFsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIHdoZW4gdGhlIE5ldHdvcmsgaXMgYWN0aXZlLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIE5ldHdvcmsucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhdGhpcy5hY3RpdmF0b3IgfHwgdGhpcy5hY3RpdmF0b3IuYWN0aXZlO1xuICB9O1xuXG4gIE5ldHdvcmsucHJvdG90eXBlLnNldFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzLnNldFNpemUuYXBwbHkodGhpcy5jYW52YXMsIGFyZ3VtZW50cyk7XG4gIH07XG4gIE5ldHdvcmsucHJvdG90eXBlLmNhbnZhc1RvRE9NID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNhbnZhcy5jYW52YXNUb0RPTS5hcHBseSh0aGlzLmNhbnZhcywgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuRE9NdG9DYW52YXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzLkRPTXRvQ2FudmFzLmFwcGx5KHRoaXMuY2FudmFzLCBhcmd1bWVudHMpO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5maW5kTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jbHVzdGVyaW5nLmZpbmROb2RlLmFwcGx5KHRoaXMuY2x1c3RlcmluZywgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuaXNDbHVzdGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNsdXN0ZXJpbmcuaXNDbHVzdGVyLmFwcGx5KHRoaXMuY2x1c3RlcmluZywgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUub3BlbkNsdXN0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy5vcGVuQ2x1c3Rlci5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsIGFyZ3VtZW50cyk7XG4gIH07XG4gIE5ldHdvcmsucHJvdG90eXBlLmNsdXN0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy5jbHVzdGVyLmFwcGx5KHRoaXMuY2x1c3RlcmluZywgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuZ2V0Tm9kZXNJbkNsdXN0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy5nZXROb2Rlc0luQ2x1c3Rlci5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsIGFyZ3VtZW50cyk7XG4gIH07XG4gIE5ldHdvcmsucHJvdG90eXBlLmNsdXN0ZXJCeUNvbm5lY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy5jbHVzdGVyQnlDb25uZWN0aW9uLmFwcGx5KHRoaXMuY2x1c3RlcmluZywgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuY2x1c3RlckJ5SHVic2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jbHVzdGVyaW5nLmNsdXN0ZXJCeUh1YnNpemUuYXBwbHkodGhpcy5jbHVzdGVyaW5nLCBhcmd1bWVudHMpO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5jbHVzdGVyT3V0bGllcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy5jbHVzdGVyT3V0bGllcnMuYXBwbHkodGhpcy5jbHVzdGVyaW5nLCBhcmd1bWVudHMpO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5nZXRTZWVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmxheW91dEVuZ2luZS5nZXRTZWVkLmFwcGx5KHRoaXMubGF5b3V0RW5naW5lLCBhcmd1bWVudHMpO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5lbmFibGVFZGl0TW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5tYW5pcHVsYXRpb24uZW5hYmxlRWRpdE1vZGUuYXBwbHkodGhpcy5tYW5pcHVsYXRpb24sIGFyZ3VtZW50cyk7XG4gIH07XG4gIE5ldHdvcmsucHJvdG90eXBlLmRpc2FibGVFZGl0TW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5tYW5pcHVsYXRpb24uZGlzYWJsZUVkaXRNb2RlLmFwcGx5KHRoaXMubWFuaXB1bGF0aW9uLCBhcmd1bWVudHMpO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5hZGROb2RlTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5tYW5pcHVsYXRpb24uYWRkTm9kZU1vZGUuYXBwbHkodGhpcy5tYW5pcHVsYXRpb24sIGFyZ3VtZW50cyk7XG4gIH07XG4gIE5ldHdvcmsucHJvdG90eXBlLmVkaXROb2RlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1hbmlwdWxhdGlvbi5lZGl0Tm9kZS5hcHBseSh0aGlzLm1hbmlwdWxhdGlvbiwgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuZWRpdE5vZGVNb2RlID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnNvbGUubG9nKFwiRGVwcmVjYXRlZDogUGxlYXNlIHVzZSBlZGl0Tm9kZSBpbnN0ZWFkIG9mIGVkaXROb2RlTW9kZS5cIik7cmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmVkaXROb2RlLmFwcGx5KHRoaXMubWFuaXB1bGF0aW9uLCBhcmd1bWVudHMpO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5hZGRFZGdlTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5tYW5pcHVsYXRpb24uYWRkRWRnZU1vZGUuYXBwbHkodGhpcy5tYW5pcHVsYXRpb24sIGFyZ3VtZW50cyk7XG4gIH07XG4gIE5ldHdvcmsucHJvdG90eXBlLmVkaXRFZGdlTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5tYW5pcHVsYXRpb24uZWRpdEVkZ2VNb2RlLmFwcGx5KHRoaXMubWFuaXB1bGF0aW9uLCBhcmd1bWVudHMpO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5kZWxldGVTZWxlY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5tYW5pcHVsYXRpb24uZGVsZXRlU2VsZWN0ZWQuYXBwbHkodGhpcy5tYW5pcHVsYXRpb24sIGFyZ3VtZW50cyk7XG4gIH07XG4gIE5ldHdvcmsucHJvdG90eXBlLmdldFBvc2l0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlc0hhbmRsZXIuZ2V0UG9zaXRpb25zLmFwcGx5KHRoaXMubm9kZXNIYW5kbGVyLCBhcmd1bWVudHMpO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5zdG9yZVBvc2l0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlc0hhbmRsZXIuc3RvcmVQb3NpdGlvbnMuYXBwbHkodGhpcy5ub2Rlc0hhbmRsZXIsIGFyZ3VtZW50cyk7XG4gIH07XG4gIE5ldHdvcmsucHJvdG90eXBlLm1vdmVOb2RlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzSGFuZGxlci5tb3ZlTm9kZS5hcHBseSh0aGlzLm5vZGVzSGFuZGxlciwgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuZ2V0Qm91bmRpbmdCb3ggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXNIYW5kbGVyLmdldEJvdW5kaW5nQm94LmFwcGx5KHRoaXMubm9kZXNIYW5kbGVyLCBhcmd1bWVudHMpO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5nZXRDb25uZWN0ZWROb2RlcyA9IGZ1bmN0aW9uIChvYmplY3RJZCkge1xuICAgIGlmICh0aGlzLmJvZHkubm9kZXNbb2JqZWN0SWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzSGFuZGxlci5nZXRDb25uZWN0ZWROb2Rlcy5hcHBseSh0aGlzLm5vZGVzSGFuZGxlciwgYXJndW1lbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZWRnZXNIYW5kbGVyLmdldENvbm5lY3RlZE5vZGVzLmFwcGx5KHRoaXMuZWRnZXNIYW5kbGVyLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuZ2V0Q29ubmVjdGVkRWRnZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXNIYW5kbGVyLmdldENvbm5lY3RlZEVkZ2VzLmFwcGx5KHRoaXMubm9kZXNIYW5kbGVyLCBhcmd1bWVudHMpO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5zdGFydFNpbXVsYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucGh5c2ljcy5zdGFydFNpbXVsYXRpb24uYXBwbHkodGhpcy5waHlzaWNzLCBhcmd1bWVudHMpO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5zdG9wU2ltdWxhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5waHlzaWNzLnN0b3BTaW11bGF0aW9uLmFwcGx5KHRoaXMucGh5c2ljcywgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuc3RhYmlsaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnBoeXNpY3Muc3RhYmlsaXplLmFwcGx5KHRoaXMucGh5c2ljcywgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuZ2V0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0aW9uLmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlciwgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuc2V0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuc2V0U2VsZWN0aW9uLmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlciwgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuZ2V0U2VsZWN0ZWROb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldFNlbGVjdGVkTm9kZXMuYXBwbHkodGhpcy5zZWxlY3Rpb25IYW5kbGVyLCBhcmd1bWVudHMpO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5nZXRTZWxlY3RlZEVkZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0ZWRFZGdlcy5hcHBseSh0aGlzLnNlbGVjdGlvbkhhbmRsZXIsIGFyZ3VtZW50cyk7XG4gIH07XG4gIE5ldHdvcmsucHJvdG90eXBlLmdldE5vZGVBdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXROb2RlQXQuYXBwbHkodGhpcy5zZWxlY3Rpb25IYW5kbGVyLCBhcmd1bWVudHMpO1xuICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQgJiYgbm9kZS5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbm9kZS5pZDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG4gIE5ldHdvcmsucHJvdG90eXBlLmdldEVkZ2VBdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWRnZSA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRFZGdlQXQuYXBwbHkodGhpcy5zZWxlY3Rpb25IYW5kbGVyLCBhcmd1bWVudHMpO1xuICAgIGlmIChlZGdlICE9PSB1bmRlZmluZWQgJiYgZWRnZS5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZWRnZS5pZDtcbiAgICB9XG4gICAgcmV0dXJuIGVkZ2U7XG4gIH07XG4gIE5ldHdvcmsucHJvdG90eXBlLnNlbGVjdE5vZGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuc2VsZWN0Tm9kZXMuYXBwbHkodGhpcy5zZWxlY3Rpb25IYW5kbGVyLCBhcmd1bWVudHMpO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5zZWxlY3RFZGdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnNlbGVjdEVkZ2VzLmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlciwgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUudW5zZWxlY3RBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnVuc2VsZWN0QWxsLmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlciwgYXJndW1lbnRzKTtcbiAgICB0aGlzLnJlZHJhdygpO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZXIucmVkcmF3LmFwcGx5KHRoaXMucmVuZGVyZXIsIGFyZ3VtZW50cyk7XG4gIH07XG4gIE5ldHdvcmsucHJvdG90eXBlLmdldFNjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnZpZXcuZ2V0U2NhbGUuYXBwbHkodGhpcy52aWV3LCBhcmd1bWVudHMpO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5nZXRWaWV3UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5nZXRWaWV3UG9zaXRpb24uYXBwbHkodGhpcy52aWV3LCBhcmd1bWVudHMpO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5maXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5maXQuYXBwbHkodGhpcy52aWV3LCBhcmd1bWVudHMpO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5tb3ZlVG8gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5tb3ZlVG8uYXBwbHkodGhpcy52aWV3LCBhcmd1bWVudHMpO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3LmZvY3VzLmFwcGx5KHRoaXMudmlldywgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUucmVsZWFzZU5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5yZWxlYXNlTm9kZS5hcHBseSh0aGlzLnZpZXcsIGFyZ3VtZW50cyk7XG4gIH07XG4gIE5ldHdvcmsucHJvdG90eXBlLmdldE9wdGlvbnNGcm9tQ29uZmlndXJhdG9yID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcHRpb25zID0ge307XG4gICAgaWYgKHRoaXMuY29uZmlndXJhdG9yKSB7XG4gICAgICBvcHRpb25zID0gdGhpcy5jb25maWd1cmF0b3IuZ2V0T3B0aW9ucy5hcHBseSh0aGlzLmNvbmZpZ3VyYXRvcik7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gTmV0d29yaztcblxuLyoqKi8gfSxcbi8qIDYyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuICBcInVzZSBzdHJpY3RcIjtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICAvKipcbiAgICogQGNsYXNzIEltYWdlc1xuICAgKiBUaGlzIGNsYXNzIGxvYWRzIGltYWdlcyBhbmQga2VlcHMgdGhlbSBzdG9yZWQuXG4gICAqL1xuXG4gIHZhciBJbWFnZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBJbWFnZXMoY2FsbGJhY2spIHtcbiAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW1hZ2VzKTtcblxuICAgICAgICAgIHRoaXMuaW1hZ2VzID0ge307XG4gICAgICAgICAgdGhpcy5pbWFnZUJyb2tlbiA9IHt9O1xuICAgICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsICAgICAgICAgICAgICAgICAgICAgIFRoZSBVcmwgdG8gY2FjaGUgdGhlIGltYWdlIGFzIFxuICAgICAgICAqIEByZXR1cm4ge0ltYWdlfSBpbWFnZVRvTG9hZEJyb2tlblVybE9uICBUaGUgaW1hZ2Ugb2JqZWN0XG4gICAgICAgKi9cblxuXG4gICAgICBfY3JlYXRlQ2xhc3MoSW1hZ2VzLCBbe1xuICAgICAgICAgIGtleTogXCJfYWRkSW1hZ2VUb0NhY2hlXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRJbWFnZVRvQ2FjaGUodXJsLCBpbWFnZVRvQ2FjaGUpIHtcbiAgICAgICAgICAgICAgLy8gSUUxMSBmaXggLS0gdGhhbmtzIGRwb25jaCFcbiAgICAgICAgICAgICAgaWYgKGltYWdlVG9DYWNoZS53aWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpbWFnZVRvQ2FjaGUpO1xuICAgICAgICAgICAgICAgICAgaW1hZ2VUb0NhY2hlLndpZHRoID0gaW1hZ2VUb0NhY2hlLm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICAgICAgaW1hZ2VUb0NhY2hlLmhlaWdodCA9IGltYWdlVG9DYWNoZS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGltYWdlVG9DYWNoZSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLmltYWdlc1t1cmxdID0gaW1hZ2VUb0NhY2hlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgICAgICAgICAgICAgICAgICAgICAgVGhlIG9yaWdpbmFsIFVybCB0aGF0IGZhaWxlZCB0byBsb2FkLCBpZiB0aGUgYnJva2VuIGltYWdlIGlzIHN1Y2Nlc3NmdWxseSBsb2FkZWQgaXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgY2FjaGUgdXNpbmcgdGhpcyBVcmwgYXMgdGhlIGtleSBzbyB0aGF0IHN1YnNlcXVlbnQgcmVxdWVzdHMgZm9yIHRoaXMgVXJsIHdpbGwgcmV0dXJuIHRoZSBicm9rZW4gaW1hZ2VcbiAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYnJva2VuVXJsICAgICAgICAgICAgICAgIFVybCB0aGUgYnJva2VuIGltYWdlIHRvIHRyeSBhbmQgbG9hZFxuICAgICAgICAgICAqIEByZXR1cm4ge0ltYWdlfSBpbWFnZVRvTG9hZEJyb2tlblVybE9uICAgVGhlIGltYWdlIG9iamVjdFxuICAgICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcIl90cnlsb2FkQnJva2VuVXJsXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF90cnlsb2FkQnJva2VuVXJsKHVybCwgYnJva2VuVXJsLCBpbWFnZVRvTG9hZEJyb2tlblVybE9uKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgLy9JZiBhbnkgb2YgdGhlIHBhcmFtZXRlcnMgYXJlbid0IHNwZWNpZmllZCB0aGVuIGV4aXQgdGhlIGZ1bmN0aW9uIGJlY2F1c2Ugbm90aGluZyBjb25zdHJ1Y3RpdmUgY2FuIGJlIGRvbmVcbiAgICAgICAgICAgICAgaWYgKHVybCA9PT0gdW5kZWZpbmVkIHx8IGJyb2tlblVybCA9PT0gdW5kZWZpbmVkIHx8IGltYWdlVG9Mb2FkQnJva2VuVXJsT24gPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgIC8vQ2xlYXIgdGhlIG9sZCBzdWJzY3JpcHRpb24gdG8gdGhlIGVycm9yIGV2ZW50IGFuZCBwdXQgYSBuZXcgaW4gcGxhY2UgdGhhdCBvbmx5IGhhbmRsZSBlcnJvcnMgaW4gbG9hZGluZyB0aGUgYnJva2VuSW1hZ2VVcmxcbiAgICAgICAgICAgICAgaW1hZ2VUb0xvYWRCcm9rZW5VcmxPbi5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkNvdWxkIG5vdCBsb2FkIGJyb2tlbkltYWdlOlwiLCBicm9rZW5VcmwpO1xuICAgICAgICAgICAgICAgICAgLy9BZGQgYW4gZW1wdHkgaW1hZ2UgdG8gdGhlIGNhY2hlIHNvIHRoYXQgd2hlbiBzdWJzZXF1ZW50IGxvYWQgY2FsbHMgYXJlIG1hZGUgZm9yIHRoZSB1cmwgd2UgZG9uJ3QgdHJ5IGxvYWQgdGhlIGltYWdlIGFuZCBicm9rZW4gaW1hZ2UgYWdhaW5cbiAgICAgICAgICAgICAgICAgIF90aGlzLl9hZGRJbWFnZVRvQ2FjaGUodXJsLCBuZXcgSW1hZ2UoKSk7XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgLy9TZXQgdGhlIHNvdXJjZSBvZiB0aGUgaW1hZ2UgdG8gdGhlIGJyb2tlblVybCwgdGhpcyBpcyBhY3R1YWxseSB3aGF0IGtpY2tzIG9mZiB0aGUgbG9hZGluZyBvZiB0aGUgYnJva2VuIGltYWdlXG4gICAgICAgICAgICAgIGltYWdlVG9Mb2FkQnJva2VuVXJsT24uc3JjID0gYnJva2VuVXJsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEByZXR1cm4ge0ltYWdlfSBpbWFnZVRvUmVkcmF3V2l0aCBUaGUgaW1hZ2VzIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIHdoZW4gaXQgaXMgaW52b2tlZFxuICAgICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcIl9yZWRyYXdXaXRoSW1hZ2VcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3JlZHJhd1dpdGhJbWFnZShpbWFnZVRvUmVkcmF3V2l0aCkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFjayhpbWFnZVRvUmVkcmF3V2l0aCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsICAgICAgICAgIFVybCBvZiB0aGUgaW1hZ2VcbiAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYnJva2VuVXJsICAgIFVybCBvZiBhbiBpbWFnZSB0byB1c2UgaWYgdGhlIHVybCBpbWFnZSBpcyBub3QgZm91bmRcbiAgICAgICAgICAgKiBAcmV0dXJuIHtJbWFnZX0gaW1nICAgICAgICAgIFRoZSBpbWFnZSBvYmplY3RcbiAgICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJsb2FkXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWQodXJsLCBicm9rZW5VcmwsIGlkKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgICAgICAgIC8vVHJ5IGFuZCBnZXQgdGhlIGltYWdlIGZyb20gdGhlIGNhY2hlLCBpZiBzdWNjZXNzZnVsIHRoZW4gcmV0dXJuIHRoZSBjYWNoZWQgaW1hZ2UgIFxuICAgICAgICAgICAgICB2YXIgY2FjaGVkSW1hZ2UgPSB0aGlzLmltYWdlc1t1cmxdO1xuICAgICAgICAgICAgICBpZiAoY2FjaGVkSW1hZ2UpIHJldHVybiBjYWNoZWRJbWFnZTtcblxuICAgICAgICAgICAgICAvL0NyZWF0ZSBhIG5ldyBpbWFnZVxuICAgICAgICAgICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG5cbiAgICAgICAgICAgICAgLy9TdWJzY3JpYmUgdG8gdGhlIGV2ZW50IHRoYXQgaXMgcmFpc2VkIGlmIHRoZSBpbWFnZSBsb2FkcyBzdWNjZXNzZnVsbHlcbiAgICAgICAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIC8vQWRkIHRoZSBpbWFnZSB0byB0aGUgY2FjaGUgYW5kIHRoZW4gcmVxdWVzdCBhIHJlZHJhd1xuICAgICAgICAgICAgICAgICAgX3RoaXMyLl9hZGRJbWFnZVRvQ2FjaGUodXJsLCBpbWcpO1xuICAgICAgICAgICAgICAgICAgX3RoaXMyLl9yZWRyYXdXaXRoSW1hZ2UoaW1nKTtcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAvL1N1YnNjcmliZSB0byB0aGUgZXZlbnQgdGhhdCBpcyByYWlzZWQgaWYgdGhlIGltYWdlIGZhaWxzIHRvIGxvYWRcbiAgICAgICAgICAgICAgaW1nLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiQ291bGQgbm90IGxvYWQgaW1hZ2U6XCIsIHVybCk7XG4gICAgICAgICAgICAgICAgICAvL1RyeSBhbmQgbG9hZCB0aGUgaW1hZ2Ugc3BlY2lmaWVkIGJ5IHRoZSBicm9rZW5VcmwgdXNpbmdcbiAgICAgICAgICAgICAgICAgIF90aGlzMi5fdHJ5bG9hZEJyb2tlblVybCh1cmwsIGJyb2tlblVybCwgaW1nKTtcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAvL1NldCB0aGUgc291cmNlIG9mIHRoZSBpbWFnZSB0byB0aGUgdXJsLCB0aGlzIGlzIGFjdHVhbGwgd2hhdCBraWNrcyBvZmYgdGhlIGxvYWRpbmcgb2YgdGhlIGltYWdlXG4gICAgICAgICAgICAgIGltZy5zcmMgPSB1cmw7XG5cbiAgICAgICAgICAgICAgLy9SZXR1cm4gdGhlIG5ldyBpbWFnZVxuICAgICAgICAgICAgICByZXR1cm4gaW1nO1xuICAgICAgICAgIH1cbiAgICAgIH1dKTtcblxuICAgICAgcmV0dXJuIEltYWdlcztcbiAgfSgpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IEltYWdlcztcblxuLyoqKi8gfSxcbi8qIDYzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICBcInVzZSBzdHJpY3RcIjtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgdmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4gIC8qKlxuICAgKiBAY2xhc3MgR3JvdXBzXG4gICAqIFRoaXMgY2xhc3MgY2FuIHN0b3JlIGdyb3VwcyBhbmQgb3B0aW9ucyBzcGVjaWZpYyBmb3IgZ3JvdXBzLlxuICAgKi9cblxuICB2YXIgR3JvdXBzID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdyb3VwcygpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBHcm91cHMpO1xuXG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICB0aGlzLmRlZmF1bHRJbmRleCA9IDA7XG4gICAgICB0aGlzLmdyb3Vwc0FycmF5ID0gW107XG4gICAgICB0aGlzLmdyb3VwSW5kZXggPSAwO1xuXG4gICAgICB0aGlzLmRlZmF1bHRHcm91cHMgPSBbeyBib3JkZXI6IFwiIzJCN0NFOVwiLCBiYWNrZ3JvdW5kOiBcIiM5N0MyRkNcIiwgaGlnaGxpZ2h0OiB7IGJvcmRlcjogXCIjMkI3Q0U5XCIsIGJhY2tncm91bmQ6IFwiI0QyRTVGRlwiIH0sIGhvdmVyOiB7IGJvcmRlcjogXCIjMkI3Q0U5XCIsIGJhY2tncm91bmQ6IFwiI0QyRTVGRlwiIH0gfSwgLy8gMDogYmx1ZVxuICAgICAgeyBib3JkZXI6IFwiI0ZGQTUwMFwiLCBiYWNrZ3JvdW5kOiBcIiNGRkZGMDBcIiwgaGlnaGxpZ2h0OiB7IGJvcmRlcjogXCIjRkZBNTAwXCIsIGJhY2tncm91bmQ6IFwiI0ZGRkZBM1wiIH0sIGhvdmVyOiB7IGJvcmRlcjogXCIjRkZBNTAwXCIsIGJhY2tncm91bmQ6IFwiI0ZGRkZBM1wiIH0gfSwgLy8gMTogeWVsbG93XG4gICAgICB7IGJvcmRlcjogXCIjRkEwQTEwXCIsIGJhY2tncm91bmQ6IFwiI0ZCN0U4MVwiLCBoaWdobGlnaHQ6IHsgYm9yZGVyOiBcIiNGQTBBMTBcIiwgYmFja2dyb3VuZDogXCIjRkZBRkIxXCIgfSwgaG92ZXI6IHsgYm9yZGVyOiBcIiNGQTBBMTBcIiwgYmFja2dyb3VuZDogXCIjRkZBRkIxXCIgfSB9LCAvLyAyOiByZWRcbiAgICAgIHsgYm9yZGVyOiBcIiM0MUE5MDZcIiwgYmFja2dyb3VuZDogXCIjN0JFMTQxXCIsIGhpZ2hsaWdodDogeyBib3JkZXI6IFwiIzQxQTkwNlwiLCBiYWNrZ3JvdW5kOiBcIiNBMUVDNzZcIiB9LCBob3ZlcjogeyBib3JkZXI6IFwiIzQxQTkwNlwiLCBiYWNrZ3JvdW5kOiBcIiNBMUVDNzZcIiB9IH0sIC8vIDM6IGdyZWVuXG4gICAgICB7IGJvcmRlcjogXCIjRTEyOUYwXCIsIGJhY2tncm91bmQ6IFwiI0VCN0RGNFwiLCBoaWdobGlnaHQ6IHsgYm9yZGVyOiBcIiNFMTI5RjBcIiwgYmFja2dyb3VuZDogXCIjRjBCM0Y1XCIgfSwgaG92ZXI6IHsgYm9yZGVyOiBcIiNFMTI5RjBcIiwgYmFja2dyb3VuZDogXCIjRjBCM0Y1XCIgfSB9LCAvLyA0OiBtYWdlbnRhXG4gICAgICB7IGJvcmRlcjogXCIjN0MyOUYwXCIsIGJhY2tncm91bmQ6IFwiI0FEODVFNFwiLCBoaWdobGlnaHQ6IHsgYm9yZGVyOiBcIiM3QzI5RjBcIiwgYmFja2dyb3VuZDogXCIjRDNCREYwXCIgfSwgaG92ZXI6IHsgYm9yZGVyOiBcIiM3QzI5RjBcIiwgYmFja2dyb3VuZDogXCIjRDNCREYwXCIgfSB9LCAvLyA1OiBwdXJwbGVcbiAgICAgIHsgYm9yZGVyOiBcIiNDMzdGMDBcIiwgYmFja2dyb3VuZDogXCIjRkZBODA3XCIsIGhpZ2hsaWdodDogeyBib3JkZXI6IFwiI0MzN0YwMFwiLCBiYWNrZ3JvdW5kOiBcIiNGRkNBNjZcIiB9LCBob3ZlcjogeyBib3JkZXI6IFwiI0MzN0YwMFwiLCBiYWNrZ3JvdW5kOiBcIiNGRkNBNjZcIiB9IH0sIC8vIDY6IG9yYW5nZVxuICAgICAgeyBib3JkZXI6IFwiIzQyMjBGQlwiLCBiYWNrZ3JvdW5kOiBcIiM2RTZFRkRcIiwgaGlnaGxpZ2h0OiB7IGJvcmRlcjogXCIjNDIyMEZCXCIsIGJhY2tncm91bmQ6IFwiIzlCOUJGRFwiIH0sIGhvdmVyOiB7IGJvcmRlcjogXCIjNDIyMEZCXCIsIGJhY2tncm91bmQ6IFwiIzlCOUJGRFwiIH0gfSwgLy8gNzogZGFya2JsdWVcbiAgICAgIHsgYm9yZGVyOiBcIiNGRDVBNzdcIiwgYmFja2dyb3VuZDogXCIjRkZDMENCXCIsIGhpZ2hsaWdodDogeyBib3JkZXI6IFwiI0ZENUE3N1wiLCBiYWNrZ3JvdW5kOiBcIiNGRkQxRDlcIiB9LCBob3ZlcjogeyBib3JkZXI6IFwiI0ZENUE3N1wiLCBiYWNrZ3JvdW5kOiBcIiNGRkQxRDlcIiB9IH0sIC8vIDg6IHBpbmtcbiAgICAgIHsgYm9yZGVyOiBcIiM0QUQ2M0FcIiwgYmFja2dyb3VuZDogXCIjQzJGQUJDXCIsIGhpZ2hsaWdodDogeyBib3JkZXI6IFwiIzRBRDYzQVwiLCBiYWNrZ3JvdW5kOiBcIiNFNkZGRTNcIiB9LCBob3ZlcjogeyBib3JkZXI6IFwiIzRBRDYzQVwiLCBiYWNrZ3JvdW5kOiBcIiNFNkZGRTNcIiB9IH0sIC8vIDk6IG1pbnRcblxuICAgICAgeyBib3JkZXI6IFwiIzk5MDAwMFwiLCBiYWNrZ3JvdW5kOiBcIiNFRTAwMDBcIiwgaGlnaGxpZ2h0OiB7IGJvcmRlcjogXCIjQkIwMDAwXCIsIGJhY2tncm91bmQ6IFwiI0ZGMzMzM1wiIH0sIGhvdmVyOiB7IGJvcmRlcjogXCIjQkIwMDAwXCIsIGJhY2tncm91bmQ6IFwiI0ZGMzMzM1wiIH0gfSwgLy8gMTA6YnJpZ2h0IHJlZFxuXG4gICAgICB7IGJvcmRlcjogXCIjRkY2MDAwXCIsIGJhY2tncm91bmQ6IFwiI0ZGNjAwMFwiLCBoaWdobGlnaHQ6IHsgYm9yZGVyOiBcIiNGRjYwMDBcIiwgYmFja2dyb3VuZDogXCIjRkY2MDAwXCIgfSwgaG92ZXI6IHsgYm9yZGVyOiBcIiNGRjYwMDBcIiwgYmFja2dyb3VuZDogXCIjRkY2MDAwXCIgfSB9LCAvLyAxMjogcmVhbCBvcmFuZ2VcbiAgICAgIHsgYm9yZGVyOiBcIiM5N0MyRkNcIiwgYmFja2dyb3VuZDogXCIjMkI3Q0U5XCIsIGhpZ2hsaWdodDogeyBib3JkZXI6IFwiI0QyRTVGRlwiLCBiYWNrZ3JvdW5kOiBcIiMyQjdDRTlcIiB9LCBob3ZlcjogeyBib3JkZXI6IFwiI0QyRTVGRlwiLCBiYWNrZ3JvdW5kOiBcIiMyQjdDRTlcIiB9IH0sIC8vIDEzOiBibHVlXG4gICAgICB7IGJvcmRlcjogXCIjMzk5NjA1XCIsIGJhY2tncm91bmQ6IFwiIzI1NUMwM1wiLCBoaWdobGlnaHQ6IHsgYm9yZGVyOiBcIiMzOTk2MDVcIiwgYmFja2dyb3VuZDogXCIjMjU1QzAzXCIgfSwgaG92ZXI6IHsgYm9yZGVyOiBcIiMzOTk2MDVcIiwgYmFja2dyb3VuZDogXCIjMjU1QzAzXCIgfSB9LCAvLyAxNDogZ3JlZW5cbiAgICAgIHsgYm9yZGVyOiBcIiNCNzAwNTRcIiwgYmFja2dyb3VuZDogXCIjRkYwMDdFXCIsIGhpZ2hsaWdodDogeyBib3JkZXI6IFwiI0I3MDA1NFwiLCBiYWNrZ3JvdW5kOiBcIiNGRjAwN0VcIiB9LCBob3ZlcjogeyBib3JkZXI6IFwiI0I3MDA1NFwiLCBiYWNrZ3JvdW5kOiBcIiNGRjAwN0VcIiB9IH0sIC8vIDE1OiBtYWdlbnRhXG4gICAgICB7IGJvcmRlcjogXCIjQUQ4NUU0XCIsIGJhY2tncm91bmQ6IFwiIzdDMjlGMFwiLCBoaWdobGlnaHQ6IHsgYm9yZGVyOiBcIiNEM0JERjBcIiwgYmFja2dyb3VuZDogXCIjN0MyOUYwXCIgfSwgaG92ZXI6IHsgYm9yZGVyOiBcIiNEM0JERjBcIiwgYmFja2dyb3VuZDogXCIjN0MyOUYwXCIgfSB9LCAvLyAxNjogcHVycGxlXG4gICAgICB7IGJvcmRlcjogXCIjNDU1N0ZBXCIsIGJhY2tncm91bmQ6IFwiIzAwMEVBMVwiLCBoaWdobGlnaHQ6IHsgYm9yZGVyOiBcIiM2RTZFRkRcIiwgYmFja2dyb3VuZDogXCIjMDAwRUExXCIgfSwgaG92ZXI6IHsgYm9yZGVyOiBcIiM2RTZFRkRcIiwgYmFja2dyb3VuZDogXCIjMDAwRUExXCIgfSB9LCAvLyAxNzogZGFya2JsdWVcbiAgICAgIHsgYm9yZGVyOiBcIiNGRkMwQ0JcIiwgYmFja2dyb3VuZDogXCIjRkQ1QTc3XCIsIGhpZ2hsaWdodDogeyBib3JkZXI6IFwiI0ZGRDFEOVwiLCBiYWNrZ3JvdW5kOiBcIiNGRDVBNzdcIiB9LCBob3ZlcjogeyBib3JkZXI6IFwiI0ZGRDFEOVwiLCBiYWNrZ3JvdW5kOiBcIiNGRDVBNzdcIiB9IH0sIC8vIDE4OiBwaW5rXG4gICAgICB7IGJvcmRlcjogXCIjQzJGQUJDXCIsIGJhY2tncm91bmQ6IFwiIzc0RDY2QVwiLCBoaWdobGlnaHQ6IHsgYm9yZGVyOiBcIiNFNkZGRTNcIiwgYmFja2dyb3VuZDogXCIjNzRENjZBXCIgfSwgaG92ZXI6IHsgYm9yZGVyOiBcIiNFNkZGRTNcIiwgYmFja2dyb3VuZDogXCIjNzRENjZBXCIgfSB9LCAvLyAxOTogbWludFxuXG4gICAgICB7IGJvcmRlcjogXCIjRUUwMDAwXCIsIGJhY2tncm91bmQ6IFwiIzk5MDAwMFwiLCBoaWdobGlnaHQ6IHsgYm9yZGVyOiBcIiNGRjMzMzNcIiwgYmFja2dyb3VuZDogXCIjQkIwMDAwXCIgfSwgaG92ZXI6IHsgYm9yZGVyOiBcIiNGRjMzMzNcIiwgYmFja2dyb3VuZDogXCIjQkIwMDAwXCIgfSB9IC8vIDIwOmJyaWdodCByZWRcbiAgICAgIF07XG5cbiAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgICAgdXNlRGVmYXVsdEdyb3VwczogdHJ1ZVxuICAgICAgfTtcbiAgICAgIHV0aWwuZXh0ZW5kKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEdyb3VwcywgW3tcbiAgICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHZhciBvcHRpb25GaWVsZHMgPSBbJ3VzZURlZmF1bHRHcm91cHMnXTtcblxuICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZm9yICh2YXIgZ3JvdXBOYW1lIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KGdyb3VwTmFtZSkpIHtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbkZpZWxkcy5pbmRleE9mKGdyb3VwTmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwID0gb3B0aW9uc1tncm91cE5hbWVdO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGdyb3VwTmFtZSwgZ3JvdXApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2xlYXIgYWxsIGdyb3Vwc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2xlYXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICAgICAgdGhpcy5ncm91cHNBcnJheSA9IFtdO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGdldCBncm91cCBvcHRpb25zIG9mIGEgZ3JvdXBuYW1lLiBJZiBncm91cG5hbWUgaXMgbm90IGZvdW5kLCBhIG5ldyBncm91cFxuICAgICAgICogaXMgYWRkZWQuXG4gICAgICAgKiBAcGFyYW0geyp9IGdyb3VwbmFtZSAgICAgICAgQ2FuIGJlIGEgbnVtYmVyLCBzdHJpbmcsIERhdGUsIGV0Yy5cbiAgICAgICAqIEByZXR1cm4ge09iamVjdH0gZ3JvdXAgICAgICBUaGUgY3JlYXRlZCBncm91cCwgY29udGFpbmluZyBhbGwgZ3JvdXAgb3B0aW9uc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KGdyb3VwbmFtZSkge1xuICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3Vwc1tncm91cG5hbWVdO1xuICAgICAgICBpZiAoZ3JvdXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudXNlRGVmYXVsdEdyb3VwcyA9PT0gZmFsc2UgJiYgdGhpcy5ncm91cHNBcnJheS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgbmV3IGdyb3VwXG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmdyb3VwSW5kZXggJSB0aGlzLmdyb3Vwc0FycmF5Lmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBJbmRleCsrO1xuICAgICAgICAgICAgZ3JvdXAgPSB7fTtcbiAgICAgICAgICAgIGdyb3VwLmNvbG9yID0gdGhpcy5ncm91cHNbdGhpcy5ncm91cHNBcnJheVtpbmRleF1dO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBuYW1lXSA9IGdyb3VwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgbmV3IGdyb3VwXG4gICAgICAgICAgICB2YXIgX2luZGV4ID0gdGhpcy5kZWZhdWx0SW5kZXggJSB0aGlzLmRlZmF1bHRHcm91cHMubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0SW5kZXgrKztcbiAgICAgICAgICAgIGdyb3VwID0ge307XG4gICAgICAgICAgICBncm91cC5jb2xvciA9IHRoaXMuZGVmYXVsdEdyb3Vwc1tfaW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5ncm91cHNbZ3JvdXBuYW1lXSA9IGdyb3VwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBncm91cDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBZGQgYSBjdXN0b20gZ3JvdXAgc3R5bGVcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBncm91cE5hbWVcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZSAgICAgICBBbiBvYmplY3QgY29udGFpbmluZyBib3JkZXJDb2xvcixcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3IsIGV0Yy5cbiAgICAgICAqIEByZXR1cm4ge09iamVjdH0gZ3JvdXAgICAgICBUaGUgY3JlYXRlZCBncm91cCBvYmplY3RcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImFkZFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChncm91cE5hbWUsIHN0eWxlKSB7XG4gICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwTmFtZV0gPSBzdHlsZTtcbiAgICAgICAgdGhpcy5ncm91cHNBcnJheS5wdXNoKGdyb3VwTmFtZSk7XG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gR3JvdXBzO1xuICB9KCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gR3JvdXBzO1xuXG4vKioqLyB9LFxuLyogNjQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIHZhciBfTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjUpO1xuXG4gIHZhciBfTm9kZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Ob2RlKTtcblxuICB2YXIgX0xhYmVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nik7XG5cbiAgdmFyIF9MYWJlbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9MYWJlbCk7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbiAgdmFyIERhdGFTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuICB2YXIgRGF0YVZpZXcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxuICB2YXIgTm9kZXNIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vZGVzSGFuZGxlcihib2R5LCBpbWFnZXMsIGdyb3VwcywgbGF5b3V0RW5naW5lKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9kZXNIYW5kbGVyKTtcblxuICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgIHRoaXMuaW1hZ2VzID0gaW1hZ2VzO1xuICAgICAgdGhpcy5ncm91cHMgPSBncm91cHM7XG4gICAgICB0aGlzLmxheW91dEVuZ2luZSA9IGxheW91dEVuZ2luZTtcblxuICAgICAgLy8gY3JlYXRlIHRoZSBub2RlIEFQSSBpbiB0aGUgYm9keSBjb250YWluZXJcbiAgICAgIHRoaXMuYm9keS5mdW5jdGlvbnMuY3JlYXRlTm9kZSA9IHRoaXMuY3JlYXRlLmJpbmQodGhpcyk7XG5cbiAgICAgIHRoaXMubm9kZXNMaXN0ZW5lcnMgPSB7XG4gICAgICAgIGFkZDogZnVuY3Rpb24gYWRkKGV2ZW50LCBwYXJhbXMpIHtcbiAgICAgICAgICBfdGhpcy5hZGQocGFyYW1zLml0ZW1zKTtcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoZXZlbnQsIHBhcmFtcykge1xuICAgICAgICAgIF90aGlzLnVwZGF0ZShwYXJhbXMuaXRlbXMsIHBhcmFtcy5kYXRhKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoZXZlbnQsIHBhcmFtcykge1xuICAgICAgICAgIF90aGlzLnJlbW92ZShwYXJhbXMuaXRlbXMpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICAgIGJvcmRlcldpZHRoOiAxLFxuICAgICAgICBib3JkZXJXaWR0aFNlbGVjdGVkOiAyLFxuICAgICAgICBicm9rZW5JbWFnZTogdW5kZWZpbmVkLFxuICAgICAgICBjb2xvcjoge1xuICAgICAgICAgIGJvcmRlcjogJyMyQjdDRTknLFxuICAgICAgICAgIGJhY2tncm91bmQ6ICcjOTdDMkZDJyxcbiAgICAgICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgICAgIGJvcmRlcjogJyMyQjdDRTknLFxuICAgICAgICAgICAgYmFja2dyb3VuZDogJyNEMkU1RkYnXG4gICAgICAgICAgfSxcbiAgICAgICAgICBob3Zlcjoge1xuICAgICAgICAgICAgYm9yZGVyOiAnIzJCN0NFOScsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiAnI0QyRTVGRidcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZpeGVkOiB7XG4gICAgICAgICAgeDogZmFsc2UsXG4gICAgICAgICAgeTogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgZm9udDoge1xuICAgICAgICAgIGNvbG9yOiAnIzM0MzQzNCcsXG4gICAgICAgICAgc2l6ZTogMTQsIC8vIHB4XG4gICAgICAgICAgZmFjZTogJ2FyaWFsJyxcbiAgICAgICAgICBiYWNrZ3JvdW5kOiAnbm9uZScsXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IDAsIC8vIHB4XG4gICAgICAgICAgc3Ryb2tlQ29sb3I6ICcjZmZmZmZmJyxcbiAgICAgICAgICBhbGlnbjogJ2NlbnRlcidcbiAgICAgICAgfSxcbiAgICAgICAgZ3JvdXA6IHVuZGVmaW5lZCxcbiAgICAgICAgaGlkZGVuOiBmYWxzZSxcbiAgICAgICAgaWNvbjoge1xuICAgICAgICAgIGZhY2U6ICdGb250QXdlc29tZScsIC8vJ0ZvbnRBd2Vzb21lJyxcbiAgICAgICAgICBjb2RlOiB1bmRlZmluZWQsIC8vJ1xcdWYwMDcnLFxuICAgICAgICAgIHNpemU6IDUwLCAvLzUwLFxuICAgICAgICAgIGNvbG9yOiAnIzJCN0NFOScgLy8nI2FhMDBmZidcbiAgICAgICAgfSxcbiAgICAgICAgaW1hZ2U6IHVuZGVmaW5lZCwgLy8gLS0+IFVSTFxuICAgICAgICBsYWJlbDogdW5kZWZpbmVkLFxuICAgICAgICBsYWJlbEhpZ2hsaWdodEJvbGQ6IHRydWUsXG4gICAgICAgIGxldmVsOiB1bmRlZmluZWQsXG4gICAgICAgIG1hc3M6IDEsXG4gICAgICAgIHBoeXNpY3M6IHRydWUsXG4gICAgICAgIHNjYWxpbmc6IHtcbiAgICAgICAgICBtaW46IDEwLFxuICAgICAgICAgIG1heDogMzAsXG4gICAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgbWluOiAxNCxcbiAgICAgICAgICAgIG1heDogMzAsXG4gICAgICAgICAgICBtYXhWaXNpYmxlOiAzMCxcbiAgICAgICAgICAgIGRyYXdUaHJlc2hvbGQ6IDVcbiAgICAgICAgICB9LFxuICAgICAgICAgIGN1c3RvbVNjYWxpbmdGdW5jdGlvbjogZnVuY3Rpb24gY3VzdG9tU2NhbGluZ0Z1bmN0aW9uKG1pbiwgbWF4LCB0b3RhbCwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChtYXggPT09IG1pbikge1xuICAgICAgICAgICAgICByZXR1cm4gMC41O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHNjYWxlID0gMSAvIChtYXggLSBtaW4pO1xuICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgKHZhbHVlIC0gbWluKSAqIHNjYWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNoYWRvdzoge1xuICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgIGNvbG9yOiAncmdiYSgwLDAsMCwwLjUpJyxcbiAgICAgICAgICBzaXplOiAxMCxcbiAgICAgICAgICB4OiA1LFxuICAgICAgICAgIHk6IDVcbiAgICAgICAgfSxcbiAgICAgICAgc2hhcGU6ICdlbGxpcHNlJyxcbiAgICAgICAgc2hhcGVQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgYm9yZGVyRGFzaGVzOiBmYWxzZSwgLy8gb25seSBmb3IgYm9yZGVyc1xuICAgICAgICAgIGJvcmRlclJhZGl1czogNiwgLy8gb25seSBmb3IgYm94IHNoYXBlXG4gICAgICAgICAgaW50ZXJwb2xhdGlvbjogdHJ1ZSwgLy8gb25seSBmb3IgaW1hZ2UgYW5kIGNpcmN1bGFySW1hZ2Ugc2hhcGVzXG4gICAgICAgICAgdXNlSW1hZ2VTaXplOiBmYWxzZSwgLy8gb25seSBmb3IgaW1hZ2UgYW5kIGNpcmN1bGFySW1hZ2Ugc2hhcGVzXG4gICAgICAgICAgdXNlQm9yZGVyV2l0aEltYWdlOiBmYWxzZSAvLyBvbmx5IGZvciBpbWFnZSBzaGFwZVxuICAgICAgICB9LFxuICAgICAgICBzaXplOiAyNSxcbiAgICAgICAgdGl0bGU6IHVuZGVmaW5lZCxcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgeDogdW5kZWZpbmVkLFxuICAgICAgICB5OiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgICB1dGlsLmV4dGVuZCh0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gICAgICB0aGlzLmJpbmRFdmVudExpc3RlbmVycygpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhOb2Rlc0hhbmRsZXIsIFt7XG4gICAgICBrZXk6ICdiaW5kRXZlbnRMaXN0ZW5lcnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgLy8gcmVmcmVzaCB0aGUgbm9kZXMuIFVzZWQgd2hlbiByZXZlcnRpbmcgZnJvbSBoaWVyYXJjaGljYWwgbGF5b3V0XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdyZWZyZXNoTm9kZXMnLCB0aGlzLnJlZnJlc2guYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdyZWZyZXNoJywgdGhpcy5yZWZyZXNoLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB1dGlsLmZvckVhY2goX3RoaXMyLm5vZGVzTGlzdGVuZXJzLCBmdW5jdGlvbiAoY2FsbGJhY2ssIGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMyLmJvZHkuZGF0YS5ub2RlcykgX3RoaXMyLmJvZHkuZGF0YS5ub2Rlcy5vZmYoZXZlbnQsIGNhbGxiYWNrKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkZWxldGUgX3RoaXMyLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZU5vZGU7XG4gICAgICAgICAgZGVsZXRlIF90aGlzMi5ub2Rlc0xpc3RlbmVycy5hZGQ7XG4gICAgICAgICAgZGVsZXRlIF90aGlzMi5ub2Rlc0xpc3RlbmVycy51cGRhdGU7XG4gICAgICAgICAgZGVsZXRlIF90aGlzMi5ub2Rlc0xpc3RlbmVycy5yZW1vdmU7XG4gICAgICAgICAgZGVsZXRlIF90aGlzMi5ub2Rlc0xpc3RlbmVycztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnc2V0T3B0aW9ucycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBfTm9kZTIuZGVmYXVsdC5wYXJzZU9wdGlvbnModGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgc2hhcGUgaW4gYWxsIG5vZGVzXG4gICAgICAgICAgaWYgKG9wdGlvbnMuc2hhcGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIHRoaXMuYm9keS5ub2Rlcykge1xuICAgICAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzLmhhc093blByb3BlcnR5KG5vZGVJZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXS51cGRhdGVTaGFwZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdXBkYXRlIHRoZSBmb250IGluIGFsbCBub2Rlc1xuICAgICAgICAgIGlmIChvcHRpb25zLmZvbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgX0xhYmVsMi5kZWZhdWx0LnBhcnNlT3B0aW9ucyh0aGlzLm9wdGlvbnMuZm9udCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBmb3IgKHZhciBfbm9kZUlkIGluIHRoaXMuYm9keS5ub2Rlcykge1xuICAgICAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzLmhhc093blByb3BlcnR5KF9ub2RlSWQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW19ub2RlSWRdLnVwZGF0ZUxhYmVsTW9kdWxlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW19ub2RlSWRdLl9yZXNldCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdXBkYXRlIHRoZSBzaGFwZSBzaXplIGluIGFsbCBub2Rlc1xuICAgICAgICAgIGlmIChvcHRpb25zLnNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgX25vZGVJZDIgaW4gdGhpcy5ib2R5Lm5vZGVzKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXMuaGFzT3duUHJvcGVydHkoX25vZGVJZDIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW19ub2RlSWQyXS5fcmVzZXQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgc3RhdGUgb2YgdGhlIGxldGlhYmxlcyBpZiBuZWVkZWRcbiAgICAgICAgICBpZiAob3B0aW9ucy5oaWRkZW4gIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnBoeXNpY3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2RhdGFDaGFuZ2VkJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0IGEgZGF0YSBzZXQgd2l0aCBub2RlcyBmb3IgdGhlIG5ldHdvcmtcbiAgICAgICAqIEBwYXJhbSB7QXJyYXkgfCBEYXRhU2V0IHwgRGF0YVZpZXd9IG5vZGVzICAgICAgICAgVGhlIGRhdGEgY29udGFpbmluZyB0aGUgbm9kZXMuXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzZXREYXRhJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREYXRhKG5vZGVzKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBkb05vdEVtaXQgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICB2YXIgb2xkTm9kZXNEYXRhID0gdGhpcy5ib2R5LmRhdGEubm9kZXM7XG5cbiAgICAgICAgaWYgKG5vZGVzIGluc3RhbmNlb2YgRGF0YVNldCB8fCBub2RlcyBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmRhdGEubm9kZXMgPSBub2RlcztcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG5vZGVzKSkge1xuICAgICAgICAgIHRoaXMuYm9keS5kYXRhLm5vZGVzID0gbmV3IERhdGFTZXQoKTtcbiAgICAgICAgICB0aGlzLmJvZHkuZGF0YS5ub2Rlcy5hZGQobm9kZXMpO1xuICAgICAgICB9IGVsc2UgaWYgKCFub2Rlcykge1xuICAgICAgICAgIHRoaXMuYm9keS5kYXRhLm5vZGVzID0gbmV3IERhdGFTZXQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheSBvciBEYXRhU2V0IGV4cGVjdGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2xkTm9kZXNEYXRhKSB7XG4gICAgICAgICAgLy8gdW5zdWJzY3JpYmUgZnJvbSBvbGQgZGF0YXNldFxuICAgICAgICAgIHV0aWwuZm9yRWFjaCh0aGlzLm5vZGVzTGlzdGVuZXJzLCBmdW5jdGlvbiAoY2FsbGJhY2ssIGV2ZW50KSB7XG4gICAgICAgICAgICBvbGROb2Rlc0RhdGEub2ZmKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgZHJhd24gbm9kZXNcbiAgICAgICAgdGhpcy5ib2R5Lm5vZGVzID0ge307XG5cbiAgICAgICAgaWYgKHRoaXMuYm9keS5kYXRhLm5vZGVzKSB7XG4gICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHN1YnNjcmliZSB0byBuZXcgZGF0YXNldFxuICAgICAgICAgICAgdmFyIG1lID0gX3RoaXMzO1xuICAgICAgICAgICAgdXRpbC5mb3JFYWNoKF90aGlzMy5ub2Rlc0xpc3RlbmVycywgZnVuY3Rpb24gKGNhbGxiYWNrLCBldmVudCkge1xuICAgICAgICAgICAgICBtZS5ib2R5LmRhdGEubm9kZXMub24oZXZlbnQsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBkcmF3IGFsbCBuZXcgbm9kZXNcbiAgICAgICAgICAgIHZhciBpZHMgPSBfdGhpczMuYm9keS5kYXRhLm5vZGVzLmdldElkcygpO1xuICAgICAgICAgICAgX3RoaXMzLmFkZChpZHMsIHRydWUpO1xuICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZG9Ob3RFbWl0ID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBZGQgbm9kZXNcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyW10gfCBTdHJpbmdbXX0gaWRzXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdhZGQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChpZHMpIHtcbiAgICAgICAgdmFyIGRvTm90RW1pdCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgIHZhciBpZCA9IHZvaWQgMDtcbiAgICAgICAgdmFyIG5ld05vZGVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWQgPSBpZHNbaV07XG4gICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB0aGlzLmJvZHkuZGF0YS5ub2Rlcy5nZXQoaWQpO1xuICAgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGUocHJvcGVydGllcyk7XG4gICAgICAgICAgbmV3Tm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICB0aGlzLmJvZHkubm9kZXNbaWRdID0gbm9kZTsgLy8gbm90ZTogdGhpcyBtYXkgcmVwbGFjZSBhbiBleGlzdGluZyBub2RlXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxheW91dEVuZ2luZS5wb3NpdGlvbkluaXRpYWxseShuZXdOb2Rlcyk7XG5cbiAgICAgICAgaWYgKGRvTm90RW1pdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVXBkYXRlIGV4aXN0aW5nIG5vZGVzLCBvciBjcmVhdGUgdGhlbSB3aGVuIG5vdCB5ZXQgZXhpc3RpbmdcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyW10gfCBTdHJpbmdbXX0gaWRzXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd1cGRhdGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShpZHMsIGNoYW5nZWREYXRhKSB7XG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgICAgdmFyIGRhdGFDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGlkID0gaWRzW2ldO1xuICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbaWRdO1xuICAgICAgICAgIHZhciBkYXRhID0gY2hhbmdlZERhdGFbaV07XG4gICAgICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gdXBkYXRlIG5vZGVcbiAgICAgICAgICAgIGRhdGFDaGFuZ2VkID0gbm9kZS5zZXRPcHRpb25zKGRhdGEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAvLyBjcmVhdGUgbm9kZVxuICAgICAgICAgICAgbm9kZSA9IHRoaXMuY3JlYXRlKGRhdGEpO1xuICAgICAgICAgICAgbm9kZXNbaWRdID0gbm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFDaGFuZ2VkID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFVcGRhdGVkXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlIGV4aXN0aW5nIG5vZGVzLiBJZiBub2RlcyBkbyBub3QgZXhpc3QsIHRoZSBtZXRob2Qgd2lsbCBqdXN0IGlnbm9yZSBpdC5cbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyW10gfCBTdHJpbmdbXX0gaWRzXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyZW1vdmUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZShpZHMpIHtcbiAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGlkID0gaWRzW2ldO1xuICAgICAgICAgIGRlbGV0ZSBub2Rlc1tpZF07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGNyZWF0ZSBhIG5vZGVcbiAgICAgICAqIEBwYXJhbSBwcm9wZXJ0aWVzXG4gICAgICAgKiBAcGFyYW0gY29uc3RydWN0b3JDbGFzc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdjcmVhdGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgIHZhciBjb25zdHJ1Y3RvckNsYXNzID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gX05vZGUyLmRlZmF1bHQgOiBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgcmV0dXJuIG5ldyBjb25zdHJ1Y3RvckNsYXNzKHByb3BlcnRpZXMsIHRoaXMuYm9keSwgdGhpcy5pbWFnZXMsIHRoaXMuZ3JvdXBzLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3JlZnJlc2gnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlZnJlc2goKSB7XG4gICAgICAgIHZhciBjbGVhclBvc2l0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogYXJndW1lbnRzWzBdO1xuXG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIG5vZGVzKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKG5vZGVzLmhhc093blByb3BlcnR5KG5vZGVJZCkpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2Rlc1tub2RlSWRdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuYm9keS5kYXRhLm5vZGVzLl9kYXRhW25vZGVJZF07XG4gICAgICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCAmJiBkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChjbGVhclBvc2l0aW9ucyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICBub2RlLnNldE9wdGlvbnMoeyB4OiBudWxsLCB5OiBudWxsIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5zZXRPcHRpb25zKHsgZml4ZWQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgbm9kZS5zZXRPcHRpb25zKGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdGhlIHBvc2l0aW9ucyBvZiB0aGUgbm9kZXMuXG4gICAgICAgKiBAcGFyYW0gaWRzICAtLT4gb3B0aW9uYWwsIGNhbiBiZSBhcnJheSBvZiBub2RlSWRzLCBjYW4gYmUgc3RyaW5nXG4gICAgICAgKiBAcmV0dXJucyB7e319XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldFBvc2l0aW9ucycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9zaXRpb25zKGlkcykge1xuICAgICAgICB2YXIgZGF0YUFycmF5ID0ge307XG4gICAgICAgIGlmIChpZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGlkcykgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbaWRzW2ldXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbaWRzW2ldXTtcbiAgICAgICAgICAgICAgICBkYXRhQXJyYXlbaWRzW2ldXSA9IHsgeDogTWF0aC5yb3VuZChub2RlLngpLCB5OiBNYXRoLnJvdW5kKG5vZGUueSkgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW2lkc10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB2YXIgX25vZGUgPSB0aGlzLmJvZHkubm9kZXNbaWRzXTtcbiAgICAgICAgICAgICAgZGF0YUFycmF5W2lkc10gPSB7IHg6IE1hdGgucm91bmQoX25vZGUueCksIHk6IE1hdGgucm91bmQoX25vZGUueSkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBfbm9kZTIgPSB0aGlzLmJvZHkubm9kZXNbdGhpcy5ib2R5Lm5vZGVJbmRpY2VzW19pXV07XG4gICAgICAgICAgICBkYXRhQXJyYXlbdGhpcy5ib2R5Lm5vZGVJbmRpY2VzW19pXV0gPSB7IHg6IE1hdGgucm91bmQoX25vZGUyLngpLCB5OiBNYXRoLnJvdW5kKF9ub2RlMi55KSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YUFycmF5O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIExvYWQgdGhlIFhZIHBvc2l0aW9ucyBvZiB0aGUgbm9kZXMgaW50byB0aGUgZGF0YXNldC5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc3RvcmVQb3NpdGlvbnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3JlUG9zaXRpb25zKCkge1xuICAgICAgICAvLyB0b2RvOiBhZGQgc3VwcG9ydCBmb3IgY2x1c3RlcnMgYW5kIGhpZXJhcmNoaWNhbC5cbiAgICAgICAgdmFyIGRhdGFBcnJheSA9IFtdO1xuICAgICAgICB2YXIgZGF0YXNldCA9IHRoaXMuYm9keS5kYXRhLm5vZGVzLmdldERhdGFTZXQoKTtcblxuICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gZGF0YXNldC5fZGF0YSkge1xuICAgICAgICAgIGlmIChkYXRhc2V0Ll9kYXRhLmhhc093blByb3BlcnR5KG5vZGVJZCkpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICAgICAgICBpZiAoZGF0YXNldC5fZGF0YVtub2RlSWRdLnggIT0gTWF0aC5yb3VuZChub2RlLngpIHx8IGRhdGFzZXQuX2RhdGFbbm9kZUlkXS55ICE9IE1hdGgucm91bmQobm9kZS55KSkge1xuICAgICAgICAgICAgICBkYXRhQXJyYXkucHVzaCh7IGlkOiBub2RlLmlkLCB4OiBNYXRoLnJvdW5kKG5vZGUueCksIHk6IE1hdGgucm91bmQobm9kZS55KSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGF0YXNldC51cGRhdGUoZGF0YUFycmF5KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBnZXQgdGhlIGJvdW5kaW5nIGJveCBvZiBhIG5vZGUuXG4gICAgICAgKiBAcGFyYW0gbm9kZUlkXG4gICAgICAgKiBAcmV0dXJucyB7anwqfVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXRCb3VuZGluZ0JveCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Qm91bmRpbmdCb3gobm9kZUlkKSB7XG4gICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdLnNoYXBlLmJvdW5kaW5nQm94O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0IHRoZSBJZHMgb2Ygbm9kZXMgY29ubmVjdGVkIHRvIHRoaXMgbm9kZS5cbiAgICAgICAqIEBwYXJhbSBub2RlSWRcbiAgICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0Q29ubmVjdGVkTm9kZXMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbm5lY3RlZE5vZGVzKG5vZGVJZCkge1xuICAgICAgICB2YXIgbm9kZUxpc3QgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgICAgIHZhciBub2RlT2JqID0ge307IC8vIHVzZWQgdG8gcXVpY2tseSBjaGVjayBpZiBub2RlIGFscmVhZHkgZXhpc3RzXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZWRnZSA9IG5vZGUuZWRnZXNbaV07XG4gICAgICAgICAgICBpZiAoZWRnZS50b0lkID09IG5vZGUuaWQpIHtcbiAgICAgICAgICAgICAgLy8gdGhlc2UgYXJlIGRvdWJsZSBlcXVhbHMgc2luY2UgaWRzIGNhbiBiZSBudW1lcmljIG9yIHN0cmluZ1xuICAgICAgICAgICAgICBpZiAobm9kZU9ialtlZGdlLmZyb21JZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG5vZGVMaXN0LnB1c2goZWRnZS5mcm9tSWQpO1xuICAgICAgICAgICAgICAgIG5vZGVPYmpbZWRnZS5mcm9tSWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChlZGdlLmZyb21JZCA9PSBub2RlLmlkKSB7XG4gICAgICAgICAgICAgIC8vIHRoZXNlIGFyZSBkb3VibGUgZXF1YWxzIHNpbmNlIGlkcyBjYW4gYmUgbnVtZXJpYyBvciBzdHJpbmdcbiAgICAgICAgICAgICAgaWYgKG5vZGVPYmpbZWRnZS50b0lkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbm9kZUxpc3QucHVzaChlZGdlLnRvSWQpO1xuICAgICAgICAgICAgICAgIG5vZGVPYmpbZWRnZS50b0lkXSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGVMaXN0O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEdldCB0aGUgaWRzIG9mIHRoZSBlZGdlcyBjb25uZWN0ZWQgdG8gdGhpcyBub2RlLlxuICAgICAgICogQHBhcmFtIG5vZGVJZFxuICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldENvbm5lY3RlZEVkZ2VzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb25uZWN0ZWRFZGdlcyhub2RlSWQpIHtcbiAgICAgICAgdmFyIGVkZ2VMaXN0ID0gW107XG4gICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGVkZ2VMaXN0LnB1c2gobm9kZS5lZGdlc1tpXS5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm9kZUlkIHByb3ZpZGVkIGZvciBnZXRDb25uZWN0ZWRFZGdlcyBkb2VzIG5vdCBleGlzdC4gUHJvdmlkZWQ6IFwiLCBub2RlSWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlZGdlTGlzdDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBNb3ZlIGEgbm9kZS5cbiAgICAgICAqIEBwYXJhbSBTdHJpbmcgbm9kZUlkXG4gICAgICAgKiBAcGFyYW0gTnVtYmVyIHhcbiAgICAgICAqIEBwYXJhbSBOdW1iZXIgeVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdtb3ZlTm9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZU5vZGUobm9kZUlkLCB4LCB5KSB7XG4gICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0ueCA9IE51bWJlcih4KTtcbiAgICAgICAgICB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXS55ID0gTnVtYmVyKHkpO1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXM0LmJvZHkuZW1pdHRlci5lbWl0KFwic3RhcnRTaW11bGF0aW9uXCIpO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm9kZSBpZCBzdXBwbGllZCB0byBtb3ZlTm9kZSBkb2VzIG5vdCBleGlzdC4gUHJvdmlkZWQ6IFwiLCBub2RlSWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIE5vZGVzSGFuZGxlcjtcbiAgfSgpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IE5vZGVzSGFuZGxlcjtcblxuLyoqKi8gfSxcbi8qIDY1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX0xhYmVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nik7XG5cbiAgdmFyIF9MYWJlbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9MYWJlbCk7XG5cbiAgdmFyIF9Cb3ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3KTtcblxuICB2YXIgX0JveDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Cb3gpO1xuXG4gIHZhciBfQ2lyY2xlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OSk7XG5cbiAgdmFyIF9DaXJjbGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2lyY2xlKTtcblxuICB2YXIgX0NpcmN1bGFySW1hZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxKTtcblxuICB2YXIgX0NpcmN1bGFySW1hZ2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2lyY3VsYXJJbWFnZSk7XG5cbiAgdmFyIF9EYXRhYmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oNzIpO1xuXG4gIHZhciBfRGF0YWJhc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRGF0YWJhc2UpO1xuXG4gIHZhciBfRGlhbW9uZCA9IF9fd2VicGFja19yZXF1aXJlX18oNzMpO1xuXG4gIHZhciBfRGlhbW9uZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EaWFtb25kKTtcblxuICB2YXIgX0RvdCA9IF9fd2VicGFja19yZXF1aXJlX18oNzUpO1xuXG4gIHZhciBfRG90MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0RvdCk7XG5cbiAgdmFyIF9FbGxpcHNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Nik7XG5cbiAgdmFyIF9FbGxpcHNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0VsbGlwc2UpO1xuXG4gIHZhciBfSWNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNzcpO1xuXG4gIHZhciBfSWNvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9JY29uKTtcblxuICB2YXIgX0ltYWdlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OCk7XG5cbiAgdmFyIF9JbWFnZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9JbWFnZSk7XG5cbiAgdmFyIF9TcXVhcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc5KTtcblxuICB2YXIgX1NxdWFyZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TcXVhcmUpO1xuXG4gIHZhciBfU3RhciA9IF9fd2VicGFja19yZXF1aXJlX18oODApO1xuXG4gIHZhciBfU3RhcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TdGFyKTtcblxuICB2YXIgX1RleHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgxKTtcblxuICB2YXIgX1RleHQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVGV4dCk7XG5cbiAgdmFyIF9UcmlhbmdsZSA9IF9fd2VicGFja19yZXF1aXJlX18oODIpO1xuXG4gIHZhciBfVHJpYW5nbGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVHJpYW5nbGUpO1xuXG4gIHZhciBfVHJpYW5nbGVEb3duID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4Myk7XG5cbiAgdmFyIF9UcmlhbmdsZURvd24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVHJpYW5nbGVEb3duKTtcblxuICB2YXIgX1ZhbGlkYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xuXG4gIHZhciBfVmFsaWRhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1ZhbGlkYXRvcik7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuICAvKipcbiAgICogQGNsYXNzIE5vZGVcbiAgICogQSBub2RlLiBBIG5vZGUgY2FuIGJlIGNvbm5lY3RlZCB0byBvdGhlciBub2RlcyB2aWEgb25lIG9yIG11bHRpcGxlIGVkZ2VzLlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBBbiBvYmplY3QgY29udGFpbmluZyBvcHRpb25zIGZvciB0aGUgbm9kZS4gQWxsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgYXJlIG9wdGlvbmFsLCBleGNlcHQgZm9yIHRoZSBpZC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bnVtYmVyfSBpZCAgICAgSWQgb2YgdGhlIG5vZGUuIFJlcXVpcmVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3N0cmluZ30gbGFiZWwgIFRleHQgbGFiZWwgZm9yIHRoZSBub2RlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge251bWJlcn0geCAgICAgIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIG5vZGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bnVtYmVyfSB5ICAgICAgVmVydGljYWwgcG9zaXRpb24gb2YgdGhlIG5vZGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nfSBzaGFwZSAgTm9kZSBzaGFwZSwgYXZhaWxhYmxlOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImRhdGFiYXNlXCIsIFwiY2lyY2xlXCIsIFwiZWxsaXBzZVwiLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJveFwiLCBcImltYWdlXCIsIFwidGV4dFwiLCBcImRvdFwiLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInN0YXJcIiwgXCJ0cmlhbmdsZVwiLCBcInRyaWFuZ2xlRG93blwiLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNxdWFyZVwiLCBcImljb25cIlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmd9IGltYWdlICBBbiBpbWFnZSB1cmxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nfSB0aXRsZSAgQW4gdGl0bGUgdGV4dCwgY2FuIGJlIEhUTUxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7YW55dHlwZX0gZ3JvdXAgQSBncm91cCBuYW1lIG9yIG51bWJlclxuICAgKiBAcGFyYW0ge05ldHdvcmsuSW1hZ2VzfSBpbWFnZWxpc3QgICAgQSBsaXN0IHdpdGggaW1hZ2VzLiBPbmx5IG5lZWRlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlbiB0aGUgbm9kZSBoYXMgYW4gaW1hZ2VcbiAgICogQHBhcmFtIHtOZXR3b3JrLkdyb3Vwc30gZ3JvdXBsaXN0ICAgIEEgbGlzdCB3aXRoIGdyb3Vwcy4gTmVlZGVkIGZvclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0cmlldmluZyBncm91cCBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgICAgIGNvbnN0YW50cyAgICBBbiBvYmplY3Qgd2l0aCBkZWZhdWx0IHZhbHVlcyBmb3JcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4YW1wbGUgZm9yIHRoZSBjb2xvclxuICAgKlxuICAgKi9cblxuICB2YXIgTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb2RlKG9wdGlvbnMsIGJvZHksIGltYWdlbGlzdCwgZ3JvdXBsaXN0LCBnbG9iYWxPcHRpb25zKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9kZSk7XG5cbiAgICAgIHRoaXMub3B0aW9ucyA9IHV0aWwuYnJpZGdlT2JqZWN0KGdsb2JhbE9wdGlvbnMpO1xuICAgICAgdGhpcy5nbG9iYWxPcHRpb25zID0gZ2xvYmFsT3B0aW9ucztcbiAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG5cbiAgICAgIHRoaXMuZWRnZXMgPSBbXTsgLy8gYWxsIGVkZ2VzIGNvbm5lY3RlZCB0byB0aGlzIG5vZGVcblxuICAgICAgLy8gc2V0IGRlZmF1bHRzIGZvciB0aGUgb3B0aW9uc1xuICAgICAgdGhpcy5pZCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuaW1hZ2VsaXN0ID0gaW1hZ2VsaXN0O1xuICAgICAgdGhpcy5ncm91cGxpc3QgPSBncm91cGxpc3Q7XG5cbiAgICAgIC8vIHN0YXRlIG9wdGlvbnNcbiAgICAgIHRoaXMueCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMueSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuYmFzZVNpemUgPSB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgIHRoaXMuYmFzZUZvbnRTaXplID0gdGhpcy5vcHRpb25zLmZvbnQuc2l6ZTtcbiAgICAgIHRoaXMucHJlZGVmaW5lZFBvc2l0aW9uID0gZmFsc2U7IC8vIHVzZWQgdG8gY2hlY2sgaWYgaW5pdGlhbCBmaXQgc2hvdWxkIGp1c3QgdGFrZSB0aGUgcmFuZ2Ugb3IgYXBwcm94aW1hdGVcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuaG92ZXIgPSBmYWxzZTtcblxuICAgICAgdGhpcy5sYWJlbE1vZHVsZSA9IG5ldyBfTGFiZWwyLmRlZmF1bHQodGhpcy5ib2R5LCB0aGlzLm9wdGlvbnMsIGZhbHNlIC8qIE5vdCBlZGdlIGxhYmVsICovKTtcbiAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBdHRhY2ggYSBlZGdlIHRvIHRoZSBub2RlXG4gICAgICogQHBhcmFtIHtFZGdlfSBlZGdlXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhOb2RlLCBbe1xuICAgICAga2V5OiAnYXR0YWNoRWRnZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYXR0YWNoRWRnZShlZGdlKSB7XG4gICAgICAgIGlmICh0aGlzLmVkZ2VzLmluZGV4T2YoZWRnZSkgPT09IC0xKSB7XG4gICAgICAgICAgdGhpcy5lZGdlcy5wdXNoKGVkZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRGV0YWNoIGEgZWRnZSBmcm9tIHRoZSBub2RlXG4gICAgICAgKiBAcGFyYW0ge0VkZ2V9IGVkZ2VcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZGV0YWNoRWRnZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGV0YWNoRWRnZShlZGdlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZWRnZXMuaW5kZXhPZihlZGdlKTtcbiAgICAgICAgaWYgKGluZGV4ICE9IC0xKSB7XG4gICAgICAgICAgdGhpcy5lZGdlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0IG9yIG92ZXJ3cml0ZSBvcHRpb25zIGZvciB0aGUgbm9kZVxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgYW4gb2JqZWN0IHdpdGggb3B0aW9uc1xuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbnN0YW50cyAgYW5kIG9iamVjdCB3aXRoIGRlZmF1bHQsIGdsb2JhbCBvcHRpb25zXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NldE9wdGlvbnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB2YXIgY3VycmVudFNoYXBlID0gdGhpcy5vcHRpb25zLnNoYXBlO1xuICAgICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gYmFzaWMgb3B0aW9uc1xuICAgICAgICBpZiAob3B0aW9ucy5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5pZCA9IG9wdGlvbnMuaWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgXCJOb2RlIG11c3QgaGF2ZSBhbiBpZFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHRoZXNlIG9wdGlvbnMgbG9jYWxseVxuICAgICAgICAvLyBjbGVhciB4IGFuZCB5IHBvc2l0aW9uc1xuICAgICAgICBpZiAob3B0aW9ucy54ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy54ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnggPSB1bmRlZmluZWQ7dGhpcy5wcmVkZWZpbmVkUG9zaXRpb24gPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy54ID0gcGFyc2VJbnQob3B0aW9ucy54KTt0aGlzLnByZWRlZmluZWRQb3NpdGlvbiA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChvcHRpb25zLnkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMueSA9IHVuZGVmaW5lZDt0aGlzLnByZWRlZmluZWRQb3NpdGlvbiA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnkgPSBwYXJzZUludChvcHRpb25zLnkpO3RoaXMucHJlZGVmaW5lZFBvc2l0aW9uID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5iYXNlU2l6ZSA9IG9wdGlvbnMuc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb3B0aW9ucy52YWx1ZSA9IHBhcnNlRmxvYXQob3B0aW9ucy52YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb3B5IGdyb3VwIG9wdGlvbnNcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmdyb3VwID09PSAnbnVtYmVyJyB8fCB0eXBlb2Ygb3B0aW9ucy5ncm91cCA9PT0gJ3N0cmluZycgJiYgb3B0aW9ucy5ncm91cCAhPSAnJykge1xuICAgICAgICAgIHZhciBncm91cE9iaiA9IHRoaXMuZ3JvdXBsaXN0LmdldChvcHRpb25zLmdyb3VwKTtcbiAgICAgICAgICB1dGlsLmRlZXBFeHRlbmQodGhpcy5vcHRpb25zLCBncm91cE9iaik7XG4gICAgICAgICAgLy8gdGhlIGNvbG9yIG9iamVjdCBuZWVkcyB0byBiZSBjb21wbGV0ZWx5IGRlZmluZWQuIFNpbmNlIGdyb3VwcyBjYW4gcGFydGlhbGx5IG92ZXJ3cml0ZSB0aGUgY29sb3JzLCB3ZSBwYXJzZSBpdCBhZ2FpbiwganVzdCBpbiBjYXNlLlxuICAgICAgICAgIHRoaXMub3B0aW9ucy5jb2xvciA9IHV0aWwucGFyc2VDb2xvcih0aGlzLm9wdGlvbnMuY29sb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhpcyB0cmFuc2Zvcm1zIGFsbCBzaG9ydGhhbmRzIGludG8gZnVsbHkgZGVmaW5lZCBvcHRpb25zXG4gICAgICAgIE5vZGUucGFyc2VPcHRpb25zKHRoaXMub3B0aW9ucywgb3B0aW9ucywgdHJ1ZSwgdGhpcy5nbG9iYWxPcHRpb25zKTtcblxuICAgICAgICAvLyBsb2FkIHRoZSBpbWFnZXNcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbWFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaW1hZ2VsaXN0KSB7XG4gICAgICAgICAgICB0aGlzLmltYWdlT2JqID0gdGhpcy5pbWFnZWxpc3QubG9hZCh0aGlzLm9wdGlvbnMuaW1hZ2UsIHRoaXMub3B0aW9ucy5icm9rZW5JbWFnZSwgdGhpcy5pZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IFwiTm8gaW1hZ2VsaXN0IHByb3ZpZGVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGVMYWJlbE1vZHVsZSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVNoYXBlKGN1cnJlbnRTaGFwZSk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuaGlkZGVuICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5waHlzaWNzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBwcm9jZXNzIGFsbCBwb3NzaWJsZSBzaG9ydGhhbmRzIGluIHRoZSBuZXcgb3B0aW9ucyBhbmQgbWFrZXMgc3VyZSB0aGF0IHRoZSBwYXJlbnRPcHRpb25zIGFyZSBmdWxseSBkZWZpbmVkLlxuICAgICAgICogU3RhdGljIHNvIGl0IGNhbiBhbHNvIGJlIHVzZWQgYnkgdGhlIGhhbmRsZXIuXG4gICAgICAgKiBAcGFyYW0gcGFyZW50T3B0aW9uc1xuICAgICAgICogQHBhcmFtIG5ld09wdGlvbnNcbiAgICAgICAqIEBwYXJhbSBhbGxvd0RlbGV0aW9uXG4gICAgICAgKiBAcGFyYW0gZ2xvYmFsT3B0aW9uc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd1cGRhdGVMYWJlbE1vZHVsZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlTGFiZWxNb2R1bGUoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGFiZWwgPT09IHVuZGVmaW5lZCB8fCB0aGlzLm9wdGlvbnMubGFiZWwgPT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMubGFiZWwgPSAnJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhYmVsTW9kdWxlLnNldE9wdGlvbnModGhpcy5vcHRpb25zLCB0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMubGFiZWxNb2R1bGUuYmFzZVNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuYmFzZUZvbnRTaXplID0gdGhpcy5sYWJlbE1vZHVsZS5iYXNlU2l6ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3VwZGF0ZVNoYXBlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVTaGFwZShjdXJyZW50U2hhcGUpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRTaGFwZSA9PT0gdGhpcy5vcHRpb25zLnNoYXBlICYmIHRoaXMuc2hhcGUpIHtcbiAgICAgICAgICB0aGlzLnNoYXBlLnNldE9wdGlvbnModGhpcy5vcHRpb25zLCB0aGlzLmltYWdlT2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBjaG9vc2UgZHJhdyBtZXRob2QgZGVwZW5kaW5nIG9uIHRoZSBzaGFwZVxuICAgICAgICAgIHN3aXRjaCAodGhpcy5vcHRpb25zLnNoYXBlKSB7XG4gICAgICAgICAgICBjYXNlICdib3gnOlxuICAgICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IF9Cb3gyLmRlZmF1bHQodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NpcmNsZSc6XG4gICAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgX0NpcmNsZTIuZGVmYXVsdCh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY2lyY3VsYXJJbWFnZSc6XG4gICAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgX0NpcmN1bGFySW1hZ2UyLmRlZmF1bHQodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUsIHRoaXMuaW1hZ2VPYmopO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RhdGFiYXNlJzpcbiAgICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBfRGF0YWJhc2UyLmRlZmF1bHQodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RpYW1vbmQnOlxuICAgICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IF9EaWFtb25kMi5kZWZhdWx0KHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkb3QnOlxuICAgICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IF9Eb3QyLmRlZmF1bHQodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2VsbGlwc2UnOlxuICAgICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IF9FbGxpcHNlMi5kZWZhdWx0KHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpY29uJzpcbiAgICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBfSWNvbjIuZGVmYXVsdCh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IF9JbWFnZTIuZGVmYXVsdCh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSwgdGhpcy5pbWFnZU9iaik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc3F1YXJlJzpcbiAgICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBfU3F1YXJlMi5kZWZhdWx0KHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzdGFyJzpcbiAgICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBfU3RhcjIuZGVmYXVsdCh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgX1RleHQyLmRlZmF1bHQodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RyaWFuZ2xlJzpcbiAgICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBfVHJpYW5nbGUyLmRlZmF1bHQodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RyaWFuZ2xlRG93bic6XG4gICAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgX1RyaWFuZ2xlRG93bjIuZGVmYXVsdCh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBfRWxsaXBzZTIuZGVmYXVsdCh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXNldCgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHNlbGVjdCB0aGlzIG5vZGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc2VsZWN0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3QoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9yZXNldCgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHVuc2VsZWN0IHRoaXMgbm9kZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd1bnNlbGVjdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdW5zZWxlY3QoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXNldCB0aGUgY2FsY3VsYXRlZCBzaXplIG9mIHRoZSBub2RlLCBmb3JjZXMgaXQgdG8gcmVjYWxjdWxhdGUgaXRzIHNpemVcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19yZXNldCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc2V0KCkge1xuICAgICAgICB0aGlzLnNoYXBlLndpZHRoID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnNoYXBlLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBnZXQgdGhlIHRpdGxlIG9mIHRoaXMgbm9kZS5cbiAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gdGl0bGUgICAgVGhlIHRpdGxlIG9mIHRoZSBub2RlLCBvciB1bmRlZmluZWQgd2hlbiBubyB0aXRsZVxuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBoYXMgYmVlbiBzZXQuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldFRpdGxlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUaXRsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy50aXRsZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIHRvIHRoZSBib3JkZXIgb2YgdGhlIE5vZGVcbiAgICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAgIGN0eFxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlICAgICAgICBBbmdsZSBpbiByYWRpYW5zXG4gICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBkaXN0YW5jZSAgIERpc3RhbmNlIHRvIHRoZSBib3JkZXIgaW4gcGl4ZWxzXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Rpc3RhbmNlVG9Cb3JkZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaGFwZS5kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENoZWNrIGlmIHRoaXMgbm9kZSBoYXMgYSBmaXhlZCB4IGFuZCB5IHBvc2l0aW9uXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSAgICAgIHRydWUgaWYgZml4ZWQsIGZhbHNlIGlmIG5vdFxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdpc0ZpeGVkJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc0ZpeGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmZpeGVkLnggJiYgdGhpcy5vcHRpb25zLmZpeGVkLnk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogY2hlY2sgaWYgdGhpcyBub2RlIGlzIHNlbGVjdGVcbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHNlbGVjdGVkICAgVHJ1ZSBpZiBub2RlIGlzIHNlbGVjdGVkLCBlbHNlIGZhbHNlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2lzU2VsZWN0ZWQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzU2VsZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHJpZXZlIHRoZSB2YWx1ZSBvZiB0aGUgbm9kZS4gQ2FuIGJlIHVuZGVmaW5lZFxuICAgICAgICogQHJldHVybiB7TnVtYmVyfSB2YWx1ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXRWYWx1ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQWRqdXN0IHRoZSB2YWx1ZSByYW5nZSBvZiB0aGUgbm9kZS4gVGhlIG5vZGUgd2lsbCBhZGp1c3QgaXQncyBzaXplXG4gICAgICAgKiBiYXNlZCBvbiBpdHMgdmFsdWUuXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gbWluXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gbWF4XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NldFZhbHVlUmFuZ2UnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFZhbHVlUmFuZ2UobWluLCBtYXgsIHRvdGFsKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBzY2FsZSA9IHRoaXMub3B0aW9ucy5zY2FsaW5nLmN1c3RvbVNjYWxpbmdGdW5jdGlvbihtaW4sIG1heCwgdG90YWwsIHRoaXMub3B0aW9ucy52YWx1ZSk7XG4gICAgICAgICAgdmFyIHNpemVEaWZmID0gdGhpcy5vcHRpb25zLnNjYWxpbmcubWF4IC0gdGhpcy5vcHRpb25zLnNjYWxpbmcubWluO1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2NhbGluZy5sYWJlbC5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgZm9udERpZmYgPSB0aGlzLm9wdGlvbnMuc2NhbGluZy5sYWJlbC5tYXggLSB0aGlzLm9wdGlvbnMuc2NhbGluZy5sYWJlbC5taW47XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZm9udC5zaXplID0gdGhpcy5vcHRpb25zLnNjYWxpbmcubGFiZWwubWluICsgc2NhbGUgKiBmb250RGlmZjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5vcHRpb25zLnNpemUgPSB0aGlzLm9wdGlvbnMuc2NhbGluZy5taW4gKyBzY2FsZSAqIHNpemVEaWZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5zaXplID0gdGhpcy5iYXNlU2l6ZTtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZm9udC5zaXplID0gdGhpcy5iYXNlRm9udFNpemU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZUxhYmVsTW9kdWxlKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRHJhdyB0aGlzIG5vZGUgaW4gdGhlIGdpdmVuIGNhbnZhc1xuICAgICAgICogVGhlIDJkIGNvbnRleHQgb2YgYSBIVE1MIGNhbnZhcyBjYW4gYmUgcmV0cmlldmVkIGJ5IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gICBjdHhcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZHJhdycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgpIHtcbiAgICAgICAgdGhpcy5zaGFwZS5kcmF3KGN0eCwgdGhpcy54LCB0aGlzLnksIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFVwZGF0ZSB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBzaGFwZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd1cGRhdGVCb3VuZGluZ0JveCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQm91bmRpbmdCb3goY3R4KSB7XG4gICAgICAgIHRoaXMuc2hhcGUudXBkYXRlQm91bmRpbmdCb3godGhpcy54LCB0aGlzLnksIGN0eCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVjYWxjdWxhdGUgdGhlIHNpemUgb2YgdGhpcyBub2RlIGluIHRoZSBnaXZlbiBjYW52YXNcbiAgICAgICAqIFRoZSAyZCBjb250ZXh0IG9mIGEgSFRNTCBjYW52YXMgY2FuIGJlIHJldHJpZXZlZCBieSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICAgY3R4XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3Jlc2l6ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKGN0eCkge1xuICAgICAgICB0aGlzLnNoYXBlLnJlc2l6ZShjdHgsIHRoaXMuc2VsZWN0ZWQpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENoZWNrIGlmIHRoaXMgb2JqZWN0IGlzIG92ZXJsYXBwaW5nIHdpdGggdGhlIHByb3ZpZGVkIG9iamVjdFxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAgIGFuIG9iamVjdCB3aXRoIHBhcmFtZXRlcnMgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSAgICAgVHJ1ZSBpZiBsb2NhdGlvbiBpcyBsb2NhdGVkIG9uIG5vZGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnaXNPdmVybGFwcGluZ1dpdGgnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzT3ZlcmxhcHBpbmdXaXRoKG9iaikge1xuICAgICAgICByZXR1cm4gdGhpcy5zaGFwZS5sZWZ0IDwgb2JqLnJpZ2h0ICYmIHRoaXMuc2hhcGUubGVmdCArIHRoaXMuc2hhcGUud2lkdGggPiBvYmoubGVmdCAmJiB0aGlzLnNoYXBlLnRvcCA8IG9iai5ib3R0b20gJiYgdGhpcy5zaGFwZS50b3AgKyB0aGlzLnNoYXBlLmhlaWdodCA+IG9iai50b3A7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2hlY2sgaWYgdGhpcyBvYmplY3QgaXMgb3ZlcmxhcHBpbmcgd2l0aCB0aGUgcHJvdmlkZWQgb2JqZWN0XG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqICAgYW4gb2JqZWN0IHdpdGggcGFyYW1ldGVycyBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b21cbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59ICAgICBUcnVlIGlmIGxvY2F0aW9uIGlzIGxvY2F0ZWQgb24gbm9kZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdpc0JvdW5kaW5nQm94T3ZlcmxhcHBpbmdXaXRoJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc0JvdW5kaW5nQm94T3ZlcmxhcHBpbmdXaXRoKG9iaikge1xuICAgICAgICByZXR1cm4gdGhpcy5zaGFwZS5ib3VuZGluZ0JveC5sZWZ0IDwgb2JqLnJpZ2h0ICYmIHRoaXMuc2hhcGUuYm91bmRpbmdCb3gucmlnaHQgPiBvYmoubGVmdCAmJiB0aGlzLnNoYXBlLmJvdW5kaW5nQm94LnRvcCA8IG9iai5ib3R0b20gJiYgdGhpcy5zaGFwZS5ib3VuZGluZ0JveC5ib3R0b20gPiBvYmoudG9wO1xuICAgICAgfVxuICAgIH1dLCBbe1xuICAgICAga2V5OiAncGFyc2VPcHRpb25zJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZU9wdGlvbnMocGFyZW50T3B0aW9ucywgbmV3T3B0aW9ucykge1xuICAgICAgICB2YXIgYWxsb3dEZWxldGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogYXJndW1lbnRzWzJdO1xuICAgICAgICB2YXIgZ2xvYmFsT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMyB8fCBhcmd1bWVudHNbM10gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzNdO1xuXG4gICAgICAgIHZhciBmaWVsZHMgPSBbJ2NvbG9yJywgJ2ZvbnQnLCAnZml4ZWQnLCAnc2hhZG93J107XG4gICAgICAgIHV0aWwuc2VsZWN0aXZlTm90RGVlcEV4dGVuZChmaWVsZHMsIHBhcmVudE9wdGlvbnMsIG5ld09wdGlvbnMsIGFsbG93RGVsZXRpb24pO1xuXG4gICAgICAgIC8vIG1lcmdlIHRoZSBzaGFkb3cgb3B0aW9ucyBpbnRvIHRoZSBwYXJlbnQuXG4gICAgICAgIHV0aWwubWVyZ2VPcHRpb25zKHBhcmVudE9wdGlvbnMsIG5ld09wdGlvbnMsICdzaGFkb3cnLCBhbGxvd0RlbGV0aW9uLCBnbG9iYWxPcHRpb25zKTtcblxuICAgICAgICAvLyBpbmRpdmlkdWFsIHNoYXBlIG5ld09wdGlvbnNcbiAgICAgICAgaWYgKG5ld09wdGlvbnMuY29sb3IgIT09IHVuZGVmaW5lZCAmJiBuZXdPcHRpb25zLmNvbG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIHBhcnNlZENvbG9yID0gdXRpbC5wYXJzZUNvbG9yKG5ld09wdGlvbnMuY29sb3IpO1xuICAgICAgICAgIHV0aWwuZmlsbElmRGVmaW5lZChwYXJlbnRPcHRpb25zLmNvbG9yLCBwYXJzZWRDb2xvcik7XG4gICAgICAgIH0gZWxzZSBpZiAoYWxsb3dEZWxldGlvbiA9PT0gdHJ1ZSAmJiBuZXdPcHRpb25zLmNvbG9yID09PSBudWxsKSB7XG4gICAgICAgICAgcGFyZW50T3B0aW9ucy5jb2xvciA9IHV0aWwuYnJpZGdlT2JqZWN0KGdsb2JhbE9wdGlvbnMuY29sb3IpOyAvLyBzZXQgdGhlIG9iamVjdCBiYWNrIHRvIHRoZSBnbG9iYWwgb3B0aW9uc1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGFuZGxlIHRoZSBmaXhlZCBvcHRpb25zXG4gICAgICAgIGlmIChuZXdPcHRpb25zLmZpeGVkICE9PSB1bmRlZmluZWQgJiYgbmV3T3B0aW9ucy5maXhlZCAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbmV3T3B0aW9ucy5maXhlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBwYXJlbnRPcHRpb25zLmZpeGVkLnggPSBuZXdPcHRpb25zLmZpeGVkO1xuICAgICAgICAgICAgcGFyZW50T3B0aW9ucy5maXhlZC55ID0gbmV3T3B0aW9ucy5maXhlZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG5ld09wdGlvbnMuZml4ZWQueCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBuZXdPcHRpb25zLmZpeGVkLnggPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICBwYXJlbnRPcHRpb25zLmZpeGVkLnggPSBuZXdPcHRpb25zLmZpeGVkLng7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3T3B0aW9ucy5maXhlZC55ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG5ld09wdGlvbnMuZml4ZWQueSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgIHBhcmVudE9wdGlvbnMuZml4ZWQueSA9IG5ld09wdGlvbnMuZml4ZWQueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoYW5kbGUgdGhlIGZvbnQgb3B0aW9uc1xuICAgICAgICBpZiAobmV3T3B0aW9ucy5mb250ICE9PSB1bmRlZmluZWQgJiYgbmV3T3B0aW9ucy5mb250ICE9PSBudWxsKSB7XG4gICAgICAgICAgX0xhYmVsMi5kZWZhdWx0LnBhcnNlT3B0aW9ucyhwYXJlbnRPcHRpb25zLmZvbnQsIG5ld09wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKGFsbG93RGVsZXRpb24gPT09IHRydWUgJiYgbmV3T3B0aW9ucy5mb250ID09PSBudWxsKSB7XG4gICAgICAgICAgcGFyZW50T3B0aW9ucy5mb250ID0gdXRpbC5icmlkZ2VPYmplY3QoZ2xvYmFsT3B0aW9ucy5mb250KTsgLy8gc2V0IHRoZSBvYmplY3QgYmFjayB0byB0aGUgZ2xvYmFsIG9wdGlvbnNcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhbmRsZSB0aGUgc2NhbGluZyBvcHRpb25zLCBzcGVjaWZpY2FsbHkgdGhlIGxhYmVsIHBhcnRcbiAgICAgICAgaWYgKG5ld09wdGlvbnMuc2NhbGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdXRpbC5tZXJnZU9wdGlvbnMocGFyZW50T3B0aW9ucy5zY2FsaW5nLCBuZXdPcHRpb25zLnNjYWxpbmcsICdsYWJlbCcsIGFsbG93RGVsZXRpb24sIGdsb2JhbE9wdGlvbnMuc2NhbGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gTm9kZTtcbiAgfSgpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IE5vZGU7XG5cbi8qKiovIH0sXG4vKiA2NiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxuICB2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgdmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4gIHZhciBMYWJlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMYWJlbChib2R5LCBvcHRpb25zKSB7XG4gICAgICB2YXIgZWRnZWxhYmVsID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBhcmd1bWVudHNbMl07XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMYWJlbCk7XG5cbiAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG5cbiAgICAgIHRoaXMucG9pbnRUb1NlbGYgPSBmYWxzZTtcbiAgICAgIHRoaXMuYmFzZVNpemUgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmZvbnRPcHRpb25zID0ge307XG4gICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICB0aGlzLnNpemUgPSB7IHRvcDogMCwgbGVmdDogMCwgd2lkdGg6IDAsIGhlaWdodDogMCwgeUxpbmU6IDAgfTsgLy8gY291bGQgYmUgY2FjaGVkXG4gICAgICB0aGlzLmlzRWRnZUxhYmVsID0gZWRnZWxhYmVsO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhMYWJlbCwgW3tcbiAgICAgIGtleTogJ3NldE9wdGlvbnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB2YXIgYWxsb3dEZWxldGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgIHRoaXMubm9kZU9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgICAgIC8vIFdlIHdhbnQgdG8ga2VlcCB0aGUgZm9udCBvcHRpb25zIHNlcGVyYXRlZCBmcm9tIHRoZSBub2RlIG9wdGlvbnMuXG4gICAgICAgIC8vIFRoZSBub2RlIG9wdGlvbnMgaGF2ZSB0byBtaXJyb3IgdGhlIGdsb2JhbHMgd2hlbiB0aGV5IGFyZSBub3Qgb3ZlcnJ1bGVkLlxuICAgICAgICB0aGlzLmZvbnRPcHRpb25zID0gdXRpbC5kZWVwRXh0ZW5kKHt9LCBvcHRpb25zLmZvbnQsIHRydWUpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmxhYmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmxhYmVsRGlydHkgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZm9udCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgTGFiZWwucGFyc2VPcHRpb25zKHRoaXMuZm9udE9wdGlvbnMsIG9wdGlvbnMsIGFsbG93RGVsZXRpb24pO1xuICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mb250ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5iYXNlU2l6ZSA9IHRoaXMuZm9udE9wdGlvbnMuc2l6ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKF90eXBlb2Yob3B0aW9ucy5mb250KSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmZvbnQuc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHRoaXMuYmFzZVNpemUgPSBvcHRpb25zLmZvbnQuc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkcmF3JyxcblxuXG4gICAgICAvKipcbiAgICAgICAqIE1haW4gZnVuY3Rpb24uIFRoaXMgaXMgY2FsbGVkIGZyb20gYW55dGhpbmcgdGhhdCB3YW50cyB0byBkcmF3IGEgbGFiZWwuXG4gICAgICAgKiBAcGFyYW0gY3R4XG4gICAgICAgKiBAcGFyYW0geFxuICAgICAgICogQHBhcmFtIHlcbiAgICAgICAqIEBwYXJhbSBzZWxlY3RlZFxuICAgICAgICogQHBhcmFtIGJhc2VsaW5lXG4gICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQpIHtcbiAgICAgICAgdmFyIGJhc2VsaW5lID0gYXJndW1lbnRzLmxlbmd0aCA8PSA0IHx8IGFyZ3VtZW50c1s0XSA9PT0gdW5kZWZpbmVkID8gJ21pZGRsZScgOiBhcmd1bWVudHNbNF07XG5cbiAgICAgICAgLy8gaWYgbm8gbGFiZWwsIHJldHVyblxuICAgICAgICBpZiAodGhpcy5ub2RlT3B0aW9ucy5sYWJlbCA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgd2UgaGF2ZSB0byByZW5kZXIgdGhlIGxhYmVsXG4gICAgICAgIHZhciB2aWV3Rm9udFNpemUgPSB0aGlzLmZvbnRPcHRpb25zLnNpemUgKiB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgICAgaWYgKHRoaXMubm9kZU9wdGlvbnMubGFiZWwgJiYgdmlld0ZvbnRTaXplIDwgdGhpcy5ub2RlT3B0aW9ucy5zY2FsaW5nLmxhYmVsLmRyYXdUaHJlc2hvbGQgLSAxKSByZXR1cm47XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBzaXplIGNhY2hlIGlmIHJlcXVpcmVkXG4gICAgICAgIHRoaXMuY2FsY3VsYXRlTGFiZWxTaXplKGN0eCwgc2VsZWN0ZWQsIHgsIHksIGJhc2VsaW5lKTtcblxuICAgICAgICAvLyBjcmVhdGUgdGhlIGZvbnRmaWxsIGJhY2tncm91bmRcbiAgICAgICAgdGhpcy5fZHJhd0JhY2tncm91bmQoY3R4KTtcbiAgICAgICAgLy8gZHJhdyB0ZXh0XG4gICAgICAgIHRoaXMuX2RyYXdUZXh0KGN0eCwgc2VsZWN0ZWQsIHgsIHksIGJhc2VsaW5lKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBEcmF3cyB0aGUgbGFiZWwgYmFja2dyb3VuZFxuICAgICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2RyYXdCYWNrZ3JvdW5kJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd0JhY2tncm91bmQoY3R4KSB7XG4gICAgICAgIGlmICh0aGlzLmZvbnRPcHRpb25zLmJhY2tncm91bmQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmZvbnRPcHRpb25zLmJhY2tncm91bmQgIT09IFwibm9uZVwiKSB7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuZm9udE9wdGlvbnMuYmFja2dyb3VuZDtcblxuICAgICAgICAgIHZhciBsaW5lTWFyZ2luID0gMjtcblxuICAgICAgICAgIGlmICh0aGlzLmlzRWRnZUxhYmVsKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZm9udE9wdGlvbnMuYWxpZ24pIHtcbiAgICAgICAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoLXRoaXMuc2l6ZS53aWR0aCAqIDAuNSwgLXRoaXMuc2l6ZS5oZWlnaHQgKiAwLjUsIHRoaXMuc2l6ZS53aWR0aCwgdGhpcy5zaXplLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KC10aGlzLnNpemUud2lkdGggKiAwLjUsIC0odGhpcy5zaXplLmhlaWdodCArIGxpbmVNYXJnaW4pLCB0aGlzLnNpemUud2lkdGgsIHRoaXMuc2l6ZS5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCgtdGhpcy5zaXplLndpZHRoICogMC41LCBsaW5lTWFyZ2luLCB0aGlzLnNpemUud2lkdGgsIHRoaXMuc2l6ZS5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCh0aGlzLnNpemUubGVmdCwgdGhpcy5zaXplLnRvcCAtIDAuNSAqIGxpbmVNYXJnaW4sIHRoaXMuc2l6ZS53aWR0aCwgdGhpcy5zaXplLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCh0aGlzLnNpemUubGVmdCwgdGhpcy5zaXplLnRvcCAtIDAuNSAqIGxpbmVNYXJnaW4sIHRoaXMuc2l6ZS53aWR0aCwgdGhpcy5zaXplLmhlaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSBjdHhcbiAgICAgICAqIEBwYXJhbSB4XG4gICAgICAgKiBAcGFyYW0gYmFzZWxpbmVcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19kcmF3VGV4dCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdUZXh0KGN0eCwgc2VsZWN0ZWQsIHgsIHkpIHtcbiAgICAgICAgdmFyIGJhc2VsaW5lID0gYXJndW1lbnRzLmxlbmd0aCA8PSA0IHx8IGFyZ3VtZW50c1s0XSA9PT0gdW5kZWZpbmVkID8gJ21pZGRsZScgOiBhcmd1bWVudHNbNF07XG5cbiAgICAgICAgdmFyIGZvbnRTaXplID0gdGhpcy5mb250T3B0aW9ucy5zaXplO1xuICAgICAgICB2YXIgdmlld0ZvbnRTaXplID0gZm9udFNpemUgKiB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgICAgLy8gdGhpcyBlbnN1cmVzIHRoYXQgdGhlcmUgd2lsbCBub3QgYmUgSFVHRSBsZXR0ZXJzIG9uIHNjcmVlbiBieSBzZXR0aW5nIGFuIHVwcGVyIGxpbWl0IG9uIHRoZSB2aXNpYmxlIHRleHQgc2l6ZSAocmVnYXJkbGVzcyBvZiB6b29tTGV2ZWwpXG4gICAgICAgIGlmICh2aWV3Rm9udFNpemUgPj0gdGhpcy5ub2RlT3B0aW9ucy5zY2FsaW5nLmxhYmVsLm1heFZpc2libGUpIHtcbiAgICAgICAgICBmb250U2l6ZSA9IE51bWJlcih0aGlzLm5vZGVPcHRpb25zLnNjYWxpbmcubGFiZWwubWF4VmlzaWJsZSkgLyB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB5TGluZSA9IHRoaXMuc2l6ZS55TGluZTtcblxuICAgICAgICB2YXIgX2dldENvbG9yMiA9IHRoaXMuX2dldENvbG9yKHZpZXdGb250U2l6ZSk7XG5cbiAgICAgICAgdmFyIF9nZXRDb2xvcjMgPSBfc2xpY2VkVG9BcnJheShfZ2V0Q29sb3IyLCAyKTtcblxuICAgICAgICB2YXIgZm9udENvbG9yID0gX2dldENvbG9yM1swXTtcbiAgICAgICAgdmFyIHN0cm9rZUNvbG9yID0gX2dldENvbG9yM1sxXTtcblxuXG4gICAgICAgIC8vIGNvbmZpZ3VyZSBjb250ZXh0IGZvciBkcmF3aW5nIHRoZSB0ZXh0XG5cbiAgICAgICAgdmFyIF9zZXRBbGlnbm1lbnQyID0gdGhpcy5fc2V0QWxpZ25tZW50KGN0eCwgeCwgeUxpbmUsIGJhc2VsaW5lKTtcblxuICAgICAgICB2YXIgX3NldEFsaWdubWVudDMgPSBfc2xpY2VkVG9BcnJheShfc2V0QWxpZ25tZW50MiwgMik7XG5cbiAgICAgICAgeCA9IF9zZXRBbGlnbm1lbnQzWzBdO1xuICAgICAgICB5TGluZSA9IF9zZXRBbGlnbm1lbnQzWzFdO1xuICAgICAgICBjdHguZm9udCA9IChzZWxlY3RlZCAmJiB0aGlzLm5vZGVPcHRpb25zLmxhYmVsSGlnaGxpZ2h0Qm9sZCA/ICdib2xkICcgOiAnJykgKyBmb250U2l6ZSArIFwicHggXCIgKyB0aGlzLmZvbnRPcHRpb25zLmZhY2U7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBmb250Q29sb3I7XG4gICAgICAgIC8vIFdoZW4gdGhlIHRleHRBbGlnbiBwcm9wZXJ0eSBpcyAnbGVmdCcsIG1ha2UgbGFiZWwgbGVmdC1qdXN0aWZpZWRcbiAgICAgICAgaWYgKCF0aGlzLmlzRWRnZUxhYmVsICYmIHRoaXMuZm9udE9wdGlvbnMuYWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSB0aGlzLmZvbnRPcHRpb25zLmFsaWduO1xuICAgICAgICAgIHggPSB4IC0gMC41ICogdGhpcy5zaXplLndpZHRoOyAvLyBTaGlmdCBsYWJlbCAxLzItZGlzdGFuY2UgdG8gdGhlIGxlZnRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHRoZSBzdHJva2VXaWR0aFxuICAgICAgICBpZiAodGhpcy5mb250T3B0aW9ucy5zdHJva2VXaWR0aCA+IDApIHtcbiAgICAgICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5mb250T3B0aW9ucy5zdHJva2VXaWR0aDtcbiAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2VDb2xvcjtcbiAgICAgICAgICBjdHgubGluZUpvaW4gPSAncm91bmQnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZHJhdyB0aGUgdGV4dFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGluZUNvdW50OyBpKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5mb250T3B0aW9ucy5zdHJva2VXaWR0aCA+IDApIHtcbiAgICAgICAgICAgIGN0eC5zdHJva2VUZXh0KHRoaXMubGluZXNbaV0sIHgsIHlMaW5lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4LmZpbGxUZXh0KHRoaXMubGluZXNbaV0sIHgsIHlMaW5lKTtcbiAgICAgICAgICB5TGluZSArPSBmb250U2l6ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19zZXRBbGlnbm1lbnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRBbGlnbm1lbnQoY3R4LCB4LCB5TGluZSwgYmFzZWxpbmUpIHtcbiAgICAgICAgLy8gY2hlY2sgZm9yIGxhYmVsIGFsaWdubWVudCAoZm9yIGVkZ2VzKVxuICAgICAgICAvLyBUT0RPOiBtYWtlIGFsaWdubWVudCBmb3Igbm9kZXNcbiAgICAgICAgaWYgKHRoaXMuaXNFZGdlTGFiZWwgJiYgdGhpcy5mb250T3B0aW9ucy5hbGlnbiAhPT0gJ2hvcml6b250YWwnICYmIHRoaXMucG9pbnRUb1NlbGYgPT09IGZhbHNlKSB7XG4gICAgICAgICAgeCA9IDA7XG4gICAgICAgICAgeUxpbmUgPSAwO1xuXG4gICAgICAgICAgdmFyIGxpbmVNYXJnaW4gPSAyO1xuICAgICAgICAgIGlmICh0aGlzLmZvbnRPcHRpb25zLmFsaWduID09PSAndG9wJykge1xuICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdhbHBoYWJldGljJztcbiAgICAgICAgICAgIHlMaW5lIC09IDIgKiBsaW5lTWFyZ2luOyAvLyBkaXN0YW5jZSBmcm9tIGVkZ2UsIHJlcXVpcmVkIGJlY2F1c2Ugd2UgdXNlIGFscGhhYmV0aWMuIEFscGhhYmV0aWMgaGFzIGxlc3MgZGlmZmVyZW5jZSBiZXR3ZWVuIGJyb3dzZXJzXG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmZvbnRPcHRpb25zLmFsaWduID09PSAnYm90dG9tJykge1xuICAgICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ2hhbmdpbmcnO1xuICAgICAgICAgICAgICB5TGluZSArPSAyICogbGluZU1hcmdpbjsgLy8gZGlzdGFuY2UgZnJvbSBlZGdlLCByZXF1aXJlZCBiZWNhdXNlIHdlIHVzZSBoYW5naW5nLiBIYW5naW5nIGhhcyBsZXNzIGRpZmZlcmVuY2UgYmV0d2VlbiBicm93c2Vyc1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gYmFzZWxpbmU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW3gsIHlMaW5lXTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBmYWRlIGluIHdoZW4gcmVsYXRpdmUgc2NhbGUgaXMgYmV0d2VlbiB0aHJlc2hvbGQgYW5kIHRocmVzaG9sZCAtIDEuXG4gICAgICAgKiBJZiB0aGUgcmVsYXRpdmUgc2NhbGUgd291bGQgYmUgc21hbGxlciB0aGFuIHRocmVzaG9sZCAtMSB0aGUgZHJhdyBmdW5jdGlvbiB3b3VsZCBoYXZlIHJldHVybmVkIGJlZm9yZSBjb21pbmcgaGVyZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gdmlld0ZvbnRTaXplXG4gICAgICAgKiBAcmV0dXJucyB7KltdfVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2dldENvbG9yJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q29sb3Iodmlld0ZvbnRTaXplKSB7XG4gICAgICAgIHZhciBmb250Q29sb3IgPSB0aGlzLmZvbnRPcHRpb25zLmNvbG9yIHx8ICcjMDAwMDAwJztcbiAgICAgICAgdmFyIHN0cm9rZUNvbG9yID0gdGhpcy5mb250T3B0aW9ucy5zdHJva2VDb2xvciB8fCAnI2ZmZmZmZic7XG4gICAgICAgIGlmICh2aWV3Rm9udFNpemUgPD0gdGhpcy5ub2RlT3B0aW9ucy5zY2FsaW5nLmxhYmVsLmRyYXdUaHJlc2hvbGQpIHtcbiAgICAgICAgICB2YXIgb3BhY2l0eSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIDEgLSAodGhpcy5ub2RlT3B0aW9ucy5zY2FsaW5nLmxhYmVsLmRyYXdUaHJlc2hvbGQgLSB2aWV3Rm9udFNpemUpKSk7XG4gICAgICAgICAgZm9udENvbG9yID0gdXRpbC5vdmVycmlkZU9wYWNpdHkoZm9udENvbG9yLCBvcGFjaXR5KTtcbiAgICAgICAgICBzdHJva2VDb2xvciA9IHV0aWwub3ZlcnJpZGVPcGFjaXR5KHN0cm9rZUNvbG9yLCBvcGFjaXR5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2ZvbnRDb2xvciwgc3Ryb2tlQ29sb3JdO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gY3R4XG4gICAgICAgKiBAcGFyYW0gc2VsZWN0ZWRcbiAgICAgICAqIEByZXR1cm5zIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXRUZXh0U2l6ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGV4dFNpemUoY3R4KSB7XG4gICAgICAgIHZhciBzZWxlY3RlZCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgIHZhciBzaXplID0ge1xuICAgICAgICAgIHdpZHRoOiB0aGlzLl9wcm9jZXNzTGFiZWwoY3R4LCBzZWxlY3RlZCksXG4gICAgICAgICAgaGVpZ2h0OiB0aGlzLmZvbnRPcHRpb25zLnNpemUgKiB0aGlzLmxpbmVDb3VudCxcbiAgICAgICAgICBsaW5lQ291bnQ6IHRoaXMubGluZUNvdW50XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gY3R4XG4gICAgICAgKiBAcGFyYW0gc2VsZWN0ZWRcbiAgICAgICAqIEBwYXJhbSB4XG4gICAgICAgKiBAcGFyYW0geVxuICAgICAgICogQHBhcmFtIGJhc2VsaW5lXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2NhbGN1bGF0ZUxhYmVsU2l6ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRlTGFiZWxTaXplKGN0eCwgc2VsZWN0ZWQpIHtcbiAgICAgICAgdmFyIHggPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyAwIDogYXJndW1lbnRzWzJdO1xuICAgICAgICB2YXIgeSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMyB8fCBhcmd1bWVudHNbM10gPT09IHVuZGVmaW5lZCA/IDAgOiBhcmd1bWVudHNbM107XG4gICAgICAgIHZhciBiYXNlbGluZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gNCB8fCBhcmd1bWVudHNbNF0gPT09IHVuZGVmaW5lZCA/ICdtaWRkbGUnIDogYXJndW1lbnRzWzRdO1xuXG4gICAgICAgIGlmICh0aGlzLmxhYmVsRGlydHkgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLnNpemUud2lkdGggPSB0aGlzLl9wcm9jZXNzTGFiZWwoY3R4LCBzZWxlY3RlZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaXplLmhlaWdodCA9IHRoaXMuZm9udE9wdGlvbnMuc2l6ZSAqIHRoaXMubGluZUNvdW50O1xuICAgICAgICB0aGlzLnNpemUubGVmdCA9IHggLSB0aGlzLnNpemUud2lkdGggKiAwLjU7XG4gICAgICAgIHRoaXMuc2l6ZS50b3AgPSB5IC0gdGhpcy5zaXplLmhlaWdodCAqIDAuNTtcbiAgICAgICAgdGhpcy5zaXplLnlMaW5lID0geSArICgxIC0gdGhpcy5saW5lQ291bnQpICogMC41ICogdGhpcy5mb250T3B0aW9ucy5zaXplO1xuICAgICAgICBpZiAoYmFzZWxpbmUgPT09IFwiaGFuZ2luZ1wiKSB7XG4gICAgICAgICAgdGhpcy5zaXplLnRvcCArPSAwLjUgKiB0aGlzLmZvbnRPcHRpb25zLnNpemU7XG4gICAgICAgICAgdGhpcy5zaXplLnRvcCArPSA0OyAvLyBkaXN0YW5jZSBmcm9tIG5vZGUsIHJlcXVpcmVkIGJlY2F1c2Ugd2UgdXNlIGhhbmdpbmcuIEhhbmdpbmcgaGFzIGxlc3MgZGlmZmVyZW5jZSBiZXR3ZWVuIGJyb3dzZXJzXG4gICAgICAgICAgdGhpcy5zaXplLnlMaW5lICs9IDQ7IC8vIGRpc3RhbmNlIGZyb20gbm9kZVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sYWJlbERpcnR5ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBjYWxjdWxhdGVzIHRoZSB3aWR0aCBhcyB3ZWxsIGFzIGV4cGxvZGVzIHRoZSBsYWJlbCBzdHJpbmcgYW5kIGNhbGN1bGF0ZXMgdGhlIGFtb3VudCBvZiBsaW5lcy5cbiAgICAgICAqIEBwYXJhbSBjdHhcbiAgICAgICAqIEBwYXJhbSBzZWxlY3RlZFxuICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19wcm9jZXNzTGFiZWwnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9wcm9jZXNzTGFiZWwoY3R4LCBzZWxlY3RlZCkge1xuICAgICAgICB2YXIgd2lkdGggPSAwO1xuICAgICAgICB2YXIgbGluZXMgPSBbJyddO1xuICAgICAgICB2YXIgbGluZUNvdW50ID0gMDtcbiAgICAgICAgaWYgKHRoaXMubm9kZU9wdGlvbnMubGFiZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGxpbmVzID0gU3RyaW5nKHRoaXMubm9kZU9wdGlvbnMubGFiZWwpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICBsaW5lQ291bnQgPSBsaW5lcy5sZW5ndGg7XG4gICAgICAgICAgY3R4LmZvbnQgPSAoc2VsZWN0ZWQgJiYgdGhpcy5ub2RlT3B0aW9ucy5sYWJlbEhpZ2hsaWdodEJvbGQgPyAnYm9sZCAnIDogJycpICsgdGhpcy5mb250T3B0aW9ucy5zaXplICsgXCJweCBcIiArIHRoaXMuZm9udE9wdGlvbnMuZmFjZTtcbiAgICAgICAgICB3aWR0aCA9IGN0eC5tZWFzdXJlVGV4dChsaW5lc1swXSkud2lkdGg7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsaW5lQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxpbmVXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dChsaW5lc1tpXSkud2lkdGg7XG4gICAgICAgICAgICB3aWR0aCA9IGxpbmVXaWR0aCA+IHdpZHRoID8gbGluZVdpZHRoIDogd2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGluZXMgPSBsaW5lcztcbiAgICAgICAgdGhpcy5saW5lQ291bnQgPSBsaW5lQ291bnQ7XG5cbiAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgICAgfVxuICAgIH1dLCBbe1xuICAgICAga2V5OiAncGFyc2VPcHRpb25zJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZU9wdGlvbnMocGFyZW50T3B0aW9ucywgbmV3T3B0aW9ucykge1xuICAgICAgICB2YXIgYWxsb3dEZWxldGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogYXJndW1lbnRzWzJdO1xuXG4gICAgICAgIGlmICh0eXBlb2YgbmV3T3B0aW9ucy5mb250ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHZhciBuZXdPcHRpb25zQXJyYXkgPSBuZXdPcHRpb25zLmZvbnQuc3BsaXQoXCIgXCIpO1xuICAgICAgICAgIHBhcmVudE9wdGlvbnMuc2l6ZSA9IG5ld09wdGlvbnNBcnJheVswXS5yZXBsYWNlKFwicHhcIiwgJycpO1xuICAgICAgICAgIHBhcmVudE9wdGlvbnMuZmFjZSA9IG5ld09wdGlvbnNBcnJheVsxXTtcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLmNvbG9yID0gbmV3T3B0aW9uc0FycmF5WzJdO1xuICAgICAgICB9IGVsc2UgaWYgKF90eXBlb2YobmV3T3B0aW9ucy5mb250KSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB1dGlsLmZpbGxJZkRlZmluZWQocGFyZW50T3B0aW9ucywgbmV3T3B0aW9ucy5mb250LCBhbGxvd0RlbGV0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnRPcHRpb25zLnNpemUgPSBOdW1iZXIocGFyZW50T3B0aW9ucy5zaXplKTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gTGFiZWw7XG4gIH0oKTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBMYWJlbDtcblxuLyoqKi8gfSxcbi8qIDY3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX05vZGVCYXNlMiA9IF9fd2VicGFja19yZXF1aXJlX18oNjgpO1xuXG4gIHZhciBfTm9kZUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTm9kZUJhc2UyKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbiAgdmFyIEJveCA9IGZ1bmN0aW9uIChfTm9kZUJhc2UpIHtcbiAgICBfaW5oZXJpdHMoQm94LCBfTm9kZUJhc2UpO1xuXG4gICAgZnVuY3Rpb24gQm94KG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQm94KTtcblxuICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihCb3gpLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQm94LCBbe1xuICAgICAga2V5OiAncmVzaXplJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoY3R4LCBzZWxlY3RlZCkge1xuICAgICAgICBpZiAodGhpcy53aWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIG1hcmdpbiA9IDU7XG4gICAgICAgICAgdmFyIHRleHRTaXplID0gdGhpcy5sYWJlbE1vZHVsZS5nZXRUZXh0U2l6ZShjdHgsIHNlbGVjdGVkKTtcbiAgICAgICAgICB0aGlzLndpZHRoID0gdGV4dFNpemUud2lkdGggKyAyICogbWFyZ2luO1xuICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gdGV4dFNpemUuaGVpZ2h0ICsgMiAqIG1hcmdpbjtcbiAgICAgICAgICB0aGlzLnJhZGl1cyA9IDAuNSAqIHRoaXMud2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkcmF3JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICAgIHRoaXMucmVzaXplKGN0eCwgc2VsZWN0ZWQpO1xuICAgICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0IC8gMjtcblxuICAgICAgICB2YXIgYm9yZGVyV2lkdGggPSB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgICAgIHZhciBzZWxlY3Rpb25MaW5lV2lkdGggPSB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGhTZWxlY3RlZCB8fCAyICogdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoO1xuXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHNlbGVjdGVkID8gdGhpcy5vcHRpb25zLmNvbG9yLmhpZ2hsaWdodC5ib3JkZXIgOiBob3ZlciA/IHRoaXMub3B0aW9ucy5jb2xvci5ob3Zlci5ib3JkZXIgOiB0aGlzLm9wdGlvbnMuY29sb3IuYm9yZGVyO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gc2VsZWN0ZWQgPyBzZWxlY3Rpb25MaW5lV2lkdGggOiBib3JkZXJXaWR0aDtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCAvPSB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IE1hdGgubWluKHRoaXMud2lkdGgsIGN0eC5saW5lV2lkdGgpO1xuXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBzZWxlY3RlZCA/IHRoaXMub3B0aW9ucy5jb2xvci5oaWdobGlnaHQuYmFja2dyb3VuZCA6IGhvdmVyID8gdGhpcy5vcHRpb25zLmNvbG9yLmhvdmVyLmJhY2tncm91bmQgOiB0aGlzLm9wdGlvbnMuY29sb3IuYmFja2dyb3VuZDtcblxuICAgICAgICB2YXIgYm9yZGVyUmFkaXVzID0gdGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5ib3JkZXJSYWRpdXM7IC8vIG9ubHkgZWZmZWN0aXZlIGZvciBib3hcbiAgICAgICAgY3R4LnJvdW5kUmVjdCh0aGlzLmxlZnQsIHRoaXMudG9wLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgYm9yZGVyUmFkaXVzKTtcblxuICAgICAgICAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG4gICAgICAgIHRoaXMuZW5hYmxlU2hhZG93KGN0eCk7XG4gICAgICAgIC8vIGRyYXcgdGhlIGJhY2tncm91bmRcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgLy8gZGlzYWJsZSBzaGFkb3dzIGZvciBvdGhlciBlbGVtZW50cy5cbiAgICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCk7XG5cbiAgICAgICAgLy9kcmF3IGRhc2hlZCBib3JkZXIgaWYgZW5hYmxlZCwgc2F2ZSBhbmQgcmVzdG9yZSBpcyByZXF1aXJlZCBmb3IgZmlyZWZveCBub3QgdG8gY3Jhc2ggb24gdW5peC5cbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgLy8gaWYgYm9yZGVycyBhcmUgemVybyB3aWR0aCwgdGhleSB3aWxsIGJlIGRyYXduIHdpdGggd2lkdGggMSBieSBkZWZhdWx0LiBUaGlzIHByZXZlbnRzIHRoYXRcbiAgICAgICAgaWYgKGJvcmRlcldpZHRoID4gMCkge1xuICAgICAgICAgIHRoaXMuZW5hYmxlQm9yZGVyRGFzaGVzKGN0eCk7XG4gICAgICAgICAgLy9kcmF3IHRoZSBib3JkZXJcbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgLy9kaXNhYmxlIGRhc2hlZCBib3JkZXIgZm9yIG90aGVyIGVsZW1lbnRzXG4gICAgICAgICAgdGhpcy5kaXNhYmxlQm9yZGVyRGFzaGVzKGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nQm94KHgsIHksIGN0eCwgc2VsZWN0ZWQpO1xuICAgICAgICB0aGlzLmxhYmVsTW9kdWxlLmRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAndXBkYXRlQm91bmRpbmdCb3gnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kaW5nQm94KHgsIHksIGN0eCwgc2VsZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5yZXNpemUoY3R4LCBzZWxlY3RlZCk7XG4gICAgICAgIHRoaXMubGVmdCA9IHggLSB0aGlzLndpZHRoICogMC41O1xuICAgICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAqIDAuNTtcblxuICAgICAgICB2YXIgYm9yZGVyUmFkaXVzID0gdGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5ib3JkZXJSYWRpdXM7IC8vIG9ubHkgZWZmZWN0aXZlIGZvciBib3hcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0gdGhpcy5sZWZ0IC0gYm9yZGVyUmFkaXVzO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LnRvcCA9IHRoaXMudG9wIC0gYm9yZGVyUmFkaXVzO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSA9IHRoaXMudG9wICsgdGhpcy5oZWlnaHQgKyBib3JkZXJSYWRpdXM7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSB0aGlzLmxlZnQgKyB0aGlzLndpZHRoICsgYm9yZGVyUmFkaXVzO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Rpc3RhbmNlVG9Cb3JkZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgICB0aGlzLnJlc2l6ZShjdHgpO1xuICAgICAgICB2YXIgYm9yZGVyV2lkdGggPSB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGg7XG5cbiAgICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGguYWJzKHRoaXMud2lkdGggLyAyIC8gTWF0aC5jb3MoYW5nbGUpKSwgTWF0aC5hYnModGhpcy5oZWlnaHQgLyAyIC8gTWF0aC5zaW4oYW5nbGUpKSkgKyBib3JkZXJXaWR0aDtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQm94O1xuICB9KF9Ob2RlQmFzZTMuZGVmYXVsdCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gQm94O1xuXG4vKioqLyB9LFxuLyogNjggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICB2YXIgTm9kZUJhc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm9kZUJhc2Uob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb2RlQmFzZSk7XG5cbiAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICB0aGlzLmxhYmVsTW9kdWxlID0gbGFiZWxNb2R1bGU7XG4gICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICB0aGlzLnRvcCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMubGVmdCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMucmFkaXVzID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5ib3VuZGluZ0JveCA9IHsgdG9wOiAwLCBsZWZ0OiAwLCByaWdodDogMCwgYm90dG9tOiAwIH07XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKE5vZGVCYXNlLCBbe1xuICAgICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2Rpc3RhbmNlVG9Cb3JkZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICAgIHZhciBib3JkZXJXaWR0aCA9IHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgICAgICAgdGhpcy5yZXNpemUoY3R4KTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGguYWJzKHRoaXMud2lkdGggLyAyIC8gTWF0aC5jb3MoYW5nbGUpKSwgTWF0aC5hYnModGhpcy5oZWlnaHQgLyAyIC8gTWF0aC5zaW4oYW5nbGUpKSkgKyBib3JkZXJXaWR0aDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZW5hYmxlU2hhZG93XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlU2hhZG93KGN0eCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNoYWRvdy5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gdGhpcy5vcHRpb25zLnNoYWRvdy5jb2xvcjtcbiAgICAgICAgICBjdHguc2hhZG93Qmx1ciA9IHRoaXMub3B0aW9ucy5zaGFkb3cuc2l6ZTtcbiAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WCA9IHRoaXMub3B0aW9ucy5zaGFkb3cueDtcbiAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IHRoaXMub3B0aW9ucy5zaGFkb3cueTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkaXNhYmxlU2hhZG93XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzYWJsZVNoYWRvdyhjdHgpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaGFkb3cuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9ICdyZ2JhKDAsMCwwLDApJztcbiAgICAgICAgICBjdHguc2hhZG93Qmx1ciA9IDA7XG4gICAgICAgICAgY3R4LnNoYWRvd09mZnNldFggPSAwO1xuICAgICAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJlbmFibGVCb3JkZXJEYXNoZXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGVCb3JkZXJEYXNoZXMoY3R4KSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLmJvcmRlckRhc2hlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBpZiAoY3R4LnNldExpbmVEYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBkYXNoZXMgPSB0aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLmJvcmRlckRhc2hlcztcbiAgICAgICAgICAgIGlmIChkYXNoZXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgZGFzaGVzID0gWzUsIDE1XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChkYXNoZXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJzZXRMaW5lRGFzaCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3Nlci4gVGhlIGRhc2hlZCBib3JkZXJzIGNhbm5vdCBiZSB1c2VkLlwiKTtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMuYm9yZGVyRGFzaGVzID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRpc2FibGVCb3JkZXJEYXNoZXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlQm9yZGVyRGFzaGVzKGN0eCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5ib3JkZXJEYXNoZXMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKGN0eC5zZXRMaW5lRGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjdHguc2V0TGluZURhc2goWzBdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwic2V0TGluZURhc2ggaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIuIFRoZSBkYXNoZWQgYm9yZGVycyBjYW5ub3QgYmUgdXNlZC5cIik7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLmJvcmRlckRhc2hlcyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBOb2RlQmFzZTtcbiAgfSgpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IE5vZGVCYXNlO1xuXG4vKioqLyB9LFxuLyogNjkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIHZhciBfQ2lyY2xlSW1hZ2VCYXNlMiA9IF9fd2VicGFja19yZXF1aXJlX18oNzApO1xuXG4gIHZhciBfQ2lyY2xlSW1hZ2VCYXNlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NpcmNsZUltYWdlQmFzZTIpO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuICBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuICB2YXIgQ2lyY2xlID0gZnVuY3Rpb24gKF9DaXJjbGVJbWFnZUJhc2UpIHtcbiAgICBfaW5oZXJpdHMoQ2lyY2xlLCBfQ2lyY2xlSW1hZ2VCYXNlKTtcblxuICAgIGZ1bmN0aW9uIENpcmNsZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENpcmNsZSk7XG5cbiAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ2lyY2xlKS5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKENpcmNsZSwgW3tcbiAgICAgIGtleTogJ3Jlc2l6ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKGN0eCwgc2VsZWN0ZWQpIHtcbiAgICAgICAgaWYgKHRoaXMud2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBtYXJnaW4gPSA1O1xuICAgICAgICAgIHZhciB0ZXh0U2l6ZSA9IHRoaXMubGFiZWxNb2R1bGUuZ2V0VGV4dFNpemUoY3R4LCBzZWxlY3RlZCk7XG4gICAgICAgICAgdmFyIGRpYW1ldGVyID0gTWF0aC5tYXgodGV4dFNpemUud2lkdGgsIHRleHRTaXplLmhlaWdodCkgKyAyICogbWFyZ2luO1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5zaXplID0gZGlhbWV0ZXIgLyAyO1xuXG4gICAgICAgICAgdGhpcy53aWR0aCA9IGRpYW1ldGVyO1xuICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gZGlhbWV0ZXI7XG4gICAgICAgICAgdGhpcy5yYWRpdXMgPSAwLjUgKiB0aGlzLndpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZHJhdycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgICB0aGlzLnJlc2l6ZShjdHgsIHNlbGVjdGVkKTtcbiAgICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggLyAyO1xuICAgICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAvIDI7XG5cbiAgICAgICAgdGhpcy5fZHJhd1Jhd0NpcmNsZShjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdGhpcy5vcHRpb25zLnNpemUpO1xuXG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gudG9wID0geSAtIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSB4IC0gdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSB4ICsgdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0geSArIHRoaXMub3B0aW9ucy5zaXplO1xuXG4gICAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdCb3goeCwgeSk7XG4gICAgICAgIHRoaXMubGFiZWxNb2R1bGUuZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICd1cGRhdGVCb3VuZGluZ0JveCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQm91bmRpbmdCb3goeCwgeSkge1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LnRvcCA9IHkgLSB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0geCAtIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LnJpZ2h0ID0geCArIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSA9IHkgKyB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkaXN0YW5jZVRvQm9yZGVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgICAgdGhpcy5yZXNpemUoY3R4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggKiAwLjU7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIENpcmNsZTtcbiAgfShfQ2lyY2xlSW1hZ2VCYXNlMy5kZWZhdWx0KTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBDaXJjbGU7XG5cbi8qKiovIH0sXG4vKiA3MCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgdmFyIF9Ob2RlQmFzZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4KTtcblxuICB2YXIgX05vZGVCYXNlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX05vZGVCYXNlMik7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG4gIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4gIHZhciBDaXJjbGVJbWFnZUJhc2UgPSBmdW5jdGlvbiAoX05vZGVCYXNlKSB7XG4gICAgX2luaGVyaXRzKENpcmNsZUltYWdlQmFzZSwgX05vZGVCYXNlKTtcblxuICAgIGZ1bmN0aW9uIENpcmNsZUltYWdlQmFzZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENpcmNsZUltYWdlQmFzZSk7XG5cbiAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihDaXJjbGVJbWFnZUJhc2UpLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpKTtcblxuICAgICAgX3RoaXMubGFiZWxPZmZzZXQgPSAwO1xuICAgICAgX3RoaXMuaW1hZ2VMb2FkZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQ2lyY2xlSW1hZ2VCYXNlLCBbe1xuICAgICAga2V5OiAnc2V0T3B0aW9ucycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zLCBpbWFnZU9iaikge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICBpZiAoaW1hZ2VPYmopIHtcbiAgICAgICAgICB0aGlzLmltYWdlT2JqID0gaW1hZ2VPYmo7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIGZ1bmN0aW9uIHJlc2l6ZXMgdGhlIGltYWdlIGJ5IHRoZSBvcHRpb25zIHNpemUgd2hlbiB0aGUgaW1hZ2UgaGFzIG5vdCB5ZXQgbG9hZGVkLiBJZiB0aGUgaW1hZ2UgaGFzIGxvYWRlZCwgd2VcbiAgICAgICAqIGZvcmNlIHRoZSB1cGRhdGUgb2YgdGhlIHNpemUgYWdhaW4uXG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3Jlc2l6ZUltYWdlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzaXplSW1hZ2UoKSB7XG4gICAgICAgIHZhciBmb3JjZSA9IGZhbHNlO1xuICAgICAgICBpZiAoIXRoaXMuaW1hZ2VPYmoud2lkdGggfHwgIXRoaXMuaW1hZ2VPYmouaGVpZ2h0KSB7XG4gICAgICAgICAgLy8gdW5kZWZpbmVkIG9yIDBcbiAgICAgICAgICB0aGlzLmltYWdlTG9hZGVkID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pbWFnZUxvYWRlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLmltYWdlTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICBmb3JjZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMud2lkdGggfHwgIXRoaXMuaGVpZ2h0IHx8IGZvcmNlID09PSB0cnVlKSB7XG4gICAgICAgICAgLy8gdW5kZWZpbmVkIG9yIDBcbiAgICAgICAgICB2YXIgd2lkdGgsIGhlaWdodCwgcmF0aW87XG4gICAgICAgICAgaWYgKHRoaXMuaW1hZ2VPYmoud2lkdGggJiYgdGhpcy5pbWFnZU9iai5oZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIG5vdCB1bmRlZmluZWQgb3IgMFxuICAgICAgICAgICAgd2lkdGggPSAwO1xuICAgICAgICAgICAgaGVpZ2h0ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMudXNlSW1hZ2VTaXplID09PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW1hZ2VPYmoud2lkdGggPiB0aGlzLmltYWdlT2JqLmhlaWdodCkge1xuICAgICAgICAgICAgICByYXRpbyA9IHRoaXMuaW1hZ2VPYmoud2lkdGggLyB0aGlzLmltYWdlT2JqLmhlaWdodDtcbiAgICAgICAgICAgICAgd2lkdGggPSB0aGlzLm9wdGlvbnMuc2l6ZSAqIDIgKiByYXRpbyB8fCB0aGlzLmltYWdlT2JqLndpZHRoO1xuICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLm9wdGlvbnMuc2l6ZSAqIDIgfHwgdGhpcy5pbWFnZU9iai5oZWlnaHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAodGhpcy5pbWFnZU9iai53aWR0aCAmJiB0aGlzLmltYWdlT2JqLmhlaWdodCkge1xuICAgICAgICAgICAgICAgIC8vIG5vdCB1bmRlZmluZWQgb3IgMFxuICAgICAgICAgICAgICAgIHJhdGlvID0gdGhpcy5pbWFnZU9iai5oZWlnaHQgLyB0aGlzLmltYWdlT2JqLndpZHRoO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJhdGlvID0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3aWR0aCA9IHRoaXMub3B0aW9ucy5zaXplICogMjtcbiAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5vcHRpb25zLnNpemUgKiAyICogcmF0aW87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHdoZW4gbm90IHVzaW5nIHRoZSBzaXplIHByb3BlcnR5LCB3ZSB1c2UgdGhlIGltYWdlIHNpemVcbiAgICAgICAgICAgIHdpZHRoID0gdGhpcy5pbWFnZU9iai53aWR0aDtcbiAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuaW1hZ2VPYmouaGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgdGhpcy5yYWRpdXMgPSAwLjUgKiB0aGlzLndpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2RyYXdSYXdDaXJjbGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3UmF3Q2lyY2xlKGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCBzaXplKSB7XG4gICAgICAgIHZhciBuZXV0cmFsYm9yZGVyV2lkdGggPSB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgICAgIHZhciBzZWxlY3Rpb25MaW5lV2lkdGggPSB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGhTZWxlY3RlZCB8fCAyICogdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoO1xuICAgICAgICB2YXIgYm9yZGVyV2lkdGggPSAoc2VsZWN0ZWQgPyBzZWxlY3Rpb25MaW5lV2lkdGggOiBuZXV0cmFsYm9yZGVyV2lkdGgpIC8gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBNYXRoLm1pbih0aGlzLndpZHRoLCBib3JkZXJXaWR0aCk7XG5cbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc2VsZWN0ZWQgPyB0aGlzLm9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0LmJvcmRlciA6IGhvdmVyID8gdGhpcy5vcHRpb25zLmNvbG9yLmhvdmVyLmJvcmRlciA6IHRoaXMub3B0aW9ucy5jb2xvci5ib3JkZXI7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBzZWxlY3RlZCA/IHRoaXMub3B0aW9ucy5jb2xvci5oaWdobGlnaHQuYmFja2dyb3VuZCA6IGhvdmVyID8gdGhpcy5vcHRpb25zLmNvbG9yLmhvdmVyLmJhY2tncm91bmQgOiB0aGlzLm9wdGlvbnMuY29sb3IuYmFja2dyb3VuZDtcbiAgICAgICAgY3R4LmNpcmNsZSh4LCB5LCBzaXplKTtcblxuICAgICAgICAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG4gICAgICAgIHRoaXMuZW5hYmxlU2hhZG93KGN0eCk7XG4gICAgICAgIC8vIGRyYXcgdGhlIGJhY2tncm91bmRcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgLy8gZGlzYWJsZSBzaGFkb3dzIGZvciBvdGhlciBlbGVtZW50cy5cbiAgICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCk7XG5cbiAgICAgICAgLy9kcmF3IGRhc2hlZCBib3JkZXIgaWYgZW5hYmxlZCwgc2F2ZSBhbmQgcmVzdG9yZSBpcyByZXF1aXJlZCBmb3IgZmlyZWZveCBub3QgdG8gY3Jhc2ggb24gdW5peC5cbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgLy8gaWYgYm9yZGVycyBhcmUgemVybyB3aWR0aCwgdGhleSB3aWxsIGJlIGRyYXduIHdpdGggd2lkdGggMSBieSBkZWZhdWx0LiBUaGlzIHByZXZlbnRzIHRoYXRcbiAgICAgICAgaWYgKGJvcmRlcldpZHRoID4gMCkge1xuICAgICAgICAgIHRoaXMuZW5hYmxlQm9yZGVyRGFzaGVzKGN0eCk7XG4gICAgICAgICAgLy9kcmF3IHRoZSBib3JkZXJcbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgLy9kaXNhYmxlIGRhc2hlZCBib3JkZXIgZm9yIG90aGVyIGVsZW1lbnRzXG4gICAgICAgICAgdGhpcy5kaXNhYmxlQm9yZGVyRGFzaGVzKGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZHJhd0ltYWdlQXRQb3NpdGlvbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdJbWFnZUF0UG9zaXRpb24oY3R4KSB7XG4gICAgICAgIGlmICh0aGlzLmltYWdlT2JqLndpZHRoICE9IDApIHtcbiAgICAgICAgICAvLyBkcmF3IHRoZSBpbWFnZVxuICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDEuMDtcblxuICAgICAgICAgIC8vIGRyYXcgc2hhZG93IGlmIGVuYWJsZWRcbiAgICAgICAgICB0aGlzLmVuYWJsZVNoYWRvdyhjdHgpO1xuXG4gICAgICAgICAgdmFyIGZhY3RvciA9IHRoaXMuaW1hZ2VPYmoud2lkdGggLyB0aGlzLndpZHRoIC8gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICAgICAgaWYgKGZhY3RvciA+IDIgJiYgdGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5pbnRlcnBvbGF0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgdyA9IHRoaXMuaW1hZ2VPYmoud2lkdGg7XG4gICAgICAgICAgICB2YXIgaCA9IHRoaXMuaW1hZ2VPYmouaGVpZ2h0O1xuICAgICAgICAgICAgdmFyIGNhbjIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIGNhbjIud2lkdGggPSB3O1xuICAgICAgICAgICAgY2FuMi5oZWlnaHQgPSB3O1xuICAgICAgICAgICAgdmFyIGN0eDIgPSBjYW4yLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgIGZhY3RvciAqPSAwLjU7XG4gICAgICAgICAgICB3ICo9IDAuNTtcbiAgICAgICAgICAgIGggKj0gMC41O1xuICAgICAgICAgICAgY3R4Mi5kcmF3SW1hZ2UodGhpcy5pbWFnZU9iaiwgMCwgMCwgdywgaCk7XG5cbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IDA7XG4gICAgICAgICAgICB2YXIgaXRlcmF0aW9ucyA9IDE7XG4gICAgICAgICAgICB3aGlsZSAoZmFjdG9yID4gMiAmJiBpdGVyYXRpb25zIDwgNCkge1xuICAgICAgICAgICAgICBjdHgyLmRyYXdJbWFnZShjYW4yLCBkaXN0YW5jZSwgMCwgdywgaCwgZGlzdGFuY2UgKyB3LCAwLCB3IC8gMiwgaCAvIDIpO1xuICAgICAgICAgICAgICBkaXN0YW5jZSArPSB3O1xuICAgICAgICAgICAgICBmYWN0b3IgKj0gMC41O1xuICAgICAgICAgICAgICB3ICo9IDAuNTtcbiAgICAgICAgICAgICAgaCAqPSAwLjU7XG4gICAgICAgICAgICAgIGl0ZXJhdGlvbnMgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoY2FuMiwgZGlzdGFuY2UsIDAsIHcsIGgsIHRoaXMubGVmdCwgdGhpcy50b3AsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZHJhdyBpbWFnZVxuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLmltYWdlT2JqLCB0aGlzLmxlZnQsIHRoaXMudG9wLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZGlzYWJsZSBzaGFkb3dzIGZvciBvdGhlciBlbGVtZW50cy5cbiAgICAgICAgICB0aGlzLmRpc2FibGVTaGFkb3coY3R4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19kcmF3SW1hZ2VMYWJlbCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdJbWFnZUxhYmVsKGN0eCwgeCwgeSwgc2VsZWN0ZWQpIHtcbiAgICAgICAgdmFyIHlMYWJlbDtcbiAgICAgICAgdmFyIG9mZnNldCA9IDA7XG5cbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBvZmZzZXQgPSB0aGlzLmhlaWdodCAqIDAuNTtcbiAgICAgICAgICB2YXIgbGFiZWxEaW1lbnNpb25zID0gdGhpcy5sYWJlbE1vZHVsZS5nZXRUZXh0U2l6ZShjdHgpO1xuICAgICAgICAgIGlmIChsYWJlbERpbWVuc2lvbnMubGluZUNvdW50ID49IDEpIHtcbiAgICAgICAgICAgIG9mZnNldCArPSBsYWJlbERpbWVuc2lvbnMuaGVpZ2h0IC8gMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB5TGFiZWwgPSB5ICsgb2Zmc2V0O1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGFiZWwpIHtcbiAgICAgICAgICB0aGlzLmxhYmVsT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFiZWxNb2R1bGUuZHJhdyhjdHgsIHgsIHlMYWJlbCwgc2VsZWN0ZWQsICdoYW5naW5nJyk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIENpcmNsZUltYWdlQmFzZTtcbiAgfShfTm9kZUJhc2UzLmRlZmF1bHQpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IENpcmNsZUltYWdlQmFzZTtcblxuLyoqKi8gfSxcbi8qIDcxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX0NpcmNsZUltYWdlQmFzZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwKTtcblxuICB2YXIgX0NpcmNsZUltYWdlQmFzZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DaXJjbGVJbWFnZUJhc2UyKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbiAgdmFyIENpcmN1bGFySW1hZ2UgPSBmdW5jdGlvbiAoX0NpcmNsZUltYWdlQmFzZSkge1xuICAgIF9pbmhlcml0cyhDaXJjdWxhckltYWdlLCBfQ2lyY2xlSW1hZ2VCYXNlKTtcblxuICAgIGZ1bmN0aW9uIENpcmN1bGFySW1hZ2Uob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUsIGltYWdlT2JqKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2lyY3VsYXJJbWFnZSk7XG5cbiAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihDaXJjdWxhckltYWdlKS5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSk7XG5cbiAgICAgIF90aGlzLmltYWdlT2JqID0gaW1hZ2VPYmo7XG4gICAgICBfdGhpcy5fc3dhcFRvSW1hZ2VSZXNpemVXaGVuSW1hZ2VMb2FkZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhDaXJjdWxhckltYWdlLCBbe1xuICAgICAga2V5OiAncmVzaXplJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLmltYWdlT2JqLnNyYyA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuaW1hZ2VPYmoud2lkdGggPT09IHVuZGVmaW5lZCB8fCB0aGlzLmltYWdlT2JqLmhlaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLndpZHRoKSB7XG4gICAgICAgICAgICB2YXIgZGlhbWV0ZXIgPSB0aGlzLm9wdGlvbnMuc2l6ZSAqIDI7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gZGlhbWV0ZXI7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGRpYW1ldGVyO1xuICAgICAgICAgICAgdGhpcy5fc3dhcFRvSW1hZ2VSZXNpemVXaGVuSW1hZ2VMb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5yYWRpdXMgPSAwLjUgKiB0aGlzLndpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5fc3dhcFRvSW1hZ2VSZXNpemVXaGVuSW1hZ2VMb2FkZWQpIHtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuX3N3YXBUb0ltYWdlUmVzaXplV2hlbkltYWdlTG9hZGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3Jlc2l6ZUltYWdlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkcmF3JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICAgIHRoaXMucmVzaXplKCk7XG5cbiAgICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggLyAyO1xuICAgICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAvIDI7XG5cbiAgICAgICAgdmFyIHNpemUgPSBNYXRoLm1pbigwLjUgKiB0aGlzLmhlaWdodCwgMC41ICogdGhpcy53aWR0aCk7XG5cbiAgICAgICAgLy8gZHJhdyB0aGUgYmFja2dyb3VuZCBjaXJjbGUuIElNUE9SVEFOVDogdGhlIHN0cm9rZSBpbiB0aGlzIG1ldGhvZCBpcyB1c2VkIGJ5IHRoZSBjbGlwIG1ldGhvZCBiZWxvdy5cbiAgICAgICAgdGhpcy5fZHJhd1Jhd0NpcmNsZShjdHgsIHgsIHksIHNlbGVjdGVkLCBob3Zlciwgc2l6ZSk7XG5cbiAgICAgICAgLy8gbm93IHdlIGRyYXcgaW4gdGhlIGNpcmNsZSwgd2Ugc2F2ZSBzbyB3ZSBjYW4gcmV2ZXJ0IHRoZSBjbGlwIG9wZXJhdGlvbiBhZnRlciBkcmF3aW5nLlxuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAvLyBjbGlwIGlzIHVzZWQgdG8gdXNlIHRoZSBzdHJva2UgaW4gZHJhd1Jhd0NpcmNsZSBhcyBhbiBhcmVhIHRoYXQgd2UgY2FuIGRyYXcgaW4uXG4gICAgICAgIGN0eC5jbGlwKCk7XG4gICAgICAgIC8vIGRyYXcgdGhlIGltYWdlXG4gICAgICAgIHRoaXMuX2RyYXdJbWFnZUF0UG9zaXRpb24oY3R4KTtcbiAgICAgICAgLy8gcmVzdG9yZSBzbyB3ZSBjYW4gYWdhaW4gZHJhdyBvbiB0aGUgZnVsbCBjYW52YXNcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgICB0aGlzLl9kcmF3SW1hZ2VMYWJlbChjdHgsIHgsIHksIHNlbGVjdGVkKTtcblxuICAgICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nQm94KHgsIHkpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3VwZGF0ZUJvdW5kaW5nQm94JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVCb3VuZGluZ0JveCh4LCB5KSB7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gudG9wID0geSAtIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSB4IC0gdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSB4ICsgdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0geSArIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSBNYXRoLm1pbih0aGlzLmJvdW5kaW5nQm94LmxlZnQsIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5sZWZ0KTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5yaWdodCA9IE1hdGgubWF4KHRoaXMuYm91bmRpbmdCb3gucmlnaHQsIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5sZWZ0ICsgdGhpcy5sYWJlbE1vZHVsZS5zaXplLndpZHRoKTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gPSBNYXRoLm1heCh0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSwgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gKyB0aGlzLmxhYmVsT2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkaXN0YW5jZVRvQm9yZGVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgICAgdGhpcy5yZXNpemUoY3R4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggKiAwLjU7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIENpcmN1bGFySW1hZ2U7XG4gIH0oX0NpcmNsZUltYWdlQmFzZTMuZGVmYXVsdCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gQ2lyY3VsYXJJbWFnZTtcblxuLyoqKi8gfSxcbi8qIDcyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX05vZGVCYXNlMiA9IF9fd2VicGFja19yZXF1aXJlX18oNjgpO1xuXG4gIHZhciBfTm9kZUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTm9kZUJhc2UyKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbiAgdmFyIERhdGFiYXNlID0gZnVuY3Rpb24gKF9Ob2RlQmFzZSkge1xuICAgIF9pbmhlcml0cyhEYXRhYmFzZSwgX05vZGVCYXNlKTtcblxuICAgIGZ1bmN0aW9uIERhdGFiYXNlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGF0YWJhc2UpO1xuXG4gICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKERhdGFiYXNlKS5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKERhdGFiYXNlLCBbe1xuICAgICAga2V5OiAncmVzaXplJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoY3R4LCBzZWxlY3RlZCkge1xuICAgICAgICBpZiAodGhpcy53aWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIG1hcmdpbiA9IDU7XG4gICAgICAgICAgdmFyIHRleHRTaXplID0gdGhpcy5sYWJlbE1vZHVsZS5nZXRUZXh0U2l6ZShjdHgsIHNlbGVjdGVkKTtcbiAgICAgICAgICB2YXIgc2l6ZSA9IHRleHRTaXplLndpZHRoICsgMiAqIG1hcmdpbjtcbiAgICAgICAgICB0aGlzLndpZHRoID0gc2l6ZTtcbiAgICAgICAgICB0aGlzLmhlaWdodCA9IHNpemU7XG4gICAgICAgICAgdGhpcy5yYWRpdXMgPSAwLjUgKiB0aGlzLndpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZHJhdycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgICB0aGlzLnJlc2l6ZShjdHgsIHNlbGVjdGVkKTtcbiAgICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggLyAyO1xuICAgICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAvIDI7XG5cbiAgICAgICAgdmFyIG5ldXRyYWxib3JkZXJXaWR0aCA9IHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgICAgICAgdmFyIHNlbGVjdGlvbkxpbmVXaWR0aCA9IHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aFNlbGVjdGVkIHx8IDIgKiB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgICAgIHZhciBib3JkZXJXaWR0aCA9IChzZWxlY3RlZCA/IHNlbGVjdGlvbkxpbmVXaWR0aCA6IG5ldXRyYWxib3JkZXJXaWR0aCkgLyB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IE1hdGgubWluKHRoaXMud2lkdGgsIGJvcmRlcldpZHRoKTtcblxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzZWxlY3RlZCA/IHRoaXMub3B0aW9ucy5jb2xvci5oaWdobGlnaHQuYm9yZGVyIDogaG92ZXIgPyB0aGlzLm9wdGlvbnMuY29sb3IuaG92ZXIuYm9yZGVyIDogdGhpcy5vcHRpb25zLmNvbG9yLmJvcmRlcjtcblxuICAgICAgICBjdHguZmlsbFN0eWxlID0gc2VsZWN0ZWQgPyB0aGlzLm9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0LmJhY2tncm91bmQgOiBob3ZlciA/IHRoaXMub3B0aW9ucy5jb2xvci5ob3Zlci5iYWNrZ3JvdW5kIDogdGhpcy5vcHRpb25zLmNvbG9yLmJhY2tncm91bmQ7XG4gICAgICAgIGN0eC5kYXRhYmFzZSh4IC0gdGhpcy53aWR0aCAvIDIsIHkgLSB0aGlzLmhlaWdodCAqIDAuNSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXG4gICAgICAgIC8vIGRyYXcgc2hhZG93IGlmIGVuYWJsZWRcbiAgICAgICAgdGhpcy5lbmFibGVTaGFkb3coY3R4KTtcbiAgICAgICAgLy8gZHJhdyB0aGUgYmFja2dyb3VuZFxuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAvLyBkaXNhYmxlIHNoYWRvd3MgZm9yIG90aGVyIGVsZW1lbnRzLlxuICAgICAgICB0aGlzLmRpc2FibGVTaGFkb3coY3R4KTtcblxuICAgICAgICAvL2RyYXcgZGFzaGVkIGJvcmRlciBpZiBlbmFibGVkLCBzYXZlIGFuZCByZXN0b3JlIGlzIHJlcXVpcmVkIGZvciBmaXJlZm94IG5vdCB0byBjcmFzaCBvbiB1bml4LlxuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAvLyBpZiBib3JkZXJzIGFyZSB6ZXJvIHdpZHRoLCB0aGV5IHdpbGwgYmUgZHJhd24gd2l0aCB3aWR0aCAxIGJ5IGRlZmF1bHQuIFRoaXMgcHJldmVudHMgdGhhdFxuICAgICAgICBpZiAoYm9yZGVyV2lkdGggPiAwKSB7XG4gICAgICAgICAgdGhpcy5lbmFibGVCb3JkZXJEYXNoZXMoY3R4KTtcbiAgICAgICAgICAvL2RyYXcgdGhlIGJvcmRlclxuICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAvL2Rpc2FibGUgZGFzaGVkIGJvcmRlciBmb3Igb3RoZXIgZWxlbWVudHNcbiAgICAgICAgICB0aGlzLmRpc2FibGVCb3JkZXJEYXNoZXMoY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdCb3goeCwgeSwgY3R4LCBzZWxlY3RlZCk7XG4gICAgICAgIHRoaXMubGFiZWxNb2R1bGUuZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICd1cGRhdGVCb3VuZGluZ0JveCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQm91bmRpbmdCb3goeCwgeSwgY3R4LCBzZWxlY3RlZCkge1xuICAgICAgICB0aGlzLnJlc2l6ZShjdHgsIHNlbGVjdGVkKTtcblxuICAgICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAqIDAuNTtcbiAgICAgICAgdGhpcy50b3AgPSB5IC0gdGhpcy5oZWlnaHQgKiAwLjU7XG5cbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0gdGhpcy5sZWZ0O1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LnRvcCA9IHRoaXMudG9wO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSA9IHRoaXMudG9wICsgdGhpcy5oZWlnaHQ7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSB0aGlzLmxlZnQgKyB0aGlzLndpZHRoO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Rpc3RhbmNlVG9Cb3JkZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gRGF0YWJhc2U7XG4gIH0oX05vZGVCYXNlMy5kZWZhdWx0KTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBEYXRhYmFzZTtcblxuLyoqKi8gfSxcbi8qIDczICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX1NoYXBlQmFzZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0KTtcblxuICB2YXIgX1NoYXBlQmFzZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TaGFwZUJhc2UyKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbiAgdmFyIERpYW1vbmQgPSBmdW5jdGlvbiAoX1NoYXBlQmFzZSkge1xuICAgIF9pbmhlcml0cyhEaWFtb25kLCBfU2hhcGVCYXNlKTtcblxuICAgIGZ1bmN0aW9uIERpYW1vbmQob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEaWFtb25kKTtcblxuICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihEaWFtb25kKS5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKERpYW1vbmQsIFt7XG4gICAgICBrZXk6ICdyZXNpemUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShjdHgpIHtcbiAgICAgICAgdGhpcy5fcmVzaXplU2hhcGUoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkcmF3JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICAgIHRoaXMuX2RyYXdTaGFwZShjdHgsICdkaWFtb25kJywgNCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkaXN0YW5jZVRvQm9yZGVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIERpYW1vbmQ7XG4gIH0oX1NoYXBlQmFzZTMuZGVmYXVsdCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gRGlhbW9uZDtcblxuLyoqKi8gfSxcbi8qIDc0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX05vZGVCYXNlMiA9IF9fd2VicGFja19yZXF1aXJlX18oNjgpO1xuXG4gIHZhciBfTm9kZUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTm9kZUJhc2UyKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbiAgdmFyIFNoYXBlQmFzZSA9IGZ1bmN0aW9uIChfTm9kZUJhc2UpIHtcbiAgICBfaW5oZXJpdHMoU2hhcGVCYXNlLCBfTm9kZUJhc2UpO1xuXG4gICAgZnVuY3Rpb24gU2hhcGVCYXNlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2hhcGVCYXNlKTtcblxuICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihTaGFwZUJhc2UpLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoU2hhcGVCYXNlLCBbe1xuICAgICAga2V5OiAnX3Jlc2l6ZVNoYXBlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzaXplU2hhcGUoKSB7XG4gICAgICAgIGlmICh0aGlzLndpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgc2l6ZSA9IDIgKiB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgICAgICB0aGlzLndpZHRoID0gc2l6ZTtcbiAgICAgICAgICB0aGlzLmhlaWdodCA9IHNpemU7XG4gICAgICAgICAgdGhpcy5yYWRpdXMgPSAwLjUgKiB0aGlzLndpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2RyYXdTaGFwZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdTaGFwZShjdHgsIHNoYXBlLCBzaXplTXVsdGlwbGllciwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICAgIHRoaXMuX3Jlc2l6ZVNoYXBlKCk7XG5cbiAgICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggLyAyO1xuICAgICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAvIDI7XG5cbiAgICAgICAgdmFyIG5ldXRyYWxib3JkZXJXaWR0aCA9IHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgICAgICAgdmFyIHNlbGVjdGlvbkxpbmVXaWR0aCA9IHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aFNlbGVjdGVkIHx8IDIgKiB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgICAgIHZhciBib3JkZXJXaWR0aCA9IChzZWxlY3RlZCA/IHNlbGVjdGlvbkxpbmVXaWR0aCA6IG5ldXRyYWxib3JkZXJXaWR0aCkgLyB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IE1hdGgubWluKHRoaXMud2lkdGgsIGJvcmRlcldpZHRoKTtcblxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzZWxlY3RlZCA/IHRoaXMub3B0aW9ucy5jb2xvci5oaWdobGlnaHQuYm9yZGVyIDogaG92ZXIgPyB0aGlzLm9wdGlvbnMuY29sb3IuaG92ZXIuYm9yZGVyIDogdGhpcy5vcHRpb25zLmNvbG9yLmJvcmRlcjtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHNlbGVjdGVkID8gdGhpcy5vcHRpb25zLmNvbG9yLmhpZ2hsaWdodC5iYWNrZ3JvdW5kIDogaG92ZXIgPyB0aGlzLm9wdGlvbnMuY29sb3IuaG92ZXIuYmFja2dyb3VuZCA6IHRoaXMub3B0aW9ucy5jb2xvci5iYWNrZ3JvdW5kO1xuICAgICAgICBjdHhbc2hhcGVdKHgsIHksIHRoaXMub3B0aW9ucy5zaXplKTtcblxuICAgICAgICAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG4gICAgICAgIHRoaXMuZW5hYmxlU2hhZG93KGN0eCk7XG4gICAgICAgIC8vIGRyYXcgdGhlIGJhY2tncm91bmRcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgLy8gZGlzYWJsZSBzaGFkb3dzIGZvciBvdGhlciBlbGVtZW50cy5cbiAgICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCk7XG5cbiAgICAgICAgLy9kcmF3IGRhc2hlZCBib3JkZXIgaWYgZW5hYmxlZCwgc2F2ZSBhbmQgcmVzdG9yZSBpcyByZXF1aXJlZCBmb3IgZmlyZWZveCBub3QgdG8gY3Jhc2ggb24gdW5peC5cbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgLy8gaWYgYm9yZGVycyBhcmUgemVybyB3aWR0aCwgdGhleSB3aWxsIGJlIGRyYXduIHdpdGggd2lkdGggMSBieSBkZWZhdWx0LiBUaGlzIHByZXZlbnRzIHRoYXRcbiAgICAgICAgaWYgKGJvcmRlcldpZHRoID4gMCkge1xuICAgICAgICAgIHRoaXMuZW5hYmxlQm9yZGVyRGFzaGVzKGN0eCk7XG4gICAgICAgICAgLy9kcmF3IHRoZSBib3JkZXJcbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgLy9kaXNhYmxlIGRhc2hlZCBib3JkZXIgZm9yIG90aGVyIGVsZW1lbnRzXG4gICAgICAgICAgdGhpcy5kaXNhYmxlQm9yZGVyRGFzaGVzKGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxhYmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgeUxhYmVsID0geSArIDAuNSAqIHRoaXMuaGVpZ2h0ICsgMzsgLy8gdGhlICsgMyBpcyB0byBvZmZzZXQgaXQgYSBiaXQgYmVsb3cgdGhlIG5vZGUuXG4gICAgICAgICAgdGhpcy5sYWJlbE1vZHVsZS5kcmF3KGN0eCwgeCwgeUxhYmVsLCBzZWxlY3RlZCwgJ2hhbmdpbmcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdCb3goeCwgeSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAndXBkYXRlQm91bmRpbmdCb3gnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kaW5nQm94KHgsIHkpIHtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC50b3AgPSB5IC0gdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gubGVmdCA9IHggLSB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5yaWdodCA9IHggKyB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gPSB5ICsgdGhpcy5vcHRpb25zLnNpemU7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sYWJlbCAhPT0gdW5kZWZpbmVkICYmIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS53aWR0aCA+IDApIHtcbiAgICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSBNYXRoLm1pbih0aGlzLmJvdW5kaW5nQm94LmxlZnQsIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5sZWZ0KTtcbiAgICAgICAgICB0aGlzLmJvdW5kaW5nQm94LnJpZ2h0ID0gTWF0aC5tYXgodGhpcy5ib3VuZGluZ0JveC5yaWdodCwgdGhpcy5sYWJlbE1vZHVsZS5zaXplLmxlZnQgKyB0aGlzLmxhYmVsTW9kdWxlLnNpemUud2lkdGgpO1xuICAgICAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0gTWF0aC5tYXgodGhpcy5ib3VuZGluZ0JveC5ib3R0b20sIHRoaXMuYm91bmRpbmdCb3guYm90dG9tICsgdGhpcy5sYWJlbE1vZHVsZS5zaXplLmhlaWdodCArIDMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFNoYXBlQmFzZTtcbiAgfShfTm9kZUJhc2UzLmRlZmF1bHQpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IFNoYXBlQmFzZTtcblxuLyoqKi8gfSxcbi8qIDc1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX1NoYXBlQmFzZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0KTtcblxuICB2YXIgX1NoYXBlQmFzZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TaGFwZUJhc2UyKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbiAgdmFyIERvdCA9IGZ1bmN0aW9uIChfU2hhcGVCYXNlKSB7XG4gICAgX2luaGVyaXRzKERvdCwgX1NoYXBlQmFzZSk7XG5cbiAgICBmdW5jdGlvbiBEb3Qob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEb3QpO1xuXG4gICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKERvdCkuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhEb3QsIFt7XG4gICAgICBrZXk6ICdyZXNpemUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShjdHgpIHtcbiAgICAgICAgdGhpcy5fcmVzaXplU2hhcGUoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkcmF3JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICAgIHRoaXMuX2RyYXdTaGFwZShjdHgsICdjaXJjbGUnLCAyLCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Rpc3RhbmNlVG9Cb3JkZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgICB0aGlzLnJlc2l6ZShjdHgpO1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIERvdDtcbiAgfShfU2hhcGVCYXNlMy5kZWZhdWx0KTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBEb3Q7XG5cbi8qKiovIH0sXG4vKiA3NiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgdmFyIF9Ob2RlQmFzZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4KTtcblxuICB2YXIgX05vZGVCYXNlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX05vZGVCYXNlMik7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG4gIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4gIHZhciBFbGxpcHNlID0gZnVuY3Rpb24gKF9Ob2RlQmFzZSkge1xuICAgIF9pbmhlcml0cyhFbGxpcHNlLCBfTm9kZUJhc2UpO1xuXG4gICAgZnVuY3Rpb24gRWxsaXBzZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVsbGlwc2UpO1xuXG4gICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKEVsbGlwc2UpLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoRWxsaXBzZSwgW3tcbiAgICAgIGtleTogJ3Jlc2l6ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKGN0eCwgc2VsZWN0ZWQpIHtcbiAgICAgICAgaWYgKHRoaXMud2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciB0ZXh0U2l6ZSA9IHRoaXMubGFiZWxNb2R1bGUuZ2V0VGV4dFNpemUoY3R4LCBzZWxlY3RlZCk7XG5cbiAgICAgICAgICB0aGlzLndpZHRoID0gdGV4dFNpemUud2lkdGggKiAxLjU7XG4gICAgICAgICAgdGhpcy5oZWlnaHQgPSB0ZXh0U2l6ZS5oZWlnaHQgKiAyO1xuICAgICAgICAgIGlmICh0aGlzLndpZHRoIDwgdGhpcy5oZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSB0aGlzLmhlaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5yYWRpdXMgPSAwLjUgKiB0aGlzLndpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZHJhdycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgICB0aGlzLnJlc2l6ZShjdHgsIHNlbGVjdGVkKTtcbiAgICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggKiAwLjU7XG4gICAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0ICogMC41O1xuXG4gICAgICAgIHZhciBuZXV0cmFsYm9yZGVyV2lkdGggPSB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgICAgIHZhciBzZWxlY3Rpb25MaW5lV2lkdGggPSB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGhTZWxlY3RlZCB8fCAyICogdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoO1xuICAgICAgICB2YXIgYm9yZGVyV2lkdGggPSAoc2VsZWN0ZWQgPyBzZWxlY3Rpb25MaW5lV2lkdGggOiBuZXV0cmFsYm9yZGVyV2lkdGgpIC8gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBNYXRoLm1pbih0aGlzLndpZHRoLCBib3JkZXJXaWR0aCk7XG5cbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc2VsZWN0ZWQgPyB0aGlzLm9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0LmJvcmRlciA6IGhvdmVyID8gdGhpcy5vcHRpb25zLmNvbG9yLmhvdmVyLmJvcmRlciA6IHRoaXMub3B0aW9ucy5jb2xvci5ib3JkZXI7XG5cbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHNlbGVjdGVkID8gdGhpcy5vcHRpb25zLmNvbG9yLmhpZ2hsaWdodC5iYWNrZ3JvdW5kIDogaG92ZXIgPyB0aGlzLm9wdGlvbnMuY29sb3IuaG92ZXIuYmFja2dyb3VuZCA6IHRoaXMub3B0aW9ucy5jb2xvci5iYWNrZ3JvdW5kO1xuICAgICAgICBjdHguZWxsaXBzZSh0aGlzLmxlZnQsIHRoaXMudG9wLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cbiAgICAgICAgLy8gZHJhdyBzaGFkb3cgaWYgZW5hYmxlZFxuICAgICAgICB0aGlzLmVuYWJsZVNoYWRvdyhjdHgpO1xuICAgICAgICAvLyBkcmF3IHRoZSBiYWNrZ3JvdW5kXG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIC8vIGRpc2FibGUgc2hhZG93cyBmb3Igb3RoZXIgZWxlbWVudHMuXG4gICAgICAgIHRoaXMuZGlzYWJsZVNoYWRvdyhjdHgpO1xuXG4gICAgICAgIC8vZHJhdyBkYXNoZWQgYm9yZGVyIGlmIGVuYWJsZWQsIHNhdmUgYW5kIHJlc3RvcmUgaXMgcmVxdWlyZWQgZm9yIGZpcmVmb3ggbm90IHRvIGNyYXNoIG9uIHVuaXguXG4gICAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgICAgLy8gaWYgYm9yZGVycyBhcmUgemVybyB3aWR0aCwgdGhleSB3aWxsIGJlIGRyYXduIHdpdGggd2lkdGggMSBieSBkZWZhdWx0LiBUaGlzIHByZXZlbnRzIHRoYXRcbiAgICAgICAgaWYgKGJvcmRlcldpZHRoID4gMCkge1xuICAgICAgICAgIHRoaXMuZW5hYmxlQm9yZGVyRGFzaGVzKGN0eCk7XG4gICAgICAgICAgLy9kcmF3IHRoZSBib3JkZXJcbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgLy9kaXNhYmxlIGRhc2hlZCBib3JkZXIgZm9yIG90aGVyIGVsZW1lbnRzXG4gICAgICAgICAgdGhpcy5kaXNhYmxlQm9yZGVyRGFzaGVzKGN0eCk7XG4gICAgICAgIH1cblxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdCb3goeCwgeSwgY3R4LCBzZWxlY3RlZCk7XG4gICAgICAgIHRoaXMubGFiZWxNb2R1bGUuZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICd1cGRhdGVCb3VuZGluZ0JveCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQm91bmRpbmdCb3goeCwgeSwgY3R4LCBzZWxlY3RlZCkge1xuICAgICAgICB0aGlzLnJlc2l6ZShjdHgsIHNlbGVjdGVkKTsgLy8ganVzdCBpbiBjYXNlXG5cbiAgICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggKiAwLjU7XG4gICAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0ICogMC41O1xuXG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gubGVmdCA9IHRoaXMubGVmdDtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC50b3AgPSB0aGlzLnRvcDtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gPSB0aGlzLnRvcCArIHRoaXMuaGVpZ2h0O1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LnJpZ2h0ID0gdGhpcy5sZWZ0ICsgdGhpcy53aWR0aDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkaXN0YW5jZVRvQm9yZGVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgICAgdGhpcy5yZXNpemUoY3R4KTtcbiAgICAgICAgdmFyIGEgPSB0aGlzLndpZHRoICogMC41O1xuICAgICAgICB2YXIgYiA9IHRoaXMuaGVpZ2h0ICogMC41O1xuICAgICAgICB2YXIgdyA9IE1hdGguc2luKGFuZ2xlKSAqIGE7XG4gICAgICAgIHZhciBoID0gTWF0aC5jb3MoYW5nbGUpICogYjtcbiAgICAgICAgcmV0dXJuIGEgKiBiIC8gTWF0aC5zcXJ0KHcgKiB3ICsgaCAqIGgpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBFbGxpcHNlO1xuICB9KF9Ob2RlQmFzZTMuZGVmYXVsdCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gRWxsaXBzZTtcblxuLyoqKi8gfSxcbi8qIDc3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX05vZGVCYXNlMiA9IF9fd2VicGFja19yZXF1aXJlX18oNjgpO1xuXG4gIHZhciBfTm9kZUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTm9kZUJhc2UyKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbiAgdmFyIEljb24gPSBmdW5jdGlvbiAoX05vZGVCYXNlKSB7XG4gICAgX2luaGVyaXRzKEljb24sIF9Ob2RlQmFzZSk7XG5cbiAgICBmdW5jdGlvbiBJY29uKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSWNvbik7XG5cbiAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSWNvbikuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhJY29uLCBbe1xuICAgICAga2V5OiAncmVzaXplJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoY3R4KSB7XG4gICAgICAgIGlmICh0aGlzLndpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgbWFyZ2luID0gNTtcbiAgICAgICAgICB2YXIgaWNvblNpemUgPSB7XG4gICAgICAgICAgICB3aWR0aDogTnVtYmVyKHRoaXMub3B0aW9ucy5pY29uLnNpemUpLFxuICAgICAgICAgICAgaGVpZ2h0OiBOdW1iZXIodGhpcy5vcHRpb25zLmljb24uc2l6ZSlcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMud2lkdGggPSBpY29uU2l6ZS53aWR0aCArIDIgKiBtYXJnaW47XG4gICAgICAgICAgdGhpcy5oZWlnaHQgPSBpY29uU2l6ZS5oZWlnaHQgKyAyICogbWFyZ2luO1xuICAgICAgICAgIHRoaXMucmFkaXVzID0gMC41ICogdGhpcy53aWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2RyYXcnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgICAgdGhpcy5yZXNpemUoY3R4KTtcbiAgICAgICAgdGhpcy5vcHRpb25zLmljb24uc2l6ZSA9IHRoaXMub3B0aW9ucy5pY29uLnNpemUgfHwgNTA7XG5cbiAgICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggKiAwLjU7XG4gICAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0ICogMC41O1xuICAgICAgICB0aGlzLl9pY29uKGN0eCwgeCwgeSwgc2VsZWN0ZWQpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGFiZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBpY29uVGV4dFNwYWNpbmcgPSA1O1xuICAgICAgICAgIHRoaXMubGFiZWxNb2R1bGUuZHJhdyhjdHgsIHgsIHkgKyB0aGlzLmhlaWdodCAqIDAuNSArIGljb25UZXh0U3BhY2luZywgc2VsZWN0ZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ0JveCh4LCB5KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICd1cGRhdGVCb3VuZGluZ0JveCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQm91bmRpbmdCb3goeCwgeSkge1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LnRvcCA9IHkgLSB0aGlzLm9wdGlvbnMuaWNvbi5zaXplICogMC41O1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSB4IC0gdGhpcy5vcHRpb25zLmljb24uc2l6ZSAqIDAuNTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5yaWdodCA9IHggKyB0aGlzLm9wdGlvbnMuaWNvbi5zaXplICogMC41O1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSA9IHkgKyB0aGlzLm9wdGlvbnMuaWNvbi5zaXplICogMC41O1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGFiZWwgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmxhYmVsTW9kdWxlLnNpemUud2lkdGggPiAwKSB7XG4gICAgICAgICAgdmFyIGljb25UZXh0U3BhY2luZyA9IDU7XG4gICAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0gTWF0aC5taW4odGhpcy5ib3VuZGluZ0JveC5sZWZ0LCB0aGlzLmxhYmVsTW9kdWxlLnNpemUubGVmdCk7XG4gICAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5yaWdodCA9IE1hdGgubWF4KHRoaXMuYm91bmRpbmdCb3gucmlnaHQsIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5sZWZ0ICsgdGhpcy5sYWJlbE1vZHVsZS5zaXplLndpZHRoKTtcbiAgICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSA9IE1hdGgubWF4KHRoaXMuYm91bmRpbmdCb3guYm90dG9tLCB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSArIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5oZWlnaHQgKyBpY29uVGV4dFNwYWNpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2ljb24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pY29uKGN0eCwgeCwgeSwgc2VsZWN0ZWQpIHtcbiAgICAgICAgdmFyIGljb25TaXplID0gTnVtYmVyKHRoaXMub3B0aW9ucy5pY29uLnNpemUpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaWNvbi5jb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjdHguZm9udCA9IChzZWxlY3RlZCA/IFwiYm9sZCBcIiA6IFwiXCIpICsgaWNvblNpemUgKyBcInB4IFwiICsgdGhpcy5vcHRpb25zLmljb24uZmFjZTtcblxuICAgICAgICAgIC8vIGRyYXcgaWNvblxuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLm9wdGlvbnMuaWNvbi5jb2xvciB8fCBcImJsYWNrXCI7XG4gICAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XG5cbiAgICAgICAgICAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG4gICAgICAgICAgdGhpcy5lbmFibGVTaGFkb3coY3R4KTtcbiAgICAgICAgICBjdHguZmlsbFRleHQodGhpcy5vcHRpb25zLmljb24uY29kZSwgeCwgeSk7XG5cbiAgICAgICAgICAvLyBkaXNhYmxlIHNoYWRvd3MgZm9yIG90aGVyIGVsZW1lbnRzLlxuICAgICAgICAgIHRoaXMuZGlzYWJsZVNoYWRvdyhjdHgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1doZW4gdXNpbmcgdGhlIGljb24gc2hhcGUsIHlvdSBuZWVkIHRvIGRlZmluZSB0aGUgY29kZSBpbiB0aGUgaWNvbiBvcHRpb25zIG9iamVjdC4gVGhpcyBjYW4gYmUgZG9uZSBwZXIgbm9kZSBvciBnbG9iYWxseS4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Rpc3RhbmNlVG9Cb3JkZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gSWNvbjtcbiAgfShfTm9kZUJhc2UzLmRlZmF1bHQpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IEljb247XG5cbi8qKiovIH0sXG4vKiA3OCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgdmFyIF9DaXJjbGVJbWFnZUJhc2UyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MCk7XG5cbiAgdmFyIF9DaXJjbGVJbWFnZUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2lyY2xlSW1hZ2VCYXNlMik7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG4gIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4gIHZhciBJbWFnZSA9IGZ1bmN0aW9uIChfQ2lyY2xlSW1hZ2VCYXNlKSB7XG4gICAgX2luaGVyaXRzKEltYWdlLCBfQ2lyY2xlSW1hZ2VCYXNlKTtcblxuICAgIGZ1bmN0aW9uIEltYWdlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlLCBpbWFnZU9iaikge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEltYWdlKTtcblxuICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKEltYWdlKS5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSk7XG5cbiAgICAgIF90aGlzLmltYWdlT2JqID0gaW1hZ2VPYmo7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEltYWdlLCBbe1xuICAgICAga2V5OiAncmVzaXplJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoKSB7XG4gICAgICAgIHRoaXMuX3Jlc2l6ZUltYWdlKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZHJhdycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0IC8gMjtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy51c2VCb3JkZXJXaXRoSW1hZ2UgPT09IHRydWUpIHtcbiAgICAgICAgICB2YXIgbmV1dHJhbGJvcmRlcldpZHRoID0gdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoO1xuICAgICAgICAgIHZhciBzZWxlY3Rpb25MaW5lV2lkdGggPSB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGhTZWxlY3RlZCB8fCAyICogdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoO1xuICAgICAgICAgIHZhciBib3JkZXJXaWR0aCA9IChzZWxlY3RlZCA/IHNlbGVjdGlvbkxpbmVXaWR0aCA6IG5ldXRyYWxib3JkZXJXaWR0aCkgLyB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgICAgICBjdHgubGluZVdpZHRoID0gTWF0aC5taW4odGhpcy53aWR0aCwgYm9yZGVyV2lkdGgpO1xuXG4gICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgICAgLy8gc2V0dXAgdGhlIGxpbmUgcHJvcGVydGllcy5cbiAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzZWxlY3RlZCA/IHRoaXMub3B0aW9ucy5jb2xvci5oaWdobGlnaHQuYm9yZGVyIDogaG92ZXIgPyB0aGlzLm9wdGlvbnMuY29sb3IuaG92ZXIuYm9yZGVyIDogdGhpcy5vcHRpb25zLmNvbG9yLmJvcmRlcjtcblxuICAgICAgICAgIC8vIHNldCBhIGZpbGxzdHlsZVxuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBzZWxlY3RlZCA/IHRoaXMub3B0aW9ucy5jb2xvci5oaWdobGlnaHQuYmFja2dyb3VuZCA6IGhvdmVyID8gdGhpcy5vcHRpb25zLmNvbG9yLmhvdmVyLmJhY2tncm91bmQgOiB0aGlzLm9wdGlvbnMuY29sb3IuYmFja2dyb3VuZDtcblxuICAgICAgICAgIC8vIGRyYXcgYSByZWN0YW5nbGUgdG8gZm9ybSB0aGUgYm9yZGVyIGFyb3VuZC4gVGhpcyByZWN0YW5nbGUgaXMgZmlsbGVkIHNvIHRoZSBvcGFjaXR5IG9mIGEgcGljdHVyZSAoaW4gZnV0dXJlIHZpcyByZWxlYXNlcz8pIGNhbiBiZSB1c2VkIHRvIHRpbnQgdGhlIGltYWdlXG4gICAgICAgICAgY3R4LnJlY3QodGhpcy5sZWZ0IC0gMC41ICogY3R4LmxpbmVXaWR0aCwgdGhpcy50b3AgLSAwLjUgKiBjdHgubGluZVdpZHRoLCB0aGlzLndpZHRoICsgY3R4LmxpbmVXaWR0aCwgdGhpcy5oZWlnaHQgKyBjdHgubGluZVdpZHRoKTtcbiAgICAgICAgICBjdHguZmlsbCgpO1xuXG4gICAgICAgICAgLy9kcmF3IGRhc2hlZCBib3JkZXIgaWYgZW5hYmxlZCwgc2F2ZSBhbmQgcmVzdG9yZSBpcyByZXF1aXJlZCBmb3IgZmlyZWZveCBub3QgdG8gY3Jhc2ggb24gdW5peC5cbiAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgIC8vIGlmIGJvcmRlcnMgYXJlIHplcm8gd2lkdGgsIHRoZXkgd2lsbCBiZSBkcmF3biB3aXRoIHdpZHRoIDEgYnkgZGVmYXVsdC4gVGhpcyBwcmV2ZW50cyB0aGF0XG4gICAgICAgICAgaWYgKGJvcmRlcldpZHRoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5lbmFibGVCb3JkZXJEYXNoZXMoY3R4KTtcbiAgICAgICAgICAgIC8vZHJhdyB0aGUgYm9yZGVyXG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAvL2Rpc2FibGUgZGFzaGVkIGJvcmRlciBmb3Igb3RoZXIgZWxlbWVudHNcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZUJvcmRlckRhc2hlcyhjdHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZHJhd0ltYWdlQXRQb3NpdGlvbihjdHgpO1xuXG4gICAgICAgIHRoaXMuX2RyYXdJbWFnZUxhYmVsKGN0eCwgeCwgeSwgc2VsZWN0ZWQgfHwgaG92ZXIpO1xuXG4gICAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdCb3goeCwgeSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAndXBkYXRlQm91bmRpbmdCb3gnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kaW5nQm94KHgsIHkpIHtcbiAgICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggLyAyO1xuICAgICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAvIDI7XG5cbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC50b3AgPSB0aGlzLnRvcDtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0gdGhpcy5sZWZ0O1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LnJpZ2h0ID0gdGhpcy5sZWZ0ICsgdGhpcy53aWR0aDtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gPSB0aGlzLnRvcCArIHRoaXMuaGVpZ2h0O1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGFiZWwgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmxhYmVsTW9kdWxlLnNpemUud2lkdGggPiAwKSB7XG4gICAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0gTWF0aC5taW4odGhpcy5ib3VuZGluZ0JveC5sZWZ0LCB0aGlzLmxhYmVsTW9kdWxlLnNpemUubGVmdCk7XG4gICAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5yaWdodCA9IE1hdGgubWF4KHRoaXMuYm91bmRpbmdCb3gucmlnaHQsIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5sZWZ0ICsgdGhpcy5sYWJlbE1vZHVsZS5zaXplLndpZHRoKTtcbiAgICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSA9IE1hdGgubWF4KHRoaXMuYm91bmRpbmdCb3guYm90dG9tLCB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSArIHRoaXMubGFiZWxPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZGlzdGFuY2VUb0JvcmRlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBJbWFnZTtcbiAgfShfQ2lyY2xlSW1hZ2VCYXNlMy5kZWZhdWx0KTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBJbWFnZTtcblxuLyoqKi8gfSxcbi8qIDc5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX1NoYXBlQmFzZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0KTtcblxuICB2YXIgX1NoYXBlQmFzZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TaGFwZUJhc2UyKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbiAgdmFyIFNxdWFyZSA9IGZ1bmN0aW9uIChfU2hhcGVCYXNlKSB7XG4gICAgX2luaGVyaXRzKFNxdWFyZSwgX1NoYXBlQmFzZSk7XG5cbiAgICBmdW5jdGlvbiBTcXVhcmUob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTcXVhcmUpO1xuXG4gICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNxdWFyZSkuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhTcXVhcmUsIFt7XG4gICAgICBrZXk6ICdyZXNpemUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZSgpIHtcbiAgICAgICAgdGhpcy5fcmVzaXplU2hhcGUoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkcmF3JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICAgIHRoaXMuX2RyYXdTaGFwZShjdHgsICdzcXVhcmUnLCAyLCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Rpc3RhbmNlVG9Cb3JkZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gU3F1YXJlO1xuICB9KF9TaGFwZUJhc2UzLmRlZmF1bHQpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IFNxdWFyZTtcblxuLyoqKi8gfSxcbi8qIDgwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX1NoYXBlQmFzZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0KTtcblxuICB2YXIgX1NoYXBlQmFzZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TaGFwZUJhc2UyKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbiAgdmFyIFN0YXIgPSBmdW5jdGlvbiAoX1NoYXBlQmFzZSkge1xuICAgIF9pbmhlcml0cyhTdGFyLCBfU2hhcGVCYXNlKTtcblxuICAgIGZ1bmN0aW9uIFN0YXIob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdGFyKTtcblxuICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihTdGFyKS5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFN0YXIsIFt7XG4gICAgICBrZXk6ICdyZXNpemUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShjdHgpIHtcbiAgICAgICAgdGhpcy5fcmVzaXplU2hhcGUoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkcmF3JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICAgIHRoaXMuX2RyYXdTaGFwZShjdHgsICdzdGFyJywgNCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkaXN0YW5jZVRvQm9yZGVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFN0YXI7XG4gIH0oX1NoYXBlQmFzZTMuZGVmYXVsdCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gU3RhcjtcblxuLyoqKi8gfSxcbi8qIDgxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX05vZGVCYXNlMiA9IF9fd2VicGFja19yZXF1aXJlX18oNjgpO1xuXG4gIHZhciBfTm9kZUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTm9kZUJhc2UyKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbiAgdmFyIFRleHQgPSBmdW5jdGlvbiAoX05vZGVCYXNlKSB7XG4gICAgX2luaGVyaXRzKFRleHQsIF9Ob2RlQmFzZSk7XG5cbiAgICBmdW5jdGlvbiBUZXh0KG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dCk7XG5cbiAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGV4dCkuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhUZXh0LCBbe1xuICAgICAga2V5OiAncmVzaXplJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoY3R4LCBzZWxlY3RlZCkge1xuICAgICAgICBpZiAodGhpcy53aWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIG1hcmdpbiA9IDU7XG4gICAgICAgICAgdmFyIHRleHRTaXplID0gdGhpcy5sYWJlbE1vZHVsZS5nZXRUZXh0U2l6ZShjdHgsIHNlbGVjdGVkKTtcbiAgICAgICAgICB0aGlzLndpZHRoID0gdGV4dFNpemUud2lkdGggKyAyICogbWFyZ2luO1xuICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gdGV4dFNpemUuaGVpZ2h0ICsgMiAqIG1hcmdpbjtcbiAgICAgICAgICB0aGlzLnJhZGl1cyA9IDAuNSAqIHRoaXMud2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkcmF3JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICAgIHRoaXMucmVzaXplKGN0eCwgc2VsZWN0ZWQgfHwgaG92ZXIpO1xuICAgICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0IC8gMjtcblxuICAgICAgICAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG4gICAgICAgIHRoaXMuZW5hYmxlU2hhZG93KGN0eCk7XG4gICAgICAgIHRoaXMubGFiZWxNb2R1bGUuZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkIHx8IGhvdmVyKTtcblxuICAgICAgICAvLyBkaXNhYmxlIHNoYWRvd3MgZm9yIG90aGVyIGVsZW1lbnRzLlxuICAgICAgICB0aGlzLmRpc2FibGVTaGFkb3coY3R4KTtcblxuICAgICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nQm94KHgsIHksIGN0eCwgc2VsZWN0ZWQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3VwZGF0ZUJvdW5kaW5nQm94JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVCb3VuZGluZ0JveCh4LCB5LCBjdHgsIHNlbGVjdGVkKSB7XG4gICAgICAgIHRoaXMucmVzaXplKGN0eCwgc2VsZWN0ZWQpO1xuXG4gICAgICAgIHRoaXMubGVmdCA9IHggLSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgdGhpcy50b3AgPSB5IC0gdGhpcy5oZWlnaHQgLyAyO1xuXG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gudG9wID0gdGhpcy50b3A7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gubGVmdCA9IHRoaXMubGVmdDtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5yaWdodCA9IHRoaXMubGVmdCArIHRoaXMud2lkdGg7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0gdGhpcy50b3AgKyB0aGlzLmhlaWdodDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkaXN0YW5jZVRvQm9yZGVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFRleHQ7XG4gIH0oX05vZGVCYXNlMy5kZWZhdWx0KTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBUZXh0O1xuXG4vKioqLyB9LFxuLyogODIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIHZhciBfU2hhcGVCYXNlMiA9IF9fd2VicGFja19yZXF1aXJlX18oNzQpO1xuXG4gIHZhciBfU2hhcGVCYXNlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NoYXBlQmFzZTIpO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuICBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuICB2YXIgVHJpYW5nbGUgPSBmdW5jdGlvbiAoX1NoYXBlQmFzZSkge1xuICAgIF9pbmhlcml0cyhUcmlhbmdsZSwgX1NoYXBlQmFzZSk7XG5cbiAgICBmdW5jdGlvbiBUcmlhbmdsZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyaWFuZ2xlKTtcblxuICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihUcmlhbmdsZSkuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhUcmlhbmdsZSwgW3tcbiAgICAgIGtleTogJ3Jlc2l6ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKGN0eCkge1xuICAgICAgICB0aGlzLl9yZXNpemVTaGFwZSgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2RyYXcnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgICAgdGhpcy5fZHJhd1NoYXBlKGN0eCwgJ3RyaWFuZ2xlJywgMywgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkaXN0YW5jZVRvQm9yZGVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFRyaWFuZ2xlO1xuICB9KF9TaGFwZUJhc2UzLmRlZmF1bHQpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IFRyaWFuZ2xlO1xuXG4vKioqLyB9LFxuLyogODMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIHZhciBfU2hhcGVCYXNlMiA9IF9fd2VicGFja19yZXF1aXJlX18oNzQpO1xuXG4gIHZhciBfU2hhcGVCYXNlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NoYXBlQmFzZTIpO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuICBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuICB2YXIgVHJpYW5nbGVEb3duID0gZnVuY3Rpb24gKF9TaGFwZUJhc2UpIHtcbiAgICBfaW5oZXJpdHMoVHJpYW5nbGVEb3duLCBfU2hhcGVCYXNlKTtcblxuICAgIGZ1bmN0aW9uIFRyaWFuZ2xlRG93bihvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyaWFuZ2xlRG93bik7XG5cbiAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVHJpYW5nbGVEb3duKS5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFRyaWFuZ2xlRG93biwgW3tcbiAgICAgIGtleTogJ3Jlc2l6ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKGN0eCkge1xuICAgICAgICB0aGlzLl9yZXNpemVTaGFwZSgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2RyYXcnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgICAgdGhpcy5fZHJhd1NoYXBlKGN0eCwgJ3RyaWFuZ2xlRG93bicsIDMsIHgsIHksIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZGlzdGFuY2VUb0JvcmRlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBUcmlhbmdsZURvd247XG4gIH0oX1NoYXBlQmFzZTMuZGVmYXVsdCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gVHJpYW5nbGVEb3duO1xuXG4vKioqLyB9LFxuLyogODQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIHZhciBfRWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oODUpO1xuXG4gIHZhciBfRWRnZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9FZGdlKTtcblxuICB2YXIgX0xhYmVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nik7XG5cbiAgdmFyIF9MYWJlbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9MYWJlbCk7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbiAgdmFyIERhdGFTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuICB2YXIgRGF0YVZpZXcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxuICB2YXIgRWRnZXNIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVkZ2VzSGFuZGxlcihib2R5LCBpbWFnZXMsIGdyb3Vwcykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVkZ2VzSGFuZGxlcik7XG5cbiAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICB0aGlzLmltYWdlcyA9IGltYWdlcztcbiAgICAgIHRoaXMuZ3JvdXBzID0gZ3JvdXBzO1xuXG4gICAgICAvLyBjcmVhdGUgdGhlIGVkZ2UgQVBJIGluIHRoZSBib2R5IGNvbnRhaW5lclxuICAgICAgdGhpcy5ib2R5LmZ1bmN0aW9ucy5jcmVhdGVFZGdlID0gdGhpcy5jcmVhdGUuYmluZCh0aGlzKTtcblxuICAgICAgdGhpcy5lZGdlc0xpc3RlbmVycyA9IHtcbiAgICAgICAgYWRkOiBmdW5jdGlvbiBhZGQoZXZlbnQsIHBhcmFtcykge1xuICAgICAgICAgIF90aGlzLmFkZChwYXJhbXMuaXRlbXMpO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShldmVudCwgcGFyYW1zKSB7XG4gICAgICAgICAgX3RoaXMudXBkYXRlKHBhcmFtcy5pdGVtcyk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGV2ZW50LCBwYXJhbXMpIHtcbiAgICAgICAgICBfdGhpcy5yZW1vdmUocGFyYW1zLml0ZW1zKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgICBhcnJvd3M6IHtcbiAgICAgICAgICB0bzogeyBlbmFibGVkOiBmYWxzZSwgc2NhbGVGYWN0b3I6IDEgfSwgLy8gYm9vbGVhbiAvIHthcnJvd1NjYWxlRmFjdG9yOjF9IC8ge2VuYWJsZWQ6IGZhbHNlLCBhcnJvd1NjYWxlRmFjdG9yOjF9XG4gICAgICAgICAgbWlkZGxlOiB7IGVuYWJsZWQ6IGZhbHNlLCBzY2FsZUZhY3RvcjogMSB9LFxuICAgICAgICAgIGZyb206IHsgZW5hYmxlZDogZmFsc2UsIHNjYWxlRmFjdG9yOiAxIH1cbiAgICAgICAgfSxcbiAgICAgICAgYXJyb3dTdHJpa2V0aHJvdWdoOiB0cnVlLFxuICAgICAgICBjb2xvcjoge1xuICAgICAgICAgIGNvbG9yOiAnIzg0ODQ4NCcsXG4gICAgICAgICAgaGlnaGxpZ2h0OiAnIzg0ODQ4NCcsXG4gICAgICAgICAgaG92ZXI6ICcjODQ4NDg0JyxcbiAgICAgICAgICBpbmhlcml0OiAnZnJvbScsXG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0sXG4gICAgICAgIGRhc2hlczogZmFsc2UsXG4gICAgICAgIGZvbnQ6IHtcbiAgICAgICAgICBjb2xvcjogJyMzNDM0MzQnLFxuICAgICAgICAgIHNpemU6IDE0LCAvLyBweFxuICAgICAgICAgIGZhY2U6ICdhcmlhbCcsXG4gICAgICAgICAgYmFja2dyb3VuZDogJ25vbmUnLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiAyLCAvLyBweFxuICAgICAgICAgIHN0cm9rZUNvbG9yOiAnI2ZmZmZmZicsXG4gICAgICAgICAgYWxpZ246ICdob3Jpem9udGFsJ1xuICAgICAgICB9LFxuICAgICAgICBoaWRkZW46IGZhbHNlLFxuICAgICAgICBob3ZlcldpZHRoOiAxLjUsXG4gICAgICAgIGxhYmVsOiB1bmRlZmluZWQsXG4gICAgICAgIGxhYmVsSGlnaGxpZ2h0Qm9sZDogdHJ1ZSxcbiAgICAgICAgbGVuZ3RoOiB1bmRlZmluZWQsXG4gICAgICAgIHBoeXNpY3M6IHRydWUsXG4gICAgICAgIHNjYWxpbmc6IHtcbiAgICAgICAgICBtaW46IDEsXG4gICAgICAgICAgbWF4OiAxNSxcbiAgICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgIG1pbjogMTQsXG4gICAgICAgICAgICBtYXg6IDMwLFxuICAgICAgICAgICAgbWF4VmlzaWJsZTogMzAsXG4gICAgICAgICAgICBkcmF3VGhyZXNob2xkOiA1XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjdXN0b21TY2FsaW5nRnVuY3Rpb246IGZ1bmN0aW9uIGN1c3RvbVNjYWxpbmdGdW5jdGlvbihtaW4sIG1heCwgdG90YWwsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDAuNTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBzY2FsZSA9IDEgLyAobWF4IC0gbWluKTtcbiAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsICh2YWx1ZSAtIG1pbikgKiBzY2FsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZWxlY3Rpb25XaWR0aDogMS41LFxuICAgICAgICBzZWxmUmVmZXJlbmNlU2l6ZTogMjAsXG4gICAgICAgIHNoYWRvdzoge1xuICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgIGNvbG9yOiAncmdiYSgwLDAsMCwwLjUpJyxcbiAgICAgICAgICBzaXplOiAxMCxcbiAgICAgICAgICB4OiA1LFxuICAgICAgICAgIHk6IDVcbiAgICAgICAgfSxcbiAgICAgICAgc21vb3RoOiB7XG4gICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICB0eXBlOiBcImR5bmFtaWNcIixcbiAgICAgICAgICBmb3JjZURpcmVjdGlvbjogJ25vbmUnLFxuICAgICAgICAgIHJvdW5kbmVzczogMC41XG4gICAgICAgIH0sXG4gICAgICAgIHRpdGxlOiB1bmRlZmluZWQsXG4gICAgICAgIHdpZHRoOiAxLFxuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgICB9O1xuXG4gICAgICB1dGlsLmV4dGVuZCh0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gICAgICB0aGlzLmJpbmRFdmVudExpc3RlbmVycygpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhFZGdlc0hhbmRsZXIsIFt7XG4gICAgICBrZXk6ICdiaW5kRXZlbnRMaXN0ZW5lcnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgLy8gdGhpcyBhbGxvd3MgZXh0ZXJuYWwgbW9kdWxlcyB0byBmb3JjZSBhbGwgZHluYW1pYyBjdXJ2ZXMgdG8gdHVybiBzdGF0aWMuXG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2ZvcmNlRGlzYWJsZUR5bmFtaWNDdXJ2ZXNcIiwgZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2R5bmFtaWMnKSB7XG4gICAgICAgICAgICB0eXBlID0gJ2NvbnRpbnVvdXMnO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZW1pdENoYW5nZSA9IGZhbHNlO1xuICAgICAgICAgIGZvciAodmFyIGVkZ2VJZCBpbiBfdGhpczIuYm9keS5lZGdlcykge1xuICAgICAgICAgICAgaWYgKF90aGlzMi5ib2R5LmVkZ2VzLmhhc093blByb3BlcnR5KGVkZ2VJZCkpIHtcbiAgICAgICAgICAgICAgdmFyIGVkZ2UgPSBfdGhpczIuYm9keS5lZGdlc1tlZGdlSWRdO1xuICAgICAgICAgICAgICB2YXIgZWRnZURhdGEgPSBfdGhpczIuYm9keS5kYXRhLmVkZ2VzLl9kYXRhW2VkZ2VJZF07XG5cbiAgICAgICAgICAgICAgLy8gb25seSBmb3JjaWJseSByZW1vdmUgdGhlIHNtb290aCBjdXJ2ZSBpZiB0aGUgZGF0YSBoYXMgYmVlbiBzZXQgb2YgdGhlIGVkZ2UgaGFzIHRoZSBzbW9vdGggY3VydmVzIGRlZmluZWQuXG4gICAgICAgICAgICAgIC8vIHRoaXMgaXMgYmVjYXVzZSBhIGNoYW5nZSBpbiB0aGUgZ2xvYmFsIHdvdWxkIG5vdCBhZmZlY3QgdGhlc2UgY3VydmVzLlxuICAgICAgICAgICAgICBpZiAoZWRnZURhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBlZGdlT3B0aW9ucyA9IGVkZ2VEYXRhLnNtb290aDtcbiAgICAgICAgICAgICAgICBpZiAoZWRnZU9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGVkZ2VPcHRpb25zLmVuYWJsZWQgPT09IHRydWUgJiYgZWRnZU9wdGlvbnMudHlwZSA9PT0gJ2R5bmFtaWMnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBlZGdlLnNldE9wdGlvbnMoeyBzbW9vdGg6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGVkZ2Uuc2V0T3B0aW9ucyh7IHNtb290aDogeyB0eXBlOiB0eXBlIH0gfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZW1pdENoYW5nZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbWl0Q2hhbmdlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBfdGhpczIuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyB0aGlzIGlzIGNhbGxlZCB3aGVuIG9wdGlvbnMgb2YgRVhJU1RJTkcgbm9kZXMgb3IgZWRnZXMgaGF2ZSBjaGFuZ2VkLlxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9kYXRhVXBkYXRlZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMyLnJlY29ubmVjdEVkZ2VzKCk7XG4gICAgICAgICAgX3RoaXMyLm1hcmtBbGxFZGdlc0FzRGlydHkoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gcmVmcmVzaCB0aGUgZWRnZXMuIFVzZWQgd2hlbiByZXZlcnRpbmcgZnJvbSBoaWVyYXJjaGljYWwgbGF5b3V0XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwicmVmcmVzaEVkZ2VzXCIsIHRoaXMucmVmcmVzaC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJyZWZyZXNoXCIsIHRoaXMucmVmcmVzaC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJkZXN0cm95XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB1dGlsLmZvckVhY2goX3RoaXMyLmVkZ2VzTGlzdGVuZXJzLCBmdW5jdGlvbiAoY2FsbGJhY2ssIGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMyLmJvZHkuZGF0YS5lZGdlcykgX3RoaXMyLmJvZHkuZGF0YS5lZGdlcy5vZmYoZXZlbnQsIGNhbGxiYWNrKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkZWxldGUgX3RoaXMyLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZUVkZ2U7XG4gICAgICAgICAgZGVsZXRlIF90aGlzMi5lZGdlc0xpc3RlbmVycy5hZGQ7XG4gICAgICAgICAgZGVsZXRlIF90aGlzMi5lZGdlc0xpc3RlbmVycy51cGRhdGU7XG4gICAgICAgICAgZGVsZXRlIF90aGlzMi5lZGdlc0xpc3RlbmVycy5yZW1vdmU7XG4gICAgICAgICAgZGVsZXRlIF90aGlzMi5lZGdlc0xpc3RlbmVycztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnc2V0T3B0aW9ucycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyB1c2UgdGhlIHBhcnNlciBmcm9tIHRoZSBFZGdlIGNsYXNzIHRvIGZpbGwgaW4gYWxsIHNob3J0aGFuZCBub3RhdGlvbnNcbiAgICAgICAgICBfRWRnZTIuZGVmYXVsdC5wYXJzZU9wdGlvbnModGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgICAgIC8vIGhhbmRsZSBtdWx0aXBsZSBpbnB1dCBjYXNlcyBmb3IgY29sb3JcbiAgICAgICAgICBpZiAob3B0aW9ucy5jb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm1hcmtBbGxFZGdlc0FzRGlydHkoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB1cGRhdGUgc21vb3RoIHNldHRpbmdzIGluIGFsbCBlZGdlc1xuICAgICAgICAgIHZhciBkYXRhQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgIGlmIChvcHRpb25zLnNtb290aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBlZGdlSWQgaW4gdGhpcy5ib2R5LmVkZ2VzKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmJvZHkuZWRnZXMuaGFzT3duUHJvcGVydHkoZWRnZUlkKSkge1xuICAgICAgICAgICAgICAgIGRhdGFDaGFuZ2VkID0gdGhpcy5ib2R5LmVkZ2VzW2VkZ2VJZF0udXBkYXRlRWRnZVR5cGUoKSB8fCBkYXRhQ2hhbmdlZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHVwZGF0ZSBmb250cyBpbiBhbGwgZWRnZXNcbiAgICAgICAgICBpZiAob3B0aW9ucy5mb250ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHVzZSB0aGUgcGFyc2VyIGZyb20gdGhlIExhYmVsIGNsYXNzIHRvIGZpbGwgaW4gYWxsIHNob3J0aGFuZCBub3RhdGlvbnNcbiAgICAgICAgICAgIF9MYWJlbDIuZGVmYXVsdC5wYXJzZU9wdGlvbnModGhpcy5vcHRpb25zLmZvbnQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgZm9yICh2YXIgX2VkZ2VJZCBpbiB0aGlzLmJvZHkuZWRnZXMpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuYm9keS5lZGdlcy5oYXNPd25Qcm9wZXJ0eShfZWRnZUlkKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYm9keS5lZGdlc1tfZWRnZUlkXS51cGRhdGVMYWJlbE1vZHVsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdXBkYXRlIHRoZSBzdGF0ZSBvZiB0aGUgdmFyaWFibGVzIGlmIG5lZWRlZFxuICAgICAgICAgIGlmIChvcHRpb25zLmhpZGRlbiAhPT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMucGh5c2ljcyAhPT0gdW5kZWZpbmVkIHx8IGRhdGFDaGFuZ2VkID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfZGF0YUNoYW5nZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBMb2FkIGVkZ2VzIGJ5IHJlYWRpbmcgdGhlIGRhdGEgdGFibGVcbiAgICAgICAqIEBwYXJhbSB7QXJyYXkgfCBEYXRhU2V0IHwgRGF0YVZpZXd9IGVkZ2VzICAgIFRoZSBkYXRhIGNvbnRhaW5pbmcgdGhlIGVkZ2VzLlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NldERhdGEnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldERhdGEoZWRnZXMpIHtcbiAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGRvTm90RW1pdCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgIHZhciBvbGRFZGdlc0RhdGEgPSB0aGlzLmJvZHkuZGF0YS5lZGdlcztcblxuICAgICAgICBpZiAoZWRnZXMgaW5zdGFuY2VvZiBEYXRhU2V0IHx8IGVkZ2VzIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZGF0YS5lZGdlcyA9IGVkZ2VzO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZWRnZXMpKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmRhdGEuZWRnZXMgPSBuZXcgRGF0YVNldCgpO1xuICAgICAgICAgIHRoaXMuYm9keS5kYXRhLmVkZ2VzLmFkZChlZGdlcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWVkZ2VzKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmRhdGEuZWRnZXMgPSBuZXcgRGF0YVNldCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5IG9yIERhdGFTZXQgZXhwZWN0ZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IGlzIHRoaXMgbnVsbCBvciB1bmRlZmluZWQgb3IgZmFsc2U/XG4gICAgICAgIGlmIChvbGRFZGdlc0RhdGEpIHtcbiAgICAgICAgICAvLyB1bnN1YnNjcmliZSBmcm9tIG9sZCBkYXRhc2V0XG4gICAgICAgICAgdXRpbC5mb3JFYWNoKHRoaXMuZWRnZXNMaXN0ZW5lcnMsIGZ1bmN0aW9uIChjYWxsYmFjaywgZXZlbnQpIHtcbiAgICAgICAgICAgIG9sZEVkZ2VzRGF0YS5vZmYoZXZlbnQsIGNhbGxiYWNrKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSBkcmF3biBlZGdlc1xuICAgICAgICB0aGlzLmJvZHkuZWRnZXMgPSB7fTtcblxuICAgICAgICAvLyBUT0RPOiBpcyB0aGlzIG51bGwgb3IgdW5kZWZpbmVkIG9yIGZhbHNlP1xuICAgICAgICBpZiAodGhpcy5ib2R5LmRhdGEuZWRnZXMpIHtcbiAgICAgICAgICAvLyBzdWJzY3JpYmUgdG8gbmV3IGRhdGFzZXRcbiAgICAgICAgICB1dGlsLmZvckVhY2godGhpcy5lZGdlc0xpc3RlbmVycywgZnVuY3Rpb24gKGNhbGxiYWNrLCBldmVudCkge1xuICAgICAgICAgICAgX3RoaXMzLmJvZHkuZGF0YS5lZGdlcy5vbihldmVudCwgY2FsbGJhY2spO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gZHJhdyBhbGwgbmV3IG5vZGVzXG4gICAgICAgICAgdmFyIGlkcyA9IHRoaXMuYm9keS5kYXRhLmVkZ2VzLmdldElkcygpO1xuICAgICAgICAgIHRoaXMuYWRkKGlkcywgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZG9Ob3RFbWl0ID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBZGQgZWRnZXNcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyW10gfCBTdHJpbmdbXX0gaWRzXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdhZGQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChpZHMpIHtcbiAgICAgICAgdmFyIGRvTm90RW1pdCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcbiAgICAgICAgdmFyIGVkZ2VzRGF0YSA9IHRoaXMuYm9keS5kYXRhLmVkZ2VzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGlkID0gaWRzW2ldO1xuXG4gICAgICAgICAgdmFyIG9sZEVkZ2UgPSBlZGdlc1tpZF07XG4gICAgICAgICAgaWYgKG9sZEVkZ2UpIHtcbiAgICAgICAgICAgIG9sZEVkZ2UuZGlzY29ubmVjdCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBkYXRhID0gZWRnZXNEYXRhLmdldChpZCwgeyBcInNob3dJbnRlcm5hbElkc1wiOiB0cnVlIH0pO1xuICAgICAgICAgIGVkZ2VzW2lkXSA9IHRoaXMuY3JlYXRlKGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRvTm90RW1pdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVXBkYXRlIGV4aXN0aW5nIGVkZ2VzLCBvciBjcmVhdGUgdGhlbSB3aGVuIG5vdCB5ZXQgZXhpc3RpbmdcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyW10gfCBTdHJpbmdbXX0gaWRzXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd1cGRhdGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShpZHMpIHtcbiAgICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuICAgICAgICB2YXIgZWRnZXNEYXRhID0gdGhpcy5ib2R5LmRhdGEuZWRnZXM7XG4gICAgICAgIHZhciBkYXRhQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBpZCA9IGlkc1tpXTtcbiAgICAgICAgICB2YXIgZGF0YSA9IGVkZ2VzRGF0YS5nZXQoaWQpO1xuICAgICAgICAgIHZhciBlZGdlID0gZWRnZXNbaWRdO1xuICAgICAgICAgIGlmIChlZGdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBlZGdlXG4gICAgICAgICAgICBlZGdlLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIGRhdGFDaGFuZ2VkID0gZWRnZS5zZXRPcHRpb25zKGRhdGEpIHx8IGRhdGFDaGFuZ2VkOyAvLyBpZiBhIHN1cHBvcnQgbm9kZSBpcyBhZGRlZCwgZGF0YSBjYW4gYmUgY2hhbmdlZC5cbiAgICAgICAgICAgIGVkZ2UuY29ubmVjdCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgZWRnZVxuICAgICAgICAgICAgdGhpcy5ib2R5LmVkZ2VzW2lkXSA9IHRoaXMuY3JlYXRlKGRhdGEpO1xuICAgICAgICAgICAgZGF0YUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhQ2hhbmdlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhVXBkYXRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZSBleGlzdGluZyBlZGdlcy4gTm9uIGV4aXN0aW5nIGlkcyB3aWxsIGJlIGlnbm9yZWRcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyW10gfCBTdHJpbmdbXX0gaWRzXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyZW1vdmUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZShpZHMpIHtcbiAgICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBpZCA9IGlkc1tpXTtcbiAgICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2lkXTtcbiAgICAgICAgICBpZiAoZWRnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlZGdlLmNsZWFudXAoKTtcbiAgICAgICAgICAgIGVkZ2UuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgZGVsZXRlIGVkZ2VzW2lkXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3JlZnJlc2gnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlZnJlc2goKSB7XG4gICAgICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcbiAgICAgICAgZm9yICh2YXIgZWRnZUlkIGluIGVkZ2VzKSB7XG4gICAgICAgICAgdmFyIGVkZ2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKGVkZ2VzLmhhc093blByb3BlcnR5KGVkZ2VJZCkpIHtcbiAgICAgICAgICAgIGVkZ2UgPSBlZGdlc1tlZGdlSWRdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuYm9keS5kYXRhLmVkZ2VzLl9kYXRhW2VkZ2VJZF07XG4gICAgICAgICAgaWYgKGVkZ2UgIT09IHVuZGVmaW5lZCAmJiBkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVkZ2Uuc2V0T3B0aW9ucyhkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdjcmVhdGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgX0VkZ2UyLmRlZmF1bHQocHJvcGVydGllcywgdGhpcy5ib2R5LCB0aGlzLm9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ21hcmtBbGxFZGdlc0FzRGlydHknLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1hcmtBbGxFZGdlc0FzRGlydHkoKSB7XG4gICAgICAgIGZvciAodmFyIGVkZ2VJZCBpbiB0aGlzLmJvZHkuZWRnZXMpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZWRnZXNbZWRnZUlkXS5lZGdlVHlwZS5jb2xvckRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlY29ubmVjdCBhbGwgZWRnZXNcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3JlY29ubmVjdEVkZ2VzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWNvbm5lY3RFZGdlcygpIHtcbiAgICAgICAgdmFyIGlkO1xuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcblxuICAgICAgICBmb3IgKGlkIGluIG5vZGVzKSB7XG4gICAgICAgICAgaWYgKG5vZGVzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgbm9kZXNbaWRdLmVkZ2VzID0gW107XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpZCBpbiBlZGdlcykge1xuICAgICAgICAgIGlmIChlZGdlcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgIHZhciBlZGdlID0gZWRnZXNbaWRdO1xuICAgICAgICAgICAgZWRnZS5mcm9tID0gbnVsbDtcbiAgICAgICAgICAgIGVkZ2UudG8gPSBudWxsO1xuICAgICAgICAgICAgZWRnZS5jb25uZWN0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0Q29ubmVjdGVkTm9kZXMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbm5lY3RlZE5vZGVzKGVkZ2VJZCkge1xuICAgICAgICB2YXIgbm9kZUxpc3QgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuYm9keS5lZGdlc1tlZGdlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgZWRnZSA9IHRoaXMuYm9keS5lZGdlc1tlZGdlSWRdO1xuICAgICAgICAgIGlmIChlZGdlLmZyb21JZCkge1xuICAgICAgICAgICAgbm9kZUxpc3QucHVzaChlZGdlLmZyb21JZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlZGdlLnRvSWQpIHtcbiAgICAgICAgICAgIG5vZGVMaXN0LnB1c2goZWRnZS50b0lkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGVMaXN0O1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBFZGdlc0hhbmRsZXI7XG4gIH0oKTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBFZGdlc0hhbmRsZXI7XG5cbi8qKiovIH0sXG4vKiA4NSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgdmFyIF9MYWJlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNjYpO1xuXG4gIHZhciBfTGFiZWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTGFiZWwpO1xuXG4gIHZhciBfQ3ViaWNCZXppZXJFZGdlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4Nik7XG5cbiAgdmFyIF9DdWJpY0JlemllckVkZ2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ3ViaWNCZXppZXJFZGdlKTtcblxuICB2YXIgX0JlemllckVkZ2VEeW5hbWljID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MCk7XG5cbiAgdmFyIF9CZXppZXJFZGdlRHluYW1pYzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CZXppZXJFZGdlRHluYW1pYyk7XG5cbiAgdmFyIF9CZXppZXJFZGdlU3RhdGljID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MSk7XG5cbiAgdmFyIF9CZXppZXJFZGdlU3RhdGljMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0JlemllckVkZ2VTdGF0aWMpO1xuXG4gIHZhciBfU3RyYWlnaHRFZGdlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Mik7XG5cbiAgdmFyIF9TdHJhaWdodEVkZ2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU3RyYWlnaHRFZGdlKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgdmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4gIC8qKlxuICAgKiBAY2xhc3MgRWRnZVxuICAgKlxuICAgKiBBIGVkZ2UgY29ubmVjdHMgdHdvIG5vZGVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzICAgICBPYmplY3Qgd2l0aCBvcHRpb25zLiBNdXN0IGNvbnRhaW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEF0IGxlYXN0IG9wdGlvbnMgZnJvbSBhbmQgdG8uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBdmFpbGFibGUgb3B0aW9uczogZnJvbSAobnVtYmVyKSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIChudW1iZXIpLCBsYWJlbCAoc3RyaW5nLCBjb2xvciAoc3RyaW5nKSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoIChudW1iZXIpLCBzdHlsZSAoc3RyaW5nKSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCAobnVtYmVyKSwgdGl0bGUgKHN0cmluZylcbiAgICogQHBhcmFtIHtOZXR3b3JrfSBuZXR3b3JrICAgICAgIEEgTmV0d29yayBvYmplY3QsIHVzZWQgdG8gZmluZCBhbmQgZWRnZSB0b1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25zdGFudHMgICAgICBBbiBvYmplY3Qgd2l0aCBkZWZhdWx0IHZhbHVlcyBmb3JcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4YW1wbGUgZm9yIHRoZSBjb2xvclxuICAgKi9cblxuICB2YXIgRWRnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFZGdlKG9wdGlvbnMsIGJvZHksIGdsb2JhbE9wdGlvbnMpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFZGdlKTtcblxuICAgICAgaWYgKGJvZHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBcIk5vIGJvZHkgcHJvdmlkZWRcIjtcbiAgICAgIH1cbiAgICAgIHRoaXMub3B0aW9ucyA9IHV0aWwuYnJpZGdlT2JqZWN0KGdsb2JhbE9wdGlvbnMpO1xuICAgICAgdGhpcy5nbG9iYWxPcHRpb25zID0gZ2xvYmFsT3B0aW9ucztcbiAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG5cbiAgICAgIC8vIGluaXRpYWxpemUgdmFyaWFibGVzXG4gICAgICB0aGlzLmlkID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5mcm9tSWQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnRvSWQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmhvdmVyID0gZmFsc2U7XG4gICAgICB0aGlzLmxhYmVsRGlydHkgPSB0cnVlO1xuICAgICAgdGhpcy5jb2xvckRpcnR5ID0gdHJ1ZTtcblxuICAgICAgdGhpcy5iYXNlV2lkdGggPSB0aGlzLm9wdGlvbnMud2lkdGg7XG4gICAgICB0aGlzLmJhc2VGb250U2l6ZSA9IHRoaXMub3B0aW9ucy5mb250LnNpemU7XG5cbiAgICAgIHRoaXMuZnJvbSA9IHVuZGVmaW5lZDsgLy8gYSBub2RlXG4gICAgICB0aGlzLnRvID0gdW5kZWZpbmVkOyAvLyBhIG5vZGVcblxuICAgICAgdGhpcy5lZGdlVHlwZSA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcblxuICAgICAgdGhpcy5sYWJlbE1vZHVsZSA9IG5ldyBfTGFiZWwyLmRlZmF1bHQodGhpcy5ib2R5LCB0aGlzLm9wdGlvbnMsIHRydWUgLyogSXQncyBhbiBlZGdlIGxhYmVsICovKTtcblxuICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBvciBvdmVyd3JpdGUgb3B0aW9ucyBmb3IgdGhlIGVkZ2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgYW4gb2JqZWN0IHdpdGggb3B0aW9uc1xuICAgICAqIEBwYXJhbSBkb05vdEVtaXRcbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKEVkZ2UsIFt7XG4gICAgICBrZXk6ICdzZXRPcHRpb25zJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29sb3JEaXJ0eSA9IHRydWU7XG5cbiAgICAgICAgRWRnZS5wYXJzZU9wdGlvbnModGhpcy5vcHRpb25zLCBvcHRpb25zLCB0cnVlLCB0aGlzLmdsb2JhbE9wdGlvbnMpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmlkID0gb3B0aW9ucy5pZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5mcm9tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmZyb21JZCA9IG9wdGlvbnMuZnJvbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy50byAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy50b0lkID0gb3B0aW9ucy50bztcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy50aXRsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy50aXRsZSA9IG9wdGlvbnMudGl0bGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG9wdGlvbnMudmFsdWUgPSBwYXJzZUZsb2F0KG9wdGlvbnMudmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIGxhYmVsIE1vZHVsZVxuICAgICAgICB0aGlzLnVwZGF0ZUxhYmVsTW9kdWxlKCk7XG5cbiAgICAgICAgdmFyIGRhdGFDaGFuZ2VkID0gdGhpcy51cGRhdGVFZGdlVHlwZSgpO1xuXG4gICAgICAgIC8vIGlmIGFueXRoaW5nIGhhcyBiZWVuIHVwZGF0ZXMsIHJlc2V0IHRoZSBzZWxlY3Rpb24gd2lkdGggYW5kIHRoZSBob3ZlciB3aWR0aFxuICAgICAgICB0aGlzLl9zZXRJbnRlcmFjdGlvbldpZHRocygpO1xuXG4gICAgICAgIC8vIEEgbm9kZSBpcyBjb25uZWN0ZWQgd2hlbiBpdCBoYXMgYSBmcm9tIGFuZCB0byBub2RlIHRoYXQgYm90aCBleGlzdCBpbiB0aGUgbmV0d29yay5ib2R5Lm5vZGVzLlxuICAgICAgICB0aGlzLmNvbm5lY3QoKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5oaWRkZW4gIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnBoeXNpY3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGRhdGFDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhQ2hhbmdlZDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICd1cGRhdGVMYWJlbE1vZHVsZScsXG4gICAgICAvLyBzZXQgdGhlIG9iamVjdCBiYWNrIHRvIHRoZSBnbG9iYWwgb3B0aW9uc1xuXG5cbiAgICAgIC8qKlxuICAgICAgICogdXBkYXRlIHRoZSBvcHRpb25zIGluIHRoZSBsYWJlbCBtb2R1bGVcbiAgICAgICAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUxhYmVsTW9kdWxlKCkge1xuICAgICAgICB0aGlzLmxhYmVsTW9kdWxlLnNldE9wdGlvbnModGhpcy5vcHRpb25zLCB0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMubGFiZWxNb2R1bGUuYmFzZVNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuYmFzZUZvbnRTaXplID0gdGhpcy5sYWJlbE1vZHVsZS5iYXNlU2l6ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHVwZGF0ZSB0aGUgZWRnZSB0eXBlLCBzZXQgdGhlIG9wdGlvbnNcbiAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd1cGRhdGVFZGdlVHlwZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRWRnZVR5cGUoKSB7XG4gICAgICAgIHZhciBkYXRhQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgY2hhbmdlSW5UeXBlID0gdHJ1ZTtcbiAgICAgICAgdmFyIHNtb290aCA9IHRoaXMub3B0aW9ucy5zbW9vdGg7XG4gICAgICAgIGlmICh0aGlzLmVkZ2VUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAodGhpcy5lZGdlVHlwZSBpbnN0YW5jZW9mIF9CZXppZXJFZGdlRHluYW1pYzIuZGVmYXVsdCAmJiBzbW9vdGguZW5hYmxlZCA9PT0gdHJ1ZSAmJiBzbW9vdGgudHlwZSA9PT0gJ2R5bmFtaWMnKSB7XG4gICAgICAgICAgICBjaGFuZ2VJblR5cGUgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuZWRnZVR5cGUgaW5zdGFuY2VvZiBfQ3ViaWNCZXppZXJFZGdlMi5kZWZhdWx0ICYmIHNtb290aC5lbmFibGVkID09PSB0cnVlICYmIHNtb290aC50eXBlID09PSAnY3ViaWNCZXppZXInKSB7XG4gICAgICAgICAgICBjaGFuZ2VJblR5cGUgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuZWRnZVR5cGUgaW5zdGFuY2VvZiBfQmV6aWVyRWRnZVN0YXRpYzIuZGVmYXVsdCAmJiBzbW9vdGguZW5hYmxlZCA9PT0gdHJ1ZSAmJiBzbW9vdGgudHlwZSAhPT0gJ2R5bmFtaWMnICYmIHNtb290aC50eXBlICE9PSAnY3ViaWNCZXppZXInKSB7XG4gICAgICAgICAgICBjaGFuZ2VJblR5cGUgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuZWRnZVR5cGUgaW5zdGFuY2VvZiBfU3RyYWlnaHRFZGdlMi5kZWZhdWx0ICYmIHNtb290aC5lbmFibGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY2hhbmdlSW5UeXBlID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNoYW5nZUluVHlwZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgZGF0YUNoYW5nZWQgPSB0aGlzLmNsZWFudXAoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hhbmdlSW5UeXBlID09PSB0cnVlKSB7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zbW9vdGguZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zbW9vdGgudHlwZSA9PT0gJ2R5bmFtaWMnKSB7XG4gICAgICAgICAgICAgIGRhdGFDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdGhpcy5lZGdlVHlwZSA9IG5ldyBfQmV6aWVyRWRnZUR5bmFtaWMyLmRlZmF1bHQodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuc21vb3RoLnR5cGUgPT09ICdjdWJpY0JlemllcicpIHtcbiAgICAgICAgICAgICAgdGhpcy5lZGdlVHlwZSA9IG5ldyBfQ3ViaWNCZXppZXJFZGdlMi5kZWZhdWx0KHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuZWRnZVR5cGUgPSBuZXcgX0JlemllckVkZ2VTdGF0aWMyLmRlZmF1bHQodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVkZ2VUeXBlID0gbmV3IF9TdHJhaWdodEVkZ2UyLmRlZmF1bHQodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpZiBub3RoaW5nIGNoYW5nZXMsIHdlIGp1c3Qgc2V0IHRoZSBvcHRpb25zLlxuICAgICAgICAgIHRoaXMuZWRnZVR5cGUuc2V0T3B0aW9ucyh0aGlzLm9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGFDaGFuZ2VkO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENvbm5lY3QgYW4gZWRnZSB0byBpdHMgbm9kZXNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnY29ubmVjdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG5cbiAgICAgICAgdGhpcy5mcm9tID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMuZnJvbUlkXSB8fCB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMudG8gPSB0aGlzLmJvZHkubm9kZXNbdGhpcy50b0lkXSB8fCB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY29ubmVjdGVkID0gdGhpcy5mcm9tICE9PSB1bmRlZmluZWQgJiYgdGhpcy50byAhPT0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuZnJvbS5hdHRhY2hFZGdlKHRoaXMpO1xuICAgICAgICAgIHRoaXMudG8uYXR0YWNoRWRnZSh0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5mcm9tKSB7XG4gICAgICAgICAgICB0aGlzLmZyb20uZGV0YWNoRWRnZSh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMudG8pIHtcbiAgICAgICAgICAgIHRoaXMudG8uZGV0YWNoRWRnZSh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVkZ2VUeXBlLmNvbm5lY3QoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBEaXNjb25uZWN0IGFuIGVkZ2UgZnJvbSBpdHMgbm9kZXNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZGlzY29ubmVjdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzY29ubmVjdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZnJvbSkge1xuICAgICAgICAgIHRoaXMuZnJvbS5kZXRhY2hFZGdlKHRoaXMpO1xuICAgICAgICAgIHRoaXMuZnJvbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50bykge1xuICAgICAgICAgIHRoaXMudG8uZGV0YWNoRWRnZSh0aGlzKTtcbiAgICAgICAgICB0aGlzLnRvID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBnZXQgdGhlIHRpdGxlIG9mIHRoaXMgZWRnZS5cbiAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gdGl0bGUgICAgVGhlIHRpdGxlIG9mIHRoZSBlZGdlLCBvciB1bmRlZmluZWQgd2hlbiBubyB0aXRsZVxuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBoYXMgYmVlbiBzZXQuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldFRpdGxlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUaXRsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGl0bGU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogY2hlY2sgaWYgdGhpcyBub2RlIGlzIHNlbGVjdGVcbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHNlbGVjdGVkICAgVHJ1ZSBpZiBub2RlIGlzIHNlbGVjdGVkLCBlbHNlIGZhbHNlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2lzU2VsZWN0ZWQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzU2VsZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHJpZXZlIHRoZSB2YWx1ZSBvZiB0aGUgZWRnZS4gQ2FuIGJlIHVuZGVmaW5lZFxuICAgICAgICogQHJldHVybiB7TnVtYmVyfSB2YWx1ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXRWYWx1ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQWRqdXN0IHRoZSB2YWx1ZSByYW5nZSBvZiB0aGUgZWRnZS4gVGhlIGVkZ2Ugd2lsbCBhZGp1c3QgaXQncyB3aWR0aFxuICAgICAgICogYmFzZWQgb24gaXRzIHZhbHVlLlxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IG1pblxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IG1heFxuICAgICAgICogQHBhcmFtIHRvdGFsXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NldFZhbHVlUmFuZ2UnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFZhbHVlUmFuZ2UobWluLCBtYXgsIHRvdGFsKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBzY2FsZSA9IHRoaXMub3B0aW9ucy5zY2FsaW5nLmN1c3RvbVNjYWxpbmdGdW5jdGlvbihtaW4sIG1heCwgdG90YWwsIHRoaXMub3B0aW9ucy52YWx1ZSk7XG4gICAgICAgICAgdmFyIHdpZHRoRGlmZiA9IHRoaXMub3B0aW9ucy5zY2FsaW5nLm1heCAtIHRoaXMub3B0aW9ucy5zY2FsaW5nLm1pbjtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNjYWxpbmcubGFiZWwuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIGZvbnREaWZmID0gdGhpcy5vcHRpb25zLnNjYWxpbmcubGFiZWwubWF4IC0gdGhpcy5vcHRpb25zLnNjYWxpbmcubGFiZWwubWluO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmZvbnQuc2l6ZSA9IHRoaXMub3B0aW9ucy5zY2FsaW5nLmxhYmVsLm1pbiArIHNjYWxlICogZm9udERpZmY7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMub3B0aW9ucy53aWR0aCA9IHRoaXMub3B0aW9ucy5zY2FsaW5nLm1pbiArIHNjYWxlICogd2lkdGhEaWZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy53aWR0aCA9IHRoaXMuYmFzZVdpZHRoO1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5mb250LnNpemUgPSB0aGlzLmJhc2VGb250U2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NldEludGVyYWN0aW9uV2lkdGhzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlTGFiZWxNb2R1bGUoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc2V0SW50ZXJhY3Rpb25XaWR0aHMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRJbnRlcmFjdGlvbldpZHRocygpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuaG92ZXJXaWR0aCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRoaXMuZWRnZVR5cGUuaG92ZXJXaWR0aCA9IHRoaXMub3B0aW9ucy5ob3ZlcldpZHRoKHRoaXMub3B0aW9ucy53aWR0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5lZGdlVHlwZS5ob3ZlcldpZHRoID0gdGhpcy5vcHRpb25zLmhvdmVyV2lkdGggKyB0aGlzLm9wdGlvbnMud2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5zZWxlY3Rpb25XaWR0aCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRoaXMuZWRnZVR5cGUuc2VsZWN0aW9uV2lkdGggPSB0aGlzLm9wdGlvbnMuc2VsZWN0aW9uV2lkdGgodGhpcy5vcHRpb25zLndpZHRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmVkZ2VUeXBlLnNlbGVjdGlvbldpZHRoID0gdGhpcy5vcHRpb25zLnNlbGVjdGlvbldpZHRoICsgdGhpcy5vcHRpb25zLndpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVkcmF3IGEgZWRnZVxuICAgICAgICogRHJhdyB0aGlzIGVkZ2UgaW4gdGhlIGdpdmVuIGNhbnZhc1xuICAgICAgICogVGhlIDJkIGNvbnRleHQgb2YgYSBIVE1MIGNhbnZhcyBjYW4gYmUgcmV0cmlldmVkIGJ5IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gICBjdHhcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZHJhdycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgpIHtcbiAgICAgICAgLy8gZ2V0IHRoZSB2aWEgbm9kZSBmcm9tIHRoZSBlZGdlIHR5cGVcbiAgICAgICAgdmFyIHZpYU5vZGUgPSB0aGlzLmVkZ2VUeXBlLmdldFZpYU5vZGUoKTtcbiAgICAgICAgdmFyIGFycm93RGF0YSA9IHt9O1xuXG4gICAgICAgIC8vIHJlc3RvcmUgZWRnZSB0YXJnZXRzIHRvIGRlZmF1bHRzXG4gICAgICAgIHRoaXMuZWRnZVR5cGUuZnJvbVBvaW50ID0gdGhpcy5lZGdlVHlwZS5mcm9tO1xuICAgICAgICB0aGlzLmVkZ2VUeXBlLnRvUG9pbnQgPSB0aGlzLmVkZ2VUeXBlLnRvO1xuXG4gICAgICAgIC8vIGZyb20gYW5kIHRvIGFycm93cyBnaXZlIGEgZGlmZmVyZW50IGVuZCBwb2ludCBmb3IgZWRnZXMuIHdlIHNldCB0aGVtIGhlcmVcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hcnJvd3MuZnJvbS5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgYXJyb3dEYXRhLmZyb20gPSB0aGlzLmVkZ2VUeXBlLmdldEFycm93RGF0YShjdHgsICdmcm9tJywgdmlhTm9kZSwgdGhpcy5zZWxlY3RlZCwgdGhpcy5ob3Zlcik7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hcnJvd1N0cmlrZXRocm91Z2ggPT09IGZhbHNlKSB0aGlzLmVkZ2VUeXBlLmZyb21Qb2ludCA9IGFycm93RGF0YS5mcm9tLmNvcmU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hcnJvd3MudG8uZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGFycm93RGF0YS50byA9IHRoaXMuZWRnZVR5cGUuZ2V0QXJyb3dEYXRhKGN0eCwgJ3RvJywgdmlhTm9kZSwgdGhpcy5zZWxlY3RlZCwgdGhpcy5ob3Zlcik7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hcnJvd1N0cmlrZXRocm91Z2ggPT09IGZhbHNlKSB0aGlzLmVkZ2VUeXBlLnRvUG9pbnQgPSBhcnJvd0RhdGEudG8uY29yZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoZSBtaWRkbGUgYXJyb3cgZGVwZW5kcyBvbiB0aGUgbGluZSwgd2hpY2ggY2FuIGRlcGVuZCBvbiB0aGUgdG8gYW5kIGZyb20gYXJyb3dzIHNvIHdlIGRvIHRoaXMgb25lIGxhc3RseS5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hcnJvd3MubWlkZGxlLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICBhcnJvd0RhdGEubWlkZGxlID0gdGhpcy5lZGdlVHlwZS5nZXRBcnJvd0RhdGEoY3R4LCAnbWlkZGxlJywgdmlhTm9kZSwgdGhpcy5zZWxlY3RlZCwgdGhpcy5ob3Zlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkcmF3IGV2ZXJ5dGhpbmdcbiAgICAgICAgdGhpcy5lZGdlVHlwZS5kcmF3TGluZShjdHgsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIsIHZpYU5vZGUpO1xuICAgICAgICB0aGlzLmRyYXdBcnJvd3MoY3R4LCBhcnJvd0RhdGEpO1xuICAgICAgICB0aGlzLmRyYXdMYWJlbChjdHgsIHZpYU5vZGUpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2RyYXdBcnJvd3MnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdBcnJvd3MoY3R4LCBhcnJvd0RhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hcnJvd3MuZnJvbS5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5lZGdlVHlwZS5kcmF3QXJyb3dIZWFkKGN0eCwgdGhpcy5zZWxlY3RlZCwgdGhpcy5ob3ZlciwgYXJyb3dEYXRhLmZyb20pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXJyb3dzLm1pZGRsZS5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5lZGdlVHlwZS5kcmF3QXJyb3dIZWFkKGN0eCwgdGhpcy5zZWxlY3RlZCwgdGhpcy5ob3ZlciwgYXJyb3dEYXRhLm1pZGRsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hcnJvd3MudG8uZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuZWRnZVR5cGUuZHJhd0Fycm93SGVhZChjdHgsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIsIGFycm93RGF0YS50byk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkcmF3TGFiZWwnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdMYWJlbChjdHgsIHZpYU5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sYWJlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gc2V0IHN0eWxlXG4gICAgICAgICAgdmFyIG5vZGUxID0gdGhpcy5mcm9tO1xuICAgICAgICAgIHZhciBub2RlMiA9IHRoaXMudG87XG4gICAgICAgICAgdmFyIHNlbGVjdGVkID0gdGhpcy5mcm9tLnNlbGVjdGVkIHx8IHRoaXMudG8uc2VsZWN0ZWQgfHwgdGhpcy5zZWxlY3RlZDtcbiAgICAgICAgICBpZiAobm9kZTEuaWQgIT0gbm9kZTIuaWQpIHtcbiAgICAgICAgICAgIHRoaXMubGFiZWxNb2R1bGUucG9pbnRUb1NlbGYgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBwb2ludCA9IHRoaXMuZWRnZVR5cGUuZ2V0UG9pbnQoMC41LCB2aWFOb2RlKTtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSBsYWJlbCBoYXMgdG8gYmUgcm90YXRlZDpcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZm9udC5hbGlnbiAhPT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgICAgICAgICAgdGhpcy5sYWJlbE1vZHVsZS5jYWxjdWxhdGVMYWJlbFNpemUoY3R4LCBzZWxlY3RlZCwgcG9pbnQueCwgcG9pbnQueSk7XG4gICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUocG9pbnQueCwgdGhpcy5sYWJlbE1vZHVsZS5zaXplLnlMaW5lKTtcbiAgICAgICAgICAgICAgdGhpcy5fcm90YXRlRm9yTGFiZWxBbGlnbm1lbnQoY3R4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZHJhdyB0aGUgbGFiZWxcbiAgICAgICAgICAgIHRoaXMubGFiZWxNb2R1bGUuZHJhdyhjdHgsIHBvaW50LngsIHBvaW50LnksIHNlbGVjdGVkKTtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSB0aGUgb3JpZW50YXRpb25zLlxuICAgICAgICAgICAgdGhpcy5sYWJlbE1vZHVsZS5wb2ludFRvU2VsZiA9IHRydWU7XG4gICAgICAgICAgICB2YXIgeCwgeTtcbiAgICAgICAgICAgIHZhciByYWRpdXMgPSB0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZVNpemU7XG4gICAgICAgICAgICBpZiAobm9kZTEuc2hhcGUud2lkdGggPiBub2RlMS5zaGFwZS5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgeCA9IG5vZGUxLnggKyBub2RlMS5zaGFwZS53aWR0aCAqIDAuNTtcbiAgICAgICAgICAgICAgeSA9IG5vZGUxLnkgLSByYWRpdXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB4ID0gbm9kZTEueCArIHJhZGl1cztcbiAgICAgICAgICAgICAgeSA9IG5vZGUxLnkgLSBub2RlMS5zaGFwZS5oZWlnaHQgKiAwLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2ludCA9IHRoaXMuX3BvaW50T25DaXJjbGUoeCwgeSwgcmFkaXVzLCAwLjEyNSk7XG4gICAgICAgICAgICB0aGlzLmxhYmVsTW9kdWxlLmRyYXcoY3R4LCBwb2ludC54LCBwb2ludC55LCBzZWxlY3RlZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2hlY2sgaWYgdGhpcyBvYmplY3QgaXMgb3ZlcmxhcHBpbmcgd2l0aCB0aGUgcHJvdmlkZWQgb2JqZWN0XG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqICAgYW4gb2JqZWN0IHdpdGggcGFyYW1ldGVycyBsZWZ0LCB0b3BcbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59ICAgICBUcnVlIGlmIGxvY2F0aW9uIGlzIGxvY2F0ZWQgb24gdGhlIGVkZ2VcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnaXNPdmVybGFwcGluZ1dpdGgnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzT3ZlcmxhcHBpbmdXaXRoKG9iaikge1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgICB2YXIgZGlzdE1heCA9IDEwO1xuICAgICAgICAgIHZhciB4RnJvbSA9IHRoaXMuZnJvbS54O1xuICAgICAgICAgIHZhciB5RnJvbSA9IHRoaXMuZnJvbS55O1xuICAgICAgICAgIHZhciB4VG8gPSB0aGlzLnRvLng7XG4gICAgICAgICAgdmFyIHlUbyA9IHRoaXMudG8ueTtcbiAgICAgICAgICB2YXIgeE9iaiA9IG9iai5sZWZ0O1xuICAgICAgICAgIHZhciB5T2JqID0gb2JqLnRvcDtcblxuICAgICAgICAgIHZhciBkaXN0ID0gdGhpcy5lZGdlVHlwZS5nZXREaXN0YW5jZVRvRWRnZSh4RnJvbSwgeUZyb20sIHhUbywgeVRvLCB4T2JqLCB5T2JqKTtcblxuICAgICAgICAgIHJldHVybiBkaXN0IDwgZGlzdE1heDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSb3RhdGVzIHRoZSBjYW52YXMgc28gdGhlIHRleHQgaXMgbW9zdCByZWFkYWJsZVxuICAgICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3JvdGF0ZUZvckxhYmVsQWxpZ25tZW50JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcm90YXRlRm9yTGFiZWxBbGlnbm1lbnQoY3R4KSB7XG4gICAgICAgIHZhciBkeSA9IHRoaXMuZnJvbS55IC0gdGhpcy50by55O1xuICAgICAgICB2YXIgZHggPSB0aGlzLmZyb20ueCAtIHRoaXMudG8ueDtcbiAgICAgICAgdmFyIGFuZ2xlSW5EZWdyZWVzID0gTWF0aC5hdGFuMihkeSwgZHgpO1xuXG4gICAgICAgIC8vIHJvdGF0ZSBzbyBsYWJlbCBpdCBpcyByZWFkYWJsZVxuICAgICAgICBpZiAoYW5nbGVJbkRlZ3JlZXMgPCAtMSAmJiBkeCA8IDAgfHwgYW5nbGVJbkRlZ3JlZXMgPiAwICYmIGR4IDwgMCkge1xuICAgICAgICAgIGFuZ2xlSW5EZWdyZWVzID0gYW5nbGVJbkRlZ3JlZXMgKyBNYXRoLlBJO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LnJvdGF0ZShhbmdsZUluRGVncmVlcyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0IGEgcG9pbnQgb24gYSBjaXJjbGVcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHBlcmNlbnRhZ2UuIFZhbHVlIGJldHdlZW4gMCAobGluZSBzdGFydCkgYW5kIDEgKGxpbmUgZW5kKVxuICAgICAgICogQHJldHVybiB7T2JqZWN0fSBwb2ludFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3BvaW50T25DaXJjbGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9wb2ludE9uQ2lyY2xlKHgsIHksIHJhZGl1cywgcGVyY2VudGFnZSkge1xuICAgICAgICB2YXIgYW5nbGUgPSBwZXJjZW50YWdlICogMiAqIE1hdGguUEk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogeCArIHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgICB5OiB5IC0gcmFkaXVzICogTWF0aC5zaW4oYW5nbGUpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnc2VsZWN0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3QoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3Vuc2VsZWN0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB1bnNlbGVjdCgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGNsZWFucyBhbGwgcmVxdWlyZWQgdGhpbmdzIG9uIGRlbGV0ZVxuICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2NsZWFudXAnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkZ2VUeXBlLmNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XSwgW3tcbiAgICAgIGtleTogJ3BhcnNlT3B0aW9ucycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VPcHRpb25zKHBhcmVudE9wdGlvbnMsIG5ld09wdGlvbnMpIHtcbiAgICAgICAgdmFyIGFsbG93RGVsZXRpb24gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1syXTtcbiAgICAgICAgdmFyIGdsb2JhbE9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDMgfHwgYXJndW1lbnRzWzNdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1szXTtcblxuICAgICAgICB2YXIgZmllbGRzID0gWydhcnJvd1N0cmlrZXRocm91Z2gnLCAnaWQnLCAnZnJvbScsICdoaWRkZW4nLCAnaG92ZXJXaWR0aCcsICdsYWJlbCcsICdsYWJlbEhpZ2hsaWdodEJvbGQnLCAnbGVuZ3RoJywgJ2xpbmUnLCAnb3BhY2l0eScsICdwaHlzaWNzJywgJ3NjYWxpbmcnLCAnc2VsZWN0aW9uV2lkdGgnLCAnc2VsZlJlZmVyZW5jZVNpemUnLCAndG8nLCAndGl0bGUnLCAndmFsdWUnLCAnd2lkdGgnXTtcblxuICAgICAgICAvLyBvbmx5IGRlZXAgZXh0ZW5kIHRoZSBpdGVtcyBpbiB0aGUgZmllbGQgYXJyYXkuIFRoZXNlIGRvIG5vdCBoYXZlIHNob3J0aGFuZC5cbiAgICAgICAgdXRpbC5zZWxlY3RpdmVEZWVwRXh0ZW5kKGZpZWxkcywgcGFyZW50T3B0aW9ucywgbmV3T3B0aW9ucywgYWxsb3dEZWxldGlvbik7XG5cbiAgICAgICAgdXRpbC5tZXJnZU9wdGlvbnMocGFyZW50T3B0aW9ucywgbmV3T3B0aW9ucywgJ3Ntb290aCcsIGFsbG93RGVsZXRpb24sIGdsb2JhbE9wdGlvbnMpO1xuICAgICAgICB1dGlsLm1lcmdlT3B0aW9ucyhwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zLCAnc2hhZG93JywgYWxsb3dEZWxldGlvbiwgZ2xvYmFsT3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKG5ld09wdGlvbnMuZGFzaGVzICE9PSB1bmRlZmluZWQgJiYgbmV3T3B0aW9ucy5kYXNoZXMgIT09IG51bGwpIHtcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLmRhc2hlcyA9IG5ld09wdGlvbnMuZGFzaGVzO1xuICAgICAgICB9IGVsc2UgaWYgKGFsbG93RGVsZXRpb24gPT09IHRydWUgJiYgbmV3T3B0aW9ucy5kYXNoZXMgPT09IG51bGwpIHtcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLmRhc2hlcyA9IE9iamVjdC5jcmVhdGUoZ2xvYmFsT3B0aW9ucy5kYXNoZXMpOyAvLyB0aGlzIHNldHMgdGhlIHBvaW50ZXIgb2YgdGhlIG9wdGlvbiBiYWNrIHRvIHRoZSBnbG9iYWwgb3B0aW9uLlxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHRoZSBzY2FsaW5nIG5ld09wdGlvbnNcbiAgICAgICAgaWYgKG5ld09wdGlvbnMuc2NhbGluZyAhPT0gdW5kZWZpbmVkICYmIG5ld09wdGlvbnMuc2NhbGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChuZXdPcHRpb25zLnNjYWxpbmcubWluICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmVudE9wdGlvbnMuc2NhbGluZy5taW4gPSBuZXdPcHRpb25zLnNjYWxpbmcubWluO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobmV3T3B0aW9ucy5zY2FsaW5nLm1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJlbnRPcHRpb25zLnNjYWxpbmcubWF4ID0gbmV3T3B0aW9ucy5zY2FsaW5nLm1heDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdXRpbC5tZXJnZU9wdGlvbnMocGFyZW50T3B0aW9ucy5zY2FsaW5nLCBuZXdPcHRpb25zLnNjYWxpbmcsICdsYWJlbCcsIGFsbG93RGVsZXRpb24sIGdsb2JhbE9wdGlvbnMuc2NhbGluZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoYWxsb3dEZWxldGlvbiA9PT0gdHJ1ZSAmJiBuZXdPcHRpb25zLnNjYWxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLnNjYWxpbmcgPSBPYmplY3QuY3JlYXRlKGdsb2JhbE9wdGlvbnMuc2NhbGluZyk7IC8vIHRoaXMgc2V0cyB0aGUgcG9pbnRlciBvZiB0aGUgb3B0aW9uIGJhY2sgdG8gdGhlIGdsb2JhbCBvcHRpb24uXG4gICAgICAgIH1cblxuICAgICAgICAvLyBoYW5kbGUgbXVsdGlwbGUgaW5wdXQgY2FzZXMgZm9yIGFycm93c1xuICAgICAgICBpZiAobmV3T3B0aW9ucy5hcnJvd3MgIT09IHVuZGVmaW5lZCAmJiBuZXdPcHRpb25zLmFycm93cyAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbmV3T3B0aW9ucy5hcnJvd3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgYXJyb3dzID0gbmV3T3B0aW9ucy5hcnJvd3MudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHBhcmVudE9wdGlvbnMuYXJyb3dzLnRvLmVuYWJsZWQgPSBhcnJvd3MuaW5kZXhPZihcInRvXCIpICE9IC0xO1xuICAgICAgICAgICAgcGFyZW50T3B0aW9ucy5hcnJvd3MubWlkZGxlLmVuYWJsZWQgPSBhcnJvd3MuaW5kZXhPZihcIm1pZGRsZVwiKSAhPSAtMTtcbiAgICAgICAgICAgIHBhcmVudE9wdGlvbnMuYXJyb3dzLmZyb20uZW5hYmxlZCA9IGFycm93cy5pbmRleE9mKFwiZnJvbVwiKSAhPSAtMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKF90eXBlb2YobmV3T3B0aW9ucy5hcnJvd3MpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdXRpbC5tZXJnZU9wdGlvbnMocGFyZW50T3B0aW9ucy5hcnJvd3MsIG5ld09wdGlvbnMuYXJyb3dzLCAndG8nLCBhbGxvd0RlbGV0aW9uLCBnbG9iYWxPcHRpb25zLmFycm93cyk7XG4gICAgICAgICAgICB1dGlsLm1lcmdlT3B0aW9ucyhwYXJlbnRPcHRpb25zLmFycm93cywgbmV3T3B0aW9ucy5hcnJvd3MsICdtaWRkbGUnLCBhbGxvd0RlbGV0aW9uLCBnbG9iYWxPcHRpb25zLmFycm93cyk7XG4gICAgICAgICAgICB1dGlsLm1lcmdlT3B0aW9ucyhwYXJlbnRPcHRpb25zLmFycm93cywgbmV3T3B0aW9ucy5hcnJvd3MsICdmcm9tJywgYWxsb3dEZWxldGlvbiwgZ2xvYmFsT3B0aW9ucy5hcnJvd3MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYXJyb3cgbmV3T3B0aW9ucyBjYW4gb25seSBiZSBhbiBvYmplY3Qgb3IgYSBzdHJpbmcuIFJlZmVyIHRvIHRoZSBkb2N1bWVudGF0aW9uLiBZb3UgdXNlZDpcIiArIEpTT04uc3RyaW5naWZ5KG5ld09wdGlvbnMuYXJyb3dzKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGFsbG93RGVsZXRpb24gPT09IHRydWUgJiYgbmV3T3B0aW9ucy5hcnJvd3MgPT09IG51bGwpIHtcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLmFycm93cyA9IE9iamVjdC5jcmVhdGUoZ2xvYmFsT3B0aW9ucy5hcnJvd3MpOyAvLyB0aGlzIHNldHMgdGhlIHBvaW50ZXIgb2YgdGhlIG9wdGlvbiBiYWNrIHRvIHRoZSBnbG9iYWwgb3B0aW9uLlxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGFuZGxlIG11bHRpcGxlIGlucHV0IGNhc2VzIGZvciBjb2xvclxuICAgICAgICBpZiAobmV3T3B0aW9ucy5jb2xvciAhPT0gdW5kZWZpbmVkICYmIG5ld09wdGlvbnMuY29sb3IgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBtYWtlIGEgY29weSBvZiB0aGUgcGFyZW50IG9iamVjdCBpbiBjYXNlIHRoaXMgaXMgcmVmZXJyaW5nIHRvIHRoZSBnbG9iYWwgb25lIChkdWUgdG8gb2JqZWN0IGNyZWF0ZSBvbmNlLCB0aGVuIHVwZGF0ZSlcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLmNvbG9yID0gdXRpbC5kZWVwRXh0ZW5kKHt9LCBwYXJlbnRPcHRpb25zLmNvbG9yLCB0cnVlKTtcbiAgICAgICAgICBpZiAodXRpbC5pc1N0cmluZyhuZXdPcHRpb25zLmNvbG9yKSkge1xuICAgICAgICAgICAgcGFyZW50T3B0aW9ucy5jb2xvci5jb2xvciA9IG5ld09wdGlvbnMuY29sb3I7XG4gICAgICAgICAgICBwYXJlbnRPcHRpb25zLmNvbG9yLmhpZ2hsaWdodCA9IG5ld09wdGlvbnMuY29sb3I7XG4gICAgICAgICAgICBwYXJlbnRPcHRpb25zLmNvbG9yLmhvdmVyID0gbmV3T3B0aW9ucy5jb2xvcjtcbiAgICAgICAgICAgIHBhcmVudE9wdGlvbnMuY29sb3IuaW5oZXJpdCA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgY29sb3JzRGVmaW5lZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG5ld09wdGlvbnMuY29sb3IuY29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBwYXJlbnRPcHRpb25zLmNvbG9yLmNvbG9yID0gbmV3T3B0aW9ucy5jb2xvci5jb2xvcjtjb2xvcnNEZWZpbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdPcHRpb25zLmNvbG9yLmhpZ2hsaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHBhcmVudE9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0ID0gbmV3T3B0aW9ucy5jb2xvci5oaWdobGlnaHQ7Y29sb3JzRGVmaW5lZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3T3B0aW9ucy5jb2xvci5ob3ZlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHBhcmVudE9wdGlvbnMuY29sb3IuaG92ZXIgPSBuZXdPcHRpb25zLmNvbG9yLmhvdmVyO2NvbG9yc0RlZmluZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld09wdGlvbnMuY29sb3IuaW5oZXJpdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHBhcmVudE9wdGlvbnMuY29sb3IuaW5oZXJpdCA9IG5ld09wdGlvbnMuY29sb3IuaW5oZXJpdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdPcHRpb25zLmNvbG9yLm9wYWNpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBwYXJlbnRPcHRpb25zLmNvbG9yLm9wYWNpdHkgPSBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBuZXdPcHRpb25zLmNvbG9yLm9wYWNpdHkpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5ld09wdGlvbnMuY29sb3IuaW5oZXJpdCA9PT0gdW5kZWZpbmVkICYmIGNvbG9yc0RlZmluZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgcGFyZW50T3B0aW9ucy5jb2xvci5pbmhlcml0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGFsbG93RGVsZXRpb24gPT09IHRydWUgJiYgbmV3T3B0aW9ucy5jb2xvciA9PT0gbnVsbCkge1xuICAgICAgICAgIHBhcmVudE9wdGlvbnMuY29sb3IgPSB1dGlsLmJyaWRnZU9iamVjdChnbG9iYWxPcHRpb25zLmNvbG9yKTsgLy8gc2V0IHRoZSBvYmplY3QgYmFjayB0byB0aGUgZ2xvYmFsIG9wdGlvbnNcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhbmRsZSB0aGUgZm9udCBzZXR0aW5nc1xuICAgICAgICBpZiAobmV3T3B0aW9ucy5mb250ICE9PSB1bmRlZmluZWQgJiYgbmV3T3B0aW9ucy5mb250ICE9PSBudWxsKSB7XG4gICAgICAgICAgX0xhYmVsMi5kZWZhdWx0LnBhcnNlT3B0aW9ucyhwYXJlbnRPcHRpb25zLmZvbnQsIG5ld09wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKGFsbG93RGVsZXRpb24gPT09IHRydWUgJiYgbmV3T3B0aW9ucy5mb250ID09PSBudWxsKSB7XG4gICAgICAgICAgcGFyZW50T3B0aW9ucy5mb250ID0gdXRpbC5icmlkZ2VPYmplY3QoZ2xvYmFsT3B0aW9ucy5mb250KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBFZGdlO1xuICB9KCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gRWRnZTtcblxuLyoqKi8gfSxcbi8qIDg2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgdmFyIF9DdWJpY0JlemllckVkZ2VCYXNlMiA9IF9fd2VicGFja19yZXF1aXJlX18oODcpO1xuXG4gIHZhciBfQ3ViaWNCZXppZXJFZGdlQmFzZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DdWJpY0JlemllckVkZ2VCYXNlMik7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG4gIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4gIHZhciBDdWJpY0JlemllckVkZ2UgPSBmdW5jdGlvbiAoX0N1YmljQmV6aWVyRWRnZUJhc2UpIHtcbiAgICBfaW5oZXJpdHMoQ3ViaWNCZXppZXJFZGdlLCBfQ3ViaWNCZXppZXJFZGdlQmFzZSk7XG5cbiAgICBmdW5jdGlvbiBDdWJpY0JlemllckVkZ2Uob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDdWJpY0JlemllckVkZ2UpO1xuXG4gICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKEN1YmljQmV6aWVyRWRnZSkuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYXcgYSBsaW5lIGJldHdlZW4gdHdvIG5vZGVzXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhDdWJpY0JlemllckVkZ2UsIFt7XG4gICAgICBrZXk6ICdfbGluZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2xpbmUoY3R4LCB2aWFOb2Rlcykge1xuICAgICAgICAvLyBnZXQgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBzdXBwb3J0IHBvaW50cy5cbiAgICAgICAgdmFyIHZpYTEgPSB2aWFOb2Rlc1swXTtcbiAgICAgICAgdmFyIHZpYTIgPSB2aWFOb2Rlc1sxXTtcblxuICAgICAgICAvLyBzdGFydCBkcmF3aW5nIHRoZSBsaW5lLlxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8odGhpcy5mcm9tUG9pbnQueCwgdGhpcy5mcm9tUG9pbnQueSk7XG5cbiAgICAgICAgLy8gZmFsbGJhY2sgdG8gbm9ybWFsIHN0cmFpZ2h0IGVkZ2VzXG4gICAgICAgIGlmICh2aWFOb2RlcyA9PT0gdW5kZWZpbmVkIHx8IHZpYTEueCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY3R4LmxpbmVUbyh0aGlzLnRvUG9pbnQueCwgdGhpcy50b1BvaW50LnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHZpYTEueCwgdmlhMS55LCB2aWEyLngsIHZpYTIueSwgdGhpcy50b1BvaW50LngsIHRoaXMudG9Qb2ludC55KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG4gICAgICAgIHRoaXMuZW5hYmxlU2hhZG93KGN0eCk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2dldFZpYUNvb3JkaW5hdGVzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VmlhQ29vcmRpbmF0ZXMoKSB7XG4gICAgICAgIHZhciBkeCA9IHRoaXMuZnJvbS54IC0gdGhpcy50by54O1xuICAgICAgICB2YXIgZHkgPSB0aGlzLmZyb20ueSAtIHRoaXMudG8ueTtcblxuICAgICAgICB2YXIgeDEgPSB2b2lkIDAsXG4gICAgICAgICAgICB5MSA9IHZvaWQgMCxcbiAgICAgICAgICAgIHgyID0gdm9pZCAwLFxuICAgICAgICAgICAgeTIgPSB2b2lkIDA7XG4gICAgICAgIHZhciByb3VuZG5lc3MgPSB0aGlzLm9wdGlvbnMuc21vb3RoLnJvdW5kbmVzcztcblxuICAgICAgICAvLyBob3Jpem9udGFsIGlmIHggPiB5IG9yIGlmIGRpcmVjdGlvbiBpcyBmb3JjZWQgb3IgaWYgZGlyZWN0aW9uIGlzIGhvcml6b250YWxcbiAgICAgICAgaWYgKChNYXRoLmFicyhkeCkgPiBNYXRoLmFicyhkeSkgfHwgdGhpcy5vcHRpb25zLnNtb290aC5mb3JjZURpcmVjdGlvbiA9PT0gdHJ1ZSB8fCB0aGlzLm9wdGlvbnMuc21vb3RoLmZvcmNlRGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcpICYmIHRoaXMub3B0aW9ucy5zbW9vdGguZm9yY2VEaXJlY3Rpb24gIT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICB5MSA9IHRoaXMuZnJvbS55O1xuICAgICAgICAgIHkyID0gdGhpcy50by55O1xuICAgICAgICAgIHgxID0gdGhpcy5mcm9tLnggLSByb3VuZG5lc3MgKiBkeDtcbiAgICAgICAgICB4MiA9IHRoaXMudG8ueCArIHJvdW5kbmVzcyAqIGR4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHkxID0gdGhpcy5mcm9tLnkgLSByb3VuZG5lc3MgKiBkeTtcbiAgICAgICAgICB5MiA9IHRoaXMudG8ueSArIHJvdW5kbmVzcyAqIGR5O1xuICAgICAgICAgIHgxID0gdGhpcy5mcm9tLng7XG4gICAgICAgICAgeDIgPSB0aGlzLnRvLng7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW3sgeDogeDEsIHk6IHkxIH0sIHsgeDogeDIsIHk6IHkyIH1dO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldFZpYU5vZGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZpYU5vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRWaWFDb29yZGluYXRlcygpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19maW5kQm9yZGVyUG9zaXRpb24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kQm9yZGVyUG9zaXRpb24obmVhck5vZGUsIGN0eCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uQmV6aWVyKG5lYXJOb2RlLCBjdHgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19nZXREaXN0YW5jZVRvRWRnZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERpc3RhbmNlVG9FZGdlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICAgICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDYgfHwgYXJndW1lbnRzWzZdID09PSB1bmRlZmluZWQgPyB0aGlzLl9nZXRWaWFDb29yZGluYXRlcygpIDogYXJndW1lbnRzWzZdO1xuXG4gICAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpO1xuXG4gICAgICAgIHZhciB2aWExID0gX3JlZjJbMF07XG4gICAgICAgIHZhciB2aWEyID0gX3JlZjJbMV07XG4gICAgICAgIC8vIHgzLHkzIGlzIHRoZSBwb2ludFxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0RGlzdGFuY2VUb0JlemllckVkZ2UoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgdmlhMSwgdmlhMik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29tYmluZWQgZnVuY3Rpb24gb2YgcG9pbnRPbkxpbmUgYW5kIHBvaW50T25CZXppZXIuIFRoaXMgZ2l2ZXMgdGhlIGNvb3JkaW5hdGVzIG9mIGEgcG9pbnQgb24gdGhlIGxpbmUgYXQgYSBjZXJ0YWluIHBlcmNlbnRhZ2Ugb2YgdGhlIHdheVxuICAgICAgICogQHBhcmFtIHBlcmNlbnRhZ2VcbiAgICAgICAqIEBwYXJhbSB2aWFcbiAgICAgICAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0UG9pbnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvaW50KHBlcmNlbnRhZ2UpIHtcbiAgICAgICAgdmFyIF9yZWYzID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fZ2V0VmlhQ29vcmRpbmF0ZXMoKSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICB2YXIgX3JlZjQgPSBfc2xpY2VkVG9BcnJheShfcmVmMywgMik7XG5cbiAgICAgICAgdmFyIHZpYTEgPSBfcmVmNFswXTtcbiAgICAgICAgdmFyIHZpYTIgPSBfcmVmNFsxXTtcblxuICAgICAgICB2YXIgdCA9IHBlcmNlbnRhZ2U7XG4gICAgICAgIHZhciB2ZWMgPSBbXTtcbiAgICAgICAgdmVjWzBdID0gTWF0aC5wb3coMSAtIHQsIDMpO1xuICAgICAgICB2ZWNbMV0gPSAzICogdCAqIE1hdGgucG93KDEgLSB0LCAyKTtcbiAgICAgICAgdmVjWzJdID0gMyAqIE1hdGgucG93KHQsIDIpICogKDEgLSB0KTtcbiAgICAgICAgdmVjWzNdID0gTWF0aC5wb3codCwgMyk7XG4gICAgICAgIHZhciB4ID0gdmVjWzBdICogdGhpcy5mcm9tUG9pbnQueCArIHZlY1sxXSAqIHZpYTEueCArIHZlY1syXSAqIHZpYTIueCArIHZlY1szXSAqIHRoaXMudG9Qb2ludC54O1xuICAgICAgICB2YXIgeSA9IHZlY1swXSAqIHRoaXMuZnJvbVBvaW50LnkgKyB2ZWNbMV0gKiB2aWExLnkgKyB2ZWNbMl0gKiB2aWEyLnkgKyB2ZWNbM10gKiB0aGlzLnRvUG9pbnQueTtcblxuICAgICAgICByZXR1cm4geyB4OiB4LCB5OiB5IH07XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEN1YmljQmV6aWVyRWRnZTtcbiAgfShfQ3ViaWNCZXppZXJFZGdlQmFzZTMuZGVmYXVsdCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gQ3ViaWNCZXppZXJFZGdlO1xuXG4vKioqLyB9LFxuLyogODcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIHZhciBfQmV6aWVyRWRnZUJhc2UyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4OCk7XG5cbiAgdmFyIF9CZXppZXJFZGdlQmFzZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CZXppZXJFZGdlQmFzZTIpO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuICBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuICB2YXIgQ3ViaWNCZXppZXJFZGdlQmFzZSA9IGZ1bmN0aW9uIChfQmV6aWVyRWRnZUJhc2UpIHtcbiAgICBfaW5oZXJpdHMoQ3ViaWNCZXppZXJFZGdlQmFzZSwgX0JlemllckVkZ2VCYXNlKTtcblxuICAgIGZ1bmN0aW9uIEN1YmljQmV6aWVyRWRnZUJhc2Uob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDdWJpY0JlemllckVkZ2VCYXNlKTtcblxuICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihDdWJpY0JlemllckVkZ2VCYXNlKS5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGEgcG9pbnQgKHgzLHkzKSBhbmQgYSBsaW5lIHNlZ21lbnQgZnJvbVxuICAgICAqICh4MSx5MSkgdG8gKHgyLHkyKS5cbiAgICAgKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg0OTIxMS9zaG9ydGVzdC1kaXN0YW5jYWUtYmV0d2Vlbi1hLXBvaW50LWFuZC1hLWxpbmUtc2VnbWVudFxuICAgICAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0IlQzMlQTl6aWVyX2N1cnZlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgxIGZyb20geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MSBmcm9tIHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDIgdG8geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MiB0byB5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgzIHBvaW50IHRvIGNoZWNrIHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTMgcG9pbnQgdG8gY2hlY2sgeVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhDdWJpY0JlemllckVkZ2VCYXNlLCBbe1xuICAgICAga2V5OiAnX2dldERpc3RhbmNlVG9CZXppZXJFZGdlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGlzdGFuY2VUb0JlemllckVkZ2UoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgdmlhMSwgdmlhMikge1xuICAgICAgICAvLyB4Myx5MyBpcyB0aGUgcG9pbnRcbiAgICAgICAgdmFyIG1pbkRpc3RhbmNlID0gMWU5O1xuICAgICAgICB2YXIgZGlzdGFuY2UgPSB2b2lkIDA7XG4gICAgICAgIHZhciBpID0gdm9pZCAwLFxuICAgICAgICAgICAgdCA9IHZvaWQgMCxcbiAgICAgICAgICAgIHggPSB2b2lkIDAsXG4gICAgICAgICAgICB5ID0gdm9pZCAwO1xuICAgICAgICB2YXIgbGFzdFggPSB4MTtcbiAgICAgICAgdmFyIGxhc3RZID0geTE7XG4gICAgICAgIHZhciB2ZWMgPSBbMCwgMCwgMCwgMF07XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgICAgdCA9IDAuMSAqIGk7XG4gICAgICAgICAgdmVjWzBdID0gTWF0aC5wb3coMSAtIHQsIDMpO1xuICAgICAgICAgIHZlY1sxXSA9IDMgKiB0ICogTWF0aC5wb3coMSAtIHQsIDIpO1xuICAgICAgICAgIHZlY1syXSA9IDMgKiBNYXRoLnBvdyh0LCAyKSAqICgxIC0gdCk7XG4gICAgICAgICAgdmVjWzNdID0gTWF0aC5wb3codCwgMyk7XG4gICAgICAgICAgeCA9IHZlY1swXSAqIHgxICsgdmVjWzFdICogdmlhMS54ICsgdmVjWzJdICogdmlhMi54ICsgdmVjWzNdICogeDI7XG4gICAgICAgICAgeSA9IHZlY1swXSAqIHkxICsgdmVjWzFdICogdmlhMS55ICsgdmVjWzJdICogdmlhMi55ICsgdmVjWzNdICogeTI7XG4gICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBkaXN0YW5jZSA9IHRoaXMuX2dldERpc3RhbmNlVG9MaW5lKGxhc3RYLCBsYXN0WSwgeCwgeSwgeDMsIHkzKTtcbiAgICAgICAgICAgIG1pbkRpc3RhbmNlID0gZGlzdGFuY2UgPCBtaW5EaXN0YW5jZSA/IGRpc3RhbmNlIDogbWluRGlzdGFuY2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxhc3RYID0geDtcbiAgICAgICAgICBsYXN0WSA9IHk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWluRGlzdGFuY2U7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEN1YmljQmV6aWVyRWRnZUJhc2U7XG4gIH0oX0JlemllckVkZ2VCYXNlMy5kZWZhdWx0KTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBDdWJpY0JlemllckVkZ2VCYXNlO1xuXG4vKioqLyB9LFxuLyogODggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIHZhciBfRWRnZUJhc2UyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4OSk7XG5cbiAgdmFyIF9FZGdlQmFzZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9FZGdlQmFzZTIpO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuICBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuICB2YXIgQmV6aWVyRWRnZUJhc2UgPSBmdW5jdGlvbiAoX0VkZ2VCYXNlKSB7XG4gICAgX2luaGVyaXRzKEJlemllckVkZ2VCYXNlLCBfRWRnZUJhc2UpO1xuXG4gICAgZnVuY3Rpb24gQmV6aWVyRWRnZUJhc2Uob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCZXppZXJFZGdlQmFzZSk7XG5cbiAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQmV6aWVyRWRnZUJhc2UpLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHVzZXMgYmluYXJ5IHNlYXJjaCB0byBsb29rIGZvciB0aGUgcG9pbnQgd2hlcmUgdGhlIGJlemllciBjdXJ2ZSBjcm9zc2VzIHRoZSBib3JkZXIgb2YgdGhlIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmVhck5vZGVcbiAgICAgKiBAcGFyYW0gY3R4XG4gICAgICogQHBhcmFtIHZpYU5vZGVcbiAgICAgKiBAcGFyYW0gbmVhck5vZGVcbiAgICAgKiBAcGFyYW0gY3R4XG4gICAgICogQHBhcmFtIHZpYU5vZGVcbiAgICAgKiBAcGFyYW0gbmVhck5vZGVcbiAgICAgKiBAcGFyYW0gY3R4XG4gICAgICogQHBhcmFtIHZpYU5vZGVcbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKEJlemllckVkZ2VCYXNlLCBbe1xuICAgICAga2V5OiAnX2ZpbmRCb3JkZXJQb3NpdGlvbkJlemllcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRCb3JkZXJQb3NpdGlvbkJlemllcihuZWFyTm9kZSwgY3R4KSB7XG4gICAgICAgIHZhciB2aWFOb2RlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fZ2V0VmlhQ29vcmRpbmF0ZXMoKSA6IGFyZ3VtZW50c1syXTtcblxuICAgICAgICB2YXIgbWF4SXRlcmF0aW9ucyA9IDEwO1xuICAgICAgICB2YXIgaXRlcmF0aW9uID0gMDtcbiAgICAgICAgdmFyIGxvdyA9IDA7XG4gICAgICAgIHZhciBoaWdoID0gMTtcbiAgICAgICAgdmFyIHBvcywgYW5nbGUsIGRpc3RhbmNlVG9Cb3JkZXIsIGRpc3RhbmNlVG9Qb2ludCwgZGlmZmVyZW5jZTtcbiAgICAgICAgdmFyIHRocmVzaG9sZCA9IDAuMjtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnRvO1xuICAgICAgICB2YXIgZnJvbSA9IGZhbHNlO1xuICAgICAgICBpZiAobmVhck5vZGUuaWQgPT09IHRoaXMuZnJvbS5pZCkge1xuICAgICAgICAgIG5vZGUgPSB0aGlzLmZyb207XG4gICAgICAgICAgZnJvbSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAobG93IDw9IGhpZ2ggJiYgaXRlcmF0aW9uIDwgbWF4SXRlcmF0aW9ucykge1xuICAgICAgICAgIHZhciBtaWRkbGUgPSAobG93ICsgaGlnaCkgKiAwLjU7XG5cbiAgICAgICAgICBwb3MgPSB0aGlzLmdldFBvaW50KG1pZGRsZSwgdmlhTm9kZSk7XG4gICAgICAgICAgYW5nbGUgPSBNYXRoLmF0YW4yKG5vZGUueSAtIHBvcy55LCBub2RlLnggLSBwb3MueCk7XG4gICAgICAgICAgZGlzdGFuY2VUb0JvcmRlciA9IG5vZGUuZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICAgICAgICBkaXN0YW5jZVRvUG9pbnQgPSBNYXRoLnNxcnQoTWF0aC5wb3cocG9zLnggLSBub2RlLngsIDIpICsgTWF0aC5wb3cocG9zLnkgLSBub2RlLnksIDIpKTtcbiAgICAgICAgICBkaWZmZXJlbmNlID0gZGlzdGFuY2VUb0JvcmRlciAtIGRpc3RhbmNlVG9Qb2ludDtcbiAgICAgICAgICBpZiAoTWF0aC5hYnMoZGlmZmVyZW5jZSkgPCB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgIGJyZWFrOyAvLyBmb3VuZFxuICAgICAgICAgIH0gZWxzZSBpZiAoZGlmZmVyZW5jZSA8IDApIHtcbiAgICAgICAgICAgICAgLy8gZGlzdGFuY2UgdG8gbm9kZXMgaXMgbGFyZ2VyIHRoYW4gZGlzdGFuY2UgdG8gYm9yZGVyIC0tPiB0IG5lZWRzIHRvIGJlIGJpZ2dlciBpZiB3ZSdyZSBsb29raW5nIGF0IHRoZSB0byBub2RlLlxuICAgICAgICAgICAgICBpZiAoZnJvbSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBsb3cgPSBtaWRkbGU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaGlnaCA9IG1pZGRsZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGZyb20gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgaGlnaCA9IG1pZGRsZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb3cgPSBtaWRkbGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGl0ZXJhdGlvbisrO1xuICAgICAgICB9XG4gICAgICAgIHBvcy50ID0gbWlkZGxlO1xuXG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGEgcG9pbnQgKHgzLHkzKSBhbmQgYSBsaW5lIHNlZ21lbnQgZnJvbVxuICAgICAgICogKHgxLHkxKSB0byAoeDIseTIpLlxuICAgICAgICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84NDkyMTEvc2hvcnRlc3QtZGlzdGFuY2FlLWJldHdlZW4tYS1wb2ludC1hbmQtYS1saW5lLXNlZ21lbnRcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MSBmcm9tIHhcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MSBmcm9tIHlcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MiB0byB4XG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0geTIgdG8geVxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHgzIHBvaW50IHRvIGNoZWNrIHhcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MyBwb2ludCB0byBjaGVjayB5XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZ2V0RGlzdGFuY2VUb0JlemllckVkZ2UnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXREaXN0YW5jZVRvQmV6aWVyRWRnZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB2aWEpIHtcbiAgICAgICAgLy8geDMseTMgaXMgdGhlIHBvaW50XG4gICAgICAgIHZhciBtaW5EaXN0YW5jZSA9IDFlOTtcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gdm9pZCAwO1xuICAgICAgICB2YXIgaSA9IHZvaWQgMCxcbiAgICAgICAgICAgIHQgPSB2b2lkIDAsXG4gICAgICAgICAgICB4ID0gdm9pZCAwLFxuICAgICAgICAgICAgeSA9IHZvaWQgMDtcbiAgICAgICAgdmFyIGxhc3RYID0geDE7XG4gICAgICAgIHZhciBsYXN0WSA9IHkxO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgMTA7IGkrKykge1xuICAgICAgICAgIHQgPSAwLjEgKiBpO1xuICAgICAgICAgIHggPSBNYXRoLnBvdygxIC0gdCwgMikgKiB4MSArIDIgKiB0ICogKDEgLSB0KSAqIHZpYS54ICsgTWF0aC5wb3codCwgMikgKiB4MjtcbiAgICAgICAgICB5ID0gTWF0aC5wb3coMSAtIHQsIDIpICogeTEgKyAyICogdCAqICgxIC0gdCkgKiB2aWEueSArIE1hdGgucG93KHQsIDIpICogeTI7XG4gICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBkaXN0YW5jZSA9IHRoaXMuX2dldERpc3RhbmNlVG9MaW5lKGxhc3RYLCBsYXN0WSwgeCwgeSwgeDMsIHkzKTtcbiAgICAgICAgICAgIG1pbkRpc3RhbmNlID0gZGlzdGFuY2UgPCBtaW5EaXN0YW5jZSA/IGRpc3RhbmNlIDogbWluRGlzdGFuY2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxhc3RYID0geDtcbiAgICAgICAgICBsYXN0WSA9IHk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWluRGlzdGFuY2U7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEJlemllckVkZ2VCYXNlO1xuICB9KF9FZGdlQmFzZTMuZGVmYXVsdCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gQmV6aWVyRWRnZUJhc2U7XG5cbi8qKiovIH0sXG4vKiA4OSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgdmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4gIHZhciBFZGdlQmFzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFZGdlQmFzZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVkZ2VCYXNlKTtcblxuICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgIHRoaXMubGFiZWxNb2R1bGUgPSBsYWJlbE1vZHVsZTtcbiAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgdGhpcy5jb2xvckRpcnR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMuY29sb3IgPSB7fTtcbiAgICAgIHRoaXMuc2VsZWN0aW9uV2lkdGggPSAyO1xuICAgICAgdGhpcy5ob3ZlcldpZHRoID0gMS41O1xuICAgICAgdGhpcy5mcm9tUG9pbnQgPSB0aGlzLmZyb207XG4gICAgICB0aGlzLnRvUG9pbnQgPSB0aGlzLnRvO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhFZGdlQmFzZSwgW3tcbiAgICAgIGtleTogJ2Nvbm5lY3QnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLm9wdGlvbnMuZnJvbV07XG4gICAgICAgIHRoaXMudG8gPSB0aGlzLmJvZHkubm9kZXNbdGhpcy5vcHRpb25zLnRvXTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdjbGVhbnVwJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnc2V0T3B0aW9ucycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuZnJvbSA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLm9wdGlvbnMuZnJvbV07XG4gICAgICAgIHRoaXMudG8gPSB0aGlzLmJvZHkubm9kZXNbdGhpcy5vcHRpb25zLnRvXTtcbiAgICAgICAgdGhpcy5pZCA9IHRoaXMub3B0aW9ucy5pZDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZWRyYXcgYSBlZGdlIGFzIGEgbGluZVxuICAgICAgICogRHJhdyB0aGlzIGVkZ2UgaW4gdGhlIGdpdmVuIGNhbnZhc1xuICAgICAgICogVGhlIDJkIGNvbnRleHQgb2YgYSBIVE1MIGNhbnZhcyBjYW4gYmUgcmV0cmlldmVkIGJ5IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gICBjdHhcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2RyYXdMaW5lJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3TGluZShjdHgsIHNlbGVjdGVkLCBob3ZlciwgdmlhTm9kZSkge1xuICAgICAgICAvLyBzZXQgc3R5bGVcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5nZXRDb2xvcihjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmdldExpbmVXaWR0aChzZWxlY3RlZCwgaG92ZXIpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGFzaGVzICE9PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMuX2RyYXdEYXNoZWRMaW5lKGN0eCwgdmlhTm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fZHJhd0xpbmUoY3R4LCB2aWFOb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19kcmF3TGluZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdMaW5lKGN0eCwgdmlhTm9kZSwgZnJvbVBvaW50LCB0b1BvaW50KSB7XG4gICAgICAgIGlmICh0aGlzLmZyb20gIT0gdGhpcy50bykge1xuICAgICAgICAgIC8vIGRyYXcgbGluZVxuICAgICAgICAgIHRoaXMuX2xpbmUoY3R4LCB2aWFOb2RlLCBmcm9tUG9pbnQsIHRvUG9pbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfZ2V0Q2lyY2xlRGF0YTIgPSB0aGlzLl9nZXRDaXJjbGVEYXRhKGN0eCk7XG5cbiAgICAgICAgICB2YXIgX2dldENpcmNsZURhdGEzID0gX3NsaWNlZFRvQXJyYXkoX2dldENpcmNsZURhdGEyLCAzKTtcblxuICAgICAgICAgIHZhciB4ID0gX2dldENpcmNsZURhdGEzWzBdO1xuICAgICAgICAgIHZhciB5ID0gX2dldENpcmNsZURhdGEzWzFdO1xuICAgICAgICAgIHZhciByYWRpdXMgPSBfZ2V0Q2lyY2xlRGF0YTNbMl07XG5cbiAgICAgICAgICB0aGlzLl9jaXJjbGUoY3R4LCB4LCB5LCByYWRpdXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2RyYXdEYXNoZWRMaW5lJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd0Rhc2hlZExpbmUoY3R4LCB2aWFOb2RlLCBmcm9tUG9pbnQsIHRvUG9pbnQpIHtcbiAgICAgICAgY3R4LmxpbmVDYXAgPSAncm91bmQnO1xuICAgICAgICB2YXIgcGF0dGVybiA9IFs1LCA1XTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5vcHRpb25zLmRhc2hlcykgPT09IHRydWUpIHtcbiAgICAgICAgICBwYXR0ZXJuID0gdGhpcy5vcHRpb25zLmRhc2hlcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG9ubHkgZmlyZWZveCBhbmQgY2hyb21lIHN1cHBvcnQgdGhpcyBtZXRob2QsIGVsc2Ugd2UgdXNlIHRoZSBsZWdhY3kgb25lLlxuICAgICAgICBpZiAoY3R4LnNldExpbmVEYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICAgICAgLy8gc2V0IGRhc2ggc2V0dGluZ3MgZm9yIGNocm9tZSBvciBmaXJlZm94XG4gICAgICAgICAgY3R4LnNldExpbmVEYXNoKHBhdHRlcm4pO1xuICAgICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IDA7XG5cbiAgICAgICAgICAvLyBkcmF3IHRoZSBsaW5lXG4gICAgICAgICAgaWYgKHRoaXMuZnJvbSAhPSB0aGlzLnRvKSB7XG4gICAgICAgICAgICAvLyBkcmF3IGxpbmVcbiAgICAgICAgICAgIHRoaXMuX2xpbmUoY3R4LCB2aWFOb2RlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIF9nZXRDaXJjbGVEYXRhNCA9IHRoaXMuX2dldENpcmNsZURhdGEoY3R4KTtcblxuICAgICAgICAgICAgdmFyIF9nZXRDaXJjbGVEYXRhNSA9IF9zbGljZWRUb0FycmF5KF9nZXRDaXJjbGVEYXRhNCwgMyk7XG5cbiAgICAgICAgICAgIHZhciB4ID0gX2dldENpcmNsZURhdGE1WzBdO1xuICAgICAgICAgICAgdmFyIHkgPSBfZ2V0Q2lyY2xlRGF0YTVbMV07XG4gICAgICAgICAgICB2YXIgcmFkaXVzID0gX2dldENpcmNsZURhdGE1WzJdO1xuXG4gICAgICAgICAgICB0aGlzLl9jaXJjbGUoY3R4LCB4LCB5LCByYWRpdXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHJlc3RvcmUgdGhlIGRhc2ggc2V0dGluZ3MuXG4gICAgICAgICAgY3R4LnNldExpbmVEYXNoKFswXSk7XG4gICAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gMDtcbiAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHVuc3VwcG9ydGluZyBzbW9vdGggbGluZXNcbiAgICAgICAgICBpZiAodGhpcy5mcm9tICE9IHRoaXMudG8pIHtcbiAgICAgICAgICAgIC8vIGRyYXcgbGluZVxuICAgICAgICAgICAgY3R4LmRhc2hlZExpbmUodGhpcy5mcm9tLngsIHRoaXMuZnJvbS55LCB0aGlzLnRvLngsIHRoaXMudG8ueSwgcGF0dGVybik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBfZ2V0Q2lyY2xlRGF0YTYgPSB0aGlzLl9nZXRDaXJjbGVEYXRhKGN0eCk7XG5cbiAgICAgICAgICAgIHZhciBfZ2V0Q2lyY2xlRGF0YTcgPSBfc2xpY2VkVG9BcnJheShfZ2V0Q2lyY2xlRGF0YTYsIDMpO1xuXG4gICAgICAgICAgICB2YXIgX3ggPSBfZ2V0Q2lyY2xlRGF0YTdbMF07XG4gICAgICAgICAgICB2YXIgX3kgPSBfZ2V0Q2lyY2xlRGF0YTdbMV07XG4gICAgICAgICAgICB2YXIgX3JhZGl1cyA9IF9nZXRDaXJjbGVEYXRhN1syXTtcblxuICAgICAgICAgICAgdGhpcy5fY2lyY2xlKGN0eCwgX3gsIF95LCBfcmFkaXVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZHJhdyBzaGFkb3cgaWYgZW5hYmxlZFxuICAgICAgICAgIHRoaXMuZW5hYmxlU2hhZG93KGN0eCk7XG5cbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgICAvLyBkaXNhYmxlIHNoYWRvd3MgZm9yIG90aGVyIGVsZW1lbnRzLlxuICAgICAgICAgIHRoaXMuZGlzYWJsZVNoYWRvdyhjdHgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZmluZEJvcmRlclBvc2l0aW9uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kQm9yZGVyUG9zaXRpb24obmVhck5vZGUsIGN0eCwgb3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5mcm9tICE9IHRoaXMudG8pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uKG5lYXJOb2RlLCBjdHgsIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9maW5kQm9yZGVyUG9zaXRpb25DaXJjbGUobmVhck5vZGUsIGN0eCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdmaW5kQm9yZGVyUG9zaXRpb25zJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kQm9yZGVyUG9zaXRpb25zKGN0eCkge1xuICAgICAgICB2YXIgZnJvbSA9IHt9O1xuICAgICAgICB2YXIgdG8gPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuZnJvbSAhPSB0aGlzLnRvKSB7XG4gICAgICAgICAgZnJvbSA9IHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbih0aGlzLmZyb20sIGN0eCk7XG4gICAgICAgICAgdG8gPSB0aGlzLl9maW5kQm9yZGVyUG9zaXRpb24odGhpcy50bywgY3R4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX2dldENpcmNsZURhdGE4ID0gdGhpcy5fZ2V0Q2lyY2xlRGF0YShjdHgpO1xuXG4gICAgICAgICAgdmFyIF9nZXRDaXJjbGVEYXRhOSA9IF9zbGljZWRUb0FycmF5KF9nZXRDaXJjbGVEYXRhOCwgMyk7XG5cbiAgICAgICAgICB2YXIgeCA9IF9nZXRDaXJjbGVEYXRhOVswXTtcbiAgICAgICAgICB2YXIgeSA9IF9nZXRDaXJjbGVEYXRhOVsxXTtcbiAgICAgICAgICB2YXIgcmFkaXVzID0gX2dldENpcmNsZURhdGE5WzJdO1xuXG5cbiAgICAgICAgICBmcm9tID0gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uQ2lyY2xlKHRoaXMuZnJvbSwgY3R4LCB7IHg6IHgsIHk6IHksIGxvdzogMC4yNSwgaGlnaDogMC42LCBkaXJlY3Rpb246IC0xIH0pO1xuICAgICAgICAgIHRvID0gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uQ2lyY2xlKHRoaXMuZnJvbSwgY3R4LCB7IHg6IHgsIHk6IHksIGxvdzogMC42LCBoaWdoOiAwLjgsIGRpcmVjdGlvbjogMSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmcm9tOiBmcm9tLCB0bzogdG8gfTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZ2V0Q2lyY2xlRGF0YScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldENpcmNsZURhdGEoY3R4KSB7XG4gICAgICAgIHZhciB4ID0gdm9pZCAwLFxuICAgICAgICAgICAgeSA9IHZvaWQgMDtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmZyb207XG4gICAgICAgIHZhciByYWRpdXMgPSB0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZVNpemU7XG5cbiAgICAgICAgaWYgKGN0eCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKG5vZGUuc2hhcGUud2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbm9kZS5zaGFwZS5yZXNpemUoY3R4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgY2lyY2xlIGNvb3JkaW5hdGVzXG4gICAgICAgIGlmIChub2RlLnNoYXBlLndpZHRoID4gbm9kZS5zaGFwZS5oZWlnaHQpIHtcbiAgICAgICAgICB4ID0gbm9kZS54ICsgbm9kZS5zaGFwZS53aWR0aCAqIDAuNTtcbiAgICAgICAgICB5ID0gbm9kZS55IC0gcmFkaXVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHggPSBub2RlLnggKyByYWRpdXM7XG4gICAgICAgICAgeSA9IG5vZGUueSAtIG5vZGUuc2hhcGUuaGVpZ2h0ICogMC41O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbeCwgeSwgcmFkaXVzXTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBHZXQgYSBwb2ludCBvbiBhIGNpcmNsZVxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gcGVyY2VudGFnZS4gVmFsdWUgYmV0d2VlbiAwIChsaW5lIHN0YXJ0KSBhbmQgMSAobGluZSBlbmQpXG4gICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHBvaW50XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfcG9pbnRPbkNpcmNsZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3BvaW50T25DaXJjbGUoeCwgeSwgcmFkaXVzLCBwZXJjZW50YWdlKSB7XG4gICAgICAgIHZhciBhbmdsZSA9IHBlcmNlbnRhZ2UgKiAyICogTWF0aC5QSTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiB4ICsgcmFkaXVzICogTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICAgIHk6IHkgLSByYWRpdXMgKiBNYXRoLnNpbihhbmdsZSlcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIGZ1bmN0aW9uIHVzZXMgYmluYXJ5IHNlYXJjaCB0byBsb29rIGZvciB0aGUgcG9pbnQgd2hlcmUgdGhlIGNpcmNsZSBjcm9zc2VzIHRoZSBib3JkZXIgb2YgdGhlIG5vZGUuXG4gICAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAgICogQHBhcmFtIGN0eFxuICAgICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2ZpbmRCb3JkZXJQb3NpdGlvbkNpcmNsZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRCb3JkZXJQb3NpdGlvbkNpcmNsZShub2RlLCBjdHgsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHggPSBvcHRpb25zLng7XG4gICAgICAgIHZhciB5ID0gb3B0aW9ucy55O1xuICAgICAgICB2YXIgbG93ID0gb3B0aW9ucy5sb3c7XG4gICAgICAgIHZhciBoaWdoID0gb3B0aW9ucy5oaWdoO1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gb3B0aW9ucy5kaXJlY3Rpb247XG5cbiAgICAgICAgdmFyIG1heEl0ZXJhdGlvbnMgPSAxMDtcbiAgICAgICAgdmFyIGl0ZXJhdGlvbiA9IDA7XG4gICAgICAgIHZhciByYWRpdXMgPSB0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZVNpemU7XG4gICAgICAgIHZhciBwb3MgPSB2b2lkIDAsXG4gICAgICAgICAgICBhbmdsZSA9IHZvaWQgMCxcbiAgICAgICAgICAgIGRpc3RhbmNlVG9Cb3JkZXIgPSB2b2lkIDAsXG4gICAgICAgICAgICBkaXN0YW5jZVRvUG9pbnQgPSB2b2lkIDAsXG4gICAgICAgICAgICBkaWZmZXJlbmNlID0gdm9pZCAwO1xuICAgICAgICB2YXIgdGhyZXNob2xkID0gMC4wNTtcbiAgICAgICAgdmFyIG1pZGRsZSA9IChsb3cgKyBoaWdoKSAqIDAuNTtcblxuICAgICAgICB3aGlsZSAobG93IDw9IGhpZ2ggJiYgaXRlcmF0aW9uIDwgbWF4SXRlcmF0aW9ucykge1xuICAgICAgICAgIG1pZGRsZSA9IChsb3cgKyBoaWdoKSAqIDAuNTtcblxuICAgICAgICAgIHBvcyA9IHRoaXMuX3BvaW50T25DaXJjbGUoeCwgeSwgcmFkaXVzLCBtaWRkbGUpO1xuICAgICAgICAgIGFuZ2xlID0gTWF0aC5hdGFuMihub2RlLnkgLSBwb3MueSwgbm9kZS54IC0gcG9zLngpO1xuICAgICAgICAgIGRpc3RhbmNlVG9Cb3JkZXIgPSBub2RlLmRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgICAgICAgZGlzdGFuY2VUb1BvaW50ID0gTWF0aC5zcXJ0KE1hdGgucG93KHBvcy54IC0gbm9kZS54LCAyKSArIE1hdGgucG93KHBvcy55IC0gbm9kZS55LCAyKSk7XG4gICAgICAgICAgZGlmZmVyZW5jZSA9IGRpc3RhbmNlVG9Cb3JkZXIgLSBkaXN0YW5jZVRvUG9pbnQ7XG4gICAgICAgICAgaWYgKE1hdGguYWJzKGRpZmZlcmVuY2UpIDwgdGhyZXNob2xkKSB7XG4gICAgICAgICAgICBicmVhazsgLy8gZm91bmRcbiAgICAgICAgICB9IGVsc2UgaWYgKGRpZmZlcmVuY2UgPiAwKSB7XG4gICAgICAgICAgICAgIC8vIGRpc3RhbmNlIHRvIG5vZGVzIGlzIGxhcmdlciB0aGFuIGRpc3RhbmNlIHRvIGJvcmRlciAtLT4gdCBuZWVkcyB0byBiZSBiaWdnZXIgaWYgd2UncmUgbG9va2luZyBhdCB0aGUgdG8gbm9kZS5cbiAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA+IDApIHtcbiAgICAgICAgICAgICAgICBsb3cgPSBtaWRkbGU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaGlnaCA9IG1pZGRsZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA+IDApIHtcbiAgICAgICAgICAgICAgICBoaWdoID0gbWlkZGxlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvdyA9IG1pZGRsZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIGl0ZXJhdGlvbisrO1xuICAgICAgICB9XG4gICAgICAgIHBvcy50ID0gbWlkZGxlO1xuXG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0IHRoZSBsaW5lIHdpZHRoIG9mIHRoZSBlZGdlLiBEZXBlbmRzIG9uIHdpZHRoIGFuZCB3aGV0aGVyIG9uZSBvZiB0aGVcbiAgICAgICAqIGNvbm5lY3RlZCBub2RlcyBpcyBzZWxlY3RlZC5cbiAgICAgICAqIEByZXR1cm4ge051bWJlcn0gd2lkdGhcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldExpbmVXaWR0aCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGluZVdpZHRoKHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgICBpZiAoc2VsZWN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5zZWxlY3Rpb25XaWR0aCwgMC4zIC8gdGhpcy5ib2R5LnZpZXcuc2NhbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChob3ZlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuaG92ZXJXaWR0aCwgMC4zIC8gdGhpcy5ib2R5LnZpZXcuc2NhbGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5vcHRpb25zLndpZHRoLCAwLjMgLyB0aGlzLmJvZHkudmlldy5zY2FsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0Q29sb3InLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbG9yKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICAgIHZhciBjb2xvck9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuY29sb3I7XG4gICAgICAgIGlmIChjb2xvck9wdGlvbnMuaW5oZXJpdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAvLyB3aGVuIHRoaXMgaXMgYSBsb29wIGVkZ2UsIGp1c3QgdXNlIHRoZSAnZnJvbScgbWV0aG9kXG4gICAgICAgICAgaWYgKGNvbG9yT3B0aW9ucy5pbmhlcml0ID09PSAnYm90aCcgJiYgdGhpcy5mcm9tLmlkICE9PSB0aGlzLnRvLmlkKSB7XG4gICAgICAgICAgICB2YXIgZ3JkID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KHRoaXMuZnJvbS54LCB0aGlzLmZyb20ueSwgdGhpcy50by54LCB0aGlzLnRvLnkpO1xuICAgICAgICAgICAgdmFyIGZyb21Db2xvciA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICB0b0NvbG9yID0gdm9pZCAwO1xuICAgICAgICAgICAgZnJvbUNvbG9yID0gdGhpcy5mcm9tLm9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0LmJvcmRlcjtcbiAgICAgICAgICAgIHRvQ29sb3IgPSB0aGlzLnRvLm9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0LmJvcmRlcjtcblxuICAgICAgICAgICAgaWYgKHRoaXMuZnJvbS5zZWxlY3RlZCA9PT0gZmFsc2UgJiYgdGhpcy50by5zZWxlY3RlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgZnJvbUNvbG9yID0gdXRpbC5vdmVycmlkZU9wYWNpdHkodGhpcy5mcm9tLm9wdGlvbnMuY29sb3IuYm9yZGVyLCB0aGlzLm9wdGlvbnMuY29sb3Iub3BhY2l0eSk7XG4gICAgICAgICAgICAgIHRvQ29sb3IgPSB1dGlsLm92ZXJyaWRlT3BhY2l0eSh0aGlzLnRvLm9wdGlvbnMuY29sb3IuYm9yZGVyLCB0aGlzLm9wdGlvbnMuY29sb3Iub3BhY2l0eSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZnJvbS5zZWxlY3RlZCA9PT0gdHJ1ZSAmJiB0aGlzLnRvLnNlbGVjdGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICB0b0NvbG9yID0gdGhpcy50by5vcHRpb25zLmNvbG9yLmJvcmRlcjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5mcm9tLnNlbGVjdGVkID09PSBmYWxzZSAmJiB0aGlzLnRvLnNlbGVjdGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIGZyb21Db2xvciA9IHRoaXMuZnJvbS5vcHRpb25zLmNvbG9yLmJvcmRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdyZC5hZGRDb2xvclN0b3AoMCwgZnJvbUNvbG9yKTtcbiAgICAgICAgICAgIGdyZC5hZGRDb2xvclN0b3AoMSwgdG9Db2xvcik7XG5cbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tIHRoaXMgcmV0dXJucyAtLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuICAgICAgICAgICAgcmV0dXJuIGdyZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5jb2xvckRpcnR5ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAoY29sb3JPcHRpb25zLmluaGVyaXQgPT09IFwidG9cIikge1xuICAgICAgICAgICAgICB0aGlzLmNvbG9yLmhpZ2hsaWdodCA9IHRoaXMudG8ub3B0aW9ucy5jb2xvci5oaWdobGlnaHQuYm9yZGVyO1xuICAgICAgICAgICAgICB0aGlzLmNvbG9yLmhvdmVyID0gdGhpcy50by5vcHRpb25zLmNvbG9yLmhvdmVyLmJvcmRlcjtcbiAgICAgICAgICAgICAgdGhpcy5jb2xvci5jb2xvciA9IHV0aWwub3ZlcnJpZGVPcGFjaXR5KHRoaXMudG8ub3B0aW9ucy5jb2xvci5ib3JkZXIsIGNvbG9yT3B0aW9ucy5vcGFjaXR5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vICh0aGlzLm9wdGlvbnMuY29sb3IuaW5oZXJpdC5zb3VyY2UgPT09IFwiZnJvbVwiKSB7XG4gICAgICAgICAgICAgIHRoaXMuY29sb3IuaGlnaGxpZ2h0ID0gdGhpcy5mcm9tLm9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0LmJvcmRlcjtcbiAgICAgICAgICAgICAgdGhpcy5jb2xvci5ob3ZlciA9IHRoaXMuZnJvbS5vcHRpb25zLmNvbG9yLmhvdmVyLmJvcmRlcjtcbiAgICAgICAgICAgICAgdGhpcy5jb2xvci5jb2xvciA9IHV0aWwub3ZlcnJpZGVPcGFjaXR5KHRoaXMuZnJvbS5vcHRpb25zLmNvbG9yLmJvcmRlciwgY29sb3JPcHRpb25zLm9wYWNpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNvbG9yRGlydHkgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmNvbG9yLmhpZ2hsaWdodCA9IGNvbG9yT3B0aW9ucy5oaWdobGlnaHQ7XG4gICAgICAgICAgdGhpcy5jb2xvci5ob3ZlciA9IGNvbG9yT3B0aW9ucy5ob3ZlcjtcbiAgICAgICAgICB0aGlzLmNvbG9yLmNvbG9yID0gdXRpbC5vdmVycmlkZU9wYWNpdHkoY29sb3JPcHRpb25zLmNvbG9yLCBjb2xvck9wdGlvbnMub3BhY2l0eSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBjb2xvciBpbmhlcml0IGlzIG9uIGFuZCBncmFkaWVudHMgYXJlIHVzZWQsIHRoZSBmdW5jdGlvbiBoYXMgYWxyZWFkeSByZXR1cm5lZCBieSBub3cuXG4gICAgICAgIHRoaXMuY29sb3JEaXJ0eSA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChzZWxlY3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbG9yLmhpZ2hsaWdodDtcbiAgICAgICAgfSBlbHNlIGlmIChob3ZlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbG9yLmhvdmVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbG9yLmNvbG9yO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRHJhdyBhIGxpbmUgZnJvbSBhIG5vZGUgdG8gaXRzZWxmLCBhIGNpcmNsZVxuICAgICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY2lyY2xlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY2lyY2xlKGN0eCwgeCwgeSwgcmFkaXVzKSB7XG4gICAgICAgIC8vIGRyYXcgc2hhZG93IGlmIGVuYWJsZWRcbiAgICAgICAgdGhpcy5lbmFibGVTaGFkb3coY3R4KTtcblxuICAgICAgICAvLyBkcmF3IGEgY2lyY2xlXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgICAvLyBkaXNhYmxlIHNoYWRvd3MgZm9yIG90aGVyIGVsZW1lbnRzLlxuICAgICAgICB0aGlzLmRpc2FibGVTaGFkb3coY3R4KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGJldHdlZW4gYSBwb2ludCAoeDMseTMpIGFuZCBhIGxpbmUgc2VnbWVudCBmcm9tXG4gICAgICAgKiAoeDEseTEpIHRvICh4Mix5MikuXG4gICAgICAgKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg0OTIxMS9zaG9ydGVzdC1kaXN0YW5jYWUtYmV0d2Vlbi1hLXBvaW50LWFuZC1hLWxpbmUtc2VnbWVudFxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0geTFcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHkyXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0geDNcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5M1xuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0RGlzdGFuY2VUb0VkZ2UnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldERpc3RhbmNlVG9FZGdlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHZpYSkge1xuICAgICAgICAvLyB4Myx5MyBpcyB0aGUgcG9pbnRcbiAgICAgICAgdmFyIHJldHVyblZhbHVlID0gMDtcbiAgICAgICAgaWYgKHRoaXMuZnJvbSAhPSB0aGlzLnRvKSB7XG4gICAgICAgICAgcmV0dXJuVmFsdWUgPSB0aGlzLl9nZXREaXN0YW5jZVRvRWRnZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB2aWEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfZ2V0Q2lyY2xlRGF0YTEwID0gdGhpcy5fZ2V0Q2lyY2xlRGF0YSgpO1xuXG4gICAgICAgICAgdmFyIF9nZXRDaXJjbGVEYXRhMTEgPSBfc2xpY2VkVG9BcnJheShfZ2V0Q2lyY2xlRGF0YTEwLCAzKTtcblxuICAgICAgICAgIHZhciB4ID0gX2dldENpcmNsZURhdGExMVswXTtcbiAgICAgICAgICB2YXIgeSA9IF9nZXRDaXJjbGVEYXRhMTFbMV07XG4gICAgICAgICAgdmFyIHJhZGl1cyA9IF9nZXRDaXJjbGVEYXRhMTFbMl07XG5cbiAgICAgICAgICB2YXIgZHggPSB4IC0geDM7XG4gICAgICAgICAgdmFyIGR5ID0geSAtIHkzO1xuICAgICAgICAgIHJldHVyblZhbHVlID0gTWF0aC5hYnMoTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KSAtIHJhZGl1cyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5sYWJlbE1vZHVsZS5zaXplLmxlZnQgPCB4MyAmJiB0aGlzLmxhYmVsTW9kdWxlLnNpemUubGVmdCArIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS53aWR0aCA+IHgzICYmIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS50b3AgPCB5MyAmJiB0aGlzLmxhYmVsTW9kdWxlLnNpemUudG9wICsgdGhpcy5sYWJlbE1vZHVsZS5zaXplLmhlaWdodCA+IHkzKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2dldERpc3RhbmNlVG9MaW5lJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGlzdGFuY2VUb0xpbmUoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgICAgICB2YXIgcHggPSB4MiAtIHgxO1xuICAgICAgICB2YXIgcHkgPSB5MiAtIHkxO1xuICAgICAgICB2YXIgc29tZXRoaW5nID0gcHggKiBweCArIHB5ICogcHk7XG4gICAgICAgIHZhciB1ID0gKCh4MyAtIHgxKSAqIHB4ICsgKHkzIC0geTEpICogcHkpIC8gc29tZXRoaW5nO1xuXG4gICAgICAgIGlmICh1ID4gMSkge1xuICAgICAgICAgIHUgPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHUgPCAwKSB7XG4gICAgICAgICAgdSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeCA9IHgxICsgdSAqIHB4O1xuICAgICAgICB2YXIgeSA9IHkxICsgdSAqIHB5O1xuICAgICAgICB2YXIgZHggPSB4IC0geDM7XG4gICAgICAgIHZhciBkeSA9IHkgLSB5MztcblxuICAgICAgICAvLyMgTm90ZTogSWYgdGhlIGFjdHVhbCBkaXN0YW5jZSBkb2VzIG5vdCBtYXR0ZXIsXG4gICAgICAgIC8vIyBpZiB5b3Ugb25seSB3YW50IHRvIGNvbXBhcmUgd2hhdCB0aGlzIGZ1bmN0aW9uXG4gICAgICAgIC8vIyByZXR1cm5zIHRvIG90aGVyIHJlc3VsdHMgb2YgdGhpcyBmdW5jdGlvbiwgeW91XG4gICAgICAgIC8vIyBjYW4ganVzdCByZXR1cm4gdGhlIHNxdWFyZWQgZGlzdGFuY2UgaW5zdGVhZFxuICAgICAgICAvLyMgKGkuZS4gcmVtb3ZlIHRoZSBzcXJ0KSB0byBnYWluIGEgbGl0dGxlIHBlcmZvcm1hbmNlXG5cbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSBjdHhcbiAgICAgICAqIEBwYXJhbSBwb3NpdGlvblxuICAgICAgICogQHBhcmFtIHZpYU5vZGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0QXJyb3dEYXRhJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBcnJvd0RhdGEoY3R4LCBwb3NpdGlvbiwgdmlhTm9kZSwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICAgIC8vIHNldCBsZXRzXG4gICAgICAgIHZhciBhbmdsZSA9IHZvaWQgMDtcbiAgICAgICAgdmFyIGFycm93UG9pbnQgPSB2b2lkIDA7XG4gICAgICAgIHZhciBub2RlMSA9IHZvaWQgMDtcbiAgICAgICAgdmFyIG5vZGUyID0gdm9pZCAwO1xuICAgICAgICB2YXIgZ3VpZGVPZmZzZXQgPSB2b2lkIDA7XG4gICAgICAgIHZhciBzY2FsZUZhY3RvciA9IHZvaWQgMDtcbiAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHRoaXMuZ2V0TGluZVdpZHRoKHNlbGVjdGVkLCBob3Zlcik7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAnZnJvbScpIHtcbiAgICAgICAgICBub2RlMSA9IHRoaXMuZnJvbTtcbiAgICAgICAgICBub2RlMiA9IHRoaXMudG87XG4gICAgICAgICAgZ3VpZGVPZmZzZXQgPSAwLjE7XG4gICAgICAgICAgc2NhbGVGYWN0b3IgPSB0aGlzLm9wdGlvbnMuYXJyb3dzLmZyb20uc2NhbGVGYWN0b3I7XG4gICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICd0bycpIHtcbiAgICAgICAgICBub2RlMSA9IHRoaXMudG87XG4gICAgICAgICAgbm9kZTIgPSB0aGlzLmZyb207XG4gICAgICAgICAgZ3VpZGVPZmZzZXQgPSAtMC4xO1xuICAgICAgICAgIHNjYWxlRmFjdG9yID0gdGhpcy5vcHRpb25zLmFycm93cy50by5zY2FsZUZhY3RvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlMSA9IHRoaXMudG87XG4gICAgICAgICAgbm9kZTIgPSB0aGlzLmZyb207XG4gICAgICAgICAgc2NhbGVGYWN0b3IgPSB0aGlzLm9wdGlvbnMuYXJyb3dzLm1pZGRsZS5zY2FsZUZhY3RvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIG5vdCBjb25uZWN0ZWQgdG8gaXRzZWxmXG4gICAgICAgIGlmIChub2RlMSAhPSBub2RlMikge1xuICAgICAgICAgIGlmIChwb3NpdGlvbiAhPT0gJ21pZGRsZScpIHtcbiAgICAgICAgICAgIC8vIGRyYXcgYXJyb3cgaGVhZFxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zbW9vdGguZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICBhcnJvd1BvaW50ID0gdGhpcy5maW5kQm9yZGVyUG9zaXRpb24obm9kZTEsIGN0eCwgeyB2aWE6IHZpYU5vZGUgfSk7XG4gICAgICAgICAgICAgIHZhciBndWlkZVBvcyA9IHRoaXMuZ2V0UG9pbnQoTWF0aC5tYXgoMC4wLCBNYXRoLm1pbigxLjAsIGFycm93UG9pbnQudCArIGd1aWRlT2Zmc2V0KSksIHZpYU5vZGUpO1xuICAgICAgICAgICAgICBhbmdsZSA9IE1hdGguYXRhbjIoYXJyb3dQb2ludC55IC0gZ3VpZGVQb3MueSwgYXJyb3dQb2ludC54IC0gZ3VpZGVQb3MueCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhbmdsZSA9IE1hdGguYXRhbjIobm9kZTEueSAtIG5vZGUyLnksIG5vZGUxLnggLSBub2RlMi54KTtcbiAgICAgICAgICAgICAgYXJyb3dQb2ludCA9IHRoaXMuZmluZEJvcmRlclBvc2l0aW9uKG5vZGUxLCBjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbmdsZSA9IE1hdGguYXRhbjIobm9kZTEueSAtIG5vZGUyLnksIG5vZGUxLnggLSBub2RlMi54KTtcbiAgICAgICAgICAgIGFycm93UG9pbnQgPSB0aGlzLmdldFBvaW50KDAuNSwgdmlhTm9kZSk7IC8vIHRoaXMgaXMgMC42IHRvIGFjY291bnQgZm9yIHRoZSBzaXplIG9mIHRoZSBhcnJvdy5cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBkcmF3IGNpcmNsZVxuXG4gICAgICAgICAgICB2YXIgX2dldENpcmNsZURhdGExMiA9IHRoaXMuX2dldENpcmNsZURhdGEoY3R4KTtcblxuICAgICAgICAgICAgdmFyIF9nZXRDaXJjbGVEYXRhMTMgPSBfc2xpY2VkVG9BcnJheShfZ2V0Q2lyY2xlRGF0YTEyLCAzKTtcblxuICAgICAgICAgICAgdmFyIHggPSBfZ2V0Q2lyY2xlRGF0YTEzWzBdO1xuICAgICAgICAgICAgdmFyIHkgPSBfZ2V0Q2lyY2xlRGF0YTEzWzFdO1xuICAgICAgICAgICAgdmFyIHJhZGl1cyA9IF9nZXRDaXJjbGVEYXRhMTNbMl07XG5cblxuICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09PSAnZnJvbScpIHtcbiAgICAgICAgICAgICAgYXJyb3dQb2ludCA9IHRoaXMuZmluZEJvcmRlclBvc2l0aW9uKHRoaXMuZnJvbSwgY3R4LCB7IHg6IHgsIHk6IHksIGxvdzogMC4yNSwgaGlnaDogMC42LCBkaXJlY3Rpb246IC0xIH0pO1xuICAgICAgICAgICAgICBhbmdsZSA9IGFycm93UG9pbnQudCAqIC0yICogTWF0aC5QSSArIDEuNSAqIE1hdGguUEkgKyAwLjEgKiBNYXRoLlBJO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3RvJykge1xuICAgICAgICAgICAgICBhcnJvd1BvaW50ID0gdGhpcy5maW5kQm9yZGVyUG9zaXRpb24odGhpcy5mcm9tLCBjdHgsIHsgeDogeCwgeTogeSwgbG93OiAwLjYsIGhpZ2g6IDEuMCwgZGlyZWN0aW9uOiAxIH0pO1xuICAgICAgICAgICAgICBhbmdsZSA9IGFycm93UG9pbnQudCAqIC0yICogTWF0aC5QSSArIDEuNSAqIE1hdGguUEkgLSAxLjEgKiBNYXRoLlBJO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYXJyb3dQb2ludCA9IHRoaXMuX3BvaW50T25DaXJjbGUoeCwgeSwgcmFkaXVzLCAwLjE3NSk7XG4gICAgICAgICAgICAgIGFuZ2xlID0gMy45MjY5OTA4MTY5ODcyNDE0OyAvLyA9PT0gMC4xNzUgKiAtMiAqIE1hdGguUEkgKyAxLjUgKiBNYXRoLlBJICsgMC4xICogTWF0aC5QSTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IDE1ICogc2NhbGVGYWN0b3IgKyAzICogbGluZVdpZHRoOyAvLyAzKiBsaW5lV2lkdGggaXMgdGhlIHdpZHRoIG9mIHRoZSBlZGdlLlxuXG4gICAgICAgIHZhciB4aSA9IGFycm93UG9pbnQueCAtIGxlbmd0aCAqIDAuOSAqIE1hdGguY29zKGFuZ2xlKTtcbiAgICAgICAgdmFyIHlpID0gYXJyb3dQb2ludC55IC0gbGVuZ3RoICogMC45ICogTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgICB2YXIgYXJyb3dDb3JlID0geyB4OiB4aSwgeTogeWkgfTtcblxuICAgICAgICByZXR1cm4geyBwb2ludDogYXJyb3dQb2ludCwgY29yZTogYXJyb3dDb3JlLCBhbmdsZTogYW5nbGUsIGxlbmd0aDogbGVuZ3RoIH07XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSBjdHhcbiAgICAgICAqIEBwYXJhbSBzZWxlY3RlZFxuICAgICAgICogQHBhcmFtIGhvdmVyXG4gICAgICAgKiBAcGFyYW0gYXJyb3dEYXRhXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2RyYXdBcnJvd0hlYWQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdBcnJvd0hlYWQoY3R4LCBzZWxlY3RlZCwgaG92ZXIsIGFycm93RGF0YSkge1xuICAgICAgICAvLyBzZXQgc3R5bGVcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5nZXRDb2xvcihjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBjdHguc3Ryb2tlU3R5bGU7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmdldExpbmVXaWR0aChzZWxlY3RlZCwgaG92ZXIpO1xuXG4gICAgICAgIC8vIGRyYXcgYXJyb3cgYXQgdGhlIGVuZCBvZiB0aGUgbGluZVxuICAgICAgICBjdHguYXJyb3coYXJyb3dEYXRhLnBvaW50LngsIGFycm93RGF0YS5wb2ludC55LCBhcnJvd0RhdGEuYW5nbGUsIGFycm93RGF0YS5sZW5ndGgpO1xuXG4gICAgICAgIC8vIGRyYXcgc2hhZG93IGlmIGVuYWJsZWRcbiAgICAgICAgdGhpcy5lbmFibGVTaGFkb3coY3R4KTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgLy8gZGlzYWJsZSBzaGFkb3dzIGZvciBvdGhlciBlbGVtZW50cy5cbiAgICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZW5hYmxlU2hhZG93JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGVTaGFkb3coY3R4KSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hhZG93LmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSB0aGlzLm9wdGlvbnMuc2hhZG93LmNvbG9yO1xuICAgICAgICAgIGN0eC5zaGFkb3dCbHVyID0gdGhpcy5vcHRpb25zLnNoYWRvdy5zaXplO1xuICAgICAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gdGhpcy5vcHRpb25zLnNoYWRvdy54O1xuICAgICAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gdGhpcy5vcHRpb25zLnNoYWRvdy55O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZGlzYWJsZVNoYWRvdycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzYWJsZVNoYWRvdyhjdHgpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaGFkb3cuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9ICdyZ2JhKDAsMCwwLDApJztcbiAgICAgICAgICBjdHguc2hhZG93Qmx1ciA9IDA7XG4gICAgICAgICAgY3R4LnNoYWRvd09mZnNldFggPSAwO1xuICAgICAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBFZGdlQmFzZTtcbiAgfSgpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IEVkZ2VCYXNlO1xuXG4vKioqLyB9LFxuLyogOTAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgdmFyIF9CZXppZXJFZGdlQmFzZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg4KTtcblxuICB2YXIgX0JlemllckVkZ2VCYXNlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0JlemllckVkZ2VCYXNlMik7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG4gIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4gIHZhciBCZXppZXJFZGdlRHluYW1pYyA9IGZ1bmN0aW9uIChfQmV6aWVyRWRnZUJhc2UpIHtcbiAgICBfaW5oZXJpdHMoQmV6aWVyRWRnZUR5bmFtaWMsIF9CZXppZXJFZGdlQmFzZSk7XG5cbiAgICBmdW5jdGlvbiBCZXppZXJFZGdlRHluYW1pYyhvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJlemllckVkZ2VEeW5hbWljKTtcblxuICAgICAgLy8gLS0+IHRoaXMgY2FsbHMgdGhlIHNldE9wdGlvbnMgYmVsb3dcblxuICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJlemllckVkZ2VEeW5hbWljKS5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSk7XG4gICAgICAvL3RoaXMudmlhID0gdW5kZWZpbmVkOyAvLyBIZXJlIGZvciBjb21wbGV0ZW5lc3MgYnV0IG5vdCBhbGxvd2VkIHRvIGRlZmluZWQgYmVmb3JlIHN1cGVyKCkgaXMgaW52b2tlZC5cblxuXG4gICAgICBfdGhpcy5fYm91bmRGdW5jdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMucG9zaXRpb25CZXppZXJOb2RlKCk7XG4gICAgICB9O1xuICAgICAgX3RoaXMuYm9keS5lbWl0dGVyLm9uKFwiX3JlcG9zaXRpb25CZXppZXJOb2Rlc1wiLCBfdGhpcy5fYm91bmRGdW5jdGlvbik7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEJlemllckVkZ2VEeW5hbWljLCBbe1xuICAgICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIHBoeXNpY3MgaGFzIGNoYW5nZWQuXG4gICAgICAgIHZhciBwaHlzaWNzQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGh5c2ljcyAhPT0gb3B0aW9ucy5waHlzaWNzKSB7XG4gICAgICAgICAgcGh5c2ljc0NoYW5nZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgdGhlIG9wdGlvbnMgYW5kIHRoZSB0byBhbmQgZnJvbSBub2Rlc1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmlkID0gdGhpcy5vcHRpb25zLmlkO1xuICAgICAgICB0aGlzLmZyb20gPSB0aGlzLmJvZHkubm9kZXNbdGhpcy5vcHRpb25zLmZyb21dO1xuICAgICAgICB0aGlzLnRvID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMub3B0aW9ucy50b107XG5cbiAgICAgICAgLy8gc2V0dXAgdGhlIHN1cHBvcnQgbm9kZSBhbmQgY29ubmVjdFxuICAgICAgICB0aGlzLnNldHVwU3VwcG9ydE5vZGUoKTtcbiAgICAgICAgdGhpcy5jb25uZWN0KCk7XG5cbiAgICAgICAgLy8gd2hlbiB3ZSBjaGFuZ2UgdGhlIHBoeXNpY3Mgc3RhdGUgb2YgdGhlIGVkZ2UsIHdlIHJlcG9zaXRpb24gdGhlIHN1cHBvcnQgbm9kZS5cbiAgICAgICAgaWYgKHBoeXNpY3NDaGFuZ2UgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLnZpYS5zZXRPcHRpb25zKHsgcGh5c2ljczogdGhpcy5vcHRpb25zLnBoeXNpY3MgfSk7XG4gICAgICAgICAgdGhpcy5wb3NpdGlvbkJlemllck5vZGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjb25uZWN0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMub3B0aW9ucy5mcm9tXTtcbiAgICAgICAgdGhpcy50byA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLm9wdGlvbnMudG9dO1xuICAgICAgICBpZiAodGhpcy5mcm9tID09PSB1bmRlZmluZWQgfHwgdGhpcy50byA9PT0gdW5kZWZpbmVkIHx8IHRoaXMub3B0aW9ucy5waHlzaWNzID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMudmlhLnNldE9wdGlvbnMoeyBwaHlzaWNzOiBmYWxzZSB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBmaXggd2VpcmQgYmVoYXZpb3VyIHdoZXJlIGEgc2VsZiByZWZlcmVuY2luZyBub2RlIGhhcyBwaHlzaWNzIGVuYWJsZWRcbiAgICAgICAgICBpZiAodGhpcy5mcm9tLmlkID09PSB0aGlzLnRvLmlkKSB7XG4gICAgICAgICAgICB0aGlzLnZpYS5zZXRPcHRpb25zKHsgcGh5c2ljczogZmFsc2UgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmlhLnNldE9wdGlvbnMoeyBwaHlzaWNzOiB0cnVlIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHJlbW92ZSB0aGUgc3VwcG9ydCBub2Rlc1xuICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjbGVhbnVwXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub2ZmKFwiX3JlcG9zaXRpb25CZXppZXJOb2Rlc1wiLCB0aGlzLl9ib3VuZEZ1bmN0aW9uKTtcbiAgICAgICAgaWYgKHRoaXMudmlhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5ib2R5Lm5vZGVzW3RoaXMudmlhLmlkXTtcbiAgICAgICAgICB0aGlzLnZpYSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQmV6aWVyIGN1cnZlcyByZXF1aXJlIGFuIGFuY2hvciBwb2ludCB0byBjYWxjdWxhdGUgdGhlIHNtb290aCBmbG93LiBUaGVzZSBwb2ludHMgYXJlIG5vZGVzLiBUaGVzZSBub2RlcyBhcmUgaW52aXNpYmxlIGJ1dFxuICAgICAgICogYXJlIHVzZWQgZm9yIHRoZSBmb3JjZSBjYWxjdWxhdGlvbi5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgY2hhbmdlZCBkYXRhIGlzIG5vdCBjYWxsZWQsIGlmIG5lZWRlZCwgaXQgaXMgcmV0dXJuZWQgYnkgdGhlIG1haW4gZWRnZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzZXR1cFN1cHBvcnROb2RlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0dXBTdXBwb3J0Tm9kZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudmlhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgbm9kZUlkID0gXCJlZGdlSWQ6XCIgKyB0aGlzLmlkO1xuICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5LmZ1bmN0aW9ucy5jcmVhdGVOb2RlKHtcbiAgICAgICAgICAgIGlkOiBub2RlSWQsXG4gICAgICAgICAgICBzaGFwZTogJ2NpcmNsZScsXG4gICAgICAgICAgICBwaHlzaWNzOiB0cnVlLFxuICAgICAgICAgICAgaGlkZGVuOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0gPSBub2RlO1xuICAgICAgICAgIHRoaXMudmlhID0gbm9kZTtcbiAgICAgICAgICB0aGlzLnZpYS5wYXJlbnRFZGdlSWQgPSB0aGlzLmlkO1xuICAgICAgICAgIHRoaXMucG9zaXRpb25CZXppZXJOb2RlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicG9zaXRpb25CZXppZXJOb2RlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcG9zaXRpb25CZXppZXJOb2RlKCkge1xuICAgICAgICBpZiAodGhpcy52aWEgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmZyb20gIT09IHVuZGVmaW5lZCAmJiB0aGlzLnRvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnZpYS54ID0gMC41ICogKHRoaXMuZnJvbS54ICsgdGhpcy50by54KTtcbiAgICAgICAgICB0aGlzLnZpYS55ID0gMC41ICogKHRoaXMuZnJvbS55ICsgdGhpcy50by55KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnZpYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy52aWEueCA9IDA7XG4gICAgICAgICAgdGhpcy52aWEueSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBEcmF3IGEgbGluZSBiZXR3ZWVuIHR3byBub2Rlc1xuICAgICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9saW5lXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2xpbmUoY3R4LCB2aWFOb2RlKSB7XG4gICAgICAgIC8vIGRyYXcgYSBzdHJhaWdodCBsaW5lXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyh0aGlzLmZyb21Qb2ludC54LCB0aGlzLmZyb21Qb2ludC55KTtcbiAgICAgICAgLy8gZmFsbGJhY2sgdG8gbm9ybWFsIHN0cmFpZ2h0IGVkZ2VzXG4gICAgICAgIGlmICh2aWFOb2RlLnggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGN0eC5saW5lVG8odGhpcy50b1BvaW50LngsIHRoaXMudG9Qb2ludC55KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh2aWFOb2RlLngsIHZpYU5vZGUueSwgdGhpcy50b1BvaW50LngsIHRoaXMudG9Qb2ludC55KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG4gICAgICAgIHRoaXMuZW5hYmxlU2hhZG93KGN0eCk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldFZpYU5vZGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWaWFOb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWE7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29tYmluZWQgZnVuY3Rpb24gb2YgcG9pbnRPbkxpbmUgYW5kIHBvaW50T25CZXppZXIuIFRoaXMgZ2l2ZXMgdGhlIGNvb3JkaW5hdGVzIG9mIGEgcG9pbnQgb24gdGhlIGxpbmUgYXQgYSBjZXJ0YWluIHBlcmNlbnRhZ2Ugb2YgdGhlIHdheVxuICAgICAgICogQHBhcmFtIHBlcmNlbnRhZ2VcbiAgICAgICAqIEBwYXJhbSB2aWFOb2RlXG4gICAgICAgKiBAcmV0dXJucyB7e3g6IG51bWJlciwgeTogbnVtYmVyfX1cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRQb2ludFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvaW50KHBlcmNlbnRhZ2UpIHtcbiAgICAgICAgdmFyIHZpYU5vZGUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB0aGlzLnZpYSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICB2YXIgdCA9IHBlcmNlbnRhZ2U7XG4gICAgICAgIHZhciB4ID0gTWF0aC5wb3coMSAtIHQsIDIpICogdGhpcy5mcm9tUG9pbnQueCArIDIgKiB0ICogKDEgLSB0KSAqIHZpYU5vZGUueCArIE1hdGgucG93KHQsIDIpICogdGhpcy50b1BvaW50Lng7XG4gICAgICAgIHZhciB5ID0gTWF0aC5wb3coMSAtIHQsIDIpICogdGhpcy5mcm9tUG9pbnQueSArIDIgKiB0ICogKDEgLSB0KSAqIHZpYU5vZGUueSArIE1hdGgucG93KHQsIDIpICogdGhpcy50b1BvaW50Lnk7XG5cbiAgICAgICAgcmV0dXJuIHsgeDogeCwgeTogeSB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfZmluZEJvcmRlclBvc2l0aW9uXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRCb3JkZXJQb3NpdGlvbihuZWFyTm9kZSwgY3R4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maW5kQm9yZGVyUG9zaXRpb25CZXppZXIobmVhck5vZGUsIGN0eCwgdGhpcy52aWEpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfZ2V0RGlzdGFuY2VUb0VkZ2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGlzdGFuY2VUb0VkZ2UoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgICAgICAvLyB4Myx5MyBpcyB0aGUgcG9pbnRcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldERpc3RhbmNlVG9CZXppZXJFZGdlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHRoaXMudmlhKTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQmV6aWVyRWRnZUR5bmFtaWM7XG4gIH0oX0JlemllckVkZ2VCYXNlMy5kZWZhdWx0KTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBCZXppZXJFZGdlRHluYW1pYztcblxuLyoqKi8gfSxcbi8qIDkxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX0JlemllckVkZ2VCYXNlMiA9IF9fd2VicGFja19yZXF1aXJlX18oODgpO1xuXG4gIHZhciBfQmV6aWVyRWRnZUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmV6aWVyRWRnZUJhc2UyKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbiAgdmFyIEJlemllckVkZ2VTdGF0aWMgPSBmdW5jdGlvbiAoX0JlemllckVkZ2VCYXNlKSB7XG4gICAgX2luaGVyaXRzKEJlemllckVkZ2VTdGF0aWMsIF9CZXppZXJFZGdlQmFzZSk7XG5cbiAgICBmdW5jdGlvbiBCZXppZXJFZGdlU3RhdGljKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmV6aWVyRWRnZVN0YXRpYyk7XG5cbiAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQmV6aWVyRWRnZVN0YXRpYykuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYXcgYSBsaW5lIGJldHdlZW4gdHdvIG5vZGVzXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhCZXppZXJFZGdlU3RhdGljLCBbe1xuICAgICAga2V5OiAnX2xpbmUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9saW5lKGN0eCwgdmlhTm9kZSkge1xuICAgICAgICAvLyBkcmF3IGEgc3RyYWlnaHQgbGluZVxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8odGhpcy5mcm9tUG9pbnQueCwgdGhpcy5mcm9tUG9pbnQueSk7XG5cbiAgICAgICAgLy8gZmFsbGJhY2sgdG8gbm9ybWFsIHN0cmFpZ2h0IGVkZ2VzXG4gICAgICAgIGlmICh2aWFOb2RlLnggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGN0eC5saW5lVG8odGhpcy50b1BvaW50LngsIHRoaXMudG9Qb2ludC55KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh2aWFOb2RlLngsIHZpYU5vZGUueSwgdGhpcy50b1BvaW50LngsIHRoaXMudG9Qb2ludC55KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG4gICAgICAgIHRoaXMuZW5hYmxlU2hhZG93KGN0eCk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0VmlhTm9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmlhTm9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogV2UgZG8gbm90IHVzZSB0aGUgdG8gYW5kIGZyb21Qb2ludHMgaGVyZSB0byBtYWtlIHRoZSB2aWEgbm9kZXMgdGhlIHNhbWUgYXMgZWRnZXMgd2l0aG91dCBhcnJvd3MuXG4gICAgICAgKiBAcmV0dXJucyB7e3g6IHVuZGVmaW5lZCwgeTogdW5kZWZpbmVkfX1cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19nZXRWaWFDb29yZGluYXRlcycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFZpYUNvb3JkaW5hdGVzKCkge1xuICAgICAgICB2YXIgeFZpYSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIHlWaWEgPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBmYWN0b3IgPSB0aGlzLm9wdGlvbnMuc21vb3RoLnJvdW5kbmVzcztcbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLm9wdGlvbnMuc21vb3RoLnR5cGU7XG4gICAgICAgIHZhciBkeCA9IE1hdGguYWJzKHRoaXMuZnJvbS54IC0gdGhpcy50by54KTtcbiAgICAgICAgdmFyIGR5ID0gTWF0aC5hYnModGhpcy5mcm9tLnkgLSB0aGlzLnRvLnkpO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ2Rpc2NyZXRlJyB8fCB0eXBlID09PSAnZGlhZ29uYWxDcm9zcycpIHtcbiAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5mcm9tLnggLSB0aGlzLnRvLngpIDw9IE1hdGguYWJzKHRoaXMuZnJvbS55IC0gdGhpcy50by55KSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZnJvbS55ID49IHRoaXMudG8ueSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5mcm9tLnggPD0gdGhpcy50by54KSB7XG4gICAgICAgICAgICAgICAgeFZpYSA9IHRoaXMuZnJvbS54ICsgZmFjdG9yICogZHk7XG4gICAgICAgICAgICAgICAgeVZpYSA9IHRoaXMuZnJvbS55IC0gZmFjdG9yICogZHk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5mcm9tLnggPiB0aGlzLnRvLngpIHtcbiAgICAgICAgICAgICAgICB4VmlhID0gdGhpcy5mcm9tLnggLSBmYWN0b3IgKiBkeTtcbiAgICAgICAgICAgICAgICB5VmlhID0gdGhpcy5mcm9tLnkgLSBmYWN0b3IgKiBkeTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmZyb20ueSA8IHRoaXMudG8ueSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5mcm9tLnggPD0gdGhpcy50by54KSB7XG4gICAgICAgICAgICAgICAgeFZpYSA9IHRoaXMuZnJvbS54ICsgZmFjdG9yICogZHk7XG4gICAgICAgICAgICAgICAgeVZpYSA9IHRoaXMuZnJvbS55ICsgZmFjdG9yICogZHk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5mcm9tLnggPiB0aGlzLnRvLngpIHtcbiAgICAgICAgICAgICAgICB4VmlhID0gdGhpcy5mcm9tLnggLSBmYWN0b3IgKiBkeTtcbiAgICAgICAgICAgICAgICB5VmlhID0gdGhpcy5mcm9tLnkgKyBmYWN0b3IgKiBkeTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiZGlzY3JldGVcIikge1xuICAgICAgICAgICAgICB4VmlhID0gZHggPCBmYWN0b3IgKiBkeSA/IHRoaXMuZnJvbS54IDogeFZpYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKHRoaXMuZnJvbS54IC0gdGhpcy50by54KSA+IE1hdGguYWJzKHRoaXMuZnJvbS55IC0gdGhpcy50by55KSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZnJvbS55ID49IHRoaXMudG8ueSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5mcm9tLnggPD0gdGhpcy50by54KSB7XG4gICAgICAgICAgICAgICAgeFZpYSA9IHRoaXMuZnJvbS54ICsgZmFjdG9yICogZHg7XG4gICAgICAgICAgICAgICAgeVZpYSA9IHRoaXMuZnJvbS55IC0gZmFjdG9yICogZHg7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5mcm9tLnggPiB0aGlzLnRvLngpIHtcbiAgICAgICAgICAgICAgICB4VmlhID0gdGhpcy5mcm9tLnggLSBmYWN0b3IgKiBkeDtcbiAgICAgICAgICAgICAgICB5VmlhID0gdGhpcy5mcm9tLnkgLSBmYWN0b3IgKiBkeDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmZyb20ueSA8IHRoaXMudG8ueSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5mcm9tLnggPD0gdGhpcy50by54KSB7XG4gICAgICAgICAgICAgICAgeFZpYSA9IHRoaXMuZnJvbS54ICsgZmFjdG9yICogZHg7XG4gICAgICAgICAgICAgICAgeVZpYSA9IHRoaXMuZnJvbS55ICsgZmFjdG9yICogZHg7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5mcm9tLnggPiB0aGlzLnRvLngpIHtcbiAgICAgICAgICAgICAgICB4VmlhID0gdGhpcy5mcm9tLnggLSBmYWN0b3IgKiBkeDtcbiAgICAgICAgICAgICAgICB5VmlhID0gdGhpcy5mcm9tLnkgKyBmYWN0b3IgKiBkeDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiZGlzY3JldGVcIikge1xuICAgICAgICAgICAgICB5VmlhID0gZHkgPCBmYWN0b3IgKiBkeCA/IHRoaXMuZnJvbS55IDogeVZpYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJzdHJhaWdodENyb3NzXCIpIHtcbiAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5mcm9tLnggLSB0aGlzLnRvLngpIDw9IE1hdGguYWJzKHRoaXMuZnJvbS55IC0gdGhpcy50by55KSkge1xuICAgICAgICAgICAgLy8gdXAgLSBkb3duXG4gICAgICAgICAgICB4VmlhID0gdGhpcy5mcm9tLng7XG4gICAgICAgICAgICBpZiAodGhpcy5mcm9tLnkgPCB0aGlzLnRvLnkpIHtcbiAgICAgICAgICAgICAgeVZpYSA9IHRoaXMudG8ueSAtICgxIC0gZmFjdG9yKSAqIGR5O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgeVZpYSA9IHRoaXMudG8ueSArICgxIC0gZmFjdG9yKSAqIGR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnModGhpcy5mcm9tLnggLSB0aGlzLnRvLngpID4gTWF0aC5hYnModGhpcy5mcm9tLnkgLSB0aGlzLnRvLnkpKSB7XG4gICAgICAgICAgICAvLyBsZWZ0IC0gcmlnaHRcbiAgICAgICAgICAgIGlmICh0aGlzLmZyb20ueCA8IHRoaXMudG8ueCkge1xuICAgICAgICAgICAgICB4VmlhID0gdGhpcy50by54IC0gKDEgLSBmYWN0b3IpICogZHg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB4VmlhID0gdGhpcy50by54ICsgKDEgLSBmYWN0b3IpICogZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5VmlhID0gdGhpcy5mcm9tLnk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgIGlmICh0aGlzLmZyb20ueCA8IHRoaXMudG8ueCkge1xuICAgICAgICAgICAgeFZpYSA9IHRoaXMudG8ueCAtICgxIC0gZmFjdG9yKSAqIGR4O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4VmlhID0gdGhpcy50by54ICsgKDEgLSBmYWN0b3IpICogZHg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHlWaWEgPSB0aGlzLmZyb20ueTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgeFZpYSA9IHRoaXMuZnJvbS54O1xuICAgICAgICAgIGlmICh0aGlzLmZyb20ueSA8IHRoaXMudG8ueSkge1xuICAgICAgICAgICAgeVZpYSA9IHRoaXMudG8ueSAtICgxIC0gZmFjdG9yKSAqIGR5O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5VmlhID0gdGhpcy50by55ICsgKDEgLSBmYWN0b3IpICogZHk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjdXJ2ZWRDVycpIHtcbiAgICAgICAgICBkeCA9IHRoaXMudG8ueCAtIHRoaXMuZnJvbS54O1xuICAgICAgICAgIGR5ID0gdGhpcy5mcm9tLnkgLSB0aGlzLnRvLnk7XG4gICAgICAgICAgdmFyIHJhZGl1cyA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgICAgdmFyIHBpID0gTWF0aC5QSTtcblxuICAgICAgICAgIHZhciBvcmlnaW5hbEFuZ2xlID0gTWF0aC5hdGFuMihkeSwgZHgpO1xuICAgICAgICAgIHZhciBteUFuZ2xlID0gKG9yaWdpbmFsQW5nbGUgKyAoZmFjdG9yICogMC41ICsgMC41KSAqIHBpKSAlICgyICogcGkpO1xuXG4gICAgICAgICAgeFZpYSA9IHRoaXMuZnJvbS54ICsgKGZhY3RvciAqIDAuNSArIDAuNSkgKiByYWRpdXMgKiBNYXRoLnNpbihteUFuZ2xlKTtcbiAgICAgICAgICB5VmlhID0gdGhpcy5mcm9tLnkgKyAoZmFjdG9yICogMC41ICsgMC41KSAqIHJhZGl1cyAqIE1hdGguY29zKG15QW5nbGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjdXJ2ZWRDQ1cnKSB7XG4gICAgICAgICAgZHggPSB0aGlzLnRvLnggLSB0aGlzLmZyb20ueDtcbiAgICAgICAgICBkeSA9IHRoaXMuZnJvbS55IC0gdGhpcy50by55O1xuICAgICAgICAgIHZhciBfcmFkaXVzID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgICB2YXIgX3BpID0gTWF0aC5QSTtcblxuICAgICAgICAgIHZhciBfb3JpZ2luYWxBbmdsZSA9IE1hdGguYXRhbjIoZHksIGR4KTtcbiAgICAgICAgICB2YXIgX215QW5nbGUgPSAoX29yaWdpbmFsQW5nbGUgKyAoLWZhY3RvciAqIDAuNSArIDAuNSkgKiBfcGkpICUgKDIgKiBfcGkpO1xuXG4gICAgICAgICAgeFZpYSA9IHRoaXMuZnJvbS54ICsgKGZhY3RvciAqIDAuNSArIDAuNSkgKiBfcmFkaXVzICogTWF0aC5zaW4oX215QW5nbGUpO1xuICAgICAgICAgIHlWaWEgPSB0aGlzLmZyb20ueSArIChmYWN0b3IgKiAwLjUgKyAwLjUpICogX3JhZGl1cyAqIE1hdGguY29zKF9teUFuZ2xlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBjb250aW51b3VzXG4gICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuZnJvbS54IC0gdGhpcy50by54KSA8PSBNYXRoLmFicyh0aGlzLmZyb20ueSAtIHRoaXMudG8ueSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZyb20ueSA+PSB0aGlzLnRvLnkpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuZnJvbS54IDw9IHRoaXMudG8ueCkge1xuICAgICAgICAgICAgICAgIHhWaWEgPSB0aGlzLmZyb20ueCArIGZhY3RvciAqIGR5O1xuICAgICAgICAgICAgICAgIHlWaWEgPSB0aGlzLmZyb20ueSAtIGZhY3RvciAqIGR5O1xuICAgICAgICAgICAgICAgIHhWaWEgPSB0aGlzLnRvLnggPCB4VmlhID8gdGhpcy50by54IDogeFZpYTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmZyb20ueCA+IHRoaXMudG8ueCkge1xuICAgICAgICAgICAgICAgIHhWaWEgPSB0aGlzLmZyb20ueCAtIGZhY3RvciAqIGR5O1xuICAgICAgICAgICAgICAgIHlWaWEgPSB0aGlzLmZyb20ueSAtIGZhY3RvciAqIGR5O1xuICAgICAgICAgICAgICAgIHhWaWEgPSB0aGlzLnRvLnggPiB4VmlhID8gdGhpcy50by54IDogeFZpYTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmZyb20ueSA8IHRoaXMudG8ueSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5mcm9tLnggPD0gdGhpcy50by54KSB7XG4gICAgICAgICAgICAgICAgeFZpYSA9IHRoaXMuZnJvbS54ICsgZmFjdG9yICogZHk7XG4gICAgICAgICAgICAgICAgeVZpYSA9IHRoaXMuZnJvbS55ICsgZmFjdG9yICogZHk7XG4gICAgICAgICAgICAgICAgeFZpYSA9IHRoaXMudG8ueCA8IHhWaWEgPyB0aGlzLnRvLnggOiB4VmlhO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZnJvbS54ID4gdGhpcy50by54KSB7XG4gICAgICAgICAgICAgICAgeFZpYSA9IHRoaXMuZnJvbS54IC0gZmFjdG9yICogZHk7XG4gICAgICAgICAgICAgICAgeVZpYSA9IHRoaXMuZnJvbS55ICsgZmFjdG9yICogZHk7XG4gICAgICAgICAgICAgICAgeFZpYSA9IHRoaXMudG8ueCA+IHhWaWEgPyB0aGlzLnRvLnggOiB4VmlhO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyh0aGlzLmZyb20ueCAtIHRoaXMudG8ueCkgPiBNYXRoLmFicyh0aGlzLmZyb20ueSAtIHRoaXMudG8ueSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZyb20ueSA+PSB0aGlzLnRvLnkpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuZnJvbS54IDw9IHRoaXMudG8ueCkge1xuICAgICAgICAgICAgICAgIHhWaWEgPSB0aGlzLmZyb20ueCArIGZhY3RvciAqIGR4O1xuICAgICAgICAgICAgICAgIHlWaWEgPSB0aGlzLmZyb20ueSAtIGZhY3RvciAqIGR4O1xuICAgICAgICAgICAgICAgIHlWaWEgPSB0aGlzLnRvLnkgPiB5VmlhID8gdGhpcy50by55IDogeVZpYTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmZyb20ueCA+IHRoaXMudG8ueCkge1xuICAgICAgICAgICAgICAgIHhWaWEgPSB0aGlzLmZyb20ueCAtIGZhY3RvciAqIGR4O1xuICAgICAgICAgICAgICAgIHlWaWEgPSB0aGlzLmZyb20ueSAtIGZhY3RvciAqIGR4O1xuICAgICAgICAgICAgICAgIHlWaWEgPSB0aGlzLnRvLnkgPiB5VmlhID8gdGhpcy50by55IDogeVZpYTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmZyb20ueSA8IHRoaXMudG8ueSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5mcm9tLnggPD0gdGhpcy50by54KSB7XG4gICAgICAgICAgICAgICAgeFZpYSA9IHRoaXMuZnJvbS54ICsgZmFjdG9yICogZHg7XG4gICAgICAgICAgICAgICAgeVZpYSA9IHRoaXMuZnJvbS55ICsgZmFjdG9yICogZHg7XG4gICAgICAgICAgICAgICAgeVZpYSA9IHRoaXMudG8ueSA8IHlWaWEgPyB0aGlzLnRvLnkgOiB5VmlhO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZnJvbS54ID4gdGhpcy50by54KSB7XG4gICAgICAgICAgICAgICAgeFZpYSA9IHRoaXMuZnJvbS54IC0gZmFjdG9yICogZHg7XG4gICAgICAgICAgICAgICAgeVZpYSA9IHRoaXMuZnJvbS55ICsgZmFjdG9yICogZHg7XG4gICAgICAgICAgICAgICAgeVZpYSA9IHRoaXMudG8ueSA8IHlWaWEgPyB0aGlzLnRvLnkgOiB5VmlhO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHg6IHhWaWEsIHk6IHlWaWEgfTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZmluZEJvcmRlclBvc2l0aW9uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZmluZEJvcmRlclBvc2l0aW9uKG5lYXJOb2RlLCBjdHgpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1syXTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uQmV6aWVyKG5lYXJOb2RlLCBjdHgsIG9wdGlvbnMudmlhKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZ2V0RGlzdGFuY2VUb0VkZ2UnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXREaXN0YW5jZVRvRWRnZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgICAgIHZhciB2aWFOb2RlID0gYXJndW1lbnRzLmxlbmd0aCA8PSA2IHx8IGFyZ3VtZW50c1s2XSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fZ2V0VmlhQ29vcmRpbmF0ZXMoKSA6IGFyZ3VtZW50c1s2XTtcbiAgICAgICAgLy8geDMseTMgaXMgdGhlIHBvaW50XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXREaXN0YW5jZVRvQmV6aWVyRWRnZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB2aWFOb2RlKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDb21iaW5lZCBmdW5jdGlvbiBvZiBwb2ludE9uTGluZSBhbmQgcG9pbnRPbkJlemllci4gVGhpcyBnaXZlcyB0aGUgY29vcmRpbmF0ZXMgb2YgYSBwb2ludCBvbiB0aGUgbGluZSBhdCBhIGNlcnRhaW4gcGVyY2VudGFnZSBvZiB0aGUgd2F5XG4gICAgICAgKiBAcGFyYW0gcGVyY2VudGFnZVxuICAgICAgICogQHBhcmFtIHZpYU5vZGVcbiAgICAgICAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0UG9pbnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvaW50KHBlcmNlbnRhZ2UpIHtcbiAgICAgICAgdmFyIHZpYU5vZGUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB0aGlzLl9nZXRWaWFDb29yZGluYXRlcygpIDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgIHZhciB0ID0gcGVyY2VudGFnZTtcbiAgICAgICAgdmFyIHggPSBNYXRoLnBvdygxIC0gdCwgMikgKiB0aGlzLmZyb21Qb2ludC54ICsgMiAqIHQgKiAoMSAtIHQpICogdmlhTm9kZS54ICsgTWF0aC5wb3codCwgMikgKiB0aGlzLnRvUG9pbnQueDtcbiAgICAgICAgdmFyIHkgPSBNYXRoLnBvdygxIC0gdCwgMikgKiB0aGlzLmZyb21Qb2ludC55ICsgMiAqIHQgKiAoMSAtIHQpICogdmlhTm9kZS55ICsgTWF0aC5wb3codCwgMikgKiB0aGlzLnRvUG9pbnQueTtcblxuICAgICAgICByZXR1cm4geyB4OiB4LCB5OiB5IH07XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEJlemllckVkZ2VTdGF0aWM7XG4gIH0oX0JlemllckVkZ2VCYXNlMy5kZWZhdWx0KTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBCZXppZXJFZGdlU3RhdGljO1xuXG4vKioqLyB9LFxuLyogOTIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIHZhciBfRWRnZUJhc2UyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4OSk7XG5cbiAgdmFyIF9FZGdlQmFzZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9FZGdlQmFzZTIpO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuICBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuICB2YXIgU3RyYWlnaHRFZGdlID0gZnVuY3Rpb24gKF9FZGdlQmFzZSkge1xuICAgIF9pbmhlcml0cyhTdHJhaWdodEVkZ2UsIF9FZGdlQmFzZSk7XG5cbiAgICBmdW5jdGlvbiBTdHJhaWdodEVkZ2Uob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdHJhaWdodEVkZ2UpO1xuXG4gICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKFN0cmFpZ2h0RWRnZSkuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYXcgYSBsaW5lIGJldHdlZW4gdHdvIG5vZGVzXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhTdHJhaWdodEVkZ2UsIFt7XG4gICAgICBrZXk6ICdfbGluZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2xpbmUoY3R4KSB7XG4gICAgICAgIC8vIGRyYXcgYSBzdHJhaWdodCBsaW5lXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyh0aGlzLmZyb21Qb2ludC54LCB0aGlzLmZyb21Qb2ludC55KTtcbiAgICAgICAgY3R4LmxpbmVUbyh0aGlzLnRvUG9pbnQueCwgdGhpcy50b1BvaW50LnkpO1xuICAgICAgICAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG4gICAgICAgIHRoaXMuZW5hYmxlU2hhZG93KGN0eCk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0VmlhTm9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmlhTm9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDb21iaW5lZCBmdW5jdGlvbiBvZiBwb2ludE9uTGluZSBhbmQgcG9pbnRPbkJlemllci4gVGhpcyBnaXZlcyB0aGUgY29vcmRpbmF0ZXMgb2YgYSBwb2ludCBvbiB0aGUgbGluZSBhdCBhIGNlcnRhaW4gcGVyY2VudGFnZSBvZiB0aGUgd2F5XG4gICAgICAgKiBAcGFyYW0gcGVyY2VudGFnZVxuICAgICAgICogQHBhcmFtIHZpYVxuICAgICAgICogQHJldHVybnMge3t4OiBudW1iZXIsIHk6IG51bWJlcn19XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXRQb2ludCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9pbnQocGVyY2VudGFnZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6ICgxIC0gcGVyY2VudGFnZSkgKiB0aGlzLmZyb21Qb2ludC54ICsgcGVyY2VudGFnZSAqIHRoaXMudG9Qb2ludC54LFxuICAgICAgICAgIHk6ICgxIC0gcGVyY2VudGFnZSkgKiB0aGlzLmZyb21Qb2ludC55ICsgcGVyY2VudGFnZSAqIHRoaXMudG9Qb2ludC55XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2ZpbmRCb3JkZXJQb3NpdGlvbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRCb3JkZXJQb3NpdGlvbihuZWFyTm9kZSwgY3R4KSB7XG4gICAgICAgIHZhciBub2RlMSA9IHRoaXMudG87XG4gICAgICAgIHZhciBub2RlMiA9IHRoaXMuZnJvbTtcbiAgICAgICAgaWYgKG5lYXJOb2RlLmlkID09PSB0aGlzLmZyb20uaWQpIHtcbiAgICAgICAgICBub2RlMSA9IHRoaXMuZnJvbTtcbiAgICAgICAgICBub2RlMiA9IHRoaXMudG87XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKG5vZGUxLnkgLSBub2RlMi55LCBub2RlMS54IC0gbm9kZTIueCk7XG4gICAgICAgIHZhciBkeCA9IG5vZGUxLnggLSBub2RlMi54O1xuICAgICAgICB2YXIgZHkgPSBub2RlMS55IC0gbm9kZTIueTtcbiAgICAgICAgdmFyIGVkZ2VTZWdtZW50TGVuZ3RoID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgdmFyIHRvQm9yZGVyRGlzdCA9IG5lYXJOb2RlLmRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgICAgIHZhciB0b0JvcmRlclBvaW50ID0gKGVkZ2VTZWdtZW50TGVuZ3RoIC0gdG9Cb3JkZXJEaXN0KSAvIGVkZ2VTZWdtZW50TGVuZ3RoO1xuXG4gICAgICAgIHZhciBib3JkZXJQb3MgPSB7fTtcbiAgICAgICAgYm9yZGVyUG9zLnggPSAoMSAtIHRvQm9yZGVyUG9pbnQpICogbm9kZTIueCArIHRvQm9yZGVyUG9pbnQgKiBub2RlMS54O1xuICAgICAgICBib3JkZXJQb3MueSA9ICgxIC0gdG9Cb3JkZXJQb2ludCkgKiBub2RlMi55ICsgdG9Cb3JkZXJQb2ludCAqIG5vZGUxLnk7XG5cbiAgICAgICAgcmV0dXJuIGJvcmRlclBvcztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZ2V0RGlzdGFuY2VUb0VkZ2UnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXREaXN0YW5jZVRvRWRnZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgICAgIC8vIHgzLHkzIGlzIHRoZSBwb2ludFxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0RGlzdGFuY2VUb0xpbmUoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Myk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFN0cmFpZ2h0RWRnZTtcbiAgfShfRWRnZUJhc2UzLmRlZmF1bHQpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IFN0cmFpZ2h0RWRnZTtcblxuLyoqKi8gfSxcbi8qIDkzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX0Jhcm5lc0h1dFNvbHZlciA9IF9fd2VicGFja19yZXF1aXJlX18oOTQpO1xuXG4gIHZhciBfQmFybmVzSHV0U29sdmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Jhcm5lc0h1dFNvbHZlcik7XG5cbiAgdmFyIF9SZXB1bHNpb25Tb2x2ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1KTtcblxuICB2YXIgX1JlcHVsc2lvblNvbHZlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9SZXB1bHNpb25Tb2x2ZXIpO1xuXG4gIHZhciBfSGllcmFyY2hpY2FsUmVwdWxzaW9uU29sdmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Nik7XG5cbiAgdmFyIF9IaWVyYXJjaGljYWxSZXB1bHNpb25Tb2x2ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfSGllcmFyY2hpY2FsUmVwdWxzaW9uU29sdmVyKTtcblxuICB2YXIgX1NwcmluZ1NvbHZlciA9IF9fd2VicGFja19yZXF1aXJlX18oOTcpO1xuXG4gIHZhciBfU3ByaW5nU29sdmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NwcmluZ1NvbHZlcik7XG5cbiAgdmFyIF9IaWVyYXJjaGljYWxTcHJpbmdTb2x2ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk4KTtcblxuICB2YXIgX0hpZXJhcmNoaWNhbFNwcmluZ1NvbHZlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9IaWVyYXJjaGljYWxTcHJpbmdTb2x2ZXIpO1xuXG4gIHZhciBfQ2VudHJhbEdyYXZpdHlTb2x2ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk5KTtcblxuICB2YXIgX0NlbnRyYWxHcmF2aXR5U29sdmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NlbnRyYWxHcmF2aXR5U29sdmVyKTtcblxuICB2YXIgX0ZBMkJhc2VkUmVwdWxzaW9uU29sdmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDApO1xuXG4gIHZhciBfRkEyQmFzZWRSZXB1bHNpb25Tb2x2ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRkEyQmFzZWRSZXB1bHNpb25Tb2x2ZXIpO1xuXG4gIHZhciBfRkEyQmFzZWRDZW50cmFsR3Jhdml0eVNvbHZlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTAxKTtcblxuICB2YXIgX0ZBMkJhc2VkQ2VudHJhbEdyYXZpdHlTb2x2ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRkEyQmFzZWRDZW50cmFsR3Jhdml0eVNvbHZlcik7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuICB2YXIgUGh5c2ljc0VuZ2luZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQaHlzaWNzRW5naW5lKGJvZHkpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQaHlzaWNzRW5naW5lKTtcblxuICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgIHRoaXMucGh5c2ljc0JvZHkgPSB7IHBoeXNpY3NOb2RlSW5kaWNlczogW10sIHBoeXNpY3NFZGdlSW5kaWNlczogW10sIGZvcmNlczoge30sIHZlbG9jaXRpZXM6IHt9IH07XG5cbiAgICAgIHRoaXMucGh5c2ljc0VuYWJsZWQgPSB0cnVlO1xuICAgICAgdGhpcy5zaW11bGF0aW9uSW50ZXJ2YWwgPSAxMDAwIC8gNjA7XG4gICAgICB0aGlzLnJlcXVpcmVzVGltZW91dCA9IHRydWU7XG4gICAgICB0aGlzLnByZXZpb3VzU3RhdGVzID0ge307XG4gICAgICB0aGlzLnJlZmVyZW5jZVN0YXRlID0ge307XG4gICAgICB0aGlzLmZyZWV6ZUNhY2hlID0ge307XG4gICAgICB0aGlzLnJlbmRlclRpbWVyID0gdW5kZWZpbmVkO1xuXG4gICAgICAvLyBwYXJhbWV0ZXJzIGZvciB0aGUgYWRhcHRpdmUgdGltZXN0ZXBcbiAgICAgIHRoaXMuYWRhcHRpdmVUaW1lc3RlcCA9IGZhbHNlO1xuICAgICAgdGhpcy5hZGFwdGl2ZVRpbWVzdGVwRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5hZGFwdGl2ZUNvdW50ZXIgPSAwO1xuICAgICAgdGhpcy5hZGFwdGl2ZUludGVydmFsID0gMztcblxuICAgICAgdGhpcy5zdGFiaWxpemVkID0gZmFsc2U7XG4gICAgICB0aGlzLnN0YXJ0ZWRTdGFiaWxpemF0aW9uID0gZmFsc2U7XG4gICAgICB0aGlzLnN0YWJpbGl6YXRpb25JdGVyYXRpb25zID0gMDtcbiAgICAgIHRoaXMucmVhZHkgPSBmYWxzZTsgLy8gd2lsbCBiZSBzZXQgdG8gdHJ1ZSBpZiB0aGUgc3RhYmlsaXplXG5cbiAgICAgIC8vIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBiYXJuZXNIdXQ6IHtcbiAgICAgICAgICB0aGV0YTogMC41LFxuICAgICAgICAgIGdyYXZpdGF0aW9uYWxDb25zdGFudDogLTIwMDAsXG4gICAgICAgICAgY2VudHJhbEdyYXZpdHk6IDAuMyxcbiAgICAgICAgICBzcHJpbmdMZW5ndGg6IDk1LFxuICAgICAgICAgIHNwcmluZ0NvbnN0YW50OiAwLjA0LFxuICAgICAgICAgIGRhbXBpbmc6IDAuMDksXG4gICAgICAgICAgYXZvaWRPdmVybGFwOiAwXG4gICAgICAgIH0sXG4gICAgICAgIGZvcmNlQXRsYXMyQmFzZWQ6IHtcbiAgICAgICAgICB0aGV0YTogMC41LFxuICAgICAgICAgIGdyYXZpdGF0aW9uYWxDb25zdGFudDogLTUwLFxuICAgICAgICAgIGNlbnRyYWxHcmF2aXR5OiAwLjAxLFxuICAgICAgICAgIHNwcmluZ0NvbnN0YW50OiAwLjA4LFxuICAgICAgICAgIHNwcmluZ0xlbmd0aDogMTAwLFxuICAgICAgICAgIGRhbXBpbmc6IDAuNCxcbiAgICAgICAgICBhdm9pZE92ZXJsYXA6IDBcbiAgICAgICAgfSxcbiAgICAgICAgcmVwdWxzaW9uOiB7XG4gICAgICAgICAgY2VudHJhbEdyYXZpdHk6IDAuMixcbiAgICAgICAgICBzcHJpbmdMZW5ndGg6IDIwMCxcbiAgICAgICAgICBzcHJpbmdDb25zdGFudDogMC4wNSxcbiAgICAgICAgICBub2RlRGlzdGFuY2U6IDEwMCxcbiAgICAgICAgICBkYW1waW5nOiAwLjA5LFxuICAgICAgICAgIGF2b2lkT3ZlcmxhcDogMFxuICAgICAgICB9LFxuICAgICAgICBoaWVyYXJjaGljYWxSZXB1bHNpb246IHtcbiAgICAgICAgICBjZW50cmFsR3Jhdml0eTogMC4wLFxuICAgICAgICAgIHNwcmluZ0xlbmd0aDogMTAwLFxuICAgICAgICAgIHNwcmluZ0NvbnN0YW50OiAwLjAxLFxuICAgICAgICAgIG5vZGVEaXN0YW5jZTogMTIwLFxuICAgICAgICAgIGRhbXBpbmc6IDAuMDlcbiAgICAgICAgfSxcbiAgICAgICAgbWF4VmVsb2NpdHk6IDUwLFxuICAgICAgICBtaW5WZWxvY2l0eTogMC43NSwgLy8gcHgvc1xuICAgICAgICBzb2x2ZXI6ICdiYXJuZXNIdXQnLFxuICAgICAgICBzdGFiaWxpemF0aW9uOiB7XG4gICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICBpdGVyYXRpb25zOiAxMDAwLCAvLyBtYXhpbXVtIG51bWJlciBvZiBpdGVyYXRpb24gdG8gc3RhYmlsaXplXG4gICAgICAgICAgdXBkYXRlSW50ZXJ2YWw6IDUwLFxuICAgICAgICAgIG9ubHlEeW5hbWljRWRnZXM6IGZhbHNlLFxuICAgICAgICAgIGZpdDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICB0aW1lc3RlcDogMC41LFxuICAgICAgICBhZGFwdGl2ZVRpbWVzdGVwOiB0cnVlXG4gICAgICB9O1xuICAgICAgdXRpbC5leHRlbmQodGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcbiAgICAgIHRoaXMudGltZXN0ZXAgPSAwLjU7XG4gICAgICB0aGlzLmxheW91dEZhaWxlZCA9IGZhbHNlO1xuXG4gICAgICB0aGlzLmJpbmRFdmVudExpc3RlbmVycygpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhQaHlzaWNzRW5naW5lLCBbe1xuICAgICAga2V5OiAnYmluZEV2ZW50TGlzdGVuZXJzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ2luaXRQaHlzaWNzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLmluaXRQaHlzaWNzKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignX2xheW91dEZhaWxlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy5sYXlvdXRGYWlsZWQgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ3Jlc2V0UGh5c2ljcycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy5zdG9wU2ltdWxhdGlvbigpO190aGlzLnJlYWR5ID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignZGlzYWJsZVBoeXNpY3MnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMucGh5c2ljc0VuYWJsZWQgPSBmYWxzZTtfdGhpcy5zdG9wU2ltdWxhdGlvbigpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ3Jlc3RvcmVQaHlzaWNzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLnNldE9wdGlvbnMoX3RoaXMub3B0aW9ucyk7XG4gICAgICAgICAgaWYgKF90aGlzLnJlYWR5ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBfdGhpcy5zdGFydFNpbXVsYXRpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignc3RhcnRTaW11bGF0aW9uJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChfdGhpcy5yZWFkeSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgX3RoaXMuc3RhcnRTaW11bGF0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ3N0b3BTaW11bGF0aW9uJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLnN0b3BTaW11bGF0aW9uKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy5zdG9wU2ltdWxhdGlvbihmYWxzZSk7XG4gICAgICAgICAgX3RoaXMuYm9keS5lbWl0dGVyLm9mZigpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gdGhpcyBldmVudCB3aWxsIHRyaWdnZXIgYSByZWJ1aWxkaW5nIG9mIHRoZSBjYWNoZSBldmVyeXRoaW5nLiBVc2VkIHdoZW4gbm9kZXMgb3IgZWRnZXMgaGF2ZSBiZWVuIGFkZGVkIG9yIHJlbW92ZWQuXG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2RhdGFDaGFuZ2VkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyB1cGRhdGUgc2hvcnRjdXQgbGlzdHNcbiAgICAgICAgICBfdGhpcy51cGRhdGVQaHlzaWNzRGF0YSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBkZWJ1Zzogc2hvdyBmb3JjZXNcbiAgICAgICAgLy8gdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJhZnRlckRyYXdpbmdcIiwgKGN0eCkgPT4ge3RoaXMuX2RyYXdGb3JjZXMoY3R4KTt9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBzZXQgdGhlIHBoeXNpY3Mgb3B0aW9uc1xuICAgICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc2V0T3B0aW9ucycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnBoeXNpY3NFbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnN0b3BTaW11bGF0aW9uKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGh5c2ljc0VuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgdXRpbC5zZWxlY3RpdmVOb3REZWVwRXh0ZW5kKFsnc3RhYmlsaXphdGlvbiddLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdXRpbC5tZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBvcHRpb25zLCAnc3RhYmlsaXphdGlvbicpO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5lbmFibGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHRoaXMucGh5c2ljc0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdGhpcy5zdG9wU2ltdWxhdGlvbigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzZXQgdGhlIHRpbWVzdGVwXG4gICAgICAgICAgICB0aGlzLnRpbWVzdGVwID0gdGhpcy5vcHRpb25zLnRpbWVzdGVwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBjb25maWd1cmUgdGhlIGVuZ2luZS5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnaW5pdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgdmFyIG9wdGlvbnM7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc29sdmVyID09PSAnZm9yY2VBdGxhczJCYXNlZCcpIHtcbiAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLmZvcmNlQXRsYXMyQmFzZWQ7XG4gICAgICAgICAgdGhpcy5ub2Rlc1NvbHZlciA9IG5ldyBfRkEyQmFzZWRSZXB1bHNpb25Tb2x2ZXIyLmRlZmF1bHQodGhpcy5ib2R5LCB0aGlzLnBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgICB0aGlzLmVkZ2VzU29sdmVyID0gbmV3IF9TcHJpbmdTb2x2ZXIyLmRlZmF1bHQodGhpcy5ib2R5LCB0aGlzLnBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgICB0aGlzLmdyYXZpdHlTb2x2ZXIgPSBuZXcgX0ZBMkJhc2VkQ2VudHJhbEdyYXZpdHlTb2x2ZXIyLmRlZmF1bHQodGhpcy5ib2R5LCB0aGlzLnBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuc29sdmVyID09PSAncmVwdWxzaW9uJykge1xuICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMucmVwdWxzaW9uO1xuICAgICAgICAgIHRoaXMubm9kZXNTb2x2ZXIgPSBuZXcgX1JlcHVsc2lvblNvbHZlcjIuZGVmYXVsdCh0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgICAgIHRoaXMuZWRnZXNTb2x2ZXIgPSBuZXcgX1NwcmluZ1NvbHZlcjIuZGVmYXVsdCh0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgICAgIHRoaXMuZ3Jhdml0eVNvbHZlciA9IG5ldyBfQ2VudHJhbEdyYXZpdHlTb2x2ZXIyLmRlZmF1bHQodGhpcy5ib2R5LCB0aGlzLnBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuc29sdmVyID09PSAnaGllcmFyY2hpY2FsUmVwdWxzaW9uJykge1xuICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsUmVwdWxzaW9uO1xuICAgICAgICAgIHRoaXMubm9kZXNTb2x2ZXIgPSBuZXcgX0hpZXJhcmNoaWNhbFJlcHVsc2lvblNvbHZlcjIuZGVmYXVsdCh0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgICAgIHRoaXMuZWRnZXNTb2x2ZXIgPSBuZXcgX0hpZXJhcmNoaWNhbFNwcmluZ1NvbHZlcjIuZGVmYXVsdCh0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgICAgIHRoaXMuZ3Jhdml0eVNvbHZlciA9IG5ldyBfQ2VudHJhbEdyYXZpdHlTb2x2ZXIyLmRlZmF1bHQodGhpcy5ib2R5LCB0aGlzLnBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBiYXJuZXNIdXRcbiAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLmJhcm5lc0h1dDtcbiAgICAgICAgICB0aGlzLm5vZGVzU29sdmVyID0gbmV3IF9CYXJuZXNIdXRTb2x2ZXIyLmRlZmF1bHQodGhpcy5ib2R5LCB0aGlzLnBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgICB0aGlzLmVkZ2VzU29sdmVyID0gbmV3IF9TcHJpbmdTb2x2ZXIyLmRlZmF1bHQodGhpcy5ib2R5LCB0aGlzLnBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgICB0aGlzLmdyYXZpdHlTb2x2ZXIgPSBuZXcgX0NlbnRyYWxHcmF2aXR5U29sdmVyMi5kZWZhdWx0KHRoaXMuYm9keSwgdGhpcy5waHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1vZGVsT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogaW5pdGlhbGl6ZSB0aGUgZW5naW5lXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2luaXRQaHlzaWNzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0UGh5c2ljcygpIHtcbiAgICAgICAgaWYgKHRoaXMucGh5c2ljc0VuYWJsZWQgPT09IHRydWUgJiYgdGhpcy5vcHRpb25zLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0YWJpbGl6YXRpb24uZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5zdGFiaWxpemUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGFiaWxpemVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ2ZpdCcsIHt9LCB0aGlzLmxheW91dEZhaWxlZCk7IC8vIGlmIHRoZSBsYXlvdXQgZmFpbGVkLCB3ZSB1c2UgdGhlIGFwcHJveGltYXRpb24gZm9yIHRoZSB6b29tXG4gICAgICAgICAgICB0aGlzLnN0YXJ0U2ltdWxhdGlvbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdmaXQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFN0YXJ0IHRoZSBzaW11bGF0aW9uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3N0YXJ0U2ltdWxhdGlvbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnRTaW11bGF0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5waHlzaWNzRW5hYmxlZCA9PT0gdHJ1ZSAmJiB0aGlzLm9wdGlvbnMuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuc3RhYmlsaXplZCA9IGZhbHNlO1xuXG4gICAgICAgICAgLy8gd2hlbiB2aXNpYmxlLCBhZGFwdGl2aXR5IGlzIGRpc2FibGVkLlxuICAgICAgICAgIHRoaXMuYWRhcHRpdmVUaW1lc3RlcCA9IGZhbHNlO1xuXG4gICAgICAgICAgLy8gdGhpcyBzZXRzIHRoZSB3aWR0aCBvZiBhbGwgbm9kZXMgaW5pdGlhbGx5IHdoaWNoIGNvdWxkIGJlIHJlcXVpcmVkIGZvciB0aGUgYXZvaWRPdmVybGFwXG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXNpemVOb2Rlc1wiKTtcbiAgICAgICAgICBpZiAodGhpcy52aWV3RnVuY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy52aWV3RnVuY3Rpb24gPSB0aGlzLnNpbXVsYXRpb25TdGVwLmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignaW5pdFJlZHJhdycsIHRoaXMudmlld0Z1bmN0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19zdGFydFJlbmRlcmluZycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfcmVkcmF3Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTdG9wIHRoZSBzaW11bGF0aW9uLCBmb3JjZSBzdGFiaWxpemF0aW9uLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzdG9wU2ltdWxhdGlvbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcFNpbXVsYXRpb24oKSB7XG4gICAgICAgIHZhciBlbWl0ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgICB0aGlzLnN0YWJpbGl6ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoZW1pdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuX2VtaXRTdGFiaWxpemVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmlld0Z1bmN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vZmYoJ2luaXRSZWRyYXcnLCB0aGlzLnZpZXdGdW5jdGlvbik7XG4gICAgICAgICAgdGhpcy52aWV3RnVuY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKGVtaXQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19zdG9wUmVuZGVyaW5nJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIHZpZXdGdW5jdGlvbiBpbnNlcnRzIHRoaXMgc3RlcCBpbnRvIGVhY2ggcmVuZGVyIGxvb3AuIEl0IGNhbGxzIHRoZSBwaHlzaWNzIHRpY2sgYW5kIGhhbmRsZXMgdGhlIGNsZWFudXAgYXQgc3RhYmlsaXplZC5cbiAgICAgICAqXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NpbXVsYXRpb25TdGVwJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzaW11bGF0aW9uU3RlcCgpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIHBoeXNpY3MgaGF2ZSBzZXR0bGVkXG4gICAgICAgIHZhciBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLnBoeXNpY3NUaWNrKCk7XG4gICAgICAgIHZhciBwaHlzaWNzVGltZSA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG5cbiAgICAgICAgLy8gcnVuIGRvdWJsZSBzcGVlZCBpZiBpdCBpcyBhIGxpdHRsZSBncmFwaFxuICAgICAgICBpZiAoKHBoeXNpY3NUaW1lIDwgMC40ICogdGhpcy5zaW11bGF0aW9uSW50ZXJ2YWwgfHwgdGhpcy5ydW5Eb3VibGVTcGVlZCA9PT0gdHJ1ZSkgJiYgdGhpcy5zdGFiaWxpemVkID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMucGh5c2ljc1RpY2soKTtcblxuICAgICAgICAgIC8vIHRoaXMgbWFrZXMgc3VyZSB0aGVyZSBpcyBubyBqaXR0ZXIuIFRoZSBkZWNpc2lvbiBpcyB0YWtlbiBvbmNlIHRvIHJ1biBpdCBhdCBkb3VibGUgc3BlZWQuXG4gICAgICAgICAgdGhpcy5ydW5Eb3VibGVTcGVlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zdGFiaWxpemVkID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5zdG9wU2ltdWxhdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogdHJpZ2dlciB0aGUgc3RhYmlsaXplZCBldmVudC5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19lbWl0U3RhYmlsaXplZCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2VtaXRTdGFiaWxpemVkKCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICB2YXIgYW1vdW50T2ZJdGVyYXRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gdGhpcy5zdGFiaWxpemF0aW9uSXRlcmF0aW9ucyA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgICBpZiAodGhpcy5zdGFiaWxpemF0aW9uSXRlcmF0aW9ucyA+IDEgfHwgdGhpcy5zdGFydGVkU3RhYmlsaXphdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMyLmJvZHkuZW1pdHRlci5lbWl0KCdzdGFiaWxpemVkJywgeyBpdGVyYXRpb25zOiBhbW91bnRPZkl0ZXJhdGlvbnMgfSk7XG4gICAgICAgICAgICBfdGhpczIuc3RhcnRlZFN0YWJpbGl6YXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIF90aGlzMi5zdGFiaWxpemF0aW9uSXRlcmF0aW9ucyA9IDA7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBIHNpbmdsZSBzaW11bGF0aW9uIHN0ZXAgKG9yICd0aWNrJykgaW4gdGhlIHBoeXNpY3Mgc2ltdWxhdGlvblxuICAgICAgICpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3BoeXNpY3NUaWNrJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwaHlzaWNzVGljaygpIHtcbiAgICAgICAgLy8gdGhpcyBpcyBoZXJlIHRvIGVuc3VyZSB0aGF0IHRoZXJlIGlzIG5vIHN0YXJ0IGV2ZW50IHdoZW4gdGhlIG5ldHdvcmsgaXMgYWxyZWFkeSBzdGFibGUuXG4gICAgICAgIGlmICh0aGlzLnN0YXJ0ZWRTdGFiaWxpemF0aW9uID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3N0YXJ0U3RhYmlsaXppbmcnKTtcbiAgICAgICAgICB0aGlzLnN0YXJ0ZWRTdGFiaWxpemF0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnN0YWJpbGl6ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgLy8gYWRhcHRpdml0eSBtZWFucyB0aGUgdGltZXN0ZXAgYWRhcHRzIHRvIHRoZSBzaXR1YXRpb24sIG9ubHkgYXBwbGljYWJsZSBmb3Igc3RhYmlsaXphdGlvblxuICAgICAgICAgIGlmICh0aGlzLmFkYXB0aXZlVGltZXN0ZXAgPT09IHRydWUgJiYgdGhpcy5hZGFwdGl2ZVRpbWVzdGVwRW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgZmFjdG9yIGZvciBpbmNyZWFzaW5nIHRoZSB0aW1lc3RlcCBvbiBzdWNjZXNzLlxuICAgICAgICAgICAgdmFyIGZhY3RvciA9IDEuMjtcblxuICAgICAgICAgICAgLy8gd2UgYXNzdW1lIHRoZSBhZGFwdGl2ZSBpbnRlcnZhbCBpc1xuICAgICAgICAgICAgaWYgKHRoaXMuYWRhcHRpdmVDb3VudGVyICUgdGhpcy5hZGFwdGl2ZUludGVydmFsID09PSAwKSB7XG4gICAgICAgICAgICAgIC8vIHdlIGxlYXZlIHRoZSB0aW1lc3RlcCBzdGFibGUgZm9yIFwiaW50ZXJ2YWxcIiBpdGVyYXRpb25zLlxuICAgICAgICAgICAgICAvLyBmaXJzdCB0aGUgYmlnIHN0ZXAgYW5kIHJldmVydC4gUmV2ZXJ0IHNhdmVzIHRoZSByZWZlcmVuY2Ugc3RhdGUuXG4gICAgICAgICAgICAgIHRoaXMudGltZXN0ZXAgPSAyICogdGhpcy50aW1lc3RlcDtcbiAgICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVGb3JjZXMoKTtcbiAgICAgICAgICAgICAgdGhpcy5tb3ZlTm9kZXMoKTtcbiAgICAgICAgICAgICAgdGhpcy5yZXZlcnQoKTtcblxuICAgICAgICAgICAgICAvLyBub3cgdGhlIG5vcm1hbCBzdGVwLiBTaW5jZSB0aGlzIGlzIHRoZSBsYXN0IHN0ZXAsIGl0IGlzIHRoZSBtb3JlIHN0YWJsZSBvbmUgYW5kIHdlIHdpbGwgdGFrZSB0aGlzLlxuICAgICAgICAgICAgICB0aGlzLnRpbWVzdGVwID0gMC41ICogdGhpcy50aW1lc3RlcDtcblxuICAgICAgICAgICAgICAvLyBzaW5jZSBpdCdzIGhhbGYgdGhlIHN0ZXAsIHdlIGRvIGl0IHR3aWNlLlxuICAgICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZUZvcmNlcygpO1xuICAgICAgICAgICAgICB0aGlzLm1vdmVOb2RlcygpO1xuICAgICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZUZvcmNlcygpO1xuICAgICAgICAgICAgICB0aGlzLm1vdmVOb2RlcygpO1xuXG4gICAgICAgICAgICAgIC8vIHdlIGNvbXBhcmUgdGhlIHR3byBzdGVwcy4gaWYgaXQgaXMgYWNjZXB0YWJsZSB3ZSBkb3VibGUgdGhlIHN0ZXAuXG4gICAgICAgICAgICAgIGlmICh0aGlzLl9ldmFsdWF0ZVN0ZXBRdWFsaXR5KCkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVzdGVwID0gZmFjdG9yICogdGhpcy50aW1lc3RlcDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBub3QsIHdlIGRlY3JlYXNlIHRoZSBzdGVwIHRvIGEgbWluaW11bSBvZiB0aGUgb3B0aW9ucyB0aW1lc3RlcC5cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgZGVjcmVhc2VkIHRpbWVzdGVwIGlzIHNtYWxsZXIgdGhhbiB0aGUgb3B0aW9ucyBzdGVwLCB3ZSBkbyBub3QgcmVzZXQgdGhlIGNvdW50ZXJcbiAgICAgICAgICAgICAgICAvLyB3ZSBhc3N1bWUgdGhhdCB0aGUgb3B0aW9ucyB0aW1lc3RlcCBpcyBzdGFibGUgZW5vdWdoLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRpbWVzdGVwIC8gZmFjdG9yIDwgdGhpcy5vcHRpb25zLnRpbWVzdGVwKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnRpbWVzdGVwID0gdGhpcy5vcHRpb25zLnRpbWVzdGVwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgdGltZXN0ZXAgd2FzIGxhcmdlciB0aGFuIDIgdGltZXMgdGhlIG9wdGlvbiBvbmUgd2UgY2hlY2sgdGhlIGFkYXB0aXZpdHkgYWdhaW4gdG8gZW5zdXJlXG4gICAgICAgICAgICAgICAgICAvLyB0aGF0IGxhcmdlIGluc3RhYmlsaXRpZXMgZG8gbm90IGZvcm0uXG4gICAgICAgICAgICAgICAgICB0aGlzLmFkYXB0aXZlQ291bnRlciA9IC0xOyAvLyBjaGVjayBhZ2FpbiBuZXh0IGl0ZXJhdGlvblxuICAgICAgICAgICAgICAgICAgdGhpcy50aW1lc3RlcCA9IE1hdGgubWF4KHRoaXMub3B0aW9ucy50aW1lc3RlcCwgdGhpcy50aW1lc3RlcCAvIGZhY3Rvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBub3JtYWwgc3RlcCwga2VlcGluZyB0aW1lc3RlcCBjb25zdGFudFxuICAgICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZUZvcmNlcygpO1xuICAgICAgICAgICAgICB0aGlzLm1vdmVOb2RlcygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpbmNyZW1lbnQgdGhlIGNvdW50ZXJcbiAgICAgICAgICAgIHRoaXMuYWRhcHRpdmVDb3VudGVyICs9IDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNhc2UgZm9yIHRoZSBzdGF0aWMgdGltZXN0ZXAsIHdlIHJlc2V0IGl0IHRvIHRoZSBvbmUgaW4gb3B0aW9ucyBhbmQgdGFrZSBhIG5vcm1hbCBzdGVwLlxuICAgICAgICAgICAgdGhpcy50aW1lc3RlcCA9IHRoaXMub3B0aW9ucy50aW1lc3RlcDtcbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlRm9yY2VzKCk7XG4gICAgICAgICAgICB0aGlzLm1vdmVOb2RlcygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGRldGVybWluZSBpZiB0aGUgbmV0d29yayBoYXMgc3RhYmlsemllZFxuICAgICAgICAgIGlmICh0aGlzLnN0YWJpbGl6ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMucmV2ZXJ0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5zdGFiaWxpemF0aW9uSXRlcmF0aW9ucysrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogTm9kZXMgYW5kIGVkZ2VzIGNhbiBoYXZlIHRoZSBwaHlzaWNzIHRvZ2dsZXMgb24gb3Igb2ZmLiBBIGNvbGxlY3Rpb24gb2YgaW5kaWNlcyBpcyBjcmVhdGVkIGhlcmUgc28gd2UgY2FuIHNraXAgdGhlIGNoZWNrIGFsbCB0aGUgdGltZS5cbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd1cGRhdGVQaHlzaWNzRGF0YScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlUGh5c2ljc0RhdGEoKSB7XG4gICAgICAgIHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzID0ge307XG4gICAgICAgIHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzID0gW107XG4gICAgICAgIHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc0VkZ2VJbmRpY2VzID0gW107XG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuXG4gICAgICAgIC8vIGdldCBub2RlIGluZGljZXMgZm9yIHBoeXNpY3NcbiAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIG5vZGVzKSB7XG4gICAgICAgICAgaWYgKG5vZGVzLmhhc093blByb3BlcnR5KG5vZGVJZCkpIHtcbiAgICAgICAgICAgIGlmIChub2Rlc1tub2RlSWRdLm9wdGlvbnMucGh5c2ljcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcy5wdXNoKG5vZGVzW25vZGVJZF0uaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCBlZGdlIGluZGljZXMgZm9yIHBoeXNpY3NcbiAgICAgICAgZm9yICh2YXIgZWRnZUlkIGluIGVkZ2VzKSB7XG4gICAgICAgICAgaWYgKGVkZ2VzLmhhc093blByb3BlcnR5KGVkZ2VJZCkpIHtcbiAgICAgICAgICAgIGlmIChlZGdlc1tlZGdlSWRdLm9wdGlvbnMucGh5c2ljcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NFZGdlSW5kaWNlcy5wdXNoKGVkZ2VzW2VkZ2VJZF0uaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCB0aGUgdmVsb2NpdHkgYW5kIHRoZSBmb3JjZXMgdmVjdG9yXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgX25vZGVJZCA9IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzW2ldO1xuICAgICAgICAgIHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW19ub2RlSWRdID0geyB4OiAwLCB5OiAwIH07XG5cbiAgICAgICAgICAvLyBmb3JjZXMgY2FuIGJlIHJlc2V0IGJlY2F1c2UgdGhleSBhcmUgcmVjYWxjdWxhdGVkLiBWZWxvY2l0aWVzIGhhdmUgdG8gcGVyc2lzdC5cbiAgICAgICAgICBpZiAodGhpcy5waHlzaWNzQm9keS52ZWxvY2l0aWVzW19ub2RlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucGh5c2ljc0JvZHkudmVsb2NpdGllc1tfbm9kZUlkXSA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFuIGRlbGV0ZWQgbm9kZXMgZnJvbSB0aGUgdmVsb2NpdHkgdmVjdG9yXG4gICAgICAgIGZvciAodmFyIF9ub2RlSWQyIGluIHRoaXMucGh5c2ljc0JvZHkudmVsb2NpdGllcykge1xuICAgICAgICAgIGlmIChub2Rlc1tfbm9kZUlkMl0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMucGh5c2ljc0JvZHkudmVsb2NpdGllc1tfbm9kZUlkMl07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV2ZXJ0IHRoZSBzaW11bGF0aW9uIG9uZSBzdGVwLiBUaGlzIGlzIGRvbmUgc28gYWZ0ZXIgc3RhYmlsaXphdGlvbiwgZXZlcnkgbmV3IHN0YXJ0IG9mIHRoZSBzaW11bGF0aW9uIHdpbGwgYWxzbyBzYXkgc3RhYmlsaXplZC5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAncmV2ZXJ0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXZlcnQoKSB7XG4gICAgICAgIHZhciBub2RlSWRzID0gT2JqZWN0LmtleXModGhpcy5wcmV2aW91c1N0YXRlcyk7XG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgICAgdmFyIHZlbG9jaXRpZXMgPSB0aGlzLnBoeXNpY3NCb2R5LnZlbG9jaXRpZXM7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlU3RhdGUgPSB7fTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbm9kZUlkID0gbm9kZUlkc1tpXTtcbiAgICAgICAgICBpZiAobm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAobm9kZXNbbm9kZUlkXS5vcHRpb25zLnBoeXNpY3MgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgdGhpcy5yZWZlcmVuY2VTdGF0ZVtub2RlSWRdID0ge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uczogeyB4OiBub2Rlc1tub2RlSWRdLngsIHk6IG5vZGVzW25vZGVJZF0ueSB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHZlbG9jaXRpZXNbbm9kZUlkXS54ID0gdGhpcy5wcmV2aW91c1N0YXRlc1tub2RlSWRdLnZ4O1xuICAgICAgICAgICAgICB2ZWxvY2l0aWVzW25vZGVJZF0ueSA9IHRoaXMucHJldmlvdXNTdGF0ZXNbbm9kZUlkXS52eTtcbiAgICAgICAgICAgICAgbm9kZXNbbm9kZUlkXS54ID0gdGhpcy5wcmV2aW91c1N0YXRlc1tub2RlSWRdLng7XG4gICAgICAgICAgICAgIG5vZGVzW25vZGVJZF0ueSA9IHRoaXMucHJldmlvdXNTdGF0ZXNbbm9kZUlkXS55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5wcmV2aW91c1N0YXRlc1tub2RlSWRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgY29tcGFyZXMgdGhlIHJlZmVyZW5jZSBzdGF0ZSB0byB0aGUgY3VycmVudCBzdGF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZXZhbHVhdGVTdGVwUXVhbGl0eScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2V2YWx1YXRlU3RlcFF1YWxpdHkoKSB7XG4gICAgICAgIHZhciBkeCA9IHZvaWQgMCxcbiAgICAgICAgICAgIGR5ID0gdm9pZCAwLFxuICAgICAgICAgICAgZHBvcyA9IHZvaWQgMDtcbiAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgICB2YXIgcmVmZXJlbmNlID0gdGhpcy5yZWZlcmVuY2VTdGF0ZTtcbiAgICAgICAgdmFyIHBvc1RocmVzaG9sZCA9IDAuMztcblxuICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gdGhpcy5yZWZlcmVuY2VTdGF0ZSkge1xuICAgICAgICAgIGlmICh0aGlzLnJlZmVyZW5jZVN0YXRlLmhhc093blByb3BlcnR5KG5vZGVJZCkgJiYgbm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkeCA9IG5vZGVzW25vZGVJZF0ueCAtIHJlZmVyZW5jZVtub2RlSWRdLnBvc2l0aW9ucy54O1xuICAgICAgICAgICAgZHkgPSBub2Rlc1tub2RlSWRdLnkgLSByZWZlcmVuY2Vbbm9kZUlkXS5wb3NpdGlvbnMueTtcblxuICAgICAgICAgICAgZHBvcyA9IE1hdGguc3FydChNYXRoLnBvdyhkeCwgMikgKyBNYXRoLnBvdyhkeSwgMikpO1xuXG4gICAgICAgICAgICBpZiAoZHBvcyA+IHBvc1RocmVzaG9sZCkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIG1vdmUgdGhlIG5vZGVzIG9uZSB0aW1lc3RlcCBhbmQgY2hlY2sgaWYgdGhleSBhcmUgc3RhYmlsaXplZFxuICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ21vdmVOb2RlcycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZU5vZGVzKCkge1xuICAgICAgICB2YXIgbm9kZUluZGljZXMgPSB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcztcbiAgICAgICAgdmFyIG1heFZlbG9jaXR5ID0gdGhpcy5vcHRpb25zLm1heFZlbG9jaXR5ID8gdGhpcy5vcHRpb25zLm1heFZlbG9jaXR5IDogMWU5O1xuICAgICAgICB2YXIgbWF4Tm9kZVZlbG9jaXR5ID0gMDtcbiAgICAgICAgdmFyIGF2ZXJhZ2VOb2RlVmVsb2NpdHkgPSAwO1xuXG4gICAgICAgIC8vIHRoZSB2ZWxvY2l0eSB0aHJlc2hvbGQgKGVuZXJneSBpbiB0aGUgc3lzdGVtKSBmb3IgdGhlIGFkYXB0aXZpdHkgdG9nZ2xlXG4gICAgICAgIHZhciB2ZWxvY2l0eUFkYXB0aXZlVGhyZXNob2xkID0gNTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5vZGVJZCA9IG5vZGVJbmRpY2VzW2ldO1xuICAgICAgICAgIHZhciBub2RlVmVsb2NpdHkgPSB0aGlzLl9wZXJmb3JtU3RlcChub2RlSWQsIG1heFZlbG9jaXR5KTtcbiAgICAgICAgICAvLyBzdGFiaWxpemVkIGlzIHRydWUgaWYgc3RhYmlsaXplZCBpcyB0cnVlIGFuZCB2ZWxvY2l0eSBpcyBzbWFsbGVyIHRoYW4gdm1pbiAtLT4gYWxsIG5vZGVzIG11c3QgYmUgc3RhYmlsaXplZFxuICAgICAgICAgIG1heE5vZGVWZWxvY2l0eSA9IE1hdGgubWF4KG1heE5vZGVWZWxvY2l0eSwgbm9kZVZlbG9jaXR5KTtcbiAgICAgICAgICBhdmVyYWdlTm9kZVZlbG9jaXR5ICs9IG5vZGVWZWxvY2l0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGV2YWx1YXRpbmcgdGhlIHN0YWJpbGl6ZWQgYW5kIGFkYXB0aXZlVGltZXN0ZXBFbmFibGVkIGNvbmRpdGlvbnNcbiAgICAgICAgdGhpcy5hZGFwdGl2ZVRpbWVzdGVwRW5hYmxlZCA9IGF2ZXJhZ2VOb2RlVmVsb2NpdHkgLyBub2RlSW5kaWNlcy5sZW5ndGggPCB2ZWxvY2l0eUFkYXB0aXZlVGhyZXNob2xkO1xuICAgICAgICB0aGlzLnN0YWJpbGl6ZWQgPSBtYXhOb2RlVmVsb2NpdHkgPCB0aGlzLm9wdGlvbnMubWluVmVsb2NpdHk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUGVyZm9ybSB0aGUgYWN0dWFsIHN0ZXBcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gbm9kZUlkXG4gICAgICAgKiBAcGFyYW0gbWF4VmVsb2NpdHlcbiAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfcGVyZm9ybVN0ZXAnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9wZXJmb3JtU3RlcChub2RlSWQsIG1heFZlbG9jaXR5KSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICAgIHZhciB0aW1lc3RlcCA9IHRoaXMudGltZXN0ZXA7XG4gICAgICAgIHZhciBmb3JjZXMgPSB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlcztcbiAgICAgICAgdmFyIHZlbG9jaXRpZXMgPSB0aGlzLnBoeXNpY3NCb2R5LnZlbG9jaXRpZXM7XG5cbiAgICAgICAgLy8gc3RvcmUgdGhlIHN0YXRlIHNvIHdlIGNhbiByZXZlcnRcbiAgICAgICAgdGhpcy5wcmV2aW91c1N0YXRlc1tub2RlSWRdID0geyB4OiBub2RlLngsIHk6IG5vZGUueSwgdng6IHZlbG9jaXRpZXNbbm9kZUlkXS54LCB2eTogdmVsb2NpdGllc1tub2RlSWRdLnkgfTtcblxuICAgICAgICBpZiAobm9kZS5vcHRpb25zLmZpeGVkLnggPT09IGZhbHNlKSB7XG4gICAgICAgICAgdmFyIGR4ID0gdGhpcy5tb2RlbE9wdGlvbnMuZGFtcGluZyAqIHZlbG9jaXRpZXNbbm9kZUlkXS54OyAvLyBkYW1waW5nIGZvcmNlXG4gICAgICAgICAgdmFyIGF4ID0gKGZvcmNlc1tub2RlSWRdLnggLSBkeCkgLyBub2RlLm9wdGlvbnMubWFzczsgLy8gYWNjZWxlcmF0aW9uXG4gICAgICAgICAgdmVsb2NpdGllc1tub2RlSWRdLnggKz0gYXggKiB0aW1lc3RlcDsgLy8gdmVsb2NpdHlcbiAgICAgICAgICB2ZWxvY2l0aWVzW25vZGVJZF0ueCA9IE1hdGguYWJzKHZlbG9jaXRpZXNbbm9kZUlkXS54KSA+IG1heFZlbG9jaXR5ID8gdmVsb2NpdGllc1tub2RlSWRdLnggPiAwID8gbWF4VmVsb2NpdHkgOiAtbWF4VmVsb2NpdHkgOiB2ZWxvY2l0aWVzW25vZGVJZF0ueDtcbiAgICAgICAgICBub2RlLnggKz0gdmVsb2NpdGllc1tub2RlSWRdLnggKiB0aW1lc3RlcDsgLy8gcG9zaXRpb25cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvcmNlc1tub2RlSWRdLnggPSAwO1xuICAgICAgICAgICAgdmVsb2NpdGllc1tub2RlSWRdLnggPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICBpZiAobm9kZS5vcHRpb25zLmZpeGVkLnkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdmFyIGR5ID0gdGhpcy5tb2RlbE9wdGlvbnMuZGFtcGluZyAqIHZlbG9jaXRpZXNbbm9kZUlkXS55OyAvLyBkYW1waW5nIGZvcmNlXG4gICAgICAgICAgdmFyIGF5ID0gKGZvcmNlc1tub2RlSWRdLnkgLSBkeSkgLyBub2RlLm9wdGlvbnMubWFzczsgLy8gYWNjZWxlcmF0aW9uXG4gICAgICAgICAgdmVsb2NpdGllc1tub2RlSWRdLnkgKz0gYXkgKiB0aW1lc3RlcDsgLy8gdmVsb2NpdHlcbiAgICAgICAgICB2ZWxvY2l0aWVzW25vZGVJZF0ueSA9IE1hdGguYWJzKHZlbG9jaXRpZXNbbm9kZUlkXS55KSA+IG1heFZlbG9jaXR5ID8gdmVsb2NpdGllc1tub2RlSWRdLnkgPiAwID8gbWF4VmVsb2NpdHkgOiAtbWF4VmVsb2NpdHkgOiB2ZWxvY2l0aWVzW25vZGVJZF0ueTtcbiAgICAgICAgICBub2RlLnkgKz0gdmVsb2NpdGllc1tub2RlSWRdLnkgKiB0aW1lc3RlcDsgLy8gcG9zaXRpb25cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvcmNlc1tub2RlSWRdLnkgPSAwO1xuICAgICAgICAgICAgdmVsb2NpdGllc1tub2RlSWRdLnkgPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICB2YXIgdG90YWxWZWxvY2l0eSA9IE1hdGguc3FydChNYXRoLnBvdyh2ZWxvY2l0aWVzW25vZGVJZF0ueCwgMikgKyBNYXRoLnBvdyh2ZWxvY2l0aWVzW25vZGVJZF0ueSwgMikpO1xuICAgICAgICByZXR1cm4gdG90YWxWZWxvY2l0eTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBjYWxjdWxhdGUgdGhlIGZvcmNlcyBmb3Igb25lIHBoeXNpY3MgaXRlcmF0aW9uLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdjYWxjdWxhdGVGb3JjZXMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZUZvcmNlcygpIHtcbiAgICAgICAgdGhpcy5ncmF2aXR5U29sdmVyLnNvbHZlKCk7XG4gICAgICAgIHRoaXMubm9kZXNTb2x2ZXIuc29sdmUoKTtcbiAgICAgICAgdGhpcy5lZGdlc1NvbHZlci5zb2x2ZSgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFdoZW4gaW5pdGlhbGl6aW5nIGFuZCBzdGFiaWxpemluZywgd2UgY2FuIGZyZWV6ZSBub2RlcyB3aXRoIGEgcHJlZGVmaW5lZCBwb3NpdGlvbi4gVGhpcyBncmVhdGx5IHNwZWVkcyB1cCBzdGFiaWxpemF0aW9uXG4gICAgICAgKiBiZWNhdXNlIG9ubHkgdGhlIHN1cHBvcnRub2RlcyBmb3IgdGhlIHNtb290aEN1cnZlcyBoYXZlIHRvIHNldHRsZS5cbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZnJlZXplTm9kZXMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9mcmVlemVOb2RlcygpIHtcbiAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgICBmb3IgKHZhciBpZCBpbiBub2Rlcykge1xuICAgICAgICAgIGlmIChub2Rlcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgIGlmIChub2Rlc1tpZF0ueCAmJiBub2Rlc1tpZF0ueSkge1xuICAgICAgICAgICAgICB0aGlzLmZyZWV6ZUNhY2hlW2lkXSA9IHsgeDogbm9kZXNbaWRdLm9wdGlvbnMuZml4ZWQueCwgeTogbm9kZXNbaWRdLm9wdGlvbnMuZml4ZWQueSB9O1xuICAgICAgICAgICAgICBub2Rlc1tpZF0ub3B0aW9ucy5maXhlZC54ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgbm9kZXNbaWRdLm9wdGlvbnMuZml4ZWQueSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVW5mcmVlemVzIHRoZSBub2RlcyB0aGF0IGhhdmUgYmVlbiBmcm96ZW4gYnkgX2ZyZWV6ZURlZmluZWROb2Rlcy5cbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfcmVzdG9yZUZyb3plbk5vZGVzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzdG9yZUZyb3plbk5vZGVzKCkge1xuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICAgIGZvciAodmFyIGlkIGluIG5vZGVzKSB7XG4gICAgICAgICAgaWYgKG5vZGVzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZnJlZXplQ2FjaGVbaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgbm9kZXNbaWRdLm9wdGlvbnMuZml4ZWQueCA9IHRoaXMuZnJlZXplQ2FjaGVbaWRdLng7XG4gICAgICAgICAgICAgIG5vZGVzW2lkXS5vcHRpb25zLmZpeGVkLnkgPSB0aGlzLmZyZWV6ZUNhY2hlW2lkXS55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZyZWV6ZUNhY2hlID0ge307XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRmluZCBhIHN0YWJsZSBwb3NpdGlvbiBmb3IgYWxsIG5vZGVzXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3N0YWJpbGl6ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc3RhYmlsaXplKCkge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICB2YXIgaXRlcmF0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHRoaXMub3B0aW9ucy5zdGFiaWxpemF0aW9uLml0ZXJhdGlvbnMgOiBhcmd1bWVudHNbMF07XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpdGVyYXRpb25zICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdUaGUgc3RhYmlsaXplIG1ldGhvZCBuZWVkcyBhIG51bWVyaWMgYW1vdW50IG9mIGl0ZXJhdGlvbnMuIFN3aXRjaGluZyB0byBkZWZhdWx0OiAnLCB0aGlzLm9wdGlvbnMuc3RhYmlsaXphdGlvbi5pdGVyYXRpb25zKTtcbiAgICAgICAgICBpdGVyYXRpb25zID0gdGhpcy5vcHRpb25zLnN0YWJpbGl6YXRpb24uaXRlcmF0aW9ucztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlbmFibGUgYWRhcHRpdmUgdGltZXN0ZXBzXG4gICAgICAgIHRoaXMuYWRhcHRpdmVUaW1lc3RlcCA9IHRydWUgJiYgdGhpcy5vcHRpb25zLmFkYXB0aXZlVGltZXN0ZXA7XG5cbiAgICAgICAgLy8gdGhpcyBzZXRzIHRoZSB3aWR0aCBvZiBhbGwgbm9kZXMgaW5pdGlhbGx5IHdoaWNoIGNvdWxkIGJlIHJlcXVpcmVkIGZvciB0aGUgYXZvaWRPdmVybGFwXG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVzaXplTm9kZXNcIik7XG5cbiAgICAgICAgLy8gc3RvcCB0aGUgcmVuZGVyIGxvb3BcbiAgICAgICAgdGhpcy5zdG9wU2ltdWxhdGlvbigpO1xuXG4gICAgICAgIC8vIHNldCBzdGFiaWx6ZSB0byBmYWxzZVxuICAgICAgICB0aGlzLnN0YWJpbGl6ZWQgPSBmYWxzZTtcblxuICAgICAgICAvLyBibG9jayByZWRyYXcgcmVxdWVzdHNcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2Jsb2NrUmVkcmF3Jyk7XG4gICAgICAgIHRoaXMudGFyZ2V0SXRlcmF0aW9ucyA9IGl0ZXJhdGlvbnM7XG5cbiAgICAgICAgLy8gc3RhcnQgdGhlIHN0YWJpbGl6YXRpb25cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGFiaWxpemF0aW9uLm9ubHlEeW5hbWljRWRnZXMgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLl9mcmVlemVOb2RlcygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhYmlsaXphdGlvbkl0ZXJhdGlvbnMgPSAwO1xuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczMuX3N0YWJpbGl6YXRpb25CYXRjaCgpO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBPbmUgYmF0Y2ggb2Ygc3RhYmlsaXphdGlvblxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3N0YWJpbGl6YXRpb25CYXRjaCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3N0YWJpbGl6YXRpb25CYXRjaCgpIHtcbiAgICAgICAgLy8gdGhpcyBpcyBoZXJlIHRvIGVuc3VyZSB0aGF0IHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBzdGFydCBldmVudC5cbiAgICAgICAgaWYgKHRoaXMuc3RhcnRlZFN0YWJpbGl6YXRpb24gPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnc3RhcnRTdGFiaWxpemluZycpO1xuICAgICAgICAgIHRoaXMuc3RhcnRlZFN0YWJpbGl6YXRpb24gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgd2hpbGUgKHRoaXMuc3RhYmlsaXplZCA9PT0gZmFsc2UgJiYgY291bnQgPCB0aGlzLm9wdGlvbnMuc3RhYmlsaXphdGlvbi51cGRhdGVJbnRlcnZhbCAmJiB0aGlzLnN0YWJpbGl6YXRpb25JdGVyYXRpb25zIDwgdGhpcy50YXJnZXRJdGVyYXRpb25zKSB7XG4gICAgICAgICAgdGhpcy5waHlzaWNzVGljaygpO1xuICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zdGFiaWxpemVkID09PSBmYWxzZSAmJiB0aGlzLnN0YWJpbGl6YXRpb25JdGVyYXRpb25zIDwgdGhpcy50YXJnZXRJdGVyYXRpb25zKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnc3RhYmlsaXphdGlvblByb2dyZXNzJywgeyBpdGVyYXRpb25zOiB0aGlzLnN0YWJpbGl6YXRpb25JdGVyYXRpb25zLCB0b3RhbDogdGhpcy50YXJnZXRJdGVyYXRpb25zIH0pO1xuICAgICAgICAgIHNldFRpbWVvdXQodGhpcy5fc3RhYmlsaXphdGlvbkJhdGNoLmJpbmQodGhpcyksIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2ZpbmFsaXplU3RhYmlsaXphdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogV3JhcCB1cCB0aGUgc3RhYmlsaXphdGlvbiwgZml0IGFuZCBlbWl0IHRoZSBldmVudHMuXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZmluYWxpemVTdGFiaWxpemF0aW9uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZmluYWxpemVTdGFiaWxpemF0aW9uKCkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfYWxsb3dSZWRyYXcnKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGFiaWxpemF0aW9uLmZpdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ2ZpdCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGFiaWxpemF0aW9uLm9ubHlEeW5hbWljRWRnZXMgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLl9yZXN0b3JlRnJvemVuTm9kZXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3N0YWJpbGl6YXRpb25JdGVyYXRpb25zRG9uZScpO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfcmVxdWVzdFJlZHJhdycpO1xuXG4gICAgICAgIGlmICh0aGlzLnN0YWJpbGl6ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLl9lbWl0U3RhYmlsaXplZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3RhcnRTaW11bGF0aW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZHJhd0ZvcmNlcycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdGb3JjZXMoY3R4KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlc1tpXV07XG4gICAgICAgICAgdmFyIGZvcmNlID0gdGhpcy5waHlzaWNzQm9keS5mb3JjZXNbdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXNbaV1dO1xuICAgICAgICAgIHZhciBmYWN0b3IgPSAyMDtcbiAgICAgICAgICB2YXIgY29sb3JGYWN0b3IgPSAwLjAzO1xuICAgICAgICAgIHZhciBmb3JjZVNpemUgPSBNYXRoLnNxcnQoTWF0aC5wb3coZm9yY2UueCwgMikgKyBNYXRoLnBvdyhmb3JjZS54LCAyKSk7XG5cbiAgICAgICAgICB2YXIgc2l6ZSA9IE1hdGgubWluKE1hdGgubWF4KDUsIGZvcmNlU2l6ZSksIDE1KTtcbiAgICAgICAgICB2YXIgYXJyb3dTaXplID0gMyAqIHNpemU7XG5cbiAgICAgICAgICB2YXIgY29sb3IgPSB1dGlsLkhTVlRvSGV4KCgxODAgLSBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBjb2xvckZhY3RvciAqIGZvcmNlU2l6ZSkpICogMTgwKSAvIDM2MCwgMSwgMSk7XG5cbiAgICAgICAgICBjdHgubGluZVdpZHRoID0gc2l6ZTtcbiAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgY3R4Lm1vdmVUbyhub2RlLngsIG5vZGUueSk7XG4gICAgICAgICAgY3R4LmxpbmVUbyhub2RlLnggKyBmYWN0b3IgKiBmb3JjZS54LCBub2RlLnkgKyBmYWN0b3IgKiBmb3JjZS55KTtcbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKGZvcmNlLnksIGZvcmNlLngpO1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgICBjdHguYXJyb3cobm9kZS54ICsgZmFjdG9yICogZm9yY2UueCArIE1hdGguY29zKGFuZ2xlKSAqIGFycm93U2l6ZSwgbm9kZS55ICsgZmFjdG9yICogZm9yY2UueSArIE1hdGguc2luKGFuZ2xlKSAqIGFycm93U2l6ZSwgYW5nbGUsIGFycm93U2l6ZSk7XG4gICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBQaHlzaWNzRW5naW5lO1xuICB9KCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gUGh5c2ljc0VuZ2luZTtcblxuLyoqKi8gfSxcbi8qIDk0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuICBcInVzZSBzdHJpY3RcIjtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgdmFyIEJhcm5lc0h1dFNvbHZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCYXJuZXNIdXRTb2x2ZXIoYm9keSwgcGh5c2ljc0JvZHksIG9wdGlvbnMpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYXJuZXNIdXRTb2x2ZXIpO1xuXG4gICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgdGhpcy5waHlzaWNzQm9keSA9IHBoeXNpY3NCb2R5O1xuICAgICAgdGhpcy5iYXJuZXNIdXRUcmVlO1xuICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgdGhpcy5yYW5kb21TZWVkID0gNTtcblxuICAgICAgLy8gZGVidWc6IHNob3cgZ3JpZFxuICAgICAgLy90aGlzLmJvZHkuZW1pdHRlci5vbihcImFmdGVyRHJhd2luZ1wiLCAoY3R4KSA9PiB7dGhpcy5fZGVidWcoY3R4LCcjZmYwMDAwJyl9KVxuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhCYXJuZXNIdXRTb2x2ZXIsIFt7XG4gICAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnRoZXRhSW52ZXJzZWQgPSAxIC8gdGhpcy5vcHRpb25zLnRoZXRhO1xuICAgICAgICB0aGlzLm92ZXJsYXBBdm9pZGFuY2VGYWN0b3IgPSAxIC0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdGhpcy5vcHRpb25zLmF2b2lkT3ZlcmxhcCkpOyAvLyBpZiAxIHRoZW4gbWluIGRpc3RhbmNlID0gMC41LCBpZiAwLjUgdGhlbiBtaW4gZGlzdGFuY2UgPSAwLjUgKyAwLjUqbm9kZS5zaGFwZS5yYWRpdXNcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2VlZGVkUmFuZG9tXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2VlZGVkUmFuZG9tKCkge1xuICAgICAgICB2YXIgeCA9IE1hdGguc2luKHRoaXMucmFuZG9tU2VlZCsrKSAqIDEwMDAwO1xuICAgICAgICByZXR1cm4geCAtIE1hdGguZmxvb3IoeCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBmdW5jdGlvbiBjYWxjdWxhdGVzIHRoZSBmb3JjZXMgdGhlIG5vZGVzIGFwcGx5IG9uIGVhY2ggb3RoZXIgYmFzZWQgb24gYSBncmF2aXRhdGlvbmFsIG1vZGVsLlxuICAgICAgICogVGhlIEJhcm5lcyBIdXQgbWV0aG9kIGlzIHVzZWQgdG8gc3BlZWQgdXAgdGhpcyBOLWJvZHkgc2ltdWxhdGlvbi5cbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic29sdmVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzb2x2ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ncmF2aXRhdGlvbmFsQ29uc3RhbnQgIT09IDAgJiYgdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBub2RlID0gdm9pZCAwO1xuICAgICAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgICAgICB2YXIgbm9kZUluZGljZXMgPSB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcztcbiAgICAgICAgICB2YXIgbm9kZUNvdW50ID0gbm9kZUluZGljZXMubGVuZ3RoO1xuXG4gICAgICAgICAgLy8gY3JlYXRlIHRoZSB0cmVlXG4gICAgICAgICAgdmFyIGJhcm5lc0h1dFRyZWUgPSB0aGlzLl9mb3JtQmFybmVzSHV0VHJlZShub2Rlcywgbm9kZUluZGljZXMpO1xuXG4gICAgICAgICAgLy8gZm9yIGRlYnVnZ2luZ1xuICAgICAgICAgIHRoaXMuYmFybmVzSHV0VHJlZSA9IGJhcm5lc0h1dFRyZWU7XG5cbiAgICAgICAgICAvLyBwbGFjZSB0aGUgbm9kZXMgb25lIGJ5IG9uZSByZWN1cnNpdmVseVxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2Rlc1tub2RlSW5kaWNlc1tpXV07XG4gICAgICAgICAgICBpZiAobm9kZS5vcHRpb25zLm1hc3MgPiAwKSB7XG4gICAgICAgICAgICAgIC8vIHN0YXJ0aW5nIHdpdGggcm9vdCBpcyBpcnJlbGV2YW50LCBpdCBuZXZlciBwYXNzZXMgdGhlIEJhcm5lc0h1dFNvbHZlciBjb25kaXRpb25cbiAgICAgICAgICAgICAgdGhpcy5fZ2V0Rm9yY2VDb250cmlidXRpb24oYmFybmVzSHV0VHJlZS5yb290LmNoaWxkcmVuLk5XLCBub2RlKTtcbiAgICAgICAgICAgICAgdGhpcy5fZ2V0Rm9yY2VDb250cmlidXRpb24oYmFybmVzSHV0VHJlZS5yb290LmNoaWxkcmVuLk5FLCBub2RlKTtcbiAgICAgICAgICAgICAgdGhpcy5fZ2V0Rm9yY2VDb250cmlidXRpb24oYmFybmVzSHV0VHJlZS5yb290LmNoaWxkcmVuLlNXLCBub2RlKTtcbiAgICAgICAgICAgICAgdGhpcy5fZ2V0Rm9yY2VDb250cmlidXRpb24oYmFybmVzSHV0VHJlZS5yb290LmNoaWxkcmVuLlNFLCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIGZ1bmN0aW9uIHRyYXZlcnNlcyB0aGUgYmFybmVzSHV0VHJlZS4gSXQgY2hlY2tzIHdoZW4gaXQgY2FuIGFwcHJveGltYXRlIGRpc3RhbnQgbm9kZXMgd2l0aCB0aGVpciBjZW50ZXIgb2YgbWFzcy5cbiAgICAgICAqIElmIGEgcmVnaW9uIGNvbnRhaW5zIGEgc2luZ2xlIG5vZGUsIHdlIGNoZWNrIGlmIGl0IGlzIG5vdCBpdHNlbGYsIHRoZW4gd2UgYXBwbHkgdGhlIGZvcmNlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSBwYXJlbnRCcmFuY2hcbiAgICAgICAqIEBwYXJhbSBub2RlXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2dldEZvcmNlQ29udHJpYnV0aW9uXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEZvcmNlQ29udHJpYnV0aW9uKHBhcmVudEJyYW5jaCwgbm9kZSkge1xuICAgICAgICAvLyB3ZSBnZXQgbm8gZm9yY2UgY29udHJpYnV0aW9uIGZyb20gYW4gZW1wdHkgcmVnaW9uXG4gICAgICAgIGlmIChwYXJlbnRCcmFuY2guY2hpbGRyZW5Db3VudCA+IDApIHtcbiAgICAgICAgICB2YXIgZHggPSB2b2lkIDAsXG4gICAgICAgICAgICAgIGR5ID0gdm9pZCAwLFxuICAgICAgICAgICAgICBkaXN0YW5jZSA9IHZvaWQgMDtcblxuICAgICAgICAgIC8vIGdldCB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgY2VudGVyIG9mIG1hc3MgdG8gdGhlIG5vZGUuXG4gICAgICAgICAgZHggPSBwYXJlbnRCcmFuY2guY2VudGVyT2ZNYXNzLnggLSBub2RlLng7XG4gICAgICAgICAgZHkgPSBwYXJlbnRCcmFuY2guY2VudGVyT2ZNYXNzLnkgLSBub2RlLnk7XG4gICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICAgICAgLy8gQmFybmVzSHV0U29sdmVyIGNvbmRpdGlvblxuICAgICAgICAgIC8vIG9yaWdpbmFsIGNvbmRpdGlvbiA6IHMvZCA8IHRoZXRhID0gcGFzc2VkICA9PT0gIGQvcyA+IDEvdGhldGEgPSBwYXNzZWRcbiAgICAgICAgICAvLyBjYWxjU2l6ZSA9IDEvcyAtLT4gZCAqIDEvcyA+IDEvdGhldGEgPSBwYXNzZWRcbiAgICAgICAgICBpZiAoZGlzdGFuY2UgKiBwYXJlbnRCcmFuY2guY2FsY1NpemUgPiB0aGlzLnRoZXRhSW52ZXJzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGN1bGF0ZUZvcmNlcyhkaXN0YW5jZSwgZHgsIGR5LCBub2RlLCBwYXJlbnRCcmFuY2gpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBEaWQgbm90IHBhc3MgdGhlIGNvbmRpdGlvbiwgZ28gaW50byBjaGlsZHJlbiBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgIGlmIChwYXJlbnRCcmFuY2guY2hpbGRyZW5Db3VudCA9PT0gNCkge1xuICAgICAgICAgICAgICB0aGlzLl9nZXRGb3JjZUNvbnRyaWJ1dGlvbihwYXJlbnRCcmFuY2guY2hpbGRyZW4uTlcsIG5vZGUpO1xuICAgICAgICAgICAgICB0aGlzLl9nZXRGb3JjZUNvbnRyaWJ1dGlvbihwYXJlbnRCcmFuY2guY2hpbGRyZW4uTkUsIG5vZGUpO1xuICAgICAgICAgICAgICB0aGlzLl9nZXRGb3JjZUNvbnRyaWJ1dGlvbihwYXJlbnRCcmFuY2guY2hpbGRyZW4uU1csIG5vZGUpO1xuICAgICAgICAgICAgICB0aGlzLl9nZXRGb3JjZUNvbnRyaWJ1dGlvbihwYXJlbnRCcmFuY2guY2hpbGRyZW4uU0UsIG5vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gcGFyZW50QnJhbmNoIG11c3QgaGF2ZSBvbmx5IG9uZSBub2RlLCBpZiBpdCB3YXMgZW1wdHkgd2Ugd291bGRudCBiZSBoZXJlXG4gICAgICAgICAgICAgIGlmIChwYXJlbnRCcmFuY2guY2hpbGRyZW4uZGF0YS5pZCAhPSBub2RlLmlkKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgaXQgaXMgbm90IHNlbGZcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVGb3JjZXMoZGlzdGFuY2UsIGR4LCBkeSwgbm9kZSwgcGFyZW50QnJhbmNoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGN1bGF0ZSB0aGUgZm9yY2VzIGJhc2VkIG9uIHRoZSBkaXN0YW5jZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gZGlzdGFuY2VcbiAgICAgICAqIEBwYXJhbSBkeFxuICAgICAgICogQHBhcmFtIGR5XG4gICAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAgICogQHBhcmFtIHBhcmVudEJyYW5jaFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9jYWxjdWxhdGVGb3JjZXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FsY3VsYXRlRm9yY2VzKGRpc3RhbmNlLCBkeCwgZHksIG5vZGUsIHBhcmVudEJyYW5jaCkge1xuICAgICAgICBpZiAoZGlzdGFuY2UgPT09IDApIHtcbiAgICAgICAgICBkaXN0YW5jZSA9IDAuMTtcbiAgICAgICAgICBkeCA9IGRpc3RhbmNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3ZlcmxhcEF2b2lkYW5jZUZhY3RvciA8IDEpIHtcbiAgICAgICAgICBkaXN0YW5jZSA9IE1hdGgubWF4KDAuMSArIHRoaXMub3ZlcmxhcEF2b2lkYW5jZUZhY3RvciAqIG5vZGUuc2hhcGUucmFkaXVzLCBkaXN0YW5jZSAtIG5vZGUuc2hhcGUucmFkaXVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoZSBkaXZpZGluZyBieSB0aGUgZGlzdGFuY2UgY3ViZWQgaW5zdGVhZCBvZiBzcXVhcmVkIGFsbG93cyB1cyB0byBnZXQgdGhlIGZ4IGFuZCBmeSBjb21wb25lbnRzIHdpdGhvdXQgc2luZXMgYW5kIGNvc2luZXNcbiAgICAgICAgLy8gaXQgaXMgc2hvcnRoYW5kIGZvciBncmF2aXR5Zm9yY2Ugd2l0aCBkaXN0YW5jZSBzcXVhcmVkIGFuZCBmeCA9IGR4L2Rpc3RhbmNlICogZ3Jhdml0eUZvcmNlXG4gICAgICAgIHZhciBncmF2aXR5Rm9yY2UgPSB0aGlzLm9wdGlvbnMuZ3Jhdml0YXRpb25hbENvbnN0YW50ICogcGFyZW50QnJhbmNoLm1hc3MgKiBub2RlLm9wdGlvbnMubWFzcyAvIE1hdGgucG93KGRpc3RhbmNlLCAzKTtcbiAgICAgICAgdmFyIGZ4ID0gZHggKiBncmF2aXR5Rm9yY2U7XG4gICAgICAgIHZhciBmeSA9IGR5ICogZ3Jhdml0eUZvcmNlO1xuXG4gICAgICAgIHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGUuaWRdLnggKz0gZng7XG4gICAgICAgIHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGUuaWRdLnkgKz0gZnk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBmdW5jdGlvbiBjb25zdHJ1Y3RzIHRoZSBiYXJuZXNIdXQgdHJlZSByZWN1cnNpdmVseS4gSXQgY3JlYXRlcyB0aGUgcm9vdCwgc3BsaXRzIGl0IGFuZCBzdGFydHMgcGxhY2luZyB0aGUgbm9kZXMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIG5vZGVzXG4gICAgICAgKiBAcGFyYW0gbm9kZUluZGljZXNcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfZm9ybUJhcm5lc0h1dFRyZWVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZm9ybUJhcm5lc0h1dFRyZWUobm9kZXMsIG5vZGVJbmRpY2VzKSB7XG4gICAgICAgIHZhciBub2RlID0gdm9pZCAwO1xuICAgICAgICB2YXIgbm9kZUNvdW50ID0gbm9kZUluZGljZXMubGVuZ3RoO1xuXG4gICAgICAgIHZhciBtaW5YID0gbm9kZXNbbm9kZUluZGljZXNbMF1dLng7XG4gICAgICAgIHZhciBtaW5ZID0gbm9kZXNbbm9kZUluZGljZXNbMF1dLnk7XG4gICAgICAgIHZhciBtYXhYID0gbm9kZXNbbm9kZUluZGljZXNbMF1dLng7XG4gICAgICAgIHZhciBtYXhZID0gbm9kZXNbbm9kZUluZGljZXNbMF1dLnk7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSByYW5nZSBvZiB0aGUgbm9kZXNcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBub2RlQ291bnQ7IGkrKykge1xuICAgICAgICAgIHZhciB4ID0gbm9kZXNbbm9kZUluZGljZXNbaV1dLng7XG4gICAgICAgICAgdmFyIHkgPSBub2Rlc1tub2RlSW5kaWNlc1tpXV0ueTtcbiAgICAgICAgICBpZiAobm9kZXNbbm9kZUluZGljZXNbaV1dLm9wdGlvbnMubWFzcyA+IDApIHtcbiAgICAgICAgICAgIGlmICh4IDwgbWluWCkge1xuICAgICAgICAgICAgICBtaW5YID0geDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4ID4gbWF4WCkge1xuICAgICAgICAgICAgICBtYXhYID0geDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5IDwgbWluWSkge1xuICAgICAgICAgICAgICBtaW5ZID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5ID4gbWF4WSkge1xuICAgICAgICAgICAgICBtYXhZID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWFrZSB0aGUgcmFuZ2UgYSBzcXVhcmVcbiAgICAgICAgdmFyIHNpemVEaWZmID0gTWF0aC5hYnMobWF4WCAtIG1pblgpIC0gTWF0aC5hYnMobWF4WSAtIG1pblkpOyAvLyBkaWZmZXJlbmNlIGJldHdlZW4gWCBhbmQgWVxuICAgICAgICBpZiAoc2l6ZURpZmYgPiAwKSB7XG4gICAgICAgICAgbWluWSAtPSAwLjUgKiBzaXplRGlmZjtcbiAgICAgICAgICBtYXhZICs9IDAuNSAqIHNpemVEaWZmO1xuICAgICAgICB9IC8vIHhTaXplID4geVNpemVcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtaW5YICs9IDAuNSAqIHNpemVEaWZmO1xuICAgICAgICAgICAgbWF4WCAtPSAwLjUgKiBzaXplRGlmZjtcbiAgICAgICAgICB9IC8vIHhTaXplIDwgeVNpemVcblxuICAgICAgICB2YXIgbWluaW11bVRyZWVTaXplID0gMWUtNTtcbiAgICAgICAgdmFyIHJvb3RTaXplID0gTWF0aC5tYXgobWluaW11bVRyZWVTaXplLCBNYXRoLmFicyhtYXhYIC0gbWluWCkpO1xuICAgICAgICB2YXIgaGFsZlJvb3RTaXplID0gMC41ICogcm9vdFNpemU7XG4gICAgICAgIHZhciBjZW50ZXJYID0gMC41ICogKG1pblggKyBtYXhYKSxcbiAgICAgICAgICAgIGNlbnRlclkgPSAwLjUgKiAobWluWSArIG1heFkpO1xuXG4gICAgICAgIC8vIGNvbnN0cnVjdCB0aGUgYmFybmVzSHV0VHJlZVxuICAgICAgICB2YXIgYmFybmVzSHV0VHJlZSA9IHtcbiAgICAgICAgICByb290OiB7XG4gICAgICAgICAgICBjZW50ZXJPZk1hc3M6IHsgeDogMCwgeTogMCB9LFxuICAgICAgICAgICAgbWFzczogMCxcbiAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICAgIG1pblg6IGNlbnRlclggLSBoYWxmUm9vdFNpemUsIG1heFg6IGNlbnRlclggKyBoYWxmUm9vdFNpemUsXG4gICAgICAgICAgICAgIG1pblk6IGNlbnRlclkgLSBoYWxmUm9vdFNpemUsIG1heFk6IGNlbnRlclkgKyBoYWxmUm9vdFNpemVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaXplOiByb290U2l6ZSxcbiAgICAgICAgICAgIGNhbGNTaXplOiAxIC8gcm9vdFNpemUsXG4gICAgICAgICAgICBjaGlsZHJlbjogeyBkYXRhOiBudWxsIH0sXG4gICAgICAgICAgICBtYXhXaWR0aDogMCxcbiAgICAgICAgICAgIGxldmVsOiAwLFxuICAgICAgICAgICAgY2hpbGRyZW5Db3VudDogNFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fc3BsaXRCcmFuY2goYmFybmVzSHV0VHJlZS5yb290KTtcblxuICAgICAgICAvLyBwbGFjZSB0aGUgbm9kZXMgb25lIGJ5IG9uZSByZWN1cnNpdmVseVxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbm9kZUNvdW50OyBfaSsrKSB7XG4gICAgICAgICAgbm9kZSA9IG5vZGVzW25vZGVJbmRpY2VzW19pXV07XG4gICAgICAgICAgaWYgKG5vZGUub3B0aW9ucy5tYXNzID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fcGxhY2VJblRyZWUoYmFybmVzSHV0VHJlZS5yb290LCBub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYWtlIGdsb2JhbFxuICAgICAgICByZXR1cm4gYmFybmVzSHV0VHJlZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiB0aGlzIHVwZGF0ZXMgdGhlIG1hc3Mgb2YgYSBicmFuY2guIHRoaXMgaXMgaW5jcmVhc2VkIGJ5IGFkZGluZyBhIG5vZGUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHBhcmVudEJyYW5jaFxuICAgICAgICogQHBhcmFtIG5vZGVcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfdXBkYXRlQnJhbmNoTWFzc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVCcmFuY2hNYXNzKHBhcmVudEJyYW5jaCwgbm9kZSkge1xuICAgICAgICB2YXIgdG90YWxNYXNzID0gcGFyZW50QnJhbmNoLm1hc3MgKyBub2RlLm9wdGlvbnMubWFzcztcbiAgICAgICAgdmFyIHRvdGFsTWFzc0ludiA9IDEgLyB0b3RhbE1hc3M7XG5cbiAgICAgICAgcGFyZW50QnJhbmNoLmNlbnRlck9mTWFzcy54ID0gcGFyZW50QnJhbmNoLmNlbnRlck9mTWFzcy54ICogcGFyZW50QnJhbmNoLm1hc3MgKyBub2RlLnggKiBub2RlLm9wdGlvbnMubWFzcztcbiAgICAgICAgcGFyZW50QnJhbmNoLmNlbnRlck9mTWFzcy54ICo9IHRvdGFsTWFzc0ludjtcblxuICAgICAgICBwYXJlbnRCcmFuY2guY2VudGVyT2ZNYXNzLnkgPSBwYXJlbnRCcmFuY2guY2VudGVyT2ZNYXNzLnkgKiBwYXJlbnRCcmFuY2gubWFzcyArIG5vZGUueSAqIG5vZGUub3B0aW9ucy5tYXNzO1xuICAgICAgICBwYXJlbnRCcmFuY2guY2VudGVyT2ZNYXNzLnkgKj0gdG90YWxNYXNzSW52O1xuXG4gICAgICAgIHBhcmVudEJyYW5jaC5tYXNzID0gdG90YWxNYXNzO1xuICAgICAgICB2YXIgYmlnZ2VzdFNpemUgPSBNYXRoLm1heChNYXRoLm1heChub2RlLmhlaWdodCwgbm9kZS5yYWRpdXMpLCBub2RlLndpZHRoKTtcbiAgICAgICAgcGFyZW50QnJhbmNoLm1heFdpZHRoID0gcGFyZW50QnJhbmNoLm1heFdpZHRoIDwgYmlnZ2VzdFNpemUgPyBiaWdnZXN0U2l6ZSA6IHBhcmVudEJyYW5jaC5tYXhXaWR0aDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBkZXRlcm1pbmUgaW4gd2hpY2ggYnJhbmNoIHRoZSBub2RlIHdpbGwgYmUgcGxhY2VkLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSBwYXJlbnRCcmFuY2hcbiAgICAgICAqIEBwYXJhbSBub2RlXG4gICAgICAgKiBAcGFyYW0gc2tpcE1hc3NVcGRhdGVcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfcGxhY2VJblRyZWVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcGxhY2VJblRyZWUocGFyZW50QnJhbmNoLCBub2RlLCBza2lwTWFzc1VwZGF0ZSkge1xuICAgICAgICBpZiAoc2tpcE1hc3NVcGRhdGUgIT0gdHJ1ZSB8fCBza2lwTWFzc1VwZGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gdXBkYXRlIHRoZSBtYXNzIG9mIHRoZSBicmFuY2guXG4gICAgICAgICAgdGhpcy5fdXBkYXRlQnJhbmNoTWFzcyhwYXJlbnRCcmFuY2gsIG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmVudEJyYW5jaC5jaGlsZHJlbi5OVy5yYW5nZS5tYXhYID4gbm9kZS54KSB7XG4gICAgICAgICAgLy8gaW4gTlcgb3IgU1dcbiAgICAgICAgICBpZiAocGFyZW50QnJhbmNoLmNoaWxkcmVuLk5XLnJhbmdlLm1heFkgPiBub2RlLnkpIHtcbiAgICAgICAgICAgIC8vIGluIE5XXG4gICAgICAgICAgICB0aGlzLl9wbGFjZUluUmVnaW9uKHBhcmVudEJyYW5jaCwgbm9kZSwgXCJOV1wiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaW4gU1dcbiAgICAgICAgICAgIHRoaXMuX3BsYWNlSW5SZWdpb24ocGFyZW50QnJhbmNoLCBub2RlLCBcIlNXXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpbiBORSBvciBTRVxuICAgICAgICAgIGlmIChwYXJlbnRCcmFuY2guY2hpbGRyZW4uTlcucmFuZ2UubWF4WSA+IG5vZGUueSkge1xuICAgICAgICAgICAgLy8gaW4gTkVcbiAgICAgICAgICAgIHRoaXMuX3BsYWNlSW5SZWdpb24ocGFyZW50QnJhbmNoLCBub2RlLCBcIk5FXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpbiBTRVxuICAgICAgICAgICAgdGhpcy5fcGxhY2VJblJlZ2lvbihwYXJlbnRCcmFuY2gsIG5vZGUsIFwiU0VcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogYWN0dWFsbHkgcGxhY2UgdGhlIG5vZGUgaW4gYSByZWdpb24gKG9yIGJyYW5jaClcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gcGFyZW50QnJhbmNoXG4gICAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAgICogQHBhcmFtIHJlZ2lvblxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9wbGFjZUluUmVnaW9uXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3BsYWNlSW5SZWdpb24ocGFyZW50QnJhbmNoLCBub2RlLCByZWdpb24pIHtcbiAgICAgICAgc3dpdGNoIChwYXJlbnRCcmFuY2guY2hpbGRyZW5bcmVnaW9uXS5jaGlsZHJlbkNvdW50KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgLy8gcGxhY2Ugbm9kZSBoZXJlXG4gICAgICAgICAgICBwYXJlbnRCcmFuY2guY2hpbGRyZW5bcmVnaW9uXS5jaGlsZHJlbi5kYXRhID0gbm9kZTtcbiAgICAgICAgICAgIHBhcmVudEJyYW5jaC5jaGlsZHJlbltyZWdpb25dLmNoaWxkcmVuQ291bnQgPSAxO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQnJhbmNoTWFzcyhwYXJlbnRCcmFuY2guY2hpbGRyZW5bcmVnaW9uXSwgbm9kZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAvLyBjb252ZXJ0IGludG8gY2hpbGRyZW5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSB0d28gbm9kZXMgZXhhY3RseSBvdmVybGFwcGluZyAob24gaW5pdCwgb24gb3BlbmluZyBvZiBjbHVzdGVyIGV0Yy4pXG4gICAgICAgICAgICAvLyB3ZSBtb3ZlIG9uZSBub2RlIGEgbGl0dGxlIGJpdCBhbmQgd2UgZG8gbm90IHB1dCBpdCBpbiB0aGUgdHJlZS5cbiAgICAgICAgICAgIGlmIChwYXJlbnRCcmFuY2guY2hpbGRyZW5bcmVnaW9uXS5jaGlsZHJlbi5kYXRhLnggPT09IG5vZGUueCAmJiBwYXJlbnRCcmFuY2guY2hpbGRyZW5bcmVnaW9uXS5jaGlsZHJlbi5kYXRhLnkgPT09IG5vZGUueSkge1xuICAgICAgICAgICAgICBub2RlLnggKz0gdGhpcy5zZWVkZWRSYW5kb20oKTtcbiAgICAgICAgICAgICAgbm9kZS55ICs9IHRoaXMuc2VlZGVkUmFuZG9tKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9zcGxpdEJyYW5jaChwYXJlbnRCcmFuY2guY2hpbGRyZW5bcmVnaW9uXSk7XG4gICAgICAgICAgICAgIHRoaXMuX3BsYWNlSW5UcmVlKHBhcmVudEJyYW5jaC5jaGlsZHJlbltyZWdpb25dLCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIC8vIHBsYWNlIGluIGJyYW5jaFxuICAgICAgICAgICAgdGhpcy5fcGxhY2VJblRyZWUocGFyZW50QnJhbmNoLmNoaWxkcmVuW3JlZ2lvbl0sIG5vZGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiB0aGlzIGZ1bmN0aW9uIHNwbGl0cyBhIGJyYW5jaCBpbnRvIDQgc3ViIGJyYW5jaGVzLiBJZiB0aGUgYnJhbmNoIGNvbnRhaW5lZCBhIG5vZGUsIHdlIHBsYWNlIGl0IGluIHRoZSBzdWJicmFuY2hcbiAgICAgICAqIGFmdGVyIHRoZSBzcGxpdCBpcyBjb21wbGV0ZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gcGFyZW50QnJhbmNoXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3NwbGl0QnJhbmNoXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NwbGl0QnJhbmNoKHBhcmVudEJyYW5jaCkge1xuICAgICAgICAvLyBpZiB0aGUgYnJhbmNoIGlzIHNoYWRlZCB3aXRoIGEgbm9kZSwgcmVwbGFjZSB0aGUgbm9kZSBpbiB0aGUgbmV3IHN1YnNldC5cbiAgICAgICAgdmFyIGNvbnRhaW5lZE5vZGUgPSBudWxsO1xuICAgICAgICBpZiAocGFyZW50QnJhbmNoLmNoaWxkcmVuQ291bnQgPT09IDEpIHtcbiAgICAgICAgICBjb250YWluZWROb2RlID0gcGFyZW50QnJhbmNoLmNoaWxkcmVuLmRhdGE7XG4gICAgICAgICAgcGFyZW50QnJhbmNoLm1hc3MgPSAwO1xuICAgICAgICAgIHBhcmVudEJyYW5jaC5jZW50ZXJPZk1hc3MueCA9IDA7XG4gICAgICAgICAgcGFyZW50QnJhbmNoLmNlbnRlck9mTWFzcy55ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnRCcmFuY2guY2hpbGRyZW5Db3VudCA9IDQ7XG4gICAgICAgIHBhcmVudEJyYW5jaC5jaGlsZHJlbi5kYXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5faW5zZXJ0UmVnaW9uKHBhcmVudEJyYW5jaCwgXCJOV1wiKTtcbiAgICAgICAgdGhpcy5faW5zZXJ0UmVnaW9uKHBhcmVudEJyYW5jaCwgXCJORVwiKTtcbiAgICAgICAgdGhpcy5faW5zZXJ0UmVnaW9uKHBhcmVudEJyYW5jaCwgXCJTV1wiKTtcbiAgICAgICAgdGhpcy5faW5zZXJ0UmVnaW9uKHBhcmVudEJyYW5jaCwgXCJTRVwiKTtcblxuICAgICAgICBpZiAoY29udGFpbmVkTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5fcGxhY2VJblRyZWUocGFyZW50QnJhbmNoLCBjb250YWluZWROb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgZnVuY3Rpb24gc3ViZGl2aWRlcyB0aGUgcmVnaW9uIGludG8gZm91ciBuZXcgc2VnbWVudHMuXG4gICAgICAgKiBTcGVjaWZpY2FsbHksIHRoaXMgaW5zZXJ0cyBhIHNpbmdsZSBuZXcgc2VnbWVudC5cbiAgICAgICAqIEl0IGZpbGxzIHRoZSBjaGlsZHJlbiBzZWN0aW9uIG9mIHRoZSBwYXJlbnRCcmFuY2hcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gcGFyZW50QnJhbmNoXG4gICAgICAgKiBAcGFyYW0gcmVnaW9uXG4gICAgICAgKiBAcGFyYW0gcGFyZW50UmFuZ2VcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaW5zZXJ0UmVnaW9uXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2luc2VydFJlZ2lvbihwYXJlbnRCcmFuY2gsIHJlZ2lvbikge1xuICAgICAgICB2YXIgbWluWCA9IHZvaWQgMCxcbiAgICAgICAgICAgIG1heFggPSB2b2lkIDAsXG4gICAgICAgICAgICBtaW5ZID0gdm9pZCAwLFxuICAgICAgICAgICAgbWF4WSA9IHZvaWQgMDtcbiAgICAgICAgdmFyIGNoaWxkU2l6ZSA9IDAuNSAqIHBhcmVudEJyYW5jaC5zaXplO1xuICAgICAgICBzd2l0Y2ggKHJlZ2lvbikge1xuICAgICAgICAgIGNhc2UgXCJOV1wiOlxuICAgICAgICAgICAgbWluWCA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5YO1xuICAgICAgICAgICAgbWF4WCA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5YICsgY2hpbGRTaXplO1xuICAgICAgICAgICAgbWluWSA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5ZO1xuICAgICAgICAgICAgbWF4WSA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5ZICsgY2hpbGRTaXplO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIk5FXCI6XG4gICAgICAgICAgICBtaW5YID0gcGFyZW50QnJhbmNoLnJhbmdlLm1pblggKyBjaGlsZFNpemU7XG4gICAgICAgICAgICBtYXhYID0gcGFyZW50QnJhbmNoLnJhbmdlLm1heFg7XG4gICAgICAgICAgICBtaW5ZID0gcGFyZW50QnJhbmNoLnJhbmdlLm1pblk7XG4gICAgICAgICAgICBtYXhZID0gcGFyZW50QnJhbmNoLnJhbmdlLm1pblkgKyBjaGlsZFNpemU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiU1dcIjpcbiAgICAgICAgICAgIG1pblggPSBwYXJlbnRCcmFuY2gucmFuZ2UubWluWDtcbiAgICAgICAgICAgIG1heFggPSBwYXJlbnRCcmFuY2gucmFuZ2UubWluWCArIGNoaWxkU2l6ZTtcbiAgICAgICAgICAgIG1pblkgPSBwYXJlbnRCcmFuY2gucmFuZ2UubWluWSArIGNoaWxkU2l6ZTtcbiAgICAgICAgICAgIG1heFkgPSBwYXJlbnRCcmFuY2gucmFuZ2UubWF4WTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJTRVwiOlxuICAgICAgICAgICAgbWluWCA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5YICsgY2hpbGRTaXplO1xuICAgICAgICAgICAgbWF4WCA9IHBhcmVudEJyYW5jaC5yYW5nZS5tYXhYO1xuICAgICAgICAgICAgbWluWSA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5ZICsgY2hpbGRTaXplO1xuICAgICAgICAgICAgbWF4WSA9IHBhcmVudEJyYW5jaC5yYW5nZS5tYXhZO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJlbnRCcmFuY2guY2hpbGRyZW5bcmVnaW9uXSA9IHtcbiAgICAgICAgICBjZW50ZXJPZk1hc3M6IHsgeDogMCwgeTogMCB9LFxuICAgICAgICAgIG1hc3M6IDAsXG4gICAgICAgICAgcmFuZ2U6IHsgbWluWDogbWluWCwgbWF4WDogbWF4WCwgbWluWTogbWluWSwgbWF4WTogbWF4WSB9LFxuICAgICAgICAgIHNpemU6IDAuNSAqIHBhcmVudEJyYW5jaC5zaXplLFxuICAgICAgICAgIGNhbGNTaXplOiAyICogcGFyZW50QnJhbmNoLmNhbGNTaXplLFxuICAgICAgICAgIGNoaWxkcmVuOiB7IGRhdGE6IG51bGwgfSxcbiAgICAgICAgICBtYXhXaWR0aDogMCxcbiAgICAgICAgICBsZXZlbDogcGFyZW50QnJhbmNoLmxldmVsICsgMSxcbiAgICAgICAgICBjaGlsZHJlbkNvdW50OiAwXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICBERUJVR0dJTkcgQkVMT1cgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBmdW5jdGlvbiBpcyBmb3IgZGVidWdnaW5nIHB1cnBvc2VkLCBpdCBkcmF3cyB0aGUgdHJlZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gY3R4XG4gICAgICAgKiBAcGFyYW0gY29sb3JcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfZGVidWdcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVidWcoY3R4LCBjb2xvcikge1xuICAgICAgICBpZiAodGhpcy5iYXJuZXNIdXRUcmVlICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xuXG4gICAgICAgICAgdGhpcy5fZHJhd0JyYW5jaCh0aGlzLmJhcm5lc0h1dFRyZWUucm9vdCwgY3R4LCBjb2xvcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuIEl0IGRyYXdzIHRoZSBicmFuY2hlcyByZWN1cnNpdmVseS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gYnJhbmNoXG4gICAgICAgKiBAcGFyYW0gY3R4XG4gICAgICAgKiBAcGFyYW0gY29sb3JcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfZHJhd0JyYW5jaFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3QnJhbmNoKGJyYW5jaCwgY3R4LCBjb2xvcikge1xuICAgICAgICBpZiAoY29sb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbG9yID0gXCIjRkYwMDAwXCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYnJhbmNoLmNoaWxkcmVuQ291bnQgPT09IDQpIHtcbiAgICAgICAgICB0aGlzLl9kcmF3QnJhbmNoKGJyYW5jaC5jaGlsZHJlbi5OVywgY3R4KTtcbiAgICAgICAgICB0aGlzLl9kcmF3QnJhbmNoKGJyYW5jaC5jaGlsZHJlbi5ORSwgY3R4KTtcbiAgICAgICAgICB0aGlzLl9kcmF3QnJhbmNoKGJyYW5jaC5jaGlsZHJlbi5TRSwgY3R4KTtcbiAgICAgICAgICB0aGlzLl9kcmF3QnJhbmNoKGJyYW5jaC5jaGlsZHJlbi5TVywgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKGJyYW5jaC5yYW5nZS5taW5YLCBicmFuY2gucmFuZ2UubWluWSk7XG4gICAgICAgIGN0eC5saW5lVG8oYnJhbmNoLnJhbmdlLm1heFgsIGJyYW5jaC5yYW5nZS5taW5ZKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhicmFuY2gucmFuZ2UubWF4WCwgYnJhbmNoLnJhbmdlLm1pblkpO1xuICAgICAgICBjdHgubGluZVRvKGJyYW5jaC5yYW5nZS5tYXhYLCBicmFuY2gucmFuZ2UubWF4WSk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8oYnJhbmNoLnJhbmdlLm1heFgsIGJyYW5jaC5yYW5nZS5tYXhZKTtcbiAgICAgICAgY3R4LmxpbmVUbyhicmFuY2gucmFuZ2UubWluWCwgYnJhbmNoLnJhbmdlLm1heFkpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKGJyYW5jaC5yYW5nZS5taW5YLCBicmFuY2gucmFuZ2UubWF4WSk7XG4gICAgICAgIGN0eC5saW5lVG8oYnJhbmNoLnJhbmdlLm1pblgsIGJyYW5jaC5yYW5nZS5taW5ZKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgIC8qXG4gICAgICAgICBpZiAoYnJhbmNoLm1hc3MgPiAwKSB7XG4gICAgICAgICBjdHguY2lyY2xlKGJyYW5jaC5jZW50ZXJPZk1hc3MueCwgYnJhbmNoLmNlbnRlck9mTWFzcy55LCAzKmJyYW5jaC5tYXNzKTtcbiAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgIH1cbiAgICAgICAgICovXG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEJhcm5lc0h1dFNvbHZlcjtcbiAgfSgpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IEJhcm5lc0h1dFNvbHZlcjtcblxuLyoqKi8gfSxcbi8qIDk1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuICBcInVzZSBzdHJpY3RcIjtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgdmFyIFJlcHVsc2lvblNvbHZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXB1bHNpb25Tb2x2ZXIoYm9keSwgcGh5c2ljc0JvZHksIG9wdGlvbnMpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZXB1bHNpb25Tb2x2ZXIpO1xuXG4gICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgdGhpcy5waHlzaWNzQm9keSA9IHBoeXNpY3NCb2R5O1xuICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhSZXB1bHNpb25Tb2x2ZXIsIFt7XG4gICAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBDYWxjdWxhdGUgdGhlIGZvcmNlcyB0aGUgbm9kZXMgYXBwbHkgb24gZWFjaCBvdGhlciBiYXNlZCBvbiBhIHJlcHVsc2lvbiBmaWVsZC5cbiAgICAgICAqIFRoaXMgZmllbGQgaXMgbGluZWFybHkgYXBwcm94aW1hdGVkLlxuICAgICAgICpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzb2x2ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNvbHZlKCkge1xuICAgICAgICB2YXIgZHgsIGR5LCBkaXN0YW5jZSwgZngsIGZ5LCByZXB1bHNpbmdGb3JjZSwgbm9kZTEsIG5vZGUyO1xuXG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgICAgdmFyIG5vZGVJbmRpY2VzID0gdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXM7XG4gICAgICAgIHZhciBmb3JjZXMgPSB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlcztcblxuICAgICAgICAvLyByZXB1bHNpbmcgZm9yY2VzIGJldHdlZW4gbm9kZXNcbiAgICAgICAgdmFyIG5vZGVEaXN0YW5jZSA9IHRoaXMub3B0aW9ucy5ub2RlRGlzdGFuY2U7XG5cbiAgICAgICAgLy8gYXBwcm94aW1hdGlvbiBjb25zdGFudHNcbiAgICAgICAgdmFyIGEgPSAtMiAvIDMgLyBub2RlRGlzdGFuY2U7XG4gICAgICAgIHZhciBiID0gNCAvIDM7XG5cbiAgICAgICAgLy8gd2UgbG9vcCBmcm9tIGkgb3ZlciBhbGwgYnV0IHRoZSBsYXN0IGVudHJlZSBpbiB0aGUgYXJyYXlcbiAgICAgICAgLy8gaiBsb29wcyBmcm9tIGkrMSB0byB0aGUgbGFzdC4gVGhpcyB3YXkgd2UgZG8gbm90IGRvdWJsZSBjb3VudCBhbnkgb2YgdGhlIGluZGljZXMsIG5vciBpID09PSBqXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZUluZGljZXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgbm9kZTEgPSBub2Rlc1tub2RlSW5kaWNlc1tpXV07XG4gICAgICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgbm9kZUluZGljZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIG5vZGUyID0gbm9kZXNbbm9kZUluZGljZXNbal1dO1xuXG4gICAgICAgICAgICBkeCA9IG5vZGUyLnggLSBub2RlMS54O1xuICAgICAgICAgICAgZHkgPSBub2RlMi55IC0gbm9kZTEueTtcbiAgICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblxuICAgICAgICAgICAgLy8gc2FtZSBjb25kaXRpb24gYXMgQmFybmVzSHV0U29sdmVyLCBtYWtpbmcgc3VyZSBub2RlcyBhcmUgbmV2ZXIgMTAwJSBvdmVybGFwcGluZy5cbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSA9PT0gMCkge1xuICAgICAgICAgICAgICBkaXN0YW5jZSA9IDAuMSAqIE1hdGgucmFuZG9tKCk7XG4gICAgICAgICAgICAgIGR4ID0gZGlzdGFuY2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8IDIgKiBub2RlRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgMC41ICogbm9kZURpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgcmVwdWxzaW5nRm9yY2UgPSAxLjA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVwdWxzaW5nRm9yY2UgPSBhICogZGlzdGFuY2UgKyBiOyAvLyBsaW5lYXIgYXBwcm94IG9mICAxIC8gKDEgKyBNYXRoLmV4cCgoZGlzdGFuY2UgLyBub2RlRGlzdGFuY2UgLSAxKSAqIHN0ZWVwbmVzcykpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVwdWxzaW5nRm9yY2UgPSByZXB1bHNpbmdGb3JjZSAvIGRpc3RhbmNlO1xuXG4gICAgICAgICAgICAgIGZ4ID0gZHggKiByZXB1bHNpbmdGb3JjZTtcbiAgICAgICAgICAgICAgZnkgPSBkeSAqIHJlcHVsc2luZ0ZvcmNlO1xuXG4gICAgICAgICAgICAgIGZvcmNlc1tub2RlMS5pZF0ueCAtPSBmeDtcbiAgICAgICAgICAgICAgZm9yY2VzW25vZGUxLmlkXS55IC09IGZ5O1xuICAgICAgICAgICAgICBmb3JjZXNbbm9kZTIuaWRdLnggKz0gZng7XG4gICAgICAgICAgICAgIGZvcmNlc1tub2RlMi5pZF0ueSArPSBmeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gUmVwdWxzaW9uU29sdmVyO1xuICB9KCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gUmVwdWxzaW9uU29sdmVyO1xuXG4vKioqLyB9LFxuLyogOTYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICB2YXIgSGllcmFyY2hpY2FsUmVwdWxzaW9uU29sdmVyID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEhpZXJhcmNoaWNhbFJlcHVsc2lvblNvbHZlcihib2R5LCBwaHlzaWNzQm9keSwgb3B0aW9ucykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhpZXJhcmNoaWNhbFJlcHVsc2lvblNvbHZlcik7XG5cbiAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICB0aGlzLnBoeXNpY3NCb2R5ID0gcGh5c2ljc0JvZHk7XG4gICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEhpZXJhcmNoaWNhbFJlcHVsc2lvblNvbHZlciwgW3tcbiAgICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsY3VsYXRlIHRoZSBmb3JjZXMgdGhlIG5vZGVzIGFwcGx5IG9uIGVhY2ggb3RoZXIgYmFzZWQgb24gYSByZXB1bHNpb24gZmllbGQuXG4gICAgICAgKiBUaGlzIGZpZWxkIGlzIGxpbmVhcmx5IGFwcHJveGltYXRlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic29sdmVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzb2x2ZSgpIHtcbiAgICAgICAgdmFyIGR4LCBkeSwgZGlzdGFuY2UsIGZ4LCBmeSwgcmVwdWxzaW5nRm9yY2UsIG5vZGUxLCBub2RlMiwgaSwgajtcblxuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICAgIHZhciBub2RlSW5kaWNlcyA9IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzO1xuICAgICAgICB2YXIgZm9yY2VzID0gdGhpcy5waHlzaWNzQm9keS5mb3JjZXM7XG5cbiAgICAgICAgLy8gcmVwdWxzaW5nIGZvcmNlcyBiZXR3ZWVuIG5vZGVzXG4gICAgICAgIHZhciBub2RlRGlzdGFuY2UgPSB0aGlzLm9wdGlvbnMubm9kZURpc3RhbmNlO1xuXG4gICAgICAgIC8vIHdlIGxvb3AgZnJvbSBpIG92ZXIgYWxsIGJ1dCB0aGUgbGFzdCBlbnRyZWUgaW4gdGhlIGFycmF5XG4gICAgICAgIC8vIGogbG9vcHMgZnJvbSBpKzEgdG8gdGhlIGxhc3QuIFRoaXMgd2F5IHdlIGRvIG5vdCBkb3VibGUgY291bnQgYW55IG9mIHRoZSBpbmRpY2VzLCBub3IgaSA9PT0galxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbm9kZUluZGljZXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgbm9kZTEgPSBub2Rlc1tub2RlSW5kaWNlc1tpXV07XG4gICAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCBub2RlSW5kaWNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbm9kZTIgPSBub2Rlc1tub2RlSW5kaWNlc1tqXV07XG5cbiAgICAgICAgICAgIC8vIG5vZGVzIG9ubHkgYWZmZWN0IG5vZGVzIG9uIHRoZWlyIGxldmVsXG4gICAgICAgICAgICBpZiAobm9kZTEubGV2ZWwgPT09IG5vZGUyLmxldmVsKSB7XG4gICAgICAgICAgICAgIGR4ID0gbm9kZTIueCAtIG5vZGUxLng7XG4gICAgICAgICAgICAgIGR5ID0gbm9kZTIueSAtIG5vZGUxLnk7XG4gICAgICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblxuICAgICAgICAgICAgICB2YXIgc3RlZXBuZXNzID0gMC4wNTtcbiAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgbm9kZURpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgcmVwdWxzaW5nRm9yY2UgPSAtTWF0aC5wb3coc3RlZXBuZXNzICogZGlzdGFuY2UsIDIpICsgTWF0aC5wb3coc3RlZXBuZXNzICogbm9kZURpc3RhbmNlLCAyKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXB1bHNpbmdGb3JjZSA9IDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gbm9ybWFsaXplIGZvcmNlIHdpdGhcbiAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgPSAwLjAxO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcHVsc2luZ0ZvcmNlID0gcmVwdWxzaW5nRm9yY2UgLyBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmeCA9IGR4ICogcmVwdWxzaW5nRm9yY2U7XG4gICAgICAgICAgICAgIGZ5ID0gZHkgKiByZXB1bHNpbmdGb3JjZTtcblxuICAgICAgICAgICAgICBmb3JjZXNbbm9kZTEuaWRdLnggLT0gZng7XG4gICAgICAgICAgICAgIGZvcmNlc1tub2RlMS5pZF0ueSAtPSBmeTtcbiAgICAgICAgICAgICAgZm9yY2VzW25vZGUyLmlkXS54ICs9IGZ4O1xuICAgICAgICAgICAgICBmb3JjZXNbbm9kZTIuaWRdLnkgKz0gZnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEhpZXJhcmNoaWNhbFJlcHVsc2lvblNvbHZlcjtcbiAgfSgpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IEhpZXJhcmNoaWNhbFJlcHVsc2lvblNvbHZlcjtcblxuLyoqKi8gfSxcbi8qIDk3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuICBcInVzZSBzdHJpY3RcIjtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgdmFyIFNwcmluZ1NvbHZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTcHJpbmdTb2x2ZXIoYm9keSwgcGh5c2ljc0JvZHksIG9wdGlvbnMpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTcHJpbmdTb2x2ZXIpO1xuXG4gICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgdGhpcy5waHlzaWNzQm9keSA9IHBoeXNpY3NCb2R5O1xuICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhTcHJpbmdTb2x2ZXIsIFt7XG4gICAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyB0aGUgc3ByaW5nZm9yY2VzIG9uIHRoZSBub2RlcywgYWNjb3VudGluZyBmb3IgdGhlIHN1cHBvcnQgbm9kZXMuXG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInNvbHZlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc29sdmUoKSB7XG4gICAgICAgIHZhciBlZGdlTGVuZ3RoID0gdm9pZCAwLFxuICAgICAgICAgICAgZWRnZSA9IHZvaWQgMDtcbiAgICAgICAgdmFyIGVkZ2VJbmRpY2VzID0gdGhpcy5waHlzaWNzQm9keS5waHlzaWNzRWRnZUluZGljZXM7XG4gICAgICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcbiAgICAgICAgdmFyIG5vZGUxID0gdm9pZCAwLFxuICAgICAgICAgICAgbm9kZTIgPSB2b2lkIDAsXG4gICAgICAgICAgICBub2RlMyA9IHZvaWQgMDtcblxuICAgICAgICAvLyBmb3JjZXMgY2F1c2VkIGJ5IHRoZSBlZGdlcywgbW9kZWxsZWQgYXMgc3ByaW5nc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZWRnZSA9IGVkZ2VzW2VkZ2VJbmRpY2VzW2ldXTtcbiAgICAgICAgICBpZiAoZWRnZS5jb25uZWN0ZWQgPT09IHRydWUgJiYgZWRnZS50b0lkICE9PSBlZGdlLmZyb21JZCkge1xuICAgICAgICAgICAgLy8gb25seSBjYWxjdWxhdGUgZm9yY2VzIGlmIG5vZGVzIGFyZSBpbiB0aGUgc2FtZSBzZWN0b3JcbiAgICAgICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbZWRnZS50b0lkXSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuYm9keS5ub2Rlc1tlZGdlLmZyb21JZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBpZiAoZWRnZS5lZGdlVHlwZS52aWEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGVkZ2VMZW5ndGggPSBlZGdlLm9wdGlvbnMubGVuZ3RoID09PSB1bmRlZmluZWQgPyB0aGlzLm9wdGlvbnMuc3ByaW5nTGVuZ3RoIDogZWRnZS5vcHRpb25zLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBub2RlMSA9IGVkZ2UudG87XG4gICAgICAgICAgICAgICAgbm9kZTIgPSBlZGdlLmVkZ2VUeXBlLnZpYTtcbiAgICAgICAgICAgICAgICBub2RlMyA9IGVkZ2UuZnJvbTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGN1bGF0ZVNwcmluZ0ZvcmNlKG5vZGUxLCBub2RlMiwgMC41ICogZWRnZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FsY3VsYXRlU3ByaW5nRm9yY2Uobm9kZTIsIG5vZGUzLCAwLjUgKiBlZGdlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0aGUgKiAxLjUgaXMgaGVyZSBzbyB0aGUgZWRnZSBsb29rcyBhcyBsYXJnZSBhcyBhIHNtb290aCBlZGdlLiBJdCBkb2VzIG5vdCBpbml0aWFsbHkgYmVjYXVzZSB0aGUgc21vb3RoIGVkZ2VzIHVzZVxuICAgICAgICAgICAgICAgIC8vIHRoZSBzdXBwb3J0IG5vZGVzIHdoaWNoIGV4ZXJ0IGEgcmVwdWxzaXZlIGZvcmNlIG9uIHRoZSB0byBhbmQgZnJvbSBub2RlcywgbWFraW5nIHRoZSBlZGdlIGFwcGVhciBsYXJnZXIuXG4gICAgICAgICAgICAgICAgZWRnZUxlbmd0aCA9IGVkZ2Uub3B0aW9ucy5sZW5ndGggPT09IHVuZGVmaW5lZCA/IHRoaXMub3B0aW9ucy5zcHJpbmdMZW5ndGggKiAxLjUgOiBlZGdlLm9wdGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGN1bGF0ZVNwcmluZ0ZvcmNlKGVkZ2UuZnJvbSwgZWRnZS50bywgZWRnZUxlbmd0aCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIGlzIHRoZSBjb2RlIGFjdHVhbGx5IHBlcmZvcm1pbmcgdGhlIGNhbGN1bGF0aW9uIGZvciB0aGUgZnVuY3Rpb24gYWJvdmUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIG5vZGUxXG4gICAgICAgKiBAcGFyYW0gbm9kZTJcbiAgICAgICAqIEBwYXJhbSBlZGdlTGVuZ3RoXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2NhbGN1bGF0ZVNwcmluZ0ZvcmNlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGN1bGF0ZVNwcmluZ0ZvcmNlKG5vZGUxLCBub2RlMiwgZWRnZUxlbmd0aCkge1xuICAgICAgICB2YXIgZHggPSBub2RlMS54IC0gbm9kZTIueDtcbiAgICAgICAgdmFyIGR5ID0gbm9kZTEueSAtIG5vZGUyLnk7XG4gICAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGgubWF4KE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSksIDAuMDEpO1xuXG4gICAgICAgIC8vIHRoZSAxL2Rpc3RhbmNlIGlzIHNvIHRoZSBmeCBhbmQgZnkgY2FuIGJlIGNhbGN1bGF0ZWQgd2l0aG91dCBzaW5lIG9yIGNvc2luZS5cbiAgICAgICAgdmFyIHNwcmluZ0ZvcmNlID0gdGhpcy5vcHRpb25zLnNwcmluZ0NvbnN0YW50ICogKGVkZ2VMZW5ndGggLSBkaXN0YW5jZSkgLyBkaXN0YW5jZTtcblxuICAgICAgICB2YXIgZnggPSBkeCAqIHNwcmluZ0ZvcmNlO1xuICAgICAgICB2YXIgZnkgPSBkeSAqIHNwcmluZ0ZvcmNlO1xuXG4gICAgICAgIC8vIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSBvbmUgbm9kZSBpcyBub3QgcGFydCBvZiB0aGUgcGh5c2Npc1xuICAgICAgICBpZiAodGhpcy5waHlzaWNzQm9keS5mb3JjZXNbbm9kZTEuaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tub2RlMS5pZF0ueCArPSBmeDtcbiAgICAgICAgICB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tub2RlMS5pZF0ueSArPSBmeTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tub2RlMi5pZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGUyLmlkXS54IC09IGZ4O1xuICAgICAgICAgIHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGUyLmlkXS55IC09IGZ5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFNwcmluZ1NvbHZlcjtcbiAgfSgpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IFNwcmluZ1NvbHZlcjtcblxuLyoqKi8gfSxcbi8qIDk4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuICBcInVzZSBzdHJpY3RcIjtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgdmFyIEhpZXJhcmNoaWNhbFNwcmluZ1NvbHZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIaWVyYXJjaGljYWxTcHJpbmdTb2x2ZXIoYm9keSwgcGh5c2ljc0JvZHksIG9wdGlvbnMpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIaWVyYXJjaGljYWxTcHJpbmdTb2x2ZXIpO1xuXG4gICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgdGhpcy5waHlzaWNzQm9keSA9IHBoeXNpY3NCb2R5O1xuICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhIaWVyYXJjaGljYWxTcHJpbmdTb2x2ZXIsIFt7XG4gICAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyB0aGUgc3ByaW5nZm9yY2VzIG9uIHRoZSBub2RlcywgYWNjb3VudGluZyBmb3IgdGhlIHN1cHBvcnQgbm9kZXMuXG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInNvbHZlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc29sdmUoKSB7XG4gICAgICAgIHZhciBlZGdlTGVuZ3RoLCBlZGdlO1xuICAgICAgICB2YXIgZHgsIGR5LCBmeCwgZnksIHNwcmluZ0ZvcmNlLCBkaXN0YW5jZTtcbiAgICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuICAgICAgICB2YXIgZmFjdG9yID0gMC41O1xuXG4gICAgICAgIHZhciBlZGdlSW5kaWNlcyA9IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc0VkZ2VJbmRpY2VzO1xuICAgICAgICB2YXIgbm9kZUluZGljZXMgPSB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcztcbiAgICAgICAgdmFyIGZvcmNlcyA9IHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzO1xuXG4gICAgICAgIC8vIGluaXRpYWxpemUgdGhlIHNwcmluZyBmb3JjZSBjb3VudGVyc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5vZGVJZCA9IG5vZGVJbmRpY2VzW2ldO1xuICAgICAgICAgIGZvcmNlc1tub2RlSWRdLnNwcmluZ0Z4ID0gMDtcbiAgICAgICAgICBmb3JjZXNbbm9kZUlkXS5zcHJpbmdGeSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmb3JjZXMgY2F1c2VkIGJ5IHRoZSBlZGdlcywgbW9kZWxsZWQgYXMgc3ByaW5nc1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZWRnZUluZGljZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgZWRnZSA9IGVkZ2VzW2VkZ2VJbmRpY2VzW19pXV07XG4gICAgICAgICAgaWYgKGVkZ2UuY29ubmVjdGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICBlZGdlTGVuZ3RoID0gZWRnZS5vcHRpb25zLmxlbmd0aCA9PT0gdW5kZWZpbmVkID8gdGhpcy5vcHRpb25zLnNwcmluZ0xlbmd0aCA6IGVkZ2Uub3B0aW9ucy5sZW5ndGg7XG5cbiAgICAgICAgICAgIGR4ID0gZWRnZS5mcm9tLnggLSBlZGdlLnRvLng7XG4gICAgICAgICAgICBkeSA9IGVkZ2UuZnJvbS55IC0gZWRnZS50by55O1xuICAgICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICAgICAgZGlzdGFuY2UgPSBkaXN0YW5jZSA9PT0gMCA/IDAuMDEgOiBkaXN0YW5jZTtcblxuICAgICAgICAgICAgLy8gdGhlIDEvZGlzdGFuY2UgaXMgc28gdGhlIGZ4IGFuZCBmeSBjYW4gYmUgY2FsY3VsYXRlZCB3aXRob3V0IHNpbmUgb3IgY29zaW5lLlxuICAgICAgICAgICAgc3ByaW5nRm9yY2UgPSB0aGlzLm9wdGlvbnMuc3ByaW5nQ29uc3RhbnQgKiAoZWRnZUxlbmd0aCAtIGRpc3RhbmNlKSAvIGRpc3RhbmNlO1xuXG4gICAgICAgICAgICBmeCA9IGR4ICogc3ByaW5nRm9yY2U7XG4gICAgICAgICAgICBmeSA9IGR5ICogc3ByaW5nRm9yY2U7XG5cbiAgICAgICAgICAgIGlmIChlZGdlLnRvLmxldmVsICE9IGVkZ2UuZnJvbS5sZXZlbCkge1xuICAgICAgICAgICAgICBpZiAoZm9yY2VzW2VkZ2UudG9JZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZvcmNlc1tlZGdlLnRvSWRdLnNwcmluZ0Z4IC09IGZ4O1xuICAgICAgICAgICAgICAgIGZvcmNlc1tlZGdlLnRvSWRdLnNwcmluZ0Z5IC09IGZ5O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChmb3JjZXNbZWRnZS5mcm9tSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmb3JjZXNbZWRnZS5mcm9tSWRdLnNwcmluZ0Z4ICs9IGZ4O1xuICAgICAgICAgICAgICAgIGZvcmNlc1tlZGdlLmZyb21JZF0uc3ByaW5nRnkgKz0gZnk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChmb3JjZXNbZWRnZS50b0lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZm9yY2VzW2VkZ2UudG9JZF0ueCAtPSBmYWN0b3IgKiBmeDtcbiAgICAgICAgICAgICAgICBmb3JjZXNbZWRnZS50b0lkXS55IC09IGZhY3RvciAqIGZ5O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChmb3JjZXNbZWRnZS5mcm9tSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmb3JjZXNbZWRnZS5mcm9tSWRdLnggKz0gZmFjdG9yICogZng7XG4gICAgICAgICAgICAgICAgZm9yY2VzW2VkZ2UuZnJvbUlkXS55ICs9IGZhY3RvciAqIGZ5O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm9ybWFsaXplIHNwcmluZyBmb3JjZXNcbiAgICAgICAgdmFyIHNwcmluZ0ZvcmNlID0gMTtcbiAgICAgICAgdmFyIHNwcmluZ0Z4LCBzcHJpbmdGeTtcbiAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbm9kZUluZGljZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgIHZhciBfbm9kZUlkID0gbm9kZUluZGljZXNbX2kyXTtcbiAgICAgICAgICBzcHJpbmdGeCA9IE1hdGgubWluKHNwcmluZ0ZvcmNlLCBNYXRoLm1heCgtc3ByaW5nRm9yY2UsIGZvcmNlc1tfbm9kZUlkXS5zcHJpbmdGeCkpO1xuICAgICAgICAgIHNwcmluZ0Z5ID0gTWF0aC5taW4oc3ByaW5nRm9yY2UsIE1hdGgubWF4KC1zcHJpbmdGb3JjZSwgZm9yY2VzW19ub2RlSWRdLnNwcmluZ0Z5KSk7XG5cbiAgICAgICAgICBmb3JjZXNbX25vZGVJZF0ueCArPSBzcHJpbmdGeDtcbiAgICAgICAgICBmb3JjZXNbX25vZGVJZF0ueSArPSBzcHJpbmdGeTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJldGFpbiBlbmVyZ3kgYmFsYW5jZVxuICAgICAgICB2YXIgdG90YWxGeCA9IDA7XG4gICAgICAgIHZhciB0b3RhbEZ5ID0gMDtcbiAgICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbm9kZUluZGljZXMubGVuZ3RoOyBfaTMrKykge1xuICAgICAgICAgIHZhciBfbm9kZUlkMiA9IG5vZGVJbmRpY2VzW19pM107XG4gICAgICAgICAgdG90YWxGeCArPSBmb3JjZXNbX25vZGVJZDJdLng7XG4gICAgICAgICAgdG90YWxGeSArPSBmb3JjZXNbX25vZGVJZDJdLnk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvcnJlY3Rpb25GeCA9IHRvdGFsRnggLyBub2RlSW5kaWNlcy5sZW5ndGg7XG4gICAgICAgIHZhciBjb3JyZWN0aW9uRnkgPSB0b3RhbEZ5IC8gbm9kZUluZGljZXMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IG5vZGVJbmRpY2VzLmxlbmd0aDsgX2k0KyspIHtcbiAgICAgICAgICB2YXIgX25vZGVJZDMgPSBub2RlSW5kaWNlc1tfaTRdO1xuICAgICAgICAgIGZvcmNlc1tfbm9kZUlkM10ueCAtPSBjb3JyZWN0aW9uRng7XG4gICAgICAgICAgZm9yY2VzW19ub2RlSWQzXS55IC09IGNvcnJlY3Rpb25GeTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBIaWVyYXJjaGljYWxTcHJpbmdTb2x2ZXI7XG4gIH0oKTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBIaWVyYXJjaGljYWxTcHJpbmdTb2x2ZXI7XG5cbi8qKiovIH0sXG4vKiA5OSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIHZhciBDZW50cmFsR3Jhdml0eVNvbHZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDZW50cmFsR3Jhdml0eVNvbHZlcihib2R5LCBwaHlzaWNzQm9keSwgb3B0aW9ucykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENlbnRyYWxHcmF2aXR5U29sdmVyKTtcblxuICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgIHRoaXMucGh5c2ljc0JvZHkgPSBwaHlzaWNzQm9keTtcbiAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQ2VudHJhbEdyYXZpdHlTb2x2ZXIsIFt7XG4gICAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzb2x2ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNvbHZlKCkge1xuICAgICAgICB2YXIgZHggPSB2b2lkIDAsXG4gICAgICAgICAgICBkeSA9IHZvaWQgMCxcbiAgICAgICAgICAgIGRpc3RhbmNlID0gdm9pZCAwLFxuICAgICAgICAgICAgbm9kZSA9IHZvaWQgMDtcbiAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgICB2YXIgbm9kZUluZGljZXMgPSB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcztcbiAgICAgICAgdmFyIGZvcmNlcyA9IHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbm9kZUlkID0gbm9kZUluZGljZXNbaV07XG4gICAgICAgICAgbm9kZSA9IG5vZGVzW25vZGVJZF07XG4gICAgICAgICAgZHggPSAtbm9kZS54O1xuICAgICAgICAgIGR5ID0gLW5vZGUueTtcbiAgICAgICAgICBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVGb3JjZXMoZGlzdGFuY2UsIGR4LCBkeSwgZm9yY2VzLCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGN1bGF0ZSB0aGUgZm9yY2VzIGJhc2VkIG9uIHRoZSBkaXN0YW5jZS5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfY2FsY3VsYXRlRm9yY2VzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGN1bGF0ZUZvcmNlcyhkaXN0YW5jZSwgZHgsIGR5LCBmb3JjZXMsIG5vZGUpIHtcbiAgICAgICAgdmFyIGdyYXZpdHlGb3JjZSA9IGRpc3RhbmNlID09PSAwID8gMCA6IHRoaXMub3B0aW9ucy5jZW50cmFsR3Jhdml0eSAvIGRpc3RhbmNlO1xuICAgICAgICBmb3JjZXNbbm9kZS5pZF0ueCA9IGR4ICogZ3Jhdml0eUZvcmNlO1xuICAgICAgICBmb3JjZXNbbm9kZS5pZF0ueSA9IGR5ICogZ3Jhdml0eUZvcmNlO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBDZW50cmFsR3Jhdml0eVNvbHZlcjtcbiAgfSgpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IENlbnRyYWxHcmF2aXR5U29sdmVyO1xuXG4vKioqLyB9LFxuLyogMTAwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICBcInVzZSBzdHJpY3RcIjtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIHZhciBfQmFybmVzSHV0U29sdmVyMiA9IF9fd2VicGFja19yZXF1aXJlX18oOTQpO1xuXG4gIHZhciBfQmFybmVzSHV0U29sdmVyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Jhcm5lc0h1dFNvbHZlcjIpO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuICBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuICB2YXIgRm9yY2VBdGxhczJCYXNlZFJlcHVsc2lvblNvbHZlciA9IGZ1bmN0aW9uIChfQmFybmVzSHV0U29sdmVyKSB7XG4gICAgX2luaGVyaXRzKEZvcmNlQXRsYXMyQmFzZWRSZXB1bHNpb25Tb2x2ZXIsIF9CYXJuZXNIdXRTb2x2ZXIpO1xuXG4gICAgZnVuY3Rpb24gRm9yY2VBdGxhczJCYXNlZFJlcHVsc2lvblNvbHZlcihib2R5LCBwaHlzaWNzQm9keSwgb3B0aW9ucykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZvcmNlQXRsYXMyQmFzZWRSZXB1bHNpb25Tb2x2ZXIpO1xuXG4gICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKEZvcmNlQXRsYXMyQmFzZWRSZXB1bHNpb25Tb2x2ZXIpLmNhbGwodGhpcywgYm9keSwgcGh5c2ljc0JvZHksIG9wdGlvbnMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGZvcmNlcyBiYXNlZCBvbiB0aGUgZGlzdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGlzdGFuY2VcbiAgICAgKiBAcGFyYW0gZHhcbiAgICAgKiBAcGFyYW0gZHlcbiAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAqIEBwYXJhbSBwYXJlbnRCcmFuY2hcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoRm9yY2VBdGxhczJCYXNlZFJlcHVsc2lvblNvbHZlciwgW3tcbiAgICAgIGtleTogXCJfY2FsY3VsYXRlRm9yY2VzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGN1bGF0ZUZvcmNlcyhkaXN0YW5jZSwgZHgsIGR5LCBub2RlLCBwYXJlbnRCcmFuY2gpIHtcbiAgICAgICAgaWYgKGRpc3RhbmNlID09PSAwKSB7XG4gICAgICAgICAgZGlzdGFuY2UgPSAwLjEgKiBNYXRoLnJhbmRvbSgpO1xuICAgICAgICAgIGR4ID0gZGlzdGFuY2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vdmVybGFwQXZvaWRhbmNlRmFjdG9yIDwgMSkge1xuICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5tYXgoMC4xICsgdGhpcy5vdmVybGFwQXZvaWRhbmNlRmFjdG9yICogbm9kZS5zaGFwZS5yYWRpdXMsIGRpc3RhbmNlIC0gbm9kZS5zaGFwZS5yYWRpdXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlZ3JlZSA9IG5vZGUuZWRnZXMubGVuZ3RoICsgMTtcbiAgICAgICAgLy8gdGhlIGRpdmlkaW5nIGJ5IHRoZSBkaXN0YW5jZSBjdWJlZCBpbnN0ZWFkIG9mIHNxdWFyZWQgYWxsb3dzIHVzIHRvIGdldCB0aGUgZnggYW5kIGZ5IGNvbXBvbmVudHMgd2l0aG91dCBzaW5lcyBhbmQgY29zaW5lc1xuICAgICAgICAvLyBpdCBpcyBzaG9ydGhhbmQgZm9yIGdyYXZpdHlmb3JjZSB3aXRoIGRpc3RhbmNlIHNxdWFyZWQgYW5kIGZ4ID0gZHgvZGlzdGFuY2UgKiBncmF2aXR5Rm9yY2VcbiAgICAgICAgdmFyIGdyYXZpdHlGb3JjZSA9IHRoaXMub3B0aW9ucy5ncmF2aXRhdGlvbmFsQ29uc3RhbnQgKiBwYXJlbnRCcmFuY2gubWFzcyAqIG5vZGUub3B0aW9ucy5tYXNzICogZGVncmVlIC8gTWF0aC5wb3coZGlzdGFuY2UsIDIpO1xuICAgICAgICB2YXIgZnggPSBkeCAqIGdyYXZpdHlGb3JjZTtcbiAgICAgICAgdmFyIGZ5ID0gZHkgKiBncmF2aXR5Rm9yY2U7XG5cbiAgICAgICAgdGhpcy5waHlzaWNzQm9keS5mb3JjZXNbbm9kZS5pZF0ueCArPSBmeDtcbiAgICAgICAgdGhpcy5waHlzaWNzQm9keS5mb3JjZXNbbm9kZS5pZF0ueSArPSBmeTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gRm9yY2VBdGxhczJCYXNlZFJlcHVsc2lvblNvbHZlcjtcbiAgfShfQmFybmVzSHV0U29sdmVyMy5kZWZhdWx0KTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBGb3JjZUF0bGFzMkJhc2VkUmVwdWxzaW9uU29sdmVyO1xuXG4vKioqLyB9LFxuLyogMTAxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICBcInVzZSBzdHJpY3RcIjtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIHZhciBfQ2VudHJhbEdyYXZpdHlTb2x2ZXIyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OSk7XG5cbiAgdmFyIF9DZW50cmFsR3Jhdml0eVNvbHZlcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DZW50cmFsR3Jhdml0eVNvbHZlcjIpO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuICBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuICB2YXIgRm9yY2VBdGxhczJCYXNlZENlbnRyYWxHcmF2aXR5U29sdmVyID0gZnVuY3Rpb24gKF9DZW50cmFsR3Jhdml0eVNvbHZlcikge1xuICAgIF9pbmhlcml0cyhGb3JjZUF0bGFzMkJhc2VkQ2VudHJhbEdyYXZpdHlTb2x2ZXIsIF9DZW50cmFsR3Jhdml0eVNvbHZlcik7XG5cbiAgICBmdW5jdGlvbiBGb3JjZUF0bGFzMkJhc2VkQ2VudHJhbEdyYXZpdHlTb2x2ZXIoYm9keSwgcGh5c2ljc0JvZHksIG9wdGlvbnMpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGb3JjZUF0bGFzMkJhc2VkQ2VudHJhbEdyYXZpdHlTb2x2ZXIpO1xuXG4gICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKEZvcmNlQXRsYXMyQmFzZWRDZW50cmFsR3Jhdml0eVNvbHZlcikuY2FsbCh0aGlzLCBib2R5LCBwaHlzaWNzQm9keSwgb3B0aW9ucykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgZm9yY2VzIGJhc2VkIG9uIHRoZSBkaXN0YW5jZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoRm9yY2VBdGxhczJCYXNlZENlbnRyYWxHcmF2aXR5U29sdmVyLCBbe1xuICAgICAga2V5OiBcIl9jYWxjdWxhdGVGb3JjZXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FsY3VsYXRlRm9yY2VzKGRpc3RhbmNlLCBkeCwgZHksIGZvcmNlcywgbm9kZSkge1xuICAgICAgICBpZiAoZGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgdmFyIGRlZ3JlZSA9IG5vZGUuZWRnZXMubGVuZ3RoICsgMTtcbiAgICAgICAgICB2YXIgZ3Jhdml0eUZvcmNlID0gdGhpcy5vcHRpb25zLmNlbnRyYWxHcmF2aXR5ICogZGVncmVlICogbm9kZS5vcHRpb25zLm1hc3M7XG4gICAgICAgICAgZm9yY2VzW25vZGUuaWRdLnggPSBkeCAqIGdyYXZpdHlGb3JjZTtcbiAgICAgICAgICBmb3JjZXNbbm9kZS5pZF0ueSA9IGR5ICogZ3Jhdml0eUZvcmNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEZvcmNlQXRsYXMyQmFzZWRDZW50cmFsR3Jhdml0eVNvbHZlcjtcbiAgfShfQ2VudHJhbEdyYXZpdHlTb2x2ZXIzLmRlZmF1bHQpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IEZvcmNlQXRsYXMyQmFzZWRDZW50cmFsR3Jhdml0eVNvbHZlcjtcblxuLyoqKi8gfSxcbi8qIDEwMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgdmFyIF9OZXR3b3JrVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTAzKTtcblxuICB2YXIgX05ldHdvcmtVdGlsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX05ldHdvcmtVdGlsKTtcblxuICB2YXIgX0NsdXN0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNCk7XG5cbiAgdmFyIF9DbHVzdGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NsdXN0ZXIpO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbiAgdmFyIENsdXN0ZXJFbmdpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2x1c3RlckVuZ2luZShib2R5KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2x1c3RlckVuZ2luZSk7XG5cbiAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICB0aGlzLmNsdXN0ZXJlZE5vZGVzID0ge307XG4gICAgICB0aGlzLmNsdXN0ZXJlZEVkZ2VzID0ge307XG5cbiAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHt9O1xuICAgICAgdXRpbC5leHRlbmQodGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ19yZXNldERhdGEnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmNsdXN0ZXJlZE5vZGVzID0ge307X3RoaXMuY2x1c3RlcmVkRWRnZXMgPSB7fTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhDbHVzdGVyRW5naW5lLCBbe1xuICAgICAga2V5OiAnc2V0T3B0aW9ucycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHt9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgKlxuICAgICAgKiBAcGFyYW0gaHVic2l6ZVxuICAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2NsdXN0ZXJCeUh1YnNpemUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsdXN0ZXJCeUh1YnNpemUoaHVic2l6ZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoaHVic2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaHVic2l6ZSA9IHRoaXMuX2dldEh1YlNpemUoKTtcbiAgICAgICAgfSBlbHNlIGlmICgodHlwZW9mIGh1YnNpemUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGh1YnNpemUpKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLl9jaGVja09wdGlvbnMoaHVic2l6ZSk7XG4gICAgICAgICAgaHVic2l6ZSA9IHRoaXMuX2dldEh1YlNpemUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBub2Rlc1RvQ2x1c3RlciA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMuYm9keS5ub2RlSW5kaWNlc1tpXV07XG4gICAgICAgICAgaWYgKG5vZGUuZWRnZXMubGVuZ3RoID49IGh1YnNpemUpIHtcbiAgICAgICAgICAgIG5vZGVzVG9DbHVzdGVyLnB1c2gobm9kZS5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5vZGVzVG9DbHVzdGVyLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIHRoaXMuY2x1c3RlckJ5Q29ubmVjdGlvbihub2Rlc1RvQ2x1c3RlcltfaV0sIG9wdGlvbnMsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2RhdGFDaGFuZ2VkJyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgKiBsb29wIG92ZXIgYWxsIG5vZGVzLCBjaGVjayBpZiB0aGV5IGFkaGVyZSB0byB0aGUgY29uZGl0aW9uIGFuZCBjbHVzdGVyIGlmIG5lZWRlZC5cbiAgICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgICogQHBhcmFtIHJlZnJlc2hEYXRhXG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnY2x1c3RlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2x1c3RlcigpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgdmFyIHJlZnJlc2hEYXRhID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICBpZiAob3B0aW9ucy5qb2luQ29uZGl0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBjbHVzdGVyQnlOb2RlRGF0YSB3aXRob3V0IGEgam9pbkNvbmRpdGlvbiBmdW5jdGlvbiBpbiB0aGUgb3B0aW9ucy5cIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBpZiB0aGUgb3B0aW9ucyBvYmplY3QgaXMgZmluZSwgYXBwZW5kIGlmIG5lZWRlZFxuICAgICAgICBvcHRpb25zID0gdGhpcy5fY2hlY2tPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgICAgIHZhciBjaGlsZE5vZGVzT2JqID0ge307XG4gICAgICAgIHZhciBjaGlsZEVkZ2VzT2JqID0ge307XG5cbiAgICAgICAgLy8gY29sbGVjdCB0aGUgbm9kZXMgdGhhdCB3aWxsIGJlIGluIHRoZSBjbHVzdGVyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5vZGVJZCA9IHRoaXMuYm9keS5ub2RlSW5kaWNlc1tpXTtcbiAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgICAgIHZhciBjbG9uZWRPcHRpb25zID0gX05ldHdvcmtVdGlsMi5kZWZhdWx0LmNsb25lT3B0aW9ucyhub2RlKTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5qb2luQ29uZGl0aW9uKGNsb25lZE9wdGlvbnMpID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjaGlsZE5vZGVzT2JqW25vZGVJZF0gPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcblxuICAgICAgICAgICAgLy8gY29sbGVjdCB0aGUgbm9kZXMgdGhhdCB3aWxsIGJlIGluIHRoZSBjbHVzdGVyXG4gICAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBub2RlLmVkZ2VzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICAgICAgdmFyIGVkZ2UgPSBub2RlLmVkZ2VzW19pMl07XG4gICAgICAgICAgICAgIGlmICh0aGlzLmNsdXN0ZXJlZEVkZ2VzW2VkZ2UuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZEVkZ2VzT2JqW2VkZ2UuaWRdID0gZWRnZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NsdXN0ZXIoY2hpbGROb2Rlc09iaiwgY2hpbGRFZGdlc09iaiwgb3B0aW9ucywgcmVmcmVzaERhdGEpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENsdXN0ZXIgYWxsIG5vZGVzIGluIHRoZSBuZXR3b3JrIHRoYXQgaGF2ZSBvbmx5IFggZWRnZXNcbiAgICAgICAqIEBwYXJhbSBlZGdlQ291bnRcbiAgICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICAgKiBAcGFyYW0gcmVmcmVzaERhdGFcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnY2x1c3RlckJ5RWRnZUNvdW50JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbHVzdGVyQnlFZGdlQ291bnQoZWRnZUNvdW50LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciByZWZyZXNoRGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhcmd1bWVudHNbMl07XG5cbiAgICAgICAgb3B0aW9ucyA9IHRoaXMuX2NoZWNrT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdmFyIGNsdXN0ZXJzID0gW107XG4gICAgICAgIHZhciB1c2VkTm9kZXMgPSB7fTtcbiAgICAgICAgdmFyIGVkZ2UgPSB2b2lkIDAsXG4gICAgICAgICAgICBlZGdlcyA9IHZvaWQgMCxcbiAgICAgICAgICAgIG5vZGUgPSB2b2lkIDAsXG4gICAgICAgICAgICBub2RlSWQgPSB2b2lkIDAsXG4gICAgICAgICAgICByZWxldmFudEVkZ2VDb3VudCA9IHZvaWQgMDtcbiAgICAgICAgLy8gY29sbGVjdCB0aGUgbm9kZXMgdGhhdCB3aWxsIGJlIGluIHRoZSBjbHVzdGVyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGNoaWxkTm9kZXNPYmogPSB7fTtcbiAgICAgICAgICB2YXIgY2hpbGRFZGdlc09iaiA9IHt9O1xuICAgICAgICAgIG5vZGVJZCA9IHRoaXMuYm9keS5ub2RlSW5kaWNlc1tpXTtcblxuICAgICAgICAgIC8vIGlmIHRoaXMgbm9kZSBpcyBhbHJlYWR5IHVzZWQgaW4gYW5vdGhlciBjbHVzdGVyIHRoaXMgc2Vzc2lvbiwgd2UgZG8gbm90IGhhdmUgdG8gcmUtZXZhbHVhdGUgaXQuXG4gICAgICAgICAgaWYgKHVzZWROb2Rlc1tub2RlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlbGV2YW50RWRnZUNvdW50ID0gMDtcbiAgICAgICAgICAgIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICAgIGVkZ2VzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vZGUuZWRnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgZWRnZSA9IG5vZGUuZWRnZXNbal07XG4gICAgICAgICAgICAgIGlmICh0aGlzLmNsdXN0ZXJlZEVkZ2VzW2VkZ2UuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWRnZS50b0lkICE9PSBlZGdlLmZyb21JZCkge1xuICAgICAgICAgICAgICAgICAgcmVsZXZhbnRFZGdlQ291bnQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWRnZXMucHVzaChlZGdlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0aGlzIG5vZGUgcXVhbGlmaWVzLCB3ZSBjb2xsZWN0IGl0cyBuZWlnaGJvdXJzIHRvIHN0YXJ0IHRoZSBjbHVzdGVyaW5nIHByb2Nlc3MuXG4gICAgICAgICAgICBpZiAocmVsZXZhbnRFZGdlQ291bnQgPT09IGVkZ2VDb3VudCkge1xuICAgICAgICAgICAgICB2YXIgZ2F0aGVyaW5nU3VjY2Vzc2Z1bCA9IHRydWU7XG4gICAgICAgICAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBlZGdlcy5sZW5ndGg7IF9qKyspIHtcbiAgICAgICAgICAgICAgICBlZGdlID0gZWRnZXNbX2pdO1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZE5vZGVJZCA9IHRoaXMuX2dldENvbm5lY3RlZElkKGVkZ2UsIG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgLy8gYWRkIHRoZSBub2RlcyB0byB0aGUgbGlzdCBieSB0aGUgam9pbiBjb25kaXRpb24uXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuam9pbkNvbmRpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICBjaGlsZEVkZ2VzT2JqW2VkZ2UuaWRdID0gZWRnZTtcbiAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXNPYmpbbm9kZUlkXSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgICAgICAgICAgICAgY2hpbGROb2Rlc09ialtjaGlsZE5vZGVJZF0gPSB0aGlzLmJvZHkubm9kZXNbY2hpbGROb2RlSWRdO1xuICAgICAgICAgICAgICAgICAgdXNlZE5vZGVzW25vZGVJZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY2xvbmVkT3B0aW9ucyA9IF9OZXR3b3JrVXRpbDIuZGVmYXVsdC5jbG9uZU9wdGlvbnModGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0pO1xuICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuam9pbkNvbmRpdGlvbihjbG9uZWRPcHRpb25zKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZEVkZ2VzT2JqW2VkZ2UuaWRdID0gZWRnZTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGROb2Rlc09ialtub2RlSWRdID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICAgICAgICAgICAgICAgIHVzZWROb2Rlc1tub2RlSWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgbm9kZSBkb2VzIG5vdCBxdWFsaWZ5IGFmdGVyIGFsbC5cbiAgICAgICAgICAgICAgICAgICAgZ2F0aGVyaW5nU3VjY2Vzc2Z1bCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBhZGQgdG8gdGhlIGNsdXN0ZXIgcXVldWVcbiAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGNoaWxkTm9kZXNPYmopLmxlbmd0aCA+IDAgJiYgT2JqZWN0LmtleXMoY2hpbGRFZGdlc09iaikubGVuZ3RoID4gMCAmJiBnYXRoZXJpbmdTdWNjZXNzZnVsID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgY2x1c3RlcnMucHVzaCh7IG5vZGVzOiBjaGlsZE5vZGVzT2JqLCBlZGdlczogY2hpbGRFZGdlc09iaiB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGNsdXN0ZXJzLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgICAgICB0aGlzLl9jbHVzdGVyKGNsdXN0ZXJzW19pM10ubm9kZXMsIGNsdXN0ZXJzW19pM10uZWRnZXMsIG9wdGlvbnMsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWZyZXNoRGF0YSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19kYXRhQ2hhbmdlZCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgKiBDbHVzdGVyIGFsbCBub2RlcyBpbiB0aGUgbmV0d29yayB0aGF0IGhhdmUgb25seSAxIGVkZ2VcbiAgICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgICogQHBhcmFtIHJlZnJlc2hEYXRhXG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnY2x1c3Rlck91dGxpZXJzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbHVzdGVyT3V0bGllcnMob3B0aW9ucykge1xuICAgICAgICB2YXIgcmVmcmVzaERhdGEgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB0cnVlIDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgIHRoaXMuY2x1c3RlckJ5RWRnZUNvdW50KDEsIG9wdGlvbnMsIHJlZnJlc2hEYXRhKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDbHVzdGVyIGFsbCBub2RlcyBpbiB0aGUgbmV0d29yayB0aGF0IGhhdmUgb25seSAyIGVkZ2VcbiAgICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICAgKiBAcGFyYW0gcmVmcmVzaERhdGFcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnY2x1c3RlckJyaWRnZXMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsdXN0ZXJCcmlkZ2VzKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlZnJlc2hEYXRhID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICB0aGlzLmNsdXN0ZXJCeUVkZ2VDb3VudCgyLCBvcHRpb25zLCByZWZyZXNoRGF0YSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgKiBzdWNrIGFsbCBjb25uZWN0ZWQgbm9kZXMgb2YgYSBub2RlIGludG8gdGhlIG5vZGUuXG4gICAgICAqIEBwYXJhbSBub2RlSWRcbiAgICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgICogQHBhcmFtIHJlZnJlc2hEYXRhXG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnY2x1c3RlckJ5Q29ubmVjdGlvbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2x1c3RlckJ5Q29ubmVjdGlvbihub2RlSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlZnJlc2hEYXRhID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFyZ3VtZW50c1syXTtcblxuICAgICAgICAvLyBraWxsIGNvbmRpdGlvbnNcbiAgICAgICAgaWYgKG5vZGVJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gbm9kZUlkIHN1cHBsaWVkIHRvIGNsdXN0ZXJCeUNvbm5lY3Rpb24hXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbbm9kZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIG5vZGVJZCBnaXZlbiB0byBjbHVzdGVyQnlDb25uZWN0aW9uIGRvZXMgbm90IGV4aXN0IVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLl9jaGVja09wdGlvbnMob3B0aW9ucywgbm9kZSk7XG4gICAgICAgIGlmIChvcHRpb25zLmNsdXN0ZXJOb2RlUHJvcGVydGllcy54ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBvcHRpb25zLmNsdXN0ZXJOb2RlUHJvcGVydGllcy54ID0gbm9kZS54O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmNsdXN0ZXJOb2RlUHJvcGVydGllcy55ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBvcHRpb25zLmNsdXN0ZXJOb2RlUHJvcGVydGllcy55ID0gbm9kZS55O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmNsdXN0ZXJOb2RlUHJvcGVydGllcy5maXhlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb3B0aW9ucy5jbHVzdGVyTm9kZVByb3BlcnRpZXMuZml4ZWQgPSB7fTtcbiAgICAgICAgICBvcHRpb25zLmNsdXN0ZXJOb2RlUHJvcGVydGllcy5maXhlZC54ID0gbm9kZS5vcHRpb25zLmZpeGVkLng7XG4gICAgICAgICAgb3B0aW9ucy5jbHVzdGVyTm9kZVByb3BlcnRpZXMuZml4ZWQueSA9IG5vZGUub3B0aW9ucy5maXhlZC55O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoaWxkTm9kZXNPYmogPSB7fTtcbiAgICAgICAgdmFyIGNoaWxkRWRnZXNPYmogPSB7fTtcbiAgICAgICAgdmFyIHBhcmVudE5vZGVJZCA9IG5vZGUuaWQ7XG4gICAgICAgIHZhciBwYXJlbnRDbG9uZWRPcHRpb25zID0gX05ldHdvcmtVdGlsMi5kZWZhdWx0LmNsb25lT3B0aW9ucyhub2RlKTtcbiAgICAgICAgY2hpbGROb2Rlc09ialtwYXJlbnROb2RlSWRdID0gbm9kZTtcblxuICAgICAgICAvLyBjb2xsZWN0IHRoZSBub2RlcyB0aGF0IHdpbGwgYmUgaW4gdGhlIGNsdXN0ZXJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVkZ2UgPSBub2RlLmVkZ2VzW2ldO1xuICAgICAgICAgIGlmICh0aGlzLmNsdXN0ZXJlZEVkZ2VzW2VkZ2UuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZE5vZGVJZCA9IHRoaXMuX2dldENvbm5lY3RlZElkKGVkZ2UsIHBhcmVudE5vZGVJZCk7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSBjaGlsZCBub2RlIGlzIG5vdCBpbiBhIGNsdXN0ZXJcbiAgICAgICAgICAgIGlmICh0aGlzLmNsdXN0ZXJlZE5vZGVzW2NoaWxkTm9kZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGlmIChjaGlsZE5vZGVJZCAhPT0gcGFyZW50Tm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuam9pbkNvbmRpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICBjaGlsZEVkZ2VzT2JqW2VkZ2UuaWRdID0gZWRnZTtcbiAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXNPYmpbY2hpbGROb2RlSWRdID0gdGhpcy5ib2R5Lm5vZGVzW2NoaWxkTm9kZUlkXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gY2xvbmUgdGhlIG9wdGlvbnMgYW5kIGluc2VydCBzb21lIGFkZGl0aW9uYWwgcGFyYW1ldGVycyB0aGF0IGNvdWxkIGJlIGludGVyZXN0aW5nLlxuICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkQ2xvbmVkT3B0aW9ucyA9IF9OZXR3b3JrVXRpbDIuZGVmYXVsdC5jbG9uZU9wdGlvbnModGhpcy5ib2R5Lm5vZGVzW2NoaWxkTm9kZUlkXSk7XG4gICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5qb2luQ29uZGl0aW9uKHBhcmVudENsb25lZE9wdGlvbnMsIGNoaWxkQ2xvbmVkT3B0aW9ucykgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRFZGdlc09ialtlZGdlLmlkXSA9IGVkZ2U7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXNPYmpbY2hpbGROb2RlSWRdID0gdGhpcy5ib2R5Lm5vZGVzW2NoaWxkTm9kZUlkXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gc3dhbGxvdyB0aGUgZWRnZSBpZiBpdCBpcyBzZWxmLXJlZmVyZW5jaW5nLlxuICAgICAgICAgICAgICAgIGNoaWxkRWRnZXNPYmpbZWRnZS5pZF0gPSBlZGdlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2x1c3RlcihjaGlsZE5vZGVzT2JqLCBjaGlsZEVkZ2VzT2JqLCBvcHRpb25zLCByZWZyZXNoRGF0YSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgKiBUaGlzIGZ1bmN0aW9uIGNyZWF0ZXMgdGhlIGVkZ2VzIHRoYXQgd2lsbCBiZSBhdHRhY2hlZCB0byB0aGUgY2x1c3RlclxuICAgICAgKiBJdCBsb29rcyBmb3IgZWRnZXMgdGhhdCBhcmUgY29ubmVjdGVkIHRvIHRoZSBub2RlcyBmcm9tIHRoZSBcIm91dHNpZGUnIG9mIHRoZSBjbHVzdGVyLlxuICAgICAgKlxuICAgICAgKiBAcGFyYW0gY2hpbGROb2Rlc09ialxuICAgICAgKiBAcGFyYW0gY2hpbGRFZGdlc09ialxuICAgICAgKiBAcGFyYW0gY2x1c3Rlck5vZGVQcm9wZXJ0aWVzXG4gICAgICAqIEBwYXJhbSBjbHVzdGVyRWRnZVByb3BlcnRpZXNcbiAgICAgICogQHByaXZhdGVcbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY3JlYXRlQ2x1c3RlckVkZ2VzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlQ2x1c3RlckVkZ2VzKGNoaWxkTm9kZXNPYmosIGNoaWxkRWRnZXNPYmosIGNsdXN0ZXJOb2RlUHJvcGVydGllcywgY2x1c3RlckVkZ2VQcm9wZXJ0aWVzKSB7XG4gICAgICAgIHZhciBlZGdlID0gdm9pZCAwLFxuICAgICAgICAgICAgY2hpbGROb2RlSWQgPSB2b2lkIDAsXG4gICAgICAgICAgICBjaGlsZE5vZGUgPSB2b2lkIDAsXG4gICAgICAgICAgICB0b0lkID0gdm9pZCAwLFxuICAgICAgICAgICAgZnJvbUlkID0gdm9pZCAwLFxuICAgICAgICAgICAgb3RoZXJOb2RlSWQgPSB2b2lkIDA7XG5cbiAgICAgICAgLy8gbG9vcCBvdmVyIGFsbCBjaGlsZCBub2RlcyBhbmQgdGhlaXIgZWRnZXMgdG8gZmluZCBlZGdlcyBnb2luZyBvdXQgb2YgdGhlIGNsdXN0ZXJcbiAgICAgICAgLy8gdGhlc2UgZWRnZXMgd2lsbCBiZSByZXBsYWNlZCBieSBjbHVzdGVyRWRnZXMuXG4gICAgICAgIHZhciBjaGlsZEtleXMgPSBPYmplY3Qua2V5cyhjaGlsZE5vZGVzT2JqKTtcbiAgICAgICAgdmFyIGNyZWF0ZUVkZ2VzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY2hpbGROb2RlSWQgPSBjaGlsZEtleXNbaV07XG4gICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2Rlc09ialtjaGlsZE5vZGVJZF07XG5cbiAgICAgICAgICAvLyBjb25zdHJ1Y3QgbmV3IGVkZ2VzIGZyb20gdGhlIGNsdXN0ZXIgdG8gb3RoZXJzXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjaGlsZE5vZGUuZWRnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGVkZ2UgPSBjaGlsZE5vZGUuZWRnZXNbal07XG4gICAgICAgICAgICAvLyB3ZSBvbmx5IGhhbmRsZSBlZGdlcyB0aGF0IGFyZSB2aXNpYmxlIHRvIHRoZSBzeXN0ZW0sIG5vdCB0aGUgZGlzYWJsZWQgb25lcyBmcm9tIHRoZSBjbHVzdGVyaW5nIHByb2Nlc3MuXG4gICAgICAgICAgICBpZiAodGhpcy5jbHVzdGVyZWRFZGdlc1tlZGdlLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIC8vIHNlbGYtcmVmZXJlbmNpbmcgZWRnZXMgd2lsbCBiZSBhZGRlZCB0byB0aGUgXCJoaWRkZW5cIiBsaXN0XG4gICAgICAgICAgICAgIGlmIChlZGdlLnRvSWQgPT0gZWRnZS5mcm9tSWQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZEVkZ2VzT2JqW2VkZ2UuaWRdID0gZWRnZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzZXQgdXAgdGhlIGZyb20gYW5kIHRvLlxuICAgICAgICAgICAgICAgIGlmIChlZGdlLnRvSWQgPT0gY2hpbGROb2RlSWQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBkb3VibGUgZXF1YWxzIGJlY2F1c2UgaW50cyBhbmQgc3RyaW5ncyBjYW4gYmUgaW50ZXJjaGFuZ2VkIGhlcmUuXG4gICAgICAgICAgICAgICAgICB0b0lkID0gY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmlkO1xuICAgICAgICAgICAgICAgICAgZnJvbUlkID0gZWRnZS5mcm9tSWQ7XG4gICAgICAgICAgICAgICAgICBvdGhlck5vZGVJZCA9IGZyb21JZDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdG9JZCA9IGVkZ2UudG9JZDtcbiAgICAgICAgICAgICAgICAgIGZyb21JZCA9IGNsdXN0ZXJOb2RlUHJvcGVydGllcy5pZDtcbiAgICAgICAgICAgICAgICAgIG90aGVyTm9kZUlkID0gdG9JZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBPbmx5IGVkZ2VzIGZyb20gdGhlIGNsdXN0ZXIgb3V0d2FyZHMgYXJlIGJlaW5nIHJlcGxhY2VkLlxuICAgICAgICAgICAgICBpZiAoY2hpbGROb2Rlc09ialtvdGhlck5vZGVJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNyZWF0ZUVkZ2VzLnB1c2goeyBlZGdlOiBlZGdlLCBmcm9tSWQ6IGZyb21JZCwgdG9JZDogdG9JZCB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhlcmUgd2UgYWN0dWFsbHkgY3JlYXRlIHRoZSByZXBsYWNlbWVudCBlZGdlcy4gV2UgY291bGQgbm90IGRvIHRoaXMgaW4gdGhlIGxvb3AgYWJvdmUgYXMgdGhlIGNyZWF0aW9uIHByb2Nlc3NcbiAgICAgICAgLy8gd291bGQgYWRkIGFuIGVkZ2UgdG8gdGhlIGVkZ2VzIGFycmF5IHdlIGFyZSBpdGVyYXRpbmcgb3Zlci5cbiAgICAgICAgZm9yICh2YXIgX2oyID0gMDsgX2oyIDwgY3JlYXRlRWRnZXMubGVuZ3RoOyBfajIrKykge1xuICAgICAgICAgIHZhciBfZWRnZSA9IGNyZWF0ZUVkZ2VzW19qMl0uZWRnZTtcbiAgICAgICAgICAvLyBjb3B5IHRoZSBvcHRpb25zIG9mIHRoZSBlZGdlIHdlIHdpbGwgcmVwbGFjZVxuICAgICAgICAgIHZhciBjbG9uZWRPcHRpb25zID0gX05ldHdvcmtVdGlsMi5kZWZhdWx0LmNsb25lT3B0aW9ucyhfZWRnZSwgJ2VkZ2UnKTtcbiAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIHByb3BlcnRpZXMgb2YgY2x1c3RlckVkZ2VzIGFyZSBzdXBlcmltcG9zZWQgb24gaXRcbiAgICAgICAgICB1dGlsLmRlZXBFeHRlbmQoY2xvbmVkT3B0aW9ucywgY2x1c3RlckVkZ2VQcm9wZXJ0aWVzKTtcblxuICAgICAgICAgIC8vIHNldCB1cCB0aGUgZWRnZVxuICAgICAgICAgIGNsb25lZE9wdGlvbnMuZnJvbSA9IGNyZWF0ZUVkZ2VzW19qMl0uZnJvbUlkO1xuICAgICAgICAgIGNsb25lZE9wdGlvbnMudG8gPSBjcmVhdGVFZGdlc1tfajJdLnRvSWQ7XG4gICAgICAgICAgY2xvbmVkT3B0aW9ucy5pZCA9ICdjbHVzdGVyRWRnZTonICsgdXRpbC5yYW5kb21VVUlEKCk7XG4gICAgICAgICAgLy9jbG9uZWRPcHRpb25zLmlkID0gJyhjZjogJyArIGNyZWF0ZUVkZ2VzW2pdLmZyb21JZCArIFwiIHRvOiBcIiArIGNyZWF0ZUVkZ2VzW2pdLnRvSWQgKyBcIilcIiArIE1hdGgucmFuZG9tKCk7XG5cbiAgICAgICAgICAvLyBjcmVhdGUgdGhlIGVkZ2UgYW5kIGdpdmUgYSByZWZlcmVuY2UgdG8gdGhlIG9uZSBpdCByZXBsYWNlZC5cbiAgICAgICAgICB2YXIgbmV3RWRnZSA9IHRoaXMuYm9keS5mdW5jdGlvbnMuY3JlYXRlRWRnZShjbG9uZWRPcHRpb25zKTtcbiAgICAgICAgICBuZXdFZGdlLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWQgPSBfZWRnZS5pZDtcblxuICAgICAgICAgIC8vIGNvbm5lY3QgdGhlIGVkZ2UuXG4gICAgICAgICAgdGhpcy5ib2R5LmVkZ2VzW25ld0VkZ2UuaWRdID0gbmV3RWRnZTtcbiAgICAgICAgICBuZXdFZGdlLmNvbm5lY3QoKTtcblxuICAgICAgICAgIC8vIGhpZGUgdGhlIHJlcGxhY2VkIGVkZ2VcbiAgICAgICAgICB0aGlzLl9iYWNrdXBFZGdlT3B0aW9ucyhfZWRnZSk7XG4gICAgICAgICAgX2VkZ2Uuc2V0T3B0aW9ucyh7IHBoeXNpY3M6IGZhbHNlLCBoaWRkZW46IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAqIFRoaXMgZnVuY3Rpb24gY2hlY2tzIHRoZSBvcHRpb25zIHRoYXQgY2FuIGJlIHN1cHBsaWVkIHRvIHRoZSBkaWZmZXJlbnQgY2x1c3RlciBmdW5jdGlvbnNcbiAgICAgICogZm9yIGNlcnRhaW4gZmllbGRzIGFuZCBpbnNlcnRzIGRlZmF1bHRzIGlmIG5lZWRlZFxuICAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICogQHByaXZhdGVcbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY2hlY2tPcHRpb25zJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY2hlY2tPcHRpb25zKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmNsdXN0ZXJFZGdlUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb3B0aW9ucy5jbHVzdGVyRWRnZVByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5jbHVzdGVyTm9kZVByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAqXG4gICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICBjaGlsZE5vZGVzT2JqICAgICAgICAgfCBvYmplY3Qgd2l0aCBub2RlIG9iamVjdHMsIGlkIGFzIGtleXMsIHNhbWUgYXMgY2hpbGROb2RlcyBleGNlcHQgaXQgYWxzbyBjb250YWlucyBhIHNvdXJjZSBub2RlXG4gICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICBjaGlsZEVkZ2VzT2JqICAgICAgICAgfCBvYmplY3Qgd2l0aCBlZGdlIG9iamVjdHMsIGlkIGFzIGtleXNcbiAgICAgICogQHBhcmFtIHtBcnJheX0gICAgIG9wdGlvbnMgICAgICAgICAgICAgICB8IG9iamVjdCB3aXRoIHtjbHVzdGVyTm9kZVByb3BlcnRpZXMsIGNsdXN0ZXJFZGdlUHJvcGVydGllcywgcHJvY2Vzc1Byb3BlcnRpZXN9XG4gICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICByZWZyZXNoRGF0YSB8IHdoZW4gdHJ1ZSwgZG8gbm90IHdyYXAgdXBcbiAgICAgICogQHByaXZhdGVcbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY2x1c3RlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NsdXN0ZXIoY2hpbGROb2Rlc09iaiwgY2hpbGRFZGdlc09iaiwgb3B0aW9ucykge1xuICAgICAgICB2YXIgcmVmcmVzaERhdGEgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDMgfHwgYXJndW1lbnRzWzNdID09PSB1bmRlZmluZWQgPyB0cnVlIDogYXJndW1lbnRzWzNdO1xuXG4gICAgICAgIC8vIGtpbGwgY29uZGl0aW9uOiBubyBjaGlsZHJlbiBzbyBjYW4ndCBjbHVzdGVyIG9yIG9ubHkgb25lIG5vZGUgaW4gdGhlIGNsdXN0ZXIsIGRvbid0IGJvdGhlclxuICAgICAgICBpZiAoT2JqZWN0LmtleXMoY2hpbGROb2Rlc09iaikubGVuZ3RoIDwgMikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgY2x1c3RlciBjYWxsIGlzIG5vdCB0cnlpbmcgdG8gY2x1c3RlciBhbnl0aGluZyB0aGF0IGlzIGluIGFub3RoZXIgY2x1c3Rlci5cbiAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIGNoaWxkTm9kZXNPYmopIHtcbiAgICAgICAgICBpZiAoY2hpbGROb2Rlc09iai5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jbHVzdGVyZWROb2Rlc1tub2RlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjbHVzdGVyTm9kZVByb3BlcnRpZXMgPSB1dGlsLmRlZXBFeHRlbmQoe30sIG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzKTtcblxuICAgICAgICAvLyBjb25zdHJ1Y3QgdGhlIGNsdXN0ZXJOb2RlUHJvcGVydGllc1xuICAgICAgICBpZiAob3B0aW9ucy5wcm9jZXNzUHJvcGVydGllcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gZ2V0IHRoZSBjaGlsZE5vZGUgb3B0aW9uc1xuICAgICAgICAgIHZhciBjaGlsZE5vZGVzT3B0aW9ucyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIF9ub2RlSWQgaW4gY2hpbGROb2Rlc09iaikge1xuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZXNPYmouaGFzT3duUHJvcGVydHkoX25vZGVJZCkpIHtcbiAgICAgICAgICAgICAgdmFyIGNsb25lZE9wdGlvbnMgPSBfTmV0d29ya1V0aWwyLmRlZmF1bHQuY2xvbmVPcHRpb25zKGNoaWxkTm9kZXNPYmpbX25vZGVJZF0pO1xuICAgICAgICAgICAgICBjaGlsZE5vZGVzT3B0aW9ucy5wdXNoKGNsb25lZE9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGdldCBjbHVzdGVyIHByb3BlcnRpZXMgYmFzZWQgb24gY2hpbGROb2Rlc1xuICAgICAgICAgIHZhciBjaGlsZEVkZ2VzT3B0aW9ucyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGVkZ2VJZCBpbiBjaGlsZEVkZ2VzT2JqKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGRFZGdlc09iai5oYXNPd25Qcm9wZXJ0eShlZGdlSWQpKSB7XG4gICAgICAgICAgICAgIC8vIHRoZXNlIGNsdXN0ZXIgZWRnZXMgd2lsbCBiZSByZW1vdmVkIG9uIGNyZWF0aW9uIG9mIHRoZSBjbHVzdGVyLlxuICAgICAgICAgICAgICBpZiAoZWRnZUlkLnN1YnN0cigwLCAxMikgIT09IFwiY2x1c3RlckVkZ2U6XCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2Nsb25lZE9wdGlvbnMgPSBfTmV0d29ya1V0aWwyLmRlZmF1bHQuY2xvbmVPcHRpb25zKGNoaWxkRWRnZXNPYmpbZWRnZUlkXSwgJ2VkZ2UnKTtcbiAgICAgICAgICAgICAgICBjaGlsZEVkZ2VzT3B0aW9ucy5wdXNoKF9jbG9uZWRPcHRpb25zKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNsdXN0ZXJOb2RlUHJvcGVydGllcyA9IG9wdGlvbnMucHJvY2Vzc1Byb3BlcnRpZXMoY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLCBjaGlsZE5vZGVzT3B0aW9ucywgY2hpbGRFZGdlc09wdGlvbnMpO1xuICAgICAgICAgIGlmICghY2x1c3Rlck5vZGVQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcHJvY2Vzc1Byb3BlcnRpZXMgZnVuY3Rpb24gZG9lcyBub3QgcmV0dXJuIHByb3BlcnRpZXMhXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGlmIHdlIGhhdmUgYW4gdW5pcXVlIGlkO1xuICAgICAgICBpZiAoY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjbHVzdGVyTm9kZVByb3BlcnRpZXMuaWQgPSAnY2x1c3RlcjonICsgdXRpbC5yYW5kb21VVUlEKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNsdXN0ZXJJZCA9IGNsdXN0ZXJOb2RlUHJvcGVydGllcy5pZDtcblxuICAgICAgICBpZiAoY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmxhYmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjbHVzdGVyTm9kZVByb3BlcnRpZXMubGFiZWwgPSAnY2x1c3Rlcic7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnaXZlIHRoZSBjbHVzdGVyTm9kZSBhIHBvc2l0aW9uIGlmIGl0IGRvZXMgbm90IGhhdmUgb25lLlxuICAgICAgICB2YXIgcG9zID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLnggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHBvcyA9IHRoaXMuX2dldENsdXN0ZXJQb3NpdGlvbihjaGlsZE5vZGVzT2JqKTtcbiAgICAgICAgICBjbHVzdGVyTm9kZVByb3BlcnRpZXMueCA9IHBvcy54O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbHVzdGVyTm9kZVByb3BlcnRpZXMueSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHBvcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwb3MgPSB0aGlzLl9nZXRDbHVzdGVyUG9zaXRpb24oY2hpbGROb2Rlc09iaik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsdXN0ZXJOb2RlUHJvcGVydGllcy55ID0gcG9zLnk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmb3JjZSB0aGUgSUQgdG8gcmVtYWluIHRoZSBzYW1lXG4gICAgICAgIGNsdXN0ZXJOb2RlUHJvcGVydGllcy5pZCA9IGNsdXN0ZXJJZDtcblxuICAgICAgICAvLyBjcmVhdGUgdGhlIGNsdXN0ZXJOb2RlXG4gICAgICAgIHZhciBjbHVzdGVyTm9kZSA9IHRoaXMuYm9keS5mdW5jdGlvbnMuY3JlYXRlTm9kZShjbHVzdGVyTm9kZVByb3BlcnRpZXMsIF9DbHVzdGVyMi5kZWZhdWx0KTtcbiAgICAgICAgY2x1c3Rlck5vZGUuaXNDbHVzdGVyID0gdHJ1ZTtcbiAgICAgICAgY2x1c3Rlck5vZGUuY29udGFpbmVkTm9kZXMgPSBjaGlsZE5vZGVzT2JqO1xuICAgICAgICBjbHVzdGVyTm9kZS5jb250YWluZWRFZGdlcyA9IGNoaWxkRWRnZXNPYmo7XG4gICAgICAgIC8vIGNhY2hlIGEgY29weSBmcm9tIHRoZSBjbHVzdGVyIGVkZ2UgcHJvcGVydGllcyBpZiB3ZSBoYXZlIHRvIHJlY29ubmVjdCBvdGhlcnMgbGF0ZXIgb25cbiAgICAgICAgY2x1c3Rlck5vZGUuY2x1c3RlckVkZ2VQcm9wZXJ0aWVzID0gb3B0aW9ucy5jbHVzdGVyRWRnZVByb3BlcnRpZXM7XG5cbiAgICAgICAgLy8gZmluYWxseSBwdXQgdGhlIGNsdXN0ZXIgbm9kZSBpbnRvIGdsb2JhbFxuICAgICAgICB0aGlzLmJvZHkubm9kZXNbY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmlkXSA9IGNsdXN0ZXJOb2RlO1xuXG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgbmV3IGVkZ2VzIHRoYXQgd2lsbCBjb25uZWN0IHRvIHRoZSBjbHVzdGVyLCBhbGwgc2VsZi1yZWZlcmVuY2luZyBlZGdlcyB3aWxsIGJlIGFkZGVkIHRvIGNoaWxkRWRnZXNPYmplY3QgaGVyZS5cbiAgICAgICAgdGhpcy5fY3JlYXRlQ2x1c3RlckVkZ2VzKGNoaWxkTm9kZXNPYmosIGNoaWxkRWRnZXNPYmosIGNsdXN0ZXJOb2RlUHJvcGVydGllcywgb3B0aW9ucy5jbHVzdGVyRWRnZVByb3BlcnRpZXMpO1xuXG4gICAgICAgIC8vIGRpc2FibGUgdGhlIGNoaWxkRWRnZXNcbiAgICAgICAgZm9yICh2YXIgX2VkZ2VJZCBpbiBjaGlsZEVkZ2VzT2JqKSB7XG4gICAgICAgICAgaWYgKGNoaWxkRWRnZXNPYmouaGFzT3duUHJvcGVydHkoX2VkZ2VJZCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJvZHkuZWRnZXNbX2VkZ2VJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB2YXIgZWRnZSA9IHRoaXMuYm9keS5lZGdlc1tfZWRnZUlkXTtcbiAgICAgICAgICAgICAgLy8gY2FjaGUgdGhlIG9wdGlvbnMgYmVmb3JlIGNoYW5naW5nXG4gICAgICAgICAgICAgIHRoaXMuX2JhY2t1cEVkZ2VPcHRpb25zKGVkZ2UpO1xuICAgICAgICAgICAgICAvLyBkaXNhYmxlIHBoeXNpY3MgYW5kIGhpZGUgdGhlIGVkZ2VcbiAgICAgICAgICAgICAgZWRnZS5zZXRPcHRpb25zKHsgcGh5c2ljczogZmFsc2UsIGhpZGRlbjogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkaXNhYmxlIHRoZSBjaGlsZE5vZGVzXG4gICAgICAgIGZvciAodmFyIF9ub2RlSWQyIGluIGNoaWxkTm9kZXNPYmopIHtcbiAgICAgICAgICBpZiAoY2hpbGROb2Rlc09iai5oYXNPd25Qcm9wZXJ0eShfbm9kZUlkMikpIHtcbiAgICAgICAgICAgIHRoaXMuY2x1c3RlcmVkTm9kZXNbX25vZGVJZDJdID0geyBjbHVzdGVySWQ6IGNsdXN0ZXJOb2RlUHJvcGVydGllcy5pZCwgbm9kZTogdGhpcy5ib2R5Lm5vZGVzW19ub2RlSWQyXSB9O1xuICAgICAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW19ub2RlSWQyXS5zZXRPcHRpb25zKHsgaGlkZGVuOiB0cnVlLCBwaHlzaWNzOiBmYWxzZSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgSUQgdG8gdW5kZWZpbmVkIHNvIG5vIGR1cGxpY2F0ZXMgYXJpc2VcbiAgICAgICAgY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmlkID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIC8vIHdyYXAgdXBcbiAgICAgICAgaWYgKHJlZnJlc2hEYXRhID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2RhdGFDaGFuZ2VkJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfYmFja3VwRWRnZU9wdGlvbnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9iYWNrdXBFZGdlT3B0aW9ucyhlZGdlKSB7XG4gICAgICAgIGlmICh0aGlzLmNsdXN0ZXJlZEVkZ2VzW2VkZ2UuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmNsdXN0ZXJlZEVkZ2VzW2VkZ2UuaWRdID0geyBwaHlzaWNzOiBlZGdlLm9wdGlvbnMucGh5c2ljcywgaGlkZGVuOiBlZGdlLm9wdGlvbnMuaGlkZGVuIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfcmVzdG9yZUVkZ2UnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXN0b3JlRWRnZShlZGdlKSB7XG4gICAgICAgIHZhciBvcmlnaW5hbE9wdGlvbnMgPSB0aGlzLmNsdXN0ZXJlZEVkZ2VzW2VkZ2UuaWRdO1xuICAgICAgICBpZiAob3JpZ2luYWxPcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBlZGdlLnNldE9wdGlvbnMoeyBwaHlzaWNzOiBvcmlnaW5hbE9wdGlvbnMucGh5c2ljcywgaGlkZGVuOiBvcmlnaW5hbE9wdGlvbnMuaGlkZGVuIH0pO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLmNsdXN0ZXJlZEVkZ2VzW2VkZ2UuaWRdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgKiBDaGVjayBpZiBhIG5vZGUgaXMgYSBjbHVzdGVyLlxuICAgICAgKiBAcGFyYW0gbm9kZUlkXG4gICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2lzQ2x1c3RlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaXNDbHVzdGVyKG5vZGVJZCkge1xuICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXS5pc0NsdXN0ZXIgPT09IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJOb2RlIGRvZXMgbm90IGV4aXN0LlwiKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAqIGdldCB0aGUgcG9zaXRpb24gb2YgdGhlIGNsdXN0ZXIgbm9kZSBiYXNlZCBvbiB3aGF0J3MgaW5zaWRlXG4gICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjaGlsZE5vZGVzT2JqICAgIHwgb2JqZWN0IHdpdGggbm9kZSBvYmplY3RzLCBpZCBhcyBrZXlzXG4gICAgICAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fVxuICAgICAgKiBAcHJpdmF0ZVxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19nZXRDbHVzdGVyUG9zaXRpb24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDbHVzdGVyUG9zaXRpb24oY2hpbGROb2Rlc09iaikge1xuICAgICAgICB2YXIgY2hpbGRLZXlzID0gT2JqZWN0LmtleXMoY2hpbGROb2Rlc09iaik7XG4gICAgICAgIHZhciBtaW5YID0gY2hpbGROb2Rlc09ialtjaGlsZEtleXNbMF1dLng7XG4gICAgICAgIHZhciBtYXhYID0gY2hpbGROb2Rlc09ialtjaGlsZEtleXNbMF1dLng7XG4gICAgICAgIHZhciBtaW5ZID0gY2hpbGROb2Rlc09ialtjaGlsZEtleXNbMF1dLnk7XG4gICAgICAgIHZhciBtYXhZID0gY2hpbGROb2Rlc09ialtjaGlsZEtleXNbMF1dLnk7XG4gICAgICAgIHZhciBub2RlID0gdm9pZCAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGNoaWxkS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG5vZGUgPSBjaGlsZE5vZGVzT2JqW2NoaWxkS2V5c1tpXV07XG4gICAgICAgICAgbWluWCA9IG5vZGUueCA8IG1pblggPyBub2RlLnggOiBtaW5YO1xuICAgICAgICAgIG1heFggPSBub2RlLnggPiBtYXhYID8gbm9kZS54IDogbWF4WDtcbiAgICAgICAgICBtaW5ZID0gbm9kZS55IDwgbWluWSA/IG5vZGUueSA6IG1pblk7XG4gICAgICAgICAgbWF4WSA9IG5vZGUueSA+IG1heFkgPyBub2RlLnkgOiBtYXhZO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgeDogMC41ICogKG1pblggKyBtYXhYKSwgeTogMC41ICogKG1pblkgKyBtYXhZKSB9O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICogT3BlbiBhIGNsdXN0ZXIgYnkgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLlxuICAgICAgKiBAcGFyYW0ge1N0cmluZ30gIGNsdXN0ZXJOb2RlSWQgfCB0aGUgSUQgb2YgdGhlIGNsdXN0ZXIgbm9kZVxuICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlZnJlc2hEYXRhIHwgd3JhcCB1cCBhZnRlcndhcmRzIGlmIG5vdCB0cnVlXG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnb3BlbkNsdXN0ZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9wZW5DbHVzdGVyKGNsdXN0ZXJOb2RlSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlZnJlc2hEYXRhID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFyZ3VtZW50c1syXTtcblxuICAgICAgICAvLyBraWxsIGNvbmRpdGlvbnNcbiAgICAgICAgaWYgKGNsdXN0ZXJOb2RlSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGNsdXN0ZXJOb2RlSWQgc3VwcGxpZWQgdG8gb3BlbkNsdXN0ZXIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbY2x1c3Rlck5vZGVJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBjbHVzdGVyTm9kZUlkIHN1cHBsaWVkIHRvIG9wZW5DbHVzdGVyIGRvZXMgbm90IGV4aXN0LlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW2NsdXN0ZXJOb2RlSWRdLmNvbnRhaW5lZE5vZGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlRoZSBub2RlOlwiICsgY2x1c3Rlck5vZGVJZCArIFwiIGlzIG5vdCBhIGNsdXN0ZXIuXCIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2x1c3Rlck5vZGUgPSB0aGlzLmJvZHkubm9kZXNbY2x1c3Rlck5vZGVJZF07XG4gICAgICAgIHZhciBjb250YWluZWROb2RlcyA9IGNsdXN0ZXJOb2RlLmNvbnRhaW5lZE5vZGVzO1xuICAgICAgICB2YXIgY29udGFpbmVkRWRnZXMgPSBjbHVzdGVyTm9kZS5jb250YWluZWRFZGdlcztcblxuICAgICAgICAvLyBhbGxvdyB0aGUgdXNlciB0byBwb3NpdGlvbiB0aGUgbm9kZXMgYWZ0ZXIgcmVsZWFzZS5cbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnJlbGVhc2VGdW5jdGlvbiAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvcHRpb25zLnJlbGVhc2VGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciBwb3NpdGlvbnMgPSB7fTtcbiAgICAgICAgICB2YXIgY2x1c3RlclBvc2l0aW9uID0geyB4OiBjbHVzdGVyTm9kZS54LCB5OiBjbHVzdGVyTm9kZS55IH07XG4gICAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIGNvbnRhaW5lZE5vZGVzKSB7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVkTm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgICAgICB2YXIgY29udGFpbmVkTm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgICAgICAgICBwb3NpdGlvbnNbbm9kZUlkXSA9IHsgeDogY29udGFpbmVkTm9kZS54LCB5OiBjb250YWluZWROb2RlLnkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG5ld1Bvc2l0aW9ucyA9IG9wdGlvbnMucmVsZWFzZUZ1bmN0aW9uKGNsdXN0ZXJQb3NpdGlvbiwgcG9zaXRpb25zKTtcblxuICAgICAgICAgIGZvciAodmFyIF9ub2RlSWQzIGluIGNvbnRhaW5lZE5vZGVzKSB7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVkTm9kZXMuaGFzT3duUHJvcGVydHkoX25vZGVJZDMpKSB7XG4gICAgICAgICAgICAgIHZhciBfY29udGFpbmVkTm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tfbm9kZUlkM107XG4gICAgICAgICAgICAgIGlmIChuZXdQb3NpdGlvbnNbX25vZGVJZDNdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBfY29udGFpbmVkTm9kZS54ID0gbmV3UG9zaXRpb25zW19ub2RlSWQzXS54ID09PSB1bmRlZmluZWQgPyBjbHVzdGVyTm9kZS54IDogbmV3UG9zaXRpb25zW19ub2RlSWQzXS54O1xuICAgICAgICAgICAgICAgIF9jb250YWluZWROb2RlLnkgPSBuZXdQb3NpdGlvbnNbX25vZGVJZDNdLnkgPT09IHVuZGVmaW5lZCA/IGNsdXN0ZXJOb2RlLnkgOiBuZXdQb3NpdGlvbnNbX25vZGVJZDNdLnk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY29weSB0aGUgcG9zaXRpb24gZnJvbSB0aGUgY2x1c3RlclxuICAgICAgICAgIGZvciAodmFyIF9ub2RlSWQ0IGluIGNvbnRhaW5lZE5vZGVzKSB7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVkTm9kZXMuaGFzT3duUHJvcGVydHkoX25vZGVJZDQpKSB7XG4gICAgICAgICAgICAgIHZhciBfY29udGFpbmVkTm9kZTIgPSB0aGlzLmJvZHkubm9kZXNbX25vZGVJZDRdO1xuICAgICAgICAgICAgICBfY29udGFpbmVkTm9kZTIgPSBjb250YWluZWROb2Rlc1tfbm9kZUlkNF07XG4gICAgICAgICAgICAgIC8vIGluaGVyaXQgcG9zaXRpb25cbiAgICAgICAgICAgICAgaWYgKF9jb250YWluZWROb2RlMi5vcHRpb25zLmZpeGVkLnggPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRhaW5lZE5vZGUyLnggPSBjbHVzdGVyTm9kZS54O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChfY29udGFpbmVkTm9kZTIub3B0aW9ucy5maXhlZC55ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIF9jb250YWluZWROb2RlMi55ID0gY2x1c3Rlck5vZGUueTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbGVhc2Ugbm9kZXNcbiAgICAgICAgZm9yICh2YXIgX25vZGVJZDUgaW4gY29udGFpbmVkTm9kZXMpIHtcbiAgICAgICAgICBpZiAoY29udGFpbmVkTm9kZXMuaGFzT3duUHJvcGVydHkoX25vZGVJZDUpKSB7XG4gICAgICAgICAgICB2YXIgX2NvbnRhaW5lZE5vZGUzID0gdGhpcy5ib2R5Lm5vZGVzW19ub2RlSWQ1XTtcblxuICAgICAgICAgICAgLy8gaW5oZXJpdCBzcGVlZFxuICAgICAgICAgICAgX2NvbnRhaW5lZE5vZGUzLnZ4ID0gY2x1c3Rlck5vZGUudng7XG4gICAgICAgICAgICBfY29udGFpbmVkTm9kZTMudnkgPSBjbHVzdGVyTm9kZS52eTtcblxuICAgICAgICAgICAgLy8gd2UgdXNlIHRoZXNlIG1ldGhvZHMgdG8gYXZvaWQgcmUtaW5zdGFudGlhdGluZyB0aGUgc2hhcGUsIHdoaWNoIGhhcHBlbnMgd2l0aCBzZXRPcHRpb25zLlxuICAgICAgICAgICAgX2NvbnRhaW5lZE5vZGUzLnNldE9wdGlvbnMoeyBoaWRkZW46IGZhbHNlLCBwaHlzaWNzOiB0cnVlIH0pO1xuXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5jbHVzdGVyZWROb2Rlc1tfbm9kZUlkNV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29weSB0aGUgY2x1c3Rlck5vZGUgZWRnZXMgYmVjYXVzZSB3ZSBjYW5ub3QgaXRlcmF0ZSBvdmVyIGFuIG9iamVjdCB0aGF0IHdlIGFkZCBvciByZW1vdmUgZnJvbS5cbiAgICAgICAgdmFyIGVkZ2VzVG9CZURlbGV0ZWQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbHVzdGVyTm9kZS5lZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGVkZ2VzVG9CZURlbGV0ZWQucHVzaChjbHVzdGVyTm9kZS5lZGdlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhY3R1YWxseSBoYW5kbGluZyB0aGUgZGVsZXRpbmcuXG4gICAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IGVkZ2VzVG9CZURlbGV0ZWQubGVuZ3RoOyBfaTQrKykge1xuICAgICAgICAgIHZhciBlZGdlID0gZWRnZXNUb0JlRGVsZXRlZFtfaTRdO1xuXG4gICAgICAgICAgdmFyIG90aGVyTm9kZUlkID0gdGhpcy5fZ2V0Q29ubmVjdGVkSWQoZWRnZSwgY2x1c3Rlck5vZGVJZCk7XG4gICAgICAgICAgLy8gaWYgdGhlIG90aGVyIG5vZGUgaXMgaW4gYW5vdGhlciBjbHVzdGVyLCB3ZSB0cmFuc2ZlciBvd25lcnNoaXAgb2YgdGhpcyBlZGdlIHRvIHRoZSBvdGhlciBjbHVzdGVyXG4gICAgICAgICAgaWYgKHRoaXMuY2x1c3RlcmVkTm9kZXNbb3RoZXJOb2RlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHRyYW5zZmVyIG93bmVyc2hpcDpcbiAgICAgICAgICAgIHZhciBvdGhlckNsdXN0ZXIgPSB0aGlzLmJvZHkubm9kZXNbdGhpcy5jbHVzdGVyZWROb2Rlc1tvdGhlck5vZGVJZF0uY2x1c3RlcklkXTtcbiAgICAgICAgICAgIHZhciB0cmFuc2ZlckVkZ2UgPSB0aGlzLmJvZHkuZWRnZXNbZWRnZS5jbHVzdGVyaW5nRWRnZVJlcGxhY2luZ0lkXTtcbiAgICAgICAgICAgIGlmICh0cmFuc2ZlckVkZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBvdGhlckNsdXN0ZXIuY29udGFpbmVkRWRnZXNbdHJhbnNmZXJFZGdlLmlkXSA9IHRyYW5zZmVyRWRnZTtcblxuICAgICAgICAgICAgICAvLyBkZWxldGUgbG9jYWwgcmVmZXJlbmNlXG4gICAgICAgICAgICAgIGRlbGV0ZSBjb250YWluZWRFZGdlc1t0cmFuc2ZlckVkZ2UuaWRdO1xuXG4gICAgICAgICAgICAgIC8vIGNyZWF0ZSBuZXcgY2x1c3RlciBlZGdlIGZyb20gdGhlIG90aGVyQ2x1c3RlcjpcbiAgICAgICAgICAgICAgLy8gZ2V0IHRvIGFuZCBmcm9tXG4gICAgICAgICAgICAgIHZhciBmcm9tSWQgPSB0cmFuc2ZlckVkZ2UuZnJvbUlkO1xuICAgICAgICAgICAgICB2YXIgdG9JZCA9IHRyYW5zZmVyRWRnZS50b0lkO1xuICAgICAgICAgICAgICBpZiAodHJhbnNmZXJFZGdlLnRvSWQgPT0gb3RoZXJOb2RlSWQpIHtcbiAgICAgICAgICAgICAgICB0b0lkID0gdGhpcy5jbHVzdGVyZWROb2Rlc1tvdGhlck5vZGVJZF0uY2x1c3RlcklkO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZyb21JZCA9IHRoaXMuY2x1c3RlcmVkTm9kZXNbb3RoZXJOb2RlSWRdLmNsdXN0ZXJJZDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIGNsb25lIHRoZSBvcHRpb25zIGFuZCBhcHBseSB0aGUgY2x1c3RlciBvcHRpb25zIHRvIHRoZW1cbiAgICAgICAgICAgICAgdmFyIGNsb25lZE9wdGlvbnMgPSBfTmV0d29ya1V0aWwyLmRlZmF1bHQuY2xvbmVPcHRpb25zKHRyYW5zZmVyRWRnZSwgJ2VkZ2UnKTtcbiAgICAgICAgICAgICAgdXRpbC5kZWVwRXh0ZW5kKGNsb25lZE9wdGlvbnMsIG90aGVyQ2x1c3Rlci5jbHVzdGVyRWRnZVByb3BlcnRpZXMpO1xuXG4gICAgICAgICAgICAgIC8vIGFwcGx5IHRoZSBlZGdlIHNwZWNpZmljIG9wdGlvbnMgdG8gaXQuXG4gICAgICAgICAgICAgIHZhciBpZCA9ICdjbHVzdGVyRWRnZTonICsgdXRpbC5yYW5kb21VVUlEKCk7XG4gICAgICAgICAgICAgIHV0aWwuZGVlcEV4dGVuZChjbG9uZWRPcHRpb25zLCB7IGZyb206IGZyb21JZCwgdG86IHRvSWQsIGhpZGRlbjogZmFsc2UsIHBoeXNpY3M6IHRydWUsIGlkOiBpZCB9KTtcblxuICAgICAgICAgICAgICAvLyBjcmVhdGUgaXRcbiAgICAgICAgICAgICAgdmFyIG5ld0VkZ2UgPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZUVkZ2UoY2xvbmVkT3B0aW9ucyk7XG4gICAgICAgICAgICAgIG5ld0VkZ2UuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZCA9IHRyYW5zZmVyRWRnZS5pZDtcbiAgICAgICAgICAgICAgdGhpcy5ib2R5LmVkZ2VzW2lkXSA9IG5ld0VkZ2U7XG4gICAgICAgICAgICAgIHRoaXMuYm9keS5lZGdlc1tpZF0uY29ubmVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVwbGFjZWRFZGdlID0gdGhpcy5ib2R5LmVkZ2VzW2VkZ2UuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZF07XG4gICAgICAgICAgICBpZiAocmVwbGFjZWRFZGdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVzdG9yZUVkZ2UocmVwbGFjZWRFZGdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWRnZS5jbGVhbnVwKCk7XG4gICAgICAgICAgLy8gdGhpcyByZW1vdmVzIHRoZSBlZGdlIGZyb20gbm9kZS5lZGdlcywgd2hpY2ggaXMgd2h5IGVkZ2VJZHMgaXMgZm9ybWVkXG4gICAgICAgICAgZWRnZS5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuYm9keS5lZGdlc1tlZGdlLmlkXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhbmRsZSB0aGUgcmVsZWFzaW5nIG9mIHRoZSBlZGdlc1xuICAgICAgICBmb3IgKHZhciBlZGdlSWQgaW4gY29udGFpbmVkRWRnZXMpIHtcbiAgICAgICAgICBpZiAoY29udGFpbmVkRWRnZXMuaGFzT3duUHJvcGVydHkoZWRnZUlkKSkge1xuICAgICAgICAgICAgdGhpcy5fcmVzdG9yZUVkZ2UoY29udGFpbmVkRWRnZXNbZWRnZUlkXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIGNsdXN0ZXJOb2RlXG4gICAgICAgIGRlbGV0ZSB0aGlzLmJvZHkubm9kZXNbY2x1c3Rlck5vZGVJZF07XG5cbiAgICAgICAgaWYgKHJlZnJlc2hEYXRhID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2RhdGFDaGFuZ2VkJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXROb2Rlc0luQ2x1c3RlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Tm9kZXNJbkNsdXN0ZXIoY2x1c3RlcklkKSB7XG4gICAgICAgIHZhciBub2Rlc0FycmF5ID0gW107XG4gICAgICAgIGlmICh0aGlzLmlzQ2x1c3RlcihjbHVzdGVySWQpID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIGNvbnRhaW5lZE5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzW2NsdXN0ZXJJZF0uY29udGFpbmVkTm9kZXM7XG4gICAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIGNvbnRhaW5lZE5vZGVzKSB7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVkTm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgICAgICBub2Rlc0FycmF5LnB1c2godGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0uaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2Rlc0FycmF5O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICogR2V0IHRoZSBzdGFjayBjbHVzdGVySWQncyB0aGF0IGEgY2VydGFpbiBub2RlIHJlc2lkZXMgaW4uIGNsdXN0ZXIgQSAtPiBjbHVzdGVyIEIgLT4gY2x1c3RlciBDIC0+IG5vZGVcbiAgICAgICogQHBhcmFtIG5vZGVJZFxuICAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZmluZE5vZGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmROb2RlKG5vZGVJZCkge1xuICAgICAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICAgICAgdmFyIG1heCA9IDEwMDtcbiAgICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuXG4gICAgICAgIHdoaWxlICh0aGlzLmNsdXN0ZXJlZE5vZGVzW25vZGVJZF0gIT09IHVuZGVmaW5lZCAmJiBjb3VudGVyIDwgbWF4KSB7XG4gICAgICAgICAgc3RhY2sucHVzaCh0aGlzLmJvZHkubm9kZXNbbm9kZUlkXS5pZCk7XG4gICAgICAgICAgbm9kZUlkID0gdGhpcy5jbHVzdGVyZWROb2Rlc1tub2RlSWRdLmNsdXN0ZXJJZDtcbiAgICAgICAgICBjb3VudGVyKys7XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sucHVzaCh0aGlzLmJvZHkubm9kZXNbbm9kZUlkXS5pZCk7XG4gICAgICAgIHN0YWNrLnJldmVyc2UoKTtcblxuICAgICAgICByZXR1cm4gc3RhY2s7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgKiBHZXQgdGhlIElkIHRoZSBub2RlIGlzIGNvbm5lY3RlZCB0b1xuICAgICAgKiBAcGFyYW0gZWRnZVxuICAgICAgKiBAcGFyYW0gbm9kZUlkXG4gICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAgKiBAcHJpdmF0ZVxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19nZXRDb25uZWN0ZWRJZCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldENvbm5lY3RlZElkKGVkZ2UsIG5vZGVJZCkge1xuICAgICAgICBpZiAoZWRnZS50b0lkICE9IG5vZGVJZCkge1xuICAgICAgICAgIHJldHVybiBlZGdlLnRvSWQ7XG4gICAgICAgIH0gZWxzZSBpZiAoZWRnZS5mcm9tSWQgIT0gbm9kZUlkKSB7XG4gICAgICAgICAgcmV0dXJuIGVkZ2UuZnJvbUlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBlZGdlLmZyb21JZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICogV2UgZGV0ZXJtaW5lIGhvdyBtYW55IGNvbm5lY3Rpb25zIGRlbm90ZSBhbiBpbXBvcnRhbnQgaHViLlxuICAgICAgKiBXZSB0YWtlIHRoZSBtZWFuICsgMipzdGQgYXMgdGhlIGltcG9ydGFudCBodWIgc2l6ZS4gKEFzc3VtaW5nIGEgbm9ybWFsIGRpc3RyaWJ1dGlvbiBvZiBkYXRhLCB+Mi4yJSlcbiAgICAgICpcbiAgICAgICogQHByaXZhdGVcbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZ2V0SHViU2l6ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEh1YlNpemUoKSB7XG4gICAgICAgIHZhciBhdmVyYWdlID0gMDtcbiAgICAgICAgdmFyIGF2ZXJhZ2VTcXVhcmVkID0gMDtcbiAgICAgICAgdmFyIGh1YkNvdW50ZXIgPSAwO1xuICAgICAgICB2YXIgbGFyZ2VzdEh1YiA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLmJvZHkubm9kZUluZGljZXNbaV1dO1xuICAgICAgICAgIGlmIChub2RlLmVkZ2VzLmxlbmd0aCA+IGxhcmdlc3RIdWIpIHtcbiAgICAgICAgICAgIGxhcmdlc3RIdWIgPSBub2RlLmVkZ2VzLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXZlcmFnZSArPSBub2RlLmVkZ2VzLmxlbmd0aDtcbiAgICAgICAgICBhdmVyYWdlU3F1YXJlZCArPSBNYXRoLnBvdyhub2RlLmVkZ2VzLmxlbmd0aCwgMik7XG4gICAgICAgICAgaHViQ291bnRlciArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGF2ZXJhZ2UgPSBhdmVyYWdlIC8gaHViQ291bnRlcjtcbiAgICAgICAgYXZlcmFnZVNxdWFyZWQgPSBhdmVyYWdlU3F1YXJlZCAvIGh1YkNvdW50ZXI7XG5cbiAgICAgICAgdmFyIHZhcmlhbmNlID0gYXZlcmFnZVNxdWFyZWQgLSBNYXRoLnBvdyhhdmVyYWdlLCAyKTtcbiAgICAgICAgdmFyIHN0YW5kYXJkRGV2aWF0aW9uID0gTWF0aC5zcXJ0KHZhcmlhbmNlKTtcblxuICAgICAgICB2YXIgaHViVGhyZXNob2xkID0gTWF0aC5mbG9vcihhdmVyYWdlICsgMiAqIHN0YW5kYXJkRGV2aWF0aW9uKTtcblxuICAgICAgICAvLyBhbHdheXMgaGF2ZSBhdCBsZWFzdCBvbmUgdG8gY2x1c3RlclxuICAgICAgICBpZiAoaHViVGhyZXNob2xkID4gbGFyZ2VzdEh1Yikge1xuICAgICAgICAgIGh1YlRocmVzaG9sZCA9IGxhcmdlc3RIdWI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaHViVGhyZXNob2xkO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBDbHVzdGVyRW5naW5lO1xuICB9KCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gQ2x1c3RlckVuZ2luZTtcblxuLyoqKi8gfSxcbi8qIDEwMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuICB2YXIgTmV0d29ya1V0aWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmV0d29ya1V0aWwoKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTmV0d29ya1V0aWwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIGNlbnRlciBwb3NpdGlvbiBvZiB0aGUgbmV0d29yayBjb25zaWRlcmluZyB0aGUgYm91bmRpbmcgYm94ZXNcbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKE5ldHdvcmtVdGlsLCBudWxsLCBbe1xuICAgICAga2V5OiBcImdldFJhbmdlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmFuZ2UoYWxsTm9kZXMpIHtcbiAgICAgICAgdmFyIHNwZWNpZmljTm9kZXMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBbXSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICB2YXIgbWluWSA9IDFlOSxcbiAgICAgICAgICAgIG1heFkgPSAtMWU5LFxuICAgICAgICAgICAgbWluWCA9IDFlOSxcbiAgICAgICAgICAgIG1heFggPSAtMWU5LFxuICAgICAgICAgICAgbm9kZTtcbiAgICAgICAgaWYgKHNwZWNpZmljTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BlY2lmaWNOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbm9kZSA9IGFsbE5vZGVzW3NwZWNpZmljTm9kZXNbaV1dO1xuICAgICAgICAgICAgaWYgKG1pblggPiBub2RlLnNoYXBlLmJvdW5kaW5nQm94LmxlZnQpIHtcbiAgICAgICAgICAgICAgbWluWCA9IG5vZGUuc2hhcGUuYm91bmRpbmdCb3gubGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXhYIDwgbm9kZS5zaGFwZS5ib3VuZGluZ0JveC5yaWdodCkge1xuICAgICAgICAgICAgICBtYXhYID0gbm9kZS5zaGFwZS5ib3VuZGluZ0JveC5yaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtaW5ZID4gbm9kZS5zaGFwZS5ib3VuZGluZ0JveC50b3ApIHtcbiAgICAgICAgICAgICAgbWluWSA9IG5vZGUuc2hhcGUuYm91bmRpbmdCb3gudG9wO1xuICAgICAgICAgICAgfSAvLyB0b3AgaXMgbmVnYXRpdmUsIGJvdHRvbSBpcyBwb3NpdGl2ZVxuICAgICAgICAgICAgaWYgKG1heFkgPCBub2RlLnNoYXBlLmJvdW5kaW5nQm94LmJvdHRvbSkge1xuICAgICAgICAgICAgICBtYXhZID0gbm9kZS5zaGFwZS5ib3VuZGluZ0JveC5ib3R0b207XG4gICAgICAgICAgICB9IC8vIHRvcCBpcyBuZWdhdGl2ZSwgYm90dG9tIGlzIHBvc2l0aXZlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1pblggPT09IDFlOSAmJiBtYXhYID09PSAtMWU5ICYmIG1pblkgPT09IDFlOSAmJiBtYXhZID09PSAtMWU5KSB7XG4gICAgICAgICAgbWluWSA9IDAsIG1heFkgPSAwLCBtaW5YID0gMCwgbWF4WCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbWluWDogbWluWCwgbWF4WDogbWF4WCwgbWluWTogbWluWSwgbWF4WTogbWF4WSB9O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEZpbmQgdGhlIGNlbnRlciBwb3NpdGlvbiBvZiB0aGUgbmV0d29ya1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0UmFuZ2VDb3JlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmFuZ2VDb3JlKGFsbE5vZGVzKSB7XG4gICAgICAgIHZhciBzcGVjaWZpY05vZGVzID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gW10gOiBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgdmFyIG1pblkgPSAxZTksXG4gICAgICAgICAgICBtYXhZID0gLTFlOSxcbiAgICAgICAgICAgIG1pblggPSAxZTksXG4gICAgICAgICAgICBtYXhYID0gLTFlOSxcbiAgICAgICAgICAgIG5vZGU7XG4gICAgICAgIGlmIChzcGVjaWZpY05vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwZWNpZmljTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG5vZGUgPSBhbGxOb2Rlc1tzcGVjaWZpY05vZGVzW2ldXTtcbiAgICAgICAgICAgIGlmIChtaW5YID4gbm9kZS54KSB7XG4gICAgICAgICAgICAgIG1pblggPSBub2RlLng7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF4WCA8IG5vZGUueCkge1xuICAgICAgICAgICAgICBtYXhYID0gbm9kZS54O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1pblkgPiBub2RlLnkpIHtcbiAgICAgICAgICAgICAgbWluWSA9IG5vZGUueTtcbiAgICAgICAgICAgIH0gLy8gdG9wIGlzIG5lZ2F0aXZlLCBib3R0b20gaXMgcG9zaXRpdmVcbiAgICAgICAgICAgIGlmIChtYXhZIDwgbm9kZS55KSB7XG4gICAgICAgICAgICAgIG1heFkgPSBub2RlLnk7XG4gICAgICAgICAgICB9IC8vIHRvcCBpcyBuZWdhdGl2ZSwgYm90dG9tIGlzIHBvc2l0aXZlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1pblggPT09IDFlOSAmJiBtYXhYID09PSAtMWU5ICYmIG1pblkgPT09IDFlOSAmJiBtYXhZID09PSAtMWU5KSB7XG4gICAgICAgICAgbWluWSA9IDAsIG1heFkgPSAwLCBtaW5YID0gMCwgbWF4WCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbWluWDogbWluWCwgbWF4WDogbWF4WCwgbWluWTogbWluWSwgbWF4WTogbWF4WSB9O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSByYW5nZSA9IHttaW5YOiBtaW5YLCBtYXhYOiBtYXhYLCBtaW5ZOiBtaW5ZLCBtYXhZOiBtYXhZfTtcbiAgICAgICAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZmluZENlbnRlclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRDZW50ZXIocmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHsgeDogMC41ICogKHJhbmdlLm1heFggKyByYW5nZS5taW5YKSxcbiAgICAgICAgICB5OiAwLjUgKiAocmFuZ2UubWF4WSArIHJhbmdlLm1pblkpIH07XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyByZXR1cm5zIGEgY2xvbmUgb2YgdGhlIG9wdGlvbnMgb3Igb3B0aW9ucyBvZiB0aGUgZWRnZSBvciBub2RlIHRvIGJlIHVzZWQgZm9yIGNvbnN0cnVjdGlvbiBvZiBuZXcgZWRnZXMgb3IgY2hlY2sgZnVuY3Rpb25zIGZvciBuZXcgbm9kZXMuXG4gICAgICAgKiBAcGFyYW0gaXRlbVxuICAgICAgICogQHBhcmFtIHR5cGVcbiAgICAgICAqIEByZXR1cm5zIHt7fX1cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImNsb25lT3B0aW9uc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lT3B0aW9ucyhpdGVtLCB0eXBlKSB7XG4gICAgICAgIHZhciBjbG9uZWRPcHRpb25zID0ge307XG4gICAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZSA9PT0gJ25vZGUnKSB7XG4gICAgICAgICAgdXRpbC5kZWVwRXh0ZW5kKGNsb25lZE9wdGlvbnMsIGl0ZW0ub3B0aW9ucywgdHJ1ZSk7XG4gICAgICAgICAgY2xvbmVkT3B0aW9ucy54ID0gaXRlbS54O1xuICAgICAgICAgIGNsb25lZE9wdGlvbnMueSA9IGl0ZW0ueTtcbiAgICAgICAgICBjbG9uZWRPcHRpb25zLmFtb3VudE9mQ29ubmVjdGlvbnMgPSBpdGVtLmVkZ2VzLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1dGlsLmRlZXBFeHRlbmQoY2xvbmVkT3B0aW9ucywgaXRlbS5vcHRpb25zLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xvbmVkT3B0aW9ucztcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gTmV0d29ya1V0aWw7XG4gIH0oKTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBOZXR3b3JrVXRpbDtcblxuLyoqKi8gfSxcbi8qIDEwNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfTm9kZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1KTtcblxuICB2YXIgX05vZGUzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTm9kZTIpO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuICBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuICAvKipcbiAgICpcbiAgICovXG5cbiAgdmFyIENsdXN0ZXIgPSBmdW5jdGlvbiAoX05vZGUpIHtcbiAgICBfaW5oZXJpdHMoQ2x1c3RlciwgX05vZGUpO1xuXG4gICAgZnVuY3Rpb24gQ2x1c3RlcihvcHRpb25zLCBib2R5LCBpbWFnZWxpc3QsIGdyb3VwbGlzdCwgZ2xvYmFsT3B0aW9ucykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENsdXN0ZXIpO1xuXG4gICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ2x1c3RlcikuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBpbWFnZWxpc3QsIGdyb3VwbGlzdCwgZ2xvYmFsT3B0aW9ucykpO1xuXG4gICAgICBfdGhpcy5pc0NsdXN0ZXIgPSB0cnVlO1xuICAgICAgX3RoaXMuY29udGFpbmVkTm9kZXMgPSB7fTtcbiAgICAgIF90aGlzLmNvbnRhaW5lZEVkZ2VzID0ge307XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIENsdXN0ZXI7XG4gIH0oX05vZGUzLmRlZmF1bHQpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IENsdXN0ZXI7XG5cbi8qKiovIH0sXG4vKiAxMDUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZTtcbiAgfVxuXG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuICB2YXIgQ2FudmFzUmVuZGVyZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2FudmFzUmVuZGVyZXIoYm9keSwgY2FudmFzKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FudmFzUmVuZGVyZXIpO1xuXG4gICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG5cbiAgICAgIHRoaXMucmVkcmF3UmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLnJlbmRlclRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5yZXF1aXJlc1RpbWVvdXQgPSB0cnVlO1xuICAgICAgdGhpcy5yZW5kZXJpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICAgIHRoaXMucmVuZGVyUmVxdWVzdHMgPSAwO1xuICAgICAgdGhpcy5waXhlbFJhdGlvID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5hbGxvd1JlZHJhdyA9IHRydWU7XG5cbiAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgICAgaGlkZUVkZ2VzT25EcmFnOiBmYWxzZSxcbiAgICAgICAgaGlkZU5vZGVzT25EcmFnOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIHV0aWwuZXh0ZW5kKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgICAgIHRoaXMuX2RldGVybWluZUJyb3dzZXJNZXRob2QoKTtcbiAgICAgIHRoaXMuYmluZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKENhbnZhc1JlbmRlcmVyLCBbe1xuICAgICAga2V5OiAnYmluZEV2ZW50TGlzdGVuZXJzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJkcmFnU3RhcnRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiZHJhZ0VuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9yZXNpemVOb2Rlc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLl9yZXNpemVOb2RlcygpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfcmVkcmF3XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoX3RoaXMucmVuZGVyaW5nQWN0aXZlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgX3RoaXMuX3JlZHJhdygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2Jsb2NrUmVkcmF3XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy5hbGxvd1JlZHJhdyA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfYWxsb3dSZWRyYXdcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLmFsbG93UmVkcmF3ID0gdHJ1ZTtfdGhpcy5yZWRyYXdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX3JlcXVlc3RSZWRyYXdcIiwgdGhpcy5fcmVxdWVzdFJlZHJhdy5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfc3RhcnRSZW5kZXJpbmdcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLnJlbmRlclJlcXVlc3RzICs9IDE7XG4gICAgICAgICAgX3RoaXMucmVuZGVyaW5nQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICBfdGhpcy5fc3RhcnRSZW5kZXJpbmcoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX3N0b3BSZW5kZXJpbmdcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLnJlbmRlclJlcXVlc3RzIC09IDE7XG4gICAgICAgICAgX3RoaXMucmVuZGVyaW5nQWN0aXZlID0gX3RoaXMucmVuZGVyUmVxdWVzdHMgPiAwO1xuICAgICAgICAgIF90aGlzLnJlbmRlclRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMucmVuZGVyUmVxdWVzdHMgPSAwO1xuICAgICAgICAgIF90aGlzLmFsbG93UmVkcmF3ID0gZmFsc2U7XG4gICAgICAgICAgX3RoaXMucmVuZGVyaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgaWYgKF90aGlzLnJlcXVpcmVzVGltZW91dCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnJlbmRlclRpbWVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoX3RoaXMucmVuZGVyVGltZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfdGhpcy5ib2R5LmVtaXR0ZXIub2ZmKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NldE9wdGlvbnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIGZpZWxkcyA9IFsnaGlkZUVkZ2VzT25EcmFnJywgJ2hpZGVOb2Rlc09uRHJhZyddO1xuICAgICAgICAgIHV0aWwuc2VsZWN0aXZlRGVlcEV4dGVuZChmaWVsZHMsIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc3RhcnRSZW5kZXJpbmcnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zdGFydFJlbmRlcmluZygpIHtcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyaW5nQWN0aXZlID09PSB0cnVlKSB7XG4gICAgICAgICAgaWYgKHRoaXMucmVuZGVyVGltZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVxdWlyZXNUaW1lb3V0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHRoaXMucmVuZGVyVGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCh0aGlzLl9yZW5kZXJTdGVwLmJpbmQodGhpcyksIHRoaXMuc2ltdWxhdGlvbkludGVydmFsKTsgLy8gd2FpdCB0aGlzLnJlbmRlclRpbWVTdGVwIG1pbGxpc2Vjb25kcyBhbmQgcGVyZm9ybSB0aGUgYW5pbWF0aW9uIHN0ZXAgZnVuY3Rpb25cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJUaW1lciA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fcmVuZGVyU3RlcC5iaW5kKHRoaXMpKTsgLy8gd2FpdCB0aGlzLnJlbmRlclRpbWVTdGVwIG1pbGxpc2Vjb25kcyBhbmQgcGVyZm9ybSB0aGUgYW5pbWF0aW9uIHN0ZXAgZnVuY3Rpb25cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19yZW5kZXJTdGVwJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVuZGVyU3RlcCgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyaW5nQWN0aXZlID09PSB0cnVlKSB7XG4gICAgICAgICAgLy8gcmVzZXQgdGhlIHJlbmRlclRpbWVyIHNvIGEgbmV3IHNjaGVkdWxlZCBhbmltYXRpb24gc3RlcCBjYW4gYmUgc2V0XG4gICAgICAgICAgdGhpcy5yZW5kZXJUaW1lciA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGlmICh0aGlzLnJlcXVpcmVzVGltZW91dCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gdGhpcyBzY2hlZHVsZXMgYSBuZXcgc2ltdWxhdGlvbiBzdGVwXG4gICAgICAgICAgICB0aGlzLl9zdGFydFJlbmRlcmluZygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX3JlZHJhdygpO1xuXG4gICAgICAgICAgaWYgKHRoaXMucmVxdWlyZXNUaW1lb3V0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8gdGhpcyBzY2hlZHVsZXMgYSBuZXcgc2ltdWxhdGlvbiBzdGVwXG4gICAgICAgICAgICB0aGlzLl9zdGFydFJlbmRlcmluZygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlZHJhdyB0aGUgbmV0d29yayB3aXRoIHRoZSBjdXJyZW50IGRhdGFcbiAgICAgICAqIGNoYXJ0IHdpbGwgYmUgcmVzaXplZCB0b28uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3JlZHJhdycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVkcmF3KCkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdzZXRTaXplJyk7XG4gICAgICAgIHRoaXMuX3JlZHJhdygpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlZHJhdyB0aGUgbmV0d29yayB3aXRoIHRoZSBjdXJyZW50IGRhdGFcbiAgICAgICAqIEBwYXJhbSBoaWRkZW4gfCB1c2VkIHRvIGdldCB0aGUgZmlyc3QgZXN0aW1hdGUgb2YgdGhlIG5vZGUgc2l6ZXMuIG9ubHkgdGhlIG5vZGVzIGFyZSBkcmF3biBhZnRlciB3aGljaCB0aGV5IGFyZSBxdWlja2x5IGRyYXduIG92ZXIuXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfcmVxdWVzdFJlZHJhdycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3JlcXVlc3RSZWRyYXcoKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIGlmICh0aGlzLnJlZHJhd1JlcXVlc3RlZCAhPT0gdHJ1ZSAmJiB0aGlzLnJlbmRlcmluZ0FjdGl2ZSA9PT0gZmFsc2UgJiYgdGhpcy5hbGxvd1JlZHJhdyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMucmVkcmF3UmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAodGhpcy5yZXF1aXJlc1RpbWVvdXQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXMyLl9yZWRyYXcoZmFsc2UpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczIuX3JlZHJhdyhmYWxzZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfcmVkcmF3JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVkcmF3KCkge1xuICAgICAgICB2YXIgaGlkZGVuID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBhcmd1bWVudHNbMF07XG5cbiAgICAgICAgaWYgKHRoaXMuYWxsb3dSZWRyYXcgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiaW5pdFJlZHJhd1wiKTtcblxuICAgICAgICAgIHRoaXMucmVkcmF3UmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICAgICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgICAgLy8gd2hlbiB0aGUgY29udGFpbmVyIGRpdiB3YXMgaGlkZGVuLCB0aGlzIGZpeGVzIGl0IGJhY2sgdXAhXG4gICAgICAgICAgaWYgKHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy53aWR0aCA9PT0gMCB8fCB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5zZXRTaXplKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5waXhlbFJhdGlvID0gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIC8gKGN0eC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDEpO1xuXG4gICAgICAgICAgY3R4LnNldFRyYW5zZm9ybSh0aGlzLnBpeGVsUmF0aW8sIDAsIDAsIHRoaXMucGl4ZWxSYXRpbywgMCwgMCk7XG5cbiAgICAgICAgICAvLyBjbGVhciB0aGUgY2FudmFzXG4gICAgICAgICAgdmFyIHcgPSB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGg7XG4gICAgICAgICAgdmFyIGggPSB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdywgaCk7XG5cbiAgICAgICAgICAvLyBpZiB0aGUgZGl2IGlzIGhpZGRlbiwgd2Ugc3RvcCB0aGUgcmVkcmF3IGhlcmUgZm9yIHBlcmZvcm1hbmNlLlxuICAgICAgICAgIGlmICh0aGlzLmNhbnZhcy5mcmFtZS5jbGllbnRXaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHNldCBzY2FsaW5nIGFuZCB0cmFuc2xhdGlvblxuICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi54LCB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi55KTtcbiAgICAgICAgICBjdHguc2NhbGUodGhpcy5ib2R5LnZpZXcuc2NhbGUsIHRoaXMuYm9keS52aWV3LnNjYWxlKTtcblxuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiYmVmb3JlRHJhd2luZ1wiLCBjdHgpO1xuICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcblxuICAgICAgICAgIGlmIChoaWRkZW4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kcmFnZ2luZyA9PT0gZmFsc2UgfHwgdGhpcy5kcmFnZ2luZyA9PT0gdHJ1ZSAmJiB0aGlzLm9wdGlvbnMuaGlkZUVkZ2VzT25EcmFnID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICB0aGlzLl9kcmF3RWRnZXMoY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5kcmFnZ2luZyA9PT0gZmFsc2UgfHwgdGhpcy5kcmFnZ2luZyA9PT0gdHJ1ZSAmJiB0aGlzLm9wdGlvbnMuaGlkZU5vZGVzT25EcmFnID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5fZHJhd05vZGVzKGN0eCwgaGlkZGVuKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImFmdGVyRHJhd2luZ1wiLCBjdHgpO1xuICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcblxuICAgICAgICAgIC8vIHJlc3RvcmUgb3JpZ2luYWwgc2NhbGluZyBhbmQgdHJhbnNsYXRpb25cbiAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgIGlmIChoaWRkZW4gPT09IHRydWUpIHtcbiAgICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdywgaCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVkcmF3IGFsbCBub2Rlc1xuICAgICAgICogVGhlIDJkIGNvbnRleHQgb2YgYSBIVE1MIGNhbnZhcyBjYW4gYmUgcmV0cmlldmVkIGJ5IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICAgY3R4XG4gICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthbHdheXNTaG93XVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3Jlc2l6ZU5vZGVzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzaXplTm9kZXMoKSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgaWYgKHRoaXMucGl4ZWxSYXRpbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5waXhlbFJhdGlvID0gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIC8gKGN0eC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDEpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0odGhpcy5waXhlbFJhdGlvLCAwLCAwLCB0aGlzLnBpeGVsUmF0aW8sIDAsIDApO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLngsIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnkpO1xuICAgICAgICBjdHguc2NhbGUodGhpcy5ib2R5LnZpZXcuc2NhbGUsIHRoaXMuYm9keS52aWV3LnNjYWxlKTtcblxuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICAgIHZhciBub2RlID0gdm9pZCAwO1xuXG4gICAgICAgIC8vIHJlc2l6ZSBhbGwgbm9kZXNcbiAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIG5vZGVzKSB7XG4gICAgICAgICAgaWYgKG5vZGVzLmhhc093blByb3BlcnR5KG5vZGVJZCkpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2Rlc1tub2RlSWRdO1xuICAgICAgICAgICAgbm9kZS5yZXNpemUoY3R4KTtcbiAgICAgICAgICAgIG5vZGUudXBkYXRlQm91bmRpbmdCb3goY3R4LCBub2RlLnNlbGVjdGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXN0b3JlIG9yaWdpbmFsIHNjYWxpbmcgYW5kIHRyYW5zbGF0aW9uXG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVkcmF3IGFsbCBub2Rlc1xuICAgICAgICogVGhlIDJkIGNvbnRleHQgb2YgYSBIVE1MIGNhbnZhcyBjYW4gYmUgcmV0cmlldmVkIGJ5IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICAgY3R4XG4gICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthbHdheXNTaG93XVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2RyYXdOb2RlcycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdOb2RlcyhjdHgpIHtcbiAgICAgICAgdmFyIGFsd2F5c1Nob3cgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICAgIHZhciBub2RlSW5kaWNlcyA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcztcbiAgICAgICAgdmFyIG5vZGUgPSB2b2lkIDA7XG4gICAgICAgIHZhciBzZWxlY3RlZCA9IFtdO1xuICAgICAgICB2YXIgbWFyZ2luID0gMjA7XG4gICAgICAgIHZhciB0b3BMZWZ0ID0gdGhpcy5jYW52YXMuRE9NdG9DYW52YXMoeyB4OiAtbWFyZ2luLCB5OiAtbWFyZ2luIH0pO1xuICAgICAgICB2YXIgYm90dG9tUmlnaHQgPSB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyh7XG4gICAgICAgICAgeDogdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoICsgbWFyZ2luLFxuICAgICAgICAgIHk6IHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHQgKyBtYXJnaW5cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB2aWV3YWJsZUFyZWEgPSB7IHRvcDogdG9wTGVmdC55LCBsZWZ0OiB0b3BMZWZ0LngsIGJvdHRvbTogYm90dG9tUmlnaHQueSwgcmlnaHQ6IGJvdHRvbVJpZ2h0LnggfTtcblxuICAgICAgICAvLyBkcmF3IHVuc2VsZWN0ZWQgbm9kZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBub2RlID0gbm9kZXNbbm9kZUluZGljZXNbaV1dO1xuICAgICAgICAgIC8vIHNldCBzZWxlY3RlZCBub2RlcyBhc2lkZVxuICAgICAgICAgIGlmIChub2RlLmlzU2VsZWN0ZWQoKSkge1xuICAgICAgICAgICAgc2VsZWN0ZWQucHVzaChub2RlSW5kaWNlc1tpXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhbHdheXNTaG93ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIG5vZGUuZHJhdyhjdHgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLmlzQm91bmRpbmdCb3hPdmVybGFwcGluZ1dpdGgodmlld2FibGVBcmVhKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICBub2RlLmRyYXcoY3R4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5vZGUudXBkYXRlQm91bmRpbmdCb3goY3R4LCBub2RlLnNlbGVjdGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkcmF3IHRoZSBzZWxlY3RlZCBub2RlcyBvbiB0b3BcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHNlbGVjdGVkLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIG5vZGUgPSBub2Rlc1tzZWxlY3RlZFtfaV1dO1xuICAgICAgICAgIG5vZGUuZHJhdyhjdHgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVkcmF3IGFsbCBlZGdlc1xuICAgICAgICogVGhlIDJkIGNvbnRleHQgb2YgYSBIVE1MIGNhbnZhcyBjYW4gYmUgcmV0cmlldmVkIGJ5IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICAgY3R4XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZHJhd0VkZ2VzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd0VkZ2VzKGN0eCkge1xuICAgICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gICAgICAgIHZhciBlZGdlSW5kaWNlcyA9IHRoaXMuYm9keS5lZGdlSW5kaWNlcztcbiAgICAgICAgdmFyIGVkZ2UgPSB2b2lkIDA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGVkZ2UgPSBlZGdlc1tlZGdlSW5kaWNlc1tpXV07XG4gICAgICAgICAgaWYgKGVkZ2UuY29ubmVjdGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICBlZGdlLmRyYXcoY3R4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBEZXRlcm1pbmUgaWYgdGhlIGJyb3dzZXIgcmVxdWlyZXMgYSBzZXRUaW1lb3V0IG9yIGEgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLiBUaGlzIHdhcyByZXF1aXJlZCBiZWNhdXNlXG4gICAgICAgKiBzb21lIGltcGxlbWVudGF0aW9ucyAoc2FmYXJpIGFuZCBJRTkpIGRpZCBub3Qgc3VwcG9ydCByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19kZXRlcm1pbmVCcm93c2VyTWV0aG9kJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZGV0ZXJtaW5lQnJvd3Nlck1ldGhvZCgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdmFyIGJyb3dzZXJUeXBlID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIHRoaXMucmVxdWlyZXNUaW1lb3V0ID0gZmFsc2U7XG4gICAgICAgICAgaWYgKGJyb3dzZXJUeXBlLmluZGV4T2YoJ21zaWUgOS4wJykgIT0gLTEpIHtcbiAgICAgICAgICAgIC8vIElFIDlcbiAgICAgICAgICAgIHRoaXMucmVxdWlyZXNUaW1lb3V0ID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGJyb3dzZXJUeXBlLmluZGV4T2YoJ3NhZmFyaScpICE9IC0xKSB7XG4gICAgICAgICAgICAvLyBzYWZhcmlcbiAgICAgICAgICAgIGlmIChicm93c2VyVHlwZS5pbmRleE9mKCdjaHJvbWUnKSA8PSAtMSkge1xuICAgICAgICAgICAgICB0aGlzLnJlcXVpcmVzVGltZW91dCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVxdWlyZXNUaW1lb3V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBDYW52YXNSZW5kZXJlcjtcbiAgfSgpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IENhbnZhc1JlbmRlcmVyO1xuXG4vKioqLyB9LFxuLyogMTA2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIHZhciBIYW1tZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcbiAgdmFyIGhhbW1lclV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcblxuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgbWFpbiBmcmFtZSBmb3IgdGhlIE5ldHdvcmsuXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgb25jZSB3aGVuIGEgTmV0d29yayBvYmplY3QgaXMgY3JlYXRlZC4gVGhlIGZyYW1lXG4gICAqIGNvbnRhaW5zIGEgY2FudmFzLCBhbmQgdGhpcyBjYW52YXMgY29udGFpbnMgYWxsIG9iamVjdHMgbGlrZSB0aGUgYXhpcyBhbmRcbiAgICogbm9kZXMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHZhciBDYW52YXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2FudmFzKGJvZHkpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYW52YXMpO1xuXG4gICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgdGhpcy5waXhlbFJhdGlvID0gMTtcbiAgICAgIHRoaXMucmVzaXplVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnJlc2l6ZUZ1bmN0aW9uID0gdGhpcy5fb25SZXNpemUuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuY2FtZXJhU3RhdGUgPSB7fTtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgICBhdXRvUmVzaXplOiB0cnVlLFxuICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgd2lkdGg6ICcxMDAlJ1xuICAgICAgfTtcbiAgICAgIHV0aWwuZXh0ZW5kKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgICAgIHRoaXMuYmluZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKENhbnZhcywgW3tcbiAgICAgIGtleTogJ2JpbmRFdmVudExpc3RlbmVycycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIC8vIGJpbmQgdGhlIGV2ZW50c1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbmNlKFwicmVzaXplXCIsIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICBpZiAob2JqLndpZHRoICE9PSAwKSB7XG4gICAgICAgICAgICBfdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueCA9IG9iai53aWR0aCAqIDAuNTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iai5oZWlnaHQgIT09IDApIHtcbiAgICAgICAgICAgIF90aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi55ID0gb2JqLmhlaWdodCAqIDAuNTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcInNldFNpemVcIiwgdGhpcy5zZXRTaXplLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImRlc3Ryb3lcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLmhhbW1lckZyYW1lLmRlc3Ryb3koKTtcbiAgICAgICAgICBfdGhpcy5oYW1tZXIuZGVzdHJveSgpO1xuICAgICAgICAgIF90aGlzLl9jbGVhblVwKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NldE9wdGlvbnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIGZpZWxkcyA9IFsnd2lkdGgnLCAnaGVpZ2h0JywgJ2F1dG9SZXNpemUnXTtcbiAgICAgICAgICB1dGlsLnNlbGVjdGl2ZURlZXBFeHRlbmQoZmllbGRzLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvUmVzaXplID09PSB0cnVlKSB7XG4gICAgICAgICAgLy8gYXV0b21hdGljYWxseSBhZGFwdCB0byBhIGNoYW5naW5nIHNpemUgb2YgdGhlIGJyb3dzZXIuXG4gICAgICAgICAgdGhpcy5fY2xlYW5VcCgpO1xuICAgICAgICAgIHRoaXMucmVzaXplVGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2hhbmdlZCA9IF90aGlzMi5zZXRTaXplKCk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICBfdGhpczIuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgICB0aGlzLnJlc2l6ZUZ1bmN0aW9uID0gdGhpcy5fb25SZXNpemUuYmluZCh0aGlzKTtcbiAgICAgICAgICB1dGlsLmFkZEV2ZW50TGlzdGVuZXIod2luZG93LCAncmVzaXplJywgdGhpcy5yZXNpemVGdW5jdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY2xlYW5VcCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NsZWFuVXAoKSB7XG4gICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgYWRhcHQgdG8gYSBjaGFuZ2luZyBzaXplIG9mIHRoZSBicm93c2VyLlxuICAgICAgICBpZiAodGhpcy5yZXNpemVUaW1lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnJlc2l6ZVRpbWVyKTtcbiAgICAgICAgfVxuICAgICAgICB1dGlsLnJlbW92ZUV2ZW50TGlzdGVuZXIod2luZG93LCAncmVzaXplJywgdGhpcy5yZXNpemVGdW5jdGlvbik7XG4gICAgICAgIHRoaXMucmVzaXplRnVuY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX29uUmVzaXplJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25SZXNpemUoKSB7XG4gICAgICAgIHRoaXMuc2V0U2l6ZSgpO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlZHJhd1wiKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBHZXQgYW5kIHN0b3JlIHRoZSBjYW1lcmFTdGF0ZVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2dldENhbWVyYVN0YXRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q2FtZXJhU3RhdGUoKSB7XG4gICAgICAgIHZhciBwaXhlbFJhdGlvID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gdGhpcy5waXhlbFJhdGlvIDogYXJndW1lbnRzWzBdO1xuXG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxpemVkID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5jYW1lcmFTdGF0ZS5wcmV2aW91c1dpZHRoID0gdGhpcy5mcmFtZS5jYW52YXMud2lkdGggLyBwaXhlbFJhdGlvO1xuICAgICAgICAgIHRoaXMuY2FtZXJhU3RhdGUucHJldmlvdXNIZWlnaHQgPSB0aGlzLmZyYW1lLmNhbnZhcy5oZWlnaHQgLyBwaXhlbFJhdGlvO1xuICAgICAgICAgIHRoaXMuY2FtZXJhU3RhdGUuc2NhbGUgPSB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgICAgICB0aGlzLmNhbWVyYVN0YXRlLnBvc2l0aW9uID0gdGhpcy5ET010b0NhbnZhcyh7XG4gICAgICAgICAgICB4OiAwLjUgKiB0aGlzLmZyYW1lLmNhbnZhcy53aWR0aCAvIHBpeGVsUmF0aW8sXG4gICAgICAgICAgICB5OiAwLjUgKiB0aGlzLmZyYW1lLmNhbnZhcy5oZWlnaHQgLyBwaXhlbFJhdGlvXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXQgdGhlIGNhbWVyYVN0YXRlXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc2V0Q2FtZXJhU3RhdGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRDYW1lcmFTdGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FtZXJhU3RhdGUuc2NhbGUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCAhPT0gMCAmJiB0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHQgIT09IDAgJiYgdGhpcy5waXhlbFJhdGlvICE9PSAwICYmIHRoaXMuY2FtZXJhU3RhdGUucHJldmlvdXNXaWR0aCA+IDApIHtcblxuICAgICAgICAgIHZhciB3aWR0aFJhdGlvID0gdGhpcy5mcmFtZS5jYW52YXMud2lkdGggLyB0aGlzLnBpeGVsUmF0aW8gLyB0aGlzLmNhbWVyYVN0YXRlLnByZXZpb3VzV2lkdGg7XG4gICAgICAgICAgdmFyIGhlaWdodFJhdGlvID0gdGhpcy5mcmFtZS5jYW52YXMuaGVpZ2h0IC8gdGhpcy5waXhlbFJhdGlvIC8gdGhpcy5jYW1lcmFTdGF0ZS5wcmV2aW91c0hlaWdodDtcbiAgICAgICAgICB2YXIgbmV3U2NhbGUgPSB0aGlzLmNhbWVyYVN0YXRlLnNjYWxlO1xuXG4gICAgICAgICAgaWYgKHdpZHRoUmF0aW8gIT0gMSAmJiBoZWlnaHRSYXRpbyAhPSAxKSB7XG4gICAgICAgICAgICBuZXdTY2FsZSA9IHRoaXMuY2FtZXJhU3RhdGUuc2NhbGUgKiAwLjUgKiAod2lkdGhSYXRpbyArIGhlaWdodFJhdGlvKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHdpZHRoUmF0aW8gIT0gMSkge1xuICAgICAgICAgICAgbmV3U2NhbGUgPSB0aGlzLmNhbWVyYVN0YXRlLnNjYWxlICogd2lkdGhSYXRpbztcbiAgICAgICAgICB9IGVsc2UgaWYgKGhlaWdodFJhdGlvICE9IDEpIHtcbiAgICAgICAgICAgIG5ld1NjYWxlID0gdGhpcy5jYW1lcmFTdGF0ZS5zY2FsZSAqIGhlaWdodFJhdGlvO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuYm9keS52aWV3LnNjYWxlID0gbmV3U2NhbGU7XG4gICAgICAgICAgLy8gdGhpcyBjb21lcyBmcm9tIHRoZSB2aWV3IG1vZHVsZS5cbiAgICAgICAgICB2YXIgY3VycmVudFZpZXdDZW50ZXIgPSB0aGlzLkRPTXRvQ2FudmFzKHtcbiAgICAgICAgICAgIHg6IDAuNSAqIHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgeTogMC41ICogdGhpcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgZGlzdGFuY2VGcm9tQ2VudGVyID0geyAvLyBvZmZzZXQgZnJvbSB2aWV3LCBkaXN0YW5jZSB2aWV3IGhhcyB0byBjaGFuZ2UgYnkgdGhlc2UgeCBhbmQgeSB0byBjZW50ZXIgdGhlIG5vZGVcbiAgICAgICAgICAgIHg6IGN1cnJlbnRWaWV3Q2VudGVyLnggLSB0aGlzLmNhbWVyYVN0YXRlLnBvc2l0aW9uLngsXG4gICAgICAgICAgICB5OiBjdXJyZW50Vmlld0NlbnRlci55IC0gdGhpcy5jYW1lcmFTdGF0ZS5wb3NpdGlvbi55XG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi54ICs9IGRpc3RhbmNlRnJvbUNlbnRlci54ICogdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueSArPSBkaXN0YW5jZUZyb21DZW50ZXIueSAqIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX3ByZXBhcmVWYWx1ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3ByZXBhcmVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHJldHVybiB2YWx1ZSArICdweCc7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmICh2YWx1ZS5pbmRleE9mKCclJykgIT09IC0xIHx8IHZhbHVlLmluZGV4T2YoJ3B4JykgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZS5pbmRleE9mKCclJykgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgKyAncHgnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCB1c2UgdGhlIHZhbHVlIHN1cHBsaWVkIGZvciB3aWR0aCBvciBoZWlnaHQ6JyArIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGUgdGhlIEhUTUxcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2NyZWF0ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZSgpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGFsbCBlbGVtZW50cyBmcm9tIHRoZSBjb250YWluZXIgZWxlbWVudC5cbiAgICAgICAgd2hpbGUgKHRoaXMuYm9keS5jb250YWluZXIuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmNvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLmJvZHkuY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmZyYW1lLmNsYXNzTmFtZSA9ICd2aXMtbmV0d29yayc7XG4gICAgICAgIHRoaXMuZnJhbWUuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICB0aGlzLmZyYW1lLnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICAgIHRoaXMuZnJhbWUudGFiSW5kZXggPSA5MDA7IC8vIHRhYiBpbmRleCBpcyByZXF1aXJlZCBmb3Iga2V5Y2hhcm0gdG8gYmluZCBrZXlzdHJva2VzIHRvIHRoZSBkaXYgaW5zdGVhZCBvZiB0aGUgd2luZG93XG5cbiAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgICAgdGhpcy5mcmFtZS5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICB0aGlzLmZyYW1lLmNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5mcmFtZS5jYW52YXMpO1xuXG4gICAgICAgIGlmICghdGhpcy5mcmFtZS5jYW52YXMuZ2V0Q29udGV4dCkge1xuICAgICAgICAgIHZhciBub0NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICAgICAgICAgIG5vQ2FudmFzLnN0eWxlLmNvbG9yID0gJ3JlZCc7XG4gICAgICAgICAgbm9DYW52YXMuc3R5bGUuZm9udFdlaWdodCA9ICdib2xkJztcbiAgICAgICAgICBub0NhbnZhcy5zdHlsZS5wYWRkaW5nID0gJzEwcHgnO1xuICAgICAgICAgIG5vQ2FudmFzLmlubmVySFRNTCA9ICdFcnJvcjogeW91ciBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgSFRNTCBjYW52YXMnO1xuICAgICAgICAgIHRoaXMuZnJhbWUuY2FudmFzLmFwcGVuZENoaWxkKG5vQ2FudmFzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5mcmFtZS5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICAgIHRoaXMucGl4ZWxSYXRpbyA9ICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSAvIChjdHgud2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHguYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCAxKTtcblxuICAgICAgICAgIHRoaXMuZnJhbWUuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKS5zZXRUcmFuc2Zvcm0odGhpcy5waXhlbFJhdGlvLCAwLCAwLCB0aGlzLnBpeGVsUmF0aW8sIDAsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHRoZSBmcmFtZSB0byB0aGUgY29udGFpbmVyIGVsZW1lbnRcbiAgICAgICAgdGhpcy5ib2R5LmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmZyYW1lKTtcblxuICAgICAgICB0aGlzLmJvZHkudmlldy5zY2FsZSA9IDE7XG4gICAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uID0geyB4OiAwLjUgKiB0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCwgeTogMC41ICogdGhpcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0IH07XG5cbiAgICAgICAgdGhpcy5fYmluZEhhbW1lcigpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgZnVuY3Rpb24gYmluZHMgaGFtbWVyLCBpdCBjYW4gYmUgcmVwZWF0ZWQgb3ZlciBhbmQgb3ZlciBkdWUgdG8gdGhlIHVuaXF1ZW5lc3MgY2hlY2suXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfYmluZEhhbW1lcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2JpbmRIYW1tZXIoKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIGlmICh0aGlzLmhhbW1lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5oYW1tZXIuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHJhZyA9IHt9O1xuICAgICAgICB0aGlzLnBpbmNoID0ge307XG5cbiAgICAgICAgLy8gaW5pdCBoYW1tZXJcbiAgICAgICAgdGhpcy5oYW1tZXIgPSBuZXcgSGFtbWVyKHRoaXMuZnJhbWUuY2FudmFzKTtcbiAgICAgICAgdGhpcy5oYW1tZXIuZ2V0KCdwaW5jaCcpLnNldCh7IGVuYWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgLy8gZW5hYmxlIHRvIGdldCBiZXR0ZXIgcmVzcG9uc2UsIHRvZG86IHRlc3Qgb24gbW9iaWxlLlxuICAgICAgICB0aGlzLmhhbW1lci5nZXQoJ3BhbicpLnNldCh7IHRocmVzaG9sZDogNSwgZGlyZWN0aW9uOiBIYW1tZXIuRElSRUNUSU9OX0FMTCB9KTtcblxuICAgICAgICBoYW1tZXJVdGlsLm9uVG91Y2godGhpcy5oYW1tZXIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uVG91Y2goZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5oYW1tZXIub24oJ3RhcCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uVGFwKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGFtbWVyLm9uKCdkb3VibGV0YXAnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vbkRvdWJsZVRhcChldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhhbW1lci5vbigncHJlc3MnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vbkhvbGQoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5oYW1tZXIub24oJ3BhbnN0YXJ0JywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25EcmFnU3RhcnQoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5oYW1tZXIub24oJ3Bhbm1vdmUnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vbkRyYWcoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5oYW1tZXIub24oJ3BhbmVuZCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uRHJhZ0VuZChldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhhbW1lci5vbigncGluY2gnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vblBpbmNoKGV2ZW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVE9ETzogbmVhdGx5IGNsZWFudXAgdGhlc2UgaGFuZGxlcnMgd2hlbiByZS1jcmVhdGluZyB0aGUgQ2FudmFzLCBJRiB0aGVzZSBhcmUgZG9uZSB3aXRoIGhhbW1lciwgZXZlbnQuc3RvcFByb3BhZ2F0aW9uIHdpbGwgbm90IHdvcms/XG4gICAgICAgIHRoaXMuZnJhbWUuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vbk1vdXNlV2hlZWwoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5mcmFtZS5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vbk1vdXNlV2hlZWwoZXZlbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmZyYW1lLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vbk1vdXNlTW92ZShldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZyYW1lLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uQ29udGV4dChldmVudCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuaGFtbWVyRnJhbWUgPSBuZXcgSGFtbWVyKHRoaXMuZnJhbWUpO1xuICAgICAgICBoYW1tZXJVdGlsLm9uUmVsZWFzZSh0aGlzLmhhbW1lckZyYW1lLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vblJlbGVhc2UoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXQgYSBuZXcgc2l6ZSBmb3IgdGhlIG5ldHdvcmtcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3aWR0aCAgIFdpZHRoIGluIHBpeGVscyBvciBwZXJjZW50YWdlIChmb3IgZXhhbXBsZSAnODAwcHgnXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBvciAnNTAlJylcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBoZWlnaHQgIEhlaWdodCBpbiBwaXhlbHMgb3IgcGVyY2VudGFnZSAgKGZvciBleGFtcGxlICc0MDBweCdcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgIG9yICczMCUnKVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzZXRTaXplJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTaXplKCkge1xuICAgICAgICB2YXIgd2lkdGggPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB0aGlzLm9wdGlvbnMud2lkdGggOiBhcmd1bWVudHNbMF07XG4gICAgICAgIHZhciBoZWlnaHQgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB0aGlzLm9wdGlvbnMuaGVpZ2h0IDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgIHdpZHRoID0gdGhpcy5fcHJlcGFyZVZhbHVlKHdpZHRoKTtcbiAgICAgICAgaGVpZ2h0ID0gdGhpcy5fcHJlcGFyZVZhbHVlKGhlaWdodCk7XG5cbiAgICAgICAgdmFyIGVtaXRFdmVudCA9IGZhbHNlO1xuICAgICAgICB2YXIgb2xkV2lkdGggPSB0aGlzLmZyYW1lLmNhbnZhcy53aWR0aDtcbiAgICAgICAgdmFyIG9sZEhlaWdodCA9IHRoaXMuZnJhbWUuY2FudmFzLmhlaWdodDtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHBpeGVsIHJhdGlvXG4gICAgICAgIHZhciBjdHggPSB0aGlzLmZyYW1lLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgIHZhciBwcmV2aW91c1JhdGlvID0gdGhpcy5waXhlbFJhdGlvOyAvLyB3ZSBjYWNoZSB0aGlzIGJlY2F1c2UgdGhlIGNhbWVyYSBzdGF0ZSBzdG9yYWdlIG5lZWRzIHRoZSBvbGQgdmFsdWVcbiAgICAgICAgdGhpcy5waXhlbFJhdGlvID0gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIC8gKGN0eC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDEpO1xuXG4gICAgICAgIGlmICh3aWR0aCAhPSB0aGlzLm9wdGlvbnMud2lkdGggfHwgaGVpZ2h0ICE9IHRoaXMub3B0aW9ucy5oZWlnaHQgfHwgdGhpcy5mcmFtZS5zdHlsZS53aWR0aCAhPSB3aWR0aCB8fCB0aGlzLmZyYW1lLnN0eWxlLmhlaWdodCAhPSBoZWlnaHQpIHtcbiAgICAgICAgICB0aGlzLl9nZXRDYW1lcmFTdGF0ZShwcmV2aW91c1JhdGlvKTtcblxuICAgICAgICAgIHRoaXMuZnJhbWUuc3R5bGUud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICB0aGlzLmZyYW1lLnN0eWxlLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAgIHRoaXMuZnJhbWUuY2FudmFzLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICAgIHRoaXMuZnJhbWUuY2FudmFzLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcblxuICAgICAgICAgIHRoaXMuZnJhbWUuY2FudmFzLndpZHRoID0gTWF0aC5yb3VuZCh0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCAqIHRoaXMucGl4ZWxSYXRpbyk7XG4gICAgICAgICAgdGhpcy5mcmFtZS5jYW52YXMuaGVpZ2h0ID0gTWF0aC5yb3VuZCh0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW8pO1xuXG4gICAgICAgICAgdGhpcy5vcHRpb25zLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAgIGVtaXRFdmVudCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdGhpcyB3b3VsZCBhZGFwdCB0aGUgd2lkdGggb2YgdGhlIGNhbnZhcyB0byB0aGUgd2lkdGggZnJvbSAxMDAlIGlmIGFuZCBvbmx5IGlmXG4gICAgICAgICAgLy8gdGhlcmUgaXMgYSBjaGFuZ2UuXG5cbiAgICAgICAgICAvLyBzdG9yZSB0aGUgY2FtZXJhIGlmIHRoZXJlIGlzIGEgY2hhbmdlIGluIHNpemUuXG4gICAgICAgICAgaWYgKHRoaXMuZnJhbWUuY2FudmFzLndpZHRoICE9IE1hdGgucm91bmQodGhpcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGggKiB0aGlzLnBpeGVsUmF0aW8pIHx8IHRoaXMuZnJhbWUuY2FudmFzLmhlaWdodCAhPSBNYXRoLnJvdW5kKHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodCAqIHRoaXMucGl4ZWxSYXRpbykpIHtcbiAgICAgICAgICAgIHRoaXMuX2dldENhbWVyYVN0YXRlKHByZXZpb3VzUmF0aW8pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLmZyYW1lLmNhbnZhcy53aWR0aCAhPSBNYXRoLnJvdW5kKHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoICogdGhpcy5waXhlbFJhdGlvKSkge1xuICAgICAgICAgICAgdGhpcy5mcmFtZS5jYW52YXMud2lkdGggPSBNYXRoLnJvdW5kKHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoICogdGhpcy5waXhlbFJhdGlvKTtcbiAgICAgICAgICAgIGVtaXRFdmVudCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLmZyYW1lLmNhbnZhcy5oZWlnaHQgIT0gTWF0aC5yb3VuZCh0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW8pKSB7XG4gICAgICAgICAgICB0aGlzLmZyYW1lLmNhbnZhcy5oZWlnaHQgPSBNYXRoLnJvdW5kKHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodCAqIHRoaXMucGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICBlbWl0RXZlbnQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbWl0RXZlbnQgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdyZXNpemUnLCB7XG4gICAgICAgICAgICB3aWR0aDogTWF0aC5yb3VuZCh0aGlzLmZyYW1lLmNhbnZhcy53aWR0aCAvIHRoaXMucGl4ZWxSYXRpbyksXG4gICAgICAgICAgICBoZWlnaHQ6IE1hdGgucm91bmQodGhpcy5mcmFtZS5jYW52YXMuaGVpZ2h0IC8gdGhpcy5waXhlbFJhdGlvKSxcbiAgICAgICAgICAgIG9sZFdpZHRoOiBNYXRoLnJvdW5kKG9sZFdpZHRoIC8gdGhpcy5waXhlbFJhdGlvKSxcbiAgICAgICAgICAgIG9sZEhlaWdodDogTWF0aC5yb3VuZChvbGRIZWlnaHQgLyB0aGlzLnBpeGVsUmF0aW8pXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyByZXN0b3JlIHRoZSBjYW1lcmEgb24gY2hhbmdlLlxuICAgICAgICAgIHRoaXMuX3NldENhbWVyYVN0YXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgaW5pdGlhbGl6ZWQgc28gdGhlIGdldCBhbmQgc2V0IGNhbWVyYSB3aWxsIHdvcmsgZnJvbSBub3cgb24uXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZW1pdEV2ZW50O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19YY29udmVydERPTXRvQ2FudmFzJyxcblxuXG4gICAgICAvKipcbiAgICAgICAqIENvbnZlcnQgdGhlIFggY29vcmRpbmF0ZSBpbiBET00tc3BhY2UgKGNvb3JkaW5hdGUgcG9pbnQgaW4gYnJvd3NlciByZWxhdGl2ZSB0byB0aGUgY29udGFpbmVyIGRpdikgdG9cbiAgICAgICAqIHRoZSBYIGNvb3JkaW5hdGUgaW4gY2FudmFzLXNwYWNlICh0aGUgc2ltdWxhdGlvbiBzYW5kYm94LCB3aGljaCB0aGUgY2FtZXJhIGxvb2tzIHVwb24pXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfWGNvbnZlcnRET010b0NhbnZhcyh4KSB7XG4gICAgICAgIHJldHVybiAoeCAtIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLngpIC8gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29udmVydCB0aGUgWCBjb29yZGluYXRlIGluIGNhbnZhcy1zcGFjZSAodGhlIHNpbXVsYXRpb24gc2FuZGJveCwgd2hpY2ggdGhlIGNhbWVyYSBsb29rcyB1cG9uKSB0b1xuICAgICAgICogdGhlIFggY29vcmRpbmF0ZSBpbiBET00tc3BhY2UgKGNvb3JkaW5hdGUgcG9pbnQgaW4gYnJvd3NlciByZWxhdGl2ZSB0byB0aGUgY29udGFpbmVyIGRpdilcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX1hjb252ZXJ0Q2FudmFzVG9ET00nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9YY29udmVydENhbnZhc1RvRE9NKHgpIHtcbiAgICAgICAgcmV0dXJuIHggKiB0aGlzLmJvZHkudmlldy5zY2FsZSArIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLng7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29udmVydCB0aGUgWSBjb29yZGluYXRlIGluIERPTS1zcGFjZSAoY29vcmRpbmF0ZSBwb2ludCBpbiBicm93c2VyIHJlbGF0aXZlIHRvIHRoZSBjb250YWluZXIgZGl2KSB0b1xuICAgICAgICogdGhlIFkgY29vcmRpbmF0ZSBpbiBjYW52YXMtc3BhY2UgKHRoZSBzaW11bGF0aW9uIHNhbmRib3gsIHdoaWNoIHRoZSBjYW1lcmEgbG9va3MgdXBvbilcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX1ljb252ZXJ0RE9NdG9DYW52YXMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9ZY29udmVydERPTXRvQ2FudmFzKHkpIHtcbiAgICAgICAgcmV0dXJuICh5IC0gdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueSkgLyB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDb252ZXJ0IHRoZSBZIGNvb3JkaW5hdGUgaW4gY2FudmFzLXNwYWNlICh0aGUgc2ltdWxhdGlvbiBzYW5kYm94LCB3aGljaCB0aGUgY2FtZXJhIGxvb2tzIHVwb24pIHRvXG4gICAgICAgKiB0aGUgWSBjb29yZGluYXRlIGluIERPTS1zcGFjZSAoY29vcmRpbmF0ZSBwb2ludCBpbiBicm93c2VyIHJlbGF0aXZlIHRvIHRoZSBjb250YWluZXIgZGl2KVxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfWWNvbnZlcnRDYW52YXNUb0RPTScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX1ljb252ZXJ0Q2FudmFzVG9ET00oeSkge1xuICAgICAgICByZXR1cm4geSAqIHRoaXMuYm9keS52aWV3LnNjYWxlICsgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IHBvcyAgID0ge3g6IG51bWJlciwgeTogbnVtYmVyfVxuICAgICAgICogQHJldHVybnMge3t4OiBudW1iZXIsIHk6IG51bWJlcn19XG4gICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnY2FudmFzVG9ET00nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNhbnZhc1RvRE9NKHBvcykge1xuICAgICAgICByZXR1cm4geyB4OiB0aGlzLl9YY29udmVydENhbnZhc1RvRE9NKHBvcy54KSwgeTogdGhpcy5fWWNvbnZlcnRDYW52YXNUb0RPTShwb3MueSkgfTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IHBvcyAgID0ge3g6IG51bWJlciwgeTogbnVtYmVyfVxuICAgICAgICogQHJldHVybnMge3t4OiBudW1iZXIsIHk6IG51bWJlcn19XG4gICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnRE9NdG9DYW52YXMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIERPTXRvQ2FudmFzKHBvcykge1xuICAgICAgICByZXR1cm4geyB4OiB0aGlzLl9YY29udmVydERPTXRvQ2FudmFzKHBvcy54KSwgeTogdGhpcy5fWWNvbnZlcnRET010b0NhbnZhcyhwb3MueSkgfTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQ2FudmFzO1xuICB9KCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gQ2FudmFzO1xuXG4vKioqLyB9LFxuLyogMTA3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX05ldHdvcmtVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDMpO1xuXG4gIHZhciBfTmV0d29ya1V0aWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTmV0d29ya1V0aWwpO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbiAgdmFyIFZpZXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVmlldyhib2R5LCBjYW52YXMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBWaWV3KTtcblxuICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuXG4gICAgICB0aGlzLmFuaW1hdGlvblNwZWVkID0gMSAvIHRoaXMucmVuZGVyUmVmcmVzaFJhdGU7XG4gICAgICB0aGlzLmFuaW1hdGlvbkVhc2luZ0Z1bmN0aW9uID0gXCJlYXNlSW5PdXRRdWludFwiO1xuICAgICAgdGhpcy5lYXNpbmdUaW1lID0gMDtcbiAgICAgIHRoaXMuc291cmNlU2NhbGUgPSAwO1xuICAgICAgdGhpcy50YXJnZXRTY2FsZSA9IDA7XG4gICAgICB0aGlzLnNvdXJjZVRyYW5zbGF0aW9uID0gMDtcbiAgICAgIHRoaXMudGFyZ2V0VHJhbnNsYXRpb24gPSAwO1xuICAgICAgdGhpcy5sb2NrZWRPbk5vZGVJZCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMubG9ja2VkT25Ob2RlT2Zmc2V0ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy50b3VjaFRpbWUgPSAwO1xuXG4gICAgICB0aGlzLnZpZXdGdW5jdGlvbiA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJmaXRcIiwgdGhpcy5maXQuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImFuaW1hdGlvbkZpbmlzaGVkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfc3RvcFJlbmRlcmluZ1wiKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJ1bmxvY2tOb2RlXCIsIHRoaXMucmVsZWFzZU5vZGUuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFZpZXcsIFt7XG4gICAgICBrZXk6ICdzZXRPcHRpb25zJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBmdW5jdGlvbiB6b29tcyBvdXQgdG8gZml0IGFsbCBkYXRhIG9uIHNjcmVlbiBiYXNlZCBvbiBhbW91bnQgb2Ygbm9kZXNcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBPcHRpb25zXG4gICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbml0aWFsWm9vbV0gIHwgem9vbSBiYXNlZCBvbiBmaXR0ZWQgZm9ybXVsYSBvciByYW5nZSwgdHJ1ZSA9IGZpdHRlZCwgZGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdmaXQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpdCgpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7IG5vZGVzOiBbXSB9IDogYXJndW1lbnRzWzBdO1xuICAgICAgICB2YXIgaW5pdGlhbFpvb20gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICB2YXIgcmFuZ2UgPSB2b2lkIDA7XG4gICAgICAgIHZhciB6b29tTGV2ZWwgPSB2b2lkIDA7XG4gICAgICAgIGlmIChvcHRpb25zLm5vZGVzID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5ub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBvcHRpb25zLm5vZGVzID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluaXRpYWxab29tID09PSB0cnVlKSB7XG4gICAgICAgICAgLy8gY2hlY2sgaWYgbW9yZSB0aGFuIGhhbGYgb2YgdGhlIG5vZGVzIGhhdmUgYSBwcmVkZWZpbmVkIHBvc2l0aW9uLiBJZiBzbywgd2UgdXNlIHRoZSByYW5nZSwgbm90IHRoZSBhcHByb3hpbWF0aW9uLlxuICAgICAgICAgIHZhciBwb3NpdGlvbkRlZmluZWQgPSAwO1xuICAgICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiB0aGlzLmJvZHkubm9kZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgICAgICAgICBpZiAobm9kZS5wcmVkZWZpbmVkUG9zaXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkRlZmluZWQgKz0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocG9zaXRpb25EZWZpbmVkID4gMC41ICogdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5maXQob3B0aW9ucywgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJhbmdlID0gX05ldHdvcmtVdGlsMi5kZWZhdWx0LmdldFJhbmdlKHRoaXMuYm9keS5ub2Rlcywgb3B0aW9ucy5ub2Rlcyk7XG5cbiAgICAgICAgICB2YXIgbnVtYmVyT2ZOb2RlcyA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGg7XG4gICAgICAgICAgem9vbUxldmVsID0gMTIuNjYyIC8gKG51bWJlck9mTm9kZXMgKyA3LjQxNDcpICsgMC4wOTY0ODIyOyAvLyB0aGlzIGlzIG9idGFpbmVkIGZyb20gZml0dGluZyBhIGRhdGFzZXQgZnJvbSA1IHBvaW50cyB3aXRoIHNjYWxlIGxldmVscyB0aGF0IGxvb2tlZCBnb29kLlxuXG4gICAgICAgICAgLy8gY29ycmVjdCBmb3IgbGFyZ2VyIGNhbnZhc3Nlcy5cbiAgICAgICAgICB2YXIgZmFjdG9yID0gTWF0aC5taW4odGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoIC8gNjAwLCB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0IC8gNjAwKTtcbiAgICAgICAgICB6b29tTGV2ZWwgKj0gZmFjdG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVzaXplTm9kZXNcIik7XG4gICAgICAgICAgcmFuZ2UgPSBfTmV0d29ya1V0aWwyLmRlZmF1bHQuZ2V0UmFuZ2UodGhpcy5ib2R5Lm5vZGVzLCBvcHRpb25zLm5vZGVzKTtcblxuICAgICAgICAgIHZhciB4RGlzdGFuY2UgPSBNYXRoLmFicyhyYW5nZS5tYXhYIC0gcmFuZ2UubWluWCkgKiAxLjE7XG4gICAgICAgICAgdmFyIHlEaXN0YW5jZSA9IE1hdGguYWJzKHJhbmdlLm1heFkgLSByYW5nZS5taW5ZKSAqIDEuMTtcblxuICAgICAgICAgIHZhciB4Wm9vbUxldmVsID0gdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoIC8geERpc3RhbmNlO1xuICAgICAgICAgIHZhciB5Wm9vbUxldmVsID0gdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodCAvIHlEaXN0YW5jZTtcblxuICAgICAgICAgIHpvb21MZXZlbCA9IHhab29tTGV2ZWwgPD0geVpvb21MZXZlbCA/IHhab29tTGV2ZWwgOiB5Wm9vbUxldmVsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHpvb21MZXZlbCA+IDEuMCkge1xuICAgICAgICAgIHpvb21MZXZlbCA9IDEuMDtcbiAgICAgICAgfSBlbHNlIGlmICh6b29tTGV2ZWwgPT09IDApIHtcbiAgICAgICAgICB6b29tTGV2ZWwgPSAxLjA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2VudGVyID0gX05ldHdvcmtVdGlsMi5kZWZhdWx0LmZpbmRDZW50ZXIocmFuZ2UpO1xuICAgICAgICB2YXIgYW5pbWF0aW9uT3B0aW9ucyA9IHsgcG9zaXRpb246IGNlbnRlciwgc2NhbGU6IHpvb21MZXZlbCwgYW5pbWF0aW9uOiBvcHRpb25zLmFuaW1hdGlvbiB9O1xuICAgICAgICB0aGlzLm1vdmVUbyhhbmltYXRpb25PcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgLy8gYW5pbWF0aW9uXG5cbiAgICAgIC8qKlxuICAgICAgICogQ2VudGVyIGEgbm9kZSBpbiB2aWV3LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBub2RlSWRcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9uc11cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZm9jdXMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZvY3VzKG5vZGVJZCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIG5vZGVQb3NpdGlvbiA9IHsgeDogdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0ueCwgeTogdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0ueSB9O1xuICAgICAgICAgIG9wdGlvbnMucG9zaXRpb24gPSBub2RlUG9zaXRpb247XG4gICAgICAgICAgb3B0aW9ucy5sb2NrZWRPbk5vZGUgPSBub2RlSWQ7XG5cbiAgICAgICAgICB0aGlzLm1vdmVUbyhvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIk5vZGU6IFwiICsgbm9kZUlkICsgXCIgY2Fubm90IGJlIGZvdW5kLlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgfCAgb3B0aW9ucy5vZmZzZXQgICA9IHt4Ok51bWJlciwgeTpOdW1iZXJ9ICAgLy8gb2Zmc2V0IGZyb20gdGhlIGNlbnRlciBpbiBET00gcGl4ZWxzXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgb3B0aW9ucy5zY2FsZSAgICA9IE51bWJlciAgICAgICAgICAgICAgICAgLy8gc2NhbGUgdG8gbW92ZSB0b1xuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG9wdGlvbnMucG9zaXRpb24gPSB7eDpOdW1iZXIsIHk6TnVtYmVyfSAgIC8vIHBvc2l0aW9uIHRvIG1vdmUgdG9cbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBvcHRpb25zLmFuaW1hdGlvbiA9IHtkdXJhdGlvbjpOdW1iZXIsIGVhc2luZ0Z1bmN0aW9uOlN0cmluZ30gfHwgQm9vbGVhbiAgIC8vIHBvc2l0aW9uIHRvIG1vdmUgdG9cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnbW92ZVRvJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlVG8ob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5vZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG9wdGlvbnMub2Zmc2V0ID0geyB4OiAwLCB5OiAwIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMub2Zmc2V0LnggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG9wdGlvbnMub2Zmc2V0LnggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLm9mZnNldC55ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBvcHRpb25zLm9mZnNldC55ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5zY2FsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb3B0aW9ucy5zY2FsZSA9IHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnBvc2l0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBvcHRpb25zLnBvc2l0aW9uID0gdGhpcy5nZXRWaWV3UG9zaXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5hbmltYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG9wdGlvbnMuYW5pbWF0aW9uID0geyBkdXJhdGlvbjogMCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmFuaW1hdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBvcHRpb25zLmFuaW1hdGlvbiA9IHsgZHVyYXRpb246IDAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5hbmltYXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgICBvcHRpb25zLmFuaW1hdGlvbiA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmFuaW1hdGlvbi5kdXJhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb3B0aW9ucy5hbmltYXRpb24uZHVyYXRpb24gPSAxMDAwO1xuICAgICAgICB9IC8vIGRlZmF1bHQgZHVyYXRpb25cbiAgICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uLmVhc2luZ0Z1bmN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBvcHRpb25zLmFuaW1hdGlvbi5lYXNpbmdGdW5jdGlvbiA9IFwiZWFzZUluT3V0UXVhZFwiO1xuICAgICAgICB9IC8vIGRlZmF1bHQgZWFzaW5nIGZ1bmN0aW9uXG5cbiAgICAgICAgdGhpcy5hbmltYXRlVmlldyhvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgIHwgIG9wdGlvbnMub2Zmc2V0ICAgPSB7eDpOdW1iZXIsIHk6TnVtYmVyfSAgIC8vIG9mZnNldCBmcm9tIHRoZSBjZW50ZXIgaW4gRE9NIHBpeGVsc1xuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG9wdGlvbnMudGltZSAgICAgPSBOdW1iZXIgICAgICAgICAgICAgICAgIC8vIGFuaW1hdGlvbiB0aW1lIGluIG1pbGxpc2Vjb25kc1xuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG9wdGlvbnMuc2NhbGUgICAgPSBOdW1iZXIgICAgICAgICAgICAgICAgIC8vIHNjYWxlIHRvIGFuaW1hdGUgdG9cbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBvcHRpb25zLnBvc2l0aW9uID0ge3g6TnVtYmVyLCB5Ok51bWJlcn0gICAvLyBwb3NpdGlvbiB0byBhbmltYXRlIHRvXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgb3B0aW9ucy5lYXNpbmdGdW5jdGlvbiA9IFN0cmluZyAgICAgICAgICAgLy8gbGluZWFyLCBlYXNlSW5RdWFkLCBlYXNlT3V0UXVhZCwgZWFzZUluT3V0UXVhZCxcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlYXNlSW5DdWJpYywgZWFzZU91dEN1YmljLCBlYXNlSW5PdXRDdWJpYyxcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlYXNlSW5RdWFydCwgZWFzZU91dFF1YXJ0LCBlYXNlSW5PdXRRdWFydCxcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlYXNlSW5RdWludCwgZWFzZU91dFF1aW50LCBlYXNlSW5PdXRRdWludFxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdhbmltYXRlVmlldycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYW5pbWF0ZVZpZXcob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uRWFzaW5nRnVuY3Rpb24gPSBvcHRpb25zLmFuaW1hdGlvbi5lYXNpbmdGdW5jdGlvbjtcbiAgICAgICAgLy8gcmVsZWFzZSBpZiBzb21ldGhpbmcgZm9jdXNzZWQgb24gdGhlIG5vZGVcbiAgICAgICAgdGhpcy5yZWxlYXNlTm9kZSgpO1xuICAgICAgICBpZiAob3B0aW9ucy5sb2NrZWQgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmxvY2tlZE9uTm9kZUlkID0gb3B0aW9ucy5sb2NrZWRPbk5vZGU7XG4gICAgICAgICAgdGhpcy5sb2NrZWRPbk5vZGVPZmZzZXQgPSBvcHRpb25zLm9mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZvcmNlZnVsbHkgY29tcGxldGUgdGhlIG9sZCBhbmltYXRpb24gaWYgaXQgd2FzIHN0aWxsIHJ1bm5pbmdcbiAgICAgICAgaWYgKHRoaXMuZWFzaW5nVGltZSAhPSAwKSB7XG4gICAgICAgICAgdGhpcy5fdHJhbnNpdGlvblJlZHJhdyh0cnVlKTsgLy8gYnkgc2V0dGluZyBlYXNpbmd0aW1lIHRvIDEsIHdlIGZpbmlzaCB0aGUgYW5pbWF0aW9uLlxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zb3VyY2VTY2FsZSA9IHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgICB0aGlzLnNvdXJjZVRyYW5zbGF0aW9uID0gdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb247XG4gICAgICAgIHRoaXMudGFyZ2V0U2NhbGUgPSBvcHRpb25zLnNjYWxlO1xuXG4gICAgICAgIC8vIHNldCB0aGUgc2NhbGUgc28gdGhlIHZpZXdDZW50ZXIgaXMgYmFzZWQgb24gdGhlIGNvcnJlY3Qgem9vbSBsZXZlbC4gVGhpcyBpcyBvdmVycmlkZGVuIGluIHRoZSB0cmFuc2l0aW9uUmVkcmF3XG4gICAgICAgIC8vIGJ1dCBhdCBsZWFzdCB0aGVuIHdlJ2xsIGhhdmUgdGhlIHRhcmdldCB0cmFuc2l0aW9uXG4gICAgICAgIHRoaXMuYm9keS52aWV3LnNjYWxlID0gdGhpcy50YXJnZXRTY2FsZTtcbiAgICAgICAgdmFyIHZpZXdDZW50ZXIgPSB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyh7IHg6IDAuNSAqIHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCwgeTogMC41ICogdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodCB9KTtcblxuICAgICAgICB2YXIgZGlzdGFuY2VGcm9tQ2VudGVyID0geyAvLyBvZmZzZXQgZnJvbSB2aWV3LCBkaXN0YW5jZSB2aWV3IGhhcyB0byBjaGFuZ2UgYnkgdGhlc2UgeCBhbmQgeSB0byBjZW50ZXIgdGhlIG5vZGVcbiAgICAgICAgICB4OiB2aWV3Q2VudGVyLnggLSBvcHRpb25zLnBvc2l0aW9uLngsXG4gICAgICAgICAgeTogdmlld0NlbnRlci55IC0gb3B0aW9ucy5wb3NpdGlvbi55XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudGFyZ2V0VHJhbnNsYXRpb24gPSB7XG4gICAgICAgICAgeDogdGhpcy5zb3VyY2VUcmFuc2xhdGlvbi54ICsgZGlzdGFuY2VGcm9tQ2VudGVyLnggKiB0aGlzLnRhcmdldFNjYWxlICsgb3B0aW9ucy5vZmZzZXQueCxcbiAgICAgICAgICB5OiB0aGlzLnNvdXJjZVRyYW5zbGF0aW9uLnkgKyBkaXN0YW5jZUZyb21DZW50ZXIueSAqIHRoaXMudGFyZ2V0U2NhbGUgKyBvcHRpb25zLm9mZnNldC55XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gaWYgdGhlIHRpbWUgaXMgc2V0IHRvIDAsIGRvbid0IGRvIGFuIGFuaW1hdGlvblxuICAgICAgICBpZiAob3B0aW9ucy5hbmltYXRpb24uZHVyYXRpb24gPT09IDApIHtcbiAgICAgICAgICBpZiAodGhpcy5sb2NrZWRPbk5vZGVJZCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMudmlld0Z1bmN0aW9uID0gdGhpcy5fbG9ja2VkUmVkcmF3LmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImluaXRSZWRyYXdcIiwgdGhpcy52aWV3RnVuY3Rpb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJvZHkudmlldy5zY2FsZSA9IHRoaXMudGFyZ2V0U2NhbGU7XG4gICAgICAgICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbiA9IHRoaXMudGFyZ2V0VHJhbnNsYXRpb247XG4gICAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYW5pbWF0aW9uU3BlZWQgPSAxIC8gKDYwICogb3B0aW9ucy5hbmltYXRpb24uZHVyYXRpb24gKiAwLjAwMSkgfHwgMSAvIDYwOyAvLyA2MCBmb3IgNjAgc2Vjb25kcywgMC4wMDEgZm9yIG1pbGxpJ3NcbiAgICAgICAgICB0aGlzLmFuaW1hdGlvbkVhc2luZ0Z1bmN0aW9uID0gb3B0aW9ucy5hbmltYXRpb24uZWFzaW5nRnVuY3Rpb247XG5cbiAgICAgICAgICB0aGlzLnZpZXdGdW5jdGlvbiA9IHRoaXMuX3RyYW5zaXRpb25SZWRyYXcuYmluZCh0aGlzKTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImluaXRSZWRyYXdcIiwgdGhpcy52aWV3RnVuY3Rpb24pO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfc3RhcnRSZW5kZXJpbmdcIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiB1c2VkIHRvIGFuaW1hdGUgc21vb3RobHkgYnkgaGlqYWNraW5nIHRoZSByZWRyYXcgZnVuY3Rpb24uXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfbG9ja2VkUmVkcmF3JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbG9ja2VkUmVkcmF3KCkge1xuICAgICAgICB2YXIgbm9kZVBvc2l0aW9uID0geyB4OiB0aGlzLmJvZHkubm9kZXNbdGhpcy5sb2NrZWRPbk5vZGVJZF0ueCwgeTogdGhpcy5ib2R5Lm5vZGVzW3RoaXMubG9ja2VkT25Ob2RlSWRdLnkgfTtcbiAgICAgICAgdmFyIHZpZXdDZW50ZXIgPSB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyh7IHg6IDAuNSAqIHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCwgeTogMC41ICogdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodCB9KTtcbiAgICAgICAgdmFyIGRpc3RhbmNlRnJvbUNlbnRlciA9IHsgLy8gb2Zmc2V0IGZyb20gdmlldywgZGlzdGFuY2UgdmlldyBoYXMgdG8gY2hhbmdlIGJ5IHRoZXNlIHggYW5kIHkgdG8gY2VudGVyIHRoZSBub2RlXG4gICAgICAgICAgeDogdmlld0NlbnRlci54IC0gbm9kZVBvc2l0aW9uLngsXG4gICAgICAgICAgeTogdmlld0NlbnRlci55IC0gbm9kZVBvc2l0aW9uLnlcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHNvdXJjZVRyYW5zbGF0aW9uID0gdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb247XG4gICAgICAgIHZhciB0YXJnZXRUcmFuc2xhdGlvbiA9IHtcbiAgICAgICAgICB4OiBzb3VyY2VUcmFuc2xhdGlvbi54ICsgZGlzdGFuY2VGcm9tQ2VudGVyLnggKiB0aGlzLmJvZHkudmlldy5zY2FsZSArIHRoaXMubG9ja2VkT25Ob2RlT2Zmc2V0LngsXG4gICAgICAgICAgeTogc291cmNlVHJhbnNsYXRpb24ueSArIGRpc3RhbmNlRnJvbUNlbnRlci55ICogdGhpcy5ib2R5LnZpZXcuc2NhbGUgKyB0aGlzLmxvY2tlZE9uTm9kZU9mZnNldC55XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24gPSB0YXJnZXRUcmFuc2xhdGlvbjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyZWxlYXNlTm9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVsZWFzZU5vZGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmxvY2tlZE9uTm9kZUlkICE9PSB1bmRlZmluZWQgJiYgdGhpcy52aWV3RnVuY3Rpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9mZihcImluaXRSZWRyYXdcIiwgdGhpcy52aWV3RnVuY3Rpb24pO1xuICAgICAgICAgIHRoaXMubG9ja2VkT25Ob2RlSWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgdGhpcy5sb2NrZWRPbk5vZGVPZmZzZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIGVhc2luZ1RpbWVcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ190cmFuc2l0aW9uUmVkcmF3JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdHJhbnNpdGlvblJlZHJhdygpIHtcbiAgICAgICAgdmFyIGZpbmlzaGVkID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBhcmd1bWVudHNbMF07XG5cbiAgICAgICAgdGhpcy5lYXNpbmdUaW1lICs9IHRoaXMuYW5pbWF0aW9uU3BlZWQ7XG4gICAgICAgIHRoaXMuZWFzaW5nVGltZSA9IGZpbmlzaGVkID09PSB0cnVlID8gMS4wIDogdGhpcy5lYXNpbmdUaW1lO1xuXG4gICAgICAgIHZhciBwcm9ncmVzcyA9IHV0aWwuZWFzaW5nRnVuY3Rpb25zW3RoaXMuYW5pbWF0aW9uRWFzaW5nRnVuY3Rpb25dKHRoaXMuZWFzaW5nVGltZSk7XG5cbiAgICAgICAgdGhpcy5ib2R5LnZpZXcuc2NhbGUgPSB0aGlzLnNvdXJjZVNjYWxlICsgKHRoaXMudGFyZ2V0U2NhbGUgLSB0aGlzLnNvdXJjZVNjYWxlKSAqIHByb2dyZXNzO1xuICAgICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbiA9IHtcbiAgICAgICAgICB4OiB0aGlzLnNvdXJjZVRyYW5zbGF0aW9uLnggKyAodGhpcy50YXJnZXRUcmFuc2xhdGlvbi54IC0gdGhpcy5zb3VyY2VUcmFuc2xhdGlvbi54KSAqIHByb2dyZXNzLFxuICAgICAgICAgIHk6IHRoaXMuc291cmNlVHJhbnNsYXRpb24ueSArICh0aGlzLnRhcmdldFRyYW5zbGF0aW9uLnkgLSB0aGlzLnNvdXJjZVRyYW5zbGF0aW9uLnkpICogcHJvZ3Jlc3NcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBjbGVhbnVwXG4gICAgICAgIGlmICh0aGlzLmVhc2luZ1RpbWUgPj0gMS4wKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub2ZmKFwiaW5pdFJlZHJhd1wiLCB0aGlzLnZpZXdGdW5jdGlvbik7XG4gICAgICAgICAgdGhpcy5lYXNpbmdUaW1lID0gMDtcbiAgICAgICAgICBpZiAodGhpcy5sb2NrZWRPbk5vZGVJZCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMudmlld0Z1bmN0aW9uID0gdGhpcy5fbG9ja2VkUmVkcmF3LmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImluaXRSZWRyYXdcIiwgdGhpcy52aWV3RnVuY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiYW5pbWF0aW9uRmluaXNoZWRcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXRTY2FsZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2NhbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXRWaWV3UG9zaXRpb24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZpZXdQb3NpdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLkRPTXRvQ2FudmFzKHsgeDogMC41ICogdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoLCB5OiAwLjUgKiB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0IH0pO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBWaWV3O1xuICB9KCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gVmlldztcblxuLyoqKi8gfSxcbi8qIDEwOCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgdmFyIF9OYXZpZ2F0aW9uSGFuZGxlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTA5KTtcblxuICB2YXIgX05hdmlnYXRpb25IYW5kbGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX05hdmlnYXRpb25IYW5kbGVyKTtcblxuICB2YXIgX1BvcHVwID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTApO1xuXG4gIHZhciBfUG9wdXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUG9wdXApO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbiAgdmFyIEludGVyYWN0aW9uSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbnRlcmFjdGlvbkhhbmRsZXIoYm9keSwgY2FudmFzLCBzZWxlY3Rpb25IYW5kbGVyKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW50ZXJhY3Rpb25IYW5kbGVyKTtcblxuICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyID0gc2VsZWN0aW9uSGFuZGxlcjtcbiAgICAgIHRoaXMubmF2aWdhdGlvbkhhbmRsZXIgPSBuZXcgX05hdmlnYXRpb25IYW5kbGVyMi5kZWZhdWx0KGJvZHksIGNhbnZhcyk7XG5cbiAgICAgIC8vIGJpbmQgdGhlIGV2ZW50cyBmcm9tIGhhbW1lciB0byBmdW5jdGlvbnMgaW4gdGhpcyBvYmplY3RcbiAgICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vblRhcCA9IHRoaXMub25UYXAuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vblRvdWNoID0gdGhpcy5vblRvdWNoLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Eb3VibGVUYXAgPSB0aGlzLm9uRG91YmxlVGFwLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Ib2xkID0gdGhpcy5vbkhvbGQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vbkRyYWdTdGFydCA9IHRoaXMub25EcmFnU3RhcnQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vbkRyYWcgPSB0aGlzLm9uRHJhZy5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uRHJhZ0VuZCA9IHRoaXMub25EcmFnRW5kLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Nb3VzZVdoZWVsID0gdGhpcy5vbk1vdXNlV2hlZWwuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vblBpbmNoID0gdGhpcy5vblBpbmNoLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Nb3VzZU1vdmUgPSB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25SZWxlYXNlID0gdGhpcy5vblJlbGVhc2UuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vbkNvbnRleHQgPSB0aGlzLm9uQ29udGV4dC5iaW5kKHRoaXMpO1xuXG4gICAgICB0aGlzLnRvdWNoVGltZSA9IDA7XG4gICAgICB0aGlzLmRyYWcgPSB7fTtcbiAgICAgIHRoaXMucGluY2ggPSB7fTtcbiAgICAgIHRoaXMucG9wdXAgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnBvcHVwT2JqID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5wb3B1cFRpbWVyID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLmJvZHkuZnVuY3Rpb25zLmdldFBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIuYmluZCh0aGlzKTtcblxuICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgICBkcmFnTm9kZXM6IHRydWUsXG4gICAgICAgIGRyYWdWaWV3OiB0cnVlLFxuICAgICAgICBob3ZlcjogZmFsc2UsXG4gICAgICAgIGtleWJvYXJkOiB7XG4gICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgc3BlZWQ6IHsgeDogMTAsIHk6IDEwLCB6b29tOiAwLjAyIH0sXG4gICAgICAgICAgYmluZFRvV2luZG93OiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIG5hdmlnYXRpb25CdXR0b25zOiBmYWxzZSxcbiAgICAgICAgdG9vbHRpcERlbGF5OiAzMDAsXG4gICAgICAgIHpvb21WaWV3OiB0cnVlXG4gICAgICB9O1xuICAgICAgdXRpbC5leHRlbmQodGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICAgICAgdGhpcy5iaW5kRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoSW50ZXJhY3Rpb25IYW5kbGVyLCBbe1xuICAgICAga2V5OiAnYmluZEV2ZW50TGlzdGVuZXJzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnBvcHVwVGltZXIpO1xuICAgICAgICAgIGRlbGV0ZSBfdGhpcy5ib2R5LmZ1bmN0aW9ucy5nZXRQb2ludGVyO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzZXRPcHRpb25zJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIGV4dGVuZCBhbGwgYnV0IHRoZSB2YWx1ZXMgaW4gZmllbGRzXG4gICAgICAgICAgdmFyIGZpZWxkcyA9IFsnaGlkZUVkZ2VzT25EcmFnJywgJ2hpZGVOb2Rlc09uRHJhZycsICdrZXlib2FyZCcsICdtdWx0aXNlbGVjdCcsICdzZWxlY3RhYmxlJywgJ3NlbGVjdENvbm5lY3RlZEVkZ2VzJ107XG4gICAgICAgICAgdXRpbC5zZWxlY3RpdmVOb3REZWVwRXh0ZW5kKGZpZWxkcywgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgICAgIC8vIG1lcmdlIHRoZSBrZXlib2FyZCBvcHRpb25zIGluLlxuICAgICAgICAgIHV0aWwubWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgb3B0aW9ucywgJ2tleWJvYXJkJyk7XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy50b29sdGlwKSB7XG4gICAgICAgICAgICB1dGlsLmV4dGVuZCh0aGlzLm9wdGlvbnMudG9vbHRpcCwgb3B0aW9ucy50b29sdGlwKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnRvb2x0aXAuY29sb3IpIHtcbiAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnRvb2x0aXAuY29sb3IgPSB1dGlsLnBhcnNlQ29sb3Iob3B0aW9ucy50b29sdGlwLmNvbG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm5hdmlnYXRpb25IYW5kbGVyLnNldE9wdGlvbnModGhpcy5vcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBHZXQgdGhlIHBvaW50ZXIgbG9jYXRpb24gZnJvbSBhIHRvdWNoIGxvY2F0aW9uXG4gICAgICAgKiBAcGFyYW0ge3t4OiBOdW1iZXIsIHk6IE51bWJlcn19IHRvdWNoXG4gICAgICAgKiBAcmV0dXJuIHt7eDogTnVtYmVyLCB5OiBOdW1iZXJ9fSBwb2ludGVyXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXRQb2ludGVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb2ludGVyKHRvdWNoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogdG91Y2gueCAtIHV0aWwuZ2V0QWJzb2x1dGVMZWZ0KHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcyksXG4gICAgICAgICAgeTogdG91Y2gueSAtIHV0aWwuZ2V0QWJzb2x1dGVUb3AodGhpcy5jYW52YXMuZnJhbWUuY2FudmFzKVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE9uIHN0YXJ0IG9mIGEgdG91Y2ggZ2VzdHVyZSwgc3RvcmUgdGhlIHBvaW50ZXJcbiAgICAgICAqIEBwYXJhbSBldmVudFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnb25Ub3VjaCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gb25Ub3VjaChldmVudCkge1xuICAgICAgICBpZiAobmV3IERhdGUoKS52YWx1ZU9mKCkgLSB0aGlzLnRvdWNoVGltZSA+IDUwKSB7XG4gICAgICAgICAgdGhpcy5kcmFnLnBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgICAgICB0aGlzLmRyYWcucGluY2hlZCA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMucGluY2guc2NhbGUgPSB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgICAgICAvLyB0byBhdm9pZCBkb3VibGUgZmlyZWluZyBvZiB0aGlzIGV2ZW50IGJlY2F1c2Ugd2UgaGF2ZSB0d28gaGFtbWVyIGluc3RhbmNlcy4gKG9uIGNhbnZhcyBhbmQgb24gZnJhbWUpXG4gICAgICAgICAgdGhpcy50b3VjaFRpbWUgPSBuZXcgRGF0ZSgpLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGhhbmRsZSB0YXAvY2xpY2sgZXZlbnQ6IHNlbGVjdC91bnNlbGVjdCBhIG5vZGVcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ29uVGFwJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvblRhcChldmVudCkge1xuICAgICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuICAgICAgICB2YXIgbXVsdGlzZWxlY3QgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIub3B0aW9ucy5tdWx0aXNlbGVjdCAmJiAoZXZlbnQuY2hhbmdlZFBvaW50ZXJzWzBdLmN0cmxLZXkgfHwgZXZlbnQuY2hhbmdlZFBvaW50ZXJzWzBdLm1ldGFLZXkpO1xuXG4gICAgICAgIHRoaXMuY2hlY2tTZWxlY3Rpb25DaGFuZ2VzKHBvaW50ZXIsIGV2ZW50LCBtdWx0aXNlbGVjdCk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2VuZXJhdGVDbGlja0V2ZW50KCdjbGljaycsIGV2ZW50LCBwb2ludGVyKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBoYW5kbGUgZG91YmxldGFwIGV2ZW50XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdvbkRvdWJsZVRhcCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gb25Eb3VibGVUYXAoZXZlbnQpIHtcbiAgICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZW5lcmF0ZUNsaWNrRXZlbnQoJ2RvdWJsZUNsaWNrJywgZXZlbnQsIHBvaW50ZXIpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGhhbmRsZSBsb25nIHRhcCBldmVudDogbXVsdGkgc2VsZWN0IG5vZGVzXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdvbkhvbGQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uSG9sZChldmVudCkge1xuICAgICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuICAgICAgICB2YXIgbXVsdGlzZWxlY3QgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIub3B0aW9ucy5tdWx0aXNlbGVjdDtcblxuICAgICAgICB0aGlzLmNoZWNrU2VsZWN0aW9uQ2hhbmdlcyhwb2ludGVyLCBldmVudCwgbXVsdGlzZWxlY3QpO1xuXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2VuZXJhdGVDbGlja0V2ZW50KCdjbGljaycsIGV2ZW50LCBwb2ludGVyKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZW5lcmF0ZUNsaWNrRXZlbnQoJ2hvbGQnLCBldmVudCwgcG9pbnRlcik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogaGFuZGxlIHRoZSByZWxlYXNlIG9mIHRoZSBzY3JlZW5cbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdvblJlbGVhc2UnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uUmVsZWFzZShldmVudCkge1xuICAgICAgICBpZiAobmV3IERhdGUoKS52YWx1ZU9mKCkgLSB0aGlzLnRvdWNoVGltZSA+IDEwKSB7XG4gICAgICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dlbmVyYXRlQ2xpY2tFdmVudCgncmVsZWFzZScsIGV2ZW50LCBwb2ludGVyKTtcbiAgICAgICAgICAvLyB0byBhdm9pZCBkb3VibGUgZmlyZWluZyBvZiB0aGlzIGV2ZW50IGJlY2F1c2Ugd2UgaGF2ZSB0d28gaGFtbWVyIGluc3RhbmNlcy4gKG9uIGNhbnZhcyBhbmQgb24gZnJhbWUpXG4gICAgICAgICAgdGhpcy50b3VjaFRpbWUgPSBuZXcgRGF0ZSgpLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ29uQ29udGV4dCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gb25Db250ZXh0KGV2ZW50KSB7XG4gICAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSB9KTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZW5lcmF0ZUNsaWNrRXZlbnQoJ29uY29udGV4dCcsIGV2ZW50LCBwb2ludGVyKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHBvaW50ZXJcbiAgICAgICAqIEBwYXJhbSBhZGRcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnY2hlY2tTZWxlY3Rpb25DaGFuZ2VzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja1NlbGVjdGlvbkNoYW5nZXMocG9pbnRlciwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGFkZCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogYXJndW1lbnRzWzJdO1xuXG4gICAgICAgIHZhciBwcmV2aW91c2x5U2VsZWN0ZWRFZGdlQ291bnQgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dldFNlbGVjdGVkRWRnZUNvdW50KCk7XG4gICAgICAgIHZhciBwcmV2aW91c2x5U2VsZWN0ZWROb2RlQ291bnQgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dldFNlbGVjdGVkTm9kZUNvdW50KCk7XG4gICAgICAgIHZhciBwcmV2aW91c1NlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgdmFyIHNlbGVjdGVkID0gdm9pZCAwO1xuICAgICAgICBpZiAoYWRkID09PSB0cnVlKSB7XG4gICAgICAgICAgc2VsZWN0ZWQgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuc2VsZWN0QWRkaXRpb25hbE9uUG9pbnQocG9pbnRlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZWN0ZWQgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuc2VsZWN0T25Qb2ludChwb2ludGVyKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VsZWN0ZWRFZGdlc0NvdW50ID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZXRTZWxlY3RlZEVkZ2VDb3VudCgpO1xuICAgICAgICB2YXIgc2VsZWN0ZWROb2Rlc0NvdW50ID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZXRTZWxlY3RlZE5vZGVDb3VudCgpO1xuICAgICAgICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRTZWxlY3Rpb24oKTtcblxuICAgICAgICB2YXIgX2RldGVybWluZUlmRGlmZmVyZW50MiA9IHRoaXMuX2RldGVybWluZUlmRGlmZmVyZW50KHByZXZpb3VzU2VsZWN0aW9uLCBjdXJyZW50U2VsZWN0aW9uKTtcblxuICAgICAgICB2YXIgbm9kZXNDaGFuZ2VkID0gX2RldGVybWluZUlmRGlmZmVyZW50Mi5ub2Rlc0NoYW5nZWQ7XG4gICAgICAgIHZhciBlZGdlc0NoYW5nZWQgPSBfZGV0ZXJtaW5lSWZEaWZmZXJlbnQyLmVkZ2VzQ2hhbmdlZDtcblxuICAgICAgICB2YXIgbm9kZVNlbGVjdGVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHNlbGVjdGVkTm9kZXNDb3VudCAtIHByZXZpb3VzbHlTZWxlY3RlZE5vZGVDb3VudCA+IDApIHtcbiAgICAgICAgICAvLyBub2RlIHdhcyBzZWxlY3RlZFxuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2VuZXJhdGVDbGlja0V2ZW50KCdzZWxlY3ROb2RlJywgZXZlbnQsIHBvaW50ZXIpO1xuICAgICAgICAgIHNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICBub2RlU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGVzQ2hhbmdlZCA9PT0gdHJ1ZSAmJiBzZWxlY3RlZE5vZGVzQ291bnQgPiAwKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZW5lcmF0ZUNsaWNrRXZlbnQoJ2Rlc2VsZWN0Tm9kZScsIGV2ZW50LCBwb2ludGVyLCBwcmV2aW91c1NlbGVjdGlvbik7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZW5lcmF0ZUNsaWNrRXZlbnQoJ3NlbGVjdE5vZGUnLCBldmVudCwgcG9pbnRlcik7XG4gICAgICAgICAgbm9kZVNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0ZWROb2Rlc0NvdW50IC0gcHJldmlvdXNseVNlbGVjdGVkTm9kZUNvdW50IDwgMCkge1xuICAgICAgICAgIC8vIG5vZGUgd2FzIGRlc2VsZWN0ZWRcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dlbmVyYXRlQ2xpY2tFdmVudCgnZGVzZWxlY3ROb2RlJywgZXZlbnQsIHBvaW50ZXIsIHByZXZpb3VzU2VsZWN0aW9uKTtcbiAgICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoYW5kbGUgdGhlIHNlbGVjdGVkIGVkZ2VzXG4gICAgICAgIGlmIChzZWxlY3RlZEVkZ2VzQ291bnQgLSBwcmV2aW91c2x5U2VsZWN0ZWRFZGdlQ291bnQgPiAwICYmIG5vZGVTZWxlY3RlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAvLyBlZGdlIHdhcyBzZWxlY3RlZFxuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2VuZXJhdGVDbGlja0V2ZW50KCdzZWxlY3RFZGdlJywgZXZlbnQsIHBvaW50ZXIpO1xuICAgICAgICAgIHNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChzZWxlY3RlZEVkZ2VzQ291bnQgPiAwICYmIGVkZ2VzQ2hhbmdlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2VuZXJhdGVDbGlja0V2ZW50KCdkZXNlbGVjdEVkZ2UnLCBldmVudCwgcG9pbnRlciwgcHJldmlvdXNTZWxlY3Rpb24pO1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2VuZXJhdGVDbGlja0V2ZW50KCdzZWxlY3RFZGdlJywgZXZlbnQsIHBvaW50ZXIpO1xuICAgICAgICAgIHNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChzZWxlY3RlZEVkZ2VzQ291bnQgLSBwcmV2aW91c2x5U2VsZWN0ZWRFZGdlQ291bnQgPCAwKSB7XG4gICAgICAgICAgLy8gZWRnZSB3YXMgZGVzZWxlY3RlZFxuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2VuZXJhdGVDbGlja0V2ZW50KCdkZXNlbGVjdEVkZ2UnLCBldmVudCwgcG9pbnRlciwgcHJldmlvdXNTZWxlY3Rpb24pO1xuICAgICAgICAgIHNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpcmUgdGhlIHNlbGVjdCBldmVudCBpZiBhbnl0aGluZyBoYXMgYmVlbiBzZWxlY3RlZCBvciBkZXNlbGVjdGVkXG4gICAgICAgIGlmIChzZWxlY3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIC8vIHNlbGVjdCBvciB1bnNlbGVjdFxuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2VuZXJhdGVDbGlja0V2ZW50KCdzZWxlY3QnLCBldmVudCwgcG9pbnRlcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIGZ1bmN0aW9uIGNoZWNrcyBpZiB0aGUgbm9kZXMgYW5kIGVkZ2VzIHByZXZpb3VzbHkgc2VsZWN0ZWQgaGF2ZSBjaGFuZ2VkLlxuICAgICAgICogQHBhcmFtIHByZXZpb3VzU2VsZWN0aW9uXG4gICAgICAgKiBAcGFyYW0gY3VycmVudFNlbGVjdGlvblxuICAgICAgICogQHJldHVybnMge3tub2Rlc0NoYW5nZWQ6IGJvb2xlYW4sIGVkZ2VzQ2hhbmdlZDogYm9vbGVhbn19XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZGV0ZXJtaW5lSWZEaWZmZXJlbnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXRlcm1pbmVJZkRpZmZlcmVudChwcmV2aW91c1NlbGVjdGlvbiwgY3VycmVudFNlbGVjdGlvbikge1xuICAgICAgICB2YXIgbm9kZXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIHZhciBlZGdlc0NoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZXZpb3VzU2VsZWN0aW9uLm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnRTZWxlY3Rpb24ubm9kZXMuaW5kZXhPZihwcmV2aW91c1NlbGVjdGlvbi5ub2Rlc1tpXSkgPT09IC0xKSB7XG4gICAgICAgICAgICBub2Rlc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgY3VycmVudFNlbGVjdGlvbi5ub2Rlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICBpZiAocHJldmlvdXNTZWxlY3Rpb24ubm9kZXMuaW5kZXhPZihwcmV2aW91c1NlbGVjdGlvbi5ub2Rlc1tfaV0pID09PSAtMSkge1xuICAgICAgICAgICAgbm9kZXNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgcHJldmlvdXNTZWxlY3Rpb24uZWRnZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgIGlmIChjdXJyZW50U2VsZWN0aW9uLmVkZ2VzLmluZGV4T2YocHJldmlvdXNTZWxlY3Rpb24uZWRnZXNbX2kyXSkgPT09IC0xKSB7XG4gICAgICAgICAgICBlZGdlc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBjdXJyZW50U2VsZWN0aW9uLmVkZ2VzLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgICAgICBpZiAocHJldmlvdXNTZWxlY3Rpb24uZWRnZXMuaW5kZXhPZihwcmV2aW91c1NlbGVjdGlvbi5lZGdlc1tfaTNdKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGVkZ2VzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgbm9kZXNDaGFuZ2VkOiBub2Rlc0NoYW5nZWQsIGVkZ2VzQ2hhbmdlZDogZWRnZXNDaGFuZ2VkIH07XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYnkgb25EcmFnU3RhcnQuXG4gICAgICAgKiBJdCBpcyBzZXBhcmF0ZWQgb3V0IGJlY2F1c2Ugd2UgY2FuIHRoZW4gb3ZlcmxvYWQgaXQgZm9yIHRoZSBkYXRhbWFuaXB1bGF0aW9uIHN5c3RlbS5cbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdvbkRyYWdTdGFydCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gb25EcmFnU3RhcnQoZXZlbnQpIHtcbiAgICAgICAgLy9pbiBjYXNlIHRoZSB0b3VjaCBldmVudCB3YXMgdHJpZ2dlcmVkIG9uIGFuIGV4dGVybmFsIGRpdiwgZG8gdGhlIGluaXRpYWwgdG91Y2ggbm93LlxuICAgICAgICBpZiAodGhpcy5kcmFnLnBvaW50ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMub25Ub3VjaChldmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBub3RlOiBkcmFnLnBvaW50ZXIgaXMgc2V0IGluIG9uVG91Y2ggdG8gZ2V0IHRoZSBpbml0aWFsIHRvdWNoIGxvY2F0aW9uXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldE5vZGVBdCh0aGlzLmRyYWcucG9pbnRlcik7XG5cbiAgICAgICAgdGhpcy5kcmFnLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kcmFnLnNlbGVjdGlvbiA9IFtdO1xuICAgICAgICB0aGlzLmRyYWcudHJhbnNsYXRpb24gPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24pOyAvLyBjb3B5IHRoZSBvYmplY3RcbiAgICAgICAgdGhpcy5kcmFnLm5vZGVJZCA9IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMub3B0aW9ucy5kcmFnTm9kZXMgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmRyYWcubm9kZUlkID0gbm9kZS5pZDtcbiAgICAgICAgICAvLyBzZWxlY3QgdGhlIGNsaWNrZWQgbm9kZSBpZiBub3QgeWV0IHNlbGVjdGVkXG4gICAgICAgICAgaWYgKG5vZGUuaXNTZWxlY3RlZCgpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnVuc2VsZWN0QWxsKCk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuc2VsZWN0T2JqZWN0KG5vZGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGFmdGVyIHNlbGVjdCB0byBjb250YWluIHRoZSBub2RlXG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZW5lcmF0ZUNsaWNrRXZlbnQoJ2RyYWdTdGFydCcsIGV2ZW50LCB0aGlzLmRyYWcucG9pbnRlcik7XG5cbiAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnNlbGVjdGlvbk9iai5ub2RlcztcbiAgICAgICAgICAvLyBjcmVhdGUgYW4gYXJyYXkgd2l0aCB0aGUgc2VsZWN0ZWQgbm9kZXMgYW5kIHRoZWlyIG9yaWdpbmFsIGxvY2F0aW9uIGFuZCBzdGF0dXNcbiAgICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uLmhhc093blByb3BlcnR5KG5vZGVJZCkpIHtcbiAgICAgICAgICAgICAgdmFyIG9iamVjdCA9IHNlbGVjdGlvbltub2RlSWRdO1xuICAgICAgICAgICAgICB2YXIgcyA9IHtcbiAgICAgICAgICAgICAgICBpZDogb2JqZWN0LmlkLFxuICAgICAgICAgICAgICAgIG5vZGU6IG9iamVjdCxcblxuICAgICAgICAgICAgICAgIC8vIHN0b3JlIG9yaWdpbmFsIHgsIHksIHhGaXhlZCBhbmQgeUZpeGVkLCBtYWtlIHRoZSBub2RlIHRlbXBvcmFyaWx5IEZpeGVkXG4gICAgICAgICAgICAgICAgeDogb2JqZWN0LngsXG4gICAgICAgICAgICAgICAgeTogb2JqZWN0LnksXG4gICAgICAgICAgICAgICAgeEZpeGVkOiBvYmplY3Qub3B0aW9ucy5maXhlZC54LFxuICAgICAgICAgICAgICAgIHlGaXhlZDogb2JqZWN0Lm9wdGlvbnMuZml4ZWQueVxuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIG9iamVjdC5vcHRpb25zLmZpeGVkLnggPSB0cnVlO1xuICAgICAgICAgICAgICBvYmplY3Qub3B0aW9ucy5maXhlZC55ID0gdHJ1ZTtcblxuICAgICAgICAgICAgICB0aGlzLmRyYWcuc2VsZWN0aW9uLnB1c2gocyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGZhbGxiYWNrIGlmIG5vIG5vZGUgaXMgc2VsZWN0ZWQgYW5kIHRodXMgdGhlIHZpZXcgaXMgZHJhZ2dlZC5cbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dlbmVyYXRlQ2xpY2tFdmVudCgnZHJhZ1N0YXJ0JywgZXZlbnQsIHRoaXMuZHJhZy5wb2ludGVyLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogaGFuZGxlIGRyYWcgZXZlbnRcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ29uRHJhZycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gb25EcmFnKGV2ZW50KSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIGlmICh0aGlzLmRyYWcucGluY2hlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgZm9jdXMgb24gbm9kZSBpZiBpdCBpcyBmb2N1c3NlZCBvbiBieSB0aGUgZm9jdXNPbk5vZGVcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgndW5sb2NrTm9kZScpO1xuXG4gICAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG5cbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuZHJhZy5zZWxlY3Rpb247XG4gICAgICAgIGlmIChzZWxlY3Rpb24gJiYgc2VsZWN0aW9uLmxlbmd0aCAmJiB0aGlzLm9wdGlvbnMuZHJhZ05vZGVzID09PSB0cnVlKSB7XG4gICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMi5zZWxlY3Rpb25IYW5kbGVyLl9nZW5lcmF0ZUNsaWNrRXZlbnQoJ2RyYWdnaW5nJywgZXZlbnQsIHBvaW50ZXIpO1xuXG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgZGVsdGEncyBhbmQgbmV3IGxvY2F0aW9uXG4gICAgICAgICAgICB2YXIgZGVsdGFYID0gcG9pbnRlci54IC0gX3RoaXMyLmRyYWcucG9pbnRlci54O1xuICAgICAgICAgICAgdmFyIGRlbHRhWSA9IHBvaW50ZXIueSAtIF90aGlzMi5kcmFnLnBvaW50ZXIueTtcblxuICAgICAgICAgICAgLy8gdXBkYXRlIHBvc2l0aW9uIG9mIGFsbCBzZWxlY3RlZCBub2Rlc1xuICAgICAgICAgICAgc2VsZWN0aW9uLmZvckVhY2goZnVuY3Rpb24gKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgICB2YXIgbm9kZSA9IHNlbGVjdGlvbi5ub2RlO1xuICAgICAgICAgICAgICAvLyBvbmx5IG1vdmUgdGhlIG5vZGUgaWYgaXQgd2FzIG5vdCBmaXhlZCBpbml0aWFsbHlcbiAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi54Rml4ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS54ID0gX3RoaXMyLmNhbnZhcy5fWGNvbnZlcnRET010b0NhbnZhcyhfdGhpczIuY2FudmFzLl9YY29udmVydENhbnZhc1RvRE9NKHNlbGVjdGlvbi54KSArIGRlbHRhWCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gb25seSBtb3ZlIHRoZSBub2RlIGlmIGl0IHdhcyBub3QgZml4ZWQgaW5pdGlhbGx5XG4gICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24ueUZpeGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIG5vZGUueSA9IF90aGlzMi5jYW52YXMuX1ljb252ZXJ0RE9NdG9DYW52YXMoX3RoaXMyLmNhbnZhcy5fWWNvbnZlcnRDYW52YXNUb0RPTShzZWxlY3Rpb24ueSkgKyBkZWx0YVkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gc3RhcnQgdGhlIHNpbXVsYXRpb24gb2YgdGhlIHBoeXNpY3NcbiAgICAgICAgICAgIF90aGlzMi5ib2R5LmVtaXR0ZXIuZW1pdCgnc3RhcnRTaW11bGF0aW9uJyk7XG4gICAgICAgICAgfSkoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBtb3ZlIHRoZSBuZXR3b3JrXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kcmFnVmlldyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZW5lcmF0ZUNsaWNrRXZlbnQoJ2RyYWdnaW5nJywgZXZlbnQsIHBvaW50ZXIsIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSBkcmFnIHdhcyBub3Qgc3RhcnRlZCBwcm9wZXJseSBiZWNhdXNlIHRoZSBjbGljayBzdGFydGVkIG91dHNpZGUgdGhlIG5ldHdvcmsgZGl2LCBzdGFydCBpdCBub3cuXG4gICAgICAgICAgICBpZiAodGhpcy5kcmFnLnBvaW50ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0aGlzLm9uRHJhZ1N0YXJ0KGV2ZW50KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRpZmZYID0gcG9pbnRlci54IC0gdGhpcy5kcmFnLnBvaW50ZXIueDtcbiAgICAgICAgICAgIHZhciBkaWZmWSA9IHBvaW50ZXIueSAtIHRoaXMuZHJhZy5wb2ludGVyLnk7XG5cbiAgICAgICAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uID0geyB4OiB0aGlzLmRyYWcudHJhbnNsYXRpb24ueCArIGRpZmZYLCB5OiB0aGlzLmRyYWcudHJhbnNsYXRpb24ueSArIGRpZmZZIH07XG4gICAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfcmVkcmF3Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogaGFuZGxlIGRyYWcgc3RhcnQgZXZlbnRcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ29uRHJhZ0VuZCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gb25EcmFnRW5kKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZHJhZy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5kcmFnLnNlbGVjdGlvbjtcbiAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBzZWxlY3Rpb24ubGVuZ3RoKSB7XG4gICAgICAgICAgc2VsZWN0aW9uLmZvckVhY2goZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgIC8vIHJlc3RvcmUgb3JpZ2luYWwgeEZpeGVkIGFuZCB5Rml4ZWRcbiAgICAgICAgICAgIHMubm9kZS5vcHRpb25zLmZpeGVkLnggPSBzLnhGaXhlZDtcbiAgICAgICAgICAgIHMubm9kZS5vcHRpb25zLmZpeGVkLnkgPSBzLnlGaXhlZDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dlbmVyYXRlQ2xpY2tFdmVudCgnZHJhZ0VuZCcsIGV2ZW50LCB0aGlzLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKSk7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnc3RhcnRTaW11bGF0aW9uJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZW5lcmF0ZUNsaWNrRXZlbnQoJ2RyYWdFbmQnLCBldmVudCwgdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlciksIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX3JlcXVlc3RSZWRyYXcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZSBwaW5jaCBldmVudFxuICAgICAgICogQHBhcmFtIGV2ZW50XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdvblBpbmNoJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvblBpbmNoKGV2ZW50KSB7XG4gICAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG5cbiAgICAgICAgdGhpcy5kcmFnLnBpbmNoZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5waW5jaFsnc2NhbGUnXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5waW5jaC5zY2FsZSA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBlbmFibGVkIG1vdmluZyB3aGlsZSBwaW5jaGluZz9cbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5waW5jaC5zY2FsZSAqIGV2ZW50LnNjYWxlO1xuICAgICAgICB0aGlzLnpvb20oc2NhbGUsIHBvaW50ZXIpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFpvb20gdGhlIG5ldHdvcmsgaW4gb3Igb3V0XG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgYSBudW1iZXIgYXJvdW5kIDEsIGFuZCBiZXR3ZWVuIDAuMDEgYW5kIDEwXG4gICAgICAgKiBAcGFyYW0ge3t4OiBOdW1iZXIsIHk6IE51bWJlcn19IHBvaW50ZXIgICAgUG9zaXRpb24gb24gc2NyZWVuXG4gICAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGFwcGxpZWRTY2FsZSAgICBzY2FsZSBpcyBsaW1pdGVkIHdpdGhpbiB0aGUgYm91bmRhcmllc1xuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnem9vbScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gem9vbShzY2FsZSwgcG9pbnRlcikge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnpvb21WaWV3ID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIHNjYWxlT2xkID0gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICAgICAgaWYgKHNjYWxlIDwgMC4wMDAwMSkge1xuICAgICAgICAgICAgc2NhbGUgPSAwLjAwMDAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2NhbGUgPiAxMCkge1xuICAgICAgICAgICAgc2NhbGUgPSAxMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcHJlU2NhbGVEcmFnUG9pbnRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAodGhpcy5kcmFnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRyYWcuZHJhZ2dpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgcHJlU2NhbGVEcmFnUG9pbnRlciA9IHRoaXMuY2FudmFzLkRPTXRvQ2FudmFzKHRoaXMuZHJhZy5wb2ludGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gKyB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0IC8gMlxuICAgICAgICAgIHZhciB0cmFuc2xhdGlvbiA9IHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uO1xuXG4gICAgICAgICAgdmFyIHNjYWxlRnJhYyA9IHNjYWxlIC8gc2NhbGVPbGQ7XG4gICAgICAgICAgdmFyIHR4ID0gKDEgLSBzY2FsZUZyYWMpICogcG9pbnRlci54ICsgdHJhbnNsYXRpb24ueCAqIHNjYWxlRnJhYztcbiAgICAgICAgICB2YXIgdHkgPSAoMSAtIHNjYWxlRnJhYykgKiBwb2ludGVyLnkgKyB0cmFuc2xhdGlvbi55ICogc2NhbGVGcmFjO1xuXG4gICAgICAgICAgdGhpcy5ib2R5LnZpZXcuc2NhbGUgPSBzY2FsZTtcbiAgICAgICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbiA9IHsgeDogdHgsIHk6IHR5IH07XG5cbiAgICAgICAgICBpZiAocHJlU2NhbGVEcmFnUG9pbnRlciAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBwb3N0U2NhbGVEcmFnUG9pbnRlciA9IHRoaXMuY2FudmFzLmNhbnZhc1RvRE9NKHByZVNjYWxlRHJhZ1BvaW50ZXIpO1xuICAgICAgICAgICAgdGhpcy5kcmFnLnBvaW50ZXIueCA9IHBvc3RTY2FsZURyYWdQb2ludGVyLng7XG4gICAgICAgICAgICB0aGlzLmRyYWcucG9pbnRlci55ID0gcG9zdFNjYWxlRHJhZ1BvaW50ZXIueTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfcmVxdWVzdFJlZHJhdycpO1xuXG4gICAgICAgICAgaWYgKHNjYWxlT2xkIDwgc2NhbGUpIHtcbiAgICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3pvb20nLCB7IGRpcmVjdGlvbjogJysnLCBzY2FsZTogdGhpcy5ib2R5LnZpZXcuc2NhbGUgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3pvb20nLCB7IGRpcmVjdGlvbjogJy0nLCBzY2FsZTogdGhpcy5ib2R5LnZpZXcuc2NhbGUgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRXZlbnQgaGFuZGxlciBmb3IgbW91c2Ugd2hlZWwgZXZlbnQsIHVzZWQgdG8gem9vbSB0aGUgdGltZWxpbmVcbiAgICAgICAqIFNlZSBodHRwOi8vYWRvbWFzLm9yZy9qYXZhc2NyaXB0LW1vdXNlLXdoZWVsL1xuICAgICAgICogICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9FaWdodE1lZGlhL2hhbW1lci5qcy9pc3N1ZXMvMjU2XG4gICAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9ICBldmVudFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnb25Nb3VzZVdoZWVsJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1vdXNlV2hlZWwoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy56b29tVmlldyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIC8vIHJldHJpZXZlIGRlbHRhXG4gICAgICAgICAgdmFyIGRlbHRhID0gMDtcbiAgICAgICAgICBpZiAoZXZlbnQud2hlZWxEZWx0YSkge1xuICAgICAgICAgICAgLyogSUUvT3BlcmEuICovXG4gICAgICAgICAgICBkZWx0YSA9IGV2ZW50LndoZWVsRGVsdGEgLyAxMjA7XG4gICAgICAgICAgfSBlbHNlIGlmIChldmVudC5kZXRhaWwpIHtcbiAgICAgICAgICAgIC8qIE1vemlsbGEgY2FzZS4gKi9cbiAgICAgICAgICAgIC8vIEluIE1vemlsbGEsIHNpZ24gb2YgZGVsdGEgaXMgZGlmZmVyZW50IHRoYW4gaW4gSUUuXG4gICAgICAgICAgICAvLyBBbHNvLCBkZWx0YSBpcyBtdWx0aXBsZSBvZiAzLlxuICAgICAgICAgICAgZGVsdGEgPSAtZXZlbnQuZGV0YWlsIC8gMztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiBkZWx0YSBpcyBub256ZXJvLCBoYW5kbGUgaXQuXG4gICAgICAgICAgLy8gQmFzaWNhbGx5LCBkZWx0YSBpcyBub3cgcG9zaXRpdmUgaWYgd2hlZWwgd2FzIHNjcm9sbGVkIHVwLFxuICAgICAgICAgIC8vIGFuZCBuZWdhdGl2ZSwgaWYgd2hlZWwgd2FzIHNjcm9sbGVkIGRvd24uXG4gICAgICAgICAgaWYgKGRlbHRhICE9PSAwKSB7XG5cbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgbmV3IHNjYWxlXG4gICAgICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgICAgICAgIHZhciB6b29tID0gZGVsdGEgLyAxMDtcbiAgICAgICAgICAgIGlmIChkZWx0YSA8IDApIHtcbiAgICAgICAgICAgICAgem9vbSA9IHpvb20gLyAoMSAtIHpvb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2NhbGUgKj0gMSArIHpvb207XG5cbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgcG9pbnRlciBsb2NhdGlvblxuICAgICAgICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoeyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZIH0pO1xuXG4gICAgICAgICAgICAvLyBhcHBseSB0aGUgbmV3IHNjYWxlXG4gICAgICAgICAgICB0aGlzLnpvb20oc2NhbGUsIHBvaW50ZXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFByZXZlbnQgZGVmYXVsdCBhY3Rpb25zIGNhdXNlZCBieSBtb3VzZSB3aGVlbC5cbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogTW91c2UgbW92ZSBoYW5kbGVyIGZvciBjaGVja2luZyB3aGV0aGVyIHRoZSB0aXRsZSBtb3ZlcyBvdmVyIGEgbm9kZSB3aXRoIGEgdGl0bGUuXG4gICAgICAgKiBAcGFyYW0gIHtFdmVudH0gZXZlbnRcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ29uTW91c2VNb3ZlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1vdXNlTW92ZShldmVudCkge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcih7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFkgfSk7XG4gICAgICAgIHZhciBwb3B1cFZpc2libGUgPSBmYWxzZTtcblxuICAgICAgICAvLyBjaGVjayBpZiB0aGUgcHJldmlvdXNseSBzZWxlY3RlZCBub2RlIGlzIHN0aWxsIHNlbGVjdGVkXG4gICAgICAgIGlmICh0aGlzLnBvcHVwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAodGhpcy5wb3B1cC5oaWRkZW4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGVja0hpZGVQb3B1cChwb2ludGVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBpZiB0aGUgcG9wdXAgd2FzIG5vdCBoaWRkZW4gYWJvdmVcbiAgICAgICAgICBpZiAodGhpcy5wb3B1cC5oaWRkZW4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBwb3B1cFZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5wb3B1cC5zZXRQb3NpdGlvbihwb2ludGVyLnggKyAzLCBwb2ludGVyLnkgLSA1KTtcbiAgICAgICAgICAgIHRoaXMucG9wdXAuc2hvdygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHdlIGJpbmQgdGhlIGtleWJvYXJkIHRvIHRoZSBkaXYsIHdlIGhhdmUgdG8gaGlnaGxpZ2h0IGl0IHRvIHVzZSBpdC4gVGhpcyBoaWdobGlnaHRzIGl0IG9uIG1vdXNlIG92ZXIuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMua2V5Ym9hcmQuYmluZFRvV2luZG93ID09PSBmYWxzZSAmJiB0aGlzLm9wdGlvbnMua2V5Ym9hcmQuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuY2FudmFzLmZyYW1lLmZvY3VzKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzdGFydCBhIHRpbWVvdXQgdGhhdCB3aWxsIGNoZWNrIGlmIHRoZSBtb3VzZSBpcyBwb3NpdGlvbmVkIGFib3ZlIGFuIGVsZW1lbnRcbiAgICAgICAgaWYgKHBvcHVwVmlzaWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBpZiAodGhpcy5wb3B1cFRpbWVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5wb3B1cFRpbWVyKTsgLy8gc3RvcCBhbnkgcnVubmluZyBjYWxjdWxhdGlvblRpbWVyXG4gICAgICAgICAgICB0aGlzLnBvcHVwVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy5kcmFnLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnBvcHVwVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5fY2hlY2tTaG93UG9wdXAocG9pbnRlcik7XG4gICAgICAgICAgICB9LCB0aGlzLm9wdGlvbnMudG9vbHRpcERlbGF5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgKiBBZGRpbmcgaG92ZXIgaGlnaGxpZ2h0c1xuICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhvdmVyID09PSB0cnVlKSB7XG4gICAgICAgICAgLy8gYWRkaW5nIGhvdmVyIGhpZ2hsaWdodHNcbiAgICAgICAgICB2YXIgb2JqID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldE5vZGVBdChwb2ludGVyKTtcbiAgICAgICAgICBpZiAob2JqID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9iaiA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRFZGdlQXQocG9pbnRlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5ob3Zlck9iamVjdChvYmopO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2hlY2sgaWYgdGhlcmUgaXMgYW4gZWxlbWVudCBvbiB0aGUgZ2l2ZW4gcG9zaXRpb24gaW4gdGhlIG5ldHdvcmtcbiAgICAgICAqIChhIG5vZGUgb3IgZWRnZSkuIElmIHNvLCBhbmQgaWYgdGhpcyBlbGVtZW50IGhhcyBhIHRpdGxlLFxuICAgICAgICogc2hvdyBhIHBvcHVwIHdpbmRvdyB3aXRoIGl0cyB0aXRsZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3t4Ok51bWJlciwgeTpOdW1iZXJ9fSBwb2ludGVyXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY2hlY2tTaG93UG9wdXAnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jaGVja1Nob3dQb3B1cChwb2ludGVyKSB7XG4gICAgICAgIHZhciB4ID0gdGhpcy5jYW52YXMuX1hjb252ZXJ0RE9NdG9DYW52YXMocG9pbnRlci54KTtcbiAgICAgICAgdmFyIHkgPSB0aGlzLmNhbnZhcy5fWWNvbnZlcnRET010b0NhbnZhcyhwb2ludGVyLnkpO1xuICAgICAgICB2YXIgcG9pbnRlck9iaiA9IHtcbiAgICAgICAgICBsZWZ0OiB4LFxuICAgICAgICAgIHRvcDogeSxcbiAgICAgICAgICByaWdodDogeCxcbiAgICAgICAgICBib3R0b206IHlcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcHJldmlvdXNQb3B1cE9iaklkID0gdGhpcy5wb3B1cE9iaiA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogdGhpcy5wb3B1cE9iai5pZDtcbiAgICAgICAgdmFyIG5vZGVVbmRlckN1cnNvciA9IGZhbHNlO1xuICAgICAgICB2YXIgcG9wdXBUeXBlID0gJ25vZGUnO1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIGEgbm9kZSBpcyB1bmRlciB0aGUgY3Vyc29yLlxuICAgICAgICBpZiAodGhpcy5wb3B1cE9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gc2VhcmNoIHRoZSBub2RlcyBmb3Igb3ZlcmxhcCwgc2VsZWN0IHRoZSB0b3Agb25lIGluIGNhc2Ugb2YgbXVsdGlwbGUgbm9kZXNcbiAgICAgICAgICB2YXIgbm9kZUluZGljZXMgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG4gICAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgICAgIHZhciBub2RlID0gdm9pZCAwO1xuICAgICAgICAgIHZhciBvdmVybGFwcGluZ05vZGVzID0gW107XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGVzW25vZGVJbmRpY2VzW2ldXTtcbiAgICAgICAgICAgIGlmIChub2RlLmlzT3ZlcmxhcHBpbmdXaXRoKHBvaW50ZXJPYmopID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIGlmIChub2RlLmdldFRpdGxlKCkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG92ZXJsYXBwaW5nTm9kZXMucHVzaChub2RlSW5kaWNlc1tpXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3ZlcmxhcHBpbmdOb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgb3ZlcmxhcHBpbmcgbm9kZXMsIHNlbGVjdCB0aGUgbGFzdCBvbmUsIHRoaXMgaXMgdGhlIG9uZSB3aGljaCBpcyBkcmF3biBvbiB0b3Agb2YgdGhlIG90aGVyc1xuICAgICAgICAgICAgdGhpcy5wb3B1cE9iaiA9IG5vZGVzW292ZXJsYXBwaW5nTm9kZXNbb3ZlcmxhcHBpbmdOb2Rlcy5sZW5ndGggLSAxXV07XG4gICAgICAgICAgICAvLyBpZiB5b3UgaG92ZXIgb3ZlciBhIG5vZGUsIHRoZSB0aXRsZSBvZiB0aGUgZWRnZSBpcyBub3Qgc3VwcG9zZWQgdG8gYmUgc2hvd24uXG4gICAgICAgICAgICBub2RlVW5kZXJDdXJzb3IgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnBvcHVwT2JqID09PSB1bmRlZmluZWQgJiYgbm9kZVVuZGVyQ3Vyc29yID09PSBmYWxzZSkge1xuICAgICAgICAgIC8vIHNlYXJjaCB0aGUgZWRnZXMgZm9yIG92ZXJsYXBcbiAgICAgICAgICB2YXIgZWRnZUluZGljZXMgPSB0aGlzLmJvZHkuZWRnZUluZGljZXM7XG4gICAgICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuICAgICAgICAgIHZhciBlZGdlID0gdm9pZCAwO1xuICAgICAgICAgIHZhciBvdmVybGFwcGluZ0VkZ2VzID0gW107XG4gICAgICAgICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgZWRnZUluZGljZXMubGVuZ3RoOyBfaTQrKykge1xuICAgICAgICAgICAgZWRnZSA9IGVkZ2VzW2VkZ2VJbmRpY2VzW19pNF1dO1xuICAgICAgICAgICAgaWYgKGVkZ2UuaXNPdmVybGFwcGluZ1dpdGgocG9pbnRlck9iaikgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgaWYgKGVkZ2UuY29ubmVjdGVkID09PSB0cnVlICYmIGVkZ2UuZ2V0VGl0bGUoKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmxhcHBpbmdFZGdlcy5wdXNoKGVkZ2VJbmRpY2VzW19pNF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG92ZXJsYXBwaW5nRWRnZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5wb3B1cE9iaiA9IGVkZ2VzW292ZXJsYXBwaW5nRWRnZXNbb3ZlcmxhcHBpbmdFZGdlcy5sZW5ndGggLSAxXV07XG4gICAgICAgICAgICBwb3B1cFR5cGUgPSAnZWRnZSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucG9wdXBPYmogIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIHNob3cgcG9wdXAgbWVzc2FnZSB3aW5kb3dcbiAgICAgICAgICBpZiAodGhpcy5wb3B1cE9iai5pZCAhPT0gcHJldmlvdXNQb3B1cE9iaklkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3B1cCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHRoaXMucG9wdXAgPSBuZXcgX1BvcHVwMi5kZWZhdWx0KHRoaXMuY2FudmFzLmZyYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5wb3B1cC5wb3B1cFRhcmdldFR5cGUgPSBwb3B1cFR5cGU7XG4gICAgICAgICAgICB0aGlzLnBvcHVwLnBvcHVwVGFyZ2V0SWQgPSB0aGlzLnBvcHVwT2JqLmlkO1xuXG4gICAgICAgICAgICAvLyBhZGp1c3QgYSBzbWFsbCBvZmZzZXQgc3VjaCB0aGF0IHRoZSBtb3VzZSBjdXJzb3IgaXMgbG9jYXRlZCBpbiB0aGVcbiAgICAgICAgICAgIC8vIGJvdHRvbSBsZWZ0IGxvY2F0aW9uIG9mIHRoZSBwb3B1cCwgYW5kIHlvdSBjYW4gZWFzaWx5IG1vdmUgb3ZlciB0aGVcbiAgICAgICAgICAgIC8vIHBvcHVwIGFyZWFcbiAgICAgICAgICAgIHRoaXMucG9wdXAuc2V0UG9zaXRpb24ocG9pbnRlci54ICsgMywgcG9pbnRlci55IC0gNSk7XG4gICAgICAgICAgICB0aGlzLnBvcHVwLnNldFRleHQodGhpcy5wb3B1cE9iai5nZXRUaXRsZSgpKTtcbiAgICAgICAgICAgIHRoaXMucG9wdXAuc2hvdygpO1xuICAgICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnc2hvd1BvcHVwJywgdGhpcy5wb3B1cE9iai5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLnBvcHVwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucG9wdXAuaGlkZSgpO1xuICAgICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnaGlkZVBvcHVwJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2hlY2sgaWYgdGhlIHBvcHVwIG11c3QgYmUgaGlkZGVuLCB3aGljaCBpcyB0aGUgY2FzZSB3aGVuIHRoZSBtb3VzZSBpcyBub1xuICAgICAgICogbG9uZ2VyIGhvdmVyaW5nIG9uIHRoZSBvYmplY3RcbiAgICAgICAqIEBwYXJhbSB7e3g6TnVtYmVyLCB5Ok51bWJlcn19IHBvaW50ZXJcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19jaGVja0hpZGVQb3B1cCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NoZWNrSGlkZVBvcHVwKHBvaW50ZXIpIHtcbiAgICAgICAgdmFyIHBvaW50ZXJPYmogPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX3BvaW50ZXJUb1Bvc2l0aW9uT2JqZWN0KHBvaW50ZXIpO1xuXG4gICAgICAgIHZhciBzdGlsbE9uT2JqID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnBvcHVwLnBvcHVwVGFyZ2V0VHlwZSA9PT0gJ25vZGUnKSB7XG4gICAgICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1t0aGlzLnBvcHVwLnBvcHVwVGFyZ2V0SWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0aWxsT25PYmogPSB0aGlzLmJvZHkubm9kZXNbdGhpcy5wb3B1cC5wb3B1cFRhcmdldElkXS5pc092ZXJsYXBwaW5nV2l0aChwb2ludGVyT2JqKTtcblxuICAgICAgICAgICAgLy8gaWYgdGhlIG1vdXNlIGlzIHN0aWxsIG9uZSB0aGUgbm9kZSwgd2UgaGF2ZSB0byBjaGVjayBpZiBpdCBpcyBub3QgYWxzbyBvbiBvbmUgdGhhdCBpcyBkcmF3biBvbiB0b3Agb2YgaXQuXG4gICAgICAgICAgICAvLyB3ZSBpbml0aWFsbHkgb25seSBjaGVjayBzdGlsbE9uT2JqIGJlY2F1c2UgdGhpcyBpcyBtdWNoIGZhc3Rlci5cbiAgICAgICAgICAgIGlmIChzdGlsbE9uT2JqID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHZhciBvdmVyTm9kZSA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXROb2RlQXQocG9pbnRlcik7XG4gICAgICAgICAgICAgIHN0aWxsT25PYmogPSBvdmVyTm9kZS5pZCA9PT0gdGhpcy5wb3B1cC5wb3B1cFRhcmdldElkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldE5vZGVBdChwb2ludGVyKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ib2R5LmVkZ2VzW3RoaXMucG9wdXAucG9wdXBUYXJnZXRJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBzdGlsbE9uT2JqID0gdGhpcy5ib2R5LmVkZ2VzW3RoaXMucG9wdXAucG9wdXBUYXJnZXRJZF0uaXNPdmVybGFwcGluZ1dpdGgocG9pbnRlck9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0aWxsT25PYmogPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhpcy5wb3B1cE9iaiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB0aGlzLnBvcHVwLmhpZGUoKTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdoaWRlUG9wdXAnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBJbnRlcmFjdGlvbkhhbmRsZXI7XG4gIH0oKTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBJbnRlcmFjdGlvbkhhbmRsZXI7XG5cbi8qKiovIH0sXG4vKiAxMDkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgdmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuICB2YXIgSGFtbWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG4gIHZhciBoYW1tZXJVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG4gIHZhciBrZXljaGFybSA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuXG4gIHZhciBOYXZpZ2F0aW9uSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOYXZpZ2F0aW9uSGFuZGxlcihib2R5LCBjYW52YXMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOYXZpZ2F0aW9uSGFuZGxlcik7XG5cbiAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcblxuICAgICAgdGhpcy5pY29uc0NyZWF0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMubmF2aWdhdGlvbkhhbW1lcnMgPSBbXTtcbiAgICAgIHRoaXMuYm91bmRGdW5jdGlvbnMgPSB7fTtcbiAgICAgIHRoaXMudG91Y2hUaW1lID0gMDtcbiAgICAgIHRoaXMuYWN0aXZhdGVkID0gZmFsc2U7XG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiYWN0aXZhdGVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5hY3RpdmF0ZWQgPSB0cnVlO190aGlzLmNvbmZpZ3VyZUtleWJvYXJkQmluZGluZ3MoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJkZWFjdGl2YXRlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuYWN0aXZhdGVkID0gZmFsc2U7X3RoaXMuY29uZmlndXJlS2V5Ym9hcmRCaW5kaW5ncygpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImRlc3Ryb3lcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXMua2V5Y2hhcm0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIF90aGlzLmtleWNoYXJtLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhOYXZpZ2F0aW9uSGFuZGxlciwgW3tcbiAgICAgIGtleTogJ3NldE9wdGlvbnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICB0aGlzLmNyZWF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnY3JlYXRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubmF2aWdhdGlvbkJ1dHRvbnMgPT09IHRydWUpIHtcbiAgICAgICAgICBpZiAodGhpcy5pY29uc0NyZWF0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWROYXZpZ2F0aW9uRWxlbWVudHMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pY29uc0NyZWF0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmNsZWFuTmF2aWdhdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb25maWd1cmVLZXlib2FyZEJpbmRpbmdzKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnY2xlYW5OYXZpZ2F0aW9uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhbk5hdmlnYXRpb24oKSB7XG4gICAgICAgIC8vIGNsZWFuIGhhbW1lciBiaW5kaW5nc1xuICAgICAgICBpZiAodGhpcy5uYXZpZ2F0aW9uSGFtbWVycy5sZW5ndGggIT0gMCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5uYXZpZ2F0aW9uSGFtbWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uSGFtbWVyc1tpXS5kZXN0cm95KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubmF2aWdhdGlvbkhhbW1lcnMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFuIHVwIHByZXZpb3VzIG5hdmlnYXRpb24gaXRlbXNcbiAgICAgICAgaWYgKHRoaXMubmF2aWdhdGlvbkRPTSAmJiB0aGlzLm5hdmlnYXRpb25ET01bJ3dyYXBwZXInXSAmJiB0aGlzLm5hdmlnYXRpb25ET01bJ3dyYXBwZXInXS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uRE9NWyd3cmFwcGVyJ10ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5hdmlnYXRpb25ET01bJ3dyYXBwZXInXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmljb25zQ3JlYXRlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0aW9uIG9mIHRoZSBuYXZpZ2F0aW9uIGNvbnRyb2xzIG5vZGVzLiBUaGV5IGFyZSBkcmF3biBvdmVyIHRoZSByZXN0IG9mIHRoZSBub2RlcyBhbmQgYXJlIG5vdCBhZmZlY3RlZCBieSBzY2FsZSBhbmQgdHJhbnNsYXRpb25cbiAgICAgICAqIHRoZXkgaGF2ZSBhIHRyaWdnZXJGdW5jdGlvbiB3aGljaCBpcyBjYWxsZWQgb24gY2xpY2suIElmIHRoZSBwb3NpdGlvbiBvZiB0aGUgbmF2aWdhdGlvbiBjb250cm9scyBpcyBkZXBlbmRlbnRcbiAgICAgICAqIG9uIHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoIG9yIHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodCwgd2UgZmxhZyBob3Jpem9udGFsQWxpZ25MZWZ0IGFuZCB2ZXJ0aWNhbEFsaWduVG9wIGZhbHNlLlxuICAgICAgICogVGhpcyBtZWFucyB0aGF0IHRoZSBsb2NhdGlvbiB3aWxsIGJlIGNvcnJlY3RlZCBieSB0aGUgX3JlbG9jYXRlTmF2aWdhdGlvbiBmdW5jdGlvbiBvbiBhIHNpemUgY2hhbmdlIG9mIHRoZSBjYW52YXMuXG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnbG9hZE5hdmlnYXRpb25FbGVtZW50cycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZE5hdmlnYXRpb25FbGVtZW50cygpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5jbGVhbk5hdmlnYXRpb24oKTtcblxuICAgICAgICB0aGlzLm5hdmlnYXRpb25ET00gPSB7fTtcbiAgICAgICAgdmFyIG5hdmlnYXRpb25EaXZzID0gWyd1cCcsICdkb3duJywgJ2xlZnQnLCAncmlnaHQnLCAnem9vbUluJywgJ3pvb21PdXQnLCAnem9vbUV4dGVuZHMnXTtcbiAgICAgICAgdmFyIG5hdmlnYXRpb25EaXZBY3Rpb25zID0gWydfbW92ZVVwJywgJ19tb3ZlRG93bicsICdfbW92ZUxlZnQnLCAnX21vdmVSaWdodCcsICdfem9vbUluJywgJ196b29tT3V0JywgJ19maXQnXTtcblxuICAgICAgICB0aGlzLm5hdmlnYXRpb25ET01bJ3dyYXBwZXInXSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLm5hdmlnYXRpb25ET01bJ3dyYXBwZXInXS5jbGFzc05hbWUgPSAndmlzLW5hdmlnYXRpb24nO1xuICAgICAgICB0aGlzLmNhbnZhcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLm5hdmlnYXRpb25ET01bJ3dyYXBwZXInXSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYXZpZ2F0aW9uRGl2cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMubmF2aWdhdGlvbkRPTVtuYXZpZ2F0aW9uRGl2c1tpXV0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICB0aGlzLm5hdmlnYXRpb25ET01bbmF2aWdhdGlvbkRpdnNbaV1dLmNsYXNzTmFtZSA9ICd2aXMtYnV0dG9uIHZpcy0nICsgbmF2aWdhdGlvbkRpdnNbaV07XG4gICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uRE9NWyd3cmFwcGVyJ10uYXBwZW5kQ2hpbGQodGhpcy5uYXZpZ2F0aW9uRE9NW25hdmlnYXRpb25EaXZzW2ldXSk7XG5cbiAgICAgICAgICB2YXIgaGFtbWVyID0gbmV3IEhhbW1lcih0aGlzLm5hdmlnYXRpb25ET01bbmF2aWdhdGlvbkRpdnNbaV1dKTtcbiAgICAgICAgICBpZiAobmF2aWdhdGlvbkRpdkFjdGlvbnNbaV0gPT09IFwiX2ZpdFwiKSB7XG4gICAgICAgICAgICBoYW1tZXJVdGlsLm9uVG91Y2goaGFtbWVyLCB0aGlzLl9maXQuYmluZCh0aGlzKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhhbW1lclV0aWwub25Ub3VjaChoYW1tZXIsIHRoaXMuYmluZFRvUmVkcmF3LmJpbmQodGhpcywgbmF2aWdhdGlvbkRpdkFjdGlvbnNbaV0pKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLm5hdmlnYXRpb25IYW1tZXJzLnB1c2goaGFtbWVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVzZSBhIGhhbW1lciBmb3IgdGhlIHJlbGVhc2Ugc28gd2UgZG8gbm90IHJlcXVpcmUgdGhlIG9uZSB1c2VkIGluIHRoZSByZXN0IG9mIHRoZSBuZXR3b3JrXG4gICAgICAgIC8vIHRoZSBvbmUgdGhlIHJlc3QgdXNlcyBjYW4gYmUgb3ZlcmxvYWRlZCBieSB0aGUgbWFuaXB1bGF0aW9uIHN5c3RlbS5cbiAgICAgICAgdmFyIGhhbW1lckZyYW1lID0gbmV3IEhhbW1lcih0aGlzLmNhbnZhcy5mcmFtZSk7XG4gICAgICAgIGhhbW1lclV0aWwub25SZWxlYXNlKGhhbW1lckZyYW1lLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMyLl9zdG9wTW92ZW1lbnQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvbkhhbW1lcnMucHVzaChoYW1tZXJGcmFtZSk7XG5cbiAgICAgICAgdGhpcy5pY29uc0NyZWF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2JpbmRUb1JlZHJhdycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYmluZFRvUmVkcmF3KGFjdGlvbikge1xuICAgICAgICBpZiAodGhpcy5ib3VuZEZ1bmN0aW9uc1thY3Rpb25dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmJvdW5kRnVuY3Rpb25zW2FjdGlvbl0gPSB0aGlzW2FjdGlvbl0uYmluZCh0aGlzKTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImluaXRSZWRyYXdcIiwgdGhpcy5ib3VuZEZ1bmN0aW9uc1thY3Rpb25dKTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3N0YXJ0UmVuZGVyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAndW5iaW5kRnJvbVJlZHJhdycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdW5iaW5kRnJvbVJlZHJhdyhhY3Rpb24pIHtcbiAgICAgICAgaWYgKHRoaXMuYm91bmRGdW5jdGlvbnNbYWN0aW9uXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub2ZmKFwiaW5pdFJlZHJhd1wiLCB0aGlzLmJvdW5kRnVuY3Rpb25zW2FjdGlvbl0pO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfc3RvcFJlbmRlcmluZ1wiKTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5ib3VuZEZ1bmN0aW9uc1thY3Rpb25dO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogdGhpcyBzdG9wcyBhbGwgbW92ZW1lbnQgaW5kdWNlZCBieSB0aGUgbmF2aWdhdGlvbiBidXR0b25zXG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2ZpdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpdCgpIHtcbiAgICAgICAgaWYgKG5ldyBEYXRlKCkudmFsdWVPZigpIC0gdGhpcy50b3VjaFRpbWUgPiA3MDApIHtcbiAgICAgICAgICAvLyBUT0RPOiBmaXggdWdseSBoYWNrIHRvIGF2b2lkIGhhbW1lcidzIGRvdWJsZSBmaXJlaW5nIG9mIGV2ZW50IChiZWNhdXNlIHdlIHVzZSByZWxlYXNlPylcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiZml0XCIsIHsgZHVyYXRpb246IDcwMCB9KTtcbiAgICAgICAgICB0aGlzLnRvdWNoVGltZSA9IG5ldyBEYXRlKCkudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogdGhpcyBzdG9wcyBhbGwgbW92ZW1lbnQgaW5kdWNlZCBieSB0aGUgbmF2aWdhdGlvbiBidXR0b25zXG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3N0b3BNb3ZlbWVudCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3N0b3BNb3ZlbWVudCgpIHtcbiAgICAgICAgZm9yICh2YXIgYm91bmRBY3Rpb24gaW4gdGhpcy5ib3VuZEZ1bmN0aW9ucykge1xuICAgICAgICAgIGlmICh0aGlzLmJvdW5kRnVuY3Rpb25zLmhhc093blByb3BlcnR5KGJvdW5kQWN0aW9uKSkge1xuICAgICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub2ZmKFwiaW5pdFJlZHJhd1wiLCB0aGlzLmJvdW5kRnVuY3Rpb25zW2JvdW5kQWN0aW9uXSk7XG4gICAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3N0b3BSZW5kZXJpbmdcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYm91bmRGdW5jdGlvbnMgPSB7fTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfbW92ZVVwJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbW92ZVVwKCkge1xuICAgICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi55ICs9IHRoaXMub3B0aW9ucy5rZXlib2FyZC5zcGVlZC55O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19tb3ZlRG93bicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX21vdmVEb3duKCkge1xuICAgICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi55IC09IHRoaXMub3B0aW9ucy5rZXlib2FyZC5zcGVlZC55O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19tb3ZlTGVmdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX21vdmVMZWZ0KCkge1xuICAgICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi54ICs9IHRoaXMub3B0aW9ucy5rZXlib2FyZC5zcGVlZC54O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19tb3ZlUmlnaHQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9tb3ZlUmlnaHQoKSB7XG4gICAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnggLT0gdGhpcy5vcHRpb25zLmtleWJvYXJkLnNwZWVkLng7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX3pvb21JbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3pvb21JbigpIHtcbiAgICAgICAgdGhpcy5ib2R5LnZpZXcuc2NhbGUgKj0gMSArIHRoaXMub3B0aW9ucy5rZXlib2FyZC5zcGVlZC56b29tO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCd6b29tJywgeyBkaXJlY3Rpb246ICcrJywgc2NhbGU6IHRoaXMuYm9keS52aWV3LnNjYWxlIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ196b29tT3V0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfem9vbU91dCgpIHtcbiAgICAgICAgdGhpcy5ib2R5LnZpZXcuc2NhbGUgLz0gMSArIHRoaXMub3B0aW9ucy5rZXlib2FyZC5zcGVlZC56b29tO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCd6b29tJywgeyBkaXJlY3Rpb246ICctJywgc2NhbGU6IHRoaXMuYm9keS52aWV3LnNjYWxlIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGJpbmQgYWxsIGtleXMgdXNpbmcga2V5Y2hhcm0uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2NvbmZpZ3VyZUtleWJvYXJkQmluZGluZ3MnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbmZpZ3VyZUtleWJvYXJkQmluZGluZ3MoKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIGlmICh0aGlzLmtleWNoYXJtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmtleWNoYXJtLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMua2V5Ym9hcmQuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMua2V5Ym9hcmQuYmluZFRvV2luZG93ID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLmtleWNoYXJtID0ga2V5Y2hhcm0oeyBjb250YWluZXI6IHdpbmRvdywgcHJldmVudERlZmF1bHQ6IHRydWUgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMua2V5Y2hhcm0gPSBrZXljaGFybSh7IGNvbnRhaW5lcjogdGhpcy5jYW52YXMuZnJhbWUsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMua2V5Y2hhcm0ucmVzZXQoKTtcblxuICAgICAgICAgIGlmICh0aGlzLmFjdGl2YXRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKFwidXBcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczMuYmluZFRvUmVkcmF3KFwiX21vdmVVcFwiKTtcbiAgICAgICAgICAgIH0sIFwia2V5ZG93blwiKTtcbiAgICAgICAgICAgIHRoaXMua2V5Y2hhcm0uYmluZChcImRvd25cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczMuYmluZFRvUmVkcmF3KFwiX21vdmVEb3duXCIpO1xuICAgICAgICAgICAgfSwgXCJrZXlkb3duXCIpO1xuICAgICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKFwibGVmdFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfbW92ZUxlZnRcIik7XG4gICAgICAgICAgICB9LCBcImtleWRvd25cIik7XG4gICAgICAgICAgICB0aGlzLmtleWNoYXJtLmJpbmQoXCJyaWdodFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfbW92ZVJpZ2h0XCIpO1xuICAgICAgICAgICAgfSwgXCJrZXlkb3duXCIpO1xuICAgICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKFwiPVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfem9vbUluXCIpO1xuICAgICAgICAgICAgfSwgXCJrZXlkb3duXCIpO1xuICAgICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKFwibnVtK1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfem9vbUluXCIpO1xuICAgICAgICAgICAgfSwgXCJrZXlkb3duXCIpO1xuICAgICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKFwibnVtLVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfem9vbU91dFwiKTtcbiAgICAgICAgICAgIH0sIFwia2V5ZG93blwiKTtcbiAgICAgICAgICAgIHRoaXMua2V5Y2hhcm0uYmluZChcIi1cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczMuYmluZFRvUmVkcmF3KFwiX3pvb21PdXRcIik7XG4gICAgICAgICAgICB9LCBcImtleWRvd25cIik7XG4gICAgICAgICAgICB0aGlzLmtleWNoYXJtLmJpbmQoXCJbXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdyhcIl96b29tT3V0XCIpO1xuICAgICAgICAgICAgfSwgXCJrZXlkb3duXCIpO1xuICAgICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKFwiXVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfem9vbUluXCIpO1xuICAgICAgICAgICAgfSwgXCJrZXlkb3duXCIpO1xuICAgICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKFwicGFnZXVwXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdyhcIl96b29tSW5cIik7XG4gICAgICAgICAgICB9LCBcImtleWRvd25cIik7XG4gICAgICAgICAgICB0aGlzLmtleWNoYXJtLmJpbmQoXCJwYWdlZG93blwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfem9vbU91dFwiKTtcbiAgICAgICAgICAgIH0sIFwia2V5ZG93blwiKTtcblxuICAgICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKFwidXBcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczMudW5iaW5kRnJvbVJlZHJhdyhcIl9tb3ZlVXBcIik7XG4gICAgICAgICAgICB9LCBcImtleXVwXCIpO1xuICAgICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKFwiZG93blwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KFwiX21vdmVEb3duXCIpO1xuICAgICAgICAgICAgfSwgXCJrZXl1cFwiKTtcbiAgICAgICAgICAgIHRoaXMua2V5Y2hhcm0uYmluZChcImxlZnRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczMudW5iaW5kRnJvbVJlZHJhdyhcIl9tb3ZlTGVmdFwiKTtcbiAgICAgICAgICAgIH0sIFwia2V5dXBcIik7XG4gICAgICAgICAgICB0aGlzLmtleWNoYXJtLmJpbmQoXCJyaWdodFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KFwiX21vdmVSaWdodFwiKTtcbiAgICAgICAgICAgIH0sIFwia2V5dXBcIik7XG4gICAgICAgICAgICB0aGlzLmtleWNoYXJtLmJpbmQoXCI9XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoXCJfem9vbUluXCIpO1xuICAgICAgICAgICAgfSwgXCJrZXl1cFwiKTtcbiAgICAgICAgICAgIHRoaXMua2V5Y2hhcm0uYmluZChcIm51bStcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczMudW5iaW5kRnJvbVJlZHJhdyhcIl96b29tSW5cIik7XG4gICAgICAgICAgICB9LCBcImtleXVwXCIpO1xuICAgICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKFwibnVtLVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KFwiX3pvb21PdXRcIik7XG4gICAgICAgICAgICB9LCBcImtleXVwXCIpO1xuICAgICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKFwiLVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KFwiX3pvb21PdXRcIik7XG4gICAgICAgICAgICB9LCBcImtleXVwXCIpO1xuICAgICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKFwiW1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KFwiX3pvb21PdXRcIik7XG4gICAgICAgICAgICB9LCBcImtleXVwXCIpO1xuICAgICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKFwiXVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KFwiX3pvb21JblwiKTtcbiAgICAgICAgICAgIH0sIFwia2V5dXBcIik7XG4gICAgICAgICAgICB0aGlzLmtleWNoYXJtLmJpbmQoXCJwYWdldXBcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczMudW5iaW5kRnJvbVJlZHJhdyhcIl96b29tSW5cIik7XG4gICAgICAgICAgICB9LCBcImtleXVwXCIpO1xuICAgICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKFwicGFnZWRvd25cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczMudW5iaW5kRnJvbVJlZHJhdyhcIl96b29tT3V0XCIpO1xuICAgICAgICAgICAgfSwgXCJrZXl1cFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gTmF2aWdhdGlvbkhhbmRsZXI7XG4gIH0oKTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBOYXZpZ2F0aW9uSGFuZGxlcjtcblxuLyoqKi8gfSxcbi8qIDExMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICAvKipcbiAgICogUG9wdXAgaXMgYSBjbGFzcyB0byBjcmVhdGUgYSBwb3B1cCB3aW5kb3cgd2l0aCBzb21lIHRleHRcbiAgICogQHBhcmFtIHtFbGVtZW50fSAgY29udGFpbmVyICAgICBUaGUgY29udGFpbmVyIG9iamVjdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt4XVxuICAgKiBAcGFyYW0ge051bWJlcn0gW3ldXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbdGV4dF1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtzdHlsZV0gICAgIEFuIG9iamVjdCBjb250YWluaW5nIGJvcmRlckNvbG9yLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yLCBldGMuXG4gICAqL1xuXG4gIHZhciBQb3B1cCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQb3B1cChjb250YWluZXIpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQb3B1cCk7XG5cbiAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuXG4gICAgICB0aGlzLnggPSAwO1xuICAgICAgdGhpcy55ID0gMDtcbiAgICAgIHRoaXMucGFkZGluZyA9IDU7XG4gICAgICB0aGlzLmhpZGRlbiA9IGZhbHNlO1xuXG4gICAgICAvLyBjcmVhdGUgdGhlIGZyYW1lXG4gICAgICB0aGlzLmZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLmZyYW1lLmNsYXNzTmFtZSA9ICd2aXMtbmV0d29yay10b29sdGlwJztcbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZnJhbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4ICAgSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgcG9wdXAgd2luZG93XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgICBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgcG9wdXAgd2luZG93XG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhQb3B1cCwgW3tcbiAgICAgIGtleTogJ3NldFBvc2l0aW9uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQb3NpdGlvbih4LCB5KSB7XG4gICAgICAgIHRoaXMueCA9IHBhcnNlSW50KHgpO1xuICAgICAgICB0aGlzLnkgPSBwYXJzZUludCh5KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXQgdGhlIGNvbnRlbnQgZm9yIHRoZSBwb3B1cCB3aW5kb3cuIFRoaXMgY2FuIGJlIEhUTUwgY29kZSBvciB0ZXh0LlxuICAgICAgICogQHBhcmFtIHtzdHJpbmcgfCBFbGVtZW50fSBjb250ZW50XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NldFRleHQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFRleHQoY29udGVudCkge1xuICAgICAgICBpZiAoY29udGVudCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICB0aGlzLmZyYW1lLmlubmVySFRNTCA9ICcnO1xuICAgICAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5mcmFtZS5pbm5lckhUTUwgPSBjb250ZW50OyAvLyBzdHJpbmcgY29udGFpbmluZyB0ZXh0IG9yIEhUTUxcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNob3cgdGhlIHBvcHVwIHdpbmRvd1xuICAgICAgICogQHBhcmFtIHtib29sZWFufSBbZG9TaG93XSAgICBTaG93IG9yIGhpZGUgdGhlIHdpbmRvd1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzaG93JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93KGRvU2hvdykge1xuICAgICAgICBpZiAoZG9TaG93ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkb1Nob3cgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRvU2hvdyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmZyYW1lLmNsaWVudEhlaWdodDtcbiAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmZyYW1lLmNsaWVudFdpZHRoO1xuICAgICAgICAgIHZhciBtYXhIZWlnaHQgPSB0aGlzLmZyYW1lLnBhcmVudE5vZGUuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgIHZhciBtYXhXaWR0aCA9IHRoaXMuZnJhbWUucGFyZW50Tm9kZS5jbGllbnRXaWR0aDtcblxuICAgICAgICAgIHZhciB0b3AgPSB0aGlzLnkgLSBoZWlnaHQ7XG4gICAgICAgICAgaWYgKHRvcCArIGhlaWdodCArIHRoaXMucGFkZGluZyA+IG1heEhlaWdodCkge1xuICAgICAgICAgICAgdG9wID0gbWF4SGVpZ2h0IC0gaGVpZ2h0IC0gdGhpcy5wYWRkaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodG9wIDwgdGhpcy5wYWRkaW5nKSB7XG4gICAgICAgICAgICB0b3AgPSB0aGlzLnBhZGRpbmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGxlZnQgPSB0aGlzLng7XG4gICAgICAgICAgaWYgKGxlZnQgKyB3aWR0aCArIHRoaXMucGFkZGluZyA+IG1heFdpZHRoKSB7XG4gICAgICAgICAgICBsZWZ0ID0gbWF4V2lkdGggLSB3aWR0aCAtIHRoaXMucGFkZGluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxlZnQgPCB0aGlzLnBhZGRpbmcpIHtcbiAgICAgICAgICAgIGxlZnQgPSB0aGlzLnBhZGRpbmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5mcmFtZS5zdHlsZS5sZWZ0ID0gbGVmdCArIFwicHhcIjtcbiAgICAgICAgICB0aGlzLmZyYW1lLnN0eWxlLnRvcCA9IHRvcCArIFwicHhcIjtcbiAgICAgICAgICB0aGlzLmZyYW1lLnN0eWxlLnZpc2liaWxpdHkgPSBcInZpc2libGVcIjtcbiAgICAgICAgICB0aGlzLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSGlkZSB0aGUgcG9wdXAgd2luZG93XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2hpZGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgICAgIHRoaXMuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5mcmFtZS5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gUG9wdXA7XG4gIH0oKTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBQb3B1cDtcblxuLyoqKi8gfSxcbi8qIDExMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgdmFyIF9Ob2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NSk7XG5cbiAgdmFyIF9Ob2RlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX05vZGUpO1xuXG4gIHZhciBfRWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oODUpO1xuXG4gIHZhciBfRWRnZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9FZGdlKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgdmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4gIHZhciBTZWxlY3Rpb25IYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlbGVjdGlvbkhhbmRsZXIoYm9keSwgY2FudmFzKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2VsZWN0aW9uSGFuZGxlcik7XG5cbiAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgIHRoaXMuc2VsZWN0aW9uT2JqID0geyBub2RlczogW10sIGVkZ2VzOiBbXSB9O1xuICAgICAgdGhpcy5ob3Zlck9iaiA9IHsgbm9kZXM6IHt9LCBlZGdlczoge30gfTtcblxuICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgICBtdWx0aXNlbGVjdDogZmFsc2UsXG4gICAgICAgIHNlbGVjdGFibGU6IHRydWUsXG4gICAgICAgIHNlbGVjdENvbm5lY3RlZEVkZ2VzOiB0cnVlLFxuICAgICAgICBob3ZlckNvbm5lY3RlZEVkZ2VzOiB0cnVlXG4gICAgICB9O1xuICAgICAgdXRpbC5leHRlbmQodGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfZGF0YUNoYW5nZWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy51cGRhdGVTZWxlY3Rpb24oKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhTZWxlY3Rpb25IYW5kbGVyLCBbe1xuICAgICAga2V5OiAnc2V0T3B0aW9ucycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgZmllbGRzID0gWydtdWx0aXNlbGVjdCcsICdob3ZlckNvbm5lY3RlZEVkZ2VzJywgJ3NlbGVjdGFibGUnLCAnc2VsZWN0Q29ubmVjdGVkRWRnZXMnXTtcbiAgICAgICAgICB1dGlsLnNlbGVjdGl2ZURlZXBFeHRlbmQoZmllbGRzLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogaGFuZGxlcyB0aGUgc2VsZWN0aW9uIHBhcnQgb2YgdGhlIHRhcDtcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlclxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc2VsZWN0T25Qb2ludCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0T25Qb2ludChwb2ludGVyKSB7XG4gICAgICAgIHZhciBzZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNlbGVjdGFibGUgPT09IHRydWUpIHtcbiAgICAgICAgICB2YXIgb2JqID0gdGhpcy5nZXROb2RlQXQocG9pbnRlcikgfHwgdGhpcy5nZXRFZGdlQXQocG9pbnRlcik7XG5cbiAgICAgICAgICAvLyB1bnNlbGVjdCBhZnRlciBnZXR0aW5nIHRoZSBvYmplY3RzIGluIG9yZGVyIHRvIHJlc3RvcmUgd2lkdGggYW5kIGhlaWdodC5cbiAgICAgICAgICB0aGlzLnVuc2VsZWN0QWxsKCk7XG5cbiAgICAgICAgICBpZiAob2JqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkID0gdGhpcy5zZWxlY3RPYmplY3Qob2JqKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzZWxlY3RBZGRpdGlvbmFsT25Qb2ludCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0QWRkaXRpb25hbE9uUG9pbnQocG9pbnRlcikge1xuICAgICAgICB2YXIgc2VsZWN0aW9uQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNlbGVjdGFibGUgPT09IHRydWUpIHtcbiAgICAgICAgICB2YXIgb2JqID0gdGhpcy5nZXROb2RlQXQocG9pbnRlcikgfHwgdGhpcy5nZXRFZGdlQXQocG9pbnRlcik7XG5cbiAgICAgICAgICBpZiAob2JqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbkNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKG9iai5pc1NlbGVjdGVkKCkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgdGhpcy5kZXNlbGVjdE9iamVjdChvYmopO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5zZWxlY3RPYmplY3Qob2JqKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZWN0aW9uQ2hhbmdlZDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZ2VuZXJhdGVDbGlja0V2ZW50JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2VuZXJhdGVDbGlja0V2ZW50KGV2ZW50VHlwZSwgZXZlbnQsIHBvaW50ZXIsIG9sZFNlbGVjdGlvbikge1xuICAgICAgICB2YXIgZW1wdHlTZWxlY3Rpb24gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDQgfHwgYXJndW1lbnRzWzRdID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1s0XTtcblxuICAgICAgICB2YXIgcHJvcGVydGllcyA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGVtcHR5U2VsZWN0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgcHJvcGVydGllcyA9IHsgbm9kZXM6IFtdLCBlZGdlczogW10gfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wZXJ0aWVzID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBwcm9wZXJ0aWVzWydwb2ludGVyJ10gPSB7XG4gICAgICAgICAgRE9NOiB7IHg6IHBvaW50ZXIueCwgeTogcG9pbnRlci55IH0sXG4gICAgICAgICAgY2FudmFzOiB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyhwb2ludGVyKVxuICAgICAgICB9O1xuICAgICAgICBwcm9wZXJ0aWVzWydldmVudCddID0gZXZlbnQ7XG5cbiAgICAgICAgaWYgKG9sZFNlbGVjdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcGVydGllc1sncHJldmlvdXNTZWxlY3Rpb24nXSA9IG9sZFNlbGVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KGV2ZW50VHlwZSwgcHJvcGVydGllcyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnc2VsZWN0T2JqZWN0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3RPYmplY3Qob2JqKSB7XG4gICAgICAgIHZhciBoaWdobGlnaHRFZGdlcyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHRoaXMub3B0aW9ucy5zZWxlY3RDb25uZWN0ZWRFZGdlcyA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICBpZiAob2JqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgX05vZGUyLmRlZmF1bHQpIHtcbiAgICAgICAgICAgIGlmIChoaWdobGlnaHRFZGdlcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICB0aGlzLl9zZWxlY3RDb25uZWN0ZWRFZGdlcyhvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBvYmouc2VsZWN0KCk7XG4gICAgICAgICAgdGhpcy5fYWRkVG9TZWxlY3Rpb24ob2JqKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZGVzZWxlY3RPYmplY3QnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc2VsZWN0T2JqZWN0KG9iaikge1xuICAgICAgICBpZiAob2JqLmlzU2VsZWN0ZWQoKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIG9iai5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuX3JlbW92ZUZyb21TZWxlY3Rpb24ob2JqKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHJldHJpZXZlIGFsbCBub2RlcyBvdmVybGFwcGluZyB3aXRoIGdpdmVuIG9iamVjdFxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAgQW4gb2JqZWN0IHdpdGggcGFyYW1ldGVycyBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b21cbiAgICAgICAqIEByZXR1cm4ge051bWJlcltdfSAgIEFuIGFycmF5IHdpdGggaWQncyBvZiB0aGUgb3ZlcmxhcHBpbmcgbm9kZXNcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19nZXRBbGxOb2Rlc092ZXJsYXBwaW5nV2l0aCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEFsbE5vZGVzT3ZlcmxhcHBpbmdXaXRoKG9iamVjdCkge1xuICAgICAgICB2YXIgb3ZlcmxhcHBpbmdOb2RlcyA9IFtdO1xuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5vZGVJZCA9IHRoaXMuYm9keS5ub2RlSW5kaWNlc1tpXTtcbiAgICAgICAgICBpZiAobm9kZXNbbm9kZUlkXS5pc092ZXJsYXBwaW5nV2l0aChvYmplY3QpKSB7XG4gICAgICAgICAgICBvdmVybGFwcGluZ05vZGVzLnB1c2gobm9kZUlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG92ZXJsYXBwaW5nTm9kZXM7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJuIGEgcG9zaXRpb24gb2JqZWN0IGluIGNhbnZhc3NwYWNlIGZyb20gYSBzaW5nbGUgcG9pbnQgaW4gc2NyZWVuc3BhY2VcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gcG9pbnRlclxuICAgICAgICogQHJldHVybnMge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCByaWdodDogbnVtYmVyLCBib3R0b206IG51bWJlcn19XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfcG9pbnRlclRvUG9zaXRpb25PYmplY3QnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9wb2ludGVyVG9Qb3NpdGlvbk9iamVjdChwb2ludGVyKSB7XG4gICAgICAgIHZhciBjYW52YXNQb3MgPSB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyhwb2ludGVyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsZWZ0OiBjYW52YXNQb3MueCAtIDEsXG4gICAgICAgICAgdG9wOiBjYW52YXNQb3MueSArIDEsXG4gICAgICAgICAgcmlnaHQ6IGNhbnZhc1Bvcy54ICsgMSxcbiAgICAgICAgICBib3R0b206IGNhbnZhc1Bvcy55IC0gMVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEdldCB0aGUgdG9wIG5vZGUgYXQgdGhlIGEgc3BlY2lmaWMgcG9pbnQgKGxpa2UgYSBjbGljaylcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3t4OiBOdW1iZXIsIHk6IE51bWJlcn19IHBvaW50ZXJcbiAgICAgICAqIEByZXR1cm4ge05vZGUgfCB1bmRlZmluZWR9IG5vZGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0Tm9kZUF0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROb2RlQXQocG9pbnRlcikge1xuICAgICAgICB2YXIgcmV0dXJuTm9kZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgLy8gd2UgZmlyc3QgY2hlY2sgaWYgdGhpcyBpcyBhbiBuYXZpZ2F0aW9uIGNvbnRyb2xzIGVsZW1lbnRcbiAgICAgICAgdmFyIHBvc2l0aW9uT2JqZWN0ID0gdGhpcy5fcG9pbnRlclRvUG9zaXRpb25PYmplY3QocG9pbnRlcik7XG4gICAgICAgIHZhciBvdmVybGFwcGluZ05vZGVzID0gdGhpcy5fZ2V0QWxsTm9kZXNPdmVybGFwcGluZ1dpdGgocG9zaXRpb25PYmplY3QpO1xuICAgICAgICAvLyBpZiB0aGVyZSBhcmUgb3ZlcmxhcHBpbmcgbm9kZXMsIHNlbGVjdCB0aGUgbGFzdCBvbmUsIHRoaXMgaXMgdGhlXG4gICAgICAgIC8vIG9uZSB3aGljaCBpcyBkcmF3biBvbiB0b3Agb2YgdGhlIG90aGVyc1xuICAgICAgICBpZiAob3ZlcmxhcHBpbmdOb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgaWYgKHJldHVybk5vZGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJvZHkubm9kZXNbb3ZlcmxhcHBpbmdOb2Rlc1tvdmVybGFwcGluZ05vZGVzLmxlbmd0aCAtIDFdXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG92ZXJsYXBwaW5nTm9kZXNbb3ZlcmxhcHBpbmdOb2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHJldHJpZXZlIGFsbCBlZGdlcyBvdmVybGFwcGluZyB3aXRoIGdpdmVuIG9iamVjdCwgc2VsZWN0b3IgaXMgYXJvdW5kIGNlbnRlclxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAgQW4gb2JqZWN0IHdpdGggcGFyYW1ldGVycyBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b21cbiAgICAgICAqIEByZXR1cm4ge051bWJlcltdfSAgIEFuIGFycmF5IHdpdGggaWQncyBvZiB0aGUgb3ZlcmxhcHBpbmcgbm9kZXNcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19nZXRFZGdlc092ZXJsYXBwaW5nV2l0aCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEVkZ2VzT3ZlcmxhcHBpbmdXaXRoKG9iamVjdCwgb3ZlcmxhcHBpbmdFZGdlcykge1xuICAgICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5LmVkZ2VJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVkZ2VJZCA9IHRoaXMuYm9keS5lZGdlSW5kaWNlc1tpXTtcbiAgICAgICAgICBpZiAoZWRnZXNbZWRnZUlkXS5pc092ZXJsYXBwaW5nV2l0aChvYmplY3QpKSB7XG4gICAgICAgICAgICBvdmVybGFwcGluZ0VkZ2VzLnB1c2goZWRnZUlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiByZXRyaWV2ZSBhbGwgbm9kZXMgb3ZlcmxhcHBpbmcgd2l0aCBnaXZlbiBvYmplY3RcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgIEFuIG9iamVjdCB3aXRoIHBhcmFtZXRlcnMgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tXG4gICAgICAgKiBAcmV0dXJuIHtOdW1iZXJbXX0gICBBbiBhcnJheSB3aXRoIGlkJ3Mgb2YgdGhlIG92ZXJsYXBwaW5nIG5vZGVzXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZ2V0QWxsRWRnZXNPdmVybGFwcGluZ1dpdGgnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRBbGxFZGdlc092ZXJsYXBwaW5nV2l0aChvYmplY3QpIHtcbiAgICAgICAgdmFyIG92ZXJsYXBwaW5nRWRnZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fZ2V0RWRnZXNPdmVybGFwcGluZ1dpdGgob2JqZWN0LCBvdmVybGFwcGluZ0VkZ2VzKTtcbiAgICAgICAgcmV0dXJuIG92ZXJsYXBwaW5nRWRnZXM7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUGxhY2UgaG9sZGVyLiBUbyBpbXBsZW1lbnQgY2hhbmdlIHRoZSBnZXROb2RlQXQgdG8gYSBfZ2V0T2JqZWN0QXQuIEhhdmUgdGhlIF9nZXRPYmplY3RBdCBjYWxsXG4gICAgICAgKiBnZXROb2RlQXQgYW5kIF9nZXRFZGdlc0F0LCB0aGVuIHByaW9ydGl6ZSB0aGUgc2VsZWN0aW9uIHRvIHVzZXIgcHJlZmVyZW5jZXMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHBvaW50ZXJcbiAgICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldEVkZ2VBdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWRnZUF0KHBvaW50ZXIpIHtcbiAgICAgICAgdmFyIHJldHVybkVkZ2UgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB0cnVlIDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgIHZhciBwb3NpdGlvbk9iamVjdCA9IHRoaXMuX3BvaW50ZXJUb1Bvc2l0aW9uT2JqZWN0KHBvaW50ZXIpO1xuICAgICAgICB2YXIgb3ZlcmxhcHBpbmdFZGdlcyA9IHRoaXMuX2dldEFsbEVkZ2VzT3ZlcmxhcHBpbmdXaXRoKHBvc2l0aW9uT2JqZWN0KTtcblxuICAgICAgICBpZiAob3ZlcmxhcHBpbmdFZGdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgaWYgKHJldHVybkVkZ2UgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJvZHkuZWRnZXNbb3ZlcmxhcHBpbmdFZGdlc1tvdmVybGFwcGluZ0VkZ2VzLmxlbmd0aCAtIDFdXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG92ZXJsYXBwaW5nRWRnZXNbb3ZlcmxhcHBpbmdFZGdlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFkZCBvYmplY3QgdG8gdGhlIHNlbGVjdGlvbiBhcnJheS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gb2JqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfYWRkVG9TZWxlY3Rpb24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRUb1NlbGVjdGlvbihvYmopIHtcbiAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIF9Ob2RlMi5kZWZhdWx0KSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25PYmoubm9kZXNbb2JqLmlkXSA9IG9iajtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbk9iai5lZGdlc1tvYmouaWRdID0gb2JqO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQWRkIG9iamVjdCB0byB0aGUgc2VsZWN0aW9uIGFycmF5LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSBvYmpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19hZGRUb0hvdmVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkVG9Ib3ZlcihvYmopIHtcbiAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIF9Ob2RlMi5kZWZhdWx0KSB7XG4gICAgICAgICAgdGhpcy5ob3Zlck9iai5ub2Rlc1tvYmouaWRdID0gb2JqO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuaG92ZXJPYmouZWRnZXNbb2JqLmlkXSA9IG9iajtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZSBhIHNpbmdsZSBvcHRpb24gZnJvbSBzZWxlY3Rpb24uXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3JlbW92ZUZyb21TZWxlY3Rpb24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVGcm9tU2VsZWN0aW9uKG9iaikge1xuICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgX05vZGUyLmRlZmF1bHQpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5zZWxlY3Rpb25PYmoubm9kZXNbb2JqLmlkXTtcbiAgICAgICAgICB0aGlzLl91bnNlbGVjdENvbm5lY3RlZEVkZ2VzKG9iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuc2VsZWN0aW9uT2JqLmVkZ2VzW29iai5pZF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBVbnNlbGVjdCBhbGwuIFRoZSBzZWxlY3Rpb25PYmogaXMgdXNlZnVsIGZvciB0aGlzLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd1bnNlbGVjdEFsbCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdW5zZWxlY3RBbGwoKSB7XG4gICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiB0aGlzLnNlbGVjdGlvbk9iai5ub2Rlcykge1xuICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk9iai5ub2Rlcy5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbk9iai5ub2Rlc1tub2RlSWRdLnVuc2VsZWN0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGVkZ2VJZCBpbiB0aGlzLnNlbGVjdGlvbk9iai5lZGdlcykge1xuICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk9iai5lZGdlcy5oYXNPd25Qcm9wZXJ0eShlZGdlSWQpKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbk9iai5lZGdlc1tlZGdlSWRdLnVuc2VsZWN0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25PYmogPSB7IG5vZGVzOiB7fSwgZWRnZXM6IHt9IH07XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogcmV0dXJuIHRoZSBudW1iZXIgb2Ygc2VsZWN0ZWQgbm9kZXNcbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2dldFNlbGVjdGVkTm9kZUNvdW50JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0U2VsZWN0ZWROb2RlQ291bnQoKSB7XG4gICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiB0aGlzLnNlbGVjdGlvbk9iai5ub2Rlcykge1xuICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk9iai5ub2Rlcy5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogcmV0dXJuIHRoZSBzZWxlY3RlZCBub2RlXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19nZXRTZWxlY3RlZE5vZGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRTZWxlY3RlZE5vZGUoKSB7XG4gICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiB0aGlzLnNlbGVjdGlvbk9iai5ub2Rlcykge1xuICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk9iai5ub2Rlcy5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25PYmoubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiByZXR1cm4gdGhlIHNlbGVjdGVkIGVkZ2VcbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2dldFNlbGVjdGVkRWRnZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFNlbGVjdGVkRWRnZSgpIHtcbiAgICAgICAgZm9yICh2YXIgZWRnZUlkIGluIHRoaXMuc2VsZWN0aW9uT2JqLmVkZ2VzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uT2JqLmVkZ2VzLmhhc093blByb3BlcnR5KGVkZ2VJZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbk9iai5lZGdlc1tlZGdlSWRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHJldHVybiB0aGUgbnVtYmVyIG9mIHNlbGVjdGVkIGVkZ2VzXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19nZXRTZWxlY3RlZEVkZ2VDb3VudCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFNlbGVjdGVkRWRnZUNvdW50KCkge1xuICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICBmb3IgKHZhciBlZGdlSWQgaW4gdGhpcy5zZWxlY3Rpb25PYmouZWRnZXMpIHtcbiAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25PYmouZWRnZXMuaGFzT3duUHJvcGVydHkoZWRnZUlkKSkge1xuICAgICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHJldHVybiB0aGUgbnVtYmVyIG9mIHNlbGVjdGVkIG9iamVjdHMuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19nZXRTZWxlY3RlZE9iamVjdENvdW50JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0U2VsZWN0ZWRPYmplY3RDb3VudCgpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIHRoaXMuc2VsZWN0aW9uT2JqLm5vZGVzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uT2JqLm5vZGVzLmhhc093blByb3BlcnR5KG5vZGVJZCkpIHtcbiAgICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGVkZ2VJZCBpbiB0aGlzLnNlbGVjdGlvbk9iai5lZGdlcykge1xuICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk9iai5lZGdlcy5oYXNPd25Qcm9wZXJ0eShlZGdlSWQpKSB7XG4gICAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2hlY2sgaWYgYW55dGhpbmcgaXMgc2VsZWN0ZWRcbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19zZWxlY3Rpb25Jc0VtcHR5JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2VsZWN0aW9uSXNFbXB0eSgpIHtcbiAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIHRoaXMuc2VsZWN0aW9uT2JqLm5vZGVzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uT2JqLm5vZGVzLmhhc093blByb3BlcnR5KG5vZGVJZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgZWRnZUlkIGluIHRoaXMuc2VsZWN0aW9uT2JqLmVkZ2VzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uT2JqLmVkZ2VzLmhhc093blByb3BlcnR5KGVkZ2VJZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogY2hlY2sgaWYgb25lIG9mIHRoZSBzZWxlY3RlZCBub2RlcyBpcyBhIGNsdXN0ZXIuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY2x1c3RlckluU2VsZWN0aW9uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY2x1c3RlckluU2VsZWN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gdGhpcy5zZWxlY3Rpb25PYmoubm9kZXMpIHtcbiAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25PYmoubm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uT2JqLm5vZGVzW25vZGVJZF0uY2x1c3RlclNpemUgPiAxKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogc2VsZWN0IHRoZSBlZGdlcyBjb25uZWN0ZWQgdG8gdGhlIG5vZGUgdGhhdCBpcyBiZWluZyBzZWxlY3RlZFxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3NlbGVjdENvbm5lY3RlZEVkZ2VzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2VsZWN0Q29ubmVjdGVkRWRnZXMobm9kZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWRnZSA9IG5vZGUuZWRnZXNbaV07XG4gICAgICAgICAgZWRnZS5zZWxlY3QoKTtcbiAgICAgICAgICB0aGlzLl9hZGRUb1NlbGVjdGlvbihlZGdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHNlbGVjdCB0aGUgZWRnZXMgY29ubmVjdGVkIHRvIHRoZSBub2RlIHRoYXQgaXMgYmVpbmcgc2VsZWN0ZWRcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19ob3ZlckNvbm5lY3RlZEVkZ2VzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaG92ZXJDb25uZWN0ZWRFZGdlcyhub2RlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5lZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlZGdlID0gbm9kZS5lZGdlc1tpXTtcbiAgICAgICAgICBlZGdlLmhvdmVyID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLl9hZGRUb0hvdmVyKGVkZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogdW5zZWxlY3QgdGhlIGVkZ2VzIGNvbm5lY3RlZCB0byB0aGUgbm9kZSB0aGF0IGlzIGJlaW5nIHNlbGVjdGVkXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfdW5zZWxlY3RDb25uZWN0ZWRFZGdlcycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3Vuc2VsZWN0Q29ubmVjdGVkRWRnZXMobm9kZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWRnZSA9IG5vZGUuZWRnZXNbaV07XG4gICAgICAgICAgZWRnZS51bnNlbGVjdCgpO1xuICAgICAgICAgIHRoaXMuX3JlbW92ZUZyb21TZWxlY3Rpb24oZWRnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIHNvbWVvbmUgY2xpY2tzIG9uIGEgbm9kZS4gZWl0aGVyIHNlbGVjdCBvciBkZXNlbGVjdCBpdC5cbiAgICAgICAqIElmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIHNlbGVjdGlvbiBhbmQgd2UgZG9uJ3Qgd2FudCB0byBhcHBlbmQgdG8gaXQsIGNsZWFyIHRoZSBleGlzdGluZyBzZWxlY3Rpb25cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge05vZGUgfHwgRWRnZX0gb2JqZWN0XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdibHVyT2JqZWN0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBibHVyT2JqZWN0KG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0LmhvdmVyID09PSB0cnVlKSB7XG4gICAgICAgICAgb2JqZWN0LmhvdmVyID0gZmFsc2U7XG4gICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIF9Ob2RlMi5kZWZhdWx0KSB7XG4gICAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiYmx1ck5vZGVcIiwgeyBub2RlOiBvYmplY3QuaWQgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJibHVyRWRnZVwiLCB7IGVkZ2U6IG9iamVjdC5pZCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIHNvbWVvbmUgY2xpY2tzIG9uIGEgbm9kZS4gZWl0aGVyIHNlbGVjdCBvciBkZXNlbGVjdCBpdC5cbiAgICAgICAqIElmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIHNlbGVjdGlvbiBhbmQgd2UgZG9uJ3Qgd2FudCB0byBhcHBlbmQgdG8gaXQsIGNsZWFyIHRoZSBleGlzdGluZyBzZWxlY3Rpb25cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge05vZGUgfHwgRWRnZX0gb2JqZWN0XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdob3Zlck9iamVjdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaG92ZXJPYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHZhciBob3ZlckNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gcmVtb3ZlIGFsbCBub2RlIGhvdmVyIGhpZ2hsaWdodHNcbiAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIHRoaXMuaG92ZXJPYmoubm9kZXMpIHtcbiAgICAgICAgICBpZiAodGhpcy5ob3Zlck9iai5ub2Rlcy5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0ID09PSB1bmRlZmluZWQgfHwgb2JqZWN0IGluc3RhbmNlb2YgX05vZGUyLmRlZmF1bHQgJiYgb2JqZWN0LmlkICE9IG5vZGVJZCB8fCBvYmplY3QgaW5zdGFuY2VvZiBfRWRnZTIuZGVmYXVsdCkge1xuICAgICAgICAgICAgICB0aGlzLmJsdXJPYmplY3QodGhpcy5ob3Zlck9iai5ub2Rlc1tub2RlSWRdKTtcbiAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuaG92ZXJPYmoubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICAgICAgaG92ZXJDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmluZyBhbGwgZWRnZSBob3ZlciBoaWdobGlnaHRzXG4gICAgICAgIGZvciAodmFyIGVkZ2VJZCBpbiB0aGlzLmhvdmVyT2JqLmVkZ2VzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaG92ZXJPYmouZWRnZXMuaGFzT3duUHJvcGVydHkoZWRnZUlkKSkge1xuICAgICAgICAgICAgLy8gaWYgdGhlIGhvdmVyIGhhcyBiZWVuIGNoYW5nZWQgaGVyZSBpdCBtZWFucyB0aGF0IHRoZSBub2RlIGhhcyBiZWVuIGhvdmVyZWQgb3ZlciBvciBvZmZcbiAgICAgICAgICAgIC8vIHdlIHRoZW4gZG8gbm90IHVzZSB0aGUgYmx1ck9iamVjdCBtZXRob2QgaGVyZS5cbiAgICAgICAgICAgIGlmIChob3ZlckNoYW5nZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgdGhpcy5ob3Zlck9iai5lZGdlc1tlZGdlSWRdLmhvdmVyID0gZmFsc2U7XG4gICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmhvdmVyT2JqLmVkZ2VzW2VkZ2VJZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiB0aGUgYmx1ciByZW1haW5zIHRoZSBzYW1lIGFuZCB0aGUgb2JqZWN0IGlzIHVuZGVmaW5lZCAobW91c2Ugb2ZmKSwgd2UgYmx1ciB0aGUgZWRnZVxuICAgICAgICAgICAgZWxzZSBpZiAob2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJsdXJPYmplY3QodGhpcy5ob3Zlck9iai5lZGdlc1tlZGdlSWRdKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5ob3Zlck9iai5lZGdlc1tlZGdlSWRdO1xuICAgICAgICAgICAgICAgIGhvdmVyQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2JqZWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAob2JqZWN0LmhvdmVyID09PSBmYWxzZSkge1xuICAgICAgICAgICAgb2JqZWN0LmhvdmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2FkZFRvSG92ZXIob2JqZWN0KTtcbiAgICAgICAgICAgIGhvdmVyQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgX05vZGUyLmRlZmF1bHQpIHtcbiAgICAgICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImhvdmVyTm9kZVwiLCB7IG5vZGU6IG9iamVjdC5pZCB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJob3ZlckVkZ2VcIiwgeyBlZGdlOiBvYmplY3QuaWQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBfTm9kZTIuZGVmYXVsdCAmJiB0aGlzLm9wdGlvbnMuaG92ZXJDb25uZWN0ZWRFZGdlcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5faG92ZXJDb25uZWN0ZWRFZGdlcyhvYmplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChob3ZlckNoYW5nZWQgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfcmVxdWVzdFJlZHJhdycpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICpcbiAgICAgICAqIHJldHJpZXZlIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgb2JqZWN0c1xuICAgICAgICogQHJldHVybiB7e25vZGVzOiBBcnJheS48U3RyaW5nPiwgZWRnZXM6IEFycmF5LjxTdHJpbmc+fX0gc2VsZWN0aW9uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldFNlbGVjdGlvbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKCkge1xuICAgICAgICB2YXIgbm9kZUlkcyA9IHRoaXMuZ2V0U2VsZWN0ZWROb2RlcygpO1xuICAgICAgICB2YXIgZWRnZUlkcyA9IHRoaXMuZ2V0U2VsZWN0ZWRFZGdlcygpO1xuICAgICAgICByZXR1cm4geyBub2Rlczogbm9kZUlkcywgZWRnZXM6IGVkZ2VJZHMgfTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKlxuICAgICAgICogcmV0cmlldmUgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBub2Rlc1xuICAgICAgICogQHJldHVybiB7U3RyaW5nW119IHNlbGVjdGlvbiAgICBBbiBhcnJheSB3aXRoIHRoZSBpZHMgb2YgdGhlXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQgbm9kZXMuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldFNlbGVjdGVkTm9kZXMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlbGVjdGVkTm9kZXMoKSB7XG4gICAgICAgIHZhciBpZEFycmF5ID0gW107XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2VsZWN0YWJsZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiB0aGlzLnNlbGVjdGlvbk9iai5ub2Rlcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uT2JqLm5vZGVzLmhhc093blByb3BlcnR5KG5vZGVJZCkpIHtcbiAgICAgICAgICAgICAgaWRBcnJheS5wdXNoKHRoaXMuc2VsZWN0aW9uT2JqLm5vZGVzW25vZGVJZF0uaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWRBcnJheTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKlxuICAgICAgICogcmV0cmlldmUgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBlZGdlc1xuICAgICAgICogQHJldHVybiB7QXJyYXl9IHNlbGVjdGlvbiAgICBBbiBhcnJheSB3aXRoIHRoZSBpZHMgb2YgdGhlXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQgbm9kZXMuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldFNlbGVjdGVkRWRnZXMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlbGVjdGVkRWRnZXMoKSB7XG4gICAgICAgIHZhciBpZEFycmF5ID0gW107XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2VsZWN0YWJsZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGZvciAodmFyIGVkZ2VJZCBpbiB0aGlzLnNlbGVjdGlvbk9iai5lZGdlcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uT2JqLmVkZ2VzLmhhc093blByb3BlcnR5KGVkZ2VJZCkpIHtcbiAgICAgICAgICAgICAgaWRBcnJheS5wdXNoKHRoaXMuc2VsZWN0aW9uT2JqLmVkZ2VzW2VkZ2VJZF0uaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWRBcnJheTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBVcGRhdGVzIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuICAgICAgICogQHBhcmFtIHt7bm9kZXM6IEFycmF5LjxTdHJpbmc+LCBlZGdlczogQXJyYXkuPFN0cmluZz59fSBTZWxlY3Rpb25cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT3B0aW9uc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzZXRTZWxlY3Rpb24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNlbGVjdGlvbihzZWxlY3Rpb24pIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICB2YXIgaSA9IHZvaWQgMCxcbiAgICAgICAgICAgIGlkID0gdm9pZCAwO1xuXG4gICAgICAgIGlmICghc2VsZWN0aW9uIHx8ICFzZWxlY3Rpb24ubm9kZXMgJiYgIXNlbGVjdGlvbi5lZGdlcykgdGhyb3cgJ1NlbGVjdGlvbiBtdXN0IGJlIGFuIG9iamVjdCB3aXRoIG5vZGVzIGFuZC9vciBlZGdlcyBwcm9wZXJ0aWVzJztcbiAgICAgICAgLy8gZmlyc3QgdW5zZWxlY3QgYW55IHNlbGVjdGVkIG5vZGUsIGlmIG9wdGlvbiBpcyB0cnVlIG9yIHVuZGVmaW5lZFxuICAgICAgICBpZiAob3B0aW9ucy51bnNlbGVjdEFsbCB8fCBvcHRpb25zLnVuc2VsZWN0QWxsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnVuc2VsZWN0QWxsKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGVjdGlvbi5ub2Rlcykge1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWxlY3Rpb24ubm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlkID0gc2VsZWN0aW9uLm5vZGVzW2ldO1xuXG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tpZF07XG4gICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ05vZGUgd2l0aCBpZCBcIicgKyBpZCArICdcIiBub3QgZm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRvbid0IHNlbGVjdCBlZGdlcyB3aXRoIGl0XG4gICAgICAgICAgICB0aGlzLnNlbGVjdE9iamVjdChub2RlLCBvcHRpb25zLmhpZ2hsaWdodEVkZ2VzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZWN0aW9uLmVkZ2VzKSB7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlbGVjdGlvbi5lZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWQgPSBzZWxlY3Rpb24uZWRnZXNbaV07XG5cbiAgICAgICAgICAgIHZhciBlZGdlID0gdGhpcy5ib2R5LmVkZ2VzW2lkXTtcbiAgICAgICAgICAgIGlmICghZWRnZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignRWRnZSB3aXRoIGlkIFwiJyArIGlkICsgJ1wiIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZWxlY3RPYmplY3QoZWRnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19yZXF1ZXN0UmVkcmF3Jyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogc2VsZWN0IHplcm8gb3IgbW9yZSBub2RlcyB3aXRoIHRoZSBvcHRpb24gdG8gaGlnaGxpZ2h0IGVkZ2VzXG4gICAgICAgKiBAcGFyYW0ge051bWJlcltdIHwgU3RyaW5nW119IHNlbGVjdGlvbiAgICAgQW4gYXJyYXkgd2l0aCB0aGUgaWRzIG9mIHRoZVxuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkIG5vZGVzLlxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBbaGlnaGxpZ2h0RWRnZXNdXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NlbGVjdE5vZGVzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3ROb2RlcyhzZWxlY3Rpb24pIHtcbiAgICAgICAgdmFyIGhpZ2hsaWdodEVkZ2VzID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICBpZiAoIXNlbGVjdGlvbiB8fCBzZWxlY3Rpb24ubGVuZ3RoID09PSB1bmRlZmluZWQpIHRocm93ICdTZWxlY3Rpb24gbXVzdCBiZSBhbiBhcnJheSB3aXRoIGlkcyc7XG5cbiAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24oeyBub2Rlczogc2VsZWN0aW9uIH0sIHsgaGlnaGxpZ2h0RWRnZXM6IGhpZ2hsaWdodEVkZ2VzIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHNlbGVjdCB6ZXJvIG9yIG1vcmUgZWRnZXNcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyW10gfCBTdHJpbmdbXX0gc2VsZWN0aW9uICAgICBBbiBhcnJheSB3aXRoIHRoZSBpZHMgb2YgdGhlXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQgbm9kZXMuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NlbGVjdEVkZ2VzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3RFZGdlcyhzZWxlY3Rpb24pIHtcbiAgICAgICAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLmxlbmd0aCA9PT0gdW5kZWZpbmVkKSB0aHJvdyAnU2VsZWN0aW9uIG11c3QgYmUgYW4gYXJyYXkgd2l0aCBpZHMnO1xuXG4gICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKHsgZWRnZXM6IHNlbGVjdGlvbiB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBWYWxpZGF0ZSB0aGUgc2VsZWN0aW9uOiByZW1vdmUgaWRzIG9mIG5vZGVzIHdoaWNoIG5vIGxvbmdlciBleGlzdFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAndXBkYXRlU2VsZWN0aW9uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVTZWxlY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiB0aGlzLnNlbGVjdGlvbk9iai5ub2Rlcykge1xuICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk9iai5ub2Rlcy5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYm9keS5ub2Rlcy5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNlbGVjdGlvbk9iai5ub2Rlc1tub2RlSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBlZGdlSWQgaW4gdGhpcy5zZWxlY3Rpb25PYmouZWRnZXMpIHtcbiAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25PYmouZWRnZXMuaGFzT3duUHJvcGVydHkoZWRnZUlkKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmJvZHkuZWRnZXMuaGFzT3duUHJvcGVydHkoZWRnZUlkKSkge1xuICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zZWxlY3Rpb25PYmouZWRnZXNbZWRnZUlkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gU2VsZWN0aW9uSGFuZGxlcjtcbiAgfSgpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IFNlbGVjdGlvbkhhbmRsZXI7XG5cbi8qKiovIH0sXG4vKiAxMTIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX3NsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfSB9OyB9KCk7XG5cbiAgdmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX05ldHdvcmtVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDMpO1xuXG4gIHZhciBfTmV0d29ya1V0aWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTmV0d29ya1V0aWwpO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbiAgdmFyIExheW91dEVuZ2luZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMYXlvdXRFbmdpbmUoYm9keSkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExheW91dEVuZ2luZSk7XG5cbiAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG5cbiAgICAgIHRoaXMuaW5pdGlhbFJhbmRvbVNlZWQgPSBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwKTtcbiAgICAgIHRoaXMucmFuZG9tU2VlZCA9IHRoaXMuaW5pdGlhbFJhbmRvbVNlZWQ7XG4gICAgICB0aGlzLnNldFBoeXNpY3MgPSBmYWxzZTtcbiAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgdGhpcy5vcHRpb25zQmFja3VwID0geyBwaHlzaWNzOiB7fSB9O1xuXG4gICAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgICByYW5kb21TZWVkOiB1bmRlZmluZWQsXG4gICAgICAgIGltcHJvdmVkTGF5b3V0OiB0cnVlLFxuICAgICAgICBoaWVyYXJjaGljYWw6IHtcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICBsZXZlbFNlcGFyYXRpb246IDE1MCxcbiAgICAgICAgICBub2RlU3BhY2luZzogMTAwLFxuICAgICAgICAgIHRyZWVTcGFjaW5nOiAyMDAsXG4gICAgICAgICAgYmxvY2tTaGlmdGluZzogdHJ1ZSxcbiAgICAgICAgICBlZGdlTWluaW1pemF0aW9uOiB0cnVlLFxuICAgICAgICAgIHBhcmVudENlbnRyYWxpemF0aW9uOiB0cnVlLFxuICAgICAgICAgIGRpcmVjdGlvbjogJ1VEJywgLy8gVUQsIERVLCBMUiwgUkxcbiAgICAgICAgICBzb3J0TWV0aG9kOiAnaHVic2l6ZScgLy8gaHVic2l6ZSwgZGlyZWN0ZWRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHV0aWwuZXh0ZW5kKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG4gICAgICB0aGlzLmJpbmRFdmVudExpc3RlbmVycygpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhMYXlvdXRFbmdpbmUsIFt7XG4gICAgICBrZXk6ICdiaW5kRXZlbnRMaXN0ZW5lcnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignX2RhdGFDaGFuZ2VkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLnNldHVwSGllcmFyY2hpY2FsTGF5b3V0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignX2RhdGFMb2FkZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMubGF5b3V0TmV0d29yaygpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ19yZXNldEhpZXJhcmNoaWNhbExheW91dCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy5zZXR1cEhpZXJhcmNoaWNhbExheW91dCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzZXRPcHRpb25zJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMsIGFsbE9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBwcmV2SGllcmFyY2hpY2FsU3RhdGUgPSB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmVuYWJsZWQ7XG4gICAgICAgICAgdXRpbC5zZWxlY3RpdmVEZWVwRXh0ZW5kKFtcInJhbmRvbVNlZWRcIiwgXCJpbXByb3ZlZExheW91dFwiXSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgICB1dGlsLm1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMsICdoaWVyYXJjaGljYWwnKTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5yYW5kb21TZWVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbFJhbmRvbVNlZWQgPSBvcHRpb25zLnJhbmRvbVNlZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHByZXZIaWVyYXJjaGljYWxTdGF0ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAvLyByZWZyZXNoIHRoZSBvdmVycmlkZGVuIG9wdGlvbnMgZm9yIG5vZGVzIGFuZCBlZGdlcy5cbiAgICAgICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgncmVmcmVzaCcsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIGxldmVsIHNlcGFyYXRpb24gaXMgdGhlIHJpZ2h0IHdheSB1cFxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZGlyZWN0aW9uID09PSAnUkwnIHx8IHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZGlyZWN0aW9uID09PSAnRFUnKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmxldmVsU2VwYXJhdGlvbiA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmxldmVsU2VwYXJhdGlvbiAqPSAtMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwubGV2ZWxTZXBhcmF0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwubGV2ZWxTZXBhcmF0aW9uICo9IC0xO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19yZXNldEhpZXJhcmNoaWNhbExheW91dCcpO1xuICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGUgaGllcmFyY2hpY2FsIHN5c3RlbSBuZWVkcyBpdCdzIG93biBwaHlzaWNzIGFuZCBzbW9vdGggY3VydmUgc2V0dGluZ3MsIHdlIGFkYXB0IHRoZSBvdGhlciBvcHRpb25zIGlmIG5lZWRlZC5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkYXB0QWxsT3B0aW9uc0ZvckhpZXJhcmNoaWNhbExheW91dChhbGxPcHRpb25zKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHByZXZIaWVyYXJjaGljYWxTdGF0ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAvLyByZWZyZXNoIHRoZSBvdmVycmlkZGVuIG9wdGlvbnMgZm9yIG5vZGVzIGFuZCBlZGdlcy5cbiAgICAgICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgncmVmcmVzaCcpO1xuICAgICAgICAgICAgICByZXR1cm4gdXRpbC5kZWVwRXh0ZW5kKGFsbE9wdGlvbnMsIHRoaXMub3B0aW9uc0JhY2t1cCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbGxPcHRpb25zO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2FkYXB0QWxsT3B0aW9uc0ZvckhpZXJhcmNoaWNhbExheW91dCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWRhcHRBbGxPcHRpb25zRm9ySGllcmFyY2hpY2FsTGF5b3V0KGFsbE9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIC8vIHNldCB0aGUgcGh5c2ljc1xuICAgICAgICAgIGlmIChhbGxPcHRpb25zLnBoeXNpY3MgPT09IHVuZGVmaW5lZCB8fCBhbGxPcHRpb25zLnBoeXNpY3MgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGFsbE9wdGlvbnMucGh5c2ljcyA9IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdGhpcy5vcHRpb25zQmFja3VwLnBoeXNpY3MuZW5hYmxlZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHRoaXMub3B0aW9uc0JhY2t1cC5waHlzaWNzLmVuYWJsZWQsXG4gICAgICAgICAgICAgIHNvbHZlcjogJ2hpZXJhcmNoaWNhbFJlcHVsc2lvbidcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNCYWNrdXAucGh5c2ljcy5lbmFibGVkID0gdGhpcy5vcHRpb25zQmFja3VwLnBoeXNpY3MuZW5hYmxlZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHRoaXMub3B0aW9uc0JhY2t1cC5waHlzaWNzLmVuYWJsZWQ7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNCYWNrdXAucGh5c2ljcy5zb2x2ZXIgPSB0aGlzLm9wdGlvbnNCYWNrdXAucGh5c2ljcy5zb2x2ZXIgfHwgJ2Jhcm5lc0h1dCc7XG4gICAgICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKGFsbE9wdGlvbnMucGh5c2ljcykgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNCYWNrdXAucGh5c2ljcy5lbmFibGVkID0gYWxsT3B0aW9ucy5waHlzaWNzLmVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhbGxPcHRpb25zLnBoeXNpY3MuZW5hYmxlZDtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc0JhY2t1cC5waHlzaWNzLnNvbHZlciA9IGFsbE9wdGlvbnMucGh5c2ljcy5zb2x2ZXIgfHwgJ2Jhcm5lc0h1dCc7XG4gICAgICAgICAgICBhbGxPcHRpb25zLnBoeXNpY3Muc29sdmVyID0gJ2hpZXJhcmNoaWNhbFJlcHVsc2lvbic7XG4gICAgICAgICAgfSBlbHNlIGlmIChhbGxPcHRpb25zLnBoeXNpY3MgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNCYWNrdXAucGh5c2ljcy5zb2x2ZXIgPSAnYmFybmVzSHV0JztcbiAgICAgICAgICAgIGFsbE9wdGlvbnMucGh5c2ljcyA9IHsgc29sdmVyOiAnaGllcmFyY2hpY2FsUmVwdWxzaW9uJyB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGdldCB0aGUgdHlwZSBvZiBzdGF0aWMgc21vb3RoIGN1cnZlIGluIGNhc2UgaXQgaXMgcmVxdWlyZWRcbiAgICAgICAgICB2YXIgdHlwZSA9ICdob3Jpem9udGFsJztcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5kaXJlY3Rpb24gPT09ICdSTCcgfHwgdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5kaXJlY3Rpb24gPT09ICdMUicpIHtcbiAgICAgICAgICAgIHR5cGUgPSAndmVydGljYWwnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGRpc2FibGUgc21vb3RoIGN1cnZlcyBpZiBub3RoaW5nIGlzIGRlZmluZWQuIElmIHNtb290aCBjdXJ2ZXMgaGF2ZSBiZWVuIHR1cm5lZCBvbiwgdHVybiB0aGVtIGludG8gc3RhdGljIHNtb290aCBjdXJ2ZXMuXG4gICAgICAgICAgaWYgKGFsbE9wdGlvbnMuZWRnZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zQmFja3VwLmVkZ2VzID0geyBzbW9vdGg6IHsgZW5hYmxlZDogdHJ1ZSwgdHlwZTogJ2R5bmFtaWMnIH0gfTtcbiAgICAgICAgICAgIGFsbE9wdGlvbnMuZWRnZXMgPSB7IHNtb290aDogZmFsc2UgfTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc0JhY2t1cC5lZGdlcyA9IHsgc21vb3RoOiB7IGVuYWJsZWQ6IHRydWUsIHR5cGU6ICdkeW5hbWljJyB9IH07XG4gICAgICAgICAgICBhbGxPcHRpb25zLmVkZ2VzLnNtb290aCA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgdGhpcy5vcHRpb25zQmFja3VwLmVkZ2VzID0geyBzbW9vdGg6IGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoIH07XG4gICAgICAgICAgICAgIGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoID0geyBlbmFibGVkOiBhbGxPcHRpb25zLmVkZ2VzLnNtb290aCwgdHlwZTogdHlwZSB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gYWxsb3cgY3VzdG9tIHR5cGVzIGV4Y2VwdCBmb3IgZHluYW1pY1xuICAgICAgICAgICAgICBpZiAoYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGgudHlwZSAhPT0gdW5kZWZpbmVkICYmIGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoLnR5cGUgIT09ICdkeW5hbWljJykge1xuICAgICAgICAgICAgICAgIHR5cGUgPSBhbGxPcHRpb25zLmVkZ2VzLnNtb290aC50eXBlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5vcHRpb25zQmFja3VwLmVkZ2VzID0ge1xuICAgICAgICAgICAgICAgIHNtb290aDogYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGguZW5hYmxlZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoLmVuYWJsZWQsXG4gICAgICAgICAgICAgICAgdHlwZTogYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGgudHlwZSA9PT0gdW5kZWZpbmVkID8gJ2R5bmFtaWMnIDogYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGgudHlwZSxcbiAgICAgICAgICAgICAgICByb3VuZG5lc3M6IGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoLnJvdW5kbmVzcyA9PT0gdW5kZWZpbmVkID8gMC41IDogYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGgucm91bmRuZXNzLFxuICAgICAgICAgICAgICAgIGZvcmNlRGlyZWN0aW9uOiBhbGxPcHRpb25zLmVkZ2VzLnNtb290aC5mb3JjZURpcmVjdGlvbiA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBhbGxPcHRpb25zLmVkZ2VzLnNtb290aC5mb3JjZURpcmVjdGlvblxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBhbGxPcHRpb25zLmVkZ2VzLnNtb290aCA9IHtcbiAgICAgICAgICAgICAgICBlbmFibGVkOiBhbGxPcHRpb25zLmVkZ2VzLnNtb290aC5lbmFibGVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGguZW5hYmxlZCxcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIHJvdW5kbmVzczogYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGgucm91bmRuZXNzID09PSB1bmRlZmluZWQgPyAwLjUgOiBhbGxPcHRpb25zLmVkZ2VzLnNtb290aC5yb3VuZG5lc3MsXG4gICAgICAgICAgICAgICAgZm9yY2VEaXJlY3Rpb246IGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoLmZvcmNlRGlyZWN0aW9uID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoLmZvcmNlRGlyZWN0aW9uXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZm9yY2UgYWxsIGVkZ2VzIGludG8gc3RhdGljIHNtb290aCBjdXJ2ZXMuIE9ubHkgYXBwbGllcyB0byBlZGdlcyB0aGF0IGRvIG5vdCB1c2UgdGhlIGdsb2JhbCBvcHRpb25zIGZvciBzbW9vdGguXG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2ZvcmNlRGlzYWJsZUR5bmFtaWNDdXJ2ZXMnLCB0eXBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhbGxPcHRpb25zO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NlZWRlZFJhbmRvbScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2VlZGVkUmFuZG9tKCkge1xuICAgICAgICB2YXIgeCA9IE1hdGguc2luKHRoaXMucmFuZG9tU2VlZCsrKSAqIDEwMDAwO1xuICAgICAgICByZXR1cm4geCAtIE1hdGguZmxvb3IoeCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAncG9zaXRpb25Jbml0aWFsbHknLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBvc2l0aW9uSW5pdGlhbGx5KG5vZGVzQXJyYXkpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZW5hYmxlZCAhPT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMucmFuZG9tU2VlZCA9IHRoaXMuaW5pdGlhbFJhbmRvbVNlZWQ7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlc0FycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzQXJyYXlbaV07XG4gICAgICAgICAgICB2YXIgcmFkaXVzID0gMTAgKiAwLjEgKiBub2Rlc0FycmF5Lmxlbmd0aCArIDEwO1xuICAgICAgICAgICAgdmFyIGFuZ2xlID0gMiAqIE1hdGguUEkgKiB0aGlzLnNlZWRlZFJhbmRvbSgpO1xuICAgICAgICAgICAgaWYgKG5vZGUueCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIG5vZGUueCA9IHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBub2RlLnkgPSByYWRpdXMgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlIEthbWFkYSBLYXdhaSB0byBwb3NpdGlvbiBub2Rlcy4gVGhpcyBpcyBxdWl0ZSBhIGhlYXZ5IGFsZ29yaXRobSBzbyBpZiB0aGVyZSBhcmUgYSBsb3Qgb2Ygbm9kZXMgd2VcbiAgICAgICAqIGNsdXN0ZXIgdGhlbSBmaXJzdCB0byByZWR1Y2UgdGhlIGFtb3VudC5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnbGF5b3V0TmV0d29yaycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbGF5b3V0TmV0d29yaygpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZW5hYmxlZCAhPT0gdHJ1ZSAmJiB0aGlzLm9wdGlvbnMuaW1wcm92ZWRMYXlvdXQgPT09IHRydWUpIHtcbiAgICAgICAgICAvLyBmaXJzdCBjaGVjayBpZiB3ZSBzaG91bGQgS2FtYWRhIEthd2FpIHRvIGxheW91dC4gVGhlIHRocmVzaG9sZCBpcyBpZiBsZXNzIHRoYW4gaGFsZiBvZiB0aGUgdmlzaWJsZVxuICAgICAgICAgIC8vIG5vZGVzIGhhdmUgcHJlZGVmaW5lZCBwb3NpdGlvbnMgd2UgdXNlIHRoaXMuXG4gICAgICAgICAgdmFyIHBvc2l0aW9uRGVmaW5lZCA9IDA7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMuYm9keS5ub2RlSW5kaWNlc1tpXV07XG4gICAgICAgICAgICBpZiAobm9kZS5wcmVkZWZpbmVkUG9zaXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgcG9zaXRpb25EZWZpbmVkICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaWYgbGVzcyB0aGFuIGhhbGYgb2YgdGhlIG5vZGVzIGhhdmUgYSBwcmVkZWZpbmVkIHBvc2l0aW9uIHdlIGNvbnRpbnVlXG4gICAgICAgICAgaWYgKHBvc2l0aW9uRGVmaW5lZCA8IDAuNSAqIHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBNQVhfTEVWRUxTID0gMTA7XG4gICAgICAgICAgICB2YXIgbGV2ZWwgPSAwO1xuICAgICAgICAgICAgdmFyIGNsdXN0ZXJUaHJlc2hvbGQgPSAxMDA7XG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgYSBsb3Qgb2Ygbm9kZXMsIHdlIGNsdXN0ZXIgYmVmb3JlIHdlIHJ1biB0aGUgYWxnb3JpdGhtLlxuICAgICAgICAgICAgaWYgKHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGggPiBjbHVzdGVyVGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgIHZhciBzdGFydExlbmd0aCA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGg7XG4gICAgICAgICAgICAgIHdoaWxlICh0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoID4gY2x1c3RlclRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS50aW1lKFwiY2x1c3RlcmluZ1wiKVxuICAgICAgICAgICAgICAgIGxldmVsICs9IDE7XG4gICAgICAgICAgICAgICAgdmFyIGJlZm9yZSA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG1hbnkgbm9kZXMgd2UgZG8gYSBodWJzaXplIGNsdXN0ZXJcbiAgICAgICAgICAgICAgICBpZiAobGV2ZWwgJSAzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmJvZHkubW9kdWxlcy5jbHVzdGVyaW5nLmNsdXN0ZXJCcmlkZ2VzKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuYm9keS5tb2R1bGVzLmNsdXN0ZXJpbmcuY2x1c3Rlck91dGxpZXJzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBhZnRlciA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGJlZm9yZSA9PSBhZnRlciAmJiBsZXZlbCAlIDMgIT09IDAgfHwgbGV2ZWwgPiBNQVhfTEVWRUxTKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9kZWNsdXN0ZXJBbGwoKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfbGF5b3V0RmFpbGVkXCIpO1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiVGhpcyBuZXR3b3JrIGNvdWxkIG5vdCBiZSBwb3NpdGlvbmVkIGJ5IHRoaXMgdmVyc2lvbiBvZiB0aGUgaW1wcm92ZWQgbGF5b3V0IGFsZ29yaXRobS4gUGxlYXNlIGRpc2FibGUgaW1wcm92ZWRMYXlvdXQgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5cIik7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vY29uc29sZS50aW1lRW5kKFwiY2x1c3RlcmluZ1wiKVxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2cobGV2ZWwsYWZ0ZXIpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gaW5jcmVhc2UgdGhlIHNpemUgb2YgdGhlIGVkZ2VzXG4gICAgICAgICAgICAgIHRoaXMuYm9keS5tb2R1bGVzLmthbWFkYUthd2FpLnNldE9wdGlvbnMoeyBzcHJpbmdMZW5ndGg6IE1hdGgubWF4KDE1MCwgMiAqIHN0YXJ0TGVuZ3RoKSB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcG9zaXRpb24gdGhlIHN5c3RlbSBmb3IgdGhlc2Ugbm9kZXMgYW5kIGVkZ2VzXG4gICAgICAgICAgICB0aGlzLmJvZHkubW9kdWxlcy5rYW1hZGFLYXdhaS5zb2x2ZSh0aGlzLmJvZHkubm9kZUluZGljZXMsIHRoaXMuYm9keS5lZGdlSW5kaWNlcywgdHJ1ZSk7XG5cbiAgICAgICAgICAgIC8vIHNoaWZ0IHRvIGNlbnRlciBwb2ludFxuICAgICAgICAgICAgdGhpcy5fc2hpZnRUb0NlbnRlcigpO1xuXG4gICAgICAgICAgICAvLyBwZXJ0dXJiIHRoZSBub2RlcyBhIGxpdHRsZSBiaXQgdG8gZm9yY2UgdGhlIHBoeXNpY3MgdG8ga2ljayBpblxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IDcwO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW3RoaXMuYm9keS5ub2RlSW5kaWNlc1tfaV1dLnggKz0gKDAuNSAtIHRoaXMuc2VlZGVkUmFuZG9tKCkpICogb2Zmc2V0O1xuICAgICAgICAgICAgICB0aGlzLmJvZHkubm9kZXNbdGhpcy5ib2R5Lm5vZGVJbmRpY2VzW19pXV0ueSArPSAoMC41IC0gdGhpcy5zZWVkZWRSYW5kb20oKSkgKiBvZmZzZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHVuY2x1c3RlciBhbGwgY2x1c3RlcnNcbiAgICAgICAgICAgIHRoaXMuX2RlY2x1c3RlckFsbCgpO1xuXG4gICAgICAgICAgICAvLyByZXBvc2l0aW9uIGFsbCBiZXppZXIgbm9kZXMuXG4gICAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcG9zaXRpb25CZXppZXJOb2Rlc1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBNb3ZlIGFsbCB0aGUgbm9kZXMgdG93YXJkcyB0byB0aGUgY2VudGVyIHNvIGdyYXZpdGF0aW9uYWwgcHVsbCB3aWwgbm90IG1vdmUgdGhlIG5vZGVzIGF3YXkgZnJvbSB2aWV3XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc2hpZnRUb0NlbnRlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NoaWZ0VG9DZW50ZXIoKSB7XG4gICAgICAgIHZhciByYW5nZSA9IF9OZXR3b3JrVXRpbDIuZGVmYXVsdC5nZXRSYW5nZUNvcmUodGhpcy5ib2R5Lm5vZGVzLCB0aGlzLmJvZHkubm9kZUluZGljZXMpO1xuICAgICAgICB2YXIgY2VudGVyID0gX05ldHdvcmtVdGlsMi5kZWZhdWx0LmZpbmRDZW50ZXIocmFuZ2UpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuYm9keS5ub2Rlc1t0aGlzLmJvZHkubm9kZUluZGljZXNbaV1dLnggLT0gY2VudGVyLng7XG4gICAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW3RoaXMuYm9keS5ub2RlSW5kaWNlc1tpXV0ueSAtPSBjZW50ZXIueTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19kZWNsdXN0ZXJBbGwnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWNsdXN0ZXJBbGwoKSB7XG4gICAgICAgIHZhciBjbHVzdGVyc1ByZXNlbnQgPSB0cnVlO1xuICAgICAgICB3aGlsZSAoY2x1c3RlcnNQcmVzZW50ID09PSB0cnVlKSB7XG4gICAgICAgICAgY2x1c3RlcnNQcmVzZW50ID0gZmFsc2U7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbdGhpcy5ib2R5Lm5vZGVJbmRpY2VzW2ldXS5pc0NsdXN0ZXIgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgY2x1c3RlcnNQcmVzZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdGhpcy5ib2R5Lm1vZHVsZXMuY2x1c3RlcmluZy5vcGVuQ2x1c3Rlcih0aGlzLmJvZHkubm9kZUluZGljZXNbaV0sIHt9LCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjbHVzdGVyc1ByZXNlbnQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19kYXRhQ2hhbmdlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldFNlZWQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluaXRpYWxSYW5kb21TZWVkO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgaXMgdGhlIG1haW4gZnVuY3Rpb24gdG8gbGF5b3V0IHRoZSBub2RlcyBpbiBhIGhpZXJhcmNoaWNhbCB3YXkuXG4gICAgICAgKiBJdCBjaGVja3MgaWYgdGhlIG5vZGUgZGV0YWlscyBhcmUgc3VwcGxpZWQgY29ycmVjdGx5XG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc2V0dXBIaWVyYXJjaGljYWxMYXlvdXQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldHVwSGllcmFyY2hpY2FsTGF5b3V0KCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5lbmFibGVkID09PSB0cnVlICYmIHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gZ2V0IHRoZSBzaXplIG9mIHRoZSBsYXJnZXN0IGh1YnMgYW5kIGNoZWNrIGlmIHRoZSB1c2VyIGhhcyBkZWZpbmVkIGEgbGV2ZWwgZm9yIGEgbm9kZS5cbiAgICAgICAgICB2YXIgbm9kZSA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgbm9kZUlkID0gdm9pZCAwO1xuICAgICAgICAgIHZhciBkZWZpbmVkTGV2ZWwgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgZGVmaW5lZFBvc2l0aW9ucyA9IHRydWU7XG4gICAgICAgICAgdmFyIHVuZGVmaW5lZExldmVsID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5oaWVyYXJjaGljYWxMZXZlbHMgPSB7fTtcbiAgICAgICAgICB0aGlzLmxhc3ROb2RlT25MZXZlbCA9IHt9O1xuICAgICAgICAgIHRoaXMuaGllcmFyY2hpY2FsQ2hpbGRyZW5SZWZlcmVuY2UgPSB7fTtcbiAgICAgICAgICB0aGlzLmhpZXJhcmNoaWNhbFBhcmVudFJlZmVyZW5jZSA9IHt9O1xuICAgICAgICAgIHRoaXMuaGllcmFyY2hpY2FsVHJlZXMgPSB7fTtcbiAgICAgICAgICB0aGlzLnRyZWVJbmRleCA9IC0xO1xuXG4gICAgICAgICAgdGhpcy5kaXN0cmlidXRpb25PcmRlcmluZyA9IHt9O1xuICAgICAgICAgIHRoaXMuZGlzdHJpYnV0aW9uSW5kZXggPSB7fTtcbiAgICAgICAgICB0aGlzLmRpc3RyaWJ1dGlvbk9yZGVyaW5nUHJlc2VuY2UgPSB7fTtcblxuICAgICAgICAgIGZvciAobm9kZUlkIGluIHRoaXMuYm9keS5ub2Rlcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlcy5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgICAgIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICAgICAgaWYgKG5vZGUub3B0aW9ucy54ID09PSB1bmRlZmluZWQgJiYgbm9kZS5vcHRpb25zLnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRlZmluZWRQb3NpdGlvbnMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobm9kZS5vcHRpb25zLmxldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVkTGV2ZWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuaGllcmFyY2hpY2FsTGV2ZWxzW25vZGVJZF0gPSBub2RlLm9wdGlvbnMubGV2ZWw7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkTGV2ZWwgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaWYgdGhlIHVzZXIgZGVmaW5lZCBzb21lIGxldmVscyBidXQgbm90IGFsbCwgYWxlcnQgYW5kIHJ1biB3aXRob3V0IGhpZXJhcmNoaWNhbCBsYXlvdXRcbiAgICAgICAgICBpZiAodW5kZWZpbmVkTGV2ZWwgPT09IHRydWUgJiYgZGVmaW5lZExldmVsID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvIHVzZSB0aGUgaGllcmFyY2hpY2FsIGxheW91dCwgbm9kZXMgcmVxdWlyZSBlaXRoZXIgbm8gcHJlZGVmaW5lZCBsZXZlbHMgb3IgbGV2ZWxzIGhhdmUgdG8gYmUgZGVmaW5lZCBmb3IgYWxsIG5vZGVzLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBkZWZpbmUgbGV2ZWxzIGlmIHVuZGVmaW5lZCBieSB0aGUgdXNlcnMuIEJhc2VkIG9uIGh1YnNpemUuXG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkTGV2ZWwgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuc29ydE1ldGhvZCA9PT0gJ2h1YnNpemUnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGV0ZXJtaW5lTGV2ZWxzQnlIdWJzaXplKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5zb3J0TWV0aG9kID09PSAnZGlyZWN0ZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGV0ZXJtaW5lTGV2ZWxzRGlyZWN0ZWQoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLnNvcnRNZXRob2QgPT09ICdjdXN0b20nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGV0ZXJtaW5lTGV2ZWxzQ3VzdG9tQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBmYWxsYmFjayBmb3IgY2FzZXMgd2hlcmUgdGhlcmUgYXJlIG5vZGVzIGJ1dCBubyBlZGdlc1xuICAgICAgICAgICAgZm9yICh2YXIgX25vZGVJZCBpbiB0aGlzLmJvZHkubm9kZXMpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlcy5oYXNPd25Qcm9wZXJ0eShfbm9kZUlkKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhpZXJhcmNoaWNhbExldmVsc1tfbm9kZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmhpZXJhcmNoaWNhbExldmVsc1tfbm9kZUlkXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjaGVjayB0aGUgZGlzdHJpYnV0aW9uIG9mIHRoZSBub2RlcyBwZXIgbGV2ZWwuXG4gICAgICAgICAgICB2YXIgZGlzdHJpYnV0aW9uID0gdGhpcy5fZ2V0RGlzdHJpYnV0aW9uKCk7XG5cbiAgICAgICAgICAgIC8vIGdldCB0aGUgcGFyZW50IGNoaWxkcmVuIHJlbGF0aW9ucy5cbiAgICAgICAgICAgIHRoaXMuX2dlbmVyYXRlTWFwKCk7XG5cbiAgICAgICAgICAgIC8vIHBsYWNlIHRoZSBub2RlcyBvbiB0aGUgY2FudmFzLlxuICAgICAgICAgICAgdGhpcy5fcGxhY2VOb2Rlc0J5SGllcmFyY2h5KGRpc3RyaWJ1dGlvbik7XG5cbiAgICAgICAgICAgIC8vIGNvbmRlbnNlIHRoZSB3aGl0ZXNwYWNlLlxuICAgICAgICAgICAgdGhpcy5fY29uZGVuc2VIaWVyYXJjaHkoKTtcblxuICAgICAgICAgICAgLy8gc2hpZnQgdG8gY2VudGVyIHNvIGdyYXZpdHkgZG9lcyBub3QgaGF2ZSB0byBkbyBtdWNoXG4gICAgICAgICAgICB0aGlzLl9zaGlmdFRvQ2VudGVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2NvbmRlbnNlSGllcmFyY2h5JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY29uZGVuc2VIaWVyYXJjaHkoKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIC8vIEdsb2JhbCB2YXIgaW4gdGhpcyBzY29wZSB0byBkZWZpbmUgd2hlbiB0aGUgbW92ZW1lbnQgaGFzIHN0b3BwZWQuXG4gICAgICAgIHZhciBzdGlsbFNoaWZ0aW5nID0gZmFsc2U7XG4gICAgICAgIHZhciBicmFuY2hlcyA9IHt9O1xuICAgICAgICAvLyBmaXJzdCB3ZSBoYXZlIHNvbWUgbWV0aG9kcyB0byBoZWxwIHNoaWZ0aW5nIHRyZWVzIGFyb3VuZC5cbiAgICAgICAgLy8gdGhlIG1haW4gbWV0aG9kIHRvIHNoaWZ0IHRoZSB0cmVlc1xuICAgICAgICB2YXIgc2hpZnRUcmVlcyA9IGZ1bmN0aW9uIHNoaWZ0VHJlZXMoKSB7XG4gICAgICAgICAgdmFyIHRyZWVTaXplcyA9IGdldFRyZWVTaXplcygpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZVNpemVzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgdmFyIGRpZmYgPSB0cmVlU2l6ZXNbaV0ubWF4IC0gdHJlZVNpemVzW2kgKyAxXS5taW47XG4gICAgICAgICAgICBzaGlmdFRyZWUoaSArIDEsIGRpZmYgKyBfdGhpczIub3B0aW9ucy5oaWVyYXJjaGljYWwudHJlZVNwYWNpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBzaGlmdCBhIHNpbmdsZSB0cmVlIGJ5IGFuIG9mZnNldFxuICAgICAgICB2YXIgc2hpZnRUcmVlID0gZnVuY3Rpb24gc2hpZnRUcmVlKGluZGV4LCBvZmZzZXQpIHtcbiAgICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gX3RoaXMyLmhpZXJhcmNoaWNhbFRyZWVzKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMyLmhpZXJhcmNoaWNhbFRyZWVzLmhhc093blByb3BlcnR5KG5vZGVJZCkpIHtcbiAgICAgICAgICAgICAgaWYgKF90aGlzMi5oaWVyYXJjaGljYWxUcmVlc1tub2RlSWRdID09PSBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gX3RoaXMyLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gX3RoaXMyLl9nZXRQb3NpdGlvbkZvckhpZXJhcmNoeShub2RlKTtcbiAgICAgICAgICAgICAgICBfdGhpczIuX3NldFBvc2l0aW9uRm9ySGllcmFyY2h5KG5vZGUsIHBvcyArIG9mZnNldCwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBnZXQgdGhlIHdpZHRoIG9mIGEgdHJlZVxuICAgICAgICB2YXIgZ2V0VHJlZVNpemUgPSBmdW5jdGlvbiBnZXRUcmVlU2l6ZShpbmRleCkge1xuICAgICAgICAgIHZhciBtaW4gPSAxZTk7XG4gICAgICAgICAgdmFyIG1heCA9IC0xZTk7XG4gICAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIF90aGlzMi5oaWVyYXJjaGljYWxUcmVlcykge1xuICAgICAgICAgICAgaWYgKF90aGlzMi5oaWVyYXJjaGljYWxUcmVlcy5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgICAgIGlmIChfdGhpczIuaGllcmFyY2hpY2FsVHJlZXNbbm9kZUlkXSA9PT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gX3RoaXMyLl9nZXRQb3NpdGlvbkZvckhpZXJhcmNoeShfdGhpczIuYm9keS5ub2Rlc1tub2RlSWRdKTtcbiAgICAgICAgICAgICAgICBtaW4gPSBNYXRoLm1pbihwb3MsIG1pbik7XG4gICAgICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgocG9zLCBtYXgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7IG1pbjogbWluLCBtYXg6IG1heCB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGdldCB0aGUgd2lkdGggb2YgYWxsIHRyZWVzXG4gICAgICAgIHZhciBnZXRUcmVlU2l6ZXMgPSBmdW5jdGlvbiBnZXRUcmVlU2l6ZXMoKSB7XG4gICAgICAgICAgdmFyIHRyZWVXaWR0aHMgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBfdGhpczIudHJlZUluZGV4OyBpKyspIHtcbiAgICAgICAgICAgIHRyZWVXaWR0aHMucHVzaChnZXRUcmVlU2l6ZShpKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cmVlV2lkdGhzO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGdldCBhIG1hcCBvZiBhbGwgbm9kZXMgaW4gdGhpcyBicmFuY2hcbiAgICAgICAgdmFyIGdldEJyYW5jaE5vZGVzID0gZnVuY3Rpb24gZ2V0QnJhbmNoTm9kZXMoc291cmNlLCBtYXApIHtcbiAgICAgICAgICBtYXBbc291cmNlLmlkXSA9IHRydWU7XG4gICAgICAgICAgaWYgKF90aGlzMi5oaWVyYXJjaGljYWxDaGlsZHJlblJlZmVyZW5jZVtzb3VyY2UuaWRdKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBfdGhpczIuaGllcmFyY2hpY2FsQ2hpbGRyZW5SZWZlcmVuY2Vbc291cmNlLmlkXTtcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBnZXRCcmFuY2hOb2RlcyhfdGhpczIuYm9keS5ub2Rlc1tjaGlsZHJlbltpXV0sIG1hcCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZ2V0IGEgbWluIG1heCB3aWR0aCBhcyB3ZWxsIGFzIHRoZSBtYXhpbXVtIG1vdmVtZW50IHNwYWNlIGl0IGhhcyBvbiBlaXRoZXIgc2lkZXNcbiAgICAgICAgLy8gd2UgdXNlIG1pbiBtYXggdGVybWlub2xvZ3kgYmVjYXVzZSB3aWR0aCBhbmQgaGVpZ2h0IGNhbiBpbnRlcmNoYW5nZSBkZXBlbmRpbmcgb24gdGhlIGRpcmVjdGlvbiBvZiB0aGUgbGF5b3V0XG4gICAgICAgIHZhciBnZXRCcmFuY2hCb3VuZGFyeSA9IGZ1bmN0aW9uIGdldEJyYW5jaEJvdW5kYXJ5KGJyYW5jaE1hcCkge1xuICAgICAgICAgIHZhciBtYXhMZXZlbCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IDFlOSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICAgIHZhciBtaW5TcGFjZSA9IDFlOTtcbiAgICAgICAgICB2YXIgbWF4U3BhY2UgPSAxZTk7XG4gICAgICAgICAgdmFyIG1pbiA9IDFlOTtcbiAgICAgICAgICB2YXIgbWF4ID0gLTFlOTtcbiAgICAgICAgICBmb3IgKHZhciBicmFuY2hOb2RlIGluIGJyYW5jaE1hcCkge1xuICAgICAgICAgICAgaWYgKGJyYW5jaE1hcC5oYXNPd25Qcm9wZXJ0eShicmFuY2hOb2RlKSkge1xuICAgICAgICAgICAgICB2YXIgbm9kZSA9IF90aGlzMi5ib2R5Lm5vZGVzW2JyYW5jaE5vZGVdO1xuICAgICAgICAgICAgICB2YXIgbGV2ZWwgPSBfdGhpczIuaGllcmFyY2hpY2FsTGV2ZWxzW25vZGUuaWRdO1xuICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBfdGhpczIuX2dldFBvc2l0aW9uRm9ySGllcmFyY2h5KG5vZGUpO1xuXG4gICAgICAgICAgICAgIC8vIGdldCB0aGUgc3BhY2UgYXJvdW5kIHRoZSBub2RlLlxuXG4gICAgICAgICAgICAgIHZhciBfZ2V0U3BhY2VBcm91bmROb2RlMiA9IF90aGlzMi5fZ2V0U3BhY2VBcm91bmROb2RlKG5vZGUsIGJyYW5jaE1hcCk7XG5cbiAgICAgICAgICAgICAgdmFyIF9nZXRTcGFjZUFyb3VuZE5vZGUzID0gX3NsaWNlZFRvQXJyYXkoX2dldFNwYWNlQXJvdW5kTm9kZTIsIDIpO1xuXG4gICAgICAgICAgICAgIHZhciBtaW5TcGFjZU5vZGUgPSBfZ2V0U3BhY2VBcm91bmROb2RlM1swXTtcbiAgICAgICAgICAgICAgdmFyIG1heFNwYWNlTm9kZSA9IF9nZXRTcGFjZUFyb3VuZE5vZGUzWzFdO1xuXG4gICAgICAgICAgICAgIG1pblNwYWNlID0gTWF0aC5taW4obWluU3BhY2VOb2RlLCBtaW5TcGFjZSk7XG4gICAgICAgICAgICAgIG1heFNwYWNlID0gTWF0aC5taW4obWF4U3BhY2VOb2RlLCBtYXhTcGFjZSk7XG5cbiAgICAgICAgICAgICAgLy8gdGhlIHdpZHRoIGlzIG9ubHkgcmVsZXZhbnQgZm9yIHRoZSBsZXZlbHMgdHdvIG5vZGVzIGhhdmUgaW4gY29tbW9uLiBUaGlzIGlzIHdoeSB3ZSBmaWx0ZXIgb24gdGhpcy5cbiAgICAgICAgICAgICAgaWYgKGxldmVsIDw9IG1heExldmVsKSB7XG4gICAgICAgICAgICAgICAgbWluID0gTWF0aC5taW4ocG9zaXRpb24sIG1pbik7XG4gICAgICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgocG9zaXRpb24sIG1heCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gW21pbiwgbWF4LCBtaW5TcGFjZSwgbWF4U3BhY2VdO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGdldCB0aGUgbWF4aW11bSBsZXZlbCBvZiBhIGJyYW5jaC5cbiAgICAgICAgdmFyIGdldE1heExldmVsID0gZnVuY3Rpb24gZ2V0TWF4TGV2ZWwobm9kZUlkKSB7XG4gICAgICAgICAgdmFyIGxldmVsID0gX3RoaXMyLmhpZXJhcmNoaWNhbExldmVsc1tub2RlSWRdO1xuICAgICAgICAgIGlmIChfdGhpczIuaGllcmFyY2hpY2FsQ2hpbGRyZW5SZWZlcmVuY2Vbbm9kZUlkXSkge1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gX3RoaXMyLmhpZXJhcmNoaWNhbENoaWxkcmVuUmVmZXJlbmNlW25vZGVJZF07XG4gICAgICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV2ZWwgPSBNYXRoLm1heChsZXZlbCwgZ2V0TWF4TGV2ZWwoY2hpbGRyZW5baV0pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbGV2ZWw7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gY2hlY2sgd2hhdCB0aGUgbWF4aW11bSBsZXZlbCBpcyB0aGVzZSBub2RlcyBoYXZlIGluIGNvbW1vbi5cbiAgICAgICAgdmFyIGdldENvbGxpc2lvbkxldmVsID0gZnVuY3Rpb24gZ2V0Q29sbGlzaW9uTGV2ZWwobm9kZTEsIG5vZGUyKSB7XG4gICAgICAgICAgdmFyIG1heExldmVsMSA9IGdldE1heExldmVsKG5vZGUxLmlkKTtcbiAgICAgICAgICB2YXIgbWF4TGV2ZWwyID0gZ2V0TWF4TGV2ZWwobm9kZTIuaWQpO1xuICAgICAgICAgIHJldHVybiBNYXRoLm1pbihtYXhMZXZlbDEsIG1heExldmVsMik7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgdHdvIG5vZGVzIGhhdmUgdGhlIHNhbWUgcGFyZW50KHMpXG4gICAgICAgIHZhciBoYXNTYW1lUGFyZW50ID0gZnVuY3Rpb24gaGFzU2FtZVBhcmVudChub2RlMSwgbm9kZTIpIHtcbiAgICAgICAgICB2YXIgcGFyZW50czEgPSBfdGhpczIuaGllcmFyY2hpY2FsUGFyZW50UmVmZXJlbmNlW25vZGUxLmlkXTtcbiAgICAgICAgICB2YXIgcGFyZW50czIgPSBfdGhpczIuaGllcmFyY2hpY2FsUGFyZW50UmVmZXJlbmNlW25vZGUyLmlkXTtcbiAgICAgICAgICBpZiAocGFyZW50czEgPT09IHVuZGVmaW5lZCB8fCBwYXJlbnRzMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRzMS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwYXJlbnRzMi5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICBpZiAocGFyZW50czFbaV0gPT0gcGFyZW50czJbal0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gY29uZGVuc2UgZWxlbWVudHMuIFRoZXNlIGNhbiBiZSBub2RlcyBvciBicmFuY2hlcyBkZXBlbmRpbmcgb24gdGhlIGNhbGxiYWNrLlxuICAgICAgICB2YXIgc2hpZnRFbGVtZW50c0Nsb3NlciA9IGZ1bmN0aW9uIHNoaWZ0RWxlbWVudHNDbG9zZXIoY2FsbGJhY2ssIGxldmVscywgY2VudGVyUGFyZW50cykge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGV2ZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbaV07XG4gICAgICAgICAgICB2YXIgbGV2ZWxOb2RlcyA9IF90aGlzMi5kaXN0cmlidXRpb25PcmRlcmluZ1tsZXZlbF07XG4gICAgICAgICAgICBpZiAobGV2ZWxOb2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGV2ZWxOb2Rlcy5sZW5ndGggLSAxOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzU2FtZVBhcmVudChsZXZlbE5vZGVzW2pdLCBsZXZlbE5vZGVzW2ogKyAxXSkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChfdGhpczIuaGllcmFyY2hpY2FsVHJlZXNbbGV2ZWxOb2Rlc1tqXS5pZF0gPT09IF90aGlzMi5oaWVyYXJjaGljYWxUcmVlc1tsZXZlbE5vZGVzW2ogKyAxXS5pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobGV2ZWxOb2Rlc1tqXSwgbGV2ZWxOb2Rlc1tqICsgMV0sIGNlbnRlclBhcmVudHMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBjYWxsYmFjayBmb3Igc2hpZnRpbmcgYnJhbmNoZXNcbiAgICAgICAgdmFyIGJyYW5jaFNoaWZ0Q2FsbGJhY2sgPSBmdW5jdGlvbiBicmFuY2hTaGlmdENhbGxiYWNrKG5vZGUxLCBub2RlMikge1xuICAgICAgICAgIHZhciBjZW50ZXJQYXJlbnQgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1syXTtcblxuICAgICAgICAgIC8vd2luZG93LkNBTExCQUNLUy5wdXNoKCgpID0+IHtcbiAgICAgICAgICB2YXIgcG9zMSA9IF90aGlzMi5fZ2V0UG9zaXRpb25Gb3JIaWVyYXJjaHkobm9kZTEpO1xuICAgICAgICAgIHZhciBwb3MyID0gX3RoaXMyLl9nZXRQb3NpdGlvbkZvckhpZXJhcmNoeShub2RlMik7XG4gICAgICAgICAgdmFyIGRpZmZBYnMgPSBNYXRoLmFicyhwb3MyIC0gcG9zMSk7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhcIk5PVyBDSEVjS0lORzpcIiwgbm9kZTEuaWQsIG5vZGUyLmlkLCBkaWZmQWJzKTtcbiAgICAgICAgICBpZiAoZGlmZkFicyA+IF90aGlzMi5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZykge1xuICAgICAgICAgICAgdmFyIGJyYW5jaE5vZGVzMSA9IHt9O2JyYW5jaE5vZGVzMVtub2RlMS5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGJyYW5jaE5vZGVzMiA9IHt9O2JyYW5jaE5vZGVzMltub2RlMi5pZF0gPSB0cnVlO1xuXG4gICAgICAgICAgICBnZXRCcmFuY2hOb2Rlcyhub2RlMSwgYnJhbmNoTm9kZXMxKTtcbiAgICAgICAgICAgIGdldEJyYW5jaE5vZGVzKG5vZGUyLCBicmFuY2hOb2RlczIpO1xuXG4gICAgICAgICAgICAvLyBjaGVjayB0aGUgbGFyZ2VzdCBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBicmFuY2hlc1xuICAgICAgICAgICAgdmFyIG1heExldmVsID0gZ2V0Q29sbGlzaW9uTGV2ZWwobm9kZTEsIG5vZGUyKTtcblxuICAgICAgICAgICAgdmFyIF9nZXRCcmFuY2hCb3VuZGFyeSA9IGdldEJyYW5jaEJvdW5kYXJ5KGJyYW5jaE5vZGVzMSwgbWF4TGV2ZWwpO1xuXG4gICAgICAgICAgICB2YXIgX2dldEJyYW5jaEJvdW5kYXJ5MiA9IF9zbGljZWRUb0FycmF5KF9nZXRCcmFuY2hCb3VuZGFyeSwgNCk7XG5cbiAgICAgICAgICAgIHZhciBtaW4xID0gX2dldEJyYW5jaEJvdW5kYXJ5MlswXTtcbiAgICAgICAgICAgIHZhciBtYXgxID0gX2dldEJyYW5jaEJvdW5kYXJ5MlsxXTtcbiAgICAgICAgICAgIHZhciBtaW5TcGFjZTEgPSBfZ2V0QnJhbmNoQm91bmRhcnkyWzJdO1xuICAgICAgICAgICAgdmFyIG1heFNwYWNlMSA9IF9nZXRCcmFuY2hCb3VuZGFyeTJbM107XG5cbiAgICAgICAgICAgIHZhciBfZ2V0QnJhbmNoQm91bmRhcnkzID0gZ2V0QnJhbmNoQm91bmRhcnkoYnJhbmNoTm9kZXMyLCBtYXhMZXZlbCk7XG5cbiAgICAgICAgICAgIHZhciBfZ2V0QnJhbmNoQm91bmRhcnk0ID0gX3NsaWNlZFRvQXJyYXkoX2dldEJyYW5jaEJvdW5kYXJ5MywgNCk7XG5cbiAgICAgICAgICAgIHZhciBtaW4yID0gX2dldEJyYW5jaEJvdW5kYXJ5NFswXTtcbiAgICAgICAgICAgIHZhciBtYXgyID0gX2dldEJyYW5jaEJvdW5kYXJ5NFsxXTtcbiAgICAgICAgICAgIHZhciBtaW5TcGFjZTIgPSBfZ2V0QnJhbmNoQm91bmRhcnk0WzJdO1xuICAgICAgICAgICAgdmFyIG1heFNwYWNlMiA9IF9nZXRCcmFuY2hCb3VuZGFyeTRbM107XG5cbiAgICAgICAgICAgIC8vY29uc29sZS5sb2cobm9kZTEuaWQsIGdldEJyYW5jaEJvdW5kYXJ5KGJyYW5jaE5vZGVzMSwgbWF4TGV2ZWwpLCBub2RlMi5pZCwgZ2V0QnJhbmNoQm91bmRhcnkoYnJhbmNoTm9kZXMyLCBtYXhMZXZlbCksIG1heExldmVsKTtcblxuICAgICAgICAgICAgdmFyIGRpZmZCcmFuY2ggPSBNYXRoLmFicyhtYXgxIC0gbWluMik7XG4gICAgICAgICAgICBpZiAoZGlmZkJyYW5jaCA+IF90aGlzMi5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZykge1xuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gbWF4MSAtIG1pbjIgKyBfdGhpczIub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmc7XG4gICAgICAgICAgICAgIGlmIChvZmZzZXQgPCAtbWluU3BhY2UyICsgX3RoaXMyLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gLW1pblNwYWNlMiArIF90aGlzMi5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZztcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiUkVTRVRUSU5HIE9GRlNFVFwiLCBtYXgxIC0gbWluMiArIHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcsIC1taW5TcGFjZTIsIG9mZnNldCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiU0hJRlRJTkdcIiwgbm9kZTIuaWQsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgX3RoaXMyLl9zaGlmdEJsb2NrKG5vZGUyLmlkLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIHN0aWxsU2hpZnRpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNlbnRlclBhcmVudCA9PT0gdHJ1ZSkgX3RoaXMyLl9jZW50ZXJQYXJlbnQobm9kZTIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZWRyYXdcIik7fSlcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbWluaW1pemVFZGdlTGVuZ3RoID0gZnVuY3Rpb24gbWluaW1pemVFZGdlTGVuZ3RoKGl0ZXJhdGlvbnMsIG5vZGUpIHtcbiAgICAgICAgICAvL3dpbmRvdy5DQUxMQkFDS1MucHVzaCgoKSA9PiB7XG4gICAgICAgICAgLy8gIGNvbnNvbGUubG9nKFwidHNcIixub2RlLmlkKTtcbiAgICAgICAgICB2YXIgbm9kZUlkID0gbm9kZS5pZDtcbiAgICAgICAgICB2YXIgYWxsRWRnZXMgPSBub2RlLmVkZ2VzO1xuICAgICAgICAgIHZhciBub2RlTGV2ZWwgPSBfdGhpczIuaGllcmFyY2hpY2FsTGV2ZWxzW25vZGUuaWRdO1xuXG4gICAgICAgICAgLy8gZ2F0aGVyIGNvbnN0YW50c1xuICAgICAgICAgIHZhciBDMiA9IF90aGlzMi5vcHRpb25zLmhpZXJhcmNoaWNhbC5sZXZlbFNlcGFyYXRpb24gKiBfdGhpczIub3B0aW9ucy5oaWVyYXJjaGljYWwubGV2ZWxTZXBhcmF0aW9uO1xuICAgICAgICAgIHZhciByZWZlcmVuY2VOb2RlcyA9IHt9O1xuICAgICAgICAgIHZhciBhYm92ZUVkZ2VzID0gW107XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxFZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGVkZ2UgPSBhbGxFZGdlc1tpXTtcbiAgICAgICAgICAgIGlmIChlZGdlLnRvSWQgIT0gZWRnZS5mcm9tSWQpIHtcbiAgICAgICAgICAgICAgdmFyIG90aGVyTm9kZSA9IGVkZ2UudG9JZCA9PSBub2RlSWQgPyBlZGdlLmZyb20gOiBlZGdlLnRvO1xuICAgICAgICAgICAgICByZWZlcmVuY2VOb2Rlc1thbGxFZGdlc1tpXS5pZF0gPSBvdGhlck5vZGU7XG4gICAgICAgICAgICAgIGlmIChfdGhpczIuaGllcmFyY2hpY2FsTGV2ZWxzW290aGVyTm9kZS5pZF0gPCBub2RlTGV2ZWwpIHtcbiAgICAgICAgICAgICAgICBhYm92ZUVkZ2VzLnB1c2goZWRnZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBkaWZmZXJlbnRpYXRlZCBzdW0gb2YgbGVuZ3RocyBiYXNlZCBvbiBvbmx5IG1vdmluZyBvbmUgbm9kZSBvdmVyIG9uZSBheGlzXG4gICAgICAgICAgdmFyIGdldEZ4ID0gZnVuY3Rpb24gZ2V0RngocG9pbnQsIGVkZ2VzKSB7XG4gICAgICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGVkZ2VzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICAgICAgaWYgKHJlZmVyZW5jZU5vZGVzW2VkZ2VzW19pMl0uaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IF90aGlzMi5fZ2V0UG9zaXRpb25Gb3JIaWVyYXJjaHkocmVmZXJlbmNlTm9kZXNbZWRnZXNbX2kyXS5pZF0pIC0gcG9pbnQ7XG4gICAgICAgICAgICAgICAgc3VtICs9IGEgLyBNYXRoLnNxcnQoYSAqIGEgKyBDMik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdW07XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIGRvdWJseSBkaWZmZXJlbnRpYXRlZCBzdW0gb2YgbGVuZ3RocyBiYXNlZCBvbiBvbmx5IG1vdmluZyBvbmUgbm9kZSBvdmVyIG9uZSBheGlzXG4gICAgICAgICAgdmFyIGdldERGeCA9IGZ1bmN0aW9uIGdldERGeChwb2ludCwgZWRnZXMpIHtcbiAgICAgICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgZWRnZXMubGVuZ3RoOyBfaTMrKykge1xuICAgICAgICAgICAgICBpZiAocmVmZXJlbmNlTm9kZXNbZWRnZXNbX2kzXS5pZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBhID0gX3RoaXMyLl9nZXRQb3NpdGlvbkZvckhpZXJhcmNoeShyZWZlcmVuY2VOb2Rlc1tlZGdlc1tfaTNdLmlkXSkgLSBwb2ludDtcbiAgICAgICAgICAgICAgICBzdW0gLT0gQzIgKiBNYXRoLnBvdyhhICogYSArIEMyLCAtMS41KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1bTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIGdldEd1ZXNzID0gZnVuY3Rpb24gZ2V0R3Vlc3MoaXRlcmF0aW9ucywgZWRnZXMpIHtcbiAgICAgICAgICAgIHZhciBndWVzcyA9IF90aGlzMi5fZ2V0UG9zaXRpb25Gb3JIaWVyYXJjaHkobm9kZSk7XG4gICAgICAgICAgICAvLyBOZXd0b24ncyBtZXRob2QgZm9yIG9wdGltaXphdGlvblxuICAgICAgICAgICAgdmFyIGd1ZXNzTWFwID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBpdGVyYXRpb25zOyBfaTQrKykge1xuICAgICAgICAgICAgICB2YXIgZnggPSBnZXRGeChndWVzcywgZWRnZXMpO1xuICAgICAgICAgICAgICB2YXIgZGZ4ID0gZ2V0REZ4KGd1ZXNzLCBlZGdlcyk7XG5cbiAgICAgICAgICAgICAgLy8gd2UgbGltaXQgdGhlIG1vdmVtZW50IHRvIGF2b2lkIGluc3RhYmlsaXR5LlxuICAgICAgICAgICAgICB2YXIgbGltaXQgPSA0MDtcbiAgICAgICAgICAgICAgdmFyIHJhdGlvID0gTWF0aC5tYXgoLWxpbWl0LCBNYXRoLm1pbihsaW1pdCwgTWF0aC5yb3VuZChmeCAvIGRmeCkpKTtcbiAgICAgICAgICAgICAgZ3Vlc3MgPSBndWVzcyAtIHJhdGlvO1xuICAgICAgICAgICAgICAvLyByZWR1Y2UgZHVwbGljYXRlc1xuICAgICAgICAgICAgICBpZiAoZ3Vlc3NNYXBbZ3Vlc3NdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBndWVzc01hcFtndWVzc10gPSBfaTQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ3Vlc3M7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZhciBtb3ZlQnJhbmNoID0gZnVuY3Rpb24gbW92ZUJyYW5jaChndWVzcykge1xuICAgICAgICAgICAgLy8gcG9zaXRpb24gbm9kZSBpZiB0aGVyZSBpcyBzcGFjZVxuICAgICAgICAgICAgdmFyIG5vZGVQb3NpdGlvbiA9IF90aGlzMi5fZ2V0UG9zaXRpb25Gb3JIaWVyYXJjaHkobm9kZSk7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIG1vdmFibGUgYXJlYSBvZiB0aGUgYnJhbmNoXG4gICAgICAgICAgICBpZiAoYnJhbmNoZXNbbm9kZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB2YXIgYnJhbmNoTm9kZXMgPSB7fTtcbiAgICAgICAgICAgICAgYnJhbmNoTm9kZXNbbm9kZS5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgICBnZXRCcmFuY2hOb2Rlcyhub2RlLCBicmFuY2hOb2Rlcyk7XG4gICAgICAgICAgICAgIGJyYW5jaGVzW25vZGUuaWRdID0gYnJhbmNoTm9kZXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBfZ2V0QnJhbmNoQm91bmRhcnk1ID0gZ2V0QnJhbmNoQm91bmRhcnkoYnJhbmNoZXNbbm9kZS5pZF0pO1xuXG4gICAgICAgICAgICB2YXIgX2dldEJyYW5jaEJvdW5kYXJ5NiA9IF9zbGljZWRUb0FycmF5KF9nZXRCcmFuY2hCb3VuZGFyeTUsIDQpO1xuXG4gICAgICAgICAgICB2YXIgbWluQnJhbmNoID0gX2dldEJyYW5jaEJvdW5kYXJ5NlswXTtcbiAgICAgICAgICAgIHZhciBtYXhCcmFuY2ggPSBfZ2V0QnJhbmNoQm91bmRhcnk2WzFdO1xuICAgICAgICAgICAgdmFyIG1pblNwYWNlQnJhbmNoID0gX2dldEJyYW5jaEJvdW5kYXJ5NlsyXTtcbiAgICAgICAgICAgIHZhciBtYXhTcGFjZUJyYW5jaCA9IF9nZXRCcmFuY2hCb3VuZGFyeTZbM107XG5cblxuICAgICAgICAgICAgdmFyIGRpZmYgPSBndWVzcyAtIG5vZGVQb3NpdGlvbjtcblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgd2UgYXJlIGFsbG93ZWQgdG8gbW92ZSB0aGUgbm9kZTpcbiAgICAgICAgICAgIHZhciBicmFuY2hPZmZzZXQgPSAwO1xuICAgICAgICAgICAgaWYgKGRpZmYgPiAwKSB7XG4gICAgICAgICAgICAgIGJyYW5jaE9mZnNldCA9IE1hdGgubWluKGRpZmYsIG1heFNwYWNlQnJhbmNoIC0gX3RoaXMyLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGlmZiA8IDApIHtcbiAgICAgICAgICAgICAgYnJhbmNoT2Zmc2V0ID0gLU1hdGgubWluKC1kaWZmLCBtaW5TcGFjZUJyYW5jaCAtIF90aGlzMi5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChicmFuY2hPZmZzZXQgIT0gMCkge1xuICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwibW92aW5nIGJyYW5jaDpcIixicmFuY2hPZmZzZXQsIG1heFNwYWNlQnJhbmNoLCBtaW5TcGFjZUJyYW5jaClcbiAgICAgICAgICAgICAgX3RoaXMyLl9zaGlmdEJsb2NrKG5vZGUuaWQsIGJyYW5jaE9mZnNldCk7XG4gICAgICAgICAgICAgIC8vdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZWRyYXdcIik7XG4gICAgICAgICAgICAgIHN0aWxsU2hpZnRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICB2YXIgbW92ZU5vZGUgPSBmdW5jdGlvbiBtb3ZlTm9kZShndWVzcykge1xuICAgICAgICAgICAgdmFyIG5vZGVQb3NpdGlvbiA9IF90aGlzMi5fZ2V0UG9zaXRpb25Gb3JIaWVyYXJjaHkobm9kZSk7XG5cbiAgICAgICAgICAgIC8vIHBvc2l0aW9uIG5vZGUgaWYgdGhlcmUgaXMgc3BhY2VcblxuICAgICAgICAgICAgdmFyIF9nZXRTcGFjZUFyb3VuZE5vZGU0ID0gX3RoaXMyLl9nZXRTcGFjZUFyb3VuZE5vZGUobm9kZSk7XG5cbiAgICAgICAgICAgIHZhciBfZ2V0U3BhY2VBcm91bmROb2RlNSA9IF9zbGljZWRUb0FycmF5KF9nZXRTcGFjZUFyb3VuZE5vZGU0LCAyKTtcblxuICAgICAgICAgICAgdmFyIG1pblNwYWNlID0gX2dldFNwYWNlQXJvdW5kTm9kZTVbMF07XG4gICAgICAgICAgICB2YXIgbWF4U3BhY2UgPSBfZ2V0U3BhY2VBcm91bmROb2RlNVsxXTtcblxuICAgICAgICAgICAgdmFyIGRpZmYgPSBndWVzcyAtIG5vZGVQb3NpdGlvbjtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIGFyZSBhbGxvd2VkIHRvIG1vdmUgdGhlIG5vZGU6XG4gICAgICAgICAgICB2YXIgbmV3UG9zaXRpb24gPSBub2RlUG9zaXRpb247XG4gICAgICAgICAgICBpZiAoZGlmZiA+IDApIHtcbiAgICAgICAgICAgICAgbmV3UG9zaXRpb24gPSBNYXRoLm1pbihub2RlUG9zaXRpb24gKyAobWF4U3BhY2UgLSBfdGhpczIub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcpLCBndWVzcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRpZmYgPCAwKSB7XG4gICAgICAgICAgICAgIG5ld1Bvc2l0aW9uID0gTWF0aC5tYXgobm9kZVBvc2l0aW9uIC0gKG1pblNwYWNlIC0gX3RoaXMyLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nKSwgZ3Vlc3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobmV3UG9zaXRpb24gIT09IG5vZGVQb3NpdGlvbikge1xuICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwibW92aW5nIE5vZGU6XCIsZGlmZiwgbWluU3BhY2UsIG1heFNwYWNlKTtcbiAgICAgICAgICAgICAgX3RoaXMyLl9zZXRQb3NpdGlvbkZvckhpZXJhcmNoeShub2RlLCBuZXdQb3NpdGlvbiwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgICAgICAgLy90aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlZHJhd1wiKTtcbiAgICAgICAgICAgICAgc3RpbGxTaGlmdGluZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZhciBndWVzcyA9IGdldEd1ZXNzKGl0ZXJhdGlvbnMsIGFib3ZlRWRnZXMpO1xuICAgICAgICAgIG1vdmVCcmFuY2goZ3Vlc3MpO1xuICAgICAgICAgIGd1ZXNzID0gZ2V0R3Vlc3MoaXRlcmF0aW9ucywgYWxsRWRnZXMpO1xuICAgICAgICAgIG1vdmVOb2RlKGd1ZXNzKTtcbiAgICAgICAgICAvL30pXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gbWV0aG9kIHRvIHJlbW92ZSB3aGl0ZXNwYWNlIGJldHdlZW4gYnJhbmNoZXMuIEJlY2F1c2Ugd2UgZG8gYm90dG9tIHVwLCB3ZSBjYW4gY2VudGVyIHRoZSBwYXJlbnRzLlxuICAgICAgICB2YXIgbWluaW1pemVFZGdlTGVuZ3RoQm90dG9tVXAgPSBmdW5jdGlvbiBtaW5pbWl6ZUVkZ2VMZW5ndGhCb3R0b21VcChpdGVyYXRpb25zKSB7XG4gICAgICAgICAgdmFyIGxldmVscyA9IE9iamVjdC5rZXlzKF90aGlzMi5kaXN0cmlidXRpb25PcmRlcmluZyk7XG4gICAgICAgICAgbGV2ZWxzID0gbGV2ZWxzLnJldmVyc2UoKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgICAgICAgc3RpbGxTaGlmdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZXZlbHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgdmFyIGxldmVsID0gbGV2ZWxzW2pdO1xuICAgICAgICAgICAgICB2YXIgbGV2ZWxOb2RlcyA9IF90aGlzMi5kaXN0cmlidXRpb25PcmRlcmluZ1tsZXZlbF07XG4gICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbGV2ZWxOb2Rlcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIG1pbmltaXplRWRnZUxlbmd0aCgxMDAwLCBsZXZlbE5vZGVzW2tdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0aWxsU2hpZnRpbmcgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkZJTklTSEVEIG1pbmltaXplRWRnZUxlbmd0aEJvdHRvbVVwIElOIFwiICsgaSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBtZXRob2QgdG8gcmVtb3ZlIHdoaXRlc3BhY2UgYmV0d2VlbiBicmFuY2hlcy4gQmVjYXVzZSB3ZSBkbyBib3R0b20gdXAsIHdlIGNhbiBjZW50ZXIgdGhlIHBhcmVudHMuXG4gICAgICAgIHZhciBzaGlmdEJyYW5jaGVzQ2xvc2VyQm90dG9tVXAgPSBmdW5jdGlvbiBzaGlmdEJyYW5jaGVzQ2xvc2VyQm90dG9tVXAoaXRlcmF0aW9ucykge1xuICAgICAgICAgIHZhciBsZXZlbHMgPSBPYmplY3Qua2V5cyhfdGhpczIuZGlzdHJpYnV0aW9uT3JkZXJpbmcpO1xuICAgICAgICAgIGxldmVscyA9IGxldmVscy5yZXZlcnNlKCk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVyYXRpb25zOyBpKyspIHtcbiAgICAgICAgICAgIHN0aWxsU2hpZnRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHNoaWZ0RWxlbWVudHNDbG9zZXIoYnJhbmNoU2hpZnRDYWxsYmFjaywgbGV2ZWxzLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChzdGlsbFNoaWZ0aW5nICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJGSU5JU0hFRCBzaGlmdEJyYW5jaGVzQ2xvc2VyQm90dG9tVXAgSU4gXCIgKyAoaSsxKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBjZW50ZXIgYWxsIHBhcmVudHNcbiAgICAgICAgdmFyIGNlbnRlckFsbFBhcmVudHMgPSBmdW5jdGlvbiBjZW50ZXJBbGxQYXJlbnRzKCkge1xuICAgICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiBfdGhpczIuYm9keS5ub2Rlcykge1xuICAgICAgICAgICAgaWYgKF90aGlzMi5ib2R5Lm5vZGVzLmhhc093blByb3BlcnR5KG5vZGVJZCkpIF90aGlzMi5fY2VudGVyUGFyZW50KF90aGlzMi5ib2R5Lm5vZGVzW25vZGVJZF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBjZW50ZXIgYWxsIHBhcmVudHNcbiAgICAgICAgdmFyIGNlbnRlckFsbFBhcmVudHNCb3R0b21VcCA9IGZ1bmN0aW9uIGNlbnRlckFsbFBhcmVudHNCb3R0b21VcCgpIHtcbiAgICAgICAgICB2YXIgbGV2ZWxzID0gT2JqZWN0LmtleXMoX3RoaXMyLmRpc3RyaWJ1dGlvbk9yZGVyaW5nKTtcbiAgICAgICAgICBsZXZlbHMgPSBsZXZlbHMucmV2ZXJzZSgpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGV2ZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbaV07XG4gICAgICAgICAgICB2YXIgbGV2ZWxOb2RlcyA9IF90aGlzMi5kaXN0cmlidXRpb25PcmRlcmluZ1tsZXZlbF07XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxldmVsTm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgX3RoaXMyLl9jZW50ZXJQYXJlbnQobGV2ZWxOb2Rlc1tqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHRoZSBhY3R1YWwgd29yayBpcyBkb25lIGhlcmUuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmJsb2NrU2hpZnRpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICBzaGlmdEJyYW5jaGVzQ2xvc2VyQm90dG9tVXAoNSk7XG4gICAgICAgICAgY2VudGVyQWxsUGFyZW50cygpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWluaW1pemUgZWRnZSBsZW5ndGhcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZWRnZU1pbmltaXphdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgIG1pbmltaXplRWRnZUxlbmd0aEJvdHRvbVVwKDIwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLnBhcmVudENlbnRyYWxpemF0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgY2VudGVyQWxsUGFyZW50c0JvdHRvbVVwKCk7XG4gICAgICAgIH1cblxuICAgICAgICBzaGlmdFRyZWVzKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBnaXZlcyB0aGUgc3BhY2UgYXJvdW5kIHRoZSBub2RlLiBJRiBhIG1hcCBpcyBzdXBwbGllZCwgaXQgd2lsbCBvbmx5IGNoZWNrIGFnYWluc3Qgbm9kZXMgTk9UIGluIHRoZSBtYXAuXG4gICAgICAgKiBUaGlzIGlzIHVzZWQgdG8gb25seSBnZXQgdGhlIGRpc3RhbmNlcyB0byBub2RlcyBvdXRzaWRlIG9mIGEgYnJhbmNoLlxuICAgICAgICogQHBhcmFtIG5vZGVcbiAgICAgICAqIEBwYXJhbSBtYXBcbiAgICAgICAqIEByZXR1cm5zIHsqW119XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZ2V0U3BhY2VBcm91bmROb2RlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0U3BhY2VBcm91bmROb2RlKG5vZGUsIG1hcCkge1xuICAgICAgICB2YXIgdXNlTWFwID0gdHJ1ZTtcbiAgICAgICAgaWYgKG1hcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdXNlTWFwID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxldmVsID0gdGhpcy5oaWVyYXJjaGljYWxMZXZlbHNbbm9kZS5pZF07XG4gICAgICAgIGlmIChsZXZlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5kaXN0cmlidXRpb25JbmRleFtub2RlLmlkXTtcbiAgICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLl9nZXRQb3NpdGlvbkZvckhpZXJhcmNoeShub2RlKTtcbiAgICAgICAgICB2YXIgbWluU3BhY2UgPSAxZTk7XG4gICAgICAgICAgdmFyIG1heFNwYWNlID0gMWU5O1xuICAgICAgICAgIGlmIChpbmRleCAhPT0gMCkge1xuICAgICAgICAgICAgdmFyIHByZXZOb2RlID0gdGhpcy5kaXN0cmlidXRpb25PcmRlcmluZ1tsZXZlbF1baW5kZXggLSAxXTtcbiAgICAgICAgICAgIGlmICh1c2VNYXAgPT09IHRydWUgJiYgbWFwW3ByZXZOb2RlLmlkXSA9PT0gdW5kZWZpbmVkIHx8IHVzZU1hcCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgdmFyIHByZXZQb3MgPSB0aGlzLl9nZXRQb3NpdGlvbkZvckhpZXJhcmNoeShwcmV2Tm9kZSk7XG4gICAgICAgICAgICAgIG1pblNwYWNlID0gcG9zaXRpb24gLSBwcmV2UG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpbmRleCAhPSB0aGlzLmRpc3RyaWJ1dGlvbk9yZGVyaW5nW2xldmVsXS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICB2YXIgbmV4dE5vZGUgPSB0aGlzLmRpc3RyaWJ1dGlvbk9yZGVyaW5nW2xldmVsXVtpbmRleCArIDFdO1xuICAgICAgICAgICAgaWYgKHVzZU1hcCA9PT0gdHJ1ZSAmJiBtYXBbbmV4dE5vZGUuaWRdID09PSB1bmRlZmluZWQgfHwgdXNlTWFwID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICB2YXIgbmV4dFBvcyA9IHRoaXMuX2dldFBvc2l0aW9uRm9ySGllcmFyY2h5KG5leHROb2RlKTtcbiAgICAgICAgICAgICAgbWF4U3BhY2UgPSBNYXRoLm1pbihtYXhTcGFjZSwgbmV4dFBvcyAtIHBvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gW21pblNwYWNlLCBtYXhTcGFjZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFswLCAwXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFdlIHVzZSB0aGlzIG1ldGhvZCB0byBjZW50ZXIgYSBwYXJlbnQgbm9kZSBhbmQgY2hlY2sgaWYgaXQgZG9lcyBub3QgY3Jvc3Mgb3RoZXIgbm9kZXMgd2hlbiBpdCBkb2VzLlxuICAgICAgICogQHBhcmFtIG5vZGVcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19jZW50ZXJQYXJlbnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jZW50ZXJQYXJlbnQobm9kZSkge1xuICAgICAgICBpZiAodGhpcy5oaWVyYXJjaGljYWxQYXJlbnRSZWZlcmVuY2Vbbm9kZS5pZF0pIHtcbiAgICAgICAgICB2YXIgcGFyZW50cyA9IHRoaXMuaGllcmFyY2hpY2FsUGFyZW50UmVmZXJlbmNlW25vZGUuaWRdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBhcmVudElkID0gcGFyZW50c1tpXTtcbiAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gdGhpcy5ib2R5Lm5vZGVzW3BhcmVudElkXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmhpZXJhcmNoaWNhbENoaWxkcmVuUmVmZXJlbmNlW3BhcmVudElkXSkge1xuICAgICAgICAgICAgICAvLyBnZXQgdGhlIHJhbmdlIG9mIHRoZSBjaGlsZHJlblxuICAgICAgICAgICAgICB2YXIgbWluUG9zID0gMWU5O1xuICAgICAgICAgICAgICB2YXIgbWF4UG9zID0gLTFlOTtcbiAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5oaWVyYXJjaGljYWxDaGlsZHJlblJlZmVyZW5jZVtwYXJlbnRJZF07XG4gICAgICAgICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgY2hpbGRyZW4ubGVuZ3RoOyBfaTUrKykge1xuICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tjaGlsZHJlbltfaTVdXTtcbiAgICAgICAgICAgICAgICAgIG1pblBvcyA9IE1hdGgubWluKG1pblBvcywgdGhpcy5fZ2V0UG9zaXRpb25Gb3JIaWVyYXJjaHkoY2hpbGROb2RlKSk7XG4gICAgICAgICAgICAgICAgICBtYXhQb3MgPSBNYXRoLm1heChtYXhQb3MsIHRoaXMuX2dldFBvc2l0aW9uRm9ySGllcmFyY2h5KGNoaWxkTm9kZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuX2dldFBvc2l0aW9uRm9ySGllcmFyY2h5KHBhcmVudE5vZGUpO1xuXG4gICAgICAgICAgICAgIHZhciBfZ2V0U3BhY2VBcm91bmROb2RlNiA9IHRoaXMuX2dldFNwYWNlQXJvdW5kTm9kZShwYXJlbnROb2RlKTtcblxuICAgICAgICAgICAgICB2YXIgX2dldFNwYWNlQXJvdW5kTm9kZTcgPSBfc2xpY2VkVG9BcnJheShfZ2V0U3BhY2VBcm91bmROb2RlNiwgMik7XG5cbiAgICAgICAgICAgICAgdmFyIG1pblNwYWNlID0gX2dldFNwYWNlQXJvdW5kTm9kZTdbMF07XG4gICAgICAgICAgICAgIHZhciBtYXhTcGFjZSA9IF9nZXRTcGFjZUFyb3VuZE5vZGU3WzFdO1xuXG4gICAgICAgICAgICAgIHZhciBuZXdQb3NpdGlvbiA9IDAuNSAqIChtaW5Qb3MgKyBtYXhQb3MpO1xuICAgICAgICAgICAgICB2YXIgZGlmZiA9IHBvc2l0aW9uIC0gbmV3UG9zaXRpb247XG4gICAgICAgICAgICAgIGlmIChkaWZmIDwgMCAmJiBNYXRoLmFicyhkaWZmKSA8IG1heFNwYWNlIC0gdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZyB8fCBkaWZmID4gMCAmJiBNYXRoLmFicyhkaWZmKSA8IG1pblNwYWNlIC0gdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFBvc2l0aW9uRm9ySGllcmFyY2h5KHBhcmVudE5vZGUsIG5ld1Bvc2l0aW9uLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBmdW5jdGlvbiBwbGFjZXMgdGhlIG5vZGVzIG9uIHRoZSBjYW52YXMgYmFzZWQgb24gdGhlIGhpZXJhcmNoaWFsIGRpc3RyaWJ1dGlvbi5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gZGlzdHJpYnV0aW9uIHwgb2J0YWluZWQgYnkgdGhlIGZ1bmN0aW9uIHRoaXMuX2dldERpc3RyaWJ1dGlvbigpXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfcGxhY2VOb2Rlc0J5SGllcmFyY2h5JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcGxhY2VOb2Rlc0J5SGllcmFyY2h5KGRpc3RyaWJ1dGlvbikge1xuICAgICAgICB0aGlzLnBvc2l0aW9uZWROb2RlcyA9IHt9O1xuICAgICAgICAvLyBzdGFydCBwbGFjaW5nIGFsbCB0aGUgbGV2ZWwgMCBub2RlcyBmaXJzdC4gVGhlbiByZWN1cnNpdmVseSBwb3NpdGlvbiB0aGVpciBicmFuY2hlcy5cbiAgICAgICAgZm9yICh2YXIgbGV2ZWwgaW4gZGlzdHJpYnV0aW9uKSB7XG4gICAgICAgICAgaWYgKGRpc3RyaWJ1dGlvbi5oYXNPd25Qcm9wZXJ0eShsZXZlbCkpIHtcbiAgICAgICAgICAgIC8vIHNvcnQgbm9kZXMgaW4gbGV2ZWwgYnkgcG9zaXRpb246XG4gICAgICAgICAgICB2YXIgbm9kZUFycmF5ID0gT2JqZWN0LmtleXMoZGlzdHJpYnV0aW9uW2xldmVsXSk7XG4gICAgICAgICAgICBub2RlQXJyYXkgPSB0aGlzLl9pbmRleEFycmF5VG9Ob2Rlcyhub2RlQXJyYXkpO1xuICAgICAgICAgICAgdGhpcy5fc29ydE5vZGVBcnJheShub2RlQXJyYXkpO1xuICAgICAgICAgICAgdmFyIGhhbmRsZWROb2RlQ291bnQgPSAwO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVBcnJheVtpXTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMucG9zaXRpb25lZE5vZGVzW25vZGUuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZyAqIGhhbmRsZWROb2RlQ291bnQ7XG4gICAgICAgICAgICAgICAgLy8gd2UgZ2V0IHRoZSBYIG9yIFkgdmFsdWVzIHdlIG5lZWQgYW5kIHN0b3JlIHRoZW0gaW4gcG9zIGFuZCBwcmV2aW91c1Bvcy4gVGhlIGdldCBhbmQgc2V0IG1ha2Ugc3VyZSB3ZSBnZXQgWCBvciBZXG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZWROb2RlQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICBwb3MgPSB0aGlzLl9nZXRQb3NpdGlvbkZvckhpZXJhcmNoeShub2RlQXJyYXlbaSAtIDFdKSArIHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3NldFBvc2l0aW9uRm9ySGllcmFyY2h5KG5vZGUsIHBvcywgbGV2ZWwpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRhUG9zaXRpb25BbmRDb250aW51ZShub2RlLCBsZXZlbCwgcG9zKTtcblxuICAgICAgICAgICAgICAgIGhhbmRsZWROb2RlQ291bnQrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgaXMgYSByZWN1cnNpdmVseSBjYWxsZWQgZnVuY3Rpb24gdG8gZW51bWVyYXRlIHRoZSBicmFuY2hlcyBmcm9tIHRoZSBsYXJnZXN0IGh1YnMgYW5kIHBsYWNlIHRoZSBub2Rlc1xuICAgICAgICogb24gYSBYIHBvc2l0aW9uIHRoYXQgZW5zdXJlcyB0aGVyZSB3aWxsIGJlIG5vIG92ZXJsYXAuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHBhcmVudElkXG4gICAgICAgKiBAcGFyYW0gcGFyZW50TGV2ZWxcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19wbGFjZUJyYW5jaE5vZGVzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcGxhY2VCcmFuY2hOb2RlcyhwYXJlbnRJZCwgcGFyZW50TGV2ZWwpIHtcbiAgICAgICAgLy8gaWYgdGhpcyBpcyBub3QgYSBwYXJlbnQsIGNhbmNlbCB0aGUgcGxhY2luZy4gVGhpcyBjYW4gaGFwcGVuIHdpdGggbXVsdGlwbGUgcGFyZW50cyB0byBvbmUgY2hpbGQuXG4gICAgICAgIGlmICh0aGlzLmhpZXJhcmNoaWNhbENoaWxkcmVuUmVmZXJlbmNlW3BhcmVudElkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IGEgbGlzdCBvZiBjaGlsZE5vZGVzXG4gICAgICAgIHZhciBjaGlsZE5vZGVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5oaWVyYXJjaGljYWxDaGlsZHJlblJlZmVyZW5jZVtwYXJlbnRJZF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjaGlsZE5vZGVzLnB1c2godGhpcy5ib2R5Lm5vZGVzW3RoaXMuaGllcmFyY2hpY2FsQ2hpbGRyZW5SZWZlcmVuY2VbcGFyZW50SWRdW2ldXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1c2UgdGhlIHBvc2l0aW9ucyB0byBvcmRlciB0aGUgbm9kZXMuXG4gICAgICAgIHRoaXMuX3NvcnROb2RlQXJyYXkoY2hpbGROb2Rlcyk7XG5cbiAgICAgICAgLy8gcG9zaXRpb24gdGhlIGNoaWxkTm9kZXNcbiAgICAgICAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgY2hpbGROb2Rlcy5sZW5ndGg7IF9pNisrKSB7XG4gICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXNbX2k2XTtcbiAgICAgICAgICB2YXIgY2hpbGROb2RlTGV2ZWwgPSB0aGlzLmhpZXJhcmNoaWNhbExldmVsc1tjaGlsZE5vZGUuaWRdO1xuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBjaGlsZCBub2RlIGlzIGJlbG93IHRoZSBwYXJlbnQgbm9kZSBhbmQgaWYgaXQgaGFzIGFscmVhZHkgYmVlbiBwb3NpdGlvbmVkLlxuICAgICAgICAgIGlmIChjaGlsZE5vZGVMZXZlbCA+IHBhcmVudExldmVsICYmIHRoaXMucG9zaXRpb25lZE5vZGVzW2NoaWxkTm9kZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gZ2V0IHRoZSBhbW91bnQgb2Ygc3BhY2UgcmVxdWlyZWQgZm9yIHRoaXMgbm9kZS4gSWYgcGFyZW50IHRoZSB3aWR0aCBpcyBiYXNlZCBvbiB0aGUgYW1vdW50IG9mIGNoaWxkcmVuLlxuICAgICAgICAgICAgdmFyIHBvcyA9IHZvaWQgMDtcblxuICAgICAgICAgICAgLy8gd2UgZ2V0IHRoZSBYIG9yIFkgdmFsdWVzIHdlIG5lZWQgYW5kIHN0b3JlIHRoZW0gaW4gcG9zIGFuZCBwcmV2aW91c1Bvcy4gVGhlIGdldCBhbmQgc2V0IG1ha2Ugc3VyZSB3ZSBnZXQgWCBvciBZXG4gICAgICAgICAgICBpZiAoX2k2ID09PSAwKSB7XG4gICAgICAgICAgICAgIHBvcyA9IHRoaXMuX2dldFBvc2l0aW9uRm9ySGllcmFyY2h5KHRoaXMuYm9keS5ub2Rlc1twYXJlbnRJZF0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcG9zID0gdGhpcy5fZ2V0UG9zaXRpb25Gb3JIaWVyYXJjaHkoY2hpbGROb2Rlc1tfaTYgLSAxXSkgKyB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc2V0UG9zaXRpb25Gb3JIaWVyYXJjaHkoY2hpbGROb2RlLCBwb3MsIGNoaWxkTm9kZUxldmVsKTtcbiAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRhUG9zaXRpb25BbmRDb250aW51ZShjaGlsZE5vZGUsIGNoaWxkTm9kZUxldmVsLCBwb3MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2VudGVyIHRoZSBwYXJlbnQgbm9kZXMuXG4gICAgICAgIHZhciBtaW5Qb3MgPSAxZTk7XG4gICAgICAgIHZhciBtYXhQb3MgPSAtMWU5O1xuICAgICAgICBmb3IgKHZhciBfaTcgPSAwOyBfaTcgPCBjaGlsZE5vZGVzLmxlbmd0aDsgX2k3KyspIHtcbiAgICAgICAgICB2YXIgY2hpbGROb2RlSWQgPSBjaGlsZE5vZGVzW19pN10uaWQ7XG4gICAgICAgICAgbWluUG9zID0gTWF0aC5taW4obWluUG9zLCB0aGlzLl9nZXRQb3NpdGlvbkZvckhpZXJhcmNoeSh0aGlzLmJvZHkubm9kZXNbY2hpbGROb2RlSWRdKSk7XG4gICAgICAgICAgbWF4UG9zID0gTWF0aC5tYXgobWF4UG9zLCB0aGlzLl9nZXRQb3NpdGlvbkZvckhpZXJhcmNoeSh0aGlzLmJvZHkubm9kZXNbY2hpbGROb2RlSWRdKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0UG9zaXRpb25Gb3JIaWVyYXJjaHkodGhpcy5ib2R5Lm5vZGVzW3BhcmVudElkXSwgMC41ICogKG1pblBvcyArIG1heFBvcyksIHBhcmVudExldmVsKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIG1ldGhvZCBjaGVja3MgZm9yIG92ZXJsYXAgYW5kIGlmIHJlcXVpcmVkIHNoaWZ0cyB0aGUgYnJhbmNoLiBJdCBhbHNvIGtlZXBzIHJlY29yZHMgb2YgcG9zaXRpb25lZCBub2Rlcy5cbiAgICAgICAqIEZpbmFsbHkgaXQgd2lsbCBjYWxsIF9wbGFjZUJyYW5jaE5vZGVzIHRvIHBsYWNlIHRoZSBicmFuY2ggbm9kZXMuXG4gICAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAgICogQHBhcmFtIGxldmVsXG4gICAgICAgKiBAcGFyYW0gcG9zXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfdmFsaWRhdGFQb3NpdGlvbkFuZENvbnRpbnVlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdmFsaWRhdGFQb3NpdGlvbkFuZENvbnRpbnVlKG5vZGUsIGxldmVsLCBwb3MpIHtcbiAgICAgICAgLy8gaWYgb3ZlcmxhcCBoYXMgYmVlbiBkZXRlY3RlZCwgd2Ugc2hpZnQgdGhlIGJyYW5jaFxuICAgICAgICBpZiAodGhpcy5sYXN0Tm9kZU9uTGV2ZWxbbGV2ZWxdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgcHJldmlvdXNQb3MgPSB0aGlzLl9nZXRQb3NpdGlvbkZvckhpZXJhcmNoeSh0aGlzLmJvZHkubm9kZXNbdGhpcy5sYXN0Tm9kZU9uTGV2ZWxbbGV2ZWxdXSk7XG4gICAgICAgICAgaWYgKHBvcyAtIHByZXZpb3VzUG9zIDwgdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZykge1xuICAgICAgICAgICAgdmFyIGRpZmYgPSBwcmV2aW91c1BvcyArIHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcgLSBwb3M7XG4gICAgICAgICAgICB2YXIgc2hhcmVkUGFyZW50ID0gdGhpcy5fZmluZENvbW1vblBhcmVudCh0aGlzLmxhc3ROb2RlT25MZXZlbFtsZXZlbF0sIG5vZGUuaWQpO1xuICAgICAgICAgICAgdGhpcy5fc2hpZnRCbG9jayhzaGFyZWRQYXJlbnQud2l0aENoaWxkLCBkaWZmKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzdG9yZSBjaGFuZ2UgaW4gcG9zaXRpb24uXG4gICAgICAgIHRoaXMubGFzdE5vZGVPbkxldmVsW2xldmVsXSA9IG5vZGUuaWQ7XG5cbiAgICAgICAgdGhpcy5wb3NpdGlvbmVkTm9kZXNbbm9kZS5pZF0gPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuX3BsYWNlQnJhbmNoTm9kZXMobm9kZS5pZCwgbGV2ZWwpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlY2VpdmVzIGFuIGFycmF5IHdpdGggbm9kZSBpbmRpY2VzIGFuZCByZXR1cm5zIGFuIGFycmF5IHdpdGggdGhlIGFjdHVhbCBub2RlIHJlZmVyZW5jZXMuIFVzZWQgZm9yIHNvcnRpbmcgYmFzZWQgb25cbiAgICAgICAqIG5vZGUgcHJvcGVydGllcy5cbiAgICAgICAqIEBwYXJhbSBpZEFycmF5XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19pbmRleEFycmF5VG9Ob2RlcycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2luZGV4QXJyYXlUb05vZGVzKGlkQXJyYXkpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFycmF5LnB1c2godGhpcy5ib2R5Lm5vZGVzW2lkQXJyYXlbaV1dKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBmdW5jdGlvbiBnZXQgdGhlIGRpc3RyaWJ1dGlvbiBvZiBsZXZlbHMgYmFzZWQgb24gaHVic2l6ZVxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZ2V0RGlzdHJpYnV0aW9uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGlzdHJpYnV0aW9uKCkge1xuICAgICAgICB2YXIgZGlzdHJpYnV0aW9uID0ge307XG4gICAgICAgIHZhciBub2RlSWQgPSB2b2lkIDAsXG4gICAgICAgICAgICBub2RlID0gdm9pZCAwO1xuXG4gICAgICAgIC8vIHdlIGZpeCBZIGJlY2F1c2UgdGhlIGhpZXJhcmNoeSBpcyB2ZXJ0aWNhbCwgd2UgZml4IFggc28gd2UgZG8gbm90IGdpdmUgYSBub2RlIGFuIHggcG9zaXRpb24gZm9yIGEgc2Vjb25kIHRpbWUuXG4gICAgICAgIC8vIHRoZSBmaXggb2YgWCBpcyByZW1vdmVkIGFmdGVyIHRoZSB4IHZhbHVlIGhhcyBiZWVuIHNldC5cbiAgICAgICAgZm9yIChub2RlSWQgaW4gdGhpcy5ib2R5Lm5vZGVzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlcy5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgICBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICAgICAgICB2YXIgbGV2ZWwgPSB0aGlzLmhpZXJhcmNoaWNhbExldmVsc1tub2RlSWRdID09PSB1bmRlZmluZWQgPyAwIDogdGhpcy5oaWVyYXJjaGljYWxMZXZlbHNbbm9kZUlkXTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmRpcmVjdGlvbiA9PT0gJ1VEJyB8fCB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmRpcmVjdGlvbiA9PT0gJ0RVJykge1xuICAgICAgICAgICAgICBub2RlLnkgPSB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmxldmVsU2VwYXJhdGlvbiAqIGxldmVsO1xuICAgICAgICAgICAgICBub2RlLm9wdGlvbnMuZml4ZWQueSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBub2RlLnggPSB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmxldmVsU2VwYXJhdGlvbiAqIGxldmVsO1xuICAgICAgICAgICAgICBub2RlLm9wdGlvbnMuZml4ZWQueCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlzdHJpYnV0aW9uW2xldmVsXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGRpc3RyaWJ1dGlvbltsZXZlbF0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3RyaWJ1dGlvbltsZXZlbF1bbm9kZUlkXSA9IG5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaXN0cmlidXRpb247XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0IHRoZSBodWJzaXplIGZyb20gYWxsIHJlbWFpbmluZyB1bmxldmVsbGVkIG5vZGVzLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZ2V0SHViU2l6ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEh1YlNpemUoKSB7XG4gICAgICAgIHZhciBodWJTaXplID0gMDtcbiAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIHRoaXMuYm9keS5ub2Rlcykge1xuICAgICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmhpZXJhcmNoaWNhbExldmVsc1tub2RlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgaHViU2l6ZSA9IG5vZGUuZWRnZXMubGVuZ3RoIDwgaHViU2l6ZSA/IGh1YlNpemUgOiBub2RlLmVkZ2VzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGh1YlNpemU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogdGhpcyBmdW5jdGlvbiBhbGxvY2F0ZXMgbm9kZXMgaW4gbGV2ZWxzIGJhc2VkIG9uIHRoZSByZWN1cnNpdmUgYnJhbmNoaW5nIGZyb20gdGhlIGxhcmdlc3QgaHVicy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gaHVic2l6ZVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2RldGVybWluZUxldmVsc0J5SHVic2l6ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2RldGVybWluZUxldmVsc0J5SHVic2l6ZSgpIHtcbiAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGh1YlNpemUgPSAxO1xuXG4gICAgICAgIHZhciBsZXZlbERvd25zdHJlYW0gPSBmdW5jdGlvbiBsZXZlbERvd25zdHJlYW0obm9kZUEsIG5vZGVCKSB7XG4gICAgICAgICAgaWYgKF90aGlzMy5oaWVyYXJjaGljYWxMZXZlbHNbbm9kZUIuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHNldCBpbml0aWFsIGxldmVsXG4gICAgICAgICAgICBpZiAoX3RoaXMzLmhpZXJhcmNoaWNhbExldmVsc1tub2RlQS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBfdGhpczMuaGllcmFyY2hpY2FsTGV2ZWxzW25vZGVBLmlkXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgbGV2ZWxcbiAgICAgICAgICAgIF90aGlzMy5oaWVyYXJjaGljYWxMZXZlbHNbbm9kZUIuaWRdID0gX3RoaXMzLmhpZXJhcmNoaWNhbExldmVsc1tub2RlQS5pZF0gKyAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB3aGlsZSAoaHViU2l6ZSA+IDApIHtcbiAgICAgICAgICAvLyBkZXRlcm1pbmUgaHVic1xuICAgICAgICAgIGh1YlNpemUgPSB0aGlzLl9nZXRIdWJTaXplKCk7XG4gICAgICAgICAgaWYgKGh1YlNpemUgPT09IDApIGJyZWFrO1xuXG4gICAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIHRoaXMuYm9keS5ub2Rlcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlcy5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICAgICAgICAgIGlmIChub2RlLmVkZ2VzLmxlbmd0aCA9PT0gaHViU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NyYXdsTmV0d29yayhsZXZlbERvd25zdHJlYW0sIG5vZGVJZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBUT0RPOiByZWxlYXNlIGZlYXR1cmVcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19kZXRlcm1pbmVMZXZlbHNDdXN0b21DYWxsYmFjaycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2RldGVybWluZUxldmVsc0N1c3RvbUNhbGxiYWNrKCkge1xuICAgICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgICB2YXIgbWluTGV2ZWwgPSAxMDAwMDA7XG5cbiAgICAgICAgLy8gVE9ETzogdGhpcyBzaG91bGQgY29tZSBmcm9tIG9wdGlvbnMuXG4gICAgICAgIHZhciBjdXN0b21DYWxsYmFjayA9IGZ1bmN0aW9uIGN1c3RvbUNhbGxiYWNrKG5vZGVBLCBub2RlQiwgZWRnZSkge307XG5cbiAgICAgICAgdmFyIGxldmVsQnlEaXJlY3Rpb24gPSBmdW5jdGlvbiBsZXZlbEJ5RGlyZWN0aW9uKG5vZGVBLCBub2RlQiwgZWRnZSkge1xuICAgICAgICAgIHZhciBsZXZlbEEgPSBfdGhpczQuaGllcmFyY2hpY2FsTGV2ZWxzW25vZGVBLmlkXTtcbiAgICAgICAgICAvLyBzZXQgaW5pdGlhbCBsZXZlbFxuICAgICAgICAgIGlmIChsZXZlbEEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgX3RoaXM0LmhpZXJhcmNoaWNhbExldmVsc1tub2RlQS5pZF0gPSBtaW5MZXZlbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZGlmZiA9IGN1c3RvbUNhbGxiYWNrKF9OZXR3b3JrVXRpbDIuZGVmYXVsdC5jbG9uZU9wdGlvbnMobm9kZUEsICdub2RlJyksIF9OZXR3b3JrVXRpbDIuZGVmYXVsdC5jbG9uZU9wdGlvbnMobm9kZUIsICdub2RlJyksIF9OZXR3b3JrVXRpbDIuZGVmYXVsdC5jbG9uZU9wdGlvbnMoZWRnZSwgJ2VkZ2UnKSk7XG5cbiAgICAgICAgICBfdGhpczQuaGllcmFyY2hpY2FsTGV2ZWxzW25vZGVCLmlkXSA9IF90aGlzNC5oaWVyYXJjaGljYWxMZXZlbHNbbm9kZUEuaWRdICsgZGlmZjtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9jcmF3bE5ldHdvcmsobGV2ZWxCeURpcmVjdGlvbik7XG4gICAgICAgIHRoaXMuX3NldE1pbkxldmVsVG9aZXJvKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogdGhpcyBmdW5jdGlvbiBhbGxvY2F0ZXMgbm9kZXMgaW4gbGV2ZWxzIGJhc2VkIG9uIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGVkZ2VzXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIGh1YnNpemVcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19kZXRlcm1pbmVMZXZlbHNEaXJlY3RlZCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2RldGVybWluZUxldmVsc0RpcmVjdGVkKCkge1xuICAgICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgICB2YXIgbWluTGV2ZWwgPSAxMDAwMDtcbiAgICAgICAgdmFyIGxldmVsQnlEaXJlY3Rpb24gPSBmdW5jdGlvbiBsZXZlbEJ5RGlyZWN0aW9uKG5vZGVBLCBub2RlQiwgZWRnZSkge1xuICAgICAgICAgIHZhciBsZXZlbEEgPSBfdGhpczUuaGllcmFyY2hpY2FsTGV2ZWxzW25vZGVBLmlkXTtcbiAgICAgICAgICAvLyBzZXQgaW5pdGlhbCBsZXZlbFxuICAgICAgICAgIGlmIChsZXZlbEEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgX3RoaXM1LmhpZXJhcmNoaWNhbExldmVsc1tub2RlQS5pZF0gPSBtaW5MZXZlbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVkZ2UudG9JZCA9PSBub2RlQi5pZCkge1xuICAgICAgICAgICAgX3RoaXM1LmhpZXJhcmNoaWNhbExldmVsc1tub2RlQi5pZF0gPSBfdGhpczUuaGllcmFyY2hpY2FsTGV2ZWxzW25vZGVBLmlkXSArIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzNS5oaWVyYXJjaGljYWxMZXZlbHNbbm9kZUIuaWRdID0gX3RoaXM1LmhpZXJhcmNoaWNhbExldmVsc1tub2RlQS5pZF0gLSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fY3Jhd2xOZXR3b3JrKGxldmVsQnlEaXJlY3Rpb24pO1xuICAgICAgICB0aGlzLl9zZXRNaW5MZXZlbFRvWmVybygpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNtYWxsIHV0aWwgbWV0aG9kIHRvIHNldCB0aGUgbWluaW11bSBsZXZlbHMgb2YgdGhlIG5vZGVzIHRvIHplcm8uXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc2V0TWluTGV2ZWxUb1plcm8nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRNaW5MZXZlbFRvWmVybygpIHtcbiAgICAgICAgdmFyIG1pbkxldmVsID0gMWU5O1xuICAgICAgICAvLyBnZXQgdGhlIG1pbmltdW0gbGV2ZWxcbiAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIHRoaXMuYm9keS5ub2Rlcykge1xuICAgICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGllcmFyY2hpY2FsTGV2ZWxzW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBtaW5MZXZlbCA9IE1hdGgubWluKHRoaXMuaGllcmFyY2hpY2FsTGV2ZWxzW25vZGVJZF0sIG1pbkxldmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzdWJ0cmFjdCB0aGUgbWluaW11bSBmcm9tIHRoZSBzZXQgc28gd2UgaGF2ZSBhIHJhbmdlIHN0YXJ0aW5nIGZyb20gMFxuICAgICAgICBmb3IgKHZhciBfbm9kZUlkMiBpbiB0aGlzLmJvZHkubm9kZXMpIHtcbiAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzLmhhc093blByb3BlcnR5KF9ub2RlSWQyKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGllcmFyY2hpY2FsTGV2ZWxzW19ub2RlSWQyXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHRoaXMuaGllcmFyY2hpY2FsTGV2ZWxzW19ub2RlSWQyXSAtPSBtaW5MZXZlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBVcGRhdGUgdGhlIGJvb2trZWVwaW5nIG9mIHBhcmVudCBhbmQgY2hpbGQuXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZ2VuZXJhdGVNYXAnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZW5lcmF0ZU1hcCgpIHtcbiAgICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGZpbGxJblJlbGF0aW9ucyA9IGZ1bmN0aW9uIGZpbGxJblJlbGF0aW9ucyhwYXJlbnROb2RlLCBjaGlsZE5vZGUpIHtcbiAgICAgICAgICBpZiAoX3RoaXM2LmhpZXJhcmNoaWNhbExldmVsc1tjaGlsZE5vZGUuaWRdID4gX3RoaXM2LmhpZXJhcmNoaWNhbExldmVsc1twYXJlbnROb2RlLmlkXSkge1xuICAgICAgICAgICAgdmFyIHBhcmVudE5vZGVJZCA9IHBhcmVudE5vZGUuaWQ7XG4gICAgICAgICAgICB2YXIgY2hpbGROb2RlSWQgPSBjaGlsZE5vZGUuaWQ7XG4gICAgICAgICAgICBpZiAoX3RoaXM2LmhpZXJhcmNoaWNhbENoaWxkcmVuUmVmZXJlbmNlW3BhcmVudE5vZGVJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBfdGhpczYuaGllcmFyY2hpY2FsQ2hpbGRyZW5SZWZlcmVuY2VbcGFyZW50Tm9kZUlkXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXM2LmhpZXJhcmNoaWNhbENoaWxkcmVuUmVmZXJlbmNlW3BhcmVudE5vZGVJZF0ucHVzaChjaGlsZE5vZGVJZCk7XG4gICAgICAgICAgICBpZiAoX3RoaXM2LmhpZXJhcmNoaWNhbFBhcmVudFJlZmVyZW5jZVtjaGlsZE5vZGVJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBfdGhpczYuaGllcmFyY2hpY2FsUGFyZW50UmVmZXJlbmNlW2NoaWxkTm9kZUlkXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXM2LmhpZXJhcmNoaWNhbFBhcmVudFJlZmVyZW5jZVtjaGlsZE5vZGVJZF0ucHVzaChwYXJlbnROb2RlSWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9jcmF3bE5ldHdvcmsoZmlsbEluUmVsYXRpb25zKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDcmF3bCBvdmVyIHRoZSBlbnRpcmUgbmV0d29yayBhbmQgdXNlIGEgY2FsbGJhY2sgb24gZWFjaCBub2RlIGNvdXBsZSB0aGF0IGlzIGNvbm5lY3RlZCB0byBlYWNoIG90aGVyLlxuICAgICAgICogQHBhcmFtIGNhbGxiYWNrICAgICAgICAgIHwgd2lsbCByZWNlaXZlIG5vZGVBIG5vZGVCIGFuZCB0aGUgY29ubmVjdGluZyBlZGdlLiBBIGFuZCBCIGFyZSB1bmlxdWUuXG4gICAgICAgKiBAcGFyYW0gc3RhcnRpbmdOb2RlSWRcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19jcmF3bE5ldHdvcmsnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmF3bE5ldHdvcmsoKSB7XG4gICAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uICgpIHt9IDogYXJndW1lbnRzWzBdO1xuICAgICAgICB2YXIgc3RhcnRpbmdOb2RlSWQgPSBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgdmFyIHByb2dyZXNzID0ge307XG4gICAgICAgIHZhciB0cmVlSW5kZXggPSAwO1xuXG4gICAgICAgIHZhciBjcmF3bGVyID0gZnVuY3Rpb24gY3Jhd2xlcihub2RlLCB0cmVlKSB7XG4gICAgICAgICAgaWYgKHByb2dyZXNzW25vZGUuaWRdID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgaWYgKF90aGlzNy5oaWVyYXJjaGljYWxUcmVlc1tub2RlLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIF90aGlzNy5oaWVyYXJjaGljYWxUcmVlc1tub2RlLmlkXSA9IHRyZWU7XG4gICAgICAgICAgICAgIF90aGlzNy50cmVlSW5kZXggPSBNYXRoLm1heCh0cmVlLCBfdGhpczcudHJlZUluZGV4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJvZ3Jlc3Nbbm9kZS5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5lZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAobm9kZS5lZGdlc1tpXS5jb25uZWN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5lZGdlc1tpXS50b0lkID09PSBub2RlLmlkKSB7XG4gICAgICAgICAgICAgICAgICBjaGlsZE5vZGUgPSBub2RlLmVkZ2VzW2ldLmZyb207XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZSA9IG5vZGUuZWRnZXNbaV0udG87XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuaWQgIT09IGNoaWxkTm9kZS5pZCkge1xuICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobm9kZSwgY2hpbGROb2RlLCBub2RlLmVkZ2VzW2ldKTtcbiAgICAgICAgICAgICAgICAgIGNyYXdsZXIoY2hpbGROb2RlLCB0cmVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gd2UgY2FuIGNyYXdsIGZyb20gYSBzcGVjaWZpYyBub2RlIG9yIG92ZXIgYWxsIG5vZGVzLlxuICAgICAgICBpZiAoc3RhcnRpbmdOb2RlSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLmJvZHkubm9kZUluZGljZXNbaV1dO1xuICAgICAgICAgICAgaWYgKHByb2dyZXNzW25vZGUuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY3Jhd2xlcihub2RlLCB0cmVlSW5kZXgpO1xuICAgICAgICAgICAgICB0cmVlSW5kZXggKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9ub2RlID0gdGhpcy5ib2R5Lm5vZGVzW3N0YXJ0aW5nTm9kZUlkXTtcbiAgICAgICAgICBpZiAoX25vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIk5vZGUgbm90IGZvdW5kOlwiLCBzdGFydGluZ05vZGVJZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNyYXdsZXIoX25vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2hpZnQgYSBicmFuY2ggYSBjZXJ0YWluIGRpc3RhbmNlXG4gICAgICAgKiBAcGFyYW0gcGFyZW50SWRcbiAgICAgICAqIEBwYXJhbSBkaWZmXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc2hpZnRCbG9jaycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NoaWZ0QmxvY2socGFyZW50SWQsIGRpZmYpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZGlyZWN0aW9uID09PSAnVUQnIHx8IHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZGlyZWN0aW9uID09PSAnRFUnKSB7XG4gICAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW3BhcmVudElkXS54ICs9IGRpZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW3BhcmVudElkXS55ICs9IGRpZmY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGllcmFyY2hpY2FsQ2hpbGRyZW5SZWZlcmVuY2VbcGFyZW50SWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaGllcmFyY2hpY2FsQ2hpbGRyZW5SZWZlcmVuY2VbcGFyZW50SWRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9zaGlmdEJsb2NrKHRoaXMuaGllcmFyY2hpY2FsQ2hpbGRyZW5SZWZlcmVuY2VbcGFyZW50SWRdW2ldLCBkaWZmKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBGaW5kIGEgY29tbW9uIHBhcmVudCBiZXR3ZWVuIGJyYW5jaGVzLlxuICAgICAgICogQHBhcmFtIGNoaWxkQVxuICAgICAgICogQHBhcmFtIGNoaWxkQlxuICAgICAgICogQHJldHVybnMge3tmb3VuZFBhcmVudCwgd2l0aENoaWxkfX1cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19maW5kQ29tbW9uUGFyZW50JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZmluZENvbW1vblBhcmVudChjaGlsZEEsIGNoaWxkQikge1xuICAgICAgICB2YXIgX3RoaXM4ID0gdGhpcztcblxuICAgICAgICB2YXIgcGFyZW50cyA9IHt9O1xuICAgICAgICB2YXIgaXRlcmF0ZVBhcmVudHMgPSBmdW5jdGlvbiBpdGVyYXRlUGFyZW50cyhwYXJlbnRzLCBjaGlsZCkge1xuICAgICAgICAgIGlmIChfdGhpczguaGllcmFyY2hpY2FsUGFyZW50UmVmZXJlbmNlW2NoaWxkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzOC5oaWVyYXJjaGljYWxQYXJlbnRSZWZlcmVuY2VbY2hpbGRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBfdGhpczguaGllcmFyY2hpY2FsUGFyZW50UmVmZXJlbmNlW2NoaWxkXVtpXTtcbiAgICAgICAgICAgICAgcGFyZW50c1twYXJlbnRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaXRlcmF0ZVBhcmVudHMocGFyZW50cywgcGFyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBmaW5kUGFyZW50ID0gZnVuY3Rpb24gZmluZFBhcmVudChwYXJlbnRzLCBjaGlsZCkge1xuICAgICAgICAgIGlmIChfdGhpczguaGllcmFyY2hpY2FsUGFyZW50UmVmZXJlbmNlW2NoaWxkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzOC5oaWVyYXJjaGljYWxQYXJlbnRSZWZlcmVuY2VbY2hpbGRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBfdGhpczguaGllcmFyY2hpY2FsUGFyZW50UmVmZXJlbmNlW2NoaWxkXVtpXTtcbiAgICAgICAgICAgICAgaWYgKHBhcmVudHNbcGFyZW50XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZm91bmRQYXJlbnQ6IHBhcmVudCwgd2l0aENoaWxkOiBjaGlsZCB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBicmFuY2ggPSBmaW5kUGFyZW50KHBhcmVudHMsIHBhcmVudCk7XG4gICAgICAgICAgICAgIGlmIChicmFuY2guZm91bmRQYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnJhbmNoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7IGZvdW5kUGFyZW50OiBudWxsLCB3aXRoQ2hpbGQ6IGNoaWxkIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgaXRlcmF0ZVBhcmVudHMocGFyZW50cywgY2hpbGRBKTtcbiAgICAgICAgcmV0dXJuIGZpbmRQYXJlbnQocGFyZW50cywgY2hpbGRCKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBYnN0cmFjdCB0aGUgZ2V0dGluZyBvZiB0aGUgcG9zaXRpb24gc28gd2Ugd29uJ3QgaGF2ZSB0byByZXBlYXQgdGhlIGNoZWNrIGZvciBkaXJlY3Rpb24gYWxsIHRoZSB0aW1lXG4gICAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAgICogQHBhcmFtIHBvc2l0aW9uXG4gICAgICAgKiBAcGFyYW0gbGV2ZWxcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19zZXRQb3NpdGlvbkZvckhpZXJhcmNoeScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFBvc2l0aW9uRm9ySGllcmFyY2h5KG5vZGUsIHBvc2l0aW9uLCBsZXZlbCkge1xuICAgICAgICB2YXIgZG9Ob3RVcGRhdGUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDMgfHwgYXJndW1lbnRzWzNdID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1szXTtcblxuICAgICAgICAvL2NvbnNvbGUubG9nKCdfc2V0UG9zaXRpb25Gb3JIaWVyYXJjaHknLG5vZGUuaWQsIHBvc2l0aW9uKVxuICAgICAgICBpZiAoZG9Ob3RVcGRhdGUgIT09IHRydWUpIHtcbiAgICAgICAgICBpZiAodGhpcy5kaXN0cmlidXRpb25PcmRlcmluZ1tsZXZlbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5kaXN0cmlidXRpb25PcmRlcmluZ1tsZXZlbF0gPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZGlzdHJpYnV0aW9uT3JkZXJpbmdQcmVzZW5jZVtsZXZlbF0gPSB7fTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5kaXN0cmlidXRpb25PcmRlcmluZ1ByZXNlbmNlW2xldmVsXVtub2RlLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3RyaWJ1dGlvbk9yZGVyaW5nW2xldmVsXS5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5kaXN0cmlidXRpb25JbmRleFtub2RlLmlkXSA9IHRoaXMuZGlzdHJpYnV0aW9uT3JkZXJpbmdbbGV2ZWxdLmxlbmd0aCAtIDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZGlzdHJpYnV0aW9uT3JkZXJpbmdQcmVzZW5jZVtsZXZlbF1bbm9kZS5pZF0gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZGlyZWN0aW9uID09PSAnVUQnIHx8IHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZGlyZWN0aW9uID09PSAnRFUnKSB7XG4gICAgICAgICAgbm9kZS54ID0gcG9zaXRpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS55ID0gcG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBYnN0cmFjdCB0aGUgZ2V0dGluZyBvZiB0aGUgcG9zaXRpb24gb2YgYSBub2RlIHNvIHdlIGRvIG5vdCBoYXZlIHRvIHJlcGVhdCB0aGUgZGlyZWN0aW9uIGNoZWNrIGFsbCB0aGUgdGltZS5cbiAgICAgICAqIEBwYXJhbSBub2RlXG4gICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfCp9XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZ2V0UG9zaXRpb25Gb3JIaWVyYXJjaHknLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRQb3NpdGlvbkZvckhpZXJhcmNoeShub2RlKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmRpcmVjdGlvbiA9PT0gJ1VEJyB8fCB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmRpcmVjdGlvbiA9PT0gJ0RVJykge1xuICAgICAgICAgIHJldHVybiBub2RlLng7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUueTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZSB0aGUgeCBvciB5IHZhbHVlIHRvIHNvcnQgdGhlIGFycmF5LCBhbGxvd2luZyB1c2VycyB0byBzcGVjaWZ5IG9yZGVyLlxuICAgICAgICogQHBhcmFtIG5vZGVBcnJheVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3NvcnROb2RlQXJyYXknLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zb3J0Tm9kZUFycmF5KG5vZGVBcnJheSkge1xuICAgICAgICBpZiAobm9kZUFycmF5Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5kaXJlY3Rpb24gPT09ICdVRCcgfHwgdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5kaXJlY3Rpb24gPT09ICdEVScpIHtcbiAgICAgICAgICAgIG5vZGVBcnJheS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhLnggLSBiLng7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZUFycmF5LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGEueSAtIGIueTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBMYXlvdXRFbmdpbmU7XG4gIH0oKTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBMYXlvdXRFbmdpbmU7XG5cbi8qKiovIH0sXG4vKiAxMTMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgdmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuICB2YXIgSGFtbWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG4gIHZhciBoYW1tZXJVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG5cbiAgLyoqXG4gICAqIGNsZWFycyB0aGUgdG9vbGJhciBkaXYgZWxlbWVudCBvZiBjaGlsZHJlblxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB2YXIgTWFuaXB1bGF0aW9uU3lzdGVtID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hbmlwdWxhdGlvblN5c3RlbShib2R5LCBjYW52YXMsIHNlbGVjdGlvbkhhbmRsZXIpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYW5pcHVsYXRpb25TeXN0ZW0pO1xuXG4gICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIgPSBzZWxlY3Rpb25IYW5kbGVyO1xuXG4gICAgICB0aGlzLmVkaXRNb2RlID0gZmFsc2U7XG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdiA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZWRpdE1vZGVEaXYgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmNsb3NlRGl2ID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkhhbW1lcnMgPSBbXTtcbiAgICAgIHRoaXMudGVtcG9yYXJ5VUlGdW5jdGlvbnMgPSB7fTtcbiAgICAgIHRoaXMudGVtcG9yYXJ5RXZlbnRGdW5jdGlvbnMgPSBbXTtcblxuICAgICAgdGhpcy50b3VjaFRpbWUgPSAwO1xuICAgICAgdGhpcy50ZW1wb3JhcnlJZHMgPSB7IG5vZGVzOiBbXSwgZWRnZXM6IFtdIH07XG4gICAgICB0aGlzLmd1aUVuYWJsZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuaW5Nb2RlID0gZmFsc2U7XG4gICAgICB0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGluaXRpYWxseUFjdGl2ZTogZmFsc2UsXG4gICAgICAgIGFkZE5vZGU6IHRydWUsXG4gICAgICAgIGFkZEVkZ2U6IHRydWUsXG4gICAgICAgIGVkaXROb2RlOiB1bmRlZmluZWQsXG4gICAgICAgIGVkaXRFZGdlOiB0cnVlLFxuICAgICAgICBkZWxldGVOb2RlOiB0cnVlLFxuICAgICAgICBkZWxldGVFZGdlOiB0cnVlLFxuICAgICAgICBjb250cm9sTm9kZVN0eWxlOiB7XG4gICAgICAgICAgc2hhcGU6ICdkb3QnLFxuICAgICAgICAgIHNpemU6IDYsXG4gICAgICAgICAgY29sb3I6IHsgYmFja2dyb3VuZDogJyNmZjAwMDAnLCBib3JkZXI6ICcjM2MzYzNjJywgaGlnaGxpZ2h0OiB7IGJhY2tncm91bmQ6ICcjMDdmOTY4JywgYm9yZGVyOiAnIzNjM2MzYycgfSB9LFxuICAgICAgICAgIGJvcmRlcldpZHRoOiAyLFxuICAgICAgICAgIGJvcmRlcldpZHRoU2VsZWN0ZWQ6IDJcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHV0aWwuZXh0ZW5kKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5fY2xlYW4oKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ19kYXRhQ2hhbmdlZCcsIHRoaXMuX3Jlc3RvcmUuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignX3Jlc2V0RGF0YScsIHRoaXMuX3Jlc3RvcmUuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgc29tZXRoaW5nIGNoYW5nZXMgaW4gdGhlIGRhdGEgZHVyaW5nIGVkaXRpbmcsIHN3aXRjaCBiYWNrIHRvIHRoZSBpbml0aWFsIGRhdGFtYW5pcHVsYXRpb24gc3RhdGUgYW5kIGNsb3NlIGFsbCBlZGl0IG1vZGVzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhNYW5pcHVsYXRpb25TeXN0ZW0sIFt7XG4gICAgICBrZXk6ICdfcmVzdG9yZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc3RvcmUoKSB7XG4gICAgICAgIGlmICh0aGlzLmluTW9kZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmluaXRpYWxseUFjdGl2ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRpc2FibGVFZGl0TW9kZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNldCB0aGUgT3B0aW9uc1xuICAgICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc2V0T3B0aW9ucycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zLCBhbGxPcHRpb25zLCBnbG9iYWxPcHRpb25zKSB7XG4gICAgICAgIGlmIChhbGxPcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoYWxsT3B0aW9ucy5sb2NhbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmxvY2FsZSA9IGFsbE9wdGlvbnMubG9jYWxlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMubG9jYWxlID0gZ2xvYmFsT3B0aW9ucy5sb2NhbGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhbGxPcHRpb25zLmxvY2FsZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmxvY2FsZXMgPSBhbGxPcHRpb25zLmxvY2FsZXM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5sb2NhbGVzID0gZ2xvYmFsT3B0aW9ucy5sb2NhbGVzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmVuYWJsZWQgPSBvcHRpb25zO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICB1dGlsLmRlZXBFeHRlbmQodGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbml0aWFsbHlBY3RpdmUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdE1vZGUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9zZXR1cCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRW5hYmxlIG9yIGRpc2FibGUgZWRpdC1tb2RlLiBEcmF3cyB0aGUgRE9NIHJlcXVpcmVkIGFuZCBjbGVhbnMgdXAgYWZ0ZXIgaXRzZWxmLlxuICAgICAgICpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3RvZ2dsZUVkaXRNb2RlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGVFZGl0TW9kZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZWRpdE1vZGUgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmRpc2FibGVFZGl0TW9kZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2VuYWJsZUVkaXRNb2RlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGVFZGl0TW9kZSgpIHtcbiAgICAgICAgdGhpcy5lZGl0TW9kZSA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5fY2xlYW4oKTtcbiAgICAgICAgaWYgKHRoaXMuZ3VpRW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgIHRoaXMuY2xvc2VEaXYuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgdGhpcy5lZGl0TW9kZURpdi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgIHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZGlzYWJsZUVkaXRNb2RlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlRWRpdE1vZGUoKSB7XG4gICAgICAgIHRoaXMuZWRpdE1vZGUgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl9jbGVhbigpO1xuICAgICAgICBpZiAodGhpcy5ndWlFbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICB0aGlzLmNsb3NlRGl2LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgdGhpcy5lZGl0TW9kZURpdi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICB0aGlzLl9jcmVhdGVFZGl0QnV0dG9uKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIHRoZSBtYWluIHRvb2xiYXIuIFJlbW92ZXMgZnVuY3Rpb25zIGJvdW5kIHRvIHRoZSBzZWxlY3QgZXZlbnQuIEJpbmRzIGFsbCB0aGUgYnV0dG9ucyBvZiB0aGUgdG9vbGJhci5cbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzaG93TWFuaXB1bGF0b3JUb29sYmFyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93TWFuaXB1bGF0b3JUb29sYmFyKCkge1xuICAgICAgICAvLyByZXN0b3JlIHRoZSBzdGF0ZSBvZiBhbnkgYm91bmQgZnVuY3Rpb25zIG9yIGV2ZW50cywgcmVtb3ZlIGNvbnRyb2wgbm9kZXMsIHJlc3RvcmUgcGh5c2ljc1xuICAgICAgICB0aGlzLl9jbGVhbigpO1xuXG4gICAgICAgIC8vIHJlc2V0IGdsb2JhbCB2YXJpYWJsZXNcbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET00gPSB7fTtcblxuICAgICAgICAvLyBpZiB0aGUgZ3VpIGlzIGVuYWJsZWQsIGRyYXcgYWxsIGVsZW1lbnRzLlxuICAgICAgICBpZiAodGhpcy5ndWlFbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgLy8gYSBfcmVzdG9yZSB3aWxsIGhpZGUgdGhlc2UgbWVudXNcbiAgICAgICAgICB0aGlzLmVkaXRNb2RlID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICB0aGlzLmNsb3NlRGl2LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXG4gICAgICAgICAgdmFyIHNlbGVjdGVkTm9kZUNvdW50ID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZXRTZWxlY3RlZE5vZGVDb3VudCgpO1xuICAgICAgICAgIHZhciBzZWxlY3RlZEVkZ2VDb3VudCA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2V0U2VsZWN0ZWRFZGdlQ291bnQoKTtcbiAgICAgICAgICB2YXIgc2VsZWN0ZWRUb3RhbENvdW50ID0gc2VsZWN0ZWROb2RlQ291bnQgKyBzZWxlY3RlZEVkZ2VDb3VudDtcbiAgICAgICAgICB2YXIgbG9jYWxlID0gdGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV07XG4gICAgICAgICAgdmFyIG5lZWRTZXBlcmF0b3IgPSBmYWxzZTtcblxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWRkTm9kZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUFkZE5vZGVCdXR0b24obG9jYWxlKTtcbiAgICAgICAgICAgIG5lZWRTZXBlcmF0b3IgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFkZEVkZ2UgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAobmVlZFNlcGVyYXRvciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVTZXBlcmF0b3IoMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZWVkU2VwZXJhdG9yID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUFkZEVkZ2VCdXR0b24obG9jYWxlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VsZWN0ZWROb2RlQ291bnQgPT09IDEgJiYgdHlwZW9mIHRoaXMub3B0aW9ucy5lZGl0Tm9kZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaWYgKG5lZWRTZXBlcmF0b3IgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlU2VwZXJhdG9yKDIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmVlZFNlcGVyYXRvciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVFZGl0Tm9kZUJ1dHRvbihsb2NhbGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0ZWRFZGdlQ291bnQgPT09IDEgJiYgc2VsZWN0ZWROb2RlQ291bnQgPT09IDAgJiYgdGhpcy5vcHRpb25zLmVkaXRFZGdlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKG5lZWRTZXBlcmF0b3IgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlU2VwZXJhdG9yKDMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmVlZFNlcGVyYXRvciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVFZGl0RWRnZUJ1dHRvbihsb2NhbGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHJlbW92ZSBidXR0b25zXG4gICAgICAgICAgaWYgKHNlbGVjdGVkVG90YWxDb3VudCAhPT0gMCkge1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkTm9kZUNvdW50ID4gMCAmJiB0aGlzLm9wdGlvbnMuZGVsZXRlTm9kZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgaWYgKG5lZWRTZXBlcmF0b3IgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVTZXBlcmF0b3IoNCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlRGVsZXRlQnV0dG9uKGxvY2FsZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlbGVjdGVkTm9kZUNvdW50ID09PSAwICYmIHRoaXMub3B0aW9ucy5kZWxldGVFZGdlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICBpZiAobmVlZFNlcGVyYXRvciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVNlcGVyYXRvcig0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVEZWxldGVCdXR0b24obG9jYWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBiaW5kIHRoZSBjbG9zZSBidXR0b25cbiAgICAgICAgICB0aGlzLl9iaW5kSGFtbWVyVG9EaXYodGhpcy5jbG9zZURpdiwgdGhpcy50b2dnbGVFZGl0TW9kZS5iaW5kKHRoaXMpKTtcblxuICAgICAgICAgIC8vIHJlZnJlc2ggdGhpcyBiYXIgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiBzZWxlY3RlZFxuICAgICAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRFdmVudCgnc2VsZWN0JywgdGhpcy5zaG93TWFuaXB1bGF0b3JUb29sYmFyLmJpbmQodGhpcykpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVkcmF3IHRvIHNob3cgYW55IHBvc3NpYmxlIGNoYW5nZXNcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX3JlZHJhdycpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZSB0aGUgdG9vbGJhciBmb3IgYWRkaW5nIE5vZGVzXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2FkZE5vZGVNb2RlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGROb2RlTW9kZSgpIHtcbiAgICAgICAgLy8gd2hlbiB1c2luZyB0aGUgZ3VpLCBlbmFibGUgZWRpdCBtb2RlIGlmIGl0IHdhc250IGFscmVhZHkuXG4gICAgICAgIGlmICh0aGlzLmVkaXRNb2RlICE9PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVzdG9yZSB0aGUgc3RhdGUgb2YgYW55IGJvdW5kIGZ1bmN0aW9ucyBvciBldmVudHMsIHJlbW92ZSBjb250cm9sIG5vZGVzLCByZXN0b3JlIHBoeXNpY3NcbiAgICAgICAgdGhpcy5fY2xlYW4oKTtcblxuICAgICAgICB0aGlzLmluTW9kZSA9ICdhZGROb2RlJztcbiAgICAgICAgaWYgKHRoaXMuZ3VpRW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBsb2NhbGUgPSB0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXTtcbiAgICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTSA9IHt9O1xuICAgICAgICAgIHRoaXMuX2NyZWF0ZUJhY2tCdXR0b24obG9jYWxlKTtcbiAgICAgICAgICB0aGlzLl9jcmVhdGVTZXBlcmF0b3IoKTtcbiAgICAgICAgICB0aGlzLl9jcmVhdGVEZXNjcmlwdGlvbihsb2NhbGVbJ2FkZERlc2NyaXB0aW9uJ10gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbJ2VuJ11bJ2FkZERlc2NyaXB0aW9uJ10pO1xuXG4gICAgICAgICAgLy8gYmluZCB0aGUgY2xvc2UgYnV0dG9uXG4gICAgICAgICAgdGhpcy5fYmluZEhhbW1lclRvRGl2KHRoaXMuY2xvc2VEaXYsIHRoaXMudG9nZ2xlRWRpdE1vZGUuYmluZCh0aGlzKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kRXZlbnQoJ2NsaWNrJywgdGhpcy5fcGVyZm9ybUFkZE5vZGUuYmluZCh0aGlzKSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogY2FsbCB0aGUgYm91bmQgZnVuY3Rpb24gdG8gaGFuZGxlIHRoZSBlZGl0aW5nIG9mIHRoZSBub2RlLiBUaGUgbm9kZSBoYXMgdG8gYmUgc2VsZWN0ZWQuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2VkaXROb2RlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBlZGl0Tm9kZSgpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgLy8gd2hlbiB1c2luZyB0aGUgZ3VpLCBlbmFibGUgZWRpdCBtb2RlIGlmIGl0IHdhc250IGFscmVhZHkuXG4gICAgICAgIGlmICh0aGlzLmVkaXRNb2RlICE9PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVzdG9yZSB0aGUgc3RhdGUgb2YgYW55IGJvdW5kIGZ1bmN0aW9ucyBvciBldmVudHMsIHJlbW92ZSBjb250cm9sIG5vZGVzLCByZXN0b3JlIHBoeXNpY3NcbiAgICAgICAgdGhpcy5fY2xlYW4oKTtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dldFNlbGVjdGVkTm9kZSgpO1xuICAgICAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5pbk1vZGUgPSAnZWRpdE5vZGUnO1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmVkaXROb2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5pc0NsdXN0ZXIgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgdmFyIGRhdGEgPSB1dGlsLmRlZXBFeHRlbmQoe30sIG5vZGUub3B0aW9ucywgZmFsc2UpO1xuICAgICAgICAgICAgICBkYXRhLnggPSBub2RlLng7XG4gICAgICAgICAgICAgIGRhdGEueSA9IG5vZGUueTtcblxuICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVkaXROb2RlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lZGl0Tm9kZShkYXRhLCBmdW5jdGlvbiAoZmluYWxpemVkRGF0YSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGZpbmFsaXplZERhdGEgIT09IG51bGwgJiYgZmluYWxpemVkRGF0YSAhPT0gdW5kZWZpbmVkICYmIF90aGlzMi5pbk1vZGUgPT09ICdlZGl0Tm9kZScpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgZm9yIHdoYXRldmVyIHJlYXNvbiB0aGUgbW9kZSBoYXMgY2hhbmdlcyAoZHVlIHRvIGRhdGFzZXQgY2hhbmdlKSBkaXNyZWdhcmQgdGhlIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzMi5ib2R5LmRhdGEubm9kZXMuZ2V0RGF0YVNldCgpLnVwZGF0ZShmaW5hbGl6ZWREYXRhKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIF90aGlzMi5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZnVuY3Rpb24gZm9yIGVkaXQgZG9lcyBub3Qgc3VwcG9ydCB0d28gYXJndW1lbnRzIChkYXRhLCBjYWxsYmFjayknKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYWxlcnQodGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV1bJ2VkaXRDbHVzdGVyRXJyb3InXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1snZW4nXVsnZWRpdENsdXN0ZXJFcnJvciddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBmdW5jdGlvbiBoYXMgYmVlbiBjb25maWd1cmVkIHRvIGhhbmRsZSB0aGUgZWRpdGluZyBvZiBub2Rlcy4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBjcmVhdGUgdGhlIHRvb2xiYXIgdG8gY29ubmVjdCBub2Rlc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdhZGRFZGdlTW9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRWRnZU1vZGUoKSB7XG4gICAgICAgIC8vIHdoZW4gdXNpbmcgdGhlIGd1aSwgZW5hYmxlIGVkaXQgbW9kZSBpZiBpdCB3YXNudCBhbHJlYWR5LlxuICAgICAgICBpZiAodGhpcy5lZGl0TW9kZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlc3RvcmUgdGhlIHN0YXRlIG9mIGFueSBib3VuZCBmdW5jdGlvbnMgb3IgZXZlbnRzLCByZW1vdmUgY29udHJvbCBub2RlcywgcmVzdG9yZSBwaHlzaWNzXG4gICAgICAgIHRoaXMuX2NsZWFuKCk7XG5cbiAgICAgICAgdGhpcy5pbk1vZGUgPSAnYWRkRWRnZSc7XG4gICAgICAgIGlmICh0aGlzLmd1aUVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICB2YXIgbG9jYWxlID0gdGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV07XG4gICAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET00gPSB7fTtcbiAgICAgICAgICB0aGlzLl9jcmVhdGVCYWNrQnV0dG9uKGxvY2FsZSk7XG4gICAgICAgICAgdGhpcy5fY3JlYXRlU2VwZXJhdG9yKCk7XG4gICAgICAgICAgdGhpcy5fY3JlYXRlRGVzY3JpcHRpb24obG9jYWxlWydlZGdlRGVzY3JpcHRpb24nXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1snZW4nXVsnZWRnZURlc2NyaXB0aW9uJ10pO1xuXG4gICAgICAgICAgLy8gYmluZCB0aGUgY2xvc2UgYnV0dG9uXG4gICAgICAgICAgdGhpcy5fYmluZEhhbW1lclRvRGl2KHRoaXMuY2xvc2VEaXYsIHRoaXMudG9nZ2xlRWRpdE1vZGUuYmluZCh0aGlzKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0ZW1wb3JhcmlseSBvdmVybG9hZCBmdW5jdGlvbnNcbiAgICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZFVJKCdvblRvdWNoJywgdGhpcy5faGFuZGxlQ29ubmVjdC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZFVJKCdvbkRyYWdFbmQnLCB0aGlzLl9maW5pc2hDb25uZWN0LmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kVUkoJ29uRHJhZycsIHRoaXMuX2RyYWdDb250cm9sTm9kZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZFVJKCdvblJlbGVhc2UnLCB0aGlzLl9maW5pc2hDb25uZWN0LmJpbmQodGhpcykpO1xuXG4gICAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSSgnb25EcmFnU3RhcnQnLCBmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSSgnb25Ib2xkJywgZnVuY3Rpb24gKCkge30pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGNyZWF0ZSB0aGUgdG9vbGJhciB0byBlZGl0IGVkZ2VzXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2VkaXRFZGdlTW9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZWRpdEVkZ2VNb2RlKCkge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICAvLyB3aGVuIHVzaW5nIHRoZSBndWksIGVuYWJsZSBlZGl0IG1vZGUgaWYgaXQgd2Fzbid0IGFscmVhZHkuXG4gICAgICAgIGlmICh0aGlzLmVkaXRNb2RlICE9PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVzdG9yZSB0aGUgc3RhdGUgb2YgYW55IGJvdW5kIGZ1bmN0aW9ucyBvciBldmVudHMsIHJlbW92ZSBjb250cm9sIG5vZGVzLCByZXN0b3JlIHBoeXNpY3NcbiAgICAgICAgdGhpcy5fY2xlYW4oKTtcblxuICAgICAgICB0aGlzLmluTW9kZSA9ICdlZGl0RWRnZSc7XG4gICAgICAgIGlmICh0aGlzLmd1aUVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICB2YXIgbG9jYWxlID0gdGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV07XG4gICAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET00gPSB7fTtcbiAgICAgICAgICB0aGlzLl9jcmVhdGVCYWNrQnV0dG9uKGxvY2FsZSk7XG4gICAgICAgICAgdGhpcy5fY3JlYXRlU2VwZXJhdG9yKCk7XG4gICAgICAgICAgdGhpcy5fY3JlYXRlRGVzY3JpcHRpb24obG9jYWxlWydlZGl0RWRnZURlc2NyaXB0aW9uJ10gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbJ2VuJ11bJ2VkaXRFZGdlRGVzY3JpcHRpb24nXSk7XG5cbiAgICAgICAgICAvLyBiaW5kIHRoZSBjbG9zZSBidXR0b25cbiAgICAgICAgICB0aGlzLl9iaW5kSGFtbWVyVG9EaXYodGhpcy5jbG9zZURpdiwgdGhpcy50b2dnbGVFZGl0TW9kZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZWRnZUJlaW5nRWRpdGVkSWQgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0ZWRFZGdlcygpWzBdO1xuICAgICAgICBpZiAodGhpcy5lZGdlQmVpbmdFZGl0ZWRJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlZGdlID0gX3RoaXMzLmJvZHkuZWRnZXNbX3RoaXMzLmVkZ2VCZWluZ0VkaXRlZElkXTtcblxuICAgICAgICAgICAgLy8gY3JlYXRlIGNvbnRyb2wgbm9kZXNcbiAgICAgICAgICAgIHZhciBjb250cm9sTm9kZUZyb20gPSBfdGhpczMuX2dldE5ld1RhcmdldE5vZGUoZWRnZS5mcm9tLngsIGVkZ2UuZnJvbS55KTtcbiAgICAgICAgICAgIHZhciBjb250cm9sTm9kZVRvID0gX3RoaXMzLl9nZXROZXdUYXJnZXROb2RlKGVkZ2UudG8ueCwgZWRnZS50by55KTtcblxuICAgICAgICAgICAgX3RoaXMzLnRlbXBvcmFyeUlkcy5ub2Rlcy5wdXNoKGNvbnRyb2xOb2RlRnJvbS5pZCk7XG4gICAgICAgICAgICBfdGhpczMudGVtcG9yYXJ5SWRzLm5vZGVzLnB1c2goY29udHJvbE5vZGVUby5pZCk7XG5cbiAgICAgICAgICAgIF90aGlzMy5ib2R5Lm5vZGVzW2NvbnRyb2xOb2RlRnJvbS5pZF0gPSBjb250cm9sTm9kZUZyb207XG4gICAgICAgICAgICBfdGhpczMuYm9keS5ub2RlSW5kaWNlcy5wdXNoKGNvbnRyb2xOb2RlRnJvbS5pZCk7XG4gICAgICAgICAgICBfdGhpczMuYm9keS5ub2Rlc1tjb250cm9sTm9kZVRvLmlkXSA9IGNvbnRyb2xOb2RlVG87XG4gICAgICAgICAgICBfdGhpczMuYm9keS5ub2RlSW5kaWNlcy5wdXNoKGNvbnRyb2xOb2RlVG8uaWQpO1xuXG4gICAgICAgICAgICAvLyB0ZW1wb3JhcmlseSBvdmVybG9hZCBVSSBmdW5jdGlvbnMsIGNsZWFuZWQgdXAgYXV0b21hdGljYWxseSBiZWNhdXNlIG9mIF90ZW1wb3JhcnlCaW5kVUlcbiAgICAgICAgICAgIF90aGlzMy5fdGVtcG9yYXJ5QmluZFVJKCdvblRvdWNoJywgX3RoaXMzLl9jb250cm9sTm9kZVRvdWNoLmJpbmQoX3RoaXMzKSk7IC8vIHVzZWQgdG8gZ2V0IHRoZSBwb3NpdGlvblxuICAgICAgICAgICAgX3RoaXMzLl90ZW1wb3JhcnlCaW5kVUkoJ29uVGFwJywgZnVuY3Rpb24gKCkge30pOyAvLyBkaXNhYmxlZFxuICAgICAgICAgICAgX3RoaXMzLl90ZW1wb3JhcnlCaW5kVUkoJ29uSG9sZCcsIGZ1bmN0aW9uICgpIHt9KTsgLy8gZGlzYWJsZWRcbiAgICAgICAgICAgIF90aGlzMy5fdGVtcG9yYXJ5QmluZFVJKCdvbkRyYWdTdGFydCcsIF90aGlzMy5fY29udHJvbE5vZGVEcmFnU3RhcnQuYmluZChfdGhpczMpKTsgLy8gdXNlZCB0byBzZWxlY3QgY29udHJvbCBub2RlXG4gICAgICAgICAgICBfdGhpczMuX3RlbXBvcmFyeUJpbmRVSSgnb25EcmFnJywgX3RoaXMzLl9jb250cm9sTm9kZURyYWcuYmluZChfdGhpczMpKTsgLy8gdXNlZCB0byBkcmFnIGNvbnRyb2wgbm9kZVxuICAgICAgICAgICAgX3RoaXMzLl90ZW1wb3JhcnlCaW5kVUkoJ29uRHJhZ0VuZCcsIF90aGlzMy5fY29udHJvbE5vZGVEcmFnRW5kLmJpbmQoX3RoaXMzKSk7IC8vIHVzZWQgdG8gY29ubmVjdCBvciByZXZlcnQgY29udHJvbCBub2Rlc1xuICAgICAgICAgICAgX3RoaXMzLl90ZW1wb3JhcnlCaW5kVUkoJ29uTW91c2VNb3ZlJywgZnVuY3Rpb24gKCkge30pOyAvLyBkaXNhYmxlZFxuXG4gICAgICAgICAgICAvLyBjcmVhdGUgZnVuY3Rpb24gdG8gcG9zaXRpb24gY29udHJvbCBub2RlcyBjb3JyZWN0bHkgb24gbW92ZW1lbnRcbiAgICAgICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgY2xlYW5lZCB1cCBiZWNhdXNlIHdlIHVzZSB0aGUgdGVtcG9yYXJ5IGJpbmRcbiAgICAgICAgICAgIF90aGlzMy5fdGVtcG9yYXJ5QmluZEV2ZW50KCdiZWZvcmVEcmF3aW5nJywgZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgICB2YXIgcG9zaXRpb25zID0gZWRnZS5lZGdlVHlwZS5maW5kQm9yZGVyUG9zaXRpb25zKGN0eCk7XG4gICAgICAgICAgICAgIGlmIChjb250cm9sTm9kZUZyb20uc2VsZWN0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbE5vZGVGcm9tLnggPSBwb3NpdGlvbnMuZnJvbS54O1xuICAgICAgICAgICAgICAgIGNvbnRyb2xOb2RlRnJvbS55ID0gcG9zaXRpb25zLmZyb20ueTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY29udHJvbE5vZGVUby5zZWxlY3RlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sTm9kZVRvLnggPSBwb3NpdGlvbnMudG8ueDtcbiAgICAgICAgICAgICAgICBjb250cm9sTm9kZVRvLnkgPSBwb3NpdGlvbnMudG8ueTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIF90aGlzMy5ib2R5LmVtaXR0ZXIuZW1pdCgnX3JlZHJhdycpO1xuICAgICAgICAgIH0pKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBkZWxldGUgZXZlcnl0aGluZyBpbiB0aGUgc2VsZWN0aW9uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2RlbGV0ZVNlbGVjdGVkJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVTZWxlY3RlZCgpIHtcbiAgICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgICAgLy8gd2hlbiB1c2luZyB0aGUgZ3VpLCBlbmFibGUgZWRpdCBtb2RlIGlmIGl0IHdhc250IGFscmVhZHkuXG4gICAgICAgIGlmICh0aGlzLmVkaXRNb2RlICE9PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVzdG9yZSB0aGUgc3RhdGUgb2YgYW55IGJvdW5kIGZ1bmN0aW9ucyBvciBldmVudHMsIHJlbW92ZSBjb250cm9sIG5vZGVzLCByZXN0b3JlIHBoeXNpY3NcbiAgICAgICAgdGhpcy5fY2xlYW4oKTtcblxuICAgICAgICB0aGlzLmluTW9kZSA9ICdkZWxldGUnO1xuICAgICAgICB2YXIgc2VsZWN0ZWROb2RlcyA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRTZWxlY3RlZE5vZGVzKCk7XG4gICAgICAgIHZhciBzZWxlY3RlZEVkZ2VzID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldFNlbGVjdGVkRWRnZXMoKTtcbiAgICAgICAgdmFyIGRlbGV0ZUZ1bmN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoc2VsZWN0ZWROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW3NlbGVjdGVkTm9kZXNbaV1dLmlzQ2x1c3RlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICBhbGVydCh0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXVsnZGVsZXRlQ2x1c3RlckVycm9yJ10gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbJ2VuJ11bJ2RlbGV0ZUNsdXN0ZXJFcnJvciddKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmRlbGV0ZU5vZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGRlbGV0ZUZ1bmN0aW9uID0gdGhpcy5vcHRpb25zLmRlbGV0ZU5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNlbGVjdGVkRWRnZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmRlbGV0ZUVkZ2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGRlbGV0ZUZ1bmN0aW9uID0gdGhpcy5vcHRpb25zLmRlbGV0ZUVkZ2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkZWxldGVGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciBkYXRhID0geyBub2Rlczogc2VsZWN0ZWROb2RlcywgZWRnZXM6IHNlbGVjdGVkRWRnZXMgfTtcbiAgICAgICAgICBpZiAoZGVsZXRlRnVuY3Rpb24ubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBkZWxldGVGdW5jdGlvbihkYXRhLCBmdW5jdGlvbiAoZmluYWxpemVkRGF0YSkge1xuICAgICAgICAgICAgICBpZiAoZmluYWxpemVkRGF0YSAhPT0gbnVsbCAmJiBmaW5hbGl6ZWREYXRhICE9PSB1bmRlZmluZWQgJiYgX3RoaXM0LmluTW9kZSA9PT0gJ2RlbGV0ZScpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBmb3Igd2hhdGV2ZXIgcmVhc29uIHRoZSBtb2RlIGhhcyBjaGFuZ2VzIChkdWUgdG8gZGF0YXNldCBjaGFuZ2UpIGRpc3JlZ2FyZCB0aGUgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBfdGhpczQuYm9keS5kYXRhLmVkZ2VzLmdldERhdGFTZXQoKS5yZW1vdmUoZmluYWxpemVkRGF0YS5lZGdlcyk7XG4gICAgICAgICAgICAgICAgX3RoaXM0LmJvZHkuZGF0YS5ub2Rlcy5nZXREYXRhU2V0KCkucmVtb3ZlKGZpbmFsaXplZERhdGEubm9kZXMpO1xuICAgICAgICAgICAgICAgIF90aGlzNC5ib2R5LmVtaXR0ZXIuZW1pdCgnc3RhcnRTaW11bGF0aW9uJyk7XG4gICAgICAgICAgICAgICAgX3RoaXM0LnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpczQuYm9keS5lbWl0dGVyLmVtaXQoJ3N0YXJ0U2ltdWxhdGlvbicpO1xuICAgICAgICAgICAgICAgIF90aGlzNC5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBmdW5jdGlvbiBmb3IgZGVsZXRlIGRvZXMgbm90IHN1cHBvcnQgdHdvIGFyZ3VtZW50cyAoZGF0YSwgY2FsbGJhY2spJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYm9keS5kYXRhLmVkZ2VzLmdldERhdGFTZXQoKS5yZW1vdmUoc2VsZWN0ZWRFZGdlcyk7XG4gICAgICAgICAgdGhpcy5ib2R5LmRhdGEubm9kZXMuZ2V0RGF0YVNldCgpLnJlbW92ZShzZWxlY3RlZE5vZGVzKTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdzdGFydFNpbXVsYXRpb24nKTtcbiAgICAgICAgICB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogUFJJVkFURSAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovL1xuXG4gICAgICAvKipcbiAgICAgICAqIGRyYXcgb3IgcmVtb3ZlIHRoZSBET01cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19zZXR1cCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAvLyBFbmFibGUgdGhlIEdVSVxuICAgICAgICAgIHRoaXMuZ3VpRW5hYmxlZCA9IHRydWU7XG5cbiAgICAgICAgICB0aGlzLl9jcmVhdGVXcmFwcGVycygpO1xuICAgICAgICAgIGlmICh0aGlzLmVkaXRNb2RlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlRWRpdEJ1dHRvbigpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fcmVtb3ZlTWFuaXB1bGF0aW9uRE9NKCk7XG5cbiAgICAgICAgICAvLyBkaXNhYmxlIHRoZSBndWlcbiAgICAgICAgICB0aGlzLmd1aUVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGNyZWF0ZSB0aGUgZGl2IG92ZXJsYXlzIHRoYXQgY29udGFpbiB0aGUgRE9NXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY3JlYXRlV3JhcHBlcnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVXcmFwcGVycygpIHtcbiAgICAgICAgLy8gbG9hZCB0aGUgbWFuaXB1bGF0b3IgSFRNTCBlbGVtZW50cy4gQWxsIHN0eWxpbmcgZG9uZSBpbiBjc3MuXG4gICAgICAgIGlmICh0aGlzLm1hbmlwdWxhdGlvbkRpdiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5jbGFzc05hbWUgPSAndmlzLW1hbmlwdWxhdGlvbic7XG4gICAgICAgICAgaWYgKHRoaXMuZWRpdE1vZGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmNhbnZhcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLm1hbmlwdWxhdGlvbkRpdik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb250YWluZXIgZm9yIHRoZSBlZGl0IGJ1dHRvbi5cbiAgICAgICAgaWYgKHRoaXMuZWRpdE1vZGVEaXYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuZWRpdE1vZGVEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICB0aGlzLmVkaXRNb2RlRGl2LmNsYXNzTmFtZSA9ICd2aXMtZWRpdC1tb2RlJztcbiAgICAgICAgICBpZiAodGhpcy5lZGl0TW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5lZGl0TW9kZURpdi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVkaXRNb2RlRGl2LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmNhbnZhcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmVkaXRNb2RlRGl2KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnRhaW5lciBmb3IgdGhlIGNsb3NlIGRpdiBidXR0b25cbiAgICAgICAgaWYgKHRoaXMuY2xvc2VEaXYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuY2xvc2VEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICB0aGlzLmNsb3NlRGl2LmNsYXNzTmFtZSA9ICd2aXMtY2xvc2UnO1xuICAgICAgICAgIHRoaXMuY2xvc2VEaXYuc3R5bGUuZGlzcGxheSA9IHRoaXMubWFuaXB1bGF0aW9uRGl2LnN0eWxlLmRpc3BsYXk7XG4gICAgICAgICAgdGhpcy5jYW52YXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5jbG9zZURpdik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBnZW5lcmF0ZSBhIG5ldyB0YXJnZXQgbm9kZS4gVXNlZCBmb3IgY3JlYXRpbmcgbmV3IGVkZ2VzIGFuZCBlZGl0aW5nIGVkZ2VzXG4gICAgICAgKiBAcGFyYW0geFxuICAgICAgICogQHBhcmFtIHlcbiAgICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2dldE5ld1RhcmdldE5vZGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXROZXdUYXJnZXROb2RlKHgsIHkpIHtcbiAgICAgICAgdmFyIGNvbnRyb2xOb2RlU3R5bGUgPSB1dGlsLmRlZXBFeHRlbmQoe30sIHRoaXMub3B0aW9ucy5jb250cm9sTm9kZVN0eWxlKTtcblxuICAgICAgICBjb250cm9sTm9kZVN0eWxlLmlkID0gJ3RhcmdldE5vZGUnICsgdXRpbC5yYW5kb21VVUlEKCk7XG4gICAgICAgIGNvbnRyb2xOb2RlU3R5bGUuaGlkZGVuID0gZmFsc2U7XG4gICAgICAgIGNvbnRyb2xOb2RlU3R5bGUucGh5c2ljcyA9IGZhbHNlO1xuICAgICAgICBjb250cm9sTm9kZVN0eWxlLnggPSB4O1xuICAgICAgICBjb250cm9sTm9kZVN0eWxlLnkgPSB5O1xuXG4gICAgICAgIC8vIHdlIGhhdmUgdG8gZGVmaW5lIHRoZSBib3VuZGluZyBib3ggaW4gb3JkZXIgZm9yIHRoZSBub2RlcyB0byBiZSBkcmF3biBpbW1lZGlhdGVseVxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5mdW5jdGlvbnMuY3JlYXRlTm9kZShjb250cm9sTm9kZVN0eWxlKTtcbiAgICAgICAgbm9kZS5zaGFwZS5ib3VuZGluZ0JveCA9IHsgbGVmdDogeCwgcmlnaHQ6IHgsIHRvcDogeSwgYm90dG9tOiB5IH07XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlIHRoZSBlZGl0IGJ1dHRvblxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY3JlYXRlRWRpdEJ1dHRvbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUVkaXRCdXR0b24oKSB7XG4gICAgICAgIC8vIHJlc3RvcmUgZXZlcnl0aGluZyB0byBpdCdzIG9yaWdpbmFsIHN0YXRlIChpZiBhcHBsaWNhYmxlKVxuICAgICAgICB0aGlzLl9jbGVhbigpO1xuXG4gICAgICAgIC8vIHJlc2V0IHRoZSBtYW5pcHVsYXRpb25ET01cbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET00gPSB7fTtcblxuICAgICAgICAvLyBlbXB0eSB0aGUgZWRpdE1vZGVEaXZcbiAgICAgICAgdXRpbC5yZWN1cnNpdmVET01EZWxldGUodGhpcy5lZGl0TW9kZURpdik7XG5cbiAgICAgICAgLy8gY3JlYXRlIHRoZSBjb250ZW50cyBmb3IgdGhlIGVkaXRNb2RlIGJ1dHRvblxuICAgICAgICB2YXIgbG9jYWxlID0gdGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV07XG4gICAgICAgIHZhciBidXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oJ2VkaXRNb2RlJywgJ3Zpcy1idXR0b24gdmlzLWVkaXQgdmlzLWVkaXQtbW9kZScsIGxvY2FsZVsnZWRpdCddIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzWydlbiddWydlZGl0J10pO1xuICAgICAgICB0aGlzLmVkaXRNb2RlRGl2LmFwcGVuZENoaWxkKGJ1dHRvbik7XG5cbiAgICAgICAgLy8gYmluZCBhIGhhbW1lciBsaXN0ZW5lciB0byB0aGUgYnV0dG9uLCBjYWxsaW5nIHRoZSBmdW5jdGlvbiB0b2dnbGVFZGl0TW9kZS5cbiAgICAgICAgdGhpcy5fYmluZEhhbW1lclRvRGl2KGJ1dHRvbiwgdGhpcy50b2dnbGVFZGl0TW9kZS5iaW5kKHRoaXMpKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiB0aGlzIGZ1bmN0aW9uIGNsZWFucyB1cCBhZnRlciBldmVyeXRoaW5nIHRoaXMgbW9kdWxlIGRvZXMuIFRlbXBvcmFyeSBlbGVtZW50cywgZnVuY3Rpb25zIGFuZCBldmVudHMgYXJlIHJlbW92ZWQsIHBoeXNpY3MgcmVzdG9yZWQsIGhhbW1lcnMgcmVtb3ZlZC5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19jbGVhbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NsZWFuKCkge1xuICAgICAgICAvLyBub3QgaW4gbW9kZVxuICAgICAgICB0aGlzLmluTW9kZSA9IGZhbHNlO1xuXG4gICAgICAgIC8vIF9jbGVhbiB0aGUgZGl2c1xuICAgICAgICBpZiAodGhpcy5ndWlFbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgdXRpbC5yZWN1cnNpdmVET01EZWxldGUodGhpcy5lZGl0TW9kZURpdik7XG4gICAgICAgICAgdXRpbC5yZWN1cnNpdmVET01EZWxldGUodGhpcy5tYW5pcHVsYXRpb25EaXYpO1xuXG4gICAgICAgICAgLy8gcmVtb3ZlcyBhbGwgdGhlIGJpbmRpbmdzIGFuZCBvdmVybG9hZHNcbiAgICAgICAgICB0aGlzLl9jbGVhbk1hbmlwdWxhdG9ySGFtbWVycygpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIHRlbXBvcmFyeSBub2RlcyBhbmQgZWRnZXNcbiAgICAgICAgdGhpcy5fY2xlYW51cFRlbXBvcmFyeU5vZGVzQW5kRWRnZXMoKTtcblxuICAgICAgICAvLyByZXN0b3JlIG92ZXJsb2FkZWQgVUkgZnVuY3Rpb25zXG4gICAgICAgIHRoaXMuX3VuYmluZFRlbXBvcmFyeVVJcygpO1xuXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgdGVtcG9yYXJ5RXZlbnRGdW5jdGlvbnNcbiAgICAgICAgdGhpcy5fdW5iaW5kVGVtcG9yYXJ5RXZlbnRzKCk7XG5cbiAgICAgICAgLy8gcmVzdG9yZSB0aGUgcGh5c2ljcyBpZiByZXF1aXJlZFxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdyZXN0b3JlUGh5c2ljcycpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEVhY2ggZG9tIGVsZW1lbnQgaGFzIGl0J3Mgb3duIGhhbW1lci4gVGhleSBhcmUgc3RvcmVkIGluIHRoaXMubWFuaXB1bGF0aW9uSGFtbWVycy4gVGhpcyBjbGVhbnMgdGhlbSB1cC5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19jbGVhbk1hbmlwdWxhdG9ySGFtbWVycycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NsZWFuTWFuaXB1bGF0b3JIYW1tZXJzKCkge1xuICAgICAgICAvLyBfY2xlYW4gaGFtbWVyIGJpbmRpbmdzXG4gICAgICAgIGlmICh0aGlzLm1hbmlwdWxhdGlvbkhhbW1lcnMubGVuZ3RoICE9IDApIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubWFuaXB1bGF0aW9uSGFtbWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25IYW1tZXJzW2ldLmRlc3Ryb3koKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25IYW1tZXJzID0gW107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmUgYWxsIERPTSBlbGVtZW50cyBjcmVhdGVkIGJ5IHRoaXMgbW9kdWxlLlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3JlbW92ZU1hbmlwdWxhdGlvbkRPTScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZU1hbmlwdWxhdGlvbkRPTSgpIHtcbiAgICAgICAgLy8gcmVtb3ZlcyBhbGwgdGhlIGJpbmRpbmdzIGFuZCBvdmVybG9hZHNcbiAgICAgICAgdGhpcy5fY2xlYW4oKTtcblxuICAgICAgICAvLyBlbXB0eSB0aGUgbWFuaXB1bGF0aW9uIGRpdnNcbiAgICAgICAgdXRpbC5yZWN1cnNpdmVET01EZWxldGUodGhpcy5tYW5pcHVsYXRpb25EaXYpO1xuICAgICAgICB1dGlsLnJlY3Vyc2l2ZURPTURlbGV0ZSh0aGlzLmVkaXRNb2RlRGl2KTtcbiAgICAgICAgdXRpbC5yZWN1cnNpdmVET01EZWxldGUodGhpcy5jbG9zZURpdik7XG5cbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBtYW5pcHVsYXRpb24gZGl2c1xuICAgICAgICBpZiAodGhpcy5tYW5pcHVsYXRpb25EaXYpIHtcbiAgICAgICAgICB0aGlzLmNhbnZhcy5mcmFtZS5yZW1vdmVDaGlsZCh0aGlzLm1hbmlwdWxhdGlvbkRpdik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZWRpdE1vZGVEaXYpIHtcbiAgICAgICAgICB0aGlzLmNhbnZhcy5mcmFtZS5yZW1vdmVDaGlsZCh0aGlzLmVkaXRNb2RlRGl2KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jbG9zZURpdikge1xuICAgICAgICAgIHRoaXMuY2FudmFzLmZyYW1lLnJlbW92ZUNoaWxkKHRoaXMuY2xvc2VEaXYpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHRoZSByZWZlcmVuY2VzIHRvIHVuZGVmaW5lZFxuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5lZGl0TW9kZURpdiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jbG9zZURpdiA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBjcmVhdGUgYSBzZXBlcmF0b3IgbGluZS4gdGhlIGluZGV4IGlzIHRvIGRpZmZlcmVudGlhdGUgaW4gdGhlIG1hbmlwdWxhdGlvbiBkb21cbiAgICAgICAqIEBwYXJhbSBpbmRleFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2NyZWF0ZVNlcGVyYXRvcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZVNlcGVyYXRvcigpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gMSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTVsnc2VwZXJhdG9yTGluZURpdicgKyBpbmRleF0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET01bJ3NlcGVyYXRvckxpbmVEaXYnICsgaW5kZXhdLmNsYXNzTmFtZSA9ICd2aXMtc2VwYXJhdG9yLWxpbmUnO1xuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5hcHBlbmRDaGlsZCh0aGlzLm1hbmlwdWxhdGlvbkRPTVsnc2VwZXJhdG9yTGluZURpdicgKyBpbmRleF0pO1xuICAgICAgfVxuXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tICAgIERPTSBmdW5jdGlvbnMgZm9yIGJ1dHRvbnMgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2NyZWF0ZUFkZE5vZGVCdXR0b24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVBZGROb2RlQnV0dG9uKGxvY2FsZSkge1xuICAgICAgICB2YXIgYnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKCdhZGROb2RlJywgJ3Zpcy1idXR0b24gdmlzLWFkZCcsIGxvY2FsZVsnYWRkTm9kZSddIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzWydlbiddWydhZGROb2RlJ10pO1xuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5hcHBlbmRDaGlsZChidXR0b24pO1xuICAgICAgICB0aGlzLl9iaW5kSGFtbWVyVG9EaXYoYnV0dG9uLCB0aGlzLmFkZE5vZGVNb2RlLmJpbmQodGhpcykpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19jcmVhdGVBZGRFZGdlQnV0dG9uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlQWRkRWRnZUJ1dHRvbihsb2NhbGUpIHtcbiAgICAgICAgdmFyIGJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbignYWRkRWRnZScsICd2aXMtYnV0dG9uIHZpcy1jb25uZWN0JywgbG9jYWxlWydhZGRFZGdlJ10gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbJ2VuJ11bJ2FkZEVkZ2UnXSk7XG4gICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gICAgICAgIHRoaXMuX2JpbmRIYW1tZXJUb0RpdihidXR0b24sIHRoaXMuYWRkRWRnZU1vZGUuYmluZCh0aGlzKSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2NyZWF0ZUVkaXROb2RlQnV0dG9uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlRWRpdE5vZGVCdXR0b24obG9jYWxlKSB7XG4gICAgICAgIHZhciBidXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oJ2VkaXROb2RlJywgJ3Zpcy1idXR0b24gdmlzLWVkaXQnLCBsb2NhbGVbJ2VkaXROb2RlJ10gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbJ2VuJ11bJ2VkaXROb2RlJ10pO1xuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5hcHBlbmRDaGlsZChidXR0b24pO1xuICAgICAgICB0aGlzLl9iaW5kSGFtbWVyVG9EaXYoYnV0dG9uLCB0aGlzLmVkaXROb2RlLmJpbmQodGhpcykpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19jcmVhdGVFZGl0RWRnZUJ1dHRvbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUVkaXRFZGdlQnV0dG9uKGxvY2FsZSkge1xuICAgICAgICB2YXIgYnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKCdlZGl0RWRnZScsICd2aXMtYnV0dG9uIHZpcy1lZGl0JywgbG9jYWxlWydlZGl0RWRnZSddIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzWydlbiddWydlZGl0RWRnZSddKTtcbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcbiAgICAgICAgdGhpcy5fYmluZEhhbW1lclRvRGl2KGJ1dHRvbiwgdGhpcy5lZGl0RWRnZU1vZGUuYmluZCh0aGlzKSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2NyZWF0ZURlbGV0ZUJ1dHRvbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZURlbGV0ZUJ1dHRvbihsb2NhbGUpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgICAgICB2YXIgZGVsZXRlQnRuQ2xhc3MgPSAndmlzLWJ1dHRvbiB2aXMtZGVsZXRlLXJ0bCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGRlbGV0ZUJ0bkNsYXNzID0gJ3Zpcy1idXR0b24gdmlzLWRlbGV0ZSc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbignZGVsZXRlJywgZGVsZXRlQnRuQ2xhc3MsIGxvY2FsZVsnZGVsJ10gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbJ2VuJ11bJ2RlbCddKTtcbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcbiAgICAgICAgdGhpcy5fYmluZEhhbW1lclRvRGl2KGJ1dHRvbiwgdGhpcy5kZWxldGVTZWxlY3RlZC5iaW5kKHRoaXMpKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY3JlYXRlQmFja0J1dHRvbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUJhY2tCdXR0b24obG9jYWxlKSB7XG4gICAgICAgIHZhciBidXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oJ2JhY2snLCAndmlzLWJ1dHRvbiB2aXMtYmFjaycsIGxvY2FsZVsnYmFjayddIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzWydlbiddWydiYWNrJ10pO1xuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5hcHBlbmRDaGlsZChidXR0b24pO1xuICAgICAgICB0aGlzLl9iaW5kSGFtbWVyVG9EaXYoYnV0dG9uLCB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIuYmluZCh0aGlzKSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2NyZWF0ZUJ1dHRvbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUJ1dHRvbihpZCwgY2xhc3NOYW1lLCBsYWJlbCkge1xuICAgICAgICB2YXIgbGFiZWxDbGFzc05hbWUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDMgfHwgYXJndW1lbnRzWzNdID09PSB1bmRlZmluZWQgPyAndmlzLWxhYmVsJyA6IGFyZ3VtZW50c1szXTtcblxuXG4gICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NW2lkICsgJ0RpdiddID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NW2lkICsgJ0RpdiddLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET01baWQgKyAnTGFiZWwnXSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTVtpZCArICdMYWJlbCddLmNsYXNzTmFtZSA9IGxhYmVsQ2xhc3NOYW1lO1xuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTVtpZCArICdMYWJlbCddLmlubmVySFRNTCA9IGxhYmVsO1xuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTVtpZCArICdEaXYnXS5hcHBlbmRDaGlsZCh0aGlzLm1hbmlwdWxhdGlvbkRPTVtpZCArICdMYWJlbCddKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uRE9NW2lkICsgJ0RpdiddO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19jcmVhdGVEZXNjcmlwdGlvbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZURlc2NyaXB0aW9uKGxhYmVsKSB7XG4gICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LmFwcGVuZENoaWxkKHRoaXMuX2NyZWF0ZUJ1dHRvbignZGVzY3JpcHRpb24nLCAndmlzLWJ1dHRvbiB2aXMtbm9uZScsIGxhYmVsKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVuZCBvZiBET00gZnVuY3Rpb25zIGZvciBidXR0b25zIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG5cbiAgICAgIC8qKlxuICAgICAgICogdGhpcyBiaW5kcyBhbiBldmVudCB1bnRpbCBjbGVhbnVwIGJ5IHRoZSBjbGVhbiBmdW5jdGlvbnMuXG4gICAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgICAqIEBwYXJhbSBuZXdGdW5jdGlvblxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3RlbXBvcmFyeUJpbmRFdmVudCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3RlbXBvcmFyeUJpbmRFdmVudChldmVudCwgbmV3RnVuY3Rpb24pIHtcbiAgICAgICAgdGhpcy50ZW1wb3JhcnlFdmVudEZ1bmN0aW9ucy5wdXNoKHsgZXZlbnQ6IGV2ZW50LCBib3VuZEZ1bmN0aW9uOiBuZXdGdW5jdGlvbiB9KTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oZXZlbnQsIG5ld0Z1bmN0aW9uKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiB0aGlzIG92ZXJyaWRlcyBhbiBVSSBmdW5jdGlvbiB1bnRpbCBjbGVhbnVwIGJ5IHRoZSBjbGVhbiBmdW5jdGlvblxuICAgICAgICogQHBhcmFtIFVJZnVuY3Rpb25OYW1lXG4gICAgICAgKiBAcGFyYW0gbmV3RnVuY3Rpb25cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ190ZW1wb3JhcnlCaW5kVUknLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF90ZW1wb3JhcnlCaW5kVUkoVUlmdW5jdGlvbk5hbWUsIG5ld0Z1bmN0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnNbVUlmdW5jdGlvbk5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnRlbXBvcmFyeVVJRnVuY3Rpb25zW1VJZnVuY3Rpb25OYW1lXSA9IHRoaXMuYm9keS5ldmVudExpc3RlbmVyc1tVSWZ1bmN0aW9uTmFtZV07XG4gICAgICAgICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzW1VJZnVuY3Rpb25OYW1lXSA9IG5ld0Z1bmN0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBVSSBmdW5jdGlvbiBkb2VzIG5vdCBleGlzdC4gVHlwbz8gWW91IHRyaWVkOiAnICsgVUlmdW5jdGlvbk5hbWUgKyAnIHBvc3NpYmxlIGFyZTogJyArIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKHRoaXMuYm9keS5ldmVudExpc3RlbmVycykpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlc3RvcmUgdGhlIG92ZXJyaWRkZW4gVUkgZnVuY3Rpb25zIHRvIHRoZWlyIG9yaWdpbmFsIHN0YXRlLlxuICAgICAgICpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ191bmJpbmRUZW1wb3JhcnlVSXMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91bmJpbmRUZW1wb3JhcnlVSXMoKSB7XG4gICAgICAgIGZvciAodmFyIGZ1bmN0aW9uTmFtZSBpbiB0aGlzLnRlbXBvcmFyeVVJRnVuY3Rpb25zKSB7XG4gICAgICAgICAgaWYgKHRoaXMudGVtcG9yYXJ5VUlGdW5jdGlvbnMuaGFzT3duUHJvcGVydHkoZnVuY3Rpb25OYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzW2Z1bmN0aW9uTmFtZV0gPSB0aGlzLnRlbXBvcmFyeVVJRnVuY3Rpb25zW2Z1bmN0aW9uTmFtZV07XG4gICAgICAgICAgICBkZWxldGUgdGhpcy50ZW1wb3JhcnlVSUZ1bmN0aW9uc1tmdW5jdGlvbk5hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRlbXBvcmFyeVVJRnVuY3Rpb25zID0ge307XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVW5iaW5kIHRoZSBldmVudHMgY3JlYXRlZCBieSBfdGVtcG9yYXJ5QmluZEV2ZW50XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfdW5iaW5kVGVtcG9yYXJ5RXZlbnRzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5iaW5kVGVtcG9yYXJ5RXZlbnRzKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudGVtcG9yYXJ5RXZlbnRGdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZXZlbnROYW1lID0gdGhpcy50ZW1wb3JhcnlFdmVudEZ1bmN0aW9uc1tpXS5ldmVudDtcbiAgICAgICAgICB2YXIgYm91bmRGdW5jdGlvbiA9IHRoaXMudGVtcG9yYXJ5RXZlbnRGdW5jdGlvbnNbaV0uYm91bmRGdW5jdGlvbjtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vZmYoZXZlbnROYW1lLCBib3VuZEZ1bmN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRlbXBvcmFyeUV2ZW50RnVuY3Rpb25zID0gW107XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQmluZCBhbiBoYW1tZXIgaW5zdGFuY2UgdG8gYSBET00gZWxlbWVudC5cbiAgICAgICAqIEBwYXJhbSBkb21FbGVtZW50XG4gICAgICAgKiBAcGFyYW0gZnVuY3RcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2JpbmRIYW1tZXJUb0RpdicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2JpbmRIYW1tZXJUb0Rpdihkb21FbGVtZW50LCBib3VuZEZ1bmN0aW9uKSB7XG4gICAgICAgIHZhciBoYW1tZXIgPSBuZXcgSGFtbWVyKGRvbUVsZW1lbnQsIHt9KTtcbiAgICAgICAgaGFtbWVyVXRpbC5vblRvdWNoKGhhbW1lciwgYm91bmRGdW5jdGlvbik7XG4gICAgICAgIHRoaXMubWFuaXB1bGF0aW9uSGFtbWVycy5wdXNoKGhhbW1lcik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogTmVhdGx5IGNsZWFuIHVwIHRlbXBvcmFyeSBlZGdlcyBhbmQgbm9kZXNcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19jbGVhbnVwVGVtcG9yYXJ5Tm9kZXNBbmRFZGdlcycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NsZWFudXBUZW1wb3JhcnlOb2Rlc0FuZEVkZ2VzKCkge1xuICAgICAgICAvLyBfY2xlYW4gdGVtcG9yYXJ5IGVkZ2VzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50ZW1wb3JhcnlJZHMuZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZWRnZXNbdGhpcy50ZW1wb3JhcnlJZHMuZWRnZXNbaV1dLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5ib2R5LmVkZ2VzW3RoaXMudGVtcG9yYXJ5SWRzLmVkZ2VzW2ldXTtcbiAgICAgICAgICB2YXIgaW5kZXhUZW1wRWRnZSA9IHRoaXMuYm9keS5lZGdlSW5kaWNlcy5pbmRleE9mKHRoaXMudGVtcG9yYXJ5SWRzLmVkZ2VzW2ldKTtcbiAgICAgICAgICBpZiAoaW5kZXhUZW1wRWRnZSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuYm9keS5lZGdlSW5kaWNlcy5zcGxpY2UoaW5kZXhUZW1wRWRnZSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gX2NsZWFuIHRlbXBvcmFyeSBub2Rlc1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdGhpcy50ZW1wb3JhcnlJZHMubm9kZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuYm9keS5ub2Rlc1t0aGlzLnRlbXBvcmFyeUlkcy5ub2Rlc1tfaV1dO1xuICAgICAgICAgIHZhciBpbmRleFRlbXBOb2RlID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmluZGV4T2YodGhpcy50ZW1wb3JhcnlJZHMubm9kZXNbX2ldKTtcbiAgICAgICAgICBpZiAoaW5kZXhUZW1wTm9kZSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuYm9keS5ub2RlSW5kaWNlcy5zcGxpY2UoaW5kZXhUZW1wTm9kZSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50ZW1wb3JhcnlJZHMgPSB7IG5vZGVzOiBbXSwgZWRnZXM6IFtdIH07XG4gICAgICB9XG5cbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFRElUIEVER0UgRlVOQ1RJT05TIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLy9cblxuICAgICAgLyoqXG4gICAgICAgKiB0aGUgdG91Y2ggaXMgdXNlZCB0byBnZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBpbml0aWFsIGNsaWNrXG4gICAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19jb250cm9sTm9kZVRvdWNoJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY29udHJvbE5vZGVUb3VjaChldmVudCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIudW5zZWxlY3RBbGwoKTtcbiAgICAgICAgdGhpcy5sYXN0VG91Y2ggPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgICAgdGhpcy5sYXN0VG91Y2gudHJhbnNsYXRpb24gPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24pOyAvLyBjb3B5IHRoZSBvYmplY3RcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiB0aGUgZHJhZyBzdGFydCBpcyB1c2VkIHRvIG1hcmsgb25lIG9mIHRoZSBjb250cm9sIG5vZGVzIGFzIHNlbGVjdGVkLlxuICAgICAgICogQHBhcmFtIGV2ZW50XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY29udHJvbE5vZGVEcmFnU3RhcnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jb250cm9sTm9kZURyYWdTdGFydChldmVudCkge1xuICAgICAgICB2YXIgcG9pbnRlciA9IHRoaXMubGFzdFRvdWNoO1xuICAgICAgICB2YXIgcG9pbnRlck9iaiA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fcG9pbnRlclRvUG9zaXRpb25PYmplY3QocG9pbnRlcik7XG4gICAgICAgIHZhciBmcm9tID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMudGVtcG9yYXJ5SWRzLm5vZGVzWzBdXTtcbiAgICAgICAgdmFyIHRvID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMudGVtcG9yYXJ5SWRzLm5vZGVzWzFdXTtcbiAgICAgICAgdmFyIGVkZ2UgPSB0aGlzLmJvZHkuZWRnZXNbdGhpcy5lZGdlQmVpbmdFZGl0ZWRJZF07XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZSA9IHVuZGVmaW5lZDtcblxuICAgICAgICB2YXIgZnJvbVNlbGVjdCA9IGZyb20uaXNPdmVybGFwcGluZ1dpdGgocG9pbnRlck9iaik7XG4gICAgICAgIHZhciB0b1NlbGVjdCA9IHRvLmlzT3ZlcmxhcHBpbmdXaXRoKHBvaW50ZXJPYmopO1xuXG4gICAgICAgIGlmIChmcm9tU2VsZWN0ID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlID0gZnJvbTtcbiAgICAgICAgICBlZGdlLmVkZ2VUeXBlLmZyb20gPSBmcm9tO1xuICAgICAgICB9IGVsc2UgaWYgKHRvU2VsZWN0ID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlID0gdG87XG4gICAgICAgICAgZWRnZS5lZGdlVHlwZS50byA9IHRvO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2UgdXNlIHRoZSBzZWxlY3Rpb24gdG8gZmluZCB0aGUgbm9kZSB0aGF0IGlzIGJlaW5nIGRyYWdnZWQuIFdlIGV4cGxpY2l0bHkgc2VsZWN0IGl0IGhlcmUuXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5zZWxlY3RPYmplY3QodGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19yZWRyYXcnKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBkcmFnZ2luZyB0aGUgY29udHJvbCBub2RlcyBvciB0aGUgY2FudmFzXG4gICAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19jb250cm9sTm9kZURyYWcnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jb250cm9sTm9kZURyYWcoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnZGlzYWJsZVBoeXNpY3MnKTtcbiAgICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgICAgdmFyIHBvcyA9IHRoaXMuY2FudmFzLkRPTXRvQ2FudmFzKHBvaW50ZXIpO1xuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUueCA9IHBvcy54O1xuICAgICAgICAgIHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZS55ID0gcG9zLnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaWYgdGhlIGRyYWcgd2FzIG5vdCBzdGFydGVkIHByb3Blcmx5IGJlY2F1c2UgdGhlIGNsaWNrIHN0YXJ0ZWQgb3V0c2lkZSB0aGUgbmV0d29yayBkaXYsIHN0YXJ0IGl0IG5vdy5cbiAgICAgICAgICB2YXIgZGlmZlggPSBwb2ludGVyLnggLSB0aGlzLmxhc3RUb3VjaC54O1xuICAgICAgICAgIHZhciBkaWZmWSA9IHBvaW50ZXIueSAtIHRoaXMubGFzdFRvdWNoLnk7XG4gICAgICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24gPSB7IHg6IHRoaXMubGFzdFRvdWNoLnRyYW5zbGF0aW9uLnggKyBkaWZmWCwgeTogdGhpcy5sYXN0VG91Y2gudHJhbnNsYXRpb24ueSArIGRpZmZZIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX3JlZHJhdycpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGNvbm5lY3Rpbmcgb3IgcmVzdG9yaW5nIHRoZSBjb250cm9sIG5vZGVzLlxuICAgICAgICogQHBhcmFtIGV2ZW50XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY29udHJvbE5vZGVEcmFnRW5kJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY29udHJvbE5vZGVEcmFnRW5kKGV2ZW50KSB7XG4gICAgICAgIHZhciBwb2ludGVyID0gdGhpcy5ib2R5LmZ1bmN0aW9ucy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICAgIHZhciBwb2ludGVyT2JqID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9wb2ludGVyVG9Qb3NpdGlvbk9iamVjdChwb2ludGVyKTtcbiAgICAgICAgdmFyIGVkZ2UgPSB0aGlzLmJvZHkuZWRnZXNbdGhpcy5lZGdlQmVpbmdFZGl0ZWRJZF07XG4gICAgICAgIC8vIGlmIHRoZSBub2RlIHRoYXQgd2FzIGRyYWdnZWQgaXMgbm90IGEgY29udHJvbCBub2RlLCByZXR1cm5cbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2UgdXNlIHRoZSBzZWxlY3Rpb24gdG8gZmluZCB0aGUgbm9kZSB0aGF0IGlzIGJlaW5nIGRyYWdnZWQuIFdlIGV4cGxpY2l0bHkgREVzZWxlY3QgdGhlIGNvbnRyb2wgbm9kZSBoZXJlLlxuICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIudW5zZWxlY3RBbGwoKTtcbiAgICAgICAgdmFyIG92ZXJsYXBwaW5nTm9kZUlkcyA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2V0QWxsTm9kZXNPdmVybGFwcGluZ1dpdGgocG9pbnRlck9iaik7XG4gICAgICAgIHZhciBub2RlID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKHZhciBpID0gb3ZlcmxhcHBpbmdOb2RlSWRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKG92ZXJsYXBwaW5nTm9kZUlkc1tpXSAhPT0gdGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlLmlkKSB7XG4gICAgICAgICAgICBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW292ZXJsYXBwaW5nTm9kZUlkc1tpXV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGVyZm9ybSB0aGUgY29ubmVjdGlvblxuICAgICAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKG5vZGUuaXNDbHVzdGVyID09PSB0cnVlKSB7XG4gICAgICAgICAgICBhbGVydCh0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXVsnY3JlYXRlRWRnZUVycm9yJ10gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbJ2VuJ11bJ2NyZWF0ZUVkZ2VFcnJvciddKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGZyb20gPSB0aGlzLmJvZHkubm9kZXNbdGhpcy50ZW1wb3JhcnlJZHMubm9kZXNbMF1dO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZS5pZCA9PT0gZnJvbS5pZCkge1xuICAgICAgICAgICAgICB0aGlzLl9wZXJmb3JtRWRpdEVkZ2Uobm9kZS5pZCwgZWRnZS50by5pZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9wZXJmb3JtRWRpdEVkZ2UoZWRnZS5mcm9tLmlkLCBub2RlLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWRnZS51cGRhdGVFZGdlVHlwZSgpO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3Jlc3RvcmVQaHlzaWNzJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX3JlZHJhdycpO1xuICAgICAgfVxuXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRU5EIE9GIEVESVQgRURHRSBGVU5DVElPTlMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xuXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEFERCBFREdFIEZVTkNUSU9OUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG4gICAgICAvKipcbiAgICAgICAqIHRoZSBmdW5jdGlvbiBib3VuZCB0byB0aGUgc2VsZWN0aW9uIGV2ZW50LiBJdCBjaGVja3MgaWYgeW91IHdhbnQgdG8gY29ubmVjdCBhIGNsdXN0ZXIgYW5kIGNoYW5nZXMgdGhlIGRlc2NyaXB0aW9uXG4gICAgICAgKiB0byB3YWxrIHRoZSB1c2VyIHRocm91Z2ggdGhlIHByb2Nlc3MuXG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2hhbmRsZUNvbm5lY3QnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVDb25uZWN0KGV2ZW50KSB7XG4gICAgICAgIC8vIGNoZWNrIHRvIGF2b2lkIGRvdWJsZSBmaXJlaW5nIG9mIHRoaXMgZnVuY3Rpb24uXG4gICAgICAgIGlmIChuZXcgRGF0ZSgpLnZhbHVlT2YoKSAtIHRoaXMudG91Y2hUaW1lID4gMTAwKSB7XG4gICAgICAgICAgdGhpcy5sYXN0VG91Y2ggPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgICAgICB0aGlzLmxhc3RUb3VjaC50cmFuc2xhdGlvbiA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbik7IC8vIGNvcHkgdGhlIG9iamVjdFxuXG4gICAgICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmxhc3RUb3VjaDtcbiAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXROb2RlQXQocG9pbnRlcik7XG5cbiAgICAgICAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5pc0NsdXN0ZXIgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgYWxlcnQodGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV1bJ2NyZWF0ZUVkZ2VFcnJvciddIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzWydlbiddWydjcmVhdGVFZGdlRXJyb3InXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBjcmVhdGUgYSBub2RlIHRoZSB0ZW1wb3JhcnkgbGluZSBjYW4gbG9vayBhdFxuICAgICAgICAgICAgICB2YXIgdGFyZ2V0Tm9kZSA9IHRoaXMuX2dldE5ld1RhcmdldE5vZGUobm9kZS54LCBub2RlLnkpO1xuICAgICAgICAgICAgICB0aGlzLmJvZHkubm9kZXNbdGFyZ2V0Tm9kZS5pZF0gPSB0YXJnZXROb2RlO1xuICAgICAgICAgICAgICB0aGlzLmJvZHkubm9kZUluZGljZXMucHVzaCh0YXJnZXROb2RlLmlkKTtcblxuICAgICAgICAgICAgICAvLyBjcmVhdGUgYSB0ZW1wb3JhcnkgZWRnZVxuICAgICAgICAgICAgICB2YXIgY29ubmVjdGlvbkVkZ2UgPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZUVkZ2Uoe1xuICAgICAgICAgICAgICAgIGlkOiAnY29ubmVjdGlvbkVkZ2UnICsgdXRpbC5yYW5kb21VVUlEKCksXG4gICAgICAgICAgICAgICAgZnJvbTogbm9kZS5pZCxcbiAgICAgICAgICAgICAgICB0bzogdGFyZ2V0Tm9kZS5pZCxcbiAgICAgICAgICAgICAgICBwaHlzaWNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzbW9vdGg6IHtcbiAgICAgICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICB0eXBlOiAnY29udGludW91cycsXG4gICAgICAgICAgICAgICAgICByb3VuZG5lc3M6IDAuNVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHRoaXMuYm9keS5lZGdlc1tjb25uZWN0aW9uRWRnZS5pZF0gPSBjb25uZWN0aW9uRWRnZTtcbiAgICAgICAgICAgICAgdGhpcy5ib2R5LmVkZ2VJbmRpY2VzLnB1c2goY29ubmVjdGlvbkVkZ2UuaWQpO1xuXG4gICAgICAgICAgICAgIHRoaXMudGVtcG9yYXJ5SWRzLm5vZGVzLnB1c2godGFyZ2V0Tm9kZS5pZCk7XG4gICAgICAgICAgICAgIHRoaXMudGVtcG9yYXJ5SWRzLmVkZ2VzLnB1c2goY29ubmVjdGlvbkVkZ2UuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnRvdWNoVGltZSA9IG5ldyBEYXRlKCkudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2RyYWdDb250cm9sTm9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYWdDb250cm9sTm9kZShldmVudCkge1xuICAgICAgICB2YXIgcG9pbnRlciA9IHRoaXMuYm9keS5mdW5jdGlvbnMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuICAgICAgICBpZiAodGhpcy50ZW1wb3JhcnlJZHMubm9kZXNbMF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciB0YXJnZXROb2RlID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMudGVtcG9yYXJ5SWRzLm5vZGVzWzBdXTsgLy8gdGhlcmUgaXMgb25seSBvbmUgdGVtcCBub2RlIGluIHRoZSBhZGQgZWRnZSBtb2RlLlxuICAgICAgICAgIHRhcmdldE5vZGUueCA9IHRoaXMuY2FudmFzLl9YY29udmVydERPTXRvQ2FudmFzKHBvaW50ZXIueCk7XG4gICAgICAgICAgdGFyZ2V0Tm9kZS55ID0gdGhpcy5jYW52YXMuX1ljb252ZXJ0RE9NdG9DYW52YXMocG9pbnRlci55KTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfcmVkcmF3Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGRpZmZYID0gcG9pbnRlci54IC0gdGhpcy5sYXN0VG91Y2gueDtcbiAgICAgICAgICB2YXIgZGlmZlkgPSBwb2ludGVyLnkgLSB0aGlzLmxhc3RUb3VjaC55O1xuICAgICAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uID0geyB4OiB0aGlzLmxhc3RUb3VjaC50cmFuc2xhdGlvbi54ICsgZGlmZlgsIHk6IHRoaXMubGFzdFRvdWNoLnRyYW5zbGF0aW9uLnkgKyBkaWZmWSB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29ubmVjdCB0aGUgbmV3IGVkZ2UgdG8gdGhlIHRhcmdldCBpZiBvbmUgZXhpc3RzLCBvdGhlcndpc2UgcmVtb3ZlIHRlbXAgbGluZVxuICAgICAgICogQHBhcmFtIGV2ZW50XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZmluaXNoQ29ubmVjdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmlzaENvbm5lY3QoZXZlbnQpIHtcbiAgICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgICAgdmFyIHBvaW50ZXJPYmogPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX3BvaW50ZXJUb1Bvc2l0aW9uT2JqZWN0KHBvaW50ZXIpO1xuXG4gICAgICAgIC8vIHJlbWVtYmVyIHRoZSBlZGdlIGlkXG4gICAgICAgIHZhciBjb25uZWN0RnJvbUlkID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodGhpcy50ZW1wb3JhcnlJZHMuZWRnZXNbMF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbm5lY3RGcm9tSWQgPSB0aGlzLmJvZHkuZWRnZXNbdGhpcy50ZW1wb3JhcnlJZHMuZWRnZXNbMF1dLmZyb21JZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCB0aGUgb3ZlcmxhcHBpbmcgbm9kZSBidXQgTk9UIHRoZSB0ZW1wb3Jhcnkgbm9kZTtcbiAgICAgICAgdmFyIG92ZXJsYXBwaW5nTm9kZUlkcyA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2V0QWxsTm9kZXNPdmVybGFwcGluZ1dpdGgocG9pbnRlck9iaik7XG4gICAgICAgIHZhciBub2RlID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKHZhciBpID0gb3ZlcmxhcHBpbmdOb2RlSWRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgLy8gaWYgdGhlIG5vZGUgaWQgaXMgTk9UIGEgdGVtcG9yYXJ5IG5vZGUsIGFjY2VwdCB0aGUgbm9kZS5cbiAgICAgICAgICBpZiAodGhpcy50ZW1wb3JhcnlJZHMubm9kZXMuaW5kZXhPZihvdmVybGFwcGluZ05vZGVJZHNbaV0pID09PSAtMSkge1xuICAgICAgICAgICAgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tvdmVybGFwcGluZ05vZGVJZHNbaV1dO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYW4gdGVtcG9yYXJ5IG5vZGVzIGFuZCBlZGdlcy5cbiAgICAgICAgdGhpcy5fY2xlYW51cFRlbXBvcmFyeU5vZGVzQW5kRWRnZXMoKTtcblxuICAgICAgICAvLyBwZXJmb3JtIHRoZSBjb25uZWN0aW9uXG4gICAgICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAobm9kZS5pc0NsdXN0ZXIgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGFsZXJ0KHRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdWydjcmVhdGVFZGdlRXJyb3InXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1snZW4nXVsnY3JlYXRlRWRnZUVycm9yJ10pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW2Nvbm5lY3RGcm9tSWRdICE9PSB1bmRlZmluZWQgJiYgdGhpcy5ib2R5Lm5vZGVzW25vZGUuaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcGVyZm9ybUFkZEVkZ2UoY29ubmVjdEZyb21JZCwgbm9kZS5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19yZWRyYXcnKTtcbiAgICAgIH1cblxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVORCBPRiBBREQgRURHRSBGVU5DVElPTlMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG5cbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBQZXJmb3JtaW5nIGFsbCB0aGUgYWN0dWFsIGRhdGEgbWFuaXB1bGF0aW9uIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG5cbiAgICAgIC8qKlxuICAgICAgICogQWRkcyBhIG5vZGUgb24gdGhlIHNwZWNpZmllZCBsb2NhdGlvblxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfcGVyZm9ybUFkZE5vZGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9wZXJmb3JtQWRkTm9kZShjbGlja0RhdGEpIHtcbiAgICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGRlZmF1bHREYXRhID0ge1xuICAgICAgICAgIGlkOiB1dGlsLnJhbmRvbVVVSUQoKSxcbiAgICAgICAgICB4OiBjbGlja0RhdGEucG9pbnRlci5jYW52YXMueCxcbiAgICAgICAgICB5OiBjbGlja0RhdGEucG9pbnRlci5jYW52YXMueSxcbiAgICAgICAgICBsYWJlbDogJ25ldydcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5hZGROb2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hZGROb2RlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmFkZE5vZGUoZGVmYXVsdERhdGEsIGZ1bmN0aW9uIChmaW5hbGl6ZWREYXRhKSB7XG4gICAgICAgICAgICAgIGlmIChmaW5hbGl6ZWREYXRhICE9PSBudWxsICYmIGZpbmFsaXplZERhdGEgIT09IHVuZGVmaW5lZCAmJiBfdGhpczUuaW5Nb2RlID09PSAnYWRkTm9kZScpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBmb3Igd2hhdGV2ZXIgcmVhc29uIHRoZSBtb2RlIGhhcyBjaGFuZ2VzIChkdWUgdG8gZGF0YXNldCBjaGFuZ2UpIGRpc3JlZ2FyZCB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICBfdGhpczUuYm9keS5kYXRhLm5vZGVzLmdldERhdGFTZXQoKS5hZGQoZmluYWxpemVkRGF0YSk7XG4gICAgICAgICAgICAgICAgX3RoaXM1LnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGZ1bmN0aW9uIGZvciBhZGQgZG9lcyBub3Qgc3VwcG9ydCB0d28gYXJndW1lbnRzIChkYXRhLGNhbGxiYWNrKScpO1xuICAgICAgICAgICAgdGhpcy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYm9keS5kYXRhLm5vZGVzLmdldERhdGFTZXQoKS5hZGQoZGVmYXVsdERhdGEpO1xuICAgICAgICAgIHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogY29ubmVjdCB0d28gbm9kZXMgd2l0aCBhIG5ldyBlZGdlLlxuICAgICAgICpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19wZXJmb3JtQWRkRWRnZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3BlcmZvcm1BZGRFZGdlKHNvdXJjZU5vZGVJZCwgdGFyZ2V0Tm9kZUlkKSB7XG4gICAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHsgZnJvbTogc291cmNlTm9kZUlkLCB0bzogdGFyZ2V0Tm9kZUlkIH07XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmFkZEVkZ2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFkZEVkZ2UubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuYWRkRWRnZShkZWZhdWx0RGF0YSwgZnVuY3Rpb24gKGZpbmFsaXplZERhdGEpIHtcbiAgICAgICAgICAgICAgaWYgKGZpbmFsaXplZERhdGEgIT09IG51bGwgJiYgZmluYWxpemVkRGF0YSAhPT0gdW5kZWZpbmVkICYmIF90aGlzNi5pbk1vZGUgPT09ICdhZGRFZGdlJykge1xuICAgICAgICAgICAgICAgIC8vIGlmIGZvciB3aGF0ZXZlciByZWFzb24gdGhlIG1vZGUgaGFzIGNoYW5nZXMgKGR1ZSB0byBkYXRhc2V0IGNoYW5nZSkgZGlzcmVnYXJkIHRoZSBjYWxsYmFja1xuICAgICAgICAgICAgICAgIF90aGlzNi5ib2R5LmRhdGEuZWRnZXMuZ2V0RGF0YVNldCgpLmFkZChmaW5hbGl6ZWREYXRhKTtcbiAgICAgICAgICAgICAgICBfdGhpczYuc2VsZWN0aW9uSGFuZGxlci51bnNlbGVjdEFsbCgpO1xuICAgICAgICAgICAgICAgIF90aGlzNi5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBmdW5jdGlvbiBmb3IgY29ubmVjdCBkb2VzIG5vdCBzdXBwb3J0IHR3byBhcmd1bWVudHMgKGRhdGEsY2FsbGJhY2spJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYm9keS5kYXRhLmVkZ2VzLmdldERhdGFTZXQoKS5hZGQoZGVmYXVsdERhdGEpO1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci51bnNlbGVjdEFsbCgpO1xuICAgICAgICAgIHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogY29ubmVjdCB0d28gbm9kZXMgd2l0aCBhIG5ldyBlZGdlLlxuICAgICAgICpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19wZXJmb3JtRWRpdEVkZ2UnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9wZXJmb3JtRWRpdEVkZ2Uoc291cmNlTm9kZUlkLCB0YXJnZXROb2RlSWQpIHtcbiAgICAgICAgdmFyIF90aGlzNyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGRlZmF1bHREYXRhID0geyBpZDogdGhpcy5lZGdlQmVpbmdFZGl0ZWRJZCwgZnJvbTogc291cmNlTm9kZUlkLCB0bzogdGFyZ2V0Tm9kZUlkIH07XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmVkaXRFZGdlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lZGl0RWRnZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lZGl0RWRnZShkZWZhdWx0RGF0YSwgZnVuY3Rpb24gKGZpbmFsaXplZERhdGEpIHtcbiAgICAgICAgICAgICAgaWYgKGZpbmFsaXplZERhdGEgPT09IG51bGwgfHwgZmluYWxpemVkRGF0YSA9PT0gdW5kZWZpbmVkIHx8IF90aGlzNy5pbk1vZGUgIT09ICdlZGl0RWRnZScpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBmb3Igd2hhdGV2ZXIgcmVhc29uIHRoZSBtb2RlIGhhcyBjaGFuZ2VzIChkdWUgdG8gZGF0YXNldCBjaGFuZ2UpIGRpc3JlZ2FyZCB0aGUgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBfdGhpczcuYm9keS5lZGdlc1tkZWZhdWx0RGF0YS5pZF0udXBkYXRlRWRnZVR5cGUoKTtcbiAgICAgICAgICAgICAgICBfdGhpczcuYm9keS5lbWl0dGVyLmVtaXQoJ19yZWRyYXcnKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpczcuYm9keS5kYXRhLmVkZ2VzLmdldERhdGFTZXQoKS51cGRhdGUoZmluYWxpemVkRGF0YSk7XG4gICAgICAgICAgICAgICAgX3RoaXM3LnNlbGVjdGlvbkhhbmRsZXIudW5zZWxlY3RBbGwoKTtcbiAgICAgICAgICAgICAgICBfdGhpczcuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZnVuY3Rpb24gZm9yIGVkaXQgZG9lcyBub3Qgc3VwcG9ydCB0d28gYXJndW1lbnRzIChkYXRhLCBjYWxsYmFjayknKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmRhdGEuZWRnZXMuZ2V0RGF0YVNldCgpLnVwZGF0ZShkZWZhdWx0RGF0YSk7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnVuc2VsZWN0QWxsKCk7XG4gICAgICAgICAgdGhpcy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gTWFuaXB1bGF0aW9uU3lzdGVtO1xuICB9KCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gTWFuaXB1bGF0aW9uU3lzdGVtO1xuXG4vKioqLyB9LFxuLyogMTE0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG4gIC8qKlxuICAgKiBUaGlzIG9iamVjdCBjb250YWlucyBhbGwgcG9zc2libGUgb3B0aW9ucy4gSXQgd2lsbCBjaGVjayBpZiB0aGUgdHlwZXMgYXJlIGNvcnJlY3QsIGlmIHJlcXVpcmVkIGlmIHRoZSBvcHRpb24gaXMgb25lXG4gICAqIG9mIHRoZSBhbGxvd2VkIHZhbHVlcy5cbiAgICpcbiAgICogX19hbnlfXyBtZWFucyB0aGF0IHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSBkb2VzIG5vdCBtYXR0ZXIuXG4gICAqIF9fdHlwZV9fIGlzIGEgcmVxdWlyZWQgZmllbGQgZm9yIGFsbCBvYmplY3RzIGFuZCBjb250YWlucyB0aGUgYWxsb3dlZCB0eXBlcyBvZiBhbGwgb2JqZWN0c1xuICAgKi9cbiAgdmFyIHN0cmluZyA9ICdzdHJpbmcnO1xuICB2YXIgYm9vbGVhbiA9ICdib29sZWFuJztcbiAgdmFyIG51bWJlciA9ICdudW1iZXInO1xuICB2YXIgYXJyYXkgPSAnYXJyYXknO1xuICB2YXIgb2JqZWN0ID0gJ29iamVjdCc7IC8vIHNob3VsZCBvbmx5IGJlIGluIGEgX190eXBlX18gcHJvcGVydHlcbiAgdmFyIGRvbSA9ICdkb20nO1xuICB2YXIgYW55ID0gJ2FueSc7XG5cbiAgdmFyIGFsbE9wdGlvbnMgPSB7XG4gICAgY29uZmlndXJlOiB7XG4gICAgICBlbmFibGVkOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgIGZpbHRlcjogeyBib29sZWFuOiBib29sZWFuLCBzdHJpbmc6IHN0cmluZywgYXJyYXk6IGFycmF5LCAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH0sXG4gICAgICBjb250YWluZXI6IHsgZG9tOiBkb20gfSxcbiAgICAgIHNob3dCdXR0b246IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIGJvb2xlYW46IGJvb2xlYW4sIHN0cmluZzogc3RyaW5nLCBhcnJheTogYXJyYXksICdmdW5jdGlvbic6ICdmdW5jdGlvbicgfVxuICAgIH0sXG4gICAgZWRnZXM6IHtcbiAgICAgIGFycm93czoge1xuICAgICAgICB0bzogeyBlbmFibGVkOiB7IGJvb2xlYW46IGJvb2xlYW4gfSwgc2NhbGVGYWN0b3I6IHsgbnVtYmVyOiBudW1iZXIgfSwgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIGJvb2xlYW46IGJvb2xlYW4gfSB9LFxuICAgICAgICBtaWRkbGU6IHsgZW5hYmxlZDogeyBib29sZWFuOiBib29sZWFuIH0sIHNjYWxlRmFjdG9yOiB7IG51bWJlcjogbnVtYmVyIH0sIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBib29sZWFuOiBib29sZWFuIH0gfSxcbiAgICAgICAgZnJvbTogeyBlbmFibGVkOiB7IGJvb2xlYW46IGJvb2xlYW4gfSwgc2NhbGVGYWN0b3I6IHsgbnVtYmVyOiBudW1iZXIgfSwgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIGJvb2xlYW46IGJvb2xlYW4gfSB9LFxuICAgICAgICBfX3R5cGVfXzogeyBzdHJpbmc6IFsnZnJvbScsICd0bycsICdtaWRkbGUnXSwgb2JqZWN0OiBvYmplY3QgfVxuICAgICAgfSxcbiAgICAgIGFycm93U3RyaWtldGhyb3VnaDogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICBjb2xvcjoge1xuICAgICAgICBjb2xvcjogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgICBoaWdobGlnaHQ6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgICAgaG92ZXI6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgICAgaW5oZXJpdDogeyBzdHJpbmc6IFsnZnJvbScsICd0bycsICdib3RoJ10sIGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgICAgb3BhY2l0eTogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgc3RyaW5nOiBzdHJpbmcgfVxuICAgICAgfSxcbiAgICAgIGRhc2hlczogeyBib29sZWFuOiBib29sZWFuLCBhcnJheTogYXJyYXkgfSxcbiAgICAgIGZvbnQ6IHtcbiAgICAgICAgY29sb3I6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgICAgc2l6ZTogeyBudW1iZXI6IG51bWJlciB9LCAvLyBweFxuICAgICAgICBmYWNlOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgIGJhY2tncm91bmQ6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHsgbnVtYmVyOiBudW1iZXIgfSwgLy8gcHhcbiAgICAgICAgc3Ryb2tlQ29sb3I6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgICAgYWxpZ246IHsgc3RyaW5nOiBbJ2hvcml6b250YWwnLCAndG9wJywgJ21pZGRsZScsICdib3R0b20nXSB9LFxuICAgICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgc3RyaW5nOiBzdHJpbmcgfVxuICAgICAgfSxcbiAgICAgIGhpZGRlbjogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICBob3ZlcldpZHRoOiB7ICdmdW5jdGlvbic6ICdmdW5jdGlvbicsIG51bWJlcjogbnVtYmVyIH0sXG4gICAgICBsYWJlbDogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICBsYWJlbEhpZ2hsaWdodEJvbGQ6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgbGVuZ3RoOiB7IG51bWJlcjogbnVtYmVyLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgIHBoeXNpY3M6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgc2NhbGluZzoge1xuICAgICAgICBtaW46IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgbWF4OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgZW5hYmxlZDogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICAgICAgbWluOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgICAgbWF4OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgICAgbWF4VmlzaWJsZTogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICAgIGRyYXdUaHJlc2hvbGQ6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgYm9vbGVhbjogYm9vbGVhbiB9XG4gICAgICAgIH0sXG4gICAgICAgIGN1c3RvbVNjYWxpbmdGdW5jdGlvbjogeyAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0IH1cbiAgICAgIH0sXG4gICAgICBzZWxlY3Rpb25XaWR0aDogeyAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nLCBudW1iZXI6IG51bWJlciB9LFxuICAgICAgc2VsZlJlZmVyZW5jZVNpemU6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIHNoYWRvdzoge1xuICAgICAgICBlbmFibGVkOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgICAgY29sb3I6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgICAgc2l6ZTogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICB4OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIHk6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIGJvb2xlYW46IGJvb2xlYW4gfVxuICAgICAgfSxcbiAgICAgIHNtb290aDoge1xuICAgICAgICBlbmFibGVkOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgICAgdHlwZTogeyBzdHJpbmc6IFsnZHluYW1pYycsICdjb250aW51b3VzJywgJ2Rpc2NyZXRlJywgJ2RpYWdvbmFsQ3Jvc3MnLCAnc3RyYWlnaHRDcm9zcycsICdob3Jpem9udGFsJywgJ3ZlcnRpY2FsJywgJ2N1cnZlZENXJywgJ2N1cnZlZENDVycsICdjdWJpY0JlemllciddIH0sXG4gICAgICAgIHJvdW5kbmVzczogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBmb3JjZURpcmVjdGlvbjogeyBzdHJpbmc6IFsnaG9yaXpvbnRhbCcsICd2ZXJ0aWNhbCcsICdub25lJ10sIGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIGJvb2xlYW46IGJvb2xlYW4gfVxuICAgICAgfSxcbiAgICAgIHRpdGxlOiB7IHN0cmluZzogc3RyaW5nLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgIHdpZHRoOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICB2YWx1ZTogeyBudW1iZXI6IG51bWJlciwgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gICAgfSxcbiAgICBncm91cHM6IHtcbiAgICAgIHVzZURlZmF1bHRHcm91cHM6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgX19hbnlfXzogJ2dldCBmcm9tIG5vZGVzLCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJlbG93JyxcbiAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0IH1cbiAgICB9LFxuICAgIGludGVyYWN0aW9uOiB7XG4gICAgICBkcmFnTm9kZXM6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgZHJhZ1ZpZXc6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgaGlkZUVkZ2VzT25EcmFnOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgIGhpZGVOb2Rlc09uRHJhZzogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICBob3ZlcjogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICBrZXlib2FyZDoge1xuICAgICAgICBlbmFibGVkOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgICAgc3BlZWQ6IHsgeDogeyBudW1iZXI6IG51bWJlciB9LCB5OiB7IG51bWJlcjogbnVtYmVyIH0sIHpvb206IHsgbnVtYmVyOiBudW1iZXIgfSwgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfSB9LFxuICAgICAgICBiaW5kVG9XaW5kb3c6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgYm9vbGVhbjogYm9vbGVhbiB9XG4gICAgICB9LFxuICAgICAgbXVsdGlzZWxlY3Q6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgbmF2aWdhdGlvbkJ1dHRvbnM6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgc2VsZWN0YWJsZTogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICBzZWxlY3RDb25uZWN0ZWRFZGdlczogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICBob3ZlckNvbm5lY3RlZEVkZ2VzOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgIHRvb2x0aXBEZWxheTogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgem9vbVZpZXc6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICAgIH0sXG4gICAgbGF5b3V0OiB7XG4gICAgICByYW5kb21TZWVkOiB7ICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJywgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIGltcHJvdmVkTGF5b3V0OiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgIGhpZXJhcmNoaWNhbDoge1xuICAgICAgICBlbmFibGVkOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgICAgbGV2ZWxTZXBhcmF0aW9uOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIG5vZGVTcGFjaW5nOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIHRyZWVTcGFjaW5nOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIGJsb2NrU2hpZnRpbmc6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgICBlZGdlTWluaW1pemF0aW9uOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgICAgcGFyZW50Q2VudHJhbGl6YXRpb246IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgICBkaXJlY3Rpb246IHsgc3RyaW5nOiBbJ1VEJywgJ0RVJywgJ0xSJywgJ1JMJ10gfSwgLy8gVUQsIERVLCBMUiwgUkxcbiAgICAgICAgc29ydE1ldGhvZDogeyBzdHJpbmc6IFsnaHVic2l6ZScsICdkaXJlY3RlZCddIH0sIC8vIGh1YnNpemUsIGRpcmVjdGVkXG4gICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBib29sZWFuOiBib29sZWFuIH1cbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gICAgfSxcbiAgICBtYW5pcHVsYXRpb246IHtcbiAgICAgIGVuYWJsZWQ6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgaW5pdGlhbGx5QWN0aXZlOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgIGFkZE5vZGU6IHsgYm9vbGVhbjogYm9vbGVhbiwgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgICAgYWRkRWRnZTogeyBib29sZWFuOiBib29sZWFuLCAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH0sXG4gICAgICBlZGl0Tm9kZTogeyAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH0sXG4gICAgICBlZGl0RWRnZTogeyBib29sZWFuOiBib29sZWFuLCAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH0sXG4gICAgICBkZWxldGVOb2RlOiB7IGJvb2xlYW46IGJvb2xlYW4sICdmdW5jdGlvbic6ICdmdW5jdGlvbicgfSxcbiAgICAgIGRlbGV0ZUVkZ2U6IHsgYm9vbGVhbjogYm9vbGVhbiwgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgICAgY29udHJvbE5vZGVTdHlsZTogJ2dldCBmcm9tIG5vZGVzLCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJlbG93JyxcbiAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBib29sZWFuOiBib29sZWFuIH1cbiAgICB9LFxuICAgIG5vZGVzOiB7XG4gICAgICBib3JkZXJXaWR0aDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgYm9yZGVyV2lkdGhTZWxlY3RlZDogeyBudW1iZXI6IG51bWJlciwgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICBicm9rZW5JbWFnZTogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICBjb2xvcjoge1xuICAgICAgICBib3JkZXI6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgICAgYmFja2dyb3VuZDogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgICBib3JkZXI6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgICAgICBiYWNrZ3JvdW5kOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIHN0cmluZzogc3RyaW5nIH1cbiAgICAgICAgfSxcbiAgICAgICAgaG92ZXI6IHtcbiAgICAgICAgICBib3JkZXI6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgICAgICBiYWNrZ3JvdW5kOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIHN0cmluZzogc3RyaW5nIH1cbiAgICAgICAgfSxcbiAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIHN0cmluZzogc3RyaW5nIH1cbiAgICAgIH0sXG4gICAgICBmaXhlZDoge1xuICAgICAgICB4OiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgICAgeTogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBib29sZWFuOiBib29sZWFuIH1cbiAgICAgIH0sXG4gICAgICBmb250OiB7XG4gICAgICAgIGFsaWduOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgIGNvbG9yOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgIHNpemU6IHsgbnVtYmVyOiBudW1iZXIgfSwgLy8gcHhcbiAgICAgICAgZmFjZTogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgICBiYWNrZ3JvdW5kOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgIHN0cm9rZVdpZHRoOiB7IG51bWJlcjogbnVtYmVyIH0sIC8vIHB4XG4gICAgICAgIHN0cm9rZUNvbG9yOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBzdHJpbmc6IHN0cmluZyB9XG4gICAgICB9LFxuICAgICAgZ3JvdXA6IHsgc3RyaW5nOiBzdHJpbmcsIG51bWJlcjogbnVtYmVyLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgIGhpZGRlbjogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICBpY29uOiB7XG4gICAgICAgIGZhY2U6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgICAgY29kZTogeyBzdHJpbmc6IHN0cmluZyB9LCAvLydcXHVmMDA3JyxcbiAgICAgICAgc2l6ZTogeyBudW1iZXI6IG51bWJlciB9LCAvLzUwLFxuICAgICAgICBjb2xvcjogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gICAgICB9LFxuICAgICAgaWQ6IHsgc3RyaW5nOiBzdHJpbmcsIG51bWJlcjogbnVtYmVyIH0sXG4gICAgICBpbWFnZTogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sIC8vIC0tPiBVUkxcbiAgICAgIGxhYmVsOiB7IHN0cmluZzogc3RyaW5nLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgIGxhYmVsSGlnaGxpZ2h0Qm9sZDogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICBsZXZlbDogeyBudW1iZXI6IG51bWJlciwgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICBtYXNzOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICBwaHlzaWNzOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgIHNjYWxpbmc6IHtcbiAgICAgICAgbWluOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIG1heDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgIGVuYWJsZWQ6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgICAgIG1pbjogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICAgIG1heDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICAgIG1heFZpc2libGU6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgICBkcmF3VGhyZXNob2xkOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIGJvb2xlYW46IGJvb2xlYW4gfVxuICAgICAgICB9LFxuICAgICAgICBjdXN0b21TY2FsaW5nRnVuY3Rpb246IHsgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gICAgICB9LFxuICAgICAgc2hhZG93OiB7XG4gICAgICAgIGVuYWJsZWQ6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgICBjb2xvcjogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgICBzaXplOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIHg6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgeTogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgYm9vbGVhbjogYm9vbGVhbiB9XG4gICAgICB9LFxuICAgICAgc2hhcGU6IHsgc3RyaW5nOiBbJ2VsbGlwc2UnLCAnY2lyY2xlJywgJ2RhdGFiYXNlJywgJ2JveCcsICd0ZXh0JywgJ2ltYWdlJywgJ2NpcmN1bGFySW1hZ2UnLCAnZGlhbW9uZCcsICdkb3QnLCAnc3RhcicsICd0cmlhbmdsZScsICd0cmlhbmdsZURvd24nLCAnc3F1YXJlJywgJ2ljb24nXSB9LFxuICAgICAgc2hhcGVQcm9wZXJ0aWVzOiB7XG4gICAgICAgIGJvcmRlckRhc2hlczogeyBib29sZWFuOiBib29sZWFuLCBhcnJheTogYXJyYXkgfSxcbiAgICAgICAgYm9yZGVyUmFkaXVzOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIGludGVycG9sYXRpb246IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgICB1c2VJbWFnZVNpemU6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgICB1c2VCb3JkZXJXaXRoSW1hZ2U6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gICAgICB9LFxuICAgICAgc2l6ZTogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgdGl0bGU6IHsgc3RyaW5nOiBzdHJpbmcsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgdmFsdWU6IHsgbnVtYmVyOiBudW1iZXIsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgeDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgeTogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICAgIH0sXG4gICAgcGh5c2ljczoge1xuICAgICAgZW5hYmxlZDogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICBiYXJuZXNIdXQ6IHtcbiAgICAgICAgZ3Jhdml0YXRpb25hbENvbnN0YW50OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIGNlbnRyYWxHcmF2aXR5OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIHNwcmluZ0xlbmd0aDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBzcHJpbmdDb25zdGFudDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBkYW1waW5nOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIGF2b2lkT3ZlcmxhcDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gICAgICB9LFxuICAgICAgZm9yY2VBdGxhczJCYXNlZDoge1xuICAgICAgICBncmF2aXRhdGlvbmFsQ29uc3RhbnQ6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgY2VudHJhbEdyYXZpdHk6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgc3ByaW5nTGVuZ3RoOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIHNwcmluZ0NvbnN0YW50OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIGRhbXBpbmc6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgYXZvaWRPdmVybGFwOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0IH1cbiAgICAgIH0sXG4gICAgICByZXB1bHNpb246IHtcbiAgICAgICAgY2VudHJhbEdyYXZpdHk6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgc3ByaW5nTGVuZ3RoOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIHNwcmluZ0NvbnN0YW50OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIG5vZGVEaXN0YW5jZTogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBkYW1waW5nOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0IH1cbiAgICAgIH0sXG4gICAgICBoaWVyYXJjaGljYWxSZXB1bHNpb246IHtcbiAgICAgICAgY2VudHJhbEdyYXZpdHk6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgc3ByaW5nTGVuZ3RoOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIHNwcmluZ0NvbnN0YW50OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIG5vZGVEaXN0YW5jZTogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBkYW1waW5nOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0IH1cbiAgICAgIH0sXG4gICAgICBtYXhWZWxvY2l0eTogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgbWluVmVsb2NpdHk6IHsgbnVtYmVyOiBudW1iZXIgfSwgLy8gcHgvc1xuICAgICAgc29sdmVyOiB7IHN0cmluZzogWydiYXJuZXNIdXQnLCAncmVwdWxzaW9uJywgJ2hpZXJhcmNoaWNhbFJlcHVsc2lvbicsICdmb3JjZUF0bGFzMkJhc2VkJ10gfSxcbiAgICAgIHN0YWJpbGl6YXRpb246IHtcbiAgICAgICAgZW5hYmxlZDogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICAgIGl0ZXJhdGlvbnM6IHsgbnVtYmVyOiBudW1iZXIgfSwgLy8gbWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9uIHRvIHN0YWJpbGl6ZVxuICAgICAgICB1cGRhdGVJbnRlcnZhbDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBvbmx5RHluYW1pY0VkZ2VzOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgICAgZml0OiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIGJvb2xlYW46IGJvb2xlYW4gfVxuICAgICAgfSxcbiAgICAgIHRpbWVzdGVwOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICBhZGFwdGl2ZVRpbWVzdGVwOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBib29sZWFuOiBib29sZWFuIH1cbiAgICB9LFxuXG4gICAgLy9nbG9iYWxzIDpcbiAgICBhdXRvUmVzaXplOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICBjbGlja1RvVXNlOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICBsb2NhbGU6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICBsb2NhbGVzOiB7XG4gICAgICBfX2FueV9fOiB7IGFueTogYW55IH0sXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gICAgfSxcbiAgICBoZWlnaHQ6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICB3aWR0aDogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0IH1cbiAgfTtcblxuICBhbGxPcHRpb25zLmdyb3Vwcy5fX2FueV9fID0gYWxsT3B0aW9ucy5ub2RlcztcbiAgYWxsT3B0aW9ucy5tYW5pcHVsYXRpb24uY29udHJvbE5vZGVTdHlsZSA9IGFsbE9wdGlvbnMubm9kZXM7XG5cbiAgdmFyIGNvbmZpZ3VyZU9wdGlvbnMgPSB7XG4gICAgbm9kZXM6IHtcbiAgICAgIGJvcmRlcldpZHRoOiBbMSwgMCwgMTAsIDFdLFxuICAgICAgYm9yZGVyV2lkdGhTZWxlY3RlZDogWzIsIDAsIDEwLCAxXSxcbiAgICAgIGNvbG9yOiB7XG4gICAgICAgIGJvcmRlcjogWydjb2xvcicsICcjMkI3Q0U5J10sXG4gICAgICAgIGJhY2tncm91bmQ6IFsnY29sb3InLCAnIzk3QzJGQyddLFxuICAgICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgICBib3JkZXI6IFsnY29sb3InLCAnIzJCN0NFOSddLFxuICAgICAgICAgIGJhY2tncm91bmQ6IFsnY29sb3InLCAnI0QyRTVGRiddXG4gICAgICAgIH0sXG4gICAgICAgIGhvdmVyOiB7XG4gICAgICAgICAgYm9yZGVyOiBbJ2NvbG9yJywgJyMyQjdDRTknXSxcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBbJ2NvbG9yJywgJyNEMkU1RkYnXVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZml4ZWQ6IHtcbiAgICAgICAgeDogZmFsc2UsXG4gICAgICAgIHk6IGZhbHNlXG4gICAgICB9LFxuICAgICAgZm9udDoge1xuICAgICAgICBjb2xvcjogWydjb2xvcicsICcjMzQzNDM0J10sXG4gICAgICAgIHNpemU6IFsxNCwgMCwgMTAwLCAxXSwgLy8gcHhcbiAgICAgICAgZmFjZTogWydhcmlhbCcsICd2ZXJkYW5hJywgJ3RhaG9tYSddLFxuICAgICAgICBiYWNrZ3JvdW5kOiBbJ2NvbG9yJywgJ25vbmUnXSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IFswLCAwLCA1MCwgMV0sIC8vIHB4XG4gICAgICAgIHN0cm9rZUNvbG9yOiBbJ2NvbG9yJywgJyNmZmZmZmYnXVxuICAgICAgfSxcbiAgICAgIC8vZ3JvdXA6ICdzdHJpbmcnLFxuICAgICAgaGlkZGVuOiBmYWxzZSxcbiAgICAgIGxhYmVsSGlnaGxpZ2h0Qm9sZDogdHJ1ZSxcbiAgICAgIC8vaWNvbjoge1xuICAgICAgLy8gIGZhY2U6ICdzdHJpbmcnLCAgLy8nRm9udEF3ZXNvbWUnLFxuICAgICAgLy8gIGNvZGU6ICdzdHJpbmcnLCAgLy8nXFx1ZjAwNycsXG4gICAgICAvLyAgc2l6ZTogWzUwLCAwLCAyMDAsIDFdLCAgLy81MCxcbiAgICAgIC8vICBjb2xvcjogWydjb2xvcicsJyMyQjdDRTknXSAgIC8vJyNhYTAwZmYnXG4gICAgICAvL30sXG4gICAgICAvL2ltYWdlOiAnc3RyaW5nJywgLy8gLS0+IFVSTFxuICAgICAgcGh5c2ljczogdHJ1ZSxcbiAgICAgIHNjYWxpbmc6IHtcbiAgICAgICAgbWluOiBbMTAsIDAsIDIwMCwgMV0sXG4gICAgICAgIG1heDogWzMwLCAwLCAyMDAsIDFdLFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgIG1pbjogWzE0LCAwLCAyMDAsIDFdLFxuICAgICAgICAgIG1heDogWzMwLCAwLCAyMDAsIDFdLFxuICAgICAgICAgIG1heFZpc2libGU6IFszMCwgMCwgMjAwLCAxXSxcbiAgICAgICAgICBkcmF3VGhyZXNob2xkOiBbNSwgMCwgMjAsIDFdXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzaGFkb3c6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGNvbG9yOiAncmdiYSgwLDAsMCwwLjUpJyxcbiAgICAgICAgc2l6ZTogWzEwLCAwLCAyMCwgMV0sXG4gICAgICAgIHg6IFs1LCAtMzAsIDMwLCAxXSxcbiAgICAgICAgeTogWzUsIC0zMCwgMzAsIDFdXG4gICAgICB9LFxuICAgICAgc2hhcGU6IFsnZWxsaXBzZScsICdib3gnLCAnY2lyY2xlJywgJ2RhdGFiYXNlJywgJ2RpYW1vbmQnLCAnZG90JywgJ3NxdWFyZScsICdzdGFyJywgJ3RleHQnLCAndHJpYW5nbGUnLCAndHJpYW5nbGVEb3duJ10sXG4gICAgICBzaGFwZVByb3BlcnRpZXM6IHtcbiAgICAgICAgYm9yZGVyRGFzaGVzOiBmYWxzZSxcbiAgICAgICAgYm9yZGVyUmFkaXVzOiBbNiwgMCwgMjAsIDFdLFxuICAgICAgICBpbnRlcnBvbGF0aW9uOiB0cnVlLFxuICAgICAgICB1c2VJbWFnZVNpemU6IGZhbHNlXG4gICAgICB9LFxuICAgICAgc2l6ZTogWzI1LCAwLCAyMDAsIDFdXG4gICAgfSxcbiAgICBlZGdlczoge1xuICAgICAgYXJyb3dzOiB7XG4gICAgICAgIHRvOiB7IGVuYWJsZWQ6IGZhbHNlLCBzY2FsZUZhY3RvcjogWzEsIDAsIDMsIDAuMDVdIH0sIC8vIGJvb2xlYW4gLyB7YXJyb3dTY2FsZUZhY3RvcjoxfSAvIHtlbmFibGVkOiBmYWxzZSwgYXJyb3dTY2FsZUZhY3RvcjoxfVxuICAgICAgICBtaWRkbGU6IHsgZW5hYmxlZDogZmFsc2UsIHNjYWxlRmFjdG9yOiBbMSwgMCwgMywgMC4wNV0gfSxcbiAgICAgICAgZnJvbTogeyBlbmFibGVkOiBmYWxzZSwgc2NhbGVGYWN0b3I6IFsxLCAwLCAzLCAwLjA1XSB9XG4gICAgICB9LFxuICAgICAgYXJyb3dTdHJpa2V0aHJvdWdoOiB0cnVlLFxuICAgICAgY29sb3I6IHtcbiAgICAgICAgY29sb3I6IFsnY29sb3InLCAnIzg0ODQ4NCddLFxuICAgICAgICBoaWdobGlnaHQ6IFsnY29sb3InLCAnIzg0ODQ4NCddLFxuICAgICAgICBob3ZlcjogWydjb2xvcicsICcjODQ4NDg0J10sXG4gICAgICAgIGluaGVyaXQ6IFsnZnJvbScsICd0bycsICdib3RoJywgdHJ1ZSwgZmFsc2VdLFxuICAgICAgICBvcGFjaXR5OiBbMSwgMCwgMSwgMC4wNV1cbiAgICAgIH0sXG4gICAgICBkYXNoZXM6IGZhbHNlLFxuICAgICAgZm9udDoge1xuICAgICAgICBjb2xvcjogWydjb2xvcicsICcjMzQzNDM0J10sXG4gICAgICAgIHNpemU6IFsxNCwgMCwgMTAwLCAxXSwgLy8gcHhcbiAgICAgICAgZmFjZTogWydhcmlhbCcsICd2ZXJkYW5hJywgJ3RhaG9tYSddLFxuICAgICAgICBiYWNrZ3JvdW5kOiBbJ2NvbG9yJywgJ25vbmUnXSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IFsyLCAwLCA1MCwgMV0sIC8vIHB4XG4gICAgICAgIHN0cm9rZUNvbG9yOiBbJ2NvbG9yJywgJyNmZmZmZmYnXSxcbiAgICAgICAgYWxpZ246IFsnaG9yaXpvbnRhbCcsICd0b3AnLCAnbWlkZGxlJywgJ2JvdHRvbSddXG4gICAgICB9LFxuICAgICAgaGlkZGVuOiBmYWxzZSxcbiAgICAgIGhvdmVyV2lkdGg6IFsxLjUsIDAsIDUsIDAuMV0sXG4gICAgICBsYWJlbEhpZ2hsaWdodEJvbGQ6IHRydWUsXG4gICAgICBwaHlzaWNzOiB0cnVlLFxuICAgICAgc2NhbGluZzoge1xuICAgICAgICBtaW46IFsxLCAwLCAxMDAsIDFdLFxuICAgICAgICBtYXg6IFsxNSwgMCwgMTAwLCAxXSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgIG1pbjogWzE0LCAwLCAyMDAsIDFdLFxuICAgICAgICAgIG1heDogWzMwLCAwLCAyMDAsIDFdLFxuICAgICAgICAgIG1heFZpc2libGU6IFszMCwgMCwgMjAwLCAxXSxcbiAgICAgICAgICBkcmF3VGhyZXNob2xkOiBbNSwgMCwgMjAsIDFdXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZWxlY3Rpb25XaWR0aDogWzEuNSwgMCwgNSwgMC4xXSxcbiAgICAgIHNlbGZSZWZlcmVuY2VTaXplOiBbMjAsIDAsIDIwMCwgMV0sXG4gICAgICBzaGFkb3c6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGNvbG9yOiAncmdiYSgwLDAsMCwwLjUpJyxcbiAgICAgICAgc2l6ZTogWzEwLCAwLCAyMCwgMV0sXG4gICAgICAgIHg6IFs1LCAtMzAsIDMwLCAxXSxcbiAgICAgICAgeTogWzUsIC0zMCwgMzAsIDFdXG4gICAgICB9LFxuICAgICAgc21vb3RoOiB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIHR5cGU6IFsnZHluYW1pYycsICdjb250aW51b3VzJywgJ2Rpc2NyZXRlJywgJ2RpYWdvbmFsQ3Jvc3MnLCAnc3RyYWlnaHRDcm9zcycsICdob3Jpem9udGFsJywgJ3ZlcnRpY2FsJywgJ2N1cnZlZENXJywgJ2N1cnZlZENDVycsICdjdWJpY0JlemllciddLFxuICAgICAgICBmb3JjZURpcmVjdGlvbjogWydob3Jpem9udGFsJywgJ3ZlcnRpY2FsJywgJ25vbmUnXSxcbiAgICAgICAgcm91bmRuZXNzOiBbMC41LCAwLCAxLCAwLjA1XVxuICAgICAgfSxcbiAgICAgIHdpZHRoOiBbMSwgMCwgMzAsIDFdXG4gICAgfSxcbiAgICBsYXlvdXQ6IHtcbiAgICAgIC8vcmFuZG9tU2VlZDogWzAsIDAsIDUwMCwgMV0sXG4gICAgICAvL2ltcHJvdmVkTGF5b3V0OiB0cnVlLFxuICAgICAgaGllcmFyY2hpY2FsOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBsZXZlbFNlcGFyYXRpb246IFsxNTAsIDIwLCA1MDAsIDVdLFxuICAgICAgICBub2RlU3BhY2luZzogWzEwMCwgMjAsIDUwMCwgNV0sXG4gICAgICAgIHRyZWVTcGFjaW5nOiBbMjAwLCAyMCwgNTAwLCA1XSxcbiAgICAgICAgYmxvY2tTaGlmdGluZzogdHJ1ZSxcbiAgICAgICAgZWRnZU1pbmltaXphdGlvbjogdHJ1ZSxcbiAgICAgICAgcGFyZW50Q2VudHJhbGl6YXRpb246IHRydWUsXG4gICAgICAgIGRpcmVjdGlvbjogWydVRCcsICdEVScsICdMUicsICdSTCddLCAvLyBVRCwgRFUsIExSLCBSTFxuICAgICAgICBzb3J0TWV0aG9kOiBbJ2h1YnNpemUnLCAnZGlyZWN0ZWQnXSAvLyBodWJzaXplLCBkaXJlY3RlZFxuICAgICAgfVxuICAgIH0sXG4gICAgaW50ZXJhY3Rpb246IHtcbiAgICAgIGRyYWdOb2RlczogdHJ1ZSxcbiAgICAgIGRyYWdWaWV3OiB0cnVlLFxuICAgICAgaGlkZUVkZ2VzT25EcmFnOiBmYWxzZSxcbiAgICAgIGhpZGVOb2Rlc09uRHJhZzogZmFsc2UsXG4gICAgICBob3ZlcjogZmFsc2UsXG4gICAgICBrZXlib2FyZDoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgc3BlZWQ6IHsgeDogWzEwLCAwLCA0MCwgMV0sIHk6IFsxMCwgMCwgNDAsIDFdLCB6b29tOiBbMC4wMiwgMCwgMC4xLCAwLjAwNV0gfSxcbiAgICAgICAgYmluZFRvV2luZG93OiB0cnVlXG4gICAgICB9LFxuICAgICAgbXVsdGlzZWxlY3Q6IGZhbHNlLFxuICAgICAgbmF2aWdhdGlvbkJ1dHRvbnM6IGZhbHNlLFxuICAgICAgc2VsZWN0YWJsZTogdHJ1ZSxcbiAgICAgIHNlbGVjdENvbm5lY3RlZEVkZ2VzOiB0cnVlLFxuICAgICAgaG92ZXJDb25uZWN0ZWRFZGdlczogdHJ1ZSxcbiAgICAgIHRvb2x0aXBEZWxheTogWzMwMCwgMCwgMTAwMCwgMjVdLFxuICAgICAgem9vbVZpZXc6IHRydWVcbiAgICB9LFxuICAgIG1hbmlwdWxhdGlvbjoge1xuICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICBpbml0aWFsbHlBY3RpdmU6IGZhbHNlXG4gICAgfSxcbiAgICBwaHlzaWNzOiB7XG4gICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgYmFybmVzSHV0OiB7XG4gICAgICAgIC8vdGhldGE6IFswLjUsIDAuMSwgMSwgMC4wNV0sXG4gICAgICAgIGdyYXZpdGF0aW9uYWxDb25zdGFudDogWy0yMDAwLCAtMzAwMDAsIDAsIDUwXSxcbiAgICAgICAgY2VudHJhbEdyYXZpdHk6IFswLjMsIDAsIDEwLCAwLjA1XSxcbiAgICAgICAgc3ByaW5nTGVuZ3RoOiBbOTUsIDAsIDUwMCwgNV0sXG4gICAgICAgIHNwcmluZ0NvbnN0YW50OiBbMC4wNCwgMCwgMS4yLCAwLjAwNV0sXG4gICAgICAgIGRhbXBpbmc6IFswLjA5LCAwLCAxLCAwLjAxXSxcbiAgICAgICAgYXZvaWRPdmVybGFwOiBbMCwgMCwgMSwgMC4wMV1cbiAgICAgIH0sXG4gICAgICBmb3JjZUF0bGFzMkJhc2VkOiB7XG4gICAgICAgIC8vdGhldGE6IFswLjUsIDAuMSwgMSwgMC4wNV0sXG4gICAgICAgIGdyYXZpdGF0aW9uYWxDb25zdGFudDogWy01MCwgLTUwMCwgMCwgMV0sXG4gICAgICAgIGNlbnRyYWxHcmF2aXR5OiBbMC4wMSwgMCwgMSwgMC4wMDVdLFxuICAgICAgICBzcHJpbmdMZW5ndGg6IFs5NSwgMCwgNTAwLCA1XSxcbiAgICAgICAgc3ByaW5nQ29uc3RhbnQ6IFswLjA4LCAwLCAxLjIsIDAuMDA1XSxcbiAgICAgICAgZGFtcGluZzogWzAuNCwgMCwgMSwgMC4wMV0sXG4gICAgICAgIGF2b2lkT3ZlcmxhcDogWzAsIDAsIDEsIDAuMDFdXG4gICAgICB9LFxuICAgICAgcmVwdWxzaW9uOiB7XG4gICAgICAgIGNlbnRyYWxHcmF2aXR5OiBbMC4yLCAwLCAxMCwgMC4wNV0sXG4gICAgICAgIHNwcmluZ0xlbmd0aDogWzIwMCwgMCwgNTAwLCA1XSxcbiAgICAgICAgc3ByaW5nQ29uc3RhbnQ6IFswLjA1LCAwLCAxLjIsIDAuMDA1XSxcbiAgICAgICAgbm9kZURpc3RhbmNlOiBbMTAwLCAwLCA1MDAsIDVdLFxuICAgICAgICBkYW1waW5nOiBbMC4wOSwgMCwgMSwgMC4wMV1cbiAgICAgIH0sXG4gICAgICBoaWVyYXJjaGljYWxSZXB1bHNpb246IHtcbiAgICAgICAgY2VudHJhbEdyYXZpdHk6IFswLjIsIDAsIDEwLCAwLjA1XSxcbiAgICAgICAgc3ByaW5nTGVuZ3RoOiBbMTAwLCAwLCA1MDAsIDVdLFxuICAgICAgICBzcHJpbmdDb25zdGFudDogWzAuMDEsIDAsIDEuMiwgMC4wMDVdLFxuICAgICAgICBub2RlRGlzdGFuY2U6IFsxMjAsIDAsIDUwMCwgNV0sXG4gICAgICAgIGRhbXBpbmc6IFswLjA5LCAwLCAxLCAwLjAxXVxuICAgICAgfSxcbiAgICAgIG1heFZlbG9jaXR5OiBbNTAsIDAsIDE1MCwgMV0sXG4gICAgICBtaW5WZWxvY2l0eTogWzAuMSwgMC4wMSwgMC41LCAwLjAxXSxcbiAgICAgIHNvbHZlcjogWydiYXJuZXNIdXQnLCAnZm9yY2VBdGxhczJCYXNlZCcsICdyZXB1bHNpb24nLCAnaGllcmFyY2hpY2FsUmVwdWxzaW9uJ10sXG4gICAgICB0aW1lc3RlcDogWzAuNSwgMC4wMSwgMSwgMC4wMV1cbiAgICB9LFxuICAgIC8vYWRhcHRpdmVUaW1lc3RlcDogdHJ1ZVxuICAgIGdsb2JhbDoge1xuICAgICAgbG9jYWxlOiBbJ2VuJywgJ25sJ11cbiAgICB9XG4gIH07XG5cbiAgZXhwb3J0cy5hbGxPcHRpb25zID0gYWxsT3B0aW9ucztcbiAgZXhwb3J0cy5jb25maWd1cmVPcHRpb25zID0gY29uZmlndXJlT3B0aW9ucztcblxuLyoqKi8gfSxcbi8qIDExNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7IC8vIGRpc3RhbmNlIGZpbmRpbmcgYWxnb3JpdGhtXG5cblxuICB2YXIgX0Zsb3lkV2Fyc2hhbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExNik7XG5cbiAgdmFyIF9GbG95ZFdhcnNoYWxsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Zsb3lkV2Fyc2hhbGwpO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICAvKipcbiAgICogS2FtYWRhS2F3YWkgcG9zaXRpb25zIHRoZSBub2RlcyBpbml0aWFsbHkgYmFzZWQgb25cbiAgICpcbiAgICogXCJBTiBBTEdPUklUSE0gRk9SIERSQVdJTkcgR0VORVJBTCBVTkRJUkVDVEVEIEdSQVBIU1wiXG4gICAqIC0tIFRvbWloaXNhIEtBTUFEQSBhbmQgU2F0b3J1IEtBV0FJIGluIDE5ODlcbiAgICpcbiAgICogUG9zc2libGUgb3B0aW1pemF0aW9ucyBpbiB0aGUgZGlzdGFuY2UgY2FsY3VsYXRpb24gY2FuIGJlIGltcGxlbWVudGVkLlxuICAgKi9cblxuICB2YXIgS2FtYWRhS2F3YWkgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gS2FtYWRhS2F3YWkoYm9keSwgZWRnZUxlbmd0aCwgZWRnZVN0cmVuZ3RoKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgS2FtYWRhS2F3YWkpO1xuXG4gICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgdGhpcy5zcHJpbmdMZW5ndGggPSBlZGdlTGVuZ3RoO1xuICAgICAgdGhpcy5zcHJpbmdDb25zdGFudCA9IGVkZ2VTdHJlbmd0aDtcbiAgICAgIHRoaXMuZGlzdGFuY2VTb2x2ZXIgPSBuZXcgX0Zsb3lkV2Fyc2hhbGwyLmRlZmF1bHQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOb3Qgc3VyZSBpZiBuZWVkZWQgYnV0IGNhbiBiZSB1c2VkIHRvIHVwZGF0ZSB0aGUgc3ByaW5nIGxlbmd0aCBhbmQgc3ByaW5nIGNvbnN0YW50XG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKEthbWFkYUthd2FpLCBbe1xuICAgICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5zcHJpbmdMZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuc3ByaW5nTGVuZ3RoID0gb3B0aW9ucy5zcHJpbmdMZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRpb25zLnNwcmluZ0NvbnN0YW50KSB7XG4gICAgICAgICAgICB0aGlzLnNwcmluZ0NvbnN0YW50ID0gb3B0aW9ucy5zcHJpbmdDb25zdGFudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBQb3NpdGlvbiB0aGUgc3lzdGVtXG4gICAgICAgKiBAcGFyYW0gbm9kZXNBcnJheVxuICAgICAgICogQHBhcmFtIGVkZ2VzQXJyYXlcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInNvbHZlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc29sdmUobm9kZXNBcnJheSwgZWRnZXNBcnJheSkge1xuICAgICAgICB2YXIgaWdub3JlQ2x1c3RlcnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1syXTtcblxuICAgICAgICAvLyBnZXQgZGlzdGFuY2UgbWF0cml4XG4gICAgICAgIHZhciBEX21hdHJpeCA9IHRoaXMuZGlzdGFuY2VTb2x2ZXIuZ2V0RGlzdGFuY2VzKHRoaXMuYm9keSwgbm9kZXNBcnJheSwgZWRnZXNBcnJheSk7IC8vIGRpc3RhbmNlIG1hdHJpeFxuXG4gICAgICAgIC8vIGdldCB0aGUgTCBNYXRyaXhcbiAgICAgICAgdGhpcy5fY3JlYXRlTF9tYXRyaXgoRF9tYXRyaXgpO1xuXG4gICAgICAgIC8vIGdldCB0aGUgSyBNYXRyaXhcbiAgICAgICAgdGhpcy5fY3JlYXRlS19tYXRyaXgoRF9tYXRyaXgpO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBwb3NpdGlvbnNcbiAgICAgICAgdmFyIHRocmVzaG9sZCA9IDAuMDE7XG4gICAgICAgIHZhciBpbm5lclRocmVzaG9sZCA9IDE7XG4gICAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgICAgdmFyIG1heEl0ZXJhdGlvbnMgPSBNYXRoLm1heCgxMDAwLCBNYXRoLm1pbigxMCAqIHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGgsIDYwMDApKTtcbiAgICAgICAgdmFyIG1heElubmVySXRlcmF0aW9ucyA9IDU7XG5cbiAgICAgICAgdmFyIG1heEVuZXJneSA9IDFlOTtcbiAgICAgICAgdmFyIGhpZ2hFX25vZGVJZCA9IDAsXG4gICAgICAgICAgICBkRV9keCA9IDAsXG4gICAgICAgICAgICBkRV9keSA9IDAsXG4gICAgICAgICAgICBkZWx0YV9tID0gMCxcbiAgICAgICAgICAgIHN1Ykl0ZXJhdGlvbnMgPSAwO1xuXG4gICAgICAgIHdoaWxlIChtYXhFbmVyZ3kgPiB0aHJlc2hvbGQgJiYgaXRlcmF0aW9ucyA8IG1heEl0ZXJhdGlvbnMpIHtcbiAgICAgICAgICBpdGVyYXRpb25zICs9IDE7XG5cbiAgICAgICAgICB2YXIgX2dldEhpZ2hlc3RFbmVyZ3lOb2RlMiA9IHRoaXMuX2dldEhpZ2hlc3RFbmVyZ3lOb2RlKGlnbm9yZUNsdXN0ZXJzKTtcblxuICAgICAgICAgIHZhciBfZ2V0SGlnaGVzdEVuZXJneU5vZGUzID0gX3NsaWNlZFRvQXJyYXkoX2dldEhpZ2hlc3RFbmVyZ3lOb2RlMiwgNCk7XG5cbiAgICAgICAgICBoaWdoRV9ub2RlSWQgPSBfZ2V0SGlnaGVzdEVuZXJneU5vZGUzWzBdO1xuICAgICAgICAgIG1heEVuZXJneSA9IF9nZXRIaWdoZXN0RW5lcmd5Tm9kZTNbMV07XG4gICAgICAgICAgZEVfZHggPSBfZ2V0SGlnaGVzdEVuZXJneU5vZGUzWzJdO1xuICAgICAgICAgIGRFX2R5ID0gX2dldEhpZ2hlc3RFbmVyZ3lOb2RlM1szXTtcblxuICAgICAgICAgIGRlbHRhX20gPSBtYXhFbmVyZ3k7XG4gICAgICAgICAgc3ViSXRlcmF0aW9ucyA9IDA7XG4gICAgICAgICAgd2hpbGUgKGRlbHRhX20gPiBpbm5lclRocmVzaG9sZCAmJiBzdWJJdGVyYXRpb25zIDwgbWF4SW5uZXJJdGVyYXRpb25zKSB7XG4gICAgICAgICAgICBzdWJJdGVyYXRpb25zICs9IDE7XG4gICAgICAgICAgICB0aGlzLl9tb3ZlTm9kZShoaWdoRV9ub2RlSWQsIGRFX2R4LCBkRV9keSk7XG5cbiAgICAgICAgICAgIHZhciBfZ2V0RW5lcmd5MiA9IHRoaXMuX2dldEVuZXJneShoaWdoRV9ub2RlSWQpO1xuXG4gICAgICAgICAgICB2YXIgX2dldEVuZXJneTMgPSBfc2xpY2VkVG9BcnJheShfZ2V0RW5lcmd5MiwgMyk7XG5cbiAgICAgICAgICAgIGRlbHRhX20gPSBfZ2V0RW5lcmd5M1swXTtcbiAgICAgICAgICAgIGRFX2R4ID0gX2dldEVuZXJneTNbMV07XG4gICAgICAgICAgICBkRV9keSA9IF9nZXRFbmVyZ3kzWzJdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGdldCB0aGUgbm9kZSB3aXRoIHRoZSBoaWdoZXN0IGVuZXJneVxuICAgICAgICogQHJldHVybnMgeypbXX1cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfZ2V0SGlnaGVzdEVuZXJneU5vZGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0SGlnaGVzdEVuZXJneU5vZGUoaWdub3JlQ2x1c3RlcnMpIHtcbiAgICAgICAgdmFyIG5vZGVzQXJyYXkgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgICAgdmFyIG1heEVuZXJneSA9IDA7XG4gICAgICAgIHZhciBtYXhFbmVyZ3lOb2RlSWQgPSBub2Rlc0FycmF5WzBdO1xuICAgICAgICB2YXIgZEVfZHhfbWF4ID0gMCxcbiAgICAgICAgICAgIGRFX2R5X21heCA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgbm9kZUlkeCA9IDA7IG5vZGVJZHggPCBub2Rlc0FycmF5Lmxlbmd0aDsgbm9kZUlkeCsrKSB7XG4gICAgICAgICAgdmFyIG0gPSBub2Rlc0FycmF5W25vZGVJZHhdO1xuICAgICAgICAgIC8vIGJ5IG5vdCBldmFsdWF0aW5nIG5vZGVzIHdpdGggcHJlZGVmaW5lZCBwb3NpdGlvbnMgd2Ugc2hvdWxkIG9ubHkgbW92ZSBub2RlcyB0aGF0IGhhdmUgbm8gcG9zaXRpb25zLlxuICAgICAgICAgIGlmIChub2Rlc1ttXS5wcmVkZWZpbmVkUG9zaXRpb24gPT09IGZhbHNlIHx8IG5vZGVzW21dLmlzQ2x1c3RlciA9PT0gdHJ1ZSAmJiBpZ25vcmVDbHVzdGVycyA9PT0gdHJ1ZSB8fCBub2Rlc1ttXS5vcHRpb25zLmZpeGVkLnggPT09IHRydWUgfHwgbm9kZXNbbV0ub3B0aW9ucy5maXhlZC55ID09PSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgX2dldEVuZXJneTQgPSB0aGlzLl9nZXRFbmVyZ3kobSk7XG5cbiAgICAgICAgICAgIHZhciBfZ2V0RW5lcmd5NSA9IF9zbGljZWRUb0FycmF5KF9nZXRFbmVyZ3k0LCAzKTtcblxuICAgICAgICAgICAgdmFyIGRlbHRhX20gPSBfZ2V0RW5lcmd5NVswXTtcbiAgICAgICAgICAgIHZhciBkRV9keCA9IF9nZXRFbmVyZ3k1WzFdO1xuICAgICAgICAgICAgdmFyIGRFX2R5ID0gX2dldEVuZXJneTVbMl07XG5cbiAgICAgICAgICAgIGlmIChtYXhFbmVyZ3kgPCBkZWx0YV9tKSB7XG4gICAgICAgICAgICAgIG1heEVuZXJneSA9IGRlbHRhX207XG4gICAgICAgICAgICAgIG1heEVuZXJneU5vZGVJZCA9IG07XG4gICAgICAgICAgICAgIGRFX2R4X21heCA9IGRFX2R4O1xuICAgICAgICAgICAgICBkRV9keV9tYXggPSBkRV9keTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW21heEVuZXJneU5vZGVJZCwgbWF4RW5lcmd5LCBkRV9keF9tYXgsIGRFX2R5X21heF07XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogY2FsY3VsYXRlIHRoZSBlbmVyZ3kgb2YgYSBzaW5nbGUgbm9kZVxuICAgICAgICogQHBhcmFtIG1cbiAgICAgICAqIEByZXR1cm5zIHsqW119XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2dldEVuZXJneVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRFbmVyZ3kobSkge1xuICAgICAgICB2YXIgbm9kZXNBcnJheSA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcztcbiAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuXG4gICAgICAgIHZhciB4X20gPSBub2Rlc1ttXS54O1xuICAgICAgICB2YXIgeV9tID0gbm9kZXNbbV0ueTtcbiAgICAgICAgdmFyIGRFX2R4ID0gMDtcbiAgICAgICAgdmFyIGRFX2R5ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaUlkeCA9IDA7IGlJZHggPCBub2Rlc0FycmF5Lmxlbmd0aDsgaUlkeCsrKSB7XG4gICAgICAgICAgdmFyIGkgPSBub2Rlc0FycmF5W2lJZHhdO1xuICAgICAgICAgIGlmIChpICE9PSBtKSB7XG4gICAgICAgICAgICB2YXIgeF9pID0gbm9kZXNbaV0ueDtcbiAgICAgICAgICAgIHZhciB5X2kgPSBub2Rlc1tpXS55O1xuICAgICAgICAgICAgdmFyIGRlbm9taW5hdG9yID0gMS4wIC8gTWF0aC5zcXJ0KE1hdGgucG93KHhfbSAtIHhfaSwgMikgKyBNYXRoLnBvdyh5X20gLSB5X2ksIDIpKTtcbiAgICAgICAgICAgIGRFX2R4ICs9IHRoaXMuS19tYXRyaXhbbV1baV0gKiAoeF9tIC0geF9pIC0gdGhpcy5MX21hdHJpeFttXVtpXSAqICh4X20gLSB4X2kpICogZGVub21pbmF0b3IpO1xuICAgICAgICAgICAgZEVfZHkgKz0gdGhpcy5LX21hdHJpeFttXVtpXSAqICh5X20gLSB5X2kgLSB0aGlzLkxfbWF0cml4W21dW2ldICogKHlfbSAtIHlfaSkgKiBkZW5vbWluYXRvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlbHRhX20gPSBNYXRoLnNxcnQoTWF0aC5wb3coZEVfZHgsIDIpICsgTWF0aC5wb3coZEVfZHksIDIpKTtcbiAgICAgICAgcmV0dXJuIFtkZWx0YV9tLCBkRV9keCwgZEVfZHldO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIG1vdmUgdGhlIG5vZGUgYmFzZWQgb24gaXQncyBlbmVyZ3lcbiAgICAgICAqIHRoZSBkeCBhbmQgZHkgYXJlIGNhbGN1bGF0ZWQgZnJvbSB0aGUgbGluZWFyIHN5c3RlbSBwcm9wb3NlZCBieSBLYW1hZGEgYW5kIEthd2FpXG4gICAgICAgKiBAcGFyYW0gbVxuICAgICAgICogQHBhcmFtIGRFX2R4XG4gICAgICAgKiBAcGFyYW0gZEVfZHlcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfbW92ZU5vZGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbW92ZU5vZGUobSwgZEVfZHgsIGRFX2R5KSB7XG4gICAgICAgIHZhciBub2Rlc0FycmF5ID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzO1xuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICAgIHZhciBkMkVfZHgyID0gMDtcbiAgICAgICAgdmFyIGQyRV9keGR5ID0gMDtcbiAgICAgICAgdmFyIGQyRV9keTIgPSAwO1xuXG4gICAgICAgIHZhciB4X20gPSBub2Rlc1ttXS54O1xuICAgICAgICB2YXIgeV9tID0gbm9kZXNbbV0ueTtcbiAgICAgICAgZm9yICh2YXIgaUlkeCA9IDA7IGlJZHggPCBub2Rlc0FycmF5Lmxlbmd0aDsgaUlkeCsrKSB7XG4gICAgICAgICAgdmFyIGkgPSBub2Rlc0FycmF5W2lJZHhdO1xuICAgICAgICAgIGlmIChpICE9PSBtKSB7XG4gICAgICAgICAgICB2YXIgeF9pID0gbm9kZXNbaV0ueDtcbiAgICAgICAgICAgIHZhciB5X2kgPSBub2Rlc1tpXS55O1xuICAgICAgICAgICAgdmFyIGRlbm9taW5hdG9yID0gMS4wIC8gTWF0aC5wb3coTWF0aC5wb3coeF9tIC0geF9pLCAyKSArIE1hdGgucG93KHlfbSAtIHlfaSwgMiksIDEuNSk7XG4gICAgICAgICAgICBkMkVfZHgyICs9IHRoaXMuS19tYXRyaXhbbV1baV0gKiAoMSAtIHRoaXMuTF9tYXRyaXhbbV1baV0gKiBNYXRoLnBvdyh5X20gLSB5X2ksIDIpICogZGVub21pbmF0b3IpO1xuICAgICAgICAgICAgZDJFX2R4ZHkgKz0gdGhpcy5LX21hdHJpeFttXVtpXSAqICh0aGlzLkxfbWF0cml4W21dW2ldICogKHhfbSAtIHhfaSkgKiAoeV9tIC0geV9pKSAqIGRlbm9taW5hdG9yKTtcbiAgICAgICAgICAgIGQyRV9keTIgKz0gdGhpcy5LX21hdHJpeFttXVtpXSAqICgxIC0gdGhpcy5MX21hdHJpeFttXVtpXSAqIE1hdGgucG93KHhfbSAtIHhfaSwgMikgKiBkZW5vbWluYXRvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIG1ha2UgdGhlIHZhcmlhYmxlIG5hbWVzIGVhc2llciB0byBtYWtlIHRoZSBzb2x2aW5nIG9mIHRoZSBsaW5lYXIgc3lzdGVtIGVhc2llciB0byByZWFkXG4gICAgICAgIHZhciBBID0gZDJFX2R4MixcbiAgICAgICAgICAgIEIgPSBkMkVfZHhkeSxcbiAgICAgICAgICAgIEMgPSBkRV9keCxcbiAgICAgICAgICAgIEQgPSBkMkVfZHkyLFxuICAgICAgICAgICAgRSA9IGRFX2R5O1xuXG4gICAgICAgIC8vIHNvbHZlIHRoZSBsaW5lYXIgc3lzdGVtIGZvciBkeCBhbmQgZHlcbiAgICAgICAgdmFyIGR5ID0gKEMgLyBBICsgRSAvIEIpIC8gKEIgLyBBIC0gRCAvIEIpO1xuICAgICAgICB2YXIgZHggPSAtKEIgKiBkeSArIEMpIC8gQTtcblxuICAgICAgICAvLyBtb3ZlIHRoZSBub2RlXG4gICAgICAgIG5vZGVzW21dLnggKz0gZHg7XG4gICAgICAgIG5vZGVzW21dLnkgKz0gZHk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlIHRoZSBMIG1hdHJpeDogZWRnZSBsZW5ndGggdGltZXMgc2hvcnRlc3QgcGF0aFxuICAgICAgICogQHBhcmFtIERfbWF0cml4XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2NyZWF0ZUxfbWF0cml4XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUxfbWF0cml4KERfbWF0cml4KSB7XG4gICAgICAgIHZhciBub2Rlc0FycmF5ID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzO1xuICAgICAgICB2YXIgZWRnZUxlbmd0aCA9IHRoaXMuc3ByaW5nTGVuZ3RoO1xuXG4gICAgICAgIHRoaXMuTF9tYXRyaXggPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlc0FycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5MX21hdHJpeFtub2Rlc0FycmF5W2ldXSA9IHt9O1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm9kZXNBcnJheS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdGhpcy5MX21hdHJpeFtub2Rlc0FycmF5W2ldXVtub2Rlc0FycmF5W2pdXSA9IGVkZ2VMZW5ndGggKiBEX21hdHJpeFtub2Rlc0FycmF5W2ldXVtub2Rlc0FycmF5W2pdXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGUgdGhlIEsgbWF0cml4OiBzcHJpbmcgY29uc3RhbnRzIHRpbWVzIHNob3J0ZXN0IHBhdGhcbiAgICAgICAqIEBwYXJhbSBEX21hdHJpeFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9jcmVhdGVLX21hdHJpeFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVLX21hdHJpeChEX21hdHJpeCkge1xuICAgICAgICB2YXIgbm9kZXNBcnJheSA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcztcbiAgICAgICAgdmFyIGVkZ2VTdHJlbmd0aCA9IHRoaXMuc3ByaW5nQ29uc3RhbnQ7XG5cbiAgICAgICAgdGhpcy5LX21hdHJpeCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLktfbWF0cml4W25vZGVzQXJyYXlbaV1dID0ge307XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2Rlc0FycmF5Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB0aGlzLktfbWF0cml4W25vZGVzQXJyYXlbaV1dW25vZGVzQXJyYXlbal1dID0gZWRnZVN0cmVuZ3RoICogTWF0aC5wb3coRF9tYXRyaXhbbm9kZXNBcnJheVtpXV1bbm9kZXNBcnJheVtqXV0sIC0yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gS2FtYWRhS2F3YWk7XG4gIH0oKTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBLYW1hZGFLYXdhaTtcblxuLyoqKi8gfSxcbi8qIDExNiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVkIGJ5IEFsZXggb24gMTAtQXVnLTE1LlxuICAgKi9cblxuICB2YXIgRmxveWRXYXJzaGFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGbG95ZFdhcnNoYWxsKCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZsb3lkV2Fyc2hhbGwpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhGbG95ZFdhcnNoYWxsLCBbe1xuICAgICAga2V5OiBcImdldERpc3RhbmNlc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldERpc3RhbmNlcyhib2R5LCBub2Rlc0FycmF5LCBlZGdlc0FycmF5KSB7XG4gICAgICAgIHZhciBEX21hdHJpeCA9IHt9O1xuICAgICAgICB2YXIgZWRnZXMgPSBib2R5LmVkZ2VzO1xuXG4gICAgICAgIC8vIHByZXBhcmUgbWF0cml4IHdpdGggbGFyZ2UgbnVtYmVyc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBEX21hdHJpeFtub2Rlc0FycmF5W2ldXSA9IHt9O1xuICAgICAgICAgIERfbWF0cml4W25vZGVzQXJyYXlbaV1dID0ge307XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2Rlc0FycmF5Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBEX21hdHJpeFtub2Rlc0FycmF5W2ldXVtub2Rlc0FycmF5W2pdXSA9IGkgPT0gaiA/IDAgOiAxZTk7XG4gICAgICAgICAgICBEX21hdHJpeFtub2Rlc0FycmF5W2ldXVtub2Rlc0FycmF5W2pdXSA9IGkgPT0gaiA/IDAgOiAxZTk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHV0IHRoZSB3ZWlnaHRzIGZvciB0aGUgZWRnZXMgaW4uIFRoaXMgYXNzdW1lcyB1bmlkaXJlY3Rpb25hbGl0eS5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGVkZ2VzQXJyYXkubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tlZGdlc0FycmF5W19pXV07XG4gICAgICAgICAgLy8gZWRnZSBoYXMgdG8gYmUgY29ubmVjdGVkIGlmIGl0IGNvdW50cyB0byB0aGUgZGlzdGFuY2VzLiBJZiBpdCBpcyBjb25uZWN0ZWQgdG8gaW5uZXIgY2x1c3RlcnMgaXQgd2lsbCBjcmFzaCBzbyB3ZSBhbHNvIGNoZWNrIGlmIGl0IGlzIGluIHRoZSBEX21hdHJpeFxuICAgICAgICAgIGlmIChlZGdlLmNvbm5lY3RlZCA9PT0gdHJ1ZSAmJiBEX21hdHJpeFtlZGdlLmZyb21JZF0gIT09IHVuZGVmaW5lZCAmJiBEX21hdHJpeFtlZGdlLnRvSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIERfbWF0cml4W2VkZ2UuZnJvbUlkXVtlZGdlLnRvSWRdID0gMTtcbiAgICAgICAgICAgIERfbWF0cml4W2VkZ2UudG9JZF1bZWRnZS5mcm9tSWRdID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbm9kZUNvdW50ID0gbm9kZXNBcnJheS5sZW5ndGg7XG5cbiAgICAgICAgLy8gQWRhcHRlZCBGbG95ZFdhcnNoYWxsIGJhc2VkIG9uIHVuaWRpcmVjdGlvbmFsaXR5IHRvIGdyZWF0bHkgcmVkdWNlIGNvbXBsZXhpdHkuXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbm9kZUNvdW50OyBrKyspIHtcbiAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBub2RlQ291bnQgLSAxOyBfaTIrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgX2ogPSBfaTIgKyAxOyBfaiA8IG5vZGVDb3VudDsgX2orKykge1xuICAgICAgICAgICAgICBEX21hdHJpeFtub2Rlc0FycmF5W19pMl1dW25vZGVzQXJyYXlbX2pdXSA9IE1hdGgubWluKERfbWF0cml4W25vZGVzQXJyYXlbX2kyXV1bbm9kZXNBcnJheVtfal1dLCBEX21hdHJpeFtub2Rlc0FycmF5W19pMl1dW25vZGVzQXJyYXlba11dICsgRF9tYXRyaXhbbm9kZXNBcnJheVtrXV1bbm9kZXNBcnJheVtfal1dKTtcbiAgICAgICAgICAgICAgRF9tYXRyaXhbbm9kZXNBcnJheVtfal1dW25vZGVzQXJyYXlbX2kyXV0gPSBEX21hdHJpeFtub2Rlc0FycmF5W19pMl1dW25vZGVzQXJyYXlbX2pdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gRF9tYXRyaXg7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEZsb3lkV2Fyc2hhbGw7XG4gIH0oKTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBGbG95ZFdhcnNoYWxsO1xuXG4vKioqLyB9LFxuLyogMTE3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIENhbnZhcyBzaGFwZXMgdXNlZCBieSBOZXR3b3JrXG4gICAqL1xuICBpZiAodHlwZW9mIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCAhPT0gJ3VuZGVmaW5lZCcpIHtcblxuICAgIC8qKlxuICAgICAqIERyYXcgYSBjaXJjbGUgc2hhcGVcbiAgICAgKi9cbiAgICBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLmNpcmNsZSA9IGZ1bmN0aW9uICh4LCB5LCByKSB7XG4gICAgICB0aGlzLmJlZ2luUGF0aCgpO1xuICAgICAgdGhpcy5hcmMoeCwgeSwgciwgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERyYXcgYSBzcXVhcmUgc2hhcGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBob3Jpem9udGFsIGNlbnRlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IHZlcnRpY2FsIGNlbnRlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByICAgc2l6ZSwgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgc3F1YXJlXG4gICAgICovXG4gICAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5zcXVhcmUgPSBmdW5jdGlvbiAoeCwgeSwgcikge1xuICAgICAgdGhpcy5iZWdpblBhdGgoKTtcbiAgICAgIHRoaXMucmVjdCh4IC0gciwgeSAtIHIsIHIgKiAyLCByICogMik7XG4gICAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEcmF3IGEgdHJpYW5nbGUgc2hhcGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBob3Jpem9udGFsIGNlbnRlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IHZlcnRpY2FsIGNlbnRlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByICAgcmFkaXVzLCBoYWxmIHRoZSBsZW5ndGggb2YgdGhlIHNpZGVzIG9mIHRoZSB0cmlhbmdsZVxuICAgICAqL1xuICAgIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUudHJpYW5nbGUgPSBmdW5jdGlvbiAoeCwgeSwgcikge1xuICAgICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FcXVpbGF0ZXJhbF90cmlhbmdsZVxuICAgICAgdGhpcy5iZWdpblBhdGgoKTtcblxuICAgICAgLy8gdGhlIGNoYW5nZSBpbiByYWRpdXMgYW5kIHRoZSBvZmZzZXQgaXMgaGVyZSB0byBjZW50ZXIgdGhlIHNoYXBlXG4gICAgICByICo9IDEuMTU7XG4gICAgICB5ICs9IDAuMjc1ICogcjtcblxuICAgICAgdmFyIHMgPSByICogMjtcbiAgICAgIHZhciBzMiA9IHMgLyAyO1xuICAgICAgdmFyIGlyID0gTWF0aC5zcXJ0KDMpIC8gNiAqIHM7IC8vIHJhZGl1cyBvZiBpbm5lciBjaXJjbGVcbiAgICAgIHZhciBoID0gTWF0aC5zcXJ0KHMgKiBzIC0gczIgKiBzMik7IC8vIGhlaWdodFxuXG4gICAgICB0aGlzLm1vdmVUbyh4LCB5IC0gKGggLSBpcikpO1xuICAgICAgdGhpcy5saW5lVG8oeCArIHMyLCB5ICsgaXIpO1xuICAgICAgdGhpcy5saW5lVG8oeCAtIHMyLCB5ICsgaXIpO1xuICAgICAgdGhpcy5saW5lVG8oeCwgeSAtIChoIC0gaXIpKTtcbiAgICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERyYXcgYSB0cmlhbmdsZSBzaGFwZSBpbiBkb3dud2FyZCBvcmllbnRhdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IGhvcml6b250YWwgY2VudGVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgdmVydGljYWwgY2VudGVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHIgcmFkaXVzXG4gICAgICovXG4gICAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS50cmlhbmdsZURvd24gPSBmdW5jdGlvbiAoeCwgeSwgcikge1xuICAgICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FcXVpbGF0ZXJhbF90cmlhbmdsZVxuICAgICAgdGhpcy5iZWdpblBhdGgoKTtcblxuICAgICAgLy8gdGhlIGNoYW5nZSBpbiByYWRpdXMgYW5kIHRoZSBvZmZzZXQgaXMgaGVyZSB0byBjZW50ZXIgdGhlIHNoYXBlXG4gICAgICByICo9IDEuMTU7XG4gICAgICB5IC09IDAuMjc1ICogcjtcblxuICAgICAgdmFyIHMgPSByICogMjtcbiAgICAgIHZhciBzMiA9IHMgLyAyO1xuICAgICAgdmFyIGlyID0gTWF0aC5zcXJ0KDMpIC8gNiAqIHM7IC8vIHJhZGl1cyBvZiBpbm5lciBjaXJjbGVcbiAgICAgIHZhciBoID0gTWF0aC5zcXJ0KHMgKiBzIC0gczIgKiBzMik7IC8vIGhlaWdodFxuXG4gICAgICB0aGlzLm1vdmVUbyh4LCB5ICsgKGggLSBpcikpO1xuICAgICAgdGhpcy5saW5lVG8oeCArIHMyLCB5IC0gaXIpO1xuICAgICAgdGhpcy5saW5lVG8oeCAtIHMyLCB5IC0gaXIpO1xuICAgICAgdGhpcy5saW5lVG8oeCwgeSArIChoIC0gaXIpKTtcbiAgICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERyYXcgYSBzdGFyIHNoYXBlLCBhIHN0YXIgd2l0aCA1IHBvaW50c1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IGhvcml6b250YWwgY2VudGVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgdmVydGljYWwgY2VudGVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHIgICByYWRpdXMsIGhhbGYgdGhlIGxlbmd0aCBvZiB0aGUgc2lkZXMgb2YgdGhlIHRyaWFuZ2xlXG4gICAgICovXG4gICAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5zdGFyID0gZnVuY3Rpb24gKHgsIHksIHIpIHtcbiAgICAgIC8vIGh0dHA6Ly93d3cuaHRtbDVjYW52YXN0dXRvcmlhbHMuY29tL2xhYnMvaHRtbDUtY2FudmFzLXN0YXItc3Bpbm5lci9cbiAgICAgIHRoaXMuYmVnaW5QYXRoKCk7XG5cbiAgICAgIC8vIHRoZSBjaGFuZ2UgaW4gcmFkaXVzIGFuZCB0aGUgb2Zmc2V0IGlzIGhlcmUgdG8gY2VudGVyIHRoZSBzaGFwZVxuICAgICAgciAqPSAwLjgyO1xuICAgICAgeSArPSAwLjEgKiByO1xuXG4gICAgICBmb3IgKHZhciBuID0gMDsgbiA8IDEwOyBuKyspIHtcbiAgICAgICAgdmFyIHJhZGl1cyA9IG4gJSAyID09PSAwID8gciAqIDEuMyA6IHIgKiAwLjU7XG4gICAgICAgIHRoaXMubGluZVRvKHggKyByYWRpdXMgKiBNYXRoLnNpbihuICogMiAqIE1hdGguUEkgLyAxMCksIHkgLSByYWRpdXMgKiBNYXRoLmNvcyhuICogMiAqIE1hdGguUEkgLyAxMCkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEcmF3IGEgRGlhbW9uZCBzaGFwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IGhvcml6b250YWwgY2VudGVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgdmVydGljYWwgY2VudGVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHIgICByYWRpdXMsIGhhbGYgdGhlIGxlbmd0aCBvZiB0aGUgc2lkZXMgb2YgdGhlIHRyaWFuZ2xlXG4gICAgICovXG4gICAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5kaWFtb25kID0gZnVuY3Rpb24gKHgsIHksIHIpIHtcbiAgICAgIC8vIGh0dHA6Ly93d3cuaHRtbDVjYW52YXN0dXRvcmlhbHMuY29tL2xhYnMvaHRtbDUtY2FudmFzLXN0YXItc3Bpbm5lci9cbiAgICAgIHRoaXMuYmVnaW5QYXRoKCk7XG5cbiAgICAgIHRoaXMubGluZVRvKHgsIHkgKyByKTtcbiAgICAgIHRoaXMubGluZVRvKHggKyByLCB5KTtcbiAgICAgIHRoaXMubGluZVRvKHgsIHkgLSByKTtcbiAgICAgIHRoaXMubGluZVRvKHggLSByLCB5KTtcblxuICAgICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMjU1NTEyL2hvdy10by1kcmF3LWEtcm91bmRlZC1yZWN0YW5nbGUtb24taHRtbC1jYW52YXNcbiAgICAgKi9cbiAgICBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLnJvdW5kUmVjdCA9IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCByKSB7XG4gICAgICB2YXIgcjJkID0gTWF0aC5QSSAvIDE4MDtcbiAgICAgIGlmICh3IC0gMiAqIHIgPCAwKSB7XG4gICAgICAgIHIgPSB3IC8gMjtcbiAgICAgIH0gLy9lbnN1cmUgdGhhdCB0aGUgcmFkaXVzIGlzbid0IHRvbyBsYXJnZSBmb3IgeFxuICAgICAgaWYgKGggLSAyICogciA8IDApIHtcbiAgICAgICAgciA9IGggLyAyO1xuICAgICAgfSAvL2Vuc3VyZSB0aGF0IHRoZSByYWRpdXMgaXNuJ3QgdG9vIGxhcmdlIGZvciB5XG4gICAgICB0aGlzLmJlZ2luUGF0aCgpO1xuICAgICAgdGhpcy5tb3ZlVG8oeCArIHIsIHkpO1xuICAgICAgdGhpcy5saW5lVG8oeCArIHcgLSByLCB5KTtcbiAgICAgIHRoaXMuYXJjKHggKyB3IC0gciwgeSArIHIsIHIsIHIyZCAqIDI3MCwgcjJkICogMzYwLCBmYWxzZSk7XG4gICAgICB0aGlzLmxpbmVUbyh4ICsgdywgeSArIGggLSByKTtcbiAgICAgIHRoaXMuYXJjKHggKyB3IC0gciwgeSArIGggLSByLCByLCAwLCByMmQgKiA5MCwgZmFsc2UpO1xuICAgICAgdGhpcy5saW5lVG8oeCArIHIsIHkgKyBoKTtcbiAgICAgIHRoaXMuYXJjKHggKyByLCB5ICsgaCAtIHIsIHIsIHIyZCAqIDkwLCByMmQgKiAxODAsIGZhbHNlKTtcbiAgICAgIHRoaXMubGluZVRvKHgsIHkgKyByKTtcbiAgICAgIHRoaXMuYXJjKHggKyByLCB5ICsgciwgciwgcjJkICogMTgwLCByMmQgKiAyNzAsIGZhbHNlKTtcbiAgICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjE3Mjc5OC9ob3ctdG8tZHJhdy1hbi1vdmFsLWluLWh0bWw1LWNhbnZhc1xuICAgICAqL1xuICAgIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuZWxsaXBzZSA9IGZ1bmN0aW9uICh4LCB5LCB3LCBoKSB7XG4gICAgICB2YXIga2FwcGEgPSAuNTUyMjg0OCxcbiAgICAgICAgICBveCA9IHcgLyAyICoga2FwcGEsXG4gICAgICAgICAgLy8gY29udHJvbCBwb2ludCBvZmZzZXQgaG9yaXpvbnRhbFxuICAgICAgb3kgPSBoIC8gMiAqIGthcHBhLFxuICAgICAgICAgIC8vIGNvbnRyb2wgcG9pbnQgb2Zmc2V0IHZlcnRpY2FsXG4gICAgICB4ZSA9IHggKyB3LFxuICAgICAgICAgIC8vIHgtZW5kXG4gICAgICB5ZSA9IHkgKyBoLFxuICAgICAgICAgIC8vIHktZW5kXG4gICAgICB4bSA9IHggKyB3IC8gMixcbiAgICAgICAgICAvLyB4LW1pZGRsZVxuICAgICAgeW0gPSB5ICsgaCAvIDI7IC8vIHktbWlkZGxlXG5cbiAgICAgIHRoaXMuYmVnaW5QYXRoKCk7XG4gICAgICB0aGlzLm1vdmVUbyh4LCB5bSk7XG4gICAgICB0aGlzLmJlemllckN1cnZlVG8oeCwgeW0gLSBveSwgeG0gLSBveCwgeSwgeG0sIHkpO1xuICAgICAgdGhpcy5iZXppZXJDdXJ2ZVRvKHhtICsgb3gsIHksIHhlLCB5bSAtIG95LCB4ZSwgeW0pO1xuICAgICAgdGhpcy5iZXppZXJDdXJ2ZVRvKHhlLCB5bSArIG95LCB4bSArIG94LCB5ZSwgeG0sIHllKTtcbiAgICAgIHRoaXMuYmV6aWVyQ3VydmVUbyh4bSAtIG94LCB5ZSwgeCwgeW0gKyBveSwgeCwgeW0pO1xuICAgICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMTcyNzk4L2hvdy10by1kcmF3LWFuLW92YWwtaW4taHRtbDUtY2FudmFzXG4gICAgICovXG4gICAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5kYXRhYmFzZSA9IGZ1bmN0aW9uICh4LCB5LCB3LCBoKSB7XG4gICAgICB2YXIgZiA9IDEgLyAzO1xuICAgICAgdmFyIHdFbGxpcHNlID0gdztcbiAgICAgIHZhciBoRWxsaXBzZSA9IGggKiBmO1xuXG4gICAgICB2YXIga2FwcGEgPSAuNTUyMjg0OCxcbiAgICAgICAgICBveCA9IHdFbGxpcHNlIC8gMiAqIGthcHBhLFxuICAgICAgICAgIC8vIGNvbnRyb2wgcG9pbnQgb2Zmc2V0IGhvcml6b250YWxcbiAgICAgIG95ID0gaEVsbGlwc2UgLyAyICoga2FwcGEsXG4gICAgICAgICAgLy8gY29udHJvbCBwb2ludCBvZmZzZXQgdmVydGljYWxcbiAgICAgIHhlID0geCArIHdFbGxpcHNlLFxuICAgICAgICAgIC8vIHgtZW5kXG4gICAgICB5ZSA9IHkgKyBoRWxsaXBzZSxcbiAgICAgICAgICAvLyB5LWVuZFxuICAgICAgeG0gPSB4ICsgd0VsbGlwc2UgLyAyLFxuICAgICAgICAgIC8vIHgtbWlkZGxlXG4gICAgICB5bSA9IHkgKyBoRWxsaXBzZSAvIDIsXG4gICAgICAgICAgLy8geS1taWRkbGVcbiAgICAgIHltYiA9IHkgKyAoaCAtIGhFbGxpcHNlIC8gMiksXG4gICAgICAgICAgLy8geS1taWRsbGUsIGJvdHRvbSBlbGxpcHNlXG4gICAgICB5ZWIgPSB5ICsgaDsgLy8geS1lbmQsIGJvdHRvbSBlbGxpcHNlXG5cbiAgICAgIHRoaXMuYmVnaW5QYXRoKCk7XG4gICAgICB0aGlzLm1vdmVUbyh4ZSwgeW0pO1xuXG4gICAgICB0aGlzLmJlemllckN1cnZlVG8oeGUsIHltICsgb3ksIHhtICsgb3gsIHllLCB4bSwgeWUpO1xuICAgICAgdGhpcy5iZXppZXJDdXJ2ZVRvKHhtIC0gb3gsIHllLCB4LCB5bSArIG95LCB4LCB5bSk7XG5cbiAgICAgIHRoaXMuYmV6aWVyQ3VydmVUbyh4LCB5bSAtIG95LCB4bSAtIG94LCB5LCB4bSwgeSk7XG4gICAgICB0aGlzLmJlemllckN1cnZlVG8oeG0gKyBveCwgeSwgeGUsIHltIC0gb3ksIHhlLCB5bSk7XG5cbiAgICAgIHRoaXMubGluZVRvKHhlLCB5bWIpO1xuXG4gICAgICB0aGlzLmJlemllckN1cnZlVG8oeGUsIHltYiArIG95LCB4bSArIG94LCB5ZWIsIHhtLCB5ZWIpO1xuICAgICAgdGhpcy5iZXppZXJDdXJ2ZVRvKHhtIC0gb3gsIHllYiwgeCwgeW1iICsgb3ksIHgsIHltYik7XG5cbiAgICAgIHRoaXMubGluZVRvKHgsIHltKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRHJhdyBhbiBhcnJvdyBwb2ludCAobm8gbGluZSlcbiAgICAgKi9cbiAgICBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLmFycm93ID0gZnVuY3Rpb24gKHgsIHksIGFuZ2xlLCBsZW5ndGgpIHtcbiAgICAgIC8vIHRhaWxcbiAgICAgIHZhciB4dCA9IHggLSBsZW5ndGggKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICB2YXIgeXQgPSB5IC0gbGVuZ3RoICogTWF0aC5zaW4oYW5nbGUpO1xuXG4gICAgICAvLyBpbm5lciB0YWlsXG4gICAgICB2YXIgeGkgPSB4IC0gbGVuZ3RoICogMC45ICogTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgdmFyIHlpID0geSAtIGxlbmd0aCAqIDAuOSAqIE1hdGguc2luKGFuZ2xlKTtcblxuICAgICAgLy8gbGVmdFxuICAgICAgdmFyIHhsID0geHQgKyBsZW5ndGggLyAzICogTWF0aC5jb3MoYW5nbGUgKyAwLjUgKiBNYXRoLlBJKTtcbiAgICAgIHZhciB5bCA9IHl0ICsgbGVuZ3RoIC8gMyAqIE1hdGguc2luKGFuZ2xlICsgMC41ICogTWF0aC5QSSk7XG5cbiAgICAgIC8vIHJpZ2h0XG4gICAgICB2YXIgeHIgPSB4dCArIGxlbmd0aCAvIDMgKiBNYXRoLmNvcyhhbmdsZSAtIDAuNSAqIE1hdGguUEkpO1xuICAgICAgdmFyIHlyID0geXQgKyBsZW5ndGggLyAzICogTWF0aC5zaW4oYW5nbGUgLSAwLjUgKiBNYXRoLlBJKTtcblxuICAgICAgdGhpcy5iZWdpblBhdGgoKTtcbiAgICAgIHRoaXMubW92ZVRvKHgsIHkpO1xuICAgICAgdGhpcy5saW5lVG8oeGwsIHlsKTtcbiAgICAgIHRoaXMubGluZVRvKHhpLCB5aSk7XG4gICAgICB0aGlzLmxpbmVUbyh4ciwgeXIpO1xuICAgICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB1cCB0aGUgZGFzaGVkTGluZSBmdW5jdGlvbmFsaXR5IGZvciBkcmF3aW5nXG4gICAgICogT3JpZ2luYWwgY29kZSBjYW1lIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80NTc2NzI0L2RvdHRlZC1zdHJva2UtaW4tY2FudmFzXG4gICAgICogQGF1dGhvciBEYXZpZCBKb3JkYW5cbiAgICAgKiBAZGF0ZSAyMDEyLTA4LTA4XG4gICAgICovXG4gICAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5kYXNoZWRMaW5lID0gZnVuY3Rpb24gKHgsIHksIHgyLCB5MiwgcGF0dGVybikge1xuICAgICAgdGhpcy5iZWdpblBhdGgoKTtcbiAgICAgIHRoaXMubW92ZVRvKHgsIHkpO1xuXG4gICAgICB2YXIgcGF0dGVybkxlbmd0aCA9IHBhdHRlcm4ubGVuZ3RoO1xuICAgICAgdmFyIGR4ID0geDIgLSB4O1xuICAgICAgdmFyIGR5ID0geTIgLSB5O1xuICAgICAgdmFyIHNsb3BlID0gZHkgLyBkeDtcbiAgICAgIHZhciBkaXN0UmVtYWluaW5nID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgIHZhciBwYXR0ZXJuSW5kZXggPSAwO1xuICAgICAgdmFyIGRyYXcgPSB0cnVlO1xuICAgICAgdmFyIHhTdGVwID0gMDtcbiAgICAgIHZhciBkYXNoTGVuZ3RoID0gcGF0dGVyblswXTtcblxuICAgICAgd2hpbGUgKGRpc3RSZW1haW5pbmcgPj0gMC4xKSB7XG4gICAgICAgIGRhc2hMZW5ndGggPSBwYXR0ZXJuW3BhdHRlcm5JbmRleCsrICUgcGF0dGVybkxlbmd0aF07XG4gICAgICAgIGlmIChkYXNoTGVuZ3RoID4gZGlzdFJlbWFpbmluZykge1xuICAgICAgICAgIGRhc2hMZW5ndGggPSBkaXN0UmVtYWluaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgeFN0ZXAgPSBNYXRoLnNxcnQoZGFzaExlbmd0aCAqIGRhc2hMZW5ndGggLyAoMSArIHNsb3BlICogc2xvcGUpKTtcbiAgICAgICAgeFN0ZXAgPSBkeCA8IDAgPyAteFN0ZXAgOiB4U3RlcDtcbiAgICAgICAgeCArPSB4U3RlcDtcbiAgICAgICAgeSArPSBzbG9wZSAqIHhTdGVwO1xuXG4gICAgICAgIGlmIChkcmF3ID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5saW5lVG8oeCwgeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5tb3ZlVG8oeCwgeSk7XG4gICAgICAgIH1cblxuICAgICAgICBkaXN0UmVtYWluaW5nIC09IGRhc2hMZW5ndGg7XG4gICAgICAgIGRyYXcgPSAhZHJhdztcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbi8qKiovIH0sXG4vKiAxMTggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogUGFyc2UgYSB0ZXh0IHNvdXJjZSBjb250YWluaW5nIGRhdGEgaW4gRE9UIGxhbmd1YWdlIGludG8gYSBKU09OIG9iamVjdC5cbiAgICogVGhlIG9iamVjdCBjb250YWlucyB0d28gbGlzdHM6IG9uZSB3aXRoIG5vZGVzIGFuZCBvbmUgd2l0aCBlZGdlcy5cbiAgICpcbiAgICogRE9UIGxhbmd1YWdlIHJlZmVyZW5jZTogaHR0cDovL3d3dy5ncmFwaHZpei5vcmcvZG9jL2luZm8vbGFuZy5odG1sXG4gICAqXG4gICAqIERPVCBsYW5ndWFnZSBhdHRyaWJ1dGVzOiBodHRwOi8vZ3JhcGh2aXoub3JnL2NvbnRlbnQvYXR0cnNcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgICAgIFRleHQgY29udGFpbmluZyBhIGdyYXBoIGluIERPVC1ub3RhdGlvblxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGdyYXBoICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdHdvIHBhcmFtZXRlcnM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0W119IG5vZGVzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0W119IGVkZ2VzXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZURPVChkYXRhKSB7XG4gICAgZG90ID0gZGF0YTtcbiAgICByZXR1cm4gcGFyc2VHcmFwaCgpO1xuICB9XG5cbiAgLy8gbWFwcGluZyBvZiBhdHRyaWJ1dGVzIGZyb20gRE9UICh0aGUga2V5cykgdG8gdmlzLmpzICh0aGUgdmFsdWVzKVxuICB2YXIgTk9ERV9BVFRSX01BUFBJTkcgPSB7XG4gICAgJ2ZvbnRzaXplJzogJ2ZvbnQuc2l6ZScsXG4gICAgJ2ZvbnRjb2xvcic6ICdmb250LmNvbG9yJyxcbiAgICAnbGFiZWxmb250Y29sb3InOiAnZm9udC5jb2xvcicsXG4gICAgJ2ZvbnRuYW1lJzogJ2ZvbnQuZmFjZScsXG4gICAgJ2NvbG9yJzogWydjb2xvci5ib3JkZXInLCAnY29sb3IuYmFja2dyb3VuZCddLFxuICAgICdmaWxsY29sb3InOiAnY29sb3IuYmFja2dyb3VuZCcsXG4gICAgJ3Rvb2x0aXAnOiAndGl0bGUnLFxuICAgICdsYWJlbHRvb2x0aXAnOiAndGl0bGUnXG4gIH07XG4gIHZhciBFREdFX0FUVFJfTUFQUElORyA9IE9iamVjdC5jcmVhdGUoTk9ERV9BVFRSX01BUFBJTkcpO1xuICBFREdFX0FUVFJfTUFQUElORy5jb2xvciA9ICdjb2xvci5jb2xvcic7XG5cbiAgLy8gdG9rZW4gdHlwZXMgZW51bWVyYXRpb25cbiAgdmFyIFRPS0VOVFlQRSA9IHtcbiAgICBOVUxMOiAwLFxuICAgIERFTElNSVRFUjogMSxcbiAgICBJREVOVElGSUVSOiAyLFxuICAgIFVOS05PV046IDNcbiAgfTtcblxuICAvLyBtYXAgd2l0aCBhbGwgZGVsaW1pdGVyc1xuICB2YXIgREVMSU1JVEVSUyA9IHtcbiAgICAneyc6IHRydWUsXG4gICAgJ30nOiB0cnVlLFxuICAgICdbJzogdHJ1ZSxcbiAgICAnXSc6IHRydWUsXG4gICAgJzsnOiB0cnVlLFxuICAgICc9JzogdHJ1ZSxcbiAgICAnLCc6IHRydWUsXG5cbiAgICAnLT4nOiB0cnVlLFxuICAgICctLSc6IHRydWVcbiAgfTtcblxuICB2YXIgZG90ID0gJyc7IC8vIGN1cnJlbnQgZG90IGZpbGVcbiAgdmFyIGluZGV4ID0gMDsgLy8gY3VycmVudCBpbmRleCBpbiBkb3QgZmlsZVxuICB2YXIgYyA9ICcnOyAvLyBjdXJyZW50IHRva2VuIGNoYXJhY3RlciBpbiBleHByXG4gIHZhciB0b2tlbiA9ICcnOyAvLyBjdXJyZW50IHRva2VuXG4gIHZhciB0b2tlblR5cGUgPSBUT0tFTlRZUEUuTlVMTDsgLy8gdHlwZSBvZiB0aGUgdG9rZW5cblxuICAvKipcbiAgICogR2V0IHRoZSBmaXJzdCBjaGFyYWN0ZXIgZnJvbSB0aGUgZG90IGZpbGUuXG4gICAqIFRoZSBjaGFyYWN0ZXIgaXMgc3RvcmVkIGludG8gdGhlIGNoYXIgYy4gSWYgdGhlIGVuZCBvZiB0aGUgZG90IGZpbGUgaXNcbiAgICogcmVhY2hlZCwgdGhlIGZ1bmN0aW9uIHB1dHMgYW4gZW1wdHkgc3RyaW5nIGluIGMuXG4gICAqL1xuICBmdW5jdGlvbiBmaXJzdCgpIHtcbiAgICBpbmRleCA9IDA7XG4gICAgYyA9IGRvdC5jaGFyQXQoMCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBuZXh0IGNoYXJhY3RlciBmcm9tIHRoZSBkb3QgZmlsZS5cbiAgICogVGhlIGNoYXJhY3RlciBpcyBzdG9yZWQgaW50byB0aGUgY2hhciBjLiBJZiB0aGUgZW5kIG9mIHRoZSBkb3QgZmlsZSBpc1xuICAgKiByZWFjaGVkLCB0aGUgZnVuY3Rpb24gcHV0cyBhbiBlbXB0eSBzdHJpbmcgaW4gYy5cbiAgICovXG4gIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgaW5kZXgrKztcbiAgICBjID0gZG90LmNoYXJBdChpbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogUHJldmlldyB0aGUgbmV4dCBjaGFyYWN0ZXIgZnJvbSB0aGUgZG90IGZpbGUuXG4gICAqIEByZXR1cm4ge1N0cmluZ30gY05leHRcbiAgICovXG4gIGZ1bmN0aW9uIG5leHRQcmV2aWV3KCkge1xuICAgIHJldHVybiBkb3QuY2hhckF0KGluZGV4ICsgMSk7XG4gIH1cblxuICAvKipcbiAgICogVGVzdCB3aGV0aGVyIGdpdmVuIGNoYXJhY3RlciBpcyBhbHBoYWJldGljIG9yIG51bWVyaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gaXNBbHBoYU51bWVyaWNcbiAgICovXG4gIHZhciByZWdleEFscGhhTnVtZXJpYyA9IC9bYS16QS1aXzAtOS46I10vO1xuICBmdW5jdGlvbiBpc0FscGhhTnVtZXJpYyhjKSB7XG4gICAgcmV0dXJuIHJlZ2V4QWxwaGFOdW1lcmljLnRlc3QoYyk7XG4gIH1cblxuICAvKipcbiAgICogTWVyZ2UgYWxsIG9wdGlvbnMgb2Ygb2JqZWN0IGIgaW50byBvYmplY3QgYlxuICAgKiBAcGFyYW0ge09iamVjdH0gYVxuICAgKiBAcGFyYW0ge09iamVjdH0gYlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGFcbiAgICovXG4gIGZ1bmN0aW9uIG1lcmdlKGEsIGIpIHtcbiAgICBpZiAoIWEpIHtcbiAgICAgIGEgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAoYikge1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBiKSB7XG4gICAgICAgIGlmIChiLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgYVtuYW1lXSA9IGJbbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGEgdmFsdWUgaW4gYW4gb2JqZWN0LCB3aGVyZSB0aGUgcHJvdmlkZWQgcGFyYW1ldGVyIG5hbWUgY2FuIGJlIGFcbiAgICogcGF0aCB3aXRoIG5lc3RlZCBwYXJhbWV0ZXJzLiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogICAgIHZhciBvYmogPSB7YTogMn07XG4gICAqICAgICBzZXRWYWx1ZShvYmosICdiLmMnLCAzKTsgICAgIC8vIG9iaiA9IHthOiAyLCBiOiB7YzogM319XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGggIEEgcGFyYW1ldGVyIG5hbWUgb3IgZG90LXNlcGFyYXRlZCBwYXJhbWV0ZXIgcGF0aCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgbGlrZSBcImNvbG9yLmhpZ2hsaWdodC5ib3JkZXJcIi5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKi9cbiAgZnVuY3Rpb24gc2V0VmFsdWUob2JqLCBwYXRoLCB2YWx1ZSkge1xuICAgIHZhciBrZXlzID0gcGF0aC5zcGxpdCgnLicpO1xuICAgIHZhciBvID0gb2JqO1xuICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgdmFyIGtleSA9IGtleXMuc2hpZnQoKTtcbiAgICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgICAvLyB0aGlzIGlzbid0IHRoZSBlbmQgcG9pbnRcbiAgICAgICAgaWYgKCFvW2tleV0pIHtcbiAgICAgICAgICBvW2tleV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBvID0gb1trZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgZW5kIHBvaW50XG4gICAgICAgIG9ba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBub2RlIHRvIGEgZ3JhcGggb2JqZWN0LiBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgbm9kZSB3aXRoXG4gICAqIHRoZSBzYW1lIGlkLCB0aGVpciBhdHRyaWJ1dGVzIHdpbGwgYmUgbWVyZ2VkLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZ3JhcGhcbiAgICogQHBhcmFtIHtPYmplY3R9IG5vZGVcbiAgICovXG4gIGZ1bmN0aW9uIGFkZE5vZGUoZ3JhcGgsIG5vZGUpIHtcbiAgICB2YXIgaSwgbGVuO1xuICAgIHZhciBjdXJyZW50ID0gbnVsbDtcblxuICAgIC8vIGZpbmQgcm9vdCBncmFwaCAoaW4gY2FzZSBvZiBzdWJncmFwaClcbiAgICB2YXIgZ3JhcGhzID0gW2dyYXBoXTsgLy8gbGlzdCB3aXRoIGFsbCBncmFwaHMgZnJvbSBjdXJyZW50IGdyYXBoIHRvIHJvb3QgZ3JhcGhcbiAgICB2YXIgcm9vdCA9IGdyYXBoO1xuICAgIHdoaWxlIChyb290LnBhcmVudCkge1xuICAgICAgZ3JhcGhzLnB1c2gocm9vdC5wYXJlbnQpO1xuICAgICAgcm9vdCA9IHJvb3QucGFyZW50O1xuICAgIH1cblxuICAgIC8vIGZpbmQgZXhpc3Rpbmcgbm9kZSAoYXQgcm9vdCBsZXZlbCkgYnkgaXRzIGlkXG4gICAgaWYgKHJvb3Qubm9kZXMpIHtcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJvb3Qubm9kZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKG5vZGUuaWQgPT09IHJvb3Qubm9kZXNbaV0uaWQpIHtcbiAgICAgICAgICBjdXJyZW50ID0gcm9vdC5ub2Rlc1tpXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghY3VycmVudCkge1xuICAgICAgLy8gdGhpcyBpcyBhIG5ldyBub2RlXG4gICAgICBjdXJyZW50ID0ge1xuICAgICAgICBpZDogbm9kZS5pZFxuICAgICAgfTtcbiAgICAgIGlmIChncmFwaC5ub2RlKSB7XG4gICAgICAgIC8vIGNsb25lIGRlZmF1bHQgYXR0cmlidXRlc1xuICAgICAgICBjdXJyZW50LmF0dHIgPSBtZXJnZShjdXJyZW50LmF0dHIsIGdyYXBoLm5vZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFkZCBub2RlIHRvIHRoaXMgKHN1YilncmFwaCBhbmQgYWxsIGl0cyBwYXJlbnQgZ3JhcGhzXG4gICAgZm9yIChpID0gZ3JhcGhzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZyA9IGdyYXBoc1tpXTtcblxuICAgICAgaWYgKCFnLm5vZGVzKSB7XG4gICAgICAgIGcubm9kZXMgPSBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChnLm5vZGVzLmluZGV4T2YoY3VycmVudCkgPT09IC0xKSB7XG4gICAgICAgIGcubm9kZXMucHVzaChjdXJyZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBtZXJnZSBhdHRyaWJ1dGVzXG4gICAgaWYgKG5vZGUuYXR0cikge1xuICAgICAgY3VycmVudC5hdHRyID0gbWVyZ2UoY3VycmVudC5hdHRyLCBub2RlLmF0dHIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYW4gZWRnZSB0byBhIGdyYXBoIG9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gZ3JhcGhcbiAgICogQHBhcmFtIHtPYmplY3R9IGVkZ2VcbiAgICovXG4gIGZ1bmN0aW9uIGFkZEVkZ2UoZ3JhcGgsIGVkZ2UpIHtcbiAgICBpZiAoIWdyYXBoLmVkZ2VzKSB7XG4gICAgICBncmFwaC5lZGdlcyA9IFtdO1xuICAgIH1cbiAgICBncmFwaC5lZGdlcy5wdXNoKGVkZ2UpO1xuICAgIGlmIChncmFwaC5lZGdlKSB7XG4gICAgICB2YXIgYXR0ciA9IG1lcmdlKHt9LCBncmFwaC5lZGdlKTsgLy8gY2xvbmUgZGVmYXVsdCBhdHRyaWJ1dGVzXG4gICAgICBlZGdlLmF0dHIgPSBtZXJnZShhdHRyLCBlZGdlLmF0dHIpOyAvLyBtZXJnZSBhdHRyaWJ1dGVzXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBlZGdlIHRvIGEgZ3JhcGggb2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBncmFwaFxuICAgKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlciB8IE9iamVjdH0gZnJvbVxuICAgKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlciB8IE9iamVjdH0gdG9cbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtPYmplY3QgfCBudWxsfSBhdHRyXG4gICAqIEByZXR1cm4ge09iamVjdH0gZWRnZVxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlRWRnZShncmFwaCwgZnJvbSwgdG8sIHR5cGUsIGF0dHIpIHtcbiAgICB2YXIgZWRnZSA9IHtcbiAgICAgIGZyb206IGZyb20sXG4gICAgICB0bzogdG8sXG4gICAgICB0eXBlOiB0eXBlXG4gICAgfTtcblxuICAgIGlmIChncmFwaC5lZGdlKSB7XG4gICAgICBlZGdlLmF0dHIgPSBtZXJnZSh7fSwgZ3JhcGguZWRnZSk7IC8vIGNsb25lIGRlZmF1bHQgYXR0cmlidXRlc1xuICAgIH1cbiAgICBlZGdlLmF0dHIgPSBtZXJnZShlZGdlLmF0dHIgfHwge30sIGF0dHIpOyAvLyBtZXJnZSBhdHRyaWJ1dGVzXG5cbiAgICByZXR1cm4gZWRnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgbmV4dCB0b2tlbiBpbiB0aGUgY3VycmVudCBkb3QgZmlsZS5cbiAgICogVGhlIHRva2VuIGFuZCB0b2tlbiB0eXBlIGFyZSBhdmFpbGFibGUgYXMgdG9rZW4gYW5kIHRva2VuVHlwZVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0VG9rZW4oKSB7XG4gICAgdG9rZW5UeXBlID0gVE9LRU5UWVBFLk5VTEw7XG4gICAgdG9rZW4gPSAnJztcblxuICAgIC8vIHNraXAgb3ZlciB3aGl0ZXNwYWNlc1xuICAgIHdoaWxlIChjID09PSAnICcgfHwgYyA9PT0gJ1xcdCcgfHwgYyA9PT0gJ1xcbicgfHwgYyA9PT0gJ1xccicpIHtcbiAgICAgIC8vIHNwYWNlLCB0YWIsIGVudGVyXG4gICAgICBuZXh0KCk7XG4gICAgfVxuXG4gICAgZG8ge1xuICAgICAgdmFyIGlzQ29tbWVudCA9IGZhbHNlO1xuXG4gICAgICAvLyBza2lwIGNvbW1lbnRcbiAgICAgIGlmIChjID09PSAnIycpIHtcbiAgICAgICAgLy8gZmluZCB0aGUgcHJldmlvdXMgbm9uLXNwYWNlIGNoYXJhY3RlclxuICAgICAgICB2YXIgaSA9IGluZGV4IC0gMTtcbiAgICAgICAgd2hpbGUgKGRvdC5jaGFyQXQoaSkgPT09ICcgJyB8fCBkb3QuY2hhckF0KGkpID09PSAnXFx0Jykge1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZG90LmNoYXJBdChpKSA9PT0gJ1xcbicgfHwgZG90LmNoYXJBdChpKSA9PT0gJycpIHtcbiAgICAgICAgICAvLyB0aGUgIyBpcyBhdCB0aGUgc3RhcnQgb2YgYSBsaW5lLCB0aGlzIGlzIGluZGVlZCBhIGxpbmUgY29tbWVudFxuICAgICAgICAgIHdoaWxlIChjICE9ICcnICYmIGMgIT0gJ1xcbicpIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXNDb21tZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGMgPT09ICcvJyAmJiBuZXh0UHJldmlldygpID09PSAnLycpIHtcbiAgICAgICAgLy8gc2tpcCBsaW5lIGNvbW1lbnRcbiAgICAgICAgd2hpbGUgKGMgIT0gJycgJiYgYyAhPSAnXFxuJykge1xuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpc0NvbW1lbnQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGMgPT09ICcvJyAmJiBuZXh0UHJldmlldygpID09PSAnKicpIHtcbiAgICAgICAgLy8gc2tpcCBibG9jayBjb21tZW50XG4gICAgICAgIHdoaWxlIChjICE9ICcnKSB7XG4gICAgICAgICAgaWYgKGMgPT09ICcqJyAmJiBuZXh0UHJldmlldygpID09PSAnLycpIHtcbiAgICAgICAgICAgIC8vIGVuZCBvZiBibG9jayBjb21tZW50IGZvdW5kLiBza2lwIHRoZXNlIGxhc3QgdHdvIGNoYXJhY3RlcnNcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlzQ29tbWVudCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHNraXAgb3ZlciB3aGl0ZXNwYWNlc1xuICAgICAgd2hpbGUgKGMgPT09ICcgJyB8fCBjID09PSAnXFx0JyB8fCBjID09PSAnXFxuJyB8fCBjID09PSAnXFxyJykge1xuICAgICAgICAvLyBzcGFjZSwgdGFiLCBlbnRlclxuICAgICAgICBuZXh0KCk7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoaXNDb21tZW50KTtcblxuICAgIC8vIGNoZWNrIGZvciBlbmQgb2YgZG90IGZpbGVcbiAgICBpZiAoYyA9PT0gJycpIHtcbiAgICAgIC8vIHRva2VuIGlzIHN0aWxsIGVtcHR5XG4gICAgICB0b2tlblR5cGUgPSBUT0tFTlRZUEUuREVMSU1JVEVSO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGZvciBkZWxpbWl0ZXJzIGNvbnNpc3Rpbmcgb2YgMiBjaGFyYWN0ZXJzXG4gICAgdmFyIGMyID0gYyArIG5leHRQcmV2aWV3KCk7XG4gICAgaWYgKERFTElNSVRFUlNbYzJdKSB7XG4gICAgICB0b2tlblR5cGUgPSBUT0tFTlRZUEUuREVMSU1JVEVSO1xuICAgICAgdG9rZW4gPSBjMjtcbiAgICAgIG5leHQoKTtcbiAgICAgIG5leHQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBmb3IgZGVsaW1pdGVycyBjb25zaXN0aW5nIG9mIDEgY2hhcmFjdGVyXG4gICAgaWYgKERFTElNSVRFUlNbY10pIHtcbiAgICAgIHRva2VuVHlwZSA9IFRPS0VOVFlQRS5ERUxJTUlURVI7XG4gICAgICB0b2tlbiA9IGM7XG4gICAgICBuZXh0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgZm9yIGFuIGlkZW50aWZpZXIgKG51bWJlciBvciBzdHJpbmcpXG4gICAgLy8gVE9ETzogbW9yZSBwcmVjaXNlIHBhcnNpbmcgb2YgbnVtYmVycy9zdHJpbmdzIChhbmQgdGhlIHBvcnQgc2VwYXJhdG9yICc6JylcbiAgICBpZiAoaXNBbHBoYU51bWVyaWMoYykgfHwgYyA9PT0gJy0nKSB7XG4gICAgICB0b2tlbiArPSBjO1xuICAgICAgbmV4dCgpO1xuXG4gICAgICB3aGlsZSAoaXNBbHBoYU51bWVyaWMoYykpIHtcbiAgICAgICAgdG9rZW4gKz0gYztcbiAgICAgICAgbmV4dCgpO1xuICAgICAgfVxuICAgICAgaWYgKHRva2VuID09PSAnZmFsc2UnKSB7XG4gICAgICAgIHRva2VuID0gZmFsc2U7IC8vIGNvbnZlcnQgdG8gYm9vbGVhblxuICAgICAgfSBlbHNlIGlmICh0b2tlbiA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgdG9rZW4gPSB0cnVlOyAvLyBjb252ZXJ0IHRvIGJvb2xlYW5cbiAgICAgICAgfSBlbHNlIGlmICghaXNOYU4oTnVtYmVyKHRva2VuKSkpIHtcbiAgICAgICAgICAgIHRva2VuID0gTnVtYmVyKHRva2VuKTsgLy8gY29udmVydCB0byBudW1iZXJcbiAgICAgICAgICB9XG4gICAgICB0b2tlblR5cGUgPSBUT0tFTlRZUEUuSURFTlRJRklFUjtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBmb3IgYSBzdHJpbmcgZW5jbG9zZWQgYnkgZG91YmxlIHF1b3Rlc1xuICAgIGlmIChjID09PSAnXCInKSB7XG4gICAgICBuZXh0KCk7XG4gICAgICB3aGlsZSAoYyAhPSAnJyAmJiAoYyAhPSAnXCInIHx8IGMgPT09ICdcIicgJiYgbmV4dFByZXZpZXcoKSA9PT0gJ1wiJykpIHtcbiAgICAgICAgdG9rZW4gKz0gYztcbiAgICAgICAgaWYgKGMgPT09ICdcIicpIHtcbiAgICAgICAgICAvLyBza2lwIHRoZSBlc2NhcGUgY2hhcmFjdGVyXG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIG5leHQoKTtcbiAgICAgIH1cbiAgICAgIGlmIChjICE9ICdcIicpIHtcbiAgICAgICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoJ0VuZCBvZiBzdHJpbmcgXCIgZXhwZWN0ZWQnKTtcbiAgICAgIH1cbiAgICAgIG5leHQoKTtcbiAgICAgIHRva2VuVHlwZSA9IFRPS0VOVFlQRS5JREVOVElGSUVSO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHNvbWV0aGluZyB1bmtub3duIGlzIGZvdW5kLCB3cm9uZyBjaGFyYWN0ZXJzLCBhIHN5bnRheCBlcnJvclxuICAgIHRva2VuVHlwZSA9IFRPS0VOVFlQRS5VTktOT1dOO1xuICAgIHdoaWxlIChjICE9ICcnKSB7XG4gICAgICB0b2tlbiArPSBjO1xuICAgICAgbmV4dCgpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1N5bnRheCBlcnJvciBpbiBwYXJ0IFwiJyArIGNob3AodG9rZW4sIDMwKSArICdcIicpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGEgZ3JhcGguXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IGdyYXBoXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZUdyYXBoKCkge1xuICAgIHZhciBncmFwaCA9IHt9O1xuXG4gICAgZmlyc3QoKTtcbiAgICBnZXRUb2tlbigpO1xuXG4gICAgLy8gb3B0aW9uYWwgc3RyaWN0IGtleXdvcmRcbiAgICBpZiAodG9rZW4gPT09ICdzdHJpY3QnKSB7XG4gICAgICBncmFwaC5zdHJpY3QgPSB0cnVlO1xuICAgICAgZ2V0VG9rZW4oKTtcbiAgICB9XG5cbiAgICAvLyBncmFwaCBvciBkaWdyYXBoIGtleXdvcmRcbiAgICBpZiAodG9rZW4gPT09ICdncmFwaCcgfHwgdG9rZW4gPT09ICdkaWdyYXBoJykge1xuICAgICAgZ3JhcGgudHlwZSA9IHRva2VuO1xuICAgICAgZ2V0VG9rZW4oKTtcbiAgICB9XG5cbiAgICAvLyBvcHRpb25hbCBncmFwaCBpZFxuICAgIGlmICh0b2tlblR5cGUgPT09IFRPS0VOVFlQRS5JREVOVElGSUVSKSB7XG4gICAgICBncmFwaC5pZCA9IHRva2VuO1xuICAgICAgZ2V0VG9rZW4oKTtcbiAgICB9XG5cbiAgICAvLyBvcGVuIGFuZ2xlIGJyYWNrZXRcbiAgICBpZiAodG9rZW4gIT0gJ3snKSB7XG4gICAgICB0aHJvdyBuZXdTeW50YXhFcnJvcignQW5nbGUgYnJhY2tldCB7IGV4cGVjdGVkJyk7XG4gICAgfVxuICAgIGdldFRva2VuKCk7XG5cbiAgICAvLyBzdGF0ZW1lbnRzXG4gICAgcGFyc2VTdGF0ZW1lbnRzKGdyYXBoKTtcblxuICAgIC8vIGNsb3NlIGFuZ2xlIGJyYWNrZXRcbiAgICBpZiAodG9rZW4gIT0gJ30nKSB7XG4gICAgICB0aHJvdyBuZXdTeW50YXhFcnJvcignQW5nbGUgYnJhY2tldCB9IGV4cGVjdGVkJyk7XG4gICAgfVxuICAgIGdldFRva2VuKCk7XG5cbiAgICAvLyBlbmQgb2YgZmlsZVxuICAgIGlmICh0b2tlbiAhPT0gJycpIHtcbiAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKCdFbmQgb2YgZmlsZSBleHBlY3RlZCcpO1xuICAgIH1cbiAgICBnZXRUb2tlbigpO1xuXG4gICAgLy8gcmVtb3ZlIHRlbXBvcmFyeSBkZWZhdWx0IG9wdGlvbnNcbiAgICBkZWxldGUgZ3JhcGgubm9kZTtcbiAgICBkZWxldGUgZ3JhcGguZWRnZTtcbiAgICBkZWxldGUgZ3JhcGguZ3JhcGg7XG5cbiAgICByZXR1cm4gZ3JhcGg7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgYSBsaXN0IHdpdGggc3RhdGVtZW50cy5cbiAgICogQHBhcmFtIHtPYmplY3R9IGdyYXBoXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZVN0YXRlbWVudHMoZ3JhcGgpIHtcbiAgICB3aGlsZSAodG9rZW4gIT09ICcnICYmIHRva2VuICE9ICd9Jykge1xuICAgICAgcGFyc2VTdGF0ZW1lbnQoZ3JhcGgpO1xuICAgICAgaWYgKHRva2VuID09PSAnOycpIHtcbiAgICAgICAgZ2V0VG9rZW4oKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgYSBzaW5nbGUgc3RhdGVtZW50LiBDYW4gYmUgYSBhbiBhdHRyaWJ1dGUgc3RhdGVtZW50LCBub2RlXG4gICAqIHN0YXRlbWVudCwgYSBzZXJpZXMgb2Ygbm9kZSBzdGF0ZW1lbnRzIGFuZCBlZGdlIHN0YXRlbWVudHMsIG9yIGFcbiAgICogcGFyYW1ldGVyLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZ3JhcGhcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlU3RhdGVtZW50KGdyYXBoKSB7XG4gICAgLy8gcGFyc2Ugc3ViZ3JhcGhcbiAgICB2YXIgc3ViZ3JhcGggPSBwYXJzZVN1YmdyYXBoKGdyYXBoKTtcbiAgICBpZiAoc3ViZ3JhcGgpIHtcbiAgICAgIC8vIGVkZ2Ugc3RhdGVtZW50c1xuICAgICAgcGFyc2VFZGdlKGdyYXBoLCBzdWJncmFwaCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBwYXJzZSBhbiBhdHRyaWJ1dGUgc3RhdGVtZW50XG4gICAgdmFyIGF0dHIgPSBwYXJzZUF0dHJpYnV0ZVN0YXRlbWVudChncmFwaCk7XG4gICAgaWYgKGF0dHIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBwYXJzZSBub2RlXG4gICAgaWYgKHRva2VuVHlwZSAhPSBUT0tFTlRZUEUuSURFTlRJRklFUikge1xuICAgICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoJ0lkZW50aWZpZXIgZXhwZWN0ZWQnKTtcbiAgICB9XG4gICAgdmFyIGlkID0gdG9rZW47IC8vIGlkIGNhbiBiZSBhIHN0cmluZyBvciBhIG51bWJlclxuICAgIGdldFRva2VuKCk7XG5cbiAgICBpZiAodG9rZW4gPT09ICc9Jykge1xuICAgICAgLy8gaWQgc3RhdGVtZW50XG4gICAgICBnZXRUb2tlbigpO1xuICAgICAgaWYgKHRva2VuVHlwZSAhPSBUT0tFTlRZUEUuSURFTlRJRklFUikge1xuICAgICAgICB0aHJvdyBuZXdTeW50YXhFcnJvcignSWRlbnRpZmllciBleHBlY3RlZCcpO1xuICAgICAgfVxuICAgICAgZ3JhcGhbaWRdID0gdG9rZW47XG4gICAgICBnZXRUb2tlbigpO1xuICAgICAgLy8gVE9ETzogaW1wbGVtZW50IGNvbW1hIHNlcGFyYXRlZCBsaXN0IHdpdGggXCJhX2xpc3Q6IElEPUlEIFsnLCddIFthX2xpc3RdIFwiXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VOb2RlU3RhdGVtZW50KGdyYXBoLCBpZCk7XG4gICAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgYSBzdWJncmFwaFxuICAgKiBAcGFyYW0ge09iamVjdH0gZ3JhcGggICAgcGFyZW50IGdyYXBoIG9iamVjdFxuICAgKiBAcmV0dXJuIHtPYmplY3QgfCBudWxsfSBzdWJncmFwaFxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VTdWJncmFwaChncmFwaCkge1xuICAgIHZhciBzdWJncmFwaCA9IG51bGw7XG5cbiAgICAvLyBvcHRpb25hbCBzdWJncmFwaCBrZXl3b3JkXG4gICAgaWYgKHRva2VuID09PSAnc3ViZ3JhcGgnKSB7XG4gICAgICBzdWJncmFwaCA9IHt9O1xuICAgICAgc3ViZ3JhcGgudHlwZSA9ICdzdWJncmFwaCc7XG4gICAgICBnZXRUb2tlbigpO1xuXG4gICAgICAvLyBvcHRpb25hbCBncmFwaCBpZFxuICAgICAgaWYgKHRva2VuVHlwZSA9PT0gVE9LRU5UWVBFLklERU5USUZJRVIpIHtcbiAgICAgICAgc3ViZ3JhcGguaWQgPSB0b2tlbjtcbiAgICAgICAgZ2V0VG9rZW4oKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBvcGVuIGFuZ2xlIGJyYWNrZXRcbiAgICBpZiAodG9rZW4gPT09ICd7Jykge1xuICAgICAgZ2V0VG9rZW4oKTtcblxuICAgICAgaWYgKCFzdWJncmFwaCkge1xuICAgICAgICBzdWJncmFwaCA9IHt9O1xuICAgICAgfVxuICAgICAgc3ViZ3JhcGgucGFyZW50ID0gZ3JhcGg7XG4gICAgICBzdWJncmFwaC5ub2RlID0gZ3JhcGgubm9kZTtcbiAgICAgIHN1YmdyYXBoLmVkZ2UgPSBncmFwaC5lZGdlO1xuICAgICAgc3ViZ3JhcGguZ3JhcGggPSBncmFwaC5ncmFwaDtcblxuICAgICAgLy8gc3RhdGVtZW50c1xuICAgICAgcGFyc2VTdGF0ZW1lbnRzKHN1YmdyYXBoKTtcblxuICAgICAgLy8gY2xvc2UgYW5nbGUgYnJhY2tldFxuICAgICAgaWYgKHRva2VuICE9ICd9Jykge1xuICAgICAgICB0aHJvdyBuZXdTeW50YXhFcnJvcignQW5nbGUgYnJhY2tldCB9IGV4cGVjdGVkJyk7XG4gICAgICB9XG4gICAgICBnZXRUb2tlbigpO1xuXG4gICAgICAvLyByZW1vdmUgdGVtcG9yYXJ5IGRlZmF1bHQgb3B0aW9uc1xuICAgICAgZGVsZXRlIHN1YmdyYXBoLm5vZGU7XG4gICAgICBkZWxldGUgc3ViZ3JhcGguZWRnZTtcbiAgICAgIGRlbGV0ZSBzdWJncmFwaC5ncmFwaDtcbiAgICAgIGRlbGV0ZSBzdWJncmFwaC5wYXJlbnQ7XG5cbiAgICAgIC8vIHJlZ2lzdGVyIGF0IHRoZSBwYXJlbnQgZ3JhcGhcbiAgICAgIGlmICghZ3JhcGguc3ViZ3JhcGhzKSB7XG4gICAgICAgIGdyYXBoLnN1YmdyYXBocyA9IFtdO1xuICAgICAgfVxuICAgICAgZ3JhcGguc3ViZ3JhcGhzLnB1c2goc3ViZ3JhcGgpO1xuICAgIH1cblxuICAgIHJldHVybiBzdWJncmFwaDtcbiAgfVxuXG4gIC8qKlxuICAgKiBwYXJzZSBhbiBhdHRyaWJ1dGUgc3RhdGVtZW50IGxpa2UgXCJub2RlIFtzaGFwZT1jaXJjbGUgZm9udFNpemU9MTZdXCIuXG4gICAqIEF2YWlsYWJsZSBrZXl3b3JkcyBhcmUgJ25vZGUnLCAnZWRnZScsICdncmFwaCcuXG4gICAqIFRoZSBwcmV2aW91cyBsaXN0IHdpdGggZGVmYXVsdCBhdHRyaWJ1dGVzIHdpbGwgYmUgcmVwbGFjZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IGdyYXBoXG4gICAqIEByZXR1cm5zIHtTdHJpbmcgfCBudWxsfSBrZXl3b3JkIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIHBhcnNlZCBhdHRyaWJ1dGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG5vZGUsIGVkZ2UsIGdyYXBoKSwgb3IgbnVsbCBpZiBub3RoaW5nXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIHBhcnNlZC5cbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlQXR0cmlidXRlU3RhdGVtZW50KGdyYXBoKSB7XG4gICAgLy8gYXR0cmlidXRlIHN0YXRlbWVudHNcbiAgICBpZiAodG9rZW4gPT09ICdub2RlJykge1xuICAgICAgZ2V0VG9rZW4oKTtcblxuICAgICAgLy8gbm9kZSBhdHRyaWJ1dGVzXG4gICAgICBncmFwaC5ub2RlID0gcGFyc2VBdHRyaWJ1dGVMaXN0KCk7XG4gICAgICByZXR1cm4gJ25vZGUnO1xuICAgIH0gZWxzZSBpZiAodG9rZW4gPT09ICdlZGdlJykge1xuICAgICAgZ2V0VG9rZW4oKTtcblxuICAgICAgLy8gZWRnZSBhdHRyaWJ1dGVzXG4gICAgICBncmFwaC5lZGdlID0gcGFyc2VBdHRyaWJ1dGVMaXN0KCk7XG4gICAgICByZXR1cm4gJ2VkZ2UnO1xuICAgIH0gZWxzZSBpZiAodG9rZW4gPT09ICdncmFwaCcpIHtcbiAgICAgIGdldFRva2VuKCk7XG5cbiAgICAgIC8vIGdyYXBoIGF0dHJpYnV0ZXNcbiAgICAgIGdyYXBoLmdyYXBoID0gcGFyc2VBdHRyaWJ1dGVMaXN0KCk7XG4gICAgICByZXR1cm4gJ2dyYXBoJztcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBwYXJzZSBhIG5vZGUgc3RhdGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBncmFwaFxuICAgKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlcn0gaWRcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlTm9kZVN0YXRlbWVudChncmFwaCwgaWQpIHtcbiAgICAvLyBub2RlIHN0YXRlbWVudFxuICAgIHZhciBub2RlID0ge1xuICAgICAgaWQ6IGlkXG4gICAgfTtcbiAgICB2YXIgYXR0ciA9IHBhcnNlQXR0cmlidXRlTGlzdCgpO1xuICAgIGlmIChhdHRyKSB7XG4gICAgICBub2RlLmF0dHIgPSBhdHRyO1xuICAgIH1cbiAgICBhZGROb2RlKGdyYXBoLCBub2RlKTtcblxuICAgIC8vIGVkZ2Ugc3RhdGVtZW50c1xuICAgIHBhcnNlRWRnZShncmFwaCwgaWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGFuIGVkZ2Ugb3IgYSBzZXJpZXMgb2YgZWRnZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IGdyYXBoXG4gICAqIEBwYXJhbSB7U3RyaW5nIHwgTnVtYmVyfSBmcm9tICAgICAgICBJZCBvZiB0aGUgZnJvbSBub2RlXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZUVkZ2UoZ3JhcGgsIGZyb20pIHtcbiAgICB3aGlsZSAodG9rZW4gPT09ICctPicgfHwgdG9rZW4gPT09ICctLScpIHtcbiAgICAgIHZhciB0bztcbiAgICAgIHZhciB0eXBlID0gdG9rZW47XG4gICAgICBnZXRUb2tlbigpO1xuXG4gICAgICB2YXIgc3ViZ3JhcGggPSBwYXJzZVN1YmdyYXBoKGdyYXBoKTtcbiAgICAgIGlmIChzdWJncmFwaCkge1xuICAgICAgICB0byA9IHN1YmdyYXBoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRva2VuVHlwZSAhPSBUT0tFTlRZUEUuSURFTlRJRklFUikge1xuICAgICAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKCdJZGVudGlmaWVyIG9yIHN1YmdyYXBoIGV4cGVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdG8gPSB0b2tlbjtcbiAgICAgICAgYWRkTm9kZShncmFwaCwge1xuICAgICAgICAgIGlkOiB0b1xuICAgICAgICB9KTtcbiAgICAgICAgZ2V0VG9rZW4oKTtcbiAgICAgIH1cblxuICAgICAgLy8gcGFyc2UgZWRnZSBhdHRyaWJ1dGVzXG4gICAgICB2YXIgYXR0ciA9IHBhcnNlQXR0cmlidXRlTGlzdCgpO1xuXG4gICAgICAvLyBjcmVhdGUgZWRnZVxuICAgICAgdmFyIGVkZ2UgPSBjcmVhdGVFZGdlKGdyYXBoLCBmcm9tLCB0bywgdHlwZSwgYXR0cik7XG4gICAgICBhZGRFZGdlKGdyYXBoLCBlZGdlKTtcblxuICAgICAgZnJvbSA9IHRvO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBhIHNldCB3aXRoIGF0dHJpYnV0ZXMsXG4gICAqIGZvciBleGFtcGxlIFtsYWJlbD1cIjEuMDAwXCIsIHNoYXBlPXNvbGlkXVxuICAgKiBAcmV0dXJuIHtPYmplY3QgfCBudWxsfSBhdHRyXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZUF0dHJpYnV0ZUxpc3QoKSB7XG4gICAgdmFyIGF0dHIgPSBudWxsO1xuXG4gICAgd2hpbGUgKHRva2VuID09PSAnWycpIHtcbiAgICAgIGdldFRva2VuKCk7XG4gICAgICBhdHRyID0ge307XG4gICAgICB3aGlsZSAodG9rZW4gIT09ICcnICYmIHRva2VuICE9ICddJykge1xuICAgICAgICBpZiAodG9rZW5UeXBlICE9IFRPS0VOVFlQRS5JREVOVElGSUVSKSB7XG4gICAgICAgICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoJ0F0dHJpYnV0ZSBuYW1lIGV4cGVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hbWUgPSB0b2tlbjtcblxuICAgICAgICBnZXRUb2tlbigpO1xuICAgICAgICBpZiAodG9rZW4gIT0gJz0nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoJ0VxdWFsIHNpZ24gPSBleHBlY3RlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGdldFRva2VuKCk7XG5cbiAgICAgICAgaWYgKHRva2VuVHlwZSAhPSBUT0tFTlRZUEUuSURFTlRJRklFUikge1xuICAgICAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKCdBdHRyaWJ1dGUgdmFsdWUgZXhwZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWUgPSB0b2tlbjtcbiAgICAgICAgc2V0VmFsdWUoYXR0ciwgbmFtZSwgdmFsdWUpOyAvLyBuYW1lIGNhbiBiZSBhIHBhdGhcblxuICAgICAgICBnZXRUb2tlbigpO1xuICAgICAgICBpZiAodG9rZW4gPT0gJywnKSB7XG4gICAgICAgICAgZ2V0VG9rZW4oKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodG9rZW4gIT0gJ10nKSB7XG4gICAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKCdCcmFja2V0IF0gZXhwZWN0ZWQnKTtcbiAgICAgIH1cbiAgICAgIGdldFRva2VuKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF0dHI7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgc3ludGF4IGVycm9yIHdpdGggZXh0cmEgaW5mb3JtYXRpb24gb24gY3VycmVudCB0b2tlbiBhbmQgaW5kZXguXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEByZXR1cm5zIHtTeW50YXhFcnJvcn0gZXJyXG4gICAqL1xuICBmdW5jdGlvbiBuZXdTeW50YXhFcnJvcihtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBTeW50YXhFcnJvcihtZXNzYWdlICsgJywgZ290IFwiJyArIGNob3AodG9rZW4sIDMwKSArICdcIiAoY2hhciAnICsgaW5kZXggKyAnKScpO1xuICB9XG5cbiAgLyoqXG4gICAqIENob3Agb2ZmIHRleHQgYWZ0ZXIgYSBtYXhpbXVtIGxlbmd0aFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICAgKiBAcGFyYW0ge051bWJlcn0gbWF4TGVuZ3RoXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqL1xuICBmdW5jdGlvbiBjaG9wKHRleHQsIG1heExlbmd0aCkge1xuICAgIHJldHVybiB0ZXh0Lmxlbmd0aCA8PSBtYXhMZW5ndGggPyB0ZXh0IDogdGV4dC5zdWJzdHIoMCwgMjcpICsgJy4uLic7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZSBhIGZ1bmN0aW9uIGZuIGZvciBlYWNoIHBhaXIgb2YgZWxlbWVudHMgaW4gdHdvIGFycmF5c1xuICAgKiBAcGFyYW0ge0FycmF5IHwgKn0gYXJyYXkxXG4gICAqIEBwYXJhbSB7QXJyYXkgfCAqfSBhcnJheTJcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZm5cbiAgICovXG4gIGZ1bmN0aW9uIGZvckVhY2gyKGFycmF5MSwgYXJyYXkyLCBmbikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycmF5MSkpIHtcbiAgICAgIGFycmF5MS5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtMSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcnJheTIpKSB7XG4gICAgICAgICAgYXJyYXkyLmZvckVhY2goZnVuY3Rpb24gKGVsZW0yKSB7XG4gICAgICAgICAgICBmbihlbGVtMSwgZWxlbTIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZuKGVsZW0xLCBhcnJheTIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXkyKSkge1xuICAgICAgICBhcnJheTIuZm9yRWFjaChmdW5jdGlvbiAoZWxlbTIpIHtcbiAgICAgICAgICBmbihhcnJheTEsIGVsZW0yKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbihhcnJheTEsIGFycmF5Mik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCBhIG5lc3RlZCBwcm9wZXJ0eSBvbiBhbiBvYmplY3RcbiAgICogV2hlbiBuZXN0ZWQgb2JqZWN0cyBhcmUgbWlzc2luZywgdGhleSB3aWxsIGJlIGNyZWF0ZWQuXG4gICAqIEZvciBleGFtcGxlIHNldFByb3Aoe30sICdmb250LmNvbG9yJywgJ3JlZCcpIHdpbGwgcmV0dXJuIHtmb250OiB7Y29sb3I6ICdyZWQnfX1cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAgIEEgZG90IHNlcGFyYXRlZCBzdHJpbmcgbGlrZSAnZm9udC5jb2xvcidcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSAgICAgICBWYWx1ZSBmb3IgdGhlIHByb3BlcnR5XG4gICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgb3JpZ2luYWwgb2JqZWN0LCBhbGxvd3MgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gc2V0UHJvcChvYmplY3QsIHBhdGgsIHZhbHVlKSB7XG4gICAgdmFyIG5hbWVzID0gcGF0aC5zcGxpdCgnLicpO1xuICAgIHZhciBwcm9wID0gbmFtZXMucG9wKCk7XG5cbiAgICAvLyB0cmF2ZXJzZSBvdmVyIHRoZSBuZXN0ZWQgb2JqZWN0c1xuICAgIHZhciBvYmogPSBvYmplY3Q7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgIGlmICghKG5hbWUgaW4gb2JqKSkge1xuICAgICAgICBvYmpbbmFtZV0gPSB7fTtcbiAgICAgIH1cbiAgICAgIG9iaiA9IG9ialtuYW1lXTtcbiAgICB9XG5cbiAgICAvLyBzZXQgdGhlIHByb3BlcnR5IHZhbHVlXG4gICAgb2JqW3Byb3BdID0gdmFsdWU7XG5cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYW4gb2JqZWN0IHdpdGggRE9UIGF0dHJpYnV0ZXMgdG8gdGhlaXIgdmlzLmpzIGVxdWl2YWxlbnRzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gYXR0ciAgICAgT2JqZWN0IHdpdGggRE9UIGF0dHJpYnV0ZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IG1hcHBpbmdcbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgIFJldHVybnMgYW4gb2JqZWN0IHdpdGggdmlzLmpzIGF0dHJpYnV0ZXNcbiAgICovXG4gIGZ1bmN0aW9uIGNvbnZlcnRBdHRyKGF0dHIsIG1hcHBpbmcpIHtcbiAgICB2YXIgY29udmVydGVkID0ge307XG5cbiAgICBmb3IgKHZhciBwcm9wIGluIGF0dHIpIHtcbiAgICAgIGlmIChhdHRyLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgIHZhciB2aXNQcm9wID0gbWFwcGluZ1twcm9wXTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmlzUHJvcCkpIHtcbiAgICAgICAgICB2aXNQcm9wLmZvckVhY2goZnVuY3Rpb24gKHZpc1Byb3BJKSB7XG4gICAgICAgICAgICBzZXRQcm9wKGNvbnZlcnRlZCwgdmlzUHJvcEksIGF0dHJbcHJvcF0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2aXNQcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHNldFByb3AoY29udmVydGVkLCB2aXNQcm9wLCBhdHRyW3Byb3BdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRQcm9wKGNvbnZlcnRlZCwgcHJvcCwgYXR0cltwcm9wXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29udmVydGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBzdHJpbmcgY29udGFpbmluZyBhIGdyYXBoIGluIERPVCBsYW5ndWFnZSBpbnRvIGEgbWFwIGNvbnRhaW5pbmdcbiAgICogd2l0aCBub2RlcyBhbmQgZWRnZXMgaW4gdGhlIGZvcm1hdCBvZiBncmFwaC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgICAgICAgICBUZXh0IGNvbnRhaW5pbmcgYSBncmFwaCBpbiBET1Qtbm90YXRpb25cbiAgICogQHJldHVybiB7T2JqZWN0fSBncmFwaERhdGFcbiAgICovXG4gIGZ1bmN0aW9uIERPVFRvR3JhcGgoZGF0YSkge1xuICAgIC8vIHBhcnNlIHRoZSBET1QgZmlsZVxuICAgIHZhciBkb3REYXRhID0gcGFyc2VET1QoZGF0YSk7XG4gICAgdmFyIGdyYXBoRGF0YSA9IHtcbiAgICAgIG5vZGVzOiBbXSxcbiAgICAgIGVkZ2VzOiBbXSxcbiAgICAgIG9wdGlvbnM6IHt9XG4gICAgfTtcblxuICAgIC8vIGNvcHkgdGhlIG5vZGVzXG4gICAgaWYgKGRvdERhdGEubm9kZXMpIHtcbiAgICAgIGRvdERhdGEubm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoZG90Tm9kZSkge1xuICAgICAgICB2YXIgZ3JhcGhOb2RlID0ge1xuICAgICAgICAgIGlkOiBkb3ROb2RlLmlkLFxuICAgICAgICAgIGxhYmVsOiBTdHJpbmcoZG90Tm9kZS5sYWJlbCB8fCBkb3ROb2RlLmlkKVxuICAgICAgICB9O1xuICAgICAgICBtZXJnZShncmFwaE5vZGUsIGNvbnZlcnRBdHRyKGRvdE5vZGUuYXR0ciwgTk9ERV9BVFRSX01BUFBJTkcpKTtcbiAgICAgICAgaWYgKGdyYXBoTm9kZS5pbWFnZSkge1xuICAgICAgICAgIGdyYXBoTm9kZS5zaGFwZSA9ICdpbWFnZSc7XG4gICAgICAgIH1cbiAgICAgICAgZ3JhcGhEYXRhLm5vZGVzLnB1c2goZ3JhcGhOb2RlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGNvcHkgdGhlIGVkZ2VzXG4gICAgaWYgKGRvdERhdGEuZWRnZXMpIHtcbiAgICAgIC8qKlxuICAgICAgICogQ29udmVydCBhbiBlZGdlIGluIERPVCBmb3JtYXQgdG8gYW4gZWRnZSB3aXRoIFZpc0dyYXBoIGZvcm1hdFxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGRvdEVkZ2VcbiAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGdyYXBoRWRnZVxuICAgICAgICovXG4gICAgICB2YXIgY29udmVydEVkZ2UgPSBmdW5jdGlvbiBjb252ZXJ0RWRnZShkb3RFZGdlKSB7XG4gICAgICAgIHZhciBncmFwaEVkZ2UgPSB7XG4gICAgICAgICAgZnJvbTogZG90RWRnZS5mcm9tLFxuICAgICAgICAgIHRvOiBkb3RFZGdlLnRvXG4gICAgICAgIH07XG4gICAgICAgIG1lcmdlKGdyYXBoRWRnZSwgY29udmVydEF0dHIoZG90RWRnZS5hdHRyLCBFREdFX0FUVFJfTUFQUElORykpO1xuICAgICAgICBncmFwaEVkZ2UuYXJyb3dzID0gZG90RWRnZS50eXBlID09PSAnLT4nID8gJ3RvJyA6IHVuZGVmaW5lZDtcblxuICAgICAgICByZXR1cm4gZ3JhcGhFZGdlO1xuICAgICAgfTtcblxuICAgICAgZG90RGF0YS5lZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChkb3RFZGdlKSB7XG4gICAgICAgIHZhciBmcm9tLCB0bztcbiAgICAgICAgaWYgKGRvdEVkZ2UuZnJvbSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgIGZyb20gPSBkb3RFZGdlLmZyb20ubm9kZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZnJvbSA9IHtcbiAgICAgICAgICAgIGlkOiBkb3RFZGdlLmZyb21cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogc3VwcG9ydCBvZiBzb2xpZC9kb3R0ZWQvZGFzaGVkIGVkZ2VzIChhdHRyID0gJ3N0eWxlJylcbiAgICAgICAgLy8gVE9ETzogc3VwcG9ydCBmb3IgYXR0cmlidXRlcyAnZGlyJyBhbmQgJ2Fycm93aGVhZCcgKGVkZ2UgYXJyb3dzKVxuXG4gICAgICAgIGlmIChkb3RFZGdlLnRvIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgdG8gPSBkb3RFZGdlLnRvLm5vZGVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRvID0ge1xuICAgICAgICAgICAgaWQ6IGRvdEVkZ2UudG9cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRvdEVkZ2UuZnJvbSBpbnN0YW5jZW9mIE9iamVjdCAmJiBkb3RFZGdlLmZyb20uZWRnZXMpIHtcbiAgICAgICAgICBkb3RFZGdlLmZyb20uZWRnZXMuZm9yRWFjaChmdW5jdGlvbiAoc3ViRWRnZSkge1xuICAgICAgICAgICAgdmFyIGdyYXBoRWRnZSA9IGNvbnZlcnRFZGdlKHN1YkVkZ2UpO1xuICAgICAgICAgICAgZ3JhcGhEYXRhLmVkZ2VzLnB1c2goZ3JhcGhFZGdlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvckVhY2gyKGZyb20sIHRvLCBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgICAgICAgICB2YXIgc3ViRWRnZSA9IGNyZWF0ZUVkZ2UoZ3JhcGhEYXRhLCBmcm9tLmlkLCB0by5pZCwgZG90RWRnZS50eXBlLCBkb3RFZGdlLmF0dHIpO1xuICAgICAgICAgIHZhciBncmFwaEVkZ2UgPSBjb252ZXJ0RWRnZShzdWJFZGdlKTtcbiAgICAgICAgICBncmFwaERhdGEuZWRnZXMucHVzaChncmFwaEVkZ2UpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZG90RWRnZS50byBpbnN0YW5jZW9mIE9iamVjdCAmJiBkb3RFZGdlLnRvLmVkZ2VzKSB7XG4gICAgICAgICAgZG90RWRnZS50by5lZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJFZGdlKSB7XG4gICAgICAgICAgICB2YXIgZ3JhcGhFZGdlID0gY29udmVydEVkZ2Uoc3ViRWRnZSk7XG4gICAgICAgICAgICBncmFwaERhdGEuZWRnZXMucHVzaChncmFwaEVkZ2UpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBjb3B5IHRoZSBvcHRpb25zXG4gICAgaWYgKGRvdERhdGEuYXR0cikge1xuICAgICAgZ3JhcGhEYXRhLm9wdGlvbnMgPSBkb3REYXRhLmF0dHI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdyYXBoRGF0YTtcbiAgfVxuXG4gIC8vIGV4cG9ydHNcbiAgZXhwb3J0cy5wYXJzZURPVCA9IHBhcnNlRE9UO1xuICBleHBvcnRzLkRPVFRvR3JhcGggPSBET1RUb0dyYXBoO1xuXG4vKioqLyB9LFxuLyogMTE5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgZnVuY3Rpb24gcGFyc2VHZXBoaShnZXBoaUpTT04sIG9wdGlvbnNPYmopIHtcbiAgICB2YXIgZWRnZXMgPSBbXTtcbiAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIGVkZ2VzOiB7XG4gICAgICAgIGluaGVyaXRDb2xvcjogZmFsc2VcbiAgICAgIH0sXG4gICAgICBub2Rlczoge1xuICAgICAgICBmaXhlZDogZmFsc2UsXG4gICAgICAgIHBhcnNlQ29sb3I6IGZhbHNlXG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zT2JqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChvcHRpb25zT2JqLmZpeGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5ub2Rlcy5maXhlZCA9IG9wdGlvbnNPYmouZml4ZWQ7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9uc09iai5wYXJzZUNvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5ub2Rlcy5wYXJzZUNvbG9yID0gb3B0aW9uc09iai5wYXJzZUNvbG9yO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnNPYmouaW5oZXJpdENvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5lZGdlcy5pbmhlcml0Q29sb3IgPSBvcHRpb25zT2JqLmluaGVyaXRDb2xvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZ0VkZ2VzID0gZ2VwaGlKU09OLmVkZ2VzO1xuICAgIHZhciBnTm9kZXMgPSBnZXBoaUpTT04ubm9kZXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnRWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlZGdlID0ge307XG4gICAgICB2YXIgZ0VkZ2UgPSBnRWRnZXNbaV07XG4gICAgICBlZGdlWydpZCddID0gZ0VkZ2UuaWQ7XG4gICAgICBlZGdlWydmcm9tJ10gPSBnRWRnZS5zb3VyY2U7XG4gICAgICBlZGdlWyd0byddID0gZ0VkZ2UudGFyZ2V0O1xuICAgICAgZWRnZVsnYXR0cmlidXRlcyddID0gZ0VkZ2UuYXR0cmlidXRlcztcbiAgICAgIGVkZ2VbJ2xhYmVsJ10gPSBnRWRnZS5sYWJlbDtcbiAgICAgIGVkZ2VbJ3RpdGxlJ10gPSBnRWRnZS5hdHRyaWJ1dGVzICE9PSB1bmRlZmluZWQgPyBnRWRnZS5hdHRyaWJ1dGVzLnRpdGxlIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKGdFZGdlWyd0eXBlJ10gPT09ICdEaXJlY3RlZCcpIHtcbiAgICAgICAgZWRnZVsnYXJyb3dzJ10gPSAndG8nO1xuICAgICAgfVxuICAgICAgLy8gICAgZWRnZVsndmFsdWUnXSA9IGdFZGdlLmF0dHJpYnV0ZXMgIT09IHVuZGVmaW5lZCA/IGdFZGdlLmF0dHJpYnV0ZXMuV2VpZ2h0IDogdW5kZWZpbmVkO1xuICAgICAgLy8gICAgZWRnZVsnd2lkdGgnXSA9IGVkZ2VbJ3ZhbHVlJ10gIT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGVkZ2VnRWRnZS5zaXplO1xuICAgICAgaWYgKGdFZGdlLmNvbG9yICYmIG9wdGlvbnMuaW5oZXJpdENvbG9yID09PSBmYWxzZSkge1xuICAgICAgICBlZGdlWydjb2xvciddID0gZ0VkZ2UuY29sb3I7XG4gICAgICB9XG4gICAgICBlZGdlcy5wdXNoKGVkZ2UpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ05vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbm9kZSA9IHt9O1xuICAgICAgdmFyIGdOb2RlID0gZ05vZGVzW2ldO1xuICAgICAgbm9kZVsnaWQnXSA9IGdOb2RlLmlkO1xuICAgICAgbm9kZVsnYXR0cmlidXRlcyddID0gZ05vZGUuYXR0cmlidXRlcztcbiAgICAgIG5vZGVbJ3RpdGxlJ10gPSBnTm9kZS50aXRsZTtcbiAgICAgIG5vZGVbJ3gnXSA9IGdOb2RlLng7XG4gICAgICBub2RlWyd5J10gPSBnTm9kZS55O1xuICAgICAgbm9kZVsnbGFiZWwnXSA9IGdOb2RlLmxhYmVsO1xuICAgICAgbm9kZVsndGl0bGUnXSA9IGdOb2RlLmF0dHJpYnV0ZXMgIT09IHVuZGVmaW5lZCA/IGdOb2RlLmF0dHJpYnV0ZXMudGl0bGUgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAob3B0aW9ucy5ub2Rlcy5wYXJzZUNvbG9yID09PSB0cnVlKSB7XG4gICAgICAgIG5vZGVbJ2NvbG9yJ10gPSBnTm9kZS5jb2xvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVbJ2NvbG9yJ10gPSBnTm9kZS5jb2xvciAhPT0gdW5kZWZpbmVkID8geyBiYWNrZ3JvdW5kOiBnTm9kZS5jb2xvciwgYm9yZGVyOiBnTm9kZS5jb2xvciwgaGlnaGxpZ2h0OiB7IGJhY2tncm91bmQ6IGdOb2RlLmNvbG9yLCBib3JkZXI6IGdOb2RlLmNvbG9yIH0sIGhvdmVyOiB7IGJhY2tncm91bmQ6IGdOb2RlLmNvbG9yLCBib3JkZXI6IGdOb2RlLmNvbG9yIH0gfSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIG5vZGVbJ3NpemUnXSA9IGdOb2RlLnNpemU7XG4gICAgICBub2RlWydmaXhlZCddID0gb3B0aW9ucy5ub2Rlcy5maXhlZCAmJiBnTm9kZS54ICE9PSB1bmRlZmluZWQgJiYgZ05vZGUueSAhPT0gdW5kZWZpbmVkO1xuICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBub2Rlczogbm9kZXMsIGVkZ2VzOiBlZGdlcyB9O1xuICB9XG5cbiAgZXhwb3J0cy5wYXJzZUdlcGhpID0gcGFyc2VHZXBoaTtcblxuLyoqKi8gfSxcbi8qIDEyMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIEVuZ2xpc2hcbiAgZXhwb3J0c1snZW4nXSA9IHtcbiAgICBlZGl0OiAnRWRpdCcsXG4gICAgZGVsOiAnRGVsZXRlIHNlbGVjdGVkJyxcbiAgICBiYWNrOiAnQmFjaycsXG4gICAgYWRkTm9kZTogJ0FkZCBOb2RlJyxcbiAgICBhZGRFZGdlOiAnQWRkIEVkZ2UnLFxuICAgIGVkaXROb2RlOiAnRWRpdCBOb2RlJyxcbiAgICBlZGl0RWRnZTogJ0VkaXQgRWRnZScsXG4gICAgYWRkRGVzY3JpcHRpb246ICdDbGljayBpbiBhbiBlbXB0eSBzcGFjZSB0byBwbGFjZSBhIG5ldyBub2RlLicsXG4gICAgZWRnZURlc2NyaXB0aW9uOiAnQ2xpY2sgb24gYSBub2RlIGFuZCBkcmFnIHRoZSBlZGdlIHRvIGFub3RoZXIgbm9kZSB0byBjb25uZWN0IHRoZW0uJyxcbiAgICBlZGl0RWRnZURlc2NyaXB0aW9uOiAnQ2xpY2sgb24gdGhlIGNvbnRyb2wgcG9pbnRzIGFuZCBkcmFnIHRoZW0gdG8gYSBub2RlIHRvIGNvbm5lY3QgdG8gaXQuJyxcbiAgICBjcmVhdGVFZGdlRXJyb3I6ICdDYW5ub3QgbGluayBlZGdlcyB0byBhIGNsdXN0ZXIuJyxcbiAgICBkZWxldGVDbHVzdGVyRXJyb3I6ICdDbHVzdGVycyBjYW5ub3QgYmUgZGVsZXRlZC4nLFxuICAgIGVkaXRDbHVzdGVyRXJyb3I6ICdDbHVzdGVycyBjYW5ub3QgYmUgZWRpdGVkLidcbiAgfTtcbiAgZXhwb3J0c1snZW5fRU4nXSA9IGV4cG9ydHNbJ2VuJ107XG4gIGV4cG9ydHNbJ2VuX1VTJ10gPSBleHBvcnRzWydlbiddO1xuXG4gIC8vIEdlcm1hblxuICBleHBvcnRzWydkZSddID0ge1xuICAgIGVkaXQ6ICdFZGl0aWVyZW4nLFxuICAgIGRlbDogJ0zDtnNjaGUgQXVzd2FobCcsXG4gICAgYmFjazogJ1p1csO8Y2snLFxuICAgIGFkZE5vZGU6ICdLbm90ZW4gaGluenVmw7xnZW4nLFxuICAgIGFkZEVkZ2U6ICdLYW50ZSBoaW56dWbDvGdlbicsXG4gICAgZWRpdE5vZGU6ICdLbm90ZW4gZWRpdGllcmVuJyxcbiAgICBlZGl0RWRnZTogJ0thbnRlIGVkaXRpZXJlbicsXG4gICAgYWRkRGVzY3JpcHRpb246ICdLbGlja2UgYXVmIGVpbmUgZnJlaWUgU3RlbGxlLCB1bSBlaW5lbiBuZXVlbiBLbm90ZW4genUgcGxhemllcmVuLicsXG4gICAgZWRnZURlc2NyaXB0aW9uOiAnS2xpY2tlIGF1ZiBlaW5lbiBLbm90ZW4gdW5kIHppZWhlIGRpZSBLYW50ZSB6dSBlaW5lbSBhbmRlcmVuIEtub3RlbiwgdW0gZGllc2UgenUgdmVyYmluZGVuLicsXG4gICAgZWRpdEVkZ2VEZXNjcmlwdGlvbjogJ0tsaWNrZSBhdWYgZGllIFZlcmJpbmR1bmdzcHVua3RlIHVuZCB6aWVoZSBkaWVzZSBhdWYgZWluZW4gS25vdGVuLCB1bSBzaWUgenUgdmVyYmluZGVuLicsXG4gICAgY3JlYXRlRWRnZUVycm9yOiAnRXMgaXN0IG5pY2h0IG3DtmdsaWNoLCBLYW50ZW4gbWl0IENsdXN0ZXJuIHp1IHZlcmJpbmRlbi4nLFxuICAgIGRlbGV0ZUNsdXN0ZXJFcnJvcjogJ0NsdXN0ZXIga8O2bm5lbiBuaWNodCBnZWzDtnNjaHQgd2VyZGVuLicsXG4gICAgZWRpdENsdXN0ZXJFcnJvcjogJ0NsdXN0ZXIga8O2bm5lbiBuaWNodCBlZGl0aWVydCB3ZXJkZW4uJ1xuICB9O1xuICBleHBvcnRzWydkZV9ERSddID0gZXhwb3J0c1snZGUnXTtcblxuICAvLyBTcGFuaXNoXG4gIGV4cG9ydHNbJ2VzJ10gPSB7XG4gICAgZWRpdDogJ0VkaXRhcicsXG4gICAgZGVsOiAnRWxpbWluYXIgc2VsZWNjacOzbicsXG4gICAgYmFjazogJ8OBdHJhcycsXG4gICAgYWRkTm9kZTogJ0HDsWFkaXIgbm9kbycsXG4gICAgYWRkRWRnZTogJ0HDsWFkaXIgYXJpc3RhJyxcbiAgICBlZGl0Tm9kZTogJ0VkaXRhciBub2RvJyxcbiAgICBlZGl0RWRnZTogJ0VkaXRhciBhcmlzdGEnLFxuICAgIGFkZERlc2NyaXB0aW9uOiAnSGFnYSBjbGljIGVuIHVuIGx1Z2FyIHZhY8OtbyBwYXJhIGNvbG9jYXIgdW4gbnVldm8gbm9kby4nLFxuICAgIGVkZ2VEZXNjcmlwdGlvbjogJ0hhZ2EgY2xpYyBlbiB1biBub2RvIHkgYXJyYXN0cmUgbGEgYXJpc3RhIGhhY2lhIG90cm8gbm9kbyBwYXJhIGNvbmVjdGFybG9zLicsXG4gICAgZWRpdEVkZ2VEZXNjcmlwdGlvbjogJ0hhZ2EgY2xpYyBlbiB1biBwdW50byBkZSBjb250cm9sIHkgYXJyYXN0cmVsbyBhIHVuIG5vZG8gcGFyYSBjb25lY3RhcmxvLicsXG4gICAgY3JlYXRlRWRnZUVycm9yOiAnTm8gc2UgcHVlZGUgY29uZWN0YXIgdW5hIGFyaXN0YSBhIHVuIGdydXBvLicsXG4gICAgZGVsZXRlQ2x1c3RlckVycm9yOiAnTm8gZXMgcG9zaWJsZSBlbGltaW5hciBncnVwb3MuJyxcbiAgICBlZGl0Q2x1c3RlckVycm9yOiAnTm8gZXMgcG9zaWJsZSBlZGl0YXIgZ3J1cG9zLidcbiAgfTtcbiAgZXhwb3J0c1snZXNfRVMnXSA9IGV4cG9ydHNbJ2VzJ107XG5cbiAgLy8gRHV0Y2hcbiAgZXhwb3J0c1snbmwnXSA9IHtcbiAgICBlZGl0OiAnV2lqemlnZW4nLFxuICAgIGRlbDogJ1NlbGVjdGllIHZlcndpamRlcmVuJyxcbiAgICBiYWNrOiAnVGVydWcnLFxuICAgIGFkZE5vZGU6ICdOb2RlIHRvZXZvZWdlbicsXG4gICAgYWRkRWRnZTogJ0xpbmsgdG9ldm9lZ2VuJyxcbiAgICBlZGl0Tm9kZTogJ05vZGUgd2lqemlnZW4nLFxuICAgIGVkaXRFZGdlOiAnTGluayB3aWp6aWdlbicsXG4gICAgYWRkRGVzY3JpcHRpb246ICdLbGlrIG9wIGVlbiBsZWVnIGdlYmllZCBvbSBlZW4gbmlldXdlIG5vZGUgdGUgbWFrZW4uJyxcbiAgICBlZGdlRGVzY3JpcHRpb246ICdLbGlrIG9wIGVlbiBub2RlIGVuIHNsZWVwIGRlIGxpbmsgbmFhciBlZW4gYW5kZXJlIG5vZGUgb20gemUgdGUgdmVyYmluZGVuLicsXG4gICAgZWRpdEVkZ2VEZXNjcmlwdGlvbjogJ0tsaWsgb3AgZGUgdmVyYmluZGluZ3NwdW50ZW4gZW4gc2xlZXAgemUgbmFhciBlZW4gbm9kZSBvbSBkYWFybWVlIHRlIHZlcmJpbmRlbi4nLFxuICAgIGNyZWF0ZUVkZ2VFcnJvcjogJ0thbiBnZWVuIGxpbmsgbWFrZW4gbmFhciBlZW4gY2x1c3Rlci4nLFxuICAgIGRlbGV0ZUNsdXN0ZXJFcnJvcjogJ0NsdXN0ZXJzIGt1bm5lbiBuaWV0IHdvcmRlbiB2ZXJ3aWpkZXJkLicsXG4gICAgZWRpdENsdXN0ZXJFcnJvcjogJ0NsdXN0ZXJzIGt1bm5lbiBuaWV0IHdvcmRlbiBhYW5nZXBhc3QuJ1xuICB9O1xuICBleHBvcnRzWydubF9OTCddID0gZXhwb3J0c1snbmwnXTtcbiAgZXhwb3J0c1snbmxfQkUnXSA9IGV4cG9ydHNbJ25sJ107XG5cbi8qKiovIH1cbi8qKioqKiovIF0pXG59KTtcbjsiXX0=
