(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var Grammar = require("../lib/Grammar"),
    State = require("../lib/State"),
    Diagram = require("../lib/Diagram");


var g = new Grammar(["A", "B", "C"]);

g.addRules({

    'S' : [['A','B','S'],['B','E','C']],
    'E' : [['C']]
});

/*g.build('S');

Diagram.drawStateDiagram(g.stateOptions.S[0],
    document.getElementById('container'));
*/

Object.keys(g.rules).forEach(function(ruleLabel){
    this.firstPass(this.rules[ruleLabel],ruleLabel);
}, g);

function buildPreRules(sOps) {
    var nodes = [], edges = [], s, data;
    Object.keys(sOps).forEach(function(ruleLabel) {
        s = new State("", ruleLabel);
        s.addStates(sOps[ruleLabel]);
        console.log(s);
        data = Diagram.buildData(s);
        nodes = nodes.concat(data.nodes);
        edges = edges.concat(data.edges);
    });
    Diagram.drawFromData(nodes,edges,document.getElementById("container2"));
};

buildPreRules(g.stateOptions);

var start = new State("","Start");
start.addStates(g.buildTraverse("S"));
Diagram.drawStateDiagram(start,
    document.getElementById('container'));

},{"../lib/Diagram":2,"../lib/Grammar":3,"../lib/State":4}],2:[function(require,module,exports){
var vis = require("vis");

var Diagram = {};

Diagram.buildData = function(state) {
    var labelIndex = {},
        nodes = [],
        edges = [];
    function buildIndex(state) {
        if(typeof labelIndex[state.label] === "undefined") {
            labelIndex[state.label] =
                {id:state.label, label:state.label};
            nodes.push(labelIndex[state.label]);
            for(var i=0,l=state.states.length;i<l;i++) {
                edges.push({from:state.label,to:state.states[i].label,
                            label:state.states[i].terminal,
                            font: {align: 'middle'},
                            arrows:'to'});
                buildIndex(state.states[i]);
            }
        }
    }
    buildIndex(state);
    return {
        nodes: nodes,
        edges: edges
    };
}

Diagram.drawFromData = function(nodes,edges,container) {
    var network = new vis.Network(container, 
        {nodes:nodes,edges:edges}, {});
    return network;
}

Diagram.drawStateDiagram = function(state,container) {
    // first build nodes variable
    var data = Diagram.buildData(state);
    console.log(data);
    var network = new vis.Network(container, data, {});
    return network;
}

module.exports = Diagram;

},{"vis":5}],3:[function(require,module,exports){
var State = require("./State.js");

function Grammar(terminals, rules) {
    this.terminals = [];
    this.rules = {};
    this.unresolvedStates = [];
    this.stateOptions = {};
    this.addTerminals(terminals || []);
    this.addRules(rules || {});
}

Grammar.prototype = {
    addTerminals : function(terminals) {
        this.terminals = this.terminals.concat(terminals);
    },
    addRules : function(rules) {
        Object.assign(this.rules, rules);
    },
    isTerminal : function(t) {
    		return this.terminals.indexOf(t) > -1;
    },
    firstPass : function(rule,ruleLabel) {
        // want to output the rule's states, one for each option
        // and remember where to insert other rules' states
        // rule is an array of options
        for(var i = 0, rlen = rule.length, option, j, s, ls, rs=[];
            i < rlen; i++) {
            option = rule[i];
            // option is an array of terminals and rule names
            // want to go through them in reverse order
            j = option.length;
            ls = [];
            while(j--) {
                s = new State(option[j]);
                if(ls[0] && ls[0].dummy) {
                    this.unresolvedStates.push([ls[0],s]);
                }
                s.addStates(ls);
                ls = [s];
                if(!this.isTerminal(option[j])) {
                    // remember to put in the correct states later
                    s.dummy = true;
                }
            }
            rs = State.merge(rs,ls);
        }
        this.stateOptions[ruleLabel] = rs;
        return rs;
    },
    build : function(startSymbol) {
        var ret;
        // each rule needs to have it's first pass
        Object.keys(this.rules).forEach(function(ruleLabel){
            this.firstPass(this.rules[ruleLabel],ruleLabel);
        }, this);
        console.log(this.unresolvedStates);
        // now need to go through all the unresolved states and
        // replace them with the other rules' states
        for(var i = 0, ulen = this.unresolvedStates.length, dummy;
            i < ulen; i++) {
            dummy = this.unresolvedStates[i];
            // dummy[0] is the dummy state which stores the states
            // that come after the nested state has been absorped
            // dummy[1] is the state that comes before the dummy
            // each of the state options' last states
            // needs to have the same states as the dummy state
            var newStates = [];
            this.stateOptions[dummy[0].terminal].forEach(function(s){
                newStates.push(s.deepCopy(dummy[0]));
            });
            console.log(newStates);
            State.addToEnd(newStates, dummy[0].states);
            dummy[1].addStates(newStates);
            if(dummy[0].terminal === startSymbol) {

            }
        }
    },

    buildTraverse : function(startSymbol,rP,endStates) {
        var rP = rP || {},
            endStates = endStates || [],
            rule = this.stateOptions[startSymbol],
            retState = new State("",startSymbol),
            ls = [];
        rP[startSymbol] = retState;
        rule.forEach(function(state){
            // go through states
            var self = this;
            function processState(state,lastState,li) {
                console.log(state,lastState);
                if(state.dummy) {
                    lastState.states.splice(li,1);
                    if(typeof rP[state.terminal] === "undefined") {
                        lastState.addStates(self.buildTraverse(
                            state.terminal,
                            rP,
                            state.states
                        ));
                    }
                    else {
                        if(state.terminal === startSymbol) {
                            ls.push(lastState);
                        }
                        else
                        lastState.addStates(rP[state.terminal].states);
                    }
                }
                else {
                    lastState = state;
                    if(state.states.length === 0) {
                        state.states = endStates;
                    }
                    else {
                        state.states.forEach(function(s,i) {
                            processState(s,state,i);
                        },this);
                    }
                }
            }
            processState(state);
            retState.addStates([state]);
        },this);
        ls.forEach(function(s){
            s.addStates(rP[startSymbol].states);
        });
        return retState.states;
    }


}
module.exports = Grammar;

},{"./State.js":4}],4:[function(require,module,exports){
var StateCount = 0;

function union_arrays (x, y) {
    var obj = {};
    for (var i = x.length-1; i >= 0; -- i)
       obj[x[i]] = x[i];
    for (var i = y.length-1; i >= 0; -- i)
       obj[y[i]] = y[i];
    var res = []
    for (var k in obj) {
        res.push(obj[k]);
    }
    return res;
}

function State(terminal,label) {
		this.terminal = terminal;
		this.states = [];
    this.label = label || StateCount++;
}

State.merge = function(retops, ops) {
		if(typeof retops === "undefined") {
    		retops = [];
    }
    ops.forEach(function(op){
    		st = retops.find(function(rop) {
        		return rop.terminal === op.terminal;
        });
        if(typeof st !== "undefined") {
        		st = State.merge(st.states, op.states);
        }
        else {
        		retops.push(op);
        }
    });
    return retops;
}

State.addToEnd = function(targets,insert) {
    for(var i=0,l=targets.length; i<l; i++) {
        if(targets[i].states.length === 0) {
            targets[i].states = insert;
        }
        else {
            State.addToEnd(targets[i].states,insert);
        }
    }
}

State.prototype = {
	addStates : function(states) {
		this.states = State.merge(this.states, states);
    },
    deepCopy : function() {
        var s = new State(this.terminal),
            oldLabels = {};
        for(var i=0,l=this.states.length;i<l;i++) {
            if(typeof oldLabels[this.states[i].label] === "undefined"
                && !this.states[i].dummy) {
                oldLabels[this.states[i].label] = true;
                s.states.push(this.states[i].deepCopy());
            }
        }
        return s;
    }
}

module.exports = State;

},{}],5:[function(require,module,exports){
/**
 * vis.js
 * https://github.com/almende/vis
 *
 * A dynamic, browser-based visualization library.
 *
 * @version 4.16.1
 * @date    2016-04-18
 *
 * @license
 * Copyright (C) 2011-2016 Almende B.V, http://almende.com
 *
 * Vis.js is dual licensed under both
 *
 * * The Apache 2.0 License
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * and
 *
 * * The MIT License
 *   http://opensource.org/licenses/MIT
 *
 * Vis.js may be distributed under either license.
 */

"use strict";

(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["vis"] = factory();
	else
		root["vis"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var util = __webpack_require__(1);

  // Graph3d
  util.extend(exports, __webpack_require__(7));

  // Timeline & Graph2d
  util.extend(exports, __webpack_require__(24));

  // Network
  util.extend(exports, __webpack_require__(60));

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

  // utility functions

  // first check if moment.js is already loaded in the browser window, if so,
  // use this instance. Else, load via commonjs.

  var moment = __webpack_require__(2);
  var uuid = __webpack_require__(6);

  /**
   * Test whether given object is a number
   * @param {*} object
   * @return {Boolean} isNumber
   */
  exports.isNumber = function (object) {
    return object instanceof Number || typeof object == 'number';
  };

  /**
   * Remove everything in the DOM object
   * @param DOMobject
   */
  exports.recursiveDOMDelete = function (DOMobject) {
    if (DOMobject) {
      while (DOMobject.hasChildNodes() === true) {
        exports.recursiveDOMDelete(DOMobject.firstChild);
        DOMobject.removeChild(DOMobject.firstChild);
      }
    }
  };

  /**
   * this function gives you a range between 0 and 1 based on the min and max values in the set, the total sum of all values and the current value.
   *
   * @param min
   * @param max
   * @param total
   * @param value
   * @returns {number}
   */
  exports.giveRange = function (min, max, total, value) {
    if (max == min) {
      return 0.5;
    } else {
      var scale = 1 / (max - min);
      return Math.max(0, (value - min) * scale);
    }
  };

  /**
   * Test whether given object is a string
   * @param {*} object
   * @return {Boolean} isString
   */
  exports.isString = function (object) {
    return object instanceof String || typeof object == 'string';
  };

  /**
   * Test whether given object is a Date, or a String containing a Date
   * @param {Date | String} object
   * @return {Boolean} isDate
   */
  exports.isDate = function (object) {
    if (object instanceof Date) {
      return true;
    } else if (exports.isString(object)) {
      // test whether this string contains a date
      var match = ASPDateRegex.exec(object);
      if (match) {
        return true;
      } else if (!isNaN(Date.parse(object))) {
        return true;
      }
    }

    return false;
  };

  /**
   * Create a semi UUID
   * source: http://stackoverflow.com/a/105074/1262753
   * @return {String} uuid
   */
  exports.randomUUID = function () {
    return uuid.v4();
  };

  /**
   * assign all keys of an object that are not nested objects to a certain value (used for color objects).
   * @param obj
   * @param value
   */
  exports.assignAllKeys = function (obj, value) {
    for (var prop in obj) {
      if (obj.hasOwnProperty(prop)) {
        if (_typeof(obj[prop]) !== 'object') {
          obj[prop] = value;
        }
      }
    }
  };

  /**
   * Fill an object with a possibly partially defined other object. Only copies values if the a object has an object requiring values.
   * That means an object is not created on a property if only the b object has it.
   * @param obj
   * @param value
   */
  exports.fillIfDefined = function (a, b) {
    var allowDeletion = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

    for (var prop in a) {
      if (b[prop] !== undefined) {
        if (_typeof(b[prop]) !== 'object') {
          if ((b[prop] === undefined || b[prop] === null) && a[prop] !== undefined && allowDeletion === true) {
            delete a[prop];
          } else {
            a[prop] = b[prop];
          }
        } else {
          if (_typeof(a[prop]) === 'object') {
            exports.fillIfDefined(a[prop], b[prop], allowDeletion);
          }
        }
      }
    }
  };

  /**
   * Extend object a with the properties of object b or a series of objects
   * Only properties with defined values are copied
   * @param {Object} a
   * @param {... Object} b
   * @return {Object} a
   */
  exports.protoExtend = function (a, b) {
    for (var i = 1; i < arguments.length; i++) {
      var other = arguments[i];
      for (var prop in other) {
        a[prop] = other[prop];
      }
    }
    return a;
  };

  /**
   * Extend object a with the properties of object b or a series of objects
   * Only properties with defined values are copied
   * @param {Object} a
   * @param {... Object} b
   * @return {Object} a
   */
  exports.extend = function (a, b) {
    for (var i = 1; i < arguments.length; i++) {
      var other = arguments[i];
      for (var prop in other) {
        if (other.hasOwnProperty(prop)) {
          a[prop] = other[prop];
        }
      }
    }
    return a;
  };

  /**
   * Extend object a with selected properties of object b or a series of objects
   * Only properties with defined values are copied
   * @param {Array.<String>} props
   * @param {Object} a
   * @param {Object} b
   * @return {Object} a
   */
  exports.selectiveExtend = function (props, a, b) {
    if (!Array.isArray(props)) {
      throw new Error('Array with property names expected as first argument');
    }

    for (var i = 2; i < arguments.length; i++) {
      var other = arguments[i];

      for (var p = 0; p < props.length; p++) {
        var prop = props[p];
        if (other.hasOwnProperty(prop)) {
          a[prop] = other[prop];
        }
      }
    }
    return a;
  };

  /**
   * Extend object a with selected properties of object b or a series of objects
   * Only properties with defined values are copied
   * @param {Array.<String>} props
   * @param {Object} a
   * @param {Object} b
   * @return {Object} a
   */
  exports.selectiveDeepExtend = function (props, a, b) {
    var allowDeletion = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

    // TODO: add support for Arrays to deepExtend
    if (Array.isArray(b)) {
      throw new TypeError('Arrays are not supported by deepExtend');
    }
    for (var i = 2; i < arguments.length; i++) {
      var other = arguments[i];
      for (var p = 0; p < props.length; p++) {
        var prop = props[p];
        if (other.hasOwnProperty(prop)) {
          if (b[prop] && b[prop].constructor === Object) {
            if (a[prop] === undefined) {
              a[prop] = {};
            }
            if (a[prop].constructor === Object) {
              exports.deepExtend(a[prop], b[prop], false, allowDeletion);
            } else {
              if (b[prop] === null && a[prop] !== undefined && allowDeletion === true) {
                delete a[prop];
              } else {
                a[prop] = b[prop];
              }
            }
          } else if (Array.isArray(b[prop])) {
            throw new TypeError('Arrays are not supported by deepExtend');
          } else {
            if (b[prop] === null && a[prop] !== undefined && allowDeletion === true) {
              delete a[prop];
            } else {
              a[prop] = b[prop];
            }
          }
        }
      }
    }
    return a;
  };

  /**
   * Extend object a with selected properties of object b or a series of objects
   * Only properties with defined values are copied
   * @param {Array.<String>} props
   * @param {Object} a
   * @param {Object} b
   * @return {Object} a
   */
  exports.selectiveNotDeepExtend = function (props, a, b) {
    var allowDeletion = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

    // TODO: add support for Arrays to deepExtend
    if (Array.isArray(b)) {
      throw new TypeError('Arrays are not supported by deepExtend');
    }
    for (var prop in b) {
      if (b.hasOwnProperty(prop)) {
        if (props.indexOf(prop) == -1) {
          if (b[prop] && b[prop].constructor === Object) {
            if (a[prop] === undefined) {
              a[prop] = {};
            }
            if (a[prop].constructor === Object) {
              exports.deepExtend(a[prop], b[prop]);
            } else {
              if (b[prop] === null && a[prop] !== undefined && allowDeletion === true) {
                delete a[prop];
              } else {
                a[prop] = b[prop];
              }
            }
          } else if (Array.isArray(b[prop])) {
            a[prop] = [];
            for (var i = 0; i < b[prop].length; i++) {
              a[prop].push(b[prop][i]);
            }
          } else {
            if (b[prop] === null && a[prop] !== undefined && allowDeletion === true) {
              delete a[prop];
            } else {
              a[prop] = b[prop];
            }
          }
        }
      }
    }
    return a;
  };

  /**
   * Deep extend an object a with the properties of object b
   * @param {Object} a
   * @param {Object} b
   * @param [Boolean] protoExtend --> optional parameter. If true, the prototype values will also be extended.
   *                                  (ie. the options objects that inherit from others will also get the inherited options)
   * @param [Boolean] global      --> optional parameter. If true, the values of fields that are null will not deleted
   * @returns {Object}
   */
  exports.deepExtend = function (a, b, protoExtend, allowDeletion) {
    for (var prop in b) {
      if (b.hasOwnProperty(prop) || protoExtend === true) {
        if (b[prop] && b[prop].constructor === Object) {
          if (a[prop] === undefined) {
            a[prop] = {};
          }
          if (a[prop].constructor === Object) {
            exports.deepExtend(a[prop], b[prop], protoExtend);
          } else {
            if (b[prop] === null && a[prop] !== undefined && allowDeletion === true) {
              delete a[prop];
            } else {
              a[prop] = b[prop];
            }
          }
        } else if (Array.isArray(b[prop])) {
          a[prop] = [];
          for (var i = 0; i < b[prop].length; i++) {
            a[prop].push(b[prop][i]);
          }
        } else {
          if (b[prop] === null && a[prop] !== undefined && allowDeletion === true) {
            delete a[prop];
          } else {
            a[prop] = b[prop];
          }
        }
      }
    }
    return a;
  };

  /**
   * Test whether all elements in two arrays are equal.
   * @param {Array} a
   * @param {Array} b
   * @return {boolean} Returns true if both arrays have the same length and same
   *                   elements.
   */
  exports.equalArray = function (a, b) {
    if (a.length != b.length) return false;

    for (var i = 0, len = a.length; i < len; i++) {
      if (a[i] != b[i]) return false;
    }

    return true;
  };

  /**
   * Convert an object to another type
   * @param {Boolean | Number | String | Date | Moment | Null | undefined} object
   * @param {String | undefined} type   Name of the type. Available types:
   *                                    'Boolean', 'Number', 'String',
   *                                    'Date', 'Moment', ISODate', 'ASPDate'.
   * @return {*} object
   * @throws Error
   */
  exports.convert = function (object, type) {
    var match;

    if (object === undefined) {
      return undefined;
    }
    if (object === null) {
      return null;
    }

    if (!type) {
      return object;
    }
    if (!(typeof type === 'string') && !(type instanceof String)) {
      throw new Error('Type must be a string');
    }

    //noinspection FallthroughInSwitchStatementJS
    switch (type) {
      case 'boolean':
      case 'Boolean':
        return Boolean(object);

      case 'number':
      case 'Number':
        return Number(object.valueOf());

      case 'string':
      case 'String':
        return String(object);

      case 'Date':
        if (exports.isNumber(object)) {
          return new Date(object);
        }
        if (object instanceof Date) {
          return new Date(object.valueOf());
        } else if (moment.isMoment(object)) {
          return new Date(object.valueOf());
        }
        if (exports.isString(object)) {
          match = ASPDateRegex.exec(object);
          if (match) {
            // object is an ASP date
            return new Date(Number(match[1])); // parse number
          } else {
              return moment(object).toDate(); // parse string
            }
        } else {
            throw new Error('Cannot convert object of type ' + exports.getType(object) + ' to type Date');
          }

      case 'Moment':
        if (exports.isNumber(object)) {
          return moment(object);
        }
        if (object instanceof Date) {
          return moment(object.valueOf());
        } else if (moment.isMoment(object)) {
          return moment(object);
        }
        if (exports.isString(object)) {
          match = ASPDateRegex.exec(object);
          if (match) {
            // object is an ASP date
            return moment(Number(match[1])); // parse number
          } else {
              return moment(object); // parse string
            }
        } else {
            throw new Error('Cannot convert object of type ' + exports.getType(object) + ' to type Date');
          }

      case 'ISODate':
        if (exports.isNumber(object)) {
          return new Date(object);
        } else if (object instanceof Date) {
          return object.toISOString();
        } else if (moment.isMoment(object)) {
          return object.toDate().toISOString();
        } else if (exports.isString(object)) {
          match = ASPDateRegex.exec(object);
          if (match) {
            // object is an ASP date
            return new Date(Number(match[1])).toISOString(); // parse number
          } else {
              return new Date(object).toISOString(); // parse string
            }
        } else {
            throw new Error('Cannot convert object of type ' + exports.getType(object) + ' to type ISODate');
          }

      case 'ASPDate':
        if (exports.isNumber(object)) {
          return '/Date(' + object + ')/';
        } else if (object instanceof Date) {
          return '/Date(' + object.valueOf() + ')/';
        } else if (exports.isString(object)) {
          match = ASPDateRegex.exec(object);
          var value;
          if (match) {
            // object is an ASP date
            value = new Date(Number(match[1])).valueOf(); // parse number
          } else {
              value = new Date(object).valueOf(); // parse string
            }
          return '/Date(' + value + ')/';
        } else {
          throw new Error('Cannot convert object of type ' + exports.getType(object) + ' to type ASPDate');
        }

      default:
        throw new Error('Unknown type "' + type + '"');
    }
  };

  // parse ASP.Net Date pattern,
  // for example '/Date(1198908717056)/' or '/Date(1198908717056-0700)/'
  // code from http://momentjs.com/
  var ASPDateRegex = /^\/?Date\((\-?\d+)/i;

  /**
   * Get the type of an object, for example exports.getType([]) returns 'Array'
   * @param {*} object
   * @return {String} type
   */
  exports.getType = function (object) {
    var type = typeof object === 'undefined' ? 'undefined' : _typeof(object);

    if (type == 'object') {
      if (object === null) {
        return 'null';
      }
      if (object instanceof Boolean) {
        return 'Boolean';
      }
      if (object instanceof Number) {
        return 'Number';
      }
      if (object instanceof String) {
        return 'String';
      }
      if (Array.isArray(object)) {
        return 'Array';
      }
      if (object instanceof Date) {
        return 'Date';
      }
      return 'Object';
    } else if (type == 'number') {
      return 'Number';
    } else if (type == 'boolean') {
      return 'Boolean';
    } else if (type == 'string') {
      return 'String';
    } else if (type === undefined) {
      return 'undefined';
    }

    return type;
  };

  /**
   * Used to extend an array and copy it. This is used to propagate paths recursively.
   *
   * @param arr
   * @param newValue
   * @returns {Array}
   */
  exports.copyAndExtendArray = function (arr, newValue) {
    var newArr = [];
    for (var i = 0; i < arr.length; i++) {
      newArr.push(arr[i]);
    }
    newArr.push(newValue);
    return newArr;
  };

  /**
   * Used to extend an array and copy it. This is used to propagate paths recursively.
   *
   * @param arr
   * @param newValue
   * @returns {Array}
   */
  exports.copyArray = function (arr) {
    var newArr = [];
    for (var i = 0; i < arr.length; i++) {
      newArr.push(arr[i]);
    }
    return newArr;
  };

  /**
   * Retrieve the absolute left value of a DOM element
   * @param {Element} elem        A dom element, for example a div
   * @return {number} left        The absolute left position of this element
   *                              in the browser page.
   */
  exports.getAbsoluteLeft = function (elem) {
    return elem.getBoundingClientRect().left;
  };

  exports.getAbsoluteRight = function (elem) {
    return elem.getBoundingClientRect().right;
  };

  /**
   * Retrieve the absolute top value of a DOM element
   * @param {Element} elem        A dom element, for example a div
   * @return {number} top        The absolute top position of this element
   *                              in the browser page.
   */
  exports.getAbsoluteTop = function (elem) {
    return elem.getBoundingClientRect().top;
  };

  /**
   * add a className to the given elements style
   * @param {Element} elem
   * @param {String} className
   */
  exports.addClassName = function (elem, className) {
    var classes = elem.className.split(' ');
    if (classes.indexOf(className) == -1) {
      classes.push(className); // add the class to the array
      elem.className = classes.join(' ');
    }
  };

  /**
   * add a className to the given elements style
   * @param {Element} elem
   * @param {String} className
   */
  exports.removeClassName = function (elem, className) {
    var classes = elem.className.split(' ');
    var index = classes.indexOf(className);
    if (index != -1) {
      classes.splice(index, 1); // remove the class from the array
      elem.className = classes.join(' ');
    }
  };

  /**
   * For each method for both arrays and objects.
   * In case of an array, the built-in Array.forEach() is applied.
   * In case of an Object, the method loops over all properties of the object.
   * @param {Object | Array} object   An Object or Array
   * @param {function} callback       Callback method, called for each item in
   *                                  the object or array with three parameters:
   *                                  callback(value, index, object)
   */
  exports.forEach = function (object, callback) {
    var i, len;
    if (Array.isArray(object)) {
      // array
      for (i = 0, len = object.length; i < len; i++) {
        callback(object[i], i, object);
      }
    } else {
      // object
      for (i in object) {
        if (object.hasOwnProperty(i)) {
          callback(object[i], i, object);
        }
      }
    }
  };

  /**
   * Convert an object into an array: all objects properties are put into the
   * array. The resulting array is unordered.
   * @param {Object} object
   * @param {Array} array
   */
  exports.toArray = function (object) {
    var array = [];

    for (var prop in object) {
      if (object.hasOwnProperty(prop)) array.push(object[prop]);
    }

    return array;
  };

  /**
   * Update a property in an object
   * @param {Object} object
   * @param {String} key
   * @param {*} value
   * @return {Boolean} changed
   */
  exports.updateProperty = function (object, key, value) {
    if (object[key] !== value) {
      object[key] = value;
      return true;
    } else {
      return false;
    }
  };

  /**
   * Throttle the given function to be only executed once every `wait` milliseconds
   * @param {function} fn
   * @param {number} wait    Time in milliseconds
   * @returns {function} Returns the throttled function
   */
  exports.throttle = function (fn, wait) {
    var timeout = null;
    var needExecution = false;

    return function throttled() {
      if (!timeout) {
        needExecution = false;
        fn();

        timeout = setTimeout(function () {
          timeout = null;
          if (needExecution) {
            throttled();
          }
        }, wait);
      } else {
        needExecution = true;
      }
    };
  };

  /**
   * Add and event listener. Works for all browsers
   * @param {Element}     element    An html element
   * @param {string}      action     The action, for example "click",
   *                                 without the prefix "on"
   * @param {function}    listener   The callback function to be executed
   * @param {boolean}     [useCapture]
   */
  exports.addEventListener = function (element, action, listener, useCapture) {
    if (element.addEventListener) {
      if (useCapture === undefined) useCapture = false;

      if (action === "mousewheel" && navigator.userAgent.indexOf("Firefox") >= 0) {
        action = "DOMMouseScroll"; // For Firefox
      }

      element.addEventListener(action, listener, useCapture);
    } else {
      element.attachEvent("on" + action, listener); // IE browsers
    }
  };

  /**
   * Remove an event listener from an element
   * @param {Element}     element         An html dom element
   * @param {string}      action          The name of the event, for example "mousedown"
   * @param {function}    listener        The listener function
   * @param {boolean}     [useCapture]
   */
  exports.removeEventListener = function (element, action, listener, useCapture) {
    if (element.removeEventListener) {
      // non-IE browsers
      if (useCapture === undefined) useCapture = false;

      if (action === "mousewheel" && navigator.userAgent.indexOf("Firefox") >= 0) {
        action = "DOMMouseScroll"; // For Firefox
      }

      element.removeEventListener(action, listener, useCapture);
    } else {
      // IE browsers
      element.detachEvent("on" + action, listener);
    }
  };

  /**
   * Cancels the event if it is cancelable, without stopping further propagation of the event.
   */
  exports.preventDefault = function (event) {
    if (!event) event = window.event;

    if (event.preventDefault) {
      event.preventDefault(); // non-IE browsers
    } else {
        event.returnValue = false; // IE browsers
      }
  };

  /**
   * Get HTML element which is the target of the event
   * @param {Event} event
   * @return {Element} target element
   */
  exports.getTarget = function (event) {
    // code from http://www.quirksmode.org/js/events_properties.html
    if (!event) {
      event = window.event;
    }

    var target;

    if (event.target) {
      target = event.target;
    } else if (event.srcElement) {
      target = event.srcElement;
    }

    if (target.nodeType != undefined && target.nodeType == 3) {
      // defeat Safari bug
      target = target.parentNode;
    }

    return target;
  };

  /**
   * Check if given element contains given parent somewhere in the DOM tree
   * @param {Element} element
   * @param {Element} parent
   */
  exports.hasParent = function (element, parent) {
    var e = element;

    while (e) {
      if (e === parent) {
        return true;
      }
      e = e.parentNode;
    }

    return false;
  };

  exports.option = {};

  /**
   * Convert a value into a boolean
   * @param {Boolean | function | undefined} value
   * @param {Boolean} [defaultValue]
   * @returns {Boolean} bool
   */
  exports.option.asBoolean = function (value, defaultValue) {
    if (typeof value == 'function') {
      value = value();
    }

    if (value != null) {
      return value != false;
    }

    return defaultValue || null;
  };

  /**
   * Convert a value into a number
   * @param {Boolean | function | undefined} value
   * @param {Number} [defaultValue]
   * @returns {Number} number
   */
  exports.option.asNumber = function (value, defaultValue) {
    if (typeof value == 'function') {
      value = value();
    }

    if (value != null) {
      return Number(value) || defaultValue || null;
    }

    return defaultValue || null;
  };

  /**
   * Convert a value into a string
   * @param {String | function | undefined} value
   * @param {String} [defaultValue]
   * @returns {String} str
   */
  exports.option.asString = function (value, defaultValue) {
    if (typeof value == 'function') {
      value = value();
    }

    if (value != null) {
      return String(value);
    }

    return defaultValue || null;
  };

  /**
   * Convert a size or location into a string with pixels or a percentage
   * @param {String | Number | function | undefined} value
   * @param {String} [defaultValue]
   * @returns {String} size
   */
  exports.option.asSize = function (value, defaultValue) {
    if (typeof value == 'function') {
      value = value();
    }

    if (exports.isString(value)) {
      return value;
    } else if (exports.isNumber(value)) {
      return value + 'px';
    } else {
      return defaultValue || null;
    }
  };

  /**
   * Convert a value into a DOM element
   * @param {HTMLElement | function | undefined} value
   * @param {HTMLElement} [defaultValue]
   * @returns {HTMLElement | null} dom
   */
  exports.option.asElement = function (value, defaultValue) {
    if (typeof value == 'function') {
      value = value();
    }

    return value || defaultValue || null;
  };

  /**
   * http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
   *
   * @param {String} hex
   * @returns {{r: *, g: *, b: *}} | 255 range
   */
  exports.hexToRGB = function (hex) {
    // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
    var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    hex = hex.replace(shorthandRegex, function (m, r, g, b) {
      return r + r + g + g + b + b;
    });
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : null;
  };

  /**
   * This function takes color in hex format or rgb() or rgba() format and overrides the opacity. Returns rgba() string.
   * @param color
   * @param opacity
   * @returns {*}
   */
  exports.overrideOpacity = function (color, opacity) {
    if (color.indexOf("rgba") != -1) {
      return color;
    } else if (color.indexOf("rgb") != -1) {
      var rgb = color.substr(color.indexOf("(") + 1).replace(")", "").split(",");
      return "rgba(" + rgb[0] + "," + rgb[1] + "," + rgb[2] + "," + opacity + ")";
    } else {
      var rgb = exports.hexToRGB(color);
      if (rgb == null) {
        return color;
      } else {
        return "rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + "," + opacity + ")";
      }
    }
  };

  /**
   *
   * @param red     0 -- 255
   * @param green   0 -- 255
   * @param blue    0 -- 255
   * @returns {string}
   * @constructor
   */
  exports.RGBToHex = function (red, green, blue) {
    return "#" + ((1 << 24) + (red << 16) + (green << 8) + blue).toString(16).slice(1);
  };

  /**
   * Parse a color property into an object with border, background, and
   * highlight colors
   * @param {Object | String} color
   * @return {Object} colorObject
   */
  exports.parseColor = function (color) {
    var c;
    if (exports.isString(color) === true) {
      if (exports.isValidRGB(color) === true) {
        var rgb = color.substr(4).substr(0, color.length - 5).split(',').map(function (value) {
          return parseInt(value);
        });
        color = exports.RGBToHex(rgb[0], rgb[1], rgb[2]);
      }
      if (exports.isValidHex(color) === true) {
        var hsv = exports.hexToHSV(color);
        var lighterColorHSV = { h: hsv.h, s: hsv.s * 0.8, v: Math.min(1, hsv.v * 1.02) };
        var darkerColorHSV = { h: hsv.h, s: Math.min(1, hsv.s * 1.25), v: hsv.v * 0.8 };
        var darkerColorHex = exports.HSVToHex(darkerColorHSV.h, darkerColorHSV.s, darkerColorHSV.v);
        var lighterColorHex = exports.HSVToHex(lighterColorHSV.h, lighterColorHSV.s, lighterColorHSV.v);
        c = {
          background: color,
          border: darkerColorHex,
          highlight: {
            background: lighterColorHex,
            border: darkerColorHex
          },
          hover: {
            background: lighterColorHex,
            border: darkerColorHex
          }
        };
      } else {
        c = {
          background: color,
          border: color,
          highlight: {
            background: color,
            border: color
          },
          hover: {
            background: color,
            border: color
          }
        };
      }
    } else {
      c = {};
      c.background = color.background || undefined;
      c.border = color.border || undefined;

      if (exports.isString(color.highlight)) {
        c.highlight = {
          border: color.highlight,
          background: color.highlight
        };
      } else {
        c.highlight = {};
        c.highlight.background = color.highlight && color.highlight.background || undefined;
        c.highlight.border = color.highlight && color.highlight.border || undefined;
      }

      if (exports.isString(color.hover)) {
        c.hover = {
          border: color.hover,
          background: color.hover
        };
      } else {
        c.hover = {};
        c.hover.background = color.hover && color.hover.background || undefined;
        c.hover.border = color.hover && color.hover.border || undefined;
      }
    }

    return c;
  };

  /**
   * http://www.javascripter.net/faq/rgb2hsv.htm
   *
   * @param red
   * @param green
   * @param blue
   * @returns {*}
   * @constructor
   */
  exports.RGBToHSV = function (red, green, blue) {
    red = red / 255;green = green / 255;blue = blue / 255;
    var minRGB = Math.min(red, Math.min(green, blue));
    var maxRGB = Math.max(red, Math.max(green, blue));

    // Black-gray-white
    if (minRGB == maxRGB) {
      return { h: 0, s: 0, v: minRGB };
    }

    // Colors other than black-gray-white:
    var d = red == minRGB ? green - blue : blue == minRGB ? red - green : blue - red;
    var h = red == minRGB ? 3 : blue == minRGB ? 1 : 5;
    var hue = 60 * (h - d / (maxRGB - minRGB)) / 360;
    var saturation = (maxRGB - minRGB) / maxRGB;
    var value = maxRGB;
    return { h: hue, s: saturation, v: value };
  };

  var cssUtil = {
    // split a string with css styles into an object with key/values
    split: function split(cssText) {
      var styles = {};

      cssText.split(';').forEach(function (style) {
        if (style.trim() != '') {
          var parts = style.split(':');
          var key = parts[0].trim();
          var value = parts[1].trim();
          styles[key] = value;
        }
      });

      return styles;
    },

    // build a css text string from an object with key/values
    join: function join(styles) {
      return Object.keys(styles).map(function (key) {
        return key + ': ' + styles[key];
      }).join('; ');
    }
  };

  /**
   * Append a string with css styles to an element
   * @param {Element} element
   * @param {String} cssText
   */
  exports.addCssText = function (element, cssText) {
    var currentStyles = cssUtil.split(element.style.cssText);
    var newStyles = cssUtil.split(cssText);
    var styles = exports.extend(currentStyles, newStyles);

    element.style.cssText = cssUtil.join(styles);
  };

  /**
   * Remove a string with css styles from an element
   * @param {Element} element
   * @param {String} cssText
   */
  exports.removeCssText = function (element, cssText) {
    var styles = cssUtil.split(element.style.cssText);
    var removeStyles = cssUtil.split(cssText);

    for (var key in removeStyles) {
      if (removeStyles.hasOwnProperty(key)) {
        delete styles[key];
      }
    }

    element.style.cssText = cssUtil.join(styles);
  };

  /**
   * https://gist.github.com/mjijackson/5311256
   * @param h
   * @param s
   * @param v
   * @returns {{r: number, g: number, b: number}}
   * @constructor
   */
  exports.HSVToRGB = function (h, s, v) {
    var r, g, b;

    var i = Math.floor(h * 6);
    var f = h * 6 - i;
    var p = v * (1 - s);
    var q = v * (1 - f * s);
    var t = v * (1 - (1 - f) * s);

    switch (i % 6) {
      case 0:
        r = v, g = t, b = p;break;
      case 1:
        r = q, g = v, b = p;break;
      case 2:
        r = p, g = v, b = t;break;
      case 3:
        r = p, g = q, b = v;break;
      case 4:
        r = t, g = p, b = v;break;
      case 5:
        r = v, g = p, b = q;break;
    }

    return { r: Math.floor(r * 255), g: Math.floor(g * 255), b: Math.floor(b * 255) };
  };

  exports.HSVToHex = function (h, s, v) {
    var rgb = exports.HSVToRGB(h, s, v);
    return exports.RGBToHex(rgb.r, rgb.g, rgb.b);
  };

  exports.hexToHSV = function (hex) {
    var rgb = exports.hexToRGB(hex);
    return exports.RGBToHSV(rgb.r, rgb.g, rgb.b);
  };

  exports.isValidHex = function (hex) {
    var isOk = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(hex);
    return isOk;
  };

  exports.isValidRGB = function (rgb) {
    rgb = rgb.replace(" ", "");
    var isOk = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/i.test(rgb);
    return isOk;
  };
  exports.isValidRGBA = function (rgba) {
    rgba = rgba.replace(" ", "");
    var isOk = /rgba\((\d{1,3}),(\d{1,3}),(\d{1,3}),(.{1,3})\)/i.test(rgba);
    return isOk;
  };

  /**
   * This recursively redirects the prototype of JSON objects to the referenceObject
   * This is used for default options.
   *
   * @param referenceObject
   * @returns {*}
   */
  exports.selectiveBridgeObject = function (fields, referenceObject) {
    if ((typeof referenceObject === 'undefined' ? 'undefined' : _typeof(referenceObject)) == "object") {
      var objectTo = Object.create(referenceObject);
      for (var i = 0; i < fields.length; i++) {
        if (referenceObject.hasOwnProperty(fields[i])) {
          if (_typeof(referenceObject[fields[i]]) == "object") {
            objectTo[fields[i]] = exports.bridgeObject(referenceObject[fields[i]]);
          }
        }
      }
      return objectTo;
    } else {
      return null;
    }
  };

  /**
   * This recursively redirects the prototype of JSON objects to the referenceObject
   * This is used for default options.
   *
   * @param referenceObject
   * @returns {*}
   */
  exports.bridgeObject = function (referenceObject) {
    if ((typeof referenceObject === 'undefined' ? 'undefined' : _typeof(referenceObject)) == "object") {
      var objectTo = Object.create(referenceObject);
      for (var i in referenceObject) {
        if (referenceObject.hasOwnProperty(i)) {
          if (_typeof(referenceObject[i]) == "object") {
            objectTo[i] = exports.bridgeObject(referenceObject[i]);
          }
        }
      }
      return objectTo;
    } else {
      return null;
    }
  };

  /**
   * This method provides a stable sort implementation, very fast for presorted data
   *
   * @param a the array
   * @param a order comparator
   * @returns {the array}
   */
  exports.insertSort = function (a, compare) {
    for (var i = 0; i < a.length; i++) {
      var k = a[i];
      for (var j = i; j > 0 && compare(k, a[j - 1]) < 0; j--) {
        a[j] = a[j - 1];
      }
      a[j] = k;
    }
    return a;
  };

  /**
   * this is used to set the options of subobjects in the options object. A requirement of these subobjects
   * is that they have an 'enabled' element which is optional for the user but mandatory for the program.
   *
   * @param [object] mergeTarget | this is either this.options or the options used for the groups.
   * @param [object] options     | options
   * @param [String] option      | this is the option key in the options argument
   */
  exports.mergeOptions = function (mergeTarget, options, option) {
    var allowDeletion = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];
    var globalOptions = arguments.length <= 4 || arguments[4] === undefined ? {} : arguments[4];

    if (options[option] === null) {
      mergeTarget[option] = Object.create(globalOptions[option]);
    } else {
      if (options[option] !== undefined) {
        if (typeof options[option] === 'boolean') {
          mergeTarget[option].enabled = options[option];
        } else {
          if (options[option].enabled === undefined) {
            mergeTarget[option].enabled = true;
          }
          for (var prop in options[option]) {
            if (options[option].hasOwnProperty(prop)) {
              mergeTarget[option][prop] = options[option][prop];
            }
          }
        }
      }
    }
  };

  /**
   * This function does a binary search for a visible item in a sorted list. If we find a visible item, the code that uses
   * this function will then iterate in both directions over this sorted list to find all visible items.
   *
   * @param {Item[]} orderedItems       | Items ordered by start
   * @param {function} comparator       | -1 is lower, 0 is equal, 1 is higher
   * @param {String} field
   * @param {String} field2
   * @returns {number}
   * @private
   */
  exports.binarySearchCustom = function (orderedItems, comparator, field, field2) {
    var maxIterations = 10000;
    var iteration = 0;
    var low = 0;
    var high = orderedItems.length - 1;

    while (low <= high && iteration < maxIterations) {
      var middle = Math.floor((low + high) / 2);

      var item = orderedItems[middle];
      var value = field2 === undefined ? item[field] : item[field][field2];

      var searchResult = comparator(value);
      if (searchResult == 0) {
        // jihaa, found a visible item!
        return middle;
      } else if (searchResult == -1) {
        // it is too small --> increase low
        low = middle + 1;
      } else {
        // it is too big --> decrease high
        high = middle - 1;
      }

      iteration++;
    }

    return -1;
  };

  /**
   * This function does a binary search for a specific value in a sorted array. If it does not exist but is in between of
   * two values, we return either the one before or the one after, depending on user input
   * If it is found, we return the index, else -1.
   *
   * @param {Array} orderedItems
   * @param {{start: number, end: number}} target
   * @param {String} field
   * @param {String} sidePreference   'before' or 'after'
   * @param {function} comparator an optional comparator, returning -1,0,1 for <,==,>.
   * @returns {number}
   * @private
   */
  exports.binarySearchValue = function (orderedItems, target, field, sidePreference, comparator) {
    var maxIterations = 10000;
    var iteration = 0;
    var low = 0;
    var high = orderedItems.length - 1;
    var prevValue, value, nextValue, middle;

    var comparator = comparator != undefined ? comparator : function (a, b) {
      return a == b ? 0 : a < b ? -1 : 1;
    };

    while (low <= high && iteration < maxIterations) {
      // get a new guess
      middle = Math.floor(0.5 * (high + low));
      prevValue = orderedItems[Math.max(0, middle - 1)][field];
      value = orderedItems[middle][field];
      nextValue = orderedItems[Math.min(orderedItems.length - 1, middle + 1)][field];

      if (comparator(value, target) == 0) {
        // we found the target
        return middle;
      } else if (comparator(prevValue, target) < 0 && comparator(value, target) > 0) {
        // target is in between of the previous and the current
        return sidePreference == 'before' ? Math.max(0, middle - 1) : middle;
      } else if (comparator(value, target) < 0 && comparator(nextValue, target) > 0) {
        // target is in between of the current and the next
        return sidePreference == 'before' ? middle : Math.min(orderedItems.length - 1, middle + 1);
      } else {
        // didnt find the target, we need to change our boundaries.
        if (comparator(value, target) < 0) {
          // it is too small --> increase low
          low = middle + 1;
        } else {
          // it is too big --> decrease high
          high = middle - 1;
        }
      }
      iteration++;
    }

    // didnt find anything. Return -1.
    return -1;
  };

  /*
   * Easing Functions - inspired from http://gizma.com/easing/
   * only considering the t value for the range [0, 1] => [0, 1]
   * https://gist.github.com/gre/1650294
   */
  exports.easingFunctions = {
    // no easing, no acceleration
    linear: function linear(t) {
      return t;
    },
    // accelerating from zero velocity
    easeInQuad: function easeInQuad(t) {
      return t * t;
    },
    // decelerating to zero velocity
    easeOutQuad: function easeOutQuad(t) {
      return t * (2 - t);
    },
    // acceleration until halfway, then deceleration
    easeInOutQuad: function easeInOutQuad(t) {
      return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    },
    // accelerating from zero velocity
    easeInCubic: function easeInCubic(t) {
      return t * t * t;
    },
    // decelerating to zero velocity
    easeOutCubic: function easeOutCubic(t) {
      return --t * t * t + 1;
    },
    // acceleration until halfway, then deceleration
    easeInOutCubic: function easeInOutCubic(t) {
      return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
    },
    // accelerating from zero velocity
    easeInQuart: function easeInQuart(t) {
      return t * t * t * t;
    },
    // decelerating to zero velocity
    easeOutQuart: function easeOutQuart(t) {
      return 1 - --t * t * t * t;
    },
    // acceleration until halfway, then deceleration
    easeInOutQuart: function easeInOutQuart(t) {
      return t < .5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
    },
    // accelerating from zero velocity
    easeInQuint: function easeInQuint(t) {
      return t * t * t * t * t;
    },
    // decelerating to zero velocity
    easeOutQuint: function easeOutQuint(t) {
      return 1 + --t * t * t * t * t;
    },
    // acceleration until halfway, then deceleration
    easeInOutQuint: function easeInOutQuint(t) {
      return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
    }
  };

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  // first check if moment.js is already loaded in the browser window, if so,
  // use this instance. Else, load via commonjs.
  module.exports = typeof window !== 'undefined' && window['moment'] || __webpack_require__(3);

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

  /* WEBPACK VAR INJECTION */(function(module) {//! moment.js
  //! version : 2.13.0
  //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
  //! license : MIT
  //! momentjs.com

  ;(function (global, factory) {
       true ? module.exports = factory() :
      typeof define === 'function' && define.amd ? define(factory) :
      global.moment = factory()
  }(this, function () { 'use strict';

      var hookCallback;

      function utils_hooks__hooks () {
          return hookCallback.apply(null, arguments);
      }

      // This is done to register the method called with moment()
      // without creating circular dependencies.
      function setHookCallback (callback) {
          hookCallback = callback;
      }

      function isArray(input) {
          return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
      }

      function isDate(input) {
          return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
      }

      function map(arr, fn) {
          var res = [], i;
          for (i = 0; i < arr.length; ++i) {
              res.push(fn(arr[i], i));
          }
          return res;
      }

      function hasOwnProp(a, b) {
          return Object.prototype.hasOwnProperty.call(a, b);
      }

      function extend(a, b) {
          for (var i in b) {
              if (hasOwnProp(b, i)) {
                  a[i] = b[i];
              }
          }

          if (hasOwnProp(b, 'toString')) {
              a.toString = b.toString;
          }

          if (hasOwnProp(b, 'valueOf')) {
              a.valueOf = b.valueOf;
          }

          return a;
      }

      function create_utc__createUTC (input, format, locale, strict) {
          return createLocalOrUTC(input, format, locale, strict, true).utc();
      }

      function defaultParsingFlags() {
          // We need to deep clone this object.
          return {
              empty           : false,
              unusedTokens    : [],
              unusedInput     : [],
              overflow        : -2,
              charsLeftOver   : 0,
              nullInput       : false,
              invalidMonth    : null,
              invalidFormat   : false,
              userInvalidated : false,
              iso             : false,
              parsedDateParts : [],
              meridiem        : null
          };
      }

      function getParsingFlags(m) {
          if (m._pf == null) {
              m._pf = defaultParsingFlags();
          }
          return m._pf;
      }

      var some;
      if (Array.prototype.some) {
          some = Array.prototype.some;
      } else {
          some = function (fun) {
              var t = Object(this);
              var len = t.length >>> 0;

              for (var i = 0; i < len; i++) {
                  if (i in t && fun.call(this, t[i], i, t)) {
                      return true;
                  }
              }

              return false;
          };
      }

      function valid__isValid(m) {
          if (m._isValid == null) {
              var flags = getParsingFlags(m);
              var parsedParts = some.call(flags.parsedDateParts, function (i) {
                  return i != null;
              });
              m._isValid = !isNaN(m._d.getTime()) &&
                  flags.overflow < 0 &&
                  !flags.empty &&
                  !flags.invalidMonth &&
                  !flags.invalidWeekday &&
                  !flags.nullInput &&
                  !flags.invalidFormat &&
                  !flags.userInvalidated &&
                  (!flags.meridiem || (flags.meridiem && parsedParts));

              if (m._strict) {
                  m._isValid = m._isValid &&
                      flags.charsLeftOver === 0 &&
                      flags.unusedTokens.length === 0 &&
                      flags.bigHour === undefined;
              }
          }
          return m._isValid;
      }

      function valid__createInvalid (flags) {
          var m = create_utc__createUTC(NaN);
          if (flags != null) {
              extend(getParsingFlags(m), flags);
          }
          else {
              getParsingFlags(m).userInvalidated = true;
          }

          return m;
      }

      function isUndefined(input) {
          return input === void 0;
      }

      // Plugins that add properties should also add the key here (null value),
      // so we can properly clone ourselves.
      var momentProperties = utils_hooks__hooks.momentProperties = [];

      function copyConfig(to, from) {
          var i, prop, val;

          if (!isUndefined(from._isAMomentObject)) {
              to._isAMomentObject = from._isAMomentObject;
          }
          if (!isUndefined(from._i)) {
              to._i = from._i;
          }
          if (!isUndefined(from._f)) {
              to._f = from._f;
          }
          if (!isUndefined(from._l)) {
              to._l = from._l;
          }
          if (!isUndefined(from._strict)) {
              to._strict = from._strict;
          }
          if (!isUndefined(from._tzm)) {
              to._tzm = from._tzm;
          }
          if (!isUndefined(from._isUTC)) {
              to._isUTC = from._isUTC;
          }
          if (!isUndefined(from._offset)) {
              to._offset = from._offset;
          }
          if (!isUndefined(from._pf)) {
              to._pf = getParsingFlags(from);
          }
          if (!isUndefined(from._locale)) {
              to._locale = from._locale;
          }

          if (momentProperties.length > 0) {
              for (i in momentProperties) {
                  prop = momentProperties[i];
                  val = from[prop];
                  if (!isUndefined(val)) {
                      to[prop] = val;
                  }
              }
          }

          return to;
      }

      var updateInProgress = false;

      // Moment prototype object
      function Moment(config) {
          copyConfig(this, config);
          this._d = new Date(config._d != null ? config._d.getTime() : NaN);
          // Prevent infinite loop in case updateOffset creates new moment
          // objects.
          if (updateInProgress === false) {
              updateInProgress = true;
              utils_hooks__hooks.updateOffset(this);
              updateInProgress = false;
          }
      }

      function isMoment (obj) {
          return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
      }

      function absFloor (number) {
          if (number < 0) {
              return Math.ceil(number);
          } else {
              return Math.floor(number);
          }
      }

      function toInt(argumentForCoercion) {
          var coercedNumber = +argumentForCoercion,
              value = 0;

          if (coercedNumber !== 0 && isFinite(coercedNumber)) {
              value = absFloor(coercedNumber);
          }

          return value;
      }

      // compare two arrays, return the number of differences
      function compareArrays(array1, array2, dontConvert) {
          var len = Math.min(array1.length, array2.length),
              lengthDiff = Math.abs(array1.length - array2.length),
              diffs = 0,
              i;
          for (i = 0; i < len; i++) {
              if ((dontConvert && array1[i] !== array2[i]) ||
                  (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                  diffs++;
              }
          }
          return diffs + lengthDiff;
      }

      function warn(msg) {
          if (utils_hooks__hooks.suppressDeprecationWarnings === false &&
                  (typeof console !==  'undefined') && console.warn) {
              console.warn('Deprecation warning: ' + msg);
          }
      }

      function deprecate(msg, fn) {
          var firstTime = true;

          return extend(function () {
              if (utils_hooks__hooks.deprecationHandler != null) {
                  utils_hooks__hooks.deprecationHandler(null, msg);
              }
              if (firstTime) {
                  warn(msg + '\nArguments: ' + Array.prototype.slice.call(arguments).join(', ') + '\n' + (new Error()).stack);
                  firstTime = false;
              }
              return fn.apply(this, arguments);
          }, fn);
      }

      var deprecations = {};

      function deprecateSimple(name, msg) {
          if (utils_hooks__hooks.deprecationHandler != null) {
              utils_hooks__hooks.deprecationHandler(name, msg);
          }
          if (!deprecations[name]) {
              warn(msg);
              deprecations[name] = true;
          }
      }

      utils_hooks__hooks.suppressDeprecationWarnings = false;
      utils_hooks__hooks.deprecationHandler = null;

      function isFunction(input) {
          return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
      }

      function isObject(input) {
          return Object.prototype.toString.call(input) === '[object Object]';
      }

      function locale_set__set (config) {
          var prop, i;
          for (i in config) {
              prop = config[i];
              if (isFunction(prop)) {
                  this[i] = prop;
              } else {
                  this['_' + i] = prop;
              }
          }
          this._config = config;
          // Lenient ordinal parsing accepts just a number in addition to
          // number + (possibly) stuff coming from _ordinalParseLenient.
          this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
      }

      function mergeConfigs(parentConfig, childConfig) {
          var res = extend({}, parentConfig), prop;
          for (prop in childConfig) {
              if (hasOwnProp(childConfig, prop)) {
                  if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                      res[prop] = {};
                      extend(res[prop], parentConfig[prop]);
                      extend(res[prop], childConfig[prop]);
                  } else if (childConfig[prop] != null) {
                      res[prop] = childConfig[prop];
                  } else {
                      delete res[prop];
                  }
              }
          }
          return res;
      }

      function Locale(config) {
          if (config != null) {
              this.set(config);
          }
      }

      var keys;

      if (Object.keys) {
          keys = Object.keys;
      } else {
          keys = function (obj) {
              var i, res = [];
              for (i in obj) {
                  if (hasOwnProp(obj, i)) {
                      res.push(i);
                  }
              }
              return res;
          };
      }

      // internal storage for locale config files
      var locales = {};
      var globalLocale;

      function normalizeLocale(key) {
          return key ? key.toLowerCase().replace('_', '-') : key;
      }

      // pick the locale from the array
      // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
      // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
      function chooseLocale(names) {
          var i = 0, j, next, locale, split;

          while (i < names.length) {
              split = normalizeLocale(names[i]).split('-');
              j = split.length;
              next = normalizeLocale(names[i + 1]);
              next = next ? next.split('-') : null;
              while (j > 0) {
                  locale = loadLocale(split.slice(0, j).join('-'));
                  if (locale) {
                      return locale;
                  }
                  if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                      //the next array item is better than a shallower substring of this one
                      break;
                  }
                  j--;
              }
              i++;
          }
          return null;
      }

      function loadLocale(name) {
          var oldLocale = null;
          // TODO: Find a better way to register and load all the locales in Node
          if (!locales[name] && (typeof module !== 'undefined') &&
                  module && module.exports) {
              try {
                  oldLocale = globalLocale._abbr;
                  !(function webpackMissingModule() { var e = new Error("Cannot find module \"./locale\""); e.code = 'MODULE_NOT_FOUND'; throw e; }());
                  // because defineLocale currently also sets the global locale, we
                  // want to undo that for lazy loaded locales
                  locale_locales__getSetGlobalLocale(oldLocale);
              } catch (e) { }
          }
          return locales[name];
      }

      // This function will load locale and then set the global locale.  If
      // no arguments are passed in, it will simply return the current global
      // locale key.
      function locale_locales__getSetGlobalLocale (key, values) {
          var data;
          if (key) {
              if (isUndefined(values)) {
                  data = locale_locales__getLocale(key);
              }
              else {
                  data = defineLocale(key, values);
              }

              if (data) {
                  // moment.duration._locale = moment._locale = data;
                  globalLocale = data;
              }
          }

          return globalLocale._abbr;
      }

      function defineLocale (name, config) {
          if (config !== null) {
              config.abbr = name;
              if (locales[name] != null) {
                  deprecateSimple('defineLocaleOverride',
                          'use moment.updateLocale(localeName, config) to change ' +
                          'an existing locale. moment.defineLocale(localeName, ' +
                          'config) should only be used for creating a new locale');
                  config = mergeConfigs(locales[name]._config, config);
              } else if (config.parentLocale != null) {
                  if (locales[config.parentLocale] != null) {
                      config = mergeConfigs(locales[config.parentLocale]._config, config);
                  } else {
                      // treat as if there is no base config
                      deprecateSimple('parentLocaleUndefined',
                              'specified parentLocale is not defined yet');
                  }
              }
              locales[name] = new Locale(config);

              // backwards compat for now: also set the locale
              locale_locales__getSetGlobalLocale(name);

              return locales[name];
          } else {
              // useful for testing
              delete locales[name];
              return null;
          }
      }

      function updateLocale(name, config) {
          if (config != null) {
              var locale;
              if (locales[name] != null) {
                  config = mergeConfigs(locales[name]._config, config);
              }
              locale = new Locale(config);
              locale.parentLocale = locales[name];
              locales[name] = locale;

              // backwards compat for now: also set the locale
              locale_locales__getSetGlobalLocale(name);
          } else {
              // pass null for config to unupdate, useful for tests
              if (locales[name] != null) {
                  if (locales[name].parentLocale != null) {
                      locales[name] = locales[name].parentLocale;
                  } else if (locales[name] != null) {
                      delete locales[name];
                  }
              }
          }
          return locales[name];
      }

      // returns locale data
      function locale_locales__getLocale (key) {
          var locale;

          if (key && key._locale && key._locale._abbr) {
              key = key._locale._abbr;
          }

          if (!key) {
              return globalLocale;
          }

          if (!isArray(key)) {
              //short-circuit everything else
              locale = loadLocale(key);
              if (locale) {
                  return locale;
              }
              key = [key];
          }

          return chooseLocale(key);
      }

      function locale_locales__listLocales() {
          return keys(locales);
      }

      var aliases = {};

      function addUnitAlias (unit, shorthand) {
          var lowerCase = unit.toLowerCase();
          aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
      }

      function normalizeUnits(units) {
          return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
      }

      function normalizeObjectUnits(inputObject) {
          var normalizedInput = {},
              normalizedProp,
              prop;

          for (prop in inputObject) {
              if (hasOwnProp(inputObject, prop)) {
                  normalizedProp = normalizeUnits(prop);
                  if (normalizedProp) {
                      normalizedInput[normalizedProp] = inputObject[prop];
                  }
              }
          }

          return normalizedInput;
      }

      function makeGetSet (unit, keepTime) {
          return function (value) {
              if (value != null) {
                  get_set__set(this, unit, value);
                  utils_hooks__hooks.updateOffset(this, keepTime);
                  return this;
              } else {
                  return get_set__get(this, unit);
              }
          };
      }

      function get_set__get (mom, unit) {
          return mom.isValid() ?
              mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
      }

      function get_set__set (mom, unit, value) {
          if (mom.isValid()) {
              mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
          }
      }

      // MOMENTS

      function getSet (units, value) {
          var unit;
          if (typeof units === 'object') {
              for (unit in units) {
                  this.set(unit, units[unit]);
              }
          } else {
              units = normalizeUnits(units);
              if (isFunction(this[units])) {
                  return this[units](value);
              }
          }
          return this;
      }

      function zeroFill(number, targetLength, forceSign) {
          var absNumber = '' + Math.abs(number),
              zerosToFill = targetLength - absNumber.length,
              sign = number >= 0;
          return (sign ? (forceSign ? '+' : '') : '-') +
              Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
      }

      var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

      var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

      var formatFunctions = {};

      var formatTokenFunctions = {};

      // token:    'M'
      // padded:   ['MM', 2]
      // ordinal:  'Mo'
      // callback: function () { this.month() + 1 }
      function addFormatToken (token, padded, ordinal, callback) {
          var func = callback;
          if (typeof callback === 'string') {
              func = function () {
                  return this[callback]();
              };
          }
          if (token) {
              formatTokenFunctions[token] = func;
          }
          if (padded) {
              formatTokenFunctions[padded[0]] = function () {
                  return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
              };
          }
          if (ordinal) {
              formatTokenFunctions[ordinal] = function () {
                  return this.localeData().ordinal(func.apply(this, arguments), token);
              };
          }
      }

      function removeFormattingTokens(input) {
          if (input.match(/\[[\s\S]/)) {
              return input.replace(/^\[|\]$/g, '');
          }
          return input.replace(/\\/g, '');
      }

      function makeFormatFunction(format) {
          var array = format.match(formattingTokens), i, length;

          for (i = 0, length = array.length; i < length; i++) {
              if (formatTokenFunctions[array[i]]) {
                  array[i] = formatTokenFunctions[array[i]];
              } else {
                  array[i] = removeFormattingTokens(array[i]);
              }
          }

          return function (mom) {
              var output = '', i;
              for (i = 0; i < length; i++) {
                  output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
              }
              return output;
          };
      }

      // format date using native date object
      function formatMoment(m, format) {
          if (!m.isValid()) {
              return m.localeData().invalidDate();
          }

          format = expandFormat(format, m.localeData());
          formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

          return formatFunctions[format](m);
      }

      function expandFormat(format, locale) {
          var i = 5;

          function replaceLongDateFormatTokens(input) {
              return locale.longDateFormat(input) || input;
          }

          localFormattingTokens.lastIndex = 0;
          while (i >= 0 && localFormattingTokens.test(format)) {
              format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
              localFormattingTokens.lastIndex = 0;
              i -= 1;
          }

          return format;
      }

      var match1         = /\d/;            //       0 - 9
      var match2         = /\d\d/;          //      00 - 99
      var match3         = /\d{3}/;         //     000 - 999
      var match4         = /\d{4}/;         //    0000 - 9999
      var match6         = /[+-]?\d{6}/;    // -999999 - 999999
      var match1to2      = /\d\d?/;         //       0 - 99
      var match3to4      = /\d\d\d\d?/;     //     999 - 9999
      var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
      var match1to3      = /\d{1,3}/;       //       0 - 999
      var match1to4      = /\d{1,4}/;       //       0 - 9999
      var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

      var matchUnsigned  = /\d+/;           //       0 - inf
      var matchSigned    = /[+-]?\d+/;      //    -inf - inf

      var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
      var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

      var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

      // any word (or two) characters or numbers including two/three word month in arabic.
      // includes scottish gaelic two word and hyphenated months
      var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


      var regexes = {};

      function addRegexToken (token, regex, strictRegex) {
          regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
              return (isStrict && strictRegex) ? strictRegex : regex;
          };
      }

      function getParseRegexForToken (token, config) {
          if (!hasOwnProp(regexes, token)) {
              return new RegExp(unescapeFormat(token));
          }

          return regexes[token](config._strict, config._locale);
      }

      // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
      function unescapeFormat(s) {
          return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
              return p1 || p2 || p3 || p4;
          }));
      }

      function regexEscape(s) {
          return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
      }

      var tokens = {};

      function addParseToken (token, callback) {
          var i, func = callback;
          if (typeof token === 'string') {
              token = [token];
          }
          if (typeof callback === 'number') {
              func = function (input, array) {
                  array[callback] = toInt(input);
              };
          }
          for (i = 0; i < token.length; i++) {
              tokens[token[i]] = func;
          }
      }

      function addWeekParseToken (token, callback) {
          addParseToken(token, function (input, array, config, token) {
              config._w = config._w || {};
              callback(input, config._w, config, token);
          });
      }

      function addTimeToArrayFromToken(token, input, config) {
          if (input != null && hasOwnProp(tokens, token)) {
              tokens[token](input, config._a, config, token);
          }
      }

      var YEAR = 0;
      var MONTH = 1;
      var DATE = 2;
      var HOUR = 3;
      var MINUTE = 4;
      var SECOND = 5;
      var MILLISECOND = 6;
      var WEEK = 7;
      var WEEKDAY = 8;

      var indexOf;

      if (Array.prototype.indexOf) {
          indexOf = Array.prototype.indexOf;
      } else {
          indexOf = function (o) {
              // I know
              var i;
              for (i = 0; i < this.length; ++i) {
                  if (this[i] === o) {
                      return i;
                  }
              }
              return -1;
          };
      }

      function daysInMonth(year, month) {
          return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
      }

      // FORMATTING

      addFormatToken('M', ['MM', 2], 'Mo', function () {
          return this.month() + 1;
      });

      addFormatToken('MMM', 0, 0, function (format) {
          return this.localeData().monthsShort(this, format);
      });

      addFormatToken('MMMM', 0, 0, function (format) {
          return this.localeData().months(this, format);
      });

      // ALIASES

      addUnitAlias('month', 'M');

      // PARSING

      addRegexToken('M',    match1to2);
      addRegexToken('MM',   match1to2, match2);
      addRegexToken('MMM',  function (isStrict, locale) {
          return locale.monthsShortRegex(isStrict);
      });
      addRegexToken('MMMM', function (isStrict, locale) {
          return locale.monthsRegex(isStrict);
      });

      addParseToken(['M', 'MM'], function (input, array) {
          array[MONTH] = toInt(input) - 1;
      });

      addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
          var month = config._locale.monthsParse(input, token, config._strict);
          // if we didn't find a month name, mark the date as invalid.
          if (month != null) {
              array[MONTH] = month;
          } else {
              getParsingFlags(config).invalidMonth = input;
          }
      });

      // LOCALES

      var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/;
      var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
      function localeMonths (m, format) {
          return isArray(this._months) ? this._months[m.month()] :
              this._months[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
      }

      var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
      function localeMonthsShort (m, format) {
          return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
              this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
      }

      function units_month__handleStrictParse(monthName, format, strict) {
          var i, ii, mom, llc = monthName.toLocaleLowerCase();
          if (!this._monthsParse) {
              // this is not used
              this._monthsParse = [];
              this._longMonthsParse = [];
              this._shortMonthsParse = [];
              for (i = 0; i < 12; ++i) {
                  mom = create_utc__createUTC([2000, i]);
                  this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                  this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
              }
          }

          if (strict) {
              if (format === 'MMM') {
                  ii = indexOf.call(this._shortMonthsParse, llc);
                  return ii !== -1 ? ii : null;
              } else {
                  ii = indexOf.call(this._longMonthsParse, llc);
                  return ii !== -1 ? ii : null;
              }
          } else {
              if (format === 'MMM') {
                  ii = indexOf.call(this._shortMonthsParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._longMonthsParse, llc);
                  return ii !== -1 ? ii : null;
              } else {
                  ii = indexOf.call(this._longMonthsParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._shortMonthsParse, llc);
                  return ii !== -1 ? ii : null;
              }
          }
      }

      function localeMonthsParse (monthName, format, strict) {
          var i, mom, regex;

          if (this._monthsParseExact) {
              return units_month__handleStrictParse.call(this, monthName, format, strict);
          }

          if (!this._monthsParse) {
              this._monthsParse = [];
              this._longMonthsParse = [];
              this._shortMonthsParse = [];
          }

          // TODO: add sorting
          // Sorting makes sure if one month (or abbr) is a prefix of another
          // see sorting in computeMonthsParse
          for (i = 0; i < 12; i++) {
              // make the regex if we don't have it already
              mom = create_utc__createUTC([2000, i]);
              if (strict && !this._longMonthsParse[i]) {
                  this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                  this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
              }
              if (!strict && !this._monthsParse[i]) {
                  regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                  this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
              }
              // test the regex
              if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                  return i;
              } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                  return i;
              } else if (!strict && this._monthsParse[i].test(monthName)) {
                  return i;
              }
          }
      }

      // MOMENTS

      function setMonth (mom, value) {
          var dayOfMonth;

          if (!mom.isValid()) {
              // No op
              return mom;
          }

          if (typeof value === 'string') {
              if (/^\d+$/.test(value)) {
                  value = toInt(value);
              } else {
                  value = mom.localeData().monthsParse(value);
                  // TODO: Another silent failure?
                  if (typeof value !== 'number') {
                      return mom;
                  }
              }
          }

          dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
          mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
          return mom;
      }

      function getSetMonth (value) {
          if (value != null) {
              setMonth(this, value);
              utils_hooks__hooks.updateOffset(this, true);
              return this;
          } else {
              return get_set__get(this, 'Month');
          }
      }

      function getDaysInMonth () {
          return daysInMonth(this.year(), this.month());
      }

      var defaultMonthsShortRegex = matchWord;
      function monthsShortRegex (isStrict) {
          if (this._monthsParseExact) {
              if (!hasOwnProp(this, '_monthsRegex')) {
                  computeMonthsParse.call(this);
              }
              if (isStrict) {
                  return this._monthsShortStrictRegex;
              } else {
                  return this._monthsShortRegex;
              }
          } else {
              return this._monthsShortStrictRegex && isStrict ?
                  this._monthsShortStrictRegex : this._monthsShortRegex;
          }
      }

      var defaultMonthsRegex = matchWord;
      function monthsRegex (isStrict) {
          if (this._monthsParseExact) {
              if (!hasOwnProp(this, '_monthsRegex')) {
                  computeMonthsParse.call(this);
              }
              if (isStrict) {
                  return this._monthsStrictRegex;
              } else {
                  return this._monthsRegex;
              }
          } else {
              return this._monthsStrictRegex && isStrict ?
                  this._monthsStrictRegex : this._monthsRegex;
          }
      }

      function computeMonthsParse () {
          function cmpLenRev(a, b) {
              return b.length - a.length;
          }

          var shortPieces = [], longPieces = [], mixedPieces = [],
              i, mom;
          for (i = 0; i < 12; i++) {
              // make the regex if we don't have it already
              mom = create_utc__createUTC([2000, i]);
              shortPieces.push(this.monthsShort(mom, ''));
              longPieces.push(this.months(mom, ''));
              mixedPieces.push(this.months(mom, ''));
              mixedPieces.push(this.monthsShort(mom, ''));
          }
          // Sorting makes sure if one month (or abbr) is a prefix of another it
          // will match the longer piece.
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          for (i = 0; i < 12; i++) {
              shortPieces[i] = regexEscape(shortPieces[i]);
              longPieces[i] = regexEscape(longPieces[i]);
              mixedPieces[i] = regexEscape(mixedPieces[i]);
          }

          this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
          this._monthsShortRegex = this._monthsRegex;
          this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
          this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
      }

      function checkOverflow (m) {
          var overflow;
          var a = m._a;

          if (a && getParsingFlags(m).overflow === -2) {
              overflow =
                  a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                  a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                  a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                  a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                  a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                  a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                  -1;

              if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                  overflow = DATE;
              }
              if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                  overflow = WEEK;
              }
              if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                  overflow = WEEKDAY;
              }

              getParsingFlags(m).overflow = overflow;
          }

          return m;
      }

      // iso 8601 regex
      // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
      var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
      var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;

      var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

      var isoDates = [
          ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
          ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
          ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
          ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
          ['YYYY-DDD', /\d{4}-\d{3}/],
          ['YYYY-MM', /\d{4}-\d\d/, false],
          ['YYYYYYMMDD', /[+-]\d{10}/],
          ['YYYYMMDD', /\d{8}/],
          // YYYYMM is NOT allowed by the standard
          ['GGGG[W]WWE', /\d{4}W\d{3}/],
          ['GGGG[W]WW', /\d{4}W\d{2}/, false],
          ['YYYYDDD', /\d{7}/]
      ];

      // iso time formats and regexes
      var isoTimes = [
          ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
          ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
          ['HH:mm:ss', /\d\d:\d\d:\d\d/],
          ['HH:mm', /\d\d:\d\d/],
          ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
          ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
          ['HHmmss', /\d\d\d\d\d\d/],
          ['HHmm', /\d\d\d\d/],
          ['HH', /\d\d/]
      ];

      var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

      // date from iso format
      function configFromISO(config) {
          var i, l,
              string = config._i,
              match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
              allowTime, dateFormat, timeFormat, tzFormat;

          if (match) {
              getParsingFlags(config).iso = true;

              for (i = 0, l = isoDates.length; i < l; i++) {
                  if (isoDates[i][1].exec(match[1])) {
                      dateFormat = isoDates[i][0];
                      allowTime = isoDates[i][2] !== false;
                      break;
                  }
              }
              if (dateFormat == null) {
                  config._isValid = false;
                  return;
              }
              if (match[3]) {
                  for (i = 0, l = isoTimes.length; i < l; i++) {
                      if (isoTimes[i][1].exec(match[3])) {
                          // match[2] should be 'T' or space
                          timeFormat = (match[2] || ' ') + isoTimes[i][0];
                          break;
                      }
                  }
                  if (timeFormat == null) {
                      config._isValid = false;
                      return;
                  }
              }
              if (!allowTime && timeFormat != null) {
                  config._isValid = false;
                  return;
              }
              if (match[4]) {
                  if (tzRegex.exec(match[4])) {
                      tzFormat = 'Z';
                  } else {
                      config._isValid = false;
                      return;
                  }
              }
              config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
              configFromStringAndFormat(config);
          } else {
              config._isValid = false;
          }
      }

      // date from iso format or fallback
      function configFromString(config) {
          var matched = aspNetJsonRegex.exec(config._i);

          if (matched !== null) {
              config._d = new Date(+matched[1]);
              return;
          }

          configFromISO(config);
          if (config._isValid === false) {
              delete config._isValid;
              utils_hooks__hooks.createFromInputFallback(config);
          }
      }

      utils_hooks__hooks.createFromInputFallback = deprecate(
          'moment construction falls back to js Date. This is ' +
          'discouraged and will be removed in upcoming major ' +
          'release. Please refer to ' +
          'https://github.com/moment/moment/issues/1407 for more info.',
          function (config) {
              config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
          }
      );

      function createDate (y, m, d, h, M, s, ms) {
          //can't just apply() to create a date:
          //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
          var date = new Date(y, m, d, h, M, s, ms);

          //the date constructor remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
              date.setFullYear(y);
          }
          return date;
      }

      function createUTCDate (y) {
          var date = new Date(Date.UTC.apply(null, arguments));

          //the Date.UTC function remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
              date.setUTCFullYear(y);
          }
          return date;
      }

      // FORMATTING

      addFormatToken('Y', 0, 0, function () {
          var y = this.year();
          return y <= 9999 ? '' + y : '+' + y;
      });

      addFormatToken(0, ['YY', 2], 0, function () {
          return this.year() % 100;
      });

      addFormatToken(0, ['YYYY',   4],       0, 'year');
      addFormatToken(0, ['YYYYY',  5],       0, 'year');
      addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

      // ALIASES

      addUnitAlias('year', 'y');

      // PARSING

      addRegexToken('Y',      matchSigned);
      addRegexToken('YY',     match1to2, match2);
      addRegexToken('YYYY',   match1to4, match4);
      addRegexToken('YYYYY',  match1to6, match6);
      addRegexToken('YYYYYY', match1to6, match6);

      addParseToken(['YYYYY', 'YYYYYY'], YEAR);
      addParseToken('YYYY', function (input, array) {
          array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
      });
      addParseToken('YY', function (input, array) {
          array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
      });
      addParseToken('Y', function (input, array) {
          array[YEAR] = parseInt(input, 10);
      });

      // HELPERS

      function daysInYear(year) {
          return isLeapYear(year) ? 366 : 365;
      }

      function isLeapYear(year) {
          return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
      }

      // HOOKS

      utils_hooks__hooks.parseTwoDigitYear = function (input) {
          return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
      };

      // MOMENTS

      var getSetYear = makeGetSet('FullYear', true);

      function getIsLeapYear () {
          return isLeapYear(this.year());
      }

      // start-of-first-week - start-of-year
      function firstWeekOffset(year, dow, doy) {
          var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
              fwd = 7 + dow - doy,
              // first-week day local weekday -- which local weekday is fwd
              fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

          return -fwdlw + fwd - 1;
      }

      //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
      function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
          var localWeekday = (7 + weekday - dow) % 7,
              weekOffset = firstWeekOffset(year, dow, doy),
              dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
              resYear, resDayOfYear;

          if (dayOfYear <= 0) {
              resYear = year - 1;
              resDayOfYear = daysInYear(resYear) + dayOfYear;
          } else if (dayOfYear > daysInYear(year)) {
              resYear = year + 1;
              resDayOfYear = dayOfYear - daysInYear(year);
          } else {
              resYear = year;
              resDayOfYear = dayOfYear;
          }

          return {
              year: resYear,
              dayOfYear: resDayOfYear
          };
      }

      function weekOfYear(mom, dow, doy) {
          var weekOffset = firstWeekOffset(mom.year(), dow, doy),
              week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
              resWeek, resYear;

          if (week < 1) {
              resYear = mom.year() - 1;
              resWeek = week + weeksInYear(resYear, dow, doy);
          } else if (week > weeksInYear(mom.year(), dow, doy)) {
              resWeek = week - weeksInYear(mom.year(), dow, doy);
              resYear = mom.year() + 1;
          } else {
              resYear = mom.year();
              resWeek = week;
          }

          return {
              week: resWeek,
              year: resYear
          };
      }

      function weeksInYear(year, dow, doy) {
          var weekOffset = firstWeekOffset(year, dow, doy),
              weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
          return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
      }

      // Pick the first defined of two or three arguments.
      function defaults(a, b, c) {
          if (a != null) {
              return a;
          }
          if (b != null) {
              return b;
          }
          return c;
      }

      function currentDateArray(config) {
          // hooks is actually the exported moment object
          var nowValue = new Date(utils_hooks__hooks.now());
          if (config._useUTC) {
              return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
          }
          return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
      }

      // convert an array to a date.
      // the array should mirror the parameters below
      // note: all values past the year are optional and will default to the lowest possible value.
      // [year, month, day , hour, minute, second, millisecond]
      function configFromArray (config) {
          var i, date, input = [], currentDate, yearToUse;

          if (config._d) {
              return;
          }

          currentDate = currentDateArray(config);

          //compute day of the year from weeks and weekdays
          if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
              dayOfYearFromWeekInfo(config);
          }

          //if the day of the year is set, figure out what it is
          if (config._dayOfYear) {
              yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

              if (config._dayOfYear > daysInYear(yearToUse)) {
                  getParsingFlags(config)._overflowDayOfYear = true;
              }

              date = createUTCDate(yearToUse, 0, config._dayOfYear);
              config._a[MONTH] = date.getUTCMonth();
              config._a[DATE] = date.getUTCDate();
          }

          // Default to current date.
          // * if no year, month, day of month are given, default to today
          // * if day of month is given, default month and year
          // * if month is given, default only year
          // * if year is given, don't default anything
          for (i = 0; i < 3 && config._a[i] == null; ++i) {
              config._a[i] = input[i] = currentDate[i];
          }

          // Zero out whatever was not defaulted, including time
          for (; i < 7; i++) {
              config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
          }

          // Check for 24:00:00.000
          if (config._a[HOUR] === 24 &&
                  config._a[MINUTE] === 0 &&
                  config._a[SECOND] === 0 &&
                  config._a[MILLISECOND] === 0) {
              config._nextDay = true;
              config._a[HOUR] = 0;
          }

          config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
          // Apply timezone offset from input. The actual utcOffset can be changed
          // with parseZone.
          if (config._tzm != null) {
              config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          }

          if (config._nextDay) {
              config._a[HOUR] = 24;
          }
      }

      function dayOfYearFromWeekInfo(config) {
          var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

          w = config._w;
          if (w.GG != null || w.W != null || w.E != null) {
              dow = 1;
              doy = 4;

              // TODO: We need to take the current isoWeekYear, but that depends on
              // how we interpret now (local, utc, fixed offset). So create
              // a now version of current config (take local/utc/offset flags, and
              // create now).
              weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
              week = defaults(w.W, 1);
              weekday = defaults(w.E, 1);
              if (weekday < 1 || weekday > 7) {
                  weekdayOverflow = true;
              }
          } else {
              dow = config._locale._week.dow;
              doy = config._locale._week.doy;

              weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
              week = defaults(w.w, 1);

              if (w.d != null) {
                  // weekday -- low day numbers are considered next week
                  weekday = w.d;
                  if (weekday < 0 || weekday > 6) {
                      weekdayOverflow = true;
                  }
              } else if (w.e != null) {
                  // local weekday -- counting starts from begining of week
                  weekday = w.e + dow;
                  if (w.e < 0 || w.e > 6) {
                      weekdayOverflow = true;
                  }
              } else {
                  // default to begining of week
                  weekday = dow;
              }
          }
          if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
              getParsingFlags(config)._overflowWeeks = true;
          } else if (weekdayOverflow != null) {
              getParsingFlags(config)._overflowWeekday = true;
          } else {
              temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
              config._a[YEAR] = temp.year;
              config._dayOfYear = temp.dayOfYear;
          }
      }

      // constant that refers to the ISO standard
      utils_hooks__hooks.ISO_8601 = function () {};

      // date from string and format string
      function configFromStringAndFormat(config) {
          // TODO: Move this to another part of the creation flow to prevent circular deps
          if (config._f === utils_hooks__hooks.ISO_8601) {
              configFromISO(config);
              return;
          }

          config._a = [];
          getParsingFlags(config).empty = true;

          // This array is used to make a Date, either with `new Date` or `Date.UTC`
          var string = '' + config._i,
              i, parsedInput, tokens, token, skipped,
              stringLength = string.length,
              totalParsedInputLength = 0;

          tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

          for (i = 0; i < tokens.length; i++) {
              token = tokens[i];
              parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
              // console.log('token', token, 'parsedInput', parsedInput,
              //         'regex', getParseRegexForToken(token, config));
              if (parsedInput) {
                  skipped = string.substr(0, string.indexOf(parsedInput));
                  if (skipped.length > 0) {
                      getParsingFlags(config).unusedInput.push(skipped);
                  }
                  string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                  totalParsedInputLength += parsedInput.length;
              }
              // don't parse if it's not a known token
              if (formatTokenFunctions[token]) {
                  if (parsedInput) {
                      getParsingFlags(config).empty = false;
                  }
                  else {
                      getParsingFlags(config).unusedTokens.push(token);
                  }
                  addTimeToArrayFromToken(token, parsedInput, config);
              }
              else if (config._strict && !parsedInput) {
                  getParsingFlags(config).unusedTokens.push(token);
              }
          }

          // add remaining unparsed input length to the string
          getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
          if (string.length > 0) {
              getParsingFlags(config).unusedInput.push(string);
          }

          // clear _12h flag if hour is <= 12
          if (getParsingFlags(config).bigHour === true &&
                  config._a[HOUR] <= 12 &&
                  config._a[HOUR] > 0) {
              getParsingFlags(config).bigHour = undefined;
          }

          getParsingFlags(config).parsedDateParts = config._a.slice(0);
          getParsingFlags(config).meridiem = config._meridiem;
          // handle meridiem
          config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

          configFromArray(config);
          checkOverflow(config);
      }


      function meridiemFixWrap (locale, hour, meridiem) {
          var isPm;

          if (meridiem == null) {
              // nothing to do
              return hour;
          }
          if (locale.meridiemHour != null) {
              return locale.meridiemHour(hour, meridiem);
          } else if (locale.isPM != null) {
              // Fallback
              isPm = locale.isPM(meridiem);
              if (isPm && hour < 12) {
                  hour += 12;
              }
              if (!isPm && hour === 12) {
                  hour = 0;
              }
              return hour;
          } else {
              // this is not supposed to happen
              return hour;
          }
      }

      // date from string and array of format strings
      function configFromStringAndArray(config) {
          var tempConfig,
              bestMoment,

              scoreToBeat,
              i,
              currentScore;

          if (config._f.length === 0) {
              getParsingFlags(config).invalidFormat = true;
              config._d = new Date(NaN);
              return;
          }

          for (i = 0; i < config._f.length; i++) {
              currentScore = 0;
              tempConfig = copyConfig({}, config);
              if (config._useUTC != null) {
                  tempConfig._useUTC = config._useUTC;
              }
              tempConfig._f = config._f[i];
              configFromStringAndFormat(tempConfig);

              if (!valid__isValid(tempConfig)) {
                  continue;
              }

              // if there is any input that was not parsed add a penalty for that format
              currentScore += getParsingFlags(tempConfig).charsLeftOver;

              //or tokens
              currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

              getParsingFlags(tempConfig).score = currentScore;

              if (scoreToBeat == null || currentScore < scoreToBeat) {
                  scoreToBeat = currentScore;
                  bestMoment = tempConfig;
              }
          }

          extend(config, bestMoment || tempConfig);
      }

      function configFromObject(config) {
          if (config._d) {
              return;
          }

          var i = normalizeObjectUnits(config._i);
          config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
              return obj && parseInt(obj, 10);
          });

          configFromArray(config);
      }

      function createFromConfig (config) {
          var res = new Moment(checkOverflow(prepareConfig(config)));
          if (res._nextDay) {
              // Adding is smart enough around DST
              res.add(1, 'd');
              res._nextDay = undefined;
          }

          return res;
      }

      function prepareConfig (config) {
          var input = config._i,
              format = config._f;

          config._locale = config._locale || locale_locales__getLocale(config._l);

          if (input === null || (format === undefined && input === '')) {
              return valid__createInvalid({nullInput: true});
          }

          if (typeof input === 'string') {
              config._i = input = config._locale.preparse(input);
          }

          if (isMoment(input)) {
              return new Moment(checkOverflow(input));
          } else if (isArray(format)) {
              configFromStringAndArray(config);
          } else if (format) {
              configFromStringAndFormat(config);
          } else if (isDate(input)) {
              config._d = input;
          } else {
              configFromInput(config);
          }

          if (!valid__isValid(config)) {
              config._d = null;
          }

          return config;
      }

      function configFromInput(config) {
          var input = config._i;
          if (input === undefined) {
              config._d = new Date(utils_hooks__hooks.now());
          } else if (isDate(input)) {
              config._d = new Date(input.valueOf());
          } else if (typeof input === 'string') {
              configFromString(config);
          } else if (isArray(input)) {
              config._a = map(input.slice(0), function (obj) {
                  return parseInt(obj, 10);
              });
              configFromArray(config);
          } else if (typeof(input) === 'object') {
              configFromObject(config);
          } else if (typeof(input) === 'number') {
              // from milliseconds
              config._d = new Date(input);
          } else {
              utils_hooks__hooks.createFromInputFallback(config);
          }
      }

      function createLocalOrUTC (input, format, locale, strict, isUTC) {
          var c = {};

          if (typeof(locale) === 'boolean') {
              strict = locale;
              locale = undefined;
          }
          // object construction must be done this way.
          // https://github.com/moment/moment/issues/1423
          c._isAMomentObject = true;
          c._useUTC = c._isUTC = isUTC;
          c._l = locale;
          c._i = input;
          c._f = format;
          c._strict = strict;

          return createFromConfig(c);
      }

      function local__createLocal (input, format, locale, strict) {
          return createLocalOrUTC(input, format, locale, strict, false);
      }

      var prototypeMin = deprecate(
           'moment().min is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
           function () {
               var other = local__createLocal.apply(null, arguments);
               if (this.isValid() && other.isValid()) {
                   return other < this ? this : other;
               } else {
                   return valid__createInvalid();
               }
           }
       );

      var prototypeMax = deprecate(
          'moment().max is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
          function () {
              var other = local__createLocal.apply(null, arguments);
              if (this.isValid() && other.isValid()) {
                  return other > this ? this : other;
              } else {
                  return valid__createInvalid();
              }
          }
      );

      // Pick a moment m from moments so that m[fn](other) is true for all
      // other. This relies on the function fn to be transitive.
      //
      // moments should either be an array of moment objects or an array, whose
      // first element is an array of moment objects.
      function pickBy(fn, moments) {
          var res, i;
          if (moments.length === 1 && isArray(moments[0])) {
              moments = moments[0];
          }
          if (!moments.length) {
              return local__createLocal();
          }
          res = moments[0];
          for (i = 1; i < moments.length; ++i) {
              if (!moments[i].isValid() || moments[i][fn](res)) {
                  res = moments[i];
              }
          }
          return res;
      }

      // TODO: Use [].sort instead?
      function min () {
          var args = [].slice.call(arguments, 0);

          return pickBy('isBefore', args);
      }

      function max () {
          var args = [].slice.call(arguments, 0);

          return pickBy('isAfter', args);
      }

      var now = function () {
          return Date.now ? Date.now() : +(new Date());
      };

      function Duration (duration) {
          var normalizedInput = normalizeObjectUnits(duration),
              years = normalizedInput.year || 0,
              quarters = normalizedInput.quarter || 0,
              months = normalizedInput.month || 0,
              weeks = normalizedInput.week || 0,
              days = normalizedInput.day || 0,
              hours = normalizedInput.hour || 0,
              minutes = normalizedInput.minute || 0,
              seconds = normalizedInput.second || 0,
              milliseconds = normalizedInput.millisecond || 0;

          // representation for dateAddRemove
          this._milliseconds = +milliseconds +
              seconds * 1e3 + // 1000
              minutes * 6e4 + // 1000 * 60
              hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
          // Because of dateAddRemove treats 24 hours as different from a
          // day when working around DST, we need to store them separately
          this._days = +days +
              weeks * 7;
          // It is impossible translate months into days without knowing
          // which months you are are talking about, so we have to store
          // it separately.
          this._months = +months +
              quarters * 3 +
              years * 12;

          this._data = {};

          this._locale = locale_locales__getLocale();

          this._bubble();
      }

      function isDuration (obj) {
          return obj instanceof Duration;
      }

      // FORMATTING

      function offset (token, separator) {
          addFormatToken(token, 0, 0, function () {
              var offset = this.utcOffset();
              var sign = '+';
              if (offset < 0) {
                  offset = -offset;
                  sign = '-';
              }
              return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
          });
      }

      offset('Z', ':');
      offset('ZZ', '');

      // PARSING

      addRegexToken('Z',  matchShortOffset);
      addRegexToken('ZZ', matchShortOffset);
      addParseToken(['Z', 'ZZ'], function (input, array, config) {
          config._useUTC = true;
          config._tzm = offsetFromString(matchShortOffset, input);
      });

      // HELPERS

      // timezone chunker
      // '+10:00' > ['10',  '00']
      // '-1530'  > ['-15', '30']
      var chunkOffset = /([\+\-]|\d\d)/gi;

      function offsetFromString(matcher, string) {
          var matches = ((string || '').match(matcher) || []);
          var chunk   = matches[matches.length - 1] || [];
          var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
          var minutes = +(parts[1] * 60) + toInt(parts[2]);

          return parts[0] === '+' ? minutes : -minutes;
      }

      // Return a moment from input, that is local/utc/zone equivalent to model.
      function cloneWithOffset(input, model) {
          var res, diff;
          if (model._isUTC) {
              res = model.clone();
              diff = (isMoment(input) || isDate(input) ? input.valueOf() : local__createLocal(input).valueOf()) - res.valueOf();
              // Use low-level api, because this fn is low-level api.
              res._d.setTime(res._d.valueOf() + diff);
              utils_hooks__hooks.updateOffset(res, false);
              return res;
          } else {
              return local__createLocal(input).local();
          }
      }

      function getDateOffset (m) {
          // On Firefox.24 Date#getTimezoneOffset returns a floating point.
          // https://github.com/moment/moment/pull/1871
          return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
      }

      // HOOKS

      // This function will be called whenever a moment is mutated.
      // It is intended to keep the offset in sync with the timezone.
      utils_hooks__hooks.updateOffset = function () {};

      // MOMENTS

      // keepLocalTime = true means only change the timezone, without
      // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
      // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
      // +0200, so we adjust the time as needed, to be valid.
      //
      // Keeping the time actually adds/subtracts (one hour)
      // from the actual represented time. That is why we call updateOffset
      // a second time. In case it wants us to change the offset again
      // _changeInProgress == true case, then we have to adjust, because
      // there is no such time in the given timezone.
      function getSetOffset (input, keepLocalTime) {
          var offset = this._offset || 0,
              localAdjust;
          if (!this.isValid()) {
              return input != null ? this : NaN;
          }
          if (input != null) {
              if (typeof input === 'string') {
                  input = offsetFromString(matchShortOffset, input);
              } else if (Math.abs(input) < 16) {
                  input = input * 60;
              }
              if (!this._isUTC && keepLocalTime) {
                  localAdjust = getDateOffset(this);
              }
              this._offset = input;
              this._isUTC = true;
              if (localAdjust != null) {
                  this.add(localAdjust, 'm');
              }
              if (offset !== input) {
                  if (!keepLocalTime || this._changeInProgress) {
                      add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
                  } else if (!this._changeInProgress) {
                      this._changeInProgress = true;
                      utils_hooks__hooks.updateOffset(this, true);
                      this._changeInProgress = null;
                  }
              }
              return this;
          } else {
              return this._isUTC ? offset : getDateOffset(this);
          }
      }

      function getSetZone (input, keepLocalTime) {
          if (input != null) {
              if (typeof input !== 'string') {
                  input = -input;
              }

              this.utcOffset(input, keepLocalTime);

              return this;
          } else {
              return -this.utcOffset();
          }
      }

      function setOffsetToUTC (keepLocalTime) {
          return this.utcOffset(0, keepLocalTime);
      }

      function setOffsetToLocal (keepLocalTime) {
          if (this._isUTC) {
              this.utcOffset(0, keepLocalTime);
              this._isUTC = false;

              if (keepLocalTime) {
                  this.subtract(getDateOffset(this), 'm');
              }
          }
          return this;
      }

      function setOffsetToParsedOffset () {
          if (this._tzm) {
              this.utcOffset(this._tzm);
          } else if (typeof this._i === 'string') {
              this.utcOffset(offsetFromString(matchOffset, this._i));
          }
          return this;
      }

      function hasAlignedHourOffset (input) {
          if (!this.isValid()) {
              return false;
          }
          input = input ? local__createLocal(input).utcOffset() : 0;

          return (this.utcOffset() - input) % 60 === 0;
      }

      function isDaylightSavingTime () {
          return (
              this.utcOffset() > this.clone().month(0).utcOffset() ||
              this.utcOffset() > this.clone().month(5).utcOffset()
          );
      }

      function isDaylightSavingTimeShifted () {
          if (!isUndefined(this._isDSTShifted)) {
              return this._isDSTShifted;
          }

          var c = {};

          copyConfig(c, this);
          c = prepareConfig(c);

          if (c._a) {
              var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
              this._isDSTShifted = this.isValid() &&
                  compareArrays(c._a, other.toArray()) > 0;
          } else {
              this._isDSTShifted = false;
          }

          return this._isDSTShifted;
      }

      function isLocal () {
          return this.isValid() ? !this._isUTC : false;
      }

      function isUtcOffset () {
          return this.isValid() ? this._isUTC : false;
      }

      function isUtc () {
          return this.isValid() ? this._isUTC && this._offset === 0 : false;
      }

      // ASP.NET json date format regex
      var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?\d*)?$/;

      // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
      // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
      // and further modified to allow for strings containing both week and day
      var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;

      function create__createDuration (input, key) {
          var duration = input,
              // matching against regexp is expensive, do it on demand
              match = null,
              sign,
              ret,
              diffRes;

          if (isDuration(input)) {
              duration = {
                  ms : input._milliseconds,
                  d  : input._days,
                  M  : input._months
              };
          } else if (typeof input === 'number') {
              duration = {};
              if (key) {
                  duration[key] = input;
              } else {
                  duration.milliseconds = input;
              }
          } else if (!!(match = aspNetRegex.exec(input))) {
              sign = (match[1] === '-') ? -1 : 1;
              duration = {
                  y  : 0,
                  d  : toInt(match[DATE])        * sign,
                  h  : toInt(match[HOUR])        * sign,
                  m  : toInt(match[MINUTE])      * sign,
                  s  : toInt(match[SECOND])      * sign,
                  ms : toInt(match[MILLISECOND]) * sign
              };
          } else if (!!(match = isoRegex.exec(input))) {
              sign = (match[1] === '-') ? -1 : 1;
              duration = {
                  y : parseIso(match[2], sign),
                  M : parseIso(match[3], sign),
                  w : parseIso(match[4], sign),
                  d : parseIso(match[5], sign),
                  h : parseIso(match[6], sign),
                  m : parseIso(match[7], sign),
                  s : parseIso(match[8], sign)
              };
          } else if (duration == null) {// checks for null or undefined
              duration = {};
          } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
              diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));

              duration = {};
              duration.ms = diffRes.milliseconds;
              duration.M = diffRes.months;
          }

          ret = new Duration(duration);

          if (isDuration(input) && hasOwnProp(input, '_locale')) {
              ret._locale = input._locale;
          }

          return ret;
      }

      create__createDuration.fn = Duration.prototype;

      function parseIso (inp, sign) {
          // We'd normally use ~~inp for this, but unfortunately it also
          // converts floats to ints.
          // inp may be undefined, so careful calling replace on it.
          var res = inp && parseFloat(inp.replace(',', '.'));
          // apply sign while we're at it
          return (isNaN(res) ? 0 : res) * sign;
      }

      function positiveMomentsDifference(base, other) {
          var res = {milliseconds: 0, months: 0};

          res.months = other.month() - base.month() +
              (other.year() - base.year()) * 12;
          if (base.clone().add(res.months, 'M').isAfter(other)) {
              --res.months;
          }

          res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

          return res;
      }

      function momentsDifference(base, other) {
          var res;
          if (!(base.isValid() && other.isValid())) {
              return {milliseconds: 0, months: 0};
          }

          other = cloneWithOffset(other, base);
          if (base.isBefore(other)) {
              res = positiveMomentsDifference(base, other);
          } else {
              res = positiveMomentsDifference(other, base);
              res.milliseconds = -res.milliseconds;
              res.months = -res.months;
          }

          return res;
      }

      function absRound (number) {
          if (number < 0) {
              return Math.round(-1 * number) * -1;
          } else {
              return Math.round(number);
          }
      }

      // TODO: remove 'name' arg after deprecation is removed
      function createAdder(direction, name) {
          return function (val, period) {
              var dur, tmp;
              //invert the arguments, but complain about it
              if (period !== null && !isNaN(+period)) {
                  deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
                  tmp = val; val = period; period = tmp;
              }

              val = typeof val === 'string' ? +val : val;
              dur = create__createDuration(val, period);
              add_subtract__addSubtract(this, dur, direction);
              return this;
          };
      }

      function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {
          var milliseconds = duration._milliseconds,
              days = absRound(duration._days),
              months = absRound(duration._months);

          if (!mom.isValid()) {
              // No op
              return;
          }

          updateOffset = updateOffset == null ? true : updateOffset;

          if (milliseconds) {
              mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
          }
          if (days) {
              get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
          }
          if (months) {
              setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
          }
          if (updateOffset) {
              utils_hooks__hooks.updateOffset(mom, days || months);
          }
      }

      var add_subtract__add      = createAdder(1, 'add');
      var add_subtract__subtract = createAdder(-1, 'subtract');

      function moment_calendar__calendar (time, formats) {
          // We want to compare the start of today, vs this.
          // Getting start-of-today depends on whether we're local/utc/offset or not.
          var now = time || local__createLocal(),
              sod = cloneWithOffset(now, this).startOf('day'),
              diff = this.diff(sod, 'days', true),
              format = diff < -6 ? 'sameElse' :
                  diff < -1 ? 'lastWeek' :
                  diff < 0 ? 'lastDay' :
                  diff < 1 ? 'sameDay' :
                  diff < 2 ? 'nextDay' :
                  diff < 7 ? 'nextWeek' : 'sameElse';

          var output = formats && (isFunction(formats[format]) ? formats[format]() : formats[format]);

          return this.format(output || this.localeData().calendar(format, this, local__createLocal(now)));
      }

      function clone () {
          return new Moment(this);
      }

      function isAfter (input, units) {
          var localInput = isMoment(input) ? input : local__createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
              return false;
          }
          units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
          if (units === 'millisecond') {
              return this.valueOf() > localInput.valueOf();
          } else {
              return localInput.valueOf() < this.clone().startOf(units).valueOf();
          }
      }

      function isBefore (input, units) {
          var localInput = isMoment(input) ? input : local__createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
              return false;
          }
          units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
          if (units === 'millisecond') {
              return this.valueOf() < localInput.valueOf();
          } else {
              return this.clone().endOf(units).valueOf() < localInput.valueOf();
          }
      }

      function isBetween (from, to, units, inclusivity) {
          inclusivity = inclusivity || '()';
          return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
              (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
      }

      function isSame (input, units) {
          var localInput = isMoment(input) ? input : local__createLocal(input),
              inputMs;
          if (!(this.isValid() && localInput.isValid())) {
              return false;
          }
          units = normalizeUnits(units || 'millisecond');
          if (units === 'millisecond') {
              return this.valueOf() === localInput.valueOf();
          } else {
              inputMs = localInput.valueOf();
              return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
          }
      }

      function isSameOrAfter (input, units) {
          return this.isSame(input, units) || this.isAfter(input,units);
      }

      function isSameOrBefore (input, units) {
          return this.isSame(input, units) || this.isBefore(input,units);
      }

      function diff (input, units, asFloat) {
          var that,
              zoneDelta,
              delta, output;

          if (!this.isValid()) {
              return NaN;
          }

          that = cloneWithOffset(input, this);

          if (!that.isValid()) {
              return NaN;
          }

          zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

          units = normalizeUnits(units);

          if (units === 'year' || units === 'month' || units === 'quarter') {
              output = monthDiff(this, that);
              if (units === 'quarter') {
                  output = output / 3;
              } else if (units === 'year') {
                  output = output / 12;
              }
          } else {
              delta = this - that;
              output = units === 'second' ? delta / 1e3 : // 1000
                  units === 'minute' ? delta / 6e4 : // 1000 * 60
                  units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
                  units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                  units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                  delta;
          }
          return asFloat ? output : absFloor(output);
      }

      function monthDiff (a, b) {
          // difference in months
          var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
              // b is in (anchor - 1 month, anchor + 1 month)
              anchor = a.clone().add(wholeMonthDiff, 'months'),
              anchor2, adjust;

          if (b - anchor < 0) {
              anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
              // linear across the month
              adjust = (b - anchor) / (anchor - anchor2);
          } else {
              anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
              // linear across the month
              adjust = (b - anchor) / (anchor2 - anchor);
          }

          //check for negative zero, return zero if negative zero
          return -(wholeMonthDiff + adjust) || 0;
      }

      utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
      utils_hooks__hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

      function toString () {
          return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
      }

      function moment_format__toISOString () {
          var m = this.clone().utc();
          if (0 < m.year() && m.year() <= 9999) {
              if (isFunction(Date.prototype.toISOString)) {
                  // native implementation is ~50x faster, use it when we can
                  return this.toDate().toISOString();
              } else {
                  return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
              }
          } else {
              return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
          }
      }

      function format (inputString) {
          if (!inputString) {
              inputString = this.isUtc() ? utils_hooks__hooks.defaultFormatUtc : utils_hooks__hooks.defaultFormat;
          }
          var output = formatMoment(this, inputString);
          return this.localeData().postformat(output);
      }

      function from (time, withoutSuffix) {
          if (this.isValid() &&
                  ((isMoment(time) && time.isValid()) ||
                   local__createLocal(time).isValid())) {
              return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
          } else {
              return this.localeData().invalidDate();
          }
      }

      function fromNow (withoutSuffix) {
          return this.from(local__createLocal(), withoutSuffix);
      }

      function to (time, withoutSuffix) {
          if (this.isValid() &&
                  ((isMoment(time) && time.isValid()) ||
                   local__createLocal(time).isValid())) {
              return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
          } else {
              return this.localeData().invalidDate();
          }
      }

      function toNow (withoutSuffix) {
          return this.to(local__createLocal(), withoutSuffix);
      }

      // If passed a locale key, it will set the locale for this
      // instance.  Otherwise, it will return the locale configuration
      // variables for this instance.
      function locale (key) {
          var newLocaleData;

          if (key === undefined) {
              return this._locale._abbr;
          } else {
              newLocaleData = locale_locales__getLocale(key);
              if (newLocaleData != null) {
                  this._locale = newLocaleData;
              }
              return this;
          }
      }

      var lang = deprecate(
          'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
          function (key) {
              if (key === undefined) {
                  return this.localeData();
              } else {
                  return this.locale(key);
              }
          }
      );

      function localeData () {
          return this._locale;
      }

      function startOf (units) {
          units = normalizeUnits(units);
          // the following switch intentionally omits break keywords
          // to utilize falling through the cases.
          switch (units) {
          case 'year':
              this.month(0);
              /* falls through */
          case 'quarter':
          case 'month':
              this.date(1);
              /* falls through */
          case 'week':
          case 'isoWeek':
          case 'day':
          case 'date':
              this.hours(0);
              /* falls through */
          case 'hour':
              this.minutes(0);
              /* falls through */
          case 'minute':
              this.seconds(0);
              /* falls through */
          case 'second':
              this.milliseconds(0);
          }

          // weeks are a special case
          if (units === 'week') {
              this.weekday(0);
          }
          if (units === 'isoWeek') {
              this.isoWeekday(1);
          }

          // quarters are also special
          if (units === 'quarter') {
              this.month(Math.floor(this.month() / 3) * 3);
          }

          return this;
      }

      function endOf (units) {
          units = normalizeUnits(units);
          if (units === undefined || units === 'millisecond') {
              return this;
          }

          // 'date' is an alias for 'day', so it should be considered as such.
          if (units === 'date') {
              units = 'day';
          }

          return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
      }

      function to_type__valueOf () {
          return this._d.valueOf() - ((this._offset || 0) * 60000);
      }

      function unix () {
          return Math.floor(this.valueOf() / 1000);
      }

      function toDate () {
          return this._offset ? new Date(this.valueOf()) : this._d;
      }

      function toArray () {
          var m = this;
          return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
      }

      function toObject () {
          var m = this;
          return {
              years: m.year(),
              months: m.month(),
              date: m.date(),
              hours: m.hours(),
              minutes: m.minutes(),
              seconds: m.seconds(),
              milliseconds: m.milliseconds()
          };
      }

      function toJSON () {
          // new Date(NaN).toJSON() === null
          return this.isValid() ? this.toISOString() : null;
      }

      function moment_valid__isValid () {
          return valid__isValid(this);
      }

      function parsingFlags () {
          return extend({}, getParsingFlags(this));
      }

      function invalidAt () {
          return getParsingFlags(this).overflow;
      }

      function creationData() {
          return {
              input: this._i,
              format: this._f,
              locale: this._locale,
              isUTC: this._isUTC,
              strict: this._strict
          };
      }

      // FORMATTING

      addFormatToken(0, ['gg', 2], 0, function () {
          return this.weekYear() % 100;
      });

      addFormatToken(0, ['GG', 2], 0, function () {
          return this.isoWeekYear() % 100;
      });

      function addWeekYearFormatToken (token, getter) {
          addFormatToken(0, [token, token.length], 0, getter);
      }

      addWeekYearFormatToken('gggg',     'weekYear');
      addWeekYearFormatToken('ggggg',    'weekYear');
      addWeekYearFormatToken('GGGG',  'isoWeekYear');
      addWeekYearFormatToken('GGGGG', 'isoWeekYear');

      // ALIASES

      addUnitAlias('weekYear', 'gg');
      addUnitAlias('isoWeekYear', 'GG');

      // PARSING

      addRegexToken('G',      matchSigned);
      addRegexToken('g',      matchSigned);
      addRegexToken('GG',     match1to2, match2);
      addRegexToken('gg',     match1to2, match2);
      addRegexToken('GGGG',   match1to4, match4);
      addRegexToken('gggg',   match1to4, match4);
      addRegexToken('GGGGG',  match1to6, match6);
      addRegexToken('ggggg',  match1to6, match6);

      addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
          week[token.substr(0, 2)] = toInt(input);
      });

      addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
          week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
      });

      // MOMENTS

      function getSetWeekYear (input) {
          return getSetWeekYearHelper.call(this,
                  input,
                  this.week(),
                  this.weekday(),
                  this.localeData()._week.dow,
                  this.localeData()._week.doy);
      }

      function getSetISOWeekYear (input) {
          return getSetWeekYearHelper.call(this,
                  input, this.isoWeek(), this.isoWeekday(), 1, 4);
      }

      function getISOWeeksInYear () {
          return weeksInYear(this.year(), 1, 4);
      }

      function getWeeksInYear () {
          var weekInfo = this.localeData()._week;
          return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
      }

      function getSetWeekYearHelper(input, week, weekday, dow, doy) {
          var weeksTarget;
          if (input == null) {
              return weekOfYear(this, dow, doy).year;
          } else {
              weeksTarget = weeksInYear(input, dow, doy);
              if (week > weeksTarget) {
                  week = weeksTarget;
              }
              return setWeekAll.call(this, input, week, weekday, dow, doy);
          }
      }

      function setWeekAll(weekYear, week, weekday, dow, doy) {
          var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
              date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

          this.year(date.getUTCFullYear());
          this.month(date.getUTCMonth());
          this.date(date.getUTCDate());
          return this;
      }

      // FORMATTING

      addFormatToken('Q', 0, 'Qo', 'quarter');

      // ALIASES

      addUnitAlias('quarter', 'Q');

      // PARSING

      addRegexToken('Q', match1);
      addParseToken('Q', function (input, array) {
          array[MONTH] = (toInt(input) - 1) * 3;
      });

      // MOMENTS

      function getSetQuarter (input) {
          return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
      }

      // FORMATTING

      addFormatToken('w', ['ww', 2], 'wo', 'week');
      addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

      // ALIASES

      addUnitAlias('week', 'w');
      addUnitAlias('isoWeek', 'W');

      // PARSING

      addRegexToken('w',  match1to2);
      addRegexToken('ww', match1to2, match2);
      addRegexToken('W',  match1to2);
      addRegexToken('WW', match1to2, match2);

      addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
          week[token.substr(0, 1)] = toInt(input);
      });

      // HELPERS

      // LOCALES

      function localeWeek (mom) {
          return weekOfYear(mom, this._week.dow, this._week.doy).week;
      }

      var defaultLocaleWeek = {
          dow : 0, // Sunday is the first day of the week.
          doy : 6  // The week that contains Jan 1st is the first week of the year.
      };

      function localeFirstDayOfWeek () {
          return this._week.dow;
      }

      function localeFirstDayOfYear () {
          return this._week.doy;
      }

      // MOMENTS

      function getSetWeek (input) {
          var week = this.localeData().week(this);
          return input == null ? week : this.add((input - week) * 7, 'd');
      }

      function getSetISOWeek (input) {
          var week = weekOfYear(this, 1, 4).week;
          return input == null ? week : this.add((input - week) * 7, 'd');
      }

      // FORMATTING

      addFormatToken('D', ['DD', 2], 'Do', 'date');

      // ALIASES

      addUnitAlias('date', 'D');

      // PARSING

      addRegexToken('D',  match1to2);
      addRegexToken('DD', match1to2, match2);
      addRegexToken('Do', function (isStrict, locale) {
          return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
      });

      addParseToken(['D', 'DD'], DATE);
      addParseToken('Do', function (input, array) {
          array[DATE] = toInt(input.match(match1to2)[0], 10);
      });

      // MOMENTS

      var getSetDayOfMonth = makeGetSet('Date', true);

      // FORMATTING

      addFormatToken('d', 0, 'do', 'day');

      addFormatToken('dd', 0, 0, function (format) {
          return this.localeData().weekdaysMin(this, format);
      });

      addFormatToken('ddd', 0, 0, function (format) {
          return this.localeData().weekdaysShort(this, format);
      });

      addFormatToken('dddd', 0, 0, function (format) {
          return this.localeData().weekdays(this, format);
      });

      addFormatToken('e', 0, 0, 'weekday');
      addFormatToken('E', 0, 0, 'isoWeekday');

      // ALIASES

      addUnitAlias('day', 'd');
      addUnitAlias('weekday', 'e');
      addUnitAlias('isoWeekday', 'E');

      // PARSING

      addRegexToken('d',    match1to2);
      addRegexToken('e',    match1to2);
      addRegexToken('E',    match1to2);
      addRegexToken('dd',   function (isStrict, locale) {
          return locale.weekdaysMinRegex(isStrict);
      });
      addRegexToken('ddd',   function (isStrict, locale) {
          return locale.weekdaysShortRegex(isStrict);
      });
      addRegexToken('dddd',   function (isStrict, locale) {
          return locale.weekdaysRegex(isStrict);
      });

      addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
          var weekday = config._locale.weekdaysParse(input, token, config._strict);
          // if we didn't get a weekday name, mark the date as invalid
          if (weekday != null) {
              week.d = weekday;
          } else {
              getParsingFlags(config).invalidWeekday = input;
          }
      });

      addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
          week[token] = toInt(input);
      });

      // HELPERS

      function parseWeekday(input, locale) {
          if (typeof input !== 'string') {
              return input;
          }

          if (!isNaN(input)) {
              return parseInt(input, 10);
          }

          input = locale.weekdaysParse(input);
          if (typeof input === 'number') {
              return input;
          }

          return null;
      }

      // LOCALES

      var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
      function localeWeekdays (m, format) {
          return isArray(this._weekdays) ? this._weekdays[m.day()] :
              this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
      }

      var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
      function localeWeekdaysShort (m) {
          return this._weekdaysShort[m.day()];
      }

      var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
      function localeWeekdaysMin (m) {
          return this._weekdaysMin[m.day()];
      }

      function day_of_week__handleStrictParse(weekdayName, format, strict) {
          var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
          if (!this._weekdaysParse) {
              this._weekdaysParse = [];
              this._shortWeekdaysParse = [];
              this._minWeekdaysParse = [];

              for (i = 0; i < 7; ++i) {
                  mom = create_utc__createUTC([2000, 1]).day(i);
                  this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                  this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                  this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
              }
          }

          if (strict) {
              if (format === 'dddd') {
                  ii = indexOf.call(this._weekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              } else if (format === 'ddd') {
                  ii = indexOf.call(this._shortWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              } else {
                  ii = indexOf.call(this._minWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              }
          } else {
              if (format === 'dddd') {
                  ii = indexOf.call(this._weekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._shortWeekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._minWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              } else if (format === 'ddd') {
                  ii = indexOf.call(this._shortWeekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._weekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._minWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              } else {
                  ii = indexOf.call(this._minWeekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._weekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._shortWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              }
          }
      }

      function localeWeekdaysParse (weekdayName, format, strict) {
          var i, mom, regex;

          if (this._weekdaysParseExact) {
              return day_of_week__handleStrictParse.call(this, weekdayName, format, strict);
          }

          if (!this._weekdaysParse) {
              this._weekdaysParse = [];
              this._minWeekdaysParse = [];
              this._shortWeekdaysParse = [];
              this._fullWeekdaysParse = [];
          }

          for (i = 0; i < 7; i++) {
              // make the regex if we don't have it already

              mom = create_utc__createUTC([2000, 1]).day(i);
              if (strict && !this._fullWeekdaysParse[i]) {
                  this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
                  this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
                  this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
              }
              if (!this._weekdaysParse[i]) {
                  regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                  this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
              }
              // test the regex
              if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                  return i;
              } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                  return i;
              } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                  return i;
              } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                  return i;
              }
          }
      }

      // MOMENTS

      function getSetDayOfWeek (input) {
          if (!this.isValid()) {
              return input != null ? this : NaN;
          }
          var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
          if (input != null) {
              input = parseWeekday(input, this.localeData());
              return this.add(input - day, 'd');
          } else {
              return day;
          }
      }

      function getSetLocaleDayOfWeek (input) {
          if (!this.isValid()) {
              return input != null ? this : NaN;
          }
          var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
          return input == null ? weekday : this.add(input - weekday, 'd');
      }

      function getSetISODayOfWeek (input) {
          if (!this.isValid()) {
              return input != null ? this : NaN;
          }
          // behaves the same as moment#day except
          // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
          // as a setter, sunday should belong to the previous week.
          return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
      }

      var defaultWeekdaysRegex = matchWord;
      function weekdaysRegex (isStrict) {
          if (this._weekdaysParseExact) {
              if (!hasOwnProp(this, '_weekdaysRegex')) {
                  computeWeekdaysParse.call(this);
              }
              if (isStrict) {
                  return this._weekdaysStrictRegex;
              } else {
                  return this._weekdaysRegex;
              }
          } else {
              return this._weekdaysStrictRegex && isStrict ?
                  this._weekdaysStrictRegex : this._weekdaysRegex;
          }
      }

      var defaultWeekdaysShortRegex = matchWord;
      function weekdaysShortRegex (isStrict) {
          if (this._weekdaysParseExact) {
              if (!hasOwnProp(this, '_weekdaysRegex')) {
                  computeWeekdaysParse.call(this);
              }
              if (isStrict) {
                  return this._weekdaysShortStrictRegex;
              } else {
                  return this._weekdaysShortRegex;
              }
          } else {
              return this._weekdaysShortStrictRegex && isStrict ?
                  this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
          }
      }

      var defaultWeekdaysMinRegex = matchWord;
      function weekdaysMinRegex (isStrict) {
          if (this._weekdaysParseExact) {
              if (!hasOwnProp(this, '_weekdaysRegex')) {
                  computeWeekdaysParse.call(this);
              }
              if (isStrict) {
                  return this._weekdaysMinStrictRegex;
              } else {
                  return this._weekdaysMinRegex;
              }
          } else {
              return this._weekdaysMinStrictRegex && isStrict ?
                  this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
          }
      }


      function computeWeekdaysParse () {
          function cmpLenRev(a, b) {
              return b.length - a.length;
          }

          var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
              i, mom, minp, shortp, longp;
          for (i = 0; i < 7; i++) {
              // make the regex if we don't have it already
              mom = create_utc__createUTC([2000, 1]).day(i);
              minp = this.weekdaysMin(mom, '');
              shortp = this.weekdaysShort(mom, '');
              longp = this.weekdays(mom, '');
              minPieces.push(minp);
              shortPieces.push(shortp);
              longPieces.push(longp);
              mixedPieces.push(minp);
              mixedPieces.push(shortp);
              mixedPieces.push(longp);
          }
          // Sorting makes sure if one weekday (or abbr) is a prefix of another it
          // will match the longer piece.
          minPieces.sort(cmpLenRev);
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          for (i = 0; i < 7; i++) {
              shortPieces[i] = regexEscape(shortPieces[i]);
              longPieces[i] = regexEscape(longPieces[i]);
              mixedPieces[i] = regexEscape(mixedPieces[i]);
          }

          this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
          this._weekdaysShortRegex = this._weekdaysRegex;
          this._weekdaysMinRegex = this._weekdaysRegex;

          this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
          this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
          this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
      }

      // FORMATTING

      addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

      // ALIASES

      addUnitAlias('dayOfYear', 'DDD');

      // PARSING

      addRegexToken('DDD',  match1to3);
      addRegexToken('DDDD', match3);
      addParseToken(['DDD', 'DDDD'], function (input, array, config) {
          config._dayOfYear = toInt(input);
      });

      // HELPERS

      // MOMENTS

      function getSetDayOfYear (input) {
          var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
          return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
      }

      // FORMATTING

      function hFormat() {
          return this.hours() % 12 || 12;
      }

      function kFormat() {
          return this.hours() || 24;
      }

      addFormatToken('H', ['HH', 2], 0, 'hour');
      addFormatToken('h', ['hh', 2], 0, hFormat);
      addFormatToken('k', ['kk', 2], 0, kFormat);

      addFormatToken('hmm', 0, 0, function () {
          return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
      });

      addFormatToken('hmmss', 0, 0, function () {
          return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
              zeroFill(this.seconds(), 2);
      });

      addFormatToken('Hmm', 0, 0, function () {
          return '' + this.hours() + zeroFill(this.minutes(), 2);
      });

      addFormatToken('Hmmss', 0, 0, function () {
          return '' + this.hours() + zeroFill(this.minutes(), 2) +
              zeroFill(this.seconds(), 2);
      });

      function meridiem (token, lowercase) {
          addFormatToken(token, 0, 0, function () {
              return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
          });
      }

      meridiem('a', true);
      meridiem('A', false);

      // ALIASES

      addUnitAlias('hour', 'h');

      // PARSING

      function matchMeridiem (isStrict, locale) {
          return locale._meridiemParse;
      }

      addRegexToken('a',  matchMeridiem);
      addRegexToken('A',  matchMeridiem);
      addRegexToken('H',  match1to2);
      addRegexToken('h',  match1to2);
      addRegexToken('HH', match1to2, match2);
      addRegexToken('hh', match1to2, match2);

      addRegexToken('hmm', match3to4);
      addRegexToken('hmmss', match5to6);
      addRegexToken('Hmm', match3to4);
      addRegexToken('Hmmss', match5to6);

      addParseToken(['H', 'HH'], HOUR);
      addParseToken(['a', 'A'], function (input, array, config) {
          config._isPm = config._locale.isPM(input);
          config._meridiem = input;
      });
      addParseToken(['h', 'hh'], function (input, array, config) {
          array[HOUR] = toInt(input);
          getParsingFlags(config).bigHour = true;
      });
      addParseToken('hmm', function (input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
          getParsingFlags(config).bigHour = true;
      });
      addParseToken('hmmss', function (input, array, config) {
          var pos1 = input.length - 4;
          var pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
          getParsingFlags(config).bigHour = true;
      });
      addParseToken('Hmm', function (input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
      });
      addParseToken('Hmmss', function (input, array, config) {
          var pos1 = input.length - 4;
          var pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
      });

      // LOCALES

      function localeIsPM (input) {
          // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
          // Using charAt should be more compatible.
          return ((input + '').toLowerCase().charAt(0) === 'p');
      }

      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
      function localeMeridiem (hours, minutes, isLower) {
          if (hours > 11) {
              return isLower ? 'pm' : 'PM';
          } else {
              return isLower ? 'am' : 'AM';
          }
      }


      // MOMENTS

      // Setting the hour should keep the time, because the user explicitly
      // specified which hour he wants. So trying to maintain the same hour (in
      // a new timezone) makes sense. Adding/subtracting hours does not follow
      // this rule.
      var getSetHour = makeGetSet('Hours', true);

      // FORMATTING

      addFormatToken('m', ['mm', 2], 0, 'minute');

      // ALIASES

      addUnitAlias('minute', 'm');

      // PARSING

      addRegexToken('m',  match1to2);
      addRegexToken('mm', match1to2, match2);
      addParseToken(['m', 'mm'], MINUTE);

      // MOMENTS

      var getSetMinute = makeGetSet('Minutes', false);

      // FORMATTING

      addFormatToken('s', ['ss', 2], 0, 'second');

      // ALIASES

      addUnitAlias('second', 's');

      // PARSING

      addRegexToken('s',  match1to2);
      addRegexToken('ss', match1to2, match2);
      addParseToken(['s', 'ss'], SECOND);

      // MOMENTS

      var getSetSecond = makeGetSet('Seconds', false);

      // FORMATTING

      addFormatToken('S', 0, 0, function () {
          return ~~(this.millisecond() / 100);
      });

      addFormatToken(0, ['SS', 2], 0, function () {
          return ~~(this.millisecond() / 10);
      });

      addFormatToken(0, ['SSS', 3], 0, 'millisecond');
      addFormatToken(0, ['SSSS', 4], 0, function () {
          return this.millisecond() * 10;
      });
      addFormatToken(0, ['SSSSS', 5], 0, function () {
          return this.millisecond() * 100;
      });
      addFormatToken(0, ['SSSSSS', 6], 0, function () {
          return this.millisecond() * 1000;
      });
      addFormatToken(0, ['SSSSSSS', 7], 0, function () {
          return this.millisecond() * 10000;
      });
      addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
          return this.millisecond() * 100000;
      });
      addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
          return this.millisecond() * 1000000;
      });


      // ALIASES

      addUnitAlias('millisecond', 'ms');

      // PARSING

      addRegexToken('S',    match1to3, match1);
      addRegexToken('SS',   match1to3, match2);
      addRegexToken('SSS',  match1to3, match3);

      var token;
      for (token = 'SSSS'; token.length <= 9; token += 'S') {
          addRegexToken(token, matchUnsigned);
      }

      function parseMs(input, array) {
          array[MILLISECOND] = toInt(('0.' + input) * 1000);
      }

      for (token = 'S'; token.length <= 9; token += 'S') {
          addParseToken(token, parseMs);
      }
      // MOMENTS

      var getSetMillisecond = makeGetSet('Milliseconds', false);

      // FORMATTING

      addFormatToken('z',  0, 0, 'zoneAbbr');
      addFormatToken('zz', 0, 0, 'zoneName');

      // MOMENTS

      function getZoneAbbr () {
          return this._isUTC ? 'UTC' : '';
      }

      function getZoneName () {
          return this._isUTC ? 'Coordinated Universal Time' : '';
      }

      var momentPrototype__proto = Moment.prototype;

      momentPrototype__proto.add               = add_subtract__add;
      momentPrototype__proto.calendar          = moment_calendar__calendar;
      momentPrototype__proto.clone             = clone;
      momentPrototype__proto.diff              = diff;
      momentPrototype__proto.endOf             = endOf;
      momentPrototype__proto.format            = format;
      momentPrototype__proto.from              = from;
      momentPrototype__proto.fromNow           = fromNow;
      momentPrototype__proto.to                = to;
      momentPrototype__proto.toNow             = toNow;
      momentPrototype__proto.get               = getSet;
      momentPrototype__proto.invalidAt         = invalidAt;
      momentPrototype__proto.isAfter           = isAfter;
      momentPrototype__proto.isBefore          = isBefore;
      momentPrototype__proto.isBetween         = isBetween;
      momentPrototype__proto.isSame            = isSame;
      momentPrototype__proto.isSameOrAfter     = isSameOrAfter;
      momentPrototype__proto.isSameOrBefore    = isSameOrBefore;
      momentPrototype__proto.isValid           = moment_valid__isValid;
      momentPrototype__proto.lang              = lang;
      momentPrototype__proto.locale            = locale;
      momentPrototype__proto.localeData        = localeData;
      momentPrototype__proto.max               = prototypeMax;
      momentPrototype__proto.min               = prototypeMin;
      momentPrototype__proto.parsingFlags      = parsingFlags;
      momentPrototype__proto.set               = getSet;
      momentPrototype__proto.startOf           = startOf;
      momentPrototype__proto.subtract          = add_subtract__subtract;
      momentPrototype__proto.toArray           = toArray;
      momentPrototype__proto.toObject          = toObject;
      momentPrototype__proto.toDate            = toDate;
      momentPrototype__proto.toISOString       = moment_format__toISOString;
      momentPrototype__proto.toJSON            = toJSON;
      momentPrototype__proto.toString          = toString;
      momentPrototype__proto.unix              = unix;
      momentPrototype__proto.valueOf           = to_type__valueOf;
      momentPrototype__proto.creationData      = creationData;

      // Year
      momentPrototype__proto.year       = getSetYear;
      momentPrototype__proto.isLeapYear = getIsLeapYear;

      // Week Year
      momentPrototype__proto.weekYear    = getSetWeekYear;
      momentPrototype__proto.isoWeekYear = getSetISOWeekYear;

      // Quarter
      momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;

      // Month
      momentPrototype__proto.month       = getSetMonth;
      momentPrototype__proto.daysInMonth = getDaysInMonth;

      // Week
      momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;
      momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;
      momentPrototype__proto.weeksInYear    = getWeeksInYear;
      momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;

      // Day
      momentPrototype__proto.date       = getSetDayOfMonth;
      momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;
      momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;
      momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
      momentPrototype__proto.dayOfYear  = getSetDayOfYear;

      // Hour
      momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;

      // Minute
      momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;

      // Second
      momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;

      // Millisecond
      momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;

      // Offset
      momentPrototype__proto.utcOffset            = getSetOffset;
      momentPrototype__proto.utc                  = setOffsetToUTC;
      momentPrototype__proto.local                = setOffsetToLocal;
      momentPrototype__proto.parseZone            = setOffsetToParsedOffset;
      momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
      momentPrototype__proto.isDST                = isDaylightSavingTime;
      momentPrototype__proto.isDSTShifted         = isDaylightSavingTimeShifted;
      momentPrototype__proto.isLocal              = isLocal;
      momentPrototype__proto.isUtcOffset          = isUtcOffset;
      momentPrototype__proto.isUtc                = isUtc;
      momentPrototype__proto.isUTC                = isUtc;

      // Timezone
      momentPrototype__proto.zoneAbbr = getZoneAbbr;
      momentPrototype__proto.zoneName = getZoneName;

      // Deprecations
      momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
      momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
      momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
      momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779', getSetZone);

      var momentPrototype = momentPrototype__proto;

      function moment__createUnix (input) {
          return local__createLocal(input * 1000);
      }

      function moment__createInZone () {
          return local__createLocal.apply(null, arguments).parseZone();
      }

      var defaultCalendar = {
          sameDay : '[Today at] LT',
          nextDay : '[Tomorrow at] LT',
          nextWeek : 'dddd [at] LT',
          lastDay : '[Yesterday at] LT',
          lastWeek : '[Last] dddd [at] LT',
          sameElse : 'L'
      };

      function locale_calendar__calendar (key, mom, now) {
          var output = this._calendar[key];
          return isFunction(output) ? output.call(mom, now) : output;
      }

      var defaultLongDateFormat = {
          LTS  : 'h:mm:ss A',
          LT   : 'h:mm A',
          L    : 'MM/DD/YYYY',
          LL   : 'MMMM D, YYYY',
          LLL  : 'MMMM D, YYYY h:mm A',
          LLLL : 'dddd, MMMM D, YYYY h:mm A'
      };

      function longDateFormat (key) {
          var format = this._longDateFormat[key],
              formatUpper = this._longDateFormat[key.toUpperCase()];

          if (format || !formatUpper) {
              return format;
          }

          this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
              return val.slice(1);
          });

          return this._longDateFormat[key];
      }

      var defaultInvalidDate = 'Invalid date';

      function invalidDate () {
          return this._invalidDate;
      }

      var defaultOrdinal = '%d';
      var defaultOrdinalParse = /\d{1,2}/;

      function ordinal (number) {
          return this._ordinal.replace('%d', number);
      }

      function preParsePostFormat (string) {
          return string;
      }

      var defaultRelativeTime = {
          future : 'in %s',
          past   : '%s ago',
          s  : 'a few seconds',
          m  : 'a minute',
          mm : '%d minutes',
          h  : 'an hour',
          hh : '%d hours',
          d  : 'a day',
          dd : '%d days',
          M  : 'a month',
          MM : '%d months',
          y  : 'a year',
          yy : '%d years'
      };

      function relative__relativeTime (number, withoutSuffix, string, isFuture) {
          var output = this._relativeTime[string];
          return (isFunction(output)) ?
              output(number, withoutSuffix, string, isFuture) :
              output.replace(/%d/i, number);
      }

      function pastFuture (diff, output) {
          var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
          return isFunction(format) ? format(output) : format.replace(/%s/i, output);
      }

      var prototype__proto = Locale.prototype;

      prototype__proto._calendar       = defaultCalendar;
      prototype__proto.calendar        = locale_calendar__calendar;
      prototype__proto._longDateFormat = defaultLongDateFormat;
      prototype__proto.longDateFormat  = longDateFormat;
      prototype__proto._invalidDate    = defaultInvalidDate;
      prototype__proto.invalidDate     = invalidDate;
      prototype__proto._ordinal        = defaultOrdinal;
      prototype__proto.ordinal         = ordinal;
      prototype__proto._ordinalParse   = defaultOrdinalParse;
      prototype__proto.preparse        = preParsePostFormat;
      prototype__proto.postformat      = preParsePostFormat;
      prototype__proto._relativeTime   = defaultRelativeTime;
      prototype__proto.relativeTime    = relative__relativeTime;
      prototype__proto.pastFuture      = pastFuture;
      prototype__proto.set             = locale_set__set;

      // Month
      prototype__proto.months            =        localeMonths;
      prototype__proto._months           = defaultLocaleMonths;
      prototype__proto.monthsShort       =        localeMonthsShort;
      prototype__proto._monthsShort      = defaultLocaleMonthsShort;
      prototype__proto.monthsParse       =        localeMonthsParse;
      prototype__proto._monthsRegex      = defaultMonthsRegex;
      prototype__proto.monthsRegex       = monthsRegex;
      prototype__proto._monthsShortRegex = defaultMonthsShortRegex;
      prototype__proto.monthsShortRegex  = monthsShortRegex;

      // Week
      prototype__proto.week = localeWeek;
      prototype__proto._week = defaultLocaleWeek;
      prototype__proto.firstDayOfYear = localeFirstDayOfYear;
      prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;

      // Day of Week
      prototype__proto.weekdays       =        localeWeekdays;
      prototype__proto._weekdays      = defaultLocaleWeekdays;
      prototype__proto.weekdaysMin    =        localeWeekdaysMin;
      prototype__proto._weekdaysMin   = defaultLocaleWeekdaysMin;
      prototype__proto.weekdaysShort  =        localeWeekdaysShort;
      prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;
      prototype__proto.weekdaysParse  =        localeWeekdaysParse;

      prototype__proto._weekdaysRegex      = defaultWeekdaysRegex;
      prototype__proto.weekdaysRegex       =        weekdaysRegex;
      prototype__proto._weekdaysShortRegex = defaultWeekdaysShortRegex;
      prototype__proto.weekdaysShortRegex  =        weekdaysShortRegex;
      prototype__proto._weekdaysMinRegex   = defaultWeekdaysMinRegex;
      prototype__proto.weekdaysMinRegex    =        weekdaysMinRegex;

      // Hours
      prototype__proto.isPM = localeIsPM;
      prototype__proto._meridiemParse = defaultLocaleMeridiemParse;
      prototype__proto.meridiem = localeMeridiem;

      function lists__get (format, index, field, setter) {
          var locale = locale_locales__getLocale();
          var utc = create_utc__createUTC().set(setter, index);
          return locale[field](utc, format);
      }

      function listMonthsImpl (format, index, field) {
          if (typeof format === 'number') {
              index = format;
              format = undefined;
          }

          format = format || '';

          if (index != null) {
              return lists__get(format, index, field, 'month');
          }

          var i;
          var out = [];
          for (i = 0; i < 12; i++) {
              out[i] = lists__get(format, i, field, 'month');
          }
          return out;
      }

      // ()
      // (5)
      // (fmt, 5)
      // (fmt)
      // (true)
      // (true, 5)
      // (true, fmt, 5)
      // (true, fmt)
      function listWeekdaysImpl (localeSorted, format, index, field) {
          if (typeof localeSorted === 'boolean') {
              if (typeof format === 'number') {
                  index = format;
                  format = undefined;
              }

              format = format || '';
          } else {
              format = localeSorted;
              index = format;
              localeSorted = false;

              if (typeof format === 'number') {
                  index = format;
                  format = undefined;
              }

              format = format || '';
          }

          var locale = locale_locales__getLocale(),
              shift = localeSorted ? locale._week.dow : 0;

          if (index != null) {
              return lists__get(format, (index + shift) % 7, field, 'day');
          }

          var i;
          var out = [];
          for (i = 0; i < 7; i++) {
              out[i] = lists__get(format, (i + shift) % 7, field, 'day');
          }
          return out;
      }

      function lists__listMonths (format, index) {
          return listMonthsImpl(format, index, 'months');
      }

      function lists__listMonthsShort (format, index) {
          return listMonthsImpl(format, index, 'monthsShort');
      }

      function lists__listWeekdays (localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
      }

      function lists__listWeekdaysShort (localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
      }

      function lists__listWeekdaysMin (localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
      }

      locale_locales__getSetGlobalLocale('en', {
          ordinalParse: /\d{1,2}(th|st|nd|rd)/,
          ordinal : function (number) {
              var b = number % 10,
                  output = (toInt(number % 100 / 10) === 1) ? 'th' :
                  (b === 1) ? 'st' :
                  (b === 2) ? 'nd' :
                  (b === 3) ? 'rd' : 'th';
              return number + output;
          }
      });

      // Side effect imports
      utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
      utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);

      var mathAbs = Math.abs;

      function duration_abs__abs () {
          var data           = this._data;

          this._milliseconds = mathAbs(this._milliseconds);
          this._days         = mathAbs(this._days);
          this._months       = mathAbs(this._months);

          data.milliseconds  = mathAbs(data.milliseconds);
          data.seconds       = mathAbs(data.seconds);
          data.minutes       = mathAbs(data.minutes);
          data.hours         = mathAbs(data.hours);
          data.months        = mathAbs(data.months);
          data.years         = mathAbs(data.years);

          return this;
      }

      function duration_add_subtract__addSubtract (duration, input, value, direction) {
          var other = create__createDuration(input, value);

          duration._milliseconds += direction * other._milliseconds;
          duration._days         += direction * other._days;
          duration._months       += direction * other._months;

          return duration._bubble();
      }

      // supports only 2.0-style add(1, 's') or add(duration)
      function duration_add_subtract__add (input, value) {
          return duration_add_subtract__addSubtract(this, input, value, 1);
      }

      // supports only 2.0-style subtract(1, 's') or subtract(duration)
      function duration_add_subtract__subtract (input, value) {
          return duration_add_subtract__addSubtract(this, input, value, -1);
      }

      function absCeil (number) {
          if (number < 0) {
              return Math.floor(number);
          } else {
              return Math.ceil(number);
          }
      }

      function bubble () {
          var milliseconds = this._milliseconds;
          var days         = this._days;
          var months       = this._months;
          var data         = this._data;
          var seconds, minutes, hours, years, monthsFromDays;

          // if we have a mix of positive and negative values, bubble down first
          // check: https://github.com/moment/moment/issues/2166
          if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                  (milliseconds <= 0 && days <= 0 && months <= 0))) {
              milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
              days = 0;
              months = 0;
          }

          // The following code bubbles up values, see the tests for
          // examples of what that means.
          data.milliseconds = milliseconds % 1000;

          seconds           = absFloor(milliseconds / 1000);
          data.seconds      = seconds % 60;

          minutes           = absFloor(seconds / 60);
          data.minutes      = minutes % 60;

          hours             = absFloor(minutes / 60);
          data.hours        = hours % 24;

          days += absFloor(hours / 24);

          // convert days to months
          monthsFromDays = absFloor(daysToMonths(days));
          months += monthsFromDays;
          days -= absCeil(monthsToDays(monthsFromDays));

          // 12 months -> 1 year
          years = absFloor(months / 12);
          months %= 12;

          data.days   = days;
          data.months = months;
          data.years  = years;

          return this;
      }

      function daysToMonths (days) {
          // 400 years have 146097 days (taking into account leap year rules)
          // 400 years have 12 months === 4800
          return days * 4800 / 146097;
      }

      function monthsToDays (months) {
          // the reverse of daysToMonths
          return months * 146097 / 4800;
      }

      function as (units) {
          var days;
          var months;
          var milliseconds = this._milliseconds;

          units = normalizeUnits(units);

          if (units === 'month' || units === 'year') {
              days   = this._days   + milliseconds / 864e5;
              months = this._months + daysToMonths(days);
              return units === 'month' ? months : months / 12;
          } else {
              // handle milliseconds separately because of floating point math errors (issue #1867)
              days = this._days + Math.round(monthsToDays(this._months));
              switch (units) {
                  case 'week'   : return days / 7     + milliseconds / 6048e5;
                  case 'day'    : return days         + milliseconds / 864e5;
                  case 'hour'   : return days * 24    + milliseconds / 36e5;
                  case 'minute' : return days * 1440  + milliseconds / 6e4;
                  case 'second' : return days * 86400 + milliseconds / 1000;
                  // Math.floor prevents floating point math errors here
                  case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                  default: throw new Error('Unknown unit ' + units);
              }
          }
      }

      // TODO: Use this.as('ms')?
      function duration_as__valueOf () {
          return (
              this._milliseconds +
              this._days * 864e5 +
              (this._months % 12) * 2592e6 +
              toInt(this._months / 12) * 31536e6
          );
      }

      function makeAs (alias) {
          return function () {
              return this.as(alias);
          };
      }

      var asMilliseconds = makeAs('ms');
      var asSeconds      = makeAs('s');
      var asMinutes      = makeAs('m');
      var asHours        = makeAs('h');
      var asDays         = makeAs('d');
      var asWeeks        = makeAs('w');
      var asMonths       = makeAs('M');
      var asYears        = makeAs('y');

      function duration_get__get (units) {
          units = normalizeUnits(units);
          return this[units + 's']();
      }

      function makeGetter(name) {
          return function () {
              return this._data[name];
          };
      }

      var milliseconds = makeGetter('milliseconds');
      var seconds      = makeGetter('seconds');
      var minutes      = makeGetter('minutes');
      var hours        = makeGetter('hours');
      var days         = makeGetter('days');
      var months       = makeGetter('months');
      var years        = makeGetter('years');

      function weeks () {
          return absFloor(this.days() / 7);
      }

      var round = Math.round;
      var thresholds = {
          s: 45,  // seconds to minute
          m: 45,  // minutes to hour
          h: 22,  // hours to day
          d: 26,  // days to month
          M: 11   // months to year
      };

      // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
      function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
          return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
      }

      function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {
          var duration = create__createDuration(posNegDuration).abs();
          var seconds  = round(duration.as('s'));
          var minutes  = round(duration.as('m'));
          var hours    = round(duration.as('h'));
          var days     = round(duration.as('d'));
          var months   = round(duration.as('M'));
          var years    = round(duration.as('y'));

          var a = seconds < thresholds.s && ['s', seconds]  ||
                  minutes <= 1           && ['m']           ||
                  minutes < thresholds.m && ['mm', minutes] ||
                  hours   <= 1           && ['h']           ||
                  hours   < thresholds.h && ['hh', hours]   ||
                  days    <= 1           && ['d']           ||
                  days    < thresholds.d && ['dd', days]    ||
                  months  <= 1           && ['M']           ||
                  months  < thresholds.M && ['MM', months]  ||
                  years   <= 1           && ['y']           || ['yy', years];

          a[2] = withoutSuffix;
          a[3] = +posNegDuration > 0;
          a[4] = locale;
          return substituteTimeAgo.apply(null, a);
      }

      // This function allows you to set a threshold for relative time strings
      function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {
          if (thresholds[threshold] === undefined) {
              return false;
          }
          if (limit === undefined) {
              return thresholds[threshold];
          }
          thresholds[threshold] = limit;
          return true;
      }

      function humanize (withSuffix) {
          var locale = this.localeData();
          var output = duration_humanize__relativeTime(this, !withSuffix, locale);

          if (withSuffix) {
              output = locale.pastFuture(+this, output);
          }

          return locale.postformat(output);
      }

      var iso_string__abs = Math.abs;

      function iso_string__toISOString() {
          // for ISO strings we do not use the normal bubbling rules:
          //  * milliseconds bubble up until they become hours
          //  * days do not bubble at all
          //  * months bubble up until they become years
          // This is because there is no context-free conversion between hours and days
          // (think of clock changes)
          // and also not between days and months (28-31 days per month)
          var seconds = iso_string__abs(this._milliseconds) / 1000;
          var days         = iso_string__abs(this._days);
          var months       = iso_string__abs(this._months);
          var minutes, hours, years;

          // 3600 seconds -> 60 minutes -> 1 hour
          minutes           = absFloor(seconds / 60);
          hours             = absFloor(minutes / 60);
          seconds %= 60;
          minutes %= 60;

          // 12 months -> 1 year
          years  = absFloor(months / 12);
          months %= 12;


          // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
          var Y = years;
          var M = months;
          var D = days;
          var h = hours;
          var m = minutes;
          var s = seconds;
          var total = this.asSeconds();

          if (!total) {
              // this is the same as C#'s (Noda) and python (isodate)...
              // but not other JS (goog.date)
              return 'P0D';
          }

          return (total < 0 ? '-' : '') +
              'P' +
              (Y ? Y + 'Y' : '') +
              (M ? M + 'M' : '') +
              (D ? D + 'D' : '') +
              ((h || m || s) ? 'T' : '') +
              (h ? h + 'H' : '') +
              (m ? m + 'M' : '') +
              (s ? s + 'S' : '');
      }

      var duration_prototype__proto = Duration.prototype;

      duration_prototype__proto.abs            = duration_abs__abs;
      duration_prototype__proto.add            = duration_add_subtract__add;
      duration_prototype__proto.subtract       = duration_add_subtract__subtract;
      duration_prototype__proto.as             = as;
      duration_prototype__proto.asMilliseconds = asMilliseconds;
      duration_prototype__proto.asSeconds      = asSeconds;
      duration_prototype__proto.asMinutes      = asMinutes;
      duration_prototype__proto.asHours        = asHours;
      duration_prototype__proto.asDays         = asDays;
      duration_prototype__proto.asWeeks        = asWeeks;
      duration_prototype__proto.asMonths       = asMonths;
      duration_prototype__proto.asYears        = asYears;
      duration_prototype__proto.valueOf        = duration_as__valueOf;
      duration_prototype__proto._bubble        = bubble;
      duration_prototype__proto.get            = duration_get__get;
      duration_prototype__proto.milliseconds   = milliseconds;
      duration_prototype__proto.seconds        = seconds;
      duration_prototype__proto.minutes        = minutes;
      duration_prototype__proto.hours          = hours;
      duration_prototype__proto.days           = days;
      duration_prototype__proto.weeks          = weeks;
      duration_prototype__proto.months         = months;
      duration_prototype__proto.years          = years;
      duration_prototype__proto.humanize       = humanize;
      duration_prototype__proto.toISOString    = iso_string__toISOString;
      duration_prototype__proto.toString       = iso_string__toISOString;
      duration_prototype__proto.toJSON         = iso_string__toISOString;
      duration_prototype__proto.locale         = locale;
      duration_prototype__proto.localeData     = localeData;

      // Deprecations
      duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
      duration_prototype__proto.lang = lang;

      // Side effect imports

      // FORMATTING

      addFormatToken('X', 0, 0, 'unix');
      addFormatToken('x', 0, 0, 'valueOf');

      // PARSING

      addRegexToken('x', matchSigned);
      addRegexToken('X', matchTimestamp);
      addParseToken('X', function (input, array, config) {
          config._d = new Date(parseFloat(input, 10) * 1000);
      });
      addParseToken('x', function (input, array, config) {
          config._d = new Date(toInt(input));
      });

      // Side effect imports


      utils_hooks__hooks.version = '2.13.0';

      setHookCallback(local__createLocal);

      utils_hooks__hooks.fn                    = momentPrototype;
      utils_hooks__hooks.min                   = min;
      utils_hooks__hooks.max                   = max;
      utils_hooks__hooks.now                   = now;
      utils_hooks__hooks.utc                   = create_utc__createUTC;
      utils_hooks__hooks.unix                  = moment__createUnix;
      utils_hooks__hooks.months                = lists__listMonths;
      utils_hooks__hooks.isDate                = isDate;
      utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;
      utils_hooks__hooks.invalid               = valid__createInvalid;
      utils_hooks__hooks.duration              = create__createDuration;
      utils_hooks__hooks.isMoment              = isMoment;
      utils_hooks__hooks.weekdays              = lists__listWeekdays;
      utils_hooks__hooks.parseZone             = moment__createInZone;
      utils_hooks__hooks.localeData            = locale_locales__getLocale;
      utils_hooks__hooks.isDuration            = isDuration;
      utils_hooks__hooks.monthsShort           = lists__listMonthsShort;
      utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;
      utils_hooks__hooks.defineLocale          = defineLocale;
      utils_hooks__hooks.updateLocale          = updateLocale;
      utils_hooks__hooks.locales               = locale_locales__listLocales;
      utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;
      utils_hooks__hooks.normalizeUnits        = normalizeUnits;
      utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
      utils_hooks__hooks.prototype             = momentPrototype;

      var _moment = utils_hooks__hooks;

      return _moment;

  }));
  /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)(module)))

/***/ },
/* 4 */
/***/ function(module, exports) {

  module.exports = function(module) {
  	if(!module.webpackPolyfill) {
  		module.deprecate = function() {};
  		module.paths = [];
  		// module.parent = undefined by default
  		module.children = [];
  		module.webpackPolyfill = 1;
  	}
  	return module;
  }


/***/ },
/* 5 */
/***/ function(module, exports) {

  function webpackContext(req) {
  	throw new Error("Cannot find module '" + req + "'.");
  }
  webpackContext.keys = function() { return []; };
  webpackContext.resolve = webpackContext;
  module.exports = webpackContext;
  webpackContext.id = 5;


/***/ },
/* 6 */
/***/ function(module, exports) {

  /* WEBPACK VAR INJECTION */(function(global) {'use strict';

  var _rng;

  var globalVar = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : null;

  if (globalVar && globalVar.crypto && crypto.getRandomValues) {
    // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
    // Moderately fast, high quality
    var _rnds8 = new Uint8Array(16);
    _rng = function whatwgRNG() {
      crypto.getRandomValues(_rnds8);
      return _rnds8;
    };
  }

  if (!_rng) {
    // Math.random()-based (RNG)
    //
    // If all else fails, use Math.random().  It's fast, but is of unspecified
    // quality.
    var _rnds = new Array(16);
    _rng = function _rng() {
      for (var i = 0, r; i < 16; i++) {
        if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
        _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
      }

      return _rnds;
    };
  }

  //     uuid.js
  //
  //     Copyright (c) 2010-2012 Robert Kieffer
  //     MIT License - http://opensource.org/licenses/mit-license.php

  // Unique ID creation requires a high quality random # generator.  We feature
  // detect to determine the best RNG source, normalizing to a function that
  // returns 128-bits of randomness, since that's what's usually required

  //var _rng = require('./rng');

  // Maps for number <-> hex string conversion
  var _byteToHex = [];
  var _hexToByte = {};
  for (var i = 0; i < 256; i++) {
    _byteToHex[i] = (i + 0x100).toString(16).substr(1);
    _hexToByte[_byteToHex[i]] = i;
  }

  // **`parse()` - Parse a UUID into it's component bytes**
  function parse(s, buf, offset) {
    var i = buf && offset || 0,
        ii = 0;

    buf = buf || [];
    s.toLowerCase().replace(/[0-9a-f]{2}/g, function (oct) {
      if (ii < 16) {
        // Don't overflow!
        buf[i + ii++] = _hexToByte[oct];
      }
    });

    // Zero out remaining bytes if string was short
    while (ii < 16) {
      buf[i + ii++] = 0;
    }

    return buf;
  }

  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**
  function unparse(buf, offset) {
    var i = offset || 0,
        bth = _byteToHex;
    return bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]];
  }

  // **`v1()` - Generate time-based UUID**
  //
  // Inspired by https://github.com/LiosK/UUID.js
  // and http://docs.python.org/library/uuid.html

  // random #'s we need to init node and clockseq
  var _seedBytes = _rng();

  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
  var _nodeId = [_seedBytes[0] | 0x01, _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]];

  // Per 4.2.2, randomize (14 bit) clockseq
  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

  // Previous uuid creation time
  var _lastMSecs = 0,
      _lastNSecs = 0;

  // See https://github.com/broofa/node-uuid for API details
  function v1(options, buf, offset) {
    var i = buf && offset || 0;
    var b = buf || [];

    options = options || {};

    var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

    // UUID timestamps are 100 nano-second units since the Gregorian epoch,
    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
    var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

    // Per 4.2.1.2, use count of uuid's generated during the current clock
    // cycle to simulate higher resolution clock
    var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

    // Time since last uuid creation (in msecs)
    var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000;

    // Per 4.2.1.2, Bump clockseq on clock regression
    if (dt < 0 && options.clockseq === undefined) {
      clockseq = clockseq + 1 & 0x3fff;
    }

    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
    // time interval
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
      nsecs = 0;
    }

    // Per 4.2.1.2 Throw error if too many uuids are requested
    if (nsecs >= 10000) {
      throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
    }

    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;

    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
    msecs += 12219292800000;

    // `time_low`
    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    b[i++] = tl >>> 24 & 0xff;
    b[i++] = tl >>> 16 & 0xff;
    b[i++] = tl >>> 8 & 0xff;
    b[i++] = tl & 0xff;

    // `time_mid`
    var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
    b[i++] = tmh >>> 8 & 0xff;
    b[i++] = tmh & 0xff;

    // `time_high_and_version`
    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
    b[i++] = tmh >>> 16 & 0xff;

    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
    b[i++] = clockseq >>> 8 | 0x80;

    // `clock_seq_low`
    b[i++] = clockseq & 0xff;

    // `node`
    var node = options.node || _nodeId;
    for (var n = 0; n < 6; n++) {
      b[i + n] = node[n];
    }

    return buf ? buf : unparse(b);
  }

  // **`v4()` - Generate random UUID**

  // See https://github.com/broofa/node-uuid for API details
  function v4(options, buf, offset) {
    // Deprecated - 'format' argument, as supported in v1.2
    var i = buf && offset || 0;

    if (typeof options == 'string') {
      buf = options == 'binary' ? new Array(16) : null;
      options = null;
    }
    options = options || {};

    var rnds = options.random || (options.rng || _rng)();

    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = rnds[6] & 0x0f | 0x40;
    rnds[8] = rnds[8] & 0x3f | 0x80;

    // Copy bytes to buffer, if provided
    if (buf) {
      for (var ii = 0; ii < 16; ii++) {
        buf[i + ii] = rnds[ii];
      }
    }

    return buf || unparse(rnds);
  }

  // Export public API
  var uuid = v4;
  uuid.v1 = v1;
  uuid.v4 = v4;
  uuid.parse = parse;
  uuid.unparse = unparse;

  module.exports = uuid;
  /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  // utils
  exports.util = __webpack_require__(1);
  exports.DOMutil = __webpack_require__(8);

  // data
  exports.DataSet = __webpack_require__(9);
  exports.DataView = __webpack_require__(11);
  exports.Queue = __webpack_require__(10);

  // Graph3d
  exports.Graph3d = __webpack_require__(12);
  exports.graph3d = {
    Camera: __webpack_require__(16),
    Filter: __webpack_require__(17),
    Point2d: __webpack_require__(15),
    Point3d: __webpack_require__(14),
    Slider: __webpack_require__(18),
    StepNumber: __webpack_require__(19)
  };

  // bundled external libraries
  exports.moment = __webpack_require__(2);
  exports.Hammer = __webpack_require__(20);
  exports.keycharm = __webpack_require__(23);

/***/ },
/* 8 */
/***/ function(module, exports) {

  'use strict';

  // DOM utility methods

  /**
   * this prepares the JSON container for allocating SVG elements
   * @param JSONcontainer
   * @private
   */
  exports.prepareElements = function (JSONcontainer) {
    // cleanup the redundant svgElements;
    for (var elementType in JSONcontainer) {
      if (JSONcontainer.hasOwnProperty(elementType)) {
        JSONcontainer[elementType].redundant = JSONcontainer[elementType].used;
        JSONcontainer[elementType].used = [];
      }
    }
  };

  /**
   * this cleans up all the unused SVG elements. By asking for the parentNode, we only need to supply the JSON container from
   * which to remove the redundant elements.
   *
   * @param JSONcontainer
   * @private
   */
  exports.cleanupElements = function (JSONcontainer) {
    // cleanup the redundant svgElements;
    for (var elementType in JSONcontainer) {
      if (JSONcontainer.hasOwnProperty(elementType)) {
        if (JSONcontainer[elementType].redundant) {
          for (var i = 0; i < JSONcontainer[elementType].redundant.length; i++) {
            JSONcontainer[elementType].redundant[i].parentNode.removeChild(JSONcontainer[elementType].redundant[i]);
          }
          JSONcontainer[elementType].redundant = [];
        }
      }
    }
  };

  /**
   * Ensures that all elements are removed first up so they can be recreated cleanly
   * @param JSONcontainer
   */
  exports.resetElements = function (JSONcontainer) {
    exports.prepareElements(JSONcontainer);
    exports.cleanupElements(JSONcontainer);
    exports.prepareElements(JSONcontainer);
  };

  /**
   * Allocate or generate an SVG element if needed. Store a reference to it in the JSON container and draw it in the svgContainer
   * the JSON container and the SVG container have to be supplied so other svg containers (like the legend) can use this.
   *
   * @param elementType
   * @param JSONcontainer
   * @param svgContainer
   * @returns {*}
   * @private
   */
  exports.getSVGElement = function (elementType, JSONcontainer, svgContainer) {
    var element;
    // allocate SVG element, if it doesnt yet exist, create one.
    if (JSONcontainer.hasOwnProperty(elementType)) {
      // this element has been created before
      // check if there is an redundant element
      if (JSONcontainer[elementType].redundant.length > 0) {
        element = JSONcontainer[elementType].redundant[0];
        JSONcontainer[elementType].redundant.shift();
      } else {
        // create a new element and add it to the SVG
        element = document.createElementNS('http://www.w3.org/2000/svg', elementType);
        svgContainer.appendChild(element);
      }
    } else {
      // create a new element and add it to the SVG, also create a new object in the svgElements to keep track of it.
      element = document.createElementNS('http://www.w3.org/2000/svg', elementType);
      JSONcontainer[elementType] = { used: [], redundant: [] };
      svgContainer.appendChild(element);
    }
    JSONcontainer[elementType].used.push(element);
    return element;
  };

  /**
   * Allocate or generate an SVG element if needed. Store a reference to it in the JSON container and draw it in the svgContainer
   * the JSON container and the SVG container have to be supplied so other svg containers (like the legend) can use this.
   *
   * @param elementType
   * @param JSONcontainer
   * @param DOMContainer
   * @returns {*}
   * @private
   */
  exports.getDOMElement = function (elementType, JSONcontainer, DOMContainer, insertBefore) {
    var element;
    // allocate DOM element, if it doesnt yet exist, create one.
    if (JSONcontainer.hasOwnProperty(elementType)) {
      // this element has been created before
      // check if there is an redundant element
      if (JSONcontainer[elementType].redundant.length > 0) {
        element = JSONcontainer[elementType].redundant[0];
        JSONcontainer[elementType].redundant.shift();
      } else {
        // create a new element and add it to the SVG
        element = document.createElement(elementType);
        if (insertBefore !== undefined) {
          DOMContainer.insertBefore(element, insertBefore);
        } else {
          DOMContainer.appendChild(element);
        }
      }
    } else {
      // create a new element and add it to the SVG, also create a new object in the svgElements to keep track of it.
      element = document.createElement(elementType);
      JSONcontainer[elementType] = { used: [], redundant: [] };
      if (insertBefore !== undefined) {
        DOMContainer.insertBefore(element, insertBefore);
      } else {
        DOMContainer.appendChild(element);
      }
    }
    JSONcontainer[elementType].used.push(element);
    return element;
  };

  /**
   * Draw a point object. This is a separate function because it can also be called by the legend.
   * The reason the JSONcontainer and the target SVG svgContainer have to be supplied is so the legend can use these functions
   * as well.
   *
   * @param x
   * @param y
   * @param groupTemplate: A template containing the necessary information to draw the datapoint e.g., {style: 'circle', size: 5, className: 'className' }
   * @param JSONcontainer
   * @param svgContainer
   * @param labelObj
   * @returns {*}
   */
  exports.drawPoint = function (x, y, groupTemplate, JSONcontainer, svgContainer, labelObj) {
    var point;
    if (groupTemplate.style == 'circle') {
      point = exports.getSVGElement('circle', JSONcontainer, svgContainer);
      point.setAttributeNS(null, "cx", x);
      point.setAttributeNS(null, "cy", y);
      point.setAttributeNS(null, "r", 0.5 * groupTemplate.size);
    } else {
      point = exports.getSVGElement('rect', JSONcontainer, svgContainer);
      point.setAttributeNS(null, "x", x - 0.5 * groupTemplate.size);
      point.setAttributeNS(null, "y", y - 0.5 * groupTemplate.size);
      point.setAttributeNS(null, "width", groupTemplate.size);
      point.setAttributeNS(null, "height", groupTemplate.size);
    }

    if (groupTemplate.styles !== undefined) {
      point.setAttributeNS(null, "style", groupTemplate.styles);
    }
    point.setAttributeNS(null, "class", groupTemplate.className + " vis-point");
    //handle label

    if (labelObj) {
      var label = exports.getSVGElement('text', JSONcontainer, svgContainer);
      if (labelObj.xOffset) {
        x = x + labelObj.xOffset;
      }

      if (labelObj.yOffset) {
        y = y + labelObj.yOffset;
      }
      if (labelObj.content) {
        label.textContent = labelObj.content;
      }

      if (labelObj.className) {
        label.setAttributeNS(null, "class", labelObj.className + " vis-label");
      }
      label.setAttributeNS(null, "x", x);
      label.setAttributeNS(null, "y", y);
    }

    return point;
  };

  /**
   * draw a bar SVG element centered on the X coordinate
   *
   * @param x
   * @param y
   * @param className
   */
  exports.drawBar = function (x, y, width, height, className, JSONcontainer, svgContainer, style) {
    if (height != 0) {
      if (height < 0) {
        height *= -1;
        y -= height;
      }
      var rect = exports.getSVGElement('rect', JSONcontainer, svgContainer);
      rect.setAttributeNS(null, "x", x - 0.5 * width);
      rect.setAttributeNS(null, "y", y);
      rect.setAttributeNS(null, "width", width);
      rect.setAttributeNS(null, "height", height);
      rect.setAttributeNS(null, "class", className);
      if (style) {
        rect.setAttributeNS(null, "style", style);
      }
    }
  };

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

  var util = __webpack_require__(1);
  var Queue = __webpack_require__(10);

  /**
   * DataSet
   *
   * Usage:
   *     var dataSet = new DataSet({
   *         fieldId: '_id',
   *         type: {
   *             // ...
   *         }
   *     });
   *
   *     dataSet.add(item);
   *     dataSet.add(data);
   *     dataSet.update(item);
   *     dataSet.update(data);
   *     dataSet.remove(id);
   *     dataSet.remove(ids);
   *     var data = dataSet.get();
   *     var data = dataSet.get(id);
   *     var data = dataSet.get(ids);
   *     var data = dataSet.get(ids, options, data);
   *     dataSet.clear();
   *
   * A data set can:
   * - add/remove/update data
   * - gives triggers upon changes in the data
   * - can  import/export data in various data formats
   *
   * @param {Array} [data]    Optional array with initial data
   * @param {Object} [options]   Available options:
   *                             {String} fieldId Field name of the id in the
   *                                              items, 'id' by default.
   *                             {Object.<String, String} type
   *                                              A map with field names as key,
   *                                              and the field type as value.
   *                             {Object} queue   Queue changes to the DataSet,
   *                                              flush them all at once.
   *                                              Queue options:
   *                                              - {number} delay  Delay in ms, null by default
   *                                              - {number} max    Maximum number of entries in the queue, Infinity by default
   * @constructor DataSet
   */
  // TODO: add a DataSet constructor DataSet(data, options)
  function DataSet(data, options) {
    // correctly read optional arguments
    if (data && !Array.isArray(data)) {
      options = data;
      data = null;
    }

    this._options = options || {};
    this._data = {}; // map with data indexed by id
    this.length = 0; // number of items in the DataSet
    this._fieldId = this._options.fieldId || 'id'; // name of the field containing id
    this._type = {}; // internal field types (NOTE: this can differ from this._options.type)

    // all variants of a Date are internally stored as Date, so we can convert
    // from everything to everything (also from ISODate to Number for example)
    if (this._options.type) {
      var fields = Object.keys(this._options.type);
      for (var i = 0, len = fields.length; i < len; i++) {
        var field = fields[i];
        var value = this._options.type[field];
        if (value == 'Date' || value == 'ISODate' || value == 'ASPDate') {
          this._type[field] = 'Date';
        } else {
          this._type[field] = value;
        }
      }
    }

    // TODO: deprecated since version 1.1.1 (or 2.0.0?)
    if (this._options.convert) {
      throw new Error('Option "convert" is deprecated. Use "type" instead.');
    }

    this._subscribers = {}; // event subscribers

    // add initial data when provided
    if (data) {
      this.add(data);
    }

    this.setOptions(options);
  }

  /**
   * @param {Object} [options]   Available options:
   *                             {Object} queue   Queue changes to the DataSet,
   *                                              flush them all at once.
   *                                              Queue options:
   *                                              - {number} delay  Delay in ms, null by default
   *                                              - {number} max    Maximum number of entries in the queue, Infinity by default
   * @param options
   */
  DataSet.prototype.setOptions = function (options) {
    if (options && options.queue !== undefined) {
      if (options.queue === false) {
        // delete queue if loaded
        if (this._queue) {
          this._queue.destroy();
          delete this._queue;
        }
      } else {
        // create queue and update its options
        if (!this._queue) {
          this._queue = Queue.extend(this, {
            replace: ['add', 'update', 'remove']
          });
        }

        if (_typeof(options.queue) === 'object') {
          this._queue.setOptions(options.queue);
        }
      }
    }
  };

  /**
   * Subscribe to an event, add an event listener
   * @param {String} event        Event name. Available events: 'put', 'update',
   *                              'remove'
   * @param {function} callback   Callback method. Called with three parameters:
   *                                  {String} event
   *                                  {Object | null} params
   *                                  {String | Number} senderId
   */
  DataSet.prototype.on = function (event, callback) {
    var subscribers = this._subscribers[event];
    if (!subscribers) {
      subscribers = [];
      this._subscribers[event] = subscribers;
    }

    subscribers.push({
      callback: callback
    });
  };

  // TODO: remove this deprecated function some day (replaced with `on` since version 0.5, deprecated since v4.0)
  DataSet.prototype.subscribe = function () {
    throw new Error('DataSet.subscribe is deprecated. Use DataSet.on instead.');
  };

  /**
   * Unsubscribe from an event, remove an event listener
   * @param {String} event
   * @param {function} callback
   */
  DataSet.prototype.off = function (event, callback) {
    var subscribers = this._subscribers[event];
    if (subscribers) {
      this._subscribers[event] = subscribers.filter(function (listener) {
        return listener.callback != callback;
      });
    }
  };

  // TODO: remove this deprecated function some day (replaced with `on` since version 0.5, deprecated since v4.0)
  DataSet.prototype.unsubscribe = function () {
    throw new Error('DataSet.unsubscribe is deprecated. Use DataSet.off instead.');
  };

  /**
   * Trigger an event
   * @param {String} event
   * @param {Object | null} params
   * @param {String} [senderId]       Optional id of the sender.
   * @private
   */
  DataSet.prototype._trigger = function (event, params, senderId) {
    if (event == '*') {
      throw new Error('Cannot trigger event *');
    }

    var subscribers = [];
    if (event in this._subscribers) {
      subscribers = subscribers.concat(this._subscribers[event]);
    }
    if ('*' in this._subscribers) {
      subscribers = subscribers.concat(this._subscribers['*']);
    }

    for (var i = 0, len = subscribers.length; i < len; i++) {
      var subscriber = subscribers[i];
      if (subscriber.callback) {
        subscriber.callback(event, params, senderId || null);
      }
    }
  };

  /**
   * Add data.
   * Adding an item will fail when there already is an item with the same id.
   * @param {Object | Array} data
   * @param {String} [senderId] Optional sender id
   * @return {Array} addedIds      Array with the ids of the added items
   */
  DataSet.prototype.add = function (data, senderId) {
    var addedIds = [],
        id,
        me = this;

    if (Array.isArray(data)) {
      // Array
      for (var i = 0, len = data.length; i < len; i++) {
        id = me._addItem(data[i]);
        addedIds.push(id);
      }
    } else if (data instanceof Object) {
      // Single item
      id = me._addItem(data);
      addedIds.push(id);
    } else {
      throw new Error('Unknown dataType');
    }

    if (addedIds.length) {
      this._trigger('add', { items: addedIds }, senderId);
    }

    return addedIds;
  };

  /**
   * Update existing items. When an item does not exist, it will be created
   * @param {Object | Array} data
   * @param {String} [senderId] Optional sender id
   * @return {Array} updatedIds     The ids of the added or updated items
   */
  DataSet.prototype.update = function (data, senderId) {
    var addedIds = [];
    var updatedIds = [];
    var oldData = [];
    var updatedData = [];
    var me = this;
    var fieldId = me._fieldId;

    var addOrUpdate = function addOrUpdate(item) {
      var id = item[fieldId];
      if (me._data[id]) {
        var oldItem = util.extend({}, me._data[id]);
        // update item
        id = me._updateItem(item);
        updatedIds.push(id);
        updatedData.push(item);
        oldData.push(oldItem);
      } else {
        // add new item
        id = me._addItem(item);
        addedIds.push(id);
      }
    };

    if (Array.isArray(data)) {
      // Array
      for (var i = 0, len = data.length; i < len; i++) {
        if (data[i] instanceof Object) {
          addOrUpdate(data[i]);
        } else {
          console.warn('Ignoring input item, which is not an object at index ' + i);
        }
      }
    } else if (data instanceof Object) {
      // Single item
      addOrUpdate(data);
    } else {
      throw new Error('Unknown dataType');
    }

    if (addedIds.length) {
      this._trigger('add', { items: addedIds }, senderId);
    }
    if (updatedIds.length) {
      var props = { items: updatedIds, oldData: oldData, data: updatedData };
      // TODO: remove deprecated property 'data' some day
      //Object.defineProperty(props, 'data', {
      //  'get': (function() {
      //    console.warn('Property data is deprecated. Use DataSet.get(ids) to retrieve the new data, use the oldData property on this object to get the old data');
      //    return updatedData;
      //  }).bind(this)
      //});
      this._trigger('update', props, senderId);
    }

    return addedIds.concat(updatedIds);
  };

  /**
   * Get a data item or multiple items.
   *
   * Usage:
   *
   *     get()
   *     get(options: Object)
   *
   *     get(id: Number | String)
   *     get(id: Number | String, options: Object)
   *
   *     get(ids: Number[] | String[])
   *     get(ids: Number[] | String[], options: Object)
   *
   * Where:
   *
   * {Number | String} id         The id of an item
   * {Number[] | String{}} ids    An array with ids of items
   * {Object} options             An Object with options. Available options:
   * {String} [returnType]        Type of data to be returned.
   *                              Can be 'Array' (default) or 'Object'.
   * {Object.<String, String>} [type]
   * {String[]} [fields]          field names to be returned
   * {function} [filter]          filter items
   * {String | function} [order]  Order the items by a field name or custom sort function.
   * @throws Error
   */
  DataSet.prototype.get = function (args) {
    var me = this;

    // parse the arguments
    var id, ids, options;
    var firstType = util.getType(arguments[0]);
    if (firstType == 'String' || firstType == 'Number') {
      // get(id [, options])
      id = arguments[0];
      options = arguments[1];
    } else if (firstType == 'Array') {
      // get(ids [, options])
      ids = arguments[0];
      options = arguments[1];
    } else {
      // get([, options])
      options = arguments[0];
    }

    // determine the return type
    var returnType;
    if (options && options.returnType) {
      var allowedValues = ['Array', 'Object'];
      returnType = allowedValues.indexOf(options.returnType) == -1 ? 'Array' : options.returnType;
    } else {
      returnType = 'Array';
    }

    // build options
    var type = options && options.type || this._options.type;
    var filter = options && options.filter;
    var items = [],
        item,
        itemIds,
        itemId,
        i,
        len;

    // convert items
    if (id != undefined) {
      // return a single item
      item = me._getItem(id, type);
      if (item && filter && !filter(item)) {
        item = null;
      }
    } else if (ids != undefined) {
      // return a subset of items
      for (i = 0, len = ids.length; i < len; i++) {
        item = me._getItem(ids[i], type);
        if (!filter || filter(item)) {
          items.push(item);
        }
      }
    } else {
      // return all items
      itemIds = Object.keys(this._data);
      for (i = 0, len = itemIds.length; i < len; i++) {
        itemId = itemIds[i];
        item = me._getItem(itemId, type);
        if (!filter || filter(item)) {
          items.push(item);
        }
      }
    }

    // order the results
    if (options && options.order && id == undefined) {
      this._sort(items, options.order);
    }

    // filter fields of the items
    if (options && options.fields) {
      var fields = options.fields;
      if (id != undefined) {
        item = this._filterFields(item, fields);
      } else {
        for (i = 0, len = items.length; i < len; i++) {
          items[i] = this._filterFields(items[i], fields);
        }
      }
    }

    // return the results
    if (returnType == 'Object') {
      var result = {},
          resultant;
      for (i = 0, len = items.length; i < len; i++) {
        resultant = items[i];
        result[resultant.id] = resultant;
      }
      return result;
    } else {
      if (id != undefined) {
        // a single item
        return item;
      } else {
        // just return our array
        return items;
      }
    }
  };

  /**
   * Get ids of all items or from a filtered set of items.
   * @param {Object} [options]    An Object with options. Available options:
   *                              {function} [filter] filter items
   *                              {String | function} [order] Order the items by
   *                                  a field name or custom sort function.
   * @return {Array} ids
   */
  DataSet.prototype.getIds = function (options) {
    var data = this._data,
        filter = options && options.filter,
        order = options && options.order,
        type = options && options.type || this._options.type,
        itemIds = Object.keys(data),
        i,
        len,
        id,
        item,
        items,
        ids = [];

    if (filter) {
      // get filtered items
      if (order) {
        // create ordered list
        items = [];
        for (i = 0, len = itemIds.length; i < len; i++) {
          id = itemIds[i];
          item = this._getItem(id, type);
          if (filter(item)) {
            items.push(item);
          }
        }

        this._sort(items, order);

        for (i = 0, len = items.length; i < len; i++) {
          ids.push(items[i][this._fieldId]);
        }
      } else {
        // create unordered list
        for (i = 0, len = itemIds.length; i < len; i++) {
          id = itemIds[i];
          item = this._getItem(id, type);
          if (filter(item)) {
            ids.push(item[this._fieldId]);
          }
        }
      }
    } else {
      // get all items
      if (order) {
        // create an ordered list
        items = [];
        for (i = 0, len = itemIds.length; i < len; i++) {
          id = itemIds[i];
          items.push(data[id]);
        }

        this._sort(items, order);

        for (i = 0, len = items.length; i < len; i++) {
          ids.push(items[i][this._fieldId]);
        }
      } else {
        // create unordered list
        for (i = 0, len = itemIds.length; i < len; i++) {
          id = itemIds[i];
          item = data[id];
          ids.push(item[this._fieldId]);
        }
      }
    }

    return ids;
  };

  /**
   * Returns the DataSet itself. Is overwritten for example by the DataView,
   * which returns the DataSet it is connected to instead.
   */
  DataSet.prototype.getDataSet = function () {
    return this;
  };

  /**
   * Execute a callback function for every item in the dataset.
   * @param {function} callback
   * @param {Object} [options]    Available options:
   *                              {Object.<String, String>} [type]
   *                              {String[]} [fields] filter fields
   *                              {function} [filter] filter items
   *                              {String | function} [order] Order the items by
   *                                  a field name or custom sort function.
   */
  DataSet.prototype.forEach = function (callback, options) {
    var filter = options && options.filter,
        type = options && options.type || this._options.type,
        data = this._data,
        itemIds = Object.keys(data),
        i,
        len,
        item,
        id;

    if (options && options.order) {
      // execute forEach on ordered list
      var items = this.get(options);

      for (i = 0, len = items.length; i < len; i++) {
        item = items[i];
        id = item[this._fieldId];
        callback(item, id);
      }
    } else {
      // unordered
      for (i = 0, len = itemIds.length; i < len; i++) {
        id = itemIds[i];
        item = this._getItem(id, type);
        if (!filter || filter(item)) {
          callback(item, id);
        }
      }
    }
  };

  /**
   * Map every item in the dataset.
   * @param {function} callback
   * @param {Object} [options]    Available options:
   *                              {Object.<String, String>} [type]
   *                              {String[]} [fields] filter fields
   *                              {function} [filter] filter items
   *                              {String | function} [order] Order the items by
   *                                  a field name or custom sort function.
   * @return {Object[]} mappedItems
   */
  DataSet.prototype.map = function (callback, options) {
    var filter = options && options.filter,
        type = options && options.type || this._options.type,
        mappedItems = [],
        data = this._data,
        itemIds = Object.keys(data),
        i,
        len,
        id,
        item;

    // convert and filter items
    for (i = 0, len = itemIds.length; i < len; i++) {
      id = itemIds[i];
      item = this._getItem(id, type);
      if (!filter || filter(item)) {
        mappedItems.push(callback(item, id));
      }
    }

    // order items
    if (options && options.order) {
      this._sort(mappedItems, options.order);
    }

    return mappedItems;
  };

  /**
   * Filter the fields of an item
   * @param {Object | null} item
   * @param {String[]} fields     Field names
   * @return {Object | null} filteredItem or null if no item is provided
   * @private
   */
  DataSet.prototype._filterFields = function (item, fields) {
    if (!item) {
      // item is null
      return item;
    }

    var filteredItem = {},
        itemFields = Object.keys(item),
        len = itemFields.length,
        i,
        field;

    if (Array.isArray(fields)) {
      for (i = 0; i < len; i++) {
        field = itemFields[i];
        if (fields.indexOf(field) != -1) {
          filteredItem[field] = item[field];
        }
      }
    } else {
      for (i = 0; i < len; i++) {
        field = itemFields[i];
        if (fields.hasOwnProperty(field)) {
          filteredItem[fields[field]] = item[field];
        }
      }
    }

    return filteredItem;
  };

  /**
   * Sort the provided array with items
   * @param {Object[]} items
   * @param {String | function} order      A field name or custom sort function.
   * @private
   */
  DataSet.prototype._sort = function (items, order) {
    if (util.isString(order)) {
      // order by provided field name
      var name = order; // field name
      items.sort(function (a, b) {
        var av = a[name];
        var bv = b[name];
        return av > bv ? 1 : av < bv ? -1 : 0;
      });
    } else if (typeof order === 'function') {
      // order by sort function
      items.sort(order);
    }
    // TODO: extend order by an Object {field:String, direction:String}
    //       where direction can be 'asc' or 'desc'
    else {
        throw new TypeError('Order must be a function or a string');
      }
  };

  /**
   * Remove an object by pointer or by id
   * @param {String | Number | Object | Array} id Object or id, or an array with
   *                                              objects or ids to be removed
   * @param {String} [senderId] Optional sender id
   * @return {Array} removedIds
   */
  DataSet.prototype.remove = function (id, senderId) {
    var removedIds = [],
        i,
        len,
        removedId;

    if (Array.isArray(id)) {
      for (i = 0, len = id.length; i < len; i++) {
        removedId = this._remove(id[i]);
        if (removedId != null) {
          removedIds.push(removedId);
        }
      }
    } else {
      removedId = this._remove(id);
      if (removedId != null) {
        removedIds.push(removedId);
      }
    }

    if (removedIds.length) {
      this._trigger('remove', { items: removedIds }, senderId);
    }

    return removedIds;
  };

  /**
   * Remove an item by its id
   * @param {Number | String | Object} id   id or item
   * @returns {Number | String | null} id
   * @private
   */
  DataSet.prototype._remove = function (id) {
    if (util.isNumber(id) || util.isString(id)) {
      if (this._data[id]) {
        delete this._data[id];
        this.length--;
        return id;
      }
    } else if (id instanceof Object) {
      var itemId = id[this._fieldId];
      if (itemId !== undefined && this._data[itemId]) {
        delete this._data[itemId];
        this.length--;
        return itemId;
      }
    }
    return null;
  };

  /**
   * Clear the data
   * @param {String} [senderId] Optional sender id
   * @return {Array} removedIds    The ids of all removed items
   */
  DataSet.prototype.clear = function (senderId) {
    var ids = Object.keys(this._data);

    this._data = {};
    this.length = 0;

    this._trigger('remove', { items: ids }, senderId);

    return ids;
  };

  /**
   * Find the item with maximum value of a specified field
   * @param {String} field
   * @return {Object | null} item  Item containing max value, or null if no items
   */
  DataSet.prototype.max = function (field) {
    var data = this._data,
        itemIds = Object.keys(data),
        max = null,
        maxField = null,
        i,
        len;

    for (i = 0, len = itemIds.length; i < len; i++) {
      var id = itemIds[i];
      var item = data[id];
      var itemField = item[field];
      if (itemField != null && (!max || itemField > maxField)) {
        max = item;
        maxField = itemField;
      }
    }

    return max;
  };

  /**
   * Find the item with minimum value of a specified field
   * @param {String} field
   * @return {Object | null} item  Item containing max value, or null if no items
   */
  DataSet.prototype.min = function (field) {
    var data = this._data,
        itemIds = Object.keys(data),
        min = null,
        minField = null,
        i,
        len;

    for (i = 0, len = itemIds.length; i < len; i++) {
      var id = itemIds[i];
      var item = data[id];
      var itemField = item[field];
      if (itemField != null && (!min || itemField < minField)) {
        min = item;
        minField = itemField;
      }
    }

    return min;
  };

  /**
   * Find all distinct values of a specified field
   * @param {String} field
   * @return {Array} values  Array containing all distinct values. If data items
   *                         do not contain the specified field are ignored.
   *                         The returned array is unordered.
   */
  DataSet.prototype.distinct = function (field) {
    var data = this._data;
    var itemIds = Object.keys(data);
    var values = [];
    var fieldType = this._options.type && this._options.type[field] || null;
    var count = 0;
    var i, j, len;

    for (i = 0, len = itemIds.length; i < len; i++) {
      var id = itemIds[i];
      var item = data[id];
      var value = item[field];
      var exists = false;
      for (j = 0; j < count; j++) {
        if (values[j] == value) {
          exists = true;
          break;
        }
      }
      if (!exists && value !== undefined) {
        values[count] = value;
        count++;
      }
    }

    if (fieldType) {
      for (i = 0, len = values.length; i < len; i++) {
        values[i] = util.convert(values[i], fieldType);
      }
    }

    return values;
  };

  /**
   * Add a single item. Will fail when an item with the same id already exists.
   * @param {Object} item
   * @return {String} id
   * @private
   */
  DataSet.prototype._addItem = function (item) {
    var id = item[this._fieldId];

    if (id != undefined) {
      // check whether this id is already taken
      if (this._data[id]) {
        // item already exists
        throw new Error('Cannot add item: item with id ' + id + ' already exists');
      }
    } else {
      // generate an id
      id = util.randomUUID();
      item[this._fieldId] = id;
    }

    var d = {},
        fields = Object.keys(item),
        i,
        len;
    for (i = 0, len = fields.length; i < len; i++) {
      var field = fields[i];
      var fieldType = this._type[field]; // type may be undefined
      d[field] = util.convert(item[field], fieldType);
    }
    this._data[id] = d;
    this.length++;

    return id;
  };

  /**
   * Get an item. Fields can be converted to a specific type
   * @param {String} id
   * @param {Object.<String, String>} [types]  field types to convert
   * @return {Object | null} item
   * @private
   */
  DataSet.prototype._getItem = function (id, types) {
    var field, value, i, len;

    // get the item from the dataset
    var raw = this._data[id];
    if (!raw) {
      return null;
    }

    // convert the items field types
    var converted = {},
        fields = Object.keys(raw);

    if (types) {
      for (i = 0, len = fields.length; i < len; i++) {
        field = fields[i];
        value = raw[field];
        converted[field] = util.convert(value, types[field]);
      }
    } else {
      // no field types specified, no converting needed
      for (i = 0, len = fields.length; i < len; i++) {
        field = fields[i];
        value = raw[field];
        converted[field] = value;
      }
    }
    return converted;
  };

  /**
   * Update a single item: merge with existing item.
   * Will fail when the item has no id, or when there does not exist an item
   * with the same id.
   * @param {Object} item
   * @return {String} id
   * @private
   */
  DataSet.prototype._updateItem = function (item) {
    var id = item[this._fieldId];
    if (id == undefined) {
      throw new Error('Cannot update item: item has no id (item: ' + JSON.stringify(item) + ')');
    }
    var d = this._data[id];
    if (!d) {
      // item doesn't exist
      throw new Error('Cannot update item: no item with id ' + id + ' found');
    }

    // merge with current item
    var fields = Object.keys(item);
    for (var i = 0, len = fields.length; i < len; i++) {
      var field = fields[i];
      var fieldType = this._type[field]; // type may be undefined
      d[field] = util.convert(item[field], fieldType);
    }

    return id;
  };

  module.exports = DataSet;

/***/ },
/* 10 */
/***/ function(module, exports) {

  'use strict';

  /**
   * A queue
   * @param {Object} options
   *            Available options:
   *            - delay: number    When provided, the queue will be flushed
   *                               automatically after an inactivity of this delay
   *                               in milliseconds.
   *                               Default value is null.
   *            - max: number      When the queue exceeds the given maximum number
   *                               of entries, the queue is flushed automatically.
   *                               Default value of max is Infinity.
   * @constructor
   */
  function Queue(options) {
    // options
    this.delay = null;
    this.max = Infinity;

    // properties
    this._queue = [];
    this._timeout = null;
    this._extended = null;

    this.setOptions(options);
  }

  /**
   * Update the configuration of the queue
   * @param {Object} options
   *            Available options:
   *            - delay: number    When provided, the queue will be flushed
   *                               automatically after an inactivity of this delay
   *                               in milliseconds.
   *                               Default value is null.
   *            - max: number      When the queue exceeds the given maximum number
   *                               of entries, the queue is flushed automatically.
   *                               Default value of max is Infinity.
   * @param options
   */
  Queue.prototype.setOptions = function (options) {
    if (options && typeof options.delay !== 'undefined') {
      this.delay = options.delay;
    }
    if (options && typeof options.max !== 'undefined') {
      this.max = options.max;
    }

    this._flushIfNeeded();
  };

  /**
   * Extend an object with queuing functionality.
   * The object will be extended with a function flush, and the methods provided
   * in options.replace will be replaced with queued ones.
   * @param {Object} object
   * @param {Object} options
   *            Available options:
   *            - replace: Array.<string>
   *                               A list with method names of the methods
   *                               on the object to be replaced with queued ones.
   *            - delay: number    When provided, the queue will be flushed
   *                               automatically after an inactivity of this delay
   *                               in milliseconds.
   *                               Default value is null.
   *            - max: number      When the queue exceeds the given maximum number
   *                               of entries, the queue is flushed automatically.
   *                               Default value of max is Infinity.
   * @return {Queue} Returns the created queue
   */
  Queue.extend = function (object, options) {
    var queue = new Queue(options);

    if (object.flush !== undefined) {
      throw new Error('Target object already has a property flush');
    }
    object.flush = function () {
      queue.flush();
    };

    var methods = [{
      name: 'flush',
      original: undefined
    }];

    if (options && options.replace) {
      for (var i = 0; i < options.replace.length; i++) {
        var name = options.replace[i];
        methods.push({
          name: name,
          original: object[name]
        });
        queue.replace(object, name);
      }
    }

    queue._extended = {
      object: object,
      methods: methods
    };

    return queue;
  };

  /**
   * Destroy the queue. The queue will first flush all queued actions, and in
   * case it has extended an object, will restore the original object.
   */
  Queue.prototype.destroy = function () {
    this.flush();

    if (this._extended) {
      var object = this._extended.object;
      var methods = this._extended.methods;
      for (var i = 0; i < methods.length; i++) {
        var method = methods[i];
        if (method.original) {
          object[method.name] = method.original;
        } else {
          delete object[method.name];
        }
      }
      this._extended = null;
    }
  };

  /**
   * Replace a method on an object with a queued version
   * @param {Object} object   Object having the method
   * @param {string} method   The method name
   */
  Queue.prototype.replace = function (object, method) {
    var me = this;
    var original = object[method];
    if (!original) {
      throw new Error('Method ' + method + ' undefined');
    }

    object[method] = function () {
      // create an Array with the arguments
      var args = [];
      for (var i = 0; i < arguments.length; i++) {
        args[i] = arguments[i];
      }

      // add this call to the queue
      me.queue({
        args: args,
        fn: original,
        context: this
      });
    };
  };

  /**
   * Queue a call
   * @param {function | {fn: function, args: Array} | {fn: function, args: Array, context: Object}} entry
   */
  Queue.prototype.queue = function (entry) {
    if (typeof entry === 'function') {
      this._queue.push({ fn: entry });
    } else {
      this._queue.push(entry);
    }

    this._flushIfNeeded();
  };

  /**
   * Check whether the queue needs to be flushed
   * @private
   */
  Queue.prototype._flushIfNeeded = function () {
    // flush when the maximum is exceeded.
    if (this._queue.length > this.max) {
      this.flush();
    }

    // flush after a period of inactivity when a delay is configured
    clearTimeout(this._timeout);
    if (this.queue.length > 0 && typeof this.delay === 'number') {
      var me = this;
      this._timeout = setTimeout(function () {
        me.flush();
      }, this.delay);
    }
  };

  /**
   * Flush all queued calls
   */
  Queue.prototype.flush = function () {
    while (this._queue.length > 0) {
      var entry = this._queue.shift();
      entry.fn.apply(entry.context || entry.fn, entry.args || []);
    }
  };

  module.exports = Queue;

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var util = __webpack_require__(1);
  var DataSet = __webpack_require__(9);

  /**
   * DataView
   *
   * a dataview offers a filtered view on a dataset or an other dataview.
   *
   * @param {DataSet | DataView} data
   * @param {Object} [options]   Available options: see method get
   *
   * @constructor DataView
   */
  function DataView(data, options) {
    this._data = null;
    this._ids = {}; // ids of the items currently in memory (just contains a boolean true)
    this.length = 0; // number of items in the DataView
    this._options = options || {};
    this._fieldId = 'id'; // name of the field containing id
    this._subscribers = {}; // event subscribers

    var me = this;
    this.listener = function () {
      me._onEvent.apply(me, arguments);
    };

    this.setData(data);
  }

  // TODO: implement a function .config() to dynamically update things like configured filter
  // and trigger changes accordingly

  /**
   * Set a data source for the view
   * @param {DataSet | DataView} data
   */
  DataView.prototype.setData = function (data) {
    var ids, id, i, len;

    if (this._data) {
      // unsubscribe from current dataset
      if (this._data.off) {
        this._data.off('*', this.listener);
      }

      // trigger a remove of all items in memory
      ids = Object.keys(this._ids);
      this._ids = {};
      this.length = 0;
      this._trigger('remove', { items: ids });
    }

    this._data = data;

    if (this._data) {
      // update fieldId
      this._fieldId = this._options.fieldId || this._data && this._data.options && this._data.options.fieldId || 'id';

      // trigger an add of all added items
      ids = this._data.getIds({ filter: this._options && this._options.filter });
      for (i = 0, len = ids.length; i < len; i++) {
        id = ids[i];
        this._ids[id] = true;
      }
      this.length = ids.length;
      this._trigger('add', { items: ids });

      // subscribe to new dataset
      if (this._data.on) {
        this._data.on('*', this.listener);
      }
    }
  };

  /**
   * Refresh the DataView. Useful when the DataView has a filter function
   * containing a variable parameter.
   */
  DataView.prototype.refresh = function () {
    var id, i, len;
    var ids = this._data.getIds({ filter: this._options && this._options.filter });
    var oldIds = Object.keys(this._ids);
    var newIds = {};
    var added = [];
    var removed = [];

    // check for additions
    for (i = 0, len = ids.length; i < len; i++) {
      id = ids[i];
      newIds[id] = true;
      if (!this._ids[id]) {
        added.push(id);
        this._ids[id] = true;
      }
    }

    // check for removals
    for (i = 0, len = oldIds.length; i < len; i++) {
      id = oldIds[i];
      if (!newIds[id]) {
        removed.push(id);
        delete this._ids[id];
      }
    }

    this.length += added.length - removed.length;

    // trigger events
    if (added.length) {
      this._trigger('add', { items: added });
    }
    if (removed.length) {
      this._trigger('remove', { items: removed });
    }
  };

  /**
   * Get data from the data view
   *
   * Usage:
   *
   *     get()
   *     get(options: Object)
   *     get(options: Object, data: Array | DataTable)
   *
   *     get(id: Number)
   *     get(id: Number, options: Object)
   *     get(id: Number, options: Object, data: Array | DataTable)
   *
   *     get(ids: Number[])
   *     get(ids: Number[], options: Object)
   *     get(ids: Number[], options: Object, data: Array | DataTable)
   *
   * Where:
   *
   * {Number | String} id         The id of an item
   * {Number[] | String{}} ids    An array with ids of items
   * {Object} options             An Object with options. Available options:
   *                              {String} [type] Type of data to be returned. Can
   *                                              be 'DataTable' or 'Array' (default)
   *                              {Object.<String, String>} [convert]
   *                              {String[]} [fields] field names to be returned
   *                              {function} [filter] filter items
   *                              {String | function} [order] Order the items by
   *                                  a field name or custom sort function.
   * {Array | DataTable} [data]   If provided, items will be appended to this
   *                              array or table. Required in case of Google
   *                              DataTable.
   * @param args
   */
  DataView.prototype.get = function (args) {
    var me = this;

    // parse the arguments
    var ids, options, data;
    var firstType = util.getType(arguments[0]);
    if (firstType == 'String' || firstType == 'Number' || firstType == 'Array') {
      // get(id(s) [, options] [, data])
      ids = arguments[0]; // can be a single id or an array with ids
      options = arguments[1];
      data = arguments[2];
    } else {
      // get([, options] [, data])
      options = arguments[0];
      data = arguments[1];
    }

    // extend the options with the default options and provided options
    var viewOptions = util.extend({}, this._options, options);

    // create a combined filter method when needed
    if (this._options.filter && options && options.filter) {
      viewOptions.filter = function (item) {
        return me._options.filter(item) && options.filter(item);
      };
    }

    // build up the call to the linked data set
    var getArguments = [];
    if (ids != undefined) {
      getArguments.push(ids);
    }
    getArguments.push(viewOptions);
    getArguments.push(data);

    return this._data && this._data.get.apply(this._data, getArguments);
  };

  /**
   * Get ids of all items or from a filtered set of items.
   * @param {Object} [options]    An Object with options. Available options:
   *                              {function} [filter] filter items
   *                              {String | function} [order] Order the items by
   *                                  a field name or custom sort function.
   * @return {Array} ids
   */
  DataView.prototype.getIds = function (options) {
    var ids;

    if (this._data) {
      var defaultFilter = this._options.filter;
      var filter;

      if (options && options.filter) {
        if (defaultFilter) {
          filter = function filter(item) {
            return defaultFilter(item) && options.filter(item);
          };
        } else {
          filter = options.filter;
        }
      } else {
        filter = defaultFilter;
      }

      ids = this._data.getIds({
        filter: filter,
        order: options && options.order
      });
    } else {
      ids = [];
    }

    return ids;
  };

  /**
   * Map every item in the dataset.
   * @param {function} callback
   * @param {Object} [options]    Available options:
   *                              {Object.<String, String>} [type]
   *                              {String[]} [fields] filter fields
   *                              {function} [filter] filter items
   *                              {String | function} [order] Order the items by
   *                                  a field name or custom sort function.
   * @return {Object[]} mappedItems
   */
  DataView.prototype.map = function (callback, options) {
    var mappedItems = [];
    if (this._data) {
      var defaultFilter = this._options.filter;
      var filter;

      if (options && options.filter) {
        if (defaultFilter) {
          filter = function filter(item) {
            return defaultFilter(item) && options.filter(item);
          };
        } else {
          filter = options.filter;
        }
      } else {
        filter = defaultFilter;
      }

      mappedItems = this._data.map(callback, {
        filter: filter,
        order: options && options.order
      });
    } else {
      mappedItems = [];
    }

    return mappedItems;
  };

  /**
   * Get the DataSet to which this DataView is connected. In case there is a chain
   * of multiple DataViews, the root DataSet of this chain is returned.
   * @return {DataSet} dataSet
   */
  DataView.prototype.getDataSet = function () {
    var dataSet = this;
    while (dataSet instanceof DataView) {
      dataSet = dataSet._data;
    }
    return dataSet || null;
  };

  /**
   * Event listener. Will propagate all events from the connected data set to
   * the subscribers of the DataView, but will filter the items and only trigger
   * when there are changes in the filtered data set.
   * @param {String} event
   * @param {Object | null} params
   * @param {String} senderId
   * @private
   */
  DataView.prototype._onEvent = function (event, params, senderId) {
    var i, len, id, item;
    var ids = params && params.items;
    var data = this._data;
    var updatedData = [];
    var added = [];
    var updated = [];
    var removed = [];

    if (ids && data) {
      switch (event) {
        case 'add':
          // filter the ids of the added items
          for (i = 0, len = ids.length; i < len; i++) {
            id = ids[i];
            item = this.get(id);
            if (item) {
              this._ids[id] = true;
              added.push(id);
            }
          }

          break;

        case 'update':
          // determine the event from the views viewpoint: an updated
          // item can be added, updated, or removed from this view.
          for (i = 0, len = ids.length; i < len; i++) {
            id = ids[i];
            item = this.get(id);

            if (item) {
              if (this._ids[id]) {
                updated.push(id);
                updatedData.push(params.data[i]);
              } else {
                this._ids[id] = true;
                added.push(id);
              }
            } else {
              if (this._ids[id]) {
                delete this._ids[id];
                removed.push(id);
              } else {
                // nothing interesting for me :-(
              }
            }
          }

          break;

        case 'remove':
          // filter the ids of the removed items
          for (i = 0, len = ids.length; i < len; i++) {
            id = ids[i];
            if (this._ids[id]) {
              delete this._ids[id];
              removed.push(id);
            }
          }

          break;
      }

      this.length += added.length - removed.length;

      if (added.length) {
        this._trigger('add', { items: added }, senderId);
      }
      if (updated.length) {
        this._trigger('update', { items: updated, data: updatedData }, senderId);
      }
      if (removed.length) {
        this._trigger('remove', { items: removed }, senderId);
      }
    }
  };

  // copy subscription functionality from DataSet
  DataView.prototype.on = DataSet.prototype.on;
  DataView.prototype.off = DataSet.prototype.off;
  DataView.prototype._trigger = DataSet.prototype._trigger;

  // TODO: make these functions deprecated (replaced with `on` and `off` since version 0.5)
  DataView.prototype.subscribe = DataView.prototype.on;
  DataView.prototype.unsubscribe = DataView.prototype.off;

  module.exports = DataView;

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

  var Emitter = __webpack_require__(13);
  var DataSet = __webpack_require__(9);
  var DataView = __webpack_require__(11);
  var util = __webpack_require__(1);
  var Point3d = __webpack_require__(14);
  var Point2d = __webpack_require__(15);
  var Camera = __webpack_require__(16);
  var Filter = __webpack_require__(17);
  var Slider = __webpack_require__(18);
  var StepNumber = __webpack_require__(19);

  /**
   * @constructor Graph3d
   * Graph3d displays data in 3d.
   *
   * Graph3d is developed in javascript as a Google Visualization Chart.
   *
   * @param {Element} container   The DOM element in which the Graph3d will
   *                              be created. Normally a div element.
   * @param {DataSet | DataView | Array} [data]
   * @param {Object} [options]
   */
  function Graph3d(container, data, options) {
    if (!(this instanceof Graph3d)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    // create variables and set default values
    this.containerElement = container;
    this.width = '400px';
    this.height = '400px';
    this.margin = 10; // px
    this.defaultXCenter = '55%';
    this.defaultYCenter = '50%';

    this.xLabel = 'x';
    this.yLabel = 'y';
    this.zLabel = 'z';

    var passValueFn = function passValueFn(v) {
      return v;
    };
    this.xValueLabel = passValueFn;
    this.yValueLabel = passValueFn;
    this.zValueLabel = passValueFn;

    this.filterLabel = 'time';
    this.legendLabel = 'value';

    this.style = Graph3d.STYLE.DOT;
    this.showPerspective = true;
    this.showGrid = true;
    this.keepAspectRatio = true;
    this.showShadow = false;
    this.showGrayBottom = false; // TODO: this does not work correctly
    this.showTooltip = false;
    this.verticalRatio = 0.5; // 0.1 to 1.0, where 1.0 results in a 'cube'

    this.animationInterval = 1000; // milliseconds
    this.animationPreload = false;

    this.camera = new Camera();
    this.camera.setArmRotation(1.0, 0.5);
    this.camera.setArmLength(1.7);
    this.eye = new Point3d(0, 0, -1); // TODO: set eye.z about 3/4 of the width of the window?

    this.dataTable = null; // The original data table
    this.dataPoints = null; // The table with point objects

    // the column indexes
    this.colX = undefined;
    this.colY = undefined;
    this.colZ = undefined;
    this.colValue = undefined;
    this.colFilter = undefined;

    this.xMin = 0;
    this.xStep = undefined; // auto by default
    this.xMax = 1;
    this.yMin = 0;
    this.yStep = undefined; // auto by default
    this.yMax = 1;
    this.zMin = 0;
    this.zStep = undefined; // auto by default
    this.zMax = 1;
    this.valueMin = 0;
    this.valueMax = 1;
    this.xBarWidth = 1;
    this.yBarWidth = 1;
    // TODO: customize axis range

    // colors
    this.axisColor = '#4D4D4D';
    this.gridColor = '#D3D3D3';
    this.dataColor = {
      fill: '#7DC1FF',
      stroke: '#3267D2',
      strokeWidth: 1 // px
    };

    this.dotSizeRatio = 0.02; // size of the dots as a fraction of the graph width

    // create a frame and canvas
    this.create();

    // apply options (also when undefined)
    this.setOptions(options);

    // apply data
    if (data) {
      this.setData(data);
    }
  }

  // Extend Graph3d with an Emitter mixin
  Emitter(Graph3d.prototype);

  /**
   * Calculate the scaling values, dependent on the range in x, y, and z direction
   */
  Graph3d.prototype._setScale = function () {
    this.scale = new Point3d(1 / (this.xMax - this.xMin), 1 / (this.yMax - this.yMin), 1 / (this.zMax - this.zMin));

    // keep aspect ration between x and y scale if desired
    if (this.keepAspectRatio) {
      if (this.scale.x < this.scale.y) {
        //noinspection JSSuspiciousNameCombination
        this.scale.y = this.scale.x;
      } else {
        //noinspection JSSuspiciousNameCombination
        this.scale.x = this.scale.y;
      }
    }

    // scale the vertical axis
    this.scale.z *= this.verticalRatio;
    // TODO: can this be automated? verticalRatio?

    // determine scale for (optional) value
    this.scale.value = 1 / (this.valueMax - this.valueMin);

    // position the camera arm
    var xCenter = (this.xMax + this.xMin) / 2 * this.scale.x;
    var yCenter = (this.yMax + this.yMin) / 2 * this.scale.y;
    var zCenter = (this.zMax + this.zMin) / 2 * this.scale.z;
    this.camera.setArmLocation(xCenter, yCenter, zCenter);
  };

  /**
   * Convert a 3D location to a 2D location on screen
   * http://en.wikipedia.org/wiki/3D_projection
   * @param {Point3d} point3d   A 3D point with parameters x, y, z
   * @return {Point2d} point2d  A 2D point with parameters x, y
   */
  Graph3d.prototype._convert3Dto2D = function (point3d) {
    var translation = this._convertPointToTranslation(point3d);
    return this._convertTranslationToScreen(translation);
  };

  /**
   * Convert a 3D location its translation seen from the camera
   * http://en.wikipedia.org/wiki/3D_projection
   * @param {Point3d} point3d    A 3D point with parameters x, y, z
   * @return {Point3d} translation A 3D point with parameters x, y, z This is
   *                   the translation of the point, seen from the
   *                   camera
   */
  Graph3d.prototype._convertPointToTranslation = function (point3d) {
    var ax = point3d.x * this.scale.x,
        ay = point3d.y * this.scale.y,
        az = point3d.z * this.scale.z,
        cx = this.camera.getCameraLocation().x,
        cy = this.camera.getCameraLocation().y,
        cz = this.camera.getCameraLocation().z,


    // calculate angles
    sinTx = Math.sin(this.camera.getCameraRotation().x),
        cosTx = Math.cos(this.camera.getCameraRotation().x),
        sinTy = Math.sin(this.camera.getCameraRotation().y),
        cosTy = Math.cos(this.camera.getCameraRotation().y),
        sinTz = Math.sin(this.camera.getCameraRotation().z),
        cosTz = Math.cos(this.camera.getCameraRotation().z),


    // calculate translation
    dx = cosTy * (sinTz * (ay - cy) + cosTz * (ax - cx)) - sinTy * (az - cz),
        dy = sinTx * (cosTy * (az - cz) + sinTy * (sinTz * (ay - cy) + cosTz * (ax - cx))) + cosTx * (cosTz * (ay - cy) - sinTz * (ax - cx)),
        dz = cosTx * (cosTy * (az - cz) + sinTy * (sinTz * (ay - cy) + cosTz * (ax - cx))) - sinTx * (cosTz * (ay - cy) - sinTz * (ax - cx));

    return new Point3d(dx, dy, dz);
  };

  /**
   * Convert a translation point to a point on the screen
   * @param {Point3d} translation   A 3D point with parameters x, y, z This is
   *                    the translation of the point, seen from the
   *                    camera
   * @return {Point2d} point2d    A 2D point with parameters x, y
   */
  Graph3d.prototype._convertTranslationToScreen = function (translation) {
    var ex = this.eye.x,
        ey = this.eye.y,
        ez = this.eye.z,
        dx = translation.x,
        dy = translation.y,
        dz = translation.z;

    // calculate position on screen from translation
    var bx;
    var by;
    if (this.showPerspective) {
      bx = (dx - ex) * (ez / dz);
      by = (dy - ey) * (ez / dz);
    } else {
      bx = dx * -(ez / this.camera.getArmLength());
      by = dy * -(ez / this.camera.getArmLength());
    }

    // shift and scale the point to the center of the screen
    // use the width of the graph to scale both horizontally and vertically.
    return new Point2d(this.xcenter + bx * this.frame.canvas.clientWidth, this.ycenter - by * this.frame.canvas.clientWidth);
  };

  /**
   * Set the background styling for the graph
   * @param {string | {fill: string, stroke: string, strokeWidth: string}} backgroundColor
   */
  Graph3d.prototype._setBackgroundColor = function (backgroundColor) {
    var fill = 'white';
    var stroke = 'gray';
    var strokeWidth = 1;

    if (typeof backgroundColor === 'string') {
      fill = backgroundColor;
      stroke = 'none';
      strokeWidth = 0;
    } else if ((typeof backgroundColor === 'undefined' ? 'undefined' : _typeof(backgroundColor)) === 'object') {
      if (backgroundColor.fill !== undefined) fill = backgroundColor.fill;
      if (backgroundColor.stroke !== undefined) stroke = backgroundColor.stroke;
      if (backgroundColor.strokeWidth !== undefined) strokeWidth = backgroundColor.strokeWidth;
    } else if (backgroundColor === undefined) {
      // use use defaults
    } else {
        throw 'Unsupported type of backgroundColor';
      }

    this.frame.style.backgroundColor = fill;
    this.frame.style.borderColor = stroke;
    this.frame.style.borderWidth = strokeWidth + 'px';
    this.frame.style.borderStyle = 'solid';
  };

  /// enumerate the available styles
  Graph3d.STYLE = {
    BAR: 0,
    BARCOLOR: 1,
    BARSIZE: 2,
    DOT: 3,
    DOTLINE: 4,
    DOTCOLOR: 5,
    DOTSIZE: 6,
    GRID: 7,
    LINE: 8,
    SURFACE: 9
  };

  /**
   * Retrieve the style index from given styleName
   * @param {string} styleName  Style name such as 'dot', 'grid', 'dot-line'
   * @return {Number} styleNumber Enumeration value representing the style, or -1
   *                when not found
   */
  Graph3d.prototype._getStyleNumber = function (styleName) {
    switch (styleName) {
      case 'dot':
        return Graph3d.STYLE.DOT;
      case 'dot-line':
        return Graph3d.STYLE.DOTLINE;
      case 'dot-color':
        return Graph3d.STYLE.DOTCOLOR;
      case 'dot-size':
        return Graph3d.STYLE.DOTSIZE;
      case 'line':
        return Graph3d.STYLE.LINE;
      case 'grid':
        return Graph3d.STYLE.GRID;
      case 'surface':
        return Graph3d.STYLE.SURFACE;
      case 'bar':
        return Graph3d.STYLE.BAR;
      case 'bar-color':
        return Graph3d.STYLE.BARCOLOR;
      case 'bar-size':
        return Graph3d.STYLE.BARSIZE;
    }

    return -1;
  };

  /**
   * Determine the indexes of the data columns, based on the given style and data
   * @param {DataSet} data
   * @param {Number}  style
   */
  Graph3d.prototype._determineColumnIndexes = function (data, style) {
    if (this.style === Graph3d.STYLE.DOT || this.style === Graph3d.STYLE.DOTLINE || this.style === Graph3d.STYLE.LINE || this.style === Graph3d.STYLE.GRID || this.style === Graph3d.STYLE.SURFACE || this.style === Graph3d.STYLE.BAR) {
      // 3 columns expected, and optionally a 4th with filter values
      this.colX = 0;
      this.colY = 1;
      this.colZ = 2;
      this.colValue = undefined;

      if (data.getNumberOfColumns() > 3) {
        this.colFilter = 3;
      }
    } else if (this.style === Graph3d.STYLE.DOTCOLOR || this.style === Graph3d.STYLE.DOTSIZE || this.style === Graph3d.STYLE.BARCOLOR || this.style === Graph3d.STYLE.BARSIZE) {
      // 4 columns expected, and optionally a 5th with filter values
      this.colX = 0;
      this.colY = 1;
      this.colZ = 2;
      this.colValue = 3;

      if (data.getNumberOfColumns() > 4) {
        this.colFilter = 4;
      }
    } else {
      throw 'Unknown style "' + this.style + '"';
    }
  };

  Graph3d.prototype.getNumberOfRows = function (data) {
    return data.length;
  };

  Graph3d.prototype.getNumberOfColumns = function (data) {
    var counter = 0;
    for (var column in data[0]) {
      if (data[0].hasOwnProperty(column)) {
        counter++;
      }
    }
    return counter;
  };

  Graph3d.prototype.getDistinctValues = function (data, column) {
    var distinctValues = [];
    for (var i = 0; i < data.length; i++) {
      if (distinctValues.indexOf(data[i][column]) == -1) {
        distinctValues.push(data[i][column]);
      }
    }
    return distinctValues;
  };

  Graph3d.prototype.getColumnRange = function (data, column) {
    var minMax = { min: data[0][column], max: data[0][column] };
    for (var i = 0; i < data.length; i++) {
      if (minMax.min > data[i][column]) {
        minMax.min = data[i][column];
      }
      if (minMax.max < data[i][column]) {
        minMax.max = data[i][column];
      }
    }
    return minMax;
  };

  /**
   * Initialize the data from the data table. Calculate minimum and maximum values
   * and column index values
   * @param {Array | DataSet | DataView} rawData   The data containing the items for the Graph.
   * @param {Number}     style   Style Number
   */
  Graph3d.prototype._dataInitialize = function (rawData, style) {
    var me = this;

    // unsubscribe from the dataTable
    if (this.dataSet) {
      this.dataSet.off('*', this._onChange);
    }

    if (rawData === undefined) return;

    if (Array.isArray(rawData)) {
      rawData = new DataSet(rawData);
    }

    var data;
    if (rawData instanceof DataSet || rawData instanceof DataView) {
      data = rawData.get();
    } else {
      throw new Error('Array, DataSet, or DataView expected');
    }

    if (data.length == 0) return;

    this.dataSet = rawData;
    this.dataTable = data;

    // subscribe to changes in the dataset
    this._onChange = function () {
      me.setData(me.dataSet);
    };
    this.dataSet.on('*', this._onChange);

    // _determineColumnIndexes
    // getNumberOfRows (points)
    // getNumberOfColumns (x,y,z,v,t,t1,t2...)
    // getDistinctValues (unique values?)
    // getColumnRange

    // determine the location of x,y,z,value,filter columns
    this.colX = 'x';
    this.colY = 'y';
    this.colZ = 'z';
    this.colValue = 'style';
    this.colFilter = 'filter';

    // check if a filter column is provided
    if (data[0].hasOwnProperty('filter')) {
      if (this.dataFilter === undefined) {
        this.dataFilter = new Filter(rawData, this.colFilter, this);
        this.dataFilter.setOnLoadCallback(function () {
          me.redraw();
        });
      }
    }

    var withBars = this.style == Graph3d.STYLE.BAR || this.style == Graph3d.STYLE.BARCOLOR || this.style == Graph3d.STYLE.BARSIZE;

    // determine barWidth from data
    if (withBars) {
      if (this.defaultXBarWidth !== undefined) {
        this.xBarWidth = this.defaultXBarWidth;
      } else {
        var dataX = this.getDistinctValues(data, this.colX);
        this.xBarWidth = dataX[1] - dataX[0] || 1;
      }

      if (this.defaultYBarWidth !== undefined) {
        this.yBarWidth = this.defaultYBarWidth;
      } else {
        var dataY = this.getDistinctValues(data, this.colY);
        this.yBarWidth = dataY[1] - dataY[0] || 1;
      }
    }

    // calculate minimums and maximums
    var xRange = this.getColumnRange(data, this.colX);
    if (withBars) {
      xRange.min -= this.xBarWidth / 2;
      xRange.max += this.xBarWidth / 2;
    }
    this.xMin = this.defaultXMin !== undefined ? this.defaultXMin : xRange.min;
    this.xMax = this.defaultXMax !== undefined ? this.defaultXMax : xRange.max;
    if (this.xMax <= this.xMin) this.xMax = this.xMin + 1;
    this.xStep = this.defaultXStep !== undefined ? this.defaultXStep : (this.xMax - this.xMin) / 5;

    var yRange = this.getColumnRange(data, this.colY);
    if (withBars) {
      yRange.min -= this.yBarWidth / 2;
      yRange.max += this.yBarWidth / 2;
    }
    this.yMin = this.defaultYMin !== undefined ? this.defaultYMin : yRange.min;
    this.yMax = this.defaultYMax !== undefined ? this.defaultYMax : yRange.max;
    if (this.yMax <= this.yMin) this.yMax = this.yMin + 1;
    this.yStep = this.defaultYStep !== undefined ? this.defaultYStep : (this.yMax - this.yMin) / 5;

    var zRange = this.getColumnRange(data, this.colZ);
    this.zMin = this.defaultZMin !== undefined ? this.defaultZMin : zRange.min;
    this.zMax = this.defaultZMax !== undefined ? this.defaultZMax : zRange.max;
    if (this.zMax <= this.zMin) this.zMax = this.zMin + 1;
    this.zStep = this.defaultZStep !== undefined ? this.defaultZStep : (this.zMax - this.zMin) / 5;

    if (this.colValue !== undefined) {
      var valueRange = this.getColumnRange(data, this.colValue);
      this.valueMin = this.defaultValueMin !== undefined ? this.defaultValueMin : valueRange.min;
      this.valueMax = this.defaultValueMax !== undefined ? this.defaultValueMax : valueRange.max;
      if (this.valueMax <= this.valueMin) this.valueMax = this.valueMin + 1;
    }

    // set the scale dependent on the ranges.
    this._setScale();
  };

  /**
   * Filter the data based on the current filter
   * @param {Array} data
   * @return {Array} dataPoints   Array with point objects which can be drawn on screen
   */
  Graph3d.prototype._getDataPoints = function (data) {
    // TODO: store the created matrix dataPoints in the filters instead of reloading each time
    var x, y, i, z, obj, point;

    var dataPoints = [];

    if (this.style === Graph3d.STYLE.GRID || this.style === Graph3d.STYLE.SURFACE) {
      // copy all values from the google data table to a matrix
      // the provided values are supposed to form a grid of (x,y) positions

      // create two lists with all present x and y values
      var dataX = [];
      var dataY = [];
      for (i = 0; i < this.getNumberOfRows(data); i++) {
        x = data[i][this.colX] || 0;
        y = data[i][this.colY] || 0;

        if (dataX.indexOf(x) === -1) {
          dataX.push(x);
        }
        if (dataY.indexOf(y) === -1) {
          dataY.push(y);
        }
      }

      var sortNumber = function sortNumber(a, b) {
        return a - b;
      };
      dataX.sort(sortNumber);
      dataY.sort(sortNumber);

      // create a grid, a 2d matrix, with all values.
      var dataMatrix = []; // temporary data matrix
      for (i = 0; i < data.length; i++) {
        x = data[i][this.colX] || 0;
        y = data[i][this.colY] || 0;
        z = data[i][this.colZ] || 0;

        var xIndex = dataX.indexOf(x); // TODO: implement Array().indexOf() for Internet Explorer
        var yIndex = dataY.indexOf(y);

        if (dataMatrix[xIndex] === undefined) {
          dataMatrix[xIndex] = [];
        }

        var point3d = new Point3d();
        point3d.x = x;
        point3d.y = y;
        point3d.z = z;

        obj = {};
        obj.point = point3d;
        obj.trans = undefined;
        obj.screen = undefined;
        obj.bottom = new Point3d(x, y, this.zMin);

        dataMatrix[xIndex][yIndex] = obj;

        dataPoints.push(obj);
      }

      // fill in the pointers to the neighbors.
      for (x = 0; x < dataMatrix.length; x++) {
        for (y = 0; y < dataMatrix[x].length; y++) {
          if (dataMatrix[x][y]) {
            dataMatrix[x][y].pointRight = x < dataMatrix.length - 1 ? dataMatrix[x + 1][y] : undefined;
            dataMatrix[x][y].pointTop = y < dataMatrix[x].length - 1 ? dataMatrix[x][y + 1] : undefined;
            dataMatrix[x][y].pointCross = x < dataMatrix.length - 1 && y < dataMatrix[x].length - 1 ? dataMatrix[x + 1][y + 1] : undefined;
          }
        }
      }
    } else {
      // 'dot', 'dot-line', etc.
      // copy all values from the google data table to a list with Point3d objects
      for (i = 0; i < data.length; i++) {
        point = new Point3d();
        point.x = data[i][this.colX] || 0;
        point.y = data[i][this.colY] || 0;
        point.z = data[i][this.colZ] || 0;

        if (this.colValue !== undefined) {
          point.value = data[i][this.colValue] || 0;
        }

        obj = {};
        obj.point = point;
        obj.bottom = new Point3d(point.x, point.y, this.zMin);
        obj.trans = undefined;
        obj.screen = undefined;

        dataPoints.push(obj);
      }
    }

    return dataPoints;
  };

  /**
   * Create the main frame for the Graph3d.
   * This function is executed once when a Graph3d object is created. The frame
   * contains a canvas, and this canvas contains all objects like the axis and
   * nodes.
   */
  Graph3d.prototype.create = function () {
    // remove all elements from the container element.
    while (this.containerElement.hasChildNodes()) {
      this.containerElement.removeChild(this.containerElement.firstChild);
    }

    this.frame = document.createElement('div');
    this.frame.style.position = 'relative';
    this.frame.style.overflow = 'hidden';

    // create the graph canvas (HTML canvas element)
    this.frame.canvas = document.createElement('canvas');
    this.frame.canvas.style.position = 'relative';
    this.frame.appendChild(this.frame.canvas);
    //if (!this.frame.canvas.getContext) {
    {
      var noCanvas = document.createElement('DIV');
      noCanvas.style.color = 'red';
      noCanvas.style.fontWeight = 'bold';
      noCanvas.style.padding = '10px';
      noCanvas.innerHTML = 'Error: your browser does not support HTML canvas';
      this.frame.canvas.appendChild(noCanvas);
    }

    this.frame.filter = document.createElement('div');
    this.frame.filter.style.position = 'absolute';
    this.frame.filter.style.bottom = '0px';
    this.frame.filter.style.left = '0px';
    this.frame.filter.style.width = '100%';
    this.frame.appendChild(this.frame.filter);

    // add event listeners to handle moving and zooming the contents
    var me = this;
    var onmousedown = function onmousedown(event) {
      me._onMouseDown(event);
    };
    var ontouchstart = function ontouchstart(event) {
      me._onTouchStart(event);
    };
    var onmousewheel = function onmousewheel(event) {
      me._onWheel(event);
    };
    var ontooltip = function ontooltip(event) {
      me._onTooltip(event);
    };
    // TODO: these events are never cleaned up... can give a 'memory leakage'

    util.addEventListener(this.frame.canvas, 'keydown', onkeydown);
    util.addEventListener(this.frame.canvas, 'mousedown', onmousedown);
    util.addEventListener(this.frame.canvas, 'touchstart', ontouchstart);
    util.addEventListener(this.frame.canvas, 'mousewheel', onmousewheel);
    util.addEventListener(this.frame.canvas, 'mousemove', ontooltip);

    // add the new graph to the container element
    this.containerElement.appendChild(this.frame);
  };

  /**
   * Set a new size for the graph
   * @param {string} width   Width in pixels or percentage (for example '800px'
   *             or '50%')
   * @param {string} height  Height in pixels or percentage  (for example '400px'
   *             or '30%')
   */
  Graph3d.prototype.setSize = function (width, height) {
    this.frame.style.width = width;
    this.frame.style.height = height;

    this._resizeCanvas();
  };

  /**
   * Resize the canvas to the current size of the frame
   */
  Graph3d.prototype._resizeCanvas = function () {
    this.frame.canvas.style.width = '100%';
    this.frame.canvas.style.height = '100%';

    this.frame.canvas.width = this.frame.canvas.clientWidth;
    this.frame.canvas.height = this.frame.canvas.clientHeight;

    // adjust with for margin
    this.frame.filter.style.width = this.frame.canvas.clientWidth - 2 * 10 + 'px';
  };

  /**
   * Start animation
   */
  Graph3d.prototype.animationStart = function () {
    if (!this.frame.filter || !this.frame.filter.slider) throw 'No animation available';

    this.frame.filter.slider.play();
  };

  /**
   * Stop animation
   */
  Graph3d.prototype.animationStop = function () {
    if (!this.frame.filter || !this.frame.filter.slider) return;

    this.frame.filter.slider.stop();
  };

  /**
   * Resize the center position based on the current values in this.defaultXCenter
   * and this.defaultYCenter (which are strings with a percentage or a value
   * in pixels). The center positions are the variables this.xCenter
   * and this.yCenter
   */
  Graph3d.prototype._resizeCenter = function () {
    // calculate the horizontal center position
    if (this.defaultXCenter.charAt(this.defaultXCenter.length - 1) === '%') {
      this.xcenter = parseFloat(this.defaultXCenter) / 100 * this.frame.canvas.clientWidth;
    } else {
      this.xcenter = parseFloat(this.defaultXCenter); // supposed to be in px
    }

    // calculate the vertical center position
    if (this.defaultYCenter.charAt(this.defaultYCenter.length - 1) === '%') {
      this.ycenter = parseFloat(this.defaultYCenter) / 100 * (this.frame.canvas.clientHeight - this.frame.filter.clientHeight);
    } else {
      this.ycenter = parseFloat(this.defaultYCenter); // supposed to be in px
    }
  };

  /**
   * Set the rotation and distance of the camera
   * @param {Object} pos   An object with the camera position. The object
   *             contains three parameters:
   *             - horizontal {Number}
   *             The horizontal rotation, between 0 and 2*PI.
   *             Optional, can be left undefined.
   *             - vertical {Number}
   *             The vertical rotation, between 0 and 0.5*PI
   *             if vertical=0.5*PI, the graph is shown from the
   *             top. Optional, can be left undefined.
   *             - distance {Number}
   *             The (normalized) distance of the camera to the
   *             center of the graph, a value between 0.71 and 5.0.
   *             Optional, can be left undefined.
   */
  Graph3d.prototype.setCameraPosition = function (pos) {
    if (pos === undefined) {
      return;
    }

    if (pos.horizontal !== undefined && pos.vertical !== undefined) {
      this.camera.setArmRotation(pos.horizontal, pos.vertical);
    }

    if (pos.distance !== undefined) {
      this.camera.setArmLength(pos.distance);
    }

    this.redraw();
  };

  /**
   * Retrieve the current camera rotation
   * @return {object}   An object with parameters horizontal, vertical, and
   *          distance
   */
  Graph3d.prototype.getCameraPosition = function () {
    var pos = this.camera.getArmRotation();
    pos.distance = this.camera.getArmLength();
    return pos;
  };

  /**
   * Load data into the 3D Graph
   */
  Graph3d.prototype._readData = function (data) {
    // read the data
    this._dataInitialize(data, this.style);

    if (this.dataFilter) {
      // apply filtering
      this.dataPoints = this.dataFilter._getDataPoints();
    } else {
      // no filtering. load all data
      this.dataPoints = this._getDataPoints(this.dataTable);
    }

    // draw the filter
    this._redrawFilter();
  };

  /**
   * Replace the dataset of the Graph3d
   * @param {Array | DataSet | DataView} data
   */
  Graph3d.prototype.setData = function (data) {
    this._readData(data);
    this.redraw();

    // start animation when option is true
    if (this.animationAutoStart && this.dataFilter) {
      this.animationStart();
    }
  };

  /**
   * Update the options. Options will be merged with current options
   * @param {Object} options
   */
  Graph3d.prototype.setOptions = function (options) {
    var cameraPosition = undefined;

    this.animationStop();

    if (options !== undefined) {
      // retrieve parameter values
      if (options.width !== undefined) this.width = options.width;
      if (options.height !== undefined) this.height = options.height;

      if (options.xCenter !== undefined) this.defaultXCenter = options.xCenter;
      if (options.yCenter !== undefined) this.defaultYCenter = options.yCenter;

      if (options.filterLabel !== undefined) this.filterLabel = options.filterLabel;
      if (options.legendLabel !== undefined) this.legendLabel = options.legendLabel;
      if (options.xLabel !== undefined) this.xLabel = options.xLabel;
      if (options.yLabel !== undefined) this.yLabel = options.yLabel;
      if (options.zLabel !== undefined) this.zLabel = options.zLabel;

      if (options.xValueLabel !== undefined) this.xValueLabel = options.xValueLabel;
      if (options.yValueLabel !== undefined) this.yValueLabel = options.yValueLabel;
      if (options.zValueLabel !== undefined) this.zValueLabel = options.zValueLabel;

      if (options.dotSizeRatio !== undefined) this.dotSizeRatio = options.dotSizeRatio;

      if (options.style !== undefined) {
        var styleNumber = this._getStyleNumber(options.style);
        if (styleNumber !== -1) {
          this.style = styleNumber;
        }
      }
      if (options.showGrid !== undefined) this.showGrid = options.showGrid;
      if (options.showPerspective !== undefined) this.showPerspective = options.showPerspective;
      if (options.showShadow !== undefined) this.showShadow = options.showShadow;
      if (options.tooltip !== undefined) this.showTooltip = options.tooltip;
      if (options.showAnimationControls !== undefined) this.showAnimationControls = options.showAnimationControls;
      if (options.keepAspectRatio !== undefined) this.keepAspectRatio = options.keepAspectRatio;
      if (options.verticalRatio !== undefined) this.verticalRatio = options.verticalRatio;

      if (options.animationInterval !== undefined) this.animationInterval = options.animationInterval;
      if (options.animationPreload !== undefined) this.animationPreload = options.animationPreload;
      if (options.animationAutoStart !== undefined) this.animationAutoStart = options.animationAutoStart;

      if (options.xBarWidth !== undefined) this.defaultXBarWidth = options.xBarWidth;
      if (options.yBarWidth !== undefined) this.defaultYBarWidth = options.yBarWidth;

      if (options.xMin !== undefined) this.defaultXMin = options.xMin;
      if (options.xStep !== undefined) this.defaultXStep = options.xStep;
      if (options.xMax !== undefined) this.defaultXMax = options.xMax;
      if (options.yMin !== undefined) this.defaultYMin = options.yMin;
      if (options.yStep !== undefined) this.defaultYStep = options.yStep;
      if (options.yMax !== undefined) this.defaultYMax = options.yMax;
      if (options.zMin !== undefined) this.defaultZMin = options.zMin;
      if (options.zStep !== undefined) this.defaultZStep = options.zStep;
      if (options.zMax !== undefined) this.defaultZMax = options.zMax;
      if (options.valueMin !== undefined) this.defaultValueMin = options.valueMin;
      if (options.valueMax !== undefined) this.defaultValueMax = options.valueMax;
      if (options.backgroundColor !== undefined) this._setBackgroundColor(options.backgroundColor);

      if (options.cameraPosition !== undefined) cameraPosition = options.cameraPosition;

      if (cameraPosition !== undefined) {
        this.camera.setArmRotation(cameraPosition.horizontal, cameraPosition.vertical);
        this.camera.setArmLength(cameraPosition.distance);
      }

      // colors
      if (options.axisColor !== undefined) this.axisColor = options.axisColor;
      if (options.gridColor !== undefined) this.gridColor = options.gridColor;
      if (options.dataColor) {
        if (typeof options.dataColor === 'string') {
          this.dataColor.fill = options.dataColor;
          this.dataColor.stroke = options.dataColor;
        } else {
          if (options.dataColor.fill) {
            this.dataColor.fill = options.dataColor.fill;
          }
          if (options.dataColor.stroke) {
            this.dataColor.stroke = options.dataColor.stroke;
          }
          if (options.dataColor.strokeWidth !== undefined) {
            this.dataColor.strokeWidth = options.dataColor.strokeWidth;
          }
        }
      }
    }

    this.setSize(this.width, this.height);

    // re-load the data
    if (this.dataTable) {
      this.setData(this.dataTable);
    }

    // start animation when option is true
    if (this.animationAutoStart && this.dataFilter) {
      this.animationStart();
    }
  };

  /**
   * Redraw the Graph.
   */
  Graph3d.prototype.redraw = function () {
    if (this.dataPoints === undefined) {
      throw 'Error: graph data not initialized';
    }

    this._resizeCanvas();
    this._resizeCenter();
    this._redrawSlider();
    this._redrawClear();
    this._redrawAxis();

    if (this.style === Graph3d.STYLE.GRID || this.style === Graph3d.STYLE.SURFACE) {
      this._redrawDataGrid();
    } else if (this.style === Graph3d.STYLE.LINE) {
      this._redrawDataLine();
    } else if (this.style === Graph3d.STYLE.BAR || this.style === Graph3d.STYLE.BARCOLOR || this.style === Graph3d.STYLE.BARSIZE) {
      this._redrawDataBar();
    } else {
      // style is DOT, DOTLINE, DOTCOLOR, DOTSIZE
      this._redrawDataDot();
    }

    this._redrawInfo();
    this._redrawLegend();
  };

  /**
   * Clear the canvas before redrawing
   */
  Graph3d.prototype._redrawClear = function () {
    var canvas = this.frame.canvas;
    var ctx = canvas.getContext('2d');

    ctx.clearRect(0, 0, canvas.width, canvas.height);
  };

  /**
   * Redraw the legend showing the colors
   */
  Graph3d.prototype._redrawLegend = function () {
    var y;

    if (this.style === Graph3d.STYLE.DOTCOLOR || this.style === Graph3d.STYLE.DOTSIZE) {

      var dotSize = this.frame.clientWidth * this.dotSizeRatio;

      var widthMin, widthMax;
      if (this.style === Graph3d.STYLE.DOTSIZE) {
        widthMin = dotSize / 2; // px
        widthMax = dotSize / 2 + dotSize * 2; // Todo: put this in one function
      } else {
          widthMin = 20; // px
          widthMax = 20; // px
        }

      var height = Math.max(this.frame.clientHeight * 0.25, 100);
      var top = this.margin;
      var right = this.frame.clientWidth - this.margin;
      var left = right - widthMax;
      var bottom = top + height;
    }

    var canvas = this.frame.canvas;
    var ctx = canvas.getContext('2d');
    ctx.lineWidth = 1;
    ctx.font = '14px arial'; // TODO: put in options

    if (this.style === Graph3d.STYLE.DOTCOLOR) {
      // draw the color bar
      var ymin = 0;
      var ymax = height; // Todo: make height customizable
      for (y = ymin; y < ymax; y++) {
        var f = (y - ymin) / (ymax - ymin);

        //var width = (dotSize / 2 + (1-f) * dotSize * 2); // Todo: put this in one function
        var hue = f * 240;
        var color = this._hsv2rgb(hue, 1, 1);

        ctx.strokeStyle = color;
        ctx.beginPath();
        ctx.moveTo(left, top + y);
        ctx.lineTo(right, top + y);
        ctx.stroke();
      }

      ctx.strokeStyle = this.axisColor;
      ctx.strokeRect(left, top, widthMax, height);
    }

    if (this.style === Graph3d.STYLE.DOTSIZE) {
      // draw border around color bar
      ctx.strokeStyle = this.axisColor;
      ctx.fillStyle = this.dataColor.fill;
      ctx.beginPath();
      ctx.moveTo(left, top);
      ctx.lineTo(right, top);
      ctx.lineTo(right - widthMax + widthMin, bottom);
      ctx.lineTo(left, bottom);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    }

    if (this.style === Graph3d.STYLE.DOTCOLOR || this.style === Graph3d.STYLE.DOTSIZE) {
      // print values along the color bar
      var gridLineLen = 5; // px
      var step = new StepNumber(this.valueMin, this.valueMax, (this.valueMax - this.valueMin) / 5, true);
      step.start();
      if (step.getCurrent() < this.valueMin) {
        step.next();
      }
      while (!step.end()) {
        y = bottom - (step.getCurrent() - this.valueMin) / (this.valueMax - this.valueMin) * height;

        ctx.beginPath();
        ctx.moveTo(left - gridLineLen, y);
        ctx.lineTo(left, y);
        ctx.stroke();

        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = this.axisColor;
        ctx.fillText(step.getCurrent(), left - 2 * gridLineLen, y);

        step.next();
      }

      ctx.textAlign = 'right';
      ctx.textBaseline = 'top';
      var label = this.legendLabel;
      ctx.fillText(label, right, bottom + this.margin);
    }
  };

  /**
   * Redraw the filter
   */
  Graph3d.prototype._redrawFilter = function () {
    this.frame.filter.innerHTML = '';

    if (this.dataFilter) {
      var options = {
        'visible': this.showAnimationControls
      };
      var slider = new Slider(this.frame.filter, options);
      this.frame.filter.slider = slider;

      // TODO: css here is not nice here...
      this.frame.filter.style.padding = '10px';
      //this.frame.filter.style.backgroundColor = '#EFEFEF';

      slider.setValues(this.dataFilter.values);
      slider.setPlayInterval(this.animationInterval);

      // create an event handler
      var me = this;
      var onchange = function onchange() {
        var index = slider.getIndex();

        me.dataFilter.selectValue(index);
        me.dataPoints = me.dataFilter._getDataPoints();

        me.redraw();
      };
      slider.setOnChangeCallback(onchange);
    } else {
      this.frame.filter.slider = undefined;
    }
  };

  /**
   * Redraw the slider
   */
  Graph3d.prototype._redrawSlider = function () {
    if (this.frame.filter.slider !== undefined) {
      this.frame.filter.slider.redraw();
    }
  };

  /**
   * Redraw common information
   */
  Graph3d.prototype._redrawInfo = function () {
    if (this.dataFilter) {
      var canvas = this.frame.canvas;
      var ctx = canvas.getContext('2d');

      ctx.font = '14px arial'; // TODO: put in options
      ctx.lineStyle = 'gray';
      ctx.fillStyle = 'gray';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';

      var x = this.margin;
      var y = this.margin;
      ctx.fillText(this.dataFilter.getLabel() + ': ' + this.dataFilter.getSelectedValue(), x, y);
    }
  };

  /**
   * Redraw the axis
   */
  Graph3d.prototype._redrawAxis = function () {
    var canvas = this.frame.canvas,
        ctx = canvas.getContext('2d'),
        from,
        to,
        step,
        prettyStep,
        text,
        xText,
        yText,
        zText,
        offset,
        xOffset,
        yOffset,
        xMin2d,
        xMax2d;

    // TODO: get the actual rendered style of the containerElement
    //ctx.font = this.containerElement.style.font;
    ctx.font = 24 / this.camera.getArmLength() + 'px arial';

    // calculate the length for the short grid lines
    var gridLenX = 0.025 / this.scale.x;
    var gridLenY = 0.025 / this.scale.y;
    var textMargin = 5 / this.camera.getArmLength(); // px
    var armAngle = this.camera.getArmRotation().horizontal;

    // draw x-grid lines
    ctx.lineWidth = 1;
    prettyStep = this.defaultXStep === undefined;
    step = new StepNumber(this.xMin, this.xMax, this.xStep, prettyStep);
    step.start();
    if (step.getCurrent() < this.xMin) {
      step.next();
    }
    while (!step.end()) {
      var x = step.getCurrent();

      if (this.showGrid) {
        from = this._convert3Dto2D(new Point3d(x, this.yMin, this.zMin));
        to = this._convert3Dto2D(new Point3d(x, this.yMax, this.zMin));
        ctx.strokeStyle = this.gridColor;
        ctx.beginPath();
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(to.x, to.y);
        ctx.stroke();
      } else {
        from = this._convert3Dto2D(new Point3d(x, this.yMin, this.zMin));
        to = this._convert3Dto2D(new Point3d(x, this.yMin + gridLenX, this.zMin));
        ctx.strokeStyle = this.axisColor;
        ctx.beginPath();
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(to.x, to.y);
        ctx.stroke();

        from = this._convert3Dto2D(new Point3d(x, this.yMax, this.zMin));
        to = this._convert3Dto2D(new Point3d(x, this.yMax - gridLenX, this.zMin));
        ctx.strokeStyle = this.axisColor;
        ctx.beginPath();
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(to.x, to.y);
        ctx.stroke();
      }

      yText = Math.cos(armAngle) > 0 ? this.yMin : this.yMax;
      text = this._convert3Dto2D(new Point3d(x, yText, this.zMin));
      if (Math.cos(armAngle * 2) > 0) {
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        text.y += textMargin;
      } else if (Math.sin(armAngle * 2) < 0) {
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
      } else {
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
      }
      ctx.fillStyle = this.axisColor;
      ctx.fillText('  ' + this.xValueLabel(step.getCurrent()) + '  ', text.x, text.y);

      step.next();
    }

    // draw y-grid lines
    ctx.lineWidth = 1;
    prettyStep = this.defaultYStep === undefined;
    step = new StepNumber(this.yMin, this.yMax, this.yStep, prettyStep);
    step.start();
    if (step.getCurrent() < this.yMin) {
      step.next();
    }
    while (!step.end()) {
      if (this.showGrid) {
        from = this._convert3Dto2D(new Point3d(this.xMin, step.getCurrent(), this.zMin));
        to = this._convert3Dto2D(new Point3d(this.xMax, step.getCurrent(), this.zMin));
        ctx.strokeStyle = this.gridColor;
        ctx.beginPath();
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(to.x, to.y);
        ctx.stroke();
      } else {
        from = this._convert3Dto2D(new Point3d(this.xMin, step.getCurrent(), this.zMin));
        to = this._convert3Dto2D(new Point3d(this.xMin + gridLenY, step.getCurrent(), this.zMin));
        ctx.strokeStyle = this.axisColor;
        ctx.beginPath();
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(to.x, to.y);
        ctx.stroke();

        from = this._convert3Dto2D(new Point3d(this.xMax, step.getCurrent(), this.zMin));
        to = this._convert3Dto2D(new Point3d(this.xMax - gridLenY, step.getCurrent(), this.zMin));
        ctx.strokeStyle = this.axisColor;
        ctx.beginPath();
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(to.x, to.y);
        ctx.stroke();
      }

      xText = Math.sin(armAngle) > 0 ? this.xMin : this.xMax;
      text = this._convert3Dto2D(new Point3d(xText, step.getCurrent(), this.zMin));
      if (Math.cos(armAngle * 2) < 0) {
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        text.y += textMargin;
      } else if (Math.sin(armAngle * 2) > 0) {
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
      } else {
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
      }
      ctx.fillStyle = this.axisColor;
      ctx.fillText('  ' + this.yValueLabel(step.getCurrent()) + '  ', text.x, text.y);

      step.next();
    }

    // draw z-grid lines and axis
    ctx.lineWidth = 1;
    prettyStep = this.defaultZStep === undefined;
    step = new StepNumber(this.zMin, this.zMax, this.zStep, prettyStep);
    step.start();
    if (step.getCurrent() < this.zMin) {
      step.next();
    }
    xText = Math.cos(armAngle) > 0 ? this.xMin : this.xMax;
    yText = Math.sin(armAngle) < 0 ? this.yMin : this.yMax;
    while (!step.end()) {
      // TODO: make z-grid lines really 3d?
      from = this._convert3Dto2D(new Point3d(xText, yText, step.getCurrent()));
      ctx.strokeStyle = this.axisColor;
      ctx.beginPath();
      ctx.moveTo(from.x, from.y);
      ctx.lineTo(from.x - textMargin, from.y);
      ctx.stroke();

      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = this.axisColor;
      ctx.fillText(this.zValueLabel(step.getCurrent()) + ' ', from.x - 5, from.y);

      step.next();
    }
    ctx.lineWidth = 1;
    from = this._convert3Dto2D(new Point3d(xText, yText, this.zMin));
    to = this._convert3Dto2D(new Point3d(xText, yText, this.zMax));
    ctx.strokeStyle = this.axisColor;
    ctx.beginPath();
    ctx.moveTo(from.x, from.y);
    ctx.lineTo(to.x, to.y);
    ctx.stroke();

    // draw x-axis
    ctx.lineWidth = 1;
    // line at yMin
    xMin2d = this._convert3Dto2D(new Point3d(this.xMin, this.yMin, this.zMin));
    xMax2d = this._convert3Dto2D(new Point3d(this.xMax, this.yMin, this.zMin));
    ctx.strokeStyle = this.axisColor;
    ctx.beginPath();
    ctx.moveTo(xMin2d.x, xMin2d.y);
    ctx.lineTo(xMax2d.x, xMax2d.y);
    ctx.stroke();
    // line at ymax
    xMin2d = this._convert3Dto2D(new Point3d(this.xMin, this.yMax, this.zMin));
    xMax2d = this._convert3Dto2D(new Point3d(this.xMax, this.yMax, this.zMin));
    ctx.strokeStyle = this.axisColor;
    ctx.beginPath();
    ctx.moveTo(xMin2d.x, xMin2d.y);
    ctx.lineTo(xMax2d.x, xMax2d.y);
    ctx.stroke();

    // draw y-axis
    ctx.lineWidth = 1;
    // line at xMin
    from = this._convert3Dto2D(new Point3d(this.xMin, this.yMin, this.zMin));
    to = this._convert3Dto2D(new Point3d(this.xMin, this.yMax, this.zMin));
    ctx.strokeStyle = this.axisColor;
    ctx.beginPath();
    ctx.moveTo(from.x, from.y);
    ctx.lineTo(to.x, to.y);
    ctx.stroke();
    // line at xMax
    from = this._convert3Dto2D(new Point3d(this.xMax, this.yMin, this.zMin));
    to = this._convert3Dto2D(new Point3d(this.xMax, this.yMax, this.zMin));
    ctx.strokeStyle = this.axisColor;
    ctx.beginPath();
    ctx.moveTo(from.x, from.y);
    ctx.lineTo(to.x, to.y);
    ctx.stroke();

    // draw x-label
    var xLabel = this.xLabel;
    if (xLabel.length > 0) {
      yOffset = 0.1 / this.scale.y;
      xText = (this.xMin + this.xMax) / 2;
      yText = Math.cos(armAngle) > 0 ? this.yMin - yOffset : this.yMax + yOffset;
      text = this._convert3Dto2D(new Point3d(xText, yText, this.zMin));
      if (Math.cos(armAngle * 2) > 0) {
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
      } else if (Math.sin(armAngle * 2) < 0) {
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
      } else {
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
      }
      ctx.fillStyle = this.axisColor;
      ctx.fillText(xLabel, text.x, text.y);
    }

    // draw y-label
    var yLabel = this.yLabel;
    if (yLabel.length > 0) {
      xOffset = 0.1 / this.scale.x;
      xText = Math.sin(armAngle) > 0 ? this.xMin - xOffset : this.xMax + xOffset;
      yText = (this.yMin + this.yMax) / 2;
      text = this._convert3Dto2D(new Point3d(xText, yText, this.zMin));
      if (Math.cos(armAngle * 2) < 0) {
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
      } else if (Math.sin(armAngle * 2) > 0) {
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
      } else {
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
      }
      ctx.fillStyle = this.axisColor;
      ctx.fillText(yLabel, text.x, text.y);
    }

    // draw z-label
    var zLabel = this.zLabel;
    if (zLabel.length > 0) {
      offset = 30; // pixels.  // TODO: relate to the max width of the values on the z axis?
      xText = Math.cos(armAngle) > 0 ? this.xMin : this.xMax;
      yText = Math.sin(armAngle) < 0 ? this.yMin : this.yMax;
      zText = (this.zMin + this.zMax) / 2;
      text = this._convert3Dto2D(new Point3d(xText, yText, zText));
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = this.axisColor;
      ctx.fillText(zLabel, text.x - offset, text.y);
    }
  };

  /**
   * Calculate the color based on the given value.
   * @param {Number} H   Hue, a value be between 0 and 360
   * @param {Number} S   Saturation, a value between 0 and 1
   * @param {Number} V   Value, a value between 0 and 1
   */
  Graph3d.prototype._hsv2rgb = function (H, S, V) {
    var R, G, B, C, Hi, X;

    C = V * S;
    Hi = Math.floor(H / 60); // hi = 0,1,2,3,4,5
    X = C * (1 - Math.abs(H / 60 % 2 - 1));

    switch (Hi) {
      case 0:
        R = C;G = X;B = 0;break;
      case 1:
        R = X;G = C;B = 0;break;
      case 2:
        R = 0;G = C;B = X;break;
      case 3:
        R = 0;G = X;B = C;break;
      case 4:
        R = X;G = 0;B = C;break;
      case 5:
        R = C;G = 0;B = X;break;

      default:
        R = 0;G = 0;B = 0;break;
    }

    return 'RGB(' + parseInt(R * 255) + ',' + parseInt(G * 255) + ',' + parseInt(B * 255) + ')';
  };

  /**
   * Draw all datapoints as a grid
   * This function can be used when the style is 'grid'
   */
  Graph3d.prototype._redrawDataGrid = function () {
    var canvas = this.frame.canvas,
        ctx = canvas.getContext('2d'),
        point,
        right,
        top,
        cross,
        i,
        topSideVisible,
        fillStyle,
        strokeStyle,
        lineWidth,
        h,
        s,
        v,
        zAvg;

    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';

    if (this.dataPoints === undefined || this.dataPoints.length <= 0) return; // TODO: throw exception?

    // calculate the translations and screen position of all points
    for (i = 0; i < this.dataPoints.length; i++) {
      var trans = this._convertPointToTranslation(this.dataPoints[i].point);
      var screen = this._convertTranslationToScreen(trans);

      this.dataPoints[i].trans = trans;
      this.dataPoints[i].screen = screen;

      // calculate the translation of the point at the bottom (needed for sorting)
      var transBottom = this._convertPointToTranslation(this.dataPoints[i].bottom);
      this.dataPoints[i].dist = this.showPerspective ? transBottom.length() : -transBottom.z;
    }

    // sort the points on depth of their (x,y) position (not on z)
    var sortDepth = function sortDepth(a, b) {
      return b.dist - a.dist;
    };
    this.dataPoints.sort(sortDepth);

    if (this.style === Graph3d.STYLE.SURFACE) {
      for (i = 0; i < this.dataPoints.length; i++) {
        point = this.dataPoints[i];
        right = this.dataPoints[i].pointRight;
        top = this.dataPoints[i].pointTop;
        cross = this.dataPoints[i].pointCross;

        if (point !== undefined && right !== undefined && top !== undefined && cross !== undefined) {

          if (this.showGrayBottom || this.showShadow) {
            // calculate the cross product of the two vectors from center
            // to left and right, in order to know whether we are looking at the
            // bottom or at the top side. We can also use the cross product
            // for calculating light intensity
            var aDiff = Point3d.subtract(cross.trans, point.trans);
            var bDiff = Point3d.subtract(top.trans, right.trans);
            var crossproduct = Point3d.crossProduct(aDiff, bDiff);
            var len = crossproduct.length();
            // FIXME: there is a bug with determining the surface side (shadow or colored)

            topSideVisible = crossproduct.z > 0;
          } else {
            topSideVisible = true;
          }

          if (topSideVisible) {
            // calculate Hue from the current value. At zMin the hue is 240, at zMax the hue is 0
            zAvg = (point.point.z + right.point.z + top.point.z + cross.point.z) / 4;
            h = (1 - (zAvg - this.zMin) * this.scale.z / this.verticalRatio) * 240;
            s = 1; // saturation

            if (this.showShadow) {
              v = Math.min(1 + crossproduct.x / len / 2, 1); // value. TODO: scale
              fillStyle = this._hsv2rgb(h, s, v);
              strokeStyle = fillStyle;
            } else {
              v = 1;
              fillStyle = this._hsv2rgb(h, s, v);
              strokeStyle = this.axisColor; // TODO: should be customizable
            }
          } else {
              fillStyle = 'gray';
              strokeStyle = this.axisColor;
            }

          ctx.lineWidth = this._getStrokeWidth(point);
          ctx.fillStyle = fillStyle;
          ctx.strokeStyle = strokeStyle;
          ctx.beginPath();
          ctx.moveTo(point.screen.x, point.screen.y);
          ctx.lineTo(right.screen.x, right.screen.y);
          ctx.lineTo(cross.screen.x, cross.screen.y);
          ctx.lineTo(top.screen.x, top.screen.y);
          ctx.closePath();
          ctx.fill();
          ctx.stroke(); // TODO: only draw stroke when strokeWidth > 0
        }
      }
    } else {
        // grid style
        for (i = 0; i < this.dataPoints.length; i++) {
          point = this.dataPoints[i];
          right = this.dataPoints[i].pointRight;
          top = this.dataPoints[i].pointTop;

          if (point !== undefined && right !== undefined) {
            // calculate Hue from the current value. At zMin the hue is 240, at zMax the hue is 0
            zAvg = (point.point.z + right.point.z) / 2;
            h = (1 - (zAvg - this.zMin) * this.scale.z / this.verticalRatio) * 240;

            ctx.lineWidth = this._getStrokeWidth(point) * 2;
            ctx.strokeStyle = this._hsv2rgb(h, 1, 1);
            ctx.beginPath();
            ctx.moveTo(point.screen.x, point.screen.y);
            ctx.lineTo(right.screen.x, right.screen.y);
            ctx.stroke();
          }

          if (point !== undefined && top !== undefined) {
            // calculate Hue from the current value. At zMin the hue is 240, at zMax the hue is 0
            zAvg = (point.point.z + top.point.z) / 2;
            h = (1 - (zAvg - this.zMin) * this.scale.z / this.verticalRatio) * 240;

            ctx.lineWidth = this._getStrokeWidth(point) * 2;
            ctx.strokeStyle = this._hsv2rgb(h, 1, 1);
            ctx.beginPath();
            ctx.moveTo(point.screen.x, point.screen.y);
            ctx.lineTo(top.screen.x, top.screen.y);
            ctx.stroke();
          }
        }
      }
  };

  Graph3d.prototype._getStrokeWidth = function (point) {
    if (point !== undefined) {
      if (this.showPerspective) {
        return 1 / -point.trans.z * this.dataColor.strokeWidth;
      } else {
        return -(this.eye.z / this.camera.getArmLength()) * this.dataColor.strokeWidth;
      }
    }

    return this.dataColor.strokeWidth;
  };

  /**
   * Draw all datapoints as dots.
   * This function can be used when the style is 'dot' or 'dot-line'
   */
  Graph3d.prototype._redrawDataDot = function () {
    var canvas = this.frame.canvas;
    var ctx = canvas.getContext('2d');
    var i;

    if (this.dataPoints === undefined || this.dataPoints.length <= 0) return; // TODO: throw exception?

    // calculate the translations of all points
    for (i = 0; i < this.dataPoints.length; i++) {
      var trans = this._convertPointToTranslation(this.dataPoints[i].point);
      var screen = this._convertTranslationToScreen(trans);
      this.dataPoints[i].trans = trans;
      this.dataPoints[i].screen = screen;

      // calculate the distance from the point at the bottom to the camera
      var transBottom = this._convertPointToTranslation(this.dataPoints[i].bottom);
      this.dataPoints[i].dist = this.showPerspective ? transBottom.length() : -transBottom.z;
    }

    // order the translated points by depth
    var sortDepth = function sortDepth(a, b) {
      return b.dist - a.dist;
    };
    this.dataPoints.sort(sortDepth);

    // draw the datapoints as colored circles
    var dotSize = this.frame.clientWidth * this.dotSizeRatio; // px
    for (i = 0; i < this.dataPoints.length; i++) {
      var point = this.dataPoints[i];

      if (this.style === Graph3d.STYLE.DOTLINE) {
        // draw a vertical line from the bottom to the graph value
        //var from = this._convert3Dto2D(new Point3d(point.point.x, point.point.y, this.zMin));
        var from = this._convert3Dto2D(point.bottom);
        ctx.lineWidth = 1;
        ctx.strokeStyle = this.gridColor;
        ctx.beginPath();
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(point.screen.x, point.screen.y);
        ctx.stroke();
      }

      // calculate radius for the circle
      var size;
      if (this.style === Graph3d.STYLE.DOTSIZE) {
        size = dotSize / 2 + 2 * dotSize * (point.point.value - this.valueMin) / (this.valueMax - this.valueMin);
      } else {
        size = dotSize;
      }

      var radius;
      if (this.showPerspective) {
        radius = size / -point.trans.z;
      } else {
        radius = size * -(this.eye.z / this.camera.getArmLength());
      }
      if (radius < 0) {
        radius = 0;
      }

      var hue, color, borderColor;
      if (this.style === Graph3d.STYLE.DOTCOLOR) {
        // calculate the color based on the value
        hue = (1 - (point.point.value - this.valueMin) * this.scale.value) * 240;
        color = this._hsv2rgb(hue, 1, 1);
        borderColor = this._hsv2rgb(hue, 1, 0.8);
      } else if (this.style === Graph3d.STYLE.DOTSIZE) {
        color = this.dataColor.fill;
        borderColor = this.dataColor.stroke;
      } else {
        // calculate Hue from the current value. At zMin the hue is 240, at zMax the hue is 0
        hue = (1 - (point.point.z - this.zMin) * this.scale.z / this.verticalRatio) * 240;
        color = this._hsv2rgb(hue, 1, 1);
        borderColor = this._hsv2rgb(hue, 1, 0.8);
      }

      // draw the circle
      ctx.lineWidth = this._getStrokeWidth(point);
      ctx.strokeStyle = borderColor;
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(point.screen.x, point.screen.y, radius, 0, Math.PI * 2, true);
      ctx.fill();
      ctx.stroke();
    }
  };

  /**
   * Draw all datapoints as bars.
   * This function can be used when the style is 'bar', 'bar-color', or 'bar-size'
   */
  Graph3d.prototype._redrawDataBar = function () {
    var canvas = this.frame.canvas;
    var ctx = canvas.getContext('2d');
    var i, j, surface, corners;

    if (this.dataPoints === undefined || this.dataPoints.length <= 0) return; // TODO: throw exception?

    // calculate the translations of all points
    for (i = 0; i < this.dataPoints.length; i++) {
      var trans = this._convertPointToTranslation(this.dataPoints[i].point);
      var screen = this._convertTranslationToScreen(trans);
      this.dataPoints[i].trans = trans;
      this.dataPoints[i].screen = screen;

      // calculate the distance from the point at the bottom to the camera
      var transBottom = this._convertPointToTranslation(this.dataPoints[i].bottom);
      this.dataPoints[i].dist = this.showPerspective ? transBottom.length() : -transBottom.z;
    }

    // order the translated points by depth
    var sortDepth = function sortDepth(a, b) {
      return b.dist - a.dist;
    };
    this.dataPoints.sort(sortDepth);

    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';

    // draw the datapoints as bars
    var xWidth = this.xBarWidth / 2;
    var yWidth = this.yBarWidth / 2;
    for (i = 0; i < this.dataPoints.length; i++) {
      var point = this.dataPoints[i];

      // determine color
      var hue, color, borderColor;
      if (this.style === Graph3d.STYLE.BARCOLOR) {
        // calculate the color based on the value
        hue = (1 - (point.point.value - this.valueMin) * this.scale.value) * 240;
        color = this._hsv2rgb(hue, 1, 1);
        borderColor = this._hsv2rgb(hue, 1, 0.8);
      } else if (this.style === Graph3d.STYLE.BARSIZE) {
        color = this.dataColor.fill;
        borderColor = this.dataColor.stroke;
      } else {
        // calculate Hue from the current value. At zMin the hue is 240, at zMax the hue is 0
        hue = (1 - (point.point.z - this.zMin) * this.scale.z / this.verticalRatio) * 240;
        color = this._hsv2rgb(hue, 1, 1);
        borderColor = this._hsv2rgb(hue, 1, 0.8);
      }

      // calculate size for the bar
      if (this.style === Graph3d.STYLE.BARSIZE) {
        xWidth = this.xBarWidth / 2 * ((point.point.value - this.valueMin) / (this.valueMax - this.valueMin) * 0.8 + 0.2);
        yWidth = this.yBarWidth / 2 * ((point.point.value - this.valueMin) / (this.valueMax - this.valueMin) * 0.8 + 0.2);
      }

      // calculate all corner points
      var me = this;
      var point3d = point.point;
      var top = [{ point: new Point3d(point3d.x - xWidth, point3d.y - yWidth, point3d.z) }, { point: new Point3d(point3d.x + xWidth, point3d.y - yWidth, point3d.z) }, { point: new Point3d(point3d.x + xWidth, point3d.y + yWidth, point3d.z) }, { point: new Point3d(point3d.x - xWidth, point3d.y + yWidth, point3d.z) }];
      var bottom = [{ point: new Point3d(point3d.x - xWidth, point3d.y - yWidth, this.zMin) }, { point: new Point3d(point3d.x + xWidth, point3d.y - yWidth, this.zMin) }, { point: new Point3d(point3d.x + xWidth, point3d.y + yWidth, this.zMin) }, { point: new Point3d(point3d.x - xWidth, point3d.y + yWidth, this.zMin) }];

      // calculate screen location of the points
      top.forEach(function (obj) {
        obj.screen = me._convert3Dto2D(obj.point);
      });
      bottom.forEach(function (obj) {
        obj.screen = me._convert3Dto2D(obj.point);
      });

      // create five sides, calculate both corner points and center points
      var surfaces = [{ corners: top, center: Point3d.avg(bottom[0].point, bottom[2].point) }, { corners: [top[0], top[1], bottom[1], bottom[0]], center: Point3d.avg(bottom[1].point, bottom[0].point) }, { corners: [top[1], top[2], bottom[2], bottom[1]], center: Point3d.avg(bottom[2].point, bottom[1].point) }, { corners: [top[2], top[3], bottom[3], bottom[2]], center: Point3d.avg(bottom[3].point, bottom[2].point) }, { corners: [top[3], top[0], bottom[0], bottom[3]], center: Point3d.avg(bottom[0].point, bottom[3].point) }];
      point.surfaces = surfaces;

      // calculate the distance of each of the surface centers to the camera
      for (j = 0; j < surfaces.length; j++) {
        surface = surfaces[j];
        var transCenter = this._convertPointToTranslation(surface.center);
        surface.dist = this.showPerspective ? transCenter.length() : -transCenter.z;
        // TODO: this dept calculation doesn't work 100% of the cases due to perspective,
        //     but the current solution is fast/simple and works in 99.9% of all cases
        //     the issue is visible in example 14, with graph.setCameraPosition({horizontal: 2.97, vertical: 0.5, distance: 0.9})
      }

      // order the surfaces by their (translated) depth
      surfaces.sort(function (a, b) {
        var diff = b.dist - a.dist;
        if (diff) return diff;

        // if equal depth, sort the top surface last
        if (a.corners === top) return 1;
        if (b.corners === top) return -1;

        // both are equal
        return 0;
      });

      // draw the ordered surfaces
      ctx.lineWidth = this._getStrokeWidth(point);
      ctx.strokeStyle = borderColor;
      ctx.fillStyle = color;
      // NOTE: we start at j=2 instead of j=0 as we don't need to draw the two surfaces at the backside
      for (j = 2; j < surfaces.length; j++) {
        surface = surfaces[j];
        corners = surface.corners;
        ctx.beginPath();
        ctx.moveTo(corners[3].screen.x, corners[3].screen.y);
        ctx.lineTo(corners[0].screen.x, corners[0].screen.y);
        ctx.lineTo(corners[1].screen.x, corners[1].screen.y);
        ctx.lineTo(corners[2].screen.x, corners[2].screen.y);
        ctx.lineTo(corners[3].screen.x, corners[3].screen.y);
        ctx.fill();
        ctx.stroke();
      }
    }
  };

  /**
   * Draw a line through all datapoints.
   * This function can be used when the style is 'line'
   */
  Graph3d.prototype._redrawDataLine = function () {
    var canvas = this.frame.canvas,
        ctx = canvas.getContext('2d'),
        point,
        i;

    if (this.dataPoints === undefined || this.dataPoints.length <= 0) return; // TODO: throw exception?

    // calculate the translations of all points
    for (i = 0; i < this.dataPoints.length; i++) {
      var trans = this._convertPointToTranslation(this.dataPoints[i].point);
      var screen = this._convertTranslationToScreen(trans);

      this.dataPoints[i].trans = trans;
      this.dataPoints[i].screen = screen;
    }

    // start the line
    if (this.dataPoints.length > 0) {
      point = this.dataPoints[0];

      ctx.lineWidth = this._getStrokeWidth(point);
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      ctx.strokeStyle = this.dataColor.stroke;
      ctx.beginPath();
      ctx.moveTo(point.screen.x, point.screen.y);

      // draw the datapoints as colored circles
      for (i = 1; i < this.dataPoints.length; i++) {
        point = this.dataPoints[i];
        ctx.lineTo(point.screen.x, point.screen.y);
      }

      // finish the line
      ctx.stroke();
    }
  };

  /**
   * Start a moving operation inside the provided parent element
   * @param {Event}     event     The event that occurred (required for
   *                  retrieving the  mouse position)
   */
  Graph3d.prototype._onMouseDown = function (event) {
    event = event || window.event;

    // check if mouse is still down (may be up when focus is lost for example
    // in an iframe)
    if (this.leftButtonDown) {
      this._onMouseUp(event);
    }

    // only react on left mouse button down
    this.leftButtonDown = event.which ? event.which === 1 : event.button === 1;
    if (!this.leftButtonDown && !this.touchDown) return;

    // get mouse position (different code for IE and all other browsers)
    this.startMouseX = getMouseX(event);
    this.startMouseY = getMouseY(event);

    this.startStart = new Date(this.start);
    this.startEnd = new Date(this.end);
    this.startArmRotation = this.camera.getArmRotation();

    this.frame.style.cursor = 'move';

    // add event listeners to handle moving the contents
    // we store the function onmousemove and onmouseup in the graph, so we can
    // remove the eventlisteners lateron in the function mouseUp()
    var me = this;
    this.onmousemove = function (event) {
      me._onMouseMove(event);
    };
    this.onmouseup = function (event) {
      me._onMouseUp(event);
    };
    util.addEventListener(document, 'mousemove', me.onmousemove);
    util.addEventListener(document, 'mouseup', me.onmouseup);
    util.preventDefault(event);
  };

  /**
   * Perform moving operating.
   * This function activated from within the funcion Graph.mouseDown().
   * @param {Event}   event  Well, eehh, the event
   */
  Graph3d.prototype._onMouseMove = function (event) {
    event = event || window.event;

    // calculate change in mouse position
    var diffX = parseFloat(getMouseX(event)) - this.startMouseX;
    var diffY = parseFloat(getMouseY(event)) - this.startMouseY;

    var horizontalNew = this.startArmRotation.horizontal + diffX / 200;
    var verticalNew = this.startArmRotation.vertical + diffY / 200;

    var snapAngle = 4; // degrees
    var snapValue = Math.sin(snapAngle / 360 * 2 * Math.PI);

    // snap horizontally to nice angles at 0pi, 0.5pi, 1pi, 1.5pi, etc...
    // the -0.001 is to take care that the vertical axis is always drawn at the left front corner
    if (Math.abs(Math.sin(horizontalNew)) < snapValue) {
      horizontalNew = Math.round(horizontalNew / Math.PI) * Math.PI - 0.001;
    }
    if (Math.abs(Math.cos(horizontalNew)) < snapValue) {
      horizontalNew = (Math.round(horizontalNew / Math.PI - 0.5) + 0.5) * Math.PI - 0.001;
    }

    // snap vertically to nice angles
    if (Math.abs(Math.sin(verticalNew)) < snapValue) {
      verticalNew = Math.round(verticalNew / Math.PI) * Math.PI;
    }
    if (Math.abs(Math.cos(verticalNew)) < snapValue) {
      verticalNew = (Math.round(verticalNew / Math.PI - 0.5) + 0.5) * Math.PI;
    }

    this.camera.setArmRotation(horizontalNew, verticalNew);
    this.redraw();

    // fire a cameraPositionChange event
    var parameters = this.getCameraPosition();
    this.emit('cameraPositionChange', parameters);

    util.preventDefault(event);
  };

  /**
   * Stop moving operating.
   * This function activated from within the funcion Graph.mouseDown().
   * @param {event}  event   The event
   */
  Graph3d.prototype._onMouseUp = function (event) {
    this.frame.style.cursor = 'auto';
    this.leftButtonDown = false;

    // remove event listeners here
    util.removeEventListener(document, 'mousemove', this.onmousemove);
    util.removeEventListener(document, 'mouseup', this.onmouseup);
    util.preventDefault(event);
  };

  /**
   * After having moved the mouse, a tooltip should pop up when the mouse is resting on a data point
   * @param {Event}  event   A mouse move event
   */
  Graph3d.prototype._onTooltip = function (event) {
    var delay = 300; // ms
    var boundingRect = this.frame.getBoundingClientRect();
    var mouseX = getMouseX(event) - boundingRect.left;
    var mouseY = getMouseY(event) - boundingRect.top;

    if (!this.showTooltip) {
      return;
    }

    if (this.tooltipTimeout) {
      clearTimeout(this.tooltipTimeout);
    }

    // (delayed) display of a tooltip only if no mouse button is down
    if (this.leftButtonDown) {
      this._hideTooltip();
      return;
    }

    if (this.tooltip && this.tooltip.dataPoint) {
      // tooltip is currently visible
      var dataPoint = this._dataPointFromXY(mouseX, mouseY);
      if (dataPoint !== this.tooltip.dataPoint) {
        // datapoint changed
        if (dataPoint) {
          this._showTooltip(dataPoint);
        } else {
          this._hideTooltip();
        }
      }
    } else {
      // tooltip is currently not visible
      var me = this;
      this.tooltipTimeout = setTimeout(function () {
        me.tooltipTimeout = null;

        // show a tooltip if we have a data point
        var dataPoint = me._dataPointFromXY(mouseX, mouseY);
        if (dataPoint) {
          me._showTooltip(dataPoint);
        }
      }, delay);
    }
  };

  /**
   * Event handler for touchstart event on mobile devices
   */
  Graph3d.prototype._onTouchStart = function (event) {
    this.touchDown = true;

    var me = this;
    this.ontouchmove = function (event) {
      me._onTouchMove(event);
    };
    this.ontouchend = function (event) {
      me._onTouchEnd(event);
    };
    util.addEventListener(document, 'touchmove', me.ontouchmove);
    util.addEventListener(document, 'touchend', me.ontouchend);

    this._onMouseDown(event);
  };

  /**
   * Event handler for touchmove event on mobile devices
   */
  Graph3d.prototype._onTouchMove = function (event) {
    this._onMouseMove(event);
  };

  /**
   * Event handler for touchend event on mobile devices
   */
  Graph3d.prototype._onTouchEnd = function (event) {
    this.touchDown = false;

    util.removeEventListener(document, 'touchmove', this.ontouchmove);
    util.removeEventListener(document, 'touchend', this.ontouchend);

    this._onMouseUp(event);
  };

  /**
   * Event handler for mouse wheel event, used to zoom the graph
   * Code from http://adomas.org/javascript-mouse-wheel/
   * @param {event}  event   The event
   */
  Graph3d.prototype._onWheel = function (event) {
    if (!event) /* For IE. */
      event = window.event;

    // retrieve delta
    var delta = 0;
    if (event.wheelDelta) {
      /* IE/Opera. */
      delta = event.wheelDelta / 120;
    } else if (event.detail) {
      /* Mozilla case. */
      // In Mozilla, sign of delta is different than in IE.
      // Also, delta is multiple of 3.
      delta = -event.detail / 3;
    }

    // If delta is nonzero, handle it.
    // Basically, delta is now positive if wheel was scrolled up,
    // and negative, if wheel was scrolled down.
    if (delta) {
      var oldLength = this.camera.getArmLength();
      var newLength = oldLength * (1 - delta / 10);

      this.camera.setArmLength(newLength);
      this.redraw();

      this._hideTooltip();
    }

    // fire a cameraPositionChange event
    var parameters = this.getCameraPosition();
    this.emit('cameraPositionChange', parameters);

    // Prevent default actions caused by mouse wheel.
    // That might be ugly, but we handle scrolls somehow
    // anyway, so don't bother here..
    util.preventDefault(event);
  };

  /**
   * Test whether a point lies inside given 2D triangle
   * @param {Point2d} point
   * @param {Point2d[]} triangle
   * @return {boolean} Returns true if given point lies inside or on the edge of the triangle
   * @private
   */
  Graph3d.prototype._insideTriangle = function (point, triangle) {
    var a = triangle[0],
        b = triangle[1],
        c = triangle[2];

    function sign(x) {
      return x > 0 ? 1 : x < 0 ? -1 : 0;
    }

    var as = sign((b.x - a.x) * (point.y - a.y) - (b.y - a.y) * (point.x - a.x));
    var bs = sign((c.x - b.x) * (point.y - b.y) - (c.y - b.y) * (point.x - b.x));
    var cs = sign((a.x - c.x) * (point.y - c.y) - (a.y - c.y) * (point.x - c.x));

    // each of the three signs must be either equal to each other or zero
    return (as == 0 || bs == 0 || as == bs) && (bs == 0 || cs == 0 || bs == cs) && (as == 0 || cs == 0 || as == cs);
  };

  /**
   * Find a data point close to given screen position (x, y)
   * @param {Number} x
   * @param {Number} y
   * @return {Object | null} The closest data point or null if not close to any data point
   * @private
   */
  Graph3d.prototype._dataPointFromXY = function (x, y) {
    var i,
        distMax = 100,
        // px
    dataPoint = null,
        closestDataPoint = null,
        closestDist = null,
        center = new Point2d(x, y);

    if (this.style === Graph3d.STYLE.BAR || this.style === Graph3d.STYLE.BARCOLOR || this.style === Graph3d.STYLE.BARSIZE) {
      // the data points are ordered from far away to closest
      for (i = this.dataPoints.length - 1; i >= 0; i--) {
        dataPoint = this.dataPoints[i];
        var surfaces = dataPoint.surfaces;
        if (surfaces) {
          for (var s = surfaces.length - 1; s >= 0; s--) {
            // split each surface in two triangles, and see if the center point is inside one of these
            var surface = surfaces[s];
            var corners = surface.corners;
            var triangle1 = [corners[0].screen, corners[1].screen, corners[2].screen];
            var triangle2 = [corners[2].screen, corners[3].screen, corners[0].screen];
            if (this._insideTriangle(center, triangle1) || this._insideTriangle(center, triangle2)) {
              // return immediately at the first hit
              return dataPoint;
            }
          }
        }
      }
    } else {
      // find the closest data point, using distance to the center of the point on 2d screen
      for (i = 0; i < this.dataPoints.length; i++) {
        dataPoint = this.dataPoints[i];
        var point = dataPoint.screen;
        if (point) {
          var distX = Math.abs(x - point.x);
          var distY = Math.abs(y - point.y);
          var dist = Math.sqrt(distX * distX + distY * distY);

          if ((closestDist === null || dist < closestDist) && dist < distMax) {
            closestDist = dist;
            closestDataPoint = dataPoint;
          }
        }
      }
    }

    return closestDataPoint;
  };

  /**
   * Display a tooltip for given data point
   * @param {Object} dataPoint
   * @private
   */
  Graph3d.prototype._showTooltip = function (dataPoint) {
    var content, line, dot;

    if (!this.tooltip) {
      content = document.createElement('div');
      content.style.position = 'absolute';
      content.style.padding = '10px';
      content.style.border = '1px solid #4d4d4d';
      content.style.color = '#1a1a1a';
      content.style.background = 'rgba(255,255,255,0.7)';
      content.style.borderRadius = '2px';
      content.style.boxShadow = '5px 5px 10px rgba(128,128,128,0.5)';

      line = document.createElement('div');
      line.style.position = 'absolute';
      line.style.height = '40px';
      line.style.width = '0';
      line.style.borderLeft = '1px solid #4d4d4d';

      dot = document.createElement('div');
      dot.style.position = 'absolute';
      dot.style.height = '0';
      dot.style.width = '0';
      dot.style.border = '5px solid #4d4d4d';
      dot.style.borderRadius = '5px';

      this.tooltip = {
        dataPoint: null,
        dom: {
          content: content,
          line: line,
          dot: dot
        }
      };
    } else {
      content = this.tooltip.dom.content;
      line = this.tooltip.dom.line;
      dot = this.tooltip.dom.dot;
    }

    this._hideTooltip();

    this.tooltip.dataPoint = dataPoint;
    if (typeof this.showTooltip === 'function') {
      content.innerHTML = this.showTooltip(dataPoint.point);
    } else {
      content.innerHTML = '<table>' + '<tr><td>' + this.xLabel + ':</td><td>' + dataPoint.point.x + '</td></tr>' + '<tr><td>' + this.yLabel + ':</td><td>' + dataPoint.point.y + '</td></tr>' + '<tr><td>' + this.zLabel + ':</td><td>' + dataPoint.point.z + '</td></tr>' + '</table>';
    }

    content.style.left = '0';
    content.style.top = '0';
    this.frame.appendChild(content);
    this.frame.appendChild(line);
    this.frame.appendChild(dot);

    // calculate sizes
    var contentWidth = content.offsetWidth;
    var contentHeight = content.offsetHeight;
    var lineHeight = line.offsetHeight;
    var dotWidth = dot.offsetWidth;
    var dotHeight = dot.offsetHeight;

    var left = dataPoint.screen.x - contentWidth / 2;
    left = Math.min(Math.max(left, 10), this.frame.clientWidth - 10 - contentWidth);

    line.style.left = dataPoint.screen.x + 'px';
    line.style.top = dataPoint.screen.y - lineHeight + 'px';
    content.style.left = left + 'px';
    content.style.top = dataPoint.screen.y - lineHeight - contentHeight + 'px';
    dot.style.left = dataPoint.screen.x - dotWidth / 2 + 'px';
    dot.style.top = dataPoint.screen.y - dotHeight / 2 + 'px';
  };

  /**
   * Hide the tooltip when displayed
   * @private
   */
  Graph3d.prototype._hideTooltip = function () {
    if (this.tooltip) {
      this.tooltip.dataPoint = null;

      for (var prop in this.tooltip.dom) {
        if (this.tooltip.dom.hasOwnProperty(prop)) {
          var elem = this.tooltip.dom[prop];
          if (elem && elem.parentNode) {
            elem.parentNode.removeChild(elem);
          }
        }
      }
    }
  };

  /**--------------------------------------------------------------------------**/

  /**
   * Get the horizontal mouse position from a mouse event
   * @param {Event} event
   * @return {Number} mouse x
   */
  function getMouseX(event) {
    if ('clientX' in event) return event.clientX;
    return event.targetTouches[0] && event.targetTouches[0].clientX || 0;
  }

  /**
   * Get the vertical mouse position from a mouse event
   * @param {Event} event
   * @return {Number} mouse y
   */
  function getMouseY(event) {
    if ('clientY' in event) return event.clientY;
    return event.targetTouches[0] && event.targetTouches[0].clientY || 0;
  }

  module.exports = Graph3d;

/***/ },
/* 13 */
/***/ function(module, exports) {

  
  /**
   * Expose `Emitter`.
   */

  module.exports = Emitter;

  /**
   * Initialize a new `Emitter`.
   *
   * @api public
   */

  function Emitter(obj) {
    if (obj) return mixin(obj);
  };

  /**
   * Mixin the emitter properties.
   *
   * @param {Object} obj
   * @return {Object}
   * @api private
   */

  function mixin(obj) {
    for (var key in Emitter.prototype) {
      obj[key] = Emitter.prototype[key];
    }
    return obj;
  }

  /**
   * Listen on the given `event` with `fn`.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */

  Emitter.prototype.on =
  Emitter.prototype.addEventListener = function(event, fn){
    this._callbacks = this._callbacks || {};
    (this._callbacks[event] = this._callbacks[event] || [])
      .push(fn);
    return this;
  };

  /**
   * Adds an `event` listener that will be invoked a single
   * time then automatically removed.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */

  Emitter.prototype.once = function(event, fn){
    var self = this;
    this._callbacks = this._callbacks || {};

    function on() {
      self.off(event, on);
      fn.apply(this, arguments);
    }

    on.fn = fn;
    this.on(event, on);
    return this;
  };

  /**
   * Remove the given callback for `event` or all
   * registered callbacks.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */

  Emitter.prototype.off =
  Emitter.prototype.removeListener =
  Emitter.prototype.removeAllListeners =
  Emitter.prototype.removeEventListener = function(event, fn){
    this._callbacks = this._callbacks || {};

    // all
    if (0 == arguments.length) {
      this._callbacks = {};
      return this;
    }

    // specific event
    var callbacks = this._callbacks[event];
    if (!callbacks) return this;

    // remove all handlers
    if (1 == arguments.length) {
      delete this._callbacks[event];
      return this;
    }

    // remove specific handler
    var cb;
    for (var i = 0; i < callbacks.length; i++) {
      cb = callbacks[i];
      if (cb === fn || cb.fn === fn) {
        callbacks.splice(i, 1);
        break;
      }
    }
    return this;
  };

  /**
   * Emit `event` with the given args.
   *
   * @param {String} event
   * @param {Mixed} ...
   * @return {Emitter}
   */

  Emitter.prototype.emit = function(event){
    this._callbacks = this._callbacks || {};
    var args = [].slice.call(arguments, 1)
      , callbacks = this._callbacks[event];

    if (callbacks) {
      callbacks = callbacks.slice(0);
      for (var i = 0, len = callbacks.length; i < len; ++i) {
        callbacks[i].apply(this, args);
      }
    }

    return this;
  };

  /**
   * Return array of callbacks for `event`.
   *
   * @param {String} event
   * @return {Array}
   * @api public
   */

  Emitter.prototype.listeners = function(event){
    this._callbacks = this._callbacks || {};
    return this._callbacks[event] || [];
  };

  /**
   * Check if this emitter has `event` handlers.
   *
   * @param {String} event
   * @return {Boolean}
   * @api public
   */

  Emitter.prototype.hasListeners = function(event){
    return !! this.listeners(event).length;
  };


/***/ },
/* 14 */
/***/ function(module, exports) {

  "use strict";

  /**
   * @prototype Point3d
   * @param {Number} [x]
   * @param {Number} [y]
   * @param {Number} [z]
   */
  function Point3d(x, y, z) {
    this.x = x !== undefined ? x : 0;
    this.y = y !== undefined ? y : 0;
    this.z = z !== undefined ? z : 0;
  };

  /**
   * Subtract the two provided points, returns a-b
   * @param {Point3d} a
   * @param {Point3d} b
   * @return {Point3d} a-b
   */
  Point3d.subtract = function (a, b) {
    var sub = new Point3d();
    sub.x = a.x - b.x;
    sub.y = a.y - b.y;
    sub.z = a.z - b.z;
    return sub;
  };

  /**
   * Add the two provided points, returns a+b
   * @param {Point3d} a
   * @param {Point3d} b
   * @return {Point3d} a+b
   */
  Point3d.add = function (a, b) {
    var sum = new Point3d();
    sum.x = a.x + b.x;
    sum.y = a.y + b.y;
    sum.z = a.z + b.z;
    return sum;
  };

  /**
   * Calculate the average of two 3d points
   * @param {Point3d} a
   * @param {Point3d} b
   * @return {Point3d} The average, (a+b)/2
   */
  Point3d.avg = function (a, b) {
    return new Point3d((a.x + b.x) / 2, (a.y + b.y) / 2, (a.z + b.z) / 2);
  };

  /**
   * Calculate the cross product of the two provided points, returns axb
   * Documentation: http://en.wikipedia.org/wiki/Cross_product
   * @param {Point3d} a
   * @param {Point3d} b
   * @return {Point3d} cross product axb
   */
  Point3d.crossProduct = function (a, b) {
    var crossproduct = new Point3d();

    crossproduct.x = a.y * b.z - a.z * b.y;
    crossproduct.y = a.z * b.x - a.x * b.z;
    crossproduct.z = a.x * b.y - a.y * b.x;

    return crossproduct;
  };

  /**
   * Rtrieve the length of the vector (or the distance from this point to the origin
   * @return {Number}  length
   */
  Point3d.prototype.length = function () {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  };

  module.exports = Point3d;

/***/ },
/* 15 */
/***/ function(module, exports) {

  "use strict";

  /**
   * @prototype Point2d
   * @param {Number} [x]
   * @param {Number} [y]
   */
  function Point2d(x, y) {
    this.x = x !== undefined ? x : 0;
    this.y = y !== undefined ? y : 0;
  }

  module.exports = Point2d;

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var Point3d = __webpack_require__(14);

  /**
   * @class Camera
   * The camera is mounted on a (virtual) camera arm. The camera arm can rotate
   * The camera is always looking in the direction of the origin of the arm.
   * This way, the camera always rotates around one fixed point, the location
   * of the camera arm.
   *
   * Documentation:
   *   http://en.wikipedia.org/wiki/3D_projection
   */
  function Camera() {
    this.armLocation = new Point3d();
    this.armRotation = {};
    this.armRotation.horizontal = 0;
    this.armRotation.vertical = 0;
    this.armLength = 1.7;

    this.cameraLocation = new Point3d();
    this.cameraRotation = new Point3d(0.5 * Math.PI, 0, 0);

    this.calculateCameraOrientation();
  }

  /**
   * Set the location (origin) of the arm
   * @param {Number} x  Normalized value of x
   * @param {Number} y  Normalized value of y
   * @param {Number} z  Normalized value of z
   */
  Camera.prototype.setArmLocation = function (x, y, z) {
    this.armLocation.x = x;
    this.armLocation.y = y;
    this.armLocation.z = z;

    this.calculateCameraOrientation();
  };

  /**
   * Set the rotation of the camera arm
   * @param {Number} horizontal   The horizontal rotation, between 0 and 2*PI.
   *                Optional, can be left undefined.
   * @param {Number} vertical   The vertical rotation, between 0 and 0.5*PI
   *                if vertical=0.5*PI, the graph is shown from the
   *                top. Optional, can be left undefined.
   */
  Camera.prototype.setArmRotation = function (horizontal, vertical) {
    if (horizontal !== undefined) {
      this.armRotation.horizontal = horizontal;
    }

    if (vertical !== undefined) {
      this.armRotation.vertical = vertical;
      if (this.armRotation.vertical < 0) this.armRotation.vertical = 0;
      if (this.armRotation.vertical > 0.5 * Math.PI) this.armRotation.vertical = 0.5 * Math.PI;
    }

    if (horizontal !== undefined || vertical !== undefined) {
      this.calculateCameraOrientation();
    }
  };

  /**
   * Retrieve the current arm rotation
   * @return {object}   An object with parameters horizontal and vertical
   */
  Camera.prototype.getArmRotation = function () {
    var rot = {};
    rot.horizontal = this.armRotation.horizontal;
    rot.vertical = this.armRotation.vertical;

    return rot;
  };

  /**
   * Set the (normalized) length of the camera arm.
   * @param {Number} length A length between 0.71 and 5.0
   */
  Camera.prototype.setArmLength = function (length) {
    if (length === undefined) return;

    this.armLength = length;

    // Radius must be larger than the corner of the graph,
    // which has a distance of sqrt(0.5^2+0.5^2) = 0.71 from the center of the
    // graph
    if (this.armLength < 0.71) this.armLength = 0.71;
    if (this.armLength > 5.0) this.armLength = 5.0;

    this.calculateCameraOrientation();
  };

  /**
   * Retrieve the arm length
   * @return {Number} length
   */
  Camera.prototype.getArmLength = function () {
    return this.armLength;
  };

  /**
   * Retrieve the camera location
   * @return {Point3d} cameraLocation
   */
  Camera.prototype.getCameraLocation = function () {
    return this.cameraLocation;
  };

  /**
   * Retrieve the camera rotation
   * @return {Point3d} cameraRotation
   */
  Camera.prototype.getCameraRotation = function () {
    return this.cameraRotation;
  };

  /**
   * Calculate the location and rotation of the camera based on the
   * position and orientation of the camera arm
   */
  Camera.prototype.calculateCameraOrientation = function () {
    // calculate location of the camera
    this.cameraLocation.x = this.armLocation.x - this.armLength * Math.sin(this.armRotation.horizontal) * Math.cos(this.armRotation.vertical);
    this.cameraLocation.y = this.armLocation.y - this.armLength * Math.cos(this.armRotation.horizontal) * Math.cos(this.armRotation.vertical);
    this.cameraLocation.z = this.armLocation.z + this.armLength * Math.sin(this.armRotation.vertical);

    // calculate rotation of the camera
    this.cameraRotation.x = Math.PI / 2 - this.armRotation.vertical;
    this.cameraRotation.y = 0;
    this.cameraRotation.z = -this.armRotation.horizontal;
  };

  module.exports = Camera;

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var DataView = __webpack_require__(11);

  /**
   * @class Filter
   *
   * @param {DataSet} data The google data table
   * @param {Number}  column             The index of the column to be filtered
   * @param {Graph} graph           The graph
   */
  function Filter(data, column, graph) {
    this.data = data;
    this.column = column;
    this.graph = graph; // the parent graph

    this.index = undefined;
    this.value = undefined;

    // read all distinct values and select the first one
    this.values = graph.getDistinctValues(data.get(), this.column);

    // sort both numeric and string values correctly
    this.values.sort(function (a, b) {
      return a > b ? 1 : a < b ? -1 : 0;
    });

    if (this.values.length > 0) {
      this.selectValue(0);
    }

    // create an array with the filtered datapoints. this will be loaded afterwards
    this.dataPoints = [];

    this.loaded = false;
    this.onLoadCallback = undefined;

    if (graph.animationPreload) {
      this.loaded = false;
      this.loadInBackground();
    } else {
      this.loaded = true;
    }
  };

  /**
   * Return the label
   * @return {string} label
   */
  Filter.prototype.isLoaded = function () {
    return this.loaded;
  };

  /**
   * Return the loaded progress
   * @return {Number} percentage between 0 and 100
   */
  Filter.prototype.getLoadedProgress = function () {
    var len = this.values.length;

    var i = 0;
    while (this.dataPoints[i]) {
      i++;
    }

    return Math.round(i / len * 100);
  };

  /**
   * Return the label
   * @return {string} label
   */
  Filter.prototype.getLabel = function () {
    return this.graph.filterLabel;
  };

  /**
   * Return the columnIndex of the filter
   * @return {Number} columnIndex
   */
  Filter.prototype.getColumn = function () {
    return this.column;
  };

  /**
   * Return the currently selected value. Returns undefined if there is no selection
   * @return {*} value
   */
  Filter.prototype.getSelectedValue = function () {
    if (this.index === undefined) return undefined;

    return this.values[this.index];
  };

  /**
   * Retrieve all values of the filter
   * @return {Array} values
   */
  Filter.prototype.getValues = function () {
    return this.values;
  };

  /**
   * Retrieve one value of the filter
   * @param {Number}  index
   * @return {*} value
   */
  Filter.prototype.getValue = function (index) {
    if (index >= this.values.length) throw 'Error: index out of range';

    return this.values[index];
  };

  /**
   * Retrieve the (filtered) dataPoints for the currently selected filter index
   * @param {Number} [index] (optional)
   * @return {Array} dataPoints
   */
  Filter.prototype._getDataPoints = function (index) {
    if (index === undefined) index = this.index;

    if (index === undefined) return [];

    var dataPoints;
    if (this.dataPoints[index]) {
      dataPoints = this.dataPoints[index];
    } else {
      var f = {};
      f.column = this.column;
      f.value = this.values[index];

      var dataView = new DataView(this.data, { filter: function filter(item) {
          return item[f.column] == f.value;
        } }).get();
      dataPoints = this.graph._getDataPoints(dataView);

      this.dataPoints[index] = dataPoints;
    }

    return dataPoints;
  };

  /**
   * Set a callback function when the filter is fully loaded.
   */
  Filter.prototype.setOnLoadCallback = function (callback) {
    this.onLoadCallback = callback;
  };

  /**
   * Add a value to the list with available values for this filter
   * No double entries will be created.
   * @param {Number} index
   */
  Filter.prototype.selectValue = function (index) {
    if (index >= this.values.length) throw 'Error: index out of range';

    this.index = index;
    this.value = this.values[index];
  };

  /**
   * Load all filtered rows in the background one by one
   * Start this method without providing an index!
   */
  Filter.prototype.loadInBackground = function (index) {
    if (index === undefined) index = 0;

    var frame = this.graph.frame;

    if (index < this.values.length) {
      var dataPointsTemp = this._getDataPoints(index);
      //this.graph.redrawInfo(); // TODO: not neat

      // create a progress box
      if (frame.progress === undefined) {
        frame.progress = document.createElement('DIV');
        frame.progress.style.position = 'absolute';
        frame.progress.style.color = 'gray';
        frame.appendChild(frame.progress);
      }
      var progress = this.getLoadedProgress();
      frame.progress.innerHTML = 'Loading animation... ' + progress + '%';
      // TODO: this is no nice solution...
      frame.progress.style.bottom = 60 + 'px'; // TODO: use height of slider
      frame.progress.style.left = 10 + 'px';

      var me = this;
      setTimeout(function () {
        me.loadInBackground(index + 1);
      }, 10);
      this.loaded = false;
    } else {
      this.loaded = true;

      // remove the progress box
      if (frame.progress !== undefined) {
        frame.removeChild(frame.progress);
        frame.progress = undefined;
      }

      if (this.onLoadCallback) this.onLoadCallback();
    }
  };

  module.exports = Filter;

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var util = __webpack_require__(1);

  /**
   * @constructor Slider
   *
   * An html slider control with start/stop/prev/next buttons
   * @param {Element} container  The element where the slider will be created
   * @param {Object} options   Available options:
   *                 {boolean} visible   If true (default) the
   *                           slider is visible.
   */
  function Slider(container, options) {
    if (container === undefined) {
      throw 'Error: No container element defined';
    }
    this.container = container;
    this.visible = options && options.visible != undefined ? options.visible : true;

    if (this.visible) {
      this.frame = document.createElement('DIV');
      //this.frame.style.backgroundColor = '#E5E5E5';
      this.frame.style.width = '100%';
      this.frame.style.position = 'relative';
      this.container.appendChild(this.frame);

      this.frame.prev = document.createElement('INPUT');
      this.frame.prev.type = 'BUTTON';
      this.frame.prev.value = 'Prev';
      this.frame.appendChild(this.frame.prev);

      this.frame.play = document.createElement('INPUT');
      this.frame.play.type = 'BUTTON';
      this.frame.play.value = 'Play';
      this.frame.appendChild(this.frame.play);

      this.frame.next = document.createElement('INPUT');
      this.frame.next.type = 'BUTTON';
      this.frame.next.value = 'Next';
      this.frame.appendChild(this.frame.next);

      this.frame.bar = document.createElement('INPUT');
      this.frame.bar.type = 'BUTTON';
      this.frame.bar.style.position = 'absolute';
      this.frame.bar.style.border = '1px solid red';
      this.frame.bar.style.width = '100px';
      this.frame.bar.style.height = '6px';
      this.frame.bar.style.borderRadius = '2px';
      this.frame.bar.style.MozBorderRadius = '2px';
      this.frame.bar.style.border = '1px solid #7F7F7F';
      this.frame.bar.style.backgroundColor = '#E5E5E5';
      this.frame.appendChild(this.frame.bar);

      this.frame.slide = document.createElement('INPUT');
      this.frame.slide.type = 'BUTTON';
      this.frame.slide.style.margin = '0px';
      this.frame.slide.value = ' ';
      this.frame.slide.style.position = 'relative';
      this.frame.slide.style.left = '-100px';
      this.frame.appendChild(this.frame.slide);

      // create events
      var me = this;
      this.frame.slide.onmousedown = function (event) {
        me._onMouseDown(event);
      };
      this.frame.prev.onclick = function (event) {
        me.prev(event);
      };
      this.frame.play.onclick = function (event) {
        me.togglePlay(event);
      };
      this.frame.next.onclick = function (event) {
        me.next(event);
      };
    }

    this.onChangeCallback = undefined;

    this.values = [];
    this.index = undefined;

    this.playTimeout = undefined;
    this.playInterval = 1000; // milliseconds
    this.playLoop = true;
  }

  /**
   * Select the previous index
   */
  Slider.prototype.prev = function () {
    var index = this.getIndex();
    if (index > 0) {
      index--;
      this.setIndex(index);
    }
  };

  /**
   * Select the next index
   */
  Slider.prototype.next = function () {
    var index = this.getIndex();
    if (index < this.values.length - 1) {
      index++;
      this.setIndex(index);
    }
  };

  /**
   * Select the next index
   */
  Slider.prototype.playNext = function () {
    var start = new Date();

    var index = this.getIndex();
    if (index < this.values.length - 1) {
      index++;
      this.setIndex(index);
    } else if (this.playLoop) {
      // jump to the start
      index = 0;
      this.setIndex(index);
    }

    var end = new Date();
    var diff = end - start;

    // calculate how much time it to to set the index and to execute the callback
    // function.
    var interval = Math.max(this.playInterval - diff, 0);
    // document.title = diff // TODO: cleanup

    var me = this;
    this.playTimeout = setTimeout(function () {
      me.playNext();
    }, interval);
  };

  /**
   * Toggle start or stop playing
   */
  Slider.prototype.togglePlay = function () {
    if (this.playTimeout === undefined) {
      this.play();
    } else {
      this.stop();
    }
  };

  /**
   * Start playing
   */
  Slider.prototype.play = function () {
    // Test whether already playing
    if (this.playTimeout) return;

    this.playNext();

    if (this.frame) {
      this.frame.play.value = 'Stop';
    }
  };

  /**
   * Stop playing
   */
  Slider.prototype.stop = function () {
    clearInterval(this.playTimeout);
    this.playTimeout = undefined;

    if (this.frame) {
      this.frame.play.value = 'Play';
    }
  };

  /**
   * Set a callback function which will be triggered when the value of the
   * slider bar has changed.
   */
  Slider.prototype.setOnChangeCallback = function (callback) {
    this.onChangeCallback = callback;
  };

  /**
   * Set the interval for playing the list
   * @param {Number} interval   The interval in milliseconds
   */
  Slider.prototype.setPlayInterval = function (interval) {
    this.playInterval = interval;
  };

  /**
   * Retrieve the current play interval
   * @return {Number} interval   The interval in milliseconds
   */
  Slider.prototype.getPlayInterval = function (interval) {
    return this.playInterval;
  };

  /**
   * Set looping on or off
   * @pararm {boolean} doLoop  If true, the slider will jump to the start when
   *               the end is passed, and will jump to the end
   *               when the start is passed.
   */
  Slider.prototype.setPlayLoop = function (doLoop) {
    this.playLoop = doLoop;
  };

  /**
   * Execute the onchange callback function
   */
  Slider.prototype.onChange = function () {
    if (this.onChangeCallback !== undefined) {
      this.onChangeCallback();
    }
  };

  /**
   * redraw the slider on the correct place
   */
  Slider.prototype.redraw = function () {
    if (this.frame) {
      // resize the bar
      this.frame.bar.style.top = this.frame.clientHeight / 2 - this.frame.bar.offsetHeight / 2 + 'px';
      this.frame.bar.style.width = this.frame.clientWidth - this.frame.prev.clientWidth - this.frame.play.clientWidth - this.frame.next.clientWidth - 30 + 'px';

      // position the slider button
      var left = this.indexToLeft(this.index);
      this.frame.slide.style.left = left + 'px';
    }
  };

  /**
   * Set the list with values for the slider
   * @param {Array} values   A javascript array with values (any type)
   */
  Slider.prototype.setValues = function (values) {
    this.values = values;

    if (this.values.length > 0) this.setIndex(0);else this.index = undefined;
  };

  /**
   * Select a value by its index
   * @param {Number} index
   */
  Slider.prototype.setIndex = function (index) {
    if (index < this.values.length) {
      this.index = index;

      this.redraw();
      this.onChange();
    } else {
      throw 'Error: index out of range';
    }
  };

  /**
   * retrieve the index of the currently selected vaue
   * @return {Number} index
   */
  Slider.prototype.getIndex = function () {
    return this.index;
  };

  /**
   * retrieve the currently selected value
   * @return {*} value
   */
  Slider.prototype.get = function () {
    return this.values[this.index];
  };

  Slider.prototype._onMouseDown = function (event) {
    // only react on left mouse button down
    var leftButtonDown = event.which ? event.which === 1 : event.button === 1;
    if (!leftButtonDown) return;

    this.startClientX = event.clientX;
    this.startSlideX = parseFloat(this.frame.slide.style.left);

    this.frame.style.cursor = 'move';

    // add event listeners to handle moving the contents
    // we store the function onmousemove and onmouseup in the graph, so we can
    // remove the eventlisteners lateron in the function mouseUp()
    var me = this;
    this.onmousemove = function (event) {
      me._onMouseMove(event);
    };
    this.onmouseup = function (event) {
      me._onMouseUp(event);
    };
    util.addEventListener(document, 'mousemove', this.onmousemove);
    util.addEventListener(document, 'mouseup', this.onmouseup);
    util.preventDefault(event);
  };

  Slider.prototype.leftToIndex = function (left) {
    var width = parseFloat(this.frame.bar.style.width) - this.frame.slide.clientWidth - 10;
    var x = left - 3;

    var index = Math.round(x / width * (this.values.length - 1));
    if (index < 0) index = 0;
    if (index > this.values.length - 1) index = this.values.length - 1;

    return index;
  };

  Slider.prototype.indexToLeft = function (index) {
    var width = parseFloat(this.frame.bar.style.width) - this.frame.slide.clientWidth - 10;

    var x = index / (this.values.length - 1) * width;
    var left = x + 3;

    return left;
  };

  Slider.prototype._onMouseMove = function (event) {
    var diff = event.clientX - this.startClientX;
    var x = this.startSlideX + diff;

    var index = this.leftToIndex(x);

    this.setIndex(index);

    util.preventDefault();
  };

  Slider.prototype._onMouseUp = function (event) {
    this.frame.style.cursor = 'auto';

    // remove event listeners
    util.removeEventListener(document, 'mousemove', this.onmousemove);
    util.removeEventListener(document, 'mouseup', this.onmouseup);

    util.preventDefault();
  };

  module.exports = Slider;

/***/ },
/* 19 */
/***/ function(module, exports) {

  "use strict";

  /**
   * @prototype StepNumber
   * The class StepNumber is an iterator for Numbers. You provide a start and end
   * value, and a best step size. StepNumber itself rounds to fixed values and
   * a finds the step that best fits the provided step.
   *
   * If prettyStep is true, the step size is chosen as close as possible to the
   * provided step, but being a round value like 1, 2, 5, 10, 20, 50, ....
   *
   * Example usage:
   *   var step = new StepNumber(0, 10, 2.5, true);
   *   step.start();
   *   while (!step.end()) {
   *   alert(step.getCurrent());
   *   step.next();
   *   }
   *
   * Version: 1.0
   *
   * @param {Number} start     The start value
   * @param {Number} end     The end value
   * @param {Number} step    Optional. Step size. Must be a positive value.
   * @param {boolean} prettyStep Optional. If true, the step size is rounded
   *               To a pretty step size (like 1, 2, 5, 10, 20, 50, ...)
   */
  function StepNumber(start, end, step, prettyStep) {
    // set default values
    this._start = 0;
    this._end = 0;
    this._step = 1;
    this.prettyStep = true;
    this.precision = 5;

    this._current = 0;
    this.setRange(start, end, step, prettyStep);
  };

  /**
   * Set a new range: start, end and step.
   *
   * @param {Number} start     The start value
   * @param {Number} end     The end value
   * @param {Number} step    Optional. Step size. Must be a positive value.
   * @param {boolean} prettyStep Optional. If true, the step size is rounded
   *               To a pretty step size (like 1, 2, 5, 10, 20, 50, ...)
   */
  StepNumber.prototype.setRange = function (start, end, step, prettyStep) {
    this._start = start ? start : 0;
    this._end = end ? end : 0;

    this.setStep(step, prettyStep);
  };

  /**
   * Set a new step size
   * @param {Number} step    New step size. Must be a positive value
   * @param {boolean} prettyStep Optional. If true, the provided step is rounded
   *               to a pretty step size (like 1, 2, 5, 10, 20, 50, ...)
   */
  StepNumber.prototype.setStep = function (step, prettyStep) {
    if (step === undefined || step <= 0) return;

    if (prettyStep !== undefined) this.prettyStep = prettyStep;

    if (this.prettyStep === true) this._step = StepNumber.calculatePrettyStep(step);else this._step = step;
  };

  /**
   * Calculate a nice step size, closest to the desired step size.
   * Returns a value in one of the ranges 1*10^n, 2*10^n, or 5*10^n, where n is an
   * integer Number. For example 1, 2, 5, 10, 20, 50, etc...
   * @param {Number}  step  Desired step size
   * @return {Number}     Nice step size
   */
  StepNumber.calculatePrettyStep = function (step) {
    var log10 = function log10(x) {
      return Math.log(x) / Math.LN10;
    };

    // try three steps (multiple of 1, 2, or 5
    var step1 = Math.pow(10, Math.round(log10(step))),
        step2 = 2 * Math.pow(10, Math.round(log10(step / 2))),
        step5 = 5 * Math.pow(10, Math.round(log10(step / 5)));

    // choose the best step (closest to minimum step)
    var prettyStep = step1;
    if (Math.abs(step2 - step) <= Math.abs(prettyStep - step)) prettyStep = step2;
    if (Math.abs(step5 - step) <= Math.abs(prettyStep - step)) prettyStep = step5;

    // for safety
    if (prettyStep <= 0) {
      prettyStep = 1;
    }

    return prettyStep;
  };

  /**
   * returns the current value of the step
   * @return {Number} current value
   */
  StepNumber.prototype.getCurrent = function () {
    return parseFloat(this._current.toPrecision(this.precision));
  };

  /**
   * returns the current step size
   * @return {Number} current step size
   */
  StepNumber.prototype.getStep = function () {
    return this._step;
  };

  /**
   * Set the current value to the largest value smaller than start, which
   * is a multiple of the step size
   */
  StepNumber.prototype.start = function () {
    this._current = this._start - this._start % this._step;
  };

  /**
   * Do a step, add the step size to the current value
   */
  StepNumber.prototype.next = function () {
    this._current += this._step;
  };

  /**
   * Returns true whether the end is reached
   * @return {boolean}  True if the current value has passed the end value.
   */
  StepNumber.prototype.end = function () {
    return this._current > this._end;
  };

  module.exports = StepNumber;

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  // Only load hammer.js when in a browser environment
  // (loading hammer.js in a node.js environment gives errors)
  if (typeof window !== 'undefined') {
    var propagating = __webpack_require__(21);
    var Hammer = window['Hammer'] || __webpack_require__(22);
    module.exports = propagating(Hammer, {
      preventDefault: 'mouse'
    });
  } else {
    module.exports = function () {
      throw Error('hammer.js is only available in a browser, not in node.js.');
    };
  }

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

  var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

  (function (factory) {
    if (true) {
      // AMD. Register as an anonymous module.
      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if (typeof exports === 'object') {
      // Node. Does not work with strict CommonJS, but
      // only CommonJS-like environments that support module.exports,
      // like Node.
      module.exports = factory();
    } else {
      // Browser globals (root is window)
      window.propagating = factory();
    }
  }(function () {
    var _firstTarget = null; // singleton, will contain the target element where the touch event started

    /**
     * Extend an Hammer.js instance with event propagation.
     *
     * Features:
     * - Events emitted by hammer will propagate in order from child to parent
     *   elements.
     * - Events are extended with a function `event.stopPropagation()` to stop
     *   propagation to parent elements.
     * - An option `preventDefault` to stop all default browser behavior.
     *
     * Usage:
     *   var hammer = propagatingHammer(new Hammer(element));
     *   var hammer = propagatingHammer(new Hammer(element), {preventDefault: true});
     *
     * @param {Hammer.Manager} hammer   An hammer instance.
     * @param {Object} [options]        Available options:
     *                                  - `preventDefault: true | false | 'mouse' | 'touch' | 'pen'`.
     *                                    Enforce preventing the default browser behavior.
     *                                    Cannot be set to `false`.
     * @return {Hammer.Manager} Returns the same hammer instance with extended
     *                          functionality
     */
    return function propagating(hammer, options) {
      var _options = options || {
        preventDefault: false
      };

      if (hammer.Manager) {
        // This looks like the Hammer constructor.
        // Overload the constructors with our own.
        var Hammer = hammer;

        var PropagatingHammer = function(element, options) {
          var o = Object.create(_options);
          if (options) Hammer.assign(o, options);
          return propagating(new Hammer(element, o), o);
        };
        Hammer.assign(PropagatingHammer, Hammer);

        PropagatingHammer.Manager = function (element, options) {
          var o = Object.create(_options);
          if (options) Hammer.assign(o, options);
          return propagating(new Hammer.Manager(element, o), o);
        };

        return PropagatingHammer;
      }

      // create a wrapper object which will override the functions
      // `on`, `off`, `destroy`, and `emit` of the hammer instance
      var wrapper = Object.create(hammer);

      // attach to DOM element
      var element = hammer.element;

      if(!element.hammer) element.hammer = [];
      element.hammer.push(wrapper);

      // register an event to catch the start of a gesture and store the
      // target in a singleton
      hammer.on('hammer.input', function (event) {
        if (_options.preventDefault === true || (_options.preventDefault === event.pointerType)) {
          event.preventDefault();
        }
        if (event.isFirst) {
          _firstTarget = event.target;
        }
      });

      /** @type {Object.<String, Array.<function>>} */
      wrapper._handlers = {};

      /**
       * Register a handler for one or multiple events
       * @param {String} events    A space separated string with events
       * @param {function} handler A callback function, called as handler(event)
       * @returns {Hammer.Manager} Returns the hammer instance
       */
      wrapper.on = function (events, handler) {
        // register the handler
        split(events).forEach(function (event) {
          var _handlers = wrapper._handlers[event];
          if (!_handlers) {
            wrapper._handlers[event] = _handlers = [];

            // register the static, propagated handler
            hammer.on(event, propagatedHandler);
          }
          _handlers.push(handler);
        });

        return wrapper;
      };

      /**
       * Unregister a handler for one or multiple events
       * @param {String} events      A space separated string with events
       * @param {function} [handler] Optional. The registered handler. If not
       *                             provided, all handlers for given events
       *                             are removed.
       * @returns {Hammer.Manager}   Returns the hammer instance
       */
      wrapper.off = function (events, handler) {
        // unregister the handler
        split(events).forEach(function (event) {
          var _handlers = wrapper._handlers[event];
          if (_handlers) {
            _handlers = handler ? _handlers.filter(function (h) {
              return h !== handler;
            }) : [];

            if (_handlers.length > 0) {
              wrapper._handlers[event] = _handlers;
            }
            else {
              // remove static, propagated handler
              hammer.off(event, propagatedHandler);
              delete wrapper._handlers[event];
            }
          }
        });

        return wrapper;
      };

      /**
       * Emit to the event listeners
       * @param {string} eventType
       * @param {Event} event
       */
      wrapper.emit = function(eventType, event) {
        _firstTarget = event.target;
        hammer.emit(eventType, event);
      };

      wrapper.destroy = function () {
        // Detach from DOM element
        var hammers = hammer.element.hammer;
        var idx = hammers.indexOf(wrapper);
        if(idx !== -1) hammers.splice(idx,1);
        if(!hammers.length) delete hammer.element.hammer;

        // clear all handlers
        wrapper._handlers = {};

        // call original hammer destroy
        hammer.destroy();
      };

      // split a string with space separated words
      function split(events) {
        return events.match(/[^ ]+/g);
      }

      /**
       * A static event handler, applying event propagation.
       * @param {Object} event
       */
      function propagatedHandler(event) {
        // let only a single hammer instance handle this event
        if (event.type !== 'hammer.input') {
          // it is possible that the same srcEvent is used with multiple hammer events,
          // we keep track on which events are handled in an object _handled
          if (!event.srcEvent._handled) {
            event.srcEvent._handled = {};
          }

          if (event.srcEvent._handled[event.type]) {
            return;
          }
          else {
            event.srcEvent._handled[event.type] = true;
          }
        }

        // attach a stopPropagation function to the event
        var stopped = false;
        event.stopPropagation = function () {
          stopped = true;
        };

        //wrap the srcEvent's stopPropagation to also stop hammer propagation:
        var srcStop = event.srcEvent.stopPropagation.bind(event.srcEvent);
        if(typeof srcStop == "function") {
          event.srcEvent.stopPropagation = function(){
            srcStop();
            event.stopPropagation();
          }
        }

        // attach firstTarget property to the event
        event.firstTarget = _firstTarget;

        // propagate over all elements (until stopped)
        var elem = _firstTarget;
        while (elem && !stopped) {
          var elemHammer = elem.hammer;
          if(elemHammer){
            var _handlers;
            for(var k = 0; k < elemHammer.length; k++){
              _handlers = elemHammer[k]._handlers[event.type];
              if(_handlers) for (var i = 0; i < _handlers.length && !stopped; i++) {
                _handlers[i](event);
              }
            }
          }
          elem = elem.parentNode;
        }
      }

      return wrapper;
    };
  }));


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

  var __WEBPACK_AMD_DEFINE_RESULT__;/*! Hammer.JS - v2.0.6 - 2015-12-23
   * http://hammerjs.github.io/
   *
   * Copyright (c) 2015 Jorik Tangelder;
   * Licensed under the  license */
  (function(window, document, exportName, undefined) {
    'use strict';

  var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
  var TEST_ELEMENT = document.createElement('div');

  var TYPE_FUNCTION = 'function';

  var round = Math.round;
  var abs = Math.abs;
  var now = Date.now;

  /**
   * set a timeout with a given scope
   * @param {Function} fn
   * @param {Number} timeout
   * @param {Object} context
   * @returns {number}
   */
  function setTimeoutContext(fn, timeout, context) {
      return setTimeout(bindFn(fn, context), timeout);
  }

  /**
   * if the argument is an array, we want to execute the fn on each entry
   * if it aint an array we don't want to do a thing.
   * this is used by all the methods that accept a single and array argument.
   * @param {*|Array} arg
   * @param {String} fn
   * @param {Object} [context]
   * @returns {Boolean}
   */
  function invokeArrayArg(arg, fn, context) {
      if (Array.isArray(arg)) {
          each(arg, context[fn], context);
          return true;
      }
      return false;
  }

  /**
   * walk objects and arrays
   * @param {Object} obj
   * @param {Function} iterator
   * @param {Object} context
   */
  function each(obj, iterator, context) {
      var i;

      if (!obj) {
          return;
      }

      if (obj.forEach) {
          obj.forEach(iterator, context);
      } else if (obj.length !== undefined) {
          i = 0;
          while (i < obj.length) {
              iterator.call(context, obj[i], i, obj);
              i++;
          }
      } else {
          for (i in obj) {
              obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
          }
      }
  }

  /**
   * wrap a method with a deprecation warning and stack trace
   * @param {Function} method
   * @param {String} name
   * @param {String} message
   * @returns {Function} A new function wrapping the supplied method.
   */
  function deprecate(method, name, message) {
      var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
      return function() {
          var e = new Error('get-stack-trace');
          var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '')
              .replace(/^\s+at\s+/gm, '')
              .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

          var log = window.console && (window.console.warn || window.console.log);
          if (log) {
              log.call(window.console, deprecationMessage, stack);
          }
          return method.apply(this, arguments);
      };
  }

  /**
   * extend object.
   * means that properties in dest will be overwritten by the ones in src.
   * @param {Object} target
   * @param {...Object} objects_to_assign
   * @returns {Object} target
   */
  var assign;
  if (typeof Object.assign !== 'function') {
      assign = function assign(target) {
          if (target === undefined || target === null) {
              throw new TypeError('Cannot convert undefined or null to object');
          }

          var output = Object(target);
          for (var index = 1; index < arguments.length; index++) {
              var source = arguments[index];
              if (source !== undefined && source !== null) {
                  for (var nextKey in source) {
                      if (source.hasOwnProperty(nextKey)) {
                          output[nextKey] = source[nextKey];
                      }
                  }
              }
          }
          return output;
      };
  } else {
      assign = Object.assign;
  }

  /**
   * extend object.
   * means that properties in dest will be overwritten by the ones in src.
   * @param {Object} dest
   * @param {Object} src
   * @param {Boolean=false} [merge]
   * @returns {Object} dest
   */
  var extend = deprecate(function extend(dest, src, merge) {
      var keys = Object.keys(src);
      var i = 0;
      while (i < keys.length) {
          if (!merge || (merge && dest[keys[i]] === undefined)) {
              dest[keys[i]] = src[keys[i]];
          }
          i++;
      }
      return dest;
  }, 'extend', 'Use `assign`.');

  /**
   * merge the values from src in the dest.
   * means that properties that exist in dest will not be overwritten by src
   * @param {Object} dest
   * @param {Object} src
   * @returns {Object} dest
   */
  var merge = deprecate(function merge(dest, src) {
      return extend(dest, src, true);
  }, 'merge', 'Use `assign`.');

  /**
   * simple class inheritance
   * @param {Function} child
   * @param {Function} base
   * @param {Object} [properties]
   */
  function inherit(child, base, properties) {
      var baseP = base.prototype,
          childP;

      childP = child.prototype = Object.create(baseP);
      childP.constructor = child;
      childP._super = baseP;

      if (properties) {
          assign(childP, properties);
      }
  }

  /**
   * simple function bind
   * @param {Function} fn
   * @param {Object} context
   * @returns {Function}
   */
  function bindFn(fn, context) {
      return function boundFn() {
          return fn.apply(context, arguments);
      };
  }

  /**
   * let a boolean value also be a function that must return a boolean
   * this first item in args will be used as the context
   * @param {Boolean|Function} val
   * @param {Array} [args]
   * @returns {Boolean}
   */
  function boolOrFn(val, args) {
      if (typeof val == TYPE_FUNCTION) {
          return val.apply(args ? args[0] || undefined : undefined, args);
      }
      return val;
  }

  /**
   * use the val2 when val1 is undefined
   * @param {*} val1
   * @param {*} val2
   * @returns {*}
   */
  function ifUndefined(val1, val2) {
      return (val1 === undefined) ? val2 : val1;
  }

  /**
   * addEventListener with multiple events at once
   * @param {EventTarget} target
   * @param {String} types
   * @param {Function} handler
   */
  function addEventListeners(target, types, handler) {
      each(splitStr(types), function(type) {
          target.addEventListener(type, handler, false);
      });
  }

  /**
   * removeEventListener with multiple events at once
   * @param {EventTarget} target
   * @param {String} types
   * @param {Function} handler
   */
  function removeEventListeners(target, types, handler) {
      each(splitStr(types), function(type) {
          target.removeEventListener(type, handler, false);
      });
  }

  /**
   * find if a node is in the given parent
   * @method hasParent
   * @param {HTMLElement} node
   * @param {HTMLElement} parent
   * @return {Boolean} found
   */
  function hasParent(node, parent) {
      while (node) {
          if (node == parent) {
              return true;
          }
          node = node.parentNode;
      }
      return false;
  }

  /**
   * small indexOf wrapper
   * @param {String} str
   * @param {String} find
   * @returns {Boolean} found
   */
  function inStr(str, find) {
      return str.indexOf(find) > -1;
  }

  /**
   * split string on whitespace
   * @param {String} str
   * @returns {Array} words
   */
  function splitStr(str) {
      return str.trim().split(/\s+/g);
  }

  /**
   * find if a array contains the object using indexOf or a simple polyFill
   * @param {Array} src
   * @param {String} find
   * @param {String} [findByKey]
   * @return {Boolean|Number} false when not found, or the index
   */
  function inArray(src, find, findByKey) {
      if (src.indexOf && !findByKey) {
          return src.indexOf(find);
      } else {
          var i = 0;
          while (i < src.length) {
              if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                  return i;
              }
              i++;
          }
          return -1;
      }
  }

  /**
   * convert array-like objects to real arrays
   * @param {Object} obj
   * @returns {Array}
   */
  function toArray(obj) {
      return Array.prototype.slice.call(obj, 0);
  }

  /**
   * unique array with objects based on a key (like 'id') or just by the array's value
   * @param {Array} src [{id:1},{id:2},{id:1}]
   * @param {String} [key]
   * @param {Boolean} [sort=False]
   * @returns {Array} [{id:1},{id:2}]
   */
  function uniqueArray(src, key, sort) {
      var results = [];
      var values = [];
      var i = 0;

      while (i < src.length) {
          var val = key ? src[i][key] : src[i];
          if (inArray(values, val) < 0) {
              results.push(src[i]);
          }
          values[i] = val;
          i++;
      }

      if (sort) {
          if (!key) {
              results = results.sort();
          } else {
              results = results.sort(function sortUniqueArray(a, b) {
                  return a[key] > b[key];
              });
          }
      }

      return results;
  }

  /**
   * get the prefixed property
   * @param {Object} obj
   * @param {String} property
   * @returns {String|Undefined} prefixed
   */
  function prefixed(obj, property) {
      var prefix, prop;
      var camelProp = property[0].toUpperCase() + property.slice(1);

      var i = 0;
      while (i < VENDOR_PREFIXES.length) {
          prefix = VENDOR_PREFIXES[i];
          prop = (prefix) ? prefix + camelProp : property;

          if (prop in obj) {
              return prop;
          }
          i++;
      }
      return undefined;
  }

  /**
   * get a unique id
   * @returns {number} uniqueId
   */
  var _uniqueId = 1;
  function uniqueId() {
      return _uniqueId++;
  }

  /**
   * get the window object of an element
   * @param {HTMLElement} element
   * @returns {DocumentView|Window}
   */
  function getWindowForElement(element) {
      var doc = element.ownerDocument || element;
      return (doc.defaultView || doc.parentWindow || window);
  }

  var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

  var SUPPORT_TOUCH = ('ontouchstart' in window);
  var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
  var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

  var INPUT_TYPE_TOUCH = 'touch';
  var INPUT_TYPE_PEN = 'pen';
  var INPUT_TYPE_MOUSE = 'mouse';
  var INPUT_TYPE_KINECT = 'kinect';

  var COMPUTE_INTERVAL = 25;

  var INPUT_START = 1;
  var INPUT_MOVE = 2;
  var INPUT_END = 4;
  var INPUT_CANCEL = 8;

  var DIRECTION_NONE = 1;
  var DIRECTION_LEFT = 2;
  var DIRECTION_RIGHT = 4;
  var DIRECTION_UP = 8;
  var DIRECTION_DOWN = 16;

  var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
  var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
  var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

  var PROPS_XY = ['x', 'y'];
  var PROPS_CLIENT_XY = ['clientX', 'clientY'];

  /**
   * create new input type manager
   * @param {Manager} manager
   * @param {Function} callback
   * @returns {Input}
   * @constructor
   */
  function Input(manager, callback) {
      var self = this;
      this.manager = manager;
      this.callback = callback;
      this.element = manager.element;
      this.target = manager.options.inputTarget;

      // smaller wrapper around the handler, for the scope and the enabled state of the manager,
      // so when disabled the input events are completely bypassed.
      this.domHandler = function(ev) {
          if (boolOrFn(manager.options.enable, [manager])) {
              self.handler(ev);
          }
      };

      this.init();

  }

  Input.prototype = {
      /**
       * should handle the inputEvent data and trigger the callback
       * @virtual
       */
      handler: function() { },

      /**
       * bind the events
       */
      init: function() {
          this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
          this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
          this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
      },

      /**
       * unbind the events
       */
      destroy: function() {
          this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
          this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
          this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
      }
  };

  /**
   * create new input type manager
   * called by the Manager constructor
   * @param {Hammer} manager
   * @returns {Input}
   */
  function createInputInstance(manager) {
      var Type;
      var inputClass = manager.options.inputClass;

      if (inputClass) {
          Type = inputClass;
      } else if (SUPPORT_POINTER_EVENTS) {
          Type = PointerEventInput;
      } else if (SUPPORT_ONLY_TOUCH) {
          Type = TouchInput;
      } else if (!SUPPORT_TOUCH) {
          Type = MouseInput;
      } else {
          Type = TouchMouseInput;
      }
      return new (Type)(manager, inputHandler);
  }

  /**
   * handle input events
   * @param {Manager} manager
   * @param {String} eventType
   * @param {Object} input
   */
  function inputHandler(manager, eventType, input) {
      var pointersLen = input.pointers.length;
      var changedPointersLen = input.changedPointers.length;
      var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
      var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

      input.isFirst = !!isFirst;
      input.isFinal = !!isFinal;

      if (isFirst) {
          manager.session = {};
      }

      // source event is the normalized value of the domEvents
      // like 'touchstart, mouseup, pointerdown'
      input.eventType = eventType;

      // compute scale, rotation etc
      computeInputData(manager, input);

      // emit secret event
      manager.emit('hammer.input', input);

      manager.recognize(input);
      manager.session.prevInput = input;
  }

  /**
   * extend the data with some usable properties like scale, rotate, velocity etc
   * @param {Object} manager
   * @param {Object} input
   */
  function computeInputData(manager, input) {
      var session = manager.session;
      var pointers = input.pointers;
      var pointersLength = pointers.length;

      // store the first input to calculate the distance and direction
      if (!session.firstInput) {
          session.firstInput = simpleCloneInputData(input);
      }

      // to compute scale and rotation we need to store the multiple touches
      if (pointersLength > 1 && !session.firstMultiple) {
          session.firstMultiple = simpleCloneInputData(input);
      } else if (pointersLength === 1) {
          session.firstMultiple = false;
      }

      var firstInput = session.firstInput;
      var firstMultiple = session.firstMultiple;
      var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

      var center = input.center = getCenter(pointers);
      input.timeStamp = now();
      input.deltaTime = input.timeStamp - firstInput.timeStamp;

      input.angle = getAngle(offsetCenter, center);
      input.distance = getDistance(offsetCenter, center);

      computeDeltaXY(session, input);
      input.offsetDirection = getDirection(input.deltaX, input.deltaY);

      var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
      input.overallVelocityX = overallVelocity.x;
      input.overallVelocityY = overallVelocity.y;
      input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;

      input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
      input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

      input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
          session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);

      computeIntervalInputData(session, input);

      // find the correct target
      var target = manager.element;
      if (hasParent(input.srcEvent.target, target)) {
          target = input.srcEvent.target;
      }
      input.target = target;
  }

  function computeDeltaXY(session, input) {
      var center = input.center;
      var offset = session.offsetDelta || {};
      var prevDelta = session.prevDelta || {};
      var prevInput = session.prevInput || {};

      if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
          prevDelta = session.prevDelta = {
              x: prevInput.deltaX || 0,
              y: prevInput.deltaY || 0
          };

          offset = session.offsetDelta = {
              x: center.x,
              y: center.y
          };
      }

      input.deltaX = prevDelta.x + (center.x - offset.x);
      input.deltaY = prevDelta.y + (center.y - offset.y);
  }

  /**
   * velocity is calculated every x ms
   * @param {Object} session
   * @param {Object} input
   */
  function computeIntervalInputData(session, input) {
      var last = session.lastInterval || input,
          deltaTime = input.timeStamp - last.timeStamp,
          velocity, velocityX, velocityY, direction;

      if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
          var deltaX = input.deltaX - last.deltaX;
          var deltaY = input.deltaY - last.deltaY;

          var v = getVelocity(deltaTime, deltaX, deltaY);
          velocityX = v.x;
          velocityY = v.y;
          velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
          direction = getDirection(deltaX, deltaY);

          session.lastInterval = input;
      } else {
          // use latest velocity info if it doesn't overtake a minimum period
          velocity = last.velocity;
          velocityX = last.velocityX;
          velocityY = last.velocityY;
          direction = last.direction;
      }

      input.velocity = velocity;
      input.velocityX = velocityX;
      input.velocityY = velocityY;
      input.direction = direction;
  }

  /**
   * create a simple clone from the input used for storage of firstInput and firstMultiple
   * @param {Object} input
   * @returns {Object} clonedInputData
   */
  function simpleCloneInputData(input) {
      // make a simple copy of the pointers because we will get a reference if we don't
      // we only need clientXY for the calculations
      var pointers = [];
      var i = 0;
      while (i < input.pointers.length) {
          pointers[i] = {
              clientX: round(input.pointers[i].clientX),
              clientY: round(input.pointers[i].clientY)
          };
          i++;
      }

      return {
          timeStamp: now(),
          pointers: pointers,
          center: getCenter(pointers),
          deltaX: input.deltaX,
          deltaY: input.deltaY
      };
  }

  /**
   * get the center of all the pointers
   * @param {Array} pointers
   * @return {Object} center contains `x` and `y` properties
   */
  function getCenter(pointers) {
      var pointersLength = pointers.length;

      // no need to loop when only one touch
      if (pointersLength === 1) {
          return {
              x: round(pointers[0].clientX),
              y: round(pointers[0].clientY)
          };
      }

      var x = 0, y = 0, i = 0;
      while (i < pointersLength) {
          x += pointers[i].clientX;
          y += pointers[i].clientY;
          i++;
      }

      return {
          x: round(x / pointersLength),
          y: round(y / pointersLength)
      };
  }

  /**
   * calculate the velocity between two points. unit is in px per ms.
   * @param {Number} deltaTime
   * @param {Number} x
   * @param {Number} y
   * @return {Object} velocity `x` and `y`
   */
  function getVelocity(deltaTime, x, y) {
      return {
          x: x / deltaTime || 0,
          y: y / deltaTime || 0
      };
  }

  /**
   * get the direction between two points
   * @param {Number} x
   * @param {Number} y
   * @return {Number} direction
   */
  function getDirection(x, y) {
      if (x === y) {
          return DIRECTION_NONE;
      }

      if (abs(x) >= abs(y)) {
          return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
      }
      return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
  }

  /**
   * calculate the absolute distance between two points
   * @param {Object} p1 {x, y}
   * @param {Object} p2 {x, y}
   * @param {Array} [props] containing x and y keys
   * @return {Number} distance
   */
  function getDistance(p1, p2, props) {
      if (!props) {
          props = PROPS_XY;
      }
      var x = p2[props[0]] - p1[props[0]],
          y = p2[props[1]] - p1[props[1]];

      return Math.sqrt((x * x) + (y * y));
  }

  /**
   * calculate the angle between two coordinates
   * @param {Object} p1
   * @param {Object} p2
   * @param {Array} [props] containing x and y keys
   * @return {Number} angle
   */
  function getAngle(p1, p2, props) {
      if (!props) {
          props = PROPS_XY;
      }
      var x = p2[props[0]] - p1[props[0]],
          y = p2[props[1]] - p1[props[1]];
      return Math.atan2(y, x) * 180 / Math.PI;
  }

  /**
   * calculate the rotation degrees between two pointersets
   * @param {Array} start array of pointers
   * @param {Array} end array of pointers
   * @return {Number} rotation
   */
  function getRotation(start, end) {
      return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
  }

  /**
   * calculate the scale factor between two pointersets
   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
   * @param {Array} start array of pointers
   * @param {Array} end array of pointers
   * @return {Number} scale
   */
  function getScale(start, end) {
      return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
  }

  var MOUSE_INPUT_MAP = {
      mousedown: INPUT_START,
      mousemove: INPUT_MOVE,
      mouseup: INPUT_END
  };

  var MOUSE_ELEMENT_EVENTS = 'mousedown';
  var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

  /**
   * Mouse events input
   * @constructor
   * @extends Input
   */
  function MouseInput() {
      this.evEl = MOUSE_ELEMENT_EVENTS;
      this.evWin = MOUSE_WINDOW_EVENTS;

      this.allow = true; // used by Input.TouchMouse to disable mouse events
      this.pressed = false; // mousedown state

      Input.apply(this, arguments);
  }

  inherit(MouseInput, Input, {
      /**
       * handle mouse events
       * @param {Object} ev
       */
      handler: function MEhandler(ev) {
          var eventType = MOUSE_INPUT_MAP[ev.type];

          // on start we want to have the left mouse button down
          if (eventType & INPUT_START && ev.button === 0) {
              this.pressed = true;
          }

          if (eventType & INPUT_MOVE && ev.which !== 1) {
              eventType = INPUT_END;
          }

          // mouse must be down, and mouse events are allowed (see the TouchMouse input)
          if (!this.pressed || !this.allow) {
              return;
          }

          if (eventType & INPUT_END) {
              this.pressed = false;
          }

          this.callback(this.manager, eventType, {
              pointers: [ev],
              changedPointers: [ev],
              pointerType: INPUT_TYPE_MOUSE,
              srcEvent: ev
          });
      }
  });

  var POINTER_INPUT_MAP = {
      pointerdown: INPUT_START,
      pointermove: INPUT_MOVE,
      pointerup: INPUT_END,
      pointercancel: INPUT_CANCEL,
      pointerout: INPUT_CANCEL
  };

  // in IE10 the pointer types is defined as an enum
  var IE10_POINTER_TYPE_ENUM = {
      2: INPUT_TYPE_TOUCH,
      3: INPUT_TYPE_PEN,
      4: INPUT_TYPE_MOUSE,
      5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
  };

  var POINTER_ELEMENT_EVENTS = 'pointerdown';
  var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

  // IE10 has prefixed support, and case-sensitive
  if (window.MSPointerEvent && !window.PointerEvent) {
      POINTER_ELEMENT_EVENTS = 'MSPointerDown';
      POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
  }

  /**
   * Pointer events input
   * @constructor
   * @extends Input
   */
  function PointerEventInput() {
      this.evEl = POINTER_ELEMENT_EVENTS;
      this.evWin = POINTER_WINDOW_EVENTS;

      Input.apply(this, arguments);

      this.store = (this.manager.session.pointerEvents = []);
  }

  inherit(PointerEventInput, Input, {
      /**
       * handle mouse events
       * @param {Object} ev
       */
      handler: function PEhandler(ev) {
          var store = this.store;
          var removePointer = false;

          var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
          var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
          var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

          var isTouch = (pointerType == INPUT_TYPE_TOUCH);

          // get index of the event in the store
          var storeIndex = inArray(store, ev.pointerId, 'pointerId');

          // start and mouse must be down
          if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
              if (storeIndex < 0) {
                  store.push(ev);
                  storeIndex = store.length - 1;
              }
          } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
              removePointer = true;
          }

          // it not found, so the pointer hasn't been down (so it's probably a hover)
          if (storeIndex < 0) {
              return;
          }

          // update the event in the store
          store[storeIndex] = ev;

          this.callback(this.manager, eventType, {
              pointers: store,
              changedPointers: [ev],
              pointerType: pointerType,
              srcEvent: ev
          });

          if (removePointer) {
              // remove from the store
              store.splice(storeIndex, 1);
          }
      }
  });

  var SINGLE_TOUCH_INPUT_MAP = {
      touchstart: INPUT_START,
      touchmove: INPUT_MOVE,
      touchend: INPUT_END,
      touchcancel: INPUT_CANCEL
  };

  var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
  var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

  /**
   * Touch events input
   * @constructor
   * @extends Input
   */
  function SingleTouchInput() {
      this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
      this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
      this.started = false;

      Input.apply(this, arguments);
  }

  inherit(SingleTouchInput, Input, {
      handler: function TEhandler(ev) {
          var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

          // should we handle the touch events?
          if (type === INPUT_START) {
              this.started = true;
          }

          if (!this.started) {
              return;
          }

          var touches = normalizeSingleTouches.call(this, ev, type);

          // when done, reset the started state
          if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
              this.started = false;
          }

          this.callback(this.manager, type, {
              pointers: touches[0],
              changedPointers: touches[1],
              pointerType: INPUT_TYPE_TOUCH,
              srcEvent: ev
          });
      }
  });

  /**
   * @this {TouchInput}
   * @param {Object} ev
   * @param {Number} type flag
   * @returns {undefined|Array} [all, changed]
   */
  function normalizeSingleTouches(ev, type) {
      var all = toArray(ev.touches);
      var changed = toArray(ev.changedTouches);

      if (type & (INPUT_END | INPUT_CANCEL)) {
          all = uniqueArray(all.concat(changed), 'identifier', true);
      }

      return [all, changed];
  }

  var TOUCH_INPUT_MAP = {
      touchstart: INPUT_START,
      touchmove: INPUT_MOVE,
      touchend: INPUT_END,
      touchcancel: INPUT_CANCEL
  };

  var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

  /**
   * Multi-user touch events input
   * @constructor
   * @extends Input
   */
  function TouchInput() {
      this.evTarget = TOUCH_TARGET_EVENTS;
      this.targetIds = {};

      Input.apply(this, arguments);
  }

  inherit(TouchInput, Input, {
      handler: function MTEhandler(ev) {
          var type = TOUCH_INPUT_MAP[ev.type];
          var touches = getTouches.call(this, ev, type);
          if (!touches) {
              return;
          }

          this.callback(this.manager, type, {
              pointers: touches[0],
              changedPointers: touches[1],
              pointerType: INPUT_TYPE_TOUCH,
              srcEvent: ev
          });
      }
  });

  /**
   * @this {TouchInput}
   * @param {Object} ev
   * @param {Number} type flag
   * @returns {undefined|Array} [all, changed]
   */
  function getTouches(ev, type) {
      var allTouches = toArray(ev.touches);
      var targetIds = this.targetIds;

      // when there is only one touch, the process can be simplified
      if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
          targetIds[allTouches[0].identifier] = true;
          return [allTouches, allTouches];
      }

      var i,
          targetTouches,
          changedTouches = toArray(ev.changedTouches),
          changedTargetTouches = [],
          target = this.target;

      // get target touches from touches
      targetTouches = allTouches.filter(function(touch) {
          return hasParent(touch.target, target);
      });

      // collect touches
      if (type === INPUT_START) {
          i = 0;
          while (i < targetTouches.length) {
              targetIds[targetTouches[i].identifier] = true;
              i++;
          }
      }

      // filter changed touches to only contain touches that exist in the collected target ids
      i = 0;
      while (i < changedTouches.length) {
          if (targetIds[changedTouches[i].identifier]) {
              changedTargetTouches.push(changedTouches[i]);
          }

          // cleanup removed touches
          if (type & (INPUT_END | INPUT_CANCEL)) {
              delete targetIds[changedTouches[i].identifier];
          }
          i++;
      }

      if (!changedTargetTouches.length) {
          return;
      }

      return [
          // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
          uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
          changedTargetTouches
      ];
  }

  /**
   * Combined touch and mouse input
   *
   * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
   * This because touch devices also emit mouse events while doing a touch.
   *
   * @constructor
   * @extends Input
   */
  function TouchMouseInput() {
      Input.apply(this, arguments);

      var handler = bindFn(this.handler, this);
      this.touch = new TouchInput(this.manager, handler);
      this.mouse = new MouseInput(this.manager, handler);
  }

  inherit(TouchMouseInput, Input, {
      /**
       * handle mouse and touch events
       * @param {Hammer} manager
       * @param {String} inputEvent
       * @param {Object} inputData
       */
      handler: function TMEhandler(manager, inputEvent, inputData) {
          var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
              isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

          // when we're in a touch event, so  block all upcoming mouse events
          // most mobile browser also emit mouseevents, right after touchstart
          if (isTouch) {
              this.mouse.allow = false;
          } else if (isMouse && !this.mouse.allow) {
              return;
          }

          // reset the allowMouse when we're done
          if (inputEvent & (INPUT_END | INPUT_CANCEL)) {
              this.mouse.allow = true;
          }

          this.callback(manager, inputEvent, inputData);
      },

      /**
       * remove the event listeners
       */
      destroy: function destroy() {
          this.touch.destroy();
          this.mouse.destroy();
      }
  });

  var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
  var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

  // magical touchAction value
  var TOUCH_ACTION_COMPUTE = 'compute';
  var TOUCH_ACTION_AUTO = 'auto';
  var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
  var TOUCH_ACTION_NONE = 'none';
  var TOUCH_ACTION_PAN_X = 'pan-x';
  var TOUCH_ACTION_PAN_Y = 'pan-y';

  /**
   * Touch Action
   * sets the touchAction property or uses the js alternative
   * @param {Manager} manager
   * @param {String} value
   * @constructor
   */
  function TouchAction(manager, value) {
      this.manager = manager;
      this.set(value);
  }

  TouchAction.prototype = {
      /**
       * set the touchAction value on the element or enable the polyfill
       * @param {String} value
       */
      set: function(value) {
          // find out the touch-action by the event handlers
          if (value == TOUCH_ACTION_COMPUTE) {
              value = this.compute();
          }

          if (NATIVE_TOUCH_ACTION && this.manager.element.style) {
              this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
          }
          this.actions = value.toLowerCase().trim();
      },

      /**
       * just re-set the touchAction value
       */
      update: function() {
          this.set(this.manager.options.touchAction);
      },

      /**
       * compute the value for the touchAction property based on the recognizer's settings
       * @returns {String} value
       */
      compute: function() {
          var actions = [];
          each(this.manager.recognizers, function(recognizer) {
              if (boolOrFn(recognizer.options.enable, [recognizer])) {
                  actions = actions.concat(recognizer.getTouchAction());
              }
          });
          return cleanTouchActions(actions.join(' '));
      },

      /**
       * this method is called on each input cycle and provides the preventing of the browser behavior
       * @param {Object} input
       */
      preventDefaults: function(input) {
          // not needed with native support for the touchAction property
          if (NATIVE_TOUCH_ACTION) {
              return;
          }

          var srcEvent = input.srcEvent;
          var direction = input.offsetDirection;

          // if the touch action did prevented once this session
          if (this.manager.session.prevented) {
              srcEvent.preventDefault();
              return;
          }

          var actions = this.actions;
          var hasNone = inStr(actions, TOUCH_ACTION_NONE);
          var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
          var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);

          if (hasNone) {
              //do not prevent defaults if this is a tap gesture

              var isTapPointer = input.pointers.length === 1;
              var isTapMovement = input.distance < 2;
              var isTapTouchTime = input.deltaTime < 250;

              if (isTapPointer && isTapMovement && isTapTouchTime) {
                  return;
              }
          }

          if (hasPanX && hasPanY) {
              // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
              return;
          }

          if (hasNone ||
              (hasPanY && direction & DIRECTION_HORIZONTAL) ||
              (hasPanX && direction & DIRECTION_VERTICAL)) {
              return this.preventSrc(srcEvent);
          }
      },

      /**
       * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
       * @param {Object} srcEvent
       */
      preventSrc: function(srcEvent) {
          this.manager.session.prevented = true;
          srcEvent.preventDefault();
      }
  };

  /**
   * when the touchActions are collected they are not a valid value, so we need to clean things up. *
   * @param {String} actions
   * @returns {*}
   */
  function cleanTouchActions(actions) {
      // none
      if (inStr(actions, TOUCH_ACTION_NONE)) {
          return TOUCH_ACTION_NONE;
      }

      var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
      var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

      // if both pan-x and pan-y are set (different recognizers
      // for different directions, e.g. horizontal pan but vertical swipe?)
      // we need none (as otherwise with pan-x pan-y combined none of these
      // recognizers will work, since the browser would handle all panning
      if (hasPanX && hasPanY) {
          return TOUCH_ACTION_NONE;
      }

      // pan-x OR pan-y
      if (hasPanX || hasPanY) {
          return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
      }

      // manipulation
      if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
          return TOUCH_ACTION_MANIPULATION;
      }

      return TOUCH_ACTION_AUTO;
  }

  /**
   * Recognizer flow explained; *
   * All recognizers have the initial state of POSSIBLE when a input session starts.
   * The definition of a input session is from the first input until the last input, with all it's movement in it. *
   * Example session for mouse-input: mousedown -> mousemove -> mouseup
   *
   * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
   * which determines with state it should be.
   *
   * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
   * POSSIBLE to give it another change on the next cycle.
   *
   *               Possible
   *                  |
   *            +-----+---------------+
   *            |                     |
   *      +-----+-----+               |
   *      |           |               |
   *   Failed      Cancelled          |
   *                          +-------+------+
   *                          |              |
   *                      Recognized       Began
   *                                         |
   *                                      Changed
   *                                         |
   *                                  Ended/Recognized
   */
  var STATE_POSSIBLE = 1;
  var STATE_BEGAN = 2;
  var STATE_CHANGED = 4;
  var STATE_ENDED = 8;
  var STATE_RECOGNIZED = STATE_ENDED;
  var STATE_CANCELLED = 16;
  var STATE_FAILED = 32;

  /**
   * Recognizer
   * Every recognizer needs to extend from this class.
   * @constructor
   * @param {Object} options
   */
  function Recognizer(options) {
      this.options = assign({}, this.defaults, options || {});

      this.id = uniqueId();

      this.manager = null;

      // default is enable true
      this.options.enable = ifUndefined(this.options.enable, true);

      this.state = STATE_POSSIBLE;

      this.simultaneous = {};
      this.requireFail = [];
  }

  Recognizer.prototype = {
      /**
       * @virtual
       * @type {Object}
       */
      defaults: {},

      /**
       * set options
       * @param {Object} options
       * @return {Recognizer}
       */
      set: function(options) {
          assign(this.options, options);

          // also update the touchAction, in case something changed about the directions/enabled state
          this.manager && this.manager.touchAction.update();
          return this;
      },

      /**
       * recognize simultaneous with an other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      recognizeWith: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
              return this;
          }

          var simultaneous = this.simultaneous;
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          if (!simultaneous[otherRecognizer.id]) {
              simultaneous[otherRecognizer.id] = otherRecognizer;
              otherRecognizer.recognizeWith(this);
          }
          return this;
      },

      /**
       * drop the simultaneous link. it doesnt remove the link on the other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      dropRecognizeWith: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
              return this;
          }

          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          delete this.simultaneous[otherRecognizer.id];
          return this;
      },

      /**
       * recognizer can only run when an other is failing
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      requireFailure: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
              return this;
          }

          var requireFail = this.requireFail;
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          if (inArray(requireFail, otherRecognizer) === -1) {
              requireFail.push(otherRecognizer);
              otherRecognizer.requireFailure(this);
          }
          return this;
      },

      /**
       * drop the requireFailure link. it does not remove the link on the other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      dropRequireFailure: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
              return this;
          }

          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          var index = inArray(this.requireFail, otherRecognizer);
          if (index > -1) {
              this.requireFail.splice(index, 1);
          }
          return this;
      },

      /**
       * has require failures boolean
       * @returns {boolean}
       */
      hasRequireFailures: function() {
          return this.requireFail.length > 0;
      },

      /**
       * if the recognizer can recognize simultaneous with an other recognizer
       * @param {Recognizer} otherRecognizer
       * @returns {Boolean}
       */
      canRecognizeWith: function(otherRecognizer) {
          return !!this.simultaneous[otherRecognizer.id];
      },

      /**
       * You should use `tryEmit` instead of `emit` directly to check
       * that all the needed recognizers has failed before emitting.
       * @param {Object} input
       */
      emit: function(input) {
          var self = this;
          var state = this.state;

          function emit(event) {
              self.manager.emit(event, input);
          }

          // 'panstart' and 'panmove'
          if (state < STATE_ENDED) {
              emit(self.options.event + stateStr(state));
          }

          emit(self.options.event); // simple 'eventName' events

          if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)
              emit(input.additionalEvent);
          }

          // panend and pancancel
          if (state >= STATE_ENDED) {
              emit(self.options.event + stateStr(state));
          }
      },

      /**
       * Check that all the require failure recognizers has failed,
       * if true, it emits a gesture event,
       * otherwise, setup the state to FAILED.
       * @param {Object} input
       */
      tryEmit: function(input) {
          if (this.canEmit()) {
              return this.emit(input);
          }
          // it's failing anyway
          this.state = STATE_FAILED;
      },

      /**
       * can we emit?
       * @returns {boolean}
       */
      canEmit: function() {
          var i = 0;
          while (i < this.requireFail.length) {
              if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                  return false;
              }
              i++;
          }
          return true;
      },

      /**
       * update the recognizer
       * @param {Object} inputData
       */
      recognize: function(inputData) {
          // make a new copy of the inputData
          // so we can change the inputData without messing up the other recognizers
          var inputDataClone = assign({}, inputData);

          // is is enabled and allow recognizing?
          if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
              this.reset();
              this.state = STATE_FAILED;
              return;
          }

          // reset when we've reached the end
          if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
              this.state = STATE_POSSIBLE;
          }

          this.state = this.process(inputDataClone);

          // the recognizer has recognized a gesture
          // so trigger an event
          if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
              this.tryEmit(inputDataClone);
          }
      },

      /**
       * return the state of the recognizer
       * the actual recognizing happens in this method
       * @virtual
       * @param {Object} inputData
       * @returns {Const} STATE
       */
      process: function(inputData) { }, // jshint ignore:line

      /**
       * return the preferred touch-action
       * @virtual
       * @returns {Array}
       */
      getTouchAction: function() { },

      /**
       * called when the gesture isn't allowed to recognize
       * like when another is being recognized or it is disabled
       * @virtual
       */
      reset: function() { }
  };

  /**
   * get a usable string, used as event postfix
   * @param {Const} state
   * @returns {String} state
   */
  function stateStr(state) {
      if (state & STATE_CANCELLED) {
          return 'cancel';
      } else if (state & STATE_ENDED) {
          return 'end';
      } else if (state & STATE_CHANGED) {
          return 'move';
      } else if (state & STATE_BEGAN) {
          return 'start';
      }
      return '';
  }

  /**
   * direction cons to string
   * @param {Const} direction
   * @returns {String}
   */
  function directionStr(direction) {
      if (direction == DIRECTION_DOWN) {
          return 'down';
      } else if (direction == DIRECTION_UP) {
          return 'up';
      } else if (direction == DIRECTION_LEFT) {
          return 'left';
      } else if (direction == DIRECTION_RIGHT) {
          return 'right';
      }
      return '';
  }

  /**
   * get a recognizer by name if it is bound to a manager
   * @param {Recognizer|String} otherRecognizer
   * @param {Recognizer} recognizer
   * @returns {Recognizer}
   */
  function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
      var manager = recognizer.manager;
      if (manager) {
          return manager.get(otherRecognizer);
      }
      return otherRecognizer;
  }

  /**
   * This recognizer is just used as a base for the simple attribute recognizers.
   * @constructor
   * @extends Recognizer
   */
  function AttrRecognizer() {
      Recognizer.apply(this, arguments);
  }

  inherit(AttrRecognizer, Recognizer, {
      /**
       * @namespace
       * @memberof AttrRecognizer
       */
      defaults: {
          /**
           * @type {Number}
           * @default 1
           */
          pointers: 1
      },

      /**
       * Used to check if it the recognizer receives valid input, like input.distance > 10.
       * @memberof AttrRecognizer
       * @param {Object} input
       * @returns {Boolean} recognized
       */
      attrTest: function(input) {
          var optionPointers = this.options.pointers;
          return optionPointers === 0 || input.pointers.length === optionPointers;
      },

      /**
       * Process the input and return the state for the recognizer
       * @memberof AttrRecognizer
       * @param {Object} input
       * @returns {*} State
       */
      process: function(input) {
          var state = this.state;
          var eventType = input.eventType;

          var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
          var isValid = this.attrTest(input);

          // on cancel input and we've recognized before, return STATE_CANCELLED
          if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
              return state | STATE_CANCELLED;
          } else if (isRecognized || isValid) {
              if (eventType & INPUT_END) {
                  return state | STATE_ENDED;
              } else if (!(state & STATE_BEGAN)) {
                  return STATE_BEGAN;
              }
              return state | STATE_CHANGED;
          }
          return STATE_FAILED;
      }
  });

  /**
   * Pan
   * Recognized when the pointer is down and moved in the allowed direction.
   * @constructor
   * @extends AttrRecognizer
   */
  function PanRecognizer() {
      AttrRecognizer.apply(this, arguments);

      this.pX = null;
      this.pY = null;
  }

  inherit(PanRecognizer, AttrRecognizer, {
      /**
       * @namespace
       * @memberof PanRecognizer
       */
      defaults: {
          event: 'pan',
          threshold: 10,
          pointers: 1,
          direction: DIRECTION_ALL
      },

      getTouchAction: function() {
          var direction = this.options.direction;
          var actions = [];
          if (direction & DIRECTION_HORIZONTAL) {
              actions.push(TOUCH_ACTION_PAN_Y);
          }
          if (direction & DIRECTION_VERTICAL) {
              actions.push(TOUCH_ACTION_PAN_X);
          }
          return actions;
      },

      directionTest: function(input) {
          var options = this.options;
          var hasMoved = true;
          var distance = input.distance;
          var direction = input.direction;
          var x = input.deltaX;
          var y = input.deltaY;

          // lock to axis?
          if (!(direction & options.direction)) {
              if (options.direction & DIRECTION_HORIZONTAL) {
                  direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                  hasMoved = x != this.pX;
                  distance = Math.abs(input.deltaX);
              } else {
                  direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                  hasMoved = y != this.pY;
                  distance = Math.abs(input.deltaY);
              }
          }
          input.direction = direction;
          return hasMoved && distance > options.threshold && direction & options.direction;
      },

      attrTest: function(input) {
          return AttrRecognizer.prototype.attrTest.call(this, input) &&
              (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
      },

      emit: function(input) {

          this.pX = input.deltaX;
          this.pY = input.deltaY;

          var direction = directionStr(input.direction);

          if (direction) {
              input.additionalEvent = this.options.event + direction;
          }
          this._super.emit.call(this, input);
      }
  });

  /**
   * Pinch
   * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
   * @constructor
   * @extends AttrRecognizer
   */
  function PinchRecognizer() {
      AttrRecognizer.apply(this, arguments);
  }

  inherit(PinchRecognizer, AttrRecognizer, {
      /**
       * @namespace
       * @memberof PinchRecognizer
       */
      defaults: {
          event: 'pinch',
          threshold: 0,
          pointers: 2
      },

      getTouchAction: function() {
          return [TOUCH_ACTION_NONE];
      },

      attrTest: function(input) {
          return this._super.attrTest.call(this, input) &&
              (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
      },

      emit: function(input) {
          if (input.scale !== 1) {
              var inOut = input.scale < 1 ? 'in' : 'out';
              input.additionalEvent = this.options.event + inOut;
          }
          this._super.emit.call(this, input);
      }
  });

  /**
   * Press
   * Recognized when the pointer is down for x ms without any movement.
   * @constructor
   * @extends Recognizer
   */
  function PressRecognizer() {
      Recognizer.apply(this, arguments);

      this._timer = null;
      this._input = null;
  }

  inherit(PressRecognizer, Recognizer, {
      /**
       * @namespace
       * @memberof PressRecognizer
       */
      defaults: {
          event: 'press',
          pointers: 1,
          time: 251, // minimal time of the pointer to be pressed
          threshold: 9 // a minimal movement is ok, but keep it low
      },

      getTouchAction: function() {
          return [TOUCH_ACTION_AUTO];
      },

      process: function(input) {
          var options = this.options;
          var validPointers = input.pointers.length === options.pointers;
          var validMovement = input.distance < options.threshold;
          var validTime = input.deltaTime > options.time;

          this._input = input;

          // we only allow little movement
          // and we've reached an end event, so a tap is possible
          if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
              this.reset();
          } else if (input.eventType & INPUT_START) {
              this.reset();
              this._timer = setTimeoutContext(function() {
                  this.state = STATE_RECOGNIZED;
                  this.tryEmit();
              }, options.time, this);
          } else if (input.eventType & INPUT_END) {
              return STATE_RECOGNIZED;
          }
          return STATE_FAILED;
      },

      reset: function() {
          clearTimeout(this._timer);
      },

      emit: function(input) {
          if (this.state !== STATE_RECOGNIZED) {
              return;
          }

          if (input && (input.eventType & INPUT_END)) {
              this.manager.emit(this.options.event + 'up', input);
          } else {
              this._input.timeStamp = now();
              this.manager.emit(this.options.event, this._input);
          }
      }
  });

  /**
   * Rotate
   * Recognized when two or more pointer are moving in a circular motion.
   * @constructor
   * @extends AttrRecognizer
   */
  function RotateRecognizer() {
      AttrRecognizer.apply(this, arguments);
  }

  inherit(RotateRecognizer, AttrRecognizer, {
      /**
       * @namespace
       * @memberof RotateRecognizer
       */
      defaults: {
          event: 'rotate',
          threshold: 0,
          pointers: 2
      },

      getTouchAction: function() {
          return [TOUCH_ACTION_NONE];
      },

      attrTest: function(input) {
          return this._super.attrTest.call(this, input) &&
              (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
      }
  });

  /**
   * Swipe
   * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
   * @constructor
   * @extends AttrRecognizer
   */
  function SwipeRecognizer() {
      AttrRecognizer.apply(this, arguments);
  }

  inherit(SwipeRecognizer, AttrRecognizer, {
      /**
       * @namespace
       * @memberof SwipeRecognizer
       */
      defaults: {
          event: 'swipe',
          threshold: 10,
          velocity: 0.3,
          direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
          pointers: 1
      },

      getTouchAction: function() {
          return PanRecognizer.prototype.getTouchAction.call(this);
      },

      attrTest: function(input) {
          var direction = this.options.direction;
          var velocity;

          if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
              velocity = input.overallVelocity;
          } else if (direction & DIRECTION_HORIZONTAL) {
              velocity = input.overallVelocityX;
          } else if (direction & DIRECTION_VERTICAL) {
              velocity = input.overallVelocityY;
          }

          return this._super.attrTest.call(this, input) &&
              direction & input.offsetDirection &&
              input.distance > this.options.threshold &&
              input.maxPointers == this.options.pointers &&
              abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
      },

      emit: function(input) {
          var direction = directionStr(input.offsetDirection);
          if (direction) {
              this.manager.emit(this.options.event + direction, input);
          }

          this.manager.emit(this.options.event, input);
      }
  });

  /**
   * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
   * between the given interval and position. The delay option can be used to recognize multi-taps without firing
   * a single tap.
   *
   * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
   * multi-taps being recognized.
   * @constructor
   * @extends Recognizer
   */
  function TapRecognizer() {
      Recognizer.apply(this, arguments);

      // previous time and center,
      // used for tap counting
      this.pTime = false;
      this.pCenter = false;

      this._timer = null;
      this._input = null;
      this.count = 0;
  }

  inherit(TapRecognizer, Recognizer, {
      /**
       * @namespace
       * @memberof PinchRecognizer
       */
      defaults: {
          event: 'tap',
          pointers: 1,
          taps: 1,
          interval: 300, // max time between the multi-tap taps
          time: 250, // max time of the pointer to be down (like finger on the screen)
          threshold: 9, // a minimal movement is ok, but keep it low
          posThreshold: 10 // a multi-tap can be a bit off the initial position
      },

      getTouchAction: function() {
          return [TOUCH_ACTION_MANIPULATION];
      },

      process: function(input) {
          var options = this.options;

          var validPointers = input.pointers.length === options.pointers;
          var validMovement = input.distance < options.threshold;
          var validTouchTime = input.deltaTime < options.time;

          this.reset();

          if ((input.eventType & INPUT_START) && (this.count === 0)) {
              return this.failTimeout();
          }

          // we only allow little movement
          // and we've reached an end event, so a tap is possible
          if (validMovement && validTouchTime && validPointers) {
              if (input.eventType != INPUT_END) {
                  return this.failTimeout();
              }

              var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
              var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

              this.pTime = input.timeStamp;
              this.pCenter = input.center;

              if (!validMultiTap || !validInterval) {
                  this.count = 1;
              } else {
                  this.count += 1;
              }

              this._input = input;

              // if tap count matches we have recognized it,
              // else it has began recognizing...
              var tapCount = this.count % options.taps;
              if (tapCount === 0) {
                  // no failing requirements, immediately trigger the tap event
                  // or wait as long as the multitap interval to trigger
                  if (!this.hasRequireFailures()) {
                      return STATE_RECOGNIZED;
                  } else {
                      this._timer = setTimeoutContext(function() {
                          this.state = STATE_RECOGNIZED;
                          this.tryEmit();
                      }, options.interval, this);
                      return STATE_BEGAN;
                  }
              }
          }
          return STATE_FAILED;
      },

      failTimeout: function() {
          this._timer = setTimeoutContext(function() {
              this.state = STATE_FAILED;
          }, this.options.interval, this);
          return STATE_FAILED;
      },

      reset: function() {
          clearTimeout(this._timer);
      },

      emit: function() {
          if (this.state == STATE_RECOGNIZED) {
              this._input.tapCount = this.count;
              this.manager.emit(this.options.event, this._input);
          }
      }
  });

  /**
   * Simple way to create a manager with a default set of recognizers.
   * @param {HTMLElement} element
   * @param {Object} [options]
   * @constructor
   */
  function Hammer(element, options) {
      options = options || {};
      options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
      return new Manager(element, options);
  }

  /**
   * @const {string}
   */
  Hammer.VERSION = '2.0.6';

  /**
   * default settings
   * @namespace
   */
  Hammer.defaults = {
      /**
       * set if DOM events are being triggered.
       * But this is slower and unused by simple implementations, so disabled by default.
       * @type {Boolean}
       * @default false
       */
      domEvents: false,

      /**
       * The value for the touchAction property/fallback.
       * When set to `compute` it will magically set the correct value based on the added recognizers.
       * @type {String}
       * @default compute
       */
      touchAction: TOUCH_ACTION_COMPUTE,

      /**
       * @type {Boolean}
       * @default true
       */
      enable: true,

      /**
       * EXPERIMENTAL FEATURE -- can be removed/changed
       * Change the parent input target element.
       * If Null, then it is being set the to main element.
       * @type {Null|EventTarget}
       * @default null
       */
      inputTarget: null,

      /**
       * force an input class
       * @type {Null|Function}
       * @default null
       */
      inputClass: null,

      /**
       * Default recognizer setup when calling `Hammer()`
       * When creating a new Manager these will be skipped.
       * @type {Array}
       */
      preset: [
          // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
          [RotateRecognizer, {enable: false}],
          [PinchRecognizer, {enable: false}, ['rotate']],
          [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
          [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],
          [TapRecognizer],
          [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],
          [PressRecognizer]
      ],

      /**
       * Some CSS properties can be used to improve the working of Hammer.
       * Add them to this method and they will be set when creating a new Manager.
       * @namespace
       */
      cssProps: {
          /**
           * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userSelect: 'none',

          /**
           * Disable the Windows Phone grippers when pressing an element.
           * @type {String}
           * @default 'none'
           */
          touchSelect: 'none',

          /**
           * Disables the default callout shown when you touch and hold a touch target.
           * On iOS, when you touch and hold a touch target such as a link, Safari displays
           * a callout containing information about the link. This property allows you to disable that callout.
           * @type {String}
           * @default 'none'
           */
          touchCallout: 'none',

          /**
           * Specifies whether zooming is enabled. Used by IE10>
           * @type {String}
           * @default 'none'
           */
          contentZooming: 'none',

          /**
           * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userDrag: 'none',

          /**
           * Overrides the highlight color shown when the user taps a link or a JavaScript
           * clickable element in iOS. This property obeys the alpha value, if specified.
           * @type {String}
           * @default 'rgba(0,0,0,0)'
           */
          tapHighlightColor: 'rgba(0,0,0,0)'
      }
  };

  var STOP = 1;
  var FORCED_STOP = 2;

  /**
   * Manager
   * @param {HTMLElement} element
   * @param {Object} [options]
   * @constructor
   */
  function Manager(element, options) {
      this.options = assign({}, Hammer.defaults, options || {});

      this.options.inputTarget = this.options.inputTarget || element;

      this.handlers = {};
      this.session = {};
      this.recognizers = [];

      this.element = element;
      this.input = createInputInstance(this);
      this.touchAction = new TouchAction(this, this.options.touchAction);

      toggleCssProps(this, true);

      each(this.options.recognizers, function(item) {
          var recognizer = this.add(new (item[0])(item[1]));
          item[2] && recognizer.recognizeWith(item[2]);
          item[3] && recognizer.requireFailure(item[3]);
      }, this);
  }

  Manager.prototype = {
      /**
       * set options
       * @param {Object} options
       * @returns {Manager}
       */
      set: function(options) {
          assign(this.options, options);

          // Options that need a little more setup
          if (options.touchAction) {
              this.touchAction.update();
          }
          if (options.inputTarget) {
              // Clean up existing event listeners and reinitialize
              this.input.destroy();
              this.input.target = options.inputTarget;
              this.input.init();
          }
          return this;
      },

      /**
       * stop recognizing for this session.
       * This session will be discarded, when a new [input]start event is fired.
       * When forced, the recognizer cycle is stopped immediately.
       * @param {Boolean} [force]
       */
      stop: function(force) {
          this.session.stopped = force ? FORCED_STOP : STOP;
      },

      /**
       * run the recognizers!
       * called by the inputHandler function on every movement of the pointers (touches)
       * it walks through all the recognizers and tries to detect the gesture that is being made
       * @param {Object} inputData
       */
      recognize: function(inputData) {
          var session = this.session;
          if (session.stopped) {
              return;
          }

          // run the touch-action polyfill
          this.touchAction.preventDefaults(inputData);

          var recognizer;
          var recognizers = this.recognizers;

          // this holds the recognizer that is being recognized.
          // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
          // if no recognizer is detecting a thing, it is set to `null`
          var curRecognizer = session.curRecognizer;

          // reset when the last recognizer is recognized
          // or when we're in a new session
          if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
              curRecognizer = session.curRecognizer = null;
          }

          var i = 0;
          while (i < recognizers.length) {
              recognizer = recognizers[i];

              // find out if we are allowed try to recognize the input for this one.
              // 1.   allow if the session is NOT forced stopped (see the .stop() method)
              // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
              //      that is being recognized.
              // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
              //      this can be setup with the `recognizeWith()` method on the recognizer.
              if (session.stopped !== FORCED_STOP && ( // 1
                      !curRecognizer || recognizer == curRecognizer || // 2
                      recognizer.canRecognizeWith(curRecognizer))) { // 3
                  recognizer.recognize(inputData);
              } else {
                  recognizer.reset();
              }

              // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
              // current active recognizer. but only if we don't already have an active recognizer
              if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                  curRecognizer = session.curRecognizer = recognizer;
              }
              i++;
          }
      },

      /**
       * get a recognizer by its event name.
       * @param {Recognizer|String} recognizer
       * @returns {Recognizer|Null}
       */
      get: function(recognizer) {
          if (recognizer instanceof Recognizer) {
              return recognizer;
          }

          var recognizers = this.recognizers;
          for (var i = 0; i < recognizers.length; i++) {
              if (recognizers[i].options.event == recognizer) {
                  return recognizers[i];
              }
          }
          return null;
      },

      /**
       * add a recognizer to the manager
       * existing recognizers with the same event name will be removed
       * @param {Recognizer} recognizer
       * @returns {Recognizer|Manager}
       */
      add: function(recognizer) {
          if (invokeArrayArg(recognizer, 'add', this)) {
              return this;
          }

          // remove existing
          var existing = this.get(recognizer.options.event);
          if (existing) {
              this.remove(existing);
          }

          this.recognizers.push(recognizer);
          recognizer.manager = this;

          this.touchAction.update();
          return recognizer;
      },

      /**
       * remove a recognizer by name or instance
       * @param {Recognizer|String} recognizer
       * @returns {Manager}
       */
      remove: function(recognizer) {
          if (invokeArrayArg(recognizer, 'remove', this)) {
              return this;
          }

          recognizer = this.get(recognizer);

          // let's make sure this recognizer exists
          if (recognizer) {
              var recognizers = this.recognizers;
              var index = inArray(recognizers, recognizer);

              if (index !== -1) {
                  recognizers.splice(index, 1);
                  this.touchAction.update();
              }
          }

          return this;
      },

      /**
       * bind event
       * @param {String} events
       * @param {Function} handler
       * @returns {EventEmitter} this
       */
      on: function(events, handler) {
          var handlers = this.handlers;
          each(splitStr(events), function(event) {
              handlers[event] = handlers[event] || [];
              handlers[event].push(handler);
          });
          return this;
      },

      /**
       * unbind event, leave emit blank to remove all handlers
       * @param {String} events
       * @param {Function} [handler]
       * @returns {EventEmitter} this
       */
      off: function(events, handler) {
          var handlers = this.handlers;
          each(splitStr(events), function(event) {
              if (!handler) {
                  delete handlers[event];
              } else {
                  handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
              }
          });
          return this;
      },

      /**
       * emit event to the listeners
       * @param {String} event
       * @param {Object} data
       */
      emit: function(event, data) {
          // we also want to trigger dom events
          if (this.options.domEvents) {
              triggerDomEvent(event, data);
          }

          // no handlers, so skip it all
          var handlers = this.handlers[event] && this.handlers[event].slice();
          if (!handlers || !handlers.length) {
              return;
          }

          data.type = event;
          data.preventDefault = function() {
              data.srcEvent.preventDefault();
          };

          var i = 0;
          while (i < handlers.length) {
              handlers[i](data);
              i++;
          }
      },

      /**
       * destroy the manager and unbinds all events
       * it doesn't unbind dom events, that is the user own responsibility
       */
      destroy: function() {
          this.element && toggleCssProps(this, false);

          this.handlers = {};
          this.session = {};
          this.input.destroy();
          this.element = null;
      }
  };

  /**
   * add/remove the css properties as defined in manager.options.cssProps
   * @param {Manager} manager
   * @param {Boolean} add
   */
  function toggleCssProps(manager, add) {
      var element = manager.element;
      if (!element.style) {
          return;
      }
      each(manager.options.cssProps, function(value, name) {
          element.style[prefixed(element.style, name)] = add ? value : '';
      });
  }

  /**
   * trigger dom event
   * @param {String} event
   * @param {Object} data
   */
  function triggerDomEvent(event, data) {
      var gestureEvent = document.createEvent('Event');
      gestureEvent.initEvent(event, true, true);
      gestureEvent.gesture = data;
      data.target.dispatchEvent(gestureEvent);
  }

  assign(Hammer, {
      INPUT_START: INPUT_START,
      INPUT_MOVE: INPUT_MOVE,
      INPUT_END: INPUT_END,
      INPUT_CANCEL: INPUT_CANCEL,

      STATE_POSSIBLE: STATE_POSSIBLE,
      STATE_BEGAN: STATE_BEGAN,
      STATE_CHANGED: STATE_CHANGED,
      STATE_ENDED: STATE_ENDED,
      STATE_RECOGNIZED: STATE_RECOGNIZED,
      STATE_CANCELLED: STATE_CANCELLED,
      STATE_FAILED: STATE_FAILED,

      DIRECTION_NONE: DIRECTION_NONE,
      DIRECTION_LEFT: DIRECTION_LEFT,
      DIRECTION_RIGHT: DIRECTION_RIGHT,
      DIRECTION_UP: DIRECTION_UP,
      DIRECTION_DOWN: DIRECTION_DOWN,
      DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
      DIRECTION_VERTICAL: DIRECTION_VERTICAL,
      DIRECTION_ALL: DIRECTION_ALL,

      Manager: Manager,
      Input: Input,
      TouchAction: TouchAction,

      TouchInput: TouchInput,
      MouseInput: MouseInput,
      PointerEventInput: PointerEventInput,
      TouchMouseInput: TouchMouseInput,
      SingleTouchInput: SingleTouchInput,

      Recognizer: Recognizer,
      AttrRecognizer: AttrRecognizer,
      Tap: TapRecognizer,
      Pan: PanRecognizer,
      Swipe: SwipeRecognizer,
      Pinch: PinchRecognizer,
      Rotate: RotateRecognizer,
      Press: PressRecognizer,

      on: addEventListeners,
      off: removeEventListeners,
      each: each,
      merge: merge,
      extend: extend,
      assign: assign,
      inherit: inherit,
      bindFn: bindFn,
      prefixed: prefixed
  });

  // this prevents errors when Hammer is loaded in the presence of an AMD
  //  style loader but by script tag, not by the loader.
  var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line
  freeGlobal.Hammer = Hammer;

  if (true) {
      !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
          return Hammer;
      }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof module != 'undefined' && module.exports) {
      module.exports = Hammer;
  } else {
      window[exportName] = Hammer;
  }

  })(window, document, 'Hammer');


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

  var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;"use strict";
  /**
   * Created by Alex on 11/6/2014.
   */

  // https://github.com/umdjs/umd/blob/master/returnExports.js#L40-L60
  // if the module has no dependencies, the above pattern can be simplified to
  (function (root, factory) {
    if (true) {
      // AMD. Register as an anonymous module.
      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if (typeof exports === 'object') {
      // Node. Does not work with strict CommonJS, but
      // only CommonJS-like environments that support module.exports,
      // like Node.
      module.exports = factory();
    } else {
      // Browser globals (root is window)
      root.keycharm = factory();
    }
  }(this, function () {

    function keycharm(options) {
      var preventDefault = options && options.preventDefault || false;

      var container = options && options.container || window;

      var _exportFunctions = {};
      var _bound = {keydown:{}, keyup:{}};
      var _keys = {};
      var i;

      // a - z
      for (i = 97; i <= 122; i++) {_keys[String.fromCharCode(i)] = {code:65 + (i - 97), shift: false};}
      // A - Z
      for (i = 65; i <= 90; i++) {_keys[String.fromCharCode(i)] = {code:i, shift: true};}
      // 0 - 9
      for (i = 0;  i <= 9;   i++) {_keys['' + i] = {code:48 + i, shift: false};}
      // F1 - F12
      for (i = 1;  i <= 12;   i++) {_keys['F' + i] = {code:111 + i, shift: false};}
      // num0 - num9
      for (i = 0;  i <= 9;   i++) {_keys['num' + i] = {code:96 + i, shift: false};}

      // numpad misc
      _keys['num*'] = {code:106, shift: false};
      _keys['num+'] = {code:107, shift: false};
      _keys['num-'] = {code:109, shift: false};
      _keys['num/'] = {code:111, shift: false};
      _keys['num.'] = {code:110, shift: false};
      // arrows
      _keys['left']  = {code:37, shift: false};
      _keys['up']    = {code:38, shift: false};
      _keys['right'] = {code:39, shift: false};
      _keys['down']  = {code:40, shift: false};
      // extra keys
      _keys['space'] = {code:32, shift: false};
      _keys['enter'] = {code:13, shift: false};
      _keys['shift'] = {code:16, shift: undefined};
      _keys['esc']   = {code:27, shift: false};
      _keys['backspace'] = {code:8, shift: false};
      _keys['tab']       = {code:9, shift: false};
      _keys['ctrl']      = {code:17, shift: false};
      _keys['alt']       = {code:18, shift: false};
      _keys['delete']    = {code:46, shift: false};
      _keys['pageup']    = {code:33, shift: false};
      _keys['pagedown']  = {code:34, shift: false};
      // symbols
      _keys['=']     = {code:187, shift: false};
      _keys['-']     = {code:189, shift: false};
      _keys[']']     = {code:221, shift: false};
      _keys['[']     = {code:219, shift: false};



      var down = function(event) {handleEvent(event,'keydown');};
      var up = function(event) {handleEvent(event,'keyup');};

      // handle the actualy bound key with the event
      var handleEvent = function(event,type) {
        if (_bound[type][event.keyCode] !== undefined) {
          var bound = _bound[type][event.keyCode];
          for (var i = 0; i < bound.length; i++) {
            if (bound[i].shift === undefined) {
              bound[i].fn(event);
            }
            else if (bound[i].shift == true && event.shiftKey == true) {
              bound[i].fn(event);
            }
            else if (bound[i].shift == false && event.shiftKey == false) {
              bound[i].fn(event);
            }
          }

          if (preventDefault == true) {
            event.preventDefault();
          }
        }
      };

      // bind a key to a callback
      _exportFunctions.bind = function(key, callback, type) {
        if (type === undefined) {
          type = 'keydown';
        }
        if (_keys[key] === undefined) {
          throw new Error("unsupported key: " + key);
        }
        if (_bound[type][_keys[key].code] === undefined) {
          _bound[type][_keys[key].code] = [];
        }
        _bound[type][_keys[key].code].push({fn:callback, shift:_keys[key].shift});
      };


      // bind all keys to a call back (demo purposes)
      _exportFunctions.bindAll = function(callback, type) {
        if (type === undefined) {
          type = 'keydown';
        }
        for (var key in _keys) {
          if (_keys.hasOwnProperty(key)) {
            _exportFunctions.bind(key,callback,type);
          }
        }
      };

      // get the key label from an event
      _exportFunctions.getKey = function(event) {
        for (var key in _keys) {
          if (_keys.hasOwnProperty(key)) {
            if (event.shiftKey == true && _keys[key].shift == true && event.keyCode == _keys[key].code) {
              return key;
            }
            else if (event.shiftKey == false && _keys[key].shift == false && event.keyCode == _keys[key].code) {
              return key;
            }
            else if (event.keyCode == _keys[key].code && key == 'shift') {
              return key;
            }
          }
        }
        return "unknown key, currently not supported";
      };

      // unbind either a specific callback from a key or all of them (by leaving callback undefined)
      _exportFunctions.unbind = function(key, callback, type) {
        if (type === undefined) {
          type = 'keydown';
        }
        if (_keys[key] === undefined) {
          throw new Error("unsupported key: " + key);
        }
        if (callback !== undefined) {
          var newBindings = [];
          var bound = _bound[type][_keys[key].code];
          if (bound !== undefined) {
            for (var i = 0; i < bound.length; i++) {
              if (!(bound[i].fn == callback && bound[i].shift == _keys[key].shift)) {
                newBindings.push(_bound[type][_keys[key].code][i]);
              }
            }
          }
          _bound[type][_keys[key].code] = newBindings;
        }
        else {
          _bound[type][_keys[key].code] = [];
        }
      };

      // reset all bound variables.
      _exportFunctions.reset = function() {
        _bound = {keydown:{}, keyup:{}};
      };

      // unbind all listeners and reset all variables.
      _exportFunctions.destroy = function() {
        _bound = {keydown:{}, keyup:{}};
        container.removeEventListener('keydown', down, true);
        container.removeEventListener('keyup', up, true);
      };

      // create listeners.
      container.addEventListener('keydown',down,true);
      container.addEventListener('keyup',up,true);

      // return the public functions.
      return _exportFunctions;
    }

    return keycharm;
  }));




/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  // utils
  exports.util = __webpack_require__(1);
  exports.DOMutil = __webpack_require__(8);

  // data
  exports.DataSet = __webpack_require__(9);
  exports.DataView = __webpack_require__(11);
  exports.Queue = __webpack_require__(10);

  // Timeline
  exports.Timeline = __webpack_require__(25);
  exports.Graph2d = __webpack_require__(50);
  exports.timeline = {
    Core: __webpack_require__(33),
    DateUtil: __webpack_require__(32),
    Range: __webpack_require__(30),
    stack: __webpack_require__(37),
    TimeStep: __webpack_require__(35),

    components: {
      items: {
        Item: __webpack_require__(39),
        BackgroundItem: __webpack_require__(43),
        BoxItem: __webpack_require__(41),
        PointItem: __webpack_require__(42),
        RangeItem: __webpack_require__(38)
      },

      BackgroundGroup: __webpack_require__(40),
      Component: __webpack_require__(31),
      CurrentTime: __webpack_require__(48),
      CustomTime: __webpack_require__(46),
      DataAxis: __webpack_require__(52),
      DataScale: __webpack_require__(53),
      GraphGroup: __webpack_require__(54),
      Group: __webpack_require__(36),
      ItemSet: __webpack_require__(34),
      Legend: __webpack_require__(58),
      LineGraph: __webpack_require__(51),
      TimeAxis: __webpack_require__(44)
    }
  };

  // bundled external libraries
  exports.moment = __webpack_require__(2);
  exports.Hammer = __webpack_require__(20);
  exports.keycharm = __webpack_require__(23);

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var _Configurator = __webpack_require__(26);

  var _Configurator2 = _interopRequireDefault(_Configurator);

  var _Validator = __webpack_require__(29);

  var _Validator2 = _interopRequireDefault(_Validator);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var Emitter = __webpack_require__(13);
  var Hammer = __webpack_require__(20);
  var moment = __webpack_require__(2);
  var util = __webpack_require__(1);
  var DataSet = __webpack_require__(9);
  var DataView = __webpack_require__(11);
  var Range = __webpack_require__(30);
  var Core = __webpack_require__(33);
  var TimeAxis = __webpack_require__(44);
  var CurrentTime = __webpack_require__(48);
  var CustomTime = __webpack_require__(46);
  var ItemSet = __webpack_require__(34);

  var printStyle = __webpack_require__(29).printStyle;
  var allOptions = __webpack_require__(49).allOptions;
  var configureOptions = __webpack_require__(49).configureOptions;

  /**
   * Create a timeline visualization
   * @param {HTMLElement} container
   * @param {vis.DataSet | vis.DataView | Array} [items]
   * @param {vis.DataSet | vis.DataView | Array} [groups]
   * @param {Object} [options]  See Timeline.setOptions for the available options.
   * @constructor
   * @extends Core
   */
  function Timeline(container, items, groups, options) {

    if (!(this instanceof Timeline)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    // if the third element is options, the forth is groups (optionally);
    if (!(Array.isArray(groups) || groups instanceof DataSet || groups instanceof DataView) && groups instanceof Object) {
      var forthArgument = options;
      options = groups;
      groups = forthArgument;
    }

    var me = this;
    this.defaultOptions = {
      start: null,
      end: null,

      autoResize: true,
      throttleRedraw: 0, // ms

      orientation: {
        axis: 'bottom', // axis orientation: 'bottom', 'top', or 'both'
        item: 'bottom' // not relevant
      },
      rtl: false,
      moment: moment,

      width: null,
      height: null,
      maxHeight: null,
      minHeight: null
    };
    this.options = util.deepExtend({}, this.defaultOptions);

    // Create the DOM, props, and emitter
    this._create(container);

    // all components listed here will be repainted automatically
    this.components = [];

    this.body = {
      dom: this.dom,
      domProps: this.props,
      emitter: {
        on: this.on.bind(this),
        off: this.off.bind(this),
        emit: this.emit.bind(this)
      },
      hiddenDates: [],
      util: {
        getScale: function getScale() {
          return me.timeAxis.step.scale;
        },
        getStep: function getStep() {
          return me.timeAxis.step.step;
        },

        toScreen: me._toScreen.bind(me),
        toGlobalScreen: me._toGlobalScreen.bind(me), // this refers to the root.width
        toTime: me._toTime.bind(me),
        toGlobalTime: me._toGlobalTime.bind(me)
      }
    };

    // range
    this.range = new Range(this.body);
    this.components.push(this.range);
    this.body.range = this.range;

    // time axis
    this.timeAxis = new TimeAxis(this.body);
    this.timeAxis2 = null; // used in case of orientation option 'both'
    this.components.push(this.timeAxis);

    // current time bar
    this.currentTime = new CurrentTime(this.body);
    this.components.push(this.currentTime);

    // item set
    this.itemSet = new ItemSet(this.body, this.options);
    this.components.push(this.itemSet);

    this.itemsData = null; // DataSet
    this.groupsData = null; // DataSet

    this.on('tap', function (event) {
      me.emit('click', me.getEventProperties(event));
    });
    this.on('doubletap', function (event) {
      me.emit('doubleClick', me.getEventProperties(event));
    });
    this.dom.root.oncontextmenu = function (event) {
      me.emit('contextmenu', me.getEventProperties(event));
    };

    //Single time autoscale/fit
    this.fitDone = false;
    this.on('changed', function () {
      if (this.itemsData == null) return;
      if (!me.fitDone) {
        me.fitDone = true;
        if (me.options.start != undefined || me.options.end != undefined) {
          if (me.options.start == undefined || me.options.end == undefined) {
            var range = me.getItemRange();
          }

          var start = me.options.start != undefined ? me.options.start : range.min;
          var end = me.options.end != undefined ? me.options.end : range.max;

          me.setWindow(start, end, { animation: false });
        } else {
          me.fit({ animation: false });
        }
      }
    });

    // apply options
    if (options) {
      this.setOptions(options);
    }

    // IMPORTANT: THIS HAPPENS BEFORE SET ITEMS!
    if (groups) {
      this.setGroups(groups);
    }

    // create itemset
    if (items) {
      this.setItems(items);
    }

    // draw for the first time
    this._redraw();
  }

  // Extend the functionality from Core
  Timeline.prototype = new Core();

  /**
   * Load a configurator
   * @return {Object}
   * @private
   */
  Timeline.prototype._createConfigurator = function () {
    return new _Configurator2.default(this, this.dom.container, configureOptions);
  };

  /**
   * Force a redraw. The size of all items will be recalculated.
   * Can be useful to manually redraw when option autoResize=false and the window
   * has been resized, or when the items CSS has been changed.
   *
   * Note: this function will be overridden on construction with a trottled version
   */
  Timeline.prototype.redraw = function () {
    this.itemSet && this.itemSet.markDirty({ refreshItems: true });
    this._redraw();
  };

  Timeline.prototype.setOptions = function (options) {
    // validate options
    var errorFound = _Validator2.default.validate(options, allOptions);

    if (errorFound === true) {
      console.log('%cErrors have been found in the supplied options object.', printStyle);
    }

    Core.prototype.setOptions.call(this, options);

    if ('type' in options) {
      if (options.type !== this.options.type) {
        this.options.type = options.type;

        // force recreation of all items
        var itemsData = this.itemsData;
        if (itemsData) {
          var selection = this.getSelection();
          this.setItems(null); // remove all
          this.setItems(itemsData); // add all
          this.setSelection(selection); // restore selection
        }
      }
    }
  };

  /**
   * Set items
   * @param {vis.DataSet | Array | null} items
   */
  Timeline.prototype.setItems = function (items) {
    // convert to type DataSet when needed
    var newDataSet;
    if (!items) {
      newDataSet = null;
    } else if (items instanceof DataSet || items instanceof DataView) {
      newDataSet = items;
    } else {
      // turn an array into a dataset
      newDataSet = new DataSet(items, {
        type: {
          start: 'Date',
          end: 'Date'
        }
      });
    }

    // set items
    this.itemsData = newDataSet;
    this.itemSet && this.itemSet.setItems(newDataSet);
  };

  /**
   * Set groups
   * @param {vis.DataSet | Array} groups
   */
  Timeline.prototype.setGroups = function (groups) {
    // convert to type DataSet when needed
    var newDataSet;
    if (!groups) {
      newDataSet = null;
    } else if (groups instanceof DataSet || groups instanceof DataView) {
      newDataSet = groups;
    } else {
      // turn an array into a dataset
      newDataSet = new DataSet(groups);
    }

    this.groupsData = newDataSet;
    this.itemSet.setGroups(newDataSet);
  };

  /**
   * Set both items and groups in one go
   * @param {{items: Array | vis.DataSet, groups: Array | vis.DataSet}} data
   */
  Timeline.prototype.setData = function (data) {
    if (data && data.groups) {
      this.setGroups(data.groups);
    }

    if (data && data.items) {
      this.setItems(data.items);
    }
  };

  /**
   * Set selected items by their id. Replaces the current selection
   * Unknown id's are silently ignored.
   * @param {string[] | string} [ids]  An array with zero or more id's of the items to be
   *                                selected. If ids is an empty array, all items will be
   *                                unselected.
   * @param {Object} [options]      Available options:
   *                                `focus: boolean`
   *                                    If true, focus will be set to the selected item(s)
   *                                `animation: boolean | {duration: number, easingFunction: string}`
   *                                    If true (default), the range is animated
   *                                    smoothly to the new window. An object can be
   *                                    provided to specify duration and easing function.
   *                                    Default duration is 500 ms, and default easing
   *                                    function is 'easeInOutQuad'.
   *                                    Only applicable when option focus is true.
   */
  Timeline.prototype.setSelection = function (ids, options) {
    this.itemSet && this.itemSet.setSelection(ids);

    if (options && options.focus) {
      this.focus(ids, options);
    }
  };

  /**
   * Get the selected items by their id
   * @return {Array} ids  The ids of the selected items
   */
  Timeline.prototype.getSelection = function () {
    return this.itemSet && this.itemSet.getSelection() || [];
  };

  /**
   * Adjust the visible window such that the selected item (or multiple items)
   * are centered on screen.
   * @param {String | String[]} id     An item id or array with item ids
   * @param {Object} [options]      Available options:
   *                                `animation: boolean | {duration: number, easingFunction: string}`
   *                                    If true (default), the range is animated
   *                                    smoothly to the new window. An object can be
   *                                    provided to specify duration and easing function.
   *                                    Default duration is 500 ms, and default easing
   *                                    function is 'easeInOutQuad'.
   */
  Timeline.prototype.focus = function (id, options) {
    if (!this.itemsData || id == undefined) return;

    var ids = Array.isArray(id) ? id : [id];

    // get the specified item(s)
    var itemsData = this.itemsData.getDataSet().get(ids, {
      type: {
        start: 'Date',
        end: 'Date'
      }
    });

    // calculate minimum start and maximum end of specified items
    var start = null;
    var end = null;
    itemsData.forEach(function (itemData) {
      var s = itemData.start.valueOf();
      var e = 'end' in itemData ? itemData.end.valueOf() : itemData.start.valueOf();

      if (start === null || s < start) {
        start = s;
      }

      if (end === null || e > end) {
        end = e;
      }
    });

    if (start !== null && end !== null) {
      // calculate the new middle and interval for the window
      var middle = (start + end) / 2;
      var interval = Math.max(this.range.end - this.range.start, (end - start) * 1.1);

      var animation = options && options.animation !== undefined ? options.animation : true;
      this.range.setRange(middle - interval / 2, middle + interval / 2, animation);
    }
  };

  /**
   * Set Timeline window such that it fits all items
   * @param {Object} [options]  Available options:
   *                                `animation: boolean | {duration: number, easingFunction: string}`
   *                                    If true (default), the range is animated
   *                                    smoothly to the new window. An object can be
   *                                    provided to specify duration and easing function.
   *                                    Default duration is 500 ms, and default easing
   *                                    function is 'easeInOutQuad'.
   */
  Timeline.prototype.fit = function (options) {
    var animation = options && options.animation !== undefined ? options.animation : true;
    var range;

    var dataset = this.itemsData && this.itemsData.getDataSet();
    if (dataset.length === 1 && dataset.get()[0].end === undefined) {
      // a single item -> don't fit, just show a range around the item from -4 to +3 days
      range = this.getDataRange();
      this.moveTo(range.min.valueOf(), { animation: animation });
    } else {
      // exactly fit the items (plus a small margin)
      range = this.getItemRange();
      this.range.setRange(range.min, range.max, animation);
    }
  };

  /**
   * Determine the range of the items, taking into account their actual width
   * and a margin of 10 pixels on both sides.
   * @return {{min: Date | null, max: Date | null}}
   */
  Timeline.prototype.getItemRange = function () {
    var _this = this;

    // get a rough approximation for the range based on the items start and end dates
    var range = this.getDataRange();
    var min = range.min !== null ? range.min.valueOf() : null;
    var max = range.max !== null ? range.max.valueOf() : null;
    var minItem = null;
    var maxItem = null;

    if (min != null && max != null) {
      var interval;
      var factor;
      var lhs;
      var rhs;
      var delta;

      (function () {
        var getStart = function getStart(item) {
          return util.convert(item.data.start, 'Date').valueOf();
        };

        var getEnd = function getEnd(item) {
          var end = item.data.end != undefined ? item.data.end : item.data.start;
          return util.convert(end, 'Date').valueOf();
        };

        // calculate the date of the left side and right side of the items given


        interval = max - min; // ms

        if (interval <= 0) {
          interval = 10;
        }
        factor = interval / _this.props.center.width;
        util.forEach(_this.itemSet.items, function (item) {
          item.show();
          item.repositionX();

          var start = getStart(item);
          var end = getEnd(item);

          if (this.options.rtl) {
            var startSide = start - (item.getWidthRight() + 10) * factor;
            var endSide = end + (item.getWidthLeft() + 10) * factor;
          } else {
            var startSide = start - (item.getWidthLeft() + 10) * factor;
            var endSide = end + (item.getWidthRight() + 10) * factor;
          }

          if (startSide < min) {
            min = startSide;
            minItem = item;
          }
          if (endSide > max) {
            max = endSide;
            maxItem = item;
          }
        }.bind(_this));

        if (minItem && maxItem) {
          lhs = minItem.getWidthLeft() + 10;
          rhs = maxItem.getWidthRight() + 10;
          delta = _this.props.center.width - lhs - rhs; // px

          if (delta > 0) {
            if (_this.options.rtl) {
              min = getStart(minItem) - rhs * interval / delta; // ms
              max = getEnd(maxItem) + lhs * interval / delta; // ms
            } else {
                min = getStart(minItem) - lhs * interval / delta; // ms
                max = getEnd(maxItem) + rhs * interval / delta; // ms
              }
          }
        }
      })();
    }

    return {
      min: min != null ? new Date(min) : null,
      max: max != null ? new Date(max) : null
    };
  };

  /**
   * Calculate the data range of the items start and end dates
   * @returns {{min: Date | null, max: Date | null}}
   */
  Timeline.prototype.getDataRange = function () {
    var min = null;
    var max = null;

    var dataset = this.itemsData && this.itemsData.getDataSet();
    if (dataset) {
      dataset.forEach(function (item) {
        var start = util.convert(item.start, 'Date').valueOf();
        var end = util.convert(item.end != undefined ? item.end : item.start, 'Date').valueOf();
        if (min === null || start < min) {
          min = start;
        }
        if (max === null || end > max) {
          max = end;
        }
      });
    }

    return {
      min: min != null ? new Date(min) : null,
      max: max != null ? new Date(max) : null
    };
  };

  /**
   * Generate Timeline related information from an event
   * @param {Event} event
   * @return {Object} An object with related information, like on which area
   *                  The event happened, whether clicked on an item, etc.
   */
  Timeline.prototype.getEventProperties = function (event) {
    var clientX = event.center ? event.center.x : event.clientX;
    var clientY = event.center ? event.center.y : event.clientY;
    if (this.options.rtl) {
      var x = util.getAbsoluteRight(this.dom.centerContainer) - clientX;
    } else {
      var x = clientX - util.getAbsoluteLeft(this.dom.centerContainer);
    }
    var y = clientY - util.getAbsoluteTop(this.dom.centerContainer);

    var item = this.itemSet.itemFromTarget(event);
    var group = this.itemSet.groupFromTarget(event);
    var customTime = CustomTime.customTimeFromTarget(event);

    var snap = this.itemSet.options.snap || null;
    var scale = this.body.util.getScale();
    var step = this.body.util.getStep();
    var time = this._toTime(x);
    var snappedTime = snap ? snap(time, scale, step) : time;

    var element = util.getTarget(event);
    var what = null;
    if (item != null) {
      what = 'item';
    } else if (customTime != null) {
      what = 'custom-time';
    } else if (util.hasParent(element, this.timeAxis.dom.foreground)) {
      what = 'axis';
    } else if (this.timeAxis2 && util.hasParent(element, this.timeAxis2.dom.foreground)) {
      what = 'axis';
    } else if (util.hasParent(element, this.itemSet.dom.labelSet)) {
      what = 'group-label';
    } else if (util.hasParent(element, this.currentTime.bar)) {
      what = 'current-time';
    } else if (util.hasParent(element, this.dom.center)) {
      what = 'background';
    }

    return {
      event: event,
      item: item ? item.id : null,
      group: group ? group.groupId : null,
      what: what,
      pageX: event.srcEvent ? event.srcEvent.pageX : event.pageX,
      pageY: event.srcEvent ? event.srcEvent.pageY : event.pageY,
      x: x,
      y: y,
      time: time,
      snappedTime: snappedTime
    };
  };

  module.exports = Timeline;

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _ColorPicker = __webpack_require__(27);

  var _ColorPicker2 = _interopRequireDefault(_ColorPicker);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);

  /**
   * The way this works is for all properties of this.possible options, you can supply the property name in any form to list the options.
   * Boolean options are recognised as Boolean
   * Number options should be written as array: [default value, min value, max value, stepsize]
   * Colors should be written as array: ['color', '#ffffff']
   * Strings with should be written as array: [option1, option2, option3, ..]
   *
   * The options are matched with their counterparts in each of the modules and the values used in the configuration are
   *
   * @param parentModule        | the location where parentModule.setOptions() can be called
   * @param defaultContainer    | the default container of the module
   * @param configureOptions    | the fully configured and predefined options set found in allOptions.js
   * @param pixelRatio          | canvas pixel ratio
   */

  var Configurator = function () {
    function Configurator(parentModule, defaultContainer, configureOptions) {
      var pixelRatio = arguments.length <= 3 || arguments[3] === undefined ? 1 : arguments[3];

      _classCallCheck(this, Configurator);

      this.parent = parentModule;
      this.changedOptions = [];
      this.container = defaultContainer;
      this.allowCreation = false;

      this.options = {};
      this.initialized = false;
      this.popupCounter = 0;
      this.defaultOptions = {
        enabled: false,
        filter: true,
        container: undefined,
        showButton: true
      };
      util.extend(this.options, this.defaultOptions);

      this.configureOptions = configureOptions;
      this.moduleOptions = {};
      this.domElements = [];
      this.popupDiv = {};
      this.popupLimit = 5;
      this.popupHistory = {};
      this.colorPicker = new _ColorPicker2.default(pixelRatio);
      this.wrapper = undefined;
    }

    /**
     * refresh all options.
     * Because all modules parse their options by themselves, we just use their options. We copy them here.
     *
     * @param options
     */


    _createClass(Configurator, [{
      key: 'setOptions',
      value: function setOptions(options) {
        if (options !== undefined) {
          // reset the popup history because the indices may have been changed.
          this.popupHistory = {};
          this._removePopup();

          var enabled = true;
          if (typeof options === 'string') {
            this.options.filter = options;
          } else if (options instanceof Array) {
            this.options.filter = options.join();
          } else if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
            if (options.container !== undefined) {
              this.options.container = options.container;
            }
            if (options.filter !== undefined) {
              this.options.filter = options.filter;
            }
            if (options.showButton !== undefined) {
              this.options.showButton = options.showButton;
            }
            if (options.enabled !== undefined) {
              enabled = options.enabled;
            }
          } else if (typeof options === 'boolean') {
            this.options.filter = true;
            enabled = options;
          } else if (typeof options === 'function') {
            this.options.filter = options;
            enabled = true;
          }
          if (this.options.filter === false) {
            enabled = false;
          }

          this.options.enabled = enabled;
        }
        this._clean();
      }
    }, {
      key: 'setModuleOptions',
      value: function setModuleOptions(moduleOptions) {
        this.moduleOptions = moduleOptions;
        if (this.options.enabled === true) {
          this._clean();
          if (this.options.container !== undefined) {
            this.container = this.options.container;
          }
          this._create();
        }
      }

      /**
       * Create all DOM elements
       * @private
       */

    }, {
      key: '_create',
      value: function _create() {
        var _this = this;

        this._clean();
        this.changedOptions = [];

        var filter = this.options.filter;
        var counter = 0;
        var show = false;
        for (var option in this.configureOptions) {
          if (this.configureOptions.hasOwnProperty(option)) {
            this.allowCreation = false;
            show = false;
            if (typeof filter === 'function') {
              show = filter(option, []);
              show = show || this._handleObject(this.configureOptions[option], [option], true);
            } else if (filter === true || filter.indexOf(option) !== -1) {
              show = true;
            }

            if (show !== false) {
              this.allowCreation = true;

              // linebreak between categories
              if (counter > 0) {
                this._makeItem([]);
              }
              // a header for the category
              this._makeHeader(option);

              // get the sub options
              this._handleObject(this.configureOptions[option], [option]);
            }
            counter++;
          }
        }

        if (this.options.showButton === true) {
          (function () {
            var generateButton = document.createElement('div');
            generateButton.className = 'vis-configuration vis-config-button';
            generateButton.innerHTML = 'generate options';
            generateButton.onclick = function () {
              _this._printOptions();
            };
            generateButton.onmouseover = function () {
              generateButton.className = 'vis-configuration vis-config-button hover';
            };
            generateButton.onmouseout = function () {
              generateButton.className = 'vis-configuration vis-config-button';
            };

            _this.optionsContainer = document.createElement('div');
            _this.optionsContainer.className = 'vis-configuration vis-config-option-container';

            _this.domElements.push(_this.optionsContainer);
            _this.domElements.push(generateButton);
          })();
        }

        this._push();
        //~ this.colorPicker.insertTo(this.container);
      }

      /**
       * draw all DOM elements on the screen
       * @private
       */

    }, {
      key: '_push',
      value: function _push() {
        this.wrapper = document.createElement('div');
        this.wrapper.className = 'vis-configuration-wrapper';
        this.container.appendChild(this.wrapper);
        for (var i = 0; i < this.domElements.length; i++) {
          this.wrapper.appendChild(this.domElements[i]);
        }

        this._showPopupIfNeeded();
      }

      /**
       * delete all DOM elements
       * @private
       */

    }, {
      key: '_clean',
      value: function _clean() {
        for (var i = 0; i < this.domElements.length; i++) {
          this.wrapper.removeChild(this.domElements[i]);
        }

        if (this.wrapper !== undefined) {
          this.container.removeChild(this.wrapper);
          this.wrapper = undefined;
        }
        this.domElements = [];

        this._removePopup();
      }

      /**
       * get the value from the actualOptions if it exists
       * @param {array} path    | where to look for the actual option
       * @returns {*}
       * @private
       */

    }, {
      key: '_getValue',
      value: function _getValue(path) {
        var base = this.moduleOptions;
        for (var i = 0; i < path.length; i++) {
          if (base[path[i]] !== undefined) {
            base = base[path[i]];
          } else {
            base = undefined;
            break;
          }
        }
        return base;
      }

      /**
       * all option elements are wrapped in an item
       * @param path
       * @param domElements
       * @private
       */

    }, {
      key: '_makeItem',
      value: function _makeItem(path) {
        var _arguments = arguments,
            _this2 = this;

        if (this.allowCreation === true) {
          var _len, domElements, _key;

          var _ret2 = function () {
            var item = document.createElement('div');
            item.className = 'vis-configuration vis-config-item vis-config-s' + path.length;

            for (_len = _arguments.length, domElements = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              domElements[_key - 1] = _arguments[_key];
            }

            domElements.forEach(function (element) {
              item.appendChild(element);
            });
            _this2.domElements.push(item);
            return {
              v: _this2.domElements.length
            };
          }();

          if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === "object") return _ret2.v;
        }
        return 0;
      }

      /**
       * header for major subjects
       * @param name
       * @private
       */

    }, {
      key: '_makeHeader',
      value: function _makeHeader(name) {
        var div = document.createElement('div');
        div.className = 'vis-configuration vis-config-header';
        div.innerHTML = name;
        this._makeItem([], div);
      }

      /**
       * make a label, if it is an object label, it gets different styling.
       * @param name
       * @param path
       * @param objectLabel
       * @returns {HTMLElement}
       * @private
       */

    }, {
      key: '_makeLabel',
      value: function _makeLabel(name, path) {
        var objectLabel = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

        var div = document.createElement('div');
        div.className = 'vis-configuration vis-config-label vis-config-s' + path.length;
        if (objectLabel === true) {
          div.innerHTML = '<i><b>' + name + ':</b></i>';
        } else {
          div.innerHTML = name + ':';
        }
        return div;
      }

      /**
       * make a dropdown list for multiple possible string optoins
       * @param arr
       * @param value
       * @param path
       * @private
       */

    }, {
      key: '_makeDropdown',
      value: function _makeDropdown(arr, value, path) {
        var select = document.createElement('select');
        select.className = 'vis-configuration vis-config-select';
        var selectedValue = 0;
        if (value !== undefined) {
          if (arr.indexOf(value) !== -1) {
            selectedValue = arr.indexOf(value);
          }
        }

        for (var i = 0; i < arr.length; i++) {
          var option = document.createElement('option');
          option.value = arr[i];
          if (i === selectedValue) {
            option.selected = 'selected';
          }
          option.innerHTML = arr[i];
          select.appendChild(option);
        }

        var me = this;
        select.onchange = function () {
          me._update(this.value, path);
        };

        var label = this._makeLabel(path[path.length - 1], path);
        this._makeItem(path, label, select);
      }

      /**
       * make a range object for numeric options
       * @param arr
       * @param value
       * @param path
       * @private
       */

    }, {
      key: '_makeRange',
      value: function _makeRange(arr, value, path) {
        var defaultValue = arr[0];
        var min = arr[1];
        var max = arr[2];
        var step = arr[3];
        var range = document.createElement('input');
        range.className = 'vis-configuration vis-config-range';
        try {
          range.type = 'range'; // not supported on IE9
          range.min = min;
          range.max = max;
        } catch (err) {}
        range.step = step;

        // set up the popup settings in case they are needed.
        var popupString = '';
        var popupValue = 0;

        if (value !== undefined) {
          var factor = 1.20;
          if (value < 0 && value * factor < min) {
            range.min = Math.ceil(value * factor);
            popupValue = range.min;
            popupString = 'range increased';
          } else if (value / factor < min) {
            range.min = Math.ceil(value / factor);
            popupValue = range.min;
            popupString = 'range increased';
          }
          if (value * factor > max && max !== 1) {
            range.max = Math.ceil(value * factor);
            popupValue = range.max;
            popupString = 'range increased';
          }
          range.value = value;
        } else {
          range.value = defaultValue;
        }

        var input = document.createElement('input');
        input.className = 'vis-configuration vis-config-rangeinput';
        input.value = range.value;

        var me = this;
        range.onchange = function () {
          input.value = this.value;me._update(Number(this.value), path);
        };
        range.oninput = function () {
          input.value = this.value;
        };

        var label = this._makeLabel(path[path.length - 1], path);
        var itemIndex = this._makeItem(path, label, range, input);

        // if a popup is needed AND it has not been shown for this value, show it.
        if (popupString !== '' && this.popupHistory[itemIndex] !== popupValue) {
          this.popupHistory[itemIndex] = popupValue;
          this._setupPopup(popupString, itemIndex);
        }
      }

      /**
       * prepare the popup
       * @param string
       * @param index
       * @private
       */

    }, {
      key: '_setupPopup',
      value: function _setupPopup(string, index) {
        var _this3 = this;

        if (this.initialized === true && this.allowCreation === true && this.popupCounter < this.popupLimit) {
          var div = document.createElement("div");
          div.id = "vis-configuration-popup";
          div.className = "vis-configuration-popup";
          div.innerHTML = string;
          div.onclick = function () {
            _this3._removePopup();
          };
          this.popupCounter += 1;
          this.popupDiv = { html: div, index: index };
        }
      }

      /**
       * remove the popup from the dom
       * @private
       */

    }, {
      key: '_removePopup',
      value: function _removePopup() {
        if (this.popupDiv.html !== undefined) {
          this.popupDiv.html.parentNode.removeChild(this.popupDiv.html);
          clearTimeout(this.popupDiv.hideTimeout);
          clearTimeout(this.popupDiv.deleteTimeout);
          this.popupDiv = {};
        }
      }

      /**
       * Show the popup if it is needed.
       * @private
       */

    }, {
      key: '_showPopupIfNeeded',
      value: function _showPopupIfNeeded() {
        var _this4 = this;

        if (this.popupDiv.html !== undefined) {
          var correspondingElement = this.domElements[this.popupDiv.index];
          var rect = correspondingElement.getBoundingClientRect();
          this.popupDiv.html.style.left = rect.left + "px";
          this.popupDiv.html.style.top = rect.top - 30 + "px"; // 30 is the height;
          document.body.appendChild(this.popupDiv.html);
          this.popupDiv.hideTimeout = setTimeout(function () {
            _this4.popupDiv.html.style.opacity = 0;
          }, 1500);
          this.popupDiv.deleteTimeout = setTimeout(function () {
            _this4._removePopup();
          }, 1800);
        }
      }

      /**
       * make a checkbox for boolean options.
       * @param defaultValue
       * @param value
       * @param path
       * @private
       */

    }, {
      key: '_makeCheckbox',
      value: function _makeCheckbox(defaultValue, value, path) {
        var checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'vis-configuration vis-config-checkbox';
        checkbox.checked = defaultValue;
        if (value !== undefined) {
          checkbox.checked = value;
          if (value !== defaultValue) {
            if ((typeof defaultValue === 'undefined' ? 'undefined' : _typeof(defaultValue)) === 'object') {
              if (value !== defaultValue.enabled) {
                this.changedOptions.push({ path: path, value: value });
              }
            } else {
              this.changedOptions.push({ path: path, value: value });
            }
          }
        }

        var me = this;
        checkbox.onchange = function () {
          me._update(this.checked, path);
        };

        var label = this._makeLabel(path[path.length - 1], path);
        this._makeItem(path, label, checkbox);
      }

      /**
       * make a text input field for string options.
       * @param defaultValue
       * @param value
       * @param path
       * @private
       */

    }, {
      key: '_makeTextInput',
      value: function _makeTextInput(defaultValue, value, path) {
        var checkbox = document.createElement('input');
        checkbox.type = 'text';
        checkbox.className = 'vis-configuration vis-config-text';
        checkbox.value = value;
        if (value !== defaultValue) {
          this.changedOptions.push({ path: path, value: value });
        }

        var me = this;
        checkbox.onchange = function () {
          me._update(this.value, path);
        };

        var label = this._makeLabel(path[path.length - 1], path);
        this._makeItem(path, label, checkbox);
      }

      /**
       * make a color field with a color picker for color fields
       * @param arr
       * @param value
       * @param path
       * @private
       */

    }, {
      key: '_makeColorField',
      value: function _makeColorField(arr, value, path) {
        var _this5 = this;

        var defaultColor = arr[1];
        var div = document.createElement('div');
        value = value === undefined ? defaultColor : value;

        if (value !== 'none') {
          div.className = 'vis-configuration vis-config-colorBlock';
          div.style.backgroundColor = value;
        } else {
          div.className = 'vis-configuration vis-config-colorBlock none';
        }

        value = value === undefined ? defaultColor : value;
        div.onclick = function () {
          _this5._showColorPicker(value, div, path);
        };

        var label = this._makeLabel(path[path.length - 1], path);
        this._makeItem(path, label, div);
      }

      /**
       * used by the color buttons to call the color picker.
       * @param event
       * @param value
       * @param div
       * @param path
       * @private
       */

    }, {
      key: '_showColorPicker',
      value: function _showColorPicker(value, div, path) {
        var _this6 = this;

        // clear the callback from this div
        div.onclick = function () {};

        this.colorPicker.insertTo(div);
        this.colorPicker.show();

        this.colorPicker.setColor(value);
        this.colorPicker.setUpdateCallback(function (color) {
          var colorString = 'rgba(' + color.r + ',' + color.g + ',' + color.b + ',' + color.a + ')';
          div.style.backgroundColor = colorString;
          _this6._update(colorString, path);
        });

        // on close of the colorpicker, restore the callback.
        this.colorPicker.setCloseCallback(function () {
          div.onclick = function () {
            _this6._showColorPicker(value, div, path);
          };
        });
      }

      /**
       * parse an object and draw the correct items
       * @param obj
       * @param path
       * @private
       */

    }, {
      key: '_handleObject',
      value: function _handleObject(obj) {
        var path = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
        var checkOnly = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

        var show = false;
        var filter = this.options.filter;
        var visibleInSet = false;
        for (var subObj in obj) {
          if (obj.hasOwnProperty(subObj)) {
            show = true;
            var item = obj[subObj];
            var newPath = util.copyAndExtendArray(path, subObj);
            if (typeof filter === 'function') {
              show = filter(subObj, path);

              // if needed we must go deeper into the object.
              if (show === false) {
                if (!(item instanceof Array) && typeof item !== 'string' && typeof item !== 'boolean' && item instanceof Object) {
                  this.allowCreation = false;
                  show = this._handleObject(item, newPath, true);
                  this.allowCreation = checkOnly === false;
                }
              }
            }

            if (show !== false) {
              visibleInSet = true;
              var value = this._getValue(newPath);

              if (item instanceof Array) {
                this._handleArray(item, value, newPath);
              } else if (typeof item === 'string') {
                this._makeTextInput(item, value, newPath);
              } else if (typeof item === 'boolean') {
                this._makeCheckbox(item, value, newPath);
              } else if (item instanceof Object) {
                // collapse the physics options that are not enabled
                var draw = true;
                if (path.indexOf('physics') !== -1) {
                  if (this.moduleOptions.physics.solver !== subObj) {
                    draw = false;
                  }
                }

                if (draw === true) {
                  // initially collapse options with an disabled enabled option.
                  if (item.enabled !== undefined) {
                    var enabledPath = util.copyAndExtendArray(newPath, 'enabled');
                    var enabledValue = this._getValue(enabledPath);
                    if (enabledValue === true) {
                      var label = this._makeLabel(subObj, newPath, true);
                      this._makeItem(newPath, label);
                      visibleInSet = this._handleObject(item, newPath) || visibleInSet;
                    } else {
                      this._makeCheckbox(item, enabledValue, newPath);
                    }
                  } else {
                    var _label = this._makeLabel(subObj, newPath, true);
                    this._makeItem(newPath, _label);
                    visibleInSet = this._handleObject(item, newPath) || visibleInSet;
                  }
                }
              } else {
                console.error('dont know how to handle', item, subObj, newPath);
              }
            }
          }
        }
        return visibleInSet;
      }

      /**
       * handle the array type of option
       * @param optionName
       * @param arr
       * @param value
       * @param path
       * @private
       */

    }, {
      key: '_handleArray',
      value: function _handleArray(arr, value, path) {
        if (typeof arr[0] === 'string' && arr[0] === 'color') {
          this._makeColorField(arr, value, path);
          if (arr[1] !== value) {
            this.changedOptions.push({ path: path, value: value });
          }
        } else if (typeof arr[0] === 'string') {
          this._makeDropdown(arr, value, path);
          if (arr[0] !== value) {
            this.changedOptions.push({ path: path, value: value });
          }
        } else if (typeof arr[0] === 'number') {
          this._makeRange(arr, value, path);
          if (arr[0] !== value) {
            this.changedOptions.push({ path: path, value: Number(value) });
          }
        }
      }

      /**
       * called to update the network with the new settings.
       * @param value
       * @param path
       * @private
       */

    }, {
      key: '_update',
      value: function _update(value, path) {
        var options = this._constructOptions(value, path);

        if (this.parent.body && this.parent.body.emitter && this.parent.body.emitter.emit) {
          this.parent.body.emitter.emit("configChange", options);
        }
        this.initialized = true;
        this.parent.setOptions(options);
      }
    }, {
      key: '_constructOptions',
      value: function _constructOptions(value, path) {
        var optionsObj = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

        var pointer = optionsObj;

        // when dropdown boxes can be string or boolean, we typecast it into correct types
        value = value === 'true' ? true : value;
        value = value === 'false' ? false : value;

        for (var i = 0; i < path.length; i++) {
          if (path[i] !== 'global') {
            if (pointer[path[i]] === undefined) {
              pointer[path[i]] = {};
            }
            if (i !== path.length - 1) {
              pointer = pointer[path[i]];
            } else {
              pointer[path[i]] = value;
            }
          }
        }
        return optionsObj;
      }
    }, {
      key: '_printOptions',
      value: function _printOptions() {
        var options = this.getOptions();
        this.optionsContainer.innerHTML = '<pre>var options = ' + JSON.stringify(options, null, 2) + '</pre>';
      }
    }, {
      key: 'getOptions',
      value: function getOptions() {
        var options = {};
        for (var i = 0; i < this.changedOptions.length; i++) {
          this._constructOptions(this.changedOptions[i].value, this.changedOptions[i].path, options);
        }
        return options;
      }
    }]);

    return Configurator;
  }();

  exports.default = Configurator;

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var Hammer = __webpack_require__(20);
  var hammerUtil = __webpack_require__(28);
  var util = __webpack_require__(1);

  var ColorPicker = function () {
    function ColorPicker() {
      var pixelRatio = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];

      _classCallCheck(this, ColorPicker);

      this.pixelRatio = pixelRatio;
      this.generated = false;
      this.centerCoordinates = { x: 289 / 2, y: 289 / 2 };
      this.r = 289 * 0.49;
      this.color = { r: 255, g: 255, b: 255, a: 1.0 };
      this.hueCircle = undefined;
      this.initialColor = { r: 255, g: 255, b: 255, a: 1.0 };
      this.previousColor = undefined;
      this.applied = false;

      // bound by
      this.updateCallback = function () {};
      this.closeCallback = function () {};

      // create all DOM elements
      this._create();
    }

    /**
     * this inserts the colorPicker into a div from the DOM
     * @param container
     */


    _createClass(ColorPicker, [{
      key: 'insertTo',
      value: function insertTo(container) {
        if (this.hammer !== undefined) {
          this.hammer.destroy();
          this.hammer = undefined;
        }
        this.container = container;
        this.container.appendChild(this.frame);
        this._bindHammer();

        this._setSize();
      }

      /**
       * the callback is executed on apply and save. Bind it to the application
       * @param callback
       */

    }, {
      key: 'setUpdateCallback',
      value: function setUpdateCallback(callback) {
        if (typeof callback === 'function') {
          this.updateCallback = callback;
        } else {
          throw new Error("Function attempted to set as colorPicker update callback is not a function.");
        }
      }

      /**
       * the callback is executed on apply and save. Bind it to the application
       * @param callback
       */

    }, {
      key: 'setCloseCallback',
      value: function setCloseCallback(callback) {
        if (typeof callback === 'function') {
          this.closeCallback = callback;
        } else {
          throw new Error("Function attempted to set as colorPicker closing callback is not a function.");
        }
      }
    }, {
      key: '_isColorString',
      value: function _isColorString(color) {
        var htmlColors = { black: '#000000', navy: '#000080', darkblue: '#00008B', mediumblue: '#0000CD', blue: '#0000FF', darkgreen: '#006400', green: '#008000', teal: '#008080', darkcyan: '#008B8B', deepskyblue: '#00BFFF', darkturquoise: '#00CED1', mediumspringgreen: '#00FA9A', lime: '#00FF00', springgreen: '#00FF7F', aqua: '#00FFFF', cyan: '#00FFFF', midnightblue: '#191970', dodgerblue: '#1E90FF', lightseagreen: '#20B2AA', forestgreen: '#228B22', seagreen: '#2E8B57', darkslategray: '#2F4F4F', limegreen: '#32CD32', mediumseagreen: '#3CB371', turquoise: '#40E0D0', royalblue: '#4169E1', steelblue: '#4682B4', darkslateblue: '#483D8B', mediumturquoise: '#48D1CC', indigo: '#4B0082', darkolivegreen: '#556B2F', cadetblue: '#5F9EA0', cornflowerblue: '#6495ED', mediumaquamarine: '#66CDAA', dimgray: '#696969', slateblue: '#6A5ACD', olivedrab: '#6B8E23', slategray: '#708090', lightslategray: '#778899', mediumslateblue: '#7B68EE', lawngreen: '#7CFC00', chartreuse: '#7FFF00', aquamarine: '#7FFFD4', maroon: '#800000', purple: '#800080', olive: '#808000', gray: '#808080', skyblue: '#87CEEB', lightskyblue: '#87CEFA', blueviolet: '#8A2BE2', darkred: '#8B0000', darkmagenta: '#8B008B', saddlebrown: '#8B4513', darkseagreen: '#8FBC8F', lightgreen: '#90EE90', mediumpurple: '#9370D8', darkviolet: '#9400D3', palegreen: '#98FB98', darkorchid: '#9932CC', yellowgreen: '#9ACD32', sienna: '#A0522D', brown: '#A52A2A', darkgray: '#A9A9A9', lightblue: '#ADD8E6', greenyellow: '#ADFF2F', paleturquoise: '#AFEEEE', lightsteelblue: '#B0C4DE', powderblue: '#B0E0E6', firebrick: '#B22222', darkgoldenrod: '#B8860B', mediumorchid: '#BA55D3', rosybrown: '#BC8F8F', darkkhaki: '#BDB76B', silver: '#C0C0C0', mediumvioletred: '#C71585', indianred: '#CD5C5C', peru: '#CD853F', chocolate: '#D2691E', tan: '#D2B48C', lightgrey: '#D3D3D3', palevioletred: '#D87093', thistle: '#D8BFD8', orchid: '#DA70D6', goldenrod: '#DAA520', crimson: '#DC143C', gainsboro: '#DCDCDC', plum: '#DDA0DD', burlywood: '#DEB887', lightcyan: '#E0FFFF', lavender: '#E6E6FA', darksalmon: '#E9967A', violet: '#EE82EE', palegoldenrod: '#EEE8AA', lightcoral: '#F08080', khaki: '#F0E68C', aliceblue: '#F0F8FF', honeydew: '#F0FFF0', azure: '#F0FFFF', sandybrown: '#F4A460', wheat: '#F5DEB3', beige: '#F5F5DC', whitesmoke: '#F5F5F5', mintcream: '#F5FFFA', ghostwhite: '#F8F8FF', salmon: '#FA8072', antiquewhite: '#FAEBD7', linen: '#FAF0E6', lightgoldenrodyellow: '#FAFAD2', oldlace: '#FDF5E6', red: '#FF0000', fuchsia: '#FF00FF', magenta: '#FF00FF', deeppink: '#FF1493', orangered: '#FF4500', tomato: '#FF6347', hotpink: '#FF69B4', coral: '#FF7F50', darkorange: '#FF8C00', lightsalmon: '#FFA07A', orange: '#FFA500', lightpink: '#FFB6C1', pink: '#FFC0CB', gold: '#FFD700', peachpuff: '#FFDAB9', navajowhite: '#FFDEAD', moccasin: '#FFE4B5', bisque: '#FFE4C4', mistyrose: '#FFE4E1', blanchedalmond: '#FFEBCD', papayawhip: '#FFEFD5', lavenderblush: '#FFF0F5', seashell: '#FFF5EE', cornsilk: '#FFF8DC', lemonchiffon: '#FFFACD', floralwhite: '#FFFAF0', snow: '#FFFAFA', yellow: '#FFFF00', lightyellow: '#FFFFE0', ivory: '#FFFFF0', white: '#FFFFFF' };
        if (typeof color === 'string') {
          return htmlColors[color];
        }
      }

      /**
       * Set the color of the colorPicker
       * Supported formats:
       * 'red'                   --> HTML color string
       * '#ffffff'               --> hex string
       * 'rbg(255,255,255)'      --> rgb string
       * 'rgba(255,255,255,1.0)' --> rgba string
       * {r:255,g:255,b:255}     --> rgb object
       * {r:255,g:255,b:255,a:1.0} --> rgba object
       * @param color
       * @param setInitial
       */

    }, {
      key: 'setColor',
      value: function setColor(color) {
        var setInitial = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

        if (color === 'none') {
          return;
        }

        var rgba = void 0;

        // if a html color shorthand is used, convert to hex
        var htmlColor = this._isColorString(color);
        if (htmlColor !== undefined) {
          color = htmlColor;
        }

        // check format
        if (util.isString(color) === true) {
          if (util.isValidRGB(color) === true) {
            var rgbaArray = color.substr(4).substr(0, color.length - 5).split(',');
            rgba = { r: rgbaArray[0], g: rgbaArray[1], b: rgbaArray[2], a: 1.0 };
          } else if (util.isValidRGBA(color) === true) {
            var _rgbaArray = color.substr(5).substr(0, color.length - 6).split(',');
            rgba = { r: _rgbaArray[0], g: _rgbaArray[1], b: _rgbaArray[2], a: _rgbaArray[3] };
          } else if (util.isValidHex(color) === true) {
            var rgbObj = util.hexToRGB(color);
            rgba = { r: rgbObj.r, g: rgbObj.g, b: rgbObj.b, a: 1.0 };
          }
        } else {
          if (color instanceof Object) {
            if (color.r !== undefined && color.g !== undefined && color.b !== undefined) {
              var alpha = color.a !== undefined ? color.a : '1.0';
              rgba = { r: color.r, g: color.g, b: color.b, a: alpha };
            }
          }
        }

        // set color
        if (rgba === undefined) {
          throw new Error("Unknown color passed to the colorPicker. Supported are strings: rgb, hex, rgba. Object: rgb ({r:r,g:g,b:b,[a:a]}). Supplied: " + JSON.stringify(color));
        } else {
          this._setColor(rgba, setInitial);
        }
      }

      /**
       * this shows the color picker.
       * The hue circle is constructed once and stored.
       */

    }, {
      key: 'show',
      value: function show() {
        if (this.closeCallback !== undefined) {
          this.closeCallback();
          this.closeCallback = undefined;
        }

        this.applied = false;
        this.frame.style.display = 'block';
        this._generateHueCircle();
      }

      // ------------------------------------------ PRIVATE ----------------------------- //

      /**
       * Hide the picker. Is called by the cancel button.
       * Optional boolean to store the previous color for easy access later on.
       * @param storePrevious
       * @private
       */

    }, {
      key: '_hide',
      value: function _hide() {
        var _this = this;

        var storePrevious = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

        // store the previous color for next time;
        if (storePrevious === true) {
          this.previousColor = util.extend({}, this.color);
        }

        if (this.applied === true) {
          this.updateCallback(this.initialColor);
        }

        this.frame.style.display = 'none';

        // call the closing callback, restoring the onclick method.
        // this is in a setTimeout because it will trigger the show again before the click is done.
        setTimeout(function () {
          if (_this.closeCallback !== undefined) {
            _this.closeCallback();
            _this.closeCallback = undefined;
          }
        }, 0);
      }

      /**
       * bound to the save button. Saves and hides.
       * @private
       */

    }, {
      key: '_save',
      value: function _save() {
        this.updateCallback(this.color);
        this.applied = false;
        this._hide();
      }

      /**
       * Bound to apply button. Saves but does not close. Is undone by the cancel button.
       * @private
       */

    }, {
      key: '_apply',
      value: function _apply() {
        this.applied = true;
        this.updateCallback(this.color);
        this._updatePicker(this.color);
      }

      /**
       * load the color from the previous session.
       * @private
       */

    }, {
      key: '_loadLast',
      value: function _loadLast() {
        if (this.previousColor !== undefined) {
          this.setColor(this.previousColor, false);
        } else {
          alert("There is no last color to load...");
        }
      }

      /**
       * set the color, place the picker
       * @param rgba
       * @param setInitial
       * @private
       */

    }, {
      key: '_setColor',
      value: function _setColor(rgba) {
        var setInitial = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

        // store the initial color
        if (setInitial === true) {
          this.initialColor = util.extend({}, rgba);
        }

        this.color = rgba;
        var hsv = util.RGBToHSV(rgba.r, rgba.g, rgba.b);

        var angleConvert = 2 * Math.PI;
        var radius = this.r * hsv.s;
        var x = this.centerCoordinates.x + radius * Math.sin(angleConvert * hsv.h);
        var y = this.centerCoordinates.y + radius * Math.cos(angleConvert * hsv.h);

        this.colorPickerSelector.style.left = x - 0.5 * this.colorPickerSelector.clientWidth + 'px';
        this.colorPickerSelector.style.top = y - 0.5 * this.colorPickerSelector.clientHeight + 'px';

        this._updatePicker(rgba);
      }

      /**
       * bound to opacity control
       * @param value
       * @private
       */

    }, {
      key: '_setOpacity',
      value: function _setOpacity(value) {
        this.color.a = value / 100;
        this._updatePicker(this.color);
      }

      /**
       * bound to brightness control
       * @param value
       * @private
       */

    }, {
      key: '_setBrightness',
      value: function _setBrightness(value) {
        var hsv = util.RGBToHSV(this.color.r, this.color.g, this.color.b);
        hsv.v = value / 100;
        var rgba = util.HSVToRGB(hsv.h, hsv.s, hsv.v);
        rgba['a'] = this.color.a;
        this.color = rgba;
        this._updatePicker();
      }

      /**
       * update the color picker. A black circle overlays the hue circle to mimic the brightness decreasing.
       * @param rgba
       * @private
       */

    }, {
      key: '_updatePicker',
      value: function _updatePicker() {
        var rgba = arguments.length <= 0 || arguments[0] === undefined ? this.color : arguments[0];

        var hsv = util.RGBToHSV(rgba.r, rgba.g, rgba.b);
        var ctx = this.colorPickerCanvas.getContext('2d');
        if (this.pixelRation === undefined) {
          this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
        }
        ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);

        // clear the canvas
        var w = this.colorPickerCanvas.clientWidth;
        var h = this.colorPickerCanvas.clientHeight;
        ctx.clearRect(0, 0, w, h);

        ctx.putImageData(this.hueCircle, 0, 0);
        ctx.fillStyle = 'rgba(0,0,0,' + (1 - hsv.v) + ')';
        ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);
        ctx.fill();

        this.brightnessRange.value = 100 * hsv.v;
        this.opacityRange.value = 100 * rgba.a;

        this.initialColorDiv.style.backgroundColor = 'rgba(' + this.initialColor.r + ',' + this.initialColor.g + ',' + this.initialColor.b + ',' + this.initialColor.a + ')';
        this.newColorDiv.style.backgroundColor = 'rgba(' + this.color.r + ',' + this.color.g + ',' + this.color.b + ',' + this.color.a + ')';
      }

      /**
       * used by create to set the size of the canvas.
       * @private
       */

    }, {
      key: '_setSize',
      value: function _setSize() {
        this.colorPickerCanvas.style.width = '100%';
        this.colorPickerCanvas.style.height = '100%';

        this.colorPickerCanvas.width = 289 * this.pixelRatio;
        this.colorPickerCanvas.height = 289 * this.pixelRatio;
      }

      /**
       * create all dom elements
       * TODO: cleanup, lots of similar dom elements
       * @private
       */

    }, {
      key: '_create',
      value: function _create() {
        this.frame = document.createElement('div');
        this.frame.className = 'vis-color-picker';

        this.colorPickerDiv = document.createElement('div');
        this.colorPickerSelector = document.createElement('div');
        this.colorPickerSelector.className = 'vis-selector';
        this.colorPickerDiv.appendChild(this.colorPickerSelector);

        this.colorPickerCanvas = document.createElement('canvas');
        this.colorPickerDiv.appendChild(this.colorPickerCanvas);

        if (!this.colorPickerCanvas.getContext) {
          var noCanvas = document.createElement('DIV');
          noCanvas.style.color = 'red';
          noCanvas.style.fontWeight = 'bold';
          noCanvas.style.padding = '10px';
          noCanvas.innerHTML = 'Error: your browser does not support HTML canvas';
          this.colorPickerCanvas.appendChild(noCanvas);
        } else {
          var ctx = this.colorPickerCanvas.getContext("2d");
          this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);

          this.colorPickerCanvas.getContext("2d").setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
        }

        this.colorPickerDiv.className = 'vis-color';

        this.opacityDiv = document.createElement('div');
        this.opacityDiv.className = 'vis-opacity';

        this.brightnessDiv = document.createElement('div');
        this.brightnessDiv.className = 'vis-brightness';

        this.arrowDiv = document.createElement('div');
        this.arrowDiv.className = 'vis-arrow';

        this.opacityRange = document.createElement('input');
        try {
          this.opacityRange.type = 'range'; // Not supported on IE9
          this.opacityRange.min = '0';
          this.opacityRange.max = '100';
        } catch (err) {}
        this.opacityRange.value = '100';
        this.opacityRange.className = 'vis-range';

        this.brightnessRange = document.createElement('input');
        try {
          this.brightnessRange.type = 'range'; // Not supported on IE9
          this.brightnessRange.min = '0';
          this.brightnessRange.max = '100';
        } catch (err) {}
        this.brightnessRange.value = '100';
        this.brightnessRange.className = 'vis-range';

        this.opacityDiv.appendChild(this.opacityRange);
        this.brightnessDiv.appendChild(this.brightnessRange);

        var me = this;
        this.opacityRange.onchange = function () {
          me._setOpacity(this.value);
        };
        this.opacityRange.oninput = function () {
          me._setOpacity(this.value);
        };
        this.brightnessRange.onchange = function () {
          me._setBrightness(this.value);
        };
        this.brightnessRange.oninput = function () {
          me._setBrightness(this.value);
        };

        this.brightnessLabel = document.createElement("div");
        this.brightnessLabel.className = "vis-label vis-brightness";
        this.brightnessLabel.innerHTML = 'brightness:';

        this.opacityLabel = document.createElement("div");
        this.opacityLabel.className = "vis-label vis-opacity";
        this.opacityLabel.innerHTML = 'opacity:';

        this.newColorDiv = document.createElement("div");
        this.newColorDiv.className = "vis-new-color";
        this.newColorDiv.innerHTML = 'new';

        this.initialColorDiv = document.createElement("div");
        this.initialColorDiv.className = "vis-initial-color";
        this.initialColorDiv.innerHTML = 'initial';

        this.cancelButton = document.createElement("div");
        this.cancelButton.className = "vis-button vis-cancel";
        this.cancelButton.innerHTML = 'cancel';
        this.cancelButton.onclick = this._hide.bind(this, false);

        this.applyButton = document.createElement("div");
        this.applyButton.className = "vis-button vis-apply";
        this.applyButton.innerHTML = 'apply';
        this.applyButton.onclick = this._apply.bind(this);

        this.saveButton = document.createElement("div");
        this.saveButton.className = "vis-button vis-save";
        this.saveButton.innerHTML = 'save';
        this.saveButton.onclick = this._save.bind(this);

        this.loadButton = document.createElement("div");
        this.loadButton.className = "vis-button vis-load";
        this.loadButton.innerHTML = 'load last';
        this.loadButton.onclick = this._loadLast.bind(this);

        this.frame.appendChild(this.colorPickerDiv);
        this.frame.appendChild(this.arrowDiv);
        this.frame.appendChild(this.brightnessLabel);
        this.frame.appendChild(this.brightnessDiv);
        this.frame.appendChild(this.opacityLabel);
        this.frame.appendChild(this.opacityDiv);
        this.frame.appendChild(this.newColorDiv);
        this.frame.appendChild(this.initialColorDiv);

        this.frame.appendChild(this.cancelButton);
        this.frame.appendChild(this.applyButton);
        this.frame.appendChild(this.saveButton);
        this.frame.appendChild(this.loadButton);
      }

      /**
       * bind hammer to the color picker
       * @private
       */

    }, {
      key: '_bindHammer',
      value: function _bindHammer() {
        var _this2 = this;

        this.drag = {};
        this.pinch = {};
        this.hammer = new Hammer(this.colorPickerCanvas);
        this.hammer.get('pinch').set({ enable: true });

        hammerUtil.onTouch(this.hammer, function (event) {
          _this2._moveSelector(event);
        });
        this.hammer.on('tap', function (event) {
          _this2._moveSelector(event);
        });
        this.hammer.on('panstart', function (event) {
          _this2._moveSelector(event);
        });
        this.hammer.on('panmove', function (event) {
          _this2._moveSelector(event);
        });
        this.hammer.on('panend', function (event) {
          _this2._moveSelector(event);
        });
      }

      /**
       * generate the hue circle. This is relatively heavy (200ms) and is done only once on the first time it is shown.
       * @private
       */

    }, {
      key: '_generateHueCircle',
      value: function _generateHueCircle() {
        if (this.generated === false) {
          var ctx = this.colorPickerCanvas.getContext('2d');
          if (this.pixelRation === undefined) {
            this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
          }
          ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);

          // clear the canvas
          var w = this.colorPickerCanvas.clientWidth;
          var h = this.colorPickerCanvas.clientHeight;
          ctx.clearRect(0, 0, w, h);

          // draw hue circle
          var x = void 0,
              y = void 0,
              hue = void 0,
              sat = void 0;
          this.centerCoordinates = { x: w * 0.5, y: h * 0.5 };
          this.r = 0.49 * w;
          var angleConvert = 2 * Math.PI / 360;
          var hfac = 1 / 360;
          var sfac = 1 / this.r;
          var rgb = void 0;
          for (hue = 0; hue < 360; hue++) {
            for (sat = 0; sat < this.r; sat++) {
              x = this.centerCoordinates.x + sat * Math.sin(angleConvert * hue);
              y = this.centerCoordinates.y + sat * Math.cos(angleConvert * hue);
              rgb = util.HSVToRGB(hue * hfac, sat * sfac, 1);
              ctx.fillStyle = 'rgb(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ')';
              ctx.fillRect(x - 0.5, y - 0.5, 2, 2);
            }
          }
          ctx.strokeStyle = 'rgba(0,0,0,1)';
          ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);
          ctx.stroke();

          this.hueCircle = ctx.getImageData(0, 0, w, h);
        }
        this.generated = true;
      }

      /**
       * move the selector. This is called by hammer functions.
       *
       * @param event
       * @private
       */

    }, {
      key: '_moveSelector',
      value: function _moveSelector(event) {
        var rect = this.colorPickerDiv.getBoundingClientRect();
        var left = event.center.x - rect.left;
        var top = event.center.y - rect.top;

        var centerY = 0.5 * this.colorPickerDiv.clientHeight;
        var centerX = 0.5 * this.colorPickerDiv.clientWidth;

        var x = left - centerX;
        var y = top - centerY;

        var angle = Math.atan2(x, y);
        var radius = 0.98 * Math.min(Math.sqrt(x * x + y * y), centerX);

        var newTop = Math.cos(angle) * radius + centerY;
        var newLeft = Math.sin(angle) * radius + centerX;

        this.colorPickerSelector.style.top = newTop - 0.5 * this.colorPickerSelector.clientHeight + 'px';
        this.colorPickerSelector.style.left = newLeft - 0.5 * this.colorPickerSelector.clientWidth + 'px';

        // set color
        var h = angle / (2 * Math.PI);
        h = h < 0 ? h + 1 : h;
        var s = radius / this.r;
        var hsv = util.RGBToHSV(this.color.r, this.color.g, this.color.b);
        hsv.h = h;
        hsv.s = s;
        var rgba = util.HSVToRGB(hsv.h, hsv.s, hsv.v);
        rgba['a'] = this.color.a;
        this.color = rgba;

        // update previews
        this.initialColorDiv.style.backgroundColor = 'rgba(' + this.initialColor.r + ',' + this.initialColor.g + ',' + this.initialColor.b + ',' + this.initialColor.a + ')';
        this.newColorDiv.style.backgroundColor = 'rgba(' + this.color.r + ',' + this.color.g + ',' + this.color.b + ',' + this.color.a + ')';
      }
    }]);

    return ColorPicker;
  }();

  exports.default = ColorPicker;

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var Hammer = __webpack_require__(20);

  /**
   * Register a touch event, taking place before a gesture
   * @param {Hammer} hammer       A hammer instance
   * @param {function} callback   Callback, called as callback(event)
   */
  exports.onTouch = function (hammer, callback) {
    callback.inputHandler = function (event) {
      if (event.isFirst) {
        callback(event);
      }
    };

    hammer.on('hammer.input', callback.inputHandler);
  };

  /**
   * Register a release event, taking place after a gesture
   * @param {Hammer} hammer       A hammer instance
   * @param {function} callback   Callback, called as callback(event)
   */
  exports.onRelease = function (hammer, callback) {
    callback.inputHandler = function (event) {
      if (event.isFinal) {
        callback(event);
      }
    };

    return hammer.on('hammer.input', callback.inputHandler);
  };

  /**
   * Unregister a touch event, taking place before a gesture
   * @param {Hammer} hammer       A hammer instance
   * @param {function} callback   Callback, called as callback(event)
   */
  exports.offTouch = function (hammer, callback) {
    hammer.off('hammer.input', callback.inputHandler);
  };

  /**
   * Unregister a release event, taking place before a gesture
   * @param {Hammer} hammer       A hammer instance
   * @param {function} callback   Callback, called as callback(event)
   */
  exports.offRelease = exports.offTouch;

  /**
   * Hack the PinchRecognizer such that it doesn't prevent default behavior
   * for vertical panning.
   *
   * Yeah ... this is quite a hack ... see https://github.com/hammerjs/hammer.js/issues/932
   *
   * @param {Hammer.Pinch} pinchRecognizer
   * @return {Hammer.Pinch} returns the pinchRecognizer
   */
  exports.disablePreventDefaultVertically = function (pinchRecognizer) {
    var TOUCH_ACTION_PAN_Y = 'pan-y';

    pinchRecognizer.getTouchAction = function () {
      // default method returns [TOUCH_ACTION_NONE]
      return [TOUCH_ACTION_PAN_Y];
    };

    return pinchRecognizer;
  };

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);

  var errorFound = false;
  var allOptions = void 0;
  var printStyle = 'background: #FFeeee; color: #dd0000';
  /**
   *  Used to validate options.
   */

  var Validator = function () {
    function Validator() {
      _classCallCheck(this, Validator);
    }

    /**
     * Main function to be called
     * @param options
     * @param subObject
     * @returns {boolean}
     */


    _createClass(Validator, null, [{
      key: 'validate',
      value: function validate(options, referenceOptions, subObject) {
        errorFound = false;
        allOptions = referenceOptions;
        var usedOptions = referenceOptions;
        if (subObject !== undefined) {
          usedOptions = referenceOptions[subObject];
        }
        Validator.parse(options, usedOptions, []);
        return errorFound;
      }

      /**
       * Will traverse an object recursively and check every value
       * @param options
       * @param referenceOptions
       * @param path
       */

    }, {
      key: 'parse',
      value: function parse(options, referenceOptions, path) {
        for (var option in options) {
          if (options.hasOwnProperty(option)) {
            Validator.check(option, options, referenceOptions, path);
          }
        }
      }

      /**
       * Check every value. If the value is an object, call the parse function on that object.
       * @param option
       * @param options
       * @param referenceOptions
       * @param path
       */

    }, {
      key: 'check',
      value: function check(option, options, referenceOptions, path) {
        if (referenceOptions[option] === undefined && referenceOptions.__any__ === undefined) {
          Validator.getSuggestion(option, referenceOptions, path);
        } else if (referenceOptions[option] === undefined && referenceOptions.__any__ !== undefined) {
          // __any__ is a wildcard. Any value is accepted and will be further analysed by reference.
          if (Validator.getType(options[option]) === 'object' && referenceOptions['__any__'].__type__ !== undefined) {
            // if the any subgroup is not a predefined object int he configurator we do not look deeper into the object.
            Validator.checkFields(option, options, referenceOptions, '__any__', referenceOptions['__any__'].__type__, path);
          } else {
            Validator.checkFields(option, options, referenceOptions, '__any__', referenceOptions['__any__'], path);
          }
        } else {
          // Since all options in the reference are objects, we can check whether they are supposed to be object to look for the __type__ field.
          if (referenceOptions[option].__type__ !== undefined) {
            // if this should be an object, we check if the correct type has been supplied to account for shorthand options.
            Validator.checkFields(option, options, referenceOptions, option, referenceOptions[option].__type__, path);
          } else {
            Validator.checkFields(option, options, referenceOptions, option, referenceOptions[option], path);
          }
        }
      }

      /**
       *
       * @param {String}  option     | the option property
       * @param {Object}  options    | The supplied options object
       * @param {Object}  referenceOptions    | The reference options containing all options and their allowed formats
       * @param {String}  referenceOption     | Usually this is the same as option, except when handling an __any__ tag.
       * @param {String}  refOptionType       | This is the type object from the reference options
       * @param {Array}   path      | where in the object is the option
       */

    }, {
      key: 'checkFields',
      value: function checkFields(option, options, referenceOptions, referenceOption, refOptionObj, path) {
        var optionType = Validator.getType(options[option]);
        var refOptionType = refOptionObj[optionType];
        if (refOptionType !== undefined) {
          // if the type is correct, we check if it is supposed to be one of a few select values
          if (Validator.getType(refOptionType) === 'array') {
            if (refOptionType.indexOf(options[option]) === -1) {
              console.log('%cInvalid option detected in "' + option + '".' + ' Allowed values are:' + Validator.print(refOptionType) + ' not "' + options[option] + '". ' + Validator.printLocation(path, option), printStyle);
              errorFound = true;
            } else if (optionType === 'object' && referenceOption !== "__any__") {
              path = util.copyAndExtendArray(path, option);
              Validator.parse(options[option], referenceOptions[referenceOption], path);
            }
          } else if (optionType === 'object' && referenceOption !== "__any__") {
            path = util.copyAndExtendArray(path, option);
            Validator.parse(options[option], referenceOptions[referenceOption], path);
          }
        } else if (refOptionObj['any'] === undefined) {
          // type of the field is incorrect and the field cannot be any
          console.log('%cInvalid type received for "' + option + '". Expected: ' + Validator.print(Object.keys(refOptionObj)) + '. Received [' + optionType + '] "' + options[option] + '"' + Validator.printLocation(path, option), printStyle);
          errorFound = true;
        }
      }
    }, {
      key: 'getType',
      value: function getType(object) {
        var type = typeof object === 'undefined' ? 'undefined' : _typeof(object);

        if (type === 'object') {
          if (object === null) {
            return 'null';
          }
          if (object instanceof Boolean) {
            return 'boolean';
          }
          if (object instanceof Number) {
            return 'number';
          }
          if (object instanceof String) {
            return 'string';
          }
          if (Array.isArray(object)) {
            return 'array';
          }
          if (object instanceof Date) {
            return 'date';
          }
          if (object.nodeType !== undefined) {
            return 'dom';
          }
          if (object._isAMomentObject === true) {
            return 'moment';
          }
          return 'object';
        } else if (type === 'number') {
          return 'number';
        } else if (type === 'boolean') {
          return 'boolean';
        } else if (type === 'string') {
          return 'string';
        } else if (type === undefined) {
          return 'undefined';
        }
        return type;
      }
    }, {
      key: 'getSuggestion',
      value: function getSuggestion(option, options, path) {
        var localSearch = Validator.findInOptions(option, options, path, false);
        var globalSearch = Validator.findInOptions(option, allOptions, [], true);

        var localSearchThreshold = 8;
        var globalSearchThreshold = 4;

        if (localSearch.indexMatch !== undefined) {
          console.log('%cUnknown option detected: "' + option + '" in ' + Validator.printLocation(localSearch.path, option, '') + 'Perhaps it was incomplete? Did you mean: "' + localSearch.indexMatch + '"?\n\n', printStyle);
        } else if (globalSearch.distance <= globalSearchThreshold && localSearch.distance > globalSearch.distance) {
          console.log('%cUnknown option detected: "' + option + '" in ' + Validator.printLocation(localSearch.path, option, '') + 'Perhaps it was misplaced? Matching option found at: ' + Validator.printLocation(globalSearch.path, globalSearch.closestMatch, ''), printStyle);
        } else if (localSearch.distance <= localSearchThreshold) {
          console.log('%cUnknown option detected: "' + option + '". Did you mean "' + localSearch.closestMatch + '"?' + Validator.printLocation(localSearch.path, option), printStyle);
        } else {
          console.log('%cUnknown option detected: "' + option + '". Did you mean one of these: ' + Validator.print(Object.keys(options)) + Validator.printLocation(path, option), printStyle);
        }

        errorFound = true;
      }

      /**
       * traverse the options in search for a match.
       * @param option
       * @param options
       * @param path
       * @param recursive
       * @returns {{closestMatch: string, path: Array, distance: number}}
       */

    }, {
      key: 'findInOptions',
      value: function findInOptions(option, options, path) {
        var recursive = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

        var min = 1e9;
        var closestMatch = '';
        var closestMatchPath = [];
        var lowerCaseOption = option.toLowerCase();
        var indexMatch = undefined;
        for (var op in options) {
          var distance = void 0;
          if (options[op].__type__ !== undefined && recursive === true) {
            var result = Validator.findInOptions(option, options[op], util.copyAndExtendArray(path, op));
            if (min > result.distance) {
              closestMatch = result.closestMatch;
              closestMatchPath = result.path;
              min = result.distance;
              indexMatch = result.indexMatch;
            }
          } else {
            if (op.toLowerCase().indexOf(lowerCaseOption) !== -1) {
              indexMatch = op;
            }
            distance = Validator.levenshteinDistance(option, op);
            if (min > distance) {
              closestMatch = op;
              closestMatchPath = util.copyArray(path);
              min = distance;
            }
          }
        }
        return { closestMatch: closestMatch, path: closestMatchPath, distance: min, indexMatch: indexMatch };
      }
    }, {
      key: 'printLocation',
      value: function printLocation(path, option) {
        var prefix = arguments.length <= 2 || arguments[2] === undefined ? 'Problem value found at: \n' : arguments[2];

        var str = '\n\n' + prefix + 'options = {\n';
        for (var i = 0; i < path.length; i++) {
          for (var j = 0; j < i + 1; j++) {
            str += '  ';
          }
          str += path[i] + ': {\n';
        }
        for (var _j = 0; _j < path.length + 1; _j++) {
          str += '  ';
        }
        str += option + '\n';
        for (var _i = 0; _i < path.length + 1; _i++) {
          for (var _j2 = 0; _j2 < path.length - _i; _j2++) {
            str += '  ';
          }
          str += '}\n';
        }
        return str + '\n\n';
      }
    }, {
      key: 'print',
      value: function print(options) {
        return JSON.stringify(options).replace(/(\")|(\[)|(\])|(,"__type__")/g, "").replace(/(\,)/g, ', ');
      }

      // Compute the edit distance between the two given strings
      // http://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance#JavaScript
      /*
       Copyright (c) 2011 Andrei Mackenzie
        Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
        The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
       */

    }, {
      key: 'levenshteinDistance',
      value: function levenshteinDistance(a, b) {
        if (a.length === 0) return b.length;
        if (b.length === 0) return a.length;

        var matrix = [];

        // increment along the first column of each row
        var i;
        for (i = 0; i <= b.length; i++) {
          matrix[i] = [i];
        }

        // increment each column in the first row
        var j;
        for (j = 0; j <= a.length; j++) {
          matrix[0][j] = j;
        }

        // Fill in the rest of the matrix
        for (i = 1; i <= b.length; i++) {
          for (j = 1; j <= a.length; j++) {
            if (b.charAt(i - 1) == a.charAt(j - 1)) {
              matrix[i][j] = matrix[i - 1][j - 1];
            } else {
              matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, // substitution
              Math.min(matrix[i][j - 1] + 1, // insertion
              matrix[i - 1][j] + 1)); // deletion
            }
          }
        }

        return matrix[b.length][a.length];
      }
    }]);

    return Validator;
  }();

  exports.default = Validator;
  exports.printStyle = printStyle;

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

  var util = __webpack_require__(1);
  var hammerUtil = __webpack_require__(28);
  var moment = __webpack_require__(2);
  var Component = __webpack_require__(31);
  var DateUtil = __webpack_require__(32);

  /**
   * @constructor Range
   * A Range controls a numeric range with a start and end value.
   * The Range adjusts the range based on mouse events or programmatic changes,
   * and triggers events when the range is changing or has been changed.
   * @param {{dom: Object, domProps: Object, emitter: Emitter}} body
   * @param {Object} [options]    See description at Range.setOptions
   */
  function Range(body, options) {
    var now = moment().hours(0).minutes(0).seconds(0).milliseconds(0);
    this.start = now.clone().add(-3, 'days').valueOf(); // Number
    this.end = now.clone().add(4, 'days').valueOf(); // Number

    this.body = body;
    this.deltaDifference = 0;
    this.scaleOffset = 0;
    this.startToFront = false;
    this.endToFront = true;

    // default options
    this.defaultOptions = {
      rtl: false,
      start: null,
      end: null,
      moment: moment,
      direction: 'horizontal', // 'horizontal' or 'vertical'
      moveable: true,
      zoomable: true,
      min: null,
      max: null,
      zoomMin: 10, // milliseconds
      zoomMax: 1000 * 60 * 60 * 24 * 365 * 10000 // milliseconds
    };
    this.options = util.extend({}, this.defaultOptions);
    this.props = {
      touch: {}
    };
    this.animationTimer = null;

    // drag listeners for dragging
    this.body.emitter.on('panstart', this._onDragStart.bind(this));
    this.body.emitter.on('panmove', this._onDrag.bind(this));
    this.body.emitter.on('panend', this._onDragEnd.bind(this));

    // mouse wheel for zooming
    this.body.emitter.on('mousewheel', this._onMouseWheel.bind(this));

    // pinch to zoom
    this.body.emitter.on('touch', this._onTouch.bind(this));
    this.body.emitter.on('pinch', this._onPinch.bind(this));

    this.setOptions(options);
  }

  Range.prototype = new Component();

  /**
   * Set options for the range controller
   * @param {Object} options      Available options:
   *                              {Number | Date | String} start  Start date for the range
   *                              {Number | Date | String} end    End date for the range
   *                              {Number} min    Minimum value for start
   *                              {Number} max    Maximum value for end
   *                              {Number} zoomMin    Set a minimum value for
   *                                                  (end - start).
   *                              {Number} zoomMax    Set a maximum value for
   *                                                  (end - start).
   *                              {Boolean} moveable Enable moving of the range
   *                                                 by dragging. True by default
   *                              {Boolean} zoomable Enable zooming of the range
   *                                                 by pinching/scrolling. True by default
   */
  Range.prototype.setOptions = function (options) {
    if (options) {
      // copy the options that we know
      var fields = ['direction', 'min', 'max', 'zoomMin', 'zoomMax', 'moveable', 'zoomable', 'moment', 'activate', 'hiddenDates', 'zoomKey', 'rtl'];
      util.selectiveExtend(fields, this.options, options);

      if ('start' in options || 'end' in options) {
        // apply a new range. both start and end are optional
        this.setRange(options.start, options.end);
      }
    }
  };

  /**
   * Test whether direction has a valid value
   * @param {String} direction    'horizontal' or 'vertical'
   */
  function validateDirection(direction) {
    if (direction != 'horizontal' && direction != 'vertical') {
      throw new TypeError('Unknown direction "' + direction + '". ' + 'Choose "horizontal" or "vertical".');
    }
  }

  /**
   * Set a new start and end range
   * @param {Date | Number | String} [start]
   * @param {Date | Number | String} [end]
   * @param {boolean | {duration: number, easingFunction: string}} [animation=false]
   *                                    If true (default), the range is animated
   *                                    smoothly to the new window. An object can be
   *                                    provided to specify duration and easing function.
   *                                    Default duration is 500 ms, and default easing
   *                                    function is 'easeInOutQuad'.
   * @param {Boolean} [byUser=false]
   *
   */
  Range.prototype.setRange = function (start, end, animation, byUser) {
    if (byUser !== true) {
      byUser = false;
    }
    var finalStart = start != undefined ? util.convert(start, 'Date').valueOf() : null;
    var finalEnd = end != undefined ? util.convert(end, 'Date').valueOf() : null;
    this._cancelAnimation();

    if (animation) {
      // true or an Object
      var me = this;
      var initStart = this.start;
      var initEnd = this.end;
      var duration = (typeof animation === 'undefined' ? 'undefined' : _typeof(animation)) === 'object' && 'duration' in animation ? animation.duration : 500;
      var easingName = (typeof animation === 'undefined' ? 'undefined' : _typeof(animation)) === 'object' && 'easingFunction' in animation ? animation.easingFunction : 'easeInOutQuad';
      var easingFunction = util.easingFunctions[easingName];
      if (!easingFunction) {
        throw new Error('Unknown easing function ' + JSON.stringify(easingName) + '. ' + 'Choose from: ' + Object.keys(util.easingFunctions).join(', '));
      }

      var initTime = new Date().valueOf();
      var anyChanged = false;

      var next = function next() {
        if (!me.props.touch.dragging) {
          var now = new Date().valueOf();
          var time = now - initTime;
          var ease = easingFunction(time / duration);
          var done = time > duration;
          var s = done || finalStart === null ? finalStart : initStart + (finalStart - initStart) * ease;
          var e = done || finalEnd === null ? finalEnd : initEnd + (finalEnd - initEnd) * ease;

          changed = me._applyRange(s, e);
          DateUtil.updateHiddenDates(me.options.moment, me.body, me.options.hiddenDates);
          anyChanged = anyChanged || changed;
          if (changed) {
            me.body.emitter.emit('rangechange', { start: new Date(me.start), end: new Date(me.end), byUser: byUser });
          }

          if (done) {
            if (anyChanged) {
              me.body.emitter.emit('rangechanged', { start: new Date(me.start), end: new Date(me.end), byUser: byUser });
            }
          } else {
            // animate with as high as possible frame rate, leave 20 ms in between
            // each to prevent the browser from blocking
            me.animationTimer = setTimeout(next, 20);
          }
        }
      };

      return next();
    } else {
      var changed = this._applyRange(finalStart, finalEnd);
      DateUtil.updateHiddenDates(this.options.moment, this.body, this.options.hiddenDates);
      if (changed) {
        var params = { start: new Date(this.start), end: new Date(this.end), byUser: byUser };
        this.body.emitter.emit('rangechange', params);
        this.body.emitter.emit('rangechanged', params);
      }
    }
  };

  /**
   * Stop an animation
   * @private
   */
  Range.prototype._cancelAnimation = function () {
    if (this.animationTimer) {
      clearTimeout(this.animationTimer);
      this.animationTimer = null;
    }
  };

  /**
   * Set a new start and end range. This method is the same as setRange, but
   * does not trigger a range change and range changed event, and it returns
   * true when the range is changed
   * @param {Number} [start]
   * @param {Number} [end]
   * @return {Boolean} changed
   * @private
   */
  Range.prototype._applyRange = function (start, end) {
    var newStart = start != null ? util.convert(start, 'Date').valueOf() : this.start,
        newEnd = end != null ? util.convert(end, 'Date').valueOf() : this.end,
        max = this.options.max != null ? util.convert(this.options.max, 'Date').valueOf() : null,
        min = this.options.min != null ? util.convert(this.options.min, 'Date').valueOf() : null,
        diff;

    // check for valid number
    if (isNaN(newStart) || newStart === null) {
      throw new Error('Invalid start "' + start + '"');
    }
    if (isNaN(newEnd) || newEnd === null) {
      throw new Error('Invalid end "' + end + '"');
    }

    // prevent start < end
    if (newEnd < newStart) {
      newEnd = newStart;
    }

    // prevent start < min
    if (min !== null) {
      if (newStart < min) {
        diff = min - newStart;
        newStart += diff;
        newEnd += diff;

        // prevent end > max
        if (max != null) {
          if (newEnd > max) {
            newEnd = max;
          }
        }
      }
    }

    // prevent end > max
    if (max !== null) {
      if (newEnd > max) {
        diff = newEnd - max;
        newStart -= diff;
        newEnd -= diff;

        // prevent start < min
        if (min != null) {
          if (newStart < min) {
            newStart = min;
          }
        }
      }
    }

    // prevent (end-start) < zoomMin
    if (this.options.zoomMin !== null) {
      var zoomMin = parseFloat(this.options.zoomMin);
      if (zoomMin < 0) {
        zoomMin = 0;
      }
      if (newEnd - newStart < zoomMin) {
        if (this.end - this.start === zoomMin && newStart > this.start && newEnd < this.end) {
          // ignore this action, we are already zoomed to the minimum
          newStart = this.start;
          newEnd = this.end;
        } else {
          // zoom to the minimum
          diff = zoomMin - (newEnd - newStart);
          newStart -= diff / 2;
          newEnd += diff / 2;
        }
      }
    }

    // prevent (end-start) > zoomMax
    if (this.options.zoomMax !== null) {
      var zoomMax = parseFloat(this.options.zoomMax);
      if (zoomMax < 0) {
        zoomMax = 0;
      }

      if (newEnd - newStart > zoomMax) {
        if (this.end - this.start === zoomMax && newStart < this.start && newEnd > this.end) {
          // ignore this action, we are already zoomed to the maximum
          newStart = this.start;
          newEnd = this.end;
        } else {
          // zoom to the maximum
          diff = newEnd - newStart - zoomMax;
          newStart += diff / 2;
          newEnd -= diff / 2;
        }
      }
    }

    var changed = this.start != newStart || this.end != newEnd;

    // if the new range does NOT overlap with the old range, emit checkRangedItems to avoid not showing ranged items (ranged meaning has end time, not necessarily of type Range)
    if (!(newStart >= this.start && newStart <= this.end || newEnd >= this.start && newEnd <= this.end) && !(this.start >= newStart && this.start <= newEnd || this.end >= newStart && this.end <= newEnd)) {
      this.body.emitter.emit('checkRangedItems');
    }

    this.start = newStart;
    this.end = newEnd;
    return changed;
  };

  /**
   * Retrieve the current range.
   * @return {Object} An object with start and end properties
   */
  Range.prototype.getRange = function () {
    return {
      start: this.start,
      end: this.end
    };
  };

  /**
   * Calculate the conversion offset and scale for current range, based on
   * the provided width
   * @param {Number} width
   * @returns {{offset: number, scale: number}} conversion
   */
  Range.prototype.conversion = function (width, totalHidden) {
    return Range.conversion(this.start, this.end, width, totalHidden);
  };

  /**
   * Static method to calculate the conversion offset and scale for a range,
   * based on the provided start, end, and width
   * @param {Number} start
   * @param {Number} end
   * @param {Number} width
   * @returns {{offset: number, scale: number}} conversion
   */
  Range.conversion = function (start, end, width, totalHidden) {
    if (totalHidden === undefined) {
      totalHidden = 0;
    }
    if (width != 0 && end - start != 0) {
      return {
        offset: start,
        scale: width / (end - start - totalHidden)
      };
    } else {
      return {
        offset: 0,
        scale: 1
      };
    }
  };

  /**
   * Start dragging horizontally or vertically
   * @param {Event} event
   * @private
   */
  Range.prototype._onDragStart = function (event) {
    this.deltaDifference = 0;
    this.previousDelta = 0;

    // only allow dragging when configured as movable
    if (!this.options.moveable) return;

    // only start dragging when the mouse is inside the current range
    if (!this._isInsideRange(event)) return;

    // refuse to drag when we where pinching to prevent the timeline make a jump
    // when releasing the fingers in opposite order from the touch screen
    if (!this.props.touch.allowDragging) return;

    this.props.touch.start = this.start;
    this.props.touch.end = this.end;
    this.props.touch.dragging = true;

    if (this.body.dom.root) {
      this.body.dom.root.style.cursor = 'move';
    }
  };

  /**
   * Perform dragging operation
   * @param {Event} event
   * @private
   */
  Range.prototype._onDrag = function (event) {
    if (!this.props.touch.dragging) return;

    // only allow dragging when configured as movable
    if (!this.options.moveable) return;

    // TODO: this may be redundant in hammerjs2
    // refuse to drag when we where pinching to prevent the timeline make a jump
    // when releasing the fingers in opposite order from the touch screen
    if (!this.props.touch.allowDragging) return;

    var direction = this.options.direction;
    validateDirection(direction);
    var delta = direction == 'horizontal' ? event.deltaX : event.deltaY;
    delta -= this.deltaDifference;
    var interval = this.props.touch.end - this.props.touch.start;

    // normalize dragging speed if cutout is in between.
    var duration = DateUtil.getHiddenDurationBetween(this.body.hiddenDates, this.start, this.end);
    interval -= duration;

    var width = direction == 'horizontal' ? this.body.domProps.center.width : this.body.domProps.center.height;

    if (this.options.rtl) {
      var diffRange = delta / width * interval;
    } else {
      var diffRange = -delta / width * interval;
    }

    var newStart = this.props.touch.start + diffRange;
    var newEnd = this.props.touch.end + diffRange;

    // snapping times away from hidden zones
    var safeStart = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newStart, this.previousDelta - delta, true);
    var safeEnd = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newEnd, this.previousDelta - delta, true);
    if (safeStart != newStart || safeEnd != newEnd) {
      this.deltaDifference += delta;
      this.props.touch.start = safeStart;
      this.props.touch.end = safeEnd;
      this._onDrag(event);
      return;
    }

    this.previousDelta = delta;
    this._applyRange(newStart, newEnd);

    var startDate = new Date(this.start);
    var endDate = new Date(this.end);

    // fire a rangechange event
    this.body.emitter.emit('rangechange', {
      start: startDate,
      end: endDate,
      byUser: true
    });
  };

  /**
   * Stop dragging operation
   * @param {event} event
   * @private
   */
  Range.prototype._onDragEnd = function (event) {
    if (!this.props.touch.dragging) return;

    // only allow dragging when configured as movable
    if (!this.options.moveable) return;

    // TODO: this may be redundant in hammerjs2
    // refuse to drag when we where pinching to prevent the timeline make a jump
    // when releasing the fingers in opposite order from the touch screen
    if (!this.props.touch.allowDragging) return;

    this.props.touch.dragging = false;
    if (this.body.dom.root) {
      this.body.dom.root.style.cursor = 'auto';
    }

    // fire a rangechanged event
    this.body.emitter.emit('rangechanged', {
      start: new Date(this.start),
      end: new Date(this.end),
      byUser: true
    });
  };

  /**
   * Event handler for mouse wheel event, used to zoom
   * Code from http://adomas.org/javascript-mouse-wheel/
   * @param {Event} event
   * @private
   */
  Range.prototype._onMouseWheel = function (event) {
    // only allow zooming when configured as zoomable and moveable
    if (!(this.options.zoomable && this.options.moveable)) return;

    // only zoom when the mouse is inside the current range
    if (!this._isInsideRange(event)) return;

    // only zoom when the according key is pressed and the zoomKey option is set
    if (this.options.zoomKey && !event[this.options.zoomKey]) return;

    // retrieve delta
    var delta = 0;
    if (event.wheelDelta) {
      /* IE/Opera. */
      delta = event.wheelDelta / 120;
    } else if (event.detail) {
      /* Mozilla case. */
      // In Mozilla, sign of delta is different than in IE.
      // Also, delta is multiple of 3.
      delta = -event.detail / 3;
    }

    // If delta is nonzero, handle it.
    // Basically, delta is now positive if wheel was scrolled up,
    // and negative, if wheel was scrolled down.
    if (delta) {
      // perform the zoom action. Delta is normally 1 or -1

      // adjust a negative delta such that zooming in with delta 0.1
      // equals zooming out with a delta -0.1
      var scale;
      if (delta < 0) {
        scale = 1 - delta / 5;
      } else {
        scale = 1 / (1 + delta / 5);
      }

      // calculate center, the date to zoom around
      var pointer = this.getPointer({ x: event.clientX, y: event.clientY }, this.body.dom.center);
      var pointerDate = this._pointerToDate(pointer);

      this.zoom(scale, pointerDate, delta);
    }

    // Prevent default actions caused by mouse wheel
    // (else the page and timeline both zoom and scroll)
    event.preventDefault();
  };

  /**
   * Start of a touch gesture
   * @private
   */
  Range.prototype._onTouch = function (event) {
    this.props.touch.start = this.start;
    this.props.touch.end = this.end;
    this.props.touch.allowDragging = true;
    this.props.touch.center = null;
    this.scaleOffset = 0;
    this.deltaDifference = 0;
  };

  /**
   * Handle pinch event
   * @param {Event} event
   * @private
   */
  Range.prototype._onPinch = function (event) {
    // only allow zooming when configured as zoomable and moveable
    if (!(this.options.zoomable && this.options.moveable)) return;

    this.props.touch.allowDragging = false;

    if (!this.props.touch.center) {
      this.props.touch.center = this.getPointer(event.center, this.body.dom.center);
    }

    var scale = 1 / (event.scale + this.scaleOffset);
    var centerDate = this._pointerToDate(this.props.touch.center);

    var hiddenDuration = DateUtil.getHiddenDurationBetween(this.body.hiddenDates, this.start, this.end);
    var hiddenDurationBefore = DateUtil.getHiddenDurationBefore(this.options.moment, this.body.hiddenDates, this, centerDate);
    var hiddenDurationAfter = hiddenDuration - hiddenDurationBefore;

    // calculate new start and end
    var newStart = centerDate - hiddenDurationBefore + (this.props.touch.start - (centerDate - hiddenDurationBefore)) * scale;
    var newEnd = centerDate + hiddenDurationAfter + (this.props.touch.end - (centerDate + hiddenDurationAfter)) * scale;

    // snapping times away from hidden zones
    this.startToFront = 1 - scale <= 0; // used to do the right auto correction with periodic hidden times
    this.endToFront = scale - 1 <= 0; // used to do the right auto correction with periodic hidden times

    var safeStart = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newStart, 1 - scale, true);
    var safeEnd = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newEnd, scale - 1, true);
    if (safeStart != newStart || safeEnd != newEnd) {
      this.props.touch.start = safeStart;
      this.props.touch.end = safeEnd;
      this.scaleOffset = 1 - event.scale;
      newStart = safeStart;
      newEnd = safeEnd;
    }

    this.setRange(newStart, newEnd, false, true);

    this.startToFront = false; // revert to default
    this.endToFront = true; // revert to default
  };

  /**
   * Test whether the mouse from a mouse event is inside the visible window,
   * between the current start and end date
   * @param {Object} event
   * @return {boolean} Returns true when inside the visible window
   * @private
   */
  Range.prototype._isInsideRange = function (event) {
    // calculate the time where the mouse is, check whether inside
    // and no scroll action should happen.
    var clientX = event.center ? event.center.x : event.clientX;
    if (this.options.rtl) {
      var x = clientX - util.getAbsoluteLeft(this.body.dom.centerContainer);
    } else {
      var x = util.getAbsoluteRight(this.body.dom.centerContainer) - clientX;
    }
    var time = this.body.util.toTime(x);

    return time >= this.start && time <= this.end;
  };

  /**
   * Helper function to calculate the center date for zooming
   * @param {{x: Number, y: Number}} pointer
   * @return {number} date
   * @private
   */
  Range.prototype._pointerToDate = function (pointer) {
    var conversion;
    var direction = this.options.direction;

    validateDirection(direction);

    if (direction == 'horizontal') {
      return this.body.util.toTime(pointer.x).valueOf();
    } else {
      var height = this.body.domProps.center.height;
      conversion = this.conversion(height);
      return pointer.y / conversion.scale + conversion.offset;
    }
  };

  /**
   * Get the pointer location relative to the location of the dom element
   * @param {{x: Number, y: Number}} touch
   * @param {Element} element   HTML DOM element
   * @return {{x: Number, y: Number}} pointer
   * @private
   */
  Range.prototype.getPointer = function (touch, element) {
    if (this.options.rtl) {
      return {
        x: util.getAbsoluteRight(element) - touch.x,
        y: touch.y - util.getAbsoluteTop(element)
      };
    } else {
      return {
        x: touch.x - util.getAbsoluteLeft(element),
        y: touch.y - util.getAbsoluteTop(element)
      };
    }
  };

  /**
   * Zoom the range the given scale in or out. Start and end date will
   * be adjusted, and the timeline will be redrawn. You can optionally give a
   * date around which to zoom.
   * For example, try scale = 0.9 or 1.1
   * @param {Number} scale      Scaling factor. Values above 1 will zoom out,
   *                            values below 1 will zoom in.
   * @param {Number} [center]   Value representing a date around which will
   *                            be zoomed.
   */
  Range.prototype.zoom = function (scale, center, delta) {
    // if centerDate is not provided, take it half between start Date and end Date
    if (center == null) {
      center = (this.start + this.end) / 2;
    }

    var hiddenDuration = DateUtil.getHiddenDurationBetween(this.body.hiddenDates, this.start, this.end);
    var hiddenDurationBefore = DateUtil.getHiddenDurationBefore(this.options.moment, this.body.hiddenDates, this, center);
    var hiddenDurationAfter = hiddenDuration - hiddenDurationBefore;

    // calculate new start and end
    var newStart = center - hiddenDurationBefore + (this.start - (center - hiddenDurationBefore)) * scale;
    var newEnd = center + hiddenDurationAfter + (this.end - (center + hiddenDurationAfter)) * scale;

    // snapping times away from hidden zones
    this.startToFront = delta > 0 ? false : true; // used to do the right autocorrection with periodic hidden times
    this.endToFront = -delta > 0 ? false : true; // used to do the right autocorrection with periodic hidden times
    var safeStart = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newStart, delta, true);
    var safeEnd = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newEnd, -delta, true);
    if (safeStart != newStart || safeEnd != newEnd) {
      newStart = safeStart;
      newEnd = safeEnd;
    }

    this.setRange(newStart, newEnd, false, true);

    this.startToFront = false; // revert to default
    this.endToFront = true; // revert to default
  };

  /**
   * Move the range with a given delta to the left or right. Start and end
   * value will be adjusted. For example, try delta = 0.1 or -0.1
   * @param {Number}  delta     Moving amount. Positive value will move right,
   *                            negative value will move left
   */
  Range.prototype.move = function (delta) {
    // zoom start Date and end Date relative to the centerDate
    var diff = this.end - this.start;

    // apply new values
    var newStart = this.start + diff * delta;
    var newEnd = this.end + diff * delta;

    // TODO: reckon with min and max range

    this.start = newStart;
    this.end = newEnd;
  };

  /**
   * Move the range to a new center point
   * @param {Number} moveTo      New center point of the range
   */
  Range.prototype.moveTo = function (moveTo) {
    var center = (this.start + this.end) / 2;

    var diff = center - moveTo;

    // calculate new start and end
    var newStart = this.start - diff;
    var newEnd = this.end - diff;

    this.setRange(newStart, newEnd);
  };

  module.exports = Range;

/***/ },
/* 31 */
/***/ function(module, exports) {

  "use strict";

  /**
   * Prototype for visual components
   * @param {{dom: Object, domProps: Object, emitter: Emitter, range: Range}} [body]
   * @param {Object} [options]
   */
  function Component(body, options) {
    this.options = null;
    this.props = null;
  }

  /**
   * Set options for the component. The new options will be merged into the
   * current options.
   * @param {Object} options
   */
  Component.prototype.setOptions = function (options) {
    if (options) {
      util.extend(this.options, options);
    }
  };

  /**
   * Repaint the component
   * @return {boolean} Returns true if the component is resized
   */
  Component.prototype.redraw = function () {
    // should be implemented by the component
    return false;
  };

  /**
   * Destroy the component. Cleanup DOM and event listeners
   */
  Component.prototype.destroy = function () {
    // should be implemented by the component
  };

  /**
   * Test whether the component is resized since the last time _isResized() was
   * called.
   * @return {Boolean} Returns true if the component is resized
   * @protected
   */
  Component.prototype._isResized = function () {
    var resized = this.props._previousWidth !== this.props.width || this.props._previousHeight !== this.props.height;

    this.props._previousWidth = this.props.width;
    this.props._previousHeight = this.props.height;

    return resized;
  };

  module.exports = Component;

/***/ },
/* 32 */
/***/ function(module, exports) {

  "use strict";

  /**
   * used in Core to convert the options into a volatile variable
   * 
   * @param {function} moment
   * @param {Object} body
   * @param {Array | Object} hiddenDates
   */
  exports.convertHiddenOptions = function (moment, body, hiddenDates) {
    if (hiddenDates && !Array.isArray(hiddenDates)) {
      return exports.convertHiddenOptions(moment, body, [hiddenDates]);
    }

    body.hiddenDates = [];
    if (hiddenDates) {
      if (Array.isArray(hiddenDates) == true) {
        for (var i = 0; i < hiddenDates.length; i++) {
          if (hiddenDates[i].repeat === undefined) {
            var dateItem = {};
            dateItem.start = moment(hiddenDates[i].start).toDate().valueOf();
            dateItem.end = moment(hiddenDates[i].end).toDate().valueOf();
            body.hiddenDates.push(dateItem);
          }
        }
        body.hiddenDates.sort(function (a, b) {
          return a.start - b.start;
        }); // sort by start time
      }
    }
  };

  /**
   * create new entrees for the repeating hidden dates
   * @param {function} moment
   * @param {Object} body
   * @param {Array | Object} hiddenDates
   */
  exports.updateHiddenDates = function (moment, body, hiddenDates) {
    if (hiddenDates && !Array.isArray(hiddenDates)) {
      return exports.updateHiddenDates(moment, body, [hiddenDates]);
    }

    if (hiddenDates && body.domProps.centerContainer.width !== undefined) {
      exports.convertHiddenOptions(moment, body, hiddenDates);

      var start = moment(body.range.start);
      var end = moment(body.range.end);

      var totalRange = body.range.end - body.range.start;
      var pixelTime = totalRange / body.domProps.centerContainer.width;

      for (var i = 0; i < hiddenDates.length; i++) {
        if (hiddenDates[i].repeat !== undefined) {
          var startDate = moment(hiddenDates[i].start);
          var endDate = moment(hiddenDates[i].end);

          if (startDate._d == "Invalid Date") {
            throw new Error("Supplied start date is not valid: " + hiddenDates[i].start);
          }
          if (endDate._d == "Invalid Date") {
            throw new Error("Supplied end date is not valid: " + hiddenDates[i].end);
          }

          var duration = endDate - startDate;
          if (duration >= 4 * pixelTime) {

            var offset = 0;
            var runUntil = end.clone();
            switch (hiddenDates[i].repeat) {
              case "daily":
                // case of time
                if (startDate.day() != endDate.day()) {
                  offset = 1;
                }
                startDate.dayOfYear(start.dayOfYear());
                startDate.year(start.year());
                startDate.subtract(7, 'days');

                endDate.dayOfYear(start.dayOfYear());
                endDate.year(start.year());
                endDate.subtract(7 - offset, 'days');

                runUntil.add(1, 'weeks');
                break;
              case "weekly":
                var dayOffset = endDate.diff(startDate, 'days');
                var day = startDate.day();

                // set the start date to the range.start
                startDate.date(start.date());
                startDate.month(start.month());
                startDate.year(start.year());
                endDate = startDate.clone();

                // force
                startDate.day(day);
                endDate.day(day);
                endDate.add(dayOffset, 'days');

                startDate.subtract(1, 'weeks');
                endDate.subtract(1, 'weeks');

                runUntil.add(1, 'weeks');
                break;
              case "monthly":
                if (startDate.month() != endDate.month()) {
                  offset = 1;
                }
                startDate.month(start.month());
                startDate.year(start.year());
                startDate.subtract(1, 'months');

                endDate.month(start.month());
                endDate.year(start.year());
                endDate.subtract(1, 'months');
                endDate.add(offset, 'months');

                runUntil.add(1, 'months');
                break;
              case "yearly":
                if (startDate.year() != endDate.year()) {
                  offset = 1;
                }
                startDate.year(start.year());
                startDate.subtract(1, 'years');
                endDate.year(start.year());
                endDate.subtract(1, 'years');
                endDate.add(offset, 'years');

                runUntil.add(1, 'years');
                break;
              default:
                console.log("Wrong repeat format, allowed are: daily, weekly, monthly, yearly. Given:", hiddenDates[i].repeat);
                return;
            }
            while (startDate < runUntil) {
              body.hiddenDates.push({ start: startDate.valueOf(), end: endDate.valueOf() });
              switch (hiddenDates[i].repeat) {
                case "daily":
                  startDate.add(1, 'days');
                  endDate.add(1, 'days');
                  break;
                case "weekly":
                  startDate.add(1, 'weeks');
                  endDate.add(1, 'weeks');
                  break;
                case "monthly":
                  startDate.add(1, 'months');
                  endDate.add(1, 'months');
                  break;
                case "yearly":
                  startDate.add(1, 'y');
                  endDate.add(1, 'y');
                  break;
                default:
                  console.log("Wrong repeat format, allowed are: daily, weekly, monthly, yearly. Given:", hiddenDates[i].repeat);
                  return;
              }
            }
            body.hiddenDates.push({ start: startDate.valueOf(), end: endDate.valueOf() });
          }
        }
      }
      // remove duplicates, merge where possible
      exports.removeDuplicates(body);
      // ensure the new positions are not on hidden dates
      var startHidden = exports.isHidden(body.range.start, body.hiddenDates);
      var endHidden = exports.isHidden(body.range.end, body.hiddenDates);
      var rangeStart = body.range.start;
      var rangeEnd = body.range.end;
      if (startHidden.hidden == true) {
        rangeStart = body.range.startToFront == true ? startHidden.startDate - 1 : startHidden.endDate + 1;
      }
      if (endHidden.hidden == true) {
        rangeEnd = body.range.endToFront == true ? endHidden.startDate - 1 : endHidden.endDate + 1;
      }
      if (startHidden.hidden == true || endHidden.hidden == true) {
        body.range._applyRange(rangeStart, rangeEnd);
      }
    }
  };

  /**
   * remove duplicates from the hidden dates list. Duplicates are evil. They mess everything up.
   * Scales with N^2
   * @param body
   */
  exports.removeDuplicates = function (body) {
    var hiddenDates = body.hiddenDates;
    var safeDates = [];
    for (var i = 0; i < hiddenDates.length; i++) {
      for (var j = 0; j < hiddenDates.length; j++) {
        if (i != j && hiddenDates[j].remove != true && hiddenDates[i].remove != true) {
          // j inside i
          if (hiddenDates[j].start >= hiddenDates[i].start && hiddenDates[j].end <= hiddenDates[i].end) {
            hiddenDates[j].remove = true;
          }
          // j start inside i
          else if (hiddenDates[j].start >= hiddenDates[i].start && hiddenDates[j].start <= hiddenDates[i].end) {
              hiddenDates[i].end = hiddenDates[j].end;
              hiddenDates[j].remove = true;
            }
            // j end inside i
            else if (hiddenDates[j].end >= hiddenDates[i].start && hiddenDates[j].end <= hiddenDates[i].end) {
                hiddenDates[i].start = hiddenDates[j].start;
                hiddenDates[j].remove = true;
              }
        }
      }
    }

    for (var i = 0; i < hiddenDates.length; i++) {
      if (hiddenDates[i].remove !== true) {
        safeDates.push(hiddenDates[i]);
      }
    }

    body.hiddenDates = safeDates;
    body.hiddenDates.sort(function (a, b) {
      return a.start - b.start;
    }); // sort by start time
  };

  exports.printDates = function (dates) {
    for (var i = 0; i < dates.length; i++) {
      console.log(i, new Date(dates[i].start), new Date(dates[i].end), dates[i].start, dates[i].end, dates[i].remove);
    }
  };

  /**
   * Used in TimeStep to avoid the hidden times.
   * @param {function} moment
   * @param {TimeStep} timeStep
   * @param previousTime
   */
  exports.stepOverHiddenDates = function (moment, timeStep, previousTime) {
    var stepInHidden = false;
    var currentValue = timeStep.current.valueOf();
    for (var i = 0; i < timeStep.hiddenDates.length; i++) {
      var startDate = timeStep.hiddenDates[i].start;
      var endDate = timeStep.hiddenDates[i].end;
      if (currentValue >= startDate && currentValue < endDate) {
        stepInHidden = true;
        break;
      }
    }

    if (stepInHidden == true && currentValue < timeStep._end.valueOf() && currentValue != previousTime) {
      var prevValue = moment(previousTime);
      var newValue = moment(endDate);
      //check if the next step should be major
      if (prevValue.year() != newValue.year()) {
        timeStep.switchedYear = true;
      } else if (prevValue.month() != newValue.month()) {
        timeStep.switchedMonth = true;
      } else if (prevValue.dayOfYear() != newValue.dayOfYear()) {
        timeStep.switchedDay = true;
      }

      timeStep.current = newValue;
    }
  };

  ///**
  // * Used in TimeStep to avoid the hidden times.
  // * @param timeStep
  // * @param previousTime
  // */
  //exports.checkFirstStep = function(timeStep) {
  //  var stepInHidden = false;
  //  var currentValue = timeStep.current.valueOf();
  //  for (var i = 0; i < timeStep.hiddenDates.length; i++) {
  //    var startDate = timeStep.hiddenDates[i].start;
  //    var endDate = timeStep.hiddenDates[i].end;
  //    if (currentValue >= startDate && currentValue < endDate) {
  //      stepInHidden = true;
  //      break;
  //    }
  //  }
  //
  //  if (stepInHidden == true && currentValue <= timeStep._end.valueOf()) {
  //    var newValue = moment(endDate);
  //    timeStep.current = newValue.toDate();
  //  }
  //};

  /**
   * replaces the Core toScreen methods
   * @param Core
   * @param time
   * @param width
   * @returns {number}
   */
  exports.toScreen = function (Core, time, width) {
    if (Core.body.hiddenDates.length == 0) {
      var conversion = Core.range.conversion(width);
      return (time.valueOf() - conversion.offset) * conversion.scale;
    } else {
      var hidden = exports.isHidden(time, Core.body.hiddenDates);
      if (hidden.hidden == true) {
        time = hidden.startDate;
      }

      var duration = exports.getHiddenDurationBetween(Core.body.hiddenDates, Core.range.start, Core.range.end);
      time = exports.correctTimeForHidden(Core.options.moment, Core.body.hiddenDates, Core.range, time);

      var conversion = Core.range.conversion(width, duration);
      return (time.valueOf() - conversion.offset) * conversion.scale;
    }
  };

  /**
   * Replaces the core toTime methods
   * @param body
   * @param range
   * @param x
   * @param width
   * @returns {Date}
   */
  exports.toTime = function (Core, x, width) {
    if (Core.body.hiddenDates.length == 0) {
      var conversion = Core.range.conversion(width);
      return new Date(x / conversion.scale + conversion.offset);
    } else {
      var hiddenDuration = exports.getHiddenDurationBetween(Core.body.hiddenDates, Core.range.start, Core.range.end);
      var totalDuration = Core.range.end - Core.range.start - hiddenDuration;
      var partialDuration = totalDuration * x / width;
      var accumulatedHiddenDuration = exports.getAccumulatedHiddenDuration(Core.body.hiddenDates, Core.range, partialDuration);

      var newTime = new Date(accumulatedHiddenDuration + partialDuration + Core.range.start);
      return newTime;
    }
  };

  /**
   * Support function
   *
   * @param hiddenDates
   * @param range
   * @returns {number}
   */
  exports.getHiddenDurationBetween = function (hiddenDates, start, end) {
    var duration = 0;
    for (var i = 0; i < hiddenDates.length; i++) {
      var startDate = hiddenDates[i].start;
      var endDate = hiddenDates[i].end;
      // if time after the cutout, and the
      if (startDate >= start && endDate < end) {
        duration += endDate - startDate;
      }
    }
    return duration;
  };

  /**
   * Support function
   * @param moment
   * @param hiddenDates
   * @param range
   * @param time
   * @returns {{duration: number, time: *, offset: number}}
   */
  exports.correctTimeForHidden = function (moment, hiddenDates, range, time) {
    time = moment(time).toDate().valueOf();
    time -= exports.getHiddenDurationBefore(moment, hiddenDates, range, time);
    return time;
  };

  exports.getHiddenDurationBefore = function (moment, hiddenDates, range, time) {
    var timeOffset = 0;
    time = moment(time).toDate().valueOf();

    for (var i = 0; i < hiddenDates.length; i++) {
      var startDate = hiddenDates[i].start;
      var endDate = hiddenDates[i].end;
      // if time after the cutout, and the
      if (startDate >= range.start && endDate < range.end) {
        if (time >= endDate) {
          timeOffset += endDate - startDate;
        }
      }
    }
    return timeOffset;
  };

  /**
   * sum the duration from start to finish, including the hidden duration,
   * until the required amount has been reached, return the accumulated hidden duration
   * @param hiddenDates
   * @param range
   * @param time
   * @returns {{duration: number, time: *, offset: number}}
   */
  exports.getAccumulatedHiddenDuration = function (hiddenDates, range, requiredDuration) {
    var hiddenDuration = 0;
    var duration = 0;
    var previousPoint = range.start;
    //exports.printDates(hiddenDates)
    for (var i = 0; i < hiddenDates.length; i++) {
      var startDate = hiddenDates[i].start;
      var endDate = hiddenDates[i].end;
      // if time after the cutout, and the
      if (startDate >= range.start && endDate < range.end) {
        duration += startDate - previousPoint;
        previousPoint = endDate;
        if (duration >= requiredDuration) {
          break;
        } else {
          hiddenDuration += endDate - startDate;
        }
      }
    }

    return hiddenDuration;
  };

  /**
   * used to step over to either side of a hidden block. Correction is disabled on tablets, might be set to true
   * @param hiddenDates
   * @param time
   * @param direction
   * @param correctionEnabled
   * @returns {*}
   */
  exports.snapAwayFromHidden = function (hiddenDates, time, direction, correctionEnabled) {
    var isHidden = exports.isHidden(time, hiddenDates);
    if (isHidden.hidden == true) {
      if (direction < 0) {
        if (correctionEnabled == true) {
          return isHidden.startDate - (isHidden.endDate - time) - 1;
        } else {
          return isHidden.startDate - 1;
        }
      } else {
        if (correctionEnabled == true) {
          return isHidden.endDate + (time - isHidden.startDate) + 1;
        } else {
          return isHidden.endDate + 1;
        }
      }
    } else {
      return time;
    }
  };

  /**
   * Check if a time is hidden
   *
   * @param time
   * @param hiddenDates
   * @returns {{hidden: boolean, startDate: Window.start, endDate: *}}
   */
  exports.isHidden = function (time, hiddenDates) {
    for (var i = 0; i < hiddenDates.length; i++) {
      var startDate = hiddenDates[i].start;
      var endDate = hiddenDates[i].end;

      if (time >= startDate && time < endDate) {
        // if the start is entering a hidden zone
        return { hidden: true, startDate: startDate, endDate: endDate };
        break;
      }
    }
    return { hidden: false, startDate: startDate, endDate: endDate };
  };

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

  var Emitter = __webpack_require__(13);
  var Hammer = __webpack_require__(20);
  var hammerUtil = __webpack_require__(28);
  var util = __webpack_require__(1);
  var DataSet = __webpack_require__(9);
  var DataView = __webpack_require__(11);
  var Range = __webpack_require__(30);
  var ItemSet = __webpack_require__(34);
  var TimeAxis = __webpack_require__(44);
  var Activator = __webpack_require__(45);
  var DateUtil = __webpack_require__(32);
  var CustomTime = __webpack_require__(46);

  /**
   * Create a timeline visualization
   * @constructor
   */
  function Core() {}

  // turn Core into an event emitter
  Emitter(Core.prototype);

  /**
   * Create the main DOM for the Core: a root panel containing left, right,
   * top, bottom, content, and background panel.
   * @param {Element} container  The container element where the Core will
   *                             be attached.
   * @protected
   */
  Core.prototype._create = function (container) {
    this.dom = {};

    this.dom.container = container;

    this.dom.root = document.createElement('div');
    this.dom.background = document.createElement('div');
    this.dom.backgroundVertical = document.createElement('div');
    this.dom.backgroundHorizontal = document.createElement('div');
    this.dom.centerContainer = document.createElement('div');
    this.dom.leftContainer = document.createElement('div');
    this.dom.rightContainer = document.createElement('div');
    this.dom.center = document.createElement('div');
    this.dom.left = document.createElement('div');
    this.dom.right = document.createElement('div');
    this.dom.top = document.createElement('div');
    this.dom.bottom = document.createElement('div');
    this.dom.shadowTop = document.createElement('div');
    this.dom.shadowBottom = document.createElement('div');
    this.dom.shadowTopLeft = document.createElement('div');
    this.dom.shadowBottomLeft = document.createElement('div');
    this.dom.shadowTopRight = document.createElement('div');
    this.dom.shadowBottomRight = document.createElement('div');

    this.dom.root.className = 'vis-timeline';
    this.dom.background.className = 'vis-panel vis-background';
    this.dom.backgroundVertical.className = 'vis-panel vis-background vis-vertical';
    this.dom.backgroundHorizontal.className = 'vis-panel vis-background vis-horizontal';
    this.dom.centerContainer.className = 'vis-panel vis-center';
    this.dom.leftContainer.className = 'vis-panel vis-left';
    this.dom.rightContainer.className = 'vis-panel vis-right';
    this.dom.top.className = 'vis-panel vis-top';
    this.dom.bottom.className = 'vis-panel vis-bottom';
    this.dom.left.className = 'vis-content';
    this.dom.center.className = 'vis-content';
    this.dom.right.className = 'vis-content';
    this.dom.shadowTop.className = 'vis-shadow vis-top';
    this.dom.shadowBottom.className = 'vis-shadow vis-bottom';
    this.dom.shadowTopLeft.className = 'vis-shadow vis-top';
    this.dom.shadowBottomLeft.className = 'vis-shadow vis-bottom';
    this.dom.shadowTopRight.className = 'vis-shadow vis-top';
    this.dom.shadowBottomRight.className = 'vis-shadow vis-bottom';

    this.dom.root.appendChild(this.dom.background);
    this.dom.root.appendChild(this.dom.backgroundVertical);
    this.dom.root.appendChild(this.dom.backgroundHorizontal);
    this.dom.root.appendChild(this.dom.centerContainer);
    this.dom.root.appendChild(this.dom.leftContainer);
    this.dom.root.appendChild(this.dom.rightContainer);
    this.dom.root.appendChild(this.dom.top);
    this.dom.root.appendChild(this.dom.bottom);

    this.dom.centerContainer.appendChild(this.dom.center);
    this.dom.leftContainer.appendChild(this.dom.left);
    this.dom.rightContainer.appendChild(this.dom.right);

    this.dom.centerContainer.appendChild(this.dom.shadowTop);
    this.dom.centerContainer.appendChild(this.dom.shadowBottom);
    this.dom.leftContainer.appendChild(this.dom.shadowTopLeft);
    this.dom.leftContainer.appendChild(this.dom.shadowBottomLeft);
    this.dom.rightContainer.appendChild(this.dom.shadowTopRight);
    this.dom.rightContainer.appendChild(this.dom.shadowBottomRight);

    this.on('rangechange', function () {
      if (this.initialDrawDone === true) {
        this._redraw(); // this allows overriding the _redraw method
      }
    }.bind(this));
    this.on('touch', this._onTouch.bind(this));
    this.on('pan', this._onDrag.bind(this));

    var me = this;
    this.on('_change', function (properties) {
      if (properties && properties.queue == true) {
        // redraw once on next tick
        if (!me._redrawTimer) {
          me._redrawTimer = setTimeout(function () {
            me._redrawTimer = null;
            me._redraw();
          }, 0);
        }
      } else {
        // redraw immediately
        me._redraw();
      }
    });

    // create event listeners for all interesting events, these events will be
    // emitted via emitter
    this.hammer = new Hammer(this.dom.root);
    var pinchRecognizer = this.hammer.get('pinch').set({ enable: true });
    hammerUtil.disablePreventDefaultVertically(pinchRecognizer);
    this.hammer.get('pan').set({ threshold: 5, direction: Hammer.DIRECTION_HORIZONTAL });
    this.listeners = {};

    var events = ['tap', 'doubletap', 'press', 'pinch', 'pan', 'panstart', 'panmove', 'panend'
    // TODO: cleanup
    //'touch', 'pinch',
    //'tap', 'doubletap', 'hold',
    //'dragstart', 'drag', 'dragend',
    //'mousewheel', 'DOMMouseScroll' // DOMMouseScroll is needed for Firefox
    ];
    events.forEach(function (type) {
      var listener = function listener(event) {
        if (me.isActive()) {
          me.emit(type, event);
        }
      };
      me.hammer.on(type, listener);
      me.listeners[type] = listener;
    });

    // emulate a touch event (emitted before the start of a pan, pinch, tap, or press)
    hammerUtil.onTouch(this.hammer, function (event) {
      me.emit('touch', event);
    }.bind(this));

    // emulate a release event (emitted after a pan, pinch, tap, or press)
    hammerUtil.onRelease(this.hammer, function (event) {
      me.emit('release', event);
    }.bind(this));

    function onMouseWheel(event) {
      if (me.isActive()) {
        me.emit('mousewheel', event);
      }
    }
    this.dom.root.addEventListener('mousewheel', onMouseWheel);
    this.dom.root.addEventListener('DOMMouseScroll', onMouseWheel);

    // size properties of each of the panels
    this.props = {
      root: {},
      background: {},
      centerContainer: {},
      leftContainer: {},
      rightContainer: {},
      center: {},
      left: {},
      right: {},
      top: {},
      bottom: {},
      border: {},
      scrollTop: 0,
      scrollTopMin: 0
    };

    this.customTimes = [];

    // store state information needed for touch events
    this.touch = {};

    this.redrawCount = 0;
    this.initialDrawDone = false;

    // attach the root panel to the provided container
    if (!container) throw new Error('No container provided');
    container.appendChild(this.dom.root);
  };

  /**
   * Set options. Options will be passed to all components loaded in the Timeline.
   * @param {Object} [options]
   *                           {String} orientation
   *                              Vertical orientation for the Timeline,
   *                              can be 'bottom' (default) or 'top'.
   *                           {String | Number} width
   *                              Width for the timeline, a number in pixels or
   *                              a css string like '1000px' or '75%'. '100%' by default.
   *                           {String | Number} height
   *                              Fixed height for the Timeline, a number in pixels or
   *                              a css string like '400px' or '75%'. If undefined,
   *                              The Timeline will automatically size such that
   *                              its contents fit.
   *                           {String | Number} minHeight
   *                              Minimum height for the Timeline, a number in pixels or
   *                              a css string like '400px' or '75%'.
   *                           {String | Number} maxHeight
   *                              Maximum height for the Timeline, a number in pixels or
   *                              a css string like '400px' or '75%'.
   *                           {Number | Date | String} start
   *                              Start date for the visible window
   *                           {Number | Date | String} end
   *                              End date for the visible window
   */
  Core.prototype.setOptions = function (options) {
    if (options) {
      // copy the known options
      var fields = ['width', 'height', 'minHeight', 'maxHeight', 'autoResize', 'start', 'end', 'clickToUse', 'dataAttributes', 'hiddenDates', 'locale', 'locales', 'moment', 'rtl', 'throttleRedraw'];
      util.selectiveExtend(fields, this.options, options);

      if (this.options.rtl) {
        var contentContainer = this.dom.leftContainer;
        this.dom.leftContainer = this.dom.rightContainer;
        this.dom.rightContainer = contentContainer;
        this.dom.container.style.direction = "rtl";
        this.dom.backgroundVertical.className = 'vis-panel vis-background vis-vertical-rtl';
      }

      this.options.orientation = { item: undefined, axis: undefined };
      if ('orientation' in options) {
        if (typeof options.orientation === 'string') {
          this.options.orientation = {
            item: options.orientation,
            axis: options.orientation
          };
        } else if (_typeof(options.orientation) === 'object') {
          if ('item' in options.orientation) {
            this.options.orientation.item = options.orientation.item;
          }
          if ('axis' in options.orientation) {
            this.options.orientation.axis = options.orientation.axis;
          }
        }
      }

      if (this.options.orientation.axis === 'both') {
        if (!this.timeAxis2) {
          var timeAxis2 = this.timeAxis2 = new TimeAxis(this.body);
          timeAxis2.setOptions = function (options) {
            var _options = options ? util.extend({}, options) : {};
            _options.orientation = 'top'; // override the orientation option, always top
            TimeAxis.prototype.setOptions.call(timeAxis2, _options);
          };
          this.components.push(timeAxis2);
        }
      } else {
        if (this.timeAxis2) {
          var index = this.components.indexOf(this.timeAxis2);
          if (index !== -1) {
            this.components.splice(index, 1);
          }
          this.timeAxis2.destroy();
          this.timeAxis2 = null;
        }
      }

      // if the graph2d's drawPoints is a function delegate the callback to the onRender property
      if (typeof options.drawPoints == 'function') {
        options.drawPoints = {
          onRender: options.drawPoints
        };
      }

      if ('hiddenDates' in this.options) {
        DateUtil.convertHiddenOptions(this.options.moment, this.body, this.options.hiddenDates);
      }

      if ('clickToUse' in options) {
        if (options.clickToUse) {
          if (!this.activator) {
            this.activator = new Activator(this.dom.root);
          }
        } else {
          if (this.activator) {
            this.activator.destroy();
            delete this.activator;
          }
        }
      }

      if ('showCustomTime' in options) {
        throw new Error('Option `showCustomTime` is deprecated. Create a custom time bar via timeline.addCustomTime(time [, id])');
      }

      // enable/disable autoResize
      this._initAutoResize();
    }

    // propagate options to all components
    this.components.forEach(function (component) {
      return component.setOptions(options);
    });

    // enable/disable configure
    if ('configure' in options) {
      if (!this.configurator) {
        this.configurator = this._createConfigurator();
      }

      this.configurator.setOptions(options.configure);

      // collect the settings of all components, and pass them to the configuration system
      var appliedOptions = util.deepExtend({}, this.options);
      this.components.forEach(function (component) {
        util.deepExtend(appliedOptions, component.options);
      });
      this.configurator.setModuleOptions({ global: appliedOptions });
    }

    // override redraw with a throttled version
    if (!this._origRedraw) {
      this._origRedraw = this._redraw.bind(this);
      this._redraw = util.throttle(this._origRedraw, this.options.throttleRedraw);
    } else {
      // Not the initial run: redraw everything
      this._redraw();
    }
  };

  /**
   * Returns true when the Timeline is active.
   * @returns {boolean}
   */
  Core.prototype.isActive = function () {
    return !this.activator || this.activator.active;
  };

  /**
   * Destroy the Core, clean up all DOM elements and event listeners.
   */
  Core.prototype.destroy = function () {
    // unbind datasets
    this.setItems(null);
    this.setGroups(null);

    // remove all event listeners
    this.off();

    // stop checking for changed size
    this._stopAutoResize();

    // remove from DOM
    if (this.dom.root.parentNode) {
      this.dom.root.parentNode.removeChild(this.dom.root);
    }
    this.dom = null;

    // remove Activator
    if (this.activator) {
      this.activator.destroy();
      delete this.activator;
    }

    // cleanup hammer touch events
    for (var event in this.listeners) {
      if (this.listeners.hasOwnProperty(event)) {
        delete this.listeners[event];
      }
    }
    this.listeners = null;
    this.hammer = null;

    // give all components the opportunity to cleanup
    this.components.forEach(function (component) {
      return component.destroy();
    });

    this.body = null;
  };

  /**
   * Set a custom time bar
   * @param {Date} time
   * @param {number} [id=undefined] Optional id of the custom time bar to be adjusted.
   */
  Core.prototype.setCustomTime = function (time, id) {
    var customTimes = this.customTimes.filter(function (component) {
      return id === component.options.id;
    });

    if (customTimes.length === 0) {
      throw new Error('No custom time bar found with id ' + JSON.stringify(id));
    }

    if (customTimes.length > 0) {
      customTimes[0].setCustomTime(time);
    }
  };

  /**
   * Retrieve the current custom time.
   * @param {number} [id=undefined]    Id of the custom time bar.
   * @return {Date | undefined} customTime
   */
  Core.prototype.getCustomTime = function (id) {
    var customTimes = this.customTimes.filter(function (component) {
      return component.options.id === id;
    });

    if (customTimes.length === 0) {
      throw new Error('No custom time bar found with id ' + JSON.stringify(id));
    }
    return customTimes[0].getCustomTime();
  };

  /**
   * Set a custom title for the custom time bar.
   * @param {String} [title] Custom title
   * @param {number} [id=undefined]    Id of the custom time bar.
   */
  Core.prototype.setCustomTimeTitle = function (title, id) {
    var customTimes = this.customTimes.filter(function (component) {
      return component.options.id === id;
    });

    if (customTimes.length === 0) {
      throw new Error('No custom time bar found with id ' + JSON.stringify(id));
    }
    if (customTimes.length > 0) {
      return customTimes[0].setCustomTitle(title);
    }
  };

  /**
   * Retrieve meta information from an event.
   * Should be overridden by classes extending Core
   * @param {Event} event
   * @return {Object} An object with related information.
   */
  Core.prototype.getEventProperties = function (event) {
    return { event: event };
  };

  /**
   * Add custom vertical bar
   * @param {Date | String | Number} [time]  A Date, unix timestamp, or
   *                                         ISO date string. Time point where
   *                                         the new bar should be placed.
   *                                         If not provided, `new Date()` will
   *                                         be used.
   * @param {Number | String} [id=undefined] Id of the new bar. Optional
   * @return {Number | String}               Returns the id of the new bar
   */
  Core.prototype.addCustomTime = function (time, id) {
    var timestamp = time !== undefined ? util.convert(time, 'Date').valueOf() : new Date();

    var exists = this.customTimes.some(function (customTime) {
      return customTime.options.id === id;
    });
    if (exists) {
      throw new Error('A custom time with id ' + JSON.stringify(id) + ' already exists');
    }

    var customTime = new CustomTime(this.body, util.extend({}, this.options, {
      time: timestamp,
      id: id
    }));

    this.customTimes.push(customTime);
    this.components.push(customTime);
    this._redraw();

    return id;
  };

  /**
   * Remove previously added custom bar
   * @param {int} id ID of the custom bar to be removed
   * @return {boolean} True if the bar exists and is removed, false otherwise
   */
  Core.prototype.removeCustomTime = function (id) {
    var customTimes = this.customTimes.filter(function (bar) {
      return bar.options.id === id;
    });

    if (customTimes.length === 0) {
      throw new Error('No custom time bar found with id ' + JSON.stringify(id));
    }

    customTimes.forEach(function (customTime) {
      this.customTimes.splice(this.customTimes.indexOf(customTime), 1);
      this.components.splice(this.components.indexOf(customTime), 1);
      customTime.destroy();
    }.bind(this));
  };

  /**
   * Get the id's of the currently visible items.
   * @returns {Array} The ids of the visible items
   */
  Core.prototype.getVisibleItems = function () {
    return this.itemSet && this.itemSet.getVisibleItems() || [];
  };

  /**
   * Set Core window such that it fits all items
   * @param {Object} [options]  Available options:
   *                                `animation: boolean | {duration: number, easingFunction: string}`
   *                                    If true (default), the range is animated
   *                                    smoothly to the new window. An object can be
   *                                    provided to specify duration and easing function.
   *                                    Default duration is 500 ms, and default easing
   *                                    function is 'easeInOutQuad'.
   */
  Core.prototype.fit = function (options) {
    var range = this.getDataRange();

    // skip range set if there is no min and max date
    if (range.min === null && range.max === null) {
      return;
    }

    // apply a margin of 1% left and right of the data
    var interval = range.max - range.min;
    var min = new Date(range.min.valueOf() - interval * 0.01);
    var max = new Date(range.max.valueOf() + interval * 0.01);
    var animation = options && options.animation !== undefined ? options.animation : true;
    this.range.setRange(min, max, animation);
  };

  /**
   * Calculate the data range of the items start and end dates
   * @returns {{min: Date | null, max: Date | null}}
   * @protected
   */
  Core.prototype.getDataRange = function () {
    // must be implemented by Timeline and Graph2d
    throw new Error('Cannot invoke abstract method getDataRange');
  };

  /**
   * Set the visible window. Both parameters are optional, you can change only
   * start or only end. Syntax:
   *
   *     TimeLine.setWindow(start, end)
   *     TimeLine.setWindow(start, end, options)
   *     TimeLine.setWindow(range)
   *
   * Where start and end can be a Date, number, or string, and range is an
   * object with properties start and end.
   *
   * @param {Date | Number | String | Object} [start] Start date of visible window
   * @param {Date | Number | String} [end]            End date of visible window
   * @param {Object} [options]  Available options:
   *                                `animation: boolean | {duration: number, easingFunction: string}`
   *                                    If true (default), the range is animated
   *                                    smoothly to the new window. An object can be
   *                                    provided to specify duration and easing function.
   *                                    Default duration is 500 ms, and default easing
   *                                    function is 'easeInOutQuad'.
   */
  Core.prototype.setWindow = function (start, end, options) {
    var animation;
    if (arguments.length == 1) {
      var range = arguments[0];
      animation = range.animation !== undefined ? range.animation : true;
      this.range.setRange(range.start, range.end, animation);
    } else {
      animation = options && options.animation !== undefined ? options.animation : true;
      this.range.setRange(start, end, animation);
    }
  };

  /**
   * Move the window such that given time is centered on screen.
   * @param {Date | Number | String} time
   * @param {Object} [options]  Available options:
   *                                `animation: boolean | {duration: number, easingFunction: string}`
   *                                    If true (default), the range is animated
   *                                    smoothly to the new window. An object can be
   *                                    provided to specify duration and easing function.
   *                                    Default duration is 500 ms, and default easing
   *                                    function is 'easeInOutQuad'.
   */
  Core.prototype.moveTo = function (time, options) {
    var interval = this.range.end - this.range.start;
    var t = util.convert(time, 'Date').valueOf();

    var start = t - interval / 2;
    var end = t + interval / 2;
    var animation = options && options.animation !== undefined ? options.animation : true;

    this.range.setRange(start, end, animation);
  };

  /**
   * Get the visible window
   * @return {{start: Date, end: Date}}   Visible range
   */
  Core.prototype.getWindow = function () {
    var range = this.range.getRange();
    return {
      start: new Date(range.start),
      end: new Date(range.end)
    };
  };

  /**
   * Force a redraw. Can be overridden by implementations of Core
   *
   * Note: this function will be overridden on construction with a trottled version
   */
  Core.prototype.redraw = function () {
    this._redraw();
  };

  /**
   * Redraw for internal use. Redraws all components. See also the public
   * method redraw.
   * @protected
   */
  Core.prototype._redraw = function () {
    this.redrawCount++;
    var resized = false;
    var options = this.options;
    var props = this.props;
    var dom = this.dom;

    if (!dom || !dom.container || dom.root.offsetWidth == 0) return; // when destroyed, or invisible

    DateUtil.updateHiddenDates(this.options.moment, this.body, this.options.hiddenDates);

    // update class names
    if (options.orientation == 'top') {
      util.addClassName(dom.root, 'vis-top');
      util.removeClassName(dom.root, 'vis-bottom');
    } else {
      util.removeClassName(dom.root, 'vis-top');
      util.addClassName(dom.root, 'vis-bottom');
    }

    // update root width and height options
    dom.root.style.maxHeight = util.option.asSize(options.maxHeight, '');
    dom.root.style.minHeight = util.option.asSize(options.minHeight, '');
    dom.root.style.width = util.option.asSize(options.width, '');

    // calculate border widths
    props.border.left = (dom.centerContainer.offsetWidth - dom.centerContainer.clientWidth) / 2;
    props.border.right = props.border.left;
    props.border.top = (dom.centerContainer.offsetHeight - dom.centerContainer.clientHeight) / 2;
    props.border.bottom = props.border.top;
    var borderRootHeight = dom.root.offsetHeight - dom.root.clientHeight;
    var borderRootWidth = dom.root.offsetWidth - dom.root.clientWidth;

    // workaround for a bug in IE: the clientWidth of an element with
    // a height:0px and overflow:hidden is not calculated and always has value 0
    if (dom.centerContainer.clientHeight === 0) {
      props.border.left = props.border.top;
      props.border.right = props.border.left;
    }
    if (dom.root.clientHeight === 0) {
      borderRootWidth = borderRootHeight;
    }

    // calculate the heights. If any of the side panels is empty, we set the height to
    // minus the border width, such that the border will be invisible
    props.center.height = dom.center.offsetHeight;
    props.left.height = dom.left.offsetHeight;
    props.right.height = dom.right.offsetHeight;
    props.top.height = dom.top.clientHeight || -props.border.top;
    props.bottom.height = dom.bottom.clientHeight || -props.border.bottom;

    // TODO: compensate borders when any of the panels is empty.

    // apply auto height
    // TODO: only calculate autoHeight when needed (else we cause an extra reflow/repaint of the DOM)
    var contentHeight = Math.max(props.left.height, props.center.height, props.right.height);
    var autoHeight = props.top.height + contentHeight + props.bottom.height + borderRootHeight + props.border.top + props.border.bottom;
    dom.root.style.height = util.option.asSize(options.height, autoHeight + 'px');

    // calculate heights of the content panels
    props.root.height = dom.root.offsetHeight;
    props.background.height = props.root.height - borderRootHeight;
    var containerHeight = props.root.height - props.top.height - props.bottom.height - borderRootHeight;
    props.centerContainer.height = containerHeight;
    props.leftContainer.height = containerHeight;
    props.rightContainer.height = props.leftContainer.height;

    // calculate the widths of the panels
    props.root.width = dom.root.offsetWidth;
    props.background.width = props.root.width - borderRootWidth;
    props.left.width = dom.leftContainer.clientWidth || -props.border.left;
    props.leftContainer.width = props.left.width;
    props.right.width = dom.rightContainer.clientWidth || -props.border.right;
    props.rightContainer.width = props.right.width;
    var centerWidth = props.root.width - props.left.width - props.right.width - borderRootWidth;
    props.center.width = centerWidth;
    props.centerContainer.width = centerWidth;
    props.top.width = centerWidth;
    props.bottom.width = centerWidth;

    // resize the panels
    dom.background.style.height = props.background.height + 'px';
    dom.backgroundVertical.style.height = props.background.height + 'px';
    dom.backgroundHorizontal.style.height = props.centerContainer.height + 'px';
    dom.centerContainer.style.height = props.centerContainer.height + 'px';
    dom.leftContainer.style.height = props.leftContainer.height + 'px';
    dom.rightContainer.style.height = props.rightContainer.height + 'px';

    dom.background.style.width = props.background.width + 'px';
    dom.backgroundVertical.style.width = props.centerContainer.width + 'px';
    dom.backgroundHorizontal.style.width = props.background.width + 'px';
    dom.centerContainer.style.width = props.center.width + 'px';
    dom.top.style.width = props.top.width + 'px';
    dom.bottom.style.width = props.bottom.width + 'px';

    // reposition the panels
    dom.background.style.left = '0';
    dom.background.style.top = '0';
    dom.backgroundVertical.style.left = props.left.width + props.border.left + 'px';
    dom.backgroundVertical.style.top = '0';
    dom.backgroundHorizontal.style.left = '0';
    dom.backgroundHorizontal.style.top = props.top.height + 'px';
    dom.centerContainer.style.left = props.left.width + 'px';
    dom.centerContainer.style.top = props.top.height + 'px';
    dom.leftContainer.style.left = '0';
    dom.leftContainer.style.top = props.top.height + 'px';
    dom.rightContainer.style.left = props.left.width + props.center.width + 'px';
    dom.rightContainer.style.top = props.top.height + 'px';
    dom.top.style.left = props.left.width + 'px';
    dom.top.style.top = '0';
    dom.bottom.style.left = props.left.width + 'px';
    dom.bottom.style.top = props.top.height + props.centerContainer.height + 'px';

    // update the scrollTop, feasible range for the offset can be changed
    // when the height of the Core or of the contents of the center changed
    this._updateScrollTop();

    // reposition the scrollable contents
    var offset = this.props.scrollTop;
    if (options.orientation.item != 'top') {
      offset += Math.max(this.props.centerContainer.height - this.props.center.height - this.props.border.top - this.props.border.bottom, 0);
    }
    dom.center.style.left = '0';
    dom.center.style.top = offset + 'px';
    dom.left.style.left = '0';
    dom.left.style.top = offset + 'px';
    dom.right.style.left = '0';
    dom.right.style.top = offset + 'px';

    // show shadows when vertical scrolling is available
    var visibilityTop = this.props.scrollTop == 0 ? 'hidden' : '';
    var visibilityBottom = this.props.scrollTop == this.props.scrollTopMin ? 'hidden' : '';
    dom.shadowTop.style.visibility = visibilityTop;
    dom.shadowBottom.style.visibility = visibilityBottom;
    dom.shadowTopLeft.style.visibility = visibilityTop;
    dom.shadowBottomLeft.style.visibility = visibilityBottom;
    dom.shadowTopRight.style.visibility = visibilityTop;
    dom.shadowBottomRight.style.visibility = visibilityBottom;

    // enable/disable vertical panning
    var contentsOverflow = this.props.center.height > this.props.centerContainer.height;
    this.hammer.get('pan').set({
      direction: contentsOverflow ? Hammer.DIRECTION_ALL : Hammer.DIRECTION_HORIZONTAL
    });

    // redraw all components
    this.components.forEach(function (component) {
      resized = component.redraw() || resized;
    });
    var MAX_REDRAW = 5;
    if (resized) {
      if (this.redrawCount < MAX_REDRAW) {
        this.body.emitter.emit('_change');
        return;
      } else {
        console.log('WARNING: infinite loop in redraw?');
      }
    } else {
      this.redrawCount = 0;
    }
    this.initialDrawDone = true;

    //Emit public 'changed' event for UI updates, see issue #1592
    this.body.emitter.emit("changed");
  };

  // TODO: deprecated since version 1.1.0, remove some day
  Core.prototype.repaint = function () {
    throw new Error('Function repaint is deprecated. Use redraw instead.');
  };

  /**
   * Set a current time. This can be used for example to ensure that a client's
   * time is synchronized with a shared server time.
   * Only applicable when option `showCurrentTime` is true.
   * @param {Date | String | Number} time     A Date, unix timestamp, or
   *                                          ISO date string.
   */
  Core.prototype.setCurrentTime = function (time) {
    if (!this.currentTime) {
      throw new Error('Option showCurrentTime must be true');
    }

    this.currentTime.setCurrentTime(time);
  };

  /**
   * Get the current time.
   * Only applicable when option `showCurrentTime` is true.
   * @return {Date} Returns the current time.
   */
  Core.prototype.getCurrentTime = function () {
    if (!this.currentTime) {
      throw new Error('Option showCurrentTime must be true');
    }

    return this.currentTime.getCurrentTime();
  };

  /**
   * Convert a position on screen (pixels) to a datetime
   * @param {int}     x    Position on the screen in pixels
   * @return {Date}   time The datetime the corresponds with given position x
   * @protected
   */
  // TODO: move this function to Range
  Core.prototype._toTime = function (x) {
    return DateUtil.toTime(this, x, this.props.center.width);
  };

  /**
   * Convert a position on the global screen (pixels) to a datetime
   * @param {int}     x    Position on the screen in pixels
   * @return {Date}   time The datetime the corresponds with given position x
   * @protected
   */
  // TODO: move this function to Range
  Core.prototype._toGlobalTime = function (x) {
    return DateUtil.toTime(this, x, this.props.root.width);
    //var conversion = this.range.conversion(this.props.root.width);
    //return new Date(x / conversion.scale + conversion.offset);
  };

  /**
   * Convert a datetime (Date object) into a position on the screen
   * @param {Date}   time A date
   * @return {int}   x    The position on the screen in pixels which corresponds
   *                      with the given date.
   * @protected
   */
  // TODO: move this function to Range
  Core.prototype._toScreen = function (time) {
    return DateUtil.toScreen(this, time, this.props.center.width);
  };

  /**
   * Convert a datetime (Date object) into a position on the root
   * This is used to get the pixel density estimate for the screen, not the center panel
   * @param {Date}   time A date
   * @return {int}   x    The position on root in pixels which corresponds
   *                      with the given date.
   * @protected
   */
  // TODO: move this function to Range
  Core.prototype._toGlobalScreen = function (time) {
    return DateUtil.toScreen(this, time, this.props.root.width);
    //var conversion = this.range.conversion(this.props.root.width);
    //return (time.valueOf() - conversion.offset) * conversion.scale;
  };

  /**
   * Initialize watching when option autoResize is true
   * @private
   */
  Core.prototype._initAutoResize = function () {
    if (this.options.autoResize == true) {
      this._startAutoResize();
    } else {
      this._stopAutoResize();
    }
  };

  /**
   * Watch for changes in the size of the container. On resize, the Panel will
   * automatically redraw itself.
   * @private
   */
  Core.prototype._startAutoResize = function () {
    var me = this;

    this._stopAutoResize();

    this._onResize = function () {
      if (me.options.autoResize != true) {
        // stop watching when the option autoResize is changed to false
        me._stopAutoResize();
        return;
      }

      if (me.dom.root) {
        // check whether the frame is resized
        // Note: we compare offsetWidth here, not clientWidth. For some reason,
        // IE does not restore the clientWidth from 0 to the actual width after
        // changing the timeline's container display style from none to visible
        if (me.dom.root.offsetWidth != me.props.lastWidth || me.dom.root.offsetHeight != me.props.lastHeight) {
          me.props.lastWidth = me.dom.root.offsetWidth;
          me.props.lastHeight = me.dom.root.offsetHeight;

          me.body.emitter.emit('_change');
        }
      }
    };

    // add event listener to window resize
    util.addEventListener(window, 'resize', this._onResize);

    //Prevent initial unnecessary redraw
    if (me.dom.root) {
      me.props.lastWidth = me.dom.root.offsetWidth;
      me.props.lastHeight = me.dom.root.offsetHeight;
    }

    this.watchTimer = setInterval(this._onResize, 1000);
  };

  /**
   * Stop watching for a resize of the frame.
   * @private
   */
  Core.prototype._stopAutoResize = function () {
    if (this.watchTimer) {
      clearInterval(this.watchTimer);
      this.watchTimer = undefined;
    }

    // remove event listener on window.resize
    if (this._onResize) {
      util.removeEventListener(window, 'resize', this._onResize);
      this._onResize = null;
    }
  };

  /**
   * Start moving the timeline vertically
   * @param {Event} event
   * @private
   */
  Core.prototype._onTouch = function (event) {
    this.touch.allowDragging = true;
    this.touch.initialScrollTop = this.props.scrollTop;
  };

  /**
   * Start moving the timeline vertically
   * @param {Event} event
   * @private
   */
  Core.prototype._onPinch = function (event) {
    this.touch.allowDragging = false;
  };

  /**
   * Move the timeline vertically
   * @param {Event} event
   * @private
   */
  Core.prototype._onDrag = function (event) {
    // refuse to drag when we where pinching to prevent the timeline make a jump
    // when releasing the fingers in opposite order from the touch screen
    if (!this.touch.allowDragging) return;

    var delta = event.deltaY;

    var oldScrollTop = this._getScrollTop();
    var newScrollTop = this._setScrollTop(this.touch.initialScrollTop + delta);

    if (newScrollTop != oldScrollTop) {
      this.emit("verticalDrag");
    }
  };

  /**
   * Apply a scrollTop
   * @param {Number} scrollTop
   * @returns {Number} scrollTop  Returns the applied scrollTop
   * @private
   */
  Core.prototype._setScrollTop = function (scrollTop) {
    this.props.scrollTop = scrollTop;
    this._updateScrollTop();
    return this.props.scrollTop;
  };

  /**
   * Update the current scrollTop when the height of  the containers has been changed
   * @returns {Number} scrollTop  Returns the applied scrollTop
   * @private
   */
  Core.prototype._updateScrollTop = function () {
    // recalculate the scrollTopMin
    var scrollTopMin = Math.min(this.props.centerContainer.height - this.props.center.height, 0); // is negative or zero
    if (scrollTopMin != this.props.scrollTopMin) {
      // in case of bottom orientation, change the scrollTop such that the contents
      // do not move relative to the time axis at the bottom
      if (this.options.orientation.item != 'top') {
        this.props.scrollTop += scrollTopMin - this.props.scrollTopMin;
      }
      this.props.scrollTopMin = scrollTopMin;
    }

    // limit the scrollTop to the feasible scroll range
    if (this.props.scrollTop > 0) this.props.scrollTop = 0;
    if (this.props.scrollTop < scrollTopMin) this.props.scrollTop = scrollTopMin;

    return this.props.scrollTop;
  };

  /**
   * Get the current scrollTop
   * @returns {number} scrollTop
   * @private
   */
  Core.prototype._getScrollTop = function () {
    return this.props.scrollTop;
  };

  /**
   * Load a configurator
   * @return {Object}
   * @private
   */
  Core.prototype._createConfigurator = function () {
    throw new Error('Cannot invoke abstract method _createConfigurator');
  };

  module.exports = Core;

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

  var Hammer = __webpack_require__(20);
  var util = __webpack_require__(1);
  var DataSet = __webpack_require__(9);
  var DataView = __webpack_require__(11);
  var TimeStep = __webpack_require__(35);
  var Component = __webpack_require__(31);
  var Group = __webpack_require__(36);
  var BackgroundGroup = __webpack_require__(40);
  var BoxItem = __webpack_require__(41);
  var PointItem = __webpack_require__(42);
  var RangeItem = __webpack_require__(38);
  var BackgroundItem = __webpack_require__(43);

  var UNGROUPED = '__ungrouped__'; // reserved group id for ungrouped items
  var BACKGROUND = '__background__'; // reserved group id for background items without group

  /**
   * An ItemSet holds a set of items and ranges which can be displayed in a
   * range. The width is determined by the parent of the ItemSet, and the height
   * is determined by the size of the items.
   * @param {{dom: Object, domProps: Object, emitter: Emitter, range: Range}} body
   * @param {Object} [options]      See ItemSet.setOptions for the available options.
   * @constructor ItemSet
   * @extends Component
   */
  function ItemSet(body, options) {
    this.body = body;
    this.defaultOptions = {
      rtl: false,
      type: null, // 'box', 'point', 'range', 'background'
      orientation: {
        item: 'bottom' // item orientation: 'top' or 'bottom'
      },
      align: 'auto', // alignment of box items
      stack: true,
      groupOrderSwap: function groupOrderSwap(fromGroup, toGroup, groups) {
        var targetOrder = toGroup.order;
        toGroup.order = fromGroup.order;
        fromGroup.order = targetOrder;
      },
      groupOrder: 'order',

      selectable: true,
      multiselect: false,
      itemsAlwaysDraggable: false,

      editable: {
        updateTime: false,
        updateGroup: false,
        add: false,
        remove: false
      },

      groupEditable: {
        order: false,
        add: false,
        remove: false
      },

      snap: TimeStep.snap,

      onAdd: function onAdd(item, callback) {
        callback(item);
      },
      onUpdate: function onUpdate(item, callback) {
        callback(item);
      },
      onMove: function onMove(item, callback) {
        callback(item);
      },
      onRemove: function onRemove(item, callback) {
        callback(item);
      },
      onMoving: function onMoving(item, callback) {
        callback(item);
      },
      onAddGroup: function onAddGroup(item, callback) {
        callback(item);
      },
      onMoveGroup: function onMoveGroup(item, callback) {
        callback(item);
      },
      onRemoveGroup: function onRemoveGroup(item, callback) {
        callback(item);
      },

      margin: {
        item: {
          horizontal: 10,
          vertical: 10
        },
        axis: 20
      }
    };

    // options is shared by this ItemSet and all its items
    this.options = util.extend({}, this.defaultOptions);

    // options for getting items from the DataSet with the correct type
    this.itemOptions = {
      type: { start: 'Date', end: 'Date' }
    };

    this.conversion = {
      toScreen: body.util.toScreen,
      toTime: body.util.toTime
    };
    this.dom = {};
    this.props = {};
    this.hammer = null;

    var me = this;
    this.itemsData = null; // DataSet
    this.groupsData = null; // DataSet

    // listeners for the DataSet of the items
    this.itemListeners = {
      'add': function add(event, params, senderId) {
        me._onAdd(params.items);
      },
      'update': function update(event, params, senderId) {
        me._onUpdate(params.items);
      },
      'remove': function remove(event, params, senderId) {
        me._onRemove(params.items);
      }
    };

    // listeners for the DataSet of the groups
    this.groupListeners = {
      'add': function add(event, params, senderId) {
        me._onAddGroups(params.items);
      },
      'update': function update(event, params, senderId) {
        me._onUpdateGroups(params.items);
      },
      'remove': function remove(event, params, senderId) {
        me._onRemoveGroups(params.items);
      }
    };

    this.items = {}; // object with an Item for every data item
    this.groups = {}; // Group object for every group
    this.groupIds = [];

    this.selection = []; // list with the ids of all selected nodes
    this.stackDirty = true; // if true, all items will be restacked on next redraw

    this.touchParams = {}; // stores properties while dragging
    this.groupTouchParams = {};
    // create the HTML DOM

    this._create();

    this.setOptions(options);
  }

  ItemSet.prototype = new Component();

  // available item types will be registered here
  ItemSet.types = {
    background: BackgroundItem,
    box: BoxItem,
    range: RangeItem,
    point: PointItem
  };

  /**
   * Create the HTML DOM for the ItemSet
   */
  ItemSet.prototype._create = function () {
    var frame = document.createElement('div');
    frame.className = 'vis-itemset';
    frame['timeline-itemset'] = this;
    this.dom.frame = frame;

    // create background panel
    var background = document.createElement('div');
    background.className = 'vis-background';
    frame.appendChild(background);
    this.dom.background = background;

    // create foreground panel
    var foreground = document.createElement('div');
    foreground.className = 'vis-foreground';
    frame.appendChild(foreground);
    this.dom.foreground = foreground;

    // create axis panel
    var axis = document.createElement('div');
    axis.className = 'vis-axis';
    this.dom.axis = axis;

    // create labelset
    var labelSet = document.createElement('div');
    labelSet.className = 'vis-labelset';
    this.dom.labelSet = labelSet;

    // create ungrouped Group
    this._updateUngrouped();

    // create background Group
    var backgroundGroup = new BackgroundGroup(BACKGROUND, null, this);
    backgroundGroup.show();
    this.groups[BACKGROUND] = backgroundGroup;

    // attach event listeners
    // Note: we bind to the centerContainer for the case where the height
    //       of the center container is larger than of the ItemSet, so we
    //       can click in the empty area to create a new item or deselect an item.
    this.hammer = new Hammer(this.body.dom.centerContainer);

    // drag items when selected
    this.hammer.on('hammer.input', function (event) {
      if (event.isFirst) {
        this._onTouch(event);
      }
    }.bind(this));
    this.hammer.on('panstart', this._onDragStart.bind(this));
    this.hammer.on('panmove', this._onDrag.bind(this));
    this.hammer.on('panend', this._onDragEnd.bind(this));
    this.hammer.get('pan').set({ threshold: 5, direction: Hammer.DIRECTION_HORIZONTAL });

    // single select (or unselect) when tapping an item
    this.hammer.on('tap', this._onSelectItem.bind(this));

    // multi select when holding mouse/touch, or on ctrl+click
    this.hammer.on('press', this._onMultiSelectItem.bind(this));

    // add item on doubletap
    this.hammer.on('doubletap', this._onAddItem.bind(this));
    this.groupHammer = new Hammer(this.body.dom.leftContainer);

    this.groupHammer.on('panstart', this._onGroupDragStart.bind(this));
    this.groupHammer.on('panmove', this._onGroupDrag.bind(this));
    this.groupHammer.on('panend', this._onGroupDragEnd.bind(this));
    this.groupHammer.get('pan').set({ threshold: 5, direction: Hammer.DIRECTION_HORIZONTAL });

    // attach to the DOM
    this.show();
  };

  /**
   * Set options for the ItemSet. Existing options will be extended/overwritten.
   * @param {Object} [options] The following options are available:
   *                           {String} type
   *                              Default type for the items. Choose from 'box'
   *                              (default), 'point', 'range', or 'background'.
   *                              The default style can be overwritten by
   *                              individual items.
   *                           {String} align
   *                              Alignment for the items, only applicable for
   *                              BoxItem. Choose 'center' (default), 'left', or
   *                              'right'.
   *                           {String} orientation.item
   *                              Orientation of the item set. Choose 'top' or
   *                              'bottom' (default).
   *                           {Function} groupOrder
   *                              A sorting function for ordering groups
   *                           {Boolean} stack
   *                              If true (default), items will be stacked on
   *                              top of each other.
   *                           {Number} margin.axis
   *                              Margin between the axis and the items in pixels.
   *                              Default is 20.
   *                           {Number} margin.item.horizontal
   *                              Horizontal margin between items in pixels.
   *                              Default is 10.
   *                           {Number} margin.item.vertical
   *                              Vertical Margin between items in pixels.
   *                              Default is 10.
   *                           {Number} margin.item
   *                              Margin between items in pixels in both horizontal
   *                              and vertical direction. Default is 10.
   *                           {Number} margin
   *                              Set margin for both axis and items in pixels.
   *                           {Boolean} selectable
   *                              If true (default), items can be selected.
   *                           {Boolean} multiselect
   *                              If true, multiple items can be selected.
   *                              False by default.
   *                           {Boolean} editable
   *                              Set all editable options to true or false
   *                           {Boolean} editable.updateTime
   *                              Allow dragging an item to an other moment in time
   *                           {Boolean} editable.updateGroup
   *                              Allow dragging an item to an other group
   *                           {Boolean} editable.add
   *                              Allow creating new items on double tap
   *                           {Boolean} editable.remove
   *                              Allow removing items by clicking the delete button
   *                              top right of a selected item.
   *                           {Function(item: Item, callback: Function)} onAdd
   *                              Callback function triggered when an item is about to be added:
   *                              when the user double taps an empty space in the Timeline.
   *                           {Function(item: Item, callback: Function)} onUpdate
   *                              Callback function fired when an item is about to be updated.
   *                              This function typically has to show a dialog where the user
   *                              change the item. If not implemented, nothing happens.
   *                           {Function(item: Item, callback: Function)} onMove
   *                              Fired when an item has been moved. If not implemented,
   *                              the move action will be accepted.
   *                           {Function(item: Item, callback: Function)} onRemove
   *                              Fired when an item is about to be deleted.
   *                              If not implemented, the item will be always removed.
   */
  ItemSet.prototype.setOptions = function (options) {
    if (options) {
      // copy all options that we know
      var fields = ['type', 'rtl', 'align', 'order', 'stack', 'selectable', 'multiselect', 'itemsAlwaysDraggable', 'multiselectPerGroup', 'groupOrder', 'dataAttributes', 'template', 'groupTemplate', 'hide', 'snap', 'groupOrderSwap'];
      util.selectiveExtend(fields, this.options, options);

      if ('orientation' in options) {
        if (typeof options.orientation === 'string') {
          this.options.orientation.item = options.orientation === 'top' ? 'top' : 'bottom';
        } else if (_typeof(options.orientation) === 'object' && 'item' in options.orientation) {
          this.options.orientation.item = options.orientation.item;
        }
      }

      if ('margin' in options) {
        if (typeof options.margin === 'number') {
          this.options.margin.axis = options.margin;
          this.options.margin.item.horizontal = options.margin;
          this.options.margin.item.vertical = options.margin;
        } else if (_typeof(options.margin) === 'object') {
          util.selectiveExtend(['axis'], this.options.margin, options.margin);
          if ('item' in options.margin) {
            if (typeof options.margin.item === 'number') {
              this.options.margin.item.horizontal = options.margin.item;
              this.options.margin.item.vertical = options.margin.item;
            } else if (_typeof(options.margin.item) === 'object') {
              util.selectiveExtend(['horizontal', 'vertical'], this.options.margin.item, options.margin.item);
            }
          }
        }
      }

      if ('editable' in options) {
        if (typeof options.editable === 'boolean') {
          this.options.editable.updateTime = options.editable;
          this.options.editable.updateGroup = options.editable;
          this.options.editable.add = options.editable;
          this.options.editable.remove = options.editable;
        } else if (_typeof(options.editable) === 'object') {
          util.selectiveExtend(['updateTime', 'updateGroup', 'add', 'remove'], this.options.editable, options.editable);
        }
      }

      if ('groupEditable' in options) {
        if (typeof options.groupEditable === 'boolean') {
          this.options.groupEditable.order = options.groupEditable;
          this.options.groupEditable.add = options.groupEditable;
          this.options.groupEditable.remove = options.groupEditable;
        } else if (_typeof(options.groupEditable) === 'object') {
          util.selectiveExtend(['order', 'add', 'remove'], this.options.groupEditable, options.groupEditable);
        }
      }

      // callback functions
      var addCallback = function (name) {
        var fn = options[name];
        if (fn) {
          if (!(fn instanceof Function)) {
            throw new Error('option ' + name + ' must be a function ' + name + '(item, callback)');
          }
          this.options[name] = fn;
        }
      }.bind(this);
      ['onAdd', 'onUpdate', 'onRemove', 'onMove', 'onMoving', 'onAddGroup', 'onMoveGroup', 'onRemoveGroup'].forEach(addCallback);

      // force the itemSet to refresh: options like orientation and margins may be changed
      this.markDirty();
    }
  };

  /**
   * Mark the ItemSet dirty so it will refresh everything with next redraw.
   * Optionally, all items can be marked as dirty and be refreshed.
   * @param {{refreshItems: boolean}} [options]
   */
  ItemSet.prototype.markDirty = function (options) {
    this.groupIds = [];
    this.stackDirty = true;

    if (options && options.refreshItems) {
      util.forEach(this.items, function (item) {
        item.dirty = true;
        if (item.displayed) item.redraw();
      });
    }
  };

  /**
   * Destroy the ItemSet
   */
  ItemSet.prototype.destroy = function () {
    this.hide();
    this.setItems(null);
    this.setGroups(null);

    this.hammer = null;

    this.body = null;
    this.conversion = null;
  };

  /**
   * Hide the component from the DOM
   */
  ItemSet.prototype.hide = function () {
    // remove the frame containing the items
    if (this.dom.frame.parentNode) {
      this.dom.frame.parentNode.removeChild(this.dom.frame);
    }

    // remove the axis with dots
    if (this.dom.axis.parentNode) {
      this.dom.axis.parentNode.removeChild(this.dom.axis);
    }

    // remove the labelset containing all group labels
    if (this.dom.labelSet.parentNode) {
      this.dom.labelSet.parentNode.removeChild(this.dom.labelSet);
    }
  };

  /**
   * Show the component in the DOM (when not already visible).
   * @return {Boolean} changed
   */
  ItemSet.prototype.show = function () {
    // show frame containing the items
    if (!this.dom.frame.parentNode) {
      this.body.dom.center.appendChild(this.dom.frame);
    }

    // show axis with dots
    if (!this.dom.axis.parentNode) {
      this.body.dom.backgroundVertical.appendChild(this.dom.axis);
    }

    // show labelset containing labels
    if (!this.dom.labelSet.parentNode) {
      this.body.dom.left.appendChild(this.dom.labelSet);
    }
  };

  /**
   * Set selected items by their id. Replaces the current selection
   * Unknown id's are silently ignored.
   * @param {string[] | string} [ids] An array with zero or more id's of the items to be
   *                                  selected, or a single item id. If ids is undefined
   *                                  or an empty array, all items will be unselected.
   */
  ItemSet.prototype.setSelection = function (ids) {
    var i, ii, id, item;

    if (ids == undefined) ids = [];
    if (!Array.isArray(ids)) ids = [ids];

    // unselect currently selected items
    for (i = 0, ii = this.selection.length; i < ii; i++) {
      id = this.selection[i];
      item = this.items[id];
      if (item) item.unselect();
    }

    // select items
    this.selection = [];
    for (i = 0, ii = ids.length; i < ii; i++) {
      id = ids[i];
      item = this.items[id];
      if (item) {
        this.selection.push(id);
        item.select();
      }
    }
  };

  /**
   * Get the selected items by their id
   * @return {Array} ids  The ids of the selected items
   */
  ItemSet.prototype.getSelection = function () {
    return this.selection.concat([]);
  };

  /**
   * Get the id's of the currently visible items.
   * @returns {Array} The ids of the visible items
   */
  ItemSet.prototype.getVisibleItems = function () {
    var range = this.body.range.getRange();

    if (this.options.rtl) {
      var right = this.body.util.toScreen(range.start);
      var left = this.body.util.toScreen(range.end);
    } else {
      var left = this.body.util.toScreen(range.start);
      var right = this.body.util.toScreen(range.end);
    }

    var ids = [];
    for (var groupId in this.groups) {
      if (this.groups.hasOwnProperty(groupId)) {
        var group = this.groups[groupId];
        var rawVisibleItems = group.visibleItems;

        // filter the "raw" set with visibleItems into a set which is really
        // visible by pixels
        for (var i = 0; i < rawVisibleItems.length; i++) {
          var item = rawVisibleItems[i];
          // TODO: also check whether visible vertically
          if (this.options.rtl) {
            if (item.right < left && item.right + item.width > right) {
              ids.push(item.id);
            }
          } else {
            if (item.left < right && item.left + item.width > left) {
              ids.push(item.id);
            }
          }
        }
      }
    }

    return ids;
  };

  /**
   * Deselect a selected item
   * @param {String | Number} id
   * @private
   */
  ItemSet.prototype._deselect = function (id) {
    var selection = this.selection;
    for (var i = 0, ii = selection.length; i < ii; i++) {
      if (selection[i] == id) {
        // non-strict comparison!
        selection.splice(i, 1);
        break;
      }
    }
  };

  /**
   * Repaint the component
   * @return {boolean} Returns true if the component is resized
   */
  ItemSet.prototype.redraw = function () {
    var margin = this.options.margin,
        range = this.body.range,
        asSize = util.option.asSize,
        options = this.options,
        orientation = options.orientation.item,
        resized = false,
        frame = this.dom.frame;

    // recalculate absolute position (before redrawing groups)
    this.props.top = this.body.domProps.top.height + this.body.domProps.border.top;

    if (this.options.rtl) {
      this.props.right = this.body.domProps.right.width + this.body.domProps.border.right;
    } else {
      this.props.left = this.body.domProps.left.width + this.body.domProps.border.left;
    }

    // update class name
    frame.className = 'vis-itemset';

    // reorder the groups (if needed)
    resized = this._orderGroups() || resized;

    // check whether zoomed (in that case we need to re-stack everything)
    // TODO: would be nicer to get this as a trigger from Range
    var visibleInterval = range.end - range.start;
    var zoomed = visibleInterval != this.lastVisibleInterval || this.props.width != this.props.lastWidth;
    if (zoomed) this.stackDirty = true;
    this.lastVisibleInterval = visibleInterval;
    this.props.lastWidth = this.props.width;

    var restack = this.stackDirty;
    var firstGroup = this._firstGroup();
    var firstMargin = {
      item: margin.item,
      axis: margin.axis
    };
    var nonFirstMargin = {
      item: margin.item,
      axis: margin.item.vertical / 2
    };
    var height = 0;
    var minHeight = margin.axis + margin.item.vertical;

    // redraw the background group
    this.groups[BACKGROUND].redraw(range, nonFirstMargin, restack);

    // redraw all regular groups
    util.forEach(this.groups, function (group) {
      var groupMargin = group == firstGroup ? firstMargin : nonFirstMargin;
      var groupResized = group.redraw(range, groupMargin, restack);
      resized = groupResized || resized;
      height += group.height;
    });
    height = Math.max(height, minHeight);
    this.stackDirty = false;

    // update frame height
    frame.style.height = asSize(height);

    // calculate actual size
    this.props.width = frame.offsetWidth;
    this.props.height = height;

    // reposition axis
    this.dom.axis.style.top = asSize(orientation == 'top' ? this.body.domProps.top.height + this.body.domProps.border.top : this.body.domProps.top.height + this.body.domProps.centerContainer.height);
    if (this.options.rtl) {
      this.dom.axis.style.right = '0';
    } else {
      this.dom.axis.style.left = '0';
    }

    // check if this component is resized
    resized = this._isResized() || resized;

    return resized;
  };

  /**
   * Get the first group, aligned with the axis
   * @return {Group | null} firstGroup
   * @private
   */
  ItemSet.prototype._firstGroup = function () {
    var firstGroupIndex = this.options.orientation.item == 'top' ? 0 : this.groupIds.length - 1;
    var firstGroupId = this.groupIds[firstGroupIndex];
    var firstGroup = this.groups[firstGroupId] || this.groups[UNGROUPED];

    return firstGroup || null;
  };

  /**
   * Create or delete the group holding all ungrouped items. This group is used when
   * there are no groups specified.
   * @protected
   */
  ItemSet.prototype._updateUngrouped = function () {
    var ungrouped = this.groups[UNGROUPED];
    var background = this.groups[BACKGROUND];
    var item, itemId;

    if (this.groupsData) {
      // remove the group holding all ungrouped items
      if (ungrouped) {
        ungrouped.hide();
        delete this.groups[UNGROUPED];

        for (itemId in this.items) {
          if (this.items.hasOwnProperty(itemId)) {
            item = this.items[itemId];
            item.parent && item.parent.remove(item);
            var groupId = this._getGroupId(item.data);
            var group = this.groups[groupId];
            group && group.add(item) || item.hide();
          }
        }
      }
    } else {
      // create a group holding all (unfiltered) items
      if (!ungrouped) {
        var id = null;
        var data = null;
        ungrouped = new Group(id, data, this);
        this.groups[UNGROUPED] = ungrouped;

        for (itemId in this.items) {
          if (this.items.hasOwnProperty(itemId)) {
            item = this.items[itemId];
            ungrouped.add(item);
          }
        }

        ungrouped.show();
      }
    }
  };

  /**
   * Get the element for the labelset
   * @return {HTMLElement} labelSet
   */
  ItemSet.prototype.getLabelSet = function () {
    return this.dom.labelSet;
  };

  /**
   * Set items
   * @param {vis.DataSet | null} items
   */
  ItemSet.prototype.setItems = function (items) {
    var me = this,
        ids,
        oldItemsData = this.itemsData;

    // replace the dataset
    if (!items) {
      this.itemsData = null;
    } else if (items instanceof DataSet || items instanceof DataView) {
      this.itemsData = items;
    } else {
      throw new TypeError('Data must be an instance of DataSet or DataView');
    }

    if (oldItemsData) {
      // unsubscribe from old dataset
      util.forEach(this.itemListeners, function (callback, event) {
        oldItemsData.off(event, callback);
      });

      // remove all drawn items
      ids = oldItemsData.getIds();
      this._onRemove(ids);
    }

    if (this.itemsData) {
      // subscribe to new dataset
      var id = this.id;
      util.forEach(this.itemListeners, function (callback, event) {
        me.itemsData.on(event, callback, id);
      });

      // add all new items
      ids = this.itemsData.getIds();
      this._onAdd(ids);

      // update the group holding all ungrouped items
      this._updateUngrouped();
    }

    this.body.emitter.emit('_change', { queue: true });
  };

  /**
   * Get the current items
   * @returns {vis.DataSet | null}
   */
  ItemSet.prototype.getItems = function () {
    return this.itemsData;
  };

  /**
   * Set groups
   * @param {vis.DataSet} groups
   */
  ItemSet.prototype.setGroups = function (groups) {
    var me = this,
        ids;

    // unsubscribe from current dataset
    if (this.groupsData) {
      util.forEach(this.groupListeners, function (callback, event) {
        me.groupsData.off(event, callback);
      });

      // remove all drawn groups
      ids = this.groupsData.getIds();
      this.groupsData = null;
      this._onRemoveGroups(ids); // note: this will cause a redraw
    }

    // replace the dataset
    if (!groups) {
      this.groupsData = null;
    } else if (groups instanceof DataSet || groups instanceof DataView) {
      this.groupsData = groups;
    } else {
      throw new TypeError('Data must be an instance of DataSet or DataView');
    }

    if (this.groupsData) {
      // subscribe to new dataset
      var id = this.id;
      util.forEach(this.groupListeners, function (callback, event) {
        me.groupsData.on(event, callback, id);
      });

      // draw all ms
      ids = this.groupsData.getIds();
      this._onAddGroups(ids);
    }

    // update the group holding all ungrouped items
    this._updateUngrouped();

    // update the order of all items in each group
    this._order();

    this.body.emitter.emit('_change', { queue: true });
  };

  /**
   * Get the current groups
   * @returns {vis.DataSet | null} groups
   */
  ItemSet.prototype.getGroups = function () {
    return this.groupsData;
  };

  /**
   * Remove an item by its id
   * @param {String | Number} id
   */
  ItemSet.prototype.removeItem = function (id) {
    var item = this.itemsData.get(id),
        dataset = this.itemsData.getDataSet();

    if (item) {
      // confirm deletion
      this.options.onRemove(item, function (item) {
        if (item) {
          // remove by id here, it is possible that an item has no id defined
          // itself, so better not delete by the item itself
          dataset.remove(id);
        }
      });
    }
  };

  /**
   * Get the time of an item based on it's data and options.type
   * @param {Object} itemData
   * @returns {string} Returns the type
   * @private
   */
  ItemSet.prototype._getType = function (itemData) {
    return itemData.type || this.options.type || (itemData.end ? 'range' : 'box');
  };

  /**
   * Get the group id for an item
   * @param {Object} itemData
   * @returns {string} Returns the groupId
   * @private
   */
  ItemSet.prototype._getGroupId = function (itemData) {
    var type = this._getType(itemData);
    if (type == 'background' && itemData.group == undefined) {
      return BACKGROUND;
    } else {
      return this.groupsData ? itemData.group : UNGROUPED;
    }
  };

  /**
   * Handle updated items
   * @param {Number[]} ids
   * @protected
   */
  ItemSet.prototype._onUpdate = function (ids) {
    var me = this;

    ids.forEach(function (id) {
      var itemData = me.itemsData.get(id, me.itemOptions);
      var item = me.items[id];
      var type = me._getType(itemData);

      var constructor = ItemSet.types[type];
      var selected;

      if (item) {
        // update item
        if (!constructor || !(item instanceof constructor)) {
          // item type has changed, delete the item and recreate it
          selected = item.selected; // preserve selection of this item
          me._removeItem(item);
          item = null;
        } else {
          me._updateItem(item, itemData);
        }
      }

      if (!item) {
        // create item
        if (constructor) {
          item = new constructor(itemData, me.conversion, me.options);
          item.id = id; // TODO: not so nice setting id afterwards
          me._addItem(item);
          if (selected) {
            this.selection.push(id);
            item.select();
          }
        } else if (type == 'rangeoverflow') {
          // TODO: deprecated since version 2.1.0 (or 3.0.0?). cleanup some day
          throw new TypeError('Item type "rangeoverflow" is deprecated. Use css styling instead: ' + '.vis-item.vis-range .vis-item-content {overflow: visible;}');
        } else {
          throw new TypeError('Unknown item type "' + type + '"');
        }
      }
    }.bind(this));

    this._order();
    this.stackDirty = true; // force re-stacking of all items next redraw
    this.body.emitter.emit('_change', { queue: true });
  };

  /**
   * Handle added items
   * @param {Number[]} ids
   * @protected
   */
  ItemSet.prototype._onAdd = ItemSet.prototype._onUpdate;

  /**
   * Handle removed items
   * @param {Number[]} ids
   * @protected
   */
  ItemSet.prototype._onRemove = function (ids) {
    var count = 0;
    var me = this;
    ids.forEach(function (id) {
      var item = me.items[id];
      if (item) {
        count++;
        me._removeItem(item);
      }
    });

    if (count) {
      // update order
      this._order();
      this.stackDirty = true; // force re-stacking of all items next redraw
      this.body.emitter.emit('_change', { queue: true });
    }
  };

  /**
   * Update the order of item in all groups
   * @private
   */
  ItemSet.prototype._order = function () {
    // reorder the items in all groups
    // TODO: optimization: only reorder groups affected by the changed items
    util.forEach(this.groups, function (group) {
      group.order();
    });
  };

  /**
   * Handle updated groups
   * @param {Number[]} ids
   * @private
   */
  ItemSet.prototype._onUpdateGroups = function (ids) {
    this._onAddGroups(ids);
  };

  /**
   * Handle changed groups (added or updated)
   * @param {Number[]} ids
   * @private
   */
  ItemSet.prototype._onAddGroups = function (ids) {
    var me = this;

    ids.forEach(function (id) {
      var groupData = me.groupsData.get(id);
      var group = me.groups[id];

      if (!group) {
        // check for reserved ids
        if (id == UNGROUPED || id == BACKGROUND) {
          throw new Error('Illegal group id. ' + id + ' is a reserved id.');
        }

        var groupOptions = Object.create(me.options);
        util.extend(groupOptions, {
          height: null
        });

        group = new Group(id, groupData, me);
        me.groups[id] = group;

        // add items with this groupId to the new group
        for (var itemId in me.items) {
          if (me.items.hasOwnProperty(itemId)) {
            var item = me.items[itemId];
            if (item.data.group == id) {
              group.add(item);
            }
          }
        }

        group.order();
        group.show();
      } else {
        // update group
        group.setData(groupData);
      }
    });

    this.body.emitter.emit('_change', { queue: true });
  };

  /**
   * Handle removed groups
   * @param {Number[]} ids
   * @private
   */
  ItemSet.prototype._onRemoveGroups = function (ids) {
    var groups = this.groups;
    ids.forEach(function (id) {
      var group = groups[id];

      if (group) {
        group.hide();
        delete groups[id];
      }
    });

    this.markDirty();

    this.body.emitter.emit('_change', { queue: true });
  };

  /**
   * Reorder the groups if needed
   * @return {boolean} changed
   * @private
   */
  ItemSet.prototype._orderGroups = function () {
    if (this.groupsData) {
      // reorder the groups
      var groupIds = this.groupsData.getIds({
        order: this.options.groupOrder
      });

      var changed = !util.equalArray(groupIds, this.groupIds);
      if (changed) {
        // hide all groups, removes them from the DOM
        var groups = this.groups;
        groupIds.forEach(function (groupId) {
          groups[groupId].hide();
        });

        // show the groups again, attach them to the DOM in correct order
        groupIds.forEach(function (groupId) {
          groups[groupId].show();
        });

        this.groupIds = groupIds;
      }

      return changed;
    } else {
      return false;
    }
  };

  /**
   * Add a new item
   * @param {Item} item
   * @private
   */
  ItemSet.prototype._addItem = function (item) {
    this.items[item.id] = item;

    // add to group
    var groupId = this._getGroupId(item.data);
    var group = this.groups[groupId];
    if (group) group.add(item);
  };

  /**
   * Update an existing item
   * @param {Item} item
   * @param {Object} itemData
   * @private
   */
  ItemSet.prototype._updateItem = function (item, itemData) {
    var oldGroupId = item.data.group;
    var oldSubGroupId = item.data.subgroup;

    // update the items data (will redraw the item when displayed)
    item.setData(itemData);

    // update group
    if (oldGroupId != item.data.group || oldSubGroupId != item.data.subgroup) {
      var oldGroup = this.groups[oldGroupId];
      if (oldGroup) oldGroup.remove(item);

      var groupId = this._getGroupId(item.data);
      var group = this.groups[groupId];
      if (group) group.add(item);
    }
  };

  /**
   * Delete an item from the ItemSet: remove it from the DOM, from the map
   * with items, and from the map with visible items, and from the selection
   * @param {Item} item
   * @private
   */
  ItemSet.prototype._removeItem = function (item) {
    // remove from DOM
    item.hide();

    // remove from items
    delete this.items[item.id];

    // remove from selection
    var index = this.selection.indexOf(item.id);
    if (index != -1) this.selection.splice(index, 1);

    // remove from group
    item.parent && item.parent.remove(item);
  };

  /**
   * Create an array containing all items being a range (having an end date)
   * @param array
   * @returns {Array}
   * @private
   */
  ItemSet.prototype._constructByEndArray = function (array) {
    var endArray = [];

    for (var i = 0; i < array.length; i++) {
      if (array[i] instanceof RangeItem) {
        endArray.push(array[i]);
      }
    }
    return endArray;
  };

  /**
   * Register the clicked item on touch, before dragStart is initiated.
   *
   * dragStart is initiated from a mousemove event, AFTER the mouse/touch is
   * already moving. Therefore, the mouse/touch can sometimes be above an other
   * DOM element than the item itself.
   *
   * @param {Event} event
   * @private
   */
  ItemSet.prototype._onTouch = function (event) {
    // store the touched item, used in _onDragStart
    this.touchParams.item = this.itemFromTarget(event);
    this.touchParams.dragLeftItem = event.target.dragLeftItem || false;
    this.touchParams.dragRightItem = event.target.dragRightItem || false;
    this.touchParams.itemProps = null;
  };

  /**
   * Given an group id, returns the index it has.
   *
   * @param {Number} groupID
   * @private
   */
  ItemSet.prototype._getGroupIndex = function (groupId) {
    for (var i = 0; i < this.groupIds.length; i++) {
      if (groupId == this.groupIds[i]) return i;
    }
  };

  /**
   * Start dragging the selected events
   * @param {Event} event
   * @private
   */
  ItemSet.prototype._onDragStart = function (event) {
    var item = this.touchParams.item || null;
    var me = this;
    var props;

    if (item && (item.selected || this.options.itemsAlwaysDraggable)) {

      if (!this.options.editable.updateTime && !this.options.editable.updateGroup && !item.editable) {
        return;
      }

      // override options.editable
      if (item.editable === false) {
        return;
      }

      var dragLeftItem = this.touchParams.dragLeftItem;
      var dragRightItem = this.touchParams.dragRightItem;

      if (dragLeftItem) {
        props = {
          item: dragLeftItem,
          initialX: event.center.x,
          dragLeft: true,
          data: this._cloneItemData(item.data)
        };

        this.touchParams.itemProps = [props];
      } else if (dragRightItem) {
        props = {
          item: dragRightItem,
          initialX: event.center.x,
          dragRight: true,
          data: this._cloneItemData(item.data)
        };

        this.touchParams.itemProps = [props];
      } else {
        this.touchParams.selectedItem = item;

        var baseGroupIndex = this._getGroupIndex(item.data.group);

        var itemsToDrag = this.options.itemsAlwaysDraggable && !item.selected ? [item.id] : this.getSelection();

        this.touchParams.itemProps = itemsToDrag.map(function (id) {
          var item = me.items[id];
          var groupIndex = me._getGroupIndex(item.data.group);
          return {
            item: item,
            initialX: event.center.x,
            groupOffset: baseGroupIndex - groupIndex,
            data: this._cloneItemData(item.data)
          };
        }.bind(this));
      }

      event.stopPropagation();
    } else if (this.options.editable.add && (event.srcEvent.ctrlKey || event.srcEvent.metaKey)) {
      // create a new range item when dragging with ctrl key down
      this._onDragStartAddItem(event);
    }
  };

  /**
   * Start creating a new range item by dragging.
   * @param {Event} event
   * @private
   */
  ItemSet.prototype._onDragStartAddItem = function (event) {
    var snap = this.options.snap || null;

    if (this.options.rtl) {
      var xAbs = util.getAbsoluteRight(this.dom.frame);
      var x = xAbs - event.center.x + 10; // plus 10 to compensate for the drag starting as soon as you've moved 10px
    } else {
        var xAbs = util.getAbsoluteLeft(this.dom.frame);
        var x = event.center.x - xAbs - 10; // minus 10 to compensate for the drag starting as soon as you've moved 10px
      }

    var time = this.body.util.toTime(x);
    var scale = this.body.util.getScale();
    var step = this.body.util.getStep();
    var start = snap ? snap(time, scale, step) : time;
    var end = start;

    var itemData = {
      type: 'range',
      start: start,
      end: end,
      content: 'new item'
    };

    var id = util.randomUUID();
    itemData[this.itemsData._fieldId] = id;

    var group = this.groupFromTarget(event);
    if (group) {
      itemData.group = group.groupId;
    }
    var newItem = new RangeItem(itemData, this.conversion, this.options);
    newItem.id = id; // TODO: not so nice setting id afterwards
    newItem.data = this._cloneItemData(itemData);
    this._addItem(newItem);

    var props = {
      item: newItem,
      initialX: event.center.x,
      data: newItem.data
    };

    if (this.options.rtl) {
      props.dragLeft = true;
    } else {
      props.dragRight = true;
    }
    this.touchParams.itemProps = [props];

    event.stopPropagation();
  };

  /**
   * Drag selected items
   * @param {Event} event
   * @private
   */
  ItemSet.prototype._onDrag = function (event) {
    if (this.touchParams.itemProps) {
      event.stopPropagation();

      var me = this;
      var snap = this.options.snap || null;

      if (this.options.rtl) {
        var xOffset = this.body.dom.root.offsetLeft + this.body.domProps.right.width;
      } else {
        var xOffset = this.body.dom.root.offsetLeft + this.body.domProps.left.width;
      }

      var scale = this.body.util.getScale();
      var step = this.body.util.getStep();

      //only calculate the new group for the item that's actually dragged
      var selectedItem = this.touchParams.selectedItem;
      var updateGroupAllowed = me.options.editable.updateGroup;
      var newGroupBase = null;
      if (updateGroupAllowed && selectedItem) {
        if (selectedItem.data.group != undefined) {
          // drag from one group to another
          var group = me.groupFromTarget(event);
          if (group) {
            //we know the offset for all items, so the new group for all items
            //will be relative to this one.
            newGroupBase = this._getGroupIndex(group.groupId);
          }
        }
      }

      // move
      this.touchParams.itemProps.forEach(function (props) {
        var current = me.body.util.toTime(event.center.x - xOffset);
        var initial = me.body.util.toTime(props.initialX - xOffset);

        if (this.options.rtl) {
          var offset = -(current - initial); // ms
        } else {
            var offset = current - initial; // ms
          }

        var itemData = this._cloneItemData(props.item.data); // clone the data
        if (props.item.editable === false) {
          return;
        }

        var updateTimeAllowed = me.options.editable.updateTime || props.item.editable === true;
        if (updateTimeAllowed) {
          if (props.dragLeft) {
            // drag left side of a range item
            if (this.options.rtl) {
              if (itemData.end != undefined) {
                var initialEnd = util.convert(props.data.end, 'Date');
                var end = new Date(initialEnd.valueOf() + offset);
                // TODO: pass a Moment instead of a Date to snap(). (Breaking change)
                itemData.end = snap ? snap(end, scale, step) : end;
              }
            } else {
              if (itemData.start != undefined) {
                var initialStart = util.convert(props.data.start, 'Date');
                var start = new Date(initialStart.valueOf() + offset);
                // TODO: pass a Moment instead of a Date to snap(). (Breaking change)
                itemData.start = snap ? snap(start, scale, step) : start;
              }
            }
          } else if (props.dragRight) {
            // drag right side of a range item
            if (this.options.rtl) {
              if (itemData.start != undefined) {
                var initialStart = util.convert(props.data.start, 'Date');
                var start = new Date(initialStart.valueOf() + offset);
                // TODO: pass a Moment instead of a Date to snap(). (Breaking change)
                itemData.start = snap ? snap(start, scale, step) : start;
              }
            } else {
              if (itemData.end != undefined) {
                var initialEnd = util.convert(props.data.end, 'Date');
                var end = new Date(initialEnd.valueOf() + offset);
                // TODO: pass a Moment instead of a Date to snap(). (Breaking change)
                itemData.end = snap ? snap(end, scale, step) : end;
              }
            }
          } else {
            // drag both start and end
            if (itemData.start != undefined) {

              var initialStart = util.convert(props.data.start, 'Date').valueOf();
              var start = new Date(initialStart + offset);

              if (itemData.end != undefined) {
                var initialEnd = util.convert(props.data.end, 'Date');
                var duration = initialEnd.valueOf() - initialStart.valueOf();

                // TODO: pass a Moment instead of a Date to snap(). (Breaking change)
                itemData.start = snap ? snap(start, scale, step) : start;
                itemData.end = new Date(itemData.start.valueOf() + duration);
              } else {
                // TODO: pass a Moment instead of a Date to snap(). (Breaking change)
                itemData.start = snap ? snap(start, scale, step) : start;
              }
            }
          }
        }

        var updateGroupAllowed = me.options.editable.updateGroup || props.item.editable === true;

        if (updateGroupAllowed && !props.dragLeft && !props.dragRight && newGroupBase != null) {
          if (itemData.group != undefined) {
            var newOffset = newGroupBase - props.groupOffset;

            //make sure we stay in bounds
            newOffset = Math.max(0, newOffset);
            newOffset = Math.min(me.groupIds.length - 1, newOffset);

            itemData.group = me.groupIds[newOffset];
          }
        }

        // confirm moving the item
        itemData = this._cloneItemData(itemData); // convert start and end to the correct type
        me.options.onMoving(itemData, function (itemData) {
          if (itemData) {
            props.item.setData(this._cloneItemData(itemData, 'Date'));
          }
        }.bind(this));
      }.bind(this));

      this.stackDirty = true; // force re-stacking of all items next redraw
      this.body.emitter.emit('_change');
    }
  };

  /**
   * Move an item to another group
   * @param {Item} item
   * @param {String | Number} groupId
   * @private
   */
  ItemSet.prototype._moveToGroup = function (item, groupId) {
    var group = this.groups[groupId];
    if (group && group.groupId != item.data.group) {
      var oldGroup = item.parent;
      oldGroup.remove(item);
      oldGroup.order();
      group.add(item);
      group.order();

      item.data.group = group.groupId;
    }
  };

  /**
   * End of dragging selected items
   * @param {Event} event
   * @private
   */
  ItemSet.prototype._onDragEnd = function (event) {
    if (this.touchParams.itemProps) {
      event.stopPropagation();

      var me = this;
      var dataset = this.itemsData.getDataSet();
      var itemProps = this.touchParams.itemProps;
      this.touchParams.itemProps = null;

      itemProps.forEach(function (props) {
        var id = props.item.id;
        var exists = me.itemsData.get(id, me.itemOptions) != null;

        if (!exists) {
          // add a new item
          me.options.onAdd(props.item.data, function (itemData) {
            me._removeItem(props.item); // remove temporary item
            if (itemData) {
              me.itemsData.getDataSet().add(itemData);
            }

            // force re-stacking of all items next redraw
            me.stackDirty = true;
            me.body.emitter.emit('_change');
          });
        } else {
          // update existing item
          var itemData = this._cloneItemData(props.item.data); // convert start and end to the correct type
          me.options.onMove(itemData, function (itemData) {
            if (itemData) {
              // apply changes
              itemData[dataset._fieldId] = id; // ensure the item contains its id (can be undefined)
              dataset.update(itemData);
            } else {
              // restore original values
              props.item.setData(props.data);

              me.stackDirty = true; // force re-stacking of all items next redraw
              me.body.emitter.emit('_change');
            }
          });
        }
      }.bind(this));
    }
  };

  ItemSet.prototype._onGroupDragStart = function (event) {
    if (this.options.groupEditable.order) {
      this.groupTouchParams.group = this.groupFromTarget(event);

      if (this.groupTouchParams.group) {
        event.stopPropagation();

        this.groupTouchParams.originalOrder = this.groupsData.getIds({
          order: this.options.groupOrder
        });
      }
    }
  };

  ItemSet.prototype._onGroupDrag = function (event) {
    if (this.options.groupEditable.order && this.groupTouchParams.group) {
      event.stopPropagation();

      // drag from one group to another
      var group = this.groupFromTarget(event);

      // try to avoid toggling when groups differ in height
      if (group && group.height != this.groupTouchParams.group.height) {
        var movingUp = group.top < this.groupTouchParams.group.top;
        var clientY = event.center ? event.center.y : event.clientY;
        var targetGroupTop = util.getAbsoluteTop(group.dom.foreground);
        var draggedGroupHeight = this.groupTouchParams.group.height;
        if (movingUp) {
          // skip swapping the groups when the dragged group is not below clientY afterwards
          if (targetGroupTop + draggedGroupHeight < clientY) {
            return;
          }
        } else {
          var targetGroupHeight = group.height;
          // skip swapping the groups when the dragged group is not below clientY afterwards
          if (targetGroupTop + targetGroupHeight - draggedGroupHeight > clientY) {
            return;
          }
        }
      }

      if (group && group != this.groupTouchParams.group) {
        var groupsData = this.groupsData;
        var targetGroup = groupsData.get(group.groupId);
        var draggedGroup = groupsData.get(this.groupTouchParams.group.groupId);

        // switch groups
        if (draggedGroup && targetGroup) {
          this.options.groupOrderSwap(draggedGroup, targetGroup, this.groupsData);
          this.groupsData.update(draggedGroup);
          this.groupsData.update(targetGroup);
        }

        // fetch current order of groups
        var newOrder = this.groupsData.getIds({
          order: this.options.groupOrder
        });

        // in case of changes since _onGroupDragStart
        if (!util.equalArray(newOrder, this.groupTouchParams.originalOrder)) {
          var groupsData = this.groupsData;
          var origOrder = this.groupTouchParams.originalOrder;
          var draggedId = this.groupTouchParams.group.groupId;
          var numGroups = Math.min(origOrder.length, newOrder.length);
          var curPos = 0;
          var newOffset = 0;
          var orgOffset = 0;
          while (curPos < numGroups) {
            // as long as the groups are where they should be step down along the groups order
            while (curPos + newOffset < numGroups && curPos + orgOffset < numGroups && newOrder[curPos + newOffset] == origOrder[curPos + orgOffset]) {
              curPos++;
            }

            // all ok
            if (curPos + newOffset >= numGroups) {
              break;
            }

            // not all ok
            // if dragged group was move upwards everything below should have an offset
            if (newOrder[curPos + newOffset] == draggedId) {
              newOffset = 1;
              continue;
            }
            // if dragged group was move downwards everything above should have an offset
            else if (origOrder[curPos + orgOffset] == draggedId) {
                orgOffset = 1;
                continue;
              }
              // found a group (apart from dragged group) that has the wrong position -> switch with the
              // group at the position where other one should be, fix index arrays and continue
              else {
                  var slippedPosition = newOrder.indexOf(origOrder[curPos + orgOffset]);
                  var switchGroup = groupsData.get(newOrder[curPos + newOffset]);
                  var shouldBeGroup = groupsData.get(origOrder[curPos + orgOffset]);
                  this.options.groupOrderSwap(switchGroup, shouldBeGroup, groupsData);
                  groupsData.update(switchGroup);
                  groupsData.update(shouldBeGroup);

                  var switchGroupId = newOrder[curPos + newOffset];
                  newOrder[curPos + newOffset] = origOrder[curPos + orgOffset];
                  newOrder[slippedPosition] = switchGroupId;

                  curPos++;
                }
          }
        }
      }
    }
  };

  ItemSet.prototype._onGroupDragEnd = function (event) {
    if (this.options.groupEditable.order && this.groupTouchParams.group) {
      event.stopPropagation();

      // update existing group
      var me = this;
      var id = me.groupTouchParams.group.groupId;
      var dataset = me.groupsData.getDataSet();
      var groupData = util.extend({}, dataset.get(id)); // clone the data
      me.options.onMoveGroup(groupData, function (groupData) {
        if (groupData) {
          // apply changes
          groupData[dataset._fieldId] = id; // ensure the group contains its id (can be undefined)
          dataset.update(groupData);
        } else {

          // fetch current order of groups
          var newOrder = dataset.getIds({
            order: me.options.groupOrder
          });

          // restore original order
          if (!util.equalArray(newOrder, me.groupTouchParams.originalOrder)) {
            var origOrder = me.groupTouchParams.originalOrder;
            var numGroups = Math.min(origOrder.length, newOrder.length);
            var curPos = 0;
            while (curPos < numGroups) {
              // as long as the groups are where they should be step down along the groups order
              while (curPos < numGroups && newOrder[curPos] == origOrder[curPos]) {
                curPos++;
              }

              // all ok
              if (curPos >= numGroups) {
                break;
              }

              // found a group that has the wrong position -> switch with the
              // group at the position where other one should be, fix index arrays and continue
              var slippedPosition = newOrder.indexOf(origOrder[curPos]);
              var switchGroup = dataset.get(newOrder[curPos]);
              var shouldBeGroup = dataset.get(origOrder[curPos]);
              me.options.groupOrderSwap(switchGroup, shouldBeGroup, dataset);
              groupsData.update(switchGroup);
              groupsData.update(shouldBeGroup);

              var switchGroupId = newOrder[curPos];
              newOrder[curPos] = origOrder[curPos];
              newOrder[slippedPosition] = switchGroupId;

              curPos++;
            }
          }
        }
      });

      me.body.emitter.emit('groupDragged', { groupId: id });
    }
  };

  /**
   * Handle selecting/deselecting an item when tapping it
   * @param {Event} event
   * @private
   */
  ItemSet.prototype._onSelectItem = function (event) {
    if (!this.options.selectable) return;

    var ctrlKey = event.srcEvent && (event.srcEvent.ctrlKey || event.srcEvent.metaKey);
    var shiftKey = event.srcEvent && event.srcEvent.shiftKey;
    if (ctrlKey || shiftKey) {
      this._onMultiSelectItem(event);
      return;
    }

    var oldSelection = this.getSelection();

    var item = this.itemFromTarget(event);
    var selection = item ? [item.id] : [];
    this.setSelection(selection);

    var newSelection = this.getSelection();

    // emit a select event,
    // except when old selection is empty and new selection is still empty
    if (newSelection.length > 0 || oldSelection.length > 0) {
      this.body.emitter.emit('select', {
        items: newSelection,
        event: event
      });
    }
  };

  /**
   * Handle creation and updates of an item on double tap
   * @param event
   * @private
   */
  ItemSet.prototype._onAddItem = function (event) {
    if (!this.options.selectable) return;
    if (!this.options.editable.add) return;

    var me = this;
    var snap = this.options.snap || null;
    var item = this.itemFromTarget(event);

    if (item) {
      // update item

      // execute async handler to update the item (or cancel it)
      var itemData = me.itemsData.get(item.id); // get a clone of the data from the dataset
      this.options.onUpdate(itemData, function (itemData) {
        if (itemData) {
          me.itemsData.getDataSet().update(itemData);
        }
      });
    } else {
      // add item
      if (this.options.rtl) {
        var xAbs = util.getAbsoluteRight(this.dom.frame);
        var x = xAbs - event.center.x;
      } else {
        var xAbs = util.getAbsoluteLeft(this.dom.frame);
        var x = event.center.x - xAbs;
      }
      // var xAbs = util.getAbsoluteLeft(this.dom.frame);
      // var x = event.center.x - xAbs;
      var start = this.body.util.toTime(x);
      var scale = this.body.util.getScale();
      var step = this.body.util.getStep();

      var newItemData = {
        start: snap ? snap(start, scale, step) : start,
        content: 'new item'
      };

      // when default type is a range, add a default end date to the new item
      if (this.options.type === 'range') {
        var end = this.body.util.toTime(x + this.props.width / 5);
        newItemData.end = snap ? snap(end, scale, step) : end;
      }

      newItemData[this.itemsData._fieldId] = util.randomUUID();

      var group = this.groupFromTarget(event);
      if (group) {
        newItemData.group = group.groupId;
      }

      // execute async handler to customize (or cancel) adding an item
      newItemData = this._cloneItemData(newItemData); // convert start and end to the correct type
      this.options.onAdd(newItemData, function (item) {
        if (item) {
          me.itemsData.getDataSet().add(item);
          // TODO: need to trigger a redraw?
        }
      });
    }
  };

  /**
   * Handle selecting/deselecting multiple items when holding an item
   * @param {Event} event
   * @private
   */
  ItemSet.prototype._onMultiSelectItem = function (event) {
    if (!this.options.selectable) return;

    var item = this.itemFromTarget(event);

    if (item) {
      // multi select items (if allowed)

      var selection = this.options.multiselect ? this.getSelection() // take current selection
      : []; // deselect current selection

      var shiftKey = event.srcEvent && event.srcEvent.shiftKey || false;

      if (shiftKey && this.options.multiselect) {
        // select all items between the old selection and the tapped item
        var itemGroup = this.itemsData.get(item.id).group;

        // when filtering get the group of the last selected item
        var lastSelectedGroup = undefined;
        if (this.options.multiselectPerGroup) {
          if (selection.length > 0) {
            lastSelectedGroup = this.itemsData.get(selection[0]).group;
          }
        }

        // determine the selection range
        if (!this.options.multiselectPerGroup || lastSelectedGroup == undefined || lastSelectedGroup == itemGroup) {
          selection.push(item.id);
        }
        var range = ItemSet._getItemRange(this.itemsData.get(selection, this.itemOptions));

        if (!this.options.multiselectPerGroup || lastSelectedGroup == itemGroup) {
          // select all items within the selection range
          selection = [];
          for (var id in this.items) {
            if (this.items.hasOwnProperty(id)) {
              var _item = this.items[id];
              var start = _item.data.start;
              var end = _item.data.end !== undefined ? _item.data.end : start;

              if (start >= range.min && end <= range.max && (!this.options.multiselectPerGroup || lastSelectedGroup == this.itemsData.get(_item.id).group) && !(_item instanceof BackgroundItem)) {
                selection.push(_item.id); // do not use id but item.id, id itself is stringified
              }
            }
          }
        }
      } else {
          // add/remove this item from the current selection
          var index = selection.indexOf(item.id);
          if (index == -1) {
            // item is not yet selected -> select it
            selection.push(item.id);
          } else {
            // item is already selected -> deselect it
            selection.splice(index, 1);
          }
        }

      this.setSelection(selection);

      this.body.emitter.emit('select', {
        items: this.getSelection(),
        event: event
      });
    }
  };

  /**
   * Calculate the time range of a list of items
   * @param {Array.<Object>} itemsData
   * @return {{min: Date, max: Date}} Returns the range of the provided items
   * @private
   */
  ItemSet._getItemRange = function (itemsData) {
    var max = null;
    var min = null;

    itemsData.forEach(function (data) {
      if (min == null || data.start < min) {
        min = data.start;
      }

      if (data.end != undefined) {
        if (max == null || data.end > max) {
          max = data.end;
        }
      } else {
        if (max == null || data.start > max) {
          max = data.start;
        }
      }
    });

    return {
      min: min,
      max: max
    };
  };

  /**
   * Find an item from an event target:
   * searches for the attribute 'timeline-item' in the event target's element tree
   * @param {Event} event
   * @return {Item | null} item
   */
  ItemSet.prototype.itemFromTarget = function (event) {
    var target = event.target;
    while (target) {
      if (target.hasOwnProperty('timeline-item')) {
        return target['timeline-item'];
      }
      target = target.parentNode;
    }

    return null;
  };

  /**
   * Find the Group from an event target:
   * searches for the attribute 'timeline-group' in the event target's element tree
   * @param {Event} event
   * @return {Group | null} group
   */
  ItemSet.prototype.groupFromTarget = function (event) {
    var clientY = event.center ? event.center.y : event.clientY;
    for (var i = 0; i < this.groupIds.length; i++) {
      var groupId = this.groupIds[i];
      var group = this.groups[groupId];
      var foreground = group.dom.foreground;
      var top = util.getAbsoluteTop(foreground);
      if (clientY > top && clientY < top + foreground.offsetHeight) {
        return group;
      }

      if (this.options.orientation.item === 'top') {
        if (i === this.groupIds.length - 1 && clientY > top) {
          return group;
        }
      } else {
        if (i === 0 && clientY < top + foreground.offset) {
          return group;
        }
      }
    }

    return null;
  };

  /**
   * Find the ItemSet from an event target:
   * searches for the attribute 'timeline-itemset' in the event target's element tree
   * @param {Event} event
   * @return {ItemSet | null} item
   */
  ItemSet.itemSetFromTarget = function (event) {
    var target = event.target;
    while (target) {
      if (target.hasOwnProperty('timeline-itemset')) {
        return target['timeline-itemset'];
      }
      target = target.parentNode;
    }

    return null;
  };

  /**
   * Clone the data of an item, and "normalize" it: convert the start and end date
   * to the type (Date, Moment, ...) configured in the DataSet. If not configured,
   * start and end are converted to Date.
   * @param {Object} itemData, typically `item.data`
   * @param {string} [type]  Optional Date type. If not provided, the type from the DataSet is taken
   * @return {Object} The cloned object
   * @private
   */
  ItemSet.prototype._cloneItemData = function (itemData, type) {
    var clone = util.extend({}, itemData);

    if (!type) {
      // convert start and end date to the type (Date, Moment, ...) configured in the DataSet
      type = this.itemsData.getDataSet()._options.type;
    }

    if (clone.start != undefined) {
      clone.start = util.convert(clone.start, type && type.start || 'Date');
    }
    if (clone.end != undefined) {
      clone.end = util.convert(clone.end, type && type.end || 'Date');
    }

    return clone;
  };

  module.exports = ItemSet;

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var moment = __webpack_require__(2);
  var DateUtil = __webpack_require__(32);
  var util = __webpack_require__(1);

  /**
   * @constructor  TimeStep
   * The class TimeStep is an iterator for dates. You provide a start date and an
   * end date. The class itself determines the best scale (step size) based on the
   * provided start Date, end Date, and minimumStep.
   *
   * If minimumStep is provided, the step size is chosen as close as possible
   * to the minimumStep but larger than minimumStep. If minimumStep is not
   * provided, the scale is set to 1 DAY.
   * The minimumStep should correspond with the onscreen size of about 6 characters
   *
   * Alternatively, you can set a scale by hand.
   * After creation, you can initialize the class by executing first(). Then you
   * can iterate from the start date to the end date via next(). You can check if
   * the end date is reached with the function hasNext(). After each step, you can
   * retrieve the current date via getCurrent().
   * The TimeStep has scales ranging from milliseconds, seconds, minutes, hours,
   * days, to years.
   *
   * Version: 1.2
   *
   * @param {Date} [start]         The start date, for example new Date(2010, 9, 21)
   *                               or new Date(2010, 9, 21, 23, 45, 00)
   * @param {Date} [end]           The end date
   * @param {Number} [minimumStep] Optional. Minimum step size in milliseconds
   */
  function TimeStep(start, end, minimumStep, hiddenDates) {
    this.moment = moment;

    // variables
    this.current = this.moment();
    this._start = this.moment();
    this._end = this.moment();

    this.autoScale = true;
    this.scale = 'day';
    this.step = 1;

    // initialize the range
    this.setRange(start, end, minimumStep);

    // hidden Dates options
    this.switchedDay = false;
    this.switchedMonth = false;
    this.switchedYear = false;
    if (Array.isArray(hiddenDates)) {
      this.hiddenDates = hiddenDates;
    } else if (hiddenDates != undefined) {
      this.hiddenDates = [hiddenDates];
    } else {
      this.hiddenDates = [];
    }

    this.format = TimeStep.FORMAT; // default formatting
  }

  // Time formatting
  TimeStep.FORMAT = {
    minorLabels: {
      millisecond: 'SSS',
      second: 's',
      minute: 'HH:mm',
      hour: 'HH:mm',
      weekday: 'ddd D',
      day: 'D',
      month: 'MMM',
      year: 'YYYY'
    },
    majorLabels: {
      millisecond: 'HH:mm:ss',
      second: 'D MMMM HH:mm',
      minute: 'ddd D MMMM',
      hour: 'ddd D MMMM',
      weekday: 'MMMM YYYY',
      day: 'MMMM YYYY',
      month: 'YYYY',
      year: ''
    }
  };

  /**
   * Set custom constructor function for moment. Can be used to set dates
   * to UTC or to set a utcOffset.
   * @param {function} moment
   */
  TimeStep.prototype.setMoment = function (moment) {
    this.moment = moment;

    // update the date properties, can have a new utcOffset
    this.current = this.moment(this.current);
    this._start = this.moment(this._start);
    this._end = this.moment(this._end);
  };

  /**
   * Set custom formatting for the minor an major labels of the TimeStep.
   * Both `minorLabels` and `majorLabels` are an Object with properties:
   * 'millisecond', 'second', 'minute', 'hour', 'weekday', 'day', 'month', 'year'.
   * @param {{minorLabels: Object, majorLabels: Object}} format
   */
  TimeStep.prototype.setFormat = function (format) {
    var defaultFormat = util.deepExtend({}, TimeStep.FORMAT);
    this.format = util.deepExtend(defaultFormat, format);
  };

  /**
   * Set a new range
   * If minimumStep is provided, the step size is chosen as close as possible
   * to the minimumStep but larger than minimumStep. If minimumStep is not
   * provided, the scale is set to 1 DAY.
   * The minimumStep should correspond with the onscreen size of about 6 characters
   * @param {Date} [start]      The start date and time.
   * @param {Date} [end]        The end date and time.
   * @param {int} [minimumStep] Optional. Minimum step size in milliseconds
   */
  TimeStep.prototype.setRange = function (start, end, minimumStep) {
    if (!(start instanceof Date) || !(end instanceof Date)) {
      throw "No legal start or end date in method setRange";
    }

    this._start = start != undefined ? this.moment(start.valueOf()) : new Date();
    this._end = end != undefined ? this.moment(end.valueOf()) : new Date();

    if (this.autoScale) {
      this.setMinimumStep(minimumStep);
    }
  };

  /**
   * Set the range iterator to the start date.
   */
  TimeStep.prototype.start = function () {
    this.current = this._start.clone();
    this.roundToMinor();
  };

  /**
   * Round the current date to the first minor date value
   * This must be executed once when the current date is set to start Date
   */
  TimeStep.prototype.roundToMinor = function () {
    // round to floor
    // IMPORTANT: we have no breaks in this switch! (this is no bug)
    // noinspection FallThroughInSwitchStatementJS
    switch (this.scale) {
      case 'year':
        this.current.year(this.step * Math.floor(this.current.year() / this.step));
        this.current.month(0);
      case 'month':
        this.current.date(1);
      case 'day': // intentional fall through
      case 'weekday':
        this.current.hours(0);
      case 'hour':
        this.current.minutes(0);
      case 'minute':
        this.current.seconds(0);
      case 'second':
        this.current.milliseconds(0);
      //case 'millisecond': // nothing to do for milliseconds
    }

    if (this.step != 1) {
      // round down to the first minor value that is a multiple of the current step size
      switch (this.scale) {
        case 'millisecond':
          this.current.subtract(this.current.milliseconds() % this.step, 'milliseconds');break;
        case 'second':
          this.current.subtract(this.current.seconds() % this.step, 'seconds');break;
        case 'minute':
          this.current.subtract(this.current.minutes() % this.step, 'minutes');break;
        case 'hour':
          this.current.subtract(this.current.hours() % this.step, 'hours');break;
        case 'weekday': // intentional fall through
        case 'day':
          this.current.subtract((this.current.date() - 1) % this.step, 'day');break;
        case 'month':
          this.current.subtract(this.current.month() % this.step, 'month');break;
        case 'year':
          this.current.subtract(this.current.year() % this.step, 'year');break;
        default:
          break;
      }
    }
  };

  /**
   * Check if the there is a next step
   * @return {boolean}  true if the current date has not passed the end date
   */
  TimeStep.prototype.hasNext = function () {
    return this.current.valueOf() <= this._end.valueOf();
  };

  /**
   * Do the next step
   */
  TimeStep.prototype.next = function () {
    var prev = this.current.valueOf();

    // Two cases, needed to prevent issues with switching daylight savings
    // (end of March and end of October)
    if (this.current.month() < 6) {
      switch (this.scale) {
        case 'millisecond':
          this.current.add(this.step, 'millisecond');break;
        case 'second':
          this.current.add(this.step, 'second');break;
        case 'minute':
          this.current.add(this.step, 'minute');break;
        case 'hour':
          this.current.add(this.step, 'hour');
          // in case of skipping an hour for daylight savings, adjust the hour again (else you get: 0h 5h 9h ... instead of 0h 4h 8h ...)
          // TODO: is this still needed now we use the function of moment.js?
          this.current.subtract(this.current.hours() % this.step, 'hour');
          break;
        case 'weekday': // intentional fall through
        case 'day':
          this.current.add(this.step, 'day');break;
        case 'month':
          this.current.add(this.step, 'month');break;
        case 'year':
          this.current.add(this.step, 'year');break;
        default:
          break;
      }
    } else {
      switch (this.scale) {
        case 'millisecond':
          this.current.add(this.step, 'millisecond');break;
        case 'second':
          this.current.add(this.step, 'second');break;
        case 'minute':
          this.current.add(this.step, 'minute');break;
        case 'hour':
          this.current.add(this.step, 'hour');break;
        case 'weekday': // intentional fall through
        case 'day':
          this.current.add(this.step, 'day');break;
        case 'month':
          this.current.add(this.step, 'month');break;
        case 'year':
          this.current.add(this.step, 'year');break;
        default:
          break;
      }
    }

    if (this.step != 1) {
      // round down to the correct major value
      switch (this.scale) {
        case 'millisecond':
          if (this.current.milliseconds() < this.step) this.current.milliseconds(0);break;
        case 'second':
          if (this.current.seconds() < this.step) this.current.seconds(0);break;
        case 'minute':
          if (this.current.minutes() < this.step) this.current.minutes(0);break;
        case 'hour':
          if (this.current.hours() < this.step) this.current.hours(0);break;
        case 'weekday': // intentional fall through
        case 'day':
          if (this.current.date() < this.step + 1) this.current.date(1);break;
        case 'month':
          if (this.current.month() < this.step) this.current.month(0);break;
        case 'year':
          break; // nothing to do for year
        default:
          break;
      }
    }

    // safety mechanism: if current time is still unchanged, move to the end
    if (this.current.valueOf() == prev) {
      this.current = this._end.clone();
    }

    DateUtil.stepOverHiddenDates(this.moment, this, prev);
  };

  /**
   * Get the current datetime
   * @return {Moment}  current The current date
   */
  TimeStep.prototype.getCurrent = function () {
    return this.current;
  };

  /**
   * Set a custom scale. Autoscaling will be disabled.
   * For example setScale('minute', 5) will result
   * in minor steps of 5 minutes, and major steps of an hour.
   *
   * @param {{scale: string, step: number}} params
   *                               An object containing two properties:
   *                               - A string 'scale'. Choose from 'millisecond', 'second',
   *                                 'minute', 'hour', 'weekday', 'day', 'month', 'year'.
   *                               - A number 'step'. A step size, by default 1.
   *                                 Choose for example 1, 2, 5, or 10.
   */
  TimeStep.prototype.setScale = function (params) {
    if (params && typeof params.scale == 'string') {
      this.scale = params.scale;
      this.step = params.step > 0 ? params.step : 1;
      this.autoScale = false;
    }
  };

  /**
   * Enable or disable autoscaling
   * @param {boolean} enable  If true, autoascaling is set true
   */
  TimeStep.prototype.setAutoScale = function (enable) {
    this.autoScale = enable;
  };

  /**
   * Automatically determine the scale that bests fits the provided minimum step
   * @param {Number} [minimumStep]  The minimum step size in milliseconds
   */
  TimeStep.prototype.setMinimumStep = function (minimumStep) {
    if (minimumStep == undefined) {
      return;
    }

    //var b = asc + ds;

    var stepYear = 1000 * 60 * 60 * 24 * 30 * 12;
    var stepMonth = 1000 * 60 * 60 * 24 * 30;
    var stepDay = 1000 * 60 * 60 * 24;
    var stepHour = 1000 * 60 * 60;
    var stepMinute = 1000 * 60;
    var stepSecond = 1000;
    var stepMillisecond = 1;

    // find the smallest step that is larger than the provided minimumStep
    if (stepYear * 1000 > minimumStep) {
      this.scale = 'year';this.step = 1000;
    }
    if (stepYear * 500 > minimumStep) {
      this.scale = 'year';this.step = 500;
    }
    if (stepYear * 100 > minimumStep) {
      this.scale = 'year';this.step = 100;
    }
    if (stepYear * 50 > minimumStep) {
      this.scale = 'year';this.step = 50;
    }
    if (stepYear * 10 > minimumStep) {
      this.scale = 'year';this.step = 10;
    }
    if (stepYear * 5 > minimumStep) {
      this.scale = 'year';this.step = 5;
    }
    if (stepYear > minimumStep) {
      this.scale = 'year';this.step = 1;
    }
    if (stepMonth * 3 > minimumStep) {
      this.scale = 'month';this.step = 3;
    }
    if (stepMonth > minimumStep) {
      this.scale = 'month';this.step = 1;
    }
    if (stepDay * 5 > minimumStep) {
      this.scale = 'day';this.step = 5;
    }
    if (stepDay * 2 > minimumStep) {
      this.scale = 'day';this.step = 2;
    }
    if (stepDay > minimumStep) {
      this.scale = 'day';this.step = 1;
    }
    if (stepDay / 2 > minimumStep) {
      this.scale = 'weekday';this.step = 1;
    }
    if (stepHour * 4 > minimumStep) {
      this.scale = 'hour';this.step = 4;
    }
    if (stepHour > minimumStep) {
      this.scale = 'hour';this.step = 1;
    }
    if (stepMinute * 15 > minimumStep) {
      this.scale = 'minute';this.step = 15;
    }
    if (stepMinute * 10 > minimumStep) {
      this.scale = 'minute';this.step = 10;
    }
    if (stepMinute * 5 > minimumStep) {
      this.scale = 'minute';this.step = 5;
    }
    if (stepMinute > minimumStep) {
      this.scale = 'minute';this.step = 1;
    }
    if (stepSecond * 15 > minimumStep) {
      this.scale = 'second';this.step = 15;
    }
    if (stepSecond * 10 > minimumStep) {
      this.scale = 'second';this.step = 10;
    }
    if (stepSecond * 5 > minimumStep) {
      this.scale = 'second';this.step = 5;
    }
    if (stepSecond > minimumStep) {
      this.scale = 'second';this.step = 1;
    }
    if (stepMillisecond * 200 > minimumStep) {
      this.scale = 'millisecond';this.step = 200;
    }
    if (stepMillisecond * 100 > minimumStep) {
      this.scale = 'millisecond';this.step = 100;
    }
    if (stepMillisecond * 50 > minimumStep) {
      this.scale = 'millisecond';this.step = 50;
    }
    if (stepMillisecond * 10 > minimumStep) {
      this.scale = 'millisecond';this.step = 10;
    }
    if (stepMillisecond * 5 > minimumStep) {
      this.scale = 'millisecond';this.step = 5;
    }
    if (stepMillisecond > minimumStep) {
      this.scale = 'millisecond';this.step = 1;
    }
  };

  /**
   * Snap a date to a rounded value.
   * The snap intervals are dependent on the current scale and step.
   * Static function
   * @param {Date} date    the date to be snapped.
   * @param {string} scale Current scale, can be 'millisecond', 'second',
   *                       'minute', 'hour', 'weekday, 'day', 'month', 'year'.
   * @param {number} step  Current step (1, 2, 4, 5, ...
   * @return {Date} snappedDate
   */
  TimeStep.snap = function (date, scale, step) {
    var clone = moment(date);

    if (scale == 'year') {
      var year = clone.year() + Math.round(clone.month() / 12);
      clone.year(Math.round(year / step) * step);
      clone.month(0);
      clone.date(0);
      clone.hours(0);
      clone.minutes(0);
      clone.seconds(0);
      clone.milliseconds(0);
    } else if (scale == 'month') {
      if (clone.date() > 15) {
        clone.date(1);
        clone.add(1, 'month');
        // important: first set Date to 1, after that change the month.
      } else {
          clone.date(1);
        }

      clone.hours(0);
      clone.minutes(0);
      clone.seconds(0);
      clone.milliseconds(0);
    } else if (scale == 'day') {
      //noinspection FallthroughInSwitchStatementJS
      switch (step) {
        case 5:
        case 2:
          clone.hours(Math.round(clone.hours() / 24) * 24);break;
        default:
          clone.hours(Math.round(clone.hours() / 12) * 12);break;
      }
      clone.minutes(0);
      clone.seconds(0);
      clone.milliseconds(0);
    } else if (scale == 'weekday') {
      //noinspection FallthroughInSwitchStatementJS
      switch (step) {
        case 5:
        case 2:
          clone.hours(Math.round(clone.hours() / 12) * 12);break;
        default:
          clone.hours(Math.round(clone.hours() / 6) * 6);break;
      }
      clone.minutes(0);
      clone.seconds(0);
      clone.milliseconds(0);
    } else if (scale == 'hour') {
      switch (step) {
        case 4:
          clone.minutes(Math.round(clone.minutes() / 60) * 60);break;
        default:
          clone.minutes(Math.round(clone.minutes() / 30) * 30);break;
      }
      clone.seconds(0);
      clone.milliseconds(0);
    } else if (scale == 'minute') {
      //noinspection FallthroughInSwitchStatementJS
      switch (step) {
        case 15:
        case 10:
          clone.minutes(Math.round(clone.minutes() / 5) * 5);
          clone.seconds(0);
          break;
        case 5:
          clone.seconds(Math.round(clone.seconds() / 60) * 60);break;
        default:
          clone.seconds(Math.round(clone.seconds() / 30) * 30);break;
      }
      clone.milliseconds(0);
    } else if (scale == 'second') {
      //noinspection FallthroughInSwitchStatementJS
      switch (step) {
        case 15:
        case 10:
          clone.seconds(Math.round(clone.seconds() / 5) * 5);
          clone.milliseconds(0);
          break;
        case 5:
          clone.milliseconds(Math.round(clone.milliseconds() / 1000) * 1000);break;
        default:
          clone.milliseconds(Math.round(clone.milliseconds() / 500) * 500);break;
      }
    } else if (scale == 'millisecond') {
      var _step = step > 5 ? step / 2 : 1;
      clone.milliseconds(Math.round(clone.milliseconds() / _step) * _step);
    }

    return clone;
  };

  /**
   * Check if the current value is a major value (for example when the step
   * is DAY, a major value is each first day of the MONTH)
   * @return {boolean} true if current date is major, else false.
   */
  TimeStep.prototype.isMajor = function () {
    if (this.switchedYear == true) {
      this.switchedYear = false;
      switch (this.scale) {
        case 'year':
        case 'month':
        case 'weekday':
        case 'day':
        case 'hour':
        case 'minute':
        case 'second':
        case 'millisecond':
          return true;
        default:
          return false;
      }
    } else if (this.switchedMonth == true) {
      this.switchedMonth = false;
      switch (this.scale) {
        case 'weekday':
        case 'day':
        case 'hour':
        case 'minute':
        case 'second':
        case 'millisecond':
          return true;
        default:
          return false;
      }
    } else if (this.switchedDay == true) {
      this.switchedDay = false;
      switch (this.scale) {
        case 'millisecond':
        case 'second':
        case 'minute':
        case 'hour':
          return true;
        default:
          return false;
      }
    }

    var date = this.moment(this.current);
    switch (this.scale) {
      case 'millisecond':
        return date.milliseconds() == 0;
      case 'second':
        return date.seconds() == 0;
      case 'minute':
        return date.hours() == 0 && date.minutes() == 0;
      case 'hour':
        return date.hours() == 0;
      case 'weekday': // intentional fall through
      case 'day':
        return date.date() == 1;
      case 'month':
        return date.month() == 0;
      case 'year':
        return false;
      default:
        return false;
    }
  };

  /**
   * Returns formatted text for the minor axislabel, depending on the current
   * date and the scale. For example when scale is MINUTE, the current time is
   * formatted as "hh:mm".
   * @param {Date} [date] custom date. if not provided, current date is taken
   */
  TimeStep.prototype.getLabelMinor = function (date) {
    if (date == undefined) {
      date = this.current;
    }

    var format = this.format.minorLabels[this.scale];
    return format && format.length > 0 ? this.moment(date).format(format) : '';
  };

  /**
   * Returns formatted text for the major axis label, depending on the current
   * date and the scale. For example when scale is MINUTE, the major scale is
   * hours, and the hour will be formatted as "hh".
   * @param {Date} [date] custom date. if not provided, current date is taken
   */
  TimeStep.prototype.getLabelMajor = function (date) {
    if (date == undefined) {
      date = this.current;
    }

    var format = this.format.majorLabels[this.scale];
    return format && format.length > 0 ? this.moment(date).format(format) : '';
  };

  TimeStep.prototype.getClassName = function () {
    var _moment = this.moment;
    var m = this.moment(this.current);
    var current = m.locale ? m.locale('en') : m.lang('en'); // old versions of moment have .lang() function
    var step = this.step;

    function even(value) {
      return value / step % 2 == 0 ? ' vis-even' : ' vis-odd';
    }

    function today(date) {
      if (date.isSame(new Date(), 'day')) {
        return ' vis-today';
      }
      if (date.isSame(_moment().add(1, 'day'), 'day')) {
        return ' vis-tomorrow';
      }
      if (date.isSame(_moment().add(-1, 'day'), 'day')) {
        return ' vis-yesterday';
      }
      return '';
    }

    function currentWeek(date) {
      return date.isSame(new Date(), 'week') ? ' vis-current-week' : '';
    }

    function currentMonth(date) {
      return date.isSame(new Date(), 'month') ? ' vis-current-month' : '';
    }

    function currentYear(date) {
      return date.isSame(new Date(), 'year') ? ' vis-current-year' : '';
    }

    switch (this.scale) {
      case 'millisecond':
        return even(current.milliseconds()).trim();

      case 'second':
        return even(current.seconds()).trim();

      case 'minute':
        return even(current.minutes()).trim();

      case 'hour':
        var hours = current.hours();
        if (this.step == 4) {
          hours = hours + '-h' + (hours + 4);
        }
        return 'vis-h' + hours + today(current) + even(current.hours());

      case 'weekday':
        return 'vis-' + current.format('dddd').toLowerCase() + today(current) + currentWeek(current) + even(current.date());

      case 'day':
        var day = current.date();
        var month = current.format('MMMM').toLowerCase();
        return 'vis-day' + day + ' vis-' + month + currentMonth(current) + even(day - 1);

      case 'month':
        return 'vis-' + current.format('MMMM').toLowerCase() + currentMonth(current) + even(current.month());

      case 'year':
        var year = current.year();
        return 'vis-year' + year + currentYear(current) + even(year);

      default:
        return '';
    }
  };

  module.exports = TimeStep;

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var util = __webpack_require__(1);
  var stack = __webpack_require__(37);
  var RangeItem = __webpack_require__(38);

  /**
   * @constructor Group
   * @param {Number | String} groupId
   * @param {Object} data
   * @param {ItemSet} itemSet
   */
  function Group(groupId, data, itemSet) {
    this.groupId = groupId;
    this.subgroups = {};
    this.subgroupIndex = 0;
    this.subgroupOrderer = data && data.subgroupOrder;
    this.itemSet = itemSet;

    this.dom = {};
    this.props = {
      label: {
        width: 0,
        height: 0
      }
    };
    this.className = null;

    this.items = {}; // items filtered by groupId of this group
    this.visibleItems = []; // items currently visible in window
    this.orderedItems = {
      byStart: [],
      byEnd: []
    };
    this.checkRangedItems = false; // needed to refresh the ranged items if the window is programatically changed with NO overlap.
    var me = this;
    this.itemSet.body.emitter.on("checkRangedItems", function () {
      me.checkRangedItems = true;
    });

    this._create();

    this.setData(data);
  }

  /**
   * Create DOM elements for the group
   * @private
   */
  Group.prototype._create = function () {
    var label = document.createElement('div');
    if (this.itemSet.options.groupEditable.order) {
      label.className = 'vis-label draggable';
    } else {
      label.className = 'vis-label';
    }
    this.dom.label = label;

    var inner = document.createElement('div');
    inner.className = 'vis-inner';
    label.appendChild(inner);
    this.dom.inner = inner;

    var foreground = document.createElement('div');
    foreground.className = 'vis-group';
    foreground['timeline-group'] = this;
    this.dom.foreground = foreground;

    this.dom.background = document.createElement('div');
    this.dom.background.className = 'vis-group';

    this.dom.axis = document.createElement('div');
    this.dom.axis.className = 'vis-group';

    // create a hidden marker to detect when the Timelines container is attached
    // to the DOM, or the style of a parent of the Timeline is changed from
    // display:none is changed to visible.
    this.dom.marker = document.createElement('div');
    this.dom.marker.style.visibility = 'hidden';
    this.dom.marker.innerHTML = '?';
    this.dom.background.appendChild(this.dom.marker);
  };

  /**
   * Set the group data for this group
   * @param {Object} data   Group data, can contain properties content and className
   */
  Group.prototype.setData = function (data) {
    // update contents
    var content;
    if (this.itemSet.options && this.itemSet.options.groupTemplate) {
      content = this.itemSet.options.groupTemplate(data);
    } else {
      content = data && data.content;
    }

    if (content instanceof Element) {
      this.dom.inner.appendChild(content);
      while (this.dom.inner.firstChild) {
        this.dom.inner.removeChild(this.dom.inner.firstChild);
      }
      this.dom.inner.appendChild(content);
    } else if (content !== undefined && content !== null) {
      this.dom.inner.innerHTML = content;
    } else {
      this.dom.inner.innerHTML = this.groupId || ''; // groupId can be null
    }

    // update title
    this.dom.label.title = data && data.title || '';

    if (!this.dom.inner.firstChild) {
      util.addClassName(this.dom.inner, 'vis-hidden');
    } else {
      util.removeClassName(this.dom.inner, 'vis-hidden');
    }

    // update className
    var className = data && data.className || null;
    if (className != this.className) {
      if (this.className) {
        util.removeClassName(this.dom.label, this.className);
        util.removeClassName(this.dom.foreground, this.className);
        util.removeClassName(this.dom.background, this.className);
        util.removeClassName(this.dom.axis, this.className);
      }
      util.addClassName(this.dom.label, className);
      util.addClassName(this.dom.foreground, className);
      util.addClassName(this.dom.background, className);
      util.addClassName(this.dom.axis, className);
      this.className = className;
    }

    // update style
    if (this.style) {
      util.removeCssText(this.dom.label, this.style);
      this.style = null;
    }
    if (data && data.style) {
      util.addCssText(this.dom.label, data.style);
      this.style = data.style;
    }
  };

  /**
   * Get the width of the group label
   * @return {number} width
   */
  Group.prototype.getLabelWidth = function () {
    return this.props.label.width;
  };

  /**
   * Repaint this group
   * @param {{start: number, end: number}} range
   * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
   * @param {boolean} [restack=false]  Force restacking of all items
   * @return {boolean} Returns true if the group is resized
   */
  Group.prototype.redraw = function (range, margin, restack) {
    var resized = false;

    // force recalculation of the height of the items when the marker height changed
    // (due to the Timeline being attached to the DOM or changed from display:none to visible)
    var markerHeight = this.dom.marker.clientHeight;
    if (markerHeight != this.lastMarkerHeight) {
      this.lastMarkerHeight = markerHeight;

      util.forEach(this.items, function (item) {
        item.dirty = true;
        if (item.displayed) item.redraw();
      });

      restack = true;
    }

    // recalculate the height of the subgroups
    this._calculateSubGroupHeights();

    // reposition visible items vertically
    if (typeof this.itemSet.options.order === 'function') {
      // a custom order function

      if (restack) {
        // brute force restack of all items

        // show all items
        var me = this;
        var limitSize = false;
        util.forEach(this.items, function (item) {
          if (!item.displayed) {
            item.redraw();
            me.visibleItems.push(item);
          }
          item.repositionX(limitSize);
        });

        // order all items and force a restacking
        var customOrderedItems = this.orderedItems.byStart.slice().sort(function (a, b) {
          return me.itemSet.options.order(a.data, b.data);
        });
        stack.stack(customOrderedItems, margin, true /* restack=true */);
      }

      this.visibleItems = this._updateVisibleItems(this.orderedItems, this.visibleItems, range);
    } else {
      // no custom order function, lazy stacking

      this.visibleItems = this._updateVisibleItems(this.orderedItems, this.visibleItems, range);
      if (this.itemSet.options.stack) {
        // TODO: ugly way to access options...
        stack.stack(this.visibleItems, margin, restack);
      } else {
        // no stacking
        stack.nostack(this.visibleItems, margin, this.subgroups);
      }
    }

    // recalculate the height of the group
    var height = this._calculateHeight(margin);

    // calculate actual size and position
    var foreground = this.dom.foreground;
    this.top = foreground.offsetTop;
    this.right = foreground.offsetLeft;
    this.width = foreground.offsetWidth;
    resized = util.updateProperty(this, 'height', height) || resized;
    // recalculate size of label
    resized = util.updateProperty(this.props.label, 'width', this.dom.inner.clientWidth) || resized;
    resized = util.updateProperty(this.props.label, 'height', this.dom.inner.clientHeight) || resized;

    // apply new height
    this.dom.background.style.height = height + 'px';
    this.dom.foreground.style.height = height + 'px';
    this.dom.label.style.height = height + 'px';

    // update vertical position of items after they are re-stacked and the height of the group is calculated
    for (var i = 0, ii = this.visibleItems.length; i < ii; i++) {
      var item = this.visibleItems[i];
      item.repositionY(margin);
    }

    return resized;
  };

  /**
   * recalculate the height of the subgroups
   * @private
   */
  Group.prototype._calculateSubGroupHeights = function () {
    if (Object.keys(this.subgroups).length > 0) {
      var me = this;

      this.resetSubgroups();

      util.forEach(this.visibleItems, function (item) {
        if (item.data.subgroup !== undefined) {
          me.subgroups[item.data.subgroup].height = Math.max(me.subgroups[item.data.subgroup].height, item.height);
          me.subgroups[item.data.subgroup].visible = true;
        }
      });
    }
  };

  /**
   * recalculate the height of the group
   * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
   * @returns {number} Returns the height
   * @private
   */
  Group.prototype._calculateHeight = function (margin) {
    // recalculate the height of the group
    var height;
    var visibleItems = this.visibleItems;
    if (visibleItems.length > 0) {
      var min = visibleItems[0].top;
      var max = visibleItems[0].top + visibleItems[0].height;
      util.forEach(visibleItems, function (item) {
        min = Math.min(min, item.top);
        max = Math.max(max, item.top + item.height);
      });
      if (min > margin.axis) {
        // there is an empty gap between the lowest item and the axis
        var offset = min - margin.axis;
        max -= offset;
        util.forEach(visibleItems, function (item) {
          item.top -= offset;
        });
      }
      height = max + margin.item.vertical / 2;
    } else {
      height = 0;
    }
    height = Math.max(height, this.props.label.height);

    return height;
  };

  /**
   * Show this group: attach to the DOM
   */
  Group.prototype.show = function () {
    if (!this.dom.label.parentNode) {
      this.itemSet.dom.labelSet.appendChild(this.dom.label);
    }

    if (!this.dom.foreground.parentNode) {
      this.itemSet.dom.foreground.appendChild(this.dom.foreground);
    }

    if (!this.dom.background.parentNode) {
      this.itemSet.dom.background.appendChild(this.dom.background);
    }

    if (!this.dom.axis.parentNode) {
      this.itemSet.dom.axis.appendChild(this.dom.axis);
    }
  };

  /**
   * Hide this group: remove from the DOM
   */
  Group.prototype.hide = function () {
    var label = this.dom.label;
    if (label.parentNode) {
      label.parentNode.removeChild(label);
    }

    var foreground = this.dom.foreground;
    if (foreground.parentNode) {
      foreground.parentNode.removeChild(foreground);
    }

    var background = this.dom.background;
    if (background.parentNode) {
      background.parentNode.removeChild(background);
    }

    var axis = this.dom.axis;
    if (axis.parentNode) {
      axis.parentNode.removeChild(axis);
    }
  };

  /**
   * Add an item to the group
   * @param {Item} item
   */
  Group.prototype.add = function (item) {
    this.items[item.id] = item;
    item.setParent(this);

    // add to
    if (item.data.subgroup !== undefined) {
      if (this.subgroups[item.data.subgroup] === undefined) {
        this.subgroups[item.data.subgroup] = { height: 0, visible: false, index: this.subgroupIndex, items: [] };
        this.subgroupIndex++;
      }
      this.subgroups[item.data.subgroup].items.push(item);
    }
    this.orderSubgroups();

    if (this.visibleItems.indexOf(item) == -1) {
      var range = this.itemSet.body.range; // TODO: not nice accessing the range like this
      this._checkIfVisible(item, this.visibleItems, range);
    }
  };

  Group.prototype.orderSubgroups = function () {
    if (this.subgroupOrderer !== undefined) {
      var sortArray = [];
      if (typeof this.subgroupOrderer == 'string') {
        for (var subgroup in this.subgroups) {
          sortArray.push({ subgroup: subgroup, sortField: this.subgroups[subgroup].items[0].data[this.subgroupOrderer] });
        }
        sortArray.sort(function (a, b) {
          return a.sortField - b.sortField;
        });
      } else if (typeof this.subgroupOrderer == 'function') {
        for (var subgroup in this.subgroups) {
          sortArray.push(this.subgroups[subgroup].items[0].data);
        }
        sortArray.sort(this.subgroupOrderer);
      }

      if (sortArray.length > 0) {
        for (var i = 0; i < sortArray.length; i++) {
          this.subgroups[sortArray[i].subgroup].index = i;
        }
      }
    }
  };

  Group.prototype.resetSubgroups = function () {
    for (var subgroup in this.subgroups) {
      if (this.subgroups.hasOwnProperty(subgroup)) {
        this.subgroups[subgroup].visible = false;
      }
    }
  };

  /**
   * Remove an item from the group
   * @param {Item} item
   */
  Group.prototype.remove = function (item) {
    delete this.items[item.id];
    item.setParent(null);

    // remove from visible items
    var index = this.visibleItems.indexOf(item);
    if (index != -1) this.visibleItems.splice(index, 1);

    if (item.data.subgroup !== undefined) {
      var subgroup = this.subgroups[item.data.subgroup];
      if (subgroup) {
        var itemIndex = subgroup.items.indexOf(item);
        subgroup.items.splice(itemIndex, 1);
        if (!subgroup.items.length) {
          delete this.subgroups[item.data.subgroup];
          this.subgroupIndex--;
        }
        this.orderSubgroups();
      }
    }
  };

  /**
   * Remove an item from the corresponding DataSet
   * @param {Item} item
   */
  Group.prototype.removeFromDataSet = function (item) {
    this.itemSet.removeItem(item.id);
  };

  /**
   * Reorder the items
   */
  Group.prototype.order = function () {
    var array = util.toArray(this.items);
    var startArray = [];
    var endArray = [];

    for (var i = 0; i < array.length; i++) {
      if (array[i].data.end !== undefined) {
        endArray.push(array[i]);
      }
      startArray.push(array[i]);
    }
    this.orderedItems = {
      byStart: startArray,
      byEnd: endArray
    };

    stack.orderByStart(this.orderedItems.byStart);
    stack.orderByEnd(this.orderedItems.byEnd);
  };

  /**
   * Update the visible items
   * @param {{byStart: Item[], byEnd: Item[]}} orderedItems   All items ordered by start date and by end date
   * @param {Item[]} visibleItems                             The previously visible items.
   * @param {{start: number, end: number}} range              Visible range
   * @return {Item[]} visibleItems                            The new visible items.
   * @private
   */
  Group.prototype._updateVisibleItems = function (orderedItems, oldVisibleItems, range) {
    var visibleItems = [];
    var visibleItemsLookup = {}; // we keep this to quickly look up if an item already exists in the list without using indexOf on visibleItems
    var interval = (range.end - range.start) / 4;
    var lowerBound = range.start - interval;
    var upperBound = range.end + interval;
    var item, i;

    // this function is used to do the binary search.
    var searchFunction = function searchFunction(value) {
      if (value < lowerBound) {
        return -1;
      } else if (value <= upperBound) {
        return 0;
      } else {
        return 1;
      }
    };

    // first check if the items that were in view previously are still in view.
    // IMPORTANT: this handles the case for the items with startdate before the window and enddate after the window!
    // also cleans up invisible items.
    if (oldVisibleItems.length > 0) {
      for (i = 0; i < oldVisibleItems.length; i++) {
        this._checkIfVisibleWithReference(oldVisibleItems[i], visibleItems, visibleItemsLookup, range);
      }
    }

    // we do a binary search for the items that have only start values.
    var initialPosByStart = util.binarySearchCustom(orderedItems.byStart, searchFunction, 'data', 'start');

    // trace the visible items from the inital start pos both ways until an invisible item is found, we only look at the start values.
    this._traceVisible(initialPosByStart, orderedItems.byStart, visibleItems, visibleItemsLookup, function (item) {
      return item.data.start < lowerBound || item.data.start > upperBound;
    });

    // if the window has changed programmatically without overlapping the old window, the ranged items with start < lowerBound and end > upperbound are not shown.
    // We therefore have to brute force check all items in the byEnd list
    if (this.checkRangedItems == true) {
      this.checkRangedItems = false;
      for (i = 0; i < orderedItems.byEnd.length; i++) {
        this._checkIfVisibleWithReference(orderedItems.byEnd[i], visibleItems, visibleItemsLookup, range);
      }
    } else {
      // we do a binary search for the items that have defined end times.
      var initialPosByEnd = util.binarySearchCustom(orderedItems.byEnd, searchFunction, 'data', 'end');

      // trace the visible items from the inital start pos both ways until an invisible item is found, we only look at the end values.
      this._traceVisible(initialPosByEnd, orderedItems.byEnd, visibleItems, visibleItemsLookup, function (item) {
        return item.data.end < lowerBound || item.data.end > upperBound;
      });
    }

    // finally, we reposition all the visible items.
    for (i = 0; i < visibleItems.length; i++) {
      item = visibleItems[i];
      if (!item.displayed) item.show();
      // reposition item horizontally
      item.repositionX();
    }

    // debug
    //console.log("new line")
    //if (this.groupId == null) {
    //  for (i = 0; i < orderedItems.byStart.length; i++) {
    //    item = orderedItems.byStart[i].data;
    //    console.log('start',i,initialPosByStart, item.start.valueOf(), item.content, item.start >= lowerBound && item.start <= upperBound,i == initialPosByStart ? "<------------------- HEREEEE" : "")
    //  }
    //  for (i = 0; i < orderedItems.byEnd.length; i++) {
    //    item = orderedItems.byEnd[i].data;
    //    console.log('rangeEnd',i,initialPosByEnd, item.end.valueOf(), item.content, item.end >= range.start && item.end <= range.end,i == initialPosByEnd ? "<------------------- HEREEEE" : "")
    //  }
    //}

    return visibleItems;
  };

  Group.prototype._traceVisible = function (initialPos, items, visibleItems, visibleItemsLookup, breakCondition) {
    var item;
    var i;

    if (initialPos != -1) {
      for (i = initialPos; i >= 0; i--) {
        item = items[i];
        if (breakCondition(item)) {
          break;
        } else {
          if (visibleItemsLookup[item.id] === undefined) {
            visibleItemsLookup[item.id] = true;
            visibleItems.push(item);
          }
        }
      }

      for (i = initialPos + 1; i < items.length; i++) {
        item = items[i];
        if (breakCondition(item)) {
          break;
        } else {
          if (visibleItemsLookup[item.id] === undefined) {
            visibleItemsLookup[item.id] = true;
            visibleItems.push(item);
          }
        }
      }
    }
  };

  /**
   * this function is very similar to the _checkIfInvisible() but it does not
   * return booleans, hides the item if it should not be seen and always adds to
   * the visibleItems.
   * this one is for brute forcing and hiding.
   *
   * @param {Item} item
   * @param {Array} visibleItems
   * @param {{start:number, end:number}} range
   * @private
   */
  Group.prototype._checkIfVisible = function (item, visibleItems, range) {
    if (item.isVisible(range)) {
      if (!item.displayed) item.show();
      // reposition item horizontally
      item.repositionX();
      visibleItems.push(item);
    } else {
      if (item.displayed) item.hide();
    }
  };

  /**
   * this function is very similar to the _checkIfInvisible() but it does not
   * return booleans, hides the item if it should not be seen and always adds to
   * the visibleItems.
   * this one is for brute forcing and hiding.
   *
   * @param {Item} item
   * @param {Array} visibleItems
   * @param {{start:number, end:number}} range
   * @private
   */
  Group.prototype._checkIfVisibleWithReference = function (item, visibleItems, visibleItemsLookup, range) {
    if (item.isVisible(range)) {
      if (visibleItemsLookup[item.id] === undefined) {
        visibleItemsLookup[item.id] = true;
        visibleItems.push(item);
      }
    } else {
      if (item.displayed) item.hide();
    }
  };

  module.exports = Group;

/***/ },
/* 37 */
/***/ function(module, exports) {

  'use strict';

  // Utility functions for ordering and stacking of items
  var EPSILON = 0.001; // used when checking collisions, to prevent round-off errors

  /**
   * Order items by their start data
   * @param {Item[]} items
   */
  exports.orderByStart = function (items) {
    items.sort(function (a, b) {
      return a.data.start - b.data.start;
    });
  };

  /**
   * Order items by their end date. If they have no end date, their start date
   * is used.
   * @param {Item[]} items
   */
  exports.orderByEnd = function (items) {
    items.sort(function (a, b) {
      var aTime = 'end' in a.data ? a.data.end : a.data.start,
          bTime = 'end' in b.data ? b.data.end : b.data.start;

      return aTime - bTime;
    });
  };

  /**
   * Adjust vertical positions of the items such that they don't overlap each
   * other.
   * @param {Item[]} items
   *            All visible items
   * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
   *            Margins between items and between items and the axis.
   * @param {boolean} [force=false]
   *            If true, all items will be repositioned. If false (default), only
   *            items having a top===null will be re-stacked
   */
  exports.stack = function (items, margin, force) {
    var i, iMax;
    if (force) {
      // reset top position of all items
      for (i = 0, iMax = items.length; i < iMax; i++) {
        items[i].top = null;
      }
    }

    // calculate new, non-overlapping positions
    for (i = 0, iMax = items.length; i < iMax; i++) {
      var item = items[i];
      if (item.stack && item.top === null) {
        // initialize top position
        item.top = margin.axis;

        do {
          // TODO: optimize checking for overlap. when there is a gap without items,
          //       you only need to check for items from the next item on, not from zero
          var collidingItem = null;
          for (var j = 0, jj = items.length; j < jj; j++) {
            var other = items[j];
            if (other.top !== null && other !== item && other.stack && exports.collision(item, other, margin.item, other.options.rtl)) {
              collidingItem = other;
              break;
            }
          }

          if (collidingItem != null) {
            // There is a collision. Reposition the items above the colliding element
            item.top = collidingItem.top + collidingItem.height + margin.item.vertical;
          }
        } while (collidingItem);
      }
    }
  };

  /**
   * Adjust vertical positions of the items without stacking them
   * @param {Item[]} items
   *            All visible items
   * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
   *            Margins between items and between items and the axis.
   */
  exports.nostack = function (items, margin, subgroups) {
    var i, iMax, newTop;

    // reset top position of all items
    for (i = 0, iMax = items.length; i < iMax; i++) {
      if (items[i].data.subgroup !== undefined) {
        newTop = margin.axis;
        for (var subgroup in subgroups) {
          if (subgroups.hasOwnProperty(subgroup)) {
            if (subgroups[subgroup].visible == true && subgroups[subgroup].index < subgroups[items[i].data.subgroup].index) {
              newTop += subgroups[subgroup].height + margin.item.vertical;
            }
          }
        }
        items[i].top = newTop;
      } else {
        items[i].top = margin.axis;
      }
    }
  };

  /**
   * Test if the two provided items collide
   * The items must have parameters left, width, top, and height.
   * @param {Item} a          The first item
   * @param {Item} b          The second item
   * @param {{horizontal: number, vertical: number}} margin
   *                          An object containing a horizontal and vertical
   *                          minimum required margin.
   * @param {boolean} rtl
   * @return {boolean}        true if a and b collide, else false
   */
  exports.collision = function (a, b, margin, rtl) {
    if (rtl) {
      return a.right - margin.horizontal + EPSILON < b.right + b.width && a.right + a.width + margin.horizontal - EPSILON > b.right && a.top - margin.vertical + EPSILON < b.top + b.height && a.top + a.height + margin.vertical - EPSILON > b.top;
    } else {
      return a.left - margin.horizontal + EPSILON < b.left + b.width && a.left + a.width + margin.horizontal - EPSILON > b.left && a.top - margin.vertical + EPSILON < b.top + b.height && a.top + a.height + margin.vertical - EPSILON > b.top;
    }
  };

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var Hammer = __webpack_require__(20);
  var Item = __webpack_require__(39);

  /**
   * @constructor RangeItem
   * @extends Item
   * @param {Object} data             Object containing parameters start, end
   *                                  content, className.
   * @param {{toScreen: function, toTime: function}} conversion
   *                                  Conversion functions from time to screen and vice versa
   * @param {Object} [options]        Configuration options
   *                                  // TODO: describe options
   */
  function RangeItem(data, conversion, options) {
    this.props = {
      content: {
        width: 0
      }
    };
    this.overflow = false; // if contents can overflow (css styling), this flag is set to true
    this.options = options;
    // validate data
    if (data) {
      if (data.start == undefined) {
        throw new Error('Property "start" missing in item ' + data.id);
      }
      if (data.end == undefined) {
        throw new Error('Property "end" missing in item ' + data.id);
      }
    }

    Item.call(this, data, conversion, options);
  }

  RangeItem.prototype = new Item(null, null, null);

  RangeItem.prototype.baseClassName = 'vis-item vis-range';

  /**
   * Check whether this item is visible inside given range
   * @returns {{start: Number, end: Number}} range with a timestamp for start and end
   * @returns {boolean} True if visible
   */
  RangeItem.prototype.isVisible = function (range) {
    // determine visibility
    return this.data.start < range.end && this.data.end > range.start;
  };

  /**
   * Repaint the item
   */
  RangeItem.prototype.redraw = function () {
    var dom = this.dom;
    if (!dom) {
      // create DOM
      this.dom = {};
      dom = this.dom;

      // background box
      dom.box = document.createElement('div');
      // className is updated in redraw()

      // frame box (to prevent the item contents from overflowing
      dom.frame = document.createElement('div');
      dom.frame.className = 'vis-item-overflow';
      dom.box.appendChild(dom.frame);

      // contents box
      dom.content = document.createElement('div');
      dom.content.className = 'vis-item-content';
      dom.frame.appendChild(dom.content);

      // attach this item as attribute
      dom.box['timeline-item'] = this;

      this.dirty = true;
    }

    // append DOM to parent DOM
    if (!this.parent) {
      throw new Error('Cannot redraw item: no parent attached');
    }
    if (!dom.box.parentNode) {
      var foreground = this.parent.dom.foreground;
      if (!foreground) {
        throw new Error('Cannot redraw item: parent has no foreground container element');
      }
      foreground.appendChild(dom.box);
    }
    this.displayed = true;

    // Update DOM when item is marked dirty. An item is marked dirty when:
    // - the item is not yet rendered
    // - the item's data is changed
    // - the item is selected/deselected
    if (this.dirty) {
      this._updateContents(this.dom.content);
      this._updateTitle(this.dom.box);
      this._updateDataAttributes(this.dom.box);
      this._updateStyle(this.dom.box);

      var editable = (this.options.editable.updateTime || this.options.editable.updateGroup || this.editable === true) && this.editable !== false;

      // update class
      var className = (this.data.className ? ' ' + this.data.className : '') + (this.selected ? ' vis-selected' : '') + (editable ? ' vis-editable' : ' vis-readonly');
      dom.box.className = this.baseClassName + className;

      // determine from css whether this box has overflow
      this.overflow = window.getComputedStyle(dom.frame).overflow !== 'hidden';

      // recalculate size
      // turn off max-width to be able to calculate the real width
      // this causes an extra browser repaint/reflow, but so be it
      this.dom.content.style.maxWidth = 'none';
      this.props.content.width = this.dom.content.offsetWidth;
      this.height = this.dom.box.offsetHeight;
      this.dom.content.style.maxWidth = '';

      this.dirty = false;
    }
    this._repaintDeleteButton(dom.box);
    this._repaintDragLeft();
    this._repaintDragRight();
  };

  /**
   * Show the item in the DOM (when not already visible). The items DOM will
   * be created when needed.
   */
  RangeItem.prototype.show = function () {
    if (!this.displayed) {
      this.redraw();
    }
  };

  /**
   * Hide the item from the DOM (when visible)
   * @return {Boolean} changed
   */
  RangeItem.prototype.hide = function () {
    if (this.displayed) {
      var box = this.dom.box;

      if (box.parentNode) {
        box.parentNode.removeChild(box);
      }

      this.displayed = false;
    }
  };

  /**
   * Reposition the item horizontally
   * @param {boolean} [limitSize=true] If true (default), the width of the range
   *                                   item will be limited, as the browser cannot
   *                                   display very wide divs. This means though
   *                                   that the applied left and width may
   *                                   not correspond to the ranges start and end
   * @Override
   */
  RangeItem.prototype.repositionX = function (limitSize) {
    var parentWidth = this.parent.width;
    var start = this.conversion.toScreen(this.data.start);
    var end = this.conversion.toScreen(this.data.end);
    var contentStartPosition;
    var contentWidth;

    // limit the width of the range, as browsers cannot draw very wide divs
    if (limitSize === undefined || limitSize === true) {
      if (start < -parentWidth) {
        start = -parentWidth;
      }
      if (end > 2 * parentWidth) {
        end = 2 * parentWidth;
      }
    }
    var boxWidth = Math.max(end - start, 1);

    if (this.overflow) {
      if (this.options.rtl) {
        this.right = start;
      } else {
        this.left = start;
      }
      this.width = boxWidth + this.props.content.width;
      contentWidth = this.props.content.width;

      // Note: The calculation of width is an optimistic calculation, giving
      //       a width which will not change when moving the Timeline
      //       So no re-stacking needed, which is nicer for the eye;
    } else {
        if (this.options.rtl) {
          this.right = start;
        } else {
          this.left = start;
        }
        this.width = boxWidth;
        contentWidth = Math.min(end - start, this.props.content.width);
      }

    if (this.options.rtl) {
      this.dom.box.style.right = this.right + 'px';
    } else {
      this.dom.box.style.left = this.left + 'px';
    }
    this.dom.box.style.width = boxWidth + 'px';

    switch (this.options.align) {
      case 'left':
        if (this.options.rtl) {
          this.dom.content.style.right = '0';
        } else {
          this.dom.content.style.left = '0';
        }
        break;

      case 'right':
        if (this.options.rtl) {
          this.dom.content.style.right = Math.max(boxWidth - contentWidth, 0) + 'px';
        } else {
          this.dom.content.style.left = Math.max(boxWidth - contentWidth, 0) + 'px';
        }
        break;

      case 'center':
        if (this.options.rtl) {
          this.dom.content.style.right = Math.max((boxWidth - contentWidth) / 2, 0) + 'px';
        } else {
          this.dom.content.style.left = Math.max((boxWidth - contentWidth) / 2, 0) + 'px';
        }

        break;

      default:
        // 'auto'
        // when range exceeds left of the window, position the contents at the left of the visible area
        if (this.overflow) {
          if (end > 0) {
            contentStartPosition = Math.max(-start, 0);
          } else {
            contentStartPosition = -contentWidth; // ensure it's not visible anymore
          }
        } else {
            if (start < 0) {
              contentStartPosition = -start;
            } else {
              contentStartPosition = 0;
            }
          }
        if (this.options.rtl) {
          this.dom.content.style.right = contentStartPosition + 'px';
        } else {
          this.dom.content.style.left = contentStartPosition + 'px';
        }
    }
  };

  /**
   * Reposition the item vertically
   * @Override
   */
  RangeItem.prototype.repositionY = function () {
    var orientation = this.options.orientation.item;
    var box = this.dom.box;

    if (orientation == 'top') {
      box.style.top = this.top + 'px';
    } else {
      box.style.top = this.parent.height - this.top - this.height + 'px';
    }
  };

  /**
   * Repaint a drag area on the left side of the range when the range is selected
   * @protected
   */
  RangeItem.prototype._repaintDragLeft = function () {
    if (this.selected && this.options.editable.updateTime && !this.dom.dragLeft) {
      // create and show drag area
      var dragLeft = document.createElement('div');
      dragLeft.className = 'vis-drag-left';
      dragLeft.dragLeftItem = this;

      this.dom.box.appendChild(dragLeft);
      this.dom.dragLeft = dragLeft;
    } else if (!this.selected && this.dom.dragLeft) {
      // delete drag area
      if (this.dom.dragLeft.parentNode) {
        this.dom.dragLeft.parentNode.removeChild(this.dom.dragLeft);
      }
      this.dom.dragLeft = null;
    }
  };

  /**
   * Repaint a drag area on the right side of the range when the range is selected
   * @protected
   */
  RangeItem.prototype._repaintDragRight = function () {
    if (this.selected && this.options.editable.updateTime && !this.dom.dragRight) {
      // create and show drag area
      var dragRight = document.createElement('div');
      dragRight.className = 'vis-drag-right';
      dragRight.dragRightItem = this;

      this.dom.box.appendChild(dragRight);
      this.dom.dragRight = dragRight;
    } else if (!this.selected && this.dom.dragRight) {
      // delete drag area
      if (this.dom.dragRight.parentNode) {
        this.dom.dragRight.parentNode.removeChild(this.dom.dragRight);
      }
      this.dom.dragRight = null;
    }
  };

  module.exports = RangeItem;

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var Hammer = __webpack_require__(20);
  var util = __webpack_require__(1);

  /**
   * @constructor Item
   * @param {Object} data             Object containing (optional) parameters type,
   *                                  start, end, content, group, className.
   * @param {{toScreen: function, toTime: function}} conversion
   *                                  Conversion functions from time to screen and vice versa
   * @param {Object} options          Configuration options
   *                                  // TODO: describe available options
   */
  function Item(data, conversion, options) {
    this.id = null;
    this.parent = null;
    this.data = data;
    this.dom = null;
    this.conversion = conversion || {};
    this.options = options || {};

    this.selected = false;
    this.displayed = false;
    this.dirty = true;

    this.top = null;
    this.right = null;
    this.left = null;
    this.width = null;
    this.height = null;

    this.editable = null;
    if (this.data && this.data.hasOwnProperty('editable') && typeof this.data.editable === 'boolean') {
      this.editable = data.editable;
    }
  }

  Item.prototype.stack = true;

  /**
   * Select current item
   */
  Item.prototype.select = function () {
    this.selected = true;
    this.dirty = true;
    if (this.displayed) this.redraw();
  };

  /**
   * Unselect current item
   */
  Item.prototype.unselect = function () {
    this.selected = false;
    this.dirty = true;
    if (this.displayed) this.redraw();
  };

  /**
   * Set data for the item. Existing data will be updated. The id should not
   * be changed. When the item is displayed, it will be redrawn immediately.
   * @param {Object} data
   */
  Item.prototype.setData = function (data) {
    var groupChanged = data.group != undefined && this.data.group != data.group;
    if (groupChanged) {
      this.parent.itemSet._moveToGroup(this, data.group);
    }

    if (data.hasOwnProperty('editable') && typeof data.editable === 'boolean') {
      this.editable = data.editable;
    }

    this.data = data;
    this.dirty = true;
    if (this.displayed) this.redraw();
  };

  /**
   * Set a parent for the item
   * @param {ItemSet | Group} parent
   */
  Item.prototype.setParent = function (parent) {
    if (this.displayed) {
      this.hide();
      this.parent = parent;
      if (this.parent) {
        this.show();
      }
    } else {
      this.parent = parent;
    }
  };

  /**
   * Check whether this item is visible inside given range
   * @returns {{start: Number, end: Number}} range with a timestamp for start and end
   * @returns {boolean} True if visible
   */
  Item.prototype.isVisible = function (range) {
    // Should be implemented by Item implementations
    return false;
  };

  /**
   * Show the Item in the DOM (when not already visible)
   * @return {Boolean} changed
   */
  Item.prototype.show = function () {
    return false;
  };

  /**
   * Hide the Item from the DOM (when visible)
   * @return {Boolean} changed
   */
  Item.prototype.hide = function () {
    return false;
  };

  /**
   * Repaint the item
   */
  Item.prototype.redraw = function () {
    // should be implemented by the item
  };

  /**
   * Reposition the Item horizontally
   */
  Item.prototype.repositionX = function () {
    // should be implemented by the item
  };

  /**
   * Reposition the Item vertically
   */
  Item.prototype.repositionY = function () {
    // should be implemented by the item
  };

  /**
   * Repaint a delete button on the top right of the item when the item is selected
   * @param {HTMLElement} anchor
   * @protected
   */
  Item.prototype._repaintDeleteButton = function (anchor) {
    var editable = (this.options.editable.remove || this.data.editable === true) && this.data.editable !== false;

    if (this.selected && editable && !this.dom.deleteButton) {
      // create and show button
      var me = this;

      var deleteButton = document.createElement('div');

      if (this.options.rtl) {
        deleteButton.className = 'vis-delete-rtl';
      } else {
        deleteButton.className = 'vis-delete';
      }
      deleteButton.title = 'Delete this item';

      // TODO: be able to destroy the delete button
      new Hammer(deleteButton).on('tap', function (event) {
        event.stopPropagation();
        me.parent.removeFromDataSet(me);
      });

      anchor.appendChild(deleteButton);
      this.dom.deleteButton = deleteButton;
    } else if (!this.selected && this.dom.deleteButton) {
      // remove button
      if (this.dom.deleteButton.parentNode) {
        this.dom.deleteButton.parentNode.removeChild(this.dom.deleteButton);
      }
      this.dom.deleteButton = null;
    }
  };

  /**
   * Set HTML contents for the item
   * @param {Element} element   HTML element to fill with the contents
   * @private
   */
  Item.prototype._updateContents = function (element) {
    var content;
    if (this.options.template) {
      var itemData = this.parent.itemSet.itemsData.get(this.id); // get a clone of the data from the dataset
      content = this.options.template(itemData);
    } else {
      content = this.data.content;
    }

    var changed = this._contentToString(this.content) !== this._contentToString(content);
    if (changed) {
      // only replace the content when changed
      if (content instanceof Element) {
        element.innerHTML = '';
        element.appendChild(content);
      } else if (content != undefined) {
        element.innerHTML = content;
      } else {
        if (!(this.data.type == 'background' && this.data.content === undefined)) {
          throw new Error('Property "content" missing in item ' + this.id);
        }
      }

      this.content = content;
    }
  };

  /**
   * Set HTML contents for the item
   * @param {Element} element   HTML element to fill with the contents
   * @private
   */
  Item.prototype._updateTitle = function (element) {
    if (this.data.title != null) {
      element.title = this.data.title || '';
    } else {
      element.removeAttribute('vis-title');
    }
  };

  /**
   * Process dataAttributes timeline option and set as data- attributes on dom.content
   * @param {Element} element   HTML element to which the attributes will be attached
   * @private
   */
  Item.prototype._updateDataAttributes = function (element) {
    if (this.options.dataAttributes && this.options.dataAttributes.length > 0) {
      var attributes = [];

      if (Array.isArray(this.options.dataAttributes)) {
        attributes = this.options.dataAttributes;
      } else if (this.options.dataAttributes == 'all') {
        attributes = Object.keys(this.data);
      } else {
        return;
      }

      for (var i = 0; i < attributes.length; i++) {
        var name = attributes[i];
        var value = this.data[name];

        if (value != null) {
          element.setAttribute('data-' + name, value);
        } else {
          element.removeAttribute('data-' + name);
        }
      }
    }
  };

  /**
   * Update custom styles of the element
   * @param element
   * @private
   */
  Item.prototype._updateStyle = function (element) {
    // remove old styles
    if (this.style) {
      util.removeCssText(element, this.style);
      this.style = null;
    }

    // append new styles
    if (this.data.style) {
      util.addCssText(element, this.data.style);
      this.style = this.data.style;
    }
  };

  /**
   * Stringify the items contents
   * @param {string | Element | undefined} content
   * @returns {string | undefined}
   * @private
   */
  Item.prototype._contentToString = function (content) {
    if (typeof content === 'string') return content;
    if (content && 'outerHTML' in content) return content.outerHTML;
    return content;
  };

  /**
   * Return the width of the item left from its start date
   * @return {number}
   */
  Item.prototype.getWidthLeft = function () {
    return 0;
  };

  /**
   * Return the width of the item right from the max of its start and end date
   * @return {number}
   */
  Item.prototype.getWidthRight = function () {
    return 0;
  };

  module.exports = Item;

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var util = __webpack_require__(1);
  var Group = __webpack_require__(36);

  /**
   * @constructor BackgroundGroup
   * @param {Number | String} groupId
   * @param {Object} data
   * @param {ItemSet} itemSet
   */
  function BackgroundGroup(groupId, data, itemSet) {
    Group.call(this, groupId, data, itemSet);

    this.width = 0;
    this.height = 0;
    this.top = 0;
    this.left = 0;
  }

  BackgroundGroup.prototype = Object.create(Group.prototype);

  /**
   * Repaint this group
   * @param {{start: number, end: number}} range
   * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
   * @param {boolean} [restack=false]  Force restacking of all items
   * @return {boolean} Returns true if the group is resized
   */
  BackgroundGroup.prototype.redraw = function (range, margin, restack) {
    var resized = false;

    this.visibleItems = this._updateVisibleItems(this.orderedItems, this.visibleItems, range);

    // calculate actual size
    this.width = this.dom.background.offsetWidth;

    // apply new height (just always zero for BackgroundGroup
    this.dom.background.style.height = '0';

    // update vertical position of items after they are re-stacked and the height of the group is calculated
    for (var i = 0, ii = this.visibleItems.length; i < ii; i++) {
      var item = this.visibleItems[i];
      item.repositionY(margin);
    }

    return resized;
  };

  /**
   * Show this group: attach to the DOM
   */
  BackgroundGroup.prototype.show = function () {
    if (!this.dom.background.parentNode) {
      this.itemSet.dom.background.appendChild(this.dom.background);
    }
  };

  module.exports = BackgroundGroup;

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var Item = __webpack_require__(39);
  var util = __webpack_require__(1);

  /**
   * @constructor BoxItem
   * @extends Item
   * @param {Object} data             Object containing parameters start
   *                                  content, className.
   * @param {{toScreen: function, toTime: function}} conversion
   *                                  Conversion functions from time to screen and vice versa
   * @param {Object} [options]        Configuration options
   *                                  // TODO: describe available options
   */
  function BoxItem(data, conversion, options) {
    this.props = {
      dot: {
        width: 0,
        height: 0
      },
      line: {
        width: 0,
        height: 0
      }
    };
    this.options = options;
    // validate data
    if (data) {
      if (data.start == undefined) {
        throw new Error('Property "start" missing in item ' + data);
      }
    }

    Item.call(this, data, conversion, options);
  }

  BoxItem.prototype = new Item(null, null, null);

  /**
   * Check whether this item is visible inside given range
   * @returns {{start: Number, end: Number}} range with a timestamp for start and end
   * @returns {boolean} True if visible
   */
  BoxItem.prototype.isVisible = function (range) {
    // determine visibility
    // TODO: account for the real width of the item. Right now we just add 1/4 to the window
    var interval = (range.end - range.start) / 4;
    return this.data.start > range.start - interval && this.data.start < range.end + interval;
  };

  /**
   * Repaint the item
   */
  BoxItem.prototype.redraw = function () {
    var dom = this.dom;
    if (!dom) {
      // create DOM
      this.dom = {};
      dom = this.dom;

      // create main box
      dom.box = document.createElement('DIV');

      // contents box (inside the background box). used for making margins
      dom.content = document.createElement('DIV');
      dom.content.className = 'vis-item-content';
      dom.box.appendChild(dom.content);

      // line to axis
      dom.line = document.createElement('DIV');
      dom.line.className = 'vis-line';

      // dot on axis
      dom.dot = document.createElement('DIV');
      dom.dot.className = 'vis-dot';

      // attach this item as attribute
      dom.box['timeline-item'] = this;

      this.dirty = true;
    }

    // append DOM to parent DOM
    if (!this.parent) {
      throw new Error('Cannot redraw item: no parent attached');
    }
    if (!dom.box.parentNode) {
      var foreground = this.parent.dom.foreground;
      if (!foreground) throw new Error('Cannot redraw item: parent has no foreground container element');
      foreground.appendChild(dom.box);
    }
    if (!dom.line.parentNode) {
      var background = this.parent.dom.background;
      if (!background) throw new Error('Cannot redraw item: parent has no background container element');
      background.appendChild(dom.line);
    }
    if (!dom.dot.parentNode) {
      var axis = this.parent.dom.axis;
      if (!background) throw new Error('Cannot redraw item: parent has no axis container element');
      axis.appendChild(dom.dot);
    }
    this.displayed = true;

    // Update DOM when item is marked dirty. An item is marked dirty when:
    // - the item is not yet rendered
    // - the item's data is changed
    // - the item is selected/deselected
    if (this.dirty) {
      this._updateContents(this.dom.content);
      this._updateTitle(this.dom.box);
      this._updateDataAttributes(this.dom.box);
      this._updateStyle(this.dom.box);

      var editable = (this.options.editable.updateTime || this.options.editable.updateGroup || this.editable === true) && this.editable !== false;

      // update class
      var className = (this.data.className ? ' ' + this.data.className : '') + (this.selected ? ' vis-selected' : '') + (editable ? ' vis-editable' : ' vis-readonly');
      dom.box.className = 'vis-item vis-box' + className;
      dom.line.className = 'vis-item vis-line' + className;
      dom.dot.className = 'vis-item vis-dot' + className;

      // recalculate size
      this.props.dot.height = dom.dot.offsetHeight;
      this.props.dot.width = dom.dot.offsetWidth;
      this.props.line.width = dom.line.offsetWidth;
      this.width = dom.box.offsetWidth;
      this.height = dom.box.offsetHeight;

      this.dirty = false;
    }

    this._repaintDeleteButton(dom.box);
  };

  /**
   * Show the item in the DOM (when not already displayed). The items DOM will
   * be created when needed.
   */
  BoxItem.prototype.show = function () {
    if (!this.displayed) {
      this.redraw();
    }
  };

  /**
   * Hide the item from the DOM (when visible)
   */
  BoxItem.prototype.hide = function () {
    if (this.displayed) {
      var dom = this.dom;

      if (dom.box.parentNode) dom.box.parentNode.removeChild(dom.box);
      if (dom.line.parentNode) dom.line.parentNode.removeChild(dom.line);
      if (dom.dot.parentNode) dom.dot.parentNode.removeChild(dom.dot);

      this.displayed = false;
    }
  };

  /**
   * Reposition the item horizontally
   * @Override
   */
  BoxItem.prototype.repositionX = function () {
    var start = this.conversion.toScreen(this.data.start);
    var align = this.options.align;

    // calculate left position of the box
    if (align == 'right') {
      if (this.options.rtl) {
        this.right = start - this.width;

        // reposition box, line, and dot
        this.dom.box.style.right = this.right + 'px';
        this.dom.line.style.right = start - this.props.line.width + 'px';
        this.dom.dot.style.right = start - this.props.line.width / 2 - this.props.dot.width / 2 + 'px';
      } else {
        this.left = start - this.width;

        // reposition box, line, and dot
        this.dom.box.style.left = this.left + 'px';
        this.dom.line.style.left = start - this.props.line.width + 'px';
        this.dom.dot.style.left = start - this.props.line.width / 2 - this.props.dot.width / 2 + 'px';
      }
    } else if (align == 'left') {
      if (this.options.rtl) {
        this.right = start;

        // reposition box, line, and dot
        this.dom.box.style.right = this.right + 'px';
        this.dom.line.style.right = start + 'px';
        this.dom.dot.style.right = start + this.props.line.width / 2 - this.props.dot.width / 2 + 'px';
      } else {
        this.left = start;

        // reposition box, line, and dot
        this.dom.box.style.left = this.left + 'px';
        this.dom.line.style.left = start + 'px';
        this.dom.dot.style.left = start + this.props.line.width / 2 - this.props.dot.width / 2 + 'px';
      }
    } else {
      // default or 'center'
      if (this.options.rtl) {
        this.right = start - this.width / 2;

        // reposition box, line, and dot
        this.dom.box.style.right = this.right + 'px';
        this.dom.line.style.right = start - this.props.line.width + 'px';
        this.dom.dot.style.right = start - this.props.dot.width / 2 + 'px';
      } else {
        this.left = start - this.width / 2;

        // reposition box, line, and dot
        this.dom.box.style.left = this.left + 'px';
        this.dom.line.style.left = start - this.props.line.width / 2 + 'px';
        this.dom.dot.style.left = start - this.props.dot.width / 2 + 'px';
      }
    }
  };

  /**
   * Reposition the item vertically
   * @Override
   */
  BoxItem.prototype.repositionY = function () {
    var orientation = this.options.orientation.item;
    var box = this.dom.box;
    var line = this.dom.line;
    var dot = this.dom.dot;

    if (orientation == 'top') {
      box.style.top = (this.top || 0) + 'px';

      line.style.top = '0';
      line.style.height = this.parent.top + this.top + 1 + 'px';
      line.style.bottom = '';
    } else {
      // orientation 'bottom'
      var itemSetHeight = this.parent.itemSet.props.height; // TODO: this is nasty
      var lineHeight = itemSetHeight - this.parent.top - this.parent.height + this.top;

      box.style.top = (this.parent.height - this.top - this.height || 0) + 'px';
      line.style.top = itemSetHeight - lineHeight + 'px';
      line.style.bottom = '0';
    }

    dot.style.top = -this.props.dot.height / 2 + 'px';
  };

  /**
   * Return the width of the item left from its start date
   * @return {number}
   */
  BoxItem.prototype.getWidthLeft = function () {
    return this.width / 2;
  };

  /**
   * Return the width of the item right from its start date
   * @return {number}
   */
  BoxItem.prototype.getWidthRight = function () {
    return this.width / 2;
  };

  module.exports = BoxItem;

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var Item = __webpack_require__(39);

  /**
   * @constructor PointItem
   * @extends Item
   * @param {Object} data             Object containing parameters start
   *                                  content, className.
   * @param {{toScreen: function, toTime: function}} conversion
   *                                  Conversion functions from time to screen and vice versa
   * @param {Object} [options]        Configuration options
   *                                  // TODO: describe available options
   */
  function PointItem(data, conversion, options) {
    this.props = {
      dot: {
        top: 0,
        width: 0,
        height: 0
      },
      content: {
        height: 0,
        marginLeft: 0,
        marginRight: 0
      }
    };
    this.options = options;
    // validate data
    if (data) {
      if (data.start == undefined) {
        throw new Error('Property "start" missing in item ' + data);
      }
    }

    Item.call(this, data, conversion, options);
  }

  PointItem.prototype = new Item(null, null, null);

  /**
   * Check whether this item is visible inside given range
   * @returns {{start: Number, end: Number}} range with a timestamp for start and end
   * @returns {boolean} True if visible
   */
  PointItem.prototype.isVisible = function (range) {
    // determine visibility
    // TODO: account for the real width of the item. Right now we just add 1/4 to the window
    var interval = (range.end - range.start) / 4;
    return this.data.start > range.start - interval && this.data.start < range.end + interval;
  };

  /**
   * Repaint the item
   */
  PointItem.prototype.redraw = function () {
    var dom = this.dom;
    if (!dom) {
      // create DOM
      this.dom = {};
      dom = this.dom;

      // background box
      dom.point = document.createElement('div');
      // className is updated in redraw()

      // contents box, right from the dot
      dom.content = document.createElement('div');
      dom.content.className = 'vis-item-content';
      dom.point.appendChild(dom.content);

      // dot at start
      dom.dot = document.createElement('div');
      dom.point.appendChild(dom.dot);

      // attach this item as attribute
      dom.point['timeline-item'] = this;

      this.dirty = true;
    }

    // append DOM to parent DOM
    if (!this.parent) {
      throw new Error('Cannot redraw item: no parent attached');
    }
    if (!dom.point.parentNode) {
      var foreground = this.parent.dom.foreground;
      if (!foreground) {
        throw new Error('Cannot redraw item: parent has no foreground container element');
      }
      foreground.appendChild(dom.point);
    }
    this.displayed = true;

    // Update DOM when item is marked dirty. An item is marked dirty when:
    // - the item is not yet rendered
    // - the item's data is changed
    // - the item is selected/deselected
    if (this.dirty) {
      this._updateContents(this.dom.content);
      this._updateTitle(this.dom.point);
      this._updateDataAttributes(this.dom.point);
      this._updateStyle(this.dom.point);

      var editable = (this.options.editable.updateTime || this.options.editable.updateGroup || this.editable === true) && this.editable !== false;

      // update class
      var className = (this.data.className ? ' ' + this.data.className : '') + (this.selected ? ' vis-selected' : '') + (editable ? ' vis-editable' : ' vis-readonly');
      dom.point.className = 'vis-item vis-point' + className;
      dom.dot.className = 'vis-item vis-dot' + className;

      // recalculate size of dot and contents
      this.props.dot.width = dom.dot.offsetWidth;
      this.props.dot.height = dom.dot.offsetHeight;
      this.props.content.height = dom.content.offsetHeight;

      // resize contents
      if (this.options.rtl) {
        dom.content.style.marginRight = 2 * this.props.dot.width + 'px';
      } else {
        dom.content.style.marginLeft = 2 * this.props.dot.width + 'px';
      }
      //dom.content.style.marginRight = ... + 'px'; // TODO: margin right

      // recalculate size
      this.width = dom.point.offsetWidth;
      this.height = dom.point.offsetHeight;

      // reposition the dot
      dom.dot.style.top = (this.height - this.props.dot.height) / 2 + 'px';
      if (this.options.rtl) {
        dom.dot.style.right = this.props.dot.width / 2 + 'px';
      } else {
        dom.dot.style.left = this.props.dot.width / 2 + 'px';
      }

      this.dirty = false;
    }

    this._repaintDeleteButton(dom.point);
  };

  /**
   * Show the item in the DOM (when not already visible). The items DOM will
   * be created when needed.
   */
  PointItem.prototype.show = function () {
    if (!this.displayed) {
      this.redraw();
    }
  };

  /**
   * Hide the item from the DOM (when visible)
   */
  PointItem.prototype.hide = function () {
    if (this.displayed) {
      if (this.dom.point.parentNode) {
        this.dom.point.parentNode.removeChild(this.dom.point);
      }

      this.displayed = false;
    }
  };

  /**
   * Reposition the item horizontally
   * @Override
   */
  PointItem.prototype.repositionX = function () {
    var start = this.conversion.toScreen(this.data.start);

    if (this.options.rtl) {
      this.right = start - this.props.dot.width;

      // reposition point
      this.dom.point.style.right = this.right + 'px';
    } else {
      this.left = start - this.props.dot.width;

      // reposition point
      this.dom.point.style.left = this.left + 'px';
    }
  };

  /**
   * Reposition the item vertically
   * @Override
   */
  PointItem.prototype.repositionY = function () {
    var orientation = this.options.orientation.item;
    var point = this.dom.point;
    if (orientation == 'top') {
      point.style.top = this.top + 'px';
    } else {
      point.style.top = this.parent.height - this.top - this.height + 'px';
    }
  };

  /**
   * Return the width of the item left from its start date
   * @return {number}
   */
  PointItem.prototype.getWidthLeft = function () {
    return this.props.dot.width;
  };

  /**
   * Return the width of the item right from  its start date
   * @return {number}
   */
  PointItem.prototype.getWidthRight = function () {
    return this.props.dot.width;
  };

  module.exports = PointItem;

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var Hammer = __webpack_require__(20);
  var Item = __webpack_require__(39);
  var BackgroundGroup = __webpack_require__(40);
  var RangeItem = __webpack_require__(38);

  /**
   * @constructor BackgroundItem
   * @extends Item
   * @param {Object} data             Object containing parameters start, end
   *                                  content, className.
   * @param {{toScreen: function, toTime: function}} conversion
   *                                  Conversion functions from time to screen and vice versa
   * @param {Object} [options]        Configuration options
   *                                  // TODO: describe options
   */
  // TODO: implement support for the BackgroundItem just having a start, then being displayed as a sort of an annotation
  function BackgroundItem(data, conversion, options) {
    this.props = {
      content: {
        width: 0
      }
    };
    this.overflow = false; // if contents can overflow (css styling), this flag is set to true

    // validate data
    if (data) {
      if (data.start == undefined) {
        throw new Error('Property "start" missing in item ' + data.id);
      }
      if (data.end == undefined) {
        throw new Error('Property "end" missing in item ' + data.id);
      }
    }

    Item.call(this, data, conversion, options);
  }

  BackgroundItem.prototype = new Item(null, null, null);

  BackgroundItem.prototype.baseClassName = 'vis-item vis-background';
  BackgroundItem.prototype.stack = false;

  /**
   * Check whether this item is visible inside given range
   * @returns {{start: Number, end: Number}} range with a timestamp for start and end
   * @returns {boolean} True if visible
   */
  BackgroundItem.prototype.isVisible = function (range) {
    // determine visibility
    return this.data.start < range.end && this.data.end > range.start;
  };

  /**
   * Repaint the item
   */
  BackgroundItem.prototype.redraw = function () {
    var dom = this.dom;
    if (!dom) {
      // create DOM
      this.dom = {};
      dom = this.dom;

      // background box
      dom.box = document.createElement('div');
      // className is updated in redraw()

      // frame box (to prevent the item contents from overflowing
      dom.frame = document.createElement('div');
      dom.frame.className = 'vis-item-overflow';
      dom.box.appendChild(dom.frame);

      // contents box
      dom.content = document.createElement('div');
      dom.content.className = 'vis-item-content';
      dom.frame.appendChild(dom.content);

      // Note: we do NOT attach this item as attribute to the DOM,
      //       such that background items cannot be selected
      //dom.box['timeline-item'] = this;

      this.dirty = true;
    }

    // append DOM to parent DOM
    if (!this.parent) {
      throw new Error('Cannot redraw item: no parent attached');
    }
    if (!dom.box.parentNode) {
      var background = this.parent.dom.background;
      if (!background) {
        throw new Error('Cannot redraw item: parent has no background container element');
      }
      background.appendChild(dom.box);
    }
    this.displayed = true;

    // Update DOM when item is marked dirty. An item is marked dirty when:
    // - the item is not yet rendered
    // - the item's data is changed
    // - the item is selected/deselected
    if (this.dirty) {
      this._updateContents(this.dom.content);
      this._updateTitle(this.dom.content);
      this._updateDataAttributes(this.dom.content);
      this._updateStyle(this.dom.box);

      // update class
      var className = (this.data.className ? ' ' + this.data.className : '') + (this.selected ? ' vis-selected' : '');
      dom.box.className = this.baseClassName + className;

      // determine from css whether this box has overflow
      this.overflow = window.getComputedStyle(dom.content).overflow !== 'hidden';

      // recalculate size
      this.props.content.width = this.dom.content.offsetWidth;
      this.height = 0; // set height zero, so this item will be ignored when stacking items

      this.dirty = false;
    }
  };

  /**
   * Show the item in the DOM (when not already visible). The items DOM will
   * be created when needed.
   */
  BackgroundItem.prototype.show = RangeItem.prototype.show;

  /**
   * Hide the item from the DOM (when visible)
   * @return {Boolean} changed
   */
  BackgroundItem.prototype.hide = RangeItem.prototype.hide;

  /**
   * Reposition the item horizontally
   * @Override
   */
  BackgroundItem.prototype.repositionX = RangeItem.prototype.repositionX;

  /**
   * Reposition the item vertically
   * @Override
   */
  BackgroundItem.prototype.repositionY = function (margin) {
    var onTop = this.options.orientation.item === 'top';
    this.dom.content.style.top = onTop ? '' : '0';
    this.dom.content.style.bottom = onTop ? '0' : '';
    var height;

    // special positioning for subgroups
    if (this.data.subgroup !== undefined) {
      // TODO: instead of calculating the top position of the subgroups here for every BackgroundItem, calculate the top of the subgroup once in Itemset

      var itemSubgroup = this.data.subgroup;
      var subgroups = this.parent.subgroups;
      var subgroupIndex = subgroups[itemSubgroup].index;
      // if the orientation is top, we need to take the difference in height into account.
      if (onTop == true) {
        // the first subgroup will have to account for the distance from the top to the first item.
        height = this.parent.subgroups[itemSubgroup].height + margin.item.vertical;
        height += subgroupIndex == 0 ? margin.axis - 0.5 * margin.item.vertical : 0;
        var newTop = this.parent.top;
        for (var subgroup in subgroups) {
          if (subgroups.hasOwnProperty(subgroup)) {
            if (subgroups[subgroup].visible == true && subgroups[subgroup].index < subgroupIndex) {
              newTop += subgroups[subgroup].height + margin.item.vertical;
            }
          }
        }

        // the others will have to be offset downwards with this same distance.
        newTop += subgroupIndex != 0 ? margin.axis - 0.5 * margin.item.vertical : 0;
        this.dom.box.style.top = newTop + 'px';
        this.dom.box.style.bottom = '';
      }
      // and when the orientation is bottom:
      else {
          var newTop = this.parent.top;
          var totalHeight = 0;
          for (var subgroup in subgroups) {
            if (subgroups.hasOwnProperty(subgroup)) {
              if (subgroups[subgroup].visible == true) {
                var newHeight = subgroups[subgroup].height + margin.item.vertical;
                totalHeight += newHeight;
                if (subgroups[subgroup].index > subgroupIndex) {
                  newTop += newHeight;
                }
              }
            }
          }
          height = this.parent.subgroups[itemSubgroup].height + margin.item.vertical;
          this.dom.box.style.top = this.parent.height - totalHeight + newTop + 'px';
          this.dom.box.style.bottom = '';
        }
    }
    // and in the case of no subgroups:
    else {
        // we want backgrounds with groups to only show in groups.
        if (this.parent instanceof BackgroundGroup) {
          // if the item is not in a group:
          height = Math.max(this.parent.height, this.parent.itemSet.body.domProps.center.height, this.parent.itemSet.body.domProps.centerContainer.height);
          this.dom.box.style.top = onTop ? '0' : '';
          this.dom.box.style.bottom = onTop ? '' : '0';
        } else {
          height = this.parent.height;
          // same alignment for items when orientation is top or bottom
          this.dom.box.style.top = this.parent.top + 'px';
          this.dom.box.style.bottom = '';
        }
      }
    this.dom.box.style.height = height + 'px';
  };

  module.exports = BackgroundItem;

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

  var util = __webpack_require__(1);
  var Component = __webpack_require__(31);
  var TimeStep = __webpack_require__(35);
  var DateUtil = __webpack_require__(32);
  var moment = __webpack_require__(2);

  /**
   * A horizontal time axis
   * @param {{dom: Object, domProps: Object, emitter: Emitter, range: Range}} body
   * @param {Object} [options]        See TimeAxis.setOptions for the available
   *                                  options.
   * @constructor TimeAxis
   * @extends Component
   */
  function TimeAxis(body, options) {
    this.dom = {
      foreground: null,
      lines: [],
      majorTexts: [],
      minorTexts: [],
      redundant: {
        lines: [],
        majorTexts: [],
        minorTexts: []
      }
    };
    this.props = {
      range: {
        start: 0,
        end: 0,
        minimumStep: 0
      },
      lineTop: 0
    };

    this.defaultOptions = {
      orientation: {
        axis: 'bottom'
      }, // axis orientation: 'top' or 'bottom'
      showMinorLabels: true,
      showMajorLabels: true,
      maxMinorChars: 7,
      format: TimeStep.FORMAT,
      moment: moment,
      timeAxis: null
    };
    this.options = util.extend({}, this.defaultOptions);

    this.body = body;

    // create the HTML DOM
    this._create();

    this.setOptions(options);
  }

  TimeAxis.prototype = new Component();

  /**
   * Set options for the TimeAxis.
   * Parameters will be merged in current options.
   * @param {Object} options  Available options:
   *                          {string} [orientation.axis]
   *                          {boolean} [showMinorLabels]
   *                          {boolean} [showMajorLabels]
   */
  TimeAxis.prototype.setOptions = function (options) {
    if (options) {
      // copy all options that we know
      util.selectiveExtend(['showMinorLabels', 'showMajorLabels', 'maxMinorChars', 'hiddenDates', 'timeAxis', 'moment', 'rtl'], this.options, options);

      // deep copy the format options
      util.selectiveDeepExtend(['format'], this.options, options);

      if ('orientation' in options) {
        if (typeof options.orientation === 'string') {
          this.options.orientation.axis = options.orientation;
        } else if (_typeof(options.orientation) === 'object' && 'axis' in options.orientation) {
          this.options.orientation.axis = options.orientation.axis;
        }
      }

      // apply locale to moment.js
      // TODO: not so nice, this is applied globally to moment.js
      if ('locale' in options) {
        if (typeof moment.locale === 'function') {
          // moment.js 2.8.1+
          moment.locale(options.locale);
        } else {
          moment.lang(options.locale);
        }
      }
    }
  };

  /**
   * Create the HTML DOM for the TimeAxis
   */
  TimeAxis.prototype._create = function () {
    this.dom.foreground = document.createElement('div');
    this.dom.background = document.createElement('div');

    this.dom.foreground.className = 'vis-time-axis vis-foreground';
    this.dom.background.className = 'vis-time-axis vis-background';
  };

  /**
   * Destroy the TimeAxis
   */
  TimeAxis.prototype.destroy = function () {
    // remove from DOM
    if (this.dom.foreground.parentNode) {
      this.dom.foreground.parentNode.removeChild(this.dom.foreground);
    }
    if (this.dom.background.parentNode) {
      this.dom.background.parentNode.removeChild(this.dom.background);
    }

    this.body = null;
  };

  /**
   * Repaint the component
   * @return {boolean} Returns true if the component is resized
   */
  TimeAxis.prototype.redraw = function () {
    var props = this.props;
    var foreground = this.dom.foreground;
    var background = this.dom.background;

    // determine the correct parent DOM element (depending on option orientation)
    var parent = this.options.orientation.axis == 'top' ? this.body.dom.top : this.body.dom.bottom;
    var parentChanged = foreground.parentNode !== parent;

    // calculate character width and height
    this._calculateCharSize();

    // TODO: recalculate sizes only needed when parent is resized or options is changed
    var showMinorLabels = this.options.showMinorLabels && this.options.orientation.axis !== 'none';
    var showMajorLabels = this.options.showMajorLabels && this.options.orientation.axis !== 'none';

    // determine the width and height of the elemens for the axis
    props.minorLabelHeight = showMinorLabels ? props.minorCharHeight : 0;
    props.majorLabelHeight = showMajorLabels ? props.majorCharHeight : 0;
    props.height = props.minorLabelHeight + props.majorLabelHeight;
    props.width = foreground.offsetWidth;

    props.minorLineHeight = this.body.domProps.root.height - props.majorLabelHeight - (this.options.orientation.axis == 'top' ? this.body.domProps.bottom.height : this.body.domProps.top.height);
    props.minorLineWidth = 1; // TODO: really calculate width
    props.majorLineHeight = props.minorLineHeight + props.majorLabelHeight;
    props.majorLineWidth = 1; // TODO: really calculate width

    //  take foreground and background offline while updating (is almost twice as fast)
    var foregroundNextSibling = foreground.nextSibling;
    var backgroundNextSibling = background.nextSibling;
    foreground.parentNode && foreground.parentNode.removeChild(foreground);
    background.parentNode && background.parentNode.removeChild(background);

    foreground.style.height = this.props.height + 'px';

    this._repaintLabels();

    // put DOM online again (at the same place)
    if (foregroundNextSibling) {
      parent.insertBefore(foreground, foregroundNextSibling);
    } else {
      parent.appendChild(foreground);
    }
    if (backgroundNextSibling) {
      this.body.dom.backgroundVertical.insertBefore(background, backgroundNextSibling);
    } else {
      this.body.dom.backgroundVertical.appendChild(background);
    }
    return this._isResized() || parentChanged;
  };

  /**
   * Repaint major and minor text labels and vertical grid lines
   * @private
   */
  TimeAxis.prototype._repaintLabels = function () {
    var orientation = this.options.orientation.axis;

    // calculate range and step (step such that we have space for 7 characters per label)
    var start = util.convert(this.body.range.start, 'Number');
    var end = util.convert(this.body.range.end, 'Number');
    var timeLabelsize = this.body.util.toTime((this.props.minorCharWidth || 10) * this.options.maxMinorChars).valueOf();
    var minimumStep = timeLabelsize - DateUtil.getHiddenDurationBefore(this.options.moment, this.body.hiddenDates, this.body.range, timeLabelsize);
    minimumStep -= this.body.util.toTime(0).valueOf();

    var step = new TimeStep(new Date(start), new Date(end), minimumStep, this.body.hiddenDates);
    step.setMoment(this.options.moment);
    if (this.options.format) {
      step.setFormat(this.options.format);
    }
    if (this.options.timeAxis) {
      step.setScale(this.options.timeAxis);
    }
    this.step = step;

    // Move all DOM elements to a "redundant" list, where they
    // can be picked for re-use, and clear the lists with lines and texts.
    // At the end of the function _repaintLabels, left over elements will be cleaned up
    var dom = this.dom;
    dom.redundant.lines = dom.lines;
    dom.redundant.majorTexts = dom.majorTexts;
    dom.redundant.minorTexts = dom.minorTexts;
    dom.lines = [];
    dom.majorTexts = [];
    dom.minorTexts = [];

    var current;
    var next;
    var x;
    var xNext;
    var isMajor, nextIsMajor;
    var width = 0,
        prevWidth;
    var line;
    var labelMinor;
    var xFirstMajorLabel = undefined;
    var count = 0;
    var MAX = 1000;
    var className;

    step.start();
    next = step.getCurrent();
    xNext = this.body.util.toScreen(next);
    while (step.hasNext() && count < MAX) {
      count++;

      isMajor = step.isMajor();
      className = step.getClassName();
      labelMinor = step.getLabelMinor();

      current = next;
      x = xNext;

      step.next();
      next = step.getCurrent();
      nextIsMajor = step.isMajor();
      xNext = this.body.util.toScreen(next);

      prevWidth = width;
      width = xNext - x;
      var showMinorGrid = width >= prevWidth * 0.4; // prevent displaying of the 31th of the month on a scale of 5 days

      if (this.options.showMinorLabels && showMinorGrid) {
        var label = this._repaintMinorText(x, labelMinor, orientation, className);
        label.style.width = width + 'px'; // set width to prevent overflow
      }

      if (isMajor && this.options.showMajorLabels) {
        if (x > 0) {
          if (xFirstMajorLabel == undefined) {
            xFirstMajorLabel = x;
          }
          label = this._repaintMajorText(x, step.getLabelMajor(), orientation, className);
        }
        line = this._repaintMajorLine(x, width, orientation, className);
      } else {
        // minor line
        if (showMinorGrid) {
          line = this._repaintMinorLine(x, width, orientation, className);
        } else {
          if (line) {
            // adjust the width of the previous grid
            line.style.width = parseInt(line.style.width) + width + 'px';
          }
        }
      }
    }

    if (count === MAX && !warnedForOverflow) {
      console.warn('Something is wrong with the Timeline scale. Limited drawing of grid lines to ' + MAX + ' lines.');
      warnedForOverflow = true;
    }

    // create a major label on the left when needed
    if (this.options.showMajorLabels) {
      var leftTime = this.body.util.toTime(0),
          leftText = step.getLabelMajor(leftTime),
          widthText = leftText.length * (this.props.majorCharWidth || 10) + 10; // upper bound estimation

      if (xFirstMajorLabel == undefined || widthText < xFirstMajorLabel) {
        this._repaintMajorText(0, leftText, orientation, className);
      }
    }

    // Cleanup leftover DOM elements from the redundant list
    util.forEach(this.dom.redundant, function (arr) {
      while (arr.length) {
        var elem = arr.pop();
        if (elem && elem.parentNode) {
          elem.parentNode.removeChild(elem);
        }
      }
    });
  };

  /**
   * Create a minor label for the axis at position x
   * @param {Number} x
   * @param {String} text
   * @param {String} orientation   "top" or "bottom" (default)
   * @param {String} className
   * @return {Element} Returns the HTML element of the created label
   * @private
   */
  TimeAxis.prototype._repaintMinorText = function (x, text, orientation, className) {
    // reuse redundant label
    var label = this.dom.redundant.minorTexts.shift();

    if (!label) {
      // create new label
      var content = document.createTextNode('');
      label = document.createElement('div');
      label.appendChild(content);
      this.dom.foreground.appendChild(label);
    }
    this.dom.minorTexts.push(label);

    label.childNodes[0].nodeValue = text;

    label.style.top = orientation == 'top' ? this.props.majorLabelHeight + 'px' : '0';

    if (this.options.rtl) {
      label.style.left = "";
      label.style.right = x + 'px';
    } else {
      label.style.left = x + 'px';
    };
    label.className = 'vis-text vis-minor ' + className;
    //label.title = title;  // TODO: this is a heavy operation

    return label;
  };

  /**
   * Create a Major label for the axis at position x
   * @param {Number} x
   * @param {String} text
   * @param {String} orientation   "top" or "bottom" (default)
   * @param {String} className
   * @return {Element} Returns the HTML element of the created label
   * @private
   */
  TimeAxis.prototype._repaintMajorText = function (x, text, orientation, className) {
    // reuse redundant label
    var label = this.dom.redundant.majorTexts.shift();

    if (!label) {
      // create label
      var content = document.createTextNode(text);
      label = document.createElement('div');
      label.appendChild(content);
      this.dom.foreground.appendChild(label);
    }
    this.dom.majorTexts.push(label);

    label.childNodes[0].nodeValue = text;
    label.className = 'vis-text vis-major ' + className;
    //label.title = title; // TODO: this is a heavy operation

    label.style.top = orientation == 'top' ? '0' : this.props.minorLabelHeight + 'px';
    if (this.options.rtl) {
      label.style.left = "";
      label.style.right = x + 'px';
    } else {
      label.style.left = x + 'px';
    };

    return label;
  };

  /**
   * Create a minor line for the axis at position x
   * @param {Number} x
   * @param {Number} width
   * @param {String} orientation   "top" or "bottom" (default)
   * @param {String} className
   * @return {Element} Returns the created line
   * @private
   */
  TimeAxis.prototype._repaintMinorLine = function (x, width, orientation, className) {
    // reuse redundant line
    var line = this.dom.redundant.lines.shift();
    if (!line) {
      // create vertical line
      line = document.createElement('div');
      this.dom.background.appendChild(line);
    }
    this.dom.lines.push(line);

    var props = this.props;
    if (orientation == 'top') {
      line.style.top = props.majorLabelHeight + 'px';
    } else {
      line.style.top = this.body.domProps.top.height + 'px';
    }
    line.style.height = props.minorLineHeight + 'px';
    if (this.options.rtl) {
      line.style.left = "";
      line.style.right = x - props.minorLineWidth / 2 + 'px';
      line.className = 'vis-grid vis-vertical-rtl vis-minor ' + className;
    } else {
      line.style.left = x - props.minorLineWidth / 2 + 'px';
      line.className = 'vis-grid vis-vertical vis-minor ' + className;
    };
    line.style.width = width + 'px';

    return line;
  };

  /**
   * Create a Major line for the axis at position x
   * @param {Number} x
   * @param {Number} width
   * @param {String} orientation   "top" or "bottom" (default)
   * @param {String} className
   * @return {Element} Returns the created line
   * @private
   */
  TimeAxis.prototype._repaintMajorLine = function (x, width, orientation, className) {
    // reuse redundant line
    var line = this.dom.redundant.lines.shift();
    if (!line) {
      // create vertical line
      line = document.createElement('div');
      this.dom.background.appendChild(line);
    }
    this.dom.lines.push(line);

    var props = this.props;
    if (orientation == 'top') {
      line.style.top = '0';
    } else {
      line.style.top = this.body.domProps.top.height + 'px';
    }

    if (this.options.rtl) {
      line.style.left = "";
      line.style.right = x - props.majorLineWidth / 2 + 'px';
      line.className = 'vis-grid vis-vertical-rtl vis-major ' + className;
    } else {
      line.style.left = x - props.majorLineWidth / 2 + 'px';
      line.className = 'vis-grid vis-vertical vis-major ' + className;
    }

    line.style.height = props.majorLineHeight + 'px';
    line.style.width = width + 'px';

    return line;
  };

  /**
   * Determine the size of text on the axis (both major and minor axis).
   * The size is calculated only once and then cached in this.props.
   * @private
   */
  TimeAxis.prototype._calculateCharSize = function () {
    // Note: We calculate char size with every redraw. Size may change, for
    // example when any of the timelines parents had display:none for example.

    // determine the char width and height on the minor axis
    if (!this.dom.measureCharMinor) {
      this.dom.measureCharMinor = document.createElement('DIV');
      this.dom.measureCharMinor.className = 'vis-text vis-minor vis-measure';
      this.dom.measureCharMinor.style.position = 'absolute';

      this.dom.measureCharMinor.appendChild(document.createTextNode('0'));
      this.dom.foreground.appendChild(this.dom.measureCharMinor);
    }
    this.props.minorCharHeight = this.dom.measureCharMinor.clientHeight;
    this.props.minorCharWidth = this.dom.measureCharMinor.clientWidth;

    // determine the char width and height on the major axis
    if (!this.dom.measureCharMajor) {
      this.dom.measureCharMajor = document.createElement('DIV');
      this.dom.measureCharMajor.className = 'vis-text vis-major vis-measure';
      this.dom.measureCharMajor.style.position = 'absolute';

      this.dom.measureCharMajor.appendChild(document.createTextNode('0'));
      this.dom.foreground.appendChild(this.dom.measureCharMajor);
    }
    this.props.majorCharHeight = this.dom.measureCharMajor.clientHeight;
    this.props.majorCharWidth = this.dom.measureCharMajor.clientWidth;
  };

  var warnedForOverflow = false;

  module.exports = TimeAxis;

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var keycharm = __webpack_require__(23);
  var Emitter = __webpack_require__(13);
  var Hammer = __webpack_require__(20);
  var util = __webpack_require__(1);

  /**
   * Turn an element into an clickToUse element.
   * When not active, the element has a transparent overlay. When the overlay is
   * clicked, the mode is changed to active.
   * When active, the element is displayed with a blue border around it, and
   * the interactive contents of the element can be used. When clicked outside
   * the element, the elements mode is changed to inactive.
   * @param {Element} container
   * @constructor
   */
  function Activator(container) {
    this.active = false;

    this.dom = {
      container: container
    };

    this.dom.overlay = document.createElement('div');
    this.dom.overlay.className = 'vis-overlay';

    this.dom.container.appendChild(this.dom.overlay);

    this.hammer = Hammer(this.dom.overlay);
    this.hammer.on('tap', this._onTapOverlay.bind(this));

    // block all touch events (except tap)
    var me = this;
    var events = ['tap', 'doubletap', 'press', 'pinch', 'pan', 'panstart', 'panmove', 'panend'];
    events.forEach(function (event) {
      me.hammer.on(event, function (event) {
        event.stopPropagation();
      });
    });

    // attach a click event to the window, in order to deactivate when clicking outside the timeline
    if (document && document.body) {
      this.onClick = function (event) {
        if (!_hasParent(event.target, container)) {
          me.deactivate();
        }
      };
      document.body.addEventListener('click', this.onClick);
    }

    if (this.keycharm !== undefined) {
      this.keycharm.destroy();
    }
    this.keycharm = keycharm();

    // keycharm listener only bounded when active)
    this.escListener = this.deactivate.bind(this);
  }

  // turn into an event emitter
  Emitter(Activator.prototype);

  // The currently active activator
  Activator.current = null;

  /**
   * Destroy the activator. Cleans up all created DOM and event listeners
   */
  Activator.prototype.destroy = function () {
    this.deactivate();

    // remove dom
    this.dom.overlay.parentNode.removeChild(this.dom.overlay);

    // remove global event listener
    if (this.onClick) {
      document.body.removeEventListener('click', this.onClick);
    }

    // cleanup hammer instances
    this.hammer.destroy();
    this.hammer = null;
    // FIXME: cleaning up hammer instances doesn't work (Timeline not removed from memory)
  };

  /**
   * Activate the element
   * Overlay is hidden, element is decorated with a blue shadow border
   */
  Activator.prototype.activate = function () {
    // we allow only one active activator at a time
    if (Activator.current) {
      Activator.current.deactivate();
    }
    Activator.current = this;

    this.active = true;
    this.dom.overlay.style.display = 'none';
    util.addClassName(this.dom.container, 'vis-active');

    this.emit('change');
    this.emit('activate');

    // ugly hack: bind ESC after emitting the events, as the Network rebinds all
    // keyboard events on a 'change' event
    this.keycharm.bind('esc', this.escListener);
  };

  /**
   * Deactivate the element
   * Overlay is displayed on top of the element
   */
  Activator.prototype.deactivate = function () {
    this.active = false;
    this.dom.overlay.style.display = '';
    util.removeClassName(this.dom.container, 'vis-active');
    this.keycharm.unbind('esc', this.escListener);

    this.emit('change');
    this.emit('deactivate');
  };

  /**
   * Handle a tap event: activate the container
   * @param event
   * @private
   */
  Activator.prototype._onTapOverlay = function (event) {
    // activate the container
    this.activate();
    event.stopPropagation();
  };

  /**
   * Test whether the element has the requested parent element somewhere in
   * its chain of parent nodes.
   * @param {HTMLElement} element
   * @param {HTMLElement} parent
   * @returns {boolean} Returns true when the parent is found somewhere in the
   *                    chain of parent nodes.
   * @private
   */
  function _hasParent(element, parent) {
    while (element) {
      if (element === parent) {
        return true;
      }
      element = element.parentNode;
    }
    return false;
  }

  module.exports = Activator;

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var Hammer = __webpack_require__(20);
  var util = __webpack_require__(1);
  var Component = __webpack_require__(31);
  var moment = __webpack_require__(2);
  var locales = __webpack_require__(47);

  /**
   * A custom time bar
   * @param {{range: Range, dom: Object}} body
   * @param {Object} [options]        Available parameters:
   *                                  {number | string} id
   *                                  {string} locales
   *                                  {string} locale
   * @constructor CustomTime
   * @extends Component
   */

  function CustomTime(body, options) {
    this.body = body;

    // default options
    this.defaultOptions = {
      moment: moment,
      locales: locales,
      locale: 'en',
      id: undefined,
      title: undefined
    };
    this.options = util.extend({}, this.defaultOptions);

    if (options && options.time) {
      this.customTime = options.time;
    } else {
      this.customTime = new Date();
    }

    this.eventParams = {}; // stores state parameters while dragging the bar

    this.setOptions(options);

    // create the DOM
    this._create();
  }

  CustomTime.prototype = new Component();

  /**
   * Set options for the component. Options will be merged in current options.
   * @param {Object} options  Available parameters:
   *                                  {number | string} id
   *                                  {string} locales
   *                                  {string} locale
   */
  CustomTime.prototype.setOptions = function (options) {
    if (options) {
      // copy all options that we know
      util.selectiveExtend(['moment', 'locale', 'locales', 'id'], this.options, options);
    }
  };

  /**
   * Create the DOM for the custom time
   * @private
   */
  CustomTime.prototype._create = function () {
    var bar = document.createElement('div');
    bar['custom-time'] = this;
    bar.className = 'vis-custom-time ' + (this.options.id || '');
    bar.style.position = 'absolute';
    bar.style.top = '0px';
    bar.style.height = '100%';
    this.bar = bar;

    var drag = document.createElement('div');
    drag.style.position = 'relative';
    drag.style.top = '0px';
    drag.style.left = '-10px';
    drag.style.height = '100%';
    drag.style.width = '20px';
    bar.appendChild(drag);

    // attach event listeners
    this.hammer = new Hammer(drag);
    this.hammer.on('panstart', this._onDragStart.bind(this));
    this.hammer.on('panmove', this._onDrag.bind(this));
    this.hammer.on('panend', this._onDragEnd.bind(this));
    this.hammer.get('pan').set({ threshold: 5, direction: Hammer.DIRECTION_HORIZONTAL });
  };

  /**
   * Destroy the CustomTime bar
   */
  CustomTime.prototype.destroy = function () {
    this.hide();

    this.hammer.destroy();
    this.hammer = null;

    this.body = null;
  };

  /**
   * Repaint the component
   * @return {boolean} Returns true if the component is resized
   */
  CustomTime.prototype.redraw = function () {
    var parent = this.body.dom.backgroundVertical;
    if (this.bar.parentNode != parent) {
      // attach to the dom
      if (this.bar.parentNode) {
        this.bar.parentNode.removeChild(this.bar);
      }
      parent.appendChild(this.bar);
    }

    var x = this.body.util.toScreen(this.customTime);

    var locale = this.options.locales[this.options.locale];
    if (!locale) {
      if (!this.warned) {
        console.log('WARNING: options.locales[\'' + this.options.locale + '\'] not found. See http://visjs.org/docs/timeline.html#Localization');
        this.warned = true;
      }
      locale = this.options.locales['en']; // fall back on english when not available
    }

    var title = this.options.title;
    // To hide the title completely use empty string ''.
    if (title === undefined) {
      title = locale.time + ': ' + this.options.moment(this.customTime).format('dddd, MMMM Do YYYY, H:mm:ss');
      title = title.charAt(0).toUpperCase() + title.substring(1);
    }

    this.bar.style.left = x + 'px';
    this.bar.title = title;

    return false;
  };

  /**
   * Remove the CustomTime from the DOM
   */
  CustomTime.prototype.hide = function () {
    // remove the line from the DOM
    if (this.bar.parentNode) {
      this.bar.parentNode.removeChild(this.bar);
    }
  };

  /**
   * Set custom time.
   * @param {Date | number | string} time
   */
  CustomTime.prototype.setCustomTime = function (time) {
    this.customTime = util.convert(time, 'Date');
    this.redraw();
  };

  /**
   * Retrieve the current custom time.
   * @return {Date} customTime
   */
  CustomTime.prototype.getCustomTime = function () {
    return new Date(this.customTime.valueOf());
  };

  /**
    * Set custom title.
    * @param {Date | number | string} title
    */
  CustomTime.prototype.setCustomTitle = function (title) {
    this.options.title = title;
  };

  /**
   * Start moving horizontally
   * @param {Event} event
   * @private
   */
  CustomTime.prototype._onDragStart = function (event) {
    this.eventParams.dragging = true;
    this.eventParams.customTime = this.customTime;

    event.stopPropagation();
  };

  /**
   * Perform moving operating.
   * @param {Event} event
   * @private
   */
  CustomTime.prototype._onDrag = function (event) {
    if (!this.eventParams.dragging) return;

    var x = this.body.util.toScreen(this.eventParams.customTime) + event.deltaX;
    var time = this.body.util.toTime(x);

    this.setCustomTime(time);

    // fire a timechange event
    this.body.emitter.emit('timechange', {
      id: this.options.id,
      time: new Date(this.customTime.valueOf())
    });

    event.stopPropagation();
  };

  /**
   * Stop moving operating.
   * @param {Event} event
   * @private
   */
  CustomTime.prototype._onDragEnd = function (event) {
    if (!this.eventParams.dragging) return;

    // fire a timechanged event
    this.body.emitter.emit('timechanged', {
      id: this.options.id,
      time: new Date(this.customTime.valueOf())
    });

    event.stopPropagation();
  };

  /**
   * Find a custom time from an event target:
   * searches for the attribute 'custom-time' in the event target's element tree
   * @param {Event} event
   * @return {CustomTime | null} customTime
   */
  CustomTime.customTimeFromTarget = function (event) {
    var target = event.target;
    while (target) {
      if (target.hasOwnProperty('custom-time')) {
        return target['custom-time'];
      }
      target = target.parentNode;
    }

    return null;
  };

  module.exports = CustomTime;

/***/ },
/* 47 */
/***/ function(module, exports) {

  'use strict';

  // English
  exports['en'] = {
    current: 'current',
    time: 'time'
  };
  exports['en_EN'] = exports['en'];
  exports['en_US'] = exports['en'];

  // Dutch
  exports['nl'] = {
    current: 'huidige',
    time: 'tijd'
  };
  exports['nl_NL'] = exports['nl'];
  exports['nl_BE'] = exports['nl'];

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var util = __webpack_require__(1);
  var Component = __webpack_require__(31);
  var moment = __webpack_require__(2);
  var locales = __webpack_require__(47);

  /**
   * A current time bar
   * @param {{range: Range, dom: Object, domProps: Object}} body
   * @param {Object} [options]        Available parameters:
   *                                  {Boolean} [showCurrentTime]
   * @constructor CurrentTime
   * @extends Component
   */
  function CurrentTime(body, options) {
    this.body = body;

    // default options
    this.defaultOptions = {
      rtl: false,
      showCurrentTime: true,

      moment: moment,
      locales: locales,
      locale: 'en'
    };
    this.options = util.extend({}, this.defaultOptions);
    this.offset = 0;

    this._create();

    this.setOptions(options);
  }

  CurrentTime.prototype = new Component();

  /**
   * Create the HTML DOM for the current time bar
   * @private
   */
  CurrentTime.prototype._create = function () {
    var bar = document.createElement('div');
    bar.className = 'vis-current-time';
    bar.style.position = 'absolute';
    bar.style.top = '0px';
    bar.style.height = '100%';

    this.bar = bar;
  };

  /**
   * Destroy the CurrentTime bar
   */
  CurrentTime.prototype.destroy = function () {
    this.options.showCurrentTime = false;
    this.redraw(); // will remove the bar from the DOM and stop refreshing

    this.body = null;
  };

  /**
   * Set options for the component. Options will be merged in current options.
   * @param {Object} options  Available parameters:
   *                          {boolean} [showCurrentTime]
   */
  CurrentTime.prototype.setOptions = function (options) {
    if (options) {
      // copy all options that we know
      util.selectiveExtend(['rtl', 'showCurrentTime', 'moment', 'locale', 'locales'], this.options, options);
    }
  };

  /**
   * Repaint the component
   * @return {boolean} Returns true if the component is resized
   */
  CurrentTime.prototype.redraw = function () {
    if (this.options.showCurrentTime) {
      var parent = this.body.dom.backgroundVertical;
      if (this.bar.parentNode != parent) {
        // attach to the dom
        if (this.bar.parentNode) {
          this.bar.parentNode.removeChild(this.bar);
        }
        parent.appendChild(this.bar);

        this.start();
      }

      var now = this.options.moment(new Date().valueOf() + this.offset);
      var x = this.body.util.toScreen(now);

      var locale = this.options.locales[this.options.locale];
      if (!locale) {
        if (!this.warned) {
          console.log('WARNING: options.locales[\'' + this.options.locale + '\'] not found. See http://visjs.org/docs/timeline/#Localization');
          this.warned = true;
        }
        locale = this.options.locales['en']; // fall back on english when not available
      }
      var title = locale.current + ' ' + locale.time + ': ' + now.format('dddd, MMMM Do YYYY, H:mm:ss');
      title = title.charAt(0).toUpperCase() + title.substring(1);

      if (this.options.rtl) {
        this.bar.style.right = x + 'px';
      } else {
        this.bar.style.left = x + 'px';
      }
      this.bar.title = title;
    } else {
      // remove the line from the DOM
      if (this.bar.parentNode) {
        this.bar.parentNode.removeChild(this.bar);
      }
      this.stop();
    }

    return false;
  };

  /**
   * Start auto refreshing the current time bar
   */
  CurrentTime.prototype.start = function () {
    var me = this;

    function update() {
      me.stop();

      // determine interval to refresh
      var scale = me.body.range.conversion(me.body.domProps.center.width).scale;
      var interval = 1 / scale / 10;
      if (interval < 30) interval = 30;
      if (interval > 1000) interval = 1000;

      me.redraw();
      me.body.emitter.emit('currentTimeTick');

      // start a renderTimer to adjust for the new time
      me.currentTimeTimer = setTimeout(update, interval);
    }

    update();
  };

  /**
   * Stop auto refreshing the current time bar
   */
  CurrentTime.prototype.stop = function () {
    if (this.currentTimeTimer !== undefined) {
      clearTimeout(this.currentTimeTimer);
      delete this.currentTimeTimer;
    }
  };

  /**
   * Set a current time. This can be used for example to ensure that a client's
   * time is synchronized with a shared server time.
   * @param {Date | String | Number} time     A Date, unix timestamp, or
   *                                          ISO date string.
   */
  CurrentTime.prototype.setCurrentTime = function (time) {
    var t = util.convert(time, 'Date').valueOf();
    var now = new Date().valueOf();
    this.offset = t - now;
    this.redraw();
  };

  /**
   * Get the current time.
   * @return {Date} Returns the current time.
   */
  CurrentTime.prototype.getCurrentTime = function () {
    return new Date(new Date().valueOf() + this.offset);
  };

  module.exports = CurrentTime;

/***/ },
/* 49 */
/***/ function(module, exports) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  /**
   * This object contains all possible options. It will check if the types are correct, if required if the option is one
   * of the allowed values.
   *
   * __any__ means that the name of the property does not matter.
   * __type__ is a required field for all objects and contains the allowed types of all objects
   */
  var string = 'string';
  var boolean = 'boolean';
  var number = 'number';
  var array = 'array';
  var date = 'date';
  var object = 'object'; // should only be in a __type__ property
  var dom = 'dom';
  var moment = 'moment';
  var any = 'any';

  var allOptions = {
    configure: {
      enabled: { boolean: boolean },
      filter: { boolean: boolean, 'function': 'function' },
      container: { dom: dom },
      __type__: { object: object, boolean: boolean, 'function': 'function' }
    },

    //globals :
    align: { string: string },
    rtl: { boolean: boolean, 'undefined': 'undefined' },
    autoResize: { boolean: boolean },
    throttleRedraw: { number: number },
    clickToUse: { boolean: boolean },
    dataAttributes: { string: string, array: array },
    editable: {
      add: { boolean: boolean, 'undefined': 'undefined' },
      remove: { boolean: boolean, 'undefined': 'undefined' },
      updateGroup: { boolean: boolean, 'undefined': 'undefined' },
      updateTime: { boolean: boolean, 'undefined': 'undefined' },
      __type__: { boolean: boolean, object: object }
    },
    end: { number: number, date: date, string: string, moment: moment },
    format: {
      minorLabels: {
        millisecond: { string: string, 'undefined': 'undefined' },
        second: { string: string, 'undefined': 'undefined' },
        minute: { string: string, 'undefined': 'undefined' },
        hour: { string: string, 'undefined': 'undefined' },
        weekday: { string: string, 'undefined': 'undefined' },
        day: { string: string, 'undefined': 'undefined' },
        month: { string: string, 'undefined': 'undefined' },
        year: { string: string, 'undefined': 'undefined' },
        __type__: { object: object }
      },
      majorLabels: {
        millisecond: { string: string, 'undefined': 'undefined' },
        second: { string: string, 'undefined': 'undefined' },
        minute: { string: string, 'undefined': 'undefined' },
        hour: { string: string, 'undefined': 'undefined' },
        weekday: { string: string, 'undefined': 'undefined' },
        day: { string: string, 'undefined': 'undefined' },
        month: { string: string, 'undefined': 'undefined' },
        year: { string: string, 'undefined': 'undefined' },
        __type__: { object: object }
      },
      __type__: { object: object }
    },
    moment: { 'function': 'function' },
    groupOrder: { string: string, 'function': 'function' },
    groupEditable: {
      add: { boolean: boolean, 'undefined': 'undefined' },
      remove: { boolean: boolean, 'undefined': 'undefined' },
      order: { boolean: boolean, 'undefined': 'undefined' },
      __type__: { boolean: boolean, object: object }
    },
    groupOrderSwap: { 'function': 'function' },
    height: { string: string, number: number },
    hiddenDates: {
      start: { date: date, number: number, string: string, moment: moment },
      end: { date: date, number: number, string: string, moment: moment },
      repeat: { string: string },
      __type__: { object: object, array: array }
    },
    itemsAlwaysDraggable: { boolean: boolean },
    locale: { string: string },
    locales: {
      __any__: { any: any },
      __type__: { object: object }
    },
    margin: {
      axis: { number: number },
      item: {
        horizontal: { number: number, 'undefined': 'undefined' },
        vertical: { number: number, 'undefined': 'undefined' },
        __type__: { object: object, number: number }
      },
      __type__: { object: object, number: number }
    },
    max: { date: date, number: number, string: string, moment: moment },
    maxHeight: { number: number, string: string },
    maxMinorChars: { number: number },
    min: { date: date, number: number, string: string, moment: moment },
    minHeight: { number: number, string: string },
    moveable: { boolean: boolean },
    multiselect: { boolean: boolean },
    multiselectPerGroup: { boolean: boolean },
    onAdd: { 'function': 'function' },
    onUpdate: { 'function': 'function' },
    onMove: { 'function': 'function' },
    onMoving: { 'function': 'function' },
    onRemove: { 'function': 'function' },
    onAddGroup: { 'function': 'function' },
    onMoveGroup: { 'function': 'function' },
    onRemoveGroup: { 'function': 'function' },
    order: { 'function': 'function' },
    orientation: {
      axis: { string: string, 'undefined': 'undefined' },
      item: { string: string, 'undefined': 'undefined' },
      __type__: { string: string, object: object }
    },
    selectable: { boolean: boolean },
    showCurrentTime: { boolean: boolean },
    showMajorLabels: { boolean: boolean },
    showMinorLabels: { boolean: boolean },
    stack: { boolean: boolean },
    snap: { 'function': 'function', 'null': 'null' },
    start: { date: date, number: number, string: string, moment: moment },
    template: { 'function': 'function' },
    groupTemplate: { 'function': 'function' },
    timeAxis: {
      scale: { string: string, 'undefined': 'undefined' },
      step: { number: number, 'undefined': 'undefined' },
      __type__: { object: object }
    },
    type: { string: string },
    width: { string: string, number: number },
    zoomable: { boolean: boolean },
    zoomKey: { string: ['ctrlKey', 'altKey', 'metaKey', ''] },
    zoomMax: { number: number },
    zoomMin: { number: number },

    __type__: { object: object }
  };

  var configureOptions = {
    global: {
      align: ['center', 'left', 'right'],
      direction: false,
      autoResize: true,
      throttleRedraw: [10, 0, 1000, 10],
      clickToUse: false,
      // dataAttributes: ['all'], // FIXME: can be 'all' or string[]
      editable: {
        add: false,
        remove: false,
        updateGroup: false,
        updateTime: false
      },
      end: '',
      format: {
        minorLabels: {
          millisecond: 'SSS',
          second: 's',
          minute: 'HH:mm',
          hour: 'HH:mm',
          weekday: 'ddd D',
          day: 'D',
          month: 'MMM',
          year: 'YYYY'
        },
        majorLabels: {
          millisecond: 'HH:mm:ss',
          second: 'D MMMM HH:mm',
          minute: 'ddd D MMMM',
          hour: 'ddd D MMMM',
          weekday: 'MMMM YYYY',
          day: 'MMMM YYYY',
          month: 'YYYY',
          year: ''
        }
      },

      //groupOrder: {string, 'function': 'function'},
      groupsDraggable: false,
      height: '',
      //hiddenDates: {object, array},
      locale: '',
      margin: {
        axis: [20, 0, 100, 1],
        item: {
          horizontal: [10, 0, 100, 1],
          vertical: [10, 0, 100, 1]
        }
      },
      max: '',
      maxHeight: '',
      maxMinorChars: [7, 0, 20, 1],
      min: '',
      minHeight: '',
      moveable: false,
      multiselect: false,
      multiselectPerGroup: false,
      //onAdd: {'function': 'function'},
      //onUpdate: {'function': 'function'},
      //onMove: {'function': 'function'},
      //onMoving: {'function': 'function'},
      //onRename: {'function': 'function'},
      //order: {'function': 'function'},
      orientation: {
        axis: ['both', 'bottom', 'top'],
        item: ['bottom', 'top']
      },
      selectable: true,
      showCurrentTime: false,
      showMajorLabels: true,
      showMinorLabels: true,
      stack: true,
      //snap: {'function': 'function', nada},
      start: '',
      //template: {'function': 'function'},
      //timeAxis: {
      //  scale: ['millisecond', 'second', 'minute', 'hour', 'weekday', 'day', 'month', 'year'],
      //  step: [1, 1, 10, 1]
      //},
      type: ['box', 'point', 'range', 'background'],
      width: '100%',
      zoomable: true,
      zoomKey: ['ctrlKey', 'altKey', 'metaKey', ''],
      zoomMax: [315360000000000, 10, 315360000000000, 1],
      zoomMin: [10, 10, 315360000000000, 1]
    }
  };

  exports.allOptions = allOptions;
  exports.configureOptions = configureOptions;

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var _Configurator = __webpack_require__(26);

  var _Configurator2 = _interopRequireDefault(_Configurator);

  var _Validator = __webpack_require__(29);

  var _Validator2 = _interopRequireDefault(_Validator);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var Emitter = __webpack_require__(13);
  var Hammer = __webpack_require__(20);
  var moment = __webpack_require__(2);
  var util = __webpack_require__(1);
  var DataSet = __webpack_require__(9);
  var DataView = __webpack_require__(11);
  var Range = __webpack_require__(30);
  var Core = __webpack_require__(33);
  var TimeAxis = __webpack_require__(44);
  var CurrentTime = __webpack_require__(48);
  var CustomTime = __webpack_require__(46);
  var LineGraph = __webpack_require__(51);

  var printStyle = __webpack_require__(29).printStyle;
  var allOptions = __webpack_require__(59).allOptions;
  var configureOptions = __webpack_require__(59).configureOptions;

  /**
   * Create a timeline visualization
   * @param {HTMLElement} container
   * @param {vis.DataSet | Array} [items]
   * @param {Object} [options]  See Graph2d.setOptions for the available options.
   * @constructor
   * @extends Core
   */
  function Graph2d(container, items, groups, options) {
    // if the third element is options, the forth is groups (optionally);
    if (!(Array.isArray(groups) || groups instanceof DataSet || groups instanceof DataView) && groups instanceof Object) {
      var forthArgument = options;
      options = groups;
      groups = forthArgument;
    }

    var me = this;
    this.defaultOptions = {
      start: null,
      end: null,

      autoResize: true,

      orientation: {
        axis: 'bottom', // axis orientation: 'bottom', 'top', or 'both'
        item: 'bottom' // not relevant for Graph2d
      },

      moment: moment,

      width: null,
      height: null,
      maxHeight: null,
      minHeight: null
    };
    this.options = util.deepExtend({}, this.defaultOptions);

    // Create the DOM, props, and emitter
    this._create(container);

    // all components listed here will be repainted automatically
    this.components = [];

    this.body = {
      dom: this.dom,
      domProps: this.props,
      emitter: {
        on: this.on.bind(this),
        off: this.off.bind(this),
        emit: this.emit.bind(this)
      },
      hiddenDates: [],
      util: {
        toScreen: me._toScreen.bind(me),
        toGlobalScreen: me._toGlobalScreen.bind(me), // this refers to the root.width
        toTime: me._toTime.bind(me),
        toGlobalTime: me._toGlobalTime.bind(me)
      }
    };

    // range
    this.range = new Range(this.body);
    this.components.push(this.range);
    this.body.range = this.range;

    // time axis
    this.timeAxis = new TimeAxis(this.body);
    this.components.push(this.timeAxis);
    //this.body.util.snap = this.timeAxis.snap.bind(this.timeAxis);

    // current time bar
    this.currentTime = new CurrentTime(this.body);
    this.components.push(this.currentTime);

    // item set
    this.linegraph = new LineGraph(this.body);

    this.components.push(this.linegraph);

    this.itemsData = null; // DataSet
    this.groupsData = null; // DataSet

    this.on('tap', function (event) {
      me.emit('click', me.getEventProperties(event));
    });
    this.on('doubletap', function (event) {
      me.emit('doubleClick', me.getEventProperties(event));
    });
    this.dom.root.oncontextmenu = function (event) {
      me.emit('contextmenu', me.getEventProperties(event));
    };

    // apply options
    if (options) {
      this.setOptions(options);
    }

    // IMPORTANT: THIS HAPPENS BEFORE SET ITEMS!
    if (groups) {
      this.setGroups(groups);
    }

    // create itemset
    if (items) {
      this.setItems(items);
    }

    // draw for the first time
    this._redraw();
  }

  // Extend the functionality from Core
  Graph2d.prototype = new Core();

  Graph2d.prototype.setOptions = function (options) {
    // validate options
    var errorFound = _Validator2.default.validate(options, allOptions);
    if (errorFound === true) {
      console.log('%cErrors have been found in the supplied options object.', printStyle);
    }

    Core.prototype.setOptions.call(this, options);
  };

  /**
   * Set items
   * @param {vis.DataSet | Array | null} items
   */
  Graph2d.prototype.setItems = function (items) {
    var initialLoad = this.itemsData == null;

    // convert to type DataSet when needed
    var newDataSet;
    if (!items) {
      newDataSet = null;
    } else if (items instanceof DataSet || items instanceof DataView) {
      newDataSet = items;
    } else {
      // turn an array into a dataset
      newDataSet = new DataSet(items, {
        type: {
          start: 'Date',
          end: 'Date'
        }
      });
    }

    // set items
    this.itemsData = newDataSet;
    this.linegraph && this.linegraph.setItems(newDataSet);

    if (initialLoad) {
      if (this.options.start != undefined || this.options.end != undefined) {
        var start = this.options.start != undefined ? this.options.start : null;
        var end = this.options.end != undefined ? this.options.end : null;
        this.setWindow(start, end, { animation: false });
      } else {
        this.fit({ animation: false });
      }
    }
  };

  /**
   * Set groups
   * @param {vis.DataSet | Array} groups
   */
  Graph2d.prototype.setGroups = function (groups) {
    // convert to type DataSet when needed
    var newDataSet;
    if (!groups) {
      newDataSet = null;
    } else if (groups instanceof DataSet || groups instanceof DataView) {
      newDataSet = groups;
    } else {
      // turn an array into a dataset
      newDataSet = new DataSet(groups);
    }

    this.groupsData = newDataSet;
    this.linegraph.setGroups(newDataSet);
  };

  /**
   * Returns an object containing an SVG element with the icon of the group (size determined by iconWidth and iconHeight), the label of the group (content) and the yAxisOrientation of the group (left or right).
   * @param groupId
   * @param width
   * @param height
   */
  Graph2d.prototype.getLegend = function (groupId, width, height) {
    if (width === undefined) {
      width = 15;
    }
    if (height === undefined) {
      height = 15;
    }
    if (this.linegraph.groups[groupId] !== undefined) {
      return this.linegraph.groups[groupId].getLegend(width, height);
    } else {
      return "cannot find group:'" + groupId + "'";
    }
  };

  /**
   * This checks if the visible option of the supplied group (by ID) is true or false.
   * @param groupId
   * @returns {*}
   */
  Graph2d.prototype.isGroupVisible = function (groupId) {
    if (this.linegraph.groups[groupId] !== undefined) {
      return this.linegraph.groups[groupId].visible && (this.linegraph.options.groups.visibility[groupId] === undefined || this.linegraph.options.groups.visibility[groupId] == true);
    } else {
      return false;
    }
  };

  /**
   * Get the data range of the item set.
   * @returns {{min: Date, max: Date}} range  A range with a start and end Date.
   *                                          When no minimum is found, min==null
   *                                          When no maximum is found, max==null
   */
  Graph2d.prototype.getDataRange = function () {
    var min = null;
    var max = null;

    // calculate min from start filed
    for (var groupId in this.linegraph.groups) {
      if (this.linegraph.groups.hasOwnProperty(groupId)) {
        if (this.linegraph.groups[groupId].visible == true) {
          for (var i = 0; i < this.linegraph.groups[groupId].itemsData.length; i++) {
            var item = this.linegraph.groups[groupId].itemsData[i];
            var value = util.convert(item.x, 'Date').valueOf();
            min = min == null ? value : min > value ? value : min;
            max = max == null ? value : max < value ? value : max;
          }
        }
      }
    }

    return {
      min: min != null ? new Date(min) : null,
      max: max != null ? new Date(max) : null
    };
  };

  /**
   * Generate Timeline related information from an event
   * @param {Event} event
   * @return {Object} An object with related information, like on which area
   *                  The event happened, whether clicked on an item, etc.
   */
  Graph2d.prototype.getEventProperties = function (event) {
    var clientX = event.center ? event.center.x : event.clientX;
    var clientY = event.center ? event.center.y : event.clientY;
    var x = clientX - util.getAbsoluteLeft(this.dom.centerContainer);
    var y = clientY - util.getAbsoluteTop(this.dom.centerContainer);
    var time = this._toTime(x);

    var customTime = CustomTime.customTimeFromTarget(event);

    var element = util.getTarget(event);
    var what = null;
    if (util.hasParent(element, this.timeAxis.dom.foreground)) {
      what = 'axis';
    } else if (this.timeAxis2 && util.hasParent(element, this.timeAxis2.dom.foreground)) {
      what = 'axis';
    } else if (util.hasParent(element, this.linegraph.yAxisLeft.dom.frame)) {
      what = 'data-axis';
    } else if (util.hasParent(element, this.linegraph.yAxisRight.dom.frame)) {
      what = 'data-axis';
    } else if (util.hasParent(element, this.linegraph.legendLeft.dom.frame)) {
      what = 'legend';
    } else if (util.hasParent(element, this.linegraph.legendRight.dom.frame)) {
      what = 'legend';
    } else if (customTime != null) {
      what = 'custom-time';
    } else if (util.hasParent(element, this.currentTime.bar)) {
      what = 'current-time';
    } else if (util.hasParent(element, this.dom.center)) {
      what = 'background';
    }

    var value = [];
    var yAxisLeft = this.linegraph.yAxisLeft;
    var yAxisRight = this.linegraph.yAxisRight;
    if (!yAxisLeft.hidden) {
      value.push(yAxisLeft.screenToValue(y));
    }
    if (!yAxisRight.hidden) {
      value.push(yAxisRight.screenToValue(y));
    }

    return {
      event: event,
      what: what,
      pageX: event.srcEvent ? event.srcEvent.pageX : event.pageX,
      pageY: event.srcEvent ? event.srcEvent.pageY : event.pageY,
      x: x,
      y: y,
      time: time,
      value: value
    };
  };

  /**
   * Load a configurator
   * @return {Object}
   * @private
   */
  Graph2d.prototype._createConfigurator = function () {
    return new _Configurator2.default(this, this.dom.container, configureOptions);
  };

  module.exports = Graph2d;

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

  var util = __webpack_require__(1);
  var DOMutil = __webpack_require__(8);
  var DataSet = __webpack_require__(9);
  var DataView = __webpack_require__(11);
  var Component = __webpack_require__(31);
  var DataAxis = __webpack_require__(52);
  var GraphGroup = __webpack_require__(54);
  var Legend = __webpack_require__(58);
  var Bars = __webpack_require__(55);
  var Lines = __webpack_require__(57);
  var Points = __webpack_require__(56);

  var UNGROUPED = '__ungrouped__'; // reserved group id for ungrouped items

  /**
   * This is the constructor of the LineGraph. It requires a Timeline body and options.
   *
   * @param body
   * @param options
   * @constructor
   */
  function LineGraph(body, options) {
    this.id = util.randomUUID();
    this.body = body;

    this.defaultOptions = {
      yAxisOrientation: 'left',
      defaultGroup: 'default',
      sort: true,
      sampling: true,
      stack: false,
      graphHeight: '400px',
      shaded: {
        enabled: false,
        orientation: 'bottom' // top, bottom, zero
      },
      style: 'line', // line, bar
      barChart: {
        width: 50,
        sideBySide: false,
        align: 'center' // left, center, right
      },
      interpolation: {
        enabled: true,
        parametrization: 'centripetal', // uniform (alpha = 0.0), chordal (alpha = 1.0), centripetal (alpha = 0.5)
        alpha: 0.5
      },
      drawPoints: {
        enabled: true,
        size: 6,
        style: 'square' // square, circle
      },
      dataAxis: {}, //Defaults are done on DataAxis level
      legend: {}, //Defaults are done on Legend level
      groups: {
        visibility: {}
      }
    };

    // options is shared by this lineGraph and all its items
    this.options = util.extend({}, this.defaultOptions);
    this.dom = {};
    this.props = {};
    this.hammer = null;
    this.groups = {};
    this.abortedGraphUpdate = false;
    this.updateSVGheight = false;
    this.updateSVGheightOnResize = false;
    this.forceGraphUpdate = true;

    var me = this;
    this.itemsData = null; // DataSet
    this.groupsData = null; // DataSet

    // listeners for the DataSet of the items
    this.itemListeners = {
      'add': function add(event, params, senderId) {
        me._onAdd(params.items);
      },
      'update': function update(event, params, senderId) {
        me._onUpdate(params.items);
      },
      'remove': function remove(event, params, senderId) {
        me._onRemove(params.items);
      }
    };

    // listeners for the DataSet of the groups
    this.groupListeners = {
      'add': function add(event, params, senderId) {
        me._onAddGroups(params.items);
      },
      'update': function update(event, params, senderId) {
        me._onUpdateGroups(params.items);
      },
      'remove': function remove(event, params, senderId) {
        me._onRemoveGroups(params.items);
      }
    };

    this.items = {}; // object with an Item for every data item
    this.selection = []; // list with the ids of all selected nodes
    this.lastStart = this.body.range.start;
    this.touchParams = {}; // stores properties while dragging

    this.svgElements = {};
    this.setOptions(options);
    this.groupsUsingDefaultStyles = [0];
    this.body.emitter.on('rangechanged', function () {
      me.lastStart = me.body.range.start;
      me.svg.style.left = util.option.asSize(-me.props.width);

      me.forceGraphUpdate = true;
      //Is this local redraw necessary? (Core also does a change event!)
      me.redraw.call(me);
    });

    // create the HTML DOM
    this._create();
    this.framework = { svg: this.svg, svgElements: this.svgElements, options: this.options, groups: this.groups };
  }

  LineGraph.prototype = new Component();

  /**
   * Create the HTML DOM for the ItemSet
   */
  LineGraph.prototype._create = function () {
    var frame = document.createElement('div');
    frame.className = 'vis-line-graph';
    this.dom.frame = frame;

    // create svg element for graph drawing.
    this.svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    this.svg.style.position = 'relative';
    this.svg.style.height = ('' + this.options.graphHeight).replace('px', '') + 'px';
    this.svg.style.display = 'block';
    frame.appendChild(this.svg);

    // data axis
    this.options.dataAxis.orientation = 'left';
    this.yAxisLeft = new DataAxis(this.body, this.options.dataAxis, this.svg, this.options.groups);

    this.options.dataAxis.orientation = 'right';
    this.yAxisRight = new DataAxis(this.body, this.options.dataAxis, this.svg, this.options.groups);
    delete this.options.dataAxis.orientation;

    // legends
    this.legendLeft = new Legend(this.body, this.options.legend, 'left', this.options.groups);
    this.legendRight = new Legend(this.body, this.options.legend, 'right', this.options.groups);

    this.show();
  };

  /**
   * set the options of the LineGraph. the mergeOptions is used for subObjects that have an enabled element.
   * @param {object} options
   */
  LineGraph.prototype.setOptions = function (options) {
    if (options) {
      var fields = ['sampling', 'defaultGroup', 'stack', 'height', 'graphHeight', 'yAxisOrientation', 'style', 'barChart', 'dataAxis', 'sort', 'groups'];
      if (options.graphHeight === undefined && options.height !== undefined) {
        this.updateSVGheight = true;
        this.updateSVGheightOnResize = true;
      } else if (this.body.domProps.centerContainer.height !== undefined && options.graphHeight !== undefined) {
        if (parseInt((options.graphHeight + '').replace("px", '')) < this.body.domProps.centerContainer.height) {
          this.updateSVGheight = true;
        }
      }
      util.selectiveDeepExtend(fields, this.options, options);
      util.mergeOptions(this.options, options, 'interpolation');
      util.mergeOptions(this.options, options, 'drawPoints');
      util.mergeOptions(this.options, options, 'shaded');
      util.mergeOptions(this.options, options, 'legend');

      if (options.interpolation) {
        if (_typeof(options.interpolation) == 'object') {
          if (options.interpolation.parametrization) {
            if (options.interpolation.parametrization == 'uniform') {
              this.options.interpolation.alpha = 0;
            } else if (options.interpolation.parametrization == 'chordal') {
              this.options.interpolation.alpha = 1.0;
            } else {
              this.options.interpolation.parametrization = 'centripetal';
              this.options.interpolation.alpha = 0.5;
            }
          }
        }
      }

      if (this.yAxisLeft) {
        if (options.dataAxis !== undefined) {
          this.yAxisLeft.setOptions(this.options.dataAxis);
          this.yAxisRight.setOptions(this.options.dataAxis);
        }
      }

      if (this.legendLeft) {
        if (options.legend !== undefined) {
          this.legendLeft.setOptions(this.options.legend);
          this.legendRight.setOptions(this.options.legend);
        }
      }

      if (this.groups.hasOwnProperty(UNGROUPED)) {
        this.groups[UNGROUPED].setOptions(options);
      }
    }

    // this is used to redraw the graph if the visibility of the groups is changed.
    if (this.dom.frame) {
      //not on initial run?
      this.forceGraphUpdate = true;
      this.body.emitter.emit("_change", { queue: true });
    }
  };

  /**
   * Hide the component from the DOM
   */
  LineGraph.prototype.hide = function () {
    // remove the frame containing the items
    if (this.dom.frame.parentNode) {
      this.dom.frame.parentNode.removeChild(this.dom.frame);
    }
  };

  /**
   * Show the component in the DOM (when not already visible).
   * @return {Boolean} changed
   */
  LineGraph.prototype.show = function () {
    // show frame containing the items
    if (!this.dom.frame.parentNode) {
      this.body.dom.center.appendChild(this.dom.frame);
    }
  };

  /**
   * Set items
   * @param {vis.DataSet | null} items
   */
  LineGraph.prototype.setItems = function (items) {
    var me = this,
        ids,
        oldItemsData = this.itemsData;

    // replace the dataset
    if (!items) {
      this.itemsData = null;
    } else if (items instanceof DataSet || items instanceof DataView) {
      this.itemsData = items;
    } else {
      throw new TypeError('Data must be an instance of DataSet or DataView');
    }

    if (oldItemsData) {
      // unsubscribe from old dataset
      util.forEach(this.itemListeners, function (callback, event) {
        oldItemsData.off(event, callback);
      });

      // remove all drawn items
      ids = oldItemsData.getIds();
      this._onRemove(ids);
    }

    if (this.itemsData) {
      // subscribe to new dataset
      var id = this.id;
      util.forEach(this.itemListeners, function (callback, event) {
        me.itemsData.on(event, callback, id);
      });

      // add all new items
      ids = this.itemsData.getIds();
      this._onAdd(ids);
    }
  };

  /**
   * Set groups
   * @param {vis.DataSet} groups
   */
  LineGraph.prototype.setGroups = function (groups) {
    var me = this;
    var ids;

    // unsubscribe from current dataset
    if (this.groupsData) {
      util.forEach(this.groupListeners, function (callback, event) {
        me.groupsData.off(event, callback);
      });

      // remove all drawn groups
      ids = this.groupsData.getIds();
      this.groupsData = null;
      for (var i = 0; i < ids.length; i++) {
        this._removeGroup(ids[i]);
      }
    }

    // replace the dataset
    if (!groups) {
      this.groupsData = null;
    } else if (groups instanceof DataSet || groups instanceof DataView) {
      this.groupsData = groups;
    } else {
      throw new TypeError('Data must be an instance of DataSet or DataView');
    }

    if (this.groupsData) {
      // subscribe to new dataset
      var id = this.id;
      util.forEach(this.groupListeners, function (callback, event) {
        me.groupsData.on(event, callback, id);
      });

      // draw all ms
      ids = this.groupsData.getIds();
      this._onAddGroups(ids);
    }
  };

  LineGraph.prototype._onUpdate = function (ids) {
    this._updateAllGroupData();
  };
  LineGraph.prototype._onAdd = function (ids) {
    this._onUpdate(ids);
  };
  LineGraph.prototype._onRemove = function (ids) {
    this._onUpdate(ids);
  };
  LineGraph.prototype._onUpdateGroups = function (groupIds) {
    this._updateAllGroupData();
  };
  LineGraph.prototype._onAddGroups = function (groupIds) {
    this._onUpdateGroups(groupIds);
  };

  /**
   * this cleans the group out off the legends and the dataaxis, updates the ungrouped and updates the graph
   * @param {Array} groupIds
   * @private
   */
  LineGraph.prototype._onRemoveGroups = function (groupIds) {
    for (var i = 0; i < groupIds.length; i++) {
      this._removeGroup(groupIds[i]);
    }
    this.forceGraphUpdate = true;
    this.body.emitter.emit("_change", { queue: true });
  };

  /**
   * this cleans the group out off the legends and the dataaxis
   * @param groupId
   * @private
   */
  LineGraph.prototype._removeGroup = function (groupId) {
    if (this.groups.hasOwnProperty(groupId)) {
      if (this.groups[groupId].options.yAxisOrientation == 'right') {
        this.yAxisRight.removeGroup(groupId);
        this.legendRight.removeGroup(groupId);
        this.legendRight.redraw();
      } else {
        this.yAxisLeft.removeGroup(groupId);
        this.legendLeft.removeGroup(groupId);
        this.legendLeft.redraw();
      }
      delete this.groups[groupId];
    }
  };

  /**
   * update a group object with the group dataset entree
   *
   * @param group
   * @param groupId
   * @private
   */
  LineGraph.prototype._updateGroup = function (group, groupId) {
    if (!this.groups.hasOwnProperty(groupId)) {
      this.groups[groupId] = new GraphGroup(group, groupId, this.options, this.groupsUsingDefaultStyles);
      if (this.groups[groupId].options.yAxisOrientation == 'right') {
        this.yAxisRight.addGroup(groupId, this.groups[groupId]);
        this.legendRight.addGroup(groupId, this.groups[groupId]);
      } else {
        this.yAxisLeft.addGroup(groupId, this.groups[groupId]);
        this.legendLeft.addGroup(groupId, this.groups[groupId]);
      }
    } else {
      this.groups[groupId].update(group);
      if (this.groups[groupId].options.yAxisOrientation == 'right') {
        this.yAxisRight.updateGroup(groupId, this.groups[groupId]);
        this.legendRight.updateGroup(groupId, this.groups[groupId]);
        //If yAxisOrientation changed, clean out the group from the other axis.
        this.yAxisLeft.removeGroup(groupId);
        this.legendLeft.removeGroup(groupId);
      } else {
        this.yAxisLeft.updateGroup(groupId, this.groups[groupId]);
        this.legendLeft.updateGroup(groupId, this.groups[groupId]);
        //If yAxisOrientation changed, clean out the group from the other axis.
        this.yAxisRight.removeGroup(groupId);
        this.legendRight.removeGroup(groupId);
      }
    }
    this.legendLeft.redraw();
    this.legendRight.redraw();
  };

  /**
   * this updates all groups, it is used when there is an update the the itemset.
   *
   * @private
   */
  LineGraph.prototype._updateAllGroupData = function () {
    if (this.itemsData != null) {
      var groupsContent = {};
      var items = this.itemsData.get();
      //pre-Determine array sizes, for more efficient memory claim
      var groupCounts = {};
      for (var i = 0; i < items.length; i++) {
        var item = items[i];
        var groupId = item.group;
        if (groupId === null || groupId === undefined) {
          groupId = UNGROUPED;
        }
        groupCounts.hasOwnProperty(groupId) ? groupCounts[groupId]++ : groupCounts[groupId] = 1;
      }
      //Now insert data into the arrays.
      for (var i = 0; i < items.length; i++) {
        var item = items[i];
        var groupId = item.group;
        if (groupId === null || groupId === undefined) {
          groupId = UNGROUPED;
        }
        if (!groupsContent.hasOwnProperty(groupId)) {
          groupsContent[groupId] = new Array(groupCounts[groupId]);
        }
        //Copy data (because of unmodifiable DataView input.
        var extended = util.bridgeObject(item);
        extended.x = util.convert(item.x, 'Date');
        extended.orginalY = item.y; //real Y
        extended.y = Number(item.y);

        var index = groupsContent[groupId].length - groupCounts[groupId]--;
        groupsContent[groupId][index] = extended;
      }

      //Make sure all groups are present, to allow removal of old groups
      for (var groupId in this.groups) {
        if (this.groups.hasOwnProperty(groupId)) {
          if (!groupsContent.hasOwnProperty(groupId)) {
            groupsContent[groupId] = new Array(0);
          }
        }
      }

      //Update legendas, style and axis
      for (var groupId in groupsContent) {
        if (groupsContent.hasOwnProperty(groupId)) {
          if (groupsContent[groupId].length == 0) {
            if (this.groups.hasOwnProperty(groupId)) {
              this._removeGroup(groupId);
            }
          } else {
            var group = undefined;
            if (this.groupsData != undefined) {
              group = this.groupsData.get(groupId);
            }
            if (group == undefined) {
              group = { id: groupId, content: this.options.defaultGroup + groupId };
            }
            this._updateGroup(group, groupId);
            this.groups[groupId].setItems(groupsContent[groupId]);
          }
        }
      }
      this.forceGraphUpdate = true;
      this.body.emitter.emit("_change", { queue: true });
    }
  };

  /**
   * Redraw the component, mandatory function
   * @return {boolean} Returns true if the component is resized
   */
  LineGraph.prototype.redraw = function () {
    var resized = false;

    // calculate actual size and position
    this.props.width = this.dom.frame.offsetWidth;
    this.props.height = this.body.domProps.centerContainer.height - this.body.domProps.border.top - this.body.domProps.border.bottom;

    // check if this component is resized
    resized = this._isResized() || resized;

    // check whether zoomed (in that case we need to re-stack everything)
    var visibleInterval = this.body.range.end - this.body.range.start;
    var zoomed = visibleInterval != this.lastVisibleInterval;
    this.lastVisibleInterval = visibleInterval;

    // the svg element is three times as big as the width, this allows for fully dragging left and right
    // without reloading the graph. the controls for this are bound to events in the constructor
    if (resized == true) {
      this.svg.style.width = util.option.asSize(3 * this.props.width);
      this.svg.style.left = util.option.asSize(-this.props.width);

      // if the height of the graph is set as proportional, change the height of the svg
      if ((this.options.height + '').indexOf("%") != -1 || this.updateSVGheightOnResize == true) {
        this.updateSVGheight = true;
      }
    }

    // update the height of the graph on each redraw of the graph.
    if (this.updateSVGheight == true) {
      if (this.options.graphHeight != this.props.height + 'px') {
        this.options.graphHeight = this.props.height + 'px';
        this.svg.style.height = this.props.height + 'px';
      }
      this.updateSVGheight = false;
    } else {
      this.svg.style.height = ('' + this.options.graphHeight).replace('px', '') + 'px';
    }

    // zoomed is here to ensure that animations are shown correctly.
    if (resized == true || zoomed == true || this.abortedGraphUpdate == true || this.forceGraphUpdate == true) {
      resized = this._updateGraph() || resized;
      this.forceGraphUpdate = false;
    } else {
      // move the whole svg while dragging
      if (this.lastStart != 0) {
        var offset = this.body.range.start - this.lastStart;
        var range = this.body.range.end - this.body.range.start;
        if (this.props.width != 0) {
          var rangePerPixelInv = this.props.width / range;
          var xOffset = offset * rangePerPixelInv;
          this.svg.style.left = -this.props.width - xOffset + 'px';
        }
      }
    }
    this.legendLeft.redraw();
    this.legendRight.redraw();
    return resized;
  };

  LineGraph.prototype._getSortedGroupIds = function () {
    // getting group Ids
    var grouplist = [];
    for (var groupId in this.groups) {
      if (this.groups.hasOwnProperty(groupId)) {
        var group = this.groups[groupId];
        if (group.visible == true && (this.options.groups.visibility[groupId] === undefined || this.options.groups.visibility[groupId] == true)) {
          grouplist.push({ id: groupId, zIndex: group.options.zIndex });
        }
      }
    }
    util.insertSort(grouplist, function (a, b) {
      var az = a.zIndex;
      var bz = b.zIndex;
      if (az === undefined) az = 0;
      if (bz === undefined) bz = 0;
      return az == bz ? 0 : az < bz ? -1 : 1;
    });
    var groupIds = new Array(grouplist.length);
    for (var i = 0; i < grouplist.length; i++) {
      groupIds[i] = grouplist[i].id;
    }
    return groupIds;
  };

  /**
   * Update and redraw the graph.
   *
   */
  LineGraph.prototype._updateGraph = function () {
    // reset the svg elements
    DOMutil.prepareElements(this.svgElements);
    if (this.props.width != 0 && this.itemsData != null) {
      var group, i;
      var groupRanges = {};
      var changeCalled = false;
      // this is the range of the SVG canvas
      var minDate = this.body.util.toGlobalTime(-this.body.domProps.root.width);
      var maxDate = this.body.util.toGlobalTime(2 * this.body.domProps.root.width);

      // getting group Ids
      var groupIds = this._getSortedGroupIds();
      if (groupIds.length > 0) {
        var groupsData = {};

        // fill groups data, this only loads the data we require based on the timewindow
        this._getRelevantData(groupIds, groupsData, minDate, maxDate);

        // apply sampling, if disabled, it will pass through this function.
        this._applySampling(groupIds, groupsData);

        // we transform the X coordinates to detect collisions
        for (i = 0; i < groupIds.length; i++) {
          this._convertXcoordinates(groupsData[groupIds[i]]);
        }

        // now all needed data has been collected we start the processing.
        this._getYRanges(groupIds, groupsData, groupRanges);

        // update the Y axis first, we use this data to draw at the correct Y points
        changeCalled = this._updateYAxis(groupIds, groupRanges);

        //  at changeCalled, abort this update cycle as the graph needs another update with new Width input from the Redraw container.
        //  Cleanup SVG elements on abort.
        if (changeCalled == true) {
          DOMutil.cleanupElements(this.svgElements);
          this.abortedGraphUpdate = true;
          return true;
        }
        this.abortedGraphUpdate = false;

        // With the yAxis scaled correctly, use this to get the Y values of the points.
        var below = undefined;
        for (i = 0; i < groupIds.length; i++) {
          group = this.groups[groupIds[i]];
          if (this.options.stack === true && this.options.style === 'line') {
            if (group.options.excludeFromStacking == undefined || !group.options.excludeFromStacking) {
              if (below != undefined) {
                this._stack(groupsData[group.id], groupsData[below.id]);
                if (group.options.shaded.enabled == true && group.options.shaded.orientation !== "group") {
                  if (group.options.shaded.orientation == "top" && below.options.shaded.orientation !== "group") {
                    below.options.shaded.orientation = "group";
                    below.options.shaded.groupId = group.id;
                  } else {
                    group.options.shaded.orientation = "group";
                    group.options.shaded.groupId = below.id;
                  }
                }
              }
              below = group;
            }
          }
          this._convertYcoordinates(groupsData[groupIds[i]], group);
        }

        //Precalculate paths and draw shading if appropriate. This will make sure the shading is always behind any lines.
        var paths = {};
        for (i = 0; i < groupIds.length; i++) {
          group = this.groups[groupIds[i]];
          if (group.options.style === 'line' && group.options.shaded.enabled == true) {
            var dataset = groupsData[groupIds[i]];
            if (dataset == null || dataset.length == 0) {
              continue;
            }
            if (!paths.hasOwnProperty(groupIds[i])) {
              paths[groupIds[i]] = Lines.calcPath(dataset, group);
            }
            if (group.options.shaded.orientation === "group") {
              var subGroupId = group.options.shaded.groupId;
              if (groupIds.indexOf(subGroupId) === -1) {
                console.log(group.id + ": Unknown shading group target given:" + subGroupId);
                continue;
              }
              if (!paths.hasOwnProperty(subGroupId)) {
                paths[subGroupId] = Lines.calcPath(groupsData[subGroupId], this.groups[subGroupId]);
              }
              Lines.drawShading(paths[groupIds[i]], group, paths[subGroupId], this.framework);
            } else {
              Lines.drawShading(paths[groupIds[i]], group, undefined, this.framework);
            }
          }
        }

        // draw the groups, calculating paths if still necessary.
        Bars.draw(groupIds, groupsData, this.framework);
        for (i = 0; i < groupIds.length; i++) {
          group = this.groups[groupIds[i]];
          if (groupsData[groupIds[i]].length > 0) {
            switch (group.options.style) {
              case "line":
                if (!paths.hasOwnProperty(groupIds[i])) {
                  paths[groupIds[i]] = Lines.calcPath(groupsData[groupIds[i]], group);
                }
                Lines.draw(paths[groupIds[i]], group, this.framework);
              //explicit no break;
              case "point":
              //explicit no break;
              case "points":
                if (group.options.style == "point" || group.options.style == "points" || group.options.drawPoints.enabled == true) {
                  Points.draw(groupsData[groupIds[i]], group, this.framework);
                }
                break;
              case "bar":
              // bar needs to be drawn enmasse
              //explicit no break
              default:
              //do nothing...
            }
          }
        }
      }
    }

    // cleanup unused svg elements
    DOMutil.cleanupElements(this.svgElements);
    return false;
  };

  LineGraph.prototype._stack = function (data, subData) {
    var index, dx, dy, subPrevPoint, subNextPoint;
    index = 0;
    // for each data point we look for a matching on in the set below
    for (var j = 0; j < data.length; j++) {
      subPrevPoint = undefined;
      subNextPoint = undefined;
      // we look for time matches or a before-after point
      for (var k = index; k < subData.length; k++) {
        // if times match exactly
        if (subData[k].x === data[j].x) {
          subPrevPoint = subData[k];
          subNextPoint = subData[k];
          index = k;
          break;
        } else if (subData[k].x > data[j].x) {
          // overshoot
          subNextPoint = subData[k];
          if (k == 0) {
            subPrevPoint = subNextPoint;
          } else {
            subPrevPoint = subData[k - 1];
          }
          index = k;
          break;
        }
      }
      // in case the last data point has been used, we assume it stays like this.
      if (subNextPoint === undefined) {
        subPrevPoint = subData[subData.length - 1];
        subNextPoint = subData[subData.length - 1];
      }
      // linear interpolation
      dx = subNextPoint.x - subPrevPoint.x;
      dy = subNextPoint.y - subPrevPoint.y;
      if (dx == 0) {
        data[j].y = data[j].orginalY + subNextPoint.y;
      } else {
        data[j].y = data[j].orginalY + dy / dx * (data[j].x - subPrevPoint.x) + subPrevPoint.y; // ax + b where b is data[j].y
      }
    }
  };

  /**
   * first select and preprocess the data from the datasets.
   * the groups have their preselection of data, we now loop over this data to see
   * what data we need to draw. Sorted data is much faster.
   * more optimization is possible by doing the sampling before and using the binary search
   * to find the end date to determine the increment.
   *
   * @param {array}  groupIds
   * @param {object} groupsData
   * @param {date}   minDate
   * @param {date}   maxDate
   * @private
   */
  LineGraph.prototype._getRelevantData = function (groupIds, groupsData, minDate, maxDate) {
    var group, i, j, item;
    if (groupIds.length > 0) {
      for (i = 0; i < groupIds.length; i++) {
        group = this.groups[groupIds[i]];
        var itemsData = group.getItems();
        // optimization for sorted data
        if (group.options.sort == true) {
          var dateComparator = function dateComparator(a, b) {
            return a.getTime() == b.getTime() ? 0 : a < b ? -1 : 1;
          };
          var first = Math.max(0, util.binarySearchValue(itemsData, minDate, 'x', 'before', dateComparator));
          var last = Math.min(itemsData.length, util.binarySearchValue(itemsData, maxDate, 'x', 'after', dateComparator) + 1);
          if (last <= 0) {
            last = itemsData.length;
          }
          var dataContainer = new Array(last - first);
          for (j = first; j < last; j++) {
            item = group.itemsData[j];
            dataContainer[j - first] = item;
          }
          groupsData[groupIds[i]] = dataContainer;
        } else {
          // If unsorted data, all data is relevant, just returning entire structure
          groupsData[groupIds[i]] = group.itemsData;
        }
      }
    }
  };

  /**
   *
   * @param groupIds
   * @param groupsData
   * @private
   */
  LineGraph.prototype._applySampling = function (groupIds, groupsData) {
    var group;
    if (groupIds.length > 0) {
      for (var i = 0; i < groupIds.length; i++) {
        group = this.groups[groupIds[i]];
        if (group.options.sampling == true) {
          var dataContainer = groupsData[groupIds[i]];
          if (dataContainer.length > 0) {
            var increment = 1;
            var amountOfPoints = dataContainer.length;

            // the global screen is used because changing the width of the yAxis may affect the increment, resulting in an endless loop
            // of width changing of the yAxis.
            var xDistance = this.body.util.toGlobalScreen(dataContainer[dataContainer.length - 1].x) - this.body.util.toGlobalScreen(dataContainer[0].x);
            var pointsPerPixel = amountOfPoints / xDistance;
            increment = Math.min(Math.ceil(0.2 * amountOfPoints), Math.max(1, Math.round(pointsPerPixel)));

            var sampledData = new Array(amountOfPoints);
            for (var j = 0; j < amountOfPoints; j += increment) {
              var idx = Math.round(j / increment);
              sampledData[idx] = dataContainer[j];
            }
            groupsData[groupIds[i]] = sampledData.splice(0, Math.round(amountOfPoints / increment));
          }
        }
      }
    }
  };

  /**
   *
   *
   * @param {array}  groupIds
   * @param {object} groupsData
   * @param {object} groupRanges  | this is being filled here
   * @private
   */
  LineGraph.prototype._getYRanges = function (groupIds, groupsData, groupRanges) {
    var groupData, group, i;
    var combinedDataLeft = [];
    var combinedDataRight = [];
    var options;
    if (groupIds.length > 0) {
      for (i = 0; i < groupIds.length; i++) {
        groupData = groupsData[groupIds[i]];
        options = this.groups[groupIds[i]].options;
        if (groupData.length > 0) {
          group = this.groups[groupIds[i]];
          // if bar graphs are stacked, their range need to be handled differently and accumulated over all groups.
          if (options.stack === true && options.style === 'bar') {
            if (options.yAxisOrientation === 'left') {
              combinedDataLeft = combinedDataLeft.concat(group.getItems());
            } else {
              combinedDataRight = combinedDataRight.concat(group.getItems());
            }
          } else {
            groupRanges[groupIds[i]] = group.getYRange(groupData, groupIds[i]);
          }
        }
      }

      // if bar graphs are stacked, their range need to be handled differently and accumulated over all groups.
      Bars.getStackedYRange(combinedDataLeft, groupRanges, groupIds, '__barStackLeft', 'left');
      Bars.getStackedYRange(combinedDataRight, groupRanges, groupIds, '__barStackRight', 'right');
    }
  };

  /**
   * this sets the Y ranges for the Y axis. It also determines which of the axis should be shown or hidden.
   * @param {Array} groupIds
   * @param {Object} groupRanges
   * @private
   */
  LineGraph.prototype._updateYAxis = function (groupIds, groupRanges) {
    var resized = false;
    var yAxisLeftUsed = false;
    var yAxisRightUsed = false;
    var minLeft = 1e9,
        minRight = 1e9,
        maxLeft = -1e9,
        maxRight = -1e9,
        minVal,
        maxVal;
    // if groups are present
    if (groupIds.length > 0) {
      // this is here to make sure that if there are no items in the axis but there are groups, that there is no infinite draw/redraw loop.
      for (var i = 0; i < groupIds.length; i++) {
        var group = this.groups[groupIds[i]];
        if (group && group.options.yAxisOrientation != 'right') {
          yAxisLeftUsed = true;
          minLeft = 1e9;
          maxLeft = -1e9;
        } else if (group && group.options.yAxisOrientation) {
          yAxisRightUsed = true;
          minRight = 1e9;
          maxRight = -1e9;
        }
      }

      // if there are items:
      for (var i = 0; i < groupIds.length; i++) {
        if (groupRanges.hasOwnProperty(groupIds[i])) {
          if (groupRanges[groupIds[i]].ignore !== true) {
            minVal = groupRanges[groupIds[i]].min;
            maxVal = groupRanges[groupIds[i]].max;

            if (groupRanges[groupIds[i]].yAxisOrientation != 'right') {
              yAxisLeftUsed = true;
              minLeft = minLeft > minVal ? minVal : minLeft;
              maxLeft = maxLeft < maxVal ? maxVal : maxLeft;
            } else {
              yAxisRightUsed = true;
              minRight = minRight > minVal ? minVal : minRight;
              maxRight = maxRight < maxVal ? maxVal : maxRight;
            }
          }
        }
      }

      if (yAxisLeftUsed == true) {
        this.yAxisLeft.setRange(minLeft, maxLeft);
      }
      if (yAxisRightUsed == true) {
        this.yAxisRight.setRange(minRight, maxRight);
      }
    }
    resized = this._toggleAxisVisiblity(yAxisLeftUsed, this.yAxisLeft) || resized;
    resized = this._toggleAxisVisiblity(yAxisRightUsed, this.yAxisRight) || resized;

    if (yAxisRightUsed == true && yAxisLeftUsed == true) {
      this.yAxisLeft.drawIcons = true;
      this.yAxisRight.drawIcons = true;
    } else {
      this.yAxisLeft.drawIcons = false;
      this.yAxisRight.drawIcons = false;
    }
    this.yAxisRight.master = !yAxisLeftUsed;
    this.yAxisRight.masterAxis = this.yAxisLeft;

    if (this.yAxisRight.master == false) {
      if (yAxisRightUsed == true) {
        this.yAxisLeft.lineOffset = this.yAxisRight.width;
      } else {
        this.yAxisLeft.lineOffset = 0;
      }

      resized = this.yAxisLeft.redraw() || resized;
      resized = this.yAxisRight.redraw() || resized;
    } else {
      resized = this.yAxisRight.redraw() || resized;
    }

    // clean the accumulated lists
    var tempGroups = ['__barStackLeft', '__barStackRight', '__lineStackLeft', '__lineStackRight'];
    for (var i = 0; i < tempGroups.length; i++) {
      if (groupIds.indexOf(tempGroups[i]) != -1) {
        groupIds.splice(groupIds.indexOf(tempGroups[i]), 1);
      }
    }

    return resized;
  };

  /**
   * This shows or hides the Y axis if needed. If there is a change, the changed event is emitted by the updateYAxis function
   *
   * @param {boolean} axisUsed
   * @returns {boolean}
   * @private
   * @param axis
   */
  LineGraph.prototype._toggleAxisVisiblity = function (axisUsed, axis) {
    var changed = false;
    if (axisUsed == false) {
      if (axis.dom.frame.parentNode && axis.hidden == false) {
        axis.hide();
        changed = true;
      }
    } else {
      if (!axis.dom.frame.parentNode && axis.hidden == true) {
        axis.show();
        changed = true;
      }
    }
    return changed;
  };

  /**
   * This uses the DataAxis object to generate the correct X coordinate on the SVG window. It uses the
   * util function toScreen to get the x coordinate from the timestamp. It also pre-filters the data and get the minMax ranges for
   * the yAxis.
   *
   * @param datapoints
   * @returns {Array}
   * @private
   */
  LineGraph.prototype._convertXcoordinates = function (datapoints) {
    var toScreen = this.body.util.toScreen;
    for (var i = 0; i < datapoints.length; i++) {
      datapoints[i].screen_x = toScreen(datapoints[i].x) + this.props.width;
      datapoints[i].screen_y = datapoints[i].y; //starting point for range calculations
    }
  };

  /**
   * This uses the DataAxis object to generate the correct X coordinate on the SVG window. It uses the
   * util function toScreen to get the x coordinate from the timestamp. It also pre-filters the data and get the minMax ranges for
   * the yAxis.
   *
   * @param datapoints
   * @param group
   * @returns {Array}
   * @private
   */
  LineGraph.prototype._convertYcoordinates = function (datapoints, group) {
    var axis = this.yAxisLeft;
    var svgHeight = Number(this.svg.style.height.replace('px', ''));
    if (group.options.yAxisOrientation == 'right') {
      axis = this.yAxisRight;
    }
    for (var i = 0; i < datapoints.length; i++) {
      datapoints[i].screen_y = Math.round(axis.convertValue(datapoints[i].y));
    }
    group.setZeroPosition(Math.min(svgHeight, axis.convertValue(0)));
  };

  module.exports = LineGraph;

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var util = __webpack_require__(1);
  var DOMutil = __webpack_require__(8);
  var Component = __webpack_require__(31);
  var DataScale = __webpack_require__(53);
  /**
   * A horizontal time axis
   * @param {Object} [options]        See DataAxis.setOptions for the available
   *                                  options.
   * @constructor DataAxis
   * @extends Component
   * @param body
   */
  function DataAxis(body, options, svg, linegraphOptions) {
    this.id = util.randomUUID();
    this.body = body;

    this.defaultOptions = {
      orientation: 'left', // supported: 'left', 'right'
      showMinorLabels: true,
      showMajorLabels: true,
      icons: false,
      majorLinesOffset: 7,
      minorLinesOffset: 4,
      labelOffsetX: 10,
      labelOffsetY: 2,
      iconWidth: 20,
      width: '40px',
      visible: true,
      alignZeros: true,
      left: {
        range: { min: undefined, max: undefined },
        format: function format(value) {
          return '' + parseFloat(value.toPrecision(3));
        },
        title: { text: undefined, style: undefined }
      },
      right: {
        range: { min: undefined, max: undefined },
        format: function format(value) {
          return '' + parseFloat(value.toPrecision(3));
        },
        title: { text: undefined, style: undefined }
      }
    };

    this.linegraphOptions = linegraphOptions;
    this.linegraphSVG = svg;
    this.props = {};
    this.DOMelements = { // dynamic elements
      lines: {},
      labels: {},
      title: {}
    };

    this.dom = {};
    this.scale = undefined;
    this.range = { start: 0, end: 0 };

    this.options = util.extend({}, this.defaultOptions);
    this.conversionFactor = 1;

    this.setOptions(options);
    this.width = Number(('' + this.options.width).replace("px", ""));
    this.minWidth = this.width;
    this.height = this.linegraphSVG.getBoundingClientRect().height;
    this.hidden = false;

    this.stepPixels = 25;
    this.zeroCrossing = -1;
    this.amountOfSteps = -1;

    this.lineOffset = 0;
    this.master = true;
    this.masterAxis = null;
    this.svgElements = {};
    this.iconsRemoved = false;

    this.groups = {};
    this.amountOfGroups = 0;

    // create the HTML DOM
    this._create();
    this.framework = { svg: this.svg, svgElements: this.svgElements, options: this.options, groups: this.groups };

    var me = this;
    this.body.emitter.on("verticalDrag", function () {
      me.dom.lineContainer.style.top = me.body.domProps.scrollTop + 'px';
    });
  }

  DataAxis.prototype = new Component();

  DataAxis.prototype.addGroup = function (label, graphOptions) {
    if (!this.groups.hasOwnProperty(label)) {
      this.groups[label] = graphOptions;
    }
    this.amountOfGroups += 1;
  };

  DataAxis.prototype.updateGroup = function (label, graphOptions) {
    if (!this.groups.hasOwnProperty(label)) {
      this.amountOfGroups += 1;
    }
    this.groups[label] = graphOptions;
  };

  DataAxis.prototype.removeGroup = function (label) {
    if (this.groups.hasOwnProperty(label)) {
      delete this.groups[label];
      this.amountOfGroups -= 1;
    }
  };

  DataAxis.prototype.setOptions = function (options) {
    if (options) {
      var redraw = false;
      if (this.options.orientation != options.orientation && options.orientation !== undefined) {
        redraw = true;
      }
      var fields = ['orientation', 'showMinorLabels', 'showMajorLabels', 'icons', 'majorLinesOffset', 'minorLinesOffset', 'labelOffsetX', 'labelOffsetY', 'iconWidth', 'width', 'visible', 'left', 'right', 'alignZeros'];
      util.selectiveDeepExtend(fields, this.options, options);

      this.minWidth = Number(('' + this.options.width).replace("px", ""));
      if (redraw === true && this.dom.frame) {
        this.hide();
        this.show();
      }
    }
  };

  /**
   * Create the HTML DOM for the DataAxis
   */
  DataAxis.prototype._create = function () {
    this.dom.frame = document.createElement('div');
    this.dom.frame.style.width = this.options.width;
    this.dom.frame.style.height = this.height;

    this.dom.lineContainer = document.createElement('div');
    this.dom.lineContainer.style.width = '100%';
    this.dom.lineContainer.style.height = this.height;
    this.dom.lineContainer.style.position = 'relative';

    // create svg element for graph drawing.
    this.svg = document.createElementNS('http://www.w3.org/2000/svg', "svg");
    this.svg.style.position = "absolute";
    this.svg.style.top = '0px';
    this.svg.style.height = '100%';
    this.svg.style.width = '100%';
    this.svg.style.display = "block";
    this.dom.frame.appendChild(this.svg);
  };

  DataAxis.prototype._redrawGroupIcons = function () {
    DOMutil.prepareElements(this.svgElements);

    var x;
    var iconWidth = this.options.iconWidth;
    var iconHeight = 15;
    var iconOffset = 4;
    var y = iconOffset + 0.5 * iconHeight;

    if (this.options.orientation === 'left') {
      x = iconOffset;
    } else {
      x = this.width - iconWidth - iconOffset;
    }

    var groupArray = Object.keys(this.groups);
    groupArray.sort(function (a, b) {
      return a < b ? -1 : 1;
    });

    for (var i = 0; i < groupArray.length; i++) {
      var groupId = groupArray[i];
      if (this.groups[groupId].visible === true && (this.linegraphOptions.visibility[groupId] === undefined || this.linegraphOptions.visibility[groupId] === true)) {
        this.groups[groupId].getLegend(iconWidth, iconHeight, this.framework, x, y);
        y += iconHeight + iconOffset;
      }
    }

    DOMutil.cleanupElements(this.svgElements);
    this.iconsRemoved = false;
  };

  DataAxis.prototype._cleanupIcons = function () {
    if (this.iconsRemoved === false) {
      DOMutil.prepareElements(this.svgElements);
      DOMutil.cleanupElements(this.svgElements);
      this.iconsRemoved = true;
    }
  };

  /**
   * Create the HTML DOM for the DataAxis
   */
  DataAxis.prototype.show = function () {
    this.hidden = false;
    if (!this.dom.frame.parentNode) {
      if (this.options.rtl) {
        this.body.dom.left.appendChild(this.dom.frame);
      } else {
        this.body.dom.left.appendChild(this.dom.frame);
      }
    }

    if (!this.dom.lineContainer.parentNode) {
      this.body.dom.backgroundHorizontal.appendChild(this.dom.lineContainer);
    }
  };

  /**
   * Create the HTML DOM for the DataAxis
   */
  DataAxis.prototype.hide = function () {
    this.hidden = true;
    if (this.dom.frame.parentNode) {
      this.dom.frame.parentNode.removeChild(this.dom.frame);
    }

    if (this.dom.lineContainer.parentNode) {
      this.dom.lineContainer.parentNode.removeChild(this.dom.lineContainer);
    }
  };

  /**
   * Set a range (start and end)
   * @param end
   * @param start
   * @param end
   */
  DataAxis.prototype.setRange = function (start, end) {
    this.range.start = start;
    this.range.end = end;
  };

  /**
   * Repaint the component
   * @return {boolean} Returns true if the component is resized
   */
  DataAxis.prototype.redraw = function () {
    var resized = false;
    var activeGroups = 0;

    // Make sure the line container adheres to the vertical scrolling.
    this.dom.lineContainer.style.top = this.body.domProps.scrollTop + 'px';

    for (var groupId in this.groups) {
      if (this.groups.hasOwnProperty(groupId)) {
        if (this.groups[groupId].visible === true && (this.linegraphOptions.visibility[groupId] === undefined || this.linegraphOptions.visibility[groupId] === true)) {
          activeGroups++;
        }
      }
    }
    if (this.amountOfGroups === 0 || activeGroups === 0) {
      this.hide();
    } else {
      this.show();
      this.height = Number(this.linegraphSVG.style.height.replace("px", ""));

      // svg offsetheight did not work in firefox and explorer...
      this.dom.lineContainer.style.height = this.height + 'px';
      this.width = this.options.visible === true ? Number(('' + this.options.width).replace("px", "")) : 0;

      var props = this.props;
      var frame = this.dom.frame;

      // update classname
      frame.className = 'vis-data-axis';

      // calculate character width and height
      this._calculateCharSize();

      var orientation = this.options.orientation;
      var showMinorLabels = this.options.showMinorLabels;
      var showMajorLabels = this.options.showMajorLabels;

      // determine the width and height of the elements for the axis
      props.minorLabelHeight = showMinorLabels ? props.minorCharHeight : 0;
      props.majorLabelHeight = showMajorLabels ? props.majorCharHeight : 0;

      props.minorLineWidth = this.body.dom.backgroundHorizontal.offsetWidth - this.lineOffset - this.width + 2 * this.options.minorLinesOffset;
      props.minorLineHeight = 1;
      props.majorLineWidth = this.body.dom.backgroundHorizontal.offsetWidth - this.lineOffset - this.width + 2 * this.options.majorLinesOffset;
      props.majorLineHeight = 1;

      //  take frame offline while updating (is almost twice as fast)
      if (orientation === 'left') {
        frame.style.top = '0';
        frame.style.left = '0';
        frame.style.bottom = '';
        frame.style.width = this.width + 'px';
        frame.style.height = this.height + "px";
        this.props.width = this.body.domProps.left.width;
        this.props.height = this.body.domProps.left.height;
      } else {
        // right
        frame.style.top = '';
        frame.style.bottom = '0';
        frame.style.left = '0';
        frame.style.width = this.width + 'px';
        frame.style.height = this.height + "px";
        this.props.width = this.body.domProps.right.width;
        this.props.height = this.body.domProps.right.height;
      }

      resized = this._redrawLabels();
      resized = this._isResized() || resized;

      if (this.options.icons === true) {
        this._redrawGroupIcons();
      } else {
        this._cleanupIcons();
      }

      this._redrawTitle(orientation);
    }
    return resized;
  };

  /**
   * Repaint major and minor text labels and vertical grid lines
   * @private
   */
  DataAxis.prototype._redrawLabels = function () {
    var _this = this;

    var resized = false;
    DOMutil.prepareElements(this.DOMelements.lines);
    DOMutil.prepareElements(this.DOMelements.labels);
    var orientation = this.options['orientation'];
    var customRange = this.options[orientation].range != undefined ? this.options[orientation].range : {};

    //Override range with manual options:
    var autoScaleEnd = true;
    if (customRange.max != undefined) {
      this.range.end = customRange.max;
      autoScaleEnd = false;
    }
    var autoScaleStart = true;
    if (customRange.min != undefined) {
      this.range.start = customRange.min;
      autoScaleStart = false;
    }

    this.scale = new DataScale(this.range.start, this.range.end, autoScaleStart, autoScaleEnd, this.dom.frame.offsetHeight, this.props.majorCharHeight, this.options.alignZeros, this.options[orientation].format);

    if (this.master === false && this.masterAxis != undefined) {
      this.scale.followScale(this.masterAxis.scale);
    }

    //Is updated in side-effect of _redrawLabel():
    this.maxLabelSize = 0;

    var lines = this.scale.getLines();
    lines.forEach(function (line) {
      var y = line.y;
      var isMajor = line.major;
      if (_this.options['showMinorLabels'] && isMajor === false) {
        _this._redrawLabel(y - 2, line.val, orientation, 'vis-y-axis vis-minor', _this.props.minorCharHeight);
      }
      if (isMajor) {
        if (y >= 0) {
          _this._redrawLabel(y - 2, line.val, orientation, 'vis-y-axis vis-major', _this.props.majorCharHeight);
        }
      }
      if (_this.master === true) {
        if (isMajor) {
          _this._redrawLine(y, orientation, 'vis-grid vis-horizontal vis-major', _this.options.majorLinesOffset, _this.props.majorLineWidth);
        } else {
          _this._redrawLine(y, orientation, 'vis-grid vis-horizontal vis-minor', _this.options.minorLinesOffset, _this.props.minorLineWidth);
        }
      }
    });

    // Note that title is rotated, so we're using the height, not width!
    var titleWidth = 0;
    if (this.options[orientation].title !== undefined && this.options[orientation].title.text !== undefined) {
      titleWidth = this.props.titleCharHeight;
    }
    var offset = this.options.icons === true ? Math.max(this.options.iconWidth, titleWidth) + this.options.labelOffsetX + 15 : titleWidth + this.options.labelOffsetX + 15;

    // this will resize the yAxis to accommodate the labels.
    if (this.maxLabelSize > this.width - offset && this.options.visible === true) {
      this.width = this.maxLabelSize + offset;
      this.options.width = this.width + "px";
      DOMutil.cleanupElements(this.DOMelements.lines);
      DOMutil.cleanupElements(this.DOMelements.labels);
      this.redraw();
      resized = true;
    }
    // this will resize the yAxis if it is too big for the labels.
    else if (this.maxLabelSize < this.width - offset && this.options.visible === true && this.width > this.minWidth) {
        this.width = Math.max(this.minWidth, this.maxLabelSize + offset);
        this.options.width = this.width + "px";
        DOMutil.cleanupElements(this.DOMelements.lines);
        DOMutil.cleanupElements(this.DOMelements.labels);
        this.redraw();
        resized = true;
      } else {
        DOMutil.cleanupElements(this.DOMelements.lines);
        DOMutil.cleanupElements(this.DOMelements.labels);
        resized = false;
      }

    return resized;
  };

  DataAxis.prototype.convertValue = function (value) {
    return this.scale.convertValue(value);
  };

  DataAxis.prototype.screenToValue = function (x) {
    return this.scale.screenToValue(x);
  };

  /**
   * Create a label for the axis at position x
   * @private
   * @param y
   * @param text
   * @param orientation
   * @param className
   * @param characterHeight
   */
  DataAxis.prototype._redrawLabel = function (y, text, orientation, className, characterHeight) {
    // reuse redundant label
    var label = DOMutil.getDOMElement('div', this.DOMelements.labels, this.dom.frame); //this.dom.redundant.labels.shift();
    label.className = className;
    label.innerHTML = text;
    if (orientation === 'left') {
      label.style.left = '-' + this.options.labelOffsetX + 'px';
      label.style.textAlign = "right";
    } else {
      label.style.right = '-' + this.options.labelOffsetX + 'px';
      label.style.textAlign = "left";
    }

    label.style.top = y - 0.5 * characterHeight + this.options.labelOffsetY + 'px';

    text += '';

    var largestWidth = Math.max(this.props.majorCharWidth, this.props.minorCharWidth);
    if (this.maxLabelSize < text.length * largestWidth) {
      this.maxLabelSize = text.length * largestWidth;
    }
  };

  /**
   * Create a minor line for the axis at position y
   * @param y
   * @param orientation
   * @param className
   * @param offset
   * @param width
   */
  DataAxis.prototype._redrawLine = function (y, orientation, className, offset, width) {
    if (this.master === true) {
      var line = DOMutil.getDOMElement('div', this.DOMelements.lines, this.dom.lineContainer); //this.dom.redundant.lines.shift();
      line.className = className;
      line.innerHTML = '';

      if (orientation === 'left') {
        line.style.left = this.width - offset + 'px';
      } else {
        line.style.right = this.width - offset + 'px';
      }

      line.style.width = width + 'px';
      line.style.top = y + 'px';
    }
  };

  /**
   * Create a title for the axis
   * @private
   * @param orientation
   */
  DataAxis.prototype._redrawTitle = function (orientation) {
    DOMutil.prepareElements(this.DOMelements.title);

    // Check if the title is defined for this axes
    if (this.options[orientation].title !== undefined && this.options[orientation].title.text !== undefined) {
      var title = DOMutil.getDOMElement('div', this.DOMelements.title, this.dom.frame);
      title.className = 'vis-y-axis vis-title vis-' + orientation;
      title.innerHTML = this.options[orientation].title.text;

      // Add style - if provided
      if (this.options[orientation].title.style !== undefined) {
        util.addCssText(title, this.options[orientation].title.style);
      }

      if (orientation === 'left') {
        title.style.left = this.props.titleCharHeight + 'px';
      } else {
        title.style.right = this.props.titleCharHeight + 'px';
      }

      title.style.width = this.height + 'px';
    }

    // we need to clean up in case we did not use all elements.
    DOMutil.cleanupElements(this.DOMelements.title);
  };

  /**
   * Determine the size of text on the axis (both major and minor axis).
   * The size is calculated only once and then cached in this.props.
   * @private
   */
  DataAxis.prototype._calculateCharSize = function () {
    // determine the char width and height on the minor axis
    if (!('minorCharHeight' in this.props)) {
      var textMinor = document.createTextNode('0');
      var measureCharMinor = document.createElement('div');
      measureCharMinor.className = 'vis-y-axis vis-minor vis-measure';
      measureCharMinor.appendChild(textMinor);
      this.dom.frame.appendChild(measureCharMinor);

      this.props.minorCharHeight = measureCharMinor.clientHeight;
      this.props.minorCharWidth = measureCharMinor.clientWidth;

      this.dom.frame.removeChild(measureCharMinor);
    }

    if (!('majorCharHeight' in this.props)) {
      var textMajor = document.createTextNode('0');
      var measureCharMajor = document.createElement('div');
      measureCharMajor.className = 'vis-y-axis vis-major vis-measure';
      measureCharMajor.appendChild(textMajor);
      this.dom.frame.appendChild(measureCharMajor);

      this.props.majorCharHeight = measureCharMajor.clientHeight;
      this.props.majorCharWidth = measureCharMajor.clientWidth;

      this.dom.frame.removeChild(measureCharMajor);
    }

    if (!('titleCharHeight' in this.props)) {
      var textTitle = document.createTextNode('0');
      var measureCharTitle = document.createElement('div');
      measureCharTitle.className = 'vis-y-axis vis-title vis-measure';
      measureCharTitle.appendChild(textTitle);
      this.dom.frame.appendChild(measureCharTitle);

      this.props.titleCharHeight = measureCharTitle.clientHeight;
      this.props.titleCharWidth = measureCharTitle.clientWidth;

      this.dom.frame.removeChild(measureCharTitle);
    }
  };

  module.exports = DataAxis;

/***/ },
/* 53 */
/***/ function(module, exports) {

  'use strict';

  /**
   * Created by ludo on 25-1-16.
   */

  function DataScale(start, end, autoScaleStart, autoScaleEnd, containerHeight, majorCharHeight) {
    var zeroAlign = arguments.length <= 6 || arguments[6] === undefined ? false : arguments[6];
    var formattingFunction = arguments.length <= 7 || arguments[7] === undefined ? false : arguments[7];

    this.majorSteps = [1, 2, 5, 10];
    this.minorSteps = [0.25, 0.5, 1, 2];
    this.customLines = null;

    this.containerHeight = containerHeight;
    this.majorCharHeight = majorCharHeight;
    this._start = start;
    this._end = end;

    this.scale = 1;
    this.minorStepIdx = -1;
    this.magnitudefactor = 1;
    this.determineScale();

    this.zeroAlign = zeroAlign;
    this.autoScaleStart = autoScaleStart;
    this.autoScaleEnd = autoScaleEnd;

    this.formattingFunction = formattingFunction;

    if (autoScaleStart || autoScaleEnd) {
      var me = this;
      var roundToMinor = function roundToMinor(value) {
        var rounded = value - value % (me.magnitudefactor * me.minorSteps[me.minorStepIdx]);
        if (value % (me.magnitudefactor * me.minorSteps[me.minorStepIdx]) > 0.5 * (me.magnitudefactor * me.minorSteps[me.minorStepIdx])) {
          return rounded + me.magnitudefactor * me.minorSteps[me.minorStepIdx];
        } else {
          return rounded;
        }
      };
      if (autoScaleStart) {
        this._start -= this.magnitudefactor * 2 * this.minorSteps[this.minorStepIdx];
        this._start = roundToMinor(this._start);
      }

      if (autoScaleEnd) {
        this._end += this.magnitudefactor * this.minorSteps[this.minorStepIdx];
        this._end = roundToMinor(this._end);
      }
      this.determineScale();
    }
  }

  DataScale.prototype.setCharHeight = function (majorCharHeight) {
    this.majorCharHeight = majorCharHeight;
  };

  DataScale.prototype.setHeight = function (containerHeight) {
    this.containerHeight = containerHeight;
  };

  DataScale.prototype.determineScale = function () {
    var range = this._end - this._start;
    this.scale = this.containerHeight / range;
    var minimumStepValue = this.majorCharHeight / this.scale;
    var orderOfMagnitude = range > 0 ? Math.round(Math.log(range) / Math.LN10) : 0;

    this.minorStepIdx = -1;
    this.magnitudefactor = Math.pow(10, orderOfMagnitude);

    var start = 0;
    if (orderOfMagnitude < 0) {
      start = orderOfMagnitude;
    }

    var solutionFound = false;
    for (var l = start; Math.abs(l) <= Math.abs(orderOfMagnitude); l++) {
      this.magnitudefactor = Math.pow(10, l);
      for (var j = 0; j < this.minorSteps.length; j++) {
        var stepSize = this.magnitudefactor * this.minorSteps[j];
        if (stepSize >= minimumStepValue) {
          solutionFound = true;
          this.minorStepIdx = j;
          break;
        }
      }
      if (solutionFound === true) {
        break;
      }
    }
  };

  DataScale.prototype.is_major = function (value) {
    return value % (this.magnitudefactor * this.majorSteps[this.minorStepIdx]) === 0;
  };

  DataScale.prototype.getStep = function () {
    return this.magnitudefactor * this.minorSteps[this.minorStepIdx];
  };

  DataScale.prototype.getFirstMajor = function () {
    var majorStep = this.magnitudefactor * this.majorSteps[this.minorStepIdx];
    return this.convertValue(this._start + (majorStep - this._start % majorStep) % majorStep);
  };

  DataScale.prototype.formatValue = function (current) {
    var returnValue = current.toPrecision(5);
    if (typeof this.formattingFunction === 'function') {
      returnValue = this.formattingFunction(current);
    }

    if (typeof returnValue === 'number') {
      return '' + returnValue;
    } else if (typeof returnValue === 'string') {
      return returnValue;
    } else {
      return current.toPrecision(5);
    }
  };

  DataScale.prototype.getLines = function () {
    var lines = [];
    var step = this.getStep();
    var bottomOffset = (step - this._start % step) % step;
    for (var i = this._start + bottomOffset; this._end - i > 0.00001; i += step) {
      if (i != this._start) {
        //Skip the bottom line
        lines.push({ major: this.is_major(i), y: this.convertValue(i), val: this.formatValue(i) });
      }
    }
    return lines;
  };

  DataScale.prototype.followScale = function (other) {
    var oldStepIdx = this.minorStepIdx;
    var oldStart = this._start;
    var oldEnd = this._end;

    var me = this;
    var increaseMagnitude = function increaseMagnitude() {
      me.magnitudefactor *= 2;
    };
    var decreaseMagnitude = function decreaseMagnitude() {
      me.magnitudefactor /= 2;
    };

    if (other.minorStepIdx <= 1 && this.minorStepIdx <= 1 || other.minorStepIdx > 1 && this.minorStepIdx > 1) {
      //easy, no need to change stepIdx nor multiplication factor
    } else if (other.minorStepIdx < this.minorStepIdx) {
        //I'm 5, they are 4 per major.
        this.minorStepIdx = 1;
        if (oldStepIdx == 2) {
          increaseMagnitude();
        } else {
          increaseMagnitude();
          increaseMagnitude();
        }
      } else {
        //I'm 4, they are 5 per major
        this.minorStepIdx = 2;
        if (oldStepIdx == 1) {
          decreaseMagnitude();
        } else {
          decreaseMagnitude();
          decreaseMagnitude();
        }
      }

    //Get masters stats:
    var lines = other.getLines();
    var otherZero = other.convertValue(0);
    var otherStep = other.getStep() * other.scale;

    var done = false;
    var count = 0;
    //Loop until magnitude is correct for given constrains.
    while (!done && count++ < 5) {

      //Get my stats:
      this.scale = otherStep / (this.minorSteps[this.minorStepIdx] * this.magnitudefactor);
      var newRange = this.containerHeight / this.scale;

      //For the case the magnitudefactor has changed:
      this._start = oldStart;
      this._end = this._start + newRange;

      var myOriginalZero = this._end * this.scale;
      var majorStep = this.magnitudefactor * this.majorSteps[this.minorStepIdx];
      var majorOffset = this.getFirstMajor() - other.getFirstMajor();

      if (this.zeroAlign) {
        var zeroOffset = otherZero - myOriginalZero;
        this._end += zeroOffset / this.scale;
        this._start = this._end - newRange;
      } else {
        if (!this.autoScaleStart) {
          this._start += majorStep - majorOffset / this.scale;
          this._end = this._start + newRange;
        } else {
          this._start -= majorOffset / this.scale;
          this._end = this._start + newRange;
        }
      }
      if (!this.autoScaleEnd && this._end > oldEnd + 0.00001) {
        //Need to decrease magnitude to prevent scale overshoot! (end)
        decreaseMagnitude();
        done = false;
        continue;
      }
      if (!this.autoScaleStart && this._start < oldStart - 0.00001) {
        if (this.zeroAlign && oldStart >= 0) {
          console.warn("Can't adhere to given 'min' range, due to zeroalign");
        } else {
          //Need to decrease magnitude to prevent scale overshoot! (start)
          decreaseMagnitude();
          done = false;
          continue;
        }
      }
      if (this.autoScaleStart && this.autoScaleEnd && newRange < oldEnd - oldStart) {
        increaseMagnitude();
        done = false;
        continue;
      }
      done = true;
    }
  };

  DataScale.prototype.convertValue = function (value) {
    return this.containerHeight - (value - this._start) * this.scale;
  };

  DataScale.prototype.screenToValue = function (pixels) {
    return (this.containerHeight - pixels) / this.scale + this._start;
  };

  module.exports = DataScale;

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

  var util = __webpack_require__(1);
  var DOMutil = __webpack_require__(8);
  var Bars = __webpack_require__(55);
  var Lines = __webpack_require__(57);
  var Points = __webpack_require__(56);

  /**
   * /**
   * @param {object} group            | the object of the group from the dataset
   * @param {string} groupId          | ID of the group
   * @param {object} options          | the default options
   * @param {array} groupsUsingDefaultStyles  | this array has one entree.
   *                                            It is passed as an array so it is passed by reference.
   *                                            It enumerates through the default styles
   * @constructor
   */
  function GraphGroup(group, groupId, options, groupsUsingDefaultStyles) {
    this.id = groupId;
    var fields = ['sampling', 'style', 'sort', 'yAxisOrientation', 'barChart', 'drawPoints', 'shaded', 'interpolation', 'zIndex', 'excludeFromStacking', 'excludeFromLegend'];
    this.options = util.selectiveBridgeObject(fields, options);
    this.usingDefaultStyle = group.className === undefined;
    this.groupsUsingDefaultStyles = groupsUsingDefaultStyles;
    this.zeroPosition = 0;
    this.update(group);
    if (this.usingDefaultStyle == true) {
      this.groupsUsingDefaultStyles[0] += 1;
    }
    this.itemsData = [];
    this.visible = group.visible === undefined ? true : group.visible;
  }

  /**
   * this loads a reference to all items in this group into this group.
   * @param {array} items
   */
  GraphGroup.prototype.setItems = function (items) {
    if (items != null) {
      this.itemsData = items;
      if (this.options.sort == true) {
        util.insertSort(this.itemsData, function (a, b) {
          return a.x > b.x ? 1 : -1;
        });
      }
    } else {
      this.itemsData = [];
    }
  };

  GraphGroup.prototype.getItems = function () {
    return this.itemsData;
  };

  /**
   * this is used for barcharts and shading, this way, we only have to calculate it once.
   * @param pos
   */
  GraphGroup.prototype.setZeroPosition = function (pos) {
    this.zeroPosition = pos;
  };

  /**
   * set the options of the graph group over the default options.
   * @param options
   */
  GraphGroup.prototype.setOptions = function (options) {
    if (options !== undefined) {
      var fields = ['sampling', 'style', 'sort', 'yAxisOrientation', 'barChart', 'zIndex', 'excludeFromStacking', 'excludeFromLegend'];
      util.selectiveDeepExtend(fields, this.options, options);

      // if the group's drawPoints is a function delegate the callback to the onRender property
      if (typeof options.drawPoints == 'function') {
        options.drawPoints = {
          onRender: options.drawPoints
        };
      }

      util.mergeOptions(this.options, options, 'interpolation');
      util.mergeOptions(this.options, options, 'drawPoints');
      util.mergeOptions(this.options, options, 'shaded');

      if (options.interpolation) {
        if (_typeof(options.interpolation) == 'object') {
          if (options.interpolation.parametrization) {
            if (options.interpolation.parametrization == 'uniform') {
              this.options.interpolation.alpha = 0;
            } else if (options.interpolation.parametrization == 'chordal') {
              this.options.interpolation.alpha = 1.0;
            } else {
              this.options.interpolation.parametrization = 'centripetal';
              this.options.interpolation.alpha = 0.5;
            }
          }
        }
      }
    }
  };

  /**
   * this updates the current group class with the latest group dataset entree, used in _updateGroup in linegraph
   * @param group
   */
  GraphGroup.prototype.update = function (group) {
    this.group = group;
    this.content = group.content || 'graph';
    this.className = group.className || this.className || 'vis-graph-group' + this.groupsUsingDefaultStyles[0] % 10;
    this.visible = group.visible === undefined ? true : group.visible;
    this.style = group.style;
    this.setOptions(group.options);
  };

  /**
   * return the legend entree for this group.
   *
   * @param iconWidth
   * @param iconHeight
   * @returns {{icon: HTMLElement, label: (group.content|*|string), orientation: (.options.yAxisOrientation|*)}}
   */
  GraphGroup.prototype.getLegend = function (iconWidth, iconHeight, framework, x, y) {
    if (framework == undefined || framework == null) {
      var svg = document.createElementNS('http://www.w3.org/2000/svg', "svg");
      framework = { svg: svg, svgElements: {}, options: this.options, groups: [this] };
    }
    if (x == undefined || x == null) {
      x = 0;
    }
    if (y == undefined || y == null) {
      y = 0.5 * iconHeight;
    }
    switch (this.options.style) {
      case "line":
        Lines.drawIcon(this, x, y, iconWidth, iconHeight, framework);
        break;
      case "points": //explicit no break
      case "point":
        Points.drawIcon(this, x, y, iconWidth, iconHeight, framework);
        break;
      case "bar":
        Bars.drawIcon(this, x, y, iconWidth, iconHeight, framework);
        break;
    }
    return { icon: framework.svg, label: this.content, orientation: this.options.yAxisOrientation };
  };

  GraphGroup.prototype.getYRange = function (groupData) {
    var yMin = groupData[0].y;
    var yMax = groupData[0].y;
    for (var j = 0; j < groupData.length; j++) {
      yMin = yMin > groupData[j].y ? groupData[j].y : yMin;
      yMax = yMax < groupData[j].y ? groupData[j].y : yMax;
    }
    return { min: yMin, max: yMax, yAxisOrientation: this.options.yAxisOrientation };
  };

  module.exports = GraphGroup;

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var DOMutil = __webpack_require__(8);
  var Points = __webpack_require__(56);

  function Bargraph(groupId, options) {}

  Bargraph.drawIcon = function (group, x, y, iconWidth, iconHeight, framework) {
    var fillHeight = iconHeight * 0.5;
    var path, fillPath;

    var outline = DOMutil.getSVGElement("rect", framework.svgElements, framework.svg);
    outline.setAttributeNS(null, "x", x);
    outline.setAttributeNS(null, "y", y - fillHeight);
    outline.setAttributeNS(null, "width", iconWidth);
    outline.setAttributeNS(null, "height", 2 * fillHeight);
    outline.setAttributeNS(null, "class", "vis-outline");

    var barWidth = Math.round(0.3 * iconWidth);
    var originalWidth = group.options.barChart.width;
    var scale = originalWidth / barWidth;
    var bar1Height = Math.round(0.4 * iconHeight);
    var bar2Height = Math.round(0.75 * iconHeight);

    var offset = Math.round((iconWidth - 2 * barWidth) / 3);

    DOMutil.drawBar(x + 0.5 * barWidth + offset, y + fillHeight - bar1Height - 1, barWidth, bar1Height, group.className + ' vis-bar', framework.svgElements, framework.svg, group.style);
    DOMutil.drawBar(x + 1.5 * barWidth + offset + 2, y + fillHeight - bar2Height - 1, barWidth, bar2Height, group.className + ' vis-bar', framework.svgElements, framework.svg, group.style);

    if (group.options.drawPoints.enabled == true) {
      var groupTemplate = {
        style: group.options.drawPoints.style,
        styles: group.options.drawPoints.styles,
        size: group.options.drawPoints.size / scale,
        className: group.className
      };
      DOMutil.drawPoint(x + 0.5 * barWidth + offset, y + fillHeight - bar1Height - 1, groupTemplate, framework.svgElements, framework.svg);
      DOMutil.drawPoint(x + 1.5 * barWidth + offset + 2, y + fillHeight - bar2Height - 1, groupTemplate, framework.svgElements, framework.svg);
    }
  };

  /**
   * draw a bar graph
   *
   * @param groupIds
   * @param processedGroupData
   */
  Bargraph.draw = function (groupIds, processedGroupData, framework) {
    var combinedData = [];
    var intersections = {};
    var coreDistance;
    var key, drawData;
    var group;
    var i, j;
    var barPoints = 0;

    // combine all barchart data
    for (i = 0; i < groupIds.length; i++) {
      group = framework.groups[groupIds[i]];
      if (group.options.style === 'bar') {
        if (group.visible === true && (framework.options.groups.visibility[groupIds[i]] === undefined || framework.options.groups.visibility[groupIds[i]] === true)) {
          for (j = 0; j < processedGroupData[groupIds[i]].length; j++) {
            combinedData.push({
              screen_x: processedGroupData[groupIds[i]][j].screen_x,
              screen_y: processedGroupData[groupIds[i]][j].screen_y,
              x: processedGroupData[groupIds[i]][j].x,
              y: processedGroupData[groupIds[i]][j].y,
              groupId: groupIds[i],
              label: processedGroupData[groupIds[i]][j].label
            });
            barPoints += 1;
          }
        }
      }
    }

    if (barPoints === 0) {
      return;
    }

    // sort by time and by group
    combinedData.sort(function (a, b) {
      if (a.screen_x === b.screen_x) {
        return a.groupId < b.groupId ? -1 : 1;
      } else {
        return a.screen_x - b.screen_x;
      }
    });

    // get intersections
    Bargraph._getDataIntersections(intersections, combinedData);

    // plot barchart
    for (i = 0; i < combinedData.length; i++) {
      group = framework.groups[combinedData[i].groupId];
      var minWidth = group.options.barChart.minWidth != undefined ? group.options.barChart.minWidth : 0.1 * group.options.barChart.width;

      key = combinedData[i].screen_x;
      var heightOffset = 0;
      if (intersections[key] === undefined) {
        if (i + 1 < combinedData.length) {
          coreDistance = Math.abs(combinedData[i + 1].screen_x - key);
        }
        drawData = Bargraph._getSafeDrawData(coreDistance, group, minWidth);
      } else {
        var nextKey = i + (intersections[key].amount - intersections[key].resolved);
        var prevKey = i - (intersections[key].resolved + 1);
        if (nextKey < combinedData.length) {
          coreDistance = Math.abs(combinedData[nextKey].screen_x - key);
        }
        drawData = Bargraph._getSafeDrawData(coreDistance, group, minWidth);
        intersections[key].resolved += 1;

        if (group.options.stack === true && group.options.excludeFromStacking !== true) {
          if (combinedData[i].screen_y < group.zeroPosition) {
            heightOffset = intersections[key].accumulatedNegative;
            intersections[key].accumulatedNegative += group.zeroPosition - combinedData[i].screen_y;
          } else {
            heightOffset = intersections[key].accumulatedPositive;
            intersections[key].accumulatedPositive += group.zeroPosition - combinedData[i].screen_y;
          }
        } else if (group.options.barChart.sideBySide === true) {
          drawData.width = drawData.width / intersections[key].amount;
          drawData.offset += intersections[key].resolved * drawData.width - 0.5 * drawData.width * (intersections[key].amount + 1);
        }
      }
      DOMutil.drawBar(combinedData[i].screen_x + drawData.offset, combinedData[i].screen_y - heightOffset, drawData.width, group.zeroPosition - combinedData[i].screen_y, group.className + ' vis-bar', framework.svgElements, framework.svg, group.style);
      // draw points
      if (group.options.drawPoints.enabled === true) {
        var pointData = {
          screen_x: combinedData[i].screen_x,
          screen_y: combinedData[i].screen_y - heightOffset,
          x: combinedData[i].x,
          y: combinedData[i].y,
          groupId: combinedData[i].groupId,
          label: combinedData[i].label
        };
        Points.draw([pointData], group, framework, drawData.offset);
        //DOMutil.drawPoint(combinedData[i].x + drawData.offset, combinedData[i].y, group, framework.svgElements, framework.svg);
      }
    }
  };

  /**
   * Fill the intersections object with counters of how many datapoints share the same x coordinates
   * @param intersections
   * @param combinedData
   * @private
   */
  Bargraph._getDataIntersections = function (intersections, combinedData) {
    // get intersections
    var coreDistance;
    for (var i = 0; i < combinedData.length; i++) {
      if (i + 1 < combinedData.length) {
        coreDistance = Math.abs(combinedData[i + 1].screen_x - combinedData[i].screen_x);
      }
      if (i > 0) {
        coreDistance = Math.min(coreDistance, Math.abs(combinedData[i - 1].screen_x - combinedData[i].screen_x));
      }
      if (coreDistance === 0) {
        if (intersections[combinedData[i].screen_x] === undefined) {
          intersections[combinedData[i].screen_x] = {
            amount: 0,
            resolved: 0,
            accumulatedPositive: 0,
            accumulatedNegative: 0
          };
        }
        intersections[combinedData[i].screen_x].amount += 1;
      }
    }
  };

  /**
   * Get the width and offset for bargraphs based on the coredistance between datapoints
   *
   * @param coreDistance
   * @param group
   * @param minWidth
   * @returns {{width: Number, offset: Number}}
   * @private
   */
  Bargraph._getSafeDrawData = function (coreDistance, group, minWidth) {
    var width, offset;
    if (coreDistance < group.options.barChart.width && coreDistance > 0) {
      width = coreDistance < minWidth ? minWidth : coreDistance;

      offset = 0; // recalculate offset with the new width;
      if (group.options.barChart.align === 'left') {
        offset -= 0.5 * coreDistance;
      } else if (group.options.barChart.align === 'right') {
        offset += 0.5 * coreDistance;
      }
    } else {
      // default settings
      width = group.options.barChart.width;
      offset = 0;
      if (group.options.barChart.align === 'left') {
        offset -= 0.5 * group.options.barChart.width;
      } else if (group.options.barChart.align === 'right') {
        offset += 0.5 * group.options.barChart.width;
      }
    }

    return { width: width, offset: offset };
  };

  Bargraph.getStackedYRange = function (combinedData, groupRanges, groupIds, groupLabel, orientation) {
    if (combinedData.length > 0) {
      // sort by time and by group
      combinedData.sort(function (a, b) {
        if (a.screen_x === b.screen_x) {
          return a.groupId < b.groupId ? -1 : 1;
        } else {
          return a.screen_x - b.screen_x;
        }
      });
      var intersections = {};

      Bargraph._getDataIntersections(intersections, combinedData);
      groupRanges[groupLabel] = Bargraph._getStackedYRange(intersections, combinedData);
      groupRanges[groupLabel].yAxisOrientation = orientation;
      groupIds.push(groupLabel);
    }
  };

  Bargraph._getStackedYRange = function (intersections, combinedData) {
    var key;
    var yMin = combinedData[0].screen_y;
    var yMax = combinedData[0].screen_y;
    for (var i = 0; i < combinedData.length; i++) {
      key = combinedData[i].screen_x;
      if (intersections[key] === undefined) {
        yMin = yMin > combinedData[i].screen_y ? combinedData[i].screen_y : yMin;
        yMax = yMax < combinedData[i].screen_y ? combinedData[i].screen_y : yMax;
      } else {
        if (combinedData[i].screen_y < 0) {
          intersections[key].accumulatedNegative += combinedData[i].screen_y;
        } else {
          intersections[key].accumulatedPositive += combinedData[i].screen_y;
        }
      }
    }
    for (var xpos in intersections) {
      if (intersections.hasOwnProperty(xpos)) {
        yMin = yMin > intersections[xpos].accumulatedNegative ? intersections[xpos].accumulatedNegative : yMin;
        yMin = yMin > intersections[xpos].accumulatedPositive ? intersections[xpos].accumulatedPositive : yMin;
        yMax = yMax < intersections[xpos].accumulatedNegative ? intersections[xpos].accumulatedNegative : yMax;
        yMax = yMax < intersections[xpos].accumulatedPositive ? intersections[xpos].accumulatedPositive : yMax;
      }
    }

    return { min: yMin, max: yMax };
  };

  module.exports = Bargraph;

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

  var DOMutil = __webpack_require__(8);

  function Points(groupId, options) {}

  /**
   * draw the data points
   *
   * @param {Array} dataset
   * @param {Object} JSONcontainer
   * @param {Object} svg            | SVG DOM element
   * @param {GraphGroup} group
   * @param {Number} [offset]
   */
  Points.draw = function (dataset, group, framework, offset) {
    offset = offset || 0;
    var callback = getCallback(framework, group);

    for (var i = 0; i < dataset.length; i++) {
      if (!callback) {
        // draw the point the simple way.
        DOMutil.drawPoint(dataset[i].screen_x + offset, dataset[i].screen_y, getGroupTemplate(group), framework.svgElements, framework.svg, dataset[i].label);
      } else {
        var callbackResult = callback(dataset[i], group); // result might be true, false or an object
        if (callbackResult === true || (typeof callbackResult === 'undefined' ? 'undefined' : _typeof(callbackResult)) === 'object') {
          DOMutil.drawPoint(dataset[i].screen_x + offset, dataset[i].screen_y, getGroupTemplate(group, callbackResult), framework.svgElements, framework.svg, dataset[i].label);
        }
      }
    }
  };

  Points.drawIcon = function (group, x, y, iconWidth, iconHeight, framework) {
    var fillHeight = iconHeight * 0.5;
    var path, fillPath;

    var outline = DOMutil.getSVGElement("rect", framework.svgElements, framework.svg);
    outline.setAttributeNS(null, "x", x);
    outline.setAttributeNS(null, "y", y - fillHeight);
    outline.setAttributeNS(null, "width", iconWidth);
    outline.setAttributeNS(null, "height", 2 * fillHeight);
    outline.setAttributeNS(null, "class", "vis-outline");

    //Don't call callback on icon
    DOMutil.drawPoint(x + 0.5 * iconWidth, y, getGroupTemplate(group), framework.svgElements, framework.svg);
  };

  function getGroupTemplate(group, callbackResult) {
    callbackResult = typeof callbackResult === 'undefined' ? {} : callbackResult;
    return {
      style: callbackResult.style || group.options.drawPoints.style,
      styles: callbackResult.styles || group.options.drawPoints.styles,
      size: callbackResult.size || group.options.drawPoints.size,
      className: callbackResult.className || group.className
    };
  }

  function getCallback(framework, group) {
    var callback = undefined;
    // check for the graph2d onRender
    if (framework.options && framework.options.drawPoints && framework.options.drawPoints.onRender && typeof framework.options.drawPoints.onRender == 'function') {
      callback = framework.options.drawPoints.onRender;
    }

    // override it with the group onRender if defined
    if (group.group.options && group.group.options.drawPoints && group.group.options.drawPoints.onRender && typeof group.group.options.drawPoints.onRender == 'function') {
      callback = group.group.options.drawPoints.onRender;
    }
    return callback;
  }

  module.exports = Points;

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

  "use strict";

  var DOMutil = __webpack_require__(8);

  function Line(groupId, options) {}

  Line.calcPath = function (dataset, group) {
      if (dataset != null) {
          if (dataset.length > 0) {
              var d = [];

              // construct path from dataset
              if (group.options.interpolation.enabled == true) {
                  d = Line._catmullRom(dataset, group);
              } else {
                  d = Line._linear(dataset);
              }
              return d;
          }
      }
  };

  Line.drawIcon = function (group, x, y, iconWidth, iconHeight, framework) {
      var fillHeight = iconHeight * 0.5;
      var path, fillPath;

      var outline = DOMutil.getSVGElement("rect", framework.svgElements, framework.svg);
      outline.setAttributeNS(null, "x", x);
      outline.setAttributeNS(null, "y", y - fillHeight);
      outline.setAttributeNS(null, "width", iconWidth);
      outline.setAttributeNS(null, "height", 2 * fillHeight);
      outline.setAttributeNS(null, "class", "vis-outline");

      path = DOMutil.getSVGElement("path", framework.svgElements, framework.svg);
      path.setAttributeNS(null, "class", group.className);
      if (group.style !== undefined) {
          path.setAttributeNS(null, "style", group.style);
      }

      path.setAttributeNS(null, "d", "M" + x + "," + y + " L" + (x + iconWidth) + "," + y + "");
      if (group.options.shaded.enabled == true) {
          fillPath = DOMutil.getSVGElement("path", framework.svgElements, framework.svg);
          if (group.options.shaded.orientation == 'top') {
              fillPath.setAttributeNS(null, "d", "M" + x + ", " + (y - fillHeight) + "L" + x + "," + y + " L" + (x + iconWidth) + "," + y + " L" + (x + iconWidth) + "," + (y - fillHeight));
          } else {
              fillPath.setAttributeNS(null, "d", "M" + x + "," + y + " " + "L" + x + "," + (y + fillHeight) + " " + "L" + (x + iconWidth) + "," + (y + fillHeight) + "L" + (x + iconWidth) + "," + y);
          }
          fillPath.setAttributeNS(null, "class", group.className + " vis-icon-fill");
          if (group.options.shaded.style !== undefined && group.options.shaded.style !== "") {
              fillPath.setAttributeNS(null, "style", group.options.shaded.style);
          }
      }

      if (group.options.drawPoints.enabled == true) {
          var groupTemplate = {
              style: group.options.drawPoints.style,
              styles: group.options.drawPoints.styles,
              size: group.options.drawPoints.size,
              className: group.className
          };
          DOMutil.drawPoint(x + 0.5 * iconWidth, y, groupTemplate, framework.svgElements, framework.svg);
      }
  };

  Line.drawShading = function (pathArray, group, subPathArray, framework) {
      // append shading to the path
      if (group.options.shaded.enabled == true) {
          var svgHeight = Number(framework.svg.style.height.replace('px', ''));
          var fillPath = DOMutil.getSVGElement('path', framework.svgElements, framework.svg);
          var type = "L";
          if (group.options.interpolation.enabled == true) {
              type = "C";
          }
          var dFill;
          var zero = 0;
          if (group.options.shaded.orientation == 'top') {
              zero = 0;
          } else if (group.options.shaded.orientation == 'bottom') {
              zero = svgHeight;
          } else {
              zero = Math.min(Math.max(0, group.zeroPosition), svgHeight);
          }
          if (group.options.shaded.orientation == 'group' && subPathArray != null && subPathArray != undefined) {
              dFill = 'M' + pathArray[0][0] + "," + pathArray[0][1] + " " + this.serializePath(pathArray, type, false) + ' L' + subPathArray[subPathArray.length - 1][0] + "," + subPathArray[subPathArray.length - 1][1] + " " + this.serializePath(subPathArray, type, true) + subPathArray[0][0] + "," + subPathArray[0][1] + " Z";
          } else {
              dFill = 'M' + pathArray[0][0] + "," + pathArray[0][1] + " " + this.serializePath(pathArray, type, false) + ' V' + zero + ' H' + pathArray[0][0] + " Z";
          }

          fillPath.setAttributeNS(null, 'class', group.className + ' vis-fill');
          if (group.options.shaded.style !== undefined) {
              fillPath.setAttributeNS(null, 'style', group.options.shaded.style);
          }
          fillPath.setAttributeNS(null, 'd', dFill);
      }
  };

  /**
   * draw a line graph
   *
   * @param dataset
   * @param group
   */
  Line.draw = function (pathArray, group, framework) {
      if (pathArray != null && pathArray != undefined) {
          var path = DOMutil.getSVGElement('path', framework.svgElements, framework.svg);
          path.setAttributeNS(null, "class", group.className);
          if (group.style !== undefined) {
              path.setAttributeNS(null, "style", group.style);
          }

          var type = "L";
          if (group.options.interpolation.enabled == true) {
              type = "C";
          }
          // copy properties to path for drawing.
          path.setAttributeNS(null, 'd', 'M' + pathArray[0][0] + "," + pathArray[0][1] + " " + this.serializePath(pathArray, type, false));
      }
  };

  Line.serializePath = function (pathArray, type, inverse) {
      if (pathArray.length < 2) {
          //Too little data to create a path.
          return "";
      }
      var d = type;
      if (inverse) {
          for (var i = pathArray.length - 2; i > 0; i--) {
              d += pathArray[i][0] + "," + pathArray[i][1] + " ";
          }
      } else {
          for (var i = 1; i < pathArray.length; i++) {
              d += pathArray[i][0] + "," + pathArray[i][1] + " ";
          }
      }
      return d;
  };

  /**
   * This uses an uniform parametrization of the interpolation algorithm:
   * 'On the Parameterization of Catmull-Rom Curves' by Cem Yuksel et al.
   * @param data
   * @returns {string}
   * @private
   */
  Line._catmullRomUniform = function (data) {
      // catmull rom
      var p0, p1, p2, p3, bp1, bp2;
      var d = [];
      d.push([Math.round(data[0].screen_x), Math.round(data[0].screen_y)]);
      var normalization = 1 / 6;
      var length = data.length;
      for (var i = 0; i < length - 1; i++) {

          p0 = i == 0 ? data[0] : data[i - 1];
          p1 = data[i];
          p2 = data[i + 1];
          p3 = i + 2 < length ? data[i + 2] : p2;

          // Catmull-Rom to Cubic Bezier conversion matrix
          //    0       1       0       0
          //  -1/6      1      1/6      0
          //    0      1/6      1     -1/6
          //    0       0       1       0

          //    bp0 = { x: p1.x,                               y: p1.y };
          bp1 = {
              screen_x: (-p0.screen_x + 6 * p1.screen_x + p2.screen_x) * normalization,
              screen_y: (-p0.screen_y + 6 * p1.screen_y + p2.screen_y) * normalization
          };
          bp2 = {
              screen_x: (p1.screen_x + 6 * p2.screen_x - p3.screen_x) * normalization,
              screen_y: (p1.screen_y + 6 * p2.screen_y - p3.screen_y) * normalization
          };
          //    bp0 = { x: p2.x,                               y: p2.y };

          d.push([bp1.screen_x, bp1.screen_y]);
          d.push([bp2.screen_x, bp2.screen_y]);
          d.push([p2.screen_x, p2.screen_y]);
      }

      return d;
  };

  /**
   * This uses either the chordal or centripetal parameterization of the catmull-rom algorithm.
   * By default, the centripetal parameterization is used because this gives the nicest results.
   * These parameterizations are relatively heavy because the distance between 4 points have to be calculated.
   *
   * One optimization can be used to reuse distances since this is a sliding window approach.
   * @param data
   * @param group
   * @returns {string}
   * @private
   */
  Line._catmullRom = function (data, group) {
      var alpha = group.options.interpolation.alpha;
      if (alpha == 0 || alpha === undefined) {
          return this._catmullRomUniform(data);
      } else {
          var p0, p1, p2, p3, bp1, bp2, d1, d2, d3, A, B, N, M;
          var d3powA, d2powA, d3pow2A, d2pow2A, d1pow2A, d1powA;
          var d = [];
          d.push([Math.round(data[0].screen_x), Math.round(data[0].screen_y)]);
          var length = data.length;
          for (var i = 0; i < length - 1; i++) {

              p0 = i == 0 ? data[0] : data[i - 1];
              p1 = data[i];
              p2 = data[i + 1];
              p3 = i + 2 < length ? data[i + 2] : p2;

              d1 = Math.sqrt(Math.pow(p0.screen_x - p1.screen_x, 2) + Math.pow(p0.screen_y - p1.screen_y, 2));
              d2 = Math.sqrt(Math.pow(p1.screen_x - p2.screen_x, 2) + Math.pow(p1.screen_y - p2.screen_y, 2));
              d3 = Math.sqrt(Math.pow(p2.screen_x - p3.screen_x, 2) + Math.pow(p2.screen_y - p3.screen_y, 2));

              // Catmull-Rom to Cubic Bezier conversion matrix

              // A = 2d1^2a + 3d1^a * d2^a + d3^2a
              // B = 2d3^2a + 3d3^a * d2^a + d2^2a

              // [   0             1            0          0          ]
              // [   -d2^2a /N     A/N          d1^2a /N   0          ]
              // [   0             d3^2a /M     B/M        -d2^2a /M  ]
              // [   0             0            1          0          ]

              d3powA = Math.pow(d3, alpha);
              d3pow2A = Math.pow(d3, 2 * alpha);
              d2powA = Math.pow(d2, alpha);
              d2pow2A = Math.pow(d2, 2 * alpha);
              d1powA = Math.pow(d1, alpha);
              d1pow2A = Math.pow(d1, 2 * alpha);

              A = 2 * d1pow2A + 3 * d1powA * d2powA + d2pow2A;
              B = 2 * d3pow2A + 3 * d3powA * d2powA + d2pow2A;
              N = 3 * d1powA * (d1powA + d2powA);
              if (N > 0) {
                  N = 1 / N;
              }
              M = 3 * d3powA * (d3powA + d2powA);
              if (M > 0) {
                  M = 1 / M;
              }

              bp1 = {
                  screen_x: (-d2pow2A * p0.screen_x + A * p1.screen_x + d1pow2A * p2.screen_x) * N,
                  screen_y: (-d2pow2A * p0.screen_y + A * p1.screen_y + d1pow2A * p2.screen_y) * N
              };

              bp2 = {
                  screen_x: (d3pow2A * p1.screen_x + B * p2.screen_x - d2pow2A * p3.screen_x) * M,
                  screen_y: (d3pow2A * p1.screen_y + B * p2.screen_y - d2pow2A * p3.screen_y) * M
              };

              if (bp1.screen_x == 0 && bp1.screen_y == 0) {
                  bp1 = p1;
              }
              if (bp2.screen_x == 0 && bp2.screen_y == 0) {
                  bp2 = p2;
              }
              d.push([bp1.screen_x, bp1.screen_y]);
              d.push([bp2.screen_x, bp2.screen_y]);
              d.push([p2.screen_x, p2.screen_y]);
          }

          return d;
      }
  };

  /**
   * this generates the SVG path for a linear drawing between datapoints.
   * @param data
   * @returns {string}
   * @private
   */
  Line._linear = function (data) {
      // linear
      var d = [];
      for (var i = 0; i < data.length; i++) {
          d.push([data[i].screen_x, data[i].screen_y]);
      }
      return d;
  };

  module.exports = Line;

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var util = __webpack_require__(1);
  var DOMutil = __webpack_require__(8);
  var Component = __webpack_require__(31);

  /**
   * Legend for Graph2d
   */
  function Legend(body, options, side, linegraphOptions) {
    this.body = body;
    this.defaultOptions = {
      enabled: false,
      icons: true,
      iconSize: 20,
      iconSpacing: 6,
      left: {
        visible: true,
        position: 'top-left' // top/bottom - left,center,right
      },
      right: {
        visible: true,
        position: 'top-right' // top/bottom - left,center,right
      }
    };

    this.side = side;
    this.options = util.extend({}, this.defaultOptions);
    this.linegraphOptions = linegraphOptions;

    this.svgElements = {};
    this.dom = {};
    this.groups = {};
    this.amountOfGroups = 0;
    this._create();
    this.framework = { svg: this.svg, svgElements: this.svgElements, options: this.options, groups: this.groups };

    this.setOptions(options);
  }

  Legend.prototype = new Component();

  Legend.prototype.clear = function () {
    this.groups = {};
    this.amountOfGroups = 0;
  };

  Legend.prototype.addGroup = function (label, graphOptions) {

    // Include a group only if the group option 'excludeFromLegend: false' is not set.
    if (graphOptions.options.excludeFromLegend != true) {
      if (!this.groups.hasOwnProperty(label)) {
        this.groups[label] = graphOptions;
      }
      this.amountOfGroups += 1;
    }
  };

  Legend.prototype.updateGroup = function (label, graphOptions) {
    this.groups[label] = graphOptions;
  };

  Legend.prototype.removeGroup = function (label) {
    if (this.groups.hasOwnProperty(label)) {
      delete this.groups[label];
      this.amountOfGroups -= 1;
    }
  };

  Legend.prototype._create = function () {
    this.dom.frame = document.createElement('div');
    this.dom.frame.className = 'vis-legend';
    this.dom.frame.style.position = "absolute";
    this.dom.frame.style.top = "10px";
    this.dom.frame.style.display = "block";

    this.dom.textArea = document.createElement('div');
    this.dom.textArea.className = 'vis-legend-text';
    this.dom.textArea.style.position = "relative";
    this.dom.textArea.style.top = "0px";

    this.svg = document.createElementNS('http://www.w3.org/2000/svg', "svg");
    this.svg.style.position = 'absolute';
    this.svg.style.top = 0 + 'px';
    this.svg.style.width = this.options.iconSize + 5 + 'px';
    this.svg.style.height = '100%';

    this.dom.frame.appendChild(this.svg);
    this.dom.frame.appendChild(this.dom.textArea);
  };

  /**
   * Hide the component from the DOM
   */
  Legend.prototype.hide = function () {
    // remove the frame containing the items
    if (this.dom.frame.parentNode) {
      this.dom.frame.parentNode.removeChild(this.dom.frame);
    }
  };

  /**
   * Show the component in the DOM (when not already visible).
   * @return {Boolean} changed
   */
  Legend.prototype.show = function () {
    // show frame containing the items
    if (!this.dom.frame.parentNode) {
      this.body.dom.center.appendChild(this.dom.frame);
    }
  };

  Legend.prototype.setOptions = function (options) {
    var fields = ['enabled', 'orientation', 'icons', 'left', 'right'];
    util.selectiveDeepExtend(fields, this.options, options);
  };

  Legend.prototype.redraw = function () {
    var activeGroups = 0;
    var groupArray = Object.keys(this.groups);
    groupArray.sort(function (a, b) {
      return a < b ? -1 : 1;
    });

    for (var i = 0; i < groupArray.length; i++) {
      var groupId = groupArray[i];
      if (this.groups[groupId].visible == true && (this.linegraphOptions.visibility[groupId] === undefined || this.linegraphOptions.visibility[groupId] == true)) {
        activeGroups++;
      }
    }

    if (this.options[this.side].visible == false || this.amountOfGroups == 0 || this.options.enabled == false || activeGroups == 0) {
      this.hide();
    } else {
      this.show();
      if (this.options[this.side].position == 'top-left' || this.options[this.side].position == 'bottom-left') {
        this.dom.frame.style.left = '4px';
        this.dom.frame.style.textAlign = "left";
        this.dom.textArea.style.textAlign = "left";
        this.dom.textArea.style.left = this.options.iconSize + 15 + 'px';
        this.dom.textArea.style.right = '';
        this.svg.style.left = 0 + 'px';
        this.svg.style.right = '';
      } else {
        this.dom.frame.style.right = '4px';
        this.dom.frame.style.textAlign = "right";
        this.dom.textArea.style.textAlign = "right";
        this.dom.textArea.style.right = this.options.iconSize + 15 + 'px';
        this.dom.textArea.style.left = '';
        this.svg.style.right = 0 + 'px';
        this.svg.style.left = '';
      }

      if (this.options[this.side].position == 'top-left' || this.options[this.side].position == 'top-right') {
        this.dom.frame.style.top = 4 - Number(this.body.dom.center.style.top.replace("px", "")) + 'px';
        this.dom.frame.style.bottom = '';
      } else {
        var scrollableHeight = this.body.domProps.center.height - this.body.domProps.centerContainer.height;
        this.dom.frame.style.bottom = 4 + scrollableHeight + Number(this.body.dom.center.style.top.replace("px", "")) + 'px';
        this.dom.frame.style.top = '';
      }

      if (this.options.icons == false) {
        this.dom.frame.style.width = this.dom.textArea.offsetWidth + 10 + 'px';
        this.dom.textArea.style.right = '';
        this.dom.textArea.style.left = '';
        this.svg.style.width = '0px';
      } else {
        this.dom.frame.style.width = this.options.iconSize + 15 + this.dom.textArea.offsetWidth + 10 + 'px';
        this.drawLegendIcons();
      }

      var content = '';
      for (var i = 0; i < groupArray.length; i++) {
        var groupId = groupArray[i];
        if (this.groups[groupId].visible == true && (this.linegraphOptions.visibility[groupId] === undefined || this.linegraphOptions.visibility[groupId] == true)) {
          content += this.groups[groupId].content + '<br />';
        }
      }
      this.dom.textArea.innerHTML = content;
      this.dom.textArea.style.lineHeight = 0.75 * this.options.iconSize + this.options.iconSpacing + 'px';
    }
  };

  Legend.prototype.drawLegendIcons = function () {
    if (this.dom.frame.parentNode) {
      var groupArray = Object.keys(this.groups);
      groupArray.sort(function (a, b) {
        return a < b ? -1 : 1;
      });

      // this resets the elements so the order is maintained
      DOMutil.resetElements(this.svgElements);

      var padding = window.getComputedStyle(this.dom.frame).paddingTop;
      var iconOffset = Number(padding.replace('px', ''));
      var x = iconOffset;
      var iconWidth = this.options.iconSize;
      var iconHeight = 0.75 * this.options.iconSize;
      var y = iconOffset + 0.5 * iconHeight + 3;

      this.svg.style.width = iconWidth + 5 + iconOffset + 'px';

      for (var i = 0; i < groupArray.length; i++) {
        var groupId = groupArray[i];
        if (this.groups[groupId].visible == true && (this.linegraphOptions.visibility[groupId] === undefined || this.linegraphOptions.visibility[groupId] == true)) {
          this.groups[groupId].getLegend(iconWidth, iconHeight, this.framework, x, y);
          y += iconHeight + this.options.iconSpacing;
        }
      }
    }
  };

  module.exports = Legend;

/***/ },
/* 59 */
/***/ function(module, exports) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  /**
   * This object contains all possible options. It will check if the types are correct, if required if the option is one
   * of the allowed values.
   *
   * __any__ means that the name of the property does not matter.
   * __type__ is a required field for all objects and contains the allowed types of all objects
   */
  var string = 'string';
  var boolean = 'boolean';
  var number = 'number';
  var array = 'array';
  var date = 'date';
  var object = 'object'; // should only be in a __type__ property
  var dom = 'dom';
  var moment = 'moment';
  var any = 'any';

  var allOptions = {
    configure: {
      enabled: { boolean: boolean },
      filter: { boolean: boolean, 'function': 'function' },
      container: { dom: dom },
      __type__: { object: object, boolean: boolean, 'function': 'function' }
    },

    //globals :
    yAxisOrientation: { string: ['left', 'right'] },
    defaultGroup: { string: string },
    sort: { boolean: boolean },
    sampling: { boolean: boolean },
    stack: { boolean: boolean },
    graphHeight: { string: string, number: number },
    shaded: {
      enabled: { boolean: boolean },
      orientation: { string: ['bottom', 'top', 'zero', 'group'] }, // top, bottom, zero, group
      groupId: { object: object },
      __type__: { boolean: boolean, object: object }
    },
    style: { string: ['line', 'bar', 'points'] }, // line, bar
    barChart: {
      width: { number: number },
      minWidth: { number: number },
      sideBySide: { boolean: boolean },
      align: { string: ['left', 'center', 'right'] },
      __type__: { object: object }
    },
    interpolation: {
      enabled: { boolean: boolean },
      parametrization: { string: ['centripetal', 'chordal', 'uniform'] }, // uniform (alpha = 0.0), chordal (alpha = 1.0), centripetal (alpha = 0.5)
      alpha: { number: number },
      __type__: { object: object, boolean: boolean }
    },
    drawPoints: {
      enabled: { boolean: boolean },
      onRender: { 'function': 'function' },
      size: { number: number },
      style: { string: ['square', 'circle'] }, // square, circle
      __type__: { object: object, boolean: boolean, 'function': 'function' }
    },
    dataAxis: {
      showMinorLabels: { boolean: boolean },
      showMajorLabels: { boolean: boolean },
      icons: { boolean: boolean },
      width: { string: string, number: number },
      visible: { boolean: boolean },
      alignZeros: { boolean: boolean },
      left: {
        range: { min: { number: number }, max: { number: number }, __type__: { object: object } },
        format: { 'function': 'function' },
        title: { text: { string: string, number: number }, style: { string: string }, __type__: { object: object } },
        __type__: { object: object }
      },
      right: {
        range: { min: { number: number }, max: { number: number }, __type__: { object: object } },
        format: { 'function': 'function' },
        title: { text: { string: string, number: number }, style: { string: string }, __type__: { object: object } },
        __type__: { object: object }
      },
      __type__: { object: object }
    },
    legend: {
      enabled: { boolean: boolean },
      icons: { boolean: boolean },
      left: {
        visible: { boolean: boolean },
        position: { string: ['top-right', 'bottom-right', 'top-left', 'bottom-left'] },
        __type__: { object: object }
      },
      right: {
        visible: { boolean: boolean },
        position: { string: ['top-right', 'bottom-right', 'top-left', 'bottom-left'] },
        __type__: { object: object }
      },
      __type__: { object: object, boolean: boolean }
    },
    groups: {
      visibility: { any: any },
      __type__: { object: object }
    },

    autoResize: { boolean: boolean },
    throttleRedraw: { number: number },
    clickToUse: { boolean: boolean },
    end: { number: number, date: date, string: string, moment: moment },
    format: {
      minorLabels: {
        millisecond: { string: string, 'undefined': 'undefined' },
        second: { string: string, 'undefined': 'undefined' },
        minute: { string: string, 'undefined': 'undefined' },
        hour: { string: string, 'undefined': 'undefined' },
        weekday: { string: string, 'undefined': 'undefined' },
        day: { string: string, 'undefined': 'undefined' },
        month: { string: string, 'undefined': 'undefined' },
        year: { string: string, 'undefined': 'undefined' },
        __type__: { object: object }
      },
      majorLabels: {
        millisecond: { string: string, 'undefined': 'undefined' },
        second: { string: string, 'undefined': 'undefined' },
        minute: { string: string, 'undefined': 'undefined' },
        hour: { string: string, 'undefined': 'undefined' },
        weekday: { string: string, 'undefined': 'undefined' },
        day: { string: string, 'undefined': 'undefined' },
        month: { string: string, 'undefined': 'undefined' },
        year: { string: string, 'undefined': 'undefined' },
        __type__: { object: object }
      },
      __type__: { object: object }
    },
    moment: { 'function': 'function' },
    height: { string: string, number: number },
    hiddenDates: {
      start: { date: date, number: number, string: string, moment: moment },
      end: { date: date, number: number, string: string, moment: moment },
      repeat: { string: string },
      __type__: { object: object, array: array }
    },
    locale: { string: string },
    locales: {
      __any__: { any: any },
      __type__: { object: object }
    },
    max: { date: date, number: number, string: string, moment: moment },
    maxHeight: { number: number, string: string },
    maxMinorChars: { number: number },
    min: { date: date, number: number, string: string, moment: moment },
    minHeight: { number: number, string: string },
    moveable: { boolean: boolean },
    multiselect: { boolean: boolean },
    orientation: { string: string },
    showCurrentTime: { boolean: boolean },
    showMajorLabels: { boolean: boolean },
    showMinorLabels: { boolean: boolean },
    start: { date: date, number: number, string: string, moment: moment },
    timeAxis: {
      scale: { string: string, 'undefined': 'undefined' },
      step: { number: number, 'undefined': 'undefined' },
      __type__: { object: object }
    },
    width: { string: string, number: number },
    zoomable: { boolean: boolean },
    zoomKey: { string: ['ctrlKey', 'altKey', 'metaKey', ''] },
    zoomMax: { number: number },
    zoomMin: { number: number },
    zIndex: { number: number },
    __type__: { object: object }
  };

  var configureOptions = {
    global: {
      //yAxisOrientation: ['left','right'], // TDOO: enable as soon as Grahp2d doesn't crash when changing this on the fly
      sort: true,
      sampling: true,
      stack: false,
      shaded: {
        enabled: false,
        orientation: ['zero', 'top', 'bottom', 'group'] // zero, top, bottom
      },
      style: ['line', 'bar', 'points'], // line, bar
      barChart: {
        width: [50, 5, 100, 5],
        minWidth: [50, 5, 100, 5],
        sideBySide: false,
        align: ['left', 'center', 'right'] // left, center, right
      },
      interpolation: {
        enabled: true,
        parametrization: ['centripetal', 'chordal', 'uniform'] // uniform (alpha = 0.0), chordal (alpha = 1.0), centripetal (alpha = 0.5)
      },
      drawPoints: {
        enabled: true,
        size: [6, 2, 30, 1],
        style: ['square', 'circle'] // square, circle
      },
      dataAxis: {
        showMinorLabels: true,
        showMajorLabels: true,
        icons: false,
        width: [40, 0, 200, 1],
        visible: true,
        alignZeros: true,
        left: {
          //range: {min:'undefined': 'undefined'ined,max:'undefined': 'undefined'ined},
          //format: function (value) {return value;},
          title: { text: '', style: '' }
        },
        right: {
          //range: {min:'undefined': 'undefined'ined,max:'undefined': 'undefined'ined},
          //format: function (value) {return value;},
          title: { text: '', style: '' }
        }
      },
      legend: {
        enabled: false,
        icons: true,
        left: {
          visible: true,
          position: ['top-right', 'bottom-right', 'top-left', 'bottom-left'] // top/bottom - left,right
        },
        right: {
          visible: true,
          position: ['top-right', 'bottom-right', 'top-left', 'bottom-left'] // top/bottom - left,right
        }
      },

      autoResize: true,
      throttleRedraw: [10, 0, 1000, 10],
      clickToUse: false,
      end: '',
      format: {
        minorLabels: {
          millisecond: 'SSS',
          second: 's',
          minute: 'HH:mm',
          hour: 'HH:mm',
          weekday: 'ddd D',
          day: 'D',
          month: 'MMM',
          year: 'YYYY'
        },
        majorLabels: {
          millisecond: 'HH:mm:ss',
          second: 'D MMMM HH:mm',
          minute: 'ddd D MMMM',
          hour: 'ddd D MMMM',
          weekday: 'MMMM YYYY',
          day: 'MMMM YYYY',
          month: 'YYYY',
          year: ''
        }
      },

      height: '',
      locale: '',
      max: '',
      maxHeight: '',
      maxMinorChars: [7, 0, 20, 1],
      min: '',
      minHeight: '',
      moveable: true,
      orientation: ['both', 'bottom', 'top'],
      showCurrentTime: false,
      showMajorLabels: true,
      showMinorLabels: true,
      start: '',
      width: '100%',
      zoomable: true,
      zoomKey: ['ctrlKey', 'altKey', 'metaKey', ''],
      zoomMax: [315360000000000, 10, 315360000000000, 1],
      zoomMin: [10, 10, 315360000000000, 1],
      zIndex: 0
    }
  };

  exports.allOptions = allOptions;
  exports.configureOptions = configureOptions;

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  // utils
  exports.util = __webpack_require__(1);
  exports.DOMutil = __webpack_require__(8);

  // data
  exports.DataSet = __webpack_require__(9);
  exports.DataView = __webpack_require__(11);
  exports.Queue = __webpack_require__(10);

  // Network
  exports.Network = __webpack_require__(61);
  exports.network = {
    Images: __webpack_require__(62),
    dotparser: __webpack_require__(118),
    gephiParser: __webpack_require__(119),
    allOptions: __webpack_require__(114)
  };
  exports.network.convertDot = function (input) {
    return exports.network.dotparser.DOTToGraph(input);
  };
  exports.network.convertGephi = function (input, options) {
    return exports.network.gephiParser.parseGephi(input, options);
  };

  // bundled external libraries
  exports.moment = __webpack_require__(2);
  exports.Hammer = __webpack_require__(20);
  exports.keycharm = __webpack_require__(23);

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var _Images = __webpack_require__(62);

  var _Images2 = _interopRequireDefault(_Images);

  var _Groups = __webpack_require__(63);

  var _Groups2 = _interopRequireDefault(_Groups);

  var _NodesHandler = __webpack_require__(64);

  var _NodesHandler2 = _interopRequireDefault(_NodesHandler);

  var _EdgesHandler = __webpack_require__(84);

  var _EdgesHandler2 = _interopRequireDefault(_EdgesHandler);

  var _PhysicsEngine = __webpack_require__(93);

  var _PhysicsEngine2 = _interopRequireDefault(_PhysicsEngine);

  var _Clustering = __webpack_require__(102);

  var _Clustering2 = _interopRequireDefault(_Clustering);

  var _CanvasRenderer = __webpack_require__(105);

  var _CanvasRenderer2 = _interopRequireDefault(_CanvasRenderer);

  var _Canvas = __webpack_require__(106);

  var _Canvas2 = _interopRequireDefault(_Canvas);

  var _View = __webpack_require__(107);

  var _View2 = _interopRequireDefault(_View);

  var _InteractionHandler = __webpack_require__(108);

  var _InteractionHandler2 = _interopRequireDefault(_InteractionHandler);

  var _SelectionHandler = __webpack_require__(111);

  var _SelectionHandler2 = _interopRequireDefault(_SelectionHandler);

  var _LayoutEngine = __webpack_require__(112);

  var _LayoutEngine2 = _interopRequireDefault(_LayoutEngine);

  var _ManipulationSystem = __webpack_require__(113);

  var _ManipulationSystem2 = _interopRequireDefault(_ManipulationSystem);

  var _Configurator = __webpack_require__(26);

  var _Configurator2 = _interopRequireDefault(_Configurator);

  var _Validator = __webpack_require__(29);

  var _Validator2 = _interopRequireDefault(_Validator);

  var _options = __webpack_require__(114);

  var _KamadaKawai = __webpack_require__(115);

  var _KamadaKawai2 = _interopRequireDefault(_KamadaKawai);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  // Load custom shapes into CanvasRenderingContext2D
  __webpack_require__(117);

  var Emitter = __webpack_require__(13);
  var util = __webpack_require__(1);
  var DataSet = __webpack_require__(9);
  var DataView = __webpack_require__(11);
  var dotparser = __webpack_require__(118);
  var gephiParser = __webpack_require__(119);
  var Activator = __webpack_require__(45);
  var locales = __webpack_require__(120);

  /**
   * @constructor Network
   * Create a network visualization, displaying nodes and edges.
   *
   * @param {Element} container   The DOM element in which the Network will
   *                                  be created. Normally a div element.
   * @param {Object} data         An object containing parameters
   *                              {Array} nodes
   *                              {Array} edges
   * @param {Object} options      Options
   */
  function Network(container, data, options) {
    var _this = this;

    if (!(this instanceof Network)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    // set constant values
    this.options = {};
    this.defaultOptions = {
      locale: 'en',
      locales: locales,
      clickToUse: false
    };
    util.extend(this.options, this.defaultOptions);

    // containers for nodes and edges
    this.body = {
      container: container,
      nodes: {},
      nodeIndices: [],
      edges: {},
      edgeIndices: [],
      emitter: {
        on: this.on.bind(this),
        off: this.off.bind(this),
        emit: this.emit.bind(this),
        once: this.once.bind(this)
      },
      eventListeners: {
        onTap: function onTap() {},
        onTouch: function onTouch() {},
        onDoubleTap: function onDoubleTap() {},
        onHold: function onHold() {},
        onDragStart: function onDragStart() {},
        onDrag: function onDrag() {},
        onDragEnd: function onDragEnd() {},
        onMouseWheel: function onMouseWheel() {},
        onPinch: function onPinch() {},
        onMouseMove: function onMouseMove() {},
        onRelease: function onRelease() {},
        onContext: function onContext() {}
      },
      data: {
        nodes: null, // A DataSet or DataView
        edges: null // A DataSet or DataView
      },
      functions: {
        createNode: function createNode() {},
        createEdge: function createEdge() {},
        getPointer: function getPointer() {}
      },
      modules: {},
      view: {
        scale: 1,
        translation: { x: 0, y: 0 }
      }
    };

    // bind the event listeners
    this.bindEventListeners();

    // setting up all modules
    this.images = new _Images2.default(function () {
      return _this.body.emitter.emit("_requestRedraw");
    }); // object with images
    this.groups = new _Groups2.default(); // object with groups
    this.canvas = new _Canvas2.default(this.body); // DOM handler
    this.selectionHandler = new _SelectionHandler2.default(this.body, this.canvas); // Selection handler
    this.interactionHandler = new _InteractionHandler2.default(this.body, this.canvas, this.selectionHandler); // Interaction handler handles all the hammer bindings (that are bound by canvas), key
    this.view = new _View2.default(this.body, this.canvas); // camera handler, does animations and zooms
    this.renderer = new _CanvasRenderer2.default(this.body, this.canvas); // renderer, starts renderloop, has events that modules can hook into
    this.physics = new _PhysicsEngine2.default(this.body); // physics engine, does all the simulations
    this.layoutEngine = new _LayoutEngine2.default(this.body); // layout engine for inital layout and hierarchical layout
    this.clustering = new _Clustering2.default(this.body); // clustering api
    this.manipulation = new _ManipulationSystem2.default(this.body, this.canvas, this.selectionHandler); // data manipulation system

    this.nodesHandler = new _NodesHandler2.default(this.body, this.images, this.groups, this.layoutEngine); // Handle adding, deleting and updating of nodes as well as global options
    this.edgesHandler = new _EdgesHandler2.default(this.body, this.images, this.groups); // Handle adding, deleting and updating of edges as well as global options

    this.body.modules["kamadaKawai"] = new _KamadaKawai2.default(this.body, 150, 0.05); // Layouting algorithm.
    this.body.modules["clustering"] = this.clustering;

    // create the DOM elements
    this.canvas._create();

    // apply options
    this.setOptions(options);

    // load data (the disable start variable will be the same as the enabled clustering)
    this.setData(data);
  }

  // Extend Network with an Emitter mixin
  Emitter(Network.prototype);

  /**
   * Set options
   * @param {Object} options
   */
  Network.prototype.setOptions = function (options) {
    var _this2 = this;

    if (options !== undefined) {
      var errorFound = _Validator2.default.validate(options, _options.allOptions);
      if (errorFound === true) {
        console.log('%cErrors have been found in the supplied options object.', _Validator.printStyle);
      }

      // copy the global fields over
      var fields = ['locale', 'locales', 'clickToUse'];
      util.selectiveDeepExtend(fields, this.options, options);

      // the hierarchical system can adapt the edges and the physics to it's own options because not all combinations work with the hierarichical system.
      options = this.layoutEngine.setOptions(options.layout, options);

      this.canvas.setOptions(options); // options for canvas are in globals

      // pass the options to the modules
      this.groups.setOptions(options.groups);
      this.nodesHandler.setOptions(options.nodes);
      this.edgesHandler.setOptions(options.edges);
      this.physics.setOptions(options.physics);
      this.manipulation.setOptions(options.manipulation, options, this.options); // manipulation uses the locales in the globals

      this.interactionHandler.setOptions(options.interaction);
      this.renderer.setOptions(options.interaction); // options for rendering are in interaction
      this.selectionHandler.setOptions(options.interaction); // options for selection are in interaction

      // reload the settings of the nodes to apply changes in groups that are not referenced by pointer.
      if (options.groups !== undefined) {
        this.body.emitter.emit("refreshNodes");
      }
      // these two do not have options at the moment, here for completeness
      //this.view.setOptions(options.view);
      //this.clustering.setOptions(options.clustering);

      if ('configure' in options) {
        if (!this.configurator) {
          this.configurator = new _Configurator2.default(this, this.body.container, _options.configureOptions, this.canvas.pixelRatio);
        }

        this.configurator.setOptions(options.configure);
      }

      // if the configuration system is enabled, copy all options and put them into the config system
      if (this.configurator && this.configurator.options.enabled === true) {
        var networkOptions = { nodes: {}, edges: {}, layout: {}, interaction: {}, manipulation: {}, physics: {}, global: {} };
        util.deepExtend(networkOptions.nodes, this.nodesHandler.options);
        util.deepExtend(networkOptions.edges, this.edgesHandler.options);
        util.deepExtend(networkOptions.layout, this.layoutEngine.options);
        // load the selectionHandler and render default options in to the interaction group
        util.deepExtend(networkOptions.interaction, this.selectionHandler.options);
        util.deepExtend(networkOptions.interaction, this.renderer.options);

        util.deepExtend(networkOptions.interaction, this.interactionHandler.options);
        util.deepExtend(networkOptions.manipulation, this.manipulation.options);
        util.deepExtend(networkOptions.physics, this.physics.options);

        // load globals into the global object
        util.deepExtend(networkOptions.global, this.canvas.options);
        util.deepExtend(networkOptions.global, this.options);

        this.configurator.setModuleOptions(networkOptions);
      }

      // handle network global options
      if (options.clickToUse !== undefined) {
        if (options.clickToUse === true) {
          if (this.activator === undefined) {
            this.activator = new Activator(this.canvas.frame);
            this.activator.on('change', function () {
              _this2.body.emitter.emit("activate");
            });
          }
        } else {
          if (this.activator !== undefined) {
            this.activator.destroy();
            delete this.activator;
          }
          this.body.emitter.emit("activate");
        }
      } else {
        this.body.emitter.emit("activate");
      }

      this.canvas.setSize();
      // start the physics simulation. Can be safely called multiple times.
      this.body.emitter.emit("startSimulation");
    }
  };

  /**
   * Update the this.body.nodeIndices with the most recent node index list
   * @private
   */
  Network.prototype._updateVisibleIndices = function () {
    var nodes = this.body.nodes;
    var edges = this.body.edges;
    this.body.nodeIndices = [];
    this.body.edgeIndices = [];

    for (var nodeId in nodes) {
      if (nodes.hasOwnProperty(nodeId)) {
        if (nodes[nodeId].options.hidden === false) {
          this.body.nodeIndices.push(nodes[nodeId].id);
        }
      }
    }

    for (var edgeId in edges) {
      if (edges.hasOwnProperty(edgeId)) {
        if (edges[edgeId].options.hidden === false) {
          this.body.edgeIndices.push(edges[edgeId].id);
        }
      }
    }
  };

  /**
   * Bind all events
   */
  Network.prototype.bindEventListeners = function () {
    var _this3 = this;

    // this event will trigger a rebuilding of the cache everything. Used when nodes or edges have been added or removed.
    this.body.emitter.on("_dataChanged", function () {
      // update shortcut lists
      _this3._updateVisibleIndices();
      _this3.body.emitter.emit("_requestRedraw");
      // call the dataUpdated event because the only difference between the two is the updating of the indices
      _this3.body.emitter.emit("_dataUpdated");
    });

    // this is called when options of EXISTING nodes or edges have changed.
    this.body.emitter.on("_dataUpdated", function () {
      // update values
      _this3._updateValueRange(_this3.body.nodes);
      _this3._updateValueRange(_this3.body.edges);
      // start simulation (can be called safely, even if already running)
      _this3.body.emitter.emit("startSimulation");
      _this3.body.emitter.emit("_requestRedraw");
    });
  };

  /**
   * Set nodes and edges, and optionally options as well.
   *
   * @param {Object} data              Object containing parameters:
   *                                   {Array | DataSet | DataView} [nodes] Array with nodes
   *                                   {Array | DataSet | DataView} [edges] Array with edges
   *                                   {String} [dot] String containing data in DOT format
   *                                   {String} [gephi] String containing data in gephi JSON format
   *                                   {Options} [options] Object with options
   */
  Network.prototype.setData = function (data) {
    // reset the physics engine.
    this.body.emitter.emit("resetPhysics");
    this.body.emitter.emit("_resetData");

    // unselect all to ensure no selections from old data are carried over.
    this.selectionHandler.unselectAll();

    if (data && data.dot && (data.nodes || data.edges)) {
      throw new SyntaxError('Data must contain either parameter "dot" or ' + ' parameter pair "nodes" and "edges", but not both.');
    }

    // set options
    this.setOptions(data && data.options);
    // set all data
    if (data && data.dot) {
      console.log('The dot property has been depricated. Please use the static convertDot method to convert DOT into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertDot(dotString);');
      // parse DOT file
      var dotData = dotparser.DOTToGraph(data.dot);
      this.setData(dotData);
      return;
    } else if (data && data.gephi) {
      // parse DOT file
      console.log('The gephi property has been depricated. Please use the static convertGephi method to convert gephi into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertGephi(gephiJson);');
      var gephiData = gephiParser.parseGephi(data.gephi);
      this.setData(gephiData);
      return;
    } else {
      this.nodesHandler.setData(data && data.nodes, true);
      this.edgesHandler.setData(data && data.edges, true);
    }

    // emit change in data
    this.body.emitter.emit("_dataChanged");

    // emit data loaded
    this.body.emitter.emit("_dataLoaded");

    // find a stable position or start animating to a stable position
    this.body.emitter.emit("initPhysics");
  };

  /**
   * Cleans up all bindings of the network, removing it fully from the memory IF the variable is set to null after calling this function.
   * var network = new vis.Network(..);
   * network.destroy();
   * network = null;
   */
  Network.prototype.destroy = function () {
    this.body.emitter.emit("destroy");
    // clear events
    this.body.emitter.off();
    this.off();

    // delete modules
    delete this.groups;
    delete this.canvas;
    delete this.selectionHandler;
    delete this.interactionHandler;
    delete this.view;
    delete this.renderer;
    delete this.physics;
    delete this.layoutEngine;
    delete this.clustering;
    delete this.manipulation;
    delete this.nodesHandler;
    delete this.edgesHandler;
    delete this.configurator;
    delete this.images;

    for (var nodeId in this.body.nodes) {
      delete this.body.nodes[nodeId];
    }
    for (var edgeId in this.body.edges) {
      delete this.body.edges[edgeId];
    }

    // remove the container and everything inside it recursively
    util.recursiveDOMDelete(this.body.container);
  };

  /**
   * Update the values of all object in the given array according to the current
   * value range of the objects in the array.
   * @param {Object} obj    An object containing a set of Edges or Nodes
   *                        The objects must have a method getValue() and
   *                        setValueRange(min, max).
   * @private
   */
  Network.prototype._updateValueRange = function (obj) {
    var id;

    // determine the range of the objects
    var valueMin = undefined;
    var valueMax = undefined;
    var valueTotal = 0;
    for (id in obj) {
      if (obj.hasOwnProperty(id)) {
        var value = obj[id].getValue();
        if (value !== undefined) {
          valueMin = valueMin === undefined ? value : Math.min(value, valueMin);
          valueMax = valueMax === undefined ? value : Math.max(value, valueMax);
          valueTotal += value;
        }
      }
    }

    // adjust the range of all objects
    if (valueMin !== undefined && valueMax !== undefined) {
      for (id in obj) {
        if (obj.hasOwnProperty(id)) {
          obj[id].setValueRange(valueMin, valueMax, valueTotal);
        }
      }
    }
  };

  /**
   * Returns true when the Network is active.
   * @returns {boolean}
   */
  Network.prototype.isActive = function () {
    return !this.activator || this.activator.active;
  };

  Network.prototype.setSize = function () {
    return this.canvas.setSize.apply(this.canvas, arguments);
  };
  Network.prototype.canvasToDOM = function () {
    return this.canvas.canvasToDOM.apply(this.canvas, arguments);
  };
  Network.prototype.DOMtoCanvas = function () {
    return this.canvas.DOMtoCanvas.apply(this.canvas, arguments);
  };
  Network.prototype.findNode = function () {
    return this.clustering.findNode.apply(this.clustering, arguments);
  };
  Network.prototype.isCluster = function () {
    return this.clustering.isCluster.apply(this.clustering, arguments);
  };
  Network.prototype.openCluster = function () {
    return this.clustering.openCluster.apply(this.clustering, arguments);
  };
  Network.prototype.cluster = function () {
    return this.clustering.cluster.apply(this.clustering, arguments);
  };
  Network.prototype.getNodesInCluster = function () {
    return this.clustering.getNodesInCluster.apply(this.clustering, arguments);
  };
  Network.prototype.clusterByConnection = function () {
    return this.clustering.clusterByConnection.apply(this.clustering, arguments);
  };
  Network.prototype.clusterByHubsize = function () {
    return this.clustering.clusterByHubsize.apply(this.clustering, arguments);
  };
  Network.prototype.clusterOutliers = function () {
    return this.clustering.clusterOutliers.apply(this.clustering, arguments);
  };
  Network.prototype.getSeed = function () {
    return this.layoutEngine.getSeed.apply(this.layoutEngine, arguments);
  };
  Network.prototype.enableEditMode = function () {
    return this.manipulation.enableEditMode.apply(this.manipulation, arguments);
  };
  Network.prototype.disableEditMode = function () {
    return this.manipulation.disableEditMode.apply(this.manipulation, arguments);
  };
  Network.prototype.addNodeMode = function () {
    return this.manipulation.addNodeMode.apply(this.manipulation, arguments);
  };
  Network.prototype.editNode = function () {
    return this.manipulation.editNode.apply(this.manipulation, arguments);
  };
  Network.prototype.editNodeMode = function () {
    console.log("Deprecated: Please use editNode instead of editNodeMode.");return this.manipulation.editNode.apply(this.manipulation, arguments);
  };
  Network.prototype.addEdgeMode = function () {
    return this.manipulation.addEdgeMode.apply(this.manipulation, arguments);
  };
  Network.prototype.editEdgeMode = function () {
    return this.manipulation.editEdgeMode.apply(this.manipulation, arguments);
  };
  Network.prototype.deleteSelected = function () {
    return this.manipulation.deleteSelected.apply(this.manipulation, arguments);
  };
  Network.prototype.getPositions = function () {
    return this.nodesHandler.getPositions.apply(this.nodesHandler, arguments);
  };
  Network.prototype.storePositions = function () {
    return this.nodesHandler.storePositions.apply(this.nodesHandler, arguments);
  };
  Network.prototype.moveNode = function () {
    return this.nodesHandler.moveNode.apply(this.nodesHandler, arguments);
  };
  Network.prototype.getBoundingBox = function () {
    return this.nodesHandler.getBoundingBox.apply(this.nodesHandler, arguments);
  };
  Network.prototype.getConnectedNodes = function (objectId) {
    if (this.body.nodes[objectId] !== undefined) {
      return this.nodesHandler.getConnectedNodes.apply(this.nodesHandler, arguments);
    } else {
      return this.edgesHandler.getConnectedNodes.apply(this.edgesHandler, arguments);
    }
  };
  Network.prototype.getConnectedEdges = function () {
    return this.nodesHandler.getConnectedEdges.apply(this.nodesHandler, arguments);
  };
  Network.prototype.startSimulation = function () {
    return this.physics.startSimulation.apply(this.physics, arguments);
  };
  Network.prototype.stopSimulation = function () {
    return this.physics.stopSimulation.apply(this.physics, arguments);
  };
  Network.prototype.stabilize = function () {
    return this.physics.stabilize.apply(this.physics, arguments);
  };
  Network.prototype.getSelection = function () {
    return this.selectionHandler.getSelection.apply(this.selectionHandler, arguments);
  };
  Network.prototype.setSelection = function () {
    return this.selectionHandler.setSelection.apply(this.selectionHandler, arguments);
  };
  Network.prototype.getSelectedNodes = function () {
    return this.selectionHandler.getSelectedNodes.apply(this.selectionHandler, arguments);
  };
  Network.prototype.getSelectedEdges = function () {
    return this.selectionHandler.getSelectedEdges.apply(this.selectionHandler, arguments);
  };
  Network.prototype.getNodeAt = function () {
    var node = this.selectionHandler.getNodeAt.apply(this.selectionHandler, arguments);
    if (node !== undefined && node.id !== undefined) {
      return node.id;
    }
    return node;
  };
  Network.prototype.getEdgeAt = function () {
    var edge = this.selectionHandler.getEdgeAt.apply(this.selectionHandler, arguments);
    if (edge !== undefined && edge.id !== undefined) {
      return edge.id;
    }
    return edge;
  };
  Network.prototype.selectNodes = function () {
    return this.selectionHandler.selectNodes.apply(this.selectionHandler, arguments);
  };
  Network.prototype.selectEdges = function () {
    return this.selectionHandler.selectEdges.apply(this.selectionHandler, arguments);
  };
  Network.prototype.unselectAll = function () {
    this.selectionHandler.unselectAll.apply(this.selectionHandler, arguments);
    this.redraw();
  };
  Network.prototype.redraw = function () {
    return this.renderer.redraw.apply(this.renderer, arguments);
  };
  Network.prototype.getScale = function () {
    return this.view.getScale.apply(this.view, arguments);
  };
  Network.prototype.getViewPosition = function () {
    return this.view.getViewPosition.apply(this.view, arguments);
  };
  Network.prototype.fit = function () {
    return this.view.fit.apply(this.view, arguments);
  };
  Network.prototype.moveTo = function () {
    return this.view.moveTo.apply(this.view, arguments);
  };
  Network.prototype.focus = function () {
    return this.view.focus.apply(this.view, arguments);
  };
  Network.prototype.releaseNode = function () {
    return this.view.releaseNode.apply(this.view, arguments);
  };
  Network.prototype.getOptionsFromConfigurator = function () {
    var options = {};
    if (this.configurator) {
      options = this.configurator.getOptions.apply(this.configurator);
    }
    return options;
  };

  module.exports = Network;

/***/ },
/* 62 */
/***/ function(module, exports) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
      value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  /**
   * @class Images
   * This class loads images and keeps them stored.
   */

  var Images = function () {
      function Images(callback) {
          _classCallCheck(this, Images);

          this.images = {};
          this.imageBroken = {};
          this.callback = callback;
      }

      /**
       * @param {string} url                      The Url to cache the image as 
        * @return {Image} imageToLoadBrokenUrlOn  The image object
       */


      _createClass(Images, [{
          key: "_addImageToCache",
          value: function _addImageToCache(url, imageToCache) {
              // IE11 fix -- thanks dponch!
              if (imageToCache.width === 0) {
                  document.body.appendChild(imageToCache);
                  imageToCache.width = imageToCache.offsetWidth;
                  imageToCache.height = imageToCache.offsetHeight;
                  document.body.removeChild(imageToCache);
              }

              this.images[url] = imageToCache;
          }

          /**
           * @param {string} url                      The original Url that failed to load, if the broken image is successfully loaded it will be added to the cache using this Url as the key so that subsequent requests for this Url will return the broken image
           * @param {string} brokenUrl                Url the broken image to try and load
           * @return {Image} imageToLoadBrokenUrlOn   The image object
           */

      }, {
          key: "_tryloadBrokenUrl",
          value: function _tryloadBrokenUrl(url, brokenUrl, imageToLoadBrokenUrlOn) {
              var _this = this;

              //If any of the parameters aren't specified then exit the function because nothing constructive can be done
              if (url === undefined || brokenUrl === undefined || imageToLoadBrokenUrlOn === undefined) return;

              //Clear the old subscription to the error event and put a new in place that only handle errors in loading the brokenImageUrl
              imageToLoadBrokenUrlOn.onerror = function () {
                  console.error("Could not load brokenImage:", brokenUrl);
                  //Add an empty image to the cache so that when subsequent load calls are made for the url we don't try load the image and broken image again
                  _this._addImageToCache(url, new Image());
              };

              //Set the source of the image to the brokenUrl, this is actually what kicks off the loading of the broken image
              imageToLoadBrokenUrlOn.src = brokenUrl;
          }

          /**
           * @return {Image} imageToRedrawWith The images that will be passed to the callback when it is invoked
           */

      }, {
          key: "_redrawWithImage",
          value: function _redrawWithImage(imageToRedrawWith) {
              if (this.callback) {
                  this.callback(imageToRedrawWith);
              }
          }

          /**
           * @param {string} url          Url of the image
           * @param {string} brokenUrl    Url of an image to use if the url image is not found
           * @return {Image} img          The image object
           */

      }, {
          key: "load",
          value: function load(url, brokenUrl, id) {
              var _this2 = this;

              //Try and get the image from the cache, if successful then return the cached image  
              var cachedImage = this.images[url];
              if (cachedImage) return cachedImage;

              //Create a new image
              var img = new Image();

              //Subscribe to the event that is raised if the image loads successfully
              img.onload = function () {
                  //Add the image to the cache and then request a redraw
                  _this2._addImageToCache(url, img);
                  _this2._redrawWithImage(img);
              };

              //Subscribe to the event that is raised if the image fails to load
              img.onerror = function () {
                  console.error("Could not load image:", url);
                  //Try and load the image specified by the brokenUrl using
                  _this2._tryloadBrokenUrl(url, brokenUrl, img);
              };

              //Set the source of the image to the url, this is actuall what kicks off the loading of the image
              img.src = url;

              //Return the new image
              return img;
          }
      }]);

      return Images;
  }();

  exports.default = Images;

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);

  /**
   * @class Groups
   * This class can store groups and options specific for groups.
   */

  var Groups = function () {
    function Groups() {
      _classCallCheck(this, Groups);

      this.clear();
      this.defaultIndex = 0;
      this.groupsArray = [];
      this.groupIndex = 0;

      this.defaultGroups = [{ border: "#2B7CE9", background: "#97C2FC", highlight: { border: "#2B7CE9", background: "#D2E5FF" }, hover: { border: "#2B7CE9", background: "#D2E5FF" } }, // 0: blue
      { border: "#FFA500", background: "#FFFF00", highlight: { border: "#FFA500", background: "#FFFFA3" }, hover: { border: "#FFA500", background: "#FFFFA3" } }, // 1: yellow
      { border: "#FA0A10", background: "#FB7E81", highlight: { border: "#FA0A10", background: "#FFAFB1" }, hover: { border: "#FA0A10", background: "#FFAFB1" } }, // 2: red
      { border: "#41A906", background: "#7BE141", highlight: { border: "#41A906", background: "#A1EC76" }, hover: { border: "#41A906", background: "#A1EC76" } }, // 3: green
      { border: "#E129F0", background: "#EB7DF4", highlight: { border: "#E129F0", background: "#F0B3F5" }, hover: { border: "#E129F0", background: "#F0B3F5" } }, // 4: magenta
      { border: "#7C29F0", background: "#AD85E4", highlight: { border: "#7C29F0", background: "#D3BDF0" }, hover: { border: "#7C29F0", background: "#D3BDF0" } }, // 5: purple
      { border: "#C37F00", background: "#FFA807", highlight: { border: "#C37F00", background: "#FFCA66" }, hover: { border: "#C37F00", background: "#FFCA66" } }, // 6: orange
      { border: "#4220FB", background: "#6E6EFD", highlight: { border: "#4220FB", background: "#9B9BFD" }, hover: { border: "#4220FB", background: "#9B9BFD" } }, // 7: darkblue
      { border: "#FD5A77", background: "#FFC0CB", highlight: { border: "#FD5A77", background: "#FFD1D9" }, hover: { border: "#FD5A77", background: "#FFD1D9" } }, // 8: pink
      { border: "#4AD63A", background: "#C2FABC", highlight: { border: "#4AD63A", background: "#E6FFE3" }, hover: { border: "#4AD63A", background: "#E6FFE3" } }, // 9: mint

      { border: "#990000", background: "#EE0000", highlight: { border: "#BB0000", background: "#FF3333" }, hover: { border: "#BB0000", background: "#FF3333" } }, // 10:bright red

      { border: "#FF6000", background: "#FF6000", highlight: { border: "#FF6000", background: "#FF6000" }, hover: { border: "#FF6000", background: "#FF6000" } }, // 12: real orange
      { border: "#97C2FC", background: "#2B7CE9", highlight: { border: "#D2E5FF", background: "#2B7CE9" }, hover: { border: "#D2E5FF", background: "#2B7CE9" } }, // 13: blue
      { border: "#399605", background: "#255C03", highlight: { border: "#399605", background: "#255C03" }, hover: { border: "#399605", background: "#255C03" } }, // 14: green
      { border: "#B70054", background: "#FF007E", highlight: { border: "#B70054", background: "#FF007E" }, hover: { border: "#B70054", background: "#FF007E" } }, // 15: magenta
      { border: "#AD85E4", background: "#7C29F0", highlight: { border: "#D3BDF0", background: "#7C29F0" }, hover: { border: "#D3BDF0", background: "#7C29F0" } }, // 16: purple
      { border: "#4557FA", background: "#000EA1", highlight: { border: "#6E6EFD", background: "#000EA1" }, hover: { border: "#6E6EFD", background: "#000EA1" } }, // 17: darkblue
      { border: "#FFC0CB", background: "#FD5A77", highlight: { border: "#FFD1D9", background: "#FD5A77" }, hover: { border: "#FFD1D9", background: "#FD5A77" } }, // 18: pink
      { border: "#C2FABC", background: "#74D66A", highlight: { border: "#E6FFE3", background: "#74D66A" }, hover: { border: "#E6FFE3", background: "#74D66A" } }, // 19: mint

      { border: "#EE0000", background: "#990000", highlight: { border: "#FF3333", background: "#BB0000" }, hover: { border: "#FF3333", background: "#BB0000" } } // 20:bright red
      ];

      this.options = {};
      this.defaultOptions = {
        useDefaultGroups: true
      };
      util.extend(this.options, this.defaultOptions);
    }

    _createClass(Groups, [{
      key: "setOptions",
      value: function setOptions(options) {
        var optionFields = ['useDefaultGroups'];

        if (options !== undefined) {
          for (var groupName in options) {
            if (options.hasOwnProperty(groupName)) {
              if (optionFields.indexOf(groupName) === -1) {
                var group = options[groupName];
                this.add(groupName, group);
              }
            }
          }
        }
      }

      /**
       * Clear all groups
       */

    }, {
      key: "clear",
      value: function clear() {
        this.groups = {};
        this.groupsArray = [];
      }

      /**
       * get group options of a groupname. If groupname is not found, a new group
       * is added.
       * @param {*} groupname        Can be a number, string, Date, etc.
       * @return {Object} group      The created group, containing all group options
       */

    }, {
      key: "get",
      value: function get(groupname) {
        var group = this.groups[groupname];
        if (group === undefined) {
          if (this.options.useDefaultGroups === false && this.groupsArray.length > 0) {
            // create new group
            var index = this.groupIndex % this.groupsArray.length;
            this.groupIndex++;
            group = {};
            group.color = this.groups[this.groupsArray[index]];
            this.groups[groupname] = group;
          } else {
            // create new group
            var _index = this.defaultIndex % this.defaultGroups.length;
            this.defaultIndex++;
            group = {};
            group.color = this.defaultGroups[_index];
            this.groups[groupname] = group;
          }
        }

        return group;
      }

      /**
       * Add a custom group style
       * @param {String} groupName
       * @param {Object} style       An object containing borderColor,
       *                             backgroundColor, etc.
       * @return {Object} group      The created group object
       */

    }, {
      key: "add",
      value: function add(groupName, style) {
        this.groups[groupName] = style;
        this.groupsArray.push(groupName);
        return style;
      }
    }]);

    return Groups;
  }();

  exports.default = Groups;

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _Node = __webpack_require__(65);

  var _Node2 = _interopRequireDefault(_Node);

  var _Label = __webpack_require__(66);

  var _Label2 = _interopRequireDefault(_Label);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);
  var DataSet = __webpack_require__(9);
  var DataView = __webpack_require__(11);

  var NodesHandler = function () {
    function NodesHandler(body, images, groups, layoutEngine) {
      var _this = this;

      _classCallCheck(this, NodesHandler);

      this.body = body;
      this.images = images;
      this.groups = groups;
      this.layoutEngine = layoutEngine;

      // create the node API in the body container
      this.body.functions.createNode = this.create.bind(this);

      this.nodesListeners = {
        add: function add(event, params) {
          _this.add(params.items);
        },
        update: function update(event, params) {
          _this.update(params.items, params.data);
        },
        remove: function remove(event, params) {
          _this.remove(params.items);
        }
      };

      this.options = {};
      this.defaultOptions = {
        borderWidth: 1,
        borderWidthSelected: 2,
        brokenImage: undefined,
        color: {
          border: '#2B7CE9',
          background: '#97C2FC',
          highlight: {
            border: '#2B7CE9',
            background: '#D2E5FF'
          },
          hover: {
            border: '#2B7CE9',
            background: '#D2E5FF'
          }
        },
        fixed: {
          x: false,
          y: false
        },
        font: {
          color: '#343434',
          size: 14, // px
          face: 'arial',
          background: 'none',
          strokeWidth: 0, // px
          strokeColor: '#ffffff',
          align: 'center'
        },
        group: undefined,
        hidden: false,
        icon: {
          face: 'FontAwesome', //'FontAwesome',
          code: undefined, //'\uf007',
          size: 50, //50,
          color: '#2B7CE9' //'#aa00ff'
        },
        image: undefined, // --> URL
        label: undefined,
        labelHighlightBold: true,
        level: undefined,
        mass: 1,
        physics: true,
        scaling: {
          min: 10,
          max: 30,
          label: {
            enabled: false,
            min: 14,
            max: 30,
            maxVisible: 30,
            drawThreshold: 5
          },
          customScalingFunction: function customScalingFunction(min, max, total, value) {
            if (max === min) {
              return 0.5;
            } else {
              var scale = 1 / (max - min);
              return Math.max(0, (value - min) * scale);
            }
          }
        },
        shadow: {
          enabled: false,
          color: 'rgba(0,0,0,0.5)',
          size: 10,
          x: 5,
          y: 5
        },
        shape: 'ellipse',
        shapeProperties: {
          borderDashes: false, // only for borders
          borderRadius: 6, // only for box shape
          interpolation: true, // only for image and circularImage shapes
          useImageSize: false, // only for image and circularImage shapes
          useBorderWithImage: false // only for image shape
        },
        size: 25,
        title: undefined,
        value: undefined,
        x: undefined,
        y: undefined
      };
      util.extend(this.options, this.defaultOptions);

      this.bindEventListeners();
    }

    _createClass(NodesHandler, [{
      key: 'bindEventListeners',
      value: function bindEventListeners() {
        var _this2 = this;

        // refresh the nodes. Used when reverting from hierarchical layout
        this.body.emitter.on('refreshNodes', this.refresh.bind(this));
        this.body.emitter.on('refresh', this.refresh.bind(this));
        this.body.emitter.on('destroy', function () {
          util.forEach(_this2.nodesListeners, function (callback, event) {
            if (_this2.body.data.nodes) _this2.body.data.nodes.off(event, callback);
          });
          delete _this2.body.functions.createNode;
          delete _this2.nodesListeners.add;
          delete _this2.nodesListeners.update;
          delete _this2.nodesListeners.remove;
          delete _this2.nodesListeners;
        });
      }
    }, {
      key: 'setOptions',
      value: function setOptions(options) {
        if (options !== undefined) {
          _Node2.default.parseOptions(this.options, options);

          // update the shape in all nodes
          if (options.shape !== undefined) {
            for (var nodeId in this.body.nodes) {
              if (this.body.nodes.hasOwnProperty(nodeId)) {
                this.body.nodes[nodeId].updateShape();
              }
            }
          }

          // update the font in all nodes
          if (options.font !== undefined) {
            _Label2.default.parseOptions(this.options.font, options);
            for (var _nodeId in this.body.nodes) {
              if (this.body.nodes.hasOwnProperty(_nodeId)) {
                this.body.nodes[_nodeId].updateLabelModule();
                this.body.nodes[_nodeId]._reset();
              }
            }
          }

          // update the shape size in all nodes
          if (options.size !== undefined) {
            for (var _nodeId2 in this.body.nodes) {
              if (this.body.nodes.hasOwnProperty(_nodeId2)) {
                this.body.nodes[_nodeId2]._reset();
              }
            }
          }

          // update the state of the letiables if needed
          if (options.hidden !== undefined || options.physics !== undefined) {
            this.body.emitter.emit('_dataChanged');
          }
        }
      }

      /**
       * Set a data set with nodes for the network
       * @param {Array | DataSet | DataView} nodes         The data containing the nodes.
       * @private
       */

    }, {
      key: 'setData',
      value: function setData(nodes) {
        var _this3 = this;

        var doNotEmit = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

        var oldNodesData = this.body.data.nodes;

        if (nodes instanceof DataSet || nodes instanceof DataView) {
          this.body.data.nodes = nodes;
        } else if (Array.isArray(nodes)) {
          this.body.data.nodes = new DataSet();
          this.body.data.nodes.add(nodes);
        } else if (!nodes) {
          this.body.data.nodes = new DataSet();
        } else {
          throw new TypeError('Array or DataSet expected');
        }

        if (oldNodesData) {
          // unsubscribe from old dataset
          util.forEach(this.nodesListeners, function (callback, event) {
            oldNodesData.off(event, callback);
          });
        }

        // remove drawn nodes
        this.body.nodes = {};

        if (this.body.data.nodes) {
          (function () {
            // subscribe to new dataset
            var me = _this3;
            util.forEach(_this3.nodesListeners, function (callback, event) {
              me.body.data.nodes.on(event, callback);
            });

            // draw all new nodes
            var ids = _this3.body.data.nodes.getIds();
            _this3.add(ids, true);
          })();
        }

        if (doNotEmit === false) {
          this.body.emitter.emit("_dataChanged");
        }
      }

      /**
       * Add nodes
       * @param {Number[] | String[]} ids
       * @private
       */

    }, {
      key: 'add',
      value: function add(ids) {
        var doNotEmit = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

        var id = void 0;
        var newNodes = [];
        for (var i = 0; i < ids.length; i++) {
          id = ids[i];
          var properties = this.body.data.nodes.get(id);
          var node = this.create(properties);
          newNodes.push(node);
          this.body.nodes[id] = node; // note: this may replace an existing node
        }

        this.layoutEngine.positionInitially(newNodes);

        if (doNotEmit === false) {
          this.body.emitter.emit("_dataChanged");
        }
      }

      /**
       * Update existing nodes, or create them when not yet existing
       * @param {Number[] | String[]} ids
       * @private
       */

    }, {
      key: 'update',
      value: function update(ids, changedData) {
        var nodes = this.body.nodes;
        var dataChanged = false;
        for (var i = 0; i < ids.length; i++) {
          var id = ids[i];
          var node = nodes[id];
          var data = changedData[i];
          if (node !== undefined) {
            // update node
            dataChanged = node.setOptions(data);
          } else {
            dataChanged = true;
            // create node
            node = this.create(data);
            nodes[id] = node;
          }
        }
        if (dataChanged === true) {
          this.body.emitter.emit("_dataChanged");
        } else {
          this.body.emitter.emit("_dataUpdated");
        }
      }

      /**
       * Remove existing nodes. If nodes do not exist, the method will just ignore it.
       * @param {Number[] | String[]} ids
       * @private
       */

    }, {
      key: 'remove',
      value: function remove(ids) {
        var nodes = this.body.nodes;

        for (var i = 0; i < ids.length; i++) {
          var id = ids[i];
          delete nodes[id];
        }

        this.body.emitter.emit("_dataChanged");
      }

      /**
       * create a node
       * @param properties
       * @param constructorClass
       */

    }, {
      key: 'create',
      value: function create(properties) {
        var constructorClass = arguments.length <= 1 || arguments[1] === undefined ? _Node2.default : arguments[1];

        return new constructorClass(properties, this.body, this.images, this.groups, this.options);
      }
    }, {
      key: 'refresh',
      value: function refresh() {
        var clearPositions = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];

        var nodes = this.body.nodes;
        for (var nodeId in nodes) {
          var node = undefined;
          if (nodes.hasOwnProperty(nodeId)) {
            node = nodes[nodeId];
          }
          var data = this.body.data.nodes._data[nodeId];
          if (node !== undefined && data !== undefined) {
            if (clearPositions === true) {
              node.setOptions({ x: null, y: null });
            }
            node.setOptions({ fixed: false });
            node.setOptions(data);
          }
        }
      }

      /**
       * Returns the positions of the nodes.
       * @param ids  --> optional, can be array of nodeIds, can be string
       * @returns {{}}
       */

    }, {
      key: 'getPositions',
      value: function getPositions(ids) {
        var dataArray = {};
        if (ids !== undefined) {
          if (Array.isArray(ids) === true) {
            for (var i = 0; i < ids.length; i++) {
              if (this.body.nodes[ids[i]] !== undefined) {
                var node = this.body.nodes[ids[i]];
                dataArray[ids[i]] = { x: Math.round(node.x), y: Math.round(node.y) };
              }
            }
          } else {
            if (this.body.nodes[ids] !== undefined) {
              var _node = this.body.nodes[ids];
              dataArray[ids] = { x: Math.round(_node.x), y: Math.round(_node.y) };
            }
          }
        } else {
          for (var _i = 0; _i < this.body.nodeIndices.length; _i++) {
            var _node2 = this.body.nodes[this.body.nodeIndices[_i]];
            dataArray[this.body.nodeIndices[_i]] = { x: Math.round(_node2.x), y: Math.round(_node2.y) };
          }
        }
        return dataArray;
      }

      /**
       * Load the XY positions of the nodes into the dataset.
       */

    }, {
      key: 'storePositions',
      value: function storePositions() {
        // todo: add support for clusters and hierarchical.
        var dataArray = [];
        var dataset = this.body.data.nodes.getDataSet();

        for (var nodeId in dataset._data) {
          if (dataset._data.hasOwnProperty(nodeId)) {
            var node = this.body.nodes[nodeId];
            if (dataset._data[nodeId].x != Math.round(node.x) || dataset._data[nodeId].y != Math.round(node.y)) {
              dataArray.push({ id: node.id, x: Math.round(node.x), y: Math.round(node.y) });
            }
          }
        }
        dataset.update(dataArray);
      }

      /**
       * get the bounding box of a node.
       * @param nodeId
       * @returns {j|*}
       */

    }, {
      key: 'getBoundingBox',
      value: function getBoundingBox(nodeId) {
        if (this.body.nodes[nodeId] !== undefined) {
          return this.body.nodes[nodeId].shape.boundingBox;
        }
      }

      /**
       * Get the Ids of nodes connected to this node.
       * @param nodeId
       * @returns {Array}
       */

    }, {
      key: 'getConnectedNodes',
      value: function getConnectedNodes(nodeId) {
        var nodeList = [];
        if (this.body.nodes[nodeId] !== undefined) {
          var node = this.body.nodes[nodeId];
          var nodeObj = {}; // used to quickly check if node already exists
          for (var i = 0; i < node.edges.length; i++) {
            var edge = node.edges[i];
            if (edge.toId == node.id) {
              // these are double equals since ids can be numeric or string
              if (nodeObj[edge.fromId] === undefined) {
                nodeList.push(edge.fromId);
                nodeObj[edge.fromId] = true;
              }
            } else if (edge.fromId == node.id) {
              // these are double equals since ids can be numeric or string
              if (nodeObj[edge.toId] === undefined) {
                nodeList.push(edge.toId);
                nodeObj[edge.toId] = true;
              }
            }
          }
        }
        return nodeList;
      }

      /**
       * Get the ids of the edges connected to this node.
       * @param nodeId
       * @returns {*}
       */

    }, {
      key: 'getConnectedEdges',
      value: function getConnectedEdges(nodeId) {
        var edgeList = [];
        if (this.body.nodes[nodeId] !== undefined) {
          var node = this.body.nodes[nodeId];
          for (var i = 0; i < node.edges.length; i++) {
            edgeList.push(node.edges[i].id);
          }
        } else {
          console.log("NodeId provided for getConnectedEdges does not exist. Provided: ", nodeId);
        }
        return edgeList;
      }

      /**
       * Move a node.
       * @param String nodeId
       * @param Number x
       * @param Number y
       */

    }, {
      key: 'moveNode',
      value: function moveNode(nodeId, x, y) {
        var _this4 = this;

        if (this.body.nodes[nodeId] !== undefined) {
          this.body.nodes[nodeId].x = Number(x);
          this.body.nodes[nodeId].y = Number(y);
          setTimeout(function () {
            _this4.body.emitter.emit("startSimulation");
          }, 0);
        } else {
          console.log("Node id supplied to moveNode does not exist. Provided: ", nodeId);
        }
      }
    }]);

    return NodesHandler;
  }();

  exports.default = NodesHandler;

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _Label = __webpack_require__(66);

  var _Label2 = _interopRequireDefault(_Label);

  var _Box = __webpack_require__(67);

  var _Box2 = _interopRequireDefault(_Box);

  var _Circle = __webpack_require__(69);

  var _Circle2 = _interopRequireDefault(_Circle);

  var _CircularImage = __webpack_require__(71);

  var _CircularImage2 = _interopRequireDefault(_CircularImage);

  var _Database = __webpack_require__(72);

  var _Database2 = _interopRequireDefault(_Database);

  var _Diamond = __webpack_require__(73);

  var _Diamond2 = _interopRequireDefault(_Diamond);

  var _Dot = __webpack_require__(75);

  var _Dot2 = _interopRequireDefault(_Dot);

  var _Ellipse = __webpack_require__(76);

  var _Ellipse2 = _interopRequireDefault(_Ellipse);

  var _Icon = __webpack_require__(77);

  var _Icon2 = _interopRequireDefault(_Icon);

  var _Image = __webpack_require__(78);

  var _Image2 = _interopRequireDefault(_Image);

  var _Square = __webpack_require__(79);

  var _Square2 = _interopRequireDefault(_Square);

  var _Star = __webpack_require__(80);

  var _Star2 = _interopRequireDefault(_Star);

  var _Text = __webpack_require__(81);

  var _Text2 = _interopRequireDefault(_Text);

  var _Triangle = __webpack_require__(82);

  var _Triangle2 = _interopRequireDefault(_Triangle);

  var _TriangleDown = __webpack_require__(83);

  var _TriangleDown2 = _interopRequireDefault(_TriangleDown);

  var _Validator = __webpack_require__(29);

  var _Validator2 = _interopRequireDefault(_Validator);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);

  /**
   * @class Node
   * A node. A node can be connected to other nodes via one or multiple edges.
   * @param {object} options An object containing options for the node. All
   *                            options are optional, except for the id.
   *                              {number} id     Id of the node. Required
   *                              {string} label  Text label for the node
   *                              {number} x      Horizontal position of the node
   *                              {number} y      Vertical position of the node
   *                              {string} shape  Node shape, available:
   *                                              "database", "circle", "ellipse",
   *                                              "box", "image", "text", "dot",
   *                                              "star", "triangle", "triangleDown",
   *                                              "square", "icon"
   *                              {string} image  An image url
   *                              {string} title  An title text, can be HTML
   *                              {anytype} group A group name or number
   * @param {Network.Images} imagelist    A list with images. Only needed
   *                                            when the node has an image
   * @param {Network.Groups} grouplist    A list with groups. Needed for
   *                                            retrieving group options
   * @param {Object}               constants    An object with default values for
   *                                            example for the color
   *
   */

  var Node = function () {
    function Node(options, body, imagelist, grouplist, globalOptions) {
      _classCallCheck(this, Node);

      this.options = util.bridgeObject(globalOptions);
      this.globalOptions = globalOptions;
      this.body = body;

      this.edges = []; // all edges connected to this node

      // set defaults for the options
      this.id = undefined;
      this.imagelist = imagelist;
      this.grouplist = grouplist;

      // state options
      this.x = undefined;
      this.y = undefined;
      this.baseSize = this.options.size;
      this.baseFontSize = this.options.font.size;
      this.predefinedPosition = false; // used to check if initial fit should just take the range or approximate
      this.selected = false;
      this.hover = false;

      this.labelModule = new _Label2.default(this.body, this.options, false /* Not edge label */);
      this.setOptions(options);
    }

    /**
     * Attach a edge to the node
     * @param {Edge} edge
     */


    _createClass(Node, [{
      key: 'attachEdge',
      value: function attachEdge(edge) {
        if (this.edges.indexOf(edge) === -1) {
          this.edges.push(edge);
        }
      }

      /**
       * Detach a edge from the node
       * @param {Edge} edge
       */

    }, {
      key: 'detachEdge',
      value: function detachEdge(edge) {
        var index = this.edges.indexOf(edge);
        if (index != -1) {
          this.edges.splice(index, 1);
        }
      }

      /**
       * Set or overwrite options for the node
       * @param {Object} options an object with options
       * @param {Object} constants  and object with default, global options
       */

    }, {
      key: 'setOptions',
      value: function setOptions(options) {
        var currentShape = this.options.shape;
        if (!options) {
          return;
        }
        // basic options
        if (options.id !== undefined) {
          this.id = options.id;
        }

        if (this.id === undefined) {
          throw "Node must have an id";
        }

        // set these options locally
        // clear x and y positions
        if (options.x !== undefined) {
          if (options.x === null) {
            this.x = undefined;this.predefinedPosition = false;
          } else {
            this.x = parseInt(options.x);this.predefinedPosition = true;
          }
        }
        if (options.y !== undefined) {
          if (options.y === null) {
            this.y = undefined;this.predefinedPosition = false;
          } else {
            this.y = parseInt(options.y);this.predefinedPosition = true;
          }
        }
        if (options.size !== undefined) {
          this.baseSize = options.size;
        }
        if (options.value !== undefined) {
          options.value = parseFloat(options.value);
        }

        // copy group options
        if (typeof options.group === 'number' || typeof options.group === 'string' && options.group != '') {
          var groupObj = this.grouplist.get(options.group);
          util.deepExtend(this.options, groupObj);
          // the color object needs to be completely defined. Since groups can partially overwrite the colors, we parse it again, just in case.
          this.options.color = util.parseColor(this.options.color);
        }

        // this transforms all shorthands into fully defined options
        Node.parseOptions(this.options, options, true, this.globalOptions);

        // load the images
        if (this.options.image !== undefined) {
          if (this.imagelist) {
            this.imageObj = this.imagelist.load(this.options.image, this.options.brokenImage, this.id);
          } else {
            throw "No imagelist provided";
          }
        }

        this.updateLabelModule();
        this.updateShape(currentShape);

        if (options.hidden !== undefined || options.physics !== undefined) {
          return true;
        }
        return false;
      }

      /**
       * This process all possible shorthands in the new options and makes sure that the parentOptions are fully defined.
       * Static so it can also be used by the handler.
       * @param parentOptions
       * @param newOptions
       * @param allowDeletion
       * @param globalOptions
       */

    }, {
      key: 'updateLabelModule',
      value: function updateLabelModule() {
        if (this.options.label === undefined || this.options.label === null) {
          this.options.label = '';
        }
        this.labelModule.setOptions(this.options, true);
        if (this.labelModule.baseSize !== undefined) {
          this.baseFontSize = this.labelModule.baseSize;
        }
      }
    }, {
      key: 'updateShape',
      value: function updateShape(currentShape) {
        if (currentShape === this.options.shape && this.shape) {
          this.shape.setOptions(this.options, this.imageObj);
        } else {
          // choose draw method depending on the shape
          switch (this.options.shape) {
            case 'box':
              this.shape = new _Box2.default(this.options, this.body, this.labelModule);
              break;
            case 'circle':
              this.shape = new _Circle2.default(this.options, this.body, this.labelModule);
              break;
            case 'circularImage':
              this.shape = new _CircularImage2.default(this.options, this.body, this.labelModule, this.imageObj);
              break;
            case 'database':
              this.shape = new _Database2.default(this.options, this.body, this.labelModule);
              break;
            case 'diamond':
              this.shape = new _Diamond2.default(this.options, this.body, this.labelModule);
              break;
            case 'dot':
              this.shape = new _Dot2.default(this.options, this.body, this.labelModule);
              break;
            case 'ellipse':
              this.shape = new _Ellipse2.default(this.options, this.body, this.labelModule);
              break;
            case 'icon':
              this.shape = new _Icon2.default(this.options, this.body, this.labelModule);
              break;
            case 'image':
              this.shape = new _Image2.default(this.options, this.body, this.labelModule, this.imageObj);
              break;
            case 'square':
              this.shape = new _Square2.default(this.options, this.body, this.labelModule);
              break;
            case 'star':
              this.shape = new _Star2.default(this.options, this.body, this.labelModule);
              break;
            case 'text':
              this.shape = new _Text2.default(this.options, this.body, this.labelModule);
              break;
            case 'triangle':
              this.shape = new _Triangle2.default(this.options, this.body, this.labelModule);
              break;
            case 'triangleDown':
              this.shape = new _TriangleDown2.default(this.options, this.body, this.labelModule);
              break;
            default:
              this.shape = new _Ellipse2.default(this.options, this.body, this.labelModule);
              break;
          }
        }
        this._reset();
      }

      /**
       * select this node
       */

    }, {
      key: 'select',
      value: function select() {
        this.selected = true;
        this._reset();
      }

      /**
       * unselect this node
       */

    }, {
      key: 'unselect',
      value: function unselect() {
        this.selected = false;
        this._reset();
      }

      /**
       * Reset the calculated size of the node, forces it to recalculate its size
       * @private
       */

    }, {
      key: '_reset',
      value: function _reset() {
        this.shape.width = undefined;
        this.shape.height = undefined;
      }

      /**
       * get the title of this node.
       * @return {string} title    The title of the node, or undefined when no title
       *                           has been set.
       */

    }, {
      key: 'getTitle',
      value: function getTitle() {
        return this.options.title;
      }

      /**
       * Calculate the distance to the border of the Node
       * @param {CanvasRenderingContext2D}   ctx
       * @param {Number} angle        Angle in radians
       * @returns {number} distance   Distance to the border in pixels
       */

    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        return this.shape.distanceToBorder(ctx, angle);
      }

      /**
       * Check if this node has a fixed x and y position
       * @return {boolean}      true if fixed, false if not
       */

    }, {
      key: 'isFixed',
      value: function isFixed() {
        return this.options.fixed.x && this.options.fixed.y;
      }

      /**
       * check if this node is selecte
       * @return {boolean} selected   True if node is selected, else false
       */

    }, {
      key: 'isSelected',
      value: function isSelected() {
        return this.selected;
      }

      /**
       * Retrieve the value of the node. Can be undefined
       * @return {Number} value
       */

    }, {
      key: 'getValue',
      value: function getValue() {
        return this.options.value;
      }

      /**
       * Adjust the value range of the node. The node will adjust it's size
       * based on its value.
       * @param {Number} min
       * @param {Number} max
       */

    }, {
      key: 'setValueRange',
      value: function setValueRange(min, max, total) {
        if (this.options.value !== undefined) {
          var scale = this.options.scaling.customScalingFunction(min, max, total, this.options.value);
          var sizeDiff = this.options.scaling.max - this.options.scaling.min;
          if (this.options.scaling.label.enabled === true) {
            var fontDiff = this.options.scaling.label.max - this.options.scaling.label.min;
            this.options.font.size = this.options.scaling.label.min + scale * fontDiff;
          }
          this.options.size = this.options.scaling.min + scale * sizeDiff;
        } else {
          this.options.size = this.baseSize;
          this.options.font.size = this.baseFontSize;
        }

        this.updateLabelModule();
      }

      /**
       * Draw this node in the given canvas
       * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
       * @param {CanvasRenderingContext2D}   ctx
       */

    }, {
      key: 'draw',
      value: function draw(ctx) {
        this.shape.draw(ctx, this.x, this.y, this.selected, this.hover);
      }

      /**
       * Update the bounding box of the shape
       */

    }, {
      key: 'updateBoundingBox',
      value: function updateBoundingBox(ctx) {
        this.shape.updateBoundingBox(this.x, this.y, ctx);
      }

      /**
       * Recalculate the size of this node in the given canvas
       * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
       * @param {CanvasRenderingContext2D}   ctx
       */

    }, {
      key: 'resize',
      value: function resize(ctx) {
        this.shape.resize(ctx, this.selected);
      }

      /**
       * Check if this object is overlapping with the provided object
       * @param {Object} obj   an object with parameters left, top, right, bottom
       * @return {boolean}     True if location is located on node
       */

    }, {
      key: 'isOverlappingWith',
      value: function isOverlappingWith(obj) {
        return this.shape.left < obj.right && this.shape.left + this.shape.width > obj.left && this.shape.top < obj.bottom && this.shape.top + this.shape.height > obj.top;
      }

      /**
       * Check if this object is overlapping with the provided object
       * @param {Object} obj   an object with parameters left, top, right, bottom
       * @return {boolean}     True if location is located on node
       */

    }, {
      key: 'isBoundingBoxOverlappingWith',
      value: function isBoundingBoxOverlappingWith(obj) {
        return this.shape.boundingBox.left < obj.right && this.shape.boundingBox.right > obj.left && this.shape.boundingBox.top < obj.bottom && this.shape.boundingBox.bottom > obj.top;
      }
    }], [{
      key: 'parseOptions',
      value: function parseOptions(parentOptions, newOptions) {
        var allowDeletion = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];
        var globalOptions = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

        var fields = ['color', 'font', 'fixed', 'shadow'];
        util.selectiveNotDeepExtend(fields, parentOptions, newOptions, allowDeletion);

        // merge the shadow options into the parent.
        util.mergeOptions(parentOptions, newOptions, 'shadow', allowDeletion, globalOptions);

        // individual shape newOptions
        if (newOptions.color !== undefined && newOptions.color !== null) {
          var parsedColor = util.parseColor(newOptions.color);
          util.fillIfDefined(parentOptions.color, parsedColor);
        } else if (allowDeletion === true && newOptions.color === null) {
          parentOptions.color = util.bridgeObject(globalOptions.color); // set the object back to the global options
        }

        // handle the fixed options
        if (newOptions.fixed !== undefined && newOptions.fixed !== null) {
          if (typeof newOptions.fixed === 'boolean') {
            parentOptions.fixed.x = newOptions.fixed;
            parentOptions.fixed.y = newOptions.fixed;
          } else {
            if (newOptions.fixed.x !== undefined && typeof newOptions.fixed.x === 'boolean') {
              parentOptions.fixed.x = newOptions.fixed.x;
            }
            if (newOptions.fixed.y !== undefined && typeof newOptions.fixed.y === 'boolean') {
              parentOptions.fixed.y = newOptions.fixed.y;
            }
          }
        }

        // handle the font options
        if (newOptions.font !== undefined && newOptions.font !== null) {
          _Label2.default.parseOptions(parentOptions.font, newOptions);
        } else if (allowDeletion === true && newOptions.font === null) {
          parentOptions.font = util.bridgeObject(globalOptions.font); // set the object back to the global options
        }

        // handle the scaling options, specifically the label part
        if (newOptions.scaling !== undefined) {
          util.mergeOptions(parentOptions.scaling, newOptions.scaling, 'label', allowDeletion, globalOptions.scaling);
        }
      }
    }]);

    return Node;
  }();

  exports.default = Node;

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);

  var Label = function () {
    function Label(body, options) {
      var edgelabel = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

      _classCallCheck(this, Label);

      this.body = body;

      this.pointToSelf = false;
      this.baseSize = undefined;
      this.fontOptions = {};
      this.setOptions(options);
      this.size = { top: 0, left: 0, width: 0, height: 0, yLine: 0 }; // could be cached
      this.isEdgeLabel = edgelabel;
    }

    _createClass(Label, [{
      key: 'setOptions',
      value: function setOptions(options) {
        var allowDeletion = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

        this.nodeOptions = options;

        // We want to keep the font options seperated from the node options.
        // The node options have to mirror the globals when they are not overruled.
        this.fontOptions = util.deepExtend({}, options.font, true);

        if (options.label !== undefined) {
          this.labelDirty = true;
        }

        if (options.font !== undefined) {
          Label.parseOptions(this.fontOptions, options, allowDeletion);
          if (typeof options.font === 'string') {
            this.baseSize = this.fontOptions.size;
          } else if (_typeof(options.font) === 'object') {
            if (options.font.size !== undefined) {
              this.baseSize = options.font.size;
            }
          }
        }
      }
    }, {
      key: 'draw',


      /**
       * Main function. This is called from anything that wants to draw a label.
       * @param ctx
       * @param x
       * @param y
       * @param selected
       * @param baseline
       */
      value: function draw(ctx, x, y, selected) {
        var baseline = arguments.length <= 4 || arguments[4] === undefined ? 'middle' : arguments[4];

        // if no label, return
        if (this.nodeOptions.label === undefined) return;

        // check if we have to render the label
        var viewFontSize = this.fontOptions.size * this.body.view.scale;
        if (this.nodeOptions.label && viewFontSize < this.nodeOptions.scaling.label.drawThreshold - 1) return;

        // update the size cache if required
        this.calculateLabelSize(ctx, selected, x, y, baseline);

        // create the fontfill background
        this._drawBackground(ctx);
        // draw text
        this._drawText(ctx, selected, x, y, baseline);
      }

      /**
       * Draws the label background
       * @param {CanvasRenderingContext2D} ctx
       * @private
       */

    }, {
      key: '_drawBackground',
      value: function _drawBackground(ctx) {
        if (this.fontOptions.background !== undefined && this.fontOptions.background !== "none") {
          ctx.fillStyle = this.fontOptions.background;

          var lineMargin = 2;

          if (this.isEdgeLabel) {
            switch (this.fontOptions.align) {
              case 'middle':
                ctx.fillRect(-this.size.width * 0.5, -this.size.height * 0.5, this.size.width, this.size.height);
                break;
              case 'top':
                ctx.fillRect(-this.size.width * 0.5, -(this.size.height + lineMargin), this.size.width, this.size.height);
                break;
              case 'bottom':
                ctx.fillRect(-this.size.width * 0.5, lineMargin, this.size.width, this.size.height);
                break;
              default:
                ctx.fillRect(this.size.left, this.size.top - 0.5 * lineMargin, this.size.width, this.size.height);
                break;
            }
          } else {
            ctx.fillRect(this.size.left, this.size.top - 0.5 * lineMargin, this.size.width, this.size.height);
          }
        }
      }

      /**
       *
       * @param ctx
       * @param x
       * @param baseline
       * @private
       */

    }, {
      key: '_drawText',
      value: function _drawText(ctx, selected, x, y) {
        var baseline = arguments.length <= 4 || arguments[4] === undefined ? 'middle' : arguments[4];

        var fontSize = this.fontOptions.size;
        var viewFontSize = fontSize * this.body.view.scale;
        // this ensures that there will not be HUGE letters on screen by setting an upper limit on the visible text size (regardless of zoomLevel)
        if (viewFontSize >= this.nodeOptions.scaling.label.maxVisible) {
          fontSize = Number(this.nodeOptions.scaling.label.maxVisible) / this.body.view.scale;
        }

        var yLine = this.size.yLine;

        var _getColor2 = this._getColor(viewFontSize);

        var _getColor3 = _slicedToArray(_getColor2, 2);

        var fontColor = _getColor3[0];
        var strokeColor = _getColor3[1];


        // configure context for drawing the text

        var _setAlignment2 = this._setAlignment(ctx, x, yLine, baseline);

        var _setAlignment3 = _slicedToArray(_setAlignment2, 2);

        x = _setAlignment3[0];
        yLine = _setAlignment3[1];
        ctx.font = (selected && this.nodeOptions.labelHighlightBold ? 'bold ' : '') + fontSize + "px " + this.fontOptions.face;
        ctx.fillStyle = fontColor;
        // When the textAlign property is 'left', make label left-justified
        if (!this.isEdgeLabel && this.fontOptions.align === 'left') {
          ctx.textAlign = this.fontOptions.align;
          x = x - 0.5 * this.size.width; // Shift label 1/2-distance to the left
        } else {
            ctx.textAlign = 'center';
          }

        // set the strokeWidth
        if (this.fontOptions.strokeWidth > 0) {
          ctx.lineWidth = this.fontOptions.strokeWidth;
          ctx.strokeStyle = strokeColor;
          ctx.lineJoin = 'round';
        }

        // draw the text
        for (var i = 0; i < this.lineCount; i++) {
          if (this.fontOptions.strokeWidth > 0) {
            ctx.strokeText(this.lines[i], x, yLine);
          }
          ctx.fillText(this.lines[i], x, yLine);
          yLine += fontSize;
        }
      }
    }, {
      key: '_setAlignment',
      value: function _setAlignment(ctx, x, yLine, baseline) {
        // check for label alignment (for edges)
        // TODO: make alignment for nodes
        if (this.isEdgeLabel && this.fontOptions.align !== 'horizontal' && this.pointToSelf === false) {
          x = 0;
          yLine = 0;

          var lineMargin = 2;
          if (this.fontOptions.align === 'top') {
            ctx.textBaseline = 'alphabetic';
            yLine -= 2 * lineMargin; // distance from edge, required because we use alphabetic. Alphabetic has less difference between browsers
          } else if (this.fontOptions.align === 'bottom') {
              ctx.textBaseline = 'hanging';
              yLine += 2 * lineMargin; // distance from edge, required because we use hanging. Hanging has less difference between browsers
            } else {
                ctx.textBaseline = 'middle';
              }
        } else {
          ctx.textBaseline = baseline;
        }

        return [x, yLine];
      }

      /**
       * fade in when relative scale is between threshold and threshold - 1.
       * If the relative scale would be smaller than threshold -1 the draw function would have returned before coming here.
       *
       * @param viewFontSize
       * @returns {*[]}
       * @private
       */

    }, {
      key: '_getColor',
      value: function _getColor(viewFontSize) {
        var fontColor = this.fontOptions.color || '#000000';
        var strokeColor = this.fontOptions.strokeColor || '#ffffff';
        if (viewFontSize <= this.nodeOptions.scaling.label.drawThreshold) {
          var opacity = Math.max(0, Math.min(1, 1 - (this.nodeOptions.scaling.label.drawThreshold - viewFontSize)));
          fontColor = util.overrideOpacity(fontColor, opacity);
          strokeColor = util.overrideOpacity(strokeColor, opacity);
        }
        return [fontColor, strokeColor];
      }

      /**
       *
       * @param ctx
       * @param selected
       * @returns {{width: number, height: number}}
       */

    }, {
      key: 'getTextSize',
      value: function getTextSize(ctx) {
        var selected = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

        var size = {
          width: this._processLabel(ctx, selected),
          height: this.fontOptions.size * this.lineCount,
          lineCount: this.lineCount
        };
        return size;
      }

      /**
       *
       * @param ctx
       * @param selected
       * @param x
       * @param y
       * @param baseline
       */

    }, {
      key: 'calculateLabelSize',
      value: function calculateLabelSize(ctx, selected) {
        var x = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
        var y = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];
        var baseline = arguments.length <= 4 || arguments[4] === undefined ? 'middle' : arguments[4];

        if (this.labelDirty === true) {
          this.size.width = this._processLabel(ctx, selected);
        }
        this.size.height = this.fontOptions.size * this.lineCount;
        this.size.left = x - this.size.width * 0.5;
        this.size.top = y - this.size.height * 0.5;
        this.size.yLine = y + (1 - this.lineCount) * 0.5 * this.fontOptions.size;
        if (baseline === "hanging") {
          this.size.top += 0.5 * this.fontOptions.size;
          this.size.top += 4; // distance from node, required because we use hanging. Hanging has less difference between browsers
          this.size.yLine += 4; // distance from node
        }

        this.labelDirty = false;
      }

      /**
       * This calculates the width as well as explodes the label string and calculates the amount of lines.
       * @param ctx
       * @param selected
       * @returns {number}
       * @private
       */

    }, {
      key: '_processLabel',
      value: function _processLabel(ctx, selected) {
        var width = 0;
        var lines = [''];
        var lineCount = 0;
        if (this.nodeOptions.label !== undefined) {
          lines = String(this.nodeOptions.label).split('\n');
          lineCount = lines.length;
          ctx.font = (selected && this.nodeOptions.labelHighlightBold ? 'bold ' : '') + this.fontOptions.size + "px " + this.fontOptions.face;
          width = ctx.measureText(lines[0]).width;
          for (var i = 1; i < lineCount; i++) {
            var lineWidth = ctx.measureText(lines[i]).width;
            width = lineWidth > width ? lineWidth : width;
          }
        }
        this.lines = lines;
        this.lineCount = lineCount;

        return width;
      }
    }], [{
      key: 'parseOptions',
      value: function parseOptions(parentOptions, newOptions) {
        var allowDeletion = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

        if (typeof newOptions.font === 'string') {
          var newOptionsArray = newOptions.font.split(" ");
          parentOptions.size = newOptionsArray[0].replace("px", '');
          parentOptions.face = newOptionsArray[1];
          parentOptions.color = newOptionsArray[2];
        } else if (_typeof(newOptions.font) === 'object') {
          util.fillIfDefined(parentOptions, newOptions.font, allowDeletion);
        }
        parentOptions.size = Number(parentOptions.size);
      }
    }]);

    return Label;
  }();

  exports.default = Label;

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _NodeBase2 = __webpack_require__(68);

  var _NodeBase3 = _interopRequireDefault(_NodeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var Box = function (_NodeBase) {
    _inherits(Box, _NodeBase);

    function Box(options, body, labelModule) {
      _classCallCheck(this, Box);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(Box).call(this, options, body, labelModule));
    }

    _createClass(Box, [{
      key: 'resize',
      value: function resize(ctx, selected) {
        if (this.width === undefined) {
          var margin = 5;
          var textSize = this.labelModule.getTextSize(ctx, selected);
          this.width = textSize.width + 2 * margin;
          this.height = textSize.height + 2 * margin;
          this.radius = 0.5 * this.width;
        }
      }
    }, {
      key: 'draw',
      value: function draw(ctx, x, y, selected, hover) {
        this.resize(ctx, selected);
        this.left = x - this.width / 2;
        this.top = y - this.height / 2;

        var borderWidth = this.options.borderWidth;
        var selectionLineWidth = this.options.borderWidthSelected || 2 * this.options.borderWidth;

        ctx.strokeStyle = selected ? this.options.color.highlight.border : hover ? this.options.color.hover.border : this.options.color.border;
        ctx.lineWidth = selected ? selectionLineWidth : borderWidth;
        ctx.lineWidth /= this.body.view.scale;
        ctx.lineWidth = Math.min(this.width, ctx.lineWidth);

        ctx.fillStyle = selected ? this.options.color.highlight.background : hover ? this.options.color.hover.background : this.options.color.background;

        var borderRadius = this.options.shapeProperties.borderRadius; // only effective for box
        ctx.roundRect(this.left, this.top, this.width, this.height, borderRadius);

        // draw shadow if enabled
        this.enableShadow(ctx);
        // draw the background
        ctx.fill();
        // disable shadows for other elements.
        this.disableShadow(ctx);

        //draw dashed border if enabled, save and restore is required for firefox not to crash on unix.
        ctx.save();
        // if borders are zero width, they will be drawn with width 1 by default. This prevents that
        if (borderWidth > 0) {
          this.enableBorderDashes(ctx);
          //draw the border
          ctx.stroke();
          //disable dashed border for other elements
          this.disableBorderDashes(ctx);
        }
        ctx.restore();

        this.updateBoundingBox(x, y, ctx, selected);
        this.labelModule.draw(ctx, x, y, selected);
      }
    }, {
      key: 'updateBoundingBox',
      value: function updateBoundingBox(x, y, ctx, selected) {
        this.resize(ctx, selected);
        this.left = x - this.width * 0.5;
        this.top = y - this.height * 0.5;

        var borderRadius = this.options.shapeProperties.borderRadius; // only effective for box
        this.boundingBox.left = this.left - borderRadius;
        this.boundingBox.top = this.top - borderRadius;
        this.boundingBox.bottom = this.top + this.height + borderRadius;
        this.boundingBox.right = this.left + this.width + borderRadius;
      }
    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        this.resize(ctx);
        var borderWidth = this.options.borderWidth;

        return Math.min(Math.abs(this.width / 2 / Math.cos(angle)), Math.abs(this.height / 2 / Math.sin(angle))) + borderWidth;
      }
    }]);

    return Box;
  }(_NodeBase3.default);

  exports.default = Box;

/***/ },
/* 68 */
/***/ function(module, exports) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var NodeBase = function () {
    function NodeBase(options, body, labelModule) {
      _classCallCheck(this, NodeBase);

      this.body = body;
      this.labelModule = labelModule;
      this.setOptions(options);
      this.top = undefined;
      this.left = undefined;
      this.height = undefined;
      this.width = undefined;
      this.radius = undefined;
      this.boundingBox = { top: 0, left: 0, right: 0, bottom: 0 };
    }

    _createClass(NodeBase, [{
      key: "setOptions",
      value: function setOptions(options) {
        this.options = options;
      }
    }, {
      key: "_distanceToBorder",
      value: function _distanceToBorder(ctx, angle) {
        var borderWidth = this.options.borderWidth;
        this.resize(ctx);
        return Math.min(Math.abs(this.width / 2 / Math.cos(angle)), Math.abs(this.height / 2 / Math.sin(angle))) + borderWidth;
      }
    }, {
      key: "enableShadow",
      value: function enableShadow(ctx) {
        if (this.options.shadow.enabled === true) {
          ctx.shadowColor = this.options.shadow.color;
          ctx.shadowBlur = this.options.shadow.size;
          ctx.shadowOffsetX = this.options.shadow.x;
          ctx.shadowOffsetY = this.options.shadow.y;
        }
      }
    }, {
      key: "disableShadow",
      value: function disableShadow(ctx) {
        if (this.options.shadow.enabled === true) {
          ctx.shadowColor = 'rgba(0,0,0,0)';
          ctx.shadowBlur = 0;
          ctx.shadowOffsetX = 0;
          ctx.shadowOffsetY = 0;
        }
      }
    }, {
      key: "enableBorderDashes",
      value: function enableBorderDashes(ctx) {
        if (this.options.shapeProperties.borderDashes !== false) {
          if (ctx.setLineDash !== undefined) {
            var dashes = this.options.shapeProperties.borderDashes;
            if (dashes === true) {
              dashes = [5, 15];
            }
            ctx.setLineDash(dashes);
          } else {
            console.warn("setLineDash is not supported in this browser. The dashed borders cannot be used.");
            this.options.shapeProperties.borderDashes = false;
          }
        }
      }
    }, {
      key: "disableBorderDashes",
      value: function disableBorderDashes(ctx) {
        if (this.options.shapeProperties.borderDashes !== false) {
          if (ctx.setLineDash !== undefined) {
            ctx.setLineDash([0]);
          } else {
            console.warn("setLineDash is not supported in this browser. The dashed borders cannot be used.");
            this.options.shapeProperties.borderDashes = false;
          }
        }
      }
    }]);

    return NodeBase;
  }();

  exports.default = NodeBase;

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _CircleImageBase2 = __webpack_require__(70);

  var _CircleImageBase3 = _interopRequireDefault(_CircleImageBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var Circle = function (_CircleImageBase) {
    _inherits(Circle, _CircleImageBase);

    function Circle(options, body, labelModule) {
      _classCallCheck(this, Circle);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(Circle).call(this, options, body, labelModule));
    }

    _createClass(Circle, [{
      key: 'resize',
      value: function resize(ctx, selected) {
        if (this.width === undefined) {
          var margin = 5;
          var textSize = this.labelModule.getTextSize(ctx, selected);
          var diameter = Math.max(textSize.width, textSize.height) + 2 * margin;
          this.options.size = diameter / 2;

          this.width = diameter;
          this.height = diameter;
          this.radius = 0.5 * this.width;
        }
      }
    }, {
      key: 'draw',
      value: function draw(ctx, x, y, selected, hover) {
        this.resize(ctx, selected);
        this.left = x - this.width / 2;
        this.top = y - this.height / 2;

        this._drawRawCircle(ctx, x, y, selected, hover, this.options.size);

        this.boundingBox.top = y - this.options.size;
        this.boundingBox.left = x - this.options.size;
        this.boundingBox.right = x + this.options.size;
        this.boundingBox.bottom = y + this.options.size;

        this.updateBoundingBox(x, y);
        this.labelModule.draw(ctx, x, y, selected);
      }
    }, {
      key: 'updateBoundingBox',
      value: function updateBoundingBox(x, y) {
        this.boundingBox.top = y - this.options.size;
        this.boundingBox.left = x - this.options.size;
        this.boundingBox.right = x + this.options.size;
        this.boundingBox.bottom = y + this.options.size;
      }
    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        this.resize(ctx);
        return this.width * 0.5;
      }
    }]);

    return Circle;
  }(_CircleImageBase3.default);

  exports.default = Circle;

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _NodeBase2 = __webpack_require__(68);

  var _NodeBase3 = _interopRequireDefault(_NodeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var CircleImageBase = function (_NodeBase) {
    _inherits(CircleImageBase, _NodeBase);

    function CircleImageBase(options, body, labelModule) {
      _classCallCheck(this, CircleImageBase);

      var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(CircleImageBase).call(this, options, body, labelModule));

      _this.labelOffset = 0;
      _this.imageLoaded = false;
      return _this;
    }

    _createClass(CircleImageBase, [{
      key: 'setOptions',
      value: function setOptions(options, imageObj) {
        this.options = options;
        if (imageObj) {
          this.imageObj = imageObj;
        }
      }

      /**
       * This function resizes the image by the options size when the image has not yet loaded. If the image has loaded, we
       * force the update of the size again.
       *
       * @private
       */

    }, {
      key: '_resizeImage',
      value: function _resizeImage() {
        var force = false;
        if (!this.imageObj.width || !this.imageObj.height) {
          // undefined or 0
          this.imageLoaded = false;
        } else if (this.imageLoaded === false) {
          this.imageLoaded = true;
          force = true;
        }

        if (!this.width || !this.height || force === true) {
          // undefined or 0
          var width, height, ratio;
          if (this.imageObj.width && this.imageObj.height) {
            // not undefined or 0
            width = 0;
            height = 0;
          }
          if (this.options.shapeProperties.useImageSize === false) {
            if (this.imageObj.width > this.imageObj.height) {
              ratio = this.imageObj.width / this.imageObj.height;
              width = this.options.size * 2 * ratio || this.imageObj.width;
              height = this.options.size * 2 || this.imageObj.height;
            } else {
              if (this.imageObj.width && this.imageObj.height) {
                // not undefined or 0
                ratio = this.imageObj.height / this.imageObj.width;
              } else {
                ratio = 1;
              }
              width = this.options.size * 2;
              height = this.options.size * 2 * ratio;
            }
          } else {
            // when not using the size property, we use the image size
            width = this.imageObj.width;
            height = this.imageObj.height;
          }
          this.width = width;
          this.height = height;
          this.radius = 0.5 * this.width;
        }
      }
    }, {
      key: '_drawRawCircle',
      value: function _drawRawCircle(ctx, x, y, selected, hover, size) {
        var neutralborderWidth = this.options.borderWidth;
        var selectionLineWidth = this.options.borderWidthSelected || 2 * this.options.borderWidth;
        var borderWidth = (selected ? selectionLineWidth : neutralborderWidth) / this.body.view.scale;
        ctx.lineWidth = Math.min(this.width, borderWidth);

        ctx.strokeStyle = selected ? this.options.color.highlight.border : hover ? this.options.color.hover.border : this.options.color.border;
        ctx.fillStyle = selected ? this.options.color.highlight.background : hover ? this.options.color.hover.background : this.options.color.background;
        ctx.circle(x, y, size);

        // draw shadow if enabled
        this.enableShadow(ctx);
        // draw the background
        ctx.fill();
        // disable shadows for other elements.
        this.disableShadow(ctx);

        //draw dashed border if enabled, save and restore is required for firefox not to crash on unix.
        ctx.save();
        // if borders are zero width, they will be drawn with width 1 by default. This prevents that
        if (borderWidth > 0) {
          this.enableBorderDashes(ctx);
          //draw the border
          ctx.stroke();
          //disable dashed border for other elements
          this.disableBorderDashes(ctx);
        }
        ctx.restore();
      }
    }, {
      key: '_drawImageAtPosition',
      value: function _drawImageAtPosition(ctx) {
        if (this.imageObj.width != 0) {
          // draw the image
          ctx.globalAlpha = 1.0;

          // draw shadow if enabled
          this.enableShadow(ctx);

          var factor = this.imageObj.width / this.width / this.body.view.scale;
          if (factor > 2 && this.options.shapeProperties.interpolation === true) {
            var w = this.imageObj.width;
            var h = this.imageObj.height;
            var can2 = document.createElement('canvas');
            can2.width = w;
            can2.height = w;
            var ctx2 = can2.getContext('2d');

            factor *= 0.5;
            w *= 0.5;
            h *= 0.5;
            ctx2.drawImage(this.imageObj, 0, 0, w, h);

            var distance = 0;
            var iterations = 1;
            while (factor > 2 && iterations < 4) {
              ctx2.drawImage(can2, distance, 0, w, h, distance + w, 0, w / 2, h / 2);
              distance += w;
              factor *= 0.5;
              w *= 0.5;
              h *= 0.5;
              iterations += 1;
            }
            ctx.drawImage(can2, distance, 0, w, h, this.left, this.top, this.width, this.height);
          } else {
            // draw image
            ctx.drawImage(this.imageObj, this.left, this.top, this.width, this.height);
          }

          // disable shadows for other elements.
          this.disableShadow(ctx);
        }
      }
    }, {
      key: '_drawImageLabel',
      value: function _drawImageLabel(ctx, x, y, selected) {
        var yLabel;
        var offset = 0;

        if (this.height !== undefined) {
          offset = this.height * 0.5;
          var labelDimensions = this.labelModule.getTextSize(ctx);
          if (labelDimensions.lineCount >= 1) {
            offset += labelDimensions.height / 2;
          }
        }

        yLabel = y + offset;

        if (this.options.label) {
          this.labelOffset = offset;
        }
        this.labelModule.draw(ctx, x, yLabel, selected, 'hanging');
      }
    }]);

    return CircleImageBase;
  }(_NodeBase3.default);

  exports.default = CircleImageBase;

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _CircleImageBase2 = __webpack_require__(70);

  var _CircleImageBase3 = _interopRequireDefault(_CircleImageBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var CircularImage = function (_CircleImageBase) {
    _inherits(CircularImage, _CircleImageBase);

    function CircularImage(options, body, labelModule, imageObj) {
      _classCallCheck(this, CircularImage);

      var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(CircularImage).call(this, options, body, labelModule));

      _this.imageObj = imageObj;
      _this._swapToImageResizeWhenImageLoaded = true;
      return _this;
    }

    _createClass(CircularImage, [{
      key: 'resize',
      value: function resize() {
        if (this.imageObj.src === undefined || this.imageObj.width === undefined || this.imageObj.height === undefined) {
          if (!this.width) {
            var diameter = this.options.size * 2;
            this.width = diameter;
            this.height = diameter;
            this._swapToImageResizeWhenImageLoaded = true;
            this.radius = 0.5 * this.width;
          }
        } else {
          if (this._swapToImageResizeWhenImageLoaded) {
            this.width = undefined;
            this.height = undefined;
            this._swapToImageResizeWhenImageLoaded = false;
          }
          this._resizeImage();
        }
      }
    }, {
      key: 'draw',
      value: function draw(ctx, x, y, selected, hover) {
        this.resize();

        this.left = x - this.width / 2;
        this.top = y - this.height / 2;

        var size = Math.min(0.5 * this.height, 0.5 * this.width);

        // draw the background circle. IMPORTANT: the stroke in this method is used by the clip method below.
        this._drawRawCircle(ctx, x, y, selected, hover, size);

        // now we draw in the circle, we save so we can revert the clip operation after drawing.
        ctx.save();
        // clip is used to use the stroke in drawRawCircle as an area that we can draw in.
        ctx.clip();
        // draw the image
        this._drawImageAtPosition(ctx);
        // restore so we can again draw on the full canvas
        ctx.restore();

        this._drawImageLabel(ctx, x, y, selected);

        this.updateBoundingBox(x, y);
      }
    }, {
      key: 'updateBoundingBox',
      value: function updateBoundingBox(x, y) {
        this.boundingBox.top = y - this.options.size;
        this.boundingBox.left = x - this.options.size;
        this.boundingBox.right = x + this.options.size;
        this.boundingBox.bottom = y + this.options.size;
        this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
        this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
        this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelOffset);
      }
    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        this.resize(ctx);
        return this.width * 0.5;
      }
    }]);

    return CircularImage;
  }(_CircleImageBase3.default);

  exports.default = CircularImage;

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _NodeBase2 = __webpack_require__(68);

  var _NodeBase3 = _interopRequireDefault(_NodeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var Database = function (_NodeBase) {
    _inherits(Database, _NodeBase);

    function Database(options, body, labelModule) {
      _classCallCheck(this, Database);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(Database).call(this, options, body, labelModule));
    }

    _createClass(Database, [{
      key: 'resize',
      value: function resize(ctx, selected) {
        if (this.width === undefined) {
          var margin = 5;
          var textSize = this.labelModule.getTextSize(ctx, selected);
          var size = textSize.width + 2 * margin;
          this.width = size;
          this.height = size;
          this.radius = 0.5 * this.width;
        }
      }
    }, {
      key: 'draw',
      value: function draw(ctx, x, y, selected, hover) {
        this.resize(ctx, selected);
        this.left = x - this.width / 2;
        this.top = y - this.height / 2;

        var neutralborderWidth = this.options.borderWidth;
        var selectionLineWidth = this.options.borderWidthSelected || 2 * this.options.borderWidth;
        var borderWidth = (selected ? selectionLineWidth : neutralborderWidth) / this.body.view.scale;
        ctx.lineWidth = Math.min(this.width, borderWidth);

        ctx.strokeStyle = selected ? this.options.color.highlight.border : hover ? this.options.color.hover.border : this.options.color.border;

        ctx.fillStyle = selected ? this.options.color.highlight.background : hover ? this.options.color.hover.background : this.options.color.background;
        ctx.database(x - this.width / 2, y - this.height * 0.5, this.width, this.height);

        // draw shadow if enabled
        this.enableShadow(ctx);
        // draw the background
        ctx.fill();
        // disable shadows for other elements.
        this.disableShadow(ctx);

        //draw dashed border if enabled, save and restore is required for firefox not to crash on unix.
        ctx.save();
        // if borders are zero width, they will be drawn with width 1 by default. This prevents that
        if (borderWidth > 0) {
          this.enableBorderDashes(ctx);
          //draw the border
          ctx.stroke();
          //disable dashed border for other elements
          this.disableBorderDashes(ctx);
        }
        ctx.restore();

        this.updateBoundingBox(x, y, ctx, selected);
        this.labelModule.draw(ctx, x, y, selected);
      }
    }, {
      key: 'updateBoundingBox',
      value: function updateBoundingBox(x, y, ctx, selected) {
        this.resize(ctx, selected);

        this.left = x - this.width * 0.5;
        this.top = y - this.height * 0.5;

        this.boundingBox.left = this.left;
        this.boundingBox.top = this.top;
        this.boundingBox.bottom = this.top + this.height;
        this.boundingBox.right = this.left + this.width;
      }
    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        return this._distanceToBorder(ctx, angle);
      }
    }]);

    return Database;
  }(_NodeBase3.default);

  exports.default = Database;

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _ShapeBase2 = __webpack_require__(74);

  var _ShapeBase3 = _interopRequireDefault(_ShapeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var Diamond = function (_ShapeBase) {
    _inherits(Diamond, _ShapeBase);

    function Diamond(options, body, labelModule) {
      _classCallCheck(this, Diamond);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(Diamond).call(this, options, body, labelModule));
    }

    _createClass(Diamond, [{
      key: 'resize',
      value: function resize(ctx) {
        this._resizeShape();
      }
    }, {
      key: 'draw',
      value: function draw(ctx, x, y, selected, hover) {
        this._drawShape(ctx, 'diamond', 4, x, y, selected, hover);
      }
    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        return this._distanceToBorder(ctx, angle);
      }
    }]);

    return Diamond;
  }(_ShapeBase3.default);

  exports.default = Diamond;

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _NodeBase2 = __webpack_require__(68);

  var _NodeBase3 = _interopRequireDefault(_NodeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var ShapeBase = function (_NodeBase) {
    _inherits(ShapeBase, _NodeBase);

    function ShapeBase(options, body, labelModule) {
      _classCallCheck(this, ShapeBase);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(ShapeBase).call(this, options, body, labelModule));
    }

    _createClass(ShapeBase, [{
      key: '_resizeShape',
      value: function _resizeShape() {
        if (this.width === undefined) {
          var size = 2 * this.options.size;
          this.width = size;
          this.height = size;
          this.radius = 0.5 * this.width;
        }
      }
    }, {
      key: '_drawShape',
      value: function _drawShape(ctx, shape, sizeMultiplier, x, y, selected, hover) {
        this._resizeShape();

        this.left = x - this.width / 2;
        this.top = y - this.height / 2;

        var neutralborderWidth = this.options.borderWidth;
        var selectionLineWidth = this.options.borderWidthSelected || 2 * this.options.borderWidth;
        var borderWidth = (selected ? selectionLineWidth : neutralborderWidth) / this.body.view.scale;
        ctx.lineWidth = Math.min(this.width, borderWidth);

        ctx.strokeStyle = selected ? this.options.color.highlight.border : hover ? this.options.color.hover.border : this.options.color.border;
        ctx.fillStyle = selected ? this.options.color.highlight.background : hover ? this.options.color.hover.background : this.options.color.background;
        ctx[shape](x, y, this.options.size);

        // draw shadow if enabled
        this.enableShadow(ctx);
        // draw the background
        ctx.fill();
        // disable shadows for other elements.
        this.disableShadow(ctx);

        //draw dashed border if enabled, save and restore is required for firefox not to crash on unix.
        ctx.save();
        // if borders are zero width, they will be drawn with width 1 by default. This prevents that
        if (borderWidth > 0) {
          this.enableBorderDashes(ctx);
          //draw the border
          ctx.stroke();
          //disable dashed border for other elements
          this.disableBorderDashes(ctx);
        }
        ctx.restore();

        if (this.options.label !== undefined) {
          var yLabel = y + 0.5 * this.height + 3; // the + 3 is to offset it a bit below the node.
          this.labelModule.draw(ctx, x, yLabel, selected, 'hanging');
        }

        this.updateBoundingBox(x, y);
      }
    }, {
      key: 'updateBoundingBox',
      value: function updateBoundingBox(x, y) {
        this.boundingBox.top = y - this.options.size;
        this.boundingBox.left = x - this.options.size;
        this.boundingBox.right = x + this.options.size;
        this.boundingBox.bottom = y + this.options.size;

        if (this.options.label !== undefined && this.labelModule.size.width > 0) {
          this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
          this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
          this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelModule.size.height + 3);
        }
      }
    }]);

    return ShapeBase;
  }(_NodeBase3.default);

  exports.default = ShapeBase;

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _ShapeBase2 = __webpack_require__(74);

  var _ShapeBase3 = _interopRequireDefault(_ShapeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var Dot = function (_ShapeBase) {
    _inherits(Dot, _ShapeBase);

    function Dot(options, body, labelModule) {
      _classCallCheck(this, Dot);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(Dot).call(this, options, body, labelModule));
    }

    _createClass(Dot, [{
      key: 'resize',
      value: function resize(ctx) {
        this._resizeShape();
      }
    }, {
      key: 'draw',
      value: function draw(ctx, x, y, selected, hover) {
        this._drawShape(ctx, 'circle', 2, x, y, selected, hover);
      }
    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        this.resize(ctx);
        return this.options.size;
      }
    }]);

    return Dot;
  }(_ShapeBase3.default);

  exports.default = Dot;

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _NodeBase2 = __webpack_require__(68);

  var _NodeBase3 = _interopRequireDefault(_NodeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var Ellipse = function (_NodeBase) {
    _inherits(Ellipse, _NodeBase);

    function Ellipse(options, body, labelModule) {
      _classCallCheck(this, Ellipse);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(Ellipse).call(this, options, body, labelModule));
    }

    _createClass(Ellipse, [{
      key: 'resize',
      value: function resize(ctx, selected) {
        if (this.width === undefined) {
          var textSize = this.labelModule.getTextSize(ctx, selected);

          this.width = textSize.width * 1.5;
          this.height = textSize.height * 2;
          if (this.width < this.height) {
            this.width = this.height;
          }
          this.radius = 0.5 * this.width;
        }
      }
    }, {
      key: 'draw',
      value: function draw(ctx, x, y, selected, hover) {
        this.resize(ctx, selected);
        this.left = x - this.width * 0.5;
        this.top = y - this.height * 0.5;

        var neutralborderWidth = this.options.borderWidth;
        var selectionLineWidth = this.options.borderWidthSelected || 2 * this.options.borderWidth;
        var borderWidth = (selected ? selectionLineWidth : neutralborderWidth) / this.body.view.scale;
        ctx.lineWidth = Math.min(this.width, borderWidth);

        ctx.strokeStyle = selected ? this.options.color.highlight.border : hover ? this.options.color.hover.border : this.options.color.border;

        ctx.fillStyle = selected ? this.options.color.highlight.background : hover ? this.options.color.hover.background : this.options.color.background;
        ctx.ellipse(this.left, this.top, this.width, this.height);

        // draw shadow if enabled
        this.enableShadow(ctx);
        // draw the background
        ctx.fill();
        // disable shadows for other elements.
        this.disableShadow(ctx);

        //draw dashed border if enabled, save and restore is required for firefox not to crash on unix.
        ctx.save();

        // if borders are zero width, they will be drawn with width 1 by default. This prevents that
        if (borderWidth > 0) {
          this.enableBorderDashes(ctx);
          //draw the border
          ctx.stroke();
          //disable dashed border for other elements
          this.disableBorderDashes(ctx);
        }

        ctx.restore();

        this.updateBoundingBox(x, y, ctx, selected);
        this.labelModule.draw(ctx, x, y, selected);
      }
    }, {
      key: 'updateBoundingBox',
      value: function updateBoundingBox(x, y, ctx, selected) {
        this.resize(ctx, selected); // just in case

        this.left = x - this.width * 0.5;
        this.top = y - this.height * 0.5;

        this.boundingBox.left = this.left;
        this.boundingBox.top = this.top;
        this.boundingBox.bottom = this.top + this.height;
        this.boundingBox.right = this.left + this.width;
      }
    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        this.resize(ctx);
        var a = this.width * 0.5;
        var b = this.height * 0.5;
        var w = Math.sin(angle) * a;
        var h = Math.cos(angle) * b;
        return a * b / Math.sqrt(w * w + h * h);
      }
    }]);

    return Ellipse;
  }(_NodeBase3.default);

  exports.default = Ellipse;

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _NodeBase2 = __webpack_require__(68);

  var _NodeBase3 = _interopRequireDefault(_NodeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var Icon = function (_NodeBase) {
    _inherits(Icon, _NodeBase);

    function Icon(options, body, labelModule) {
      _classCallCheck(this, Icon);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(Icon).call(this, options, body, labelModule));
    }

    _createClass(Icon, [{
      key: 'resize',
      value: function resize(ctx) {
        if (this.width === undefined) {
          var margin = 5;
          var iconSize = {
            width: Number(this.options.icon.size),
            height: Number(this.options.icon.size)
          };
          this.width = iconSize.width + 2 * margin;
          this.height = iconSize.height + 2 * margin;
          this.radius = 0.5 * this.width;
        }
      }
    }, {
      key: 'draw',
      value: function draw(ctx, x, y, selected, hover) {
        this.resize(ctx);
        this.options.icon.size = this.options.icon.size || 50;

        this.left = x - this.width * 0.5;
        this.top = y - this.height * 0.5;
        this._icon(ctx, x, y, selected);

        if (this.options.label !== undefined) {
          var iconTextSpacing = 5;
          this.labelModule.draw(ctx, x, y + this.height * 0.5 + iconTextSpacing, selected);
        }

        this.updateBoundingBox(x, y);
      }
    }, {
      key: 'updateBoundingBox',
      value: function updateBoundingBox(x, y) {
        this.boundingBox.top = y - this.options.icon.size * 0.5;
        this.boundingBox.left = x - this.options.icon.size * 0.5;
        this.boundingBox.right = x + this.options.icon.size * 0.5;
        this.boundingBox.bottom = y + this.options.icon.size * 0.5;

        if (this.options.label !== undefined && this.labelModule.size.width > 0) {
          var iconTextSpacing = 5;
          this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
          this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
          this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelModule.size.height + iconTextSpacing);
        }
      }
    }, {
      key: '_icon',
      value: function _icon(ctx, x, y, selected) {
        var iconSize = Number(this.options.icon.size);

        if (this.options.icon.code !== undefined) {
          ctx.font = (selected ? "bold " : "") + iconSize + "px " + this.options.icon.face;

          // draw icon
          ctx.fillStyle = this.options.icon.color || "black";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";

          // draw shadow if enabled
          this.enableShadow(ctx);
          ctx.fillText(this.options.icon.code, x, y);

          // disable shadows for other elements.
          this.disableShadow(ctx);
        } else {
          console.error('When using the icon shape, you need to define the code in the icon options object. This can be done per node or globally.');
        }
      }
    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        return this._distanceToBorder(ctx, angle);
      }
    }]);

    return Icon;
  }(_NodeBase3.default);

  exports.default = Icon;

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _CircleImageBase2 = __webpack_require__(70);

  var _CircleImageBase3 = _interopRequireDefault(_CircleImageBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var Image = function (_CircleImageBase) {
    _inherits(Image, _CircleImageBase);

    function Image(options, body, labelModule, imageObj) {
      _classCallCheck(this, Image);

      var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Image).call(this, options, body, labelModule));

      _this.imageObj = imageObj;
      return _this;
    }

    _createClass(Image, [{
      key: 'resize',
      value: function resize() {
        this._resizeImage();
      }
    }, {
      key: 'draw',
      value: function draw(ctx, x, y, selected, hover) {
        this.resize();
        this.left = x - this.width / 2;
        this.top = y - this.height / 2;

        if (this.options.shapeProperties.useBorderWithImage === true) {
          var neutralborderWidth = this.options.borderWidth;
          var selectionLineWidth = this.options.borderWidthSelected || 2 * this.options.borderWidth;
          var borderWidth = (selected ? selectionLineWidth : neutralborderWidth) / this.body.view.scale;
          ctx.lineWidth = Math.min(this.width, borderWidth);

          ctx.beginPath();

          // setup the line properties.
          ctx.strokeStyle = selected ? this.options.color.highlight.border : hover ? this.options.color.hover.border : this.options.color.border;

          // set a fillstyle
          ctx.fillStyle = selected ? this.options.color.highlight.background : hover ? this.options.color.hover.background : this.options.color.background;

          // draw a rectangle to form the border around. This rectangle is filled so the opacity of a picture (in future vis releases?) can be used to tint the image
          ctx.rect(this.left - 0.5 * ctx.lineWidth, this.top - 0.5 * ctx.lineWidth, this.width + ctx.lineWidth, this.height + ctx.lineWidth);
          ctx.fill();

          //draw dashed border if enabled, save and restore is required for firefox not to crash on unix.
          ctx.save();
          // if borders are zero width, they will be drawn with width 1 by default. This prevents that
          if (borderWidth > 0) {
            this.enableBorderDashes(ctx);
            //draw the border
            ctx.stroke();
            //disable dashed border for other elements
            this.disableBorderDashes(ctx);
          }
          ctx.restore();

          ctx.closePath();
        }

        this._drawImageAtPosition(ctx);

        this._drawImageLabel(ctx, x, y, selected || hover);

        this.updateBoundingBox(x, y);
      }
    }, {
      key: 'updateBoundingBox',
      value: function updateBoundingBox(x, y) {
        this.resize();
        this.left = x - this.width / 2;
        this.top = y - this.height / 2;

        this.boundingBox.top = this.top;
        this.boundingBox.left = this.left;
        this.boundingBox.right = this.left + this.width;
        this.boundingBox.bottom = this.top + this.height;

        if (this.options.label !== undefined && this.labelModule.size.width > 0) {
          this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
          this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
          this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelOffset);
        }
      }
    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        return this._distanceToBorder(ctx, angle);
      }
    }]);

    return Image;
  }(_CircleImageBase3.default);

  exports.default = Image;

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _ShapeBase2 = __webpack_require__(74);

  var _ShapeBase3 = _interopRequireDefault(_ShapeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var Square = function (_ShapeBase) {
    _inherits(Square, _ShapeBase);

    function Square(options, body, labelModule) {
      _classCallCheck(this, Square);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(Square).call(this, options, body, labelModule));
    }

    _createClass(Square, [{
      key: 'resize',
      value: function resize() {
        this._resizeShape();
      }
    }, {
      key: 'draw',
      value: function draw(ctx, x, y, selected, hover) {
        this._drawShape(ctx, 'square', 2, x, y, selected, hover);
      }
    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        return this._distanceToBorder(ctx, angle);
      }
    }]);

    return Square;
  }(_ShapeBase3.default);

  exports.default = Square;

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _ShapeBase2 = __webpack_require__(74);

  var _ShapeBase3 = _interopRequireDefault(_ShapeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var Star = function (_ShapeBase) {
    _inherits(Star, _ShapeBase);

    function Star(options, body, labelModule) {
      _classCallCheck(this, Star);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(Star).call(this, options, body, labelModule));
    }

    _createClass(Star, [{
      key: 'resize',
      value: function resize(ctx) {
        this._resizeShape();
      }
    }, {
      key: 'draw',
      value: function draw(ctx, x, y, selected, hover) {
        this._drawShape(ctx, 'star', 4, x, y, selected, hover);
      }
    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        return this._distanceToBorder(ctx, angle);
      }
    }]);

    return Star;
  }(_ShapeBase3.default);

  exports.default = Star;

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _NodeBase2 = __webpack_require__(68);

  var _NodeBase3 = _interopRequireDefault(_NodeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var Text = function (_NodeBase) {
    _inherits(Text, _NodeBase);

    function Text(options, body, labelModule) {
      _classCallCheck(this, Text);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(Text).call(this, options, body, labelModule));
    }

    _createClass(Text, [{
      key: 'resize',
      value: function resize(ctx, selected) {
        if (this.width === undefined) {
          var margin = 5;
          var textSize = this.labelModule.getTextSize(ctx, selected);
          this.width = textSize.width + 2 * margin;
          this.height = textSize.height + 2 * margin;
          this.radius = 0.5 * this.width;
        }
      }
    }, {
      key: 'draw',
      value: function draw(ctx, x, y, selected, hover) {
        this.resize(ctx, selected || hover);
        this.left = x - this.width / 2;
        this.top = y - this.height / 2;

        // draw shadow if enabled
        this.enableShadow(ctx);
        this.labelModule.draw(ctx, x, y, selected || hover);

        // disable shadows for other elements.
        this.disableShadow(ctx);

        this.updateBoundingBox(x, y, ctx, selected);
      }
    }, {
      key: 'updateBoundingBox',
      value: function updateBoundingBox(x, y, ctx, selected) {
        this.resize(ctx, selected);

        this.left = x - this.width / 2;
        this.top = y - this.height / 2;

        this.boundingBox.top = this.top;
        this.boundingBox.left = this.left;
        this.boundingBox.right = this.left + this.width;
        this.boundingBox.bottom = this.top + this.height;
      }
    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        return this._distanceToBorder(ctx, angle);
      }
    }]);

    return Text;
  }(_NodeBase3.default);

  exports.default = Text;

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _ShapeBase2 = __webpack_require__(74);

  var _ShapeBase3 = _interopRequireDefault(_ShapeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var Triangle = function (_ShapeBase) {
    _inherits(Triangle, _ShapeBase);

    function Triangle(options, body, labelModule) {
      _classCallCheck(this, Triangle);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(Triangle).call(this, options, body, labelModule));
    }

    _createClass(Triangle, [{
      key: 'resize',
      value: function resize(ctx) {
        this._resizeShape();
      }
    }, {
      key: 'draw',
      value: function draw(ctx, x, y, selected, hover) {
        this._drawShape(ctx, 'triangle', 3, x, y, selected, hover);
      }
    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        return this._distanceToBorder(ctx, angle);
      }
    }]);

    return Triangle;
  }(_ShapeBase3.default);

  exports.default = Triangle;

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _ShapeBase2 = __webpack_require__(74);

  var _ShapeBase3 = _interopRequireDefault(_ShapeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var TriangleDown = function (_ShapeBase) {
    _inherits(TriangleDown, _ShapeBase);

    function TriangleDown(options, body, labelModule) {
      _classCallCheck(this, TriangleDown);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(TriangleDown).call(this, options, body, labelModule));
    }

    _createClass(TriangleDown, [{
      key: 'resize',
      value: function resize(ctx) {
        this._resizeShape();
      }
    }, {
      key: 'draw',
      value: function draw(ctx, x, y, selected, hover) {
        this._drawShape(ctx, 'triangleDown', 3, x, y, selected, hover);
      }
    }, {
      key: 'distanceToBorder',
      value: function distanceToBorder(ctx, angle) {
        return this._distanceToBorder(ctx, angle);
      }
    }]);

    return TriangleDown;
  }(_ShapeBase3.default);

  exports.default = TriangleDown;

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _Edge = __webpack_require__(85);

  var _Edge2 = _interopRequireDefault(_Edge);

  var _Label = __webpack_require__(66);

  var _Label2 = _interopRequireDefault(_Label);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);
  var DataSet = __webpack_require__(9);
  var DataView = __webpack_require__(11);

  var EdgesHandler = function () {
    function EdgesHandler(body, images, groups) {
      var _this = this;

      _classCallCheck(this, EdgesHandler);

      this.body = body;
      this.images = images;
      this.groups = groups;

      // create the edge API in the body container
      this.body.functions.createEdge = this.create.bind(this);

      this.edgesListeners = {
        add: function add(event, params) {
          _this.add(params.items);
        },
        update: function update(event, params) {
          _this.update(params.items);
        },
        remove: function remove(event, params) {
          _this.remove(params.items);
        }
      };

      this.options = {};
      this.defaultOptions = {
        arrows: {
          to: { enabled: false, scaleFactor: 1 }, // boolean / {arrowScaleFactor:1} / {enabled: false, arrowScaleFactor:1}
          middle: { enabled: false, scaleFactor: 1 },
          from: { enabled: false, scaleFactor: 1 }
        },
        arrowStrikethrough: true,
        color: {
          color: '#848484',
          highlight: '#848484',
          hover: '#848484',
          inherit: 'from',
          opacity: 1.0
        },
        dashes: false,
        font: {
          color: '#343434',
          size: 14, // px
          face: 'arial',
          background: 'none',
          strokeWidth: 2, // px
          strokeColor: '#ffffff',
          align: 'horizontal'
        },
        hidden: false,
        hoverWidth: 1.5,
        label: undefined,
        labelHighlightBold: true,
        length: undefined,
        physics: true,
        scaling: {
          min: 1,
          max: 15,
          label: {
            enabled: true,
            min: 14,
            max: 30,
            maxVisible: 30,
            drawThreshold: 5
          },
          customScalingFunction: function customScalingFunction(min, max, total, value) {
            if (max === min) {
              return 0.5;
            } else {
              var scale = 1 / (max - min);
              return Math.max(0, (value - min) * scale);
            }
          }
        },
        selectionWidth: 1.5,
        selfReferenceSize: 20,
        shadow: {
          enabled: false,
          color: 'rgba(0,0,0,0.5)',
          size: 10,
          x: 5,
          y: 5
        },
        smooth: {
          enabled: true,
          type: "dynamic",
          forceDirection: 'none',
          roundness: 0.5
        },
        title: undefined,
        width: 1,
        value: undefined
      };

      util.extend(this.options, this.defaultOptions);

      this.bindEventListeners();
    }

    _createClass(EdgesHandler, [{
      key: 'bindEventListeners',
      value: function bindEventListeners() {
        var _this2 = this;

        // this allows external modules to force all dynamic curves to turn static.
        this.body.emitter.on("_forceDisableDynamicCurves", function (type) {
          if (type === 'dynamic') {
            type = 'continuous';
          }
          var emitChange = false;
          for (var edgeId in _this2.body.edges) {
            if (_this2.body.edges.hasOwnProperty(edgeId)) {
              var edge = _this2.body.edges[edgeId];
              var edgeData = _this2.body.data.edges._data[edgeId];

              // only forcibly remove the smooth curve if the data has been set of the edge has the smooth curves defined.
              // this is because a change in the global would not affect these curves.
              if (edgeData !== undefined) {
                var edgeOptions = edgeData.smooth;
                if (edgeOptions !== undefined) {
                  if (edgeOptions.enabled === true && edgeOptions.type === 'dynamic') {
                    if (type === undefined) {
                      edge.setOptions({ smooth: false });
                    } else {
                      edge.setOptions({ smooth: { type: type } });
                    }
                    emitChange = true;
                  }
                }
              }
            }
          }
          if (emitChange === true) {
            _this2.body.emitter.emit("_dataChanged");
          }
        });

        // this is called when options of EXISTING nodes or edges have changed.
        this.body.emitter.on("_dataUpdated", function () {
          _this2.reconnectEdges();
          _this2.markAllEdgesAsDirty();
        });

        // refresh the edges. Used when reverting from hierarchical layout
        this.body.emitter.on("refreshEdges", this.refresh.bind(this));
        this.body.emitter.on("refresh", this.refresh.bind(this));
        this.body.emitter.on("destroy", function () {
          util.forEach(_this2.edgesListeners, function (callback, event) {
            if (_this2.body.data.edges) _this2.body.data.edges.off(event, callback);
          });
          delete _this2.body.functions.createEdge;
          delete _this2.edgesListeners.add;
          delete _this2.edgesListeners.update;
          delete _this2.edgesListeners.remove;
          delete _this2.edgesListeners;
        });
      }
    }, {
      key: 'setOptions',
      value: function setOptions(options) {
        if (options !== undefined) {
          // use the parser from the Edge class to fill in all shorthand notations
          _Edge2.default.parseOptions(this.options, options);

          // handle multiple input cases for color
          if (options.color !== undefined) {
            this.markAllEdgesAsDirty();
          }

          // update smooth settings in all edges
          var dataChanged = false;
          if (options.smooth !== undefined) {
            for (var edgeId in this.body.edges) {
              if (this.body.edges.hasOwnProperty(edgeId)) {
                dataChanged = this.body.edges[edgeId].updateEdgeType() || dataChanged;
              }
            }
          }

          // update fonts in all edges
          if (options.font !== undefined) {
            // use the parser from the Label class to fill in all shorthand notations
            _Label2.default.parseOptions(this.options.font, options);
            for (var _edgeId in this.body.edges) {
              if (this.body.edges.hasOwnProperty(_edgeId)) {
                this.body.edges[_edgeId].updateLabelModule();
              }
            }
          }

          // update the state of the variables if needed
          if (options.hidden !== undefined || options.physics !== undefined || dataChanged === true) {
            this.body.emitter.emit('_dataChanged');
          }
        }
      }

      /**
       * Load edges by reading the data table
       * @param {Array | DataSet | DataView} edges    The data containing the edges.
       * @private
       * @private
       */

    }, {
      key: 'setData',
      value: function setData(edges) {
        var _this3 = this;

        var doNotEmit = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

        var oldEdgesData = this.body.data.edges;

        if (edges instanceof DataSet || edges instanceof DataView) {
          this.body.data.edges = edges;
        } else if (Array.isArray(edges)) {
          this.body.data.edges = new DataSet();
          this.body.data.edges.add(edges);
        } else if (!edges) {
          this.body.data.edges = new DataSet();
        } else {
          throw new TypeError('Array or DataSet expected');
        }

        // TODO: is this null or undefined or false?
        if (oldEdgesData) {
          // unsubscribe from old dataset
          util.forEach(this.edgesListeners, function (callback, event) {
            oldEdgesData.off(event, callback);
          });
        }

        // remove drawn edges
        this.body.edges = {};

        // TODO: is this null or undefined or false?
        if (this.body.data.edges) {
          // subscribe to new dataset
          util.forEach(this.edgesListeners, function (callback, event) {
            _this3.body.data.edges.on(event, callback);
          });

          // draw all new nodes
          var ids = this.body.data.edges.getIds();
          this.add(ids, true);
        }

        if (doNotEmit === false) {
          this.body.emitter.emit("_dataChanged");
        }
      }

      /**
       * Add edges
       * @param {Number[] | String[]} ids
       * @private
       */

    }, {
      key: 'add',
      value: function add(ids) {
        var doNotEmit = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

        var edges = this.body.edges;
        var edgesData = this.body.data.edges;

        for (var i = 0; i < ids.length; i++) {
          var id = ids[i];

          var oldEdge = edges[id];
          if (oldEdge) {
            oldEdge.disconnect();
          }

          var data = edgesData.get(id, { "showInternalIds": true });
          edges[id] = this.create(data);
        }

        if (doNotEmit === false) {
          this.body.emitter.emit("_dataChanged");
        }
      }

      /**
       * Update existing edges, or create them when not yet existing
       * @param {Number[] | String[]} ids
       * @private
       */

    }, {
      key: 'update',
      value: function update(ids) {
        var edges = this.body.edges;
        var edgesData = this.body.data.edges;
        var dataChanged = false;
        for (var i = 0; i < ids.length; i++) {
          var id = ids[i];
          var data = edgesData.get(id);
          var edge = edges[id];
          if (edge !== undefined) {
            // update edge
            edge.disconnect();
            dataChanged = edge.setOptions(data) || dataChanged; // if a support node is added, data can be changed.
            edge.connect();
          } else {
            // create edge
            this.body.edges[id] = this.create(data);
            dataChanged = true;
          }
        }

        if (dataChanged === true) {
          this.body.emitter.emit("_dataChanged");
        } else {
          this.body.emitter.emit("_dataUpdated");
        }
      }

      /**
       * Remove existing edges. Non existing ids will be ignored
       * @param {Number[] | String[]} ids
       * @private
       */

    }, {
      key: 'remove',
      value: function remove(ids) {
        var edges = this.body.edges;
        for (var i = 0; i < ids.length; i++) {
          var id = ids[i];
          var edge = edges[id];
          if (edge !== undefined) {
            edge.cleanup();
            edge.disconnect();
            delete edges[id];
          }
        }

        this.body.emitter.emit("_dataChanged");
      }
    }, {
      key: 'refresh',
      value: function refresh() {
        var edges = this.body.edges;
        for (var edgeId in edges) {
          var edge = undefined;
          if (edges.hasOwnProperty(edgeId)) {
            edge = edges[edgeId];
          }
          var data = this.body.data.edges._data[edgeId];
          if (edge !== undefined && data !== undefined) {
            edge.setOptions(data);
          }
        }
      }
    }, {
      key: 'create',
      value: function create(properties) {
        return new _Edge2.default(properties, this.body, this.options);
      }
    }, {
      key: 'markAllEdgesAsDirty',
      value: function markAllEdgesAsDirty() {
        for (var edgeId in this.body.edges) {
          this.body.edges[edgeId].edgeType.colorDirty = true;
        }
      }

      /**
       * Reconnect all edges
       * @private
       */

    }, {
      key: 'reconnectEdges',
      value: function reconnectEdges() {
        var id;
        var nodes = this.body.nodes;
        var edges = this.body.edges;

        for (id in nodes) {
          if (nodes.hasOwnProperty(id)) {
            nodes[id].edges = [];
          }
        }

        for (id in edges) {
          if (edges.hasOwnProperty(id)) {
            var edge = edges[id];
            edge.from = null;
            edge.to = null;
            edge.connect();
          }
        }
      }
    }, {
      key: 'getConnectedNodes',
      value: function getConnectedNodes(edgeId) {
        var nodeList = [];
        if (this.body.edges[edgeId] !== undefined) {
          var edge = this.body.edges[edgeId];
          if (edge.fromId) {
            nodeList.push(edge.fromId);
          }
          if (edge.toId) {
            nodeList.push(edge.toId);
          }
        }
        return nodeList;
      }
    }]);

    return EdgesHandler;
  }();

  exports.default = EdgesHandler;

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _Label = __webpack_require__(66);

  var _Label2 = _interopRequireDefault(_Label);

  var _CubicBezierEdge = __webpack_require__(86);

  var _CubicBezierEdge2 = _interopRequireDefault(_CubicBezierEdge);

  var _BezierEdgeDynamic = __webpack_require__(90);

  var _BezierEdgeDynamic2 = _interopRequireDefault(_BezierEdgeDynamic);

  var _BezierEdgeStatic = __webpack_require__(91);

  var _BezierEdgeStatic2 = _interopRequireDefault(_BezierEdgeStatic);

  var _StraightEdge = __webpack_require__(92);

  var _StraightEdge2 = _interopRequireDefault(_StraightEdge);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);

  /**
   * @class Edge
   *
   * A edge connects two nodes
   * @param {Object} properties     Object with options. Must contain
   *                                At least options from and to.
   *                                Available options: from (number),
   *                                to (number), label (string, color (string),
   *                                width (number), style (string),
   *                                length (number), title (string)
   * @param {Network} network       A Network object, used to find and edge to
   *                                nodes.
   * @param {Object} constants      An object with default values for
   *                                example for the color
   */

  var Edge = function () {
    function Edge(options, body, globalOptions) {
      _classCallCheck(this, Edge);

      if (body === undefined) {
        throw "No body provided";
      }
      this.options = util.bridgeObject(globalOptions);
      this.globalOptions = globalOptions;
      this.body = body;

      // initialize variables
      this.id = undefined;
      this.fromId = undefined;
      this.toId = undefined;
      this.selected = false;
      this.hover = false;
      this.labelDirty = true;
      this.colorDirty = true;

      this.baseWidth = this.options.width;
      this.baseFontSize = this.options.font.size;

      this.from = undefined; // a node
      this.to = undefined; // a node

      this.edgeType = undefined;

      this.connected = false;

      this.labelModule = new _Label2.default(this.body, this.options, true /* It's an edge label */);

      this.setOptions(options);
    }

    /**
     * Set or overwrite options for the edge
     * @param {Object} options  an object with options
     * @param doNotEmit
     */


    _createClass(Edge, [{
      key: 'setOptions',
      value: function setOptions(options) {
        if (!options) {
          return;
        }
        this.colorDirty = true;

        Edge.parseOptions(this.options, options, true, this.globalOptions);

        if (options.id !== undefined) {
          this.id = options.id;
        }
        if (options.from !== undefined) {
          this.fromId = options.from;
        }
        if (options.to !== undefined) {
          this.toId = options.to;
        }
        if (options.title !== undefined) {
          this.title = options.title;
        }
        if (options.value !== undefined) {
          options.value = parseFloat(options.value);
        }

        // update label Module
        this.updateLabelModule();

        var dataChanged = this.updateEdgeType();

        // if anything has been updates, reset the selection width and the hover width
        this._setInteractionWidths();

        // A node is connected when it has a from and to node that both exist in the network.body.nodes.
        this.connect();

        if (options.hidden !== undefined || options.physics !== undefined) {
          dataChanged = true;
        }

        return dataChanged;
      }
    }, {
      key: 'updateLabelModule',
      // set the object back to the global options


      /**
       * update the options in the label module
       */
      value: function updateLabelModule() {
        this.labelModule.setOptions(this.options, true);
        if (this.labelModule.baseSize !== undefined) {
          this.baseFontSize = this.labelModule.baseSize;
        }
      }

      /**
       * update the edge type, set the options
       * @returns {boolean}
       */

    }, {
      key: 'updateEdgeType',
      value: function updateEdgeType() {
        var dataChanged = false;
        var changeInType = true;
        var smooth = this.options.smooth;
        if (this.edgeType !== undefined) {
          if (this.edgeType instanceof _BezierEdgeDynamic2.default && smooth.enabled === true && smooth.type === 'dynamic') {
            changeInType = false;
          }
          if (this.edgeType instanceof _CubicBezierEdge2.default && smooth.enabled === true && smooth.type === 'cubicBezier') {
            changeInType = false;
          }
          if (this.edgeType instanceof _BezierEdgeStatic2.default && smooth.enabled === true && smooth.type !== 'dynamic' && smooth.type !== 'cubicBezier') {
            changeInType = false;
          }
          if (this.edgeType instanceof _StraightEdge2.default && smooth.enabled === false) {
            changeInType = false;
          }

          if (changeInType === true) {
            dataChanged = this.cleanup();
          }
        }

        if (changeInType === true) {
          if (this.options.smooth.enabled === true) {
            if (this.options.smooth.type === 'dynamic') {
              dataChanged = true;
              this.edgeType = new _BezierEdgeDynamic2.default(this.options, this.body, this.labelModule);
            } else if (this.options.smooth.type === 'cubicBezier') {
              this.edgeType = new _CubicBezierEdge2.default(this.options, this.body, this.labelModule);
            } else {
              this.edgeType = new _BezierEdgeStatic2.default(this.options, this.body, this.labelModule);
            }
          } else {
            this.edgeType = new _StraightEdge2.default(this.options, this.body, this.labelModule);
          }
        } else {
          // if nothing changes, we just set the options.
          this.edgeType.setOptions(this.options);
        }

        return dataChanged;
      }

      /**
       * Connect an edge to its nodes
       */

    }, {
      key: 'connect',
      value: function connect() {
        this.disconnect();

        this.from = this.body.nodes[this.fromId] || undefined;
        this.to = this.body.nodes[this.toId] || undefined;
        this.connected = this.from !== undefined && this.to !== undefined;

        if (this.connected === true) {
          this.from.attachEdge(this);
          this.to.attachEdge(this);
        } else {
          if (this.from) {
            this.from.detachEdge(this);
          }
          if (this.to) {
            this.to.detachEdge(this);
          }
        }

        this.edgeType.connect();
      }

      /**
       * Disconnect an edge from its nodes
       */

    }, {
      key: 'disconnect',
      value: function disconnect() {
        if (this.from) {
          this.from.detachEdge(this);
          this.from = undefined;
        }
        if (this.to) {
          this.to.detachEdge(this);
          this.to = undefined;
        }

        this.connected = false;
      }

      /**
       * get the title of this edge.
       * @return {string} title    The title of the edge, or undefined when no title
       *                           has been set.
       */

    }, {
      key: 'getTitle',
      value: function getTitle() {
        return this.title;
      }

      /**
       * check if this node is selecte
       * @return {boolean} selected   True if node is selected, else false
       */

    }, {
      key: 'isSelected',
      value: function isSelected() {
        return this.selected;
      }

      /**
       * Retrieve the value of the edge. Can be undefined
       * @return {Number} value
       */

    }, {
      key: 'getValue',
      value: function getValue() {
        return this.options.value;
      }

      /**
       * Adjust the value range of the edge. The edge will adjust it's width
       * based on its value.
       * @param {Number} min
       * @param {Number} max
       * @param total
       */

    }, {
      key: 'setValueRange',
      value: function setValueRange(min, max, total) {
        if (this.options.value !== undefined) {
          var scale = this.options.scaling.customScalingFunction(min, max, total, this.options.value);
          var widthDiff = this.options.scaling.max - this.options.scaling.min;
          if (this.options.scaling.label.enabled === true) {
            var fontDiff = this.options.scaling.label.max - this.options.scaling.label.min;
            this.options.font.size = this.options.scaling.label.min + scale * fontDiff;
          }
          this.options.width = this.options.scaling.min + scale * widthDiff;
        } else {
          this.options.width = this.baseWidth;
          this.options.font.size = this.baseFontSize;
        }

        this._setInteractionWidths();
        this.updateLabelModule();
      }
    }, {
      key: '_setInteractionWidths',
      value: function _setInteractionWidths() {
        if (typeof this.options.hoverWidth === 'function') {
          this.edgeType.hoverWidth = this.options.hoverWidth(this.options.width);
        } else {
          this.edgeType.hoverWidth = this.options.hoverWidth + this.options.width;
        }

        if (typeof this.options.selectionWidth === 'function') {
          this.edgeType.selectionWidth = this.options.selectionWidth(this.options.width);
        } else {
          this.edgeType.selectionWidth = this.options.selectionWidth + this.options.width;
        }
      }

      /**
       * Redraw a edge
       * Draw this edge in the given canvas
       * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
       * @param {CanvasRenderingContext2D}   ctx
       */

    }, {
      key: 'draw',
      value: function draw(ctx) {
        // get the via node from the edge type
        var viaNode = this.edgeType.getViaNode();
        var arrowData = {};

        // restore edge targets to defaults
        this.edgeType.fromPoint = this.edgeType.from;
        this.edgeType.toPoint = this.edgeType.to;

        // from and to arrows give a different end point for edges. we set them here
        if (this.options.arrows.from.enabled === true) {
          arrowData.from = this.edgeType.getArrowData(ctx, 'from', viaNode, this.selected, this.hover);
          if (this.options.arrowStrikethrough === false) this.edgeType.fromPoint = arrowData.from.core;
        }
        if (this.options.arrows.to.enabled === true) {
          arrowData.to = this.edgeType.getArrowData(ctx, 'to', viaNode, this.selected, this.hover);
          if (this.options.arrowStrikethrough === false) this.edgeType.toPoint = arrowData.to.core;
        }

        // the middle arrow depends on the line, which can depend on the to and from arrows so we do this one lastly.
        if (this.options.arrows.middle.enabled === true) {
          arrowData.middle = this.edgeType.getArrowData(ctx, 'middle', viaNode, this.selected, this.hover);
        }

        // draw everything
        this.edgeType.drawLine(ctx, this.selected, this.hover, viaNode);
        this.drawArrows(ctx, arrowData);
        this.drawLabel(ctx, viaNode);
      }
    }, {
      key: 'drawArrows',
      value: function drawArrows(ctx, arrowData) {
        if (this.options.arrows.from.enabled === true) {
          this.edgeType.drawArrowHead(ctx, this.selected, this.hover, arrowData.from);
        }
        if (this.options.arrows.middle.enabled === true) {
          this.edgeType.drawArrowHead(ctx, this.selected, this.hover, arrowData.middle);
        }
        if (this.options.arrows.to.enabled === true) {
          this.edgeType.drawArrowHead(ctx, this.selected, this.hover, arrowData.to);
        }
      }
    }, {
      key: 'drawLabel',
      value: function drawLabel(ctx, viaNode) {
        if (this.options.label !== undefined) {
          // set style
          var node1 = this.from;
          var node2 = this.to;
          var selected = this.from.selected || this.to.selected || this.selected;
          if (node1.id != node2.id) {
            this.labelModule.pointToSelf = false;
            var point = this.edgeType.getPoint(0.5, viaNode);
            ctx.save();

            // if the label has to be rotated:
            if (this.options.font.align !== "horizontal") {
              this.labelModule.calculateLabelSize(ctx, selected, point.x, point.y);
              ctx.translate(point.x, this.labelModule.size.yLine);
              this._rotateForLabelAlignment(ctx);
            }

            // draw the label
            this.labelModule.draw(ctx, point.x, point.y, selected);
            ctx.restore();
          } else {
            // Ignore the orientations.
            this.labelModule.pointToSelf = true;
            var x, y;
            var radius = this.options.selfReferenceSize;
            if (node1.shape.width > node1.shape.height) {
              x = node1.x + node1.shape.width * 0.5;
              y = node1.y - radius;
            } else {
              x = node1.x + radius;
              y = node1.y - node1.shape.height * 0.5;
            }
            point = this._pointOnCircle(x, y, radius, 0.125);
            this.labelModule.draw(ctx, point.x, point.y, selected);
          }
        }
      }

      /**
       * Check if this object is overlapping with the provided object
       * @param {Object} obj   an object with parameters left, top
       * @return {boolean}     True if location is located on the edge
       */

    }, {
      key: 'isOverlappingWith',
      value: function isOverlappingWith(obj) {
        if (this.connected) {
          var distMax = 10;
          var xFrom = this.from.x;
          var yFrom = this.from.y;
          var xTo = this.to.x;
          var yTo = this.to.y;
          var xObj = obj.left;
          var yObj = obj.top;

          var dist = this.edgeType.getDistanceToEdge(xFrom, yFrom, xTo, yTo, xObj, yObj);

          return dist < distMax;
        } else {
          return false;
        }
      }

      /**
       * Rotates the canvas so the text is most readable
       * @param {CanvasRenderingContext2D} ctx
       * @private
       */

    }, {
      key: '_rotateForLabelAlignment',
      value: function _rotateForLabelAlignment(ctx) {
        var dy = this.from.y - this.to.y;
        var dx = this.from.x - this.to.x;
        var angleInDegrees = Math.atan2(dy, dx);

        // rotate so label it is readable
        if (angleInDegrees < -1 && dx < 0 || angleInDegrees > 0 && dx < 0) {
          angleInDegrees = angleInDegrees + Math.PI;
        }

        ctx.rotate(angleInDegrees);
      }

      /**
       * Get a point on a circle
       * @param {Number} x
       * @param {Number} y
       * @param {Number} radius
       * @param {Number} percentage. Value between 0 (line start) and 1 (line end)
       * @return {Object} point
       * @private
       */

    }, {
      key: '_pointOnCircle',
      value: function _pointOnCircle(x, y, radius, percentage) {
        var angle = percentage * 2 * Math.PI;
        return {
          x: x + radius * Math.cos(angle),
          y: y - radius * Math.sin(angle)
        };
      }
    }, {
      key: 'select',
      value: function select() {
        this.selected = true;
      }
    }, {
      key: 'unselect',
      value: function unselect() {
        this.selected = false;
      }

      /**
       * cleans all required things on delete
       * @returns {*}
       */

    }, {
      key: 'cleanup',
      value: function cleanup() {
        return this.edgeType.cleanup();
      }
    }], [{
      key: 'parseOptions',
      value: function parseOptions(parentOptions, newOptions) {
        var allowDeletion = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];
        var globalOptions = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

        var fields = ['arrowStrikethrough', 'id', 'from', 'hidden', 'hoverWidth', 'label', 'labelHighlightBold', 'length', 'line', 'opacity', 'physics', 'scaling', 'selectionWidth', 'selfReferenceSize', 'to', 'title', 'value', 'width'];

        // only deep extend the items in the field array. These do not have shorthand.
        util.selectiveDeepExtend(fields, parentOptions, newOptions, allowDeletion);

        util.mergeOptions(parentOptions, newOptions, 'smooth', allowDeletion, globalOptions);
        util.mergeOptions(parentOptions, newOptions, 'shadow', allowDeletion, globalOptions);

        if (newOptions.dashes !== undefined && newOptions.dashes !== null) {
          parentOptions.dashes = newOptions.dashes;
        } else if (allowDeletion === true && newOptions.dashes === null) {
          parentOptions.dashes = Object.create(globalOptions.dashes); // this sets the pointer of the option back to the global option.
        }

        // set the scaling newOptions
        if (newOptions.scaling !== undefined && newOptions.scaling !== null) {
          if (newOptions.scaling.min !== undefined) {
            parentOptions.scaling.min = newOptions.scaling.min;
          }
          if (newOptions.scaling.max !== undefined) {
            parentOptions.scaling.max = newOptions.scaling.max;
          }
          util.mergeOptions(parentOptions.scaling, newOptions.scaling, 'label', allowDeletion, globalOptions.scaling);
        } else if (allowDeletion === true && newOptions.scaling === null) {
          parentOptions.scaling = Object.create(globalOptions.scaling); // this sets the pointer of the option back to the global option.
        }

        // handle multiple input cases for arrows
        if (newOptions.arrows !== undefined && newOptions.arrows !== null) {
          if (typeof newOptions.arrows === 'string') {
            var arrows = newOptions.arrows.toLowerCase();
            parentOptions.arrows.to.enabled = arrows.indexOf("to") != -1;
            parentOptions.arrows.middle.enabled = arrows.indexOf("middle") != -1;
            parentOptions.arrows.from.enabled = arrows.indexOf("from") != -1;
          } else if (_typeof(newOptions.arrows) === 'object') {
            util.mergeOptions(parentOptions.arrows, newOptions.arrows, 'to', allowDeletion, globalOptions.arrows);
            util.mergeOptions(parentOptions.arrows, newOptions.arrows, 'middle', allowDeletion, globalOptions.arrows);
            util.mergeOptions(parentOptions.arrows, newOptions.arrows, 'from', allowDeletion, globalOptions.arrows);
          } else {
            throw new Error("The arrow newOptions can only be an object or a string. Refer to the documentation. You used:" + JSON.stringify(newOptions.arrows));
          }
        } else if (allowDeletion === true && newOptions.arrows === null) {
          parentOptions.arrows = Object.create(globalOptions.arrows); // this sets the pointer of the option back to the global option.
        }

        // handle multiple input cases for color
        if (newOptions.color !== undefined && newOptions.color !== null) {
          // make a copy of the parent object in case this is referring to the global one (due to object create once, then update)
          parentOptions.color = util.deepExtend({}, parentOptions.color, true);
          if (util.isString(newOptions.color)) {
            parentOptions.color.color = newOptions.color;
            parentOptions.color.highlight = newOptions.color;
            parentOptions.color.hover = newOptions.color;
            parentOptions.color.inherit = false;
          } else {
            var colorsDefined = false;
            if (newOptions.color.color !== undefined) {
              parentOptions.color.color = newOptions.color.color;colorsDefined = true;
            }
            if (newOptions.color.highlight !== undefined) {
              parentOptions.color.highlight = newOptions.color.highlight;colorsDefined = true;
            }
            if (newOptions.color.hover !== undefined) {
              parentOptions.color.hover = newOptions.color.hover;colorsDefined = true;
            }
            if (newOptions.color.inherit !== undefined) {
              parentOptions.color.inherit = newOptions.color.inherit;
            }
            if (newOptions.color.opacity !== undefined) {
              parentOptions.color.opacity = Math.min(1, Math.max(0, newOptions.color.opacity));
            }

            if (newOptions.color.inherit === undefined && colorsDefined === true) {
              parentOptions.color.inherit = false;
            }
          }
        } else if (allowDeletion === true && newOptions.color === null) {
          parentOptions.color = util.bridgeObject(globalOptions.color); // set the object back to the global options
        }

        // handle the font settings
        if (newOptions.font !== undefined && newOptions.font !== null) {
          _Label2.default.parseOptions(parentOptions.font, newOptions);
        } else if (allowDeletion === true && newOptions.font === null) {
          parentOptions.font = util.bridgeObject(globalOptions.font);
        }
      }
    }]);

    return Edge;
  }();

  exports.default = Edge;

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _CubicBezierEdgeBase2 = __webpack_require__(87);

  var _CubicBezierEdgeBase3 = _interopRequireDefault(_CubicBezierEdgeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var CubicBezierEdge = function (_CubicBezierEdgeBase) {
    _inherits(CubicBezierEdge, _CubicBezierEdgeBase);

    function CubicBezierEdge(options, body, labelModule) {
      _classCallCheck(this, CubicBezierEdge);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(CubicBezierEdge).call(this, options, body, labelModule));
    }

    /**
     * Draw a line between two nodes
     * @param {CanvasRenderingContext2D} ctx
     * @private
     */


    _createClass(CubicBezierEdge, [{
      key: '_line',
      value: function _line(ctx, viaNodes) {
        // get the coordinates of the support points.
        var via1 = viaNodes[0];
        var via2 = viaNodes[1];

        // start drawing the line.
        ctx.beginPath();
        ctx.moveTo(this.fromPoint.x, this.fromPoint.y);

        // fallback to normal straight edges
        if (viaNodes === undefined || via1.x === undefined) {
          ctx.lineTo(this.toPoint.x, this.toPoint.y);
        } else {
          ctx.bezierCurveTo(via1.x, via1.y, via2.x, via2.y, this.toPoint.x, this.toPoint.y);
        }
        // draw shadow if enabled
        this.enableShadow(ctx);
        ctx.stroke();
        this.disableShadow(ctx);
      }
    }, {
      key: '_getViaCoordinates',
      value: function _getViaCoordinates() {
        var dx = this.from.x - this.to.x;
        var dy = this.from.y - this.to.y;

        var x1 = void 0,
            y1 = void 0,
            x2 = void 0,
            y2 = void 0;
        var roundness = this.options.smooth.roundness;

        // horizontal if x > y or if direction is forced or if direction is horizontal
        if ((Math.abs(dx) > Math.abs(dy) || this.options.smooth.forceDirection === true || this.options.smooth.forceDirection === 'horizontal') && this.options.smooth.forceDirection !== 'vertical') {
          y1 = this.from.y;
          y2 = this.to.y;
          x1 = this.from.x - roundness * dx;
          x2 = this.to.x + roundness * dx;
        } else {
          y1 = this.from.y - roundness * dy;
          y2 = this.to.y + roundness * dy;
          x1 = this.from.x;
          x2 = this.to.x;
        }

        return [{ x: x1, y: y1 }, { x: x2, y: y2 }];
      }
    }, {
      key: 'getViaNode',
      value: function getViaNode() {
        return this._getViaCoordinates();
      }
    }, {
      key: '_findBorderPosition',
      value: function _findBorderPosition(nearNode, ctx) {
        return this._findBorderPositionBezier(nearNode, ctx);
      }
    }, {
      key: '_getDistanceToEdge',
      value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
        var _ref = arguments.length <= 6 || arguments[6] === undefined ? this._getViaCoordinates() : arguments[6];

        var _ref2 = _slicedToArray(_ref, 2);

        var via1 = _ref2[0];
        var via2 = _ref2[1];
        // x3,y3 is the point
        return this._getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, via1, via2);
      }

      /**
       * Combined function of pointOnLine and pointOnBezier. This gives the coordinates of a point on the line at a certain percentage of the way
       * @param percentage
       * @param via
       * @returns {{x: number, y: number}}
       * @private
       */

    }, {
      key: 'getPoint',
      value: function getPoint(percentage) {
        var _ref3 = arguments.length <= 1 || arguments[1] === undefined ? this._getViaCoordinates() : arguments[1];

        var _ref4 = _slicedToArray(_ref3, 2);

        var via1 = _ref4[0];
        var via2 = _ref4[1];

        var t = percentage;
        var vec = [];
        vec[0] = Math.pow(1 - t, 3);
        vec[1] = 3 * t * Math.pow(1 - t, 2);
        vec[2] = 3 * Math.pow(t, 2) * (1 - t);
        vec[3] = Math.pow(t, 3);
        var x = vec[0] * this.fromPoint.x + vec[1] * via1.x + vec[2] * via2.x + vec[3] * this.toPoint.x;
        var y = vec[0] * this.fromPoint.y + vec[1] * via1.y + vec[2] * via2.y + vec[3] * this.toPoint.y;

        return { x: x, y: y };
      }
    }]);

    return CubicBezierEdge;
  }(_CubicBezierEdgeBase3.default);

  exports.default = CubicBezierEdge;

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _BezierEdgeBase2 = __webpack_require__(88);

  var _BezierEdgeBase3 = _interopRequireDefault(_BezierEdgeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var CubicBezierEdgeBase = function (_BezierEdgeBase) {
    _inherits(CubicBezierEdgeBase, _BezierEdgeBase);

    function CubicBezierEdgeBase(options, body, labelModule) {
      _classCallCheck(this, CubicBezierEdgeBase);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(CubicBezierEdgeBase).call(this, options, body, labelModule));
    }

    /**
     * Calculate the distance between a point (x3,y3) and a line segment from
     * (x1,y1) to (x2,y2).
     * http://stackoverflow.com/questions/849211/shortest-distancae-between-a-point-and-a-line-segment
     * https://en.wikipedia.org/wiki/B%C3%A9zier_curve
     * @param {number} x1 from x
     * @param {number} y1 from y
     * @param {number} x2 to x
     * @param {number} y2 to y
     * @param {number} x3 point to check x
     * @param {number} y3 point to check y
     * @private
     */


    _createClass(CubicBezierEdgeBase, [{
      key: '_getDistanceToBezierEdge',
      value: function _getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, via1, via2) {
        // x3,y3 is the point
        var minDistance = 1e9;
        var distance = void 0;
        var i = void 0,
            t = void 0,
            x = void 0,
            y = void 0;
        var lastX = x1;
        var lastY = y1;
        var vec = [0, 0, 0, 0];
        for (i = 1; i < 10; i++) {
          t = 0.1 * i;
          vec[0] = Math.pow(1 - t, 3);
          vec[1] = 3 * t * Math.pow(1 - t, 2);
          vec[2] = 3 * Math.pow(t, 2) * (1 - t);
          vec[3] = Math.pow(t, 3);
          x = vec[0] * x1 + vec[1] * via1.x + vec[2] * via2.x + vec[3] * x2;
          y = vec[0] * y1 + vec[1] * via1.y + vec[2] * via2.y + vec[3] * y2;
          if (i > 0) {
            distance = this._getDistanceToLine(lastX, lastY, x, y, x3, y3);
            minDistance = distance < minDistance ? distance : minDistance;
          }
          lastX = x;
          lastY = y;
        }

        return minDistance;
      }
    }]);

    return CubicBezierEdgeBase;
  }(_BezierEdgeBase3.default);

  exports.default = CubicBezierEdgeBase;

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _EdgeBase2 = __webpack_require__(89);

  var _EdgeBase3 = _interopRequireDefault(_EdgeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var BezierEdgeBase = function (_EdgeBase) {
    _inherits(BezierEdgeBase, _EdgeBase);

    function BezierEdgeBase(options, body, labelModule) {
      _classCallCheck(this, BezierEdgeBase);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(BezierEdgeBase).call(this, options, body, labelModule));
    }

    /**
     * This function uses binary search to look for the point where the bezier curve crosses the border of the node.
     *
     * @param nearNode
     * @param ctx
     * @param viaNode
     * @param nearNode
     * @param ctx
     * @param viaNode
     * @param nearNode
     * @param ctx
     * @param viaNode
     */


    _createClass(BezierEdgeBase, [{
      key: '_findBorderPositionBezier',
      value: function _findBorderPositionBezier(nearNode, ctx) {
        var viaNode = arguments.length <= 2 || arguments[2] === undefined ? this._getViaCoordinates() : arguments[2];

        var maxIterations = 10;
        var iteration = 0;
        var low = 0;
        var high = 1;
        var pos, angle, distanceToBorder, distanceToPoint, difference;
        var threshold = 0.2;
        var node = this.to;
        var from = false;
        if (nearNode.id === this.from.id) {
          node = this.from;
          from = true;
        }

        while (low <= high && iteration < maxIterations) {
          var middle = (low + high) * 0.5;

          pos = this.getPoint(middle, viaNode);
          angle = Math.atan2(node.y - pos.y, node.x - pos.x);
          distanceToBorder = node.distanceToBorder(ctx, angle);
          distanceToPoint = Math.sqrt(Math.pow(pos.x - node.x, 2) + Math.pow(pos.y - node.y, 2));
          difference = distanceToBorder - distanceToPoint;
          if (Math.abs(difference) < threshold) {
            break; // found
          } else if (difference < 0) {
              // distance to nodes is larger than distance to border --> t needs to be bigger if we're looking at the to node.
              if (from === false) {
                low = middle;
              } else {
                high = middle;
              }
            } else {
              if (from === false) {
                high = middle;
              } else {
                low = middle;
              }
            }

          iteration++;
        }
        pos.t = middle;

        return pos;
      }

      /**
       * Calculate the distance between a point (x3,y3) and a line segment from
       * (x1,y1) to (x2,y2).
       * http://stackoverflow.com/questions/849211/shortest-distancae-between-a-point-and-a-line-segment
       * @param {number} x1 from x
       * @param {number} y1 from y
       * @param {number} x2 to x
       * @param {number} y2 to y
       * @param {number} x3 point to check x
       * @param {number} y3 point to check y
       * @private
       */

    }, {
      key: '_getDistanceToBezierEdge',
      value: function _getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, via) {
        // x3,y3 is the point
        var minDistance = 1e9;
        var distance = void 0;
        var i = void 0,
            t = void 0,
            x = void 0,
            y = void 0;
        var lastX = x1;
        var lastY = y1;
        for (i = 1; i < 10; i++) {
          t = 0.1 * i;
          x = Math.pow(1 - t, 2) * x1 + 2 * t * (1 - t) * via.x + Math.pow(t, 2) * x2;
          y = Math.pow(1 - t, 2) * y1 + 2 * t * (1 - t) * via.y + Math.pow(t, 2) * y2;
          if (i > 0) {
            distance = this._getDistanceToLine(lastX, lastY, x, y, x3, y3);
            minDistance = distance < minDistance ? distance : minDistance;
          }
          lastX = x;
          lastY = y;
        }

        return minDistance;
      }
    }]);

    return BezierEdgeBase;
  }(_EdgeBase3.default);

  exports.default = BezierEdgeBase;

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);

  var EdgeBase = function () {
    function EdgeBase(options, body, labelModule) {
      _classCallCheck(this, EdgeBase);

      this.body = body;
      this.labelModule = labelModule;
      this.options = {};
      this.setOptions(options);
      this.colorDirty = true;
      this.color = {};
      this.selectionWidth = 2;
      this.hoverWidth = 1.5;
      this.fromPoint = this.from;
      this.toPoint = this.to;
    }

    _createClass(EdgeBase, [{
      key: 'connect',
      value: function connect() {
        this.from = this.body.nodes[this.options.from];
        this.to = this.body.nodes[this.options.to];
      }
    }, {
      key: 'cleanup',
      value: function cleanup() {
        return false;
      }
    }, {
      key: 'setOptions',
      value: function setOptions(options) {
        this.options = options;
        this.from = this.body.nodes[this.options.from];
        this.to = this.body.nodes[this.options.to];
        this.id = this.options.id;
      }

      /**
       * Redraw a edge as a line
       * Draw this edge in the given canvas
       * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
       * @param {CanvasRenderingContext2D}   ctx
       * @private
       */

    }, {
      key: 'drawLine',
      value: function drawLine(ctx, selected, hover, viaNode) {
        // set style
        ctx.strokeStyle = this.getColor(ctx, selected, hover);
        ctx.lineWidth = this.getLineWidth(selected, hover);

        if (this.options.dashes !== false) {
          this._drawDashedLine(ctx, viaNode);
        } else {
          this._drawLine(ctx, viaNode);
        }
      }
    }, {
      key: '_drawLine',
      value: function _drawLine(ctx, viaNode, fromPoint, toPoint) {
        if (this.from != this.to) {
          // draw line
          this._line(ctx, viaNode, fromPoint, toPoint);
        } else {
          var _getCircleData2 = this._getCircleData(ctx);

          var _getCircleData3 = _slicedToArray(_getCircleData2, 3);

          var x = _getCircleData3[0];
          var y = _getCircleData3[1];
          var radius = _getCircleData3[2];

          this._circle(ctx, x, y, radius);
        }
      }
    }, {
      key: '_drawDashedLine',
      value: function _drawDashedLine(ctx, viaNode, fromPoint, toPoint) {
        ctx.lineCap = 'round';
        var pattern = [5, 5];
        if (Array.isArray(this.options.dashes) === true) {
          pattern = this.options.dashes;
        }

        // only firefox and chrome support this method, else we use the legacy one.
        if (ctx.setLineDash !== undefined) {
          ctx.save();

          // set dash settings for chrome or firefox
          ctx.setLineDash(pattern);
          ctx.lineDashOffset = 0;

          // draw the line
          if (this.from != this.to) {
            // draw line
            this._line(ctx, viaNode);
          } else {
            var _getCircleData4 = this._getCircleData(ctx);

            var _getCircleData5 = _slicedToArray(_getCircleData4, 3);

            var x = _getCircleData5[0];
            var y = _getCircleData5[1];
            var radius = _getCircleData5[2];

            this._circle(ctx, x, y, radius);
          }

          // restore the dash settings.
          ctx.setLineDash([0]);
          ctx.lineDashOffset = 0;
          ctx.restore();
        } else {
          // unsupporting smooth lines
          if (this.from != this.to) {
            // draw line
            ctx.dashedLine(this.from.x, this.from.y, this.to.x, this.to.y, pattern);
          } else {
            var _getCircleData6 = this._getCircleData(ctx);

            var _getCircleData7 = _slicedToArray(_getCircleData6, 3);

            var _x = _getCircleData7[0];
            var _y = _getCircleData7[1];
            var _radius = _getCircleData7[2];

            this._circle(ctx, _x, _y, _radius);
          }
          // draw shadow if enabled
          this.enableShadow(ctx);

          ctx.stroke();

          // disable shadows for other elements.
          this.disableShadow(ctx);
        }
      }
    }, {
      key: 'findBorderPosition',
      value: function findBorderPosition(nearNode, ctx, options) {
        if (this.from != this.to) {
          return this._findBorderPosition(nearNode, ctx, options);
        } else {
          return this._findBorderPositionCircle(nearNode, ctx, options);
        }
      }
    }, {
      key: 'findBorderPositions',
      value: function findBorderPositions(ctx) {
        var from = {};
        var to = {};
        if (this.from != this.to) {
          from = this._findBorderPosition(this.from, ctx);
          to = this._findBorderPosition(this.to, ctx);
        } else {
          var _getCircleData8 = this._getCircleData(ctx);

          var _getCircleData9 = _slicedToArray(_getCircleData8, 3);

          var x = _getCircleData9[0];
          var y = _getCircleData9[1];
          var radius = _getCircleData9[2];


          from = this._findBorderPositionCircle(this.from, ctx, { x: x, y: y, low: 0.25, high: 0.6, direction: -1 });
          to = this._findBorderPositionCircle(this.from, ctx, { x: x, y: y, low: 0.6, high: 0.8, direction: 1 });
        }
        return { from: from, to: to };
      }
    }, {
      key: '_getCircleData',
      value: function _getCircleData(ctx) {
        var x = void 0,
            y = void 0;
        var node = this.from;
        var radius = this.options.selfReferenceSize;

        if (ctx !== undefined) {
          if (node.shape.width === undefined) {
            node.shape.resize(ctx);
          }
        }

        // get circle coordinates
        if (node.shape.width > node.shape.height) {
          x = node.x + node.shape.width * 0.5;
          y = node.y - radius;
        } else {
          x = node.x + radius;
          y = node.y - node.shape.height * 0.5;
        }
        return [x, y, radius];
      }

      /**
       * Get a point on a circle
       * @param {Number} x
       * @param {Number} y
       * @param {Number} radius
       * @param {Number} percentage. Value between 0 (line start) and 1 (line end)
       * @return {Object} point
       * @private
       */

    }, {
      key: '_pointOnCircle',
      value: function _pointOnCircle(x, y, radius, percentage) {
        var angle = percentage * 2 * Math.PI;
        return {
          x: x + radius * Math.cos(angle),
          y: y - radius * Math.sin(angle)
        };
      }

      /**
       * This function uses binary search to look for the point where the circle crosses the border of the node.
       * @param node
       * @param ctx
       * @param options
       * @returns {*}
       * @private
       */

    }, {
      key: '_findBorderPositionCircle',
      value: function _findBorderPositionCircle(node, ctx, options) {
        var x = options.x;
        var y = options.y;
        var low = options.low;
        var high = options.high;
        var direction = options.direction;

        var maxIterations = 10;
        var iteration = 0;
        var radius = this.options.selfReferenceSize;
        var pos = void 0,
            angle = void 0,
            distanceToBorder = void 0,
            distanceToPoint = void 0,
            difference = void 0;
        var threshold = 0.05;
        var middle = (low + high) * 0.5;

        while (low <= high && iteration < maxIterations) {
          middle = (low + high) * 0.5;

          pos = this._pointOnCircle(x, y, radius, middle);
          angle = Math.atan2(node.y - pos.y, node.x - pos.x);
          distanceToBorder = node.distanceToBorder(ctx, angle);
          distanceToPoint = Math.sqrt(Math.pow(pos.x - node.x, 2) + Math.pow(pos.y - node.y, 2));
          difference = distanceToBorder - distanceToPoint;
          if (Math.abs(difference) < threshold) {
            break; // found
          } else if (difference > 0) {
              // distance to nodes is larger than distance to border --> t needs to be bigger if we're looking at the to node.
              if (direction > 0) {
                low = middle;
              } else {
                high = middle;
              }
            } else {
              if (direction > 0) {
                high = middle;
              } else {
                low = middle;
              }
            }
          iteration++;
        }
        pos.t = middle;

        return pos;
      }

      /**
       * Get the line width of the edge. Depends on width and whether one of the
       * connected nodes is selected.
       * @return {Number} width
       * @private
       */

    }, {
      key: 'getLineWidth',
      value: function getLineWidth(selected, hover) {
        if (selected === true) {
          return Math.max(this.selectionWidth, 0.3 / this.body.view.scale);
        } else {
          if (hover === true) {
            return Math.max(this.hoverWidth, 0.3 / this.body.view.scale);
          } else {
            return Math.max(this.options.width, 0.3 / this.body.view.scale);
          }
        }
      }
    }, {
      key: 'getColor',
      value: function getColor(ctx, selected, hover) {
        var colorOptions = this.options.color;
        if (colorOptions.inherit !== false) {
          // when this is a loop edge, just use the 'from' method
          if (colorOptions.inherit === 'both' && this.from.id !== this.to.id) {
            var grd = ctx.createLinearGradient(this.from.x, this.from.y, this.to.x, this.to.y);
            var fromColor = void 0,
                toColor = void 0;
            fromColor = this.from.options.color.highlight.border;
            toColor = this.to.options.color.highlight.border;

            if (this.from.selected === false && this.to.selected === false) {
              fromColor = util.overrideOpacity(this.from.options.color.border, this.options.color.opacity);
              toColor = util.overrideOpacity(this.to.options.color.border, this.options.color.opacity);
            } else if (this.from.selected === true && this.to.selected === false) {
              toColor = this.to.options.color.border;
            } else if (this.from.selected === false && this.to.selected === true) {
              fromColor = this.from.options.color.border;
            }
            grd.addColorStop(0, fromColor);
            grd.addColorStop(1, toColor);

            // -------------------- this returns -------------------- //
            return grd;
          }

          if (this.colorDirty === true) {
            if (colorOptions.inherit === "to") {
              this.color.highlight = this.to.options.color.highlight.border;
              this.color.hover = this.to.options.color.hover.border;
              this.color.color = util.overrideOpacity(this.to.options.color.border, colorOptions.opacity);
            } else {
              // (this.options.color.inherit.source === "from") {
              this.color.highlight = this.from.options.color.highlight.border;
              this.color.hover = this.from.options.color.hover.border;
              this.color.color = util.overrideOpacity(this.from.options.color.border, colorOptions.opacity);
            }
          }
        } else if (this.colorDirty === true) {
          this.color.highlight = colorOptions.highlight;
          this.color.hover = colorOptions.hover;
          this.color.color = util.overrideOpacity(colorOptions.color, colorOptions.opacity);
        }

        // if color inherit is on and gradients are used, the function has already returned by now.
        this.colorDirty = false;

        if (selected === true) {
          return this.color.highlight;
        } else if (hover === true) {
          return this.color.hover;
        } else {
          return this.color.color;
        }
      }

      /**
       * Draw a line from a node to itself, a circle
       * @param {CanvasRenderingContext2D} ctx
       * @param {Number} x
       * @param {Number} y
       * @param {Number} radius
       * @private
       */

    }, {
      key: '_circle',
      value: function _circle(ctx, x, y, radius) {
        // draw shadow if enabled
        this.enableShadow(ctx);

        // draw a circle
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, 2 * Math.PI, false);
        ctx.stroke();

        // disable shadows for other elements.
        this.disableShadow(ctx);
      }

      /**
       * Calculate the distance between a point (x3,y3) and a line segment from
       * (x1,y1) to (x2,y2).
       * http://stackoverflow.com/questions/849211/shortest-distancae-between-a-point-and-a-line-segment
       * @param {number} x1
       * @param {number} y1
       * @param {number} x2
       * @param {number} y2
       * @param {number} x3
       * @param {number} y3
       * @private
       */

    }, {
      key: 'getDistanceToEdge',
      value: function getDistanceToEdge(x1, y1, x2, y2, x3, y3, via) {
        // x3,y3 is the point
        var returnValue = 0;
        if (this.from != this.to) {
          returnValue = this._getDistanceToEdge(x1, y1, x2, y2, x3, y3, via);
        } else {
          var _getCircleData10 = this._getCircleData();

          var _getCircleData11 = _slicedToArray(_getCircleData10, 3);

          var x = _getCircleData11[0];
          var y = _getCircleData11[1];
          var radius = _getCircleData11[2];

          var dx = x - x3;
          var dy = y - y3;
          returnValue = Math.abs(Math.sqrt(dx * dx + dy * dy) - radius);
        }

        if (this.labelModule.size.left < x3 && this.labelModule.size.left + this.labelModule.size.width > x3 && this.labelModule.size.top < y3 && this.labelModule.size.top + this.labelModule.size.height > y3) {
          return 0;
        } else {
          return returnValue;
        }
      }
    }, {
      key: '_getDistanceToLine',
      value: function _getDistanceToLine(x1, y1, x2, y2, x3, y3) {
        var px = x2 - x1;
        var py = y2 - y1;
        var something = px * px + py * py;
        var u = ((x3 - x1) * px + (y3 - y1) * py) / something;

        if (u > 1) {
          u = 1;
        } else if (u < 0) {
          u = 0;
        }

        var x = x1 + u * px;
        var y = y1 + u * py;
        var dx = x - x3;
        var dy = y - y3;

        //# Note: If the actual distance does not matter,
        //# if you only want to compare what this function
        //# returns to other results of this function, you
        //# can just return the squared distance instead
        //# (i.e. remove the sqrt) to gain a little performance

        return Math.sqrt(dx * dx + dy * dy);
      }

      /**
       *
       * @param ctx
       * @param position
       * @param viaNode
       */

    }, {
      key: 'getArrowData',
      value: function getArrowData(ctx, position, viaNode, selected, hover) {
        // set lets
        var angle = void 0;
        var arrowPoint = void 0;
        var node1 = void 0;
        var node2 = void 0;
        var guideOffset = void 0;
        var scaleFactor = void 0;
        var lineWidth = this.getLineWidth(selected, hover);

        if (position === 'from') {
          node1 = this.from;
          node2 = this.to;
          guideOffset = 0.1;
          scaleFactor = this.options.arrows.from.scaleFactor;
        } else if (position === 'to') {
          node1 = this.to;
          node2 = this.from;
          guideOffset = -0.1;
          scaleFactor = this.options.arrows.to.scaleFactor;
        } else {
          node1 = this.to;
          node2 = this.from;
          scaleFactor = this.options.arrows.middle.scaleFactor;
        }

        // if not connected to itself
        if (node1 != node2) {
          if (position !== 'middle') {
            // draw arrow head
            if (this.options.smooth.enabled === true) {
              arrowPoint = this.findBorderPosition(node1, ctx, { via: viaNode });
              var guidePos = this.getPoint(Math.max(0.0, Math.min(1.0, arrowPoint.t + guideOffset)), viaNode);
              angle = Math.atan2(arrowPoint.y - guidePos.y, arrowPoint.x - guidePos.x);
            } else {
              angle = Math.atan2(node1.y - node2.y, node1.x - node2.x);
              arrowPoint = this.findBorderPosition(node1, ctx);
            }
          } else {
            angle = Math.atan2(node1.y - node2.y, node1.x - node2.x);
            arrowPoint = this.getPoint(0.5, viaNode); // this is 0.6 to account for the size of the arrow.
          }
        } else {
            // draw circle

            var _getCircleData12 = this._getCircleData(ctx);

            var _getCircleData13 = _slicedToArray(_getCircleData12, 3);

            var x = _getCircleData13[0];
            var y = _getCircleData13[1];
            var radius = _getCircleData13[2];


            if (position === 'from') {
              arrowPoint = this.findBorderPosition(this.from, ctx, { x: x, y: y, low: 0.25, high: 0.6, direction: -1 });
              angle = arrowPoint.t * -2 * Math.PI + 1.5 * Math.PI + 0.1 * Math.PI;
            } else if (position === 'to') {
              arrowPoint = this.findBorderPosition(this.from, ctx, { x: x, y: y, low: 0.6, high: 1.0, direction: 1 });
              angle = arrowPoint.t * -2 * Math.PI + 1.5 * Math.PI - 1.1 * Math.PI;
            } else {
              arrowPoint = this._pointOnCircle(x, y, radius, 0.175);
              angle = 3.9269908169872414; // === 0.175 * -2 * Math.PI + 1.5 * Math.PI + 0.1 * Math.PI;
            }
          }

        var length = 15 * scaleFactor + 3 * lineWidth; // 3* lineWidth is the width of the edge.

        var xi = arrowPoint.x - length * 0.9 * Math.cos(angle);
        var yi = arrowPoint.y - length * 0.9 * Math.sin(angle);
        var arrowCore = { x: xi, y: yi };

        return { point: arrowPoint, core: arrowCore, angle: angle, length: length };
      }

      /**
       *
       * @param ctx
       * @param selected
       * @param hover
       * @param arrowData
       */

    }, {
      key: 'drawArrowHead',
      value: function drawArrowHead(ctx, selected, hover, arrowData) {
        // set style
        ctx.strokeStyle = this.getColor(ctx, selected, hover);
        ctx.fillStyle = ctx.strokeStyle;
        ctx.lineWidth = this.getLineWidth(selected, hover);

        // draw arrow at the end of the line
        ctx.arrow(arrowData.point.x, arrowData.point.y, arrowData.angle, arrowData.length);

        // draw shadow if enabled
        this.enableShadow(ctx);
        ctx.fill();
        // disable shadows for other elements.
        this.disableShadow(ctx);
      }
    }, {
      key: 'enableShadow',
      value: function enableShadow(ctx) {
        if (this.options.shadow.enabled === true) {
          ctx.shadowColor = this.options.shadow.color;
          ctx.shadowBlur = this.options.shadow.size;
          ctx.shadowOffsetX = this.options.shadow.x;
          ctx.shadowOffsetY = this.options.shadow.y;
        }
      }
    }, {
      key: 'disableShadow',
      value: function disableShadow(ctx) {
        if (this.options.shadow.enabled === true) {
          ctx.shadowColor = 'rgba(0,0,0,0)';
          ctx.shadowBlur = 0;
          ctx.shadowOffsetX = 0;
          ctx.shadowOffsetY = 0;
        }
      }
    }]);

    return EdgeBase;
  }();

  exports.default = EdgeBase;

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _BezierEdgeBase2 = __webpack_require__(88);

  var _BezierEdgeBase3 = _interopRequireDefault(_BezierEdgeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var BezierEdgeDynamic = function (_BezierEdgeBase) {
    _inherits(BezierEdgeDynamic, _BezierEdgeBase);

    function BezierEdgeDynamic(options, body, labelModule) {
      _classCallCheck(this, BezierEdgeDynamic);

      // --> this calls the setOptions below

      var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(BezierEdgeDynamic).call(this, options, body, labelModule));
      //this.via = undefined; // Here for completeness but not allowed to defined before super() is invoked.


      _this._boundFunction = function () {
        _this.positionBezierNode();
      };
      _this.body.emitter.on("_repositionBezierNodes", _this._boundFunction);
      return _this;
    }

    _createClass(BezierEdgeDynamic, [{
      key: "setOptions",
      value: function setOptions(options) {
        // check if the physics has changed.
        var physicsChange = false;
        if (this.options.physics !== options.physics) {
          physicsChange = true;
        }

        // set the options and the to and from nodes
        this.options = options;
        this.id = this.options.id;
        this.from = this.body.nodes[this.options.from];
        this.to = this.body.nodes[this.options.to];

        // setup the support node and connect
        this.setupSupportNode();
        this.connect();

        // when we change the physics state of the edge, we reposition the support node.
        if (physicsChange === true) {
          this.via.setOptions({ physics: this.options.physics });
          this.positionBezierNode();
        }
      }
    }, {
      key: "connect",
      value: function connect() {
        this.from = this.body.nodes[this.options.from];
        this.to = this.body.nodes[this.options.to];
        if (this.from === undefined || this.to === undefined || this.options.physics === false) {
          this.via.setOptions({ physics: false });
        } else {
          // fix weird behaviour where a self referencing node has physics enabled
          if (this.from.id === this.to.id) {
            this.via.setOptions({ physics: false });
          } else {
            this.via.setOptions({ physics: true });
          }
        }
      }

      /**
       * remove the support nodes
       * @returns {boolean}
       */

    }, {
      key: "cleanup",
      value: function cleanup() {
        this.body.emitter.off("_repositionBezierNodes", this._boundFunction);
        if (this.via !== undefined) {
          delete this.body.nodes[this.via.id];
          this.via = undefined;
          return true;
        }
        return false;
      }

      /**
       * Bezier curves require an anchor point to calculate the smooth flow. These points are nodes. These nodes are invisible but
       * are used for the force calculation.
       *
       * The changed data is not called, if needed, it is returned by the main edge constructor.
       * @private
       */

    }, {
      key: "setupSupportNode",
      value: function setupSupportNode() {
        if (this.via === undefined) {
          var nodeId = "edgeId:" + this.id;
          var node = this.body.functions.createNode({
            id: nodeId,
            shape: 'circle',
            physics: true,
            hidden: true
          });
          this.body.nodes[nodeId] = node;
          this.via = node;
          this.via.parentEdgeId = this.id;
          this.positionBezierNode();
        }
      }
    }, {
      key: "positionBezierNode",
      value: function positionBezierNode() {
        if (this.via !== undefined && this.from !== undefined && this.to !== undefined) {
          this.via.x = 0.5 * (this.from.x + this.to.x);
          this.via.y = 0.5 * (this.from.y + this.to.y);
        } else if (this.via !== undefined) {
          this.via.x = 0;
          this.via.y = 0;
        }
      }

      /**
       * Draw a line between two nodes
       * @param {CanvasRenderingContext2D} ctx
       * @private
       */

    }, {
      key: "_line",
      value: function _line(ctx, viaNode) {
        // draw a straight line
        ctx.beginPath();
        ctx.moveTo(this.fromPoint.x, this.fromPoint.y);
        // fallback to normal straight edges
        if (viaNode.x === undefined) {
          ctx.lineTo(this.toPoint.x, this.toPoint.y);
        } else {
          ctx.quadraticCurveTo(viaNode.x, viaNode.y, this.toPoint.x, this.toPoint.y);
        }
        // draw shadow if enabled
        this.enableShadow(ctx);
        ctx.stroke();
        this.disableShadow(ctx);
      }
    }, {
      key: "getViaNode",
      value: function getViaNode() {
        return this.via;
      }

      /**
       * Combined function of pointOnLine and pointOnBezier. This gives the coordinates of a point on the line at a certain percentage of the way
       * @param percentage
       * @param viaNode
       * @returns {{x: number, y: number}}
       * @private
       */

    }, {
      key: "getPoint",
      value: function getPoint(percentage) {
        var viaNode = arguments.length <= 1 || arguments[1] === undefined ? this.via : arguments[1];

        var t = percentage;
        var x = Math.pow(1 - t, 2) * this.fromPoint.x + 2 * t * (1 - t) * viaNode.x + Math.pow(t, 2) * this.toPoint.x;
        var y = Math.pow(1 - t, 2) * this.fromPoint.y + 2 * t * (1 - t) * viaNode.y + Math.pow(t, 2) * this.toPoint.y;

        return { x: x, y: y };
      }
    }, {
      key: "_findBorderPosition",
      value: function _findBorderPosition(nearNode, ctx) {
        return this._findBorderPositionBezier(nearNode, ctx, this.via);
      }
    }, {
      key: "_getDistanceToEdge",
      value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
        // x3,y3 is the point
        return this._getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, this.via);
      }
    }]);

    return BezierEdgeDynamic;
  }(_BezierEdgeBase3.default);

  exports.default = BezierEdgeDynamic;

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _BezierEdgeBase2 = __webpack_require__(88);

  var _BezierEdgeBase3 = _interopRequireDefault(_BezierEdgeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var BezierEdgeStatic = function (_BezierEdgeBase) {
    _inherits(BezierEdgeStatic, _BezierEdgeBase);

    function BezierEdgeStatic(options, body, labelModule) {
      _classCallCheck(this, BezierEdgeStatic);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(BezierEdgeStatic).call(this, options, body, labelModule));
    }

    /**
     * Draw a line between two nodes
     * @param {CanvasRenderingContext2D} ctx
     * @private
     */


    _createClass(BezierEdgeStatic, [{
      key: '_line',
      value: function _line(ctx, viaNode) {
        // draw a straight line
        ctx.beginPath();
        ctx.moveTo(this.fromPoint.x, this.fromPoint.y);

        // fallback to normal straight edges
        if (viaNode.x === undefined) {
          ctx.lineTo(this.toPoint.x, this.toPoint.y);
        } else {
          ctx.quadraticCurveTo(viaNode.x, viaNode.y, this.toPoint.x, this.toPoint.y);
        }
        // draw shadow if enabled
        this.enableShadow(ctx);
        ctx.stroke();
        this.disableShadow(ctx);
      }
    }, {
      key: 'getViaNode',
      value: function getViaNode() {
        return this._getViaCoordinates();
      }

      /**
       * We do not use the to and fromPoints here to make the via nodes the same as edges without arrows.
       * @returns {{x: undefined, y: undefined}}
       * @private
       */

    }, {
      key: '_getViaCoordinates',
      value: function _getViaCoordinates() {
        var xVia = undefined;
        var yVia = undefined;
        var factor = this.options.smooth.roundness;
        var type = this.options.smooth.type;
        var dx = Math.abs(this.from.x - this.to.x);
        var dy = Math.abs(this.from.y - this.to.y);
        if (type === 'discrete' || type === 'diagonalCross') {
          if (Math.abs(this.from.x - this.to.x) <= Math.abs(this.from.y - this.to.y)) {
            if (this.from.y >= this.to.y) {
              if (this.from.x <= this.to.x) {
                xVia = this.from.x + factor * dy;
                yVia = this.from.y - factor * dy;
              } else if (this.from.x > this.to.x) {
                xVia = this.from.x - factor * dy;
                yVia = this.from.y - factor * dy;
              }
            } else if (this.from.y < this.to.y) {
              if (this.from.x <= this.to.x) {
                xVia = this.from.x + factor * dy;
                yVia = this.from.y + factor * dy;
              } else if (this.from.x > this.to.x) {
                xVia = this.from.x - factor * dy;
                yVia = this.from.y + factor * dy;
              }
            }
            if (type === "discrete") {
              xVia = dx < factor * dy ? this.from.x : xVia;
            }
          } else if (Math.abs(this.from.x - this.to.x) > Math.abs(this.from.y - this.to.y)) {
            if (this.from.y >= this.to.y) {
              if (this.from.x <= this.to.x) {
                xVia = this.from.x + factor * dx;
                yVia = this.from.y - factor * dx;
              } else if (this.from.x > this.to.x) {
                xVia = this.from.x - factor * dx;
                yVia = this.from.y - factor * dx;
              }
            } else if (this.from.y < this.to.y) {
              if (this.from.x <= this.to.x) {
                xVia = this.from.x + factor * dx;
                yVia = this.from.y + factor * dx;
              } else if (this.from.x > this.to.x) {
                xVia = this.from.x - factor * dx;
                yVia = this.from.y + factor * dx;
              }
            }
            if (type === "discrete") {
              yVia = dy < factor * dx ? this.from.y : yVia;
            }
          }
        } else if (type === "straightCross") {
          if (Math.abs(this.from.x - this.to.x) <= Math.abs(this.from.y - this.to.y)) {
            // up - down
            xVia = this.from.x;
            if (this.from.y < this.to.y) {
              yVia = this.to.y - (1 - factor) * dy;
            } else {
              yVia = this.to.y + (1 - factor) * dy;
            }
          } else if (Math.abs(this.from.x - this.to.x) > Math.abs(this.from.y - this.to.y)) {
            // left - right
            if (this.from.x < this.to.x) {
              xVia = this.to.x - (1 - factor) * dx;
            } else {
              xVia = this.to.x + (1 - factor) * dx;
            }
            yVia = this.from.y;
          }
        } else if (type === 'horizontal') {
          if (this.from.x < this.to.x) {
            xVia = this.to.x - (1 - factor) * dx;
          } else {
            xVia = this.to.x + (1 - factor) * dx;
          }
          yVia = this.from.y;
        } else if (type === 'vertical') {
          xVia = this.from.x;
          if (this.from.y < this.to.y) {
            yVia = this.to.y - (1 - factor) * dy;
          } else {
            yVia = this.to.y + (1 - factor) * dy;
          }
        } else if (type === 'curvedCW') {
          dx = this.to.x - this.from.x;
          dy = this.from.y - this.to.y;
          var radius = Math.sqrt(dx * dx + dy * dy);
          var pi = Math.PI;

          var originalAngle = Math.atan2(dy, dx);
          var myAngle = (originalAngle + (factor * 0.5 + 0.5) * pi) % (2 * pi);

          xVia = this.from.x + (factor * 0.5 + 0.5) * radius * Math.sin(myAngle);
          yVia = this.from.y + (factor * 0.5 + 0.5) * radius * Math.cos(myAngle);
        } else if (type === 'curvedCCW') {
          dx = this.to.x - this.from.x;
          dy = this.from.y - this.to.y;
          var _radius = Math.sqrt(dx * dx + dy * dy);
          var _pi = Math.PI;

          var _originalAngle = Math.atan2(dy, dx);
          var _myAngle = (_originalAngle + (-factor * 0.5 + 0.5) * _pi) % (2 * _pi);

          xVia = this.from.x + (factor * 0.5 + 0.5) * _radius * Math.sin(_myAngle);
          yVia = this.from.y + (factor * 0.5 + 0.5) * _radius * Math.cos(_myAngle);
        } else {
          // continuous
          if (Math.abs(this.from.x - this.to.x) <= Math.abs(this.from.y - this.to.y)) {
            if (this.from.y >= this.to.y) {
              if (this.from.x <= this.to.x) {
                xVia = this.from.x + factor * dy;
                yVia = this.from.y - factor * dy;
                xVia = this.to.x < xVia ? this.to.x : xVia;
              } else if (this.from.x > this.to.x) {
                xVia = this.from.x - factor * dy;
                yVia = this.from.y - factor * dy;
                xVia = this.to.x > xVia ? this.to.x : xVia;
              }
            } else if (this.from.y < this.to.y) {
              if (this.from.x <= this.to.x) {
                xVia = this.from.x + factor * dy;
                yVia = this.from.y + factor * dy;
                xVia = this.to.x < xVia ? this.to.x : xVia;
              } else if (this.from.x > this.to.x) {
                xVia = this.from.x - factor * dy;
                yVia = this.from.y + factor * dy;
                xVia = this.to.x > xVia ? this.to.x : xVia;
              }
            }
          } else if (Math.abs(this.from.x - this.to.x) > Math.abs(this.from.y - this.to.y)) {
            if (this.from.y >= this.to.y) {
              if (this.from.x <= this.to.x) {
                xVia = this.from.x + factor * dx;
                yVia = this.from.y - factor * dx;
                yVia = this.to.y > yVia ? this.to.y : yVia;
              } else if (this.from.x > this.to.x) {
                xVia = this.from.x - factor * dx;
                yVia = this.from.y - factor * dx;
                yVia = this.to.y > yVia ? this.to.y : yVia;
              }
            } else if (this.from.y < this.to.y) {
              if (this.from.x <= this.to.x) {
                xVia = this.from.x + factor * dx;
                yVia = this.from.y + factor * dx;
                yVia = this.to.y < yVia ? this.to.y : yVia;
              } else if (this.from.x > this.to.x) {
                xVia = this.from.x - factor * dx;
                yVia = this.from.y + factor * dx;
                yVia = this.to.y < yVia ? this.to.y : yVia;
              }
            }
          }
        }
        return { x: xVia, y: yVia };
      }
    }, {
      key: '_findBorderPosition',
      value: function _findBorderPosition(nearNode, ctx) {
        var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

        return this._findBorderPositionBezier(nearNode, ctx, options.via);
      }
    }, {
      key: '_getDistanceToEdge',
      value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
        var viaNode = arguments.length <= 6 || arguments[6] === undefined ? this._getViaCoordinates() : arguments[6];
        // x3,y3 is the point
        return this._getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, viaNode);
      }

      /**
       * Combined function of pointOnLine and pointOnBezier. This gives the coordinates of a point on the line at a certain percentage of the way
       * @param percentage
       * @param viaNode
       * @returns {{x: number, y: number}}
       * @private
       */

    }, {
      key: 'getPoint',
      value: function getPoint(percentage) {
        var viaNode = arguments.length <= 1 || arguments[1] === undefined ? this._getViaCoordinates() : arguments[1];

        var t = percentage;
        var x = Math.pow(1 - t, 2) * this.fromPoint.x + 2 * t * (1 - t) * viaNode.x + Math.pow(t, 2) * this.toPoint.x;
        var y = Math.pow(1 - t, 2) * this.fromPoint.y + 2 * t * (1 - t) * viaNode.y + Math.pow(t, 2) * this.toPoint.y;

        return { x: x, y: y };
      }
    }]);

    return BezierEdgeStatic;
  }(_BezierEdgeBase3.default);

  exports.default = BezierEdgeStatic;

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _EdgeBase2 = __webpack_require__(89);

  var _EdgeBase3 = _interopRequireDefault(_EdgeBase2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var StraightEdge = function (_EdgeBase) {
    _inherits(StraightEdge, _EdgeBase);

    function StraightEdge(options, body, labelModule) {
      _classCallCheck(this, StraightEdge);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(StraightEdge).call(this, options, body, labelModule));
    }

    /**
     * Draw a line between two nodes
     * @param {CanvasRenderingContext2D} ctx
     * @private
     */


    _createClass(StraightEdge, [{
      key: '_line',
      value: function _line(ctx) {
        // draw a straight line
        ctx.beginPath();
        ctx.moveTo(this.fromPoint.x, this.fromPoint.y);
        ctx.lineTo(this.toPoint.x, this.toPoint.y);
        // draw shadow if enabled
        this.enableShadow(ctx);
        ctx.stroke();
        this.disableShadow(ctx);
      }
    }, {
      key: 'getViaNode',
      value: function getViaNode() {
        return undefined;
      }

      /**
       * Combined function of pointOnLine and pointOnBezier. This gives the coordinates of a point on the line at a certain percentage of the way
       * @param percentage
       * @param via
       * @returns {{x: number, y: number}}
       * @private
       */

    }, {
      key: 'getPoint',
      value: function getPoint(percentage) {
        return {
          x: (1 - percentage) * this.fromPoint.x + percentage * this.toPoint.x,
          y: (1 - percentage) * this.fromPoint.y + percentage * this.toPoint.y
        };
      }
    }, {
      key: '_findBorderPosition',
      value: function _findBorderPosition(nearNode, ctx) {
        var node1 = this.to;
        var node2 = this.from;
        if (nearNode.id === this.from.id) {
          node1 = this.from;
          node2 = this.to;
        }

        var angle = Math.atan2(node1.y - node2.y, node1.x - node2.x);
        var dx = node1.x - node2.x;
        var dy = node1.y - node2.y;
        var edgeSegmentLength = Math.sqrt(dx * dx + dy * dy);
        var toBorderDist = nearNode.distanceToBorder(ctx, angle);
        var toBorderPoint = (edgeSegmentLength - toBorderDist) / edgeSegmentLength;

        var borderPos = {};
        borderPos.x = (1 - toBorderPoint) * node2.x + toBorderPoint * node1.x;
        borderPos.y = (1 - toBorderPoint) * node2.y + toBorderPoint * node1.y;

        return borderPos;
      }
    }, {
      key: '_getDistanceToEdge',
      value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
        // x3,y3 is the point
        return this._getDistanceToLine(x1, y1, x2, y2, x3, y3);
      }
    }]);

    return StraightEdge;
  }(_EdgeBase3.default);

  exports.default = StraightEdge;

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _BarnesHutSolver = __webpack_require__(94);

  var _BarnesHutSolver2 = _interopRequireDefault(_BarnesHutSolver);

  var _RepulsionSolver = __webpack_require__(95);

  var _RepulsionSolver2 = _interopRequireDefault(_RepulsionSolver);

  var _HierarchicalRepulsionSolver = __webpack_require__(96);

  var _HierarchicalRepulsionSolver2 = _interopRequireDefault(_HierarchicalRepulsionSolver);

  var _SpringSolver = __webpack_require__(97);

  var _SpringSolver2 = _interopRequireDefault(_SpringSolver);

  var _HierarchicalSpringSolver = __webpack_require__(98);

  var _HierarchicalSpringSolver2 = _interopRequireDefault(_HierarchicalSpringSolver);

  var _CentralGravitySolver = __webpack_require__(99);

  var _CentralGravitySolver2 = _interopRequireDefault(_CentralGravitySolver);

  var _FA2BasedRepulsionSolver = __webpack_require__(100);

  var _FA2BasedRepulsionSolver2 = _interopRequireDefault(_FA2BasedRepulsionSolver);

  var _FA2BasedCentralGravitySolver = __webpack_require__(101);

  var _FA2BasedCentralGravitySolver2 = _interopRequireDefault(_FA2BasedCentralGravitySolver);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);

  var PhysicsEngine = function () {
    function PhysicsEngine(body) {
      _classCallCheck(this, PhysicsEngine);

      this.body = body;
      this.physicsBody = { physicsNodeIndices: [], physicsEdgeIndices: [], forces: {}, velocities: {} };

      this.physicsEnabled = true;
      this.simulationInterval = 1000 / 60;
      this.requiresTimeout = true;
      this.previousStates = {};
      this.referenceState = {};
      this.freezeCache = {};
      this.renderTimer = undefined;

      // parameters for the adaptive timestep
      this.adaptiveTimestep = false;
      this.adaptiveTimestepEnabled = false;
      this.adaptiveCounter = 0;
      this.adaptiveInterval = 3;

      this.stabilized = false;
      this.startedStabilization = false;
      this.stabilizationIterations = 0;
      this.ready = false; // will be set to true if the stabilize

      // default options
      this.options = {};
      this.defaultOptions = {
        enabled: true,
        barnesHut: {
          theta: 0.5,
          gravitationalConstant: -2000,
          centralGravity: 0.3,
          springLength: 95,
          springConstant: 0.04,
          damping: 0.09,
          avoidOverlap: 0
        },
        forceAtlas2Based: {
          theta: 0.5,
          gravitationalConstant: -50,
          centralGravity: 0.01,
          springConstant: 0.08,
          springLength: 100,
          damping: 0.4,
          avoidOverlap: 0
        },
        repulsion: {
          centralGravity: 0.2,
          springLength: 200,
          springConstant: 0.05,
          nodeDistance: 100,
          damping: 0.09,
          avoidOverlap: 0
        },
        hierarchicalRepulsion: {
          centralGravity: 0.0,
          springLength: 100,
          springConstant: 0.01,
          nodeDistance: 120,
          damping: 0.09
        },
        maxVelocity: 50,
        minVelocity: 0.75, // px/s
        solver: 'barnesHut',
        stabilization: {
          enabled: true,
          iterations: 1000, // maximum number of iteration to stabilize
          updateInterval: 50,
          onlyDynamicEdges: false,
          fit: true
        },
        timestep: 0.5,
        adaptiveTimestep: true
      };
      util.extend(this.options, this.defaultOptions);
      this.timestep = 0.5;
      this.layoutFailed = false;

      this.bindEventListeners();
    }

    _createClass(PhysicsEngine, [{
      key: 'bindEventListeners',
      value: function bindEventListeners() {
        var _this = this;

        this.body.emitter.on('initPhysics', function () {
          _this.initPhysics();
        });
        this.body.emitter.on('_layoutFailed', function () {
          _this.layoutFailed = true;
        });
        this.body.emitter.on('resetPhysics', function () {
          _this.stopSimulation();_this.ready = false;
        });
        this.body.emitter.on('disablePhysics', function () {
          _this.physicsEnabled = false;_this.stopSimulation();
        });
        this.body.emitter.on('restorePhysics', function () {
          _this.setOptions(_this.options);
          if (_this.ready === true) {
            _this.startSimulation();
          }
        });
        this.body.emitter.on('startSimulation', function () {
          if (_this.ready === true) {
            _this.startSimulation();
          }
        });
        this.body.emitter.on('stopSimulation', function () {
          _this.stopSimulation();
        });
        this.body.emitter.on('destroy', function () {
          _this.stopSimulation(false);
          _this.body.emitter.off();
        });
        // this event will trigger a rebuilding of the cache everything. Used when nodes or edges have been added or removed.
        this.body.emitter.on("_dataChanged", function () {
          // update shortcut lists
          _this.updatePhysicsData();
        });

        // debug: show forces
        // this.body.emitter.on("afterDrawing", (ctx) => {this._drawForces(ctx);});
      }

      /**
       * set the physics options
       * @param options
       */

    }, {
      key: 'setOptions',
      value: function setOptions(options) {
        if (options !== undefined) {
          if (options === false) {
            this.options.enabled = false;
            this.physicsEnabled = false;
            this.stopSimulation();
          } else {
            this.physicsEnabled = true;
            util.selectiveNotDeepExtend(['stabilization'], this.options, options);
            util.mergeOptions(this.options, options, 'stabilization');

            if (options.enabled === undefined) {
              this.options.enabled = true;
            }

            if (this.options.enabled === false) {
              this.physicsEnabled = false;
              this.stopSimulation();
            }

            // set the timestep
            this.timestep = this.options.timestep;
          }
        }
        this.init();
      }

      /**
       * configure the engine.
       */

    }, {
      key: 'init',
      value: function init() {
        var options;
        if (this.options.solver === 'forceAtlas2Based') {
          options = this.options.forceAtlas2Based;
          this.nodesSolver = new _FA2BasedRepulsionSolver2.default(this.body, this.physicsBody, options);
          this.edgesSolver = new _SpringSolver2.default(this.body, this.physicsBody, options);
          this.gravitySolver = new _FA2BasedCentralGravitySolver2.default(this.body, this.physicsBody, options);
        } else if (this.options.solver === 'repulsion') {
          options = this.options.repulsion;
          this.nodesSolver = new _RepulsionSolver2.default(this.body, this.physicsBody, options);
          this.edgesSolver = new _SpringSolver2.default(this.body, this.physicsBody, options);
          this.gravitySolver = new _CentralGravitySolver2.default(this.body, this.physicsBody, options);
        } else if (this.options.solver === 'hierarchicalRepulsion') {
          options = this.options.hierarchicalRepulsion;
          this.nodesSolver = new _HierarchicalRepulsionSolver2.default(this.body, this.physicsBody, options);
          this.edgesSolver = new _HierarchicalSpringSolver2.default(this.body, this.physicsBody, options);
          this.gravitySolver = new _CentralGravitySolver2.default(this.body, this.physicsBody, options);
        } else {
          // barnesHut
          options = this.options.barnesHut;
          this.nodesSolver = new _BarnesHutSolver2.default(this.body, this.physicsBody, options);
          this.edgesSolver = new _SpringSolver2.default(this.body, this.physicsBody, options);
          this.gravitySolver = new _CentralGravitySolver2.default(this.body, this.physicsBody, options);
        }

        this.modelOptions = options;
      }

      /**
       * initialize the engine
       */

    }, {
      key: 'initPhysics',
      value: function initPhysics() {
        if (this.physicsEnabled === true && this.options.enabled === true) {
          if (this.options.stabilization.enabled === true) {
            this.stabilize();
          } else {
            this.stabilized = false;
            this.ready = true;
            this.body.emitter.emit('fit', {}, this.layoutFailed); // if the layout failed, we use the approximation for the zoom
            this.startSimulation();
          }
        } else {
          this.ready = true;
          this.body.emitter.emit('fit');
        }
      }

      /**
       * Start the simulation
       */

    }, {
      key: 'startSimulation',
      value: function startSimulation() {
        if (this.physicsEnabled === true && this.options.enabled === true) {
          this.stabilized = false;

          // when visible, adaptivity is disabled.
          this.adaptiveTimestep = false;

          // this sets the width of all nodes initially which could be required for the avoidOverlap
          this.body.emitter.emit("_resizeNodes");
          if (this.viewFunction === undefined) {
            this.viewFunction = this.simulationStep.bind(this);
            this.body.emitter.on('initRedraw', this.viewFunction);
            this.body.emitter.emit('_startRendering');
          }
        } else {
          this.body.emitter.emit('_redraw');
        }
      }

      /**
       * Stop the simulation, force stabilization.
       */

    }, {
      key: 'stopSimulation',
      value: function stopSimulation() {
        var emit = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

        this.stabilized = true;
        if (emit === true) {
          this._emitStabilized();
        }
        if (this.viewFunction !== undefined) {
          this.body.emitter.off('initRedraw', this.viewFunction);
          this.viewFunction = undefined;
          if (emit === true) {
            this.body.emitter.emit('_stopRendering');
          }
        }
      }

      /**
       * The viewFunction inserts this step into each render loop. It calls the physics tick and handles the cleanup at stabilized.
       *
       */

    }, {
      key: 'simulationStep',
      value: function simulationStep() {
        // check if the physics have settled
        var startTime = Date.now();
        this.physicsTick();
        var physicsTime = Date.now() - startTime;

        // run double speed if it is a little graph
        if ((physicsTime < 0.4 * this.simulationInterval || this.runDoubleSpeed === true) && this.stabilized === false) {
          this.physicsTick();

          // this makes sure there is no jitter. The decision is taken once to run it at double speed.
          this.runDoubleSpeed = true;
        }

        if (this.stabilized === true) {
          this.stopSimulation();
        }
      }

      /**
       * trigger the stabilized event.
       * @private
       */

    }, {
      key: '_emitStabilized',
      value: function _emitStabilized() {
        var _this2 = this;

        var amountOfIterations = arguments.length <= 0 || arguments[0] === undefined ? this.stabilizationIterations : arguments[0];

        if (this.stabilizationIterations > 1 || this.startedStabilization === true) {
          setTimeout(function () {
            _this2.body.emitter.emit('stabilized', { iterations: amountOfIterations });
            _this2.startedStabilization = false;
            _this2.stabilizationIterations = 0;
          }, 0);
        }
      }

      /**
       * A single simulation step (or 'tick') in the physics simulation
       *
       * @private
       */

    }, {
      key: 'physicsTick',
      value: function physicsTick() {
        // this is here to ensure that there is no start event when the network is already stable.
        if (this.startedStabilization === false) {
          this.body.emitter.emit('startStabilizing');
          this.startedStabilization = true;
        }

        if (this.stabilized === false) {
          // adaptivity means the timestep adapts to the situation, only applicable for stabilization
          if (this.adaptiveTimestep === true && this.adaptiveTimestepEnabled === true) {
            // this is the factor for increasing the timestep on success.
            var factor = 1.2;

            // we assume the adaptive interval is
            if (this.adaptiveCounter % this.adaptiveInterval === 0) {
              // we leave the timestep stable for "interval" iterations.
              // first the big step and revert. Revert saves the reference state.
              this.timestep = 2 * this.timestep;
              this.calculateForces();
              this.moveNodes();
              this.revert();

              // now the normal step. Since this is the last step, it is the more stable one and we will take this.
              this.timestep = 0.5 * this.timestep;

              // since it's half the step, we do it twice.
              this.calculateForces();
              this.moveNodes();
              this.calculateForces();
              this.moveNodes();

              // we compare the two steps. if it is acceptable we double the step.
              if (this._evaluateStepQuality() === true) {
                this.timestep = factor * this.timestep;
              } else {
                // if not, we decrease the step to a minimum of the options timestep.
                // if the decreased timestep is smaller than the options step, we do not reset the counter
                // we assume that the options timestep is stable enough.
                if (this.timestep / factor < this.options.timestep) {
                  this.timestep = this.options.timestep;
                } else {
                  // if the timestep was larger than 2 times the option one we check the adaptivity again to ensure
                  // that large instabilities do not form.
                  this.adaptiveCounter = -1; // check again next iteration
                  this.timestep = Math.max(this.options.timestep, this.timestep / factor);
                }
              }
            } else {
              // normal step, keeping timestep constant
              this.calculateForces();
              this.moveNodes();
            }

            // increment the counter
            this.adaptiveCounter += 1;
          } else {
            // case for the static timestep, we reset it to the one in options and take a normal step.
            this.timestep = this.options.timestep;
            this.calculateForces();
            this.moveNodes();
          }

          // determine if the network has stabilzied
          if (this.stabilized === true) {
            this.revert();
          }

          this.stabilizationIterations++;
        }
      }

      /**
       * Nodes and edges can have the physics toggles on or off. A collection of indices is created here so we can skip the check all the time.
       *
       * @private
       */

    }, {
      key: 'updatePhysicsData',
      value: function updatePhysicsData() {
        this.physicsBody.forces = {};
        this.physicsBody.physicsNodeIndices = [];
        this.physicsBody.physicsEdgeIndices = [];
        var nodes = this.body.nodes;
        var edges = this.body.edges;

        // get node indices for physics
        for (var nodeId in nodes) {
          if (nodes.hasOwnProperty(nodeId)) {
            if (nodes[nodeId].options.physics === true) {
              this.physicsBody.physicsNodeIndices.push(nodes[nodeId].id);
            }
          }
        }

        // get edge indices for physics
        for (var edgeId in edges) {
          if (edges.hasOwnProperty(edgeId)) {
            if (edges[edgeId].options.physics === true) {
              this.physicsBody.physicsEdgeIndices.push(edges[edgeId].id);
            }
          }
        }

        // get the velocity and the forces vector
        for (var i = 0; i < this.physicsBody.physicsNodeIndices.length; i++) {
          var _nodeId = this.physicsBody.physicsNodeIndices[i];
          this.physicsBody.forces[_nodeId] = { x: 0, y: 0 };

          // forces can be reset because they are recalculated. Velocities have to persist.
          if (this.physicsBody.velocities[_nodeId] === undefined) {
            this.physicsBody.velocities[_nodeId] = { x: 0, y: 0 };
          }
        }

        // clean deleted nodes from the velocity vector
        for (var _nodeId2 in this.physicsBody.velocities) {
          if (nodes[_nodeId2] === undefined) {
            delete this.physicsBody.velocities[_nodeId2];
          }
        }
      }

      /**
       * Revert the simulation one step. This is done so after stabilization, every new start of the simulation will also say stabilized.
       */

    }, {
      key: 'revert',
      value: function revert() {
        var nodeIds = Object.keys(this.previousStates);
        var nodes = this.body.nodes;
        var velocities = this.physicsBody.velocities;
        this.referenceState = {};

        for (var i = 0; i < nodeIds.length; i++) {
          var nodeId = nodeIds[i];
          if (nodes[nodeId] !== undefined) {
            if (nodes[nodeId].options.physics === true) {
              this.referenceState[nodeId] = {
                positions: { x: nodes[nodeId].x, y: nodes[nodeId].y }
              };
              velocities[nodeId].x = this.previousStates[nodeId].vx;
              velocities[nodeId].y = this.previousStates[nodeId].vy;
              nodes[nodeId].x = this.previousStates[nodeId].x;
              nodes[nodeId].y = this.previousStates[nodeId].y;
            }
          } else {
            delete this.previousStates[nodeId];
          }
        }
      }

      /**
       * This compares the reference state to the current state
       */

    }, {
      key: '_evaluateStepQuality',
      value: function _evaluateStepQuality() {
        var dx = void 0,
            dy = void 0,
            dpos = void 0;
        var nodes = this.body.nodes;
        var reference = this.referenceState;
        var posThreshold = 0.3;

        for (var nodeId in this.referenceState) {
          if (this.referenceState.hasOwnProperty(nodeId) && nodes[nodeId] !== undefined) {
            dx = nodes[nodeId].x - reference[nodeId].positions.x;
            dy = nodes[nodeId].y - reference[nodeId].positions.y;

            dpos = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));

            if (dpos > posThreshold) {
              return false;
            }
          }
        }
        return true;
      }

      /**
       * move the nodes one timestep and check if they are stabilized
       * @returns {boolean}
       */

    }, {
      key: 'moveNodes',
      value: function moveNodes() {
        var nodeIndices = this.physicsBody.physicsNodeIndices;
        var maxVelocity = this.options.maxVelocity ? this.options.maxVelocity : 1e9;
        var maxNodeVelocity = 0;
        var averageNodeVelocity = 0;

        // the velocity threshold (energy in the system) for the adaptivity toggle
        var velocityAdaptiveThreshold = 5;

        for (var i = 0; i < nodeIndices.length; i++) {
          var nodeId = nodeIndices[i];
          var nodeVelocity = this._performStep(nodeId, maxVelocity);
          // stabilized is true if stabilized is true and velocity is smaller than vmin --> all nodes must be stabilized
          maxNodeVelocity = Math.max(maxNodeVelocity, nodeVelocity);
          averageNodeVelocity += nodeVelocity;
        }

        // evaluating the stabilized and adaptiveTimestepEnabled conditions
        this.adaptiveTimestepEnabled = averageNodeVelocity / nodeIndices.length < velocityAdaptiveThreshold;
        this.stabilized = maxNodeVelocity < this.options.minVelocity;
      }

      /**
       * Perform the actual step
       *
       * @param nodeId
       * @param maxVelocity
       * @returns {number}
       * @private
       */

    }, {
      key: '_performStep',
      value: function _performStep(nodeId, maxVelocity) {
        var node = this.body.nodes[nodeId];
        var timestep = this.timestep;
        var forces = this.physicsBody.forces;
        var velocities = this.physicsBody.velocities;

        // store the state so we can revert
        this.previousStates[nodeId] = { x: node.x, y: node.y, vx: velocities[nodeId].x, vy: velocities[nodeId].y };

        if (node.options.fixed.x === false) {
          var dx = this.modelOptions.damping * velocities[nodeId].x; // damping force
          var ax = (forces[nodeId].x - dx) / node.options.mass; // acceleration
          velocities[nodeId].x += ax * timestep; // velocity
          velocities[nodeId].x = Math.abs(velocities[nodeId].x) > maxVelocity ? velocities[nodeId].x > 0 ? maxVelocity : -maxVelocity : velocities[nodeId].x;
          node.x += velocities[nodeId].x * timestep; // position
        } else {
            forces[nodeId].x = 0;
            velocities[nodeId].x = 0;
          }

        if (node.options.fixed.y === false) {
          var dy = this.modelOptions.damping * velocities[nodeId].y; // damping force
          var ay = (forces[nodeId].y - dy) / node.options.mass; // acceleration
          velocities[nodeId].y += ay * timestep; // velocity
          velocities[nodeId].y = Math.abs(velocities[nodeId].y) > maxVelocity ? velocities[nodeId].y > 0 ? maxVelocity : -maxVelocity : velocities[nodeId].y;
          node.y += velocities[nodeId].y * timestep; // position
        } else {
            forces[nodeId].y = 0;
            velocities[nodeId].y = 0;
          }

        var totalVelocity = Math.sqrt(Math.pow(velocities[nodeId].x, 2) + Math.pow(velocities[nodeId].y, 2));
        return totalVelocity;
      }

      /**
       * calculate the forces for one physics iteration.
       */

    }, {
      key: 'calculateForces',
      value: function calculateForces() {
        this.gravitySolver.solve();
        this.nodesSolver.solve();
        this.edgesSolver.solve();
      }

      /**
       * When initializing and stabilizing, we can freeze nodes with a predefined position. This greatly speeds up stabilization
       * because only the supportnodes for the smoothCurves have to settle.
       *
       * @private
       */

    }, {
      key: '_freezeNodes',
      value: function _freezeNodes() {
        var nodes = this.body.nodes;
        for (var id in nodes) {
          if (nodes.hasOwnProperty(id)) {
            if (nodes[id].x && nodes[id].y) {
              this.freezeCache[id] = { x: nodes[id].options.fixed.x, y: nodes[id].options.fixed.y };
              nodes[id].options.fixed.x = true;
              nodes[id].options.fixed.y = true;
            }
          }
        }
      }

      /**
       * Unfreezes the nodes that have been frozen by _freezeDefinedNodes.
       *
       * @private
       */

    }, {
      key: '_restoreFrozenNodes',
      value: function _restoreFrozenNodes() {
        var nodes = this.body.nodes;
        for (var id in nodes) {
          if (nodes.hasOwnProperty(id)) {
            if (this.freezeCache[id] !== undefined) {
              nodes[id].options.fixed.x = this.freezeCache[id].x;
              nodes[id].options.fixed.y = this.freezeCache[id].y;
            }
          }
        }
        this.freezeCache = {};
      }

      /**
       * Find a stable position for all nodes
       */

    }, {
      key: 'stabilize',
      value: function stabilize() {
        var _this3 = this;

        var iterations = arguments.length <= 0 || arguments[0] === undefined ? this.options.stabilization.iterations : arguments[0];

        if (typeof iterations !== 'number') {
          console.log('The stabilize method needs a numeric amount of iterations. Switching to default: ', this.options.stabilization.iterations);
          iterations = this.options.stabilization.iterations;
        }

        if (this.physicsBody.physicsNodeIndices.length === 0) {
          this.ready = true;
          return;
        }

        // enable adaptive timesteps
        this.adaptiveTimestep = true && this.options.adaptiveTimestep;

        // this sets the width of all nodes initially which could be required for the avoidOverlap
        this.body.emitter.emit("_resizeNodes");

        // stop the render loop
        this.stopSimulation();

        // set stabilze to false
        this.stabilized = false;

        // block redraw requests
        this.body.emitter.emit('_blockRedraw');
        this.targetIterations = iterations;

        // start the stabilization
        if (this.options.stabilization.onlyDynamicEdges === true) {
          this._freezeNodes();
        }
        this.stabilizationIterations = 0;

        setTimeout(function () {
          return _this3._stabilizationBatch();
        }, 0);
      }

      /**
       * One batch of stabilization
       * @private
       */

    }, {
      key: '_stabilizationBatch',
      value: function _stabilizationBatch() {
        // this is here to ensure that there is at least one start event.
        if (this.startedStabilization === false) {
          this.body.emitter.emit('startStabilizing');
          this.startedStabilization = true;
        }

        var count = 0;
        while (this.stabilized === false && count < this.options.stabilization.updateInterval && this.stabilizationIterations < this.targetIterations) {
          this.physicsTick();
          count++;
        }

        if (this.stabilized === false && this.stabilizationIterations < this.targetIterations) {
          this.body.emitter.emit('stabilizationProgress', { iterations: this.stabilizationIterations, total: this.targetIterations });
          setTimeout(this._stabilizationBatch.bind(this), 0);
        } else {
          this._finalizeStabilization();
        }
      }

      /**
       * Wrap up the stabilization, fit and emit the events.
       * @private
       */

    }, {
      key: '_finalizeStabilization',
      value: function _finalizeStabilization() {
        this.body.emitter.emit('_allowRedraw');
        if (this.options.stabilization.fit === true) {
          this.body.emitter.emit('fit');
        }

        if (this.options.stabilization.onlyDynamicEdges === true) {
          this._restoreFrozenNodes();
        }

        this.body.emitter.emit('stabilizationIterationsDone');
        this.body.emitter.emit('_requestRedraw');

        if (this.stabilized === true) {
          this._emitStabilized();
        } else {
          this.startSimulation();
        }

        this.ready = true;
      }
    }, {
      key: '_drawForces',
      value: function _drawForces(ctx) {
        for (var i = 0; i < this.physicsBody.physicsNodeIndices.length; i++) {
          var node = this.body.nodes[this.physicsBody.physicsNodeIndices[i]];
          var force = this.physicsBody.forces[this.physicsBody.physicsNodeIndices[i]];
          var factor = 20;
          var colorFactor = 0.03;
          var forceSize = Math.sqrt(Math.pow(force.x, 2) + Math.pow(force.x, 2));

          var size = Math.min(Math.max(5, forceSize), 15);
          var arrowSize = 3 * size;

          var color = util.HSVToHex((180 - Math.min(1, Math.max(0, colorFactor * forceSize)) * 180) / 360, 1, 1);

          ctx.lineWidth = size;
          ctx.strokeStyle = color;
          ctx.beginPath();
          ctx.moveTo(node.x, node.y);
          ctx.lineTo(node.x + factor * force.x, node.y + factor * force.y);
          ctx.stroke();

          var angle = Math.atan2(force.y, force.x);
          ctx.fillStyle = color;
          ctx.arrow(node.x + factor * force.x + Math.cos(angle) * arrowSize, node.y + factor * force.y + Math.sin(angle) * arrowSize, angle, arrowSize);
          ctx.fill();
        }
      }
    }]);

    return PhysicsEngine;
  }();

  exports.default = PhysicsEngine;

/***/ },
/* 94 */
/***/ function(module, exports) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var BarnesHutSolver = function () {
    function BarnesHutSolver(body, physicsBody, options) {
      _classCallCheck(this, BarnesHutSolver);

      this.body = body;
      this.physicsBody = physicsBody;
      this.barnesHutTree;
      this.setOptions(options);
      this.randomSeed = 5;

      // debug: show grid
      //this.body.emitter.on("afterDrawing", (ctx) => {this._debug(ctx,'#ff0000')})
    }

    _createClass(BarnesHutSolver, [{
      key: "setOptions",
      value: function setOptions(options) {
        this.options = options;
        this.thetaInversed = 1 / this.options.theta;
        this.overlapAvoidanceFactor = 1 - Math.max(0, Math.min(1, this.options.avoidOverlap)); // if 1 then min distance = 0.5, if 0.5 then min distance = 0.5 + 0.5*node.shape.radius
      }
    }, {
      key: "seededRandom",
      value: function seededRandom() {
        var x = Math.sin(this.randomSeed++) * 10000;
        return x - Math.floor(x);
      }

      /**
       * This function calculates the forces the nodes apply on each other based on a gravitational model.
       * The Barnes Hut method is used to speed up this N-body simulation.
       *
       * @private
       */

    }, {
      key: "solve",
      value: function solve() {
        if (this.options.gravitationalConstant !== 0 && this.physicsBody.physicsNodeIndices.length > 0) {
          var node = void 0;
          var nodes = this.body.nodes;
          var nodeIndices = this.physicsBody.physicsNodeIndices;
          var nodeCount = nodeIndices.length;

          // create the tree
          var barnesHutTree = this._formBarnesHutTree(nodes, nodeIndices);

          // for debugging
          this.barnesHutTree = barnesHutTree;

          // place the nodes one by one recursively
          for (var i = 0; i < nodeCount; i++) {
            node = nodes[nodeIndices[i]];
            if (node.options.mass > 0) {
              // starting with root is irrelevant, it never passes the BarnesHutSolver condition
              this._getForceContribution(barnesHutTree.root.children.NW, node);
              this._getForceContribution(barnesHutTree.root.children.NE, node);
              this._getForceContribution(barnesHutTree.root.children.SW, node);
              this._getForceContribution(barnesHutTree.root.children.SE, node);
            }
          }
        }
      }

      /**
       * This function traverses the barnesHutTree. It checks when it can approximate distant nodes with their center of mass.
       * If a region contains a single node, we check if it is not itself, then we apply the force.
       *
       * @param parentBranch
       * @param node
       * @private
       */

    }, {
      key: "_getForceContribution",
      value: function _getForceContribution(parentBranch, node) {
        // we get no force contribution from an empty region
        if (parentBranch.childrenCount > 0) {
          var dx = void 0,
              dy = void 0,
              distance = void 0;

          // get the distance from the center of mass to the node.
          dx = parentBranch.centerOfMass.x - node.x;
          dy = parentBranch.centerOfMass.y - node.y;
          distance = Math.sqrt(dx * dx + dy * dy);

          // BarnesHutSolver condition
          // original condition : s/d < theta = passed  ===  d/s > 1/theta = passed
          // calcSize = 1/s --> d * 1/s > 1/theta = passed
          if (distance * parentBranch.calcSize > this.thetaInversed) {
            this._calculateForces(distance, dx, dy, node, parentBranch);
          } else {
            // Did not pass the condition, go into children if available
            if (parentBranch.childrenCount === 4) {
              this._getForceContribution(parentBranch.children.NW, node);
              this._getForceContribution(parentBranch.children.NE, node);
              this._getForceContribution(parentBranch.children.SW, node);
              this._getForceContribution(parentBranch.children.SE, node);
            } else {
              // parentBranch must have only one node, if it was empty we wouldnt be here
              if (parentBranch.children.data.id != node.id) {
                // if it is not self
                this._calculateForces(distance, dx, dy, node, parentBranch);
              }
            }
          }
        }
      }

      /**
       * Calculate the forces based on the distance.
       *
       * @param distance
       * @param dx
       * @param dy
       * @param node
       * @param parentBranch
       * @private
       */

    }, {
      key: "_calculateForces",
      value: function _calculateForces(distance, dx, dy, node, parentBranch) {
        if (distance === 0) {
          distance = 0.1;
          dx = distance;
        }

        if (this.overlapAvoidanceFactor < 1) {
          distance = Math.max(0.1 + this.overlapAvoidanceFactor * node.shape.radius, distance - node.shape.radius);
        }

        // the dividing by the distance cubed instead of squared allows us to get the fx and fy components without sines and cosines
        // it is shorthand for gravityforce with distance squared and fx = dx/distance * gravityForce
        var gravityForce = this.options.gravitationalConstant * parentBranch.mass * node.options.mass / Math.pow(distance, 3);
        var fx = dx * gravityForce;
        var fy = dy * gravityForce;

        this.physicsBody.forces[node.id].x += fx;
        this.physicsBody.forces[node.id].y += fy;
      }

      /**
       * This function constructs the barnesHut tree recursively. It creates the root, splits it and starts placing the nodes.
       *
       * @param nodes
       * @param nodeIndices
       * @private
       */

    }, {
      key: "_formBarnesHutTree",
      value: function _formBarnesHutTree(nodes, nodeIndices) {
        var node = void 0;
        var nodeCount = nodeIndices.length;

        var minX = nodes[nodeIndices[0]].x;
        var minY = nodes[nodeIndices[0]].y;
        var maxX = nodes[nodeIndices[0]].x;
        var maxY = nodes[nodeIndices[0]].y;

        // get the range of the nodes
        for (var i = 1; i < nodeCount; i++) {
          var x = nodes[nodeIndices[i]].x;
          var y = nodes[nodeIndices[i]].y;
          if (nodes[nodeIndices[i]].options.mass > 0) {
            if (x < minX) {
              minX = x;
            }
            if (x > maxX) {
              maxX = x;
            }
            if (y < minY) {
              minY = y;
            }
            if (y > maxY) {
              maxY = y;
            }
          }
        }
        // make the range a square
        var sizeDiff = Math.abs(maxX - minX) - Math.abs(maxY - minY); // difference between X and Y
        if (sizeDiff > 0) {
          minY -= 0.5 * sizeDiff;
          maxY += 0.5 * sizeDiff;
        } // xSize > ySize
        else {
            minX += 0.5 * sizeDiff;
            maxX -= 0.5 * sizeDiff;
          } // xSize < ySize

        var minimumTreeSize = 1e-5;
        var rootSize = Math.max(minimumTreeSize, Math.abs(maxX - minX));
        var halfRootSize = 0.5 * rootSize;
        var centerX = 0.5 * (minX + maxX),
            centerY = 0.5 * (minY + maxY);

        // construct the barnesHutTree
        var barnesHutTree = {
          root: {
            centerOfMass: { x: 0, y: 0 },
            mass: 0,
            range: {
              minX: centerX - halfRootSize, maxX: centerX + halfRootSize,
              minY: centerY - halfRootSize, maxY: centerY + halfRootSize
            },
            size: rootSize,
            calcSize: 1 / rootSize,
            children: { data: null },
            maxWidth: 0,
            level: 0,
            childrenCount: 4
          }
        };
        this._splitBranch(barnesHutTree.root);

        // place the nodes one by one recursively
        for (var _i = 0; _i < nodeCount; _i++) {
          node = nodes[nodeIndices[_i]];
          if (node.options.mass > 0) {
            this._placeInTree(barnesHutTree.root, node);
          }
        }

        // make global
        return barnesHutTree;
      }

      /**
       * this updates the mass of a branch. this is increased by adding a node.
       *
       * @param parentBranch
       * @param node
       * @private
       */

    }, {
      key: "_updateBranchMass",
      value: function _updateBranchMass(parentBranch, node) {
        var totalMass = parentBranch.mass + node.options.mass;
        var totalMassInv = 1 / totalMass;

        parentBranch.centerOfMass.x = parentBranch.centerOfMass.x * parentBranch.mass + node.x * node.options.mass;
        parentBranch.centerOfMass.x *= totalMassInv;

        parentBranch.centerOfMass.y = parentBranch.centerOfMass.y * parentBranch.mass + node.y * node.options.mass;
        parentBranch.centerOfMass.y *= totalMassInv;

        parentBranch.mass = totalMass;
        var biggestSize = Math.max(Math.max(node.height, node.radius), node.width);
        parentBranch.maxWidth = parentBranch.maxWidth < biggestSize ? biggestSize : parentBranch.maxWidth;
      }

      /**
       * determine in which branch the node will be placed.
       *
       * @param parentBranch
       * @param node
       * @param skipMassUpdate
       * @private
       */

    }, {
      key: "_placeInTree",
      value: function _placeInTree(parentBranch, node, skipMassUpdate) {
        if (skipMassUpdate != true || skipMassUpdate === undefined) {
          // update the mass of the branch.
          this._updateBranchMass(parentBranch, node);
        }

        if (parentBranch.children.NW.range.maxX > node.x) {
          // in NW or SW
          if (parentBranch.children.NW.range.maxY > node.y) {
            // in NW
            this._placeInRegion(parentBranch, node, "NW");
          } else {
            // in SW
            this._placeInRegion(parentBranch, node, "SW");
          }
        } else {
          // in NE or SE
          if (parentBranch.children.NW.range.maxY > node.y) {
            // in NE
            this._placeInRegion(parentBranch, node, "NE");
          } else {
            // in SE
            this._placeInRegion(parentBranch, node, "SE");
          }
        }
      }

      /**
       * actually place the node in a region (or branch)
       *
       * @param parentBranch
       * @param node
       * @param region
       * @private
       */

    }, {
      key: "_placeInRegion",
      value: function _placeInRegion(parentBranch, node, region) {
        switch (parentBranch.children[region].childrenCount) {
          case 0:
            // place node here
            parentBranch.children[region].children.data = node;
            parentBranch.children[region].childrenCount = 1;
            this._updateBranchMass(parentBranch.children[region], node);
            break;
          case 1:
            // convert into children
            // if there are two nodes exactly overlapping (on init, on opening of cluster etc.)
            // we move one node a little bit and we do not put it in the tree.
            if (parentBranch.children[region].children.data.x === node.x && parentBranch.children[region].children.data.y === node.y) {
              node.x += this.seededRandom();
              node.y += this.seededRandom();
            } else {
              this._splitBranch(parentBranch.children[region]);
              this._placeInTree(parentBranch.children[region], node);
            }
            break;
          case 4:
            // place in branch
            this._placeInTree(parentBranch.children[region], node);
            break;
        }
      }

      /**
       * this function splits a branch into 4 sub branches. If the branch contained a node, we place it in the subbranch
       * after the split is complete.
       *
       * @param parentBranch
       * @private
       */

    }, {
      key: "_splitBranch",
      value: function _splitBranch(parentBranch) {
        // if the branch is shaded with a node, replace the node in the new subset.
        var containedNode = null;
        if (parentBranch.childrenCount === 1) {
          containedNode = parentBranch.children.data;
          parentBranch.mass = 0;
          parentBranch.centerOfMass.x = 0;
          parentBranch.centerOfMass.y = 0;
        }
        parentBranch.childrenCount = 4;
        parentBranch.children.data = null;
        this._insertRegion(parentBranch, "NW");
        this._insertRegion(parentBranch, "NE");
        this._insertRegion(parentBranch, "SW");
        this._insertRegion(parentBranch, "SE");

        if (containedNode != null) {
          this._placeInTree(parentBranch, containedNode);
        }
      }

      /**
       * This function subdivides the region into four new segments.
       * Specifically, this inserts a single new segment.
       * It fills the children section of the parentBranch
       *
       * @param parentBranch
       * @param region
       * @param parentRange
       * @private
       */

    }, {
      key: "_insertRegion",
      value: function _insertRegion(parentBranch, region) {
        var minX = void 0,
            maxX = void 0,
            minY = void 0,
            maxY = void 0;
        var childSize = 0.5 * parentBranch.size;
        switch (region) {
          case "NW":
            minX = parentBranch.range.minX;
            maxX = parentBranch.range.minX + childSize;
            minY = parentBranch.range.minY;
            maxY = parentBranch.range.minY + childSize;
            break;
          case "NE":
            minX = parentBranch.range.minX + childSize;
            maxX = parentBranch.range.maxX;
            minY = parentBranch.range.minY;
            maxY = parentBranch.range.minY + childSize;
            break;
          case "SW":
            minX = parentBranch.range.minX;
            maxX = parentBranch.range.minX + childSize;
            minY = parentBranch.range.minY + childSize;
            maxY = parentBranch.range.maxY;
            break;
          case "SE":
            minX = parentBranch.range.minX + childSize;
            maxX = parentBranch.range.maxX;
            minY = parentBranch.range.minY + childSize;
            maxY = parentBranch.range.maxY;
            break;
        }

        parentBranch.children[region] = {
          centerOfMass: { x: 0, y: 0 },
          mass: 0,
          range: { minX: minX, maxX: maxX, minY: minY, maxY: maxY },
          size: 0.5 * parentBranch.size,
          calcSize: 2 * parentBranch.calcSize,
          children: { data: null },
          maxWidth: 0,
          level: parentBranch.level + 1,
          childrenCount: 0
        };
      }

      //---------------------------  DEBUGGING BELOW  ---------------------------//

      /**
       * This function is for debugging purposed, it draws the tree.
       *
       * @param ctx
       * @param color
       * @private
       */

    }, {
      key: "_debug",
      value: function _debug(ctx, color) {
        if (this.barnesHutTree !== undefined) {

          ctx.lineWidth = 1;

          this._drawBranch(this.barnesHutTree.root, ctx, color);
        }
      }

      /**
       * This function is for debugging purposes. It draws the branches recursively.
       *
       * @param branch
       * @param ctx
       * @param color
       * @private
       */

    }, {
      key: "_drawBranch",
      value: function _drawBranch(branch, ctx, color) {
        if (color === undefined) {
          color = "#FF0000";
        }

        if (branch.childrenCount === 4) {
          this._drawBranch(branch.children.NW, ctx);
          this._drawBranch(branch.children.NE, ctx);
          this._drawBranch(branch.children.SE, ctx);
          this._drawBranch(branch.children.SW, ctx);
        }
        ctx.strokeStyle = color;
        ctx.beginPath();
        ctx.moveTo(branch.range.minX, branch.range.minY);
        ctx.lineTo(branch.range.maxX, branch.range.minY);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(branch.range.maxX, branch.range.minY);
        ctx.lineTo(branch.range.maxX, branch.range.maxY);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(branch.range.maxX, branch.range.maxY);
        ctx.lineTo(branch.range.minX, branch.range.maxY);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(branch.range.minX, branch.range.maxY);
        ctx.lineTo(branch.range.minX, branch.range.minY);
        ctx.stroke();

        /*
         if (branch.mass > 0) {
         ctx.circle(branch.centerOfMass.x, branch.centerOfMass.y, 3*branch.mass);
         ctx.stroke();
         }
         */
      }
    }]);

    return BarnesHutSolver;
  }();

  exports.default = BarnesHutSolver;

/***/ },
/* 95 */
/***/ function(module, exports) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var RepulsionSolver = function () {
    function RepulsionSolver(body, physicsBody, options) {
      _classCallCheck(this, RepulsionSolver);

      this.body = body;
      this.physicsBody = physicsBody;
      this.setOptions(options);
    }

    _createClass(RepulsionSolver, [{
      key: "setOptions",
      value: function setOptions(options) {
        this.options = options;
      }
      /**
       * Calculate the forces the nodes apply on each other based on a repulsion field.
       * This field is linearly approximated.
       *
       * @private
       */

    }, {
      key: "solve",
      value: function solve() {
        var dx, dy, distance, fx, fy, repulsingForce, node1, node2;

        var nodes = this.body.nodes;
        var nodeIndices = this.physicsBody.physicsNodeIndices;
        var forces = this.physicsBody.forces;

        // repulsing forces between nodes
        var nodeDistance = this.options.nodeDistance;

        // approximation constants
        var a = -2 / 3 / nodeDistance;
        var b = 4 / 3;

        // we loop from i over all but the last entree in the array
        // j loops from i+1 to the last. This way we do not double count any of the indices, nor i === j
        for (var i = 0; i < nodeIndices.length - 1; i++) {
          node1 = nodes[nodeIndices[i]];
          for (var j = i + 1; j < nodeIndices.length; j++) {
            node2 = nodes[nodeIndices[j]];

            dx = node2.x - node1.x;
            dy = node2.y - node1.y;
            distance = Math.sqrt(dx * dx + dy * dy);

            // same condition as BarnesHutSolver, making sure nodes are never 100% overlapping.
            if (distance === 0) {
              distance = 0.1 * Math.random();
              dx = distance;
            }

            if (distance < 2 * nodeDistance) {
              if (distance < 0.5 * nodeDistance) {
                repulsingForce = 1.0;
              } else {
                repulsingForce = a * distance + b; // linear approx of  1 / (1 + Math.exp((distance / nodeDistance - 1) * steepness))
              }
              repulsingForce = repulsingForce / distance;

              fx = dx * repulsingForce;
              fy = dy * repulsingForce;

              forces[node1.id].x -= fx;
              forces[node1.id].y -= fy;
              forces[node2.id].x += fx;
              forces[node2.id].y += fy;
            }
          }
        }
      }
    }]);

    return RepulsionSolver;
  }();

  exports.default = RepulsionSolver;

/***/ },
/* 96 */
/***/ function(module, exports) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var HierarchicalRepulsionSolver = function () {
    function HierarchicalRepulsionSolver(body, physicsBody, options) {
      _classCallCheck(this, HierarchicalRepulsionSolver);

      this.body = body;
      this.physicsBody = physicsBody;
      this.setOptions(options);
    }

    _createClass(HierarchicalRepulsionSolver, [{
      key: "setOptions",
      value: function setOptions(options) {
        this.options = options;
      }

      /**
       * Calculate the forces the nodes apply on each other based on a repulsion field.
       * This field is linearly approximated.
       *
       * @private
       */

    }, {
      key: "solve",
      value: function solve() {
        var dx, dy, distance, fx, fy, repulsingForce, node1, node2, i, j;

        var nodes = this.body.nodes;
        var nodeIndices = this.physicsBody.physicsNodeIndices;
        var forces = this.physicsBody.forces;

        // repulsing forces between nodes
        var nodeDistance = this.options.nodeDistance;

        // we loop from i over all but the last entree in the array
        // j loops from i+1 to the last. This way we do not double count any of the indices, nor i === j
        for (i = 0; i < nodeIndices.length - 1; i++) {
          node1 = nodes[nodeIndices[i]];
          for (j = i + 1; j < nodeIndices.length; j++) {
            node2 = nodes[nodeIndices[j]];

            // nodes only affect nodes on their level
            if (node1.level === node2.level) {
              dx = node2.x - node1.x;
              dy = node2.y - node1.y;
              distance = Math.sqrt(dx * dx + dy * dy);

              var steepness = 0.05;
              if (distance < nodeDistance) {
                repulsingForce = -Math.pow(steepness * distance, 2) + Math.pow(steepness * nodeDistance, 2);
              } else {
                repulsingForce = 0;
              }
              // normalize force with
              if (distance === 0) {
                distance = 0.01;
              } else {
                repulsingForce = repulsingForce / distance;
              }
              fx = dx * repulsingForce;
              fy = dy * repulsingForce;

              forces[node1.id].x -= fx;
              forces[node1.id].y -= fy;
              forces[node2.id].x += fx;
              forces[node2.id].y += fy;
            }
          }
        }
      }
    }]);

    return HierarchicalRepulsionSolver;
  }();

  exports.default = HierarchicalRepulsionSolver;

/***/ },
/* 97 */
/***/ function(module, exports) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var SpringSolver = function () {
    function SpringSolver(body, physicsBody, options) {
      _classCallCheck(this, SpringSolver);

      this.body = body;
      this.physicsBody = physicsBody;
      this.setOptions(options);
    }

    _createClass(SpringSolver, [{
      key: "setOptions",
      value: function setOptions(options) {
        this.options = options;
      }

      /**
       * This function calculates the springforces on the nodes, accounting for the support nodes.
       *
       * @private
       */

    }, {
      key: "solve",
      value: function solve() {
        var edgeLength = void 0,
            edge = void 0;
        var edgeIndices = this.physicsBody.physicsEdgeIndices;
        var edges = this.body.edges;
        var node1 = void 0,
            node2 = void 0,
            node3 = void 0;

        // forces caused by the edges, modelled as springs
        for (var i = 0; i < edgeIndices.length; i++) {
          edge = edges[edgeIndices[i]];
          if (edge.connected === true && edge.toId !== edge.fromId) {
            // only calculate forces if nodes are in the same sector
            if (this.body.nodes[edge.toId] !== undefined && this.body.nodes[edge.fromId] !== undefined) {
              if (edge.edgeType.via !== undefined) {
                edgeLength = edge.options.length === undefined ? this.options.springLength : edge.options.length;
                node1 = edge.to;
                node2 = edge.edgeType.via;
                node3 = edge.from;

                this._calculateSpringForce(node1, node2, 0.5 * edgeLength);
                this._calculateSpringForce(node2, node3, 0.5 * edgeLength);
              } else {
                // the * 1.5 is here so the edge looks as large as a smooth edge. It does not initially because the smooth edges use
                // the support nodes which exert a repulsive force on the to and from nodes, making the edge appear larger.
                edgeLength = edge.options.length === undefined ? this.options.springLength * 1.5 : edge.options.length;
                this._calculateSpringForce(edge.from, edge.to, edgeLength);
              }
            }
          }
        }
      }

      /**
       * This is the code actually performing the calculation for the function above.
       *
       * @param node1
       * @param node2
       * @param edgeLength
       * @private
       */

    }, {
      key: "_calculateSpringForce",
      value: function _calculateSpringForce(node1, node2, edgeLength) {
        var dx = node1.x - node2.x;
        var dy = node1.y - node2.y;
        var distance = Math.max(Math.sqrt(dx * dx + dy * dy), 0.01);

        // the 1/distance is so the fx and fy can be calculated without sine or cosine.
        var springForce = this.options.springConstant * (edgeLength - distance) / distance;

        var fx = dx * springForce;
        var fy = dy * springForce;

        // handle the case where one node is not part of the physcis
        if (this.physicsBody.forces[node1.id] !== undefined) {
          this.physicsBody.forces[node1.id].x += fx;
          this.physicsBody.forces[node1.id].y += fy;
        }

        if (this.physicsBody.forces[node2.id] !== undefined) {
          this.physicsBody.forces[node2.id].x -= fx;
          this.physicsBody.forces[node2.id].y -= fy;
        }
      }
    }]);

    return SpringSolver;
  }();

  exports.default = SpringSolver;

/***/ },
/* 98 */
/***/ function(module, exports) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var HierarchicalSpringSolver = function () {
    function HierarchicalSpringSolver(body, physicsBody, options) {
      _classCallCheck(this, HierarchicalSpringSolver);

      this.body = body;
      this.physicsBody = physicsBody;
      this.setOptions(options);
    }

    _createClass(HierarchicalSpringSolver, [{
      key: "setOptions",
      value: function setOptions(options) {
        this.options = options;
      }

      /**
       * This function calculates the springforces on the nodes, accounting for the support nodes.
       *
       * @private
       */

    }, {
      key: "solve",
      value: function solve() {
        var edgeLength, edge;
        var dx, dy, fx, fy, springForce, distance;
        var edges = this.body.edges;
        var factor = 0.5;

        var edgeIndices = this.physicsBody.physicsEdgeIndices;
        var nodeIndices = this.physicsBody.physicsNodeIndices;
        var forces = this.physicsBody.forces;

        // initialize the spring force counters
        for (var i = 0; i < nodeIndices.length; i++) {
          var nodeId = nodeIndices[i];
          forces[nodeId].springFx = 0;
          forces[nodeId].springFy = 0;
        }

        // forces caused by the edges, modelled as springs
        for (var _i = 0; _i < edgeIndices.length; _i++) {
          edge = edges[edgeIndices[_i]];
          if (edge.connected === true) {
            edgeLength = edge.options.length === undefined ? this.options.springLength : edge.options.length;

            dx = edge.from.x - edge.to.x;
            dy = edge.from.y - edge.to.y;
            distance = Math.sqrt(dx * dx + dy * dy);
            distance = distance === 0 ? 0.01 : distance;

            // the 1/distance is so the fx and fy can be calculated without sine or cosine.
            springForce = this.options.springConstant * (edgeLength - distance) / distance;

            fx = dx * springForce;
            fy = dy * springForce;

            if (edge.to.level != edge.from.level) {
              if (forces[edge.toId] !== undefined) {
                forces[edge.toId].springFx -= fx;
                forces[edge.toId].springFy -= fy;
              }
              if (forces[edge.fromId] !== undefined) {
                forces[edge.fromId].springFx += fx;
                forces[edge.fromId].springFy += fy;
              }
            } else {
              if (forces[edge.toId] !== undefined) {
                forces[edge.toId].x -= factor * fx;
                forces[edge.toId].y -= factor * fy;
              }
              if (forces[edge.fromId] !== undefined) {
                forces[edge.fromId].x += factor * fx;
                forces[edge.fromId].y += factor * fy;
              }
            }
          }
        }

        // normalize spring forces
        var springForce = 1;
        var springFx, springFy;
        for (var _i2 = 0; _i2 < nodeIndices.length; _i2++) {
          var _nodeId = nodeIndices[_i2];
          springFx = Math.min(springForce, Math.max(-springForce, forces[_nodeId].springFx));
          springFy = Math.min(springForce, Math.max(-springForce, forces[_nodeId].springFy));

          forces[_nodeId].x += springFx;
          forces[_nodeId].y += springFy;
        }

        // retain energy balance
        var totalFx = 0;
        var totalFy = 0;
        for (var _i3 = 0; _i3 < nodeIndices.length; _i3++) {
          var _nodeId2 = nodeIndices[_i3];
          totalFx += forces[_nodeId2].x;
          totalFy += forces[_nodeId2].y;
        }
        var correctionFx = totalFx / nodeIndices.length;
        var correctionFy = totalFy / nodeIndices.length;

        for (var _i4 = 0; _i4 < nodeIndices.length; _i4++) {
          var _nodeId3 = nodeIndices[_i4];
          forces[_nodeId3].x -= correctionFx;
          forces[_nodeId3].y -= correctionFy;
        }
      }
    }]);

    return HierarchicalSpringSolver;
  }();

  exports.default = HierarchicalSpringSolver;

/***/ },
/* 99 */
/***/ function(module, exports) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var CentralGravitySolver = function () {
    function CentralGravitySolver(body, physicsBody, options) {
      _classCallCheck(this, CentralGravitySolver);

      this.body = body;
      this.physicsBody = physicsBody;
      this.setOptions(options);
    }

    _createClass(CentralGravitySolver, [{
      key: "setOptions",
      value: function setOptions(options) {
        this.options = options;
      }
    }, {
      key: "solve",
      value: function solve() {
        var dx = void 0,
            dy = void 0,
            distance = void 0,
            node = void 0;
        var nodes = this.body.nodes;
        var nodeIndices = this.physicsBody.physicsNodeIndices;
        var forces = this.physicsBody.forces;

        for (var i = 0; i < nodeIndices.length; i++) {
          var nodeId = nodeIndices[i];
          node = nodes[nodeId];
          dx = -node.x;
          dy = -node.y;
          distance = Math.sqrt(dx * dx + dy * dy);

          this._calculateForces(distance, dx, dy, forces, node);
        }
      }

      /**
       * Calculate the forces based on the distance.
       * @private
       */

    }, {
      key: "_calculateForces",
      value: function _calculateForces(distance, dx, dy, forces, node) {
        var gravityForce = distance === 0 ? 0 : this.options.centralGravity / distance;
        forces[node.id].x = dx * gravityForce;
        forces[node.id].y = dy * gravityForce;
      }
    }]);

    return CentralGravitySolver;
  }();

  exports.default = CentralGravitySolver;

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _BarnesHutSolver2 = __webpack_require__(94);

  var _BarnesHutSolver3 = _interopRequireDefault(_BarnesHutSolver2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var ForceAtlas2BasedRepulsionSolver = function (_BarnesHutSolver) {
    _inherits(ForceAtlas2BasedRepulsionSolver, _BarnesHutSolver);

    function ForceAtlas2BasedRepulsionSolver(body, physicsBody, options) {
      _classCallCheck(this, ForceAtlas2BasedRepulsionSolver);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(ForceAtlas2BasedRepulsionSolver).call(this, body, physicsBody, options));
    }

    /**
     * Calculate the forces based on the distance.
     *
     * @param distance
     * @param dx
     * @param dy
     * @param node
     * @param parentBranch
     * @private
     */


    _createClass(ForceAtlas2BasedRepulsionSolver, [{
      key: "_calculateForces",
      value: function _calculateForces(distance, dx, dy, node, parentBranch) {
        if (distance === 0) {
          distance = 0.1 * Math.random();
          dx = distance;
        }

        if (this.overlapAvoidanceFactor < 1) {
          distance = Math.max(0.1 + this.overlapAvoidanceFactor * node.shape.radius, distance - node.shape.radius);
        }

        var degree = node.edges.length + 1;
        // the dividing by the distance cubed instead of squared allows us to get the fx and fy components without sines and cosines
        // it is shorthand for gravityforce with distance squared and fx = dx/distance * gravityForce
        var gravityForce = this.options.gravitationalConstant * parentBranch.mass * node.options.mass * degree / Math.pow(distance, 2);
        var fx = dx * gravityForce;
        var fy = dy * gravityForce;

        this.physicsBody.forces[node.id].x += fx;
        this.physicsBody.forces[node.id].y += fy;
      }
    }]);

    return ForceAtlas2BasedRepulsionSolver;
  }(_BarnesHutSolver3.default);

  exports.default = ForceAtlas2BasedRepulsionSolver;

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _CentralGravitySolver2 = __webpack_require__(99);

  var _CentralGravitySolver3 = _interopRequireDefault(_CentralGravitySolver2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var ForceAtlas2BasedCentralGravitySolver = function (_CentralGravitySolver) {
    _inherits(ForceAtlas2BasedCentralGravitySolver, _CentralGravitySolver);

    function ForceAtlas2BasedCentralGravitySolver(body, physicsBody, options) {
      _classCallCheck(this, ForceAtlas2BasedCentralGravitySolver);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(ForceAtlas2BasedCentralGravitySolver).call(this, body, physicsBody, options));
    }

    /**
     * Calculate the forces based on the distance.
     * @private
     */


    _createClass(ForceAtlas2BasedCentralGravitySolver, [{
      key: "_calculateForces",
      value: function _calculateForces(distance, dx, dy, forces, node) {
        if (distance > 0) {
          var degree = node.edges.length + 1;
          var gravityForce = this.options.centralGravity * degree * node.options.mass;
          forces[node.id].x = dx * gravityForce;
          forces[node.id].y = dy * gravityForce;
        }
      }
    }]);

    return ForceAtlas2BasedCentralGravitySolver;
  }(_CentralGravitySolver3.default);

  exports.default = ForceAtlas2BasedCentralGravitySolver;

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _NetworkUtil = __webpack_require__(103);

  var _NetworkUtil2 = _interopRequireDefault(_NetworkUtil);

  var _Cluster = __webpack_require__(104);

  var _Cluster2 = _interopRequireDefault(_Cluster);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);

  var ClusterEngine = function () {
    function ClusterEngine(body) {
      var _this = this;

      _classCallCheck(this, ClusterEngine);

      this.body = body;
      this.clusteredNodes = {};
      this.clusteredEdges = {};

      this.options = {};
      this.defaultOptions = {};
      util.extend(this.options, this.defaultOptions);

      this.body.emitter.on('_resetData', function () {
        _this.clusteredNodes = {};_this.clusteredEdges = {};
      });
    }

    _createClass(ClusterEngine, [{
      key: 'setOptions',
      value: function setOptions(options) {
        if (options !== undefined) {}
      }

      /**
      *
      * @param hubsize
      * @param options
      */

    }, {
      key: 'clusterByHubsize',
      value: function clusterByHubsize(hubsize, options) {
        if (hubsize === undefined) {
          hubsize = this._getHubSize();
        } else if ((typeof hubsize === 'undefined' ? 'undefined' : _typeof(hubsize)) === "object") {
          options = this._checkOptions(hubsize);
          hubsize = this._getHubSize();
        }

        var nodesToCluster = [];
        for (var i = 0; i < this.body.nodeIndices.length; i++) {
          var node = this.body.nodes[this.body.nodeIndices[i]];
          if (node.edges.length >= hubsize) {
            nodesToCluster.push(node.id);
          }
        }

        for (var _i = 0; _i < nodesToCluster.length; _i++) {
          this.clusterByConnection(nodesToCluster[_i], options, true);
        }

        this.body.emitter.emit('_dataChanged');
      }

      /**
      * loop over all nodes, check if they adhere to the condition and cluster if needed.
      * @param options
      * @param refreshData
      */

    }, {
      key: 'cluster',
      value: function cluster() {
        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
        var refreshData = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

        if (options.joinCondition === undefined) {
          throw new Error("Cannot call clusterByNodeData without a joinCondition function in the options.");
        }

        // check if the options object is fine, append if needed
        options = this._checkOptions(options);

        var childNodesObj = {};
        var childEdgesObj = {};

        // collect the nodes that will be in the cluster
        for (var i = 0; i < this.body.nodeIndices.length; i++) {
          var nodeId = this.body.nodeIndices[i];
          var node = this.body.nodes[nodeId];
          var clonedOptions = _NetworkUtil2.default.cloneOptions(node);
          if (options.joinCondition(clonedOptions) === true) {
            childNodesObj[nodeId] = this.body.nodes[nodeId];

            // collect the nodes that will be in the cluster
            for (var _i2 = 0; _i2 < node.edges.length; _i2++) {
              var edge = node.edges[_i2];
              if (this.clusteredEdges[edge.id] === undefined) {
                childEdgesObj[edge.id] = edge;
              }
            }
          }
        }

        this._cluster(childNodesObj, childEdgesObj, options, refreshData);
      }

      /**
       * Cluster all nodes in the network that have only X edges
       * @param edgeCount
       * @param options
       * @param refreshData
       */

    }, {
      key: 'clusterByEdgeCount',
      value: function clusterByEdgeCount(edgeCount, options) {
        var refreshData = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];

        options = this._checkOptions(options);
        var clusters = [];
        var usedNodes = {};
        var edge = void 0,
            edges = void 0,
            node = void 0,
            nodeId = void 0,
            relevantEdgeCount = void 0;
        // collect the nodes that will be in the cluster
        for (var i = 0; i < this.body.nodeIndices.length; i++) {
          var childNodesObj = {};
          var childEdgesObj = {};
          nodeId = this.body.nodeIndices[i];

          // if this node is already used in another cluster this session, we do not have to re-evaluate it.
          if (usedNodes[nodeId] === undefined) {
            relevantEdgeCount = 0;
            node = this.body.nodes[nodeId];
            edges = [];
            for (var j = 0; j < node.edges.length; j++) {
              edge = node.edges[j];
              if (this.clusteredEdges[edge.id] === undefined) {
                if (edge.toId !== edge.fromId) {
                  relevantEdgeCount++;
                }
                edges.push(edge);
              }
            }

            // this node qualifies, we collect its neighbours to start the clustering process.
            if (relevantEdgeCount === edgeCount) {
              var gatheringSuccessful = true;
              for (var _j = 0; _j < edges.length; _j++) {
                edge = edges[_j];
                var childNodeId = this._getConnectedId(edge, nodeId);
                // add the nodes to the list by the join condition.
                if (options.joinCondition === undefined) {
                  childEdgesObj[edge.id] = edge;
                  childNodesObj[nodeId] = this.body.nodes[nodeId];
                  childNodesObj[childNodeId] = this.body.nodes[childNodeId];
                  usedNodes[nodeId] = true;
                } else {
                  var clonedOptions = _NetworkUtil2.default.cloneOptions(this.body.nodes[nodeId]);
                  if (options.joinCondition(clonedOptions) === true) {
                    childEdgesObj[edge.id] = edge;
                    childNodesObj[nodeId] = this.body.nodes[nodeId];
                    usedNodes[nodeId] = true;
                  } else {
                    // this node does not qualify after all.
                    gatheringSuccessful = false;
                    break;
                  }
                }
              }

              // add to the cluster queue
              if (Object.keys(childNodesObj).length > 0 && Object.keys(childEdgesObj).length > 0 && gatheringSuccessful === true) {
                clusters.push({ nodes: childNodesObj, edges: childEdgesObj });
              }
            }
          }
        }

        for (var _i3 = 0; _i3 < clusters.length; _i3++) {
          this._cluster(clusters[_i3].nodes, clusters[_i3].edges, options, false);
        }

        if (refreshData === true) {
          this.body.emitter.emit('_dataChanged');
        }
      }

      /**
      * Cluster all nodes in the network that have only 1 edge
      * @param options
      * @param refreshData
      */

    }, {
      key: 'clusterOutliers',
      value: function clusterOutliers(options) {
        var refreshData = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

        this.clusterByEdgeCount(1, options, refreshData);
      }

      /**
       * Cluster all nodes in the network that have only 2 edge
       * @param options
       * @param refreshData
       */

    }, {
      key: 'clusterBridges',
      value: function clusterBridges(options) {
        var refreshData = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

        this.clusterByEdgeCount(2, options, refreshData);
      }

      /**
      * suck all connected nodes of a node into the node.
      * @param nodeId
      * @param options
      * @param refreshData
      */

    }, {
      key: 'clusterByConnection',
      value: function clusterByConnection(nodeId, options) {
        var refreshData = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];

        // kill conditions
        if (nodeId === undefined) {
          throw new Error("No nodeId supplied to clusterByConnection!");
        }
        if (this.body.nodes[nodeId] === undefined) {
          throw new Error("The nodeId given to clusterByConnection does not exist!");
        }

        var node = this.body.nodes[nodeId];
        options = this._checkOptions(options, node);
        if (options.clusterNodeProperties.x === undefined) {
          options.clusterNodeProperties.x = node.x;
        }
        if (options.clusterNodeProperties.y === undefined) {
          options.clusterNodeProperties.y = node.y;
        }
        if (options.clusterNodeProperties.fixed === undefined) {
          options.clusterNodeProperties.fixed = {};
          options.clusterNodeProperties.fixed.x = node.options.fixed.x;
          options.clusterNodeProperties.fixed.y = node.options.fixed.y;
        }

        var childNodesObj = {};
        var childEdgesObj = {};
        var parentNodeId = node.id;
        var parentClonedOptions = _NetworkUtil2.default.cloneOptions(node);
        childNodesObj[parentNodeId] = node;

        // collect the nodes that will be in the cluster
        for (var i = 0; i < node.edges.length; i++) {
          var edge = node.edges[i];
          if (this.clusteredEdges[edge.id] === undefined) {
            var childNodeId = this._getConnectedId(edge, parentNodeId);

            // if the child node is not in a cluster
            if (this.clusteredNodes[childNodeId] === undefined) {
              if (childNodeId !== parentNodeId) {
                if (options.joinCondition === undefined) {
                  childEdgesObj[edge.id] = edge;
                  childNodesObj[childNodeId] = this.body.nodes[childNodeId];
                } else {
                  // clone the options and insert some additional parameters that could be interesting.
                  var childClonedOptions = _NetworkUtil2.default.cloneOptions(this.body.nodes[childNodeId]);
                  if (options.joinCondition(parentClonedOptions, childClonedOptions) === true) {
                    childEdgesObj[edge.id] = edge;
                    childNodesObj[childNodeId] = this.body.nodes[childNodeId];
                  }
                }
              } else {
                // swallow the edge if it is self-referencing.
                childEdgesObj[edge.id] = edge;
              }
            }
          }
        }

        this._cluster(childNodesObj, childEdgesObj, options, refreshData);
      }

      /**
      * This function creates the edges that will be attached to the cluster
      * It looks for edges that are connected to the nodes from the "outside' of the cluster.
      *
      * @param childNodesObj
      * @param childEdgesObj
      * @param clusterNodeProperties
      * @param clusterEdgeProperties
      * @private
      */

    }, {
      key: '_createClusterEdges',
      value: function _createClusterEdges(childNodesObj, childEdgesObj, clusterNodeProperties, clusterEdgeProperties) {
        var edge = void 0,
            childNodeId = void 0,
            childNode = void 0,
            toId = void 0,
            fromId = void 0,
            otherNodeId = void 0;

        // loop over all child nodes and their edges to find edges going out of the cluster
        // these edges will be replaced by clusterEdges.
        var childKeys = Object.keys(childNodesObj);
        var createEdges = [];
        for (var i = 0; i < childKeys.length; i++) {
          childNodeId = childKeys[i];
          childNode = childNodesObj[childNodeId];

          // construct new edges from the cluster to others
          for (var j = 0; j < childNode.edges.length; j++) {
            edge = childNode.edges[j];
            // we only handle edges that are visible to the system, not the disabled ones from the clustering process.
            if (this.clusteredEdges[edge.id] === undefined) {
              // self-referencing edges will be added to the "hidden" list
              if (edge.toId == edge.fromId) {
                childEdgesObj[edge.id] = edge;
              } else {
                // set up the from and to.
                if (edge.toId == childNodeId) {
                  // this is a double equals because ints and strings can be interchanged here.
                  toId = clusterNodeProperties.id;
                  fromId = edge.fromId;
                  otherNodeId = fromId;
                } else {
                  toId = edge.toId;
                  fromId = clusterNodeProperties.id;
                  otherNodeId = toId;
                }
              }

              // Only edges from the cluster outwards are being replaced.
              if (childNodesObj[otherNodeId] === undefined) {
                createEdges.push({ edge: edge, fromId: fromId, toId: toId });
              }
            }
          }
        }

        // here we actually create the replacement edges. We could not do this in the loop above as the creation process
        // would add an edge to the edges array we are iterating over.
        for (var _j2 = 0; _j2 < createEdges.length; _j2++) {
          var _edge = createEdges[_j2].edge;
          // copy the options of the edge we will replace
          var clonedOptions = _NetworkUtil2.default.cloneOptions(_edge, 'edge');
          // make sure the properties of clusterEdges are superimposed on it
          util.deepExtend(clonedOptions, clusterEdgeProperties);

          // set up the edge
          clonedOptions.from = createEdges[_j2].fromId;
          clonedOptions.to = createEdges[_j2].toId;
          clonedOptions.id = 'clusterEdge:' + util.randomUUID();
          //clonedOptions.id = '(cf: ' + createEdges[j].fromId + " to: " + createEdges[j].toId + ")" + Math.random();

          // create the edge and give a reference to the one it replaced.
          var newEdge = this.body.functions.createEdge(clonedOptions);
          newEdge.clusteringEdgeReplacingId = _edge.id;

          // connect the edge.
          this.body.edges[newEdge.id] = newEdge;
          newEdge.connect();

          // hide the replaced edge
          this._backupEdgeOptions(_edge);
          _edge.setOptions({ physics: false, hidden: true });
        }
      }

      /**
      * This function checks the options that can be supplied to the different cluster functions
      * for certain fields and inserts defaults if needed
      * @param options
      * @returns {*}
      * @private
      */

    }, {
      key: '_checkOptions',
      value: function _checkOptions() {
        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

        if (options.clusterEdgeProperties === undefined) {
          options.clusterEdgeProperties = {};
        }
        if (options.clusterNodeProperties === undefined) {
          options.clusterNodeProperties = {};
        }

        return options;
      }

      /**
      *
      * @param {Object}    childNodesObj         | object with node objects, id as keys, same as childNodes except it also contains a source node
      * @param {Object}    childEdgesObj         | object with edge objects, id as keys
      * @param {Array}     options               | object with {clusterNodeProperties, clusterEdgeProperties, processProperties}
      * @param {Boolean}   refreshData | when true, do not wrap up
      * @private
      */

    }, {
      key: '_cluster',
      value: function _cluster(childNodesObj, childEdgesObj, options) {
        var refreshData = arguments.length <= 3 || arguments[3] === undefined ? true : arguments[3];

        // kill condition: no children so can't cluster or only one node in the cluster, don't bother
        if (Object.keys(childNodesObj).length < 2) {
          return;
        }

        // check if this cluster call is not trying to cluster anything that is in another cluster.
        for (var nodeId in childNodesObj) {
          if (childNodesObj.hasOwnProperty(nodeId)) {
            if (this.clusteredNodes[nodeId] !== undefined) {
              return;
            }
          }
        }

        var clusterNodeProperties = util.deepExtend({}, options.clusterNodeProperties);

        // construct the clusterNodeProperties
        if (options.processProperties !== undefined) {
          // get the childNode options
          var childNodesOptions = [];
          for (var _nodeId in childNodesObj) {
            if (childNodesObj.hasOwnProperty(_nodeId)) {
              var clonedOptions = _NetworkUtil2.default.cloneOptions(childNodesObj[_nodeId]);
              childNodesOptions.push(clonedOptions);
            }
          }

          // get cluster properties based on childNodes
          var childEdgesOptions = [];
          for (var edgeId in childEdgesObj) {
            if (childEdgesObj.hasOwnProperty(edgeId)) {
              // these cluster edges will be removed on creation of the cluster.
              if (edgeId.substr(0, 12) !== "clusterEdge:") {
                var _clonedOptions = _NetworkUtil2.default.cloneOptions(childEdgesObj[edgeId], 'edge');
                childEdgesOptions.push(_clonedOptions);
              }
            }
          }

          clusterNodeProperties = options.processProperties(clusterNodeProperties, childNodesOptions, childEdgesOptions);
          if (!clusterNodeProperties) {
            throw new Error("The processProperties function does not return properties!");
          }
        }

        // check if we have an unique id;
        if (clusterNodeProperties.id === undefined) {
          clusterNodeProperties.id = 'cluster:' + util.randomUUID();
        }
        var clusterId = clusterNodeProperties.id;

        if (clusterNodeProperties.label === undefined) {
          clusterNodeProperties.label = 'cluster';
        }

        // give the clusterNode a position if it does not have one.
        var pos = undefined;
        if (clusterNodeProperties.x === undefined) {
          pos = this._getClusterPosition(childNodesObj);
          clusterNodeProperties.x = pos.x;
        }
        if (clusterNodeProperties.y === undefined) {
          if (pos === undefined) {
            pos = this._getClusterPosition(childNodesObj);
          }
          clusterNodeProperties.y = pos.y;
        }

        // force the ID to remain the same
        clusterNodeProperties.id = clusterId;

        // create the clusterNode
        var clusterNode = this.body.functions.createNode(clusterNodeProperties, _Cluster2.default);
        clusterNode.isCluster = true;
        clusterNode.containedNodes = childNodesObj;
        clusterNode.containedEdges = childEdgesObj;
        // cache a copy from the cluster edge properties if we have to reconnect others later on
        clusterNode.clusterEdgeProperties = options.clusterEdgeProperties;

        // finally put the cluster node into global
        this.body.nodes[clusterNodeProperties.id] = clusterNode;

        // create the new edges that will connect to the cluster, all self-referencing edges will be added to childEdgesObject here.
        this._createClusterEdges(childNodesObj, childEdgesObj, clusterNodeProperties, options.clusterEdgeProperties);

        // disable the childEdges
        for (var _edgeId in childEdgesObj) {
          if (childEdgesObj.hasOwnProperty(_edgeId)) {
            if (this.body.edges[_edgeId] !== undefined) {
              var edge = this.body.edges[_edgeId];
              // cache the options before changing
              this._backupEdgeOptions(edge);
              // disable physics and hide the edge
              edge.setOptions({ physics: false, hidden: true });
            }
          }
        }

        // disable the childNodes
        for (var _nodeId2 in childNodesObj) {
          if (childNodesObj.hasOwnProperty(_nodeId2)) {
            this.clusteredNodes[_nodeId2] = { clusterId: clusterNodeProperties.id, node: this.body.nodes[_nodeId2] };
            this.body.nodes[_nodeId2].setOptions({ hidden: true, physics: false });
          }
        }

        // set ID to undefined so no duplicates arise
        clusterNodeProperties.id = undefined;

        // wrap up
        if (refreshData === true) {
          this.body.emitter.emit('_dataChanged');
        }
      }
    }, {
      key: '_backupEdgeOptions',
      value: function _backupEdgeOptions(edge) {
        if (this.clusteredEdges[edge.id] === undefined) {
          this.clusteredEdges[edge.id] = { physics: edge.options.physics, hidden: edge.options.hidden };
        }
      }
    }, {
      key: '_restoreEdge',
      value: function _restoreEdge(edge) {
        var originalOptions = this.clusteredEdges[edge.id];
        if (originalOptions !== undefined) {
          edge.setOptions({ physics: originalOptions.physics, hidden: originalOptions.hidden });
          delete this.clusteredEdges[edge.id];
        }
      }

      /**
      * Check if a node is a cluster.
      * @param nodeId
      * @returns {*}
      */

    }, {
      key: 'isCluster',
      value: function isCluster(nodeId) {
        if (this.body.nodes[nodeId] !== undefined) {
          return this.body.nodes[nodeId].isCluster === true;
        } else {
          console.log("Node does not exist.");
          return false;
        }
      }

      /**
      * get the position of the cluster node based on what's inside
      * @param {object} childNodesObj    | object with node objects, id as keys
      * @returns {{x: number, y: number}}
      * @private
      */

    }, {
      key: '_getClusterPosition',
      value: function _getClusterPosition(childNodesObj) {
        var childKeys = Object.keys(childNodesObj);
        var minX = childNodesObj[childKeys[0]].x;
        var maxX = childNodesObj[childKeys[0]].x;
        var minY = childNodesObj[childKeys[0]].y;
        var maxY = childNodesObj[childKeys[0]].y;
        var node = void 0;
        for (var i = 1; i < childKeys.length; i++) {
          node = childNodesObj[childKeys[i]];
          minX = node.x < minX ? node.x : minX;
          maxX = node.x > maxX ? node.x : maxX;
          minY = node.y < minY ? node.y : minY;
          maxY = node.y > maxY ? node.y : maxY;
        }

        return { x: 0.5 * (minX + maxX), y: 0.5 * (minY + maxY) };
      }

      /**
      * Open a cluster by calling this function.
      * @param {String}  clusterNodeId | the ID of the cluster node
      * @param {Boolean} refreshData | wrap up afterwards if not true
      */

    }, {
      key: 'openCluster',
      value: function openCluster(clusterNodeId, options) {
        var refreshData = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];

        // kill conditions
        if (clusterNodeId === undefined) {
          throw new Error("No clusterNodeId supplied to openCluster.");
        }
        if (this.body.nodes[clusterNodeId] === undefined) {
          throw new Error("The clusterNodeId supplied to openCluster does not exist.");
        }
        if (this.body.nodes[clusterNodeId].containedNodes === undefined) {
          console.log("The node:" + clusterNodeId + " is not a cluster.");
          return;
        }
        var clusterNode = this.body.nodes[clusterNodeId];
        var containedNodes = clusterNode.containedNodes;
        var containedEdges = clusterNode.containedEdges;

        // allow the user to position the nodes after release.
        if (options !== undefined && options.releaseFunction !== undefined && typeof options.releaseFunction === 'function') {
          var positions = {};
          var clusterPosition = { x: clusterNode.x, y: clusterNode.y };
          for (var nodeId in containedNodes) {
            if (containedNodes.hasOwnProperty(nodeId)) {
              var containedNode = this.body.nodes[nodeId];
              positions[nodeId] = { x: containedNode.x, y: containedNode.y };
            }
          }
          var newPositions = options.releaseFunction(clusterPosition, positions);

          for (var _nodeId3 in containedNodes) {
            if (containedNodes.hasOwnProperty(_nodeId3)) {
              var _containedNode = this.body.nodes[_nodeId3];
              if (newPositions[_nodeId3] !== undefined) {
                _containedNode.x = newPositions[_nodeId3].x === undefined ? clusterNode.x : newPositions[_nodeId3].x;
                _containedNode.y = newPositions[_nodeId3].y === undefined ? clusterNode.y : newPositions[_nodeId3].y;
              }
            }
          }
        } else {
          // copy the position from the cluster
          for (var _nodeId4 in containedNodes) {
            if (containedNodes.hasOwnProperty(_nodeId4)) {
              var _containedNode2 = this.body.nodes[_nodeId4];
              _containedNode2 = containedNodes[_nodeId4];
              // inherit position
              if (_containedNode2.options.fixed.x === false) {
                _containedNode2.x = clusterNode.x;
              }
              if (_containedNode2.options.fixed.y === false) {
                _containedNode2.y = clusterNode.y;
              }
            }
          }
        }

        // release nodes
        for (var _nodeId5 in containedNodes) {
          if (containedNodes.hasOwnProperty(_nodeId5)) {
            var _containedNode3 = this.body.nodes[_nodeId5];

            // inherit speed
            _containedNode3.vx = clusterNode.vx;
            _containedNode3.vy = clusterNode.vy;

            // we use these methods to avoid re-instantiating the shape, which happens with setOptions.
            _containedNode3.setOptions({ hidden: false, physics: true });

            delete this.clusteredNodes[_nodeId5];
          }
        }

        // copy the clusterNode edges because we cannot iterate over an object that we add or remove from.
        var edgesToBeDeleted = [];
        for (var i = 0; i < clusterNode.edges.length; i++) {
          edgesToBeDeleted.push(clusterNode.edges[i]);
        }

        // actually handling the deleting.
        for (var _i4 = 0; _i4 < edgesToBeDeleted.length; _i4++) {
          var edge = edgesToBeDeleted[_i4];

          var otherNodeId = this._getConnectedId(edge, clusterNodeId);
          // if the other node is in another cluster, we transfer ownership of this edge to the other cluster
          if (this.clusteredNodes[otherNodeId] !== undefined) {
            // transfer ownership:
            var otherCluster = this.body.nodes[this.clusteredNodes[otherNodeId].clusterId];
            var transferEdge = this.body.edges[edge.clusteringEdgeReplacingId];
            if (transferEdge !== undefined) {
              otherCluster.containedEdges[transferEdge.id] = transferEdge;

              // delete local reference
              delete containedEdges[transferEdge.id];

              // create new cluster edge from the otherCluster:
              // get to and from
              var fromId = transferEdge.fromId;
              var toId = transferEdge.toId;
              if (transferEdge.toId == otherNodeId) {
                toId = this.clusteredNodes[otherNodeId].clusterId;
              } else {
                fromId = this.clusteredNodes[otherNodeId].clusterId;
              }

              // clone the options and apply the cluster options to them
              var clonedOptions = _NetworkUtil2.default.cloneOptions(transferEdge, 'edge');
              util.deepExtend(clonedOptions, otherCluster.clusterEdgeProperties);

              // apply the edge specific options to it.
              var id = 'clusterEdge:' + util.randomUUID();
              util.deepExtend(clonedOptions, { from: fromId, to: toId, hidden: false, physics: true, id: id });

              // create it
              var newEdge = this.body.functions.createEdge(clonedOptions);
              newEdge.clusteringEdgeReplacingId = transferEdge.id;
              this.body.edges[id] = newEdge;
              this.body.edges[id].connect();
            }
          } else {
            var replacedEdge = this.body.edges[edge.clusteringEdgeReplacingId];
            if (replacedEdge !== undefined) {
              this._restoreEdge(replacedEdge);
            }
          }
          edge.cleanup();
          // this removes the edge from node.edges, which is why edgeIds is formed
          edge.disconnect();
          delete this.body.edges[edge.id];
        }

        // handle the releasing of the edges
        for (var edgeId in containedEdges) {
          if (containedEdges.hasOwnProperty(edgeId)) {
            this._restoreEdge(containedEdges[edgeId]);
          }
        }

        // remove clusterNode
        delete this.body.nodes[clusterNodeId];

        if (refreshData === true) {
          this.body.emitter.emit('_dataChanged');
        }
      }
    }, {
      key: 'getNodesInCluster',
      value: function getNodesInCluster(clusterId) {
        var nodesArray = [];
        if (this.isCluster(clusterId) === true) {
          var containedNodes = this.body.nodes[clusterId].containedNodes;
          for (var nodeId in containedNodes) {
            if (containedNodes.hasOwnProperty(nodeId)) {
              nodesArray.push(this.body.nodes[nodeId].id);
            }
          }
        }

        return nodesArray;
      }

      /**
      * Get the stack clusterId's that a certain node resides in. cluster A -> cluster B -> cluster C -> node
      * @param nodeId
      * @returns {Array}
      */

    }, {
      key: 'findNode',
      value: function findNode(nodeId) {
        var stack = [];
        var max = 100;
        var counter = 0;

        while (this.clusteredNodes[nodeId] !== undefined && counter < max) {
          stack.push(this.body.nodes[nodeId].id);
          nodeId = this.clusteredNodes[nodeId].clusterId;
          counter++;
        }
        stack.push(this.body.nodes[nodeId].id);
        stack.reverse();

        return stack;
      }

      /**
      * Get the Id the node is connected to
      * @param edge
      * @param nodeId
      * @returns {*}
      * @private
      */

    }, {
      key: '_getConnectedId',
      value: function _getConnectedId(edge, nodeId) {
        if (edge.toId != nodeId) {
          return edge.toId;
        } else if (edge.fromId != nodeId) {
          return edge.fromId;
        } else {
          return edge.fromId;
        }
      }

      /**
      * We determine how many connections denote an important hub.
      * We take the mean + 2*std as the important hub size. (Assuming a normal distribution of data, ~2.2%)
      *
      * @private
      */

    }, {
      key: '_getHubSize',
      value: function _getHubSize() {
        var average = 0;
        var averageSquared = 0;
        var hubCounter = 0;
        var largestHub = 0;

        for (var i = 0; i < this.body.nodeIndices.length; i++) {
          var node = this.body.nodes[this.body.nodeIndices[i]];
          if (node.edges.length > largestHub) {
            largestHub = node.edges.length;
          }
          average += node.edges.length;
          averageSquared += Math.pow(node.edges.length, 2);
          hubCounter += 1;
        }
        average = average / hubCounter;
        averageSquared = averageSquared / hubCounter;

        var variance = averageSquared - Math.pow(average, 2);
        var standardDeviation = Math.sqrt(variance);

        var hubThreshold = Math.floor(average + 2 * standardDeviation);

        // always have at least one to cluster
        if (hubThreshold > largestHub) {
          hubThreshold = largestHub;
        }

        return hubThreshold;
      }
    }]);

    return ClusterEngine;
  }();

  exports.default = ClusterEngine;

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);

  var NetworkUtil = function () {
    function NetworkUtil() {
      _classCallCheck(this, NetworkUtil);
    }

    /**
     * Find the center position of the network considering the bounding boxes
     */


    _createClass(NetworkUtil, null, [{
      key: "getRange",
      value: function getRange(allNodes) {
        var specificNodes = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];

        var minY = 1e9,
            maxY = -1e9,
            minX = 1e9,
            maxX = -1e9,
            node;
        if (specificNodes.length > 0) {
          for (var i = 0; i < specificNodes.length; i++) {
            node = allNodes[specificNodes[i]];
            if (minX > node.shape.boundingBox.left) {
              minX = node.shape.boundingBox.left;
            }
            if (maxX < node.shape.boundingBox.right) {
              maxX = node.shape.boundingBox.right;
            }
            if (minY > node.shape.boundingBox.top) {
              minY = node.shape.boundingBox.top;
            } // top is negative, bottom is positive
            if (maxY < node.shape.boundingBox.bottom) {
              maxY = node.shape.boundingBox.bottom;
            } // top is negative, bottom is positive
          }
        }

        if (minX === 1e9 && maxX === -1e9 && minY === 1e9 && maxY === -1e9) {
          minY = 0, maxY = 0, minX = 0, maxX = 0;
        }
        return { minX: minX, maxX: maxX, minY: minY, maxY: maxY };
      }

      /**
       * Find the center position of the network
       */

    }, {
      key: "getRangeCore",
      value: function getRangeCore(allNodes) {
        var specificNodes = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];

        var minY = 1e9,
            maxY = -1e9,
            minX = 1e9,
            maxX = -1e9,
            node;
        if (specificNodes.length > 0) {
          for (var i = 0; i < specificNodes.length; i++) {
            node = allNodes[specificNodes[i]];
            if (minX > node.x) {
              minX = node.x;
            }
            if (maxX < node.x) {
              maxX = node.x;
            }
            if (minY > node.y) {
              minY = node.y;
            } // top is negative, bottom is positive
            if (maxY < node.y) {
              maxY = node.y;
            } // top is negative, bottom is positive
          }
        }

        if (minX === 1e9 && maxX === -1e9 && minY === 1e9 && maxY === -1e9) {
          minY = 0, maxY = 0, minX = 0, maxX = 0;
        }
        return { minX: minX, maxX: maxX, minY: minY, maxY: maxY };
      }

      /**
       * @param {object} range = {minX: minX, maxX: maxX, minY: minY, maxY: maxY};
       * @returns {{x: number, y: number}}
       */

    }, {
      key: "findCenter",
      value: function findCenter(range) {
        return { x: 0.5 * (range.maxX + range.minX),
          y: 0.5 * (range.maxY + range.minY) };
      }

      /**
       * This returns a clone of the options or options of the edge or node to be used for construction of new edges or check functions for new nodes.
       * @param item
       * @param type
       * @returns {{}}
       */

    }, {
      key: "cloneOptions",
      value: function cloneOptions(item, type) {
        var clonedOptions = {};
        if (type === undefined || type === 'node') {
          util.deepExtend(clonedOptions, item.options, true);
          clonedOptions.x = item.x;
          clonedOptions.y = item.y;
          clonedOptions.amountOfConnections = item.edges.length;
        } else {
          util.deepExtend(clonedOptions, item.options, true);
        }
        return clonedOptions;
      }
    }]);

    return NetworkUtil;
  }();

  exports.default = NetworkUtil;

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _Node2 = __webpack_require__(65);

  var _Node3 = _interopRequireDefault(_Node2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  /**
   *
   */

  var Cluster = function (_Node) {
    _inherits(Cluster, _Node);

    function Cluster(options, body, imagelist, grouplist, globalOptions) {
      _classCallCheck(this, Cluster);

      var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Cluster).call(this, options, body, imagelist, grouplist, globalOptions));

      _this.isCluster = true;
      _this.containedNodes = {};
      _this.containedEdges = {};
      return _this;
    }

    return Cluster;
  }(_Node3.default);

  exports.default = Cluster;

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  if (typeof window !== 'undefined') {
    window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
  }

  var util = __webpack_require__(1);

  var CanvasRenderer = function () {
    function CanvasRenderer(body, canvas) {
      _classCallCheck(this, CanvasRenderer);

      this.body = body;
      this.canvas = canvas;

      this.redrawRequested = false;
      this.renderTimer = undefined;
      this.requiresTimeout = true;
      this.renderingActive = false;
      this.renderRequests = 0;
      this.pixelRatio = undefined;
      this.allowRedraw = true;

      this.dragging = false;
      this.options = {};
      this.defaultOptions = {
        hideEdgesOnDrag: false,
        hideNodesOnDrag: false
      };
      util.extend(this.options, this.defaultOptions);

      this._determineBrowserMethod();
      this.bindEventListeners();
    }

    _createClass(CanvasRenderer, [{
      key: 'bindEventListeners',
      value: function bindEventListeners() {
        var _this = this;

        this.body.emitter.on("dragStart", function () {
          _this.dragging = true;
        });
        this.body.emitter.on("dragEnd", function () {
          return _this.dragging = false;
        });
        this.body.emitter.on("_resizeNodes", function () {
          return _this._resizeNodes();
        });
        this.body.emitter.on("_redraw", function () {
          if (_this.renderingActive === false) {
            _this._redraw();
          }
        });
        this.body.emitter.on("_blockRedraw", function () {
          _this.allowRedraw = false;
        });
        this.body.emitter.on("_allowRedraw", function () {
          _this.allowRedraw = true;_this.redrawRequested = false;
        });
        this.body.emitter.on("_requestRedraw", this._requestRedraw.bind(this));
        this.body.emitter.on("_startRendering", function () {
          _this.renderRequests += 1;
          _this.renderingActive = true;
          _this._startRendering();
        });
        this.body.emitter.on("_stopRendering", function () {
          _this.renderRequests -= 1;
          _this.renderingActive = _this.renderRequests > 0;
          _this.renderTimer = undefined;
        });
        this.body.emitter.on('destroy', function () {
          _this.renderRequests = 0;
          _this.allowRedraw = false;
          _this.renderingActive = false;
          if (_this.requiresTimeout === true) {
            clearTimeout(_this.renderTimer);
          } else {
            cancelAnimationFrame(_this.renderTimer);
          }
          _this.body.emitter.off();
        });
      }
    }, {
      key: 'setOptions',
      value: function setOptions(options) {
        if (options !== undefined) {
          var fields = ['hideEdgesOnDrag', 'hideNodesOnDrag'];
          util.selectiveDeepExtend(fields, this.options, options);
        }
      }
    }, {
      key: '_startRendering',
      value: function _startRendering() {
        if (this.renderingActive === true) {
          if (this.renderTimer === undefined) {
            if (this.requiresTimeout === true) {
              this.renderTimer = window.setTimeout(this._renderStep.bind(this), this.simulationInterval); // wait this.renderTimeStep milliseconds and perform the animation step function
            } else {
                this.renderTimer = window.requestAnimationFrame(this._renderStep.bind(this)); // wait this.renderTimeStep milliseconds and perform the animation step function
              }
          }
        }
      }
    }, {
      key: '_renderStep',
      value: function _renderStep() {
        if (this.renderingActive === true) {
          // reset the renderTimer so a new scheduled animation step can be set
          this.renderTimer = undefined;

          if (this.requiresTimeout === true) {
            // this schedules a new simulation step
            this._startRendering();
          }

          this._redraw();

          if (this.requiresTimeout === false) {
            // this schedules a new simulation step
            this._startRendering();
          }
        }
      }

      /**
       * Redraw the network with the current data
       * chart will be resized too.
       */

    }, {
      key: 'redraw',
      value: function redraw() {
        this.body.emitter.emit('setSize');
        this._redraw();
      }

      /**
       * Redraw the network with the current data
       * @param hidden | used to get the first estimate of the node sizes. only the nodes are drawn after which they are quickly drawn over.
       * @private
       */

    }, {
      key: '_requestRedraw',
      value: function _requestRedraw() {
        var _this2 = this;

        if (this.redrawRequested !== true && this.renderingActive === false && this.allowRedraw === true) {
          this.redrawRequested = true;
          if (this.requiresTimeout === true) {
            window.setTimeout(function () {
              _this2._redraw(false);
            }, 0);
          } else {
            window.requestAnimationFrame(function () {
              _this2._redraw(false);
            });
          }
        }
      }
    }, {
      key: '_redraw',
      value: function _redraw() {
        var hidden = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];

        if (this.allowRedraw === true) {
          this.body.emitter.emit("initRedraw");

          this.redrawRequested = false;
          var ctx = this.canvas.frame.canvas.getContext('2d');

          // when the container div was hidden, this fixes it back up!
          if (this.canvas.frame.canvas.width === 0 || this.canvas.frame.canvas.height === 0) {
            this.canvas.setSize();
          }

          this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);

          ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);

          // clear the canvas
          var w = this.canvas.frame.canvas.clientWidth;
          var h = this.canvas.frame.canvas.clientHeight;
          ctx.clearRect(0, 0, w, h);

          // if the div is hidden, we stop the redraw here for performance.
          if (this.canvas.frame.clientWidth === 0) {
            return;
          }

          // set scaling and translation
          ctx.save();
          ctx.translate(this.body.view.translation.x, this.body.view.translation.y);
          ctx.scale(this.body.view.scale, this.body.view.scale);

          ctx.beginPath();
          this.body.emitter.emit("beforeDrawing", ctx);
          ctx.closePath();

          if (hidden === false) {
            if (this.dragging === false || this.dragging === true && this.options.hideEdgesOnDrag === false) {
              this._drawEdges(ctx);
            }
          }

          if (this.dragging === false || this.dragging === true && this.options.hideNodesOnDrag === false) {
            this._drawNodes(ctx, hidden);
          }

          ctx.beginPath();
          this.body.emitter.emit("afterDrawing", ctx);
          ctx.closePath();

          // restore original scaling and translation
          ctx.restore();
          if (hidden === true) {
            ctx.clearRect(0, 0, w, h);
          }
        }
      }

      /**
       * Redraw all nodes
       * The 2d context of a HTML canvas can be retrieved by canvas.getContext('2d');
       * @param {CanvasRenderingContext2D}   ctx
       * @param {Boolean} [alwaysShow]
       * @private
       */

    }, {
      key: '_resizeNodes',
      value: function _resizeNodes() {
        var ctx = this.canvas.frame.canvas.getContext('2d');
        if (this.pixelRatio === undefined) {
          this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
        }
        ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
        ctx.save();
        ctx.translate(this.body.view.translation.x, this.body.view.translation.y);
        ctx.scale(this.body.view.scale, this.body.view.scale);

        var nodes = this.body.nodes;
        var node = void 0;

        // resize all nodes
        for (var nodeId in nodes) {
          if (nodes.hasOwnProperty(nodeId)) {
            node = nodes[nodeId];
            node.resize(ctx);
            node.updateBoundingBox(ctx, node.selected);
          }
        }

        // restore original scaling and translation
        ctx.restore();
      }

      /**
       * Redraw all nodes
       * The 2d context of a HTML canvas can be retrieved by canvas.getContext('2d');
       * @param {CanvasRenderingContext2D}   ctx
       * @param {Boolean} [alwaysShow]
       * @private
       */

    }, {
      key: '_drawNodes',
      value: function _drawNodes(ctx) {
        var alwaysShow = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

        var nodes = this.body.nodes;
        var nodeIndices = this.body.nodeIndices;
        var node = void 0;
        var selected = [];
        var margin = 20;
        var topLeft = this.canvas.DOMtoCanvas({ x: -margin, y: -margin });
        var bottomRight = this.canvas.DOMtoCanvas({
          x: this.canvas.frame.canvas.clientWidth + margin,
          y: this.canvas.frame.canvas.clientHeight + margin
        });
        var viewableArea = { top: topLeft.y, left: topLeft.x, bottom: bottomRight.y, right: bottomRight.x };

        // draw unselected nodes;
        for (var i = 0; i < nodeIndices.length; i++) {
          node = nodes[nodeIndices[i]];
          // set selected nodes aside
          if (node.isSelected()) {
            selected.push(nodeIndices[i]);
          } else {
            if (alwaysShow === true) {
              node.draw(ctx);
            } else if (node.isBoundingBoxOverlappingWith(viewableArea) === true) {
              node.draw(ctx);
            } else {
              node.updateBoundingBox(ctx, node.selected);
            }
          }
        }

        // draw the selected nodes on top
        for (var _i = 0; _i < selected.length; _i++) {
          node = nodes[selected[_i]];
          node.draw(ctx);
        }
      }

      /**
       * Redraw all edges
       * The 2d context of a HTML canvas can be retrieved by canvas.getContext('2d');
       * @param {CanvasRenderingContext2D}   ctx
       * @private
       */

    }, {
      key: '_drawEdges',
      value: function _drawEdges(ctx) {
        var edges = this.body.edges;
        var edgeIndices = this.body.edgeIndices;
        var edge = void 0;

        for (var i = 0; i < edgeIndices.length; i++) {
          edge = edges[edgeIndices[i]];
          if (edge.connected === true) {
            edge.draw(ctx);
          }
        }
      }

      /**
       * Determine if the browser requires a setTimeout or a requestAnimationFrame. This was required because
       * some implementations (safari and IE9) did not support requestAnimationFrame
       * @private
       */

    }, {
      key: '_determineBrowserMethod',
      value: function _determineBrowserMethod() {
        if (typeof window !== 'undefined') {
          var browserType = navigator.userAgent.toLowerCase();
          this.requiresTimeout = false;
          if (browserType.indexOf('msie 9.0') != -1) {
            // IE 9
            this.requiresTimeout = true;
          } else if (browserType.indexOf('safari') != -1) {
            // safari
            if (browserType.indexOf('chrome') <= -1) {
              this.requiresTimeout = true;
            }
          }
        } else {
          this.requiresTimeout = true;
        }
      }
    }]);

    return CanvasRenderer;
  }();

  exports.default = CanvasRenderer;

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var Hammer = __webpack_require__(20);
  var hammerUtil = __webpack_require__(28);

  var util = __webpack_require__(1);

  /**
   * Create the main frame for the Network.
   * This function is executed once when a Network object is created. The frame
   * contains a canvas, and this canvas contains all objects like the axis and
   * nodes.
   * @private
   */

  var Canvas = function () {
    function Canvas(body) {
      _classCallCheck(this, Canvas);

      this.body = body;
      this.pixelRatio = 1;
      this.resizeTimer = undefined;
      this.resizeFunction = this._onResize.bind(this);
      this.cameraState = {};
      this.initialized = false;

      this.options = {};
      this.defaultOptions = {
        autoResize: true,
        height: '100%',
        width: '100%'
      };
      util.extend(this.options, this.defaultOptions);

      this.bindEventListeners();
    }

    _createClass(Canvas, [{
      key: 'bindEventListeners',
      value: function bindEventListeners() {
        var _this = this;

        // bind the events
        this.body.emitter.once("resize", function (obj) {
          if (obj.width !== 0) {
            _this.body.view.translation.x = obj.width * 0.5;
          }
          if (obj.height !== 0) {
            _this.body.view.translation.y = obj.height * 0.5;
          }
        });
        this.body.emitter.on("setSize", this.setSize.bind(this));
        this.body.emitter.on("destroy", function () {
          _this.hammerFrame.destroy();
          _this.hammer.destroy();
          _this._cleanUp();
        });
      }
    }, {
      key: 'setOptions',
      value: function setOptions(options) {
        var _this2 = this;

        if (options !== undefined) {
          var fields = ['width', 'height', 'autoResize'];
          util.selectiveDeepExtend(fields, this.options, options);
        }

        if (this.options.autoResize === true) {
          // automatically adapt to a changing size of the browser.
          this._cleanUp();
          this.resizeTimer = setInterval(function () {
            var changed = _this2.setSize();
            if (changed === true) {
              _this2.body.emitter.emit("_requestRedraw");
            }
          }, 1000);
          this.resizeFunction = this._onResize.bind(this);
          util.addEventListener(window, 'resize', this.resizeFunction);
        }
      }
    }, {
      key: '_cleanUp',
      value: function _cleanUp() {
        // automatically adapt to a changing size of the browser.
        if (this.resizeTimer !== undefined) {
          clearInterval(this.resizeTimer);
        }
        util.removeEventListener(window, 'resize', this.resizeFunction);
        this.resizeFunction = undefined;
      }
    }, {
      key: '_onResize',
      value: function _onResize() {
        this.setSize();
        this.body.emitter.emit("_redraw");
      }

      /**
       * Get and store the cameraState
       * @private
       */

    }, {
      key: '_getCameraState',
      value: function _getCameraState() {
        var pixelRatio = arguments.length <= 0 || arguments[0] === undefined ? this.pixelRatio : arguments[0];

        if (this.initialized === true) {
          this.cameraState.previousWidth = this.frame.canvas.width / pixelRatio;
          this.cameraState.previousHeight = this.frame.canvas.height / pixelRatio;
          this.cameraState.scale = this.body.view.scale;
          this.cameraState.position = this.DOMtoCanvas({
            x: 0.5 * this.frame.canvas.width / pixelRatio,
            y: 0.5 * this.frame.canvas.height / pixelRatio
          });
        }
      }

      /**
       * Set the cameraState
       * @private
       */

    }, {
      key: '_setCameraState',
      value: function _setCameraState() {
        if (this.cameraState.scale !== undefined && this.frame.canvas.clientWidth !== 0 && this.frame.canvas.clientHeight !== 0 && this.pixelRatio !== 0 && this.cameraState.previousWidth > 0) {

          var widthRatio = this.frame.canvas.width / this.pixelRatio / this.cameraState.previousWidth;
          var heightRatio = this.frame.canvas.height / this.pixelRatio / this.cameraState.previousHeight;
          var newScale = this.cameraState.scale;

          if (widthRatio != 1 && heightRatio != 1) {
            newScale = this.cameraState.scale * 0.5 * (widthRatio + heightRatio);
          } else if (widthRatio != 1) {
            newScale = this.cameraState.scale * widthRatio;
          } else if (heightRatio != 1) {
            newScale = this.cameraState.scale * heightRatio;
          }

          this.body.view.scale = newScale;
          // this comes from the view module.
          var currentViewCenter = this.DOMtoCanvas({
            x: 0.5 * this.frame.canvas.clientWidth,
            y: 0.5 * this.frame.canvas.clientHeight
          });

          var distanceFromCenter = { // offset from view, distance view has to change by these x and y to center the node
            x: currentViewCenter.x - this.cameraState.position.x,
            y: currentViewCenter.y - this.cameraState.position.y
          };
          this.body.view.translation.x += distanceFromCenter.x * this.body.view.scale;
          this.body.view.translation.y += distanceFromCenter.y * this.body.view.scale;
        }
      }
    }, {
      key: '_prepareValue',
      value: function _prepareValue(value) {
        if (typeof value === 'number') {
          return value + 'px';
        } else if (typeof value === 'string') {
          if (value.indexOf('%') !== -1 || value.indexOf('px') !== -1) {
            return value;
          } else if (value.indexOf('%') === -1) {
            return value + 'px';
          }
        }
        throw new Error('Could not use the value supplied for width or height:' + value);
      }

      /**
       * Create the HTML
       */

    }, {
      key: '_create',
      value: function _create() {
        // remove all elements from the container element.
        while (this.body.container.hasChildNodes()) {
          this.body.container.removeChild(this.body.container.firstChild);
        }

        this.frame = document.createElement('div');
        this.frame.className = 'vis-network';
        this.frame.style.position = 'relative';
        this.frame.style.overflow = 'hidden';
        this.frame.tabIndex = 900; // tab index is required for keycharm to bind keystrokes to the div instead of the window

        //////////////////////////////////////////////////////////////////

        this.frame.canvas = document.createElement("canvas");
        this.frame.canvas.style.position = 'relative';
        this.frame.appendChild(this.frame.canvas);

        if (!this.frame.canvas.getContext) {
          var noCanvas = document.createElement('DIV');
          noCanvas.style.color = 'red';
          noCanvas.style.fontWeight = 'bold';
          noCanvas.style.padding = '10px';
          noCanvas.innerHTML = 'Error: your browser does not support HTML canvas';
          this.frame.canvas.appendChild(noCanvas);
        } else {
          var ctx = this.frame.canvas.getContext("2d");
          this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);

          this.frame.canvas.getContext("2d").setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
        }

        // add the frame to the container element
        this.body.container.appendChild(this.frame);

        this.body.view.scale = 1;
        this.body.view.translation = { x: 0.5 * this.frame.canvas.clientWidth, y: 0.5 * this.frame.canvas.clientHeight };

        this._bindHammer();
      }

      /**
       * This function binds hammer, it can be repeated over and over due to the uniqueness check.
       * @private
       */

    }, {
      key: '_bindHammer',
      value: function _bindHammer() {
        var _this3 = this;

        if (this.hammer !== undefined) {
          this.hammer.destroy();
        }
        this.drag = {};
        this.pinch = {};

        // init hammer
        this.hammer = new Hammer(this.frame.canvas);
        this.hammer.get('pinch').set({ enable: true });
        // enable to get better response, todo: test on mobile.
        this.hammer.get('pan').set({ threshold: 5, direction: Hammer.DIRECTION_ALL });

        hammerUtil.onTouch(this.hammer, function (event) {
          _this3.body.eventListeners.onTouch(event);
        });
        this.hammer.on('tap', function (event) {
          _this3.body.eventListeners.onTap(event);
        });
        this.hammer.on('doubletap', function (event) {
          _this3.body.eventListeners.onDoubleTap(event);
        });
        this.hammer.on('press', function (event) {
          _this3.body.eventListeners.onHold(event);
        });
        this.hammer.on('panstart', function (event) {
          _this3.body.eventListeners.onDragStart(event);
        });
        this.hammer.on('panmove', function (event) {
          _this3.body.eventListeners.onDrag(event);
        });
        this.hammer.on('panend', function (event) {
          _this3.body.eventListeners.onDragEnd(event);
        });
        this.hammer.on('pinch', function (event) {
          _this3.body.eventListeners.onPinch(event);
        });

        // TODO: neatly cleanup these handlers when re-creating the Canvas, IF these are done with hammer, event.stopPropagation will not work?
        this.frame.canvas.addEventListener('mousewheel', function (event) {
          _this3.body.eventListeners.onMouseWheel(event);
        });
        this.frame.canvas.addEventListener('DOMMouseScroll', function (event) {
          _this3.body.eventListeners.onMouseWheel(event);
        });

        this.frame.canvas.addEventListener('mousemove', function (event) {
          _this3.body.eventListeners.onMouseMove(event);
        });
        this.frame.canvas.addEventListener('contextmenu', function (event) {
          _this3.body.eventListeners.onContext(event);
        });

        this.hammerFrame = new Hammer(this.frame);
        hammerUtil.onRelease(this.hammerFrame, function (event) {
          _this3.body.eventListeners.onRelease(event);
        });
      }

      /**
       * Set a new size for the network
       * @param {string} width   Width in pixels or percentage (for example '800px'
       *                         or '50%')
       * @param {string} height  Height in pixels or percentage  (for example '400px'
       *                         or '30%')
       */

    }, {
      key: 'setSize',
      value: function setSize() {
        var width = arguments.length <= 0 || arguments[0] === undefined ? this.options.width : arguments[0];
        var height = arguments.length <= 1 || arguments[1] === undefined ? this.options.height : arguments[1];

        width = this._prepareValue(width);
        height = this._prepareValue(height);

        var emitEvent = false;
        var oldWidth = this.frame.canvas.width;
        var oldHeight = this.frame.canvas.height;

        // update the pixel ratio
        var ctx = this.frame.canvas.getContext("2d");
        var previousRatio = this.pixelRatio; // we cache this because the camera state storage needs the old value
        this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);

        if (width != this.options.width || height != this.options.height || this.frame.style.width != width || this.frame.style.height != height) {
          this._getCameraState(previousRatio);

          this.frame.style.width = width;
          this.frame.style.height = height;

          this.frame.canvas.style.width = '100%';
          this.frame.canvas.style.height = '100%';

          this.frame.canvas.width = Math.round(this.frame.canvas.clientWidth * this.pixelRatio);
          this.frame.canvas.height = Math.round(this.frame.canvas.clientHeight * this.pixelRatio);

          this.options.width = width;
          this.options.height = height;

          emitEvent = true;
        } else {
          // this would adapt the width of the canvas to the width from 100% if and only if
          // there is a change.

          // store the camera if there is a change in size.
          if (this.frame.canvas.width != Math.round(this.frame.canvas.clientWidth * this.pixelRatio) || this.frame.canvas.height != Math.round(this.frame.canvas.clientHeight * this.pixelRatio)) {
            this._getCameraState(previousRatio);
          }

          if (this.frame.canvas.width != Math.round(this.frame.canvas.clientWidth * this.pixelRatio)) {
            this.frame.canvas.width = Math.round(this.frame.canvas.clientWidth * this.pixelRatio);
            emitEvent = true;
          }
          if (this.frame.canvas.height != Math.round(this.frame.canvas.clientHeight * this.pixelRatio)) {
            this.frame.canvas.height = Math.round(this.frame.canvas.clientHeight * this.pixelRatio);
            emitEvent = true;
          }
        }

        if (emitEvent === true) {
          this.body.emitter.emit('resize', {
            width: Math.round(this.frame.canvas.width / this.pixelRatio),
            height: Math.round(this.frame.canvas.height / this.pixelRatio),
            oldWidth: Math.round(oldWidth / this.pixelRatio),
            oldHeight: Math.round(oldHeight / this.pixelRatio)
          });

          // restore the camera on change.
          this._setCameraState();
        }

        // set initialized so the get and set camera will work from now on.
        this.initialized = true;
        return emitEvent;
      }
    }, {
      key: '_XconvertDOMtoCanvas',


      /**
       * Convert the X coordinate in DOM-space (coordinate point in browser relative to the container div) to
       * the X coordinate in canvas-space (the simulation sandbox, which the camera looks upon)
       * @param {number} x
       * @returns {number}
       * @private
       */
      value: function _XconvertDOMtoCanvas(x) {
        return (x - this.body.view.translation.x) / this.body.view.scale;
      }

      /**
       * Convert the X coordinate in canvas-space (the simulation sandbox, which the camera looks upon) to
       * the X coordinate in DOM-space (coordinate point in browser relative to the container div)
       * @param {number} x
       * @returns {number}
       * @private
       */

    }, {
      key: '_XconvertCanvasToDOM',
      value: function _XconvertCanvasToDOM(x) {
        return x * this.body.view.scale + this.body.view.translation.x;
      }

      /**
       * Convert the Y coordinate in DOM-space (coordinate point in browser relative to the container div) to
       * the Y coordinate in canvas-space (the simulation sandbox, which the camera looks upon)
       * @param {number} y
       * @returns {number}
       * @private
       */

    }, {
      key: '_YconvertDOMtoCanvas',
      value: function _YconvertDOMtoCanvas(y) {
        return (y - this.body.view.translation.y) / this.body.view.scale;
      }

      /**
       * Convert the Y coordinate in canvas-space (the simulation sandbox, which the camera looks upon) to
       * the Y coordinate in DOM-space (coordinate point in browser relative to the container div)
       * @param {number} y
       * @returns {number}
       * @private
       */

    }, {
      key: '_YconvertCanvasToDOM',
      value: function _YconvertCanvasToDOM(y) {
        return y * this.body.view.scale + this.body.view.translation.y;
      }

      /**
       *
       * @param {object} pos   = {x: number, y: number}
       * @returns {{x: number, y: number}}
       * @constructor
       */

    }, {
      key: 'canvasToDOM',
      value: function canvasToDOM(pos) {
        return { x: this._XconvertCanvasToDOM(pos.x), y: this._YconvertCanvasToDOM(pos.y) };
      }

      /**
       *
       * @param {object} pos   = {x: number, y: number}
       * @returns {{x: number, y: number}}
       * @constructor
       */

    }, {
      key: 'DOMtoCanvas',
      value: function DOMtoCanvas(pos) {
        return { x: this._XconvertDOMtoCanvas(pos.x), y: this._YconvertDOMtoCanvas(pos.y) };
      }
    }]);

    return Canvas;
  }();

  exports.default = Canvas;

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _NetworkUtil = __webpack_require__(103);

  var _NetworkUtil2 = _interopRequireDefault(_NetworkUtil);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);

  var View = function () {
    function View(body, canvas) {
      var _this = this;

      _classCallCheck(this, View);

      this.body = body;
      this.canvas = canvas;

      this.animationSpeed = 1 / this.renderRefreshRate;
      this.animationEasingFunction = "easeInOutQuint";
      this.easingTime = 0;
      this.sourceScale = 0;
      this.targetScale = 0;
      this.sourceTranslation = 0;
      this.targetTranslation = 0;
      this.lockedOnNodeId = undefined;
      this.lockedOnNodeOffset = undefined;
      this.touchTime = 0;

      this.viewFunction = undefined;

      this.body.emitter.on("fit", this.fit.bind(this));
      this.body.emitter.on("animationFinished", function () {
        _this.body.emitter.emit("_stopRendering");
      });
      this.body.emitter.on("unlockNode", this.releaseNode.bind(this));
    }

    _createClass(View, [{
      key: 'setOptions',
      value: function setOptions() {
        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

        this.options = options;
      }

      /**
       * This function zooms out to fit all data on screen based on amount of nodes
       * @param {Object} Options
       * @param {Boolean} [initialZoom]  | zoom based on fitted formula or range, true = fitted, default = false;
       */

    }, {
      key: 'fit',
      value: function fit() {
        var options = arguments.length <= 0 || arguments[0] === undefined ? { nodes: [] } : arguments[0];
        var initialZoom = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

        var range = void 0;
        var zoomLevel = void 0;
        if (options.nodes === undefined || options.nodes.length === 0) {
          options.nodes = this.body.nodeIndices;
        }

        if (initialZoom === true) {
          // check if more than half of the nodes have a predefined position. If so, we use the range, not the approximation.
          var positionDefined = 0;
          for (var nodeId in this.body.nodes) {
            if (this.body.nodes.hasOwnProperty(nodeId)) {
              var node = this.body.nodes[nodeId];
              if (node.predefinedPosition === true) {
                positionDefined += 1;
              }
            }
          }
          if (positionDefined > 0.5 * this.body.nodeIndices.length) {
            this.fit(options, false);
            return;
          }

          range = _NetworkUtil2.default.getRange(this.body.nodes, options.nodes);

          var numberOfNodes = this.body.nodeIndices.length;
          zoomLevel = 12.662 / (numberOfNodes + 7.4147) + 0.0964822; // this is obtained from fitting a dataset from 5 points with scale levels that looked good.

          // correct for larger canvasses.
          var factor = Math.min(this.canvas.frame.canvas.clientWidth / 600, this.canvas.frame.canvas.clientHeight / 600);
          zoomLevel *= factor;
        } else {
          this.body.emitter.emit("_resizeNodes");
          range = _NetworkUtil2.default.getRange(this.body.nodes, options.nodes);

          var xDistance = Math.abs(range.maxX - range.minX) * 1.1;
          var yDistance = Math.abs(range.maxY - range.minY) * 1.1;

          var xZoomLevel = this.canvas.frame.canvas.clientWidth / xDistance;
          var yZoomLevel = this.canvas.frame.canvas.clientHeight / yDistance;

          zoomLevel = xZoomLevel <= yZoomLevel ? xZoomLevel : yZoomLevel;
        }

        if (zoomLevel > 1.0) {
          zoomLevel = 1.0;
        } else if (zoomLevel === 0) {
          zoomLevel = 1.0;
        }

        var center = _NetworkUtil2.default.findCenter(range);
        var animationOptions = { position: center, scale: zoomLevel, animation: options.animation };
        this.moveTo(animationOptions);
      }

      // animation

      /**
       * Center a node in view.
       *
       * @param {Number} nodeId
       * @param {Number} [options]
       */

    }, {
      key: 'focus',
      value: function focus(nodeId) {
        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        if (this.body.nodes[nodeId] !== undefined) {
          var nodePosition = { x: this.body.nodes[nodeId].x, y: this.body.nodes[nodeId].y };
          options.position = nodePosition;
          options.lockedOnNode = nodeId;

          this.moveTo(options);
        } else {
          console.log("Node: " + nodeId + " cannot be found.");
        }
      }

      /**
       *
       * @param {Object} options  |  options.offset   = {x:Number, y:Number}   // offset from the center in DOM pixels
       *                          |  options.scale    = Number                 // scale to move to
       *                          |  options.position = {x:Number, y:Number}   // position to move to
       *                          |  options.animation = {duration:Number, easingFunction:String} || Boolean   // position to move to
       */

    }, {
      key: 'moveTo',
      value: function moveTo(options) {
        if (options === undefined) {
          options = {};
          return;
        }
        if (options.offset === undefined) {
          options.offset = { x: 0, y: 0 };
        }
        if (options.offset.x === undefined) {
          options.offset.x = 0;
        }
        if (options.offset.y === undefined) {
          options.offset.y = 0;
        }
        if (options.scale === undefined) {
          options.scale = this.body.view.scale;
        }
        if (options.position === undefined) {
          options.position = this.getViewPosition();
        }
        if (options.animation === undefined) {
          options.animation = { duration: 0 };
        }
        if (options.animation === false) {
          options.animation = { duration: 0 };
        }
        if (options.animation === true) {
          options.animation = {};
        }
        if (options.animation.duration === undefined) {
          options.animation.duration = 1000;
        } // default duration
        if (options.animation.easingFunction === undefined) {
          options.animation.easingFunction = "easeInOutQuad";
        } // default easing function

        this.animateView(options);
      }

      /**
       *
       * @param {Object} options  |  options.offset   = {x:Number, y:Number}   // offset from the center in DOM pixels
       *                          |  options.time     = Number                 // animation time in milliseconds
       *                          |  options.scale    = Number                 // scale to animate to
       *                          |  options.position = {x:Number, y:Number}   // position to animate to
       *                          |  options.easingFunction = String           // linear, easeInQuad, easeOutQuad, easeInOutQuad,
       *                                                                       // easeInCubic, easeOutCubic, easeInOutCubic,
       *                                                                       // easeInQuart, easeOutQuart, easeInOutQuart,
       *                                                                       // easeInQuint, easeOutQuint, easeInOutQuint
       */

    }, {
      key: 'animateView',
      value: function animateView(options) {
        if (options === undefined) {
          return;
        }
        this.animationEasingFunction = options.animation.easingFunction;
        // release if something focussed on the node
        this.releaseNode();
        if (options.locked === true) {
          this.lockedOnNodeId = options.lockedOnNode;
          this.lockedOnNodeOffset = options.offset;
        }

        // forcefully complete the old animation if it was still running
        if (this.easingTime != 0) {
          this._transitionRedraw(true); // by setting easingtime to 1, we finish the animation.
        }

        this.sourceScale = this.body.view.scale;
        this.sourceTranslation = this.body.view.translation;
        this.targetScale = options.scale;

        // set the scale so the viewCenter is based on the correct zoom level. This is overridden in the transitionRedraw
        // but at least then we'll have the target transition
        this.body.view.scale = this.targetScale;
        var viewCenter = this.canvas.DOMtoCanvas({ x: 0.5 * this.canvas.frame.canvas.clientWidth, y: 0.5 * this.canvas.frame.canvas.clientHeight });

        var distanceFromCenter = { // offset from view, distance view has to change by these x and y to center the node
          x: viewCenter.x - options.position.x,
          y: viewCenter.y - options.position.y
        };
        this.targetTranslation = {
          x: this.sourceTranslation.x + distanceFromCenter.x * this.targetScale + options.offset.x,
          y: this.sourceTranslation.y + distanceFromCenter.y * this.targetScale + options.offset.y
        };

        // if the time is set to 0, don't do an animation
        if (options.animation.duration === 0) {
          if (this.lockedOnNodeId != undefined) {
            this.viewFunction = this._lockedRedraw.bind(this);
            this.body.emitter.on("initRedraw", this.viewFunction);
          } else {
            this.body.view.scale = this.targetScale;
            this.body.view.translation = this.targetTranslation;
            this.body.emitter.emit("_requestRedraw");
          }
        } else {
          this.animationSpeed = 1 / (60 * options.animation.duration * 0.001) || 1 / 60; // 60 for 60 seconds, 0.001 for milli's
          this.animationEasingFunction = options.animation.easingFunction;

          this.viewFunction = this._transitionRedraw.bind(this);
          this.body.emitter.on("initRedraw", this.viewFunction);
          this.body.emitter.emit("_startRendering");
        }
      }

      /**
       * used to animate smoothly by hijacking the redraw function.
       * @private
       */

    }, {
      key: '_lockedRedraw',
      value: function _lockedRedraw() {
        var nodePosition = { x: this.body.nodes[this.lockedOnNodeId].x, y: this.body.nodes[this.lockedOnNodeId].y };
        var viewCenter = this.canvas.DOMtoCanvas({ x: 0.5 * this.canvas.frame.canvas.clientWidth, y: 0.5 * this.canvas.frame.canvas.clientHeight });
        var distanceFromCenter = { // offset from view, distance view has to change by these x and y to center the node
          x: viewCenter.x - nodePosition.x,
          y: viewCenter.y - nodePosition.y
        };
        var sourceTranslation = this.body.view.translation;
        var targetTranslation = {
          x: sourceTranslation.x + distanceFromCenter.x * this.body.view.scale + this.lockedOnNodeOffset.x,
          y: sourceTranslation.y + distanceFromCenter.y * this.body.view.scale + this.lockedOnNodeOffset.y
        };

        this.body.view.translation = targetTranslation;
      }
    }, {
      key: 'releaseNode',
      value: function releaseNode() {
        if (this.lockedOnNodeId !== undefined && this.viewFunction !== undefined) {
          this.body.emitter.off("initRedraw", this.viewFunction);
          this.lockedOnNodeId = undefined;
          this.lockedOnNodeOffset = undefined;
        }
      }

      /**
       *
       * @param easingTime
       * @private
       */

    }, {
      key: '_transitionRedraw',
      value: function _transitionRedraw() {
        var finished = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];

        this.easingTime += this.animationSpeed;
        this.easingTime = finished === true ? 1.0 : this.easingTime;

        var progress = util.easingFunctions[this.animationEasingFunction](this.easingTime);

        this.body.view.scale = this.sourceScale + (this.targetScale - this.sourceScale) * progress;
        this.body.view.translation = {
          x: this.sourceTranslation.x + (this.targetTranslation.x - this.sourceTranslation.x) * progress,
          y: this.sourceTranslation.y + (this.targetTranslation.y - this.sourceTranslation.y) * progress
        };

        // cleanup
        if (this.easingTime >= 1.0) {
          this.body.emitter.off("initRedraw", this.viewFunction);
          this.easingTime = 0;
          if (this.lockedOnNodeId != undefined) {
            this.viewFunction = this._lockedRedraw.bind(this);
            this.body.emitter.on("initRedraw", this.viewFunction);
          }
          this.body.emitter.emit("animationFinished");
        }
      }
    }, {
      key: 'getScale',
      value: function getScale() {
        return this.body.view.scale;
      }
    }, {
      key: 'getViewPosition',
      value: function getViewPosition() {
        return this.canvas.DOMtoCanvas({ x: 0.5 * this.canvas.frame.canvas.clientWidth, y: 0.5 * this.canvas.frame.canvas.clientHeight });
      }
    }]);

    return View;
  }();

  exports.default = View;

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _NavigationHandler = __webpack_require__(109);

  var _NavigationHandler2 = _interopRequireDefault(_NavigationHandler);

  var _Popup = __webpack_require__(110);

  var _Popup2 = _interopRequireDefault(_Popup);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);

  var InteractionHandler = function () {
    function InteractionHandler(body, canvas, selectionHandler) {
      _classCallCheck(this, InteractionHandler);

      this.body = body;
      this.canvas = canvas;
      this.selectionHandler = selectionHandler;
      this.navigationHandler = new _NavigationHandler2.default(body, canvas);

      // bind the events from hammer to functions in this object
      this.body.eventListeners.onTap = this.onTap.bind(this);
      this.body.eventListeners.onTouch = this.onTouch.bind(this);
      this.body.eventListeners.onDoubleTap = this.onDoubleTap.bind(this);
      this.body.eventListeners.onHold = this.onHold.bind(this);
      this.body.eventListeners.onDragStart = this.onDragStart.bind(this);
      this.body.eventListeners.onDrag = this.onDrag.bind(this);
      this.body.eventListeners.onDragEnd = this.onDragEnd.bind(this);
      this.body.eventListeners.onMouseWheel = this.onMouseWheel.bind(this);
      this.body.eventListeners.onPinch = this.onPinch.bind(this);
      this.body.eventListeners.onMouseMove = this.onMouseMove.bind(this);
      this.body.eventListeners.onRelease = this.onRelease.bind(this);
      this.body.eventListeners.onContext = this.onContext.bind(this);

      this.touchTime = 0;
      this.drag = {};
      this.pinch = {};
      this.popup = undefined;
      this.popupObj = undefined;
      this.popupTimer = undefined;

      this.body.functions.getPointer = this.getPointer.bind(this);

      this.options = {};
      this.defaultOptions = {
        dragNodes: true,
        dragView: true,
        hover: false,
        keyboard: {
          enabled: false,
          speed: { x: 10, y: 10, zoom: 0.02 },
          bindToWindow: true
        },
        navigationButtons: false,
        tooltipDelay: 300,
        zoomView: true
      };
      util.extend(this.options, this.defaultOptions);

      this.bindEventListeners();
    }

    _createClass(InteractionHandler, [{
      key: 'bindEventListeners',
      value: function bindEventListeners() {
        var _this = this;

        this.body.emitter.on('destroy', function () {
          clearTimeout(_this.popupTimer);
          delete _this.body.functions.getPointer;
        });
      }
    }, {
      key: 'setOptions',
      value: function setOptions(options) {
        if (options !== undefined) {
          // extend all but the values in fields
          var fields = ['hideEdgesOnDrag', 'hideNodesOnDrag', 'keyboard', 'multiselect', 'selectable', 'selectConnectedEdges'];
          util.selectiveNotDeepExtend(fields, this.options, options);

          // merge the keyboard options in.
          util.mergeOptions(this.options, options, 'keyboard');

          if (options.tooltip) {
            util.extend(this.options.tooltip, options.tooltip);
            if (options.tooltip.color) {
              this.options.tooltip.color = util.parseColor(options.tooltip.color);
            }
          }
        }

        this.navigationHandler.setOptions(this.options);
      }

      /**
       * Get the pointer location from a touch location
       * @param {{x: Number, y: Number}} touch
       * @return {{x: Number, y: Number}} pointer
       * @private
       */

    }, {
      key: 'getPointer',
      value: function getPointer(touch) {
        return {
          x: touch.x - util.getAbsoluteLeft(this.canvas.frame.canvas),
          y: touch.y - util.getAbsoluteTop(this.canvas.frame.canvas)
        };
      }

      /**
       * On start of a touch gesture, store the pointer
       * @param event
       * @private
       */

    }, {
      key: 'onTouch',
      value: function onTouch(event) {
        if (new Date().valueOf() - this.touchTime > 50) {
          this.drag.pointer = this.getPointer(event.center);
          this.drag.pinched = false;
          this.pinch.scale = this.body.view.scale;
          // to avoid double fireing of this event because we have two hammer instances. (on canvas and on frame)
          this.touchTime = new Date().valueOf();
        }
      }

      /**
       * handle tap/click event: select/unselect a node
       * @private
       */

    }, {
      key: 'onTap',
      value: function onTap(event) {
        var pointer = this.getPointer(event.center);
        var multiselect = this.selectionHandler.options.multiselect && (event.changedPointers[0].ctrlKey || event.changedPointers[0].metaKey);

        this.checkSelectionChanges(pointer, event, multiselect);
        this.selectionHandler._generateClickEvent('click', event, pointer);
      }

      /**
       * handle doubletap event
       * @private
       */

    }, {
      key: 'onDoubleTap',
      value: function onDoubleTap(event) {
        var pointer = this.getPointer(event.center);
        this.selectionHandler._generateClickEvent('doubleClick', event, pointer);
      }

      /**
       * handle long tap event: multi select nodes
       * @private
       */

    }, {
      key: 'onHold',
      value: function onHold(event) {
        var pointer = this.getPointer(event.center);
        var multiselect = this.selectionHandler.options.multiselect;

        this.checkSelectionChanges(pointer, event, multiselect);

        this.selectionHandler._generateClickEvent('click', event, pointer);
        this.selectionHandler._generateClickEvent('hold', event, pointer);
      }

      /**
       * handle the release of the screen
       *
       * @private
       */

    }, {
      key: 'onRelease',
      value: function onRelease(event) {
        if (new Date().valueOf() - this.touchTime > 10) {
          var pointer = this.getPointer(event.center);
          this.selectionHandler._generateClickEvent('release', event, pointer);
          // to avoid double fireing of this event because we have two hammer instances. (on canvas and on frame)
          this.touchTime = new Date().valueOf();
        }
      }
    }, {
      key: 'onContext',
      value: function onContext(event) {
        var pointer = this.getPointer({ x: event.clientX, y: event.clientY });
        this.selectionHandler._generateClickEvent('oncontext', event, pointer);
      }

      /**
       *
       * @param pointer
       * @param add
       */

    }, {
      key: 'checkSelectionChanges',
      value: function checkSelectionChanges(pointer, event) {
        var add = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

        var previouslySelectedEdgeCount = this.selectionHandler._getSelectedEdgeCount();
        var previouslySelectedNodeCount = this.selectionHandler._getSelectedNodeCount();
        var previousSelection = this.selectionHandler.getSelection();
        var selected = void 0;
        if (add === true) {
          selected = this.selectionHandler.selectAdditionalOnPoint(pointer);
        } else {
          selected = this.selectionHandler.selectOnPoint(pointer);
        }
        var selectedEdgesCount = this.selectionHandler._getSelectedEdgeCount();
        var selectedNodesCount = this.selectionHandler._getSelectedNodeCount();
        var currentSelection = this.selectionHandler.getSelection();

        var _determineIfDifferent2 = this._determineIfDifferent(previousSelection, currentSelection);

        var nodesChanged = _determineIfDifferent2.nodesChanged;
        var edgesChanged = _determineIfDifferent2.edgesChanged;

        var nodeSelected = false;

        if (selectedNodesCount - previouslySelectedNodeCount > 0) {
          // node was selected
          this.selectionHandler._generateClickEvent('selectNode', event, pointer);
          selected = true;
          nodeSelected = true;
        } else if (nodesChanged === true && selectedNodesCount > 0) {
          this.selectionHandler._generateClickEvent('deselectNode', event, pointer, previousSelection);
          this.selectionHandler._generateClickEvent('selectNode', event, pointer);
          nodeSelected = true;
          selected = true;
        } else if (selectedNodesCount - previouslySelectedNodeCount < 0) {
          // node was deselected
          this.selectionHandler._generateClickEvent('deselectNode', event, pointer, previousSelection);
          selected = true;
        }

        // handle the selected edges
        if (selectedEdgesCount - previouslySelectedEdgeCount > 0 && nodeSelected === false) {
          // edge was selected
          this.selectionHandler._generateClickEvent('selectEdge', event, pointer);
          selected = true;
        } else if (selectedEdgesCount > 0 && edgesChanged === true) {
          this.selectionHandler._generateClickEvent('deselectEdge', event, pointer, previousSelection);
          this.selectionHandler._generateClickEvent('selectEdge', event, pointer);
          selected = true;
        } else if (selectedEdgesCount - previouslySelectedEdgeCount < 0) {
          // edge was deselected
          this.selectionHandler._generateClickEvent('deselectEdge', event, pointer, previousSelection);
          selected = true;
        }

        // fire the select event if anything has been selected or deselected
        if (selected === true) {
          // select or unselect
          this.selectionHandler._generateClickEvent('select', event, pointer);
        }
      }

      /**
       * This function checks if the nodes and edges previously selected have changed.
       * @param previousSelection
       * @param currentSelection
       * @returns {{nodesChanged: boolean, edgesChanged: boolean}}
       * @private
       */

    }, {
      key: '_determineIfDifferent',
      value: function _determineIfDifferent(previousSelection, currentSelection) {
        var nodesChanged = false;
        var edgesChanged = false;

        for (var i = 0; i < previousSelection.nodes.length; i++) {
          if (currentSelection.nodes.indexOf(previousSelection.nodes[i]) === -1) {
            nodesChanged = true;
          }
        }
        for (var _i = 0; _i < currentSelection.nodes.length; _i++) {
          if (previousSelection.nodes.indexOf(previousSelection.nodes[_i]) === -1) {
            nodesChanged = true;
          }
        }
        for (var _i2 = 0; _i2 < previousSelection.edges.length; _i2++) {
          if (currentSelection.edges.indexOf(previousSelection.edges[_i2]) === -1) {
            edgesChanged = true;
          }
        }
        for (var _i3 = 0; _i3 < currentSelection.edges.length; _i3++) {
          if (previousSelection.edges.indexOf(previousSelection.edges[_i3]) === -1) {
            edgesChanged = true;
          }
        }

        return { nodesChanged: nodesChanged, edgesChanged: edgesChanged };
      }

      /**
       * This function is called by onDragStart.
       * It is separated out because we can then overload it for the datamanipulation system.
       *
       * @private
       */

    }, {
      key: 'onDragStart',
      value: function onDragStart(event) {
        //in case the touch event was triggered on an external div, do the initial touch now.
        if (this.drag.pointer === undefined) {
          this.onTouch(event);
        }

        // note: drag.pointer is set in onTouch to get the initial touch location
        var node = this.selectionHandler.getNodeAt(this.drag.pointer);

        this.drag.dragging = true;
        this.drag.selection = [];
        this.drag.translation = util.extend({}, this.body.view.translation); // copy the object
        this.drag.nodeId = undefined;

        if (node !== undefined && this.options.dragNodes === true) {
          this.drag.nodeId = node.id;
          // select the clicked node if not yet selected
          if (node.isSelected() === false) {
            this.selectionHandler.unselectAll();
            this.selectionHandler.selectObject(node);
          }

          // after select to contain the node
          this.selectionHandler._generateClickEvent('dragStart', event, this.drag.pointer);

          var selection = this.selectionHandler.selectionObj.nodes;
          // create an array with the selected nodes and their original location and status
          for (var nodeId in selection) {
            if (selection.hasOwnProperty(nodeId)) {
              var object = selection[nodeId];
              var s = {
                id: object.id,
                node: object,

                // store original x, y, xFixed and yFixed, make the node temporarily Fixed
                x: object.x,
                y: object.y,
                xFixed: object.options.fixed.x,
                yFixed: object.options.fixed.y
              };

              object.options.fixed.x = true;
              object.options.fixed.y = true;

              this.drag.selection.push(s);
            }
          }
        } else {
          // fallback if no node is selected and thus the view is dragged.
          this.selectionHandler._generateClickEvent('dragStart', event, this.drag.pointer, undefined, true);
        }
      }

      /**
       * handle drag event
       * @private
       */

    }, {
      key: 'onDrag',
      value: function onDrag(event) {
        var _this2 = this;

        if (this.drag.pinched === true) {
          return;
        }

        // remove the focus on node if it is focussed on by the focusOnNode
        this.body.emitter.emit('unlockNode');

        var pointer = this.getPointer(event.center);

        var selection = this.drag.selection;
        if (selection && selection.length && this.options.dragNodes === true) {
          (function () {
            _this2.selectionHandler._generateClickEvent('dragging', event, pointer);

            // calculate delta's and new location
            var deltaX = pointer.x - _this2.drag.pointer.x;
            var deltaY = pointer.y - _this2.drag.pointer.y;

            // update position of all selected nodes
            selection.forEach(function (selection) {
              var node = selection.node;
              // only move the node if it was not fixed initially
              if (selection.xFixed === false) {
                node.x = _this2.canvas._XconvertDOMtoCanvas(_this2.canvas._XconvertCanvasToDOM(selection.x) + deltaX);
              }
              // only move the node if it was not fixed initially
              if (selection.yFixed === false) {
                node.y = _this2.canvas._YconvertDOMtoCanvas(_this2.canvas._YconvertCanvasToDOM(selection.y) + deltaY);
              }
            });

            // start the simulation of the physics
            _this2.body.emitter.emit('startSimulation');
          })();
        } else {
          // move the network
          if (this.options.dragView === true) {
            this.selectionHandler._generateClickEvent('dragging', event, pointer, undefined, true);

            // if the drag was not started properly because the click started outside the network div, start it now.
            if (this.drag.pointer === undefined) {
              this.onDragStart(event);
              return;
            }
            var diffX = pointer.x - this.drag.pointer.x;
            var diffY = pointer.y - this.drag.pointer.y;

            this.body.view.translation = { x: this.drag.translation.x + diffX, y: this.drag.translation.y + diffY };
            this.body.emitter.emit('_redraw');
          }
        }
      }

      /**
       * handle drag start event
       * @private
       */

    }, {
      key: 'onDragEnd',
      value: function onDragEnd(event) {
        this.drag.dragging = false;
        var selection = this.drag.selection;
        if (selection && selection.length) {
          selection.forEach(function (s) {
            // restore original xFixed and yFixed
            s.node.options.fixed.x = s.xFixed;
            s.node.options.fixed.y = s.yFixed;
          });
          this.selectionHandler._generateClickEvent('dragEnd', event, this.getPointer(event.center));
          this.body.emitter.emit('startSimulation');
        } else {
          this.selectionHandler._generateClickEvent('dragEnd', event, this.getPointer(event.center), undefined, true);
          this.body.emitter.emit('_requestRedraw');
        }
      }

      /**
       * Handle pinch event
       * @param event
       * @private
       */

    }, {
      key: 'onPinch',
      value: function onPinch(event) {
        var pointer = this.getPointer(event.center);

        this.drag.pinched = true;
        if (this.pinch['scale'] === undefined) {
          this.pinch.scale = 1;
        }

        // TODO: enabled moving while pinching?
        var scale = this.pinch.scale * event.scale;
        this.zoom(scale, pointer);
      }

      /**
       * Zoom the network in or out
       * @param {Number} scale a number around 1, and between 0.01 and 10
       * @param {{x: Number, y: Number}} pointer    Position on screen
       * @return {Number} appliedScale    scale is limited within the boundaries
       * @private
       */

    }, {
      key: 'zoom',
      value: function zoom(scale, pointer) {
        if (this.options.zoomView === true) {
          var scaleOld = this.body.view.scale;
          if (scale < 0.00001) {
            scale = 0.00001;
          }
          if (scale > 10) {
            scale = 10;
          }

          var preScaleDragPointer = undefined;
          if (this.drag !== undefined) {
            if (this.drag.dragging === true) {
              preScaleDragPointer = this.canvas.DOMtoCanvas(this.drag.pointer);
            }
          }
          // + this.canvas.frame.canvas.clientHeight / 2
          var translation = this.body.view.translation;

          var scaleFrac = scale / scaleOld;
          var tx = (1 - scaleFrac) * pointer.x + translation.x * scaleFrac;
          var ty = (1 - scaleFrac) * pointer.y + translation.y * scaleFrac;

          this.body.view.scale = scale;
          this.body.view.translation = { x: tx, y: ty };

          if (preScaleDragPointer != undefined) {
            var postScaleDragPointer = this.canvas.canvasToDOM(preScaleDragPointer);
            this.drag.pointer.x = postScaleDragPointer.x;
            this.drag.pointer.y = postScaleDragPointer.y;
          }

          this.body.emitter.emit('_requestRedraw');

          if (scaleOld < scale) {
            this.body.emitter.emit('zoom', { direction: '+', scale: this.body.view.scale });
          } else {
            this.body.emitter.emit('zoom', { direction: '-', scale: this.body.view.scale });
          }
        }
      }

      /**
       * Event handler for mouse wheel event, used to zoom the timeline
       * See http://adomas.org/javascript-mouse-wheel/
       *     https://github.com/EightMedia/hammer.js/issues/256
       * @param {MouseEvent}  event
       * @private
       */

    }, {
      key: 'onMouseWheel',
      value: function onMouseWheel(event) {
        if (this.options.zoomView === true) {
          // retrieve delta
          var delta = 0;
          if (event.wheelDelta) {
            /* IE/Opera. */
            delta = event.wheelDelta / 120;
          } else if (event.detail) {
            /* Mozilla case. */
            // In Mozilla, sign of delta is different than in IE.
            // Also, delta is multiple of 3.
            delta = -event.detail / 3;
          }

          // If delta is nonzero, handle it.
          // Basically, delta is now positive if wheel was scrolled up,
          // and negative, if wheel was scrolled down.
          if (delta !== 0) {

            // calculate the new scale
            var scale = this.body.view.scale;
            var zoom = delta / 10;
            if (delta < 0) {
              zoom = zoom / (1 - zoom);
            }
            scale *= 1 + zoom;

            // calculate the pointer location
            var pointer = this.getPointer({ x: event.clientX, y: event.clientY });

            // apply the new scale
            this.zoom(scale, pointer);
          }

          // Prevent default actions caused by mouse wheel.
          event.preventDefault();
        }
      }

      /**
       * Mouse move handler for checking whether the title moves over a node with a title.
       * @param  {Event} event
       * @private
       */

    }, {
      key: 'onMouseMove',
      value: function onMouseMove(event) {
        var _this3 = this;

        var pointer = this.getPointer({ x: event.clientX, y: event.clientY });
        var popupVisible = false;

        // check if the previously selected node is still selected
        if (this.popup !== undefined) {
          if (this.popup.hidden === false) {
            this._checkHidePopup(pointer);
          }

          // if the popup was not hidden above
          if (this.popup.hidden === false) {
            popupVisible = true;
            this.popup.setPosition(pointer.x + 3, pointer.y - 5);
            this.popup.show();
          }
        }

        // if we bind the keyboard to the div, we have to highlight it to use it. This highlights it on mouse over.
        if (this.options.keyboard.bindToWindow === false && this.options.keyboard.enabled === true) {
          this.canvas.frame.focus();
        }

        // start a timeout that will check if the mouse is positioned above an element
        if (popupVisible === false) {
          if (this.popupTimer !== undefined) {
            clearInterval(this.popupTimer); // stop any running calculationTimer
            this.popupTimer = undefined;
          }
          if (!this.drag.dragging) {
            this.popupTimer = setTimeout(function () {
              return _this3._checkShowPopup(pointer);
            }, this.options.tooltipDelay);
          }
        }

        /**
        * Adding hover highlights
        */
        if (this.options.hover === true) {
          // adding hover highlights
          var obj = this.selectionHandler.getNodeAt(pointer);
          if (obj === undefined) {
            obj = this.selectionHandler.getEdgeAt(pointer);
          }
          this.selectionHandler.hoverObject(obj);
        }
      }

      /**
       * Check if there is an element on the given position in the network
       * (a node or edge). If so, and if this element has a title,
       * show a popup window with its title.
       *
       * @param {{x:Number, y:Number}} pointer
       * @private
       */

    }, {
      key: '_checkShowPopup',
      value: function _checkShowPopup(pointer) {
        var x = this.canvas._XconvertDOMtoCanvas(pointer.x);
        var y = this.canvas._YconvertDOMtoCanvas(pointer.y);
        var pointerObj = {
          left: x,
          top: y,
          right: x,
          bottom: y
        };

        var previousPopupObjId = this.popupObj === undefined ? undefined : this.popupObj.id;
        var nodeUnderCursor = false;
        var popupType = 'node';

        // check if a node is under the cursor.
        if (this.popupObj === undefined) {
          // search the nodes for overlap, select the top one in case of multiple nodes
          var nodeIndices = this.body.nodeIndices;
          var nodes = this.body.nodes;
          var node = void 0;
          var overlappingNodes = [];
          for (var i = 0; i < nodeIndices.length; i++) {
            node = nodes[nodeIndices[i]];
            if (node.isOverlappingWith(pointerObj) === true) {
              if (node.getTitle() !== undefined) {
                overlappingNodes.push(nodeIndices[i]);
              }
            }
          }

          if (overlappingNodes.length > 0) {
            // if there are overlapping nodes, select the last one, this is the one which is drawn on top of the others
            this.popupObj = nodes[overlappingNodes[overlappingNodes.length - 1]];
            // if you hover over a node, the title of the edge is not supposed to be shown.
            nodeUnderCursor = true;
          }
        }

        if (this.popupObj === undefined && nodeUnderCursor === false) {
          // search the edges for overlap
          var edgeIndices = this.body.edgeIndices;
          var edges = this.body.edges;
          var edge = void 0;
          var overlappingEdges = [];
          for (var _i4 = 0; _i4 < edgeIndices.length; _i4++) {
            edge = edges[edgeIndices[_i4]];
            if (edge.isOverlappingWith(pointerObj) === true) {
              if (edge.connected === true && edge.getTitle() !== undefined) {
                overlappingEdges.push(edgeIndices[_i4]);
              }
            }
          }

          if (overlappingEdges.length > 0) {
            this.popupObj = edges[overlappingEdges[overlappingEdges.length - 1]];
            popupType = 'edge';
          }
        }

        if (this.popupObj !== undefined) {
          // show popup message window
          if (this.popupObj.id !== previousPopupObjId) {
            if (this.popup === undefined) {
              this.popup = new _Popup2.default(this.canvas.frame);
            }

            this.popup.popupTargetType = popupType;
            this.popup.popupTargetId = this.popupObj.id;

            // adjust a small offset such that the mouse cursor is located in the
            // bottom left location of the popup, and you can easily move over the
            // popup area
            this.popup.setPosition(pointer.x + 3, pointer.y - 5);
            this.popup.setText(this.popupObj.getTitle());
            this.popup.show();
            this.body.emitter.emit('showPopup', this.popupObj.id);
          }
        } else {
          if (this.popup !== undefined) {
            this.popup.hide();
            this.body.emitter.emit('hidePopup');
          }
        }
      }

      /**
       * Check if the popup must be hidden, which is the case when the mouse is no
       * longer hovering on the object
       * @param {{x:Number, y:Number}} pointer
       * @private
       */

    }, {
      key: '_checkHidePopup',
      value: function _checkHidePopup(pointer) {
        var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);

        var stillOnObj = false;
        if (this.popup.popupTargetType === 'node') {
          if (this.body.nodes[this.popup.popupTargetId] !== undefined) {
            stillOnObj = this.body.nodes[this.popup.popupTargetId].isOverlappingWith(pointerObj);

            // if the mouse is still one the node, we have to check if it is not also on one that is drawn on top of it.
            // we initially only check stillOnObj because this is much faster.
            if (stillOnObj === true) {
              var overNode = this.selectionHandler.getNodeAt(pointer);
              stillOnObj = overNode.id === this.popup.popupTargetId;
            }
          }
        } else {
          if (this.selectionHandler.getNodeAt(pointer) === undefined) {
            if (this.body.edges[this.popup.popupTargetId] !== undefined) {
              stillOnObj = this.body.edges[this.popup.popupTargetId].isOverlappingWith(pointerObj);
            }
          }
        }

        if (stillOnObj === false) {
          this.popupObj = undefined;
          this.popup.hide();
          this.body.emitter.emit('hidePopup');
        }
      }
    }]);

    return InteractionHandler;
  }();

  exports.default = InteractionHandler;

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);
  var Hammer = __webpack_require__(20);
  var hammerUtil = __webpack_require__(28);
  var keycharm = __webpack_require__(23);

  var NavigationHandler = function () {
    function NavigationHandler(body, canvas) {
      var _this = this;

      _classCallCheck(this, NavigationHandler);

      this.body = body;
      this.canvas = canvas;

      this.iconsCreated = false;
      this.navigationHammers = [];
      this.boundFunctions = {};
      this.touchTime = 0;
      this.activated = false;

      this.body.emitter.on("activate", function () {
        _this.activated = true;_this.configureKeyboardBindings();
      });
      this.body.emitter.on("deactivate", function () {
        _this.activated = false;_this.configureKeyboardBindings();
      });
      this.body.emitter.on("destroy", function () {
        if (_this.keycharm !== undefined) {
          _this.keycharm.destroy();
        }
      });

      this.options = {};
    }

    _createClass(NavigationHandler, [{
      key: 'setOptions',
      value: function setOptions(options) {
        if (options !== undefined) {
          this.options = options;
          this.create();
        }
      }
    }, {
      key: 'create',
      value: function create() {
        if (this.options.navigationButtons === true) {
          if (this.iconsCreated === false) {
            this.loadNavigationElements();
          }
        } else if (this.iconsCreated === true) {
          this.cleanNavigation();
        }

        this.configureKeyboardBindings();
      }
    }, {
      key: 'cleanNavigation',
      value: function cleanNavigation() {
        // clean hammer bindings
        if (this.navigationHammers.length != 0) {
          for (var i = 0; i < this.navigationHammers.length; i++) {
            this.navigationHammers[i].destroy();
          }
          this.navigationHammers = [];
        }

        // clean up previous navigation items
        if (this.navigationDOM && this.navigationDOM['wrapper'] && this.navigationDOM['wrapper'].parentNode) {
          this.navigationDOM['wrapper'].parentNode.removeChild(this.navigationDOM['wrapper']);
        }

        this.iconsCreated = false;
      }

      /**
       * Creation of the navigation controls nodes. They are drawn over the rest of the nodes and are not affected by scale and translation
       * they have a triggerFunction which is called on click. If the position of the navigation controls is dependent
       * on this.frame.canvas.clientWidth or this.frame.canvas.clientHeight, we flag horizontalAlignLeft and verticalAlignTop false.
       * This means that the location will be corrected by the _relocateNavigation function on a size change of the canvas.
       *
       * @private
       */

    }, {
      key: 'loadNavigationElements',
      value: function loadNavigationElements() {
        var _this2 = this;

        this.cleanNavigation();

        this.navigationDOM = {};
        var navigationDivs = ['up', 'down', 'left', 'right', 'zoomIn', 'zoomOut', 'zoomExtends'];
        var navigationDivActions = ['_moveUp', '_moveDown', '_moveLeft', '_moveRight', '_zoomIn', '_zoomOut', '_fit'];

        this.navigationDOM['wrapper'] = document.createElement('div');
        this.navigationDOM['wrapper'].className = 'vis-navigation';
        this.canvas.frame.appendChild(this.navigationDOM['wrapper']);

        for (var i = 0; i < navigationDivs.length; i++) {
          this.navigationDOM[navigationDivs[i]] = document.createElement('div');
          this.navigationDOM[navigationDivs[i]].className = 'vis-button vis-' + navigationDivs[i];
          this.navigationDOM['wrapper'].appendChild(this.navigationDOM[navigationDivs[i]]);

          var hammer = new Hammer(this.navigationDOM[navigationDivs[i]]);
          if (navigationDivActions[i] === "_fit") {
            hammerUtil.onTouch(hammer, this._fit.bind(this));
          } else {
            hammerUtil.onTouch(hammer, this.bindToRedraw.bind(this, navigationDivActions[i]));
          }

          this.navigationHammers.push(hammer);
        }

        // use a hammer for the release so we do not require the one used in the rest of the network
        // the one the rest uses can be overloaded by the manipulation system.
        var hammerFrame = new Hammer(this.canvas.frame);
        hammerUtil.onRelease(hammerFrame, function () {
          _this2._stopMovement();
        });
        this.navigationHammers.push(hammerFrame);

        this.iconsCreated = true;
      }
    }, {
      key: 'bindToRedraw',
      value: function bindToRedraw(action) {
        if (this.boundFunctions[action] === undefined) {
          this.boundFunctions[action] = this[action].bind(this);
          this.body.emitter.on("initRedraw", this.boundFunctions[action]);
          this.body.emitter.emit("_startRendering");
        }
      }
    }, {
      key: 'unbindFromRedraw',
      value: function unbindFromRedraw(action) {
        if (this.boundFunctions[action] !== undefined) {
          this.body.emitter.off("initRedraw", this.boundFunctions[action]);
          this.body.emitter.emit("_stopRendering");
          delete this.boundFunctions[action];
        }
      }

      /**
       * this stops all movement induced by the navigation buttons
       *
       * @private
       */

    }, {
      key: '_fit',
      value: function _fit() {
        if (new Date().valueOf() - this.touchTime > 700) {
          // TODO: fix ugly hack to avoid hammer's double fireing of event (because we use release?)
          this.body.emitter.emit("fit", { duration: 700 });
          this.touchTime = new Date().valueOf();
        }
      }

      /**
       * this stops all movement induced by the navigation buttons
       *
       * @private
       */

    }, {
      key: '_stopMovement',
      value: function _stopMovement() {
        for (var boundAction in this.boundFunctions) {
          if (this.boundFunctions.hasOwnProperty(boundAction)) {
            this.body.emitter.off("initRedraw", this.boundFunctions[boundAction]);
            this.body.emitter.emit("_stopRendering");
          }
        }
        this.boundFunctions = {};
      }
    }, {
      key: '_moveUp',
      value: function _moveUp() {
        this.body.view.translation.y += this.options.keyboard.speed.y;
      }
    }, {
      key: '_moveDown',
      value: function _moveDown() {
        this.body.view.translation.y -= this.options.keyboard.speed.y;
      }
    }, {
      key: '_moveLeft',
      value: function _moveLeft() {
        this.body.view.translation.x += this.options.keyboard.speed.x;
      }
    }, {
      key: '_moveRight',
      value: function _moveRight() {
        this.body.view.translation.x -= this.options.keyboard.speed.x;
      }
    }, {
      key: '_zoomIn',
      value: function _zoomIn() {
        this.body.view.scale *= 1 + this.options.keyboard.speed.zoom;
        this.body.emitter.emit('zoom', { direction: '+', scale: this.body.view.scale });
      }
    }, {
      key: '_zoomOut',
      value: function _zoomOut() {
        this.body.view.scale /= 1 + this.options.keyboard.speed.zoom;
        this.body.emitter.emit('zoom', { direction: '-', scale: this.body.view.scale });
      }

      /**
       * bind all keys using keycharm.
       */

    }, {
      key: 'configureKeyboardBindings',
      value: function configureKeyboardBindings() {
        var _this3 = this;

        if (this.keycharm !== undefined) {
          this.keycharm.destroy();
        }

        if (this.options.keyboard.enabled === true) {
          if (this.options.keyboard.bindToWindow === true) {
            this.keycharm = keycharm({ container: window, preventDefault: true });
          } else {
            this.keycharm = keycharm({ container: this.canvas.frame, preventDefault: true });
          }

          this.keycharm.reset();

          if (this.activated === true) {
            this.keycharm.bind("up", function () {
              _this3.bindToRedraw("_moveUp");
            }, "keydown");
            this.keycharm.bind("down", function () {
              _this3.bindToRedraw("_moveDown");
            }, "keydown");
            this.keycharm.bind("left", function () {
              _this3.bindToRedraw("_moveLeft");
            }, "keydown");
            this.keycharm.bind("right", function () {
              _this3.bindToRedraw("_moveRight");
            }, "keydown");
            this.keycharm.bind("=", function () {
              _this3.bindToRedraw("_zoomIn");
            }, "keydown");
            this.keycharm.bind("num+", function () {
              _this3.bindToRedraw("_zoomIn");
            }, "keydown");
            this.keycharm.bind("num-", function () {
              _this3.bindToRedraw("_zoomOut");
            }, "keydown");
            this.keycharm.bind("-", function () {
              _this3.bindToRedraw("_zoomOut");
            }, "keydown");
            this.keycharm.bind("[", function () {
              _this3.bindToRedraw("_zoomOut");
            }, "keydown");
            this.keycharm.bind("]", function () {
              _this3.bindToRedraw("_zoomIn");
            }, "keydown");
            this.keycharm.bind("pageup", function () {
              _this3.bindToRedraw("_zoomIn");
            }, "keydown");
            this.keycharm.bind("pagedown", function () {
              _this3.bindToRedraw("_zoomOut");
            }, "keydown");

            this.keycharm.bind("up", function () {
              _this3.unbindFromRedraw("_moveUp");
            }, "keyup");
            this.keycharm.bind("down", function () {
              _this3.unbindFromRedraw("_moveDown");
            }, "keyup");
            this.keycharm.bind("left", function () {
              _this3.unbindFromRedraw("_moveLeft");
            }, "keyup");
            this.keycharm.bind("right", function () {
              _this3.unbindFromRedraw("_moveRight");
            }, "keyup");
            this.keycharm.bind("=", function () {
              _this3.unbindFromRedraw("_zoomIn");
            }, "keyup");
            this.keycharm.bind("num+", function () {
              _this3.unbindFromRedraw("_zoomIn");
            }, "keyup");
            this.keycharm.bind("num-", function () {
              _this3.unbindFromRedraw("_zoomOut");
            }, "keyup");
            this.keycharm.bind("-", function () {
              _this3.unbindFromRedraw("_zoomOut");
            }, "keyup");
            this.keycharm.bind("[", function () {
              _this3.unbindFromRedraw("_zoomOut");
            }, "keyup");
            this.keycharm.bind("]", function () {
              _this3.unbindFromRedraw("_zoomIn");
            }, "keyup");
            this.keycharm.bind("pageup", function () {
              _this3.unbindFromRedraw("_zoomIn");
            }, "keyup");
            this.keycharm.bind("pagedown", function () {
              _this3.unbindFromRedraw("_zoomOut");
            }, "keyup");
          }
        }
      }
    }]);

    return NavigationHandler;
  }();

  exports.default = NavigationHandler;

/***/ },
/* 110 */
/***/ function(module, exports) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  /**
   * Popup is a class to create a popup window with some text
   * @param {Element}  container     The container object.
   * @param {Number} [x]
   * @param {Number} [y]
   * @param {String} [text]
   * @param {Object} [style]     An object containing borderColor,
   *                             backgroundColor, etc.
   */

  var Popup = function () {
    function Popup(container) {
      _classCallCheck(this, Popup);

      this.container = container;

      this.x = 0;
      this.y = 0;
      this.padding = 5;
      this.hidden = false;

      // create the frame
      this.frame = document.createElement('div');
      this.frame.className = 'vis-network-tooltip';
      this.container.appendChild(this.frame);
    }

    /**
     * @param {number} x   Horizontal position of the popup window
     * @param {number} y   Vertical position of the popup window
     */


    _createClass(Popup, [{
      key: 'setPosition',
      value: function setPosition(x, y) {
        this.x = parseInt(x);
        this.y = parseInt(y);
      }

      /**
       * Set the content for the popup window. This can be HTML code or text.
       * @param {string | Element} content
       */

    }, {
      key: 'setText',
      value: function setText(content) {
        if (content instanceof Element) {
          this.frame.innerHTML = '';
          this.frame.appendChild(content);
        } else {
          this.frame.innerHTML = content; // string containing text or HTML
        }
      }

      /**
       * Show the popup window
       * @param {boolean} [doShow]    Show or hide the window
       */

    }, {
      key: 'show',
      value: function show(doShow) {
        if (doShow === undefined) {
          doShow = true;
        }

        if (doShow === true) {
          var height = this.frame.clientHeight;
          var width = this.frame.clientWidth;
          var maxHeight = this.frame.parentNode.clientHeight;
          var maxWidth = this.frame.parentNode.clientWidth;

          var top = this.y - height;
          if (top + height + this.padding > maxHeight) {
            top = maxHeight - height - this.padding;
          }
          if (top < this.padding) {
            top = this.padding;
          }

          var left = this.x;
          if (left + width + this.padding > maxWidth) {
            left = maxWidth - width - this.padding;
          }
          if (left < this.padding) {
            left = this.padding;
          }

          this.frame.style.left = left + "px";
          this.frame.style.top = top + "px";
          this.frame.style.visibility = "visible";
          this.hidden = false;
        } else {
          this.hide();
        }
      }

      /**
       * Hide the popup window
       */

    }, {
      key: 'hide',
      value: function hide() {
        this.hidden = true;
        this.frame.style.visibility = "hidden";
      }
    }]);

    return Popup;
  }();

  exports.default = Popup;

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _Node = __webpack_require__(65);

  var _Node2 = _interopRequireDefault(_Node);

  var _Edge = __webpack_require__(85);

  var _Edge2 = _interopRequireDefault(_Edge);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);

  var SelectionHandler = function () {
    function SelectionHandler(body, canvas) {
      var _this = this;

      _classCallCheck(this, SelectionHandler);

      this.body = body;
      this.canvas = canvas;
      this.selectionObj = { nodes: [], edges: [] };
      this.hoverObj = { nodes: {}, edges: {} };

      this.options = {};
      this.defaultOptions = {
        multiselect: false,
        selectable: true,
        selectConnectedEdges: true,
        hoverConnectedEdges: true
      };
      util.extend(this.options, this.defaultOptions);

      this.body.emitter.on("_dataChanged", function () {
        _this.updateSelection();
      });
    }

    _createClass(SelectionHandler, [{
      key: 'setOptions',
      value: function setOptions(options) {
        if (options !== undefined) {
          var fields = ['multiselect', 'hoverConnectedEdges', 'selectable', 'selectConnectedEdges'];
          util.selectiveDeepExtend(fields, this.options, options);
        }
      }

      /**
       * handles the selection part of the tap;
       *
       * @param {Object} pointer
       * @private
       */

    }, {
      key: 'selectOnPoint',
      value: function selectOnPoint(pointer) {
        var selected = false;
        if (this.options.selectable === true) {
          var obj = this.getNodeAt(pointer) || this.getEdgeAt(pointer);

          // unselect after getting the objects in order to restore width and height.
          this.unselectAll();

          if (obj !== undefined) {
            selected = this.selectObject(obj);
          }
          this.body.emitter.emit("_requestRedraw");
        }
        return selected;
      }
    }, {
      key: 'selectAdditionalOnPoint',
      value: function selectAdditionalOnPoint(pointer) {
        var selectionChanged = false;
        if (this.options.selectable === true) {
          var obj = this.getNodeAt(pointer) || this.getEdgeAt(pointer);

          if (obj !== undefined) {
            selectionChanged = true;
            if (obj.isSelected() === true) {
              this.deselectObject(obj);
            } else {
              this.selectObject(obj);
            }

            this.body.emitter.emit("_requestRedraw");
          }
        }
        return selectionChanged;
      }
    }, {
      key: '_generateClickEvent',
      value: function _generateClickEvent(eventType, event, pointer, oldSelection) {
        var emptySelection = arguments.length <= 4 || arguments[4] === undefined ? false : arguments[4];

        var properties = void 0;
        if (emptySelection === true) {
          properties = { nodes: [], edges: [] };
        } else {
          properties = this.getSelection();
        }
        properties['pointer'] = {
          DOM: { x: pointer.x, y: pointer.y },
          canvas: this.canvas.DOMtoCanvas(pointer)
        };
        properties['event'] = event;

        if (oldSelection !== undefined) {
          properties['previousSelection'] = oldSelection;
        }
        this.body.emitter.emit(eventType, properties);
      }
    }, {
      key: 'selectObject',
      value: function selectObject(obj) {
        var highlightEdges = arguments.length <= 1 || arguments[1] === undefined ? this.options.selectConnectedEdges : arguments[1];

        if (obj !== undefined) {
          if (obj instanceof _Node2.default) {
            if (highlightEdges === true) {
              this._selectConnectedEdges(obj);
            }
          }
          obj.select();
          this._addToSelection(obj);
          return true;
        }
        return false;
      }
    }, {
      key: 'deselectObject',
      value: function deselectObject(obj) {
        if (obj.isSelected() === true) {
          obj.selected = false;
          this._removeFromSelection(obj);
        }
      }

      /**
       * retrieve all nodes overlapping with given object
       * @param {Object} object  An object with parameters left, top, right, bottom
       * @return {Number[]}   An array with id's of the overlapping nodes
       * @private
       */

    }, {
      key: '_getAllNodesOverlappingWith',
      value: function _getAllNodesOverlappingWith(object) {
        var overlappingNodes = [];
        var nodes = this.body.nodes;
        for (var i = 0; i < this.body.nodeIndices.length; i++) {
          var nodeId = this.body.nodeIndices[i];
          if (nodes[nodeId].isOverlappingWith(object)) {
            overlappingNodes.push(nodeId);
          }
        }
        return overlappingNodes;
      }

      /**
       * Return a position object in canvasspace from a single point in screenspace
       *
       * @param pointer
       * @returns {{left: number, top: number, right: number, bottom: number}}
       * @private
       */

    }, {
      key: '_pointerToPositionObject',
      value: function _pointerToPositionObject(pointer) {
        var canvasPos = this.canvas.DOMtoCanvas(pointer);
        return {
          left: canvasPos.x - 1,
          top: canvasPos.y + 1,
          right: canvasPos.x + 1,
          bottom: canvasPos.y - 1
        };
      }

      /**
       * Get the top node at the a specific point (like a click)
       *
       * @param {{x: Number, y: Number}} pointer
       * @return {Node | undefined} node
       */

    }, {
      key: 'getNodeAt',
      value: function getNodeAt(pointer) {
        var returnNode = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

        // we first check if this is an navigation controls element
        var positionObject = this._pointerToPositionObject(pointer);
        var overlappingNodes = this._getAllNodesOverlappingWith(positionObject);
        // if there are overlapping nodes, select the last one, this is the
        // one which is drawn on top of the others
        if (overlappingNodes.length > 0) {
          if (returnNode === true) {
            return this.body.nodes[overlappingNodes[overlappingNodes.length - 1]];
          } else {
            return overlappingNodes[overlappingNodes.length - 1];
          }
        } else {
          return undefined;
        }
      }

      /**
       * retrieve all edges overlapping with given object, selector is around center
       * @param {Object} object  An object with parameters left, top, right, bottom
       * @return {Number[]}   An array with id's of the overlapping nodes
       * @private
       */

    }, {
      key: '_getEdgesOverlappingWith',
      value: function _getEdgesOverlappingWith(object, overlappingEdges) {
        var edges = this.body.edges;
        for (var i = 0; i < this.body.edgeIndices.length; i++) {
          var edgeId = this.body.edgeIndices[i];
          if (edges[edgeId].isOverlappingWith(object)) {
            overlappingEdges.push(edgeId);
          }
        }
      }

      /**
       * retrieve all nodes overlapping with given object
       * @param {Object} object  An object with parameters left, top, right, bottom
       * @return {Number[]}   An array with id's of the overlapping nodes
       * @private
       */

    }, {
      key: '_getAllEdgesOverlappingWith',
      value: function _getAllEdgesOverlappingWith(object) {
        var overlappingEdges = [];
        this._getEdgesOverlappingWith(object, overlappingEdges);
        return overlappingEdges;
      }

      /**
       * Place holder. To implement change the getNodeAt to a _getObjectAt. Have the _getObjectAt call
       * getNodeAt and _getEdgesAt, then priortize the selection to user preferences.
       *
       * @param pointer
       * @returns {undefined}
       */

    }, {
      key: 'getEdgeAt',
      value: function getEdgeAt(pointer) {
        var returnEdge = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

        var positionObject = this._pointerToPositionObject(pointer);
        var overlappingEdges = this._getAllEdgesOverlappingWith(positionObject);

        if (overlappingEdges.length > 0) {
          if (returnEdge === true) {
            return this.body.edges[overlappingEdges[overlappingEdges.length - 1]];
          } else {
            return overlappingEdges[overlappingEdges.length - 1];
          }
        } else {
          return undefined;
        }
      }

      /**
       * Add object to the selection array.
       *
       * @param obj
       * @private
       */

    }, {
      key: '_addToSelection',
      value: function _addToSelection(obj) {
        if (obj instanceof _Node2.default) {
          this.selectionObj.nodes[obj.id] = obj;
        } else {
          this.selectionObj.edges[obj.id] = obj;
        }
      }

      /**
       * Add object to the selection array.
       *
       * @param obj
       * @private
       */

    }, {
      key: '_addToHover',
      value: function _addToHover(obj) {
        if (obj instanceof _Node2.default) {
          this.hoverObj.nodes[obj.id] = obj;
        } else {
          this.hoverObj.edges[obj.id] = obj;
        }
      }

      /**
       * Remove a single option from selection.
       *
       * @param {Object} obj
       * @private
       */

    }, {
      key: '_removeFromSelection',
      value: function _removeFromSelection(obj) {
        if (obj instanceof _Node2.default) {
          delete this.selectionObj.nodes[obj.id];
          this._unselectConnectedEdges(obj);
        } else {
          delete this.selectionObj.edges[obj.id];
        }
      }

      /**
       * Unselect all. The selectionObj is useful for this.
       */

    }, {
      key: 'unselectAll',
      value: function unselectAll() {
        for (var nodeId in this.selectionObj.nodes) {
          if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
            this.selectionObj.nodes[nodeId].unselect();
          }
        }
        for (var edgeId in this.selectionObj.edges) {
          if (this.selectionObj.edges.hasOwnProperty(edgeId)) {
            this.selectionObj.edges[edgeId].unselect();
          }
        }

        this.selectionObj = { nodes: {}, edges: {} };
      }

      /**
       * return the number of selected nodes
       *
       * @returns {number}
       * @private
       */

    }, {
      key: '_getSelectedNodeCount',
      value: function _getSelectedNodeCount() {
        var count = 0;
        for (var nodeId in this.selectionObj.nodes) {
          if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
            count += 1;
          }
        }
        return count;
      }

      /**
       * return the selected node
       *
       * @returns {number}
       * @private
       */

    }, {
      key: '_getSelectedNode',
      value: function _getSelectedNode() {
        for (var nodeId in this.selectionObj.nodes) {
          if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
            return this.selectionObj.nodes[nodeId];
          }
        }
        return undefined;
      }

      /**
       * return the selected edge
       *
       * @returns {number}
       * @private
       */

    }, {
      key: '_getSelectedEdge',
      value: function _getSelectedEdge() {
        for (var edgeId in this.selectionObj.edges) {
          if (this.selectionObj.edges.hasOwnProperty(edgeId)) {
            return this.selectionObj.edges[edgeId];
          }
        }
        return undefined;
      }

      /**
       * return the number of selected edges
       *
       * @returns {number}
       * @private
       */

    }, {
      key: '_getSelectedEdgeCount',
      value: function _getSelectedEdgeCount() {
        var count = 0;
        for (var edgeId in this.selectionObj.edges) {
          if (this.selectionObj.edges.hasOwnProperty(edgeId)) {
            count += 1;
          }
        }
        return count;
      }

      /**
       * return the number of selected objects.
       *
       * @returns {number}
       * @private
       */

    }, {
      key: '_getSelectedObjectCount',
      value: function _getSelectedObjectCount() {
        var count = 0;
        for (var nodeId in this.selectionObj.nodes) {
          if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
            count += 1;
          }
        }
        for (var edgeId in this.selectionObj.edges) {
          if (this.selectionObj.edges.hasOwnProperty(edgeId)) {
            count += 1;
          }
        }
        return count;
      }

      /**
       * Check if anything is selected
       *
       * @returns {boolean}
       * @private
       */

    }, {
      key: '_selectionIsEmpty',
      value: function _selectionIsEmpty() {
        for (var nodeId in this.selectionObj.nodes) {
          if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
            return false;
          }
        }
        for (var edgeId in this.selectionObj.edges) {
          if (this.selectionObj.edges.hasOwnProperty(edgeId)) {
            return false;
          }
        }
        return true;
      }

      /**
       * check if one of the selected nodes is a cluster.
       *
       * @returns {boolean}
       * @private
       */

    }, {
      key: '_clusterInSelection',
      value: function _clusterInSelection() {
        for (var nodeId in this.selectionObj.nodes) {
          if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
            if (this.selectionObj.nodes[nodeId].clusterSize > 1) {
              return true;
            }
          }
        }
        return false;
      }

      /**
       * select the edges connected to the node that is being selected
       *
       * @param {Node} node
       * @private
       */

    }, {
      key: '_selectConnectedEdges',
      value: function _selectConnectedEdges(node) {
        for (var i = 0; i < node.edges.length; i++) {
          var edge = node.edges[i];
          edge.select();
          this._addToSelection(edge);
        }
      }

      /**
       * select the edges connected to the node that is being selected
       *
       * @param {Node} node
       * @private
       */

    }, {
      key: '_hoverConnectedEdges',
      value: function _hoverConnectedEdges(node) {
        for (var i = 0; i < node.edges.length; i++) {
          var edge = node.edges[i];
          edge.hover = true;
          this._addToHover(edge);
        }
      }

      /**
       * unselect the edges connected to the node that is being selected
       *
       * @param {Node} node
       * @private
       */

    }, {
      key: '_unselectConnectedEdges',
      value: function _unselectConnectedEdges(node) {
        for (var i = 0; i < node.edges.length; i++) {
          var edge = node.edges[i];
          edge.unselect();
          this._removeFromSelection(edge);
        }
      }

      /**
       * This is called when someone clicks on a node. either select or deselect it.
       * If there is an existing selection and we don't want to append to it, clear the existing selection
       *
       * @param {Node || Edge} object
       * @private
       */

    }, {
      key: 'blurObject',
      value: function blurObject(object) {
        if (object.hover === true) {
          object.hover = false;
          if (object instanceof _Node2.default) {
            this.body.emitter.emit("blurNode", { node: object.id });
          } else {
            this.body.emitter.emit("blurEdge", { edge: object.id });
          }
        }
      }

      /**
       * This is called when someone clicks on a node. either select or deselect it.
       * If there is an existing selection and we don't want to append to it, clear the existing selection
       *
       * @param {Node || Edge} object
       * @private
       */

    }, {
      key: 'hoverObject',
      value: function hoverObject(object) {
        var hoverChanged = false;
        // remove all node hover highlights
        for (var nodeId in this.hoverObj.nodes) {
          if (this.hoverObj.nodes.hasOwnProperty(nodeId)) {
            if (object === undefined || object instanceof _Node2.default && object.id != nodeId || object instanceof _Edge2.default) {
              this.blurObject(this.hoverObj.nodes[nodeId]);
              delete this.hoverObj.nodes[nodeId];
              hoverChanged = true;
            }
          }
        }

        // removing all edge hover highlights
        for (var edgeId in this.hoverObj.edges) {
          if (this.hoverObj.edges.hasOwnProperty(edgeId)) {
            // if the hover has been changed here it means that the node has been hovered over or off
            // we then do not use the blurObject method here.
            if (hoverChanged === true) {
              this.hoverObj.edges[edgeId].hover = false;
              delete this.hoverObj.edges[edgeId];
            }
            // if the blur remains the same and the object is undefined (mouse off), we blur the edge
            else if (object === undefined) {
                this.blurObject(this.hoverObj.edges[edgeId]);
                delete this.hoverObj.edges[edgeId];
                hoverChanged = true;
              }
          }
        }

        if (object !== undefined) {
          if (object.hover === false) {
            object.hover = true;
            this._addToHover(object);
            hoverChanged = true;
            if (object instanceof _Node2.default) {
              this.body.emitter.emit("hoverNode", { node: object.id });
            } else {
              this.body.emitter.emit("hoverEdge", { edge: object.id });
            }
          }
          if (object instanceof _Node2.default && this.options.hoverConnectedEdges === true) {
            this._hoverConnectedEdges(object);
          }
        }

        if (hoverChanged === true) {
          this.body.emitter.emit('_requestRedraw');
        }
      }

      /**
       *
       * retrieve the currently selected objects
       * @return {{nodes: Array.<String>, edges: Array.<String>}} selection
       */

    }, {
      key: 'getSelection',
      value: function getSelection() {
        var nodeIds = this.getSelectedNodes();
        var edgeIds = this.getSelectedEdges();
        return { nodes: nodeIds, edges: edgeIds };
      }

      /**
       *
       * retrieve the currently selected nodes
       * @return {String[]} selection    An array with the ids of the
       *                                            selected nodes.
       */

    }, {
      key: 'getSelectedNodes',
      value: function getSelectedNodes() {
        var idArray = [];
        if (this.options.selectable === true) {
          for (var nodeId in this.selectionObj.nodes) {
            if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
              idArray.push(this.selectionObj.nodes[nodeId].id);
            }
          }
        }
        return idArray;
      }

      /**
       *
       * retrieve the currently selected edges
       * @return {Array} selection    An array with the ids of the
       *                                            selected nodes.
       */

    }, {
      key: 'getSelectedEdges',
      value: function getSelectedEdges() {
        var idArray = [];
        if (this.options.selectable === true) {
          for (var edgeId in this.selectionObj.edges) {
            if (this.selectionObj.edges.hasOwnProperty(edgeId)) {
              idArray.push(this.selectionObj.edges[edgeId].id);
            }
          }
        }
        return idArray;
      }

      /**
       * Updates the current selection
       * @param {{nodes: Array.<String>, edges: Array.<String>}} Selection
       * @param {Object} options                                 Options
       */

    }, {
      key: 'setSelection',
      value: function setSelection(selection) {
        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        var i = void 0,
            id = void 0;

        if (!selection || !selection.nodes && !selection.edges) throw 'Selection must be an object with nodes and/or edges properties';
        // first unselect any selected node, if option is true or undefined
        if (options.unselectAll || options.unselectAll === undefined) {
          this.unselectAll();
        }
        if (selection.nodes) {
          for (i = 0; i < selection.nodes.length; i++) {
            id = selection.nodes[i];

            var node = this.body.nodes[id];
            if (!node) {
              throw new RangeError('Node with id "' + id + '" not found');
            }
            // don't select edges with it
            this.selectObject(node, options.highlightEdges);
          }
        }

        if (selection.edges) {
          for (i = 0; i < selection.edges.length; i++) {
            id = selection.edges[i];

            var edge = this.body.edges[id];
            if (!edge) {
              throw new RangeError('Edge with id "' + id + '" not found');
            }
            this.selectObject(edge);
          }
        }
        this.body.emitter.emit('_requestRedraw');
      }

      /**
       * select zero or more nodes with the option to highlight edges
       * @param {Number[] | String[]} selection     An array with the ids of the
       *                                            selected nodes.
       * @param {boolean} [highlightEdges]
       */

    }, {
      key: 'selectNodes',
      value: function selectNodes(selection) {
        var highlightEdges = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

        if (!selection || selection.length === undefined) throw 'Selection must be an array with ids';

        this.setSelection({ nodes: selection }, { highlightEdges: highlightEdges });
      }

      /**
       * select zero or more edges
       * @param {Number[] | String[]} selection     An array with the ids of the
       *                                            selected nodes.
       */

    }, {
      key: 'selectEdges',
      value: function selectEdges(selection) {
        if (!selection || selection.length === undefined) throw 'Selection must be an array with ids';

        this.setSelection({ edges: selection });
      }

      /**
       * Validate the selection: remove ids of nodes which no longer exist
       * @private
       */

    }, {
      key: 'updateSelection',
      value: function updateSelection() {
        for (var nodeId in this.selectionObj.nodes) {
          if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
            if (!this.body.nodes.hasOwnProperty(nodeId)) {
              delete this.selectionObj.nodes[nodeId];
            }
          }
        }
        for (var edgeId in this.selectionObj.edges) {
          if (this.selectionObj.edges.hasOwnProperty(edgeId)) {
            if (!this.body.edges.hasOwnProperty(edgeId)) {
              delete this.selectionObj.edges[edgeId];
            }
          }
        }
      }
    }]);

    return SelectionHandler;
  }();

  exports.default = SelectionHandler;

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  var _NetworkUtil = __webpack_require__(103);

  var _NetworkUtil2 = _interopRequireDefault(_NetworkUtil);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);

  var LayoutEngine = function () {
    function LayoutEngine(body) {
      _classCallCheck(this, LayoutEngine);

      this.body = body;

      this.initialRandomSeed = Math.round(Math.random() * 1000000);
      this.randomSeed = this.initialRandomSeed;
      this.setPhysics = false;
      this.options = {};
      this.optionsBackup = { physics: {} };

      this.defaultOptions = {
        randomSeed: undefined,
        improvedLayout: true,
        hierarchical: {
          enabled: false,
          levelSeparation: 150,
          nodeSpacing: 100,
          treeSpacing: 200,
          blockShifting: true,
          edgeMinimization: true,
          parentCentralization: true,
          direction: 'UD', // UD, DU, LR, RL
          sortMethod: 'hubsize' // hubsize, directed
        }
      };
      util.extend(this.options, this.defaultOptions);
      this.bindEventListeners();
    }

    _createClass(LayoutEngine, [{
      key: 'bindEventListeners',
      value: function bindEventListeners() {
        var _this = this;

        this.body.emitter.on('_dataChanged', function () {
          _this.setupHierarchicalLayout();
        });
        this.body.emitter.on('_dataLoaded', function () {
          _this.layoutNetwork();
        });
        this.body.emitter.on('_resetHierarchicalLayout', function () {
          _this.setupHierarchicalLayout();
        });
      }
    }, {
      key: 'setOptions',
      value: function setOptions(options, allOptions) {
        if (options !== undefined) {
          var prevHierarchicalState = this.options.hierarchical.enabled;
          util.selectiveDeepExtend(["randomSeed", "improvedLayout"], this.options, options);
          util.mergeOptions(this.options, options, 'hierarchical');
          if (options.randomSeed !== undefined) {
            this.initialRandomSeed = options.randomSeed;
          }

          if (this.options.hierarchical.enabled === true) {
            if (prevHierarchicalState === true) {
              // refresh the overridden options for nodes and edges.
              this.body.emitter.emit('refresh', true);
            }

            // make sure the level separation is the right way up
            if (this.options.hierarchical.direction === 'RL' || this.options.hierarchical.direction === 'DU') {
              if (this.options.hierarchical.levelSeparation > 0) {
                this.options.hierarchical.levelSeparation *= -1;
              }
            } else {
              if (this.options.hierarchical.levelSeparation < 0) {
                this.options.hierarchical.levelSeparation *= -1;
              }
            }

            this.body.emitter.emit('_resetHierarchicalLayout');
            // because the hierarchical system needs it's own physics and smooth curve settings, we adapt the other options if needed.
            return this.adaptAllOptionsForHierarchicalLayout(allOptions);
          } else {
            if (prevHierarchicalState === true) {
              // refresh the overridden options for nodes and edges.
              this.body.emitter.emit('refresh');
              return util.deepExtend(allOptions, this.optionsBackup);
            }
          }
        }
        return allOptions;
      }
    }, {
      key: 'adaptAllOptionsForHierarchicalLayout',
      value: function adaptAllOptionsForHierarchicalLayout(allOptions) {
        if (this.options.hierarchical.enabled === true) {
          // set the physics
          if (allOptions.physics === undefined || allOptions.physics === true) {
            allOptions.physics = {
              enabled: this.optionsBackup.physics.enabled === undefined ? true : this.optionsBackup.physics.enabled,
              solver: 'hierarchicalRepulsion'
            };
            this.optionsBackup.physics.enabled = this.optionsBackup.physics.enabled === undefined ? true : this.optionsBackup.physics.enabled;
            this.optionsBackup.physics.solver = this.optionsBackup.physics.solver || 'barnesHut';
          } else if (_typeof(allOptions.physics) === 'object') {
            this.optionsBackup.physics.enabled = allOptions.physics.enabled === undefined ? true : allOptions.physics.enabled;
            this.optionsBackup.physics.solver = allOptions.physics.solver || 'barnesHut';
            allOptions.physics.solver = 'hierarchicalRepulsion';
          } else if (allOptions.physics !== false) {
            this.optionsBackup.physics.solver = 'barnesHut';
            allOptions.physics = { solver: 'hierarchicalRepulsion' };
          }

          // get the type of static smooth curve in case it is required
          var type = 'horizontal';
          if (this.options.hierarchical.direction === 'RL' || this.options.hierarchical.direction === 'LR') {
            type = 'vertical';
          }

          // disable smooth curves if nothing is defined. If smooth curves have been turned on, turn them into static smooth curves.
          if (allOptions.edges === undefined) {
            this.optionsBackup.edges = { smooth: { enabled: true, type: 'dynamic' } };
            allOptions.edges = { smooth: false };
          } else if (allOptions.edges.smooth === undefined) {
            this.optionsBackup.edges = { smooth: { enabled: true, type: 'dynamic' } };
            allOptions.edges.smooth = false;
          } else {
            if (typeof allOptions.edges.smooth === 'boolean') {
              this.optionsBackup.edges = { smooth: allOptions.edges.smooth };
              allOptions.edges.smooth = { enabled: allOptions.edges.smooth, type: type };
            } else {
              // allow custom types except for dynamic
              if (allOptions.edges.smooth.type !== undefined && allOptions.edges.smooth.type !== 'dynamic') {
                type = allOptions.edges.smooth.type;
              }

              this.optionsBackup.edges = {
                smooth: allOptions.edges.smooth.enabled === undefined ? true : allOptions.edges.smooth.enabled,
                type: allOptions.edges.smooth.type === undefined ? 'dynamic' : allOptions.edges.smooth.type,
                roundness: allOptions.edges.smooth.roundness === undefined ? 0.5 : allOptions.edges.smooth.roundness,
                forceDirection: allOptions.edges.smooth.forceDirection === undefined ? false : allOptions.edges.smooth.forceDirection
              };
              allOptions.edges.smooth = {
                enabled: allOptions.edges.smooth.enabled === undefined ? true : allOptions.edges.smooth.enabled,
                type: type,
                roundness: allOptions.edges.smooth.roundness === undefined ? 0.5 : allOptions.edges.smooth.roundness,
                forceDirection: allOptions.edges.smooth.forceDirection === undefined ? false : allOptions.edges.smooth.forceDirection
              };
            }
          }

          // force all edges into static smooth curves. Only applies to edges that do not use the global options for smooth.
          this.body.emitter.emit('_forceDisableDynamicCurves', type);
        }

        return allOptions;
      }
    }, {
      key: 'seededRandom',
      value: function seededRandom() {
        var x = Math.sin(this.randomSeed++) * 10000;
        return x - Math.floor(x);
      }
    }, {
      key: 'positionInitially',
      value: function positionInitially(nodesArray) {
        if (this.options.hierarchical.enabled !== true) {
          this.randomSeed = this.initialRandomSeed;
          for (var i = 0; i < nodesArray.length; i++) {
            var node = nodesArray[i];
            var radius = 10 * 0.1 * nodesArray.length + 10;
            var angle = 2 * Math.PI * this.seededRandom();
            if (node.x === undefined) {
              node.x = radius * Math.cos(angle);
            }
            if (node.y === undefined) {
              node.y = radius * Math.sin(angle);
            }
          }
        }
      }

      /**
       * Use Kamada Kawai to position nodes. This is quite a heavy algorithm so if there are a lot of nodes we
       * cluster them first to reduce the amount.
       */

    }, {
      key: 'layoutNetwork',
      value: function layoutNetwork() {
        if (this.options.hierarchical.enabled !== true && this.options.improvedLayout === true) {
          // first check if we should Kamada Kawai to layout. The threshold is if less than half of the visible
          // nodes have predefined positions we use this.
          var positionDefined = 0;
          for (var i = 0; i < this.body.nodeIndices.length; i++) {
            var node = this.body.nodes[this.body.nodeIndices[i]];
            if (node.predefinedPosition === true) {
              positionDefined += 1;
            }
          }

          // if less than half of the nodes have a predefined position we continue
          if (positionDefined < 0.5 * this.body.nodeIndices.length) {
            var MAX_LEVELS = 10;
            var level = 0;
            var clusterThreshold = 100;
            // if there are a lot of nodes, we cluster before we run the algorithm.
            if (this.body.nodeIndices.length > clusterThreshold) {
              var startLength = this.body.nodeIndices.length;
              while (this.body.nodeIndices.length > clusterThreshold) {
                //console.time("clustering")
                level += 1;
                var before = this.body.nodeIndices.length;
                // if there are many nodes we do a hubsize cluster
                if (level % 3 === 0) {
                  this.body.modules.clustering.clusterBridges();
                } else {
                  this.body.modules.clustering.clusterOutliers();
                }
                var after = this.body.nodeIndices.length;
                if (before == after && level % 3 !== 0 || level > MAX_LEVELS) {
                  this._declusterAll();
                  this.body.emitter.emit("_layoutFailed");
                  console.info("This network could not be positioned by this version of the improved layout algorithm. Please disable improvedLayout for better performance.");
                  return;
                }
                //console.timeEnd("clustering")
                //console.log(level,after)
              }
              // increase the size of the edges
              this.body.modules.kamadaKawai.setOptions({ springLength: Math.max(150, 2 * startLength) });
            }

            // position the system for these nodes and edges
            this.body.modules.kamadaKawai.solve(this.body.nodeIndices, this.body.edgeIndices, true);

            // shift to center point
            this._shiftToCenter();

            // perturb the nodes a little bit to force the physics to kick in
            var offset = 70;
            for (var _i = 0; _i < this.body.nodeIndices.length; _i++) {
              this.body.nodes[this.body.nodeIndices[_i]].x += (0.5 - this.seededRandom()) * offset;
              this.body.nodes[this.body.nodeIndices[_i]].y += (0.5 - this.seededRandom()) * offset;
            }

            // uncluster all clusters
            this._declusterAll();

            // reposition all bezier nodes.
            this.body.emitter.emit("_repositionBezierNodes");
          }
        }
      }

      /**
       * Move all the nodes towards to the center so gravitational pull wil not move the nodes away from view
       * @private
       */

    }, {
      key: '_shiftToCenter',
      value: function _shiftToCenter() {
        var range = _NetworkUtil2.default.getRangeCore(this.body.nodes, this.body.nodeIndices);
        var center = _NetworkUtil2.default.findCenter(range);
        for (var i = 0; i < this.body.nodeIndices.length; i++) {
          this.body.nodes[this.body.nodeIndices[i]].x -= center.x;
          this.body.nodes[this.body.nodeIndices[i]].y -= center.y;
        }
      }
    }, {
      key: '_declusterAll',
      value: function _declusterAll() {
        var clustersPresent = true;
        while (clustersPresent === true) {
          clustersPresent = false;
          for (var i = 0; i < this.body.nodeIndices.length; i++) {
            if (this.body.nodes[this.body.nodeIndices[i]].isCluster === true) {
              clustersPresent = true;
              this.body.modules.clustering.openCluster(this.body.nodeIndices[i], {}, false);
            }
          }
          if (clustersPresent === true) {
            this.body.emitter.emit('_dataChanged');
          }
        }
      }
    }, {
      key: 'getSeed',
      value: function getSeed() {
        return this.initialRandomSeed;
      }

      /**
       * This is the main function to layout the nodes in a hierarchical way.
       * It checks if the node details are supplied correctly
       *
       * @private
       */

    }, {
      key: 'setupHierarchicalLayout',
      value: function setupHierarchicalLayout() {
        if (this.options.hierarchical.enabled === true && this.body.nodeIndices.length > 0) {
          // get the size of the largest hubs and check if the user has defined a level for a node.
          var node = void 0,
              nodeId = void 0;
          var definedLevel = false;
          var definedPositions = true;
          var undefinedLevel = false;
          this.hierarchicalLevels = {};
          this.lastNodeOnLevel = {};
          this.hierarchicalChildrenReference = {};
          this.hierarchicalParentReference = {};
          this.hierarchicalTrees = {};
          this.treeIndex = -1;

          this.distributionOrdering = {};
          this.distributionIndex = {};
          this.distributionOrderingPresence = {};

          for (nodeId in this.body.nodes) {
            if (this.body.nodes.hasOwnProperty(nodeId)) {
              node = this.body.nodes[nodeId];
              if (node.options.x === undefined && node.options.y === undefined) {
                definedPositions = false;
              }
              if (node.options.level !== undefined) {
                definedLevel = true;
                this.hierarchicalLevels[nodeId] = node.options.level;
              } else {
                undefinedLevel = true;
              }
            }
          }

          // if the user defined some levels but not all, alert and run without hierarchical layout
          if (undefinedLevel === true && definedLevel === true) {
            throw new Error('To use the hierarchical layout, nodes require either no predefined levels or levels have to be defined for all nodes.');
            return;
          } else {
            // define levels if undefined by the users. Based on hubsize.
            if (undefinedLevel === true) {
              if (this.options.hierarchical.sortMethod === 'hubsize') {
                this._determineLevelsByHubsize();
              } else if (this.options.hierarchical.sortMethod === 'directed') {
                this._determineLevelsDirected();
              } else if (this.options.hierarchical.sortMethod === 'custom') {
                this._determineLevelsCustomCallback();
              }
            }

            // fallback for cases where there are nodes but no edges
            for (var _nodeId in this.body.nodes) {
              if (this.body.nodes.hasOwnProperty(_nodeId)) {
                if (this.hierarchicalLevels[_nodeId] === undefined) {
                  this.hierarchicalLevels[_nodeId] = 0;
                }
              }
            }
            // check the distribution of the nodes per level.
            var distribution = this._getDistribution();

            // get the parent children relations.
            this._generateMap();

            // place the nodes on the canvas.
            this._placeNodesByHierarchy(distribution);

            // condense the whitespace.
            this._condenseHierarchy();

            // shift to center so gravity does not have to do much
            this._shiftToCenter();
          }
        }
      }

      /**
       * @private
       */

    }, {
      key: '_condenseHierarchy',
      value: function _condenseHierarchy() {
        var _this2 = this;

        // Global var in this scope to define when the movement has stopped.
        var stillShifting = false;
        var branches = {};
        // first we have some methods to help shifting trees around.
        // the main method to shift the trees
        var shiftTrees = function shiftTrees() {
          var treeSizes = getTreeSizes();
          for (var i = 0; i < treeSizes.length - 1; i++) {
            var diff = treeSizes[i].max - treeSizes[i + 1].min;
            shiftTree(i + 1, diff + _this2.options.hierarchical.treeSpacing);
          }
        };

        // shift a single tree by an offset
        var shiftTree = function shiftTree(index, offset) {
          for (var nodeId in _this2.hierarchicalTrees) {
            if (_this2.hierarchicalTrees.hasOwnProperty(nodeId)) {
              if (_this2.hierarchicalTrees[nodeId] === index) {
                var node = _this2.body.nodes[nodeId];
                var pos = _this2._getPositionForHierarchy(node);
                _this2._setPositionForHierarchy(node, pos + offset, undefined, true);
              }
            }
          }
        };

        // get the width of a tree
        var getTreeSize = function getTreeSize(index) {
          var min = 1e9;
          var max = -1e9;
          for (var nodeId in _this2.hierarchicalTrees) {
            if (_this2.hierarchicalTrees.hasOwnProperty(nodeId)) {
              if (_this2.hierarchicalTrees[nodeId] === index) {
                var pos = _this2._getPositionForHierarchy(_this2.body.nodes[nodeId]);
                min = Math.min(pos, min);
                max = Math.max(pos, max);
              }
            }
          }
          return { min: min, max: max };
        };

        // get the width of all trees
        var getTreeSizes = function getTreeSizes() {
          var treeWidths = [];
          for (var i = 0; i <= _this2.treeIndex; i++) {
            treeWidths.push(getTreeSize(i));
          }
          return treeWidths;
        };

        // get a map of all nodes in this branch
        var getBranchNodes = function getBranchNodes(source, map) {
          map[source.id] = true;
          if (_this2.hierarchicalChildrenReference[source.id]) {
            var children = _this2.hierarchicalChildrenReference[source.id];
            if (children.length > 0) {
              for (var i = 0; i < children.length; i++) {
                getBranchNodes(_this2.body.nodes[children[i]], map);
              }
            }
          }
        };

        // get a min max width as well as the maximum movement space it has on either sides
        // we use min max terminology because width and height can interchange depending on the direction of the layout
        var getBranchBoundary = function getBranchBoundary(branchMap) {
          var maxLevel = arguments.length <= 1 || arguments[1] === undefined ? 1e9 : arguments[1];

          var minSpace = 1e9;
          var maxSpace = 1e9;
          var min = 1e9;
          var max = -1e9;
          for (var branchNode in branchMap) {
            if (branchMap.hasOwnProperty(branchNode)) {
              var node = _this2.body.nodes[branchNode];
              var level = _this2.hierarchicalLevels[node.id];
              var position = _this2._getPositionForHierarchy(node);

              // get the space around the node.

              var _getSpaceAroundNode2 = _this2._getSpaceAroundNode(node, branchMap);

              var _getSpaceAroundNode3 = _slicedToArray(_getSpaceAroundNode2, 2);

              var minSpaceNode = _getSpaceAroundNode3[0];
              var maxSpaceNode = _getSpaceAroundNode3[1];

              minSpace = Math.min(minSpaceNode, minSpace);
              maxSpace = Math.min(maxSpaceNode, maxSpace);

              // the width is only relevant for the levels two nodes have in common. This is why we filter on this.
              if (level <= maxLevel) {
                min = Math.min(position, min);
                max = Math.max(position, max);
              }
            }
          }

          return [min, max, minSpace, maxSpace];
        };

        // get the maximum level of a branch.
        var getMaxLevel = function getMaxLevel(nodeId) {
          var level = _this2.hierarchicalLevels[nodeId];
          if (_this2.hierarchicalChildrenReference[nodeId]) {
            var children = _this2.hierarchicalChildrenReference[nodeId];
            if (children.length > 0) {
              for (var i = 0; i < children.length; i++) {
                level = Math.max(level, getMaxLevel(children[i]));
              }
            }
          }
          return level;
        };

        // check what the maximum level is these nodes have in common.
        var getCollisionLevel = function getCollisionLevel(node1, node2) {
          var maxLevel1 = getMaxLevel(node1.id);
          var maxLevel2 = getMaxLevel(node2.id);
          return Math.min(maxLevel1, maxLevel2);
        };

        // check if two nodes have the same parent(s)
        var hasSameParent = function hasSameParent(node1, node2) {
          var parents1 = _this2.hierarchicalParentReference[node1.id];
          var parents2 = _this2.hierarchicalParentReference[node2.id];
          if (parents1 === undefined || parents2 === undefined) {
            return false;
          }

          for (var i = 0; i < parents1.length; i++) {
            for (var j = 0; j < parents2.length; j++) {
              if (parents1[i] == parents2[j]) {
                return true;
              }
            }
          }
          return false;
        };

        // condense elements. These can be nodes or branches depending on the callback.
        var shiftElementsCloser = function shiftElementsCloser(callback, levels, centerParents) {
          for (var i = 0; i < levels.length; i++) {
            var level = levels[i];
            var levelNodes = _this2.distributionOrdering[level];
            if (levelNodes.length > 1) {
              for (var j = 0; j < levelNodes.length - 1; j++) {
                if (hasSameParent(levelNodes[j], levelNodes[j + 1]) === true) {
                  if (_this2.hierarchicalTrees[levelNodes[j].id] === _this2.hierarchicalTrees[levelNodes[j + 1].id]) {
                    callback(levelNodes[j], levelNodes[j + 1], centerParents);
                  }
                }
              }
            }
          }
        };

        // callback for shifting branches
        var branchShiftCallback = function branchShiftCallback(node1, node2) {
          var centerParent = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

          //window.CALLBACKS.push(() => {
          var pos1 = _this2._getPositionForHierarchy(node1);
          var pos2 = _this2._getPositionForHierarchy(node2);
          var diffAbs = Math.abs(pos2 - pos1);
          //console.log("NOW CHEcKING:", node1.id, node2.id, diffAbs);
          if (diffAbs > _this2.options.hierarchical.nodeSpacing) {
            var branchNodes1 = {};branchNodes1[node1.id] = true;
            var branchNodes2 = {};branchNodes2[node2.id] = true;

            getBranchNodes(node1, branchNodes1);
            getBranchNodes(node2, branchNodes2);

            // check the largest distance between the branches
            var maxLevel = getCollisionLevel(node1, node2);

            var _getBranchBoundary = getBranchBoundary(branchNodes1, maxLevel);

            var _getBranchBoundary2 = _slicedToArray(_getBranchBoundary, 4);

            var min1 = _getBranchBoundary2[0];
            var max1 = _getBranchBoundary2[1];
            var minSpace1 = _getBranchBoundary2[2];
            var maxSpace1 = _getBranchBoundary2[3];

            var _getBranchBoundary3 = getBranchBoundary(branchNodes2, maxLevel);

            var _getBranchBoundary4 = _slicedToArray(_getBranchBoundary3, 4);

            var min2 = _getBranchBoundary4[0];
            var max2 = _getBranchBoundary4[1];
            var minSpace2 = _getBranchBoundary4[2];
            var maxSpace2 = _getBranchBoundary4[3];

            //console.log(node1.id, getBranchBoundary(branchNodes1, maxLevel), node2.id, getBranchBoundary(branchNodes2, maxLevel), maxLevel);

            var diffBranch = Math.abs(max1 - min2);
            if (diffBranch > _this2.options.hierarchical.nodeSpacing) {
              var offset = max1 - min2 + _this2.options.hierarchical.nodeSpacing;
              if (offset < -minSpace2 + _this2.options.hierarchical.nodeSpacing) {
                offset = -minSpace2 + _this2.options.hierarchical.nodeSpacing;
                //console.log("RESETTING OFFSET", max1 - min2 + this.options.hierarchical.nodeSpacing, -minSpace2, offset);
              }
              if (offset < 0) {
                //console.log("SHIFTING", node2.id, offset);
                _this2._shiftBlock(node2.id, offset);
                stillShifting = true;

                if (centerParent === true) _this2._centerParent(node2);
              }
            }
          }
          //this.body.emitter.emit("_redraw");})
        };

        var minimizeEdgeLength = function minimizeEdgeLength(iterations, node) {
          //window.CALLBACKS.push(() => {
          //  console.log("ts",node.id);
          var nodeId = node.id;
          var allEdges = node.edges;
          var nodeLevel = _this2.hierarchicalLevels[node.id];

          // gather constants
          var C2 = _this2.options.hierarchical.levelSeparation * _this2.options.hierarchical.levelSeparation;
          var referenceNodes = {};
          var aboveEdges = [];
          for (var i = 0; i < allEdges.length; i++) {
            var edge = allEdges[i];
            if (edge.toId != edge.fromId) {
              var otherNode = edge.toId == nodeId ? edge.from : edge.to;
              referenceNodes[allEdges[i].id] = otherNode;
              if (_this2.hierarchicalLevels[otherNode.id] < nodeLevel) {
                aboveEdges.push(edge);
              }
            }
          }

          // differentiated sum of lengths based on only moving one node over one axis
          var getFx = function getFx(point, edges) {
            var sum = 0;
            for (var _i2 = 0; _i2 < edges.length; _i2++) {
              if (referenceNodes[edges[_i2].id] !== undefined) {
                var a = _this2._getPositionForHierarchy(referenceNodes[edges[_i2].id]) - point;
                sum += a / Math.sqrt(a * a + C2);
              }
            }
            return sum;
          };

          // doubly differentiated sum of lengths based on only moving one node over one axis
          var getDFx = function getDFx(point, edges) {
            var sum = 0;
            for (var _i3 = 0; _i3 < edges.length; _i3++) {
              if (referenceNodes[edges[_i3].id] !== undefined) {
                var a = _this2._getPositionForHierarchy(referenceNodes[edges[_i3].id]) - point;
                sum -= C2 * Math.pow(a * a + C2, -1.5);
              }
            }
            return sum;
          };

          var getGuess = function getGuess(iterations, edges) {
            var guess = _this2._getPositionForHierarchy(node);
            // Newton's method for optimization
            var guessMap = {};
            for (var _i4 = 0; _i4 < iterations; _i4++) {
              var fx = getFx(guess, edges);
              var dfx = getDFx(guess, edges);

              // we limit the movement to avoid instability.
              var limit = 40;
              var ratio = Math.max(-limit, Math.min(limit, Math.round(fx / dfx)));
              guess = guess - ratio;
              // reduce duplicates
              if (guessMap[guess] !== undefined) {
                break;
              }
              guessMap[guess] = _i4;
            }
            return guess;
          };

          var moveBranch = function moveBranch(guess) {
            // position node if there is space
            var nodePosition = _this2._getPositionForHierarchy(node);

            // check movable area of the branch
            if (branches[node.id] === undefined) {
              var branchNodes = {};
              branchNodes[node.id] = true;
              getBranchNodes(node, branchNodes);
              branches[node.id] = branchNodes;
            }

            var _getBranchBoundary5 = getBranchBoundary(branches[node.id]);

            var _getBranchBoundary6 = _slicedToArray(_getBranchBoundary5, 4);

            var minBranch = _getBranchBoundary6[0];
            var maxBranch = _getBranchBoundary6[1];
            var minSpaceBranch = _getBranchBoundary6[2];
            var maxSpaceBranch = _getBranchBoundary6[3];


            var diff = guess - nodePosition;

            // check if we are allowed to move the node:
            var branchOffset = 0;
            if (diff > 0) {
              branchOffset = Math.min(diff, maxSpaceBranch - _this2.options.hierarchical.nodeSpacing);
            } else if (diff < 0) {
              branchOffset = -Math.min(-diff, minSpaceBranch - _this2.options.hierarchical.nodeSpacing);
            }

            if (branchOffset != 0) {
              //console.log("moving branch:",branchOffset, maxSpaceBranch, minSpaceBranch)
              _this2._shiftBlock(node.id, branchOffset);
              //this.body.emitter.emit("_redraw");
              stillShifting = true;
            }
          };

          var moveNode = function moveNode(guess) {
            var nodePosition = _this2._getPositionForHierarchy(node);

            // position node if there is space

            var _getSpaceAroundNode4 = _this2._getSpaceAroundNode(node);

            var _getSpaceAroundNode5 = _slicedToArray(_getSpaceAroundNode4, 2);

            var minSpace = _getSpaceAroundNode5[0];
            var maxSpace = _getSpaceAroundNode5[1];

            var diff = guess - nodePosition;
            // check if we are allowed to move the node:
            var newPosition = nodePosition;
            if (diff > 0) {
              newPosition = Math.min(nodePosition + (maxSpace - _this2.options.hierarchical.nodeSpacing), guess);
            } else if (diff < 0) {
              newPosition = Math.max(nodePosition - (minSpace - _this2.options.hierarchical.nodeSpacing), guess);
            }

            if (newPosition !== nodePosition) {
              //console.log("moving Node:",diff, minSpace, maxSpace);
              _this2._setPositionForHierarchy(node, newPosition, undefined, true);
              //this.body.emitter.emit("_redraw");
              stillShifting = true;
            }
          };

          var guess = getGuess(iterations, aboveEdges);
          moveBranch(guess);
          guess = getGuess(iterations, allEdges);
          moveNode(guess);
          //})
        };

        // method to remove whitespace between branches. Because we do bottom up, we can center the parents.
        var minimizeEdgeLengthBottomUp = function minimizeEdgeLengthBottomUp(iterations) {
          var levels = Object.keys(_this2.distributionOrdering);
          levels = levels.reverse();
          for (var i = 0; i < iterations; i++) {
            stillShifting = false;
            for (var j = 0; j < levels.length; j++) {
              var level = levels[j];
              var levelNodes = _this2.distributionOrdering[level];
              for (var k = 0; k < levelNodes.length; k++) {
                minimizeEdgeLength(1000, levelNodes[k]);
              }
            }
            if (stillShifting !== true) {
              //console.log("FINISHED minimizeEdgeLengthBottomUp IN " + i);
              break;
            }
          }
        };

        // method to remove whitespace between branches. Because we do bottom up, we can center the parents.
        var shiftBranchesCloserBottomUp = function shiftBranchesCloserBottomUp(iterations) {
          var levels = Object.keys(_this2.distributionOrdering);
          levels = levels.reverse();
          for (var i = 0; i < iterations; i++) {
            stillShifting = false;
            shiftElementsCloser(branchShiftCallback, levels, true);
            if (stillShifting !== true) {
              //console.log("FINISHED shiftBranchesCloserBottomUp IN " + (i+1));
              break;
            }
          }
        };

        // center all parents
        var centerAllParents = function centerAllParents() {
          for (var nodeId in _this2.body.nodes) {
            if (_this2.body.nodes.hasOwnProperty(nodeId)) _this2._centerParent(_this2.body.nodes[nodeId]);
          }
        };

        // center all parents
        var centerAllParentsBottomUp = function centerAllParentsBottomUp() {
          var levels = Object.keys(_this2.distributionOrdering);
          levels = levels.reverse();
          for (var i = 0; i < levels.length; i++) {
            var level = levels[i];
            var levelNodes = _this2.distributionOrdering[level];
            for (var j = 0; j < levelNodes.length; j++) {
              _this2._centerParent(levelNodes[j]);
            }
          }
        };

        // the actual work is done here.
        if (this.options.hierarchical.blockShifting === true) {
          shiftBranchesCloserBottomUp(5);
          centerAllParents();
        }

        // minimize edge length
        if (this.options.hierarchical.edgeMinimization === true) {
          minimizeEdgeLengthBottomUp(20);
        }

        if (this.options.hierarchical.parentCentralization === true) {
          centerAllParentsBottomUp();
        }

        shiftTrees();
      }

      /**
       * This gives the space around the node. IF a map is supplied, it will only check against nodes NOT in the map.
       * This is used to only get the distances to nodes outside of a branch.
       * @param node
       * @param map
       * @returns {*[]}
       * @private
       */

    }, {
      key: '_getSpaceAroundNode',
      value: function _getSpaceAroundNode(node, map) {
        var useMap = true;
        if (map === undefined) {
          useMap = false;
        }
        var level = this.hierarchicalLevels[node.id];
        if (level !== undefined) {
          var index = this.distributionIndex[node.id];
          var position = this._getPositionForHierarchy(node);
          var minSpace = 1e9;
          var maxSpace = 1e9;
          if (index !== 0) {
            var prevNode = this.distributionOrdering[level][index - 1];
            if (useMap === true && map[prevNode.id] === undefined || useMap === false) {
              var prevPos = this._getPositionForHierarchy(prevNode);
              minSpace = position - prevPos;
            }
          }

          if (index != this.distributionOrdering[level].length - 1) {
            var nextNode = this.distributionOrdering[level][index + 1];
            if (useMap === true && map[nextNode.id] === undefined || useMap === false) {
              var nextPos = this._getPositionForHierarchy(nextNode);
              maxSpace = Math.min(maxSpace, nextPos - position);
            }
          }

          return [minSpace, maxSpace];
        } else {
          return [0, 0];
        }
      }

      /**
       * We use this method to center a parent node and check if it does not cross other nodes when it does.
       * @param node
       * @private
       */

    }, {
      key: '_centerParent',
      value: function _centerParent(node) {
        if (this.hierarchicalParentReference[node.id]) {
          var parents = this.hierarchicalParentReference[node.id];
          for (var i = 0; i < parents.length; i++) {
            var parentId = parents[i];
            var parentNode = this.body.nodes[parentId];
            if (this.hierarchicalChildrenReference[parentId]) {
              // get the range of the children
              var minPos = 1e9;
              var maxPos = -1e9;
              var children = this.hierarchicalChildrenReference[parentId];
              if (children.length > 0) {
                for (var _i5 = 0; _i5 < children.length; _i5++) {
                  var childNode = this.body.nodes[children[_i5]];
                  minPos = Math.min(minPos, this._getPositionForHierarchy(childNode));
                  maxPos = Math.max(maxPos, this._getPositionForHierarchy(childNode));
                }
              }

              var position = this._getPositionForHierarchy(parentNode);

              var _getSpaceAroundNode6 = this._getSpaceAroundNode(parentNode);

              var _getSpaceAroundNode7 = _slicedToArray(_getSpaceAroundNode6, 2);

              var minSpace = _getSpaceAroundNode7[0];
              var maxSpace = _getSpaceAroundNode7[1];

              var newPosition = 0.5 * (minPos + maxPos);
              var diff = position - newPosition;
              if (diff < 0 && Math.abs(diff) < maxSpace - this.options.hierarchical.nodeSpacing || diff > 0 && Math.abs(diff) < minSpace - this.options.hierarchical.nodeSpacing) {
                this._setPositionForHierarchy(parentNode, newPosition, undefined, true);
              }
            }
          }
        }
      }

      /**
       * This function places the nodes on the canvas based on the hierarchial distribution.
       *
       * @param {Object} distribution | obtained by the function this._getDistribution()
       * @private
       */

    }, {
      key: '_placeNodesByHierarchy',
      value: function _placeNodesByHierarchy(distribution) {
        this.positionedNodes = {};
        // start placing all the level 0 nodes first. Then recursively position their branches.
        for (var level in distribution) {
          if (distribution.hasOwnProperty(level)) {
            // sort nodes in level by position:
            var nodeArray = Object.keys(distribution[level]);
            nodeArray = this._indexArrayToNodes(nodeArray);
            this._sortNodeArray(nodeArray);
            var handledNodeCount = 0;

            for (var i = 0; i < nodeArray.length; i++) {
              var node = nodeArray[i];
              if (this.positionedNodes[node.id] === undefined) {
                var pos = this.options.hierarchical.nodeSpacing * handledNodeCount;
                // we get the X or Y values we need and store them in pos and previousPos. The get and set make sure we get X or Y
                if (handledNodeCount > 0) {
                  pos = this._getPositionForHierarchy(nodeArray[i - 1]) + this.options.hierarchical.nodeSpacing;
                }
                this._setPositionForHierarchy(node, pos, level);
                this._validataPositionAndContinue(node, level, pos);

                handledNodeCount++;
              }
            }
          }
        }
      }

      /**
       * This is a recursively called function to enumerate the branches from the largest hubs and place the nodes
       * on a X position that ensures there will be no overlap.
       *
       * @param parentId
       * @param parentLevel
       * @private
       */

    }, {
      key: '_placeBranchNodes',
      value: function _placeBranchNodes(parentId, parentLevel) {
        // if this is not a parent, cancel the placing. This can happen with multiple parents to one child.
        if (this.hierarchicalChildrenReference[parentId] === undefined) {
          return;
        }

        // get a list of childNodes
        var childNodes = [];
        for (var i = 0; i < this.hierarchicalChildrenReference[parentId].length; i++) {
          childNodes.push(this.body.nodes[this.hierarchicalChildrenReference[parentId][i]]);
        }

        // use the positions to order the nodes.
        this._sortNodeArray(childNodes);

        // position the childNodes
        for (var _i6 = 0; _i6 < childNodes.length; _i6++) {
          var childNode = childNodes[_i6];
          var childNodeLevel = this.hierarchicalLevels[childNode.id];
          // check if the child node is below the parent node and if it has already been positioned.
          if (childNodeLevel > parentLevel && this.positionedNodes[childNode.id] === undefined) {
            // get the amount of space required for this node. If parent the width is based on the amount of children.
            var pos = void 0;

            // we get the X or Y values we need and store them in pos and previousPos. The get and set make sure we get X or Y
            if (_i6 === 0) {
              pos = this._getPositionForHierarchy(this.body.nodes[parentId]);
            } else {
              pos = this._getPositionForHierarchy(childNodes[_i6 - 1]) + this.options.hierarchical.nodeSpacing;
            }
            this._setPositionForHierarchy(childNode, pos, childNodeLevel);
            this._validataPositionAndContinue(childNode, childNodeLevel, pos);
          } else {
            return;
          }
        }

        // center the parent nodes.
        var minPos = 1e9;
        var maxPos = -1e9;
        for (var _i7 = 0; _i7 < childNodes.length; _i7++) {
          var childNodeId = childNodes[_i7].id;
          minPos = Math.min(minPos, this._getPositionForHierarchy(this.body.nodes[childNodeId]));
          maxPos = Math.max(maxPos, this._getPositionForHierarchy(this.body.nodes[childNodeId]));
        }
        this._setPositionForHierarchy(this.body.nodes[parentId], 0.5 * (minPos + maxPos), parentLevel);
      }

      /**
       * This method checks for overlap and if required shifts the branch. It also keeps records of positioned nodes.
       * Finally it will call _placeBranchNodes to place the branch nodes.
       * @param node
       * @param level
       * @param pos
       * @private
       */

    }, {
      key: '_validataPositionAndContinue',
      value: function _validataPositionAndContinue(node, level, pos) {
        // if overlap has been detected, we shift the branch
        if (this.lastNodeOnLevel[level] !== undefined) {
          var previousPos = this._getPositionForHierarchy(this.body.nodes[this.lastNodeOnLevel[level]]);
          if (pos - previousPos < this.options.hierarchical.nodeSpacing) {
            var diff = previousPos + this.options.hierarchical.nodeSpacing - pos;
            var sharedParent = this._findCommonParent(this.lastNodeOnLevel[level], node.id);
            this._shiftBlock(sharedParent.withChild, diff);
          }
        }

        // store change in position.
        this.lastNodeOnLevel[level] = node.id;

        this.positionedNodes[node.id] = true;

        this._placeBranchNodes(node.id, level);
      }

      /**
       * Receives an array with node indices and returns an array with the actual node references. Used for sorting based on
       * node properties.
       * @param idArray
       */

    }, {
      key: '_indexArrayToNodes',
      value: function _indexArrayToNodes(idArray) {
        var array = [];
        for (var i = 0; i < idArray.length; i++) {
          array.push(this.body.nodes[idArray[i]]);
        }
        return array;
      }

      /**
       * This function get the distribution of levels based on hubsize
       *
       * @returns {Object}
       * @private
       */

    }, {
      key: '_getDistribution',
      value: function _getDistribution() {
        var distribution = {};
        var nodeId = void 0,
            node = void 0;

        // we fix Y because the hierarchy is vertical, we fix X so we do not give a node an x position for a second time.
        // the fix of X is removed after the x value has been set.
        for (nodeId in this.body.nodes) {
          if (this.body.nodes.hasOwnProperty(nodeId)) {
            node = this.body.nodes[nodeId];
            var level = this.hierarchicalLevels[nodeId] === undefined ? 0 : this.hierarchicalLevels[nodeId];
            if (this.options.hierarchical.direction === 'UD' || this.options.hierarchical.direction === 'DU') {
              node.y = this.options.hierarchical.levelSeparation * level;
              node.options.fixed.y = true;
            } else {
              node.x = this.options.hierarchical.levelSeparation * level;
              node.options.fixed.x = true;
            }
            if (distribution[level] === undefined) {
              distribution[level] = {};
            }
            distribution[level][nodeId] = node;
          }
        }
        return distribution;
      }

      /**
       * Get the hubsize from all remaining unlevelled nodes.
       *
       * @returns {number}
       * @private
       */

    }, {
      key: '_getHubSize',
      value: function _getHubSize() {
        var hubSize = 0;
        for (var nodeId in this.body.nodes) {
          if (this.body.nodes.hasOwnProperty(nodeId)) {
            var node = this.body.nodes[nodeId];
            if (this.hierarchicalLevels[nodeId] === undefined) {
              hubSize = node.edges.length < hubSize ? hubSize : node.edges.length;
            }
          }
        }
        return hubSize;
      }

      /**
       * this function allocates nodes in levels based on the recursive branching from the largest hubs.
       *
       * @param hubsize
       * @private
       */

    }, {
      key: '_determineLevelsByHubsize',
      value: function _determineLevelsByHubsize() {
        var _this3 = this;

        var hubSize = 1;

        var levelDownstream = function levelDownstream(nodeA, nodeB) {
          if (_this3.hierarchicalLevels[nodeB.id] === undefined) {
            // set initial level
            if (_this3.hierarchicalLevels[nodeA.id] === undefined) {
              _this3.hierarchicalLevels[nodeA.id] = 0;
            }
            // set level
            _this3.hierarchicalLevels[nodeB.id] = _this3.hierarchicalLevels[nodeA.id] + 1;
          }
        };

        while (hubSize > 0) {
          // determine hubs
          hubSize = this._getHubSize();
          if (hubSize === 0) break;

          for (var nodeId in this.body.nodes) {
            if (this.body.nodes.hasOwnProperty(nodeId)) {
              var node = this.body.nodes[nodeId];
              if (node.edges.length === hubSize) {
                this._crawlNetwork(levelDownstream, nodeId);
              }
            }
          }
        }
      }

      /**
       * TODO: release feature
       * @private
       */

    }, {
      key: '_determineLevelsCustomCallback',
      value: function _determineLevelsCustomCallback() {
        var _this4 = this;

        var minLevel = 100000;

        // TODO: this should come from options.
        var customCallback = function customCallback(nodeA, nodeB, edge) {};

        var levelByDirection = function levelByDirection(nodeA, nodeB, edge) {
          var levelA = _this4.hierarchicalLevels[nodeA.id];
          // set initial level
          if (levelA === undefined) {
            _this4.hierarchicalLevels[nodeA.id] = minLevel;
          }

          var diff = customCallback(_NetworkUtil2.default.cloneOptions(nodeA, 'node'), _NetworkUtil2.default.cloneOptions(nodeB, 'node'), _NetworkUtil2.default.cloneOptions(edge, 'edge'));

          _this4.hierarchicalLevels[nodeB.id] = _this4.hierarchicalLevels[nodeA.id] + diff;
        };

        this._crawlNetwork(levelByDirection);
        this._setMinLevelToZero();
      }

      /**
       * this function allocates nodes in levels based on the direction of the edges
       *
       * @param hubsize
       * @private
       */

    }, {
      key: '_determineLevelsDirected',
      value: function _determineLevelsDirected() {
        var _this5 = this;

        var minLevel = 10000;
        var levelByDirection = function levelByDirection(nodeA, nodeB, edge) {
          var levelA = _this5.hierarchicalLevels[nodeA.id];
          // set initial level
          if (levelA === undefined) {
            _this5.hierarchicalLevels[nodeA.id] = minLevel;
          }
          if (edge.toId == nodeB.id) {
            _this5.hierarchicalLevels[nodeB.id] = _this5.hierarchicalLevels[nodeA.id] + 1;
          } else {
            _this5.hierarchicalLevels[nodeB.id] = _this5.hierarchicalLevels[nodeA.id] - 1;
          }
        };
        this._crawlNetwork(levelByDirection);
        this._setMinLevelToZero();
      }

      /**
       * Small util method to set the minimum levels of the nodes to zero.
       * @private
       */

    }, {
      key: '_setMinLevelToZero',
      value: function _setMinLevelToZero() {
        var minLevel = 1e9;
        // get the minimum level
        for (var nodeId in this.body.nodes) {
          if (this.body.nodes.hasOwnProperty(nodeId)) {
            if (this.hierarchicalLevels[nodeId] !== undefined) {
              minLevel = Math.min(this.hierarchicalLevels[nodeId], minLevel);
            }
          }
        }

        // subtract the minimum from the set so we have a range starting from 0
        for (var _nodeId2 in this.body.nodes) {
          if (this.body.nodes.hasOwnProperty(_nodeId2)) {
            if (this.hierarchicalLevels[_nodeId2] !== undefined) {
              this.hierarchicalLevels[_nodeId2] -= minLevel;
            }
          }
        }
      }

      /**
       * Update the bookkeeping of parent and child.
       * @private
       */

    }, {
      key: '_generateMap',
      value: function _generateMap() {
        var _this6 = this;

        var fillInRelations = function fillInRelations(parentNode, childNode) {
          if (_this6.hierarchicalLevels[childNode.id] > _this6.hierarchicalLevels[parentNode.id]) {
            var parentNodeId = parentNode.id;
            var childNodeId = childNode.id;
            if (_this6.hierarchicalChildrenReference[parentNodeId] === undefined) {
              _this6.hierarchicalChildrenReference[parentNodeId] = [];
            }
            _this6.hierarchicalChildrenReference[parentNodeId].push(childNodeId);
            if (_this6.hierarchicalParentReference[childNodeId] === undefined) {
              _this6.hierarchicalParentReference[childNodeId] = [];
            }
            _this6.hierarchicalParentReference[childNodeId].push(parentNodeId);
          }
        };

        this._crawlNetwork(fillInRelations);
      }

      /**
       * Crawl over the entire network and use a callback on each node couple that is connected to each other.
       * @param callback          | will receive nodeA nodeB and the connecting edge. A and B are unique.
       * @param startingNodeId
       * @private
       */

    }, {
      key: '_crawlNetwork',
      value: function _crawlNetwork() {
        var _this7 = this;

        var callback = arguments.length <= 0 || arguments[0] === undefined ? function () {} : arguments[0];
        var startingNodeId = arguments[1];

        var progress = {};
        var treeIndex = 0;

        var crawler = function crawler(node, tree) {
          if (progress[node.id] === undefined) {

            if (_this7.hierarchicalTrees[node.id] === undefined) {
              _this7.hierarchicalTrees[node.id] = tree;
              _this7.treeIndex = Math.max(tree, _this7.treeIndex);
            }

            progress[node.id] = true;
            var childNode = void 0;
            for (var i = 0; i < node.edges.length; i++) {
              if (node.edges[i].connected === true) {
                if (node.edges[i].toId === node.id) {
                  childNode = node.edges[i].from;
                } else {
                  childNode = node.edges[i].to;
                }

                if (node.id !== childNode.id) {
                  callback(node, childNode, node.edges[i]);
                  crawler(childNode, tree);
                }
              }
            }
          }
        };

        // we can crawl from a specific node or over all nodes.
        if (startingNodeId === undefined) {
          for (var i = 0; i < this.body.nodeIndices.length; i++) {
            var node = this.body.nodes[this.body.nodeIndices[i]];
            if (progress[node.id] === undefined) {
              crawler(node, treeIndex);
              treeIndex += 1;
            }
          }
        } else {
          var _node = this.body.nodes[startingNodeId];
          if (_node === undefined) {
            console.error("Node not found:", startingNodeId);
            return;
          }
          crawler(_node);
        }
      }

      /**
       * Shift a branch a certain distance
       * @param parentId
       * @param diff
       * @private
       */

    }, {
      key: '_shiftBlock',
      value: function _shiftBlock(parentId, diff) {
        if (this.options.hierarchical.direction === 'UD' || this.options.hierarchical.direction === 'DU') {
          this.body.nodes[parentId].x += diff;
        } else {
          this.body.nodes[parentId].y += diff;
        }
        if (this.hierarchicalChildrenReference[parentId] !== undefined) {
          for (var i = 0; i < this.hierarchicalChildrenReference[parentId].length; i++) {
            this._shiftBlock(this.hierarchicalChildrenReference[parentId][i], diff);
          }
        }
      }

      /**
       * Find a common parent between branches.
       * @param childA
       * @param childB
       * @returns {{foundParent, withChild}}
       * @private
       */

    }, {
      key: '_findCommonParent',
      value: function _findCommonParent(childA, childB) {
        var _this8 = this;

        var parents = {};
        var iterateParents = function iterateParents(parents, child) {
          if (_this8.hierarchicalParentReference[child] !== undefined) {
            for (var i = 0; i < _this8.hierarchicalParentReference[child].length; i++) {
              var parent = _this8.hierarchicalParentReference[child][i];
              parents[parent] = true;
              iterateParents(parents, parent);
            }
          }
        };
        var findParent = function findParent(parents, child) {
          if (_this8.hierarchicalParentReference[child] !== undefined) {
            for (var i = 0; i < _this8.hierarchicalParentReference[child].length; i++) {
              var parent = _this8.hierarchicalParentReference[child][i];
              if (parents[parent] !== undefined) {
                return { foundParent: parent, withChild: child };
              }
              var branch = findParent(parents, parent);
              if (branch.foundParent !== null) {
                return branch;
              }
            }
          }
          return { foundParent: null, withChild: child };
        };

        iterateParents(parents, childA);
        return findParent(parents, childB);
      }

      /**
       * Abstract the getting of the position so we won't have to repeat the check for direction all the time
       * @param node
       * @param position
       * @param level
       * @private
       */

    }, {
      key: '_setPositionForHierarchy',
      value: function _setPositionForHierarchy(node, position, level) {
        var doNotUpdate = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

        //console.log('_setPositionForHierarchy',node.id, position)
        if (doNotUpdate !== true) {
          if (this.distributionOrdering[level] === undefined) {
            this.distributionOrdering[level] = [];
            this.distributionOrderingPresence[level] = {};
          }

          if (this.distributionOrderingPresence[level][node.id] === undefined) {
            this.distributionOrdering[level].push(node);
            this.distributionIndex[node.id] = this.distributionOrdering[level].length - 1;
          }
          this.distributionOrderingPresence[level][node.id] = true;
        }

        if (this.options.hierarchical.direction === 'UD' || this.options.hierarchical.direction === 'DU') {
          node.x = position;
        } else {
          node.y = position;
        }
      }

      /**
       * Abstract the getting of the position of a node so we do not have to repeat the direction check all the time.
       * @param node
       * @returns {number|*}
       * @private
       */

    }, {
      key: '_getPositionForHierarchy',
      value: function _getPositionForHierarchy(node) {
        if (this.options.hierarchical.direction === 'UD' || this.options.hierarchical.direction === 'DU') {
          return node.x;
        } else {
          return node.y;
        }
      }

      /**
       * Use the x or y value to sort the array, allowing users to specify order.
       * @param nodeArray
       * @private
       */

    }, {
      key: '_sortNodeArray',
      value: function _sortNodeArray(nodeArray) {
        if (nodeArray.length > 1) {
          if (this.options.hierarchical.direction === 'UD' || this.options.hierarchical.direction === 'DU') {
            nodeArray.sort(function (a, b) {
              return a.x - b.x;
            });
          } else {
            nodeArray.sort(function (a, b) {
              return a.y - b.y;
            });
          }
        }
      }
    }]);

    return LayoutEngine;
  }();

  exports.default = LayoutEngine;

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var util = __webpack_require__(1);
  var Hammer = __webpack_require__(20);
  var hammerUtil = __webpack_require__(28);

  /**
   * clears the toolbar div element of children
   *
   * @private
   */

  var ManipulationSystem = function () {
    function ManipulationSystem(body, canvas, selectionHandler) {
      var _this = this;

      _classCallCheck(this, ManipulationSystem);

      this.body = body;
      this.canvas = canvas;
      this.selectionHandler = selectionHandler;

      this.editMode = false;
      this.manipulationDiv = undefined;
      this.editModeDiv = undefined;
      this.closeDiv = undefined;

      this.manipulationHammers = [];
      this.temporaryUIFunctions = {};
      this.temporaryEventFunctions = [];

      this.touchTime = 0;
      this.temporaryIds = { nodes: [], edges: [] };
      this.guiEnabled = false;
      this.inMode = false;
      this.selectedControlNode = undefined;

      this.options = {};
      this.defaultOptions = {
        enabled: false,
        initiallyActive: false,
        addNode: true,
        addEdge: true,
        editNode: undefined,
        editEdge: true,
        deleteNode: true,
        deleteEdge: true,
        controlNodeStyle: {
          shape: 'dot',
          size: 6,
          color: { background: '#ff0000', border: '#3c3c3c', highlight: { background: '#07f968', border: '#3c3c3c' } },
          borderWidth: 2,
          borderWidthSelected: 2
        }
      };
      util.extend(this.options, this.defaultOptions);

      this.body.emitter.on('destroy', function () {
        _this._clean();
      });
      this.body.emitter.on('_dataChanged', this._restore.bind(this));
      this.body.emitter.on('_resetData', this._restore.bind(this));
    }

    /**
     * If something changes in the data during editing, switch back to the initial datamanipulation state and close all edit modes.
     * @private
     */


    _createClass(ManipulationSystem, [{
      key: '_restore',
      value: function _restore() {
        if (this.inMode !== false) {
          if (this.options.initiallyActive === true) {
            this.enableEditMode();
          } else {
            this.disableEditMode();
          }
        }
      }

      /**
       * Set the Options
       * @param options
       */

    }, {
      key: 'setOptions',
      value: function setOptions(options, allOptions, globalOptions) {
        if (allOptions !== undefined) {
          if (allOptions.locale !== undefined) {
            this.options.locale = allOptions.locale;
          } else {
            this.options.locale = globalOptions.locale;
          }
          if (allOptions.locales !== undefined) {
            this.options.locales = allOptions.locales;
          } else {
            this.options.locales = globalOptions.locales;
          }
        }

        if (options !== undefined) {
          if (typeof options === 'boolean') {
            this.options.enabled = options;
          } else {
            this.options.enabled = true;
            util.deepExtend(this.options, options);
          }
          if (this.options.initiallyActive === true) {
            this.editMode = true;
          }
          this._setup();
        }
      }

      /**
       * Enable or disable edit-mode. Draws the DOM required and cleans up after itself.
       *
       * @private
       */

    }, {
      key: 'toggleEditMode',
      value: function toggleEditMode() {
        if (this.editMode === true) {
          this.disableEditMode();
        } else {
          this.enableEditMode();
        }
      }
    }, {
      key: 'enableEditMode',
      value: function enableEditMode() {
        this.editMode = true;

        this._clean();
        if (this.guiEnabled === true) {
          this.manipulationDiv.style.display = 'block';
          this.closeDiv.style.display = 'block';
          this.editModeDiv.style.display = 'none';
          this.showManipulatorToolbar();
        }
      }
    }, {
      key: 'disableEditMode',
      value: function disableEditMode() {
        this.editMode = false;

        this._clean();
        if (this.guiEnabled === true) {
          this.manipulationDiv.style.display = 'none';
          this.closeDiv.style.display = 'none';
          this.editModeDiv.style.display = 'block';
          this._createEditButton();
        }
      }

      /**
       * Creates the main toolbar. Removes functions bound to the select event. Binds all the buttons of the toolbar.
       *
       * @private
       */

    }, {
      key: 'showManipulatorToolbar',
      value: function showManipulatorToolbar() {
        // restore the state of any bound functions or events, remove control nodes, restore physics
        this._clean();

        // reset global variables
        this.manipulationDOM = {};

        // if the gui is enabled, draw all elements.
        if (this.guiEnabled === true) {
          // a _restore will hide these menus
          this.editMode = true;
          this.manipulationDiv.style.display = 'block';
          this.closeDiv.style.display = 'block';

          var selectedNodeCount = this.selectionHandler._getSelectedNodeCount();
          var selectedEdgeCount = this.selectionHandler._getSelectedEdgeCount();
          var selectedTotalCount = selectedNodeCount + selectedEdgeCount;
          var locale = this.options.locales[this.options.locale];
          var needSeperator = false;

          if (this.options.addNode !== false) {
            this._createAddNodeButton(locale);
            needSeperator = true;
          }
          if (this.options.addEdge !== false) {
            if (needSeperator === true) {
              this._createSeperator(1);
            } else {
              needSeperator = true;
            }
            this._createAddEdgeButton(locale);
          }

          if (selectedNodeCount === 1 && typeof this.options.editNode === 'function') {
            if (needSeperator === true) {
              this._createSeperator(2);
            } else {
              needSeperator = true;
            }
            this._createEditNodeButton(locale);
          } else if (selectedEdgeCount === 1 && selectedNodeCount === 0 && this.options.editEdge !== false) {
            if (needSeperator === true) {
              this._createSeperator(3);
            } else {
              needSeperator = true;
            }
            this._createEditEdgeButton(locale);
          }

          // remove buttons
          if (selectedTotalCount !== 0) {
            if (selectedNodeCount > 0 && this.options.deleteNode !== false) {
              if (needSeperator === true) {
                this._createSeperator(4);
              }
              this._createDeleteButton(locale);
            } else if (selectedNodeCount === 0 && this.options.deleteEdge !== false) {
              if (needSeperator === true) {
                this._createSeperator(4);
              }
              this._createDeleteButton(locale);
            }
          }

          // bind the close button
          this._bindHammerToDiv(this.closeDiv, this.toggleEditMode.bind(this));

          // refresh this bar based on what has been selected
          this._temporaryBindEvent('select', this.showManipulatorToolbar.bind(this));
        }

        // redraw to show any possible changes
        this.body.emitter.emit('_redraw');
      }

      /**
       * Create the toolbar for adding Nodes
       */

    }, {
      key: 'addNodeMode',
      value: function addNodeMode() {
        // when using the gui, enable edit mode if it wasnt already.
        if (this.editMode !== true) {
          this.enableEditMode();
        }

        // restore the state of any bound functions or events, remove control nodes, restore physics
        this._clean();

        this.inMode = 'addNode';
        if (this.guiEnabled === true) {
          var locale = this.options.locales[this.options.locale];
          this.manipulationDOM = {};
          this._createBackButton(locale);
          this._createSeperator();
          this._createDescription(locale['addDescription'] || this.options.locales['en']['addDescription']);

          // bind the close button
          this._bindHammerToDiv(this.closeDiv, this.toggleEditMode.bind(this));
        }

        this._temporaryBindEvent('click', this._performAddNode.bind(this));
      }

      /**
       * call the bound function to handle the editing of the node. The node has to be selected.
       */

    }, {
      key: 'editNode',
      value: function editNode() {
        var _this2 = this;

        // when using the gui, enable edit mode if it wasnt already.
        if (this.editMode !== true) {
          this.enableEditMode();
        }

        // restore the state of any bound functions or events, remove control nodes, restore physics
        this._clean();
        var node = this.selectionHandler._getSelectedNode();
        if (node !== undefined) {
          this.inMode = 'editNode';
          if (typeof this.options.editNode === 'function') {
            if (node.isCluster !== true) {
              var data = util.deepExtend({}, node.options, false);
              data.x = node.x;
              data.y = node.y;

              if (this.options.editNode.length === 2) {
                this.options.editNode(data, function (finalizedData) {
                  if (finalizedData !== null && finalizedData !== undefined && _this2.inMode === 'editNode') {
                    // if for whatever reason the mode has changes (due to dataset change) disregard the callback) {
                    _this2.body.data.nodes.getDataSet().update(finalizedData);
                  }
                  _this2.showManipulatorToolbar();
                });
              } else {
                throw new Error('The function for edit does not support two arguments (data, callback)');
              }
            } else {
              alert(this.options.locales[this.options.locale]['editClusterError'] || this.options.locales['en']['editClusterError']);
            }
          } else {
            throw new Error('No function has been configured to handle the editing of nodes.');
          }
        } else {
          this.showManipulatorToolbar();
        }
      }

      /**
       * create the toolbar to connect nodes
       */

    }, {
      key: 'addEdgeMode',
      value: function addEdgeMode() {
        // when using the gui, enable edit mode if it wasnt already.
        if (this.editMode !== true) {
          this.enableEditMode();
        }

        // restore the state of any bound functions or events, remove control nodes, restore physics
        this._clean();

        this.inMode = 'addEdge';
        if (this.guiEnabled === true) {
          var locale = this.options.locales[this.options.locale];
          this.manipulationDOM = {};
          this._createBackButton(locale);
          this._createSeperator();
          this._createDescription(locale['edgeDescription'] || this.options.locales['en']['edgeDescription']);

          // bind the close button
          this._bindHammerToDiv(this.closeDiv, this.toggleEditMode.bind(this));
        }

        // temporarily overload functions
        this._temporaryBindUI('onTouch', this._handleConnect.bind(this));
        this._temporaryBindUI('onDragEnd', this._finishConnect.bind(this));
        this._temporaryBindUI('onDrag', this._dragControlNode.bind(this));
        this._temporaryBindUI('onRelease', this._finishConnect.bind(this));

        this._temporaryBindUI('onDragStart', function () {});
        this._temporaryBindUI('onHold', function () {});
      }

      /**
       * create the toolbar to edit edges
       */

    }, {
      key: 'editEdgeMode',
      value: function editEdgeMode() {
        var _this3 = this;

        // when using the gui, enable edit mode if it wasn't already.
        if (this.editMode !== true) {
          this.enableEditMode();
        }

        // restore the state of any bound functions or events, remove control nodes, restore physics
        this._clean();

        this.inMode = 'editEdge';
        if (this.guiEnabled === true) {
          var locale = this.options.locales[this.options.locale];
          this.manipulationDOM = {};
          this._createBackButton(locale);
          this._createSeperator();
          this._createDescription(locale['editEdgeDescription'] || this.options.locales['en']['editEdgeDescription']);

          // bind the close button
          this._bindHammerToDiv(this.closeDiv, this.toggleEditMode.bind(this));
        }

        this.edgeBeingEditedId = this.selectionHandler.getSelectedEdges()[0];
        if (this.edgeBeingEditedId !== undefined) {
          (function () {
            var edge = _this3.body.edges[_this3.edgeBeingEditedId];

            // create control nodes
            var controlNodeFrom = _this3._getNewTargetNode(edge.from.x, edge.from.y);
            var controlNodeTo = _this3._getNewTargetNode(edge.to.x, edge.to.y);

            _this3.temporaryIds.nodes.push(controlNodeFrom.id);
            _this3.temporaryIds.nodes.push(controlNodeTo.id);

            _this3.body.nodes[controlNodeFrom.id] = controlNodeFrom;
            _this3.body.nodeIndices.push(controlNodeFrom.id);
            _this3.body.nodes[controlNodeTo.id] = controlNodeTo;
            _this3.body.nodeIndices.push(controlNodeTo.id);

            // temporarily overload UI functions, cleaned up automatically because of _temporaryBindUI
            _this3._temporaryBindUI('onTouch', _this3._controlNodeTouch.bind(_this3)); // used to get the position
            _this3._temporaryBindUI('onTap', function () {}); // disabled
            _this3._temporaryBindUI('onHold', function () {}); // disabled
            _this3._temporaryBindUI('onDragStart', _this3._controlNodeDragStart.bind(_this3)); // used to select control node
            _this3._temporaryBindUI('onDrag', _this3._controlNodeDrag.bind(_this3)); // used to drag control node
            _this3._temporaryBindUI('onDragEnd', _this3._controlNodeDragEnd.bind(_this3)); // used to connect or revert control nodes
            _this3._temporaryBindUI('onMouseMove', function () {}); // disabled

            // create function to position control nodes correctly on movement
            // automatically cleaned up because we use the temporary bind
            _this3._temporaryBindEvent('beforeDrawing', function (ctx) {
              var positions = edge.edgeType.findBorderPositions(ctx);
              if (controlNodeFrom.selected === false) {
                controlNodeFrom.x = positions.from.x;
                controlNodeFrom.y = positions.from.y;
              }
              if (controlNodeTo.selected === false) {
                controlNodeTo.x = positions.to.x;
                controlNodeTo.y = positions.to.y;
              }
            });

            _this3.body.emitter.emit('_redraw');
          })();
        } else {
          this.showManipulatorToolbar();
        }
      }

      /**
       * delete everything in the selection
       */

    }, {
      key: 'deleteSelected',
      value: function deleteSelected() {
        var _this4 = this;

        // when using the gui, enable edit mode if it wasnt already.
        if (this.editMode !== true) {
          this.enableEditMode();
        }

        // restore the state of any bound functions or events, remove control nodes, restore physics
        this._clean();

        this.inMode = 'delete';
        var selectedNodes = this.selectionHandler.getSelectedNodes();
        var selectedEdges = this.selectionHandler.getSelectedEdges();
        var deleteFunction = undefined;
        if (selectedNodes.length > 0) {
          for (var i = 0; i < selectedNodes.length; i++) {
            if (this.body.nodes[selectedNodes[i]].isCluster === true) {
              alert(this.options.locales[this.options.locale]['deleteClusterError'] || this.options.locales['en']['deleteClusterError']);
              return;
            }
          }

          if (typeof this.options.deleteNode === 'function') {
            deleteFunction = this.options.deleteNode;
          }
        } else if (selectedEdges.length > 0) {
          if (typeof this.options.deleteEdge === 'function') {
            deleteFunction = this.options.deleteEdge;
          }
        }

        if (typeof deleteFunction === 'function') {
          var data = { nodes: selectedNodes, edges: selectedEdges };
          if (deleteFunction.length === 2) {
            deleteFunction(data, function (finalizedData) {
              if (finalizedData !== null && finalizedData !== undefined && _this4.inMode === 'delete') {
                // if for whatever reason the mode has changes (due to dataset change) disregard the callback) {
                _this4.body.data.edges.getDataSet().remove(finalizedData.edges);
                _this4.body.data.nodes.getDataSet().remove(finalizedData.nodes);
                _this4.body.emitter.emit('startSimulation');
                _this4.showManipulatorToolbar();
              } else {
                _this4.body.emitter.emit('startSimulation');
                _this4.showManipulatorToolbar();
              }
            });
          } else {
            throw new Error('The function for delete does not support two arguments (data, callback)');
          }
        } else {
          this.body.data.edges.getDataSet().remove(selectedEdges);
          this.body.data.nodes.getDataSet().remove(selectedNodes);
          this.body.emitter.emit('startSimulation');
          this.showManipulatorToolbar();
        }
      }

      //********************************************** PRIVATE ***************************************//

      /**
       * draw or remove the DOM
       * @private
       */

    }, {
      key: '_setup',
      value: function _setup() {
        if (this.options.enabled === true) {
          // Enable the GUI
          this.guiEnabled = true;

          this._createWrappers();
          if (this.editMode === false) {
            this._createEditButton();
          } else {
            this.showManipulatorToolbar();
          }
        } else {
          this._removeManipulationDOM();

          // disable the gui
          this.guiEnabled = false;
        }
      }

      /**
       * create the div overlays that contain the DOM
       * @private
       */

    }, {
      key: '_createWrappers',
      value: function _createWrappers() {
        // load the manipulator HTML elements. All styling done in css.
        if (this.manipulationDiv === undefined) {
          this.manipulationDiv = document.createElement('div');
          this.manipulationDiv.className = 'vis-manipulation';
          if (this.editMode === true) {
            this.manipulationDiv.style.display = 'block';
          } else {
            this.manipulationDiv.style.display = 'none';
          }
          this.canvas.frame.appendChild(this.manipulationDiv);
        }

        // container for the edit button.
        if (this.editModeDiv === undefined) {
          this.editModeDiv = document.createElement('div');
          this.editModeDiv.className = 'vis-edit-mode';
          if (this.editMode === true) {
            this.editModeDiv.style.display = 'none';
          } else {
            this.editModeDiv.style.display = 'block';
          }
          this.canvas.frame.appendChild(this.editModeDiv);
        }

        // container for the close div button
        if (this.closeDiv === undefined) {
          this.closeDiv = document.createElement('div');
          this.closeDiv.className = 'vis-close';
          this.closeDiv.style.display = this.manipulationDiv.style.display;
          this.canvas.frame.appendChild(this.closeDiv);
        }
      }

      /**
       * generate a new target node. Used for creating new edges and editing edges
       * @param x
       * @param y
       * @returns {*}
       * @private
       */

    }, {
      key: '_getNewTargetNode',
      value: function _getNewTargetNode(x, y) {
        var controlNodeStyle = util.deepExtend({}, this.options.controlNodeStyle);

        controlNodeStyle.id = 'targetNode' + util.randomUUID();
        controlNodeStyle.hidden = false;
        controlNodeStyle.physics = false;
        controlNodeStyle.x = x;
        controlNodeStyle.y = y;

        // we have to define the bounding box in order for the nodes to be drawn immediately
        var node = this.body.functions.createNode(controlNodeStyle);
        node.shape.boundingBox = { left: x, right: x, top: y, bottom: y };

        return node;
      }

      /**
       * Create the edit button
       */

    }, {
      key: '_createEditButton',
      value: function _createEditButton() {
        // restore everything to it's original state (if applicable)
        this._clean();

        // reset the manipulationDOM
        this.manipulationDOM = {};

        // empty the editModeDiv
        util.recursiveDOMDelete(this.editModeDiv);

        // create the contents for the editMode button
        var locale = this.options.locales[this.options.locale];
        var button = this._createButton('editMode', 'vis-button vis-edit vis-edit-mode', locale['edit'] || this.options.locales['en']['edit']);
        this.editModeDiv.appendChild(button);

        // bind a hammer listener to the button, calling the function toggleEditMode.
        this._bindHammerToDiv(button, this.toggleEditMode.bind(this));
      }

      /**
       * this function cleans up after everything this module does. Temporary elements, functions and events are removed, physics restored, hammers removed.
       * @private
       */

    }, {
      key: '_clean',
      value: function _clean() {
        // not in mode
        this.inMode = false;

        // _clean the divs
        if (this.guiEnabled === true) {
          util.recursiveDOMDelete(this.editModeDiv);
          util.recursiveDOMDelete(this.manipulationDiv);

          // removes all the bindings and overloads
          this._cleanManipulatorHammers();
        }

        // remove temporary nodes and edges
        this._cleanupTemporaryNodesAndEdges();

        // restore overloaded UI functions
        this._unbindTemporaryUIs();

        // remove the temporaryEventFunctions
        this._unbindTemporaryEvents();

        // restore the physics if required
        this.body.emitter.emit('restorePhysics');
      }

      /**
       * Each dom element has it's own hammer. They are stored in this.manipulationHammers. This cleans them up.
       * @private
       */

    }, {
      key: '_cleanManipulatorHammers',
      value: function _cleanManipulatorHammers() {
        // _clean hammer bindings
        if (this.manipulationHammers.length != 0) {
          for (var i = 0; i < this.manipulationHammers.length; i++) {
            this.manipulationHammers[i].destroy();
          }
          this.manipulationHammers = [];
        }
      }

      /**
       * Remove all DOM elements created by this module.
       * @private
       */

    }, {
      key: '_removeManipulationDOM',
      value: function _removeManipulationDOM() {
        // removes all the bindings and overloads
        this._clean();

        // empty the manipulation divs
        util.recursiveDOMDelete(this.manipulationDiv);
        util.recursiveDOMDelete(this.editModeDiv);
        util.recursiveDOMDelete(this.closeDiv);

        // remove the manipulation divs
        if (this.manipulationDiv) {
          this.canvas.frame.removeChild(this.manipulationDiv);
        }
        if (this.editModeDiv) {
          this.canvas.frame.removeChild(this.editModeDiv);
        }
        if (this.closeDiv) {
          this.canvas.frame.removeChild(this.closeDiv);
        }

        // set the references to undefined
        this.manipulationDiv = undefined;
        this.editModeDiv = undefined;
        this.closeDiv = undefined;
      }

      /**
       * create a seperator line. the index is to differentiate in the manipulation dom
       * @param index
       * @private
       */

    }, {
      key: '_createSeperator',
      value: function _createSeperator() {
        var index = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];

        this.manipulationDOM['seperatorLineDiv' + index] = document.createElement('div');
        this.manipulationDOM['seperatorLineDiv' + index].className = 'vis-separator-line';
        this.manipulationDiv.appendChild(this.manipulationDOM['seperatorLineDiv' + index]);
      }

      // ----------------------    DOM functions for buttons    --------------------------//

    }, {
      key: '_createAddNodeButton',
      value: function _createAddNodeButton(locale) {
        var button = this._createButton('addNode', 'vis-button vis-add', locale['addNode'] || this.options.locales['en']['addNode']);
        this.manipulationDiv.appendChild(button);
        this._bindHammerToDiv(button, this.addNodeMode.bind(this));
      }
    }, {
      key: '_createAddEdgeButton',
      value: function _createAddEdgeButton(locale) {
        var button = this._createButton('addEdge', 'vis-button vis-connect', locale['addEdge'] || this.options.locales['en']['addEdge']);
        this.manipulationDiv.appendChild(button);
        this._bindHammerToDiv(button, this.addEdgeMode.bind(this));
      }
    }, {
      key: '_createEditNodeButton',
      value: function _createEditNodeButton(locale) {
        var button = this._createButton('editNode', 'vis-button vis-edit', locale['editNode'] || this.options.locales['en']['editNode']);
        this.manipulationDiv.appendChild(button);
        this._bindHammerToDiv(button, this.editNode.bind(this));
      }
    }, {
      key: '_createEditEdgeButton',
      value: function _createEditEdgeButton(locale) {
        var button = this._createButton('editEdge', 'vis-button vis-edit', locale['editEdge'] || this.options.locales['en']['editEdge']);
        this.manipulationDiv.appendChild(button);
        this._bindHammerToDiv(button, this.editEdgeMode.bind(this));
      }
    }, {
      key: '_createDeleteButton',
      value: function _createDeleteButton(locale) {
        if (this.options.rtl) {
          var deleteBtnClass = 'vis-button vis-delete-rtl';
        } else {
          var deleteBtnClass = 'vis-button vis-delete';
        }
        var button = this._createButton('delete', deleteBtnClass, locale['del'] || this.options.locales['en']['del']);
        this.manipulationDiv.appendChild(button);
        this._bindHammerToDiv(button, this.deleteSelected.bind(this));
      }
    }, {
      key: '_createBackButton',
      value: function _createBackButton(locale) {
        var button = this._createButton('back', 'vis-button vis-back', locale['back'] || this.options.locales['en']['back']);
        this.manipulationDiv.appendChild(button);
        this._bindHammerToDiv(button, this.showManipulatorToolbar.bind(this));
      }
    }, {
      key: '_createButton',
      value: function _createButton(id, className, label) {
        var labelClassName = arguments.length <= 3 || arguments[3] === undefined ? 'vis-label' : arguments[3];


        this.manipulationDOM[id + 'Div'] = document.createElement('div');
        this.manipulationDOM[id + 'Div'].className = className;
        this.manipulationDOM[id + 'Label'] = document.createElement('div');
        this.manipulationDOM[id + 'Label'].className = labelClassName;
        this.manipulationDOM[id + 'Label'].innerHTML = label;
        this.manipulationDOM[id + 'Div'].appendChild(this.manipulationDOM[id + 'Label']);
        return this.manipulationDOM[id + 'Div'];
      }
    }, {
      key: '_createDescription',
      value: function _createDescription(label) {
        this.manipulationDiv.appendChild(this._createButton('description', 'vis-button vis-none', label));
      }

      // -------------------------- End of DOM functions for buttons ------------------------------//

      /**
       * this binds an event until cleanup by the clean functions.
       * @param event
       * @param newFunction
       * @private
       */

    }, {
      key: '_temporaryBindEvent',
      value: function _temporaryBindEvent(event, newFunction) {
        this.temporaryEventFunctions.push({ event: event, boundFunction: newFunction });
        this.body.emitter.on(event, newFunction);
      }

      /**
       * this overrides an UI function until cleanup by the clean function
       * @param UIfunctionName
       * @param newFunction
       * @private
       */

    }, {
      key: '_temporaryBindUI',
      value: function _temporaryBindUI(UIfunctionName, newFunction) {
        if (this.body.eventListeners[UIfunctionName] !== undefined) {
          this.temporaryUIFunctions[UIfunctionName] = this.body.eventListeners[UIfunctionName];
          this.body.eventListeners[UIfunctionName] = newFunction;
        } else {
          throw new Error('This UI function does not exist. Typo? You tried: ' + UIfunctionName + ' possible are: ' + JSON.stringify(Object.keys(this.body.eventListeners)));
        }
      }

      /**
       * Restore the overridden UI functions to their original state.
       *
       * @private
       */

    }, {
      key: '_unbindTemporaryUIs',
      value: function _unbindTemporaryUIs() {
        for (var functionName in this.temporaryUIFunctions) {
          if (this.temporaryUIFunctions.hasOwnProperty(functionName)) {
            this.body.eventListeners[functionName] = this.temporaryUIFunctions[functionName];
            delete this.temporaryUIFunctions[functionName];
          }
        }
        this.temporaryUIFunctions = {};
      }

      /**
       * Unbind the events created by _temporaryBindEvent
       * @private
       */

    }, {
      key: '_unbindTemporaryEvents',
      value: function _unbindTemporaryEvents() {
        for (var i = 0; i < this.temporaryEventFunctions.length; i++) {
          var eventName = this.temporaryEventFunctions[i].event;
          var boundFunction = this.temporaryEventFunctions[i].boundFunction;
          this.body.emitter.off(eventName, boundFunction);
        }
        this.temporaryEventFunctions = [];
      }

      /**
       * Bind an hammer instance to a DOM element.
       * @param domElement
       * @param funct
       */

    }, {
      key: '_bindHammerToDiv',
      value: function _bindHammerToDiv(domElement, boundFunction) {
        var hammer = new Hammer(domElement, {});
        hammerUtil.onTouch(hammer, boundFunction);
        this.manipulationHammers.push(hammer);
      }

      /**
       * Neatly clean up temporary edges and nodes
       * @private
       */

    }, {
      key: '_cleanupTemporaryNodesAndEdges',
      value: function _cleanupTemporaryNodesAndEdges() {
        // _clean temporary edges
        for (var i = 0; i < this.temporaryIds.edges.length; i++) {
          this.body.edges[this.temporaryIds.edges[i]].disconnect();
          delete this.body.edges[this.temporaryIds.edges[i]];
          var indexTempEdge = this.body.edgeIndices.indexOf(this.temporaryIds.edges[i]);
          if (indexTempEdge !== -1) {
            this.body.edgeIndices.splice(indexTempEdge, 1);
          }
        }

        // _clean temporary nodes
        for (var _i = 0; _i < this.temporaryIds.nodes.length; _i++) {
          delete this.body.nodes[this.temporaryIds.nodes[_i]];
          var indexTempNode = this.body.nodeIndices.indexOf(this.temporaryIds.nodes[_i]);
          if (indexTempNode !== -1) {
            this.body.nodeIndices.splice(indexTempNode, 1);
          }
        }

        this.temporaryIds = { nodes: [], edges: [] };
      }

      // ------------------------------------------ EDIT EDGE FUNCTIONS -----------------------------------------//

      /**
       * the touch is used to get the position of the initial click
       * @param event
       * @private
       */

    }, {
      key: '_controlNodeTouch',
      value: function _controlNodeTouch(event) {
        this.selectionHandler.unselectAll();
        this.lastTouch = this.body.functions.getPointer(event.center);
        this.lastTouch.translation = util.extend({}, this.body.view.translation); // copy the object
      }

      /**
       * the drag start is used to mark one of the control nodes as selected.
       * @param event
       * @private
       */

    }, {
      key: '_controlNodeDragStart',
      value: function _controlNodeDragStart(event) {
        var pointer = this.lastTouch;
        var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);
        var from = this.body.nodes[this.temporaryIds.nodes[0]];
        var to = this.body.nodes[this.temporaryIds.nodes[1]];
        var edge = this.body.edges[this.edgeBeingEditedId];
        this.selectedControlNode = undefined;

        var fromSelect = from.isOverlappingWith(pointerObj);
        var toSelect = to.isOverlappingWith(pointerObj);

        if (fromSelect === true) {
          this.selectedControlNode = from;
          edge.edgeType.from = from;
        } else if (toSelect === true) {
          this.selectedControlNode = to;
          edge.edgeType.to = to;
        }

        // we use the selection to find the node that is being dragged. We explicitly select it here.
        if (this.selectedControlNode !== undefined) {
          this.selectionHandler.selectObject(this.selectedControlNode);
        }

        this.body.emitter.emit('_redraw');
      }

      /**
       * dragging the control nodes or the canvas
       * @param event
       * @private
       */

    }, {
      key: '_controlNodeDrag',
      value: function _controlNodeDrag(event) {
        this.body.emitter.emit('disablePhysics');
        var pointer = this.body.functions.getPointer(event.center);
        var pos = this.canvas.DOMtoCanvas(pointer);
        if (this.selectedControlNode !== undefined) {
          this.selectedControlNode.x = pos.x;
          this.selectedControlNode.y = pos.y;
        } else {
          // if the drag was not started properly because the click started outside the network div, start it now.
          var diffX = pointer.x - this.lastTouch.x;
          var diffY = pointer.y - this.lastTouch.y;
          this.body.view.translation = { x: this.lastTouch.translation.x + diffX, y: this.lastTouch.translation.y + diffY };
        }
        this.body.emitter.emit('_redraw');
      }

      /**
       * connecting or restoring the control nodes.
       * @param event
       * @private
       */

    }, {
      key: '_controlNodeDragEnd',
      value: function _controlNodeDragEnd(event) {
        var pointer = this.body.functions.getPointer(event.center);
        var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);
        var edge = this.body.edges[this.edgeBeingEditedId];
        // if the node that was dragged is not a control node, return
        if (this.selectedControlNode === undefined) {
          return;
        }

        // we use the selection to find the node that is being dragged. We explicitly DEselect the control node here.
        this.selectionHandler.unselectAll();
        var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);
        var node = undefined;
        for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {
          if (overlappingNodeIds[i] !== this.selectedControlNode.id) {
            node = this.body.nodes[overlappingNodeIds[i]];
            break;
          }
        }
        // perform the connection
        if (node !== undefined && this.selectedControlNode !== undefined) {
          if (node.isCluster === true) {
            alert(this.options.locales[this.options.locale]['createEdgeError'] || this.options.locales['en']['createEdgeError']);
          } else {
            var from = this.body.nodes[this.temporaryIds.nodes[0]];
            if (this.selectedControlNode.id === from.id) {
              this._performEditEdge(node.id, edge.to.id);
            } else {
              this._performEditEdge(edge.from.id, node.id);
            }
          }
        } else {
          edge.updateEdgeType();
          this.body.emitter.emit('restorePhysics');
        }
        this.body.emitter.emit('_redraw');
      }

      // ------------------------------------ END OF EDIT EDGE FUNCTIONS -----------------------------------------//

      // ------------------------------------------- ADD EDGE FUNCTIONS -----------------------------------------//
      /**
       * the function bound to the selection event. It checks if you want to connect a cluster and changes the description
       * to walk the user through the process.
       *
       * @private
       */

    }, {
      key: '_handleConnect',
      value: function _handleConnect(event) {
        // check to avoid double fireing of this function.
        if (new Date().valueOf() - this.touchTime > 100) {
          this.lastTouch = this.body.functions.getPointer(event.center);
          this.lastTouch.translation = util.extend({}, this.body.view.translation); // copy the object

          var pointer = this.lastTouch;
          var node = this.selectionHandler.getNodeAt(pointer);

          if (node !== undefined) {
            if (node.isCluster === true) {
              alert(this.options.locales[this.options.locale]['createEdgeError'] || this.options.locales['en']['createEdgeError']);
            } else {
              // create a node the temporary line can look at
              var targetNode = this._getNewTargetNode(node.x, node.y);
              this.body.nodes[targetNode.id] = targetNode;
              this.body.nodeIndices.push(targetNode.id);

              // create a temporary edge
              var connectionEdge = this.body.functions.createEdge({
                id: 'connectionEdge' + util.randomUUID(),
                from: node.id,
                to: targetNode.id,
                physics: false,
                smooth: {
                  enabled: true,
                  type: 'continuous',
                  roundness: 0.5
                }
              });
              this.body.edges[connectionEdge.id] = connectionEdge;
              this.body.edgeIndices.push(connectionEdge.id);

              this.temporaryIds.nodes.push(targetNode.id);
              this.temporaryIds.edges.push(connectionEdge.id);
            }
          }
          this.touchTime = new Date().valueOf();
        }
      }
    }, {
      key: '_dragControlNode',
      value: function _dragControlNode(event) {
        var pointer = this.body.functions.getPointer(event.center);
        if (this.temporaryIds.nodes[0] !== undefined) {
          var targetNode = this.body.nodes[this.temporaryIds.nodes[0]]; // there is only one temp node in the add edge mode.
          targetNode.x = this.canvas._XconvertDOMtoCanvas(pointer.x);
          targetNode.y = this.canvas._YconvertDOMtoCanvas(pointer.y);
          this.body.emitter.emit('_redraw');
        } else {
          var diffX = pointer.x - this.lastTouch.x;
          var diffY = pointer.y - this.lastTouch.y;
          this.body.view.translation = { x: this.lastTouch.translation.x + diffX, y: this.lastTouch.translation.y + diffY };
        }
      }

      /**
       * Connect the new edge to the target if one exists, otherwise remove temp line
       * @param event
       * @private
       */

    }, {
      key: '_finishConnect',
      value: function _finishConnect(event) {
        var pointer = this.body.functions.getPointer(event.center);
        var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);

        // remember the edge id
        var connectFromId = undefined;
        if (this.temporaryIds.edges[0] !== undefined) {
          connectFromId = this.body.edges[this.temporaryIds.edges[0]].fromId;
        }

        // get the overlapping node but NOT the temporary node;
        var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);
        var node = undefined;
        for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {
          // if the node id is NOT a temporary node, accept the node.
          if (this.temporaryIds.nodes.indexOf(overlappingNodeIds[i]) === -1) {
            node = this.body.nodes[overlappingNodeIds[i]];
            break;
          }
        }

        // clean temporary nodes and edges.
        this._cleanupTemporaryNodesAndEdges();

        // perform the connection
        if (node !== undefined) {
          if (node.isCluster === true) {
            alert(this.options.locales[this.options.locale]['createEdgeError'] || this.options.locales['en']['createEdgeError']);
          } else {
            if (this.body.nodes[connectFromId] !== undefined && this.body.nodes[node.id] !== undefined) {
              this._performAddEdge(connectFromId, node.id);
            }
          }
        }
        this.body.emitter.emit('_redraw');
      }

      // --------------------------------------- END OF ADD EDGE FUNCTIONS -------------------------------------//

      // ------------------------------ Performing all the actual data manipulation ------------------------//

      /**
       * Adds a node on the specified location
       */

    }, {
      key: '_performAddNode',
      value: function _performAddNode(clickData) {
        var _this5 = this;

        var defaultData = {
          id: util.randomUUID(),
          x: clickData.pointer.canvas.x,
          y: clickData.pointer.canvas.y,
          label: 'new'
        };

        if (typeof this.options.addNode === 'function') {
          if (this.options.addNode.length === 2) {
            this.options.addNode(defaultData, function (finalizedData) {
              if (finalizedData !== null && finalizedData !== undefined && _this5.inMode === 'addNode') {
                // if for whatever reason the mode has changes (due to dataset change) disregard the callback
                _this5.body.data.nodes.getDataSet().add(finalizedData);
                _this5.showManipulatorToolbar();
              }
            });
          } else {
            throw new Error('The function for add does not support two arguments (data,callback)');
            this.showManipulatorToolbar();
          }
        } else {
          this.body.data.nodes.getDataSet().add(defaultData);
          this.showManipulatorToolbar();
        }
      }

      /**
       * connect two nodes with a new edge.
       *
       * @private
       */

    }, {
      key: '_performAddEdge',
      value: function _performAddEdge(sourceNodeId, targetNodeId) {
        var _this6 = this;

        var defaultData = { from: sourceNodeId, to: targetNodeId };
        if (typeof this.options.addEdge === 'function') {
          if (this.options.addEdge.length === 2) {
            this.options.addEdge(defaultData, function (finalizedData) {
              if (finalizedData !== null && finalizedData !== undefined && _this6.inMode === 'addEdge') {
                // if for whatever reason the mode has changes (due to dataset change) disregard the callback
                _this6.body.data.edges.getDataSet().add(finalizedData);
                _this6.selectionHandler.unselectAll();
                _this6.showManipulatorToolbar();
              }
            });
          } else {
            throw new Error('The function for connect does not support two arguments (data,callback)');
          }
        } else {
          this.body.data.edges.getDataSet().add(defaultData);
          this.selectionHandler.unselectAll();
          this.showManipulatorToolbar();
        }
      }

      /**
       * connect two nodes with a new edge.
       *
       * @private
       */

    }, {
      key: '_performEditEdge',
      value: function _performEditEdge(sourceNodeId, targetNodeId) {
        var _this7 = this;

        var defaultData = { id: this.edgeBeingEditedId, from: sourceNodeId, to: targetNodeId };
        if (typeof this.options.editEdge === 'function') {
          if (this.options.editEdge.length === 2) {
            this.options.editEdge(defaultData, function (finalizedData) {
              if (finalizedData === null || finalizedData === undefined || _this7.inMode !== 'editEdge') {
                // if for whatever reason the mode has changes (due to dataset change) disregard the callback) {
                _this7.body.edges[defaultData.id].updateEdgeType();
                _this7.body.emitter.emit('_redraw');
              } else {
                _this7.body.data.edges.getDataSet().update(finalizedData);
                _this7.selectionHandler.unselectAll();
                _this7.showManipulatorToolbar();
              }
            });
          } else {
            throw new Error('The function for edit does not support two arguments (data, callback)');
          }
        } else {
          this.body.data.edges.getDataSet().update(defaultData);
          this.selectionHandler.unselectAll();
          this.showManipulatorToolbar();
        }
      }
    }]);

    return ManipulationSystem;
  }();

  exports.default = ManipulationSystem;

/***/ },
/* 114 */
/***/ function(module, exports) {

  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  /**
   * This object contains all possible options. It will check if the types are correct, if required if the option is one
   * of the allowed values.
   *
   * __any__ means that the name of the property does not matter.
   * __type__ is a required field for all objects and contains the allowed types of all objects
   */
  var string = 'string';
  var boolean = 'boolean';
  var number = 'number';
  var array = 'array';
  var object = 'object'; // should only be in a __type__ property
  var dom = 'dom';
  var any = 'any';

  var allOptions = {
    configure: {
      enabled: { boolean: boolean },
      filter: { boolean: boolean, string: string, array: array, 'function': 'function' },
      container: { dom: dom },
      showButton: { boolean: boolean },
      __type__: { object: object, boolean: boolean, string: string, array: array, 'function': 'function' }
    },
    edges: {
      arrows: {
        to: { enabled: { boolean: boolean }, scaleFactor: { number: number }, __type__: { object: object, boolean: boolean } },
        middle: { enabled: { boolean: boolean }, scaleFactor: { number: number }, __type__: { object: object, boolean: boolean } },
        from: { enabled: { boolean: boolean }, scaleFactor: { number: number }, __type__: { object: object, boolean: boolean } },
        __type__: { string: ['from', 'to', 'middle'], object: object }
      },
      arrowStrikethrough: { boolean: boolean },
      color: {
        color: { string: string },
        highlight: { string: string },
        hover: { string: string },
        inherit: { string: ['from', 'to', 'both'], boolean: boolean },
        opacity: { number: number },
        __type__: { object: object, string: string }
      },
      dashes: { boolean: boolean, array: array },
      font: {
        color: { string: string },
        size: { number: number }, // px
        face: { string: string },
        background: { string: string },
        strokeWidth: { number: number }, // px
        strokeColor: { string: string },
        align: { string: ['horizontal', 'top', 'middle', 'bottom'] },
        __type__: { object: object, string: string }
      },
      hidden: { boolean: boolean },
      hoverWidth: { 'function': 'function', number: number },
      label: { string: string, 'undefined': 'undefined' },
      labelHighlightBold: { boolean: boolean },
      length: { number: number, 'undefined': 'undefined' },
      physics: { boolean: boolean },
      scaling: {
        min: { number: number },
        max: { number: number },
        label: {
          enabled: { boolean: boolean },
          min: { number: number },
          max: { number: number },
          maxVisible: { number: number },
          drawThreshold: { number: number },
          __type__: { object: object, boolean: boolean }
        },
        customScalingFunction: { 'function': 'function' },
        __type__: { object: object }
      },
      selectionWidth: { 'function': 'function', number: number },
      selfReferenceSize: { number: number },
      shadow: {
        enabled: { boolean: boolean },
        color: { string: string },
        size: { number: number },
        x: { number: number },
        y: { number: number },
        __type__: { object: object, boolean: boolean }
      },
      smooth: {
        enabled: { boolean: boolean },
        type: { string: ['dynamic', 'continuous', 'discrete', 'diagonalCross', 'straightCross', 'horizontal', 'vertical', 'curvedCW', 'curvedCCW', 'cubicBezier'] },
        roundness: { number: number },
        forceDirection: { string: ['horizontal', 'vertical', 'none'], boolean: boolean },
        __type__: { object: object, boolean: boolean }
      },
      title: { string: string, 'undefined': 'undefined' },
      width: { number: number },
      value: { number: number, 'undefined': 'undefined' },
      __type__: { object: object }
    },
    groups: {
      useDefaultGroups: { boolean: boolean },
      __any__: 'get from nodes, will be overwritten below',
      __type__: { object: object }
    },
    interaction: {
      dragNodes: { boolean: boolean },
      dragView: { boolean: boolean },
      hideEdgesOnDrag: { boolean: boolean },
      hideNodesOnDrag: { boolean: boolean },
      hover: { boolean: boolean },
      keyboard: {
        enabled: { boolean: boolean },
        speed: { x: { number: number }, y: { number: number }, zoom: { number: number }, __type__: { object: object } },
        bindToWindow: { boolean: boolean },
        __type__: { object: object, boolean: boolean }
      },
      multiselect: { boolean: boolean },
      navigationButtons: { boolean: boolean },
      selectable: { boolean: boolean },
      selectConnectedEdges: { boolean: boolean },
      hoverConnectedEdges: { boolean: boolean },
      tooltipDelay: { number: number },
      zoomView: { boolean: boolean },
      __type__: { object: object }
    },
    layout: {
      randomSeed: { 'undefined': 'undefined', number: number },
      improvedLayout: { boolean: boolean },
      hierarchical: {
        enabled: { boolean: boolean },
        levelSeparation: { number: number },
        nodeSpacing: { number: number },
        treeSpacing: { number: number },
        blockShifting: { boolean: boolean },
        edgeMinimization: { boolean: boolean },
        parentCentralization: { boolean: boolean },
        direction: { string: ['UD', 'DU', 'LR', 'RL'] }, // UD, DU, LR, RL
        sortMethod: { string: ['hubsize', 'directed'] }, // hubsize, directed
        __type__: { object: object, boolean: boolean }
      },
      __type__: { object: object }
    },
    manipulation: {
      enabled: { boolean: boolean },
      initiallyActive: { boolean: boolean },
      addNode: { boolean: boolean, 'function': 'function' },
      addEdge: { boolean: boolean, 'function': 'function' },
      editNode: { 'function': 'function' },
      editEdge: { boolean: boolean, 'function': 'function' },
      deleteNode: { boolean: boolean, 'function': 'function' },
      deleteEdge: { boolean: boolean, 'function': 'function' },
      controlNodeStyle: 'get from nodes, will be overwritten below',
      __type__: { object: object, boolean: boolean }
    },
    nodes: {
      borderWidth: { number: number },
      borderWidthSelected: { number: number, 'undefined': 'undefined' },
      brokenImage: { string: string, 'undefined': 'undefined' },
      color: {
        border: { string: string },
        background: { string: string },
        highlight: {
          border: { string: string },
          background: { string: string },
          __type__: { object: object, string: string }
        },
        hover: {
          border: { string: string },
          background: { string: string },
          __type__: { object: object, string: string }
        },
        __type__: { object: object, string: string }
      },
      fixed: {
        x: { boolean: boolean },
        y: { boolean: boolean },
        __type__: { object: object, boolean: boolean }
      },
      font: {
        align: { string: string },
        color: { string: string },
        size: { number: number }, // px
        face: { string: string },
        background: { string: string },
        strokeWidth: { number: number }, // px
        strokeColor: { string: string },
        __type__: { object: object, string: string }
      },
      group: { string: string, number: number, 'undefined': 'undefined' },
      hidden: { boolean: boolean },
      icon: {
        face: { string: string },
        code: { string: string }, //'\uf007',
        size: { number: number }, //50,
        color: { string: string },
        __type__: { object: object }
      },
      id: { string: string, number: number },
      image: { string: string, 'undefined': 'undefined' }, // --> URL
      label: { string: string, 'undefined': 'undefined' },
      labelHighlightBold: { boolean: boolean },
      level: { number: number, 'undefined': 'undefined' },
      mass: { number: number },
      physics: { boolean: boolean },
      scaling: {
        min: { number: number },
        max: { number: number },
        label: {
          enabled: { boolean: boolean },
          min: { number: number },
          max: { number: number },
          maxVisible: { number: number },
          drawThreshold: { number: number },
          __type__: { object: object, boolean: boolean }
        },
        customScalingFunction: { 'function': 'function' },
        __type__: { object: object }
      },
      shadow: {
        enabled: { boolean: boolean },
        color: { string: string },
        size: { number: number },
        x: { number: number },
        y: { number: number },
        __type__: { object: object, boolean: boolean }
      },
      shape: { string: ['ellipse', 'circle', 'database', 'box', 'text', 'image', 'circularImage', 'diamond', 'dot', 'star', 'triangle', 'triangleDown', 'square', 'icon'] },
      shapeProperties: {
        borderDashes: { boolean: boolean, array: array },
        borderRadius: { number: number },
        interpolation: { boolean: boolean },
        useImageSize: { boolean: boolean },
        useBorderWithImage: { boolean: boolean },
        __type__: { object: object }
      },
      size: { number: number },
      title: { string: string, 'undefined': 'undefined' },
      value: { number: number, 'undefined': 'undefined' },
      x: { number: number },
      y: { number: number },
      __type__: { object: object }
    },
    physics: {
      enabled: { boolean: boolean },
      barnesHut: {
        gravitationalConstant: { number: number },
        centralGravity: { number: number },
        springLength: { number: number },
        springConstant: { number: number },
        damping: { number: number },
        avoidOverlap: { number: number },
        __type__: { object: object }
      },
      forceAtlas2Based: {
        gravitationalConstant: { number: number },
        centralGravity: { number: number },
        springLength: { number: number },
        springConstant: { number: number },
        damping: { number: number },
        avoidOverlap: { number: number },
        __type__: { object: object }
      },
      repulsion: {
        centralGravity: { number: number },
        springLength: { number: number },
        springConstant: { number: number },
        nodeDistance: { number: number },
        damping: { number: number },
        __type__: { object: object }
      },
      hierarchicalRepulsion: {
        centralGravity: { number: number },
        springLength: { number: number },
        springConstant: { number: number },
        nodeDistance: { number: number },
        damping: { number: number },
        __type__: { object: object }
      },
      maxVelocity: { number: number },
      minVelocity: { number: number }, // px/s
      solver: { string: ['barnesHut', 'repulsion', 'hierarchicalRepulsion', 'forceAtlas2Based'] },
      stabilization: {
        enabled: { boolean: boolean },
        iterations: { number: number }, // maximum number of iteration to stabilize
        updateInterval: { number: number },
        onlyDynamicEdges: { boolean: boolean },
        fit: { boolean: boolean },
        __type__: { object: object, boolean: boolean }
      },
      timestep: { number: number },
      adaptiveTimestep: { boolean: boolean },
      __type__: { object: object, boolean: boolean }
    },

    //globals :
    autoResize: { boolean: boolean },
    clickToUse: { boolean: boolean },
    locale: { string: string },
    locales: {
      __any__: { any: any },
      __type__: { object: object }
    },
    height: { string: string },
    width: { string: string },
    __type__: { object: object }
  };

  allOptions.groups.__any__ = allOptions.nodes;
  allOptions.manipulation.controlNodeStyle = allOptions.nodes;

  var configureOptions = {
    nodes: {
      borderWidth: [1, 0, 10, 1],
      borderWidthSelected: [2, 0, 10, 1],
      color: {
        border: ['color', '#2B7CE9'],
        background: ['color', '#97C2FC'],
        highlight: {
          border: ['color', '#2B7CE9'],
          background: ['color', '#D2E5FF']
        },
        hover: {
          border: ['color', '#2B7CE9'],
          background: ['color', '#D2E5FF']
        }
      },
      fixed: {
        x: false,
        y: false
      },
      font: {
        color: ['color', '#343434'],
        size: [14, 0, 100, 1], // px
        face: ['arial', 'verdana', 'tahoma'],
        background: ['color', 'none'],
        strokeWidth: [0, 0, 50, 1], // px
        strokeColor: ['color', '#ffffff']
      },
      //group: 'string',
      hidden: false,
      labelHighlightBold: true,
      //icon: {
      //  face: 'string',  //'FontAwesome',
      //  code: 'string',  //'\uf007',
      //  size: [50, 0, 200, 1],  //50,
      //  color: ['color','#2B7CE9']   //'#aa00ff'
      //},
      //image: 'string', // --> URL
      physics: true,
      scaling: {
        min: [10, 0, 200, 1],
        max: [30, 0, 200, 1],
        label: {
          enabled: false,
          min: [14, 0, 200, 1],
          max: [30, 0, 200, 1],
          maxVisible: [30, 0, 200, 1],
          drawThreshold: [5, 0, 20, 1]
        }
      },
      shadow: {
        enabled: false,
        color: 'rgba(0,0,0,0.5)',
        size: [10, 0, 20, 1],
        x: [5, -30, 30, 1],
        y: [5, -30, 30, 1]
      },
      shape: ['ellipse', 'box', 'circle', 'database', 'diamond', 'dot', 'square', 'star', 'text', 'triangle', 'triangleDown'],
      shapeProperties: {
        borderDashes: false,
        borderRadius: [6, 0, 20, 1],
        interpolation: true,
        useImageSize: false
      },
      size: [25, 0, 200, 1]
    },
    edges: {
      arrows: {
        to: { enabled: false, scaleFactor: [1, 0, 3, 0.05] }, // boolean / {arrowScaleFactor:1} / {enabled: false, arrowScaleFactor:1}
        middle: { enabled: false, scaleFactor: [1, 0, 3, 0.05] },
        from: { enabled: false, scaleFactor: [1, 0, 3, 0.05] }
      },
      arrowStrikethrough: true,
      color: {
        color: ['color', '#848484'],
        highlight: ['color', '#848484'],
        hover: ['color', '#848484'],
        inherit: ['from', 'to', 'both', true, false],
        opacity: [1, 0, 1, 0.05]
      },
      dashes: false,
      font: {
        color: ['color', '#343434'],
        size: [14, 0, 100, 1], // px
        face: ['arial', 'verdana', 'tahoma'],
        background: ['color', 'none'],
        strokeWidth: [2, 0, 50, 1], // px
        strokeColor: ['color', '#ffffff'],
        align: ['horizontal', 'top', 'middle', 'bottom']
      },
      hidden: false,
      hoverWidth: [1.5, 0, 5, 0.1],
      labelHighlightBold: true,
      physics: true,
      scaling: {
        min: [1, 0, 100, 1],
        max: [15, 0, 100, 1],
        label: {
          enabled: true,
          min: [14, 0, 200, 1],
          max: [30, 0, 200, 1],
          maxVisible: [30, 0, 200, 1],
          drawThreshold: [5, 0, 20, 1]
        }
      },
      selectionWidth: [1.5, 0, 5, 0.1],
      selfReferenceSize: [20, 0, 200, 1],
      shadow: {
        enabled: false,
        color: 'rgba(0,0,0,0.5)',
        size: [10, 0, 20, 1],
        x: [5, -30, 30, 1],
        y: [5, -30, 30, 1]
      },
      smooth: {
        enabled: true,
        type: ['dynamic', 'continuous', 'discrete', 'diagonalCross', 'straightCross', 'horizontal', 'vertical', 'curvedCW', 'curvedCCW', 'cubicBezier'],
        forceDirection: ['horizontal', 'vertical', 'none'],
        roundness: [0.5, 0, 1, 0.05]
      },
      width: [1, 0, 30, 1]
    },
    layout: {
      //randomSeed: [0, 0, 500, 1],
      //improvedLayout: true,
      hierarchical: {
        enabled: false,
        levelSeparation: [150, 20, 500, 5],
        nodeSpacing: [100, 20, 500, 5],
        treeSpacing: [200, 20, 500, 5],
        blockShifting: true,
        edgeMinimization: true,
        parentCentralization: true,
        direction: ['UD', 'DU', 'LR', 'RL'], // UD, DU, LR, RL
        sortMethod: ['hubsize', 'directed'] // hubsize, directed
      }
    },
    interaction: {
      dragNodes: true,
      dragView: true,
      hideEdgesOnDrag: false,
      hideNodesOnDrag: false,
      hover: false,
      keyboard: {
        enabled: false,
        speed: { x: [10, 0, 40, 1], y: [10, 0, 40, 1], zoom: [0.02, 0, 0.1, 0.005] },
        bindToWindow: true
      },
      multiselect: false,
      navigationButtons: false,
      selectable: true,
      selectConnectedEdges: true,
      hoverConnectedEdges: true,
      tooltipDelay: [300, 0, 1000, 25],
      zoomView: true
    },
    manipulation: {
      enabled: false,
      initiallyActive: false
    },
    physics: {
      enabled: true,
      barnesHut: {
        //theta: [0.5, 0.1, 1, 0.05],
        gravitationalConstant: [-2000, -30000, 0, 50],
        centralGravity: [0.3, 0, 10, 0.05],
        springLength: [95, 0, 500, 5],
        springConstant: [0.04, 0, 1.2, 0.005],
        damping: [0.09, 0, 1, 0.01],
        avoidOverlap: [0, 0, 1, 0.01]
      },
      forceAtlas2Based: {
        //theta: [0.5, 0.1, 1, 0.05],
        gravitationalConstant: [-50, -500, 0, 1],
        centralGravity: [0.01, 0, 1, 0.005],
        springLength: [95, 0, 500, 5],
        springConstant: [0.08, 0, 1.2, 0.005],
        damping: [0.4, 0, 1, 0.01],
        avoidOverlap: [0, 0, 1, 0.01]
      },
      repulsion: {
        centralGravity: [0.2, 0, 10, 0.05],
        springLength: [200, 0, 500, 5],
        springConstant: [0.05, 0, 1.2, 0.005],
        nodeDistance: [100, 0, 500, 5],
        damping: [0.09, 0, 1, 0.01]
      },
      hierarchicalRepulsion: {
        centralGravity: [0.2, 0, 10, 0.05],
        springLength: [100, 0, 500, 5],
        springConstant: [0.01, 0, 1.2, 0.005],
        nodeDistance: [120, 0, 500, 5],
        damping: [0.09, 0, 1, 0.01]
      },
      maxVelocity: [50, 0, 150, 1],
      minVelocity: [0.1, 0.01, 0.5, 0.01],
      solver: ['barnesHut', 'forceAtlas2Based', 'repulsion', 'hierarchicalRepulsion'],
      timestep: [0.5, 0.01, 1, 0.01]
    },
    //adaptiveTimestep: true
    global: {
      locale: ['en', 'nl']
    }
  };

  exports.allOptions = allOptions;
  exports.configureOptions = configureOptions;

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // distance finding algorithm


  var _FloydWarshall = __webpack_require__(116);

  var _FloydWarshall2 = _interopRequireDefault(_FloydWarshall);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  /**
   * KamadaKawai positions the nodes initially based on
   *
   * "AN ALGORITHM FOR DRAWING GENERAL UNDIRECTED GRAPHS"
   * -- Tomihisa KAMADA and Satoru KAWAI in 1989
   *
   * Possible optimizations in the distance calculation can be implemented.
   */

  var KamadaKawai = function () {
    function KamadaKawai(body, edgeLength, edgeStrength) {
      _classCallCheck(this, KamadaKawai);

      this.body = body;
      this.springLength = edgeLength;
      this.springConstant = edgeStrength;
      this.distanceSolver = new _FloydWarshall2.default();
    }

    /**
     * Not sure if needed but can be used to update the spring length and spring constant
     * @param options
     */


    _createClass(KamadaKawai, [{
      key: "setOptions",
      value: function setOptions(options) {
        if (options) {
          if (options.springLength) {
            this.springLength = options.springLength;
          }
          if (options.springConstant) {
            this.springConstant = options.springConstant;
          }
        }
      }

      /**
       * Position the system
       * @param nodesArray
       * @param edgesArray
       */

    }, {
      key: "solve",
      value: function solve(nodesArray, edgesArray) {
        var ignoreClusters = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

        // get distance matrix
        var D_matrix = this.distanceSolver.getDistances(this.body, nodesArray, edgesArray); // distance matrix

        // get the L Matrix
        this._createL_matrix(D_matrix);

        // get the K Matrix
        this._createK_matrix(D_matrix);

        // calculate positions
        var threshold = 0.01;
        var innerThreshold = 1;
        var iterations = 0;
        var maxIterations = Math.max(1000, Math.min(10 * this.body.nodeIndices.length, 6000));
        var maxInnerIterations = 5;

        var maxEnergy = 1e9;
        var highE_nodeId = 0,
            dE_dx = 0,
            dE_dy = 0,
            delta_m = 0,
            subIterations = 0;

        while (maxEnergy > threshold && iterations < maxIterations) {
          iterations += 1;

          var _getHighestEnergyNode2 = this._getHighestEnergyNode(ignoreClusters);

          var _getHighestEnergyNode3 = _slicedToArray(_getHighestEnergyNode2, 4);

          highE_nodeId = _getHighestEnergyNode3[0];
          maxEnergy = _getHighestEnergyNode3[1];
          dE_dx = _getHighestEnergyNode3[2];
          dE_dy = _getHighestEnergyNode3[3];

          delta_m = maxEnergy;
          subIterations = 0;
          while (delta_m > innerThreshold && subIterations < maxInnerIterations) {
            subIterations += 1;
            this._moveNode(highE_nodeId, dE_dx, dE_dy);

            var _getEnergy2 = this._getEnergy(highE_nodeId);

            var _getEnergy3 = _slicedToArray(_getEnergy2, 3);

            delta_m = _getEnergy3[0];
            dE_dx = _getEnergy3[1];
            dE_dy = _getEnergy3[2];
          }
        }
      }

      /**
       * get the node with the highest energy
       * @returns {*[]}
       * @private
       */

    }, {
      key: "_getHighestEnergyNode",
      value: function _getHighestEnergyNode(ignoreClusters) {
        var nodesArray = this.body.nodeIndices;
        var nodes = this.body.nodes;
        var maxEnergy = 0;
        var maxEnergyNodeId = nodesArray[0];
        var dE_dx_max = 0,
            dE_dy_max = 0;

        for (var nodeIdx = 0; nodeIdx < nodesArray.length; nodeIdx++) {
          var m = nodesArray[nodeIdx];
          // by not evaluating nodes with predefined positions we should only move nodes that have no positions.
          if (nodes[m].predefinedPosition === false || nodes[m].isCluster === true && ignoreClusters === true || nodes[m].options.fixed.x === true || nodes[m].options.fixed.y === true) {
            var _getEnergy4 = this._getEnergy(m);

            var _getEnergy5 = _slicedToArray(_getEnergy4, 3);

            var delta_m = _getEnergy5[0];
            var dE_dx = _getEnergy5[1];
            var dE_dy = _getEnergy5[2];

            if (maxEnergy < delta_m) {
              maxEnergy = delta_m;
              maxEnergyNodeId = m;
              dE_dx_max = dE_dx;
              dE_dy_max = dE_dy;
            }
          }
        }

        return [maxEnergyNodeId, maxEnergy, dE_dx_max, dE_dy_max];
      }

      /**
       * calculate the energy of a single node
       * @param m
       * @returns {*[]}
       * @private
       */

    }, {
      key: "_getEnergy",
      value: function _getEnergy(m) {
        var nodesArray = this.body.nodeIndices;
        var nodes = this.body.nodes;

        var x_m = nodes[m].x;
        var y_m = nodes[m].y;
        var dE_dx = 0;
        var dE_dy = 0;
        for (var iIdx = 0; iIdx < nodesArray.length; iIdx++) {
          var i = nodesArray[iIdx];
          if (i !== m) {
            var x_i = nodes[i].x;
            var y_i = nodes[i].y;
            var denominator = 1.0 / Math.sqrt(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2));
            dE_dx += this.K_matrix[m][i] * (x_m - x_i - this.L_matrix[m][i] * (x_m - x_i) * denominator);
            dE_dy += this.K_matrix[m][i] * (y_m - y_i - this.L_matrix[m][i] * (y_m - y_i) * denominator);
          }
        }

        var delta_m = Math.sqrt(Math.pow(dE_dx, 2) + Math.pow(dE_dy, 2));
        return [delta_m, dE_dx, dE_dy];
      }

      /**
       * move the node based on it's energy
       * the dx and dy are calculated from the linear system proposed by Kamada and Kawai
       * @param m
       * @param dE_dx
       * @param dE_dy
       * @private
       */

    }, {
      key: "_moveNode",
      value: function _moveNode(m, dE_dx, dE_dy) {
        var nodesArray = this.body.nodeIndices;
        var nodes = this.body.nodes;
        var d2E_dx2 = 0;
        var d2E_dxdy = 0;
        var d2E_dy2 = 0;

        var x_m = nodes[m].x;
        var y_m = nodes[m].y;
        for (var iIdx = 0; iIdx < nodesArray.length; iIdx++) {
          var i = nodesArray[iIdx];
          if (i !== m) {
            var x_i = nodes[i].x;
            var y_i = nodes[i].y;
            var denominator = 1.0 / Math.pow(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2), 1.5);
            d2E_dx2 += this.K_matrix[m][i] * (1 - this.L_matrix[m][i] * Math.pow(y_m - y_i, 2) * denominator);
            d2E_dxdy += this.K_matrix[m][i] * (this.L_matrix[m][i] * (x_m - x_i) * (y_m - y_i) * denominator);
            d2E_dy2 += this.K_matrix[m][i] * (1 - this.L_matrix[m][i] * Math.pow(x_m - x_i, 2) * denominator);
          }
        }
        // make the variable names easier to make the solving of the linear system easier to read
        var A = d2E_dx2,
            B = d2E_dxdy,
            C = dE_dx,
            D = d2E_dy2,
            E = dE_dy;

        // solve the linear system for dx and dy
        var dy = (C / A + E / B) / (B / A - D / B);
        var dx = -(B * dy + C) / A;

        // move the node
        nodes[m].x += dx;
        nodes[m].y += dy;
      }

      /**
       * Create the L matrix: edge length times shortest path
       * @param D_matrix
       * @private
       */

    }, {
      key: "_createL_matrix",
      value: function _createL_matrix(D_matrix) {
        var nodesArray = this.body.nodeIndices;
        var edgeLength = this.springLength;

        this.L_matrix = [];
        for (var i = 0; i < nodesArray.length; i++) {
          this.L_matrix[nodesArray[i]] = {};
          for (var j = 0; j < nodesArray.length; j++) {
            this.L_matrix[nodesArray[i]][nodesArray[j]] = edgeLength * D_matrix[nodesArray[i]][nodesArray[j]];
          }
        }
      }

      /**
       * Create the K matrix: spring constants times shortest path
       * @param D_matrix
       * @private
       */

    }, {
      key: "_createK_matrix",
      value: function _createK_matrix(D_matrix) {
        var nodesArray = this.body.nodeIndices;
        var edgeStrength = this.springConstant;

        this.K_matrix = [];
        for (var i = 0; i < nodesArray.length; i++) {
          this.K_matrix[nodesArray[i]] = {};
          for (var j = 0; j < nodesArray.length; j++) {
            this.K_matrix[nodesArray[i]][nodesArray[j]] = edgeStrength * Math.pow(D_matrix[nodesArray[i]][nodesArray[j]], -2);
          }
        }
      }
    }]);

    return KamadaKawai;
  }();

  exports.default = KamadaKawai;

/***/ },
/* 116 */
/***/ function(module, exports) {

  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  /**
   * Created by Alex on 10-Aug-15.
   */

  var FloydWarshall = function () {
    function FloydWarshall() {
      _classCallCheck(this, FloydWarshall);
    }

    _createClass(FloydWarshall, [{
      key: "getDistances",
      value: function getDistances(body, nodesArray, edgesArray) {
        var D_matrix = {};
        var edges = body.edges;

        // prepare matrix with large numbers
        for (var i = 0; i < nodesArray.length; i++) {
          D_matrix[nodesArray[i]] = {};
          D_matrix[nodesArray[i]] = {};
          for (var j = 0; j < nodesArray.length; j++) {
            D_matrix[nodesArray[i]][nodesArray[j]] = i == j ? 0 : 1e9;
            D_matrix[nodesArray[i]][nodesArray[j]] = i == j ? 0 : 1e9;
          }
        }

        // put the weights for the edges in. This assumes unidirectionality.
        for (var _i = 0; _i < edgesArray.length; _i++) {
          var edge = edges[edgesArray[_i]];
          // edge has to be connected if it counts to the distances. If it is connected to inner clusters it will crash so we also check if it is in the D_matrix
          if (edge.connected === true && D_matrix[edge.fromId] !== undefined && D_matrix[edge.toId] !== undefined) {
            D_matrix[edge.fromId][edge.toId] = 1;
            D_matrix[edge.toId][edge.fromId] = 1;
          }
        }

        var nodeCount = nodesArray.length;

        // Adapted FloydWarshall based on unidirectionality to greatly reduce complexity.
        for (var k = 0; k < nodeCount; k++) {
          for (var _i2 = 0; _i2 < nodeCount - 1; _i2++) {
            for (var _j = _i2 + 1; _j < nodeCount; _j++) {
              D_matrix[nodesArray[_i2]][nodesArray[_j]] = Math.min(D_matrix[nodesArray[_i2]][nodesArray[_j]], D_matrix[nodesArray[_i2]][nodesArray[k]] + D_matrix[nodesArray[k]][nodesArray[_j]]);
              D_matrix[nodesArray[_j]][nodesArray[_i2]] = D_matrix[nodesArray[_i2]][nodesArray[_j]];
            }
          }
        }

        return D_matrix;
      }
    }]);

    return FloydWarshall;
  }();

  exports.default = FloydWarshall;

/***/ },
/* 117 */
/***/ function(module, exports) {

  'use strict';

  /**
   * Canvas shapes used by Network
   */
  if (typeof CanvasRenderingContext2D !== 'undefined') {

    /**
     * Draw a circle shape
     */
    CanvasRenderingContext2D.prototype.circle = function (x, y, r) {
      this.beginPath();
      this.arc(x, y, r, 0, 2 * Math.PI, false);
      this.closePath();
    };

    /**
     * Draw a square shape
     * @param {Number} x horizontal center
     * @param {Number} y vertical center
     * @param {Number} r   size, width and height of the square
     */
    CanvasRenderingContext2D.prototype.square = function (x, y, r) {
      this.beginPath();
      this.rect(x - r, y - r, r * 2, r * 2);
      this.closePath();
    };

    /**
     * Draw a triangle shape
     * @param {Number} x horizontal center
     * @param {Number} y vertical center
     * @param {Number} r   radius, half the length of the sides of the triangle
     */
    CanvasRenderingContext2D.prototype.triangle = function (x, y, r) {
      // http://en.wikipedia.org/wiki/Equilateral_triangle
      this.beginPath();

      // the change in radius and the offset is here to center the shape
      r *= 1.15;
      y += 0.275 * r;

      var s = r * 2;
      var s2 = s / 2;
      var ir = Math.sqrt(3) / 6 * s; // radius of inner circle
      var h = Math.sqrt(s * s - s2 * s2); // height

      this.moveTo(x, y - (h - ir));
      this.lineTo(x + s2, y + ir);
      this.lineTo(x - s2, y + ir);
      this.lineTo(x, y - (h - ir));
      this.closePath();
    };

    /**
     * Draw a triangle shape in downward orientation
     * @param {Number} x horizontal center
     * @param {Number} y vertical center
     * @param {Number} r radius
     */
    CanvasRenderingContext2D.prototype.triangleDown = function (x, y, r) {
      // http://en.wikipedia.org/wiki/Equilateral_triangle
      this.beginPath();

      // the change in radius and the offset is here to center the shape
      r *= 1.15;
      y -= 0.275 * r;

      var s = r * 2;
      var s2 = s / 2;
      var ir = Math.sqrt(3) / 6 * s; // radius of inner circle
      var h = Math.sqrt(s * s - s2 * s2); // height

      this.moveTo(x, y + (h - ir));
      this.lineTo(x + s2, y - ir);
      this.lineTo(x - s2, y - ir);
      this.lineTo(x, y + (h - ir));
      this.closePath();
    };

    /**
     * Draw a star shape, a star with 5 points
     * @param {Number} x horizontal center
     * @param {Number} y vertical center
     * @param {Number} r   radius, half the length of the sides of the triangle
     */
    CanvasRenderingContext2D.prototype.star = function (x, y, r) {
      // http://www.html5canvastutorials.com/labs/html5-canvas-star-spinner/
      this.beginPath();

      // the change in radius and the offset is here to center the shape
      r *= 0.82;
      y += 0.1 * r;

      for (var n = 0; n < 10; n++) {
        var radius = n % 2 === 0 ? r * 1.3 : r * 0.5;
        this.lineTo(x + radius * Math.sin(n * 2 * Math.PI / 10), y - radius * Math.cos(n * 2 * Math.PI / 10));
      }

      this.closePath();
    };

    /**
     * Draw a Diamond shape
     * @param {Number} x horizontal center
     * @param {Number} y vertical center
     * @param {Number} r   radius, half the length of the sides of the triangle
     */
    CanvasRenderingContext2D.prototype.diamond = function (x, y, r) {
      // http://www.html5canvastutorials.com/labs/html5-canvas-star-spinner/
      this.beginPath();

      this.lineTo(x, y + r);
      this.lineTo(x + r, y);
      this.lineTo(x, y - r);
      this.lineTo(x - r, y);

      this.closePath();
    };

    /**
     * http://stackoverflow.com/questions/1255512/how-to-draw-a-rounded-rectangle-on-html-canvas
     */
    CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
      var r2d = Math.PI / 180;
      if (w - 2 * r < 0) {
        r = w / 2;
      } //ensure that the radius isn't too large for x
      if (h - 2 * r < 0) {
        r = h / 2;
      } //ensure that the radius isn't too large for y
      this.beginPath();
      this.moveTo(x + r, y);
      this.lineTo(x + w - r, y);
      this.arc(x + w - r, y + r, r, r2d * 270, r2d * 360, false);
      this.lineTo(x + w, y + h - r);
      this.arc(x + w - r, y + h - r, r, 0, r2d * 90, false);
      this.lineTo(x + r, y + h);
      this.arc(x + r, y + h - r, r, r2d * 90, r2d * 180, false);
      this.lineTo(x, y + r);
      this.arc(x + r, y + r, r, r2d * 180, r2d * 270, false);
      this.closePath();
    };

    /**
     * http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas
     */
    CanvasRenderingContext2D.prototype.ellipse = function (x, y, w, h) {
      var kappa = .5522848,
          ox = w / 2 * kappa,
          // control point offset horizontal
      oy = h / 2 * kappa,
          // control point offset vertical
      xe = x + w,
          // x-end
      ye = y + h,
          // y-end
      xm = x + w / 2,
          // x-middle
      ym = y + h / 2; // y-middle

      this.beginPath();
      this.moveTo(x, ym);
      this.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
      this.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
      this.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
      this.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
      this.closePath();
    };

    /**
     * http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas
     */
    CanvasRenderingContext2D.prototype.database = function (x, y, w, h) {
      var f = 1 / 3;
      var wEllipse = w;
      var hEllipse = h * f;

      var kappa = .5522848,
          ox = wEllipse / 2 * kappa,
          // control point offset horizontal
      oy = hEllipse / 2 * kappa,
          // control point offset vertical
      xe = x + wEllipse,
          // x-end
      ye = y + hEllipse,
          // y-end
      xm = x + wEllipse / 2,
          // x-middle
      ym = y + hEllipse / 2,
          // y-middle
      ymb = y + (h - hEllipse / 2),
          // y-midlle, bottom ellipse
      yeb = y + h; // y-end, bottom ellipse

      this.beginPath();
      this.moveTo(xe, ym);

      this.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
      this.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);

      this.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
      this.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);

      this.lineTo(xe, ymb);

      this.bezierCurveTo(xe, ymb + oy, xm + ox, yeb, xm, yeb);
      this.bezierCurveTo(xm - ox, yeb, x, ymb + oy, x, ymb);

      this.lineTo(x, ym);
    };

    /**
     * Draw an arrow point (no line)
     */
    CanvasRenderingContext2D.prototype.arrow = function (x, y, angle, length) {
      // tail
      var xt = x - length * Math.cos(angle);
      var yt = y - length * Math.sin(angle);

      // inner tail
      var xi = x - length * 0.9 * Math.cos(angle);
      var yi = y - length * 0.9 * Math.sin(angle);

      // left
      var xl = xt + length / 3 * Math.cos(angle + 0.5 * Math.PI);
      var yl = yt + length / 3 * Math.sin(angle + 0.5 * Math.PI);

      // right
      var xr = xt + length / 3 * Math.cos(angle - 0.5 * Math.PI);
      var yr = yt + length / 3 * Math.sin(angle - 0.5 * Math.PI);

      this.beginPath();
      this.moveTo(x, y);
      this.lineTo(xl, yl);
      this.lineTo(xi, yi);
      this.lineTo(xr, yr);
      this.closePath();
    };

    /**
     * Sets up the dashedLine functionality for drawing
     * Original code came from http://stackoverflow.com/questions/4576724/dotted-stroke-in-canvas
     * @author David Jordan
     * @date 2012-08-08
     */
    CanvasRenderingContext2D.prototype.dashedLine = function (x, y, x2, y2, pattern) {
      this.beginPath();
      this.moveTo(x, y);

      var patternLength = pattern.length;
      var dx = x2 - x;
      var dy = y2 - y;
      var slope = dy / dx;
      var distRemaining = Math.sqrt(dx * dx + dy * dy);
      var patternIndex = 0;
      var draw = true;
      var xStep = 0;
      var dashLength = pattern[0];

      while (distRemaining >= 0.1) {
        dashLength = pattern[patternIndex++ % patternLength];
        if (dashLength > distRemaining) {
          dashLength = distRemaining;
        }

        xStep = Math.sqrt(dashLength * dashLength / (1 + slope * slope));
        xStep = dx < 0 ? -xStep : xStep;
        x += xStep;
        y += slope * xStep;

        if (draw === true) {
          this.lineTo(x, y);
        } else {
          this.moveTo(x, y);
        }

        distRemaining -= dashLength;
        draw = !draw;
      }
    };
  }

/***/ },
/* 118 */
/***/ function(module, exports) {

  'use strict';

  /**
   * Parse a text source containing data in DOT language into a JSON object.
   * The object contains two lists: one with nodes and one with edges.
   *
   * DOT language reference: http://www.graphviz.org/doc/info/lang.html
   *
   * DOT language attributes: http://graphviz.org/content/attrs
   *
   * @param {String} data     Text containing a graph in DOT-notation
   * @return {Object} graph   An object containing two parameters:
   *                          {Object[]} nodes
   *                          {Object[]} edges
   */
  function parseDOT(data) {
    dot = data;
    return parseGraph();
  }

  // mapping of attributes from DOT (the keys) to vis.js (the values)
  var NODE_ATTR_MAPPING = {
    'fontsize': 'font.size',
    'fontcolor': 'font.color',
    'labelfontcolor': 'font.color',
    'fontname': 'font.face',
    'color': ['color.border', 'color.background'],
    'fillcolor': 'color.background',
    'tooltip': 'title',
    'labeltooltip': 'title'
  };
  var EDGE_ATTR_MAPPING = Object.create(NODE_ATTR_MAPPING);
  EDGE_ATTR_MAPPING.color = 'color.color';

  // token types enumeration
  var TOKENTYPE = {
    NULL: 0,
    DELIMITER: 1,
    IDENTIFIER: 2,
    UNKNOWN: 3
  };

  // map with all delimiters
  var DELIMITERS = {
    '{': true,
    '}': true,
    '[': true,
    ']': true,
    ';': true,
    '=': true,
    ',': true,

    '->': true,
    '--': true
  };

  var dot = ''; // current dot file
  var index = 0; // current index in dot file
  var c = ''; // current token character in expr
  var token = ''; // current token
  var tokenType = TOKENTYPE.NULL; // type of the token

  /**
   * Get the first character from the dot file.
   * The character is stored into the char c. If the end of the dot file is
   * reached, the function puts an empty string in c.
   */
  function first() {
    index = 0;
    c = dot.charAt(0);
  }

  /**
   * Get the next character from the dot file.
   * The character is stored into the char c. If the end of the dot file is
   * reached, the function puts an empty string in c.
   */
  function next() {
    index++;
    c = dot.charAt(index);
  }

  /**
   * Preview the next character from the dot file.
   * @return {String} cNext
   */
  function nextPreview() {
    return dot.charAt(index + 1);
  }

  /**
   * Test whether given character is alphabetic or numeric
   * @param {String} c
   * @return {Boolean} isAlphaNumeric
   */
  var regexAlphaNumeric = /[a-zA-Z_0-9.:#]/;
  function isAlphaNumeric(c) {
    return regexAlphaNumeric.test(c);
  }

  /**
   * Merge all options of object b into object b
   * @param {Object} a
   * @param {Object} b
   * @return {Object} a
   */
  function merge(a, b) {
    if (!a) {
      a = {};
    }

    if (b) {
      for (var name in b) {
        if (b.hasOwnProperty(name)) {
          a[name] = b[name];
        }
      }
    }
    return a;
  }

  /**
   * Set a value in an object, where the provided parameter name can be a
   * path with nested parameters. For example:
   *
   *     var obj = {a: 2};
   *     setValue(obj, 'b.c', 3);     // obj = {a: 2, b: {c: 3}}
   *
   * @param {Object} obj
   * @param {String} path  A parameter name or dot-separated parameter path,
   *                      like "color.highlight.border".
   * @param {*} value
   */
  function setValue(obj, path, value) {
    var keys = path.split('.');
    var o = obj;
    while (keys.length) {
      var key = keys.shift();
      if (keys.length) {
        // this isn't the end point
        if (!o[key]) {
          o[key] = {};
        }
        o = o[key];
      } else {
        // this is the end point
        o[key] = value;
      }
    }
  }

  /**
   * Add a node to a graph object. If there is already a node with
   * the same id, their attributes will be merged.
   * @param {Object} graph
   * @param {Object} node
   */
  function addNode(graph, node) {
    var i, len;
    var current = null;

    // find root graph (in case of subgraph)
    var graphs = [graph]; // list with all graphs from current graph to root graph
    var root = graph;
    while (root.parent) {
      graphs.push(root.parent);
      root = root.parent;
    }

    // find existing node (at root level) by its id
    if (root.nodes) {
      for (i = 0, len = root.nodes.length; i < len; i++) {
        if (node.id === root.nodes[i].id) {
          current = root.nodes[i];
          break;
        }
      }
    }

    if (!current) {
      // this is a new node
      current = {
        id: node.id
      };
      if (graph.node) {
        // clone default attributes
        current.attr = merge(current.attr, graph.node);
      }
    }

    // add node to this (sub)graph and all its parent graphs
    for (i = graphs.length - 1; i >= 0; i--) {
      var g = graphs[i];

      if (!g.nodes) {
        g.nodes = [];
      }
      if (g.nodes.indexOf(current) === -1) {
        g.nodes.push(current);
      }
    }

    // merge attributes
    if (node.attr) {
      current.attr = merge(current.attr, node.attr);
    }
  }

  /**
   * Add an edge to a graph object
   * @param {Object} graph
   * @param {Object} edge
   */
  function addEdge(graph, edge) {
    if (!graph.edges) {
      graph.edges = [];
    }
    graph.edges.push(edge);
    if (graph.edge) {
      var attr = merge({}, graph.edge); // clone default attributes
      edge.attr = merge(attr, edge.attr); // merge attributes
    }
  }

  /**
   * Create an edge to a graph object
   * @param {Object} graph
   * @param {String | Number | Object} from
   * @param {String | Number | Object} to
   * @param {String} type
   * @param {Object | null} attr
   * @return {Object} edge
   */
  function createEdge(graph, from, to, type, attr) {
    var edge = {
      from: from,
      to: to,
      type: type
    };

    if (graph.edge) {
      edge.attr = merge({}, graph.edge); // clone default attributes
    }
    edge.attr = merge(edge.attr || {}, attr); // merge attributes

    return edge;
  }

  /**
   * Get next token in the current dot file.
   * The token and token type are available as token and tokenType
   */
  function getToken() {
    tokenType = TOKENTYPE.NULL;
    token = '';

    // skip over whitespaces
    while (c === ' ' || c === '\t' || c === '\n' || c === '\r') {
      // space, tab, enter
      next();
    }

    do {
      var isComment = false;

      // skip comment
      if (c === '#') {
        // find the previous non-space character
        var i = index - 1;
        while (dot.charAt(i) === ' ' || dot.charAt(i) === '\t') {
          i--;
        }
        if (dot.charAt(i) === '\n' || dot.charAt(i) === '') {
          // the # is at the start of a line, this is indeed a line comment
          while (c != '' && c != '\n') {
            next();
          }
          isComment = true;
        }
      }
      if (c === '/' && nextPreview() === '/') {
        // skip line comment
        while (c != '' && c != '\n') {
          next();
        }
        isComment = true;
      }
      if (c === '/' && nextPreview() === '*') {
        // skip block comment
        while (c != '') {
          if (c === '*' && nextPreview() === '/') {
            // end of block comment found. skip these last two characters
            next();
            next();
            break;
          } else {
            next();
          }
        }
        isComment = true;
      }

      // skip over whitespaces
      while (c === ' ' || c === '\t' || c === '\n' || c === '\r') {
        // space, tab, enter
        next();
      }
    } while (isComment);

    // check for end of dot file
    if (c === '') {
      // token is still empty
      tokenType = TOKENTYPE.DELIMITER;
      return;
    }

    // check for delimiters consisting of 2 characters
    var c2 = c + nextPreview();
    if (DELIMITERS[c2]) {
      tokenType = TOKENTYPE.DELIMITER;
      token = c2;
      next();
      next();
      return;
    }

    // check for delimiters consisting of 1 character
    if (DELIMITERS[c]) {
      tokenType = TOKENTYPE.DELIMITER;
      token = c;
      next();
      return;
    }

    // check for an identifier (number or string)
    // TODO: more precise parsing of numbers/strings (and the port separator ':')
    if (isAlphaNumeric(c) || c === '-') {
      token += c;
      next();

      while (isAlphaNumeric(c)) {
        token += c;
        next();
      }
      if (token === 'false') {
        token = false; // convert to boolean
      } else if (token === 'true') {
          token = true; // convert to boolean
        } else if (!isNaN(Number(token))) {
            token = Number(token); // convert to number
          }
      tokenType = TOKENTYPE.IDENTIFIER;
      return;
    }

    // check for a string enclosed by double quotes
    if (c === '"') {
      next();
      while (c != '' && (c != '"' || c === '"' && nextPreview() === '"')) {
        token += c;
        if (c === '"') {
          // skip the escape character
          next();
        }
        next();
      }
      if (c != '"') {
        throw newSyntaxError('End of string " expected');
      }
      next();
      tokenType = TOKENTYPE.IDENTIFIER;
      return;
    }

    // something unknown is found, wrong characters, a syntax error
    tokenType = TOKENTYPE.UNKNOWN;
    while (c != '') {
      token += c;
      next();
    }
    throw new SyntaxError('Syntax error in part "' + chop(token, 30) + '"');
  }

  /**
   * Parse a graph.
   * @returns {Object} graph
   */
  function parseGraph() {
    var graph = {};

    first();
    getToken();

    // optional strict keyword
    if (token === 'strict') {
      graph.strict = true;
      getToken();
    }

    // graph or digraph keyword
    if (token === 'graph' || token === 'digraph') {
      graph.type = token;
      getToken();
    }

    // optional graph id
    if (tokenType === TOKENTYPE.IDENTIFIER) {
      graph.id = token;
      getToken();
    }

    // open angle bracket
    if (token != '{') {
      throw newSyntaxError('Angle bracket { expected');
    }
    getToken();

    // statements
    parseStatements(graph);

    // close angle bracket
    if (token != '}') {
      throw newSyntaxError('Angle bracket } expected');
    }
    getToken();

    // end of file
    if (token !== '') {
      throw newSyntaxError('End of file expected');
    }
    getToken();

    // remove temporary default options
    delete graph.node;
    delete graph.edge;
    delete graph.graph;

    return graph;
  }

  /**
   * Parse a list with statements.
   * @param {Object} graph
   */
  function parseStatements(graph) {
    while (token !== '' && token != '}') {
      parseStatement(graph);
      if (token === ';') {
        getToken();
      }
    }
  }

  /**
   * Parse a single statement. Can be a an attribute statement, node
   * statement, a series of node statements and edge statements, or a
   * parameter.
   * @param {Object} graph
   */
  function parseStatement(graph) {
    // parse subgraph
    var subgraph = parseSubgraph(graph);
    if (subgraph) {
      // edge statements
      parseEdge(graph, subgraph);

      return;
    }

    // parse an attribute statement
    var attr = parseAttributeStatement(graph);
    if (attr) {
      return;
    }

    // parse node
    if (tokenType != TOKENTYPE.IDENTIFIER) {
      throw newSyntaxError('Identifier expected');
    }
    var id = token; // id can be a string or a number
    getToken();

    if (token === '=') {
      // id statement
      getToken();
      if (tokenType != TOKENTYPE.IDENTIFIER) {
        throw newSyntaxError('Identifier expected');
      }
      graph[id] = token;
      getToken();
      // TODO: implement comma separated list with "a_list: ID=ID [','] [a_list] "
    } else {
        parseNodeStatement(graph, id);
      }
  }

  /**
   * Parse a subgraph
   * @param {Object} graph    parent graph object
   * @return {Object | null} subgraph
   */
  function parseSubgraph(graph) {
    var subgraph = null;

    // optional subgraph keyword
    if (token === 'subgraph') {
      subgraph = {};
      subgraph.type = 'subgraph';
      getToken();

      // optional graph id
      if (tokenType === TOKENTYPE.IDENTIFIER) {
        subgraph.id = token;
        getToken();
      }
    }

    // open angle bracket
    if (token === '{') {
      getToken();

      if (!subgraph) {
        subgraph = {};
      }
      subgraph.parent = graph;
      subgraph.node = graph.node;
      subgraph.edge = graph.edge;
      subgraph.graph = graph.graph;

      // statements
      parseStatements(subgraph);

      // close angle bracket
      if (token != '}') {
        throw newSyntaxError('Angle bracket } expected');
      }
      getToken();

      // remove temporary default options
      delete subgraph.node;
      delete subgraph.edge;
      delete subgraph.graph;
      delete subgraph.parent;

      // register at the parent graph
      if (!graph.subgraphs) {
        graph.subgraphs = [];
      }
      graph.subgraphs.push(subgraph);
    }

    return subgraph;
  }

  /**
   * parse an attribute statement like "node [shape=circle fontSize=16]".
   * Available keywords are 'node', 'edge', 'graph'.
   * The previous list with default attributes will be replaced
   * @param {Object} graph
   * @returns {String | null} keyword Returns the name of the parsed attribute
   *                                  (node, edge, graph), or null if nothing
   *                                  is parsed.
   */
  function parseAttributeStatement(graph) {
    // attribute statements
    if (token === 'node') {
      getToken();

      // node attributes
      graph.node = parseAttributeList();
      return 'node';
    } else if (token === 'edge') {
      getToken();

      // edge attributes
      graph.edge = parseAttributeList();
      return 'edge';
    } else if (token === 'graph') {
      getToken();

      // graph attributes
      graph.graph = parseAttributeList();
      return 'graph';
    }

    return null;
  }

  /**
   * parse a node statement
   * @param {Object} graph
   * @param {String | Number} id
   */
  function parseNodeStatement(graph, id) {
    // node statement
    var node = {
      id: id
    };
    var attr = parseAttributeList();
    if (attr) {
      node.attr = attr;
    }
    addNode(graph, node);

    // edge statements
    parseEdge(graph, id);
  }

  /**
   * Parse an edge or a series of edges
   * @param {Object} graph
   * @param {String | Number} from        Id of the from node
   */
  function parseEdge(graph, from) {
    while (token === '->' || token === '--') {
      var to;
      var type = token;
      getToken();

      var subgraph = parseSubgraph(graph);
      if (subgraph) {
        to = subgraph;
      } else {
        if (tokenType != TOKENTYPE.IDENTIFIER) {
          throw newSyntaxError('Identifier or subgraph expected');
        }
        to = token;
        addNode(graph, {
          id: to
        });
        getToken();
      }

      // parse edge attributes
      var attr = parseAttributeList();

      // create edge
      var edge = createEdge(graph, from, to, type, attr);
      addEdge(graph, edge);

      from = to;
    }
  }

  /**
   * Parse a set with attributes,
   * for example [label="1.000", shape=solid]
   * @return {Object | null} attr
   */
  function parseAttributeList() {
    var attr = null;

    while (token === '[') {
      getToken();
      attr = {};
      while (token !== '' && token != ']') {
        if (tokenType != TOKENTYPE.IDENTIFIER) {
          throw newSyntaxError('Attribute name expected');
        }
        var name = token;

        getToken();
        if (token != '=') {
          throw newSyntaxError('Equal sign = expected');
        }
        getToken();

        if (tokenType != TOKENTYPE.IDENTIFIER) {
          throw newSyntaxError('Attribute value expected');
        }
        var value = token;
        setValue(attr, name, value); // name can be a path

        getToken();
        if (token == ',') {
          getToken();
        }
      }

      if (token != ']') {
        throw newSyntaxError('Bracket ] expected');
      }
      getToken();
    }

    return attr;
  }

  /**
   * Create a syntax error with extra information on current token and index.
   * @param {String} message
   * @returns {SyntaxError} err
   */
  function newSyntaxError(message) {
    return new SyntaxError(message + ', got "' + chop(token, 30) + '" (char ' + index + ')');
  }

  /**
   * Chop off text after a maximum length
   * @param {String} text
   * @param {Number} maxLength
   * @returns {String}
   */
  function chop(text, maxLength) {
    return text.length <= maxLength ? text : text.substr(0, 27) + '...';
  }

  /**
   * Execute a function fn for each pair of elements in two arrays
   * @param {Array | *} array1
   * @param {Array | *} array2
   * @param {function} fn
   */
  function forEach2(array1, array2, fn) {
    if (Array.isArray(array1)) {
      array1.forEach(function (elem1) {
        if (Array.isArray(array2)) {
          array2.forEach(function (elem2) {
            fn(elem1, elem2);
          });
        } else {
          fn(elem1, array2);
        }
      });
    } else {
      if (Array.isArray(array2)) {
        array2.forEach(function (elem2) {
          fn(array1, elem2);
        });
      } else {
        fn(array1, array2);
      }
    }
  }

  /**
   * Set a nested property on an object
   * When nested objects are missing, they will be created.
   * For example setProp({}, 'font.color', 'red') will return {font: {color: 'red'}}
   * @param {Object} object
   * @param {string} path   A dot separated string like 'font.color'
   * @param {*} value       Value for the property
   * @return {Object} Returns the original object, allows for chaining.
   */
  function setProp(object, path, value) {
    var names = path.split('.');
    var prop = names.pop();

    // traverse over the nested objects
    var obj = object;
    for (var i = 0; i < names.length; i++) {
      var name = names[i];
      if (!(name in obj)) {
        obj[name] = {};
      }
      obj = obj[name];
    }

    // set the property value
    obj[prop] = value;

    return object;
  }

  /**
   * Convert an object with DOT attributes to their vis.js equivalents.
   * @param {Object} attr     Object with DOT attributes
   * @param {Object} mapping
   * @return {Object}         Returns an object with vis.js attributes
   */
  function convertAttr(attr, mapping) {
    var converted = {};

    for (var prop in attr) {
      if (attr.hasOwnProperty(prop)) {
        var visProp = mapping[prop];
        if (Array.isArray(visProp)) {
          visProp.forEach(function (visPropI) {
            setProp(converted, visPropI, attr[prop]);
          });
        } else if (typeof visProp === 'string') {
          setProp(converted, visProp, attr[prop]);
        } else {
          setProp(converted, prop, attr[prop]);
        }
      }
    }

    return converted;
  }

  /**
   * Convert a string containing a graph in DOT language into a map containing
   * with nodes and edges in the format of graph.
   * @param {String} data         Text containing a graph in DOT-notation
   * @return {Object} graphData
   */
  function DOTToGraph(data) {
    // parse the DOT file
    var dotData = parseDOT(data);
    var graphData = {
      nodes: [],
      edges: [],
      options: {}
    };

    // copy the nodes
    if (dotData.nodes) {
      dotData.nodes.forEach(function (dotNode) {
        var graphNode = {
          id: dotNode.id,
          label: String(dotNode.label || dotNode.id)
        };
        merge(graphNode, convertAttr(dotNode.attr, NODE_ATTR_MAPPING));
        if (graphNode.image) {
          graphNode.shape = 'image';
        }
        graphData.nodes.push(graphNode);
      });
    }

    // copy the edges
    if (dotData.edges) {
      /**
       * Convert an edge in DOT format to an edge with VisGraph format
       * @param {Object} dotEdge
       * @returns {Object} graphEdge
       */
      var convertEdge = function convertEdge(dotEdge) {
        var graphEdge = {
          from: dotEdge.from,
          to: dotEdge.to
        };
        merge(graphEdge, convertAttr(dotEdge.attr, EDGE_ATTR_MAPPING));
        graphEdge.arrows = dotEdge.type === '->' ? 'to' : undefined;

        return graphEdge;
      };

      dotData.edges.forEach(function (dotEdge) {
        var from, to;
        if (dotEdge.from instanceof Object) {
          from = dotEdge.from.nodes;
        } else {
          from = {
            id: dotEdge.from
          };
        }

        // TODO: support of solid/dotted/dashed edges (attr = 'style')
        // TODO: support for attributes 'dir' and 'arrowhead' (edge arrows)

        if (dotEdge.to instanceof Object) {
          to = dotEdge.to.nodes;
        } else {
          to = {
            id: dotEdge.to
          };
        }

        if (dotEdge.from instanceof Object && dotEdge.from.edges) {
          dotEdge.from.edges.forEach(function (subEdge) {
            var graphEdge = convertEdge(subEdge);
            graphData.edges.push(graphEdge);
          });
        }

        forEach2(from, to, function (from, to) {
          var subEdge = createEdge(graphData, from.id, to.id, dotEdge.type, dotEdge.attr);
          var graphEdge = convertEdge(subEdge);
          graphData.edges.push(graphEdge);
        });

        if (dotEdge.to instanceof Object && dotEdge.to.edges) {
          dotEdge.to.edges.forEach(function (subEdge) {
            var graphEdge = convertEdge(subEdge);
            graphData.edges.push(graphEdge);
          });
        }
      });
    }

    // copy the options
    if (dotData.attr) {
      graphData.options = dotData.attr;
    }

    return graphData;
  }

  // exports
  exports.parseDOT = parseDOT;
  exports.DOTToGraph = DOTToGraph;

/***/ },
/* 119 */
/***/ function(module, exports) {

  'use strict';

  function parseGephi(gephiJSON, optionsObj) {
    var edges = [];
    var nodes = [];
    var options = {
      edges: {
        inheritColor: false
      },
      nodes: {
        fixed: false,
        parseColor: false
      }
    };

    if (optionsObj !== undefined) {
      if (optionsObj.fixed !== undefined) {
        options.nodes.fixed = optionsObj.fixed;
      }
      if (optionsObj.parseColor !== undefined) {
        options.nodes.parseColor = optionsObj.parseColor;
      }
      if (optionsObj.inheritColor !== undefined) {
        options.edges.inheritColor = optionsObj.inheritColor;
      }
    }

    var gEdges = gephiJSON.edges;
    var gNodes = gephiJSON.nodes;
    for (var i = 0; i < gEdges.length; i++) {
      var edge = {};
      var gEdge = gEdges[i];
      edge['id'] = gEdge.id;
      edge['from'] = gEdge.source;
      edge['to'] = gEdge.target;
      edge['attributes'] = gEdge.attributes;
      edge['label'] = gEdge.label;
      edge['title'] = gEdge.attributes !== undefined ? gEdge.attributes.title : undefined;
      if (gEdge['type'] === 'Directed') {
        edge['arrows'] = 'to';
      }
      //    edge['value'] = gEdge.attributes !== undefined ? gEdge.attributes.Weight : undefined;
      //    edge['width'] = edge['value'] !== undefined ? undefined : edgegEdge.size;
      if (gEdge.color && options.inheritColor === false) {
        edge['color'] = gEdge.color;
      }
      edges.push(edge);
    }

    for (var i = 0; i < gNodes.length; i++) {
      var node = {};
      var gNode = gNodes[i];
      node['id'] = gNode.id;
      node['attributes'] = gNode.attributes;
      node['title'] = gNode.title;
      node['x'] = gNode.x;
      node['y'] = gNode.y;
      node['label'] = gNode.label;
      node['title'] = gNode.attributes !== undefined ? gNode.attributes.title : undefined;
      if (options.nodes.parseColor === true) {
        node['color'] = gNode.color;
      } else {
        node['color'] = gNode.color !== undefined ? { background: gNode.color, border: gNode.color, highlight: { background: gNode.color, border: gNode.color }, hover: { background: gNode.color, border: gNode.color } } : undefined;
      }
      node['size'] = gNode.size;
      node['fixed'] = options.nodes.fixed && gNode.x !== undefined && gNode.y !== undefined;
      nodes.push(node);
    }

    return { nodes: nodes, edges: edges };
  }

  exports.parseGephi = parseGephi;

/***/ },
/* 120 */
/***/ function(module, exports) {

  'use strict';

  // English
  exports['en'] = {
    edit: 'Edit',
    del: 'Delete selected',
    back: 'Back',
    addNode: 'Add Node',
    addEdge: 'Add Edge',
    editNode: 'Edit Node',
    editEdge: 'Edit Edge',
    addDescription: 'Click in an empty space to place a new node.',
    edgeDescription: 'Click on a node and drag the edge to another node to connect them.',
    editEdgeDescription: 'Click on the control points and drag them to a node to connect to it.',
    createEdgeError: 'Cannot link edges to a cluster.',
    deleteClusterError: 'Clusters cannot be deleted.',
    editClusterError: 'Clusters cannot be edited.'
  };
  exports['en_EN'] = exports['en'];
  exports['en_US'] = exports['en'];

  // German
  exports['de'] = {
    edit: 'Editieren',
    del: 'Lösche Auswahl',
    back: 'Zurück',
    addNode: 'Knoten hinzufügen',
    addEdge: 'Kante hinzufügen',
    editNode: 'Knoten editieren',
    editEdge: 'Kante editieren',
    addDescription: 'Klicke auf eine freie Stelle, um einen neuen Knoten zu plazieren.',
    edgeDescription: 'Klicke auf einen Knoten und ziehe die Kante zu einem anderen Knoten, um diese zu verbinden.',
    editEdgeDescription: 'Klicke auf die Verbindungspunkte und ziehe diese auf einen Knoten, um sie zu verbinden.',
    createEdgeError: 'Es ist nicht möglich, Kanten mit Clustern zu verbinden.',
    deleteClusterError: 'Cluster können nicht gelöscht werden.',
    editClusterError: 'Cluster können nicht editiert werden.'
  };
  exports['de_DE'] = exports['de'];

  // Spanish
  exports['es'] = {
    edit: 'Editar',
    del: 'Eliminar selección',
    back: 'Átras',
    addNode: 'Añadir nodo',
    addEdge: 'Añadir arista',
    editNode: 'Editar nodo',
    editEdge: 'Editar arista',
    addDescription: 'Haga clic en un lugar vacío para colocar un nuevo nodo.',
    edgeDescription: 'Haga clic en un nodo y arrastre la arista hacia otro nodo para conectarlos.',
    editEdgeDescription: 'Haga clic en un punto de control y arrastrelo a un nodo para conectarlo.',
    createEdgeError: 'No se puede conectar una arista a un grupo.',
    deleteClusterError: 'No es posible eliminar grupos.',
    editClusterError: 'No es posible editar grupos.'
  };
  exports['es_ES'] = exports['es'];

  // Dutch
  exports['nl'] = {
    edit: 'Wijzigen',
    del: 'Selectie verwijderen',
    back: 'Terug',
    addNode: 'Node toevoegen',
    addEdge: 'Link toevoegen',
    editNode: 'Node wijzigen',
    editEdge: 'Link wijzigen',
    addDescription: 'Klik op een leeg gebied om een nieuwe node te maken.',
    edgeDescription: 'Klik op een node en sleep de link naar een andere node om ze te verbinden.',
    editEdgeDescription: 'Klik op de verbindingspunten en sleep ze naar een node om daarmee te verbinden.',
    createEdgeError: 'Kan geen link maken naar een cluster.',
    deleteClusterError: 'Clusters kunnen niet worden verwijderd.',
    editClusterError: 'Clusters kunnen niet worden aangepast.'
  };
  exports['nl_NL'] = exports['nl'];
  exports['nl_BE'] = exports['nl'];

/***/ }
/******/ ])
});
;
},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy5ucG0tZ2xvYmFsL2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsImV4YW1wbGVzL2luZGV4LmpzIiwibGliL0RpYWdyYW0uanMiLCJsaWIvR3JhbW1hci5qcyIsImxpYi9TdGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy92aXMvZGlzdC92aXMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsInZhciBHcmFtbWFyID0gcmVxdWlyZShcIi4uL2xpYi9HcmFtbWFyXCIpLFxuICAgIFN0YXRlID0gcmVxdWlyZShcIi4uL2xpYi9TdGF0ZVwiKSxcbiAgICBEaWFncmFtID0gcmVxdWlyZShcIi4uL2xpYi9EaWFncmFtXCIpO1xuXG5cbnZhciBnID0gbmV3IEdyYW1tYXIoW1wiQVwiLCBcIkJcIiwgXCJDXCJdKTtcblxuZy5hZGRSdWxlcyh7XG5cbiAgICAnUycgOiBbWydBJywnQicsJ1MnXSxbJ0InLCdFJywnQyddXSxcbiAgICAnRScgOiBbWydDJ11dXG59KTtcblxuLypnLmJ1aWxkKCdTJyk7XG5cbkRpYWdyYW0uZHJhd1N0YXRlRGlhZ3JhbShnLnN0YXRlT3B0aW9ucy5TWzBdLFxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250YWluZXInKSk7XG4qL1xuXG5PYmplY3Qua2V5cyhnLnJ1bGVzKS5mb3JFYWNoKGZ1bmN0aW9uKHJ1bGVMYWJlbCl7XG4gICAgdGhpcy5maXJzdFBhc3ModGhpcy5ydWxlc1tydWxlTGFiZWxdLHJ1bGVMYWJlbCk7XG59LCBnKTtcblxuZnVuY3Rpb24gYnVpbGRQcmVSdWxlcyhzT3BzKSB7XG4gICAgdmFyIG5vZGVzID0gW10sIGVkZ2VzID0gW10sIHMsIGRhdGE7XG4gICAgT2JqZWN0LmtleXMoc09wcykuZm9yRWFjaChmdW5jdGlvbihydWxlTGFiZWwpIHtcbiAgICAgICAgcyA9IG5ldyBTdGF0ZShcIlwiLCBydWxlTGFiZWwpO1xuICAgICAgICBzLmFkZFN0YXRlcyhzT3BzW3J1bGVMYWJlbF0pO1xuICAgICAgICBjb25zb2xlLmxvZyhzKTtcbiAgICAgICAgZGF0YSA9IERpYWdyYW0uYnVpbGREYXRhKHMpO1xuICAgICAgICBub2RlcyA9IG5vZGVzLmNvbmNhdChkYXRhLm5vZGVzKTtcbiAgICAgICAgZWRnZXMgPSBlZGdlcy5jb25jYXQoZGF0YS5lZGdlcyk7XG4gICAgfSk7XG4gICAgRGlhZ3JhbS5kcmF3RnJvbURhdGEobm9kZXMsZWRnZXMsZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjb250YWluZXIyXCIpKTtcbn07XG5cbmJ1aWxkUHJlUnVsZXMoZy5zdGF0ZU9wdGlvbnMpO1xuXG52YXIgc3RhcnQgPSBuZXcgU3RhdGUoXCJcIixcIlN0YXJ0XCIpO1xuc3RhcnQuYWRkU3RhdGVzKGcuYnVpbGRUcmF2ZXJzZShcIlNcIikpO1xuRGlhZ3JhbS5kcmF3U3RhdGVEaWFncmFtKHN0YXJ0LFxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250YWluZXInKSk7XG4iLCJ2YXIgdmlzID0gcmVxdWlyZShcInZpc1wiKTtcblxudmFyIERpYWdyYW0gPSB7fTtcblxuRGlhZ3JhbS5idWlsZERhdGEgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBsYWJlbEluZGV4ID0ge30sXG4gICAgICAgIG5vZGVzID0gW10sXG4gICAgICAgIGVkZ2VzID0gW107XG4gICAgZnVuY3Rpb24gYnVpbGRJbmRleChzdGF0ZSkge1xuICAgICAgICBpZih0eXBlb2YgbGFiZWxJbmRleFtzdGF0ZS5sYWJlbF0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGxhYmVsSW5kZXhbc3RhdGUubGFiZWxdID1cbiAgICAgICAgICAgICAgICB7aWQ6c3RhdGUubGFiZWwsIGxhYmVsOnN0YXRlLmxhYmVsfTtcbiAgICAgICAgICAgIG5vZGVzLnB1c2gobGFiZWxJbmRleFtzdGF0ZS5sYWJlbF0pO1xuICAgICAgICAgICAgZm9yKHZhciBpPTAsbD1zdGF0ZS5zdGF0ZXMubGVuZ3RoO2k8bDtpKyspIHtcbiAgICAgICAgICAgICAgICBlZGdlcy5wdXNoKHtmcm9tOnN0YXRlLmxhYmVsLHRvOnN0YXRlLnN0YXRlc1tpXS5sYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDpzdGF0ZS5zdGF0ZXNbaV0udGVybWluYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udDoge2FsaWduOiAnbWlkZGxlJ30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyb3dzOid0byd9KTtcbiAgICAgICAgICAgICAgICBidWlsZEluZGV4KHN0YXRlLnN0YXRlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYnVpbGRJbmRleChzdGF0ZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZXM6IG5vZGVzLFxuICAgICAgICBlZGdlczogZWRnZXNcbiAgICB9O1xufVxuXG5EaWFncmFtLmRyYXdGcm9tRGF0YSA9IGZ1bmN0aW9uKG5vZGVzLGVkZ2VzLGNvbnRhaW5lcikge1xuICAgIHZhciBuZXR3b3JrID0gbmV3IHZpcy5OZXR3b3JrKGNvbnRhaW5lciwgXG4gICAgICAgIHtub2Rlczpub2RlcyxlZGdlczplZGdlc30sIHt9KTtcbiAgICByZXR1cm4gbmV0d29yaztcbn1cblxuRGlhZ3JhbS5kcmF3U3RhdGVEaWFncmFtID0gZnVuY3Rpb24oc3RhdGUsY29udGFpbmVyKSB7XG4gICAgLy8gZmlyc3QgYnVpbGQgbm9kZXMgdmFyaWFibGVcbiAgICB2YXIgZGF0YSA9IERpYWdyYW0uYnVpbGREYXRhKHN0YXRlKTtcbiAgICBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICB2YXIgbmV0d29yayA9IG5ldyB2aXMuTmV0d29yayhjb250YWluZXIsIGRhdGEsIHt9KTtcbiAgICByZXR1cm4gbmV0d29yaztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEaWFncmFtO1xuIiwidmFyIFN0YXRlID0gcmVxdWlyZShcIi4vU3RhdGUuanNcIik7XG5cbmZ1bmN0aW9uIEdyYW1tYXIodGVybWluYWxzLCBydWxlcykge1xuICAgIHRoaXMudGVybWluYWxzID0gW107XG4gICAgdGhpcy5ydWxlcyA9IHt9O1xuICAgIHRoaXMudW5yZXNvbHZlZFN0YXRlcyA9IFtdO1xuICAgIHRoaXMuc3RhdGVPcHRpb25zID0ge307XG4gICAgdGhpcy5hZGRUZXJtaW5hbHModGVybWluYWxzIHx8IFtdKTtcbiAgICB0aGlzLmFkZFJ1bGVzKHJ1bGVzIHx8IHt9KTtcbn1cblxuR3JhbW1hci5wcm90b3R5cGUgPSB7XG4gICAgYWRkVGVybWluYWxzIDogZnVuY3Rpb24odGVybWluYWxzKSB7XG4gICAgICAgIHRoaXMudGVybWluYWxzID0gdGhpcy50ZXJtaW5hbHMuY29uY2F0KHRlcm1pbmFscyk7XG4gICAgfSxcbiAgICBhZGRSdWxlcyA6IGZ1bmN0aW9uKHJ1bGVzKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5ydWxlcywgcnVsZXMpO1xuICAgIH0sXG4gICAgaXNUZXJtaW5hbCA6IGZ1bmN0aW9uKHQpIHtcbiAgICBcdFx0cmV0dXJuIHRoaXMudGVybWluYWxzLmluZGV4T2YodCkgPiAtMTtcbiAgICB9LFxuICAgIGZpcnN0UGFzcyA6IGZ1bmN0aW9uKHJ1bGUscnVsZUxhYmVsKSB7XG4gICAgICAgIC8vIHdhbnQgdG8gb3V0cHV0IHRoZSBydWxlJ3Mgc3RhdGVzLCBvbmUgZm9yIGVhY2ggb3B0aW9uXG4gICAgICAgIC8vIGFuZCByZW1lbWJlciB3aGVyZSB0byBpbnNlcnQgb3RoZXIgcnVsZXMnIHN0YXRlc1xuICAgICAgICAvLyBydWxlIGlzIGFuIGFycmF5IG9mIG9wdGlvbnNcbiAgICAgICAgZm9yKHZhciBpID0gMCwgcmxlbiA9IHJ1bGUubGVuZ3RoLCBvcHRpb24sIGosIHMsIGxzLCBycz1bXTtcbiAgICAgICAgICAgIGkgPCBybGVuOyBpKyspIHtcbiAgICAgICAgICAgIG9wdGlvbiA9IHJ1bGVbaV07XG4gICAgICAgICAgICAvLyBvcHRpb24gaXMgYW4gYXJyYXkgb2YgdGVybWluYWxzIGFuZCBydWxlIG5hbWVzXG4gICAgICAgICAgICAvLyB3YW50IHRvIGdvIHRocm91Z2ggdGhlbSBpbiByZXZlcnNlIG9yZGVyXG4gICAgICAgICAgICBqID0gb3B0aW9uLmxlbmd0aDtcbiAgICAgICAgICAgIGxzID0gW107XG4gICAgICAgICAgICB3aGlsZShqLS0pIHtcbiAgICAgICAgICAgICAgICBzID0gbmV3IFN0YXRlKG9wdGlvbltqXSk7XG4gICAgICAgICAgICAgICAgaWYobHNbMF0gJiYgbHNbMF0uZHVtbXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnJlc29sdmVkU3RhdGVzLnB1c2goW2xzWzBdLHNdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcy5hZGRTdGF0ZXMobHMpO1xuICAgICAgICAgICAgICAgIGxzID0gW3NdO1xuICAgICAgICAgICAgICAgIGlmKCF0aGlzLmlzVGVybWluYWwob3B0aW9uW2pdKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZW1lbWJlciB0byBwdXQgaW4gdGhlIGNvcnJlY3Qgc3RhdGVzIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgIHMuZHVtbXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJzID0gU3RhdGUubWVyZ2UocnMsbHMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGVPcHRpb25zW3J1bGVMYWJlbF0gPSBycztcbiAgICAgICAgcmV0dXJuIHJzO1xuICAgIH0sXG4gICAgYnVpbGQgOiBmdW5jdGlvbihzdGFydFN5bWJvbCkge1xuICAgICAgICB2YXIgcmV0O1xuICAgICAgICAvLyBlYWNoIHJ1bGUgbmVlZHMgdG8gaGF2ZSBpdCdzIGZpcnN0IHBhc3NcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5ydWxlcykuZm9yRWFjaChmdW5jdGlvbihydWxlTGFiZWwpe1xuICAgICAgICAgICAgdGhpcy5maXJzdFBhc3ModGhpcy5ydWxlc1tydWxlTGFiZWxdLHJ1bGVMYWJlbCk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnVucmVzb2x2ZWRTdGF0ZXMpO1xuICAgICAgICAvLyBub3cgbmVlZCB0byBnbyB0aHJvdWdoIGFsbCB0aGUgdW5yZXNvbHZlZCBzdGF0ZXMgYW5kXG4gICAgICAgIC8vIHJlcGxhY2UgdGhlbSB3aXRoIHRoZSBvdGhlciBydWxlcycgc3RhdGVzXG4gICAgICAgIGZvcih2YXIgaSA9IDAsIHVsZW4gPSB0aGlzLnVucmVzb2x2ZWRTdGF0ZXMubGVuZ3RoLCBkdW1teTtcbiAgICAgICAgICAgIGkgPCB1bGVuOyBpKyspIHtcbiAgICAgICAgICAgIGR1bW15ID0gdGhpcy51bnJlc29sdmVkU3RhdGVzW2ldO1xuICAgICAgICAgICAgLy8gZHVtbXlbMF0gaXMgdGhlIGR1bW15IHN0YXRlIHdoaWNoIHN0b3JlcyB0aGUgc3RhdGVzXG4gICAgICAgICAgICAvLyB0aGF0IGNvbWUgYWZ0ZXIgdGhlIG5lc3RlZCBzdGF0ZSBoYXMgYmVlbiBhYnNvcnBlZFxuICAgICAgICAgICAgLy8gZHVtbXlbMV0gaXMgdGhlIHN0YXRlIHRoYXQgY29tZXMgYmVmb3JlIHRoZSBkdW1teVxuICAgICAgICAgICAgLy8gZWFjaCBvZiB0aGUgc3RhdGUgb3B0aW9ucycgbGFzdCBzdGF0ZXNcbiAgICAgICAgICAgIC8vIG5lZWRzIHRvIGhhdmUgdGhlIHNhbWUgc3RhdGVzIGFzIHRoZSBkdW1teSBzdGF0ZVxuICAgICAgICAgICAgdmFyIG5ld1N0YXRlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZU9wdGlvbnNbZHVtbXlbMF0udGVybWluYWxdLmZvckVhY2goZnVuY3Rpb24ocyl7XG4gICAgICAgICAgICAgICAgbmV3U3RhdGVzLnB1c2gocy5kZWVwQ29weShkdW1teVswXSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhuZXdTdGF0ZXMpO1xuICAgICAgICAgICAgU3RhdGUuYWRkVG9FbmQobmV3U3RhdGVzLCBkdW1teVswXS5zdGF0ZXMpO1xuICAgICAgICAgICAgZHVtbXlbMV0uYWRkU3RhdGVzKG5ld1N0YXRlcyk7XG4gICAgICAgICAgICBpZihkdW1teVswXS50ZXJtaW5hbCA9PT0gc3RhcnRTeW1ib2wpIHtcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGJ1aWxkVHJhdmVyc2UgOiBmdW5jdGlvbihzdGFydFN5bWJvbCxyUCxlbmRTdGF0ZXMpIHtcbiAgICAgICAgdmFyIHJQID0gclAgfHwge30sXG4gICAgICAgICAgICBlbmRTdGF0ZXMgPSBlbmRTdGF0ZXMgfHwgW10sXG4gICAgICAgICAgICBydWxlID0gdGhpcy5zdGF0ZU9wdGlvbnNbc3RhcnRTeW1ib2xdLFxuICAgICAgICAgICAgcmV0U3RhdGUgPSBuZXcgU3RhdGUoXCJcIixzdGFydFN5bWJvbCksXG4gICAgICAgICAgICBscyA9IFtdO1xuICAgICAgICByUFtzdGFydFN5bWJvbF0gPSByZXRTdGF0ZTtcbiAgICAgICAgcnVsZS5mb3JFYWNoKGZ1bmN0aW9uKHN0YXRlKXtcbiAgICAgICAgICAgIC8vIGdvIHRocm91Z2ggc3RhdGVzXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBmdW5jdGlvbiBwcm9jZXNzU3RhdGUoc3RhdGUsbGFzdFN0YXRlLGxpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coc3RhdGUsbGFzdFN0YXRlKTtcbiAgICAgICAgICAgICAgICBpZihzdGF0ZS5kdW1teSkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0U3RhdGUuc3RhdGVzLnNwbGljZShsaSwxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIHJQW3N0YXRlLnRlcm1pbmFsXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFN0YXRlLmFkZFN0YXRlcyhzZWxmLmJ1aWxkVHJhdmVyc2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUudGVybWluYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgclAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuc3RhdGVzXG4gICAgICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN0YXRlLnRlcm1pbmFsID09PSBzdGFydFN5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxzLnB1c2gobGFzdFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RTdGF0ZS5hZGRTdGF0ZXMoclBbc3RhdGUudGVybWluYWxdLnN0YXRlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RTdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgICAgICAgICBpZihzdGF0ZS5zdGF0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zdGF0ZXMgPSBlbmRTdGF0ZXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zdGF0ZXMuZm9yRWFjaChmdW5jdGlvbihzLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzU3RhdGUocyxzdGF0ZSxpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9jZXNzU3RhdGUoc3RhdGUpO1xuICAgICAgICAgICAgcmV0U3RhdGUuYWRkU3RhdGVzKFtzdGF0ZV0pO1xuICAgICAgICB9LHRoaXMpO1xuICAgICAgICBscy5mb3JFYWNoKGZ1bmN0aW9uKHMpe1xuICAgICAgICAgICAgcy5hZGRTdGF0ZXMoclBbc3RhcnRTeW1ib2xdLnN0YXRlcyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmV0U3RhdGUuc3RhdGVzO1xuICAgIH1cblxuXG59XG5tb2R1bGUuZXhwb3J0cyA9IEdyYW1tYXI7XG4iLCJ2YXIgU3RhdGVDb3VudCA9IDA7XG5cbmZ1bmN0aW9uIHVuaW9uX2FycmF5cyAoeCwgeSkge1xuICAgIHZhciBvYmogPSB7fTtcbiAgICBmb3IgKHZhciBpID0geC5sZW5ndGgtMTsgaSA+PSAwOyAtLSBpKVxuICAgICAgIG9ialt4W2ldXSA9IHhbaV07XG4gICAgZm9yICh2YXIgaSA9IHkubGVuZ3RoLTE7IGkgPj0gMDsgLS0gaSlcbiAgICAgICBvYmpbeVtpXV0gPSB5W2ldO1xuICAgIHZhciByZXMgPSBbXVxuICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgICAgIHJlcy5wdXNoKG9ialtrXSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIFN0YXRlKHRlcm1pbmFsLGxhYmVsKSB7XG5cdFx0dGhpcy50ZXJtaW5hbCA9IHRlcm1pbmFsO1xuXHRcdHRoaXMuc3RhdGVzID0gW107XG4gICAgdGhpcy5sYWJlbCA9IGxhYmVsIHx8IFN0YXRlQ291bnQrKztcbn1cblxuU3RhdGUubWVyZ2UgPSBmdW5jdGlvbihyZXRvcHMsIG9wcykge1xuXHRcdGlmKHR5cGVvZiByZXRvcHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBcdFx0cmV0b3BzID0gW107XG4gICAgfVxuICAgIG9wcy5mb3JFYWNoKGZ1bmN0aW9uKG9wKXtcbiAgICBcdFx0c3QgPSByZXRvcHMuZmluZChmdW5jdGlvbihyb3ApIHtcbiAgICAgICAgXHRcdHJldHVybiByb3AudGVybWluYWwgPT09IG9wLnRlcm1pbmFsO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYodHlwZW9mIHN0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIFx0XHRzdCA9IFN0YXRlLm1lcmdlKHN0LnN0YXRlcywgb3Auc3RhdGVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgXHRcdHJldG9wcy5wdXNoKG9wKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXRvcHM7XG59XG5cblN0YXRlLmFkZFRvRW5kID0gZnVuY3Rpb24odGFyZ2V0cyxpbnNlcnQpIHtcbiAgICBmb3IodmFyIGk9MCxsPXRhcmdldHMubGVuZ3RoOyBpPGw7IGkrKykge1xuICAgICAgICBpZih0YXJnZXRzW2ldLnN0YXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRhcmdldHNbaV0uc3RhdGVzID0gaW5zZXJ0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgU3RhdGUuYWRkVG9FbmQodGFyZ2V0c1tpXS5zdGF0ZXMsaW5zZXJ0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuU3RhdGUucHJvdG90eXBlID0ge1xuXHRhZGRTdGF0ZXMgOiBmdW5jdGlvbihzdGF0ZXMpIHtcblx0XHR0aGlzLnN0YXRlcyA9IFN0YXRlLm1lcmdlKHRoaXMuc3RhdGVzLCBzdGF0ZXMpO1xuICAgIH0sXG4gICAgZGVlcENvcHkgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHMgPSBuZXcgU3RhdGUodGhpcy50ZXJtaW5hbCksXG4gICAgICAgICAgICBvbGRMYWJlbHMgPSB7fTtcbiAgICAgICAgZm9yKHZhciBpPTAsbD10aGlzLnN0YXRlcy5sZW5ndGg7aTxsO2krKykge1xuICAgICAgICAgICAgaWYodHlwZW9mIG9sZExhYmVsc1t0aGlzLnN0YXRlc1tpXS5sYWJlbF0gPT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgICAmJiAhdGhpcy5zdGF0ZXNbaV0uZHVtbXkpIHtcbiAgICAgICAgICAgICAgICBvbGRMYWJlbHNbdGhpcy5zdGF0ZXNbaV0ubGFiZWxdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzLnN0YXRlcy5wdXNoKHRoaXMuc3RhdGVzW2ldLmRlZXBDb3B5KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZTtcbiIsIi8qKlxuICogdmlzLmpzXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYWxtZW5kZS92aXNcbiAqXG4gKiBBIGR5bmFtaWMsIGJyb3dzZXItYmFzZWQgdmlzdWFsaXphdGlvbiBsaWJyYXJ5LlxuICpcbiAqIEB2ZXJzaW9uIDQuMTYuMVxuICogQGRhdGUgICAgMjAxNi0wNC0xOFxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTEtMjAxNiBBbG1lbmRlIEIuViwgaHR0cDovL2FsbWVuZGUuY29tXG4gKlxuICogVmlzLmpzIGlzIGR1YWwgbGljZW5zZWQgdW5kZXIgYm90aFxuICpcbiAqICogVGhlIEFwYWNoZSAyLjAgTGljZW5zZVxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBhbmRcbiAqXG4gKiAqIFRoZSBNSVQgTGljZW5zZVxuICogICBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKlxuICogVmlzLmpzIG1heSBiZSBkaXN0cmlidXRlZCB1bmRlciBlaXRoZXIgbGljZW5zZS5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1widmlzXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcInZpc1wiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxuLyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZVxuLyoqKioqKi8gXHRcdH07XG5cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG5cblxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4gIC8vIEdyYXBoM2RcbiAgdXRpbC5leHRlbmQoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyg3KSk7XG5cbiAgLy8gVGltZWxpbmUgJiBHcmFwaDJkXG4gIHV0aWwuZXh0ZW5kKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oMjQpKTtcblxuICAvLyBOZXR3b3JrXG4gIHV0aWwuZXh0ZW5kKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oNjApKTtcblxuLyoqKi8gfSxcbi8qIDEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuICAvLyB1dGlsaXR5IGZ1bmN0aW9uc1xuXG4gIC8vIGZpcnN0IGNoZWNrIGlmIG1vbWVudC5qcyBpcyBhbHJlYWR5IGxvYWRlZCBpbiB0aGUgYnJvd3NlciB3aW5kb3csIGlmIHNvLFxuICAvLyB1c2UgdGhpcyBpbnN0YW5jZS4gRWxzZSwgbG9hZCB2aWEgY29tbW9uanMuXG5cbiAgdmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4gIHZhciB1dWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxuICAvKipcbiAgICogVGVzdCB3aGV0aGVyIGdpdmVuIG9iamVjdCBpcyBhIG51bWJlclxuICAgKiBAcGFyYW0geyp9IG9iamVjdFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBpc051bWJlclxuICAgKi9cbiAgZXhwb3J0cy5pc051bWJlciA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgTnVtYmVyIHx8IHR5cGVvZiBvYmplY3QgPT0gJ251bWJlcic7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBldmVyeXRoaW5nIGluIHRoZSBET00gb2JqZWN0XG4gICAqIEBwYXJhbSBET01vYmplY3RcbiAgICovXG4gIGV4cG9ydHMucmVjdXJzaXZlRE9NRGVsZXRlID0gZnVuY3Rpb24gKERPTW9iamVjdCkge1xuICAgIGlmIChET01vYmplY3QpIHtcbiAgICAgIHdoaWxlIChET01vYmplY3QuaGFzQ2hpbGROb2RlcygpID09PSB0cnVlKSB7XG4gICAgICAgIGV4cG9ydHMucmVjdXJzaXZlRE9NRGVsZXRlKERPTW9iamVjdC5maXJzdENoaWxkKTtcbiAgICAgICAgRE9Nb2JqZWN0LnJlbW92ZUNoaWxkKERPTW9iamVjdC5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIHRoaXMgZnVuY3Rpb24gZ2l2ZXMgeW91IGEgcmFuZ2UgYmV0d2VlbiAwIGFuZCAxIGJhc2VkIG9uIHRoZSBtaW4gYW5kIG1heCB2YWx1ZXMgaW4gdGhlIHNldCwgdGhlIHRvdGFsIHN1bSBvZiBhbGwgdmFsdWVzIGFuZCB0aGUgY3VycmVudCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIG1pblxuICAgKiBAcGFyYW0gbWF4XG4gICAqIEBwYXJhbSB0b3RhbFxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGV4cG9ydHMuZ2l2ZVJhbmdlID0gZnVuY3Rpb24gKG1pbiwgbWF4LCB0b3RhbCwgdmFsdWUpIHtcbiAgICBpZiAobWF4ID09IG1pbikge1xuICAgICAgcmV0dXJuIDAuNTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNjYWxlID0gMSAvIChtYXggLSBtaW4pO1xuICAgICAgcmV0dXJuIE1hdGgubWF4KDAsICh2YWx1ZSAtIG1pbikgKiBzY2FsZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUZXN0IHdoZXRoZXIgZ2l2ZW4gb2JqZWN0IGlzIGEgc3RyaW5nXG4gICAqIEBwYXJhbSB7Kn0gb2JqZWN0XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGlzU3RyaW5nXG4gICAqL1xuICBleHBvcnRzLmlzU3RyaW5nID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBTdHJpbmcgfHwgdHlwZW9mIG9iamVjdCA9PSAnc3RyaW5nJztcbiAgfTtcblxuICAvKipcbiAgICogVGVzdCB3aGV0aGVyIGdpdmVuIG9iamVjdCBpcyBhIERhdGUsIG9yIGEgU3RyaW5nIGNvbnRhaW5pbmcgYSBEYXRlXG4gICAqIEBwYXJhbSB7RGF0ZSB8IFN0cmluZ30gb2JqZWN0XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGlzRGF0ZVxuICAgKi9cbiAgZXhwb3J0cy5pc0RhdGUgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZXhwb3J0cy5pc1N0cmluZyhvYmplY3QpKSB7XG4gICAgICAvLyB0ZXN0IHdoZXRoZXIgdGhpcyBzdHJpbmcgY29udGFpbnMgYSBkYXRlXG4gICAgICB2YXIgbWF0Y2ggPSBBU1BEYXRlUmVnZXguZXhlYyhvYmplY3QpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmICghaXNOYU4oRGF0ZS5wYXJzZShvYmplY3QpKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHNlbWkgVVVJRFxuICAgKiBzb3VyY2U6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzEwNTA3NC8xMjYyNzUzXG4gICAqIEByZXR1cm4ge1N0cmluZ30gdXVpZFxuICAgKi9cbiAgZXhwb3J0cy5yYW5kb21VVUlEID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB1dWlkLnY0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIGFzc2lnbiBhbGwga2V5cyBvZiBhbiBvYmplY3QgdGhhdCBhcmUgbm90IG5lc3RlZCBvYmplY3RzIHRvIGEgY2VydGFpbiB2YWx1ZSAodXNlZCBmb3IgY29sb3Igb2JqZWN0cykuXG4gICAqIEBwYXJhbSBvYmpcbiAgICogQHBhcmFtIHZhbHVlXG4gICAqL1xuICBleHBvcnRzLmFzc2lnbkFsbEtleXMgPSBmdW5jdGlvbiAob2JqLCB2YWx1ZSkge1xuICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgIGlmIChfdHlwZW9mKG9ialtwcm9wXSkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgb2JqW3Byb3BdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpbGwgYW4gb2JqZWN0IHdpdGggYSBwb3NzaWJseSBwYXJ0aWFsbHkgZGVmaW5lZCBvdGhlciBvYmplY3QuIE9ubHkgY29waWVzIHZhbHVlcyBpZiB0aGUgYSBvYmplY3QgaGFzIGFuIG9iamVjdCByZXF1aXJpbmcgdmFsdWVzLlxuICAgKiBUaGF0IG1lYW5zIGFuIG9iamVjdCBpcyBub3QgY3JlYXRlZCBvbiBhIHByb3BlcnR5IGlmIG9ubHkgdGhlIGIgb2JqZWN0IGhhcyBpdC5cbiAgICogQHBhcmFtIG9ialxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICovXG4gIGV4cG9ydHMuZmlsbElmRGVmaW5lZCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGFsbG93RGVsZXRpb24gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1syXTtcblxuICAgIGZvciAodmFyIHByb3AgaW4gYSkge1xuICAgICAgaWYgKGJbcHJvcF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoX3R5cGVvZihiW3Byb3BdKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBpZiAoKGJbcHJvcF0gPT09IHVuZGVmaW5lZCB8fCBiW3Byb3BdID09PSBudWxsKSAmJiBhW3Byb3BdICE9PSB1bmRlZmluZWQgJiYgYWxsb3dEZWxldGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgZGVsZXRlIGFbcHJvcF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFbcHJvcF0gPSBiW3Byb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoX3R5cGVvZihhW3Byb3BdKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuZmlsbElmRGVmaW5lZChhW3Byb3BdLCBiW3Byb3BdLCBhbGxvd0RlbGV0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4dGVuZCBvYmplY3QgYSB3aXRoIHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiIG9yIGEgc2VyaWVzIG9mIG9iamVjdHNcbiAgICogT25seSBwcm9wZXJ0aWVzIHdpdGggZGVmaW5lZCB2YWx1ZXMgYXJlIGNvcGllZFxuICAgKiBAcGFyYW0ge09iamVjdH0gYVxuICAgKiBAcGFyYW0gey4uLiBPYmplY3R9IGJcbiAgICogQHJldHVybiB7T2JqZWN0fSBhXG4gICAqL1xuICBleHBvcnRzLnByb3RvRXh0ZW5kID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG90aGVyID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBvdGhlcikge1xuICAgICAgICBhW3Byb3BdID0gb3RoZXJbcHJvcF07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFeHRlbmQgb2JqZWN0IGEgd2l0aCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYiBvciBhIHNlcmllcyBvZiBvYmplY3RzXG4gICAqIE9ubHkgcHJvcGVydGllcyB3aXRoIGRlZmluZWQgdmFsdWVzIGFyZSBjb3BpZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IGFcbiAgICogQHBhcmFtIHsuLi4gT2JqZWN0fSBiXG4gICAqIEByZXR1cm4ge09iamVjdH0gYVxuICAgKi9cbiAgZXhwb3J0cy5leHRlbmQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgb3RoZXIgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHZhciBwcm9wIGluIG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlci5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgIGFbcHJvcF0gPSBvdGhlcltwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfTtcblxuICAvKipcbiAgICogRXh0ZW5kIG9iamVjdCBhIHdpdGggc2VsZWN0ZWQgcHJvcGVydGllcyBvZiBvYmplY3QgYiBvciBhIHNlcmllcyBvZiBvYmplY3RzXG4gICAqIE9ubHkgcHJvcGVydGllcyB3aXRoIGRlZmluZWQgdmFsdWVzIGFyZSBjb3BpZWRcbiAgICogQHBhcmFtIHtBcnJheS48U3RyaW5nPn0gcHJvcHNcbiAgICogQHBhcmFtIHtPYmplY3R9IGFcbiAgICogQHBhcmFtIHtPYmplY3R9IGJcbiAgICogQHJldHVybiB7T2JqZWN0fSBhXG4gICAqL1xuICBleHBvcnRzLnNlbGVjdGl2ZUV4dGVuZCA9IGZ1bmN0aW9uIChwcm9wcywgYSwgYikge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQXJyYXkgd2l0aCBwcm9wZXJ0eSBuYW1lcyBleHBlY3RlZCBhcyBmaXJzdCBhcmd1bWVudCcpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgb3RoZXIgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgcHJvcHMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgdmFyIHByb3AgPSBwcm9wc1twXTtcbiAgICAgICAgaWYgKG90aGVyLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgYVtwcm9wXSA9IG90aGVyW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFeHRlbmQgb2JqZWN0IGEgd2l0aCBzZWxlY3RlZCBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiIG9yIGEgc2VyaWVzIG9mIG9iamVjdHNcbiAgICogT25seSBwcm9wZXJ0aWVzIHdpdGggZGVmaW5lZCB2YWx1ZXMgYXJlIGNvcGllZFxuICAgKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fSBwcm9wc1xuICAgKiBAcGFyYW0ge09iamVjdH0gYVxuICAgKiBAcGFyYW0ge09iamVjdH0gYlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGFcbiAgICovXG4gIGV4cG9ydHMuc2VsZWN0aXZlRGVlcEV4dGVuZCA9IGZ1bmN0aW9uIChwcm9wcywgYSwgYikge1xuICAgIHZhciBhbGxvd0RlbGV0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA8PSAzIHx8IGFyZ3VtZW50c1szXSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBhcmd1bWVudHNbM107XG5cbiAgICAvLyBUT0RPOiBhZGQgc3VwcG9ydCBmb3IgQXJyYXlzIHRvIGRlZXBFeHRlbmRcbiAgICBpZiAoQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXlzIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IGRlZXBFeHRlbmQnKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvdGhlciA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgcHJvcHMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgdmFyIHByb3AgPSBwcm9wc1twXTtcbiAgICAgICAgaWYgKG90aGVyLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgaWYgKGJbcHJvcF0gJiYgYltwcm9wXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoYVtwcm9wXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGFbcHJvcF0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhW3Byb3BdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICAgICAgZXhwb3J0cy5kZWVwRXh0ZW5kKGFbcHJvcF0sIGJbcHJvcF0sIGZhbHNlLCBhbGxvd0RlbGV0aW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChiW3Byb3BdID09PSBudWxsICYmIGFbcHJvcF0gIT09IHVuZGVmaW5lZCAmJiBhbGxvd0RlbGV0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGFbcHJvcF07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYVtwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYltwcm9wXSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5cyBhcmUgbm90IHN1cHBvcnRlZCBieSBkZWVwRXh0ZW5kJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChiW3Byb3BdID09PSBudWxsICYmIGFbcHJvcF0gIT09IHVuZGVmaW5lZCAmJiBhbGxvd0RlbGV0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBhW3Byb3BdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYVtwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFeHRlbmQgb2JqZWN0IGEgd2l0aCBzZWxlY3RlZCBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiIG9yIGEgc2VyaWVzIG9mIG9iamVjdHNcbiAgICogT25seSBwcm9wZXJ0aWVzIHdpdGggZGVmaW5lZCB2YWx1ZXMgYXJlIGNvcGllZFxuICAgKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fSBwcm9wc1xuICAgKiBAcGFyYW0ge09iamVjdH0gYVxuICAgKiBAcGFyYW0ge09iamVjdH0gYlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGFcbiAgICovXG4gIGV4cG9ydHMuc2VsZWN0aXZlTm90RGVlcEV4dGVuZCA9IGZ1bmN0aW9uIChwcm9wcywgYSwgYikge1xuICAgIHZhciBhbGxvd0RlbGV0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA8PSAzIHx8IGFyZ3VtZW50c1szXSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBhcmd1bWVudHNbM107XG5cbiAgICAvLyBUT0RPOiBhZGQgc3VwcG9ydCBmb3IgQXJyYXlzIHRvIGRlZXBFeHRlbmRcbiAgICBpZiAoQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXlzIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IGRlZXBFeHRlbmQnKTtcbiAgICB9XG4gICAgZm9yICh2YXIgcHJvcCBpbiBiKSB7XG4gICAgICBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICBpZiAocHJvcHMuaW5kZXhPZihwcm9wKSA9PSAtMSkge1xuICAgICAgICAgIGlmIChiW3Byb3BdICYmIGJbcHJvcF0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICAgICAgaWYgKGFbcHJvcF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBhW3Byb3BdID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYVtwcm9wXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgICAgICAgIGV4cG9ydHMuZGVlcEV4dGVuZChhW3Byb3BdLCBiW3Byb3BdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChiW3Byb3BdID09PSBudWxsICYmIGFbcHJvcF0gIT09IHVuZGVmaW5lZCAmJiBhbGxvd0RlbGV0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGFbcHJvcF07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYVtwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYltwcm9wXSkpIHtcbiAgICAgICAgICAgIGFbcHJvcF0gPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYltwcm9wXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBhW3Byb3BdLnB1c2goYltwcm9wXVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChiW3Byb3BdID09PSBudWxsICYmIGFbcHJvcF0gIT09IHVuZGVmaW5lZCAmJiBhbGxvd0RlbGV0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBhW3Byb3BdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYVtwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZWVwIGV4dGVuZCBhbiBvYmplY3QgYSB3aXRoIHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBiXG4gICAqIEBwYXJhbSBbQm9vbGVhbl0gcHJvdG9FeHRlbmQgLS0+IG9wdGlvbmFsIHBhcmFtZXRlci4gSWYgdHJ1ZSwgdGhlIHByb3RvdHlwZSB2YWx1ZXMgd2lsbCBhbHNvIGJlIGV4dGVuZGVkLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaWUuIHRoZSBvcHRpb25zIG9iamVjdHMgdGhhdCBpbmhlcml0IGZyb20gb3RoZXJzIHdpbGwgYWxzbyBnZXQgdGhlIGluaGVyaXRlZCBvcHRpb25zKVxuICAgKiBAcGFyYW0gW0Jvb2xlYW5dIGdsb2JhbCAgICAgIC0tPiBvcHRpb25hbCBwYXJhbWV0ZXIuIElmIHRydWUsIHRoZSB2YWx1ZXMgb2YgZmllbGRzIHRoYXQgYXJlIG51bGwgd2lsbCBub3QgZGVsZXRlZFxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKi9cbiAgZXhwb3J0cy5kZWVwRXh0ZW5kID0gZnVuY3Rpb24gKGEsIGIsIHByb3RvRXh0ZW5kLCBhbGxvd0RlbGV0aW9uKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBiKSB7XG4gICAgICBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwcm9wKSB8fCBwcm90b0V4dGVuZCA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAoYltwcm9wXSAmJiBiW3Byb3BdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICBpZiAoYVtwcm9wXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhW3Byb3BdID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhW3Byb3BdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuZGVlcEV4dGVuZChhW3Byb3BdLCBiW3Byb3BdLCBwcm90b0V4dGVuZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChiW3Byb3BdID09PSBudWxsICYmIGFbcHJvcF0gIT09IHVuZGVmaW5lZCAmJiBhbGxvd0RlbGV0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBhW3Byb3BdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYVtwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYltwcm9wXSkpIHtcbiAgICAgICAgICBhW3Byb3BdID0gW107XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiW3Byb3BdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhW3Byb3BdLnB1c2goYltwcm9wXVtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChiW3Byb3BdID09PSBudWxsICYmIGFbcHJvcF0gIT09IHVuZGVmaW5lZCAmJiBhbGxvd0RlbGV0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICBkZWxldGUgYVtwcm9wXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYVtwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUZXN0IHdoZXRoZXIgYWxsIGVsZW1lbnRzIGluIHR3byBhcnJheXMgYXJlIGVxdWFsLlxuICAgKiBAcGFyYW0ge0FycmF5fSBhXG4gICAqIEBwYXJhbSB7QXJyYXl9IGJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGJvdGggYXJyYXlzIGhhdmUgdGhlIHNhbWUgbGVuZ3RoIGFuZCBzYW1lXG4gICAqICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLlxuICAgKi9cbiAgZXhwb3J0cy5lcXVhbEFycmF5ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoYVtpXSAhPSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYW4gb2JqZWN0IHRvIGFub3RoZXIgdHlwZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW4gfCBOdW1iZXIgfCBTdHJpbmcgfCBEYXRlIHwgTW9tZW50IHwgTnVsbCB8IHVuZGVmaW5lZH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nIHwgdW5kZWZpbmVkfSB0eXBlICAgTmFtZSBvZiB0aGUgdHlwZS4gQXZhaWxhYmxlIHR5cGVzOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdCb29sZWFuJywgJ051bWJlcicsICdTdHJpbmcnLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdEYXRlJywgJ01vbWVudCcsIElTT0RhdGUnLCAnQVNQRGF0ZScuXG4gICAqIEByZXR1cm4geyp9IG9iamVjdFxuICAgKiBAdGhyb3dzIEVycm9yXG4gICAqL1xuICBleHBvcnRzLmNvbnZlcnQgPSBmdW5jdGlvbiAob2JqZWN0LCB0eXBlKSB7XG4gICAgdmFyIG1hdGNoO1xuXG4gICAgaWYgKG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAob2JqZWN0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICAgIGlmICghKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykgJiYgISh0eXBlIGluc3RhbmNlb2YgU3RyaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUeXBlIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICAvL25vaW5zcGVjdGlvbiBGYWxsdGhyb3VnaEluU3dpdGNoU3RhdGVtZW50SlNcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnQm9vbGVhbic6XG4gICAgICAgIHJldHVybiBCb29sZWFuKG9iamVjdCk7XG5cbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgICByZXR1cm4gTnVtYmVyKG9iamVjdC52YWx1ZU9mKCkpO1xuXG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAnU3RyaW5nJzpcbiAgICAgICAgcmV0dXJuIFN0cmluZyhvYmplY3QpO1xuXG4gICAgICBjYXNlICdEYXRlJzpcbiAgICAgICAgaWYgKGV4cG9ydHMuaXNOdW1iZXIob2JqZWN0KSkge1xuICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG9iamVjdC52YWx1ZU9mKCkpO1xuICAgICAgICB9IGVsc2UgaWYgKG1vbWVudC5pc01vbWVudChvYmplY3QpKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG9iamVjdC52YWx1ZU9mKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHBvcnRzLmlzU3RyaW5nKG9iamVjdCkpIHtcbiAgICAgICAgICBtYXRjaCA9IEFTUERhdGVSZWdleC5leGVjKG9iamVjdCk7XG4gICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAvLyBvYmplY3QgaXMgYW4gQVNQIGRhdGVcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShOdW1iZXIobWF0Y2hbMV0pKTsgLy8gcGFyc2UgbnVtYmVyXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG1vbWVudChvYmplY3QpLnRvRGF0ZSgpOyAvLyBwYXJzZSBzdHJpbmdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnZlcnQgb2JqZWN0IG9mIHR5cGUgJyArIGV4cG9ydHMuZ2V0VHlwZShvYmplY3QpICsgJyB0byB0eXBlIERhdGUnKTtcbiAgICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ01vbWVudCc6XG4gICAgICAgIGlmIChleHBvcnRzLmlzTnVtYmVyKG9iamVjdCkpIHtcbiAgICAgICAgICByZXR1cm4gbW9tZW50KG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICByZXR1cm4gbW9tZW50KG9iamVjdC52YWx1ZU9mKCkpO1xuICAgICAgICB9IGVsc2UgaWYgKG1vbWVudC5pc01vbWVudChvYmplY3QpKSB7XG4gICAgICAgICAgcmV0dXJuIG1vbWVudChvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHBvcnRzLmlzU3RyaW5nKG9iamVjdCkpIHtcbiAgICAgICAgICBtYXRjaCA9IEFTUERhdGVSZWdleC5leGVjKG9iamVjdCk7XG4gICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAvLyBvYmplY3QgaXMgYW4gQVNQIGRhdGVcbiAgICAgICAgICAgIHJldHVybiBtb21lbnQoTnVtYmVyKG1hdGNoWzFdKSk7IC8vIHBhcnNlIG51bWJlclxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBtb21lbnQob2JqZWN0KTsgLy8gcGFyc2Ugc3RyaW5nXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IG9iamVjdCBvZiB0eXBlICcgKyBleHBvcnRzLmdldFR5cGUob2JqZWN0KSArICcgdG8gdHlwZSBEYXRlJyk7XG4gICAgICAgICAgfVxuXG4gICAgICBjYXNlICdJU09EYXRlJzpcbiAgICAgICAgaWYgKGV4cG9ydHMuaXNOdW1iZXIob2JqZWN0KSkge1xuICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShvYmplY3QpO1xuICAgICAgICB9IGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0LnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSBpZiAobW9tZW50LmlzTW9tZW50KG9iamVjdCkpIHtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0LnRvRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXhwb3J0cy5pc1N0cmluZyhvYmplY3QpKSB7XG4gICAgICAgICAgbWF0Y2ggPSBBU1BEYXRlUmVnZXguZXhlYyhvYmplY3QpO1xuICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgLy8gb2JqZWN0IGlzIGFuIEFTUCBkYXRlXG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoTnVtYmVyKG1hdGNoWzFdKSkudG9JU09TdHJpbmcoKTsgLy8gcGFyc2UgbnVtYmVyXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG9iamVjdCkudG9JU09TdHJpbmcoKTsgLy8gcGFyc2Ugc3RyaW5nXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IG9iamVjdCBvZiB0eXBlICcgKyBleHBvcnRzLmdldFR5cGUob2JqZWN0KSArICcgdG8gdHlwZSBJU09EYXRlJyk7XG4gICAgICAgICAgfVxuXG4gICAgICBjYXNlICdBU1BEYXRlJzpcbiAgICAgICAgaWYgKGV4cG9ydHMuaXNOdW1iZXIob2JqZWN0KSkge1xuICAgICAgICAgIHJldHVybiAnL0RhdGUoJyArIG9iamVjdCArICcpLyc7XG4gICAgICAgIH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgIHJldHVybiAnL0RhdGUoJyArIG9iamVjdC52YWx1ZU9mKCkgKyAnKS8nO1xuICAgICAgICB9IGVsc2UgaWYgKGV4cG9ydHMuaXNTdHJpbmcob2JqZWN0KSkge1xuICAgICAgICAgIG1hdGNoID0gQVNQRGF0ZVJlZ2V4LmV4ZWMob2JqZWN0KTtcbiAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAvLyBvYmplY3QgaXMgYW4gQVNQIGRhdGVcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUoTnVtYmVyKG1hdGNoWzFdKSkudmFsdWVPZigpOyAvLyBwYXJzZSBudW1iZXJcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBEYXRlKG9iamVjdCkudmFsdWVPZigpOyAvLyBwYXJzZSBzdHJpbmdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gJy9EYXRlKCcgKyB2YWx1ZSArICcpLyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29udmVydCBvYmplY3Qgb2YgdHlwZSAnICsgZXhwb3J0cy5nZXRUeXBlKG9iamVjdCkgKyAnIHRvIHR5cGUgQVNQRGF0ZScpO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB0eXBlIFwiJyArIHR5cGUgKyAnXCInKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gcGFyc2UgQVNQLk5ldCBEYXRlIHBhdHRlcm4sXG4gIC8vIGZvciBleGFtcGxlICcvRGF0ZSgxMTk4OTA4NzE3MDU2KS8nIG9yICcvRGF0ZSgxMTk4OTA4NzE3MDU2LTA3MDApLydcbiAgLy8gY29kZSBmcm9tIGh0dHA6Ly9tb21lbnRqcy5jb20vXG4gIHZhciBBU1BEYXRlUmVnZXggPSAvXlxcLz9EYXRlXFwoKFxcLT9cXGQrKS9pO1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHR5cGUgb2YgYW4gb2JqZWN0LCBmb3IgZXhhbXBsZSBleHBvcnRzLmdldFR5cGUoW10pIHJldHVybnMgJ0FycmF5J1xuICAgKiBAcGFyYW0geyp9IG9iamVjdFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IHR5cGVcbiAgICovXG4gIGV4cG9ydHMuZ2V0VHlwZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBvYmplY3QgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9iamVjdCk7XG5cbiAgICBpZiAodHlwZSA9PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKG9iamVjdCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEJvb2xlYW4pIHtcbiAgICAgICAgcmV0dXJuICdCb29sZWFuJztcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBOdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuICdOdW1iZXInO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICByZXR1cm4gJ1N0cmluZyc7XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiAnQXJyYXknO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICdEYXRlJztcbiAgICAgIH1cbiAgICAgIHJldHVybiAnT2JqZWN0JztcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiAnTnVtYmVyJztcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICByZXR1cm4gJ0Jvb2xlYW4nO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuICdTdHJpbmcnO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gZXh0ZW5kIGFuIGFycmF5IGFuZCBjb3B5IGl0LiBUaGlzIGlzIHVzZWQgdG8gcHJvcGFnYXRlIHBhdGhzIHJlY3Vyc2l2ZWx5LlxuICAgKlxuICAgKiBAcGFyYW0gYXJyXG4gICAqIEBwYXJhbSBuZXdWYWx1ZVxuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqL1xuICBleHBvcnRzLmNvcHlBbmRFeHRlbmRBcnJheSA9IGZ1bmN0aW9uIChhcnIsIG5ld1ZhbHVlKSB7XG4gICAgdmFyIG5ld0FyciA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBuZXdBcnIucHVzaChhcnJbaV0pO1xuICAgIH1cbiAgICBuZXdBcnIucHVzaChuZXdWYWx1ZSk7XG4gICAgcmV0dXJuIG5ld0FycjtcbiAgfTtcblxuICAvKipcbiAgICogVXNlZCB0byBleHRlbmQgYW4gYXJyYXkgYW5kIGNvcHkgaXQuIFRoaXMgaXMgdXNlZCB0byBwcm9wYWdhdGUgcGF0aHMgcmVjdXJzaXZlbHkuXG4gICAqXG4gICAqIEBwYXJhbSBhcnJcbiAgICogQHBhcmFtIG5ld1ZhbHVlXG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICovXG4gIGV4cG9ydHMuY29weUFycmF5ID0gZnVuY3Rpb24gKGFycikge1xuICAgIHZhciBuZXdBcnIgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgbmV3QXJyLnB1c2goYXJyW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0FycjtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlldmUgdGhlIGFic29sdXRlIGxlZnQgdmFsdWUgb2YgYSBET00gZWxlbWVudFxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW0gICAgICAgIEEgZG9tIGVsZW1lbnQsIGZvciBleGFtcGxlIGEgZGl2XG4gICAqIEByZXR1cm4ge251bWJlcn0gbGVmdCAgICAgICAgVGhlIGFic29sdXRlIGxlZnQgcG9zaXRpb24gb2YgdGhpcyBlbGVtZW50XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gdGhlIGJyb3dzZXIgcGFnZS5cbiAgICovXG4gIGV4cG9ydHMuZ2V0QWJzb2x1dGVMZWZ0ID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICByZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuICB9O1xuXG4gIGV4cG9ydHMuZ2V0QWJzb2x1dGVSaWdodCA9IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgcmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkucmlnaHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSBhYnNvbHV0ZSB0b3AgdmFsdWUgb2YgYSBET00gZWxlbWVudFxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW0gICAgICAgIEEgZG9tIGVsZW1lbnQsIGZvciBleGFtcGxlIGEgZGl2XG4gICAqIEByZXR1cm4ge251bWJlcn0gdG9wICAgICAgICBUaGUgYWJzb2x1dGUgdG9wIHBvc2l0aW9uIG9mIHRoaXMgZWxlbWVudFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIHRoZSBicm93c2VyIHBhZ2UuXG4gICAqL1xuICBleHBvcnRzLmdldEFic29sdXRlVG9wID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICByZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gIH07XG5cbiAgLyoqXG4gICAqIGFkZCBhIGNsYXNzTmFtZSB0byB0aGUgZ2l2ZW4gZWxlbWVudHMgc3R5bGVcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIGV4cG9ydHMuYWRkQ2xhc3NOYW1lID0gZnVuY3Rpb24gKGVsZW0sIGNsYXNzTmFtZSkge1xuICAgIHZhciBjbGFzc2VzID0gZWxlbS5jbGFzc05hbWUuc3BsaXQoJyAnKTtcbiAgICBpZiAoY2xhc3Nlcy5pbmRleE9mKGNsYXNzTmFtZSkgPT0gLTEpIHtcbiAgICAgIGNsYXNzZXMucHVzaChjbGFzc05hbWUpOyAvLyBhZGQgdGhlIGNsYXNzIHRvIHRoZSBhcnJheVxuICAgICAgZWxlbS5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oJyAnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIGFkZCBhIGNsYXNzTmFtZSB0byB0aGUgZ2l2ZW4gZWxlbWVudHMgc3R5bGVcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIGV4cG9ydHMucmVtb3ZlQ2xhc3NOYW1lID0gZnVuY3Rpb24gKGVsZW0sIGNsYXNzTmFtZSkge1xuICAgIHZhciBjbGFzc2VzID0gZWxlbS5jbGFzc05hbWUuc3BsaXQoJyAnKTtcbiAgICB2YXIgaW5kZXggPSBjbGFzc2VzLmluZGV4T2YoY2xhc3NOYW1lKTtcbiAgICBpZiAoaW5kZXggIT0gLTEpIHtcbiAgICAgIGNsYXNzZXMuc3BsaWNlKGluZGV4LCAxKTsgLy8gcmVtb3ZlIHRoZSBjbGFzcyBmcm9tIHRoZSBhcnJheVxuICAgICAgZWxlbS5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oJyAnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEZvciBlYWNoIG1ldGhvZCBmb3IgYm90aCBhcnJheXMgYW5kIG9iamVjdHMuXG4gICAqIEluIGNhc2Ugb2YgYW4gYXJyYXksIHRoZSBidWlsdC1pbiBBcnJheS5mb3JFYWNoKCkgaXMgYXBwbGllZC5cbiAgICogSW4gY2FzZSBvZiBhbiBPYmplY3QsIHRoZSBtZXRob2QgbG9vcHMgb3ZlciBhbGwgcHJvcGVydGllcyBvZiB0aGUgb2JqZWN0LlxuICAgKiBAcGFyYW0ge09iamVjdCB8IEFycmF5fSBvYmplY3QgICBBbiBPYmplY3Qgb3IgQXJyYXlcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgICAgICAgQ2FsbGJhY2sgbWV0aG9kLCBjYWxsZWQgZm9yIGVhY2ggaXRlbSBpblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgb2JqZWN0IG9yIGFycmF5IHdpdGggdGhyZWUgcGFyYW1ldGVyczpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodmFsdWUsIGluZGV4LCBvYmplY3QpXG4gICAqL1xuICBleHBvcnRzLmZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHZhciBpLCBsZW47XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgLy8gYXJyYXlcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG9iamVjdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjYWxsYmFjayhvYmplY3RbaV0sIGksIG9iamVjdCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG9iamVjdFxuICAgICAgZm9yIChpIGluIG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgY2FsbGJhY2sob2JqZWN0W2ldLCBpLCBvYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGFuIG9iamVjdCBpbnRvIGFuIGFycmF5OiBhbGwgb2JqZWN0cyBwcm9wZXJ0aWVzIGFyZSBwdXQgaW50byB0aGVcbiAgICogYXJyYXkuIFRoZSByZXN1bHRpbmcgYXJyYXkgaXMgdW5vcmRlcmVkLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gICAqL1xuICBleHBvcnRzLnRvQXJyYXkgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgdmFyIGFycmF5ID0gW107XG5cbiAgICBmb3IgKHZhciBwcm9wIGluIG9iamVjdCkge1xuICAgICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgYXJyYXkucHVzaChvYmplY3RbcHJvcF0pO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIGEgcHJvcGVydHkgaW4gYW4gb2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGNoYW5nZWRcbiAgICovXG4gIGV4cG9ydHMudXBkYXRlUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKG9iamVjdFtrZXldICE9PSB2YWx1ZSkge1xuICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUaHJvdHRsZSB0aGUgZ2l2ZW4gZnVuY3Rpb24gdG8gYmUgb25seSBleGVjdXRlZCBvbmNlIGV2ZXJ5IGB3YWl0YCBtaWxsaXNlY29uZHNcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZm5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgICAgVGltZSBpbiBtaWxsaXNlY29uZHNcbiAgICogQHJldHVybnMge2Z1bmN0aW9ufSBSZXR1cm5zIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb25cbiAgICovXG4gIGV4cG9ydHMudGhyb3R0bGUgPSBmdW5jdGlvbiAoZm4sIHdhaXQpIHtcbiAgICB2YXIgdGltZW91dCA9IG51bGw7XG4gICAgdmFyIG5lZWRFeGVjdXRpb24gPSBmYWxzZTtcblxuICAgIHJldHVybiBmdW5jdGlvbiB0aHJvdHRsZWQoKSB7XG4gICAgICBpZiAoIXRpbWVvdXQpIHtcbiAgICAgICAgbmVlZEV4ZWN1dGlvbiA9IGZhbHNlO1xuICAgICAgICBmbigpO1xuXG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICBpZiAobmVlZEV4ZWN1dGlvbikge1xuICAgICAgICAgICAgdGhyb3R0bGVkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB3YWl0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5lZWRFeGVjdXRpb24gPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhbmQgZXZlbnQgbGlzdGVuZXIuIFdvcmtzIGZvciBhbGwgYnJvd3NlcnNcbiAgICogQHBhcmFtIHtFbGVtZW50fSAgICAgZWxlbWVudCAgICBBbiBodG1sIGVsZW1lbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgYWN0aW9uICAgICBUaGUgYWN0aW9uLCBmb3IgZXhhbXBsZSBcImNsaWNrXCIsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aG91dCB0aGUgcHJlZml4IFwib25cIlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSAgICBsaXN0ZW5lciAgIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBleGVjdXRlZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICBbdXNlQ2FwdHVyZV1cbiAgICovXG4gIGV4cG9ydHMuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChlbGVtZW50LCBhY3Rpb24sIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XG4gICAgaWYgKGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgaWYgKHVzZUNhcHR1cmUgPT09IHVuZGVmaW5lZCkgdXNlQ2FwdHVyZSA9IGZhbHNlO1xuXG4gICAgICBpZiAoYWN0aW9uID09PSBcIm1vdXNld2hlZWxcIiAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJGaXJlZm94XCIpID49IDApIHtcbiAgICAgICAgYWN0aW9uID0gXCJET01Nb3VzZVNjcm9sbFwiOyAvLyBGb3IgRmlyZWZveFxuICAgICAgfVxuXG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoYWN0aW9uLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuYXR0YWNoRXZlbnQoXCJvblwiICsgYWN0aW9uLCBsaXN0ZW5lcik7IC8vIElFIGJyb3dzZXJzXG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIgZnJvbSBhbiBlbGVtZW50XG4gICAqIEBwYXJhbSB7RWxlbWVudH0gICAgIGVsZW1lbnQgICAgICAgICBBbiBodG1sIGRvbSBlbGVtZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgIGFjdGlvbiAgICAgICAgICBUaGUgbmFtZSBvZiB0aGUgZXZlbnQsIGZvciBleGFtcGxlIFwibW91c2Vkb3duXCJcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gICAgbGlzdGVuZXIgICAgICAgIFRoZSBsaXN0ZW5lciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICBbdXNlQ2FwdHVyZV1cbiAgICovXG4gIGV4cG9ydHMucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChlbGVtZW50LCBhY3Rpb24sIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XG4gICAgaWYgKGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgLy8gbm9uLUlFIGJyb3dzZXJzXG4gICAgICBpZiAodXNlQ2FwdHVyZSA9PT0gdW5kZWZpbmVkKSB1c2VDYXB0dXJlID0gZmFsc2U7XG5cbiAgICAgIGlmIChhY3Rpb24gPT09IFwibW91c2V3aGVlbFwiICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIkZpcmVmb3hcIikgPj0gMCkge1xuICAgICAgICBhY3Rpb24gPSBcIkRPTU1vdXNlU2Nyb2xsXCI7IC8vIEZvciBGaXJlZm94XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihhY3Rpb24sIGxpc3RlbmVyLCB1c2VDYXB0dXJlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSUUgYnJvd3NlcnNcbiAgICAgIGVsZW1lbnQuZGV0YWNoRXZlbnQoXCJvblwiICsgYWN0aW9uLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDYW5jZWxzIHRoZSBldmVudCBpZiBpdCBpcyBjYW5jZWxhYmxlLCB3aXRob3V0IHN0b3BwaW5nIGZ1cnRoZXIgcHJvcGFnYXRpb24gb2YgdGhlIGV2ZW50LlxuICAgKi9cbiAgZXhwb3J0cy5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmICghZXZlbnQpIGV2ZW50ID0gd2luZG93LmV2ZW50O1xuXG4gICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBub24tSUUgYnJvd3NlcnNcbiAgICB9IGVsc2Uge1xuICAgICAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlOyAvLyBJRSBicm93c2Vyc1xuICAgICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgSFRNTCBlbGVtZW50IHdoaWNoIGlzIHRoZSB0YXJnZXQgb2YgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEByZXR1cm4ge0VsZW1lbnR9IHRhcmdldCBlbGVtZW50XG4gICAqL1xuICBleHBvcnRzLmdldFRhcmdldCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGNvZGUgZnJvbSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2pzL2V2ZW50c19wcm9wZXJ0aWVzLmh0bWxcbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICBldmVudCA9IHdpbmRvdy5ldmVudDtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0O1xuXG4gICAgaWYgKGV2ZW50LnRhcmdldCkge1xuICAgICAgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgIH0gZWxzZSBpZiAoZXZlbnQuc3JjRWxlbWVudCkge1xuICAgICAgdGFyZ2V0ID0gZXZlbnQuc3JjRWxlbWVudDtcbiAgICB9XG5cbiAgICBpZiAodGFyZ2V0Lm5vZGVUeXBlICE9IHVuZGVmaW5lZCAmJiB0YXJnZXQubm9kZVR5cGUgPT0gMykge1xuICAgICAgLy8gZGVmZWF0IFNhZmFyaSBidWdcbiAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGdpdmVuIGVsZW1lbnQgY29udGFpbnMgZ2l2ZW4gcGFyZW50IHNvbWV3aGVyZSBpbiB0aGUgRE9NIHRyZWVcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcGFyZW50XG4gICAqL1xuICBleHBvcnRzLmhhc1BhcmVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBwYXJlbnQpIHtcbiAgICB2YXIgZSA9IGVsZW1lbnQ7XG5cbiAgICB3aGlsZSAoZSkge1xuICAgICAgaWYgKGUgPT09IHBhcmVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGUgPSBlLnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIGV4cG9ydHMub3B0aW9uID0ge307XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSB2YWx1ZSBpbnRvIGEgYm9vbGVhblxuICAgKiBAcGFyYW0ge0Jvb2xlYW4gfCBmdW5jdGlvbiB8IHVuZGVmaW5lZH0gdmFsdWVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbZGVmYXVsdFZhbHVlXVxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYm9vbFxuICAgKi9cbiAgZXhwb3J0cy5vcHRpb24uYXNCb29sZWFuID0gZnVuY3Rpb24gKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUoKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHZhbHVlICE9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBkZWZhdWx0VmFsdWUgfHwgbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydCBhIHZhbHVlIGludG8gYSBudW1iZXJcbiAgICogQHBhcmFtIHtCb29sZWFuIHwgZnVuY3Rpb24gfCB1bmRlZmluZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVmYXVsdFZhbHVlXVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBudW1iZXJcbiAgICovXG4gIGV4cG9ydHMub3B0aW9uLmFzTnVtYmVyID0gZnVuY3Rpb24gKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUoKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSkgfHwgZGVmYXVsdFZhbHVlIHx8IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZSB8fCBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgdmFsdWUgaW50byBhIHN0cmluZ1xuICAgKiBAcGFyYW0ge1N0cmluZyB8IGZ1bmN0aW9uIHwgdW5kZWZpbmVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2RlZmF1bHRWYWx1ZV1cbiAgICogQHJldHVybnMge1N0cmluZ30gc3RyXG4gICAqL1xuICBleHBvcnRzLm9wdGlvbi5hc1N0cmluZyA9IGZ1bmN0aW9uICh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlKCk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWZhdWx0VmFsdWUgfHwgbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydCBhIHNpemUgb3IgbG9jYXRpb24gaW50byBhIHN0cmluZyB3aXRoIHBpeGVscyBvciBhIHBlcmNlbnRhZ2VcbiAgICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXIgfCBmdW5jdGlvbiB8IHVuZGVmaW5lZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtkZWZhdWx0VmFsdWVdXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IHNpemVcbiAgICovXG4gIGV4cG9ydHMub3B0aW9uLmFzU2l6ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlKCk7XG4gICAgfVxuXG4gICAgaWYgKGV4cG9ydHMuaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIGlmIChleHBvcnRzLmlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlICsgJ3B4JztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZSB8fCBudWxsO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydCBhIHZhbHVlIGludG8gYSBET00gZWxlbWVudFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgZnVuY3Rpb24gfCB1bmRlZmluZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFtkZWZhdWx0VmFsdWVdXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9IGRvbVxuICAgKi9cbiAgZXhwb3J0cy5vcHRpb24uYXNFbGVtZW50ID0gZnVuY3Rpb24gKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWUgfHwgZGVmYXVsdFZhbHVlIHx8IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTYyMzgzOC9yZ2ItdG8taGV4LWFuZC1oZXgtdG8tcmdiXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBoZXhcbiAgICogQHJldHVybnMge3tyOiAqLCBnOiAqLCBiOiAqfX0gfCAyNTUgcmFuZ2VcbiAgICovXG4gIGV4cG9ydHMuaGV4VG9SR0IgPSBmdW5jdGlvbiAoaGV4KSB7XG4gICAgLy8gRXhwYW5kIHNob3J0aGFuZCBmb3JtIChlLmcuIFwiMDNGXCIpIHRvIGZ1bGwgZm9ybSAoZS5nLiBcIjAwMzNGRlwiKVxuICAgIHZhciBzaG9ydGhhbmRSZWdleCA9IC9eIz8oW2EtZlxcZF0pKFthLWZcXGRdKShbYS1mXFxkXSkkL2k7XG4gICAgaGV4ID0gaGV4LnJlcGxhY2Uoc2hvcnRoYW5kUmVnZXgsIGZ1bmN0aW9uIChtLCByLCBnLCBiKSB7XG4gICAgICByZXR1cm4gciArIHIgKyBnICsgZyArIGIgKyBiO1xuICAgIH0pO1xuICAgIHZhciByZXN1bHQgPSAvXiM/KFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pJC9pLmV4ZWMoaGV4KTtcbiAgICByZXR1cm4gcmVzdWx0ID8ge1xuICAgICAgcjogcGFyc2VJbnQocmVzdWx0WzFdLCAxNiksXG4gICAgICBnOiBwYXJzZUludChyZXN1bHRbMl0sIDE2KSxcbiAgICAgIGI6IHBhcnNlSW50KHJlc3VsdFszXSwgMTYpXG4gICAgfSA6IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgY29sb3IgaW4gaGV4IGZvcm1hdCBvciByZ2IoKSBvciByZ2JhKCkgZm9ybWF0IGFuZCBvdmVycmlkZXMgdGhlIG9wYWNpdHkuIFJldHVybnMgcmdiYSgpIHN0cmluZy5cbiAgICogQHBhcmFtIGNvbG9yXG4gICAqIEBwYXJhbSBvcGFjaXR5XG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgZXhwb3J0cy5vdmVycmlkZU9wYWNpdHkgPSBmdW5jdGlvbiAoY29sb3IsIG9wYWNpdHkpIHtcbiAgICBpZiAoY29sb3IuaW5kZXhPZihcInJnYmFcIikgIT0gLTEpIHtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9IGVsc2UgaWYgKGNvbG9yLmluZGV4T2YoXCJyZ2JcIikgIT0gLTEpIHtcbiAgICAgIHZhciByZ2IgPSBjb2xvci5zdWJzdHIoY29sb3IuaW5kZXhPZihcIihcIikgKyAxKS5yZXBsYWNlKFwiKVwiLCBcIlwiKS5zcGxpdChcIixcIik7XG4gICAgICByZXR1cm4gXCJyZ2JhKFwiICsgcmdiWzBdICsgXCIsXCIgKyByZ2JbMV0gKyBcIixcIiArIHJnYlsyXSArIFwiLFwiICsgb3BhY2l0eSArIFwiKVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmdiID0gZXhwb3J0cy5oZXhUb1JHQihjb2xvcik7XG4gICAgICBpZiAocmdiID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGNvbG9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwicmdiYShcIiArIHJnYi5yICsgXCIsXCIgKyByZ2IuZyArIFwiLFwiICsgcmdiLmIgKyBcIixcIiArIG9wYWNpdHkgKyBcIilcIjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSByZWQgICAgIDAgLS0gMjU1XG4gICAqIEBwYXJhbSBncmVlbiAgIDAgLS0gMjU1XG4gICAqIEBwYXJhbSBibHVlICAgIDAgLS0gMjU1XG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZXhwb3J0cy5SR0JUb0hleCA9IGZ1bmN0aW9uIChyZWQsIGdyZWVuLCBibHVlKSB7XG4gICAgcmV0dXJuIFwiI1wiICsgKCgxIDw8IDI0KSArIChyZWQgPDwgMTYpICsgKGdyZWVuIDw8IDgpICsgYmx1ZSkudG9TdHJpbmcoMTYpLnNsaWNlKDEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQYXJzZSBhIGNvbG9yIHByb3BlcnR5IGludG8gYW4gb2JqZWN0IHdpdGggYm9yZGVyLCBiYWNrZ3JvdW5kLCBhbmRcbiAgICogaGlnaGxpZ2h0IGNvbG9yc1xuICAgKiBAcGFyYW0ge09iamVjdCB8IFN0cmluZ30gY29sb3JcbiAgICogQHJldHVybiB7T2JqZWN0fSBjb2xvck9iamVjdFxuICAgKi9cbiAgZXhwb3J0cy5wYXJzZUNvbG9yID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgdmFyIGM7XG4gICAgaWYgKGV4cG9ydHMuaXNTdHJpbmcoY29sb3IpID09PSB0cnVlKSB7XG4gICAgICBpZiAoZXhwb3J0cy5pc1ZhbGlkUkdCKGNvbG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgcmdiID0gY29sb3Iuc3Vic3RyKDQpLnN1YnN0cigwLCBjb2xvci5sZW5ndGggLSA1KS5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29sb3IgPSBleHBvcnRzLlJHQlRvSGV4KHJnYlswXSwgcmdiWzFdLCByZ2JbMl0pO1xuICAgICAgfVxuICAgICAgaWYgKGV4cG9ydHMuaXNWYWxpZEhleChjb2xvcikgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIGhzdiA9IGV4cG9ydHMuaGV4VG9IU1YoY29sb3IpO1xuICAgICAgICB2YXIgbGlnaHRlckNvbG9ySFNWID0geyBoOiBoc3YuaCwgczogaHN2LnMgKiAwLjgsIHY6IE1hdGgubWluKDEsIGhzdi52ICogMS4wMikgfTtcbiAgICAgICAgdmFyIGRhcmtlckNvbG9ySFNWID0geyBoOiBoc3YuaCwgczogTWF0aC5taW4oMSwgaHN2LnMgKiAxLjI1KSwgdjogaHN2LnYgKiAwLjggfTtcbiAgICAgICAgdmFyIGRhcmtlckNvbG9ySGV4ID0gZXhwb3J0cy5IU1ZUb0hleChkYXJrZXJDb2xvckhTVi5oLCBkYXJrZXJDb2xvckhTVi5zLCBkYXJrZXJDb2xvckhTVi52KTtcbiAgICAgICAgdmFyIGxpZ2h0ZXJDb2xvckhleCA9IGV4cG9ydHMuSFNWVG9IZXgobGlnaHRlckNvbG9ySFNWLmgsIGxpZ2h0ZXJDb2xvckhTVi5zLCBsaWdodGVyQ29sb3JIU1Yudik7XG4gICAgICAgIGMgPSB7XG4gICAgICAgICAgYmFja2dyb3VuZDogY29sb3IsXG4gICAgICAgICAgYm9yZGVyOiBkYXJrZXJDb2xvckhleCxcbiAgICAgICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgICAgIGJhY2tncm91bmQ6IGxpZ2h0ZXJDb2xvckhleCxcbiAgICAgICAgICAgIGJvcmRlcjogZGFya2VyQ29sb3JIZXhcbiAgICAgICAgICB9LFxuICAgICAgICAgIGhvdmVyOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiBsaWdodGVyQ29sb3JIZXgsXG4gICAgICAgICAgICBib3JkZXI6IGRhcmtlckNvbG9ySGV4XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYyA9IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBjb2xvcixcbiAgICAgICAgICBib3JkZXI6IGNvbG9yLFxuICAgICAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICAgICAgYmFja2dyb3VuZDogY29sb3IsXG4gICAgICAgICAgICBib3JkZXI6IGNvbG9yXG4gICAgICAgICAgfSxcbiAgICAgICAgICBob3Zlcjoge1xuICAgICAgICAgICAgYmFja2dyb3VuZDogY29sb3IsXG4gICAgICAgICAgICBib3JkZXI6IGNvbG9yXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjID0ge307XG4gICAgICBjLmJhY2tncm91bmQgPSBjb2xvci5iYWNrZ3JvdW5kIHx8IHVuZGVmaW5lZDtcbiAgICAgIGMuYm9yZGVyID0gY29sb3IuYm9yZGVyIHx8IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGV4cG9ydHMuaXNTdHJpbmcoY29sb3IuaGlnaGxpZ2h0KSkge1xuICAgICAgICBjLmhpZ2hsaWdodCA9IHtcbiAgICAgICAgICBib3JkZXI6IGNvbG9yLmhpZ2hsaWdodCxcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBjb2xvci5oaWdobGlnaHRcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGMuaGlnaGxpZ2h0ID0ge307XG4gICAgICAgIGMuaGlnaGxpZ2h0LmJhY2tncm91bmQgPSBjb2xvci5oaWdobGlnaHQgJiYgY29sb3IuaGlnaGxpZ2h0LmJhY2tncm91bmQgfHwgdW5kZWZpbmVkO1xuICAgICAgICBjLmhpZ2hsaWdodC5ib3JkZXIgPSBjb2xvci5oaWdobGlnaHQgJiYgY29sb3IuaGlnaGxpZ2h0LmJvcmRlciB8fCB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChleHBvcnRzLmlzU3RyaW5nKGNvbG9yLmhvdmVyKSkge1xuICAgICAgICBjLmhvdmVyID0ge1xuICAgICAgICAgIGJvcmRlcjogY29sb3IuaG92ZXIsXG4gICAgICAgICAgYmFja2dyb3VuZDogY29sb3IuaG92ZXJcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGMuaG92ZXIgPSB7fTtcbiAgICAgICAgYy5ob3Zlci5iYWNrZ3JvdW5kID0gY29sb3IuaG92ZXIgJiYgY29sb3IuaG92ZXIuYmFja2dyb3VuZCB8fCB1bmRlZmluZWQ7XG4gICAgICAgIGMuaG92ZXIuYm9yZGVyID0gY29sb3IuaG92ZXIgJiYgY29sb3IuaG92ZXIuYm9yZGVyIHx8IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYztcbiAgfTtcblxuICAvKipcbiAgICogaHR0cDovL3d3dy5qYXZhc2NyaXB0ZXIubmV0L2ZhcS9yZ2IyaHN2Lmh0bVxuICAgKlxuICAgKiBAcGFyYW0gcmVkXG4gICAqIEBwYXJhbSBncmVlblxuICAgKiBAcGFyYW0gYmx1ZVxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBleHBvcnRzLlJHQlRvSFNWID0gZnVuY3Rpb24gKHJlZCwgZ3JlZW4sIGJsdWUpIHtcbiAgICByZWQgPSByZWQgLyAyNTU7Z3JlZW4gPSBncmVlbiAvIDI1NTtibHVlID0gYmx1ZSAvIDI1NTtcbiAgICB2YXIgbWluUkdCID0gTWF0aC5taW4ocmVkLCBNYXRoLm1pbihncmVlbiwgYmx1ZSkpO1xuICAgIHZhciBtYXhSR0IgPSBNYXRoLm1heChyZWQsIE1hdGgubWF4KGdyZWVuLCBibHVlKSk7XG5cbiAgICAvLyBCbGFjay1ncmF5LXdoaXRlXG4gICAgaWYgKG1pblJHQiA9PSBtYXhSR0IpIHtcbiAgICAgIHJldHVybiB7IGg6IDAsIHM6IDAsIHY6IG1pblJHQiB9O1xuICAgIH1cblxuICAgIC8vIENvbG9ycyBvdGhlciB0aGFuIGJsYWNrLWdyYXktd2hpdGU6XG4gICAgdmFyIGQgPSByZWQgPT0gbWluUkdCID8gZ3JlZW4gLSBibHVlIDogYmx1ZSA9PSBtaW5SR0IgPyByZWQgLSBncmVlbiA6IGJsdWUgLSByZWQ7XG4gICAgdmFyIGggPSByZWQgPT0gbWluUkdCID8gMyA6IGJsdWUgPT0gbWluUkdCID8gMSA6IDU7XG4gICAgdmFyIGh1ZSA9IDYwICogKGggLSBkIC8gKG1heFJHQiAtIG1pblJHQikpIC8gMzYwO1xuICAgIHZhciBzYXR1cmF0aW9uID0gKG1heFJHQiAtIG1pblJHQikgLyBtYXhSR0I7XG4gICAgdmFyIHZhbHVlID0gbWF4UkdCO1xuICAgIHJldHVybiB7IGg6IGh1ZSwgczogc2F0dXJhdGlvbiwgdjogdmFsdWUgfTtcbiAgfTtcblxuICB2YXIgY3NzVXRpbCA9IHtcbiAgICAvLyBzcGxpdCBhIHN0cmluZyB3aXRoIGNzcyBzdHlsZXMgaW50byBhbiBvYmplY3Qgd2l0aCBrZXkvdmFsdWVzXG4gICAgc3BsaXQ6IGZ1bmN0aW9uIHNwbGl0KGNzc1RleHQpIHtcbiAgICAgIHZhciBzdHlsZXMgPSB7fTtcblxuICAgICAgY3NzVGV4dC5zcGxpdCgnOycpLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICAgIGlmIChzdHlsZS50cmltKCkgIT0gJycpIHtcbiAgICAgICAgICB2YXIgcGFydHMgPSBzdHlsZS5zcGxpdCgnOicpO1xuICAgICAgICAgIHZhciBrZXkgPSBwYXJ0c1swXS50cmltKCk7XG4gICAgICAgICAgdmFyIHZhbHVlID0gcGFydHNbMV0udHJpbSgpO1xuICAgICAgICAgIHN0eWxlc1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gc3R5bGVzO1xuICAgIH0sXG5cbiAgICAvLyBidWlsZCBhIGNzcyB0ZXh0IHN0cmluZyBmcm9tIGFuIG9iamVjdCB3aXRoIGtleS92YWx1ZXNcbiAgICBqb2luOiBmdW5jdGlvbiBqb2luKHN0eWxlcykge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHN0eWxlcykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleSArICc6ICcgKyBzdHlsZXNba2V5XTtcbiAgICAgIH0pLmpvaW4oJzsgJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBcHBlbmQgYSBzdHJpbmcgd2l0aCBjc3Mgc3R5bGVzIHRvIGFuIGVsZW1lbnRcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjc3NUZXh0XG4gICAqL1xuICBleHBvcnRzLmFkZENzc1RleHQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY3NzVGV4dCkge1xuICAgIHZhciBjdXJyZW50U3R5bGVzID0gY3NzVXRpbC5zcGxpdChlbGVtZW50LnN0eWxlLmNzc1RleHQpO1xuICAgIHZhciBuZXdTdHlsZXMgPSBjc3NVdGlsLnNwbGl0KGNzc1RleHQpO1xuICAgIHZhciBzdHlsZXMgPSBleHBvcnRzLmV4dGVuZChjdXJyZW50U3R5bGVzLCBuZXdTdHlsZXMpO1xuXG4gICAgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gY3NzVXRpbC5qb2luKHN0eWxlcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIHN0cmluZyB3aXRoIGNzcyBzdHlsZXMgZnJvbSBhbiBlbGVtZW50XG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gY3NzVGV4dFxuICAgKi9cbiAgZXhwb3J0cy5yZW1vdmVDc3NUZXh0ID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNzc1RleHQpIHtcbiAgICB2YXIgc3R5bGVzID0gY3NzVXRpbC5zcGxpdChlbGVtZW50LnN0eWxlLmNzc1RleHQpO1xuICAgIHZhciByZW1vdmVTdHlsZXMgPSBjc3NVdGlsLnNwbGl0KGNzc1RleHQpO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHJlbW92ZVN0eWxlcykge1xuICAgICAgaWYgKHJlbW92ZVN0eWxlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGRlbGV0ZSBzdHlsZXNba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBjc3NVdGlsLmpvaW4oc3R5bGVzKTtcbiAgfTtcblxuICAvKipcbiAgICogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vbWppamFja3Nvbi81MzExMjU2XG4gICAqIEBwYXJhbSBoXG4gICAqIEBwYXJhbSBzXG4gICAqIEBwYXJhbSB2XG4gICAqIEByZXR1cm5zIHt7cjogbnVtYmVyLCBnOiBudW1iZXIsIGI6IG51bWJlcn19XG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZXhwb3J0cy5IU1ZUb1JHQiA9IGZ1bmN0aW9uIChoLCBzLCB2KSB7XG4gICAgdmFyIHIsIGcsIGI7XG5cbiAgICB2YXIgaSA9IE1hdGguZmxvb3IoaCAqIDYpO1xuICAgIHZhciBmID0gaCAqIDYgLSBpO1xuICAgIHZhciBwID0gdiAqICgxIC0gcyk7XG4gICAgdmFyIHEgPSB2ICogKDEgLSBmICogcyk7XG4gICAgdmFyIHQgPSB2ICogKDEgLSAoMSAtIGYpICogcyk7XG5cbiAgICBzd2l0Y2ggKGkgJSA2KSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHIgPSB2LCBnID0gdCwgYiA9IHA7YnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHIgPSBxLCBnID0gdiwgYiA9IHA7YnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHIgPSBwLCBnID0gdiwgYiA9IHQ7YnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHIgPSBwLCBnID0gcSwgYiA9IHY7YnJlYWs7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHIgPSB0LCBnID0gcCwgYiA9IHY7YnJlYWs7XG4gICAgICBjYXNlIDU6XG4gICAgICAgIHIgPSB2LCBnID0gcCwgYiA9IHE7YnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgcjogTWF0aC5mbG9vcihyICogMjU1KSwgZzogTWF0aC5mbG9vcihnICogMjU1KSwgYjogTWF0aC5mbG9vcihiICogMjU1KSB9O1xuICB9O1xuXG4gIGV4cG9ydHMuSFNWVG9IZXggPSBmdW5jdGlvbiAoaCwgcywgdikge1xuICAgIHZhciByZ2IgPSBleHBvcnRzLkhTVlRvUkdCKGgsIHMsIHYpO1xuICAgIHJldHVybiBleHBvcnRzLlJHQlRvSGV4KHJnYi5yLCByZ2IuZywgcmdiLmIpO1xuICB9O1xuXG4gIGV4cG9ydHMuaGV4VG9IU1YgPSBmdW5jdGlvbiAoaGV4KSB7XG4gICAgdmFyIHJnYiA9IGV4cG9ydHMuaGV4VG9SR0IoaGV4KTtcbiAgICByZXR1cm4gZXhwb3J0cy5SR0JUb0hTVihyZ2IuciwgcmdiLmcsIHJnYi5iKTtcbiAgfTtcblxuICBleHBvcnRzLmlzVmFsaWRIZXggPSBmdW5jdGlvbiAoaGV4KSB7XG4gICAgdmFyIGlzT2sgPSAvKF4jWzAtOUEtRl17Nn0kKXwoXiNbMC05QS1GXXszfSQpL2kudGVzdChoZXgpO1xuICAgIHJldHVybiBpc09rO1xuICB9O1xuXG4gIGV4cG9ydHMuaXNWYWxpZFJHQiA9IGZ1bmN0aW9uIChyZ2IpIHtcbiAgICByZ2IgPSByZ2IucmVwbGFjZShcIiBcIiwgXCJcIik7XG4gICAgdmFyIGlzT2sgPSAvcmdiXFwoKFxcZHsxLDN9KSwoXFxkezEsM30pLChcXGR7MSwzfSlcXCkvaS50ZXN0KHJnYik7XG4gICAgcmV0dXJuIGlzT2s7XG4gIH07XG4gIGV4cG9ydHMuaXNWYWxpZFJHQkEgPSBmdW5jdGlvbiAocmdiYSkge1xuICAgIHJnYmEgPSByZ2JhLnJlcGxhY2UoXCIgXCIsIFwiXCIpO1xuICAgIHZhciBpc09rID0gL3JnYmFcXCgoXFxkezEsM30pLChcXGR7MSwzfSksKFxcZHsxLDN9KSwoLnsxLDN9KVxcKS9pLnRlc3QocmdiYSk7XG4gICAgcmV0dXJuIGlzT2s7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgcmVjdXJzaXZlbHkgcmVkaXJlY3RzIHRoZSBwcm90b3R5cGUgb2YgSlNPTiBvYmplY3RzIHRvIHRoZSByZWZlcmVuY2VPYmplY3RcbiAgICogVGhpcyBpcyB1c2VkIGZvciBkZWZhdWx0IG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSByZWZlcmVuY2VPYmplY3RcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBleHBvcnRzLnNlbGVjdGl2ZUJyaWRnZU9iamVjdCA9IGZ1bmN0aW9uIChmaWVsZHMsIHJlZmVyZW5jZU9iamVjdCkge1xuICAgIGlmICgodHlwZW9mIHJlZmVyZW5jZU9iamVjdCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocmVmZXJlbmNlT2JqZWN0KSkgPT0gXCJvYmplY3RcIikge1xuICAgICAgdmFyIG9iamVjdFRvID0gT2JqZWN0LmNyZWF0ZShyZWZlcmVuY2VPYmplY3QpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHJlZmVyZW5jZU9iamVjdC5oYXNPd25Qcm9wZXJ0eShmaWVsZHNbaV0pKSB7XG4gICAgICAgICAgaWYgKF90eXBlb2YocmVmZXJlbmNlT2JqZWN0W2ZpZWxkc1tpXV0pID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIG9iamVjdFRvW2ZpZWxkc1tpXV0gPSBleHBvcnRzLmJyaWRnZU9iamVjdChyZWZlcmVuY2VPYmplY3RbZmllbGRzW2ldXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0VG87XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVGhpcyByZWN1cnNpdmVseSByZWRpcmVjdHMgdGhlIHByb3RvdHlwZSBvZiBKU09OIG9iamVjdHMgdG8gdGhlIHJlZmVyZW5jZU9iamVjdFxuICAgKiBUaGlzIGlzIHVzZWQgZm9yIGRlZmF1bHQgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHJlZmVyZW5jZU9iamVjdFxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGV4cG9ydHMuYnJpZGdlT2JqZWN0ID0gZnVuY3Rpb24gKHJlZmVyZW5jZU9iamVjdCkge1xuICAgIGlmICgodHlwZW9mIHJlZmVyZW5jZU9iamVjdCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocmVmZXJlbmNlT2JqZWN0KSkgPT0gXCJvYmplY3RcIikge1xuICAgICAgdmFyIG9iamVjdFRvID0gT2JqZWN0LmNyZWF0ZShyZWZlcmVuY2VPYmplY3QpO1xuICAgICAgZm9yICh2YXIgaSBpbiByZWZlcmVuY2VPYmplY3QpIHtcbiAgICAgICAgaWYgKHJlZmVyZW5jZU9iamVjdC5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgIGlmIChfdHlwZW9mKHJlZmVyZW5jZU9iamVjdFtpXSkgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgb2JqZWN0VG9baV0gPSBleHBvcnRzLmJyaWRnZU9iamVjdChyZWZlcmVuY2VPYmplY3RbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdFRvO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHByb3ZpZGVzIGEgc3RhYmxlIHNvcnQgaW1wbGVtZW50YXRpb24sIHZlcnkgZmFzdCBmb3IgcHJlc29ydGVkIGRhdGFcbiAgICpcbiAgICogQHBhcmFtIGEgdGhlIGFycmF5XG4gICAqIEBwYXJhbSBhIG9yZGVyIGNvbXBhcmF0b3JcbiAgICogQHJldHVybnMge3RoZSBhcnJheX1cbiAgICovXG4gIGV4cG9ydHMuaW5zZXJ0U29ydCA9IGZ1bmN0aW9uIChhLCBjb21wYXJlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgayA9IGFbaV07XG4gICAgICBmb3IgKHZhciBqID0gaTsgaiA+IDAgJiYgY29tcGFyZShrLCBhW2ogLSAxXSkgPCAwOyBqLS0pIHtcbiAgICAgICAgYVtqXSA9IGFbaiAtIDFdO1xuICAgICAgfVxuICAgICAgYVtqXSA9IGs7XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9O1xuXG4gIC8qKlxuICAgKiB0aGlzIGlzIHVzZWQgdG8gc2V0IHRoZSBvcHRpb25zIG9mIHN1Ym9iamVjdHMgaW4gdGhlIG9wdGlvbnMgb2JqZWN0LiBBIHJlcXVpcmVtZW50IG9mIHRoZXNlIHN1Ym9iamVjdHNcbiAgICogaXMgdGhhdCB0aGV5IGhhdmUgYW4gJ2VuYWJsZWQnIGVsZW1lbnQgd2hpY2ggaXMgb3B0aW9uYWwgZm9yIHRoZSB1c2VyIGJ1dCBtYW5kYXRvcnkgZm9yIHRoZSBwcm9ncmFtLlxuICAgKlxuICAgKiBAcGFyYW0gW29iamVjdF0gbWVyZ2VUYXJnZXQgfCB0aGlzIGlzIGVpdGhlciB0aGlzLm9wdGlvbnMgb3IgdGhlIG9wdGlvbnMgdXNlZCBmb3IgdGhlIGdyb3Vwcy5cbiAgICogQHBhcmFtIFtvYmplY3RdIG9wdGlvbnMgICAgIHwgb3B0aW9uc1xuICAgKiBAcGFyYW0gW1N0cmluZ10gb3B0aW9uICAgICAgfCB0aGlzIGlzIHRoZSBvcHRpb24ga2V5IGluIHRoZSBvcHRpb25zIGFyZ3VtZW50XG4gICAqL1xuICBleHBvcnRzLm1lcmdlT3B0aW9ucyA9IGZ1bmN0aW9uIChtZXJnZVRhcmdldCwgb3B0aW9ucywgb3B0aW9uKSB7XG4gICAgdmFyIGFsbG93RGVsZXRpb24gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDMgfHwgYXJndW1lbnRzWzNdID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1szXTtcbiAgICB2YXIgZ2xvYmFsT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gNCB8fCBhcmd1bWVudHNbNF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzRdO1xuXG4gICAgaWYgKG9wdGlvbnNbb3B0aW9uXSA9PT0gbnVsbCkge1xuICAgICAgbWVyZ2VUYXJnZXRbb3B0aW9uXSA9IE9iamVjdC5jcmVhdGUoZ2xvYmFsT3B0aW9uc1tvcHRpb25dKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG9wdGlvbnNbb3B0aW9uXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uc1tvcHRpb25dID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBtZXJnZVRhcmdldFtvcHRpb25dLmVuYWJsZWQgPSBvcHRpb25zW29wdGlvbl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnNbb3B0aW9uXS5lbmFibGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1lcmdlVGFyZ2V0W29wdGlvbl0uZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gb3B0aW9uc1tvcHRpb25dKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9uc1tvcHRpb25dLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgIG1lcmdlVGFyZ2V0W29wdGlvbl1bcHJvcF0gPSBvcHRpb25zW29wdGlvbl1bcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGRvZXMgYSBiaW5hcnkgc2VhcmNoIGZvciBhIHZpc2libGUgaXRlbSBpbiBhIHNvcnRlZCBsaXN0LiBJZiB3ZSBmaW5kIGEgdmlzaWJsZSBpdGVtLCB0aGUgY29kZSB0aGF0IHVzZXNcbiAgICogdGhpcyBmdW5jdGlvbiB3aWxsIHRoZW4gaXRlcmF0ZSBpbiBib3RoIGRpcmVjdGlvbnMgb3ZlciB0aGlzIHNvcnRlZCBsaXN0IHRvIGZpbmQgYWxsIHZpc2libGUgaXRlbXMuXG4gICAqXG4gICAqIEBwYXJhbSB7SXRlbVtdfSBvcmRlcmVkSXRlbXMgICAgICAgfCBJdGVtcyBvcmRlcmVkIGJ5IHN0YXJ0XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbXBhcmF0b3IgICAgICAgfCAtMSBpcyBsb3dlciwgMCBpcyBlcXVhbCwgMSBpcyBoaWdoZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZDJcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGV4cG9ydHMuYmluYXJ5U2VhcmNoQ3VzdG9tID0gZnVuY3Rpb24gKG9yZGVyZWRJdGVtcywgY29tcGFyYXRvciwgZmllbGQsIGZpZWxkMikge1xuICAgIHZhciBtYXhJdGVyYXRpb25zID0gMTAwMDA7XG4gICAgdmFyIGl0ZXJhdGlvbiA9IDA7XG4gICAgdmFyIGxvdyA9IDA7XG4gICAgdmFyIGhpZ2ggPSBvcmRlcmVkSXRlbXMubGVuZ3RoIC0gMTtcblxuICAgIHdoaWxlIChsb3cgPD0gaGlnaCAmJiBpdGVyYXRpb24gPCBtYXhJdGVyYXRpb25zKSB7XG4gICAgICB2YXIgbWlkZGxlID0gTWF0aC5mbG9vcigobG93ICsgaGlnaCkgLyAyKTtcblxuICAgICAgdmFyIGl0ZW0gPSBvcmRlcmVkSXRlbXNbbWlkZGxlXTtcbiAgICAgIHZhciB2YWx1ZSA9IGZpZWxkMiA9PT0gdW5kZWZpbmVkID8gaXRlbVtmaWVsZF0gOiBpdGVtW2ZpZWxkXVtmaWVsZDJdO1xuXG4gICAgICB2YXIgc2VhcmNoUmVzdWx0ID0gY29tcGFyYXRvcih2YWx1ZSk7XG4gICAgICBpZiAoc2VhcmNoUmVzdWx0ID09IDApIHtcbiAgICAgICAgLy8gamloYWEsIGZvdW5kIGEgdmlzaWJsZSBpdGVtIVxuICAgICAgICByZXR1cm4gbWlkZGxlO1xuICAgICAgfSBlbHNlIGlmIChzZWFyY2hSZXN1bHQgPT0gLTEpIHtcbiAgICAgICAgLy8gaXQgaXMgdG9vIHNtYWxsIC0tPiBpbmNyZWFzZSBsb3dcbiAgICAgICAgbG93ID0gbWlkZGxlICsgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGl0IGlzIHRvbyBiaWcgLS0+IGRlY3JlYXNlIGhpZ2hcbiAgICAgICAgaGlnaCA9IG1pZGRsZSAtIDE7XG4gICAgICB9XG5cbiAgICAgIGl0ZXJhdGlvbisrO1xuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBkb2VzIGEgYmluYXJ5IHNlYXJjaCBmb3IgYSBzcGVjaWZpYyB2YWx1ZSBpbiBhIHNvcnRlZCBhcnJheS4gSWYgaXQgZG9lcyBub3QgZXhpc3QgYnV0IGlzIGluIGJldHdlZW4gb2ZcbiAgICogdHdvIHZhbHVlcywgd2UgcmV0dXJuIGVpdGhlciB0aGUgb25lIGJlZm9yZSBvciB0aGUgb25lIGFmdGVyLCBkZXBlbmRpbmcgb24gdXNlciBpbnB1dFxuICAgKiBJZiBpdCBpcyBmb3VuZCwgd2UgcmV0dXJuIHRoZSBpbmRleCwgZWxzZSAtMS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gb3JkZXJlZEl0ZW1zXG4gICAqIEBwYXJhbSB7e3N0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyfX0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2lkZVByZWZlcmVuY2UgICAnYmVmb3JlJyBvciAnYWZ0ZXInXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbXBhcmF0b3IgYW4gb3B0aW9uYWwgY29tcGFyYXRvciwgcmV0dXJuaW5nIC0xLDAsMSBmb3IgPCw9PSw+LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZXhwb3J0cy5iaW5hcnlTZWFyY2hWYWx1ZSA9IGZ1bmN0aW9uIChvcmRlcmVkSXRlbXMsIHRhcmdldCwgZmllbGQsIHNpZGVQcmVmZXJlbmNlLCBjb21wYXJhdG9yKSB7XG4gICAgdmFyIG1heEl0ZXJhdGlvbnMgPSAxMDAwMDtcbiAgICB2YXIgaXRlcmF0aW9uID0gMDtcbiAgICB2YXIgbG93ID0gMDtcbiAgICB2YXIgaGlnaCA9IG9yZGVyZWRJdGVtcy5sZW5ndGggLSAxO1xuICAgIHZhciBwcmV2VmFsdWUsIHZhbHVlLCBuZXh0VmFsdWUsIG1pZGRsZTtcblxuICAgIHZhciBjb21wYXJhdG9yID0gY29tcGFyYXRvciAhPSB1bmRlZmluZWQgPyBjb21wYXJhdG9yIDogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhID09IGIgPyAwIDogYSA8IGIgPyAtMSA6IDE7XG4gICAgfTtcblxuICAgIHdoaWxlIChsb3cgPD0gaGlnaCAmJiBpdGVyYXRpb24gPCBtYXhJdGVyYXRpb25zKSB7XG4gICAgICAvLyBnZXQgYSBuZXcgZ3Vlc3NcbiAgICAgIG1pZGRsZSA9IE1hdGguZmxvb3IoMC41ICogKGhpZ2ggKyBsb3cpKTtcbiAgICAgIHByZXZWYWx1ZSA9IG9yZGVyZWRJdGVtc1tNYXRoLm1heCgwLCBtaWRkbGUgLSAxKV1bZmllbGRdO1xuICAgICAgdmFsdWUgPSBvcmRlcmVkSXRlbXNbbWlkZGxlXVtmaWVsZF07XG4gICAgICBuZXh0VmFsdWUgPSBvcmRlcmVkSXRlbXNbTWF0aC5taW4ob3JkZXJlZEl0ZW1zLmxlbmd0aCAtIDEsIG1pZGRsZSArIDEpXVtmaWVsZF07XG5cbiAgICAgIGlmIChjb21wYXJhdG9yKHZhbHVlLCB0YXJnZXQpID09IDApIHtcbiAgICAgICAgLy8gd2UgZm91bmQgdGhlIHRhcmdldFxuICAgICAgICByZXR1cm4gbWlkZGxlO1xuICAgICAgfSBlbHNlIGlmIChjb21wYXJhdG9yKHByZXZWYWx1ZSwgdGFyZ2V0KSA8IDAgJiYgY29tcGFyYXRvcih2YWx1ZSwgdGFyZ2V0KSA+IDApIHtcbiAgICAgICAgLy8gdGFyZ2V0IGlzIGluIGJldHdlZW4gb2YgdGhlIHByZXZpb3VzIGFuZCB0aGUgY3VycmVudFxuICAgICAgICByZXR1cm4gc2lkZVByZWZlcmVuY2UgPT0gJ2JlZm9yZScgPyBNYXRoLm1heCgwLCBtaWRkbGUgLSAxKSA6IG1pZGRsZTtcbiAgICAgIH0gZWxzZSBpZiAoY29tcGFyYXRvcih2YWx1ZSwgdGFyZ2V0KSA8IDAgJiYgY29tcGFyYXRvcihuZXh0VmFsdWUsIHRhcmdldCkgPiAwKSB7XG4gICAgICAgIC8vIHRhcmdldCBpcyBpbiBiZXR3ZWVuIG9mIHRoZSBjdXJyZW50IGFuZCB0aGUgbmV4dFxuICAgICAgICByZXR1cm4gc2lkZVByZWZlcmVuY2UgPT0gJ2JlZm9yZScgPyBtaWRkbGUgOiBNYXRoLm1pbihvcmRlcmVkSXRlbXMubGVuZ3RoIC0gMSwgbWlkZGxlICsgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkaWRudCBmaW5kIHRoZSB0YXJnZXQsIHdlIG5lZWQgdG8gY2hhbmdlIG91ciBib3VuZGFyaWVzLlxuICAgICAgICBpZiAoY29tcGFyYXRvcih2YWx1ZSwgdGFyZ2V0KSA8IDApIHtcbiAgICAgICAgICAvLyBpdCBpcyB0b28gc21hbGwgLS0+IGluY3JlYXNlIGxvd1xuICAgICAgICAgIGxvdyA9IG1pZGRsZSArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaXQgaXMgdG9vIGJpZyAtLT4gZGVjcmVhc2UgaGlnaFxuICAgICAgICAgIGhpZ2ggPSBtaWRkbGUgLSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpdGVyYXRpb24rKztcbiAgICB9XG5cbiAgICAvLyBkaWRudCBmaW5kIGFueXRoaW5nLiBSZXR1cm4gLTEuXG4gICAgcmV0dXJuIC0xO1xuICB9O1xuXG4gIC8qXG4gICAqIEVhc2luZyBGdW5jdGlvbnMgLSBpbnNwaXJlZCBmcm9tIGh0dHA6Ly9naXptYS5jb20vZWFzaW5nL1xuICAgKiBvbmx5IGNvbnNpZGVyaW5nIHRoZSB0IHZhbHVlIGZvciB0aGUgcmFuZ2UgWzAsIDFdID0+IFswLCAxXVxuICAgKiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9ncmUvMTY1MDI5NFxuICAgKi9cbiAgZXhwb3J0cy5lYXNpbmdGdW5jdGlvbnMgPSB7XG4gICAgLy8gbm8gZWFzaW5nLCBubyBhY2NlbGVyYXRpb25cbiAgICBsaW5lYXI6IGZ1bmN0aW9uIGxpbmVhcih0KSB7XG4gICAgICByZXR1cm4gdDtcbiAgICB9LFxuICAgIC8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcbiAgICBlYXNlSW5RdWFkOiBmdW5jdGlvbiBlYXNlSW5RdWFkKHQpIHtcbiAgICAgIHJldHVybiB0ICogdDtcbiAgICB9LFxuICAgIC8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG4gICAgZWFzZU91dFF1YWQ6IGZ1bmN0aW9uIGVhc2VPdXRRdWFkKHQpIHtcbiAgICAgIHJldHVybiB0ICogKDIgLSB0KTtcbiAgICB9LFxuICAgIC8vIGFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxuICAgIGVhc2VJbk91dFF1YWQ6IGZ1bmN0aW9uIGVhc2VJbk91dFF1YWQodCkge1xuICAgICAgcmV0dXJuIHQgPCAuNSA/IDIgKiB0ICogdCA6IC0xICsgKDQgLSAyICogdCkgKiB0O1xuICAgIH0sXG4gICAgLy8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxuICAgIGVhc2VJbkN1YmljOiBmdW5jdGlvbiBlYXNlSW5DdWJpYyh0KSB7XG4gICAgICByZXR1cm4gdCAqIHQgKiB0O1xuICAgIH0sXG4gICAgLy8gZGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcbiAgICBlYXNlT3V0Q3ViaWM6IGZ1bmN0aW9uIGVhc2VPdXRDdWJpYyh0KSB7XG4gICAgICByZXR1cm4gLS10ICogdCAqIHQgKyAxO1xuICAgIH0sXG4gICAgLy8gYWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXG4gICAgZWFzZUluT3V0Q3ViaWM6IGZ1bmN0aW9uIGVhc2VJbk91dEN1YmljKHQpIHtcbiAgICAgIHJldHVybiB0IDwgLjUgPyA0ICogdCAqIHQgKiB0IDogKHQgLSAxKSAqICgyICogdCAtIDIpICogKDIgKiB0IC0gMikgKyAxO1xuICAgIH0sXG4gICAgLy8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxuICAgIGVhc2VJblF1YXJ0OiBmdW5jdGlvbiBlYXNlSW5RdWFydCh0KSB7XG4gICAgICByZXR1cm4gdCAqIHQgKiB0ICogdDtcbiAgICB9LFxuICAgIC8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG4gICAgZWFzZU91dFF1YXJ0OiBmdW5jdGlvbiBlYXNlT3V0UXVhcnQodCkge1xuICAgICAgcmV0dXJuIDEgLSAtLXQgKiB0ICogdCAqIHQ7XG4gICAgfSxcbiAgICAvLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbiAgICBlYXNlSW5PdXRRdWFydDogZnVuY3Rpb24gZWFzZUluT3V0UXVhcnQodCkge1xuICAgICAgcmV0dXJuIHQgPCAuNSA/IDggKiB0ICogdCAqIHQgKiB0IDogMSAtIDggKiAtLXQgKiB0ICogdCAqIHQ7XG4gICAgfSxcbiAgICAvLyBhY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XG4gICAgZWFzZUluUXVpbnQ6IGZ1bmN0aW9uIGVhc2VJblF1aW50KHQpIHtcbiAgICAgIHJldHVybiB0ICogdCAqIHQgKiB0ICogdDtcbiAgICB9LFxuICAgIC8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG4gICAgZWFzZU91dFF1aW50OiBmdW5jdGlvbiBlYXNlT3V0UXVpbnQodCkge1xuICAgICAgcmV0dXJuIDEgKyAtLXQgKiB0ICogdCAqIHQgKiB0O1xuICAgIH0sXG4gICAgLy8gYWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXG4gICAgZWFzZUluT3V0UXVpbnQ6IGZ1bmN0aW9uIGVhc2VJbk91dFF1aW50KHQpIHtcbiAgICAgIHJldHVybiB0IDwgLjUgPyAxNiAqIHQgKiB0ICogdCAqIHQgKiB0IDogMSArIDE2ICogLS10ICogdCAqIHQgKiB0ICogdDtcbiAgICB9XG4gIH07XG5cbi8qKiovIH0sXG4vKiAyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gZmlyc3QgY2hlY2sgaWYgbW9tZW50LmpzIGlzIGFscmVhZHkgbG9hZGVkIGluIHRoZSBicm93c2VyIHdpbmRvdywgaWYgc28sXG4gIC8vIHVzZSB0aGlzIGluc3RhbmNlLiBFbHNlLCBsb2FkIHZpYSBjb21tb25qcy5cbiAgbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3dbJ21vbWVudCddIHx8IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbi8qKiovIH0sXG4vKiAzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24obW9kdWxlKSB7Ly8hIG1vbWVudC5qc1xuICAvLyEgdmVyc2lvbiA6IDIuMTMuMFxuICAvLyEgYXV0aG9ycyA6IFRpbSBXb29kLCBJc2tyZW4gQ2hlcm5ldiwgTW9tZW50LmpzIGNvbnRyaWJ1dG9yc1xuICAvLyEgbGljZW5zZSA6IE1JVFxuICAvLyEgbW9tZW50anMuY29tXG5cbiAgOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgICAgdHJ1ZSA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gICAgICBnbG9iYWwubW9tZW50ID0gZmFjdG9yeSgpXG4gIH0odGhpcywgZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICAgIHZhciBob29rQ2FsbGJhY2s7XG5cbiAgICAgIGZ1bmN0aW9uIHV0aWxzX2hvb2tzX19ob29rcyAoKSB7XG4gICAgICAgICAgcmV0dXJuIGhvb2tDYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGlzIGlzIGRvbmUgdG8gcmVnaXN0ZXIgdGhlIG1ldGhvZCBjYWxsZWQgd2l0aCBtb21lbnQoKVxuICAgICAgLy8gd2l0aG91dCBjcmVhdGluZyBjaXJjdWxhciBkZXBlbmRlbmNpZXMuXG4gICAgICBmdW5jdGlvbiBzZXRIb29rQ2FsbGJhY2sgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgaG9va0NhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzQXJyYXkoaW5wdXQpIHtcbiAgICAgICAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBBcnJheSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc0RhdGUoaW5wdXQpIHtcbiAgICAgICAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBEYXRlIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IERhdGVdJztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbWFwKGFyciwgZm4pIHtcbiAgICAgICAgICB2YXIgcmVzID0gW10sIGk7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICByZXMucHVzaChmbihhcnJbaV0sIGkpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaGFzT3duUHJvcChhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLCBiKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZXh0ZW5kKGEsIGIpIHtcbiAgICAgICAgICBmb3IgKHZhciBpIGluIGIpIHtcbiAgICAgICAgICAgICAgaWYgKGhhc093blByb3AoYiwgaSkpIHtcbiAgICAgICAgICAgICAgICAgIGFbaV0gPSBiW2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGhhc093blByb3AoYiwgJ3RvU3RyaW5nJykpIHtcbiAgICAgICAgICAgICAgYS50b1N0cmluZyA9IGIudG9TdHJpbmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGhhc093blByb3AoYiwgJ3ZhbHVlT2YnKSkge1xuICAgICAgICAgICAgICBhLnZhbHVlT2YgPSBiLnZhbHVlT2Y7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgdHJ1ZSkudXRjKCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRlZmF1bHRQYXJzaW5nRmxhZ3MoKSB7XG4gICAgICAgICAgLy8gV2UgbmVlZCB0byBkZWVwIGNsb25lIHRoaXMgb2JqZWN0LlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGVtcHR5ICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgICB1bnVzZWRUb2tlbnMgICAgOiBbXSxcbiAgICAgICAgICAgICAgdW51c2VkSW5wdXQgICAgIDogW10sXG4gICAgICAgICAgICAgIG92ZXJmbG93ICAgICAgICA6IC0yLFxuICAgICAgICAgICAgICBjaGFyc0xlZnRPdmVyICAgOiAwLFxuICAgICAgICAgICAgICBudWxsSW5wdXQgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgICAgaW52YWxpZE1vbnRoICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgaW52YWxpZEZvcm1hdCAgIDogZmFsc2UsXG4gICAgICAgICAgICAgIHVzZXJJbnZhbGlkYXRlZCA6IGZhbHNlLFxuICAgICAgICAgICAgICBpc28gICAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgICAgcGFyc2VkRGF0ZVBhcnRzIDogW10sXG4gICAgICAgICAgICAgIG1lcmlkaWVtICAgICAgICA6IG51bGxcbiAgICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRQYXJzaW5nRmxhZ3MobSkge1xuICAgICAgICAgIGlmIChtLl9wZiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIG0uX3BmID0gZGVmYXVsdFBhcnNpbmdGbGFncygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbS5fcGY7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb21lO1xuICAgICAgaWYgKEFycmF5LnByb3RvdHlwZS5zb21lKSB7XG4gICAgICAgICAgc29tZSA9IEFycmF5LnByb3RvdHlwZS5zb21lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzb21lID0gZnVuY3Rpb24gKGZ1bikge1xuICAgICAgICAgICAgICB2YXIgdCA9IE9iamVjdCh0aGlzKTtcbiAgICAgICAgICAgICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpIGluIHQgJiYgZnVuLmNhbGwodGhpcywgdFtpXSwgaSwgdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB2YWxpZF9faXNWYWxpZChtKSB7XG4gICAgICAgICAgaWYgKG0uX2lzVmFsaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgZmxhZ3MgPSBnZXRQYXJzaW5nRmxhZ3MobSk7XG4gICAgICAgICAgICAgIHZhciBwYXJzZWRQYXJ0cyA9IHNvbWUuY2FsbChmbGFncy5wYXJzZWREYXRlUGFydHMsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaSAhPSBudWxsO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbS5faXNWYWxpZCA9ICFpc05hTihtLl9kLmdldFRpbWUoKSkgJiZcbiAgICAgICAgICAgICAgICAgIGZsYWdzLm92ZXJmbG93IDwgMCAmJlxuICAgICAgICAgICAgICAgICAgIWZsYWdzLmVtcHR5ICYmXG4gICAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZE1vbnRoICYmXG4gICAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZFdlZWtkYXkgJiZcbiAgICAgICAgICAgICAgICAgICFmbGFncy5udWxsSW5wdXQgJiZcbiAgICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkRm9ybWF0ICYmXG4gICAgICAgICAgICAgICAgICAhZmxhZ3MudXNlckludmFsaWRhdGVkICYmXG4gICAgICAgICAgICAgICAgICAoIWZsYWdzLm1lcmlkaWVtIHx8IChmbGFncy5tZXJpZGllbSAmJiBwYXJzZWRQYXJ0cykpO1xuXG4gICAgICAgICAgICAgIGlmIChtLl9zdHJpY3QpIHtcbiAgICAgICAgICAgICAgICAgIG0uX2lzVmFsaWQgPSBtLl9pc1ZhbGlkICYmXG4gICAgICAgICAgICAgICAgICAgICAgZmxhZ3MuY2hhcnNMZWZ0T3ZlciA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgIGZsYWdzLnVudXNlZFRva2Vucy5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICBmbGFncy5iaWdIb3VyID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG0uX2lzVmFsaWQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHZhbGlkX19jcmVhdGVJbnZhbGlkIChmbGFncykge1xuICAgICAgICAgIHZhciBtID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKE5hTik7XG4gICAgICAgICAgaWYgKGZsYWdzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgZXh0ZW5kKGdldFBhcnNpbmdGbGFncyhtKSwgZmxhZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLnVzZXJJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKGlucHV0KSB7XG4gICAgICAgICAgcmV0dXJuIGlucHV0ID09PSB2b2lkIDA7XG4gICAgICB9XG5cbiAgICAgIC8vIFBsdWdpbnMgdGhhdCBhZGQgcHJvcGVydGllcyBzaG91bGQgYWxzbyBhZGQgdGhlIGtleSBoZXJlIChudWxsIHZhbHVlKSxcbiAgICAgIC8vIHNvIHdlIGNhbiBwcm9wZXJseSBjbG9uZSBvdXJzZWx2ZXMuXG4gICAgICB2YXIgbW9tZW50UHJvcGVydGllcyA9IHV0aWxzX2hvb2tzX19ob29rcy5tb21lbnRQcm9wZXJ0aWVzID0gW107XG5cbiAgICAgIGZ1bmN0aW9uIGNvcHlDb25maWcodG8sIGZyb20pIHtcbiAgICAgICAgICB2YXIgaSwgcHJvcCwgdmFsO1xuXG4gICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pc0FNb21lbnRPYmplY3QpKSB7XG4gICAgICAgICAgICAgIHRvLl9pc0FNb21lbnRPYmplY3QgPSBmcm9tLl9pc0FNb21lbnRPYmplY3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faSkpIHtcbiAgICAgICAgICAgICAgdG8uX2kgPSBmcm9tLl9pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2YpKSB7XG4gICAgICAgICAgICAgIHRvLl9mID0gZnJvbS5fZjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9sKSkge1xuICAgICAgICAgICAgICB0by5fbCA9IGZyb20uX2w7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fc3RyaWN0KSkge1xuICAgICAgICAgICAgICB0by5fc3RyaWN0ID0gZnJvbS5fc3RyaWN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3R6bSkpIHtcbiAgICAgICAgICAgICAgdG8uX3R6bSA9IGZyb20uX3R6bTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pc1VUQykpIHtcbiAgICAgICAgICAgICAgdG8uX2lzVVRDID0gZnJvbS5faXNVVEM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fb2Zmc2V0KSkge1xuICAgICAgICAgICAgICB0by5fb2Zmc2V0ID0gZnJvbS5fb2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3BmKSkge1xuICAgICAgICAgICAgICB0by5fcGYgPSBnZXRQYXJzaW5nRmxhZ3MoZnJvbSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbG9jYWxlKSkge1xuICAgICAgICAgICAgICB0by5fbG9jYWxlID0gZnJvbS5fbG9jYWxlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtb21lbnRQcm9wZXJ0aWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgZm9yIChpIGluIG1vbWVudFByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgIHByb3AgPSBtb21lbnRQcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgICAgICAgdmFsID0gZnJvbVtwcm9wXTtcbiAgICAgICAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRvW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRvO1xuICAgICAgfVxuXG4gICAgICB2YXIgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4gICAgICAvLyBNb21lbnQgcHJvdG90eXBlIG9iamVjdFxuICAgICAgZnVuY3Rpb24gTW9tZW50KGNvbmZpZykge1xuICAgICAgICAgIGNvcHlDb25maWcodGhpcywgY29uZmlnKTtcbiAgICAgICAgICB0aGlzLl9kID0gbmV3IERhdGUoY29uZmlnLl9kICE9IG51bGwgPyBjb25maWcuX2QuZ2V0VGltZSgpIDogTmFOKTtcbiAgICAgICAgICAvLyBQcmV2ZW50IGluZmluaXRlIGxvb3AgaW4gY2FzZSB1cGRhdGVPZmZzZXQgY3JlYXRlcyBuZXcgbW9tZW50XG4gICAgICAgICAgLy8gb2JqZWN0cy5cbiAgICAgICAgICBpZiAodXBkYXRlSW5Qcm9ncmVzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzTW9tZW50IChvYmopIHtcbiAgICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgTW9tZW50IHx8IChvYmogIT0gbnVsbCAmJiBvYmouX2lzQU1vbWVudE9iamVjdCAhPSBudWxsKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYWJzRmxvb3IgKG51bWJlcikge1xuICAgICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdG9JbnQoYXJndW1lbnRGb3JDb2VyY2lvbikge1xuICAgICAgICAgIHZhciBjb2VyY2VkTnVtYmVyID0gK2FyZ3VtZW50Rm9yQ29lcmNpb24sXG4gICAgICAgICAgICAgIHZhbHVlID0gMDtcblxuICAgICAgICAgIGlmIChjb2VyY2VkTnVtYmVyICE9PSAwICYmIGlzRmluaXRlKGNvZXJjZWROdW1iZXIpKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gYWJzRmxvb3IoY29lcmNlZE51bWJlcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICAvLyBjb21wYXJlIHR3byBhcnJheXMsIHJldHVybiB0aGUgbnVtYmVyIG9mIGRpZmZlcmVuY2VzXG4gICAgICBmdW5jdGlvbiBjb21wYXJlQXJyYXlzKGFycmF5MSwgYXJyYXkyLCBkb250Q29udmVydCkge1xuICAgICAgICAgIHZhciBsZW4gPSBNYXRoLm1pbihhcnJheTEubGVuZ3RoLCBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgICAgICAgbGVuZ3RoRGlmZiA9IE1hdGguYWJzKGFycmF5MS5sZW5ndGggLSBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgICAgICAgZGlmZnMgPSAwLFxuICAgICAgICAgICAgICBpO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICBpZiAoKGRvbnRDb252ZXJ0ICYmIGFycmF5MVtpXSAhPT0gYXJyYXkyW2ldKSB8fFxuICAgICAgICAgICAgICAgICAgKCFkb250Q29udmVydCAmJiB0b0ludChhcnJheTFbaV0pICE9PSB0b0ludChhcnJheTJbaV0pKSkge1xuICAgICAgICAgICAgICAgICAgZGlmZnMrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGlmZnMgKyBsZW5ndGhEaWZmO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB3YXJuKG1zZykge1xuICAgICAgICAgIGlmICh1dGlsc19ob29rc19faG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgICAgKHR5cGVvZiBjb25zb2xlICE9PSAgJ3VuZGVmaW5lZCcpICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIHdhcm5pbmc6ICcgKyBtc2cpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGVwcmVjYXRlKG1zZywgZm4pIHtcbiAgICAgICAgICB2YXIgZmlyc3RUaW1lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBleHRlbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAodXRpbHNfaG9va3NfX2hvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG51bGwsIG1zZyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGZpcnN0VGltZSkge1xuICAgICAgICAgICAgICAgICAgd2Fybihtc2cgKyAnXFxuQXJndW1lbnRzOiAnICsgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKCcsICcpICsgJ1xcbicgKyAobmV3IEVycm9yKCkpLnN0YWNrKTtcbiAgICAgICAgICAgICAgICAgIGZpcnN0VGltZSA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH0sIGZuKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRlcHJlY2F0aW9ucyA9IHt9O1xuXG4gICAgICBmdW5jdGlvbiBkZXByZWNhdGVTaW1wbGUobmFtZSwgbXNnKSB7XG4gICAgICAgICAgaWYgKHV0aWxzX2hvb2tzX19ob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG5hbWUsIG1zZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZGVwcmVjYXRpb25zW25hbWVdKSB7XG4gICAgICAgICAgICAgIHdhcm4obXNnKTtcbiAgICAgICAgICAgICAgZGVwcmVjYXRpb25zW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPSBmYWxzZTtcbiAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgPSBudWxsO1xuXG4gICAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgRnVuY3Rpb24gfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaXNPYmplY3QoaW5wdXQpIHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGxvY2FsZV9zZXRfX3NldCAoY29uZmlnKSB7XG4gICAgICAgICAgdmFyIHByb3AsIGk7XG4gICAgICAgICAgZm9yIChpIGluIGNvbmZpZykge1xuICAgICAgICAgICAgICBwcm9wID0gY29uZmlnW2ldO1xuICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgdGhpc1tpXSA9IHByb3A7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0aGlzWydfJyArIGldID0gcHJvcDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG4gICAgICAgICAgLy8gTGVuaWVudCBvcmRpbmFsIHBhcnNpbmcgYWNjZXB0cyBqdXN0IGEgbnVtYmVyIGluIGFkZGl0aW9uIHRvXG4gICAgICAgICAgLy8gbnVtYmVyICsgKHBvc3NpYmx5KSBzdHVmZiBjb21pbmcgZnJvbSBfb3JkaW5hbFBhcnNlTGVuaWVudC5cbiAgICAgICAgICB0aGlzLl9vcmRpbmFsUGFyc2VMZW5pZW50ID0gbmV3IFJlZ0V4cCh0aGlzLl9vcmRpbmFsUGFyc2Uuc291cmNlICsgJ3wnICsgKC9cXGR7MSwyfS8pLnNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNoaWxkQ29uZmlnKSB7XG4gICAgICAgICAgdmFyIHJlcyA9IGV4dGVuZCh7fSwgcGFyZW50Q29uZmlnKSwgcHJvcDtcbiAgICAgICAgICBmb3IgKHByb3AgaW4gY2hpbGRDb25maWcpIHtcbiAgICAgICAgICAgICAgaWYgKGhhc093blByb3AoY2hpbGRDb25maWcsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKSAmJiBpc09iamVjdChjaGlsZENvbmZpZ1twcm9wXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICBleHRlbmQocmVzW3Byb3BdLCBwYXJlbnRDb25maWdbcHJvcF0pO1xuICAgICAgICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIGNoaWxkQ29uZmlnW3Byb3BdKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGRDb25maWdbcHJvcF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IGNoaWxkQ29uZmlnW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcmVzW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIExvY2FsZShjb25maWcpIHtcbiAgICAgICAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhpcy5zZXQoY29uZmlnKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBrZXlzO1xuXG4gICAgICBpZiAoT2JqZWN0LmtleXMpIHtcbiAgICAgICAgICBrZXlzID0gT2JqZWN0LmtleXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIGtleXMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgIHZhciBpLCByZXMgPSBbXTtcbiAgICAgICAgICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICAgICAgICAgICAgaWYgKGhhc093blByb3Aob2JqLCBpKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gaW50ZXJuYWwgc3RvcmFnZSBmb3IgbG9jYWxlIGNvbmZpZyBmaWxlc1xuICAgICAgdmFyIGxvY2FsZXMgPSB7fTtcbiAgICAgIHZhciBnbG9iYWxMb2NhbGU7XG5cbiAgICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2FsZShrZXkpIHtcbiAgICAgICAgICByZXR1cm4ga2V5ID8ga2V5LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnXycsICctJykgOiBrZXk7XG4gICAgICB9XG5cbiAgICAgIC8vIHBpY2sgdGhlIGxvY2FsZSBmcm9tIHRoZSBhcnJheVxuICAgICAgLy8gdHJ5IFsnZW4tYXUnLCAnZW4tZ2InXSBhcyAnZW4tYXUnLCAnZW4tZ2InLCAnZW4nLCBhcyBpbiBtb3ZlIHRocm91Z2ggdGhlIGxpc3QgdHJ5aW5nIGVhY2hcbiAgICAgIC8vIHN1YnN0cmluZyBmcm9tIG1vc3Qgc3BlY2lmaWMgdG8gbGVhc3QsIGJ1dCBtb3ZlIHRvIHRoZSBuZXh0IGFycmF5IGl0ZW0gaWYgaXQncyBhIG1vcmUgc3BlY2lmaWMgdmFyaWFudCB0aGFuIHRoZSBjdXJyZW50IHJvb3RcbiAgICAgIGZ1bmN0aW9uIGNob29zZUxvY2FsZShuYW1lcykge1xuICAgICAgICAgIHZhciBpID0gMCwgaiwgbmV4dCwgbG9jYWxlLCBzcGxpdDtcblxuICAgICAgICAgIHdoaWxlIChpIDwgbmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHNwbGl0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2ldKS5zcGxpdCgnLScpO1xuICAgICAgICAgICAgICBqID0gc3BsaXQubGVuZ3RoO1xuICAgICAgICAgICAgICBuZXh0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2kgKyAxXSk7XG4gICAgICAgICAgICAgIG5leHQgPSBuZXh0ID8gbmV4dC5zcGxpdCgnLScpIDogbnVsbDtcbiAgICAgICAgICAgICAgd2hpbGUgKGogPiAwKSB7XG4gICAgICAgICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKHNwbGl0LnNsaWNlKDAsIGopLmpvaW4oJy0nKSk7XG4gICAgICAgICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChuZXh0ICYmIG5leHQubGVuZ3RoID49IGogJiYgY29tcGFyZUFycmF5cyhzcGxpdCwgbmV4dCwgdHJ1ZSkgPj0gaiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvL3RoZSBuZXh0IGFycmF5IGl0ZW0gaXMgYmV0dGVyIHRoYW4gYSBzaGFsbG93ZXIgc3Vic3RyaW5nIG9mIHRoaXMgb25lXG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbG9hZExvY2FsZShuYW1lKSB7XG4gICAgICAgICAgdmFyIG9sZExvY2FsZSA9IG51bGw7XG4gICAgICAgICAgLy8gVE9ETzogRmluZCBhIGJldHRlciB3YXkgdG8gcmVnaXN0ZXIgYW5kIGxvYWQgYWxsIHRoZSBsb2NhbGVzIGluIE5vZGVcbiAgICAgICAgICBpZiAoIWxvY2FsZXNbbmFtZV0gJiYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgICAgICAgbW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBvbGRMb2NhbGUgPSBnbG9iYWxMb2NhbGUuX2FiYnI7XG4gICAgICAgICAgICAgICAgICAhKGZ1bmN0aW9uIHdlYnBhY2tNaXNzaW5nTW9kdWxlKCkgeyB2YXIgZSA9IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSBcXFwiLi9sb2NhbGVcXFwiXCIpOyBlLmNvZGUgPSAnTU9EVUxFX05PVF9GT1VORCc7IHRocm93IGU7IH0oKSk7XG4gICAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIGRlZmluZUxvY2FsZSBjdXJyZW50bHkgYWxzbyBzZXRzIHRoZSBnbG9iYWwgbG9jYWxlLCB3ZVxuICAgICAgICAgICAgICAgICAgLy8gd2FudCB0byB1bmRvIHRoYXQgZm9yIGxhenkgbG9hZGVkIGxvY2FsZXNcbiAgICAgICAgICAgICAgICAgIGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGUob2xkTG9jYWxlKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgbG9hZCBsb2NhbGUgYW5kIHRoZW4gc2V0IHRoZSBnbG9iYWwgbG9jYWxlLiAgSWZcbiAgICAgIC8vIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGluLCBpdCB3aWxsIHNpbXBseSByZXR1cm4gdGhlIGN1cnJlbnQgZ2xvYmFsXG4gICAgICAvLyBsb2NhbGUga2V5LlxuICAgICAgZnVuY3Rpb24gbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZSAoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgICBkYXRhID0gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZShrZXkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZGF0YSA9IGRlZmluZUxvY2FsZShrZXksIHZhbHVlcyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgLy8gbW9tZW50LmR1cmF0aW9uLl9sb2NhbGUgPSBtb21lbnQuX2xvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICBnbG9iYWxMb2NhbGUgPSBkYXRhO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGVmaW5lTG9jYWxlIChuYW1lLCBjb25maWcpIHtcbiAgICAgICAgICBpZiAoY29uZmlnICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGNvbmZpZy5hYmJyID0gbmFtZTtcbiAgICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKCdkZWZpbmVMb2NhbGVPdmVycmlkZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICd1c2UgbW9tZW50LnVwZGF0ZUxvY2FsZShsb2NhbGVOYW1lLCBjb25maWcpIHRvIGNoYW5nZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FuIGV4aXN0aW5nIGxvY2FsZS4gbW9tZW50LmRlZmluZUxvY2FsZShsb2NhbGVOYW1lLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbmZpZykgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgY3JlYXRpbmcgYSBuZXcgbG9jYWxlJyk7XG4gICAgICAgICAgICAgICAgICBjb25maWcgPSBtZXJnZUNvbmZpZ3MobG9jYWxlc1tuYW1lXS5fY29uZmlnLCBjb25maWcpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZy5wYXJlbnRMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZyA9IG1lcmdlQ29uZmlncyhsb2NhbGVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdLl9jb25maWcsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIHRyZWF0IGFzIGlmIHRoZXJlIGlzIG5vIGJhc2UgY29uZmlnXG4gICAgICAgICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKCdwYXJlbnRMb2NhbGVVbmRlZmluZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3NwZWNpZmllZCBwYXJlbnRMb2NhbGUgaXMgbm90IGRlZmluZWQgeWV0Jyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IG5ldyBMb2NhbGUoY29uZmlnKTtcblxuICAgICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgICAgbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZShuYW1lKTtcblxuICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyB1c2VmdWwgZm9yIHRlc3RpbmdcbiAgICAgICAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdXBkYXRlTG9jYWxlKG5hbWUsIGNvbmZpZykge1xuICAgICAgICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgbG9jYWxlO1xuICAgICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBjb25maWcgPSBtZXJnZUNvbmZpZ3MobG9jYWxlc1tuYW1lXS5fY29uZmlnLCBjb25maWcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxvY2FsZSA9IG5ldyBMb2NhbGUoY29uZmlnKTtcbiAgICAgICAgICAgICAgbG9jYWxlLnBhcmVudExvY2FsZSA9IGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBsb2NhbGU7XG5cbiAgICAgICAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdCBmb3Igbm93OiBhbHNvIHNldCB0aGUgbG9jYWxlXG4gICAgICAgICAgICAgIGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGUobmFtZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gcGFzcyBudWxsIGZvciBjb25maWcgdG8gdW51cGRhdGUsIHVzZWZ1bCBmb3IgdGVzdHNcbiAgICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlc1tuYW1lXS5wYXJlbnRMb2NhbGU7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgICAgfVxuXG4gICAgICAvLyByZXR1cm5zIGxvY2FsZSBkYXRhXG4gICAgICBmdW5jdGlvbiBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlIChrZXkpIHtcbiAgICAgICAgICB2YXIgbG9jYWxlO1xuXG4gICAgICAgICAgaWYgKGtleSAmJiBrZXkuX2xvY2FsZSAmJiBrZXkuX2xvY2FsZS5fYWJicikge1xuICAgICAgICAgICAgICBrZXkgPSBrZXkuX2xvY2FsZS5fYWJicjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghaXNBcnJheShrZXkpKSB7XG4gICAgICAgICAgICAgIC8vc2hvcnQtY2lyY3VpdCBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShrZXkpO1xuICAgICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGtleSA9IFtrZXldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjaG9vc2VMb2NhbGUoa2V5KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbG9jYWxlX2xvY2FsZXNfX2xpc3RMb2NhbGVzKCkge1xuICAgICAgICAgIHJldHVybiBrZXlzKGxvY2FsZXMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgYWxpYXNlcyA9IHt9O1xuXG4gICAgICBmdW5jdGlvbiBhZGRVbml0QWxpYXMgKHVuaXQsIHNob3J0aGFuZCkge1xuICAgICAgICAgIHZhciBsb3dlckNhc2UgPSB1bml0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgYWxpYXNlc1tsb3dlckNhc2VdID0gYWxpYXNlc1tsb3dlckNhc2UgKyAncyddID0gYWxpYXNlc1tzaG9ydGhhbmRdID0gdW5pdDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbm9ybWFsaXplVW5pdHModW5pdHMpIHtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIHVuaXRzID09PSAnc3RyaW5nJyA/IGFsaWFzZXNbdW5pdHNdIHx8IGFsaWFzZXNbdW5pdHMudG9Mb3dlckNhc2UoKV0gOiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZU9iamVjdFVuaXRzKGlucHV0T2JqZWN0KSB7XG4gICAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IHt9LFxuICAgICAgICAgICAgICBub3JtYWxpemVkUHJvcCxcbiAgICAgICAgICAgICAgcHJvcDtcblxuICAgICAgICAgIGZvciAocHJvcCBpbiBpbnB1dE9iamVjdCkge1xuICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcChpbnB1dE9iamVjdCwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wID0gbm9ybWFsaXplVW5pdHMocHJvcCk7XG4gICAgICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZFByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkSW5wdXRbbm9ybWFsaXplZFByb3BdID0gaW5wdXRPYmplY3RbcHJvcF07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbm9ybWFsaXplZElucHV0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBtYWtlR2V0U2V0ICh1bml0LCBrZWVwVGltZSkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGdldF9zZXRfX3NldCh0aGlzLCB1bml0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIGtlZXBUaW1lKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldF9zZXRfX2dldCh0aGlzLCB1bml0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldF9zZXRfX2dldCAobW9tLCB1bml0KSB7XG4gICAgICAgICAgcmV0dXJuIG1vbS5pc1ZhbGlkKCkgP1xuICAgICAgICAgICAgICBtb20uX2RbJ2dldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0oKSA6IE5hTjtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0X3NldF9fc2V0IChtb20sIHVuaXQsIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKG1vbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE1PTUVOVFNcblxuICAgICAgZnVuY3Rpb24gZ2V0U2V0ICh1bml0cywgdmFsdWUpIHtcbiAgICAgICAgICB2YXIgdW5pdDtcbiAgICAgICAgICBpZiAodHlwZW9mIHVuaXRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICBmb3IgKHVuaXQgaW4gdW5pdHMpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KHVuaXQsIHVuaXRzW3VuaXRdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzW3VuaXRzXSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW3VuaXRzXSh2YWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHplcm9GaWxsKG51bWJlciwgdGFyZ2V0TGVuZ3RoLCBmb3JjZVNpZ24pIHtcbiAgICAgICAgICB2YXIgYWJzTnVtYmVyID0gJycgKyBNYXRoLmFicyhudW1iZXIpLFxuICAgICAgICAgICAgICB6ZXJvc1RvRmlsbCA9IHRhcmdldExlbmd0aCAtIGFic051bWJlci5sZW5ndGgsXG4gICAgICAgICAgICAgIHNpZ24gPSBudW1iZXIgPj0gMDtcbiAgICAgICAgICByZXR1cm4gKHNpZ24gPyAoZm9yY2VTaWduID8gJysnIDogJycpIDogJy0nKSArXG4gICAgICAgICAgICAgIE1hdGgucG93KDEwLCBNYXRoLm1heCgwLCB6ZXJvc1RvRmlsbCkpLnRvU3RyaW5nKCkuc3Vic3RyKDEpICsgYWJzTnVtYmVyO1xuICAgICAgfVxuXG4gICAgICB2YXIgZm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhbSGhdbW0oc3MpP3xNb3xNTT9NP00/fERvfERERG98REQ/RD9EP3xkZGQ/ZD98ZG8/fHdbb3x3XT98V1tvfFddP3xRbz98WVlZWVlZfFlZWVlZfFlZWVl8WVl8Z2coZ2dnPyk/fEdHKEdHRz8pP3xlfEV8YXxBfGhoP3xISD98a2s/fG1tP3xzcz98U3sxLDl9fHh8WHx6ej98Wlo/fC4pL2c7XG5cbiAgICAgIHZhciBsb2NhbEZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oTFRTfExUfExMP0w/TD98bHsxLDR9KS9nO1xuXG4gICAgICB2YXIgZm9ybWF0RnVuY3Rpb25zID0ge307XG5cbiAgICAgIHZhciBmb3JtYXRUb2tlbkZ1bmN0aW9ucyA9IHt9O1xuXG4gICAgICAvLyB0b2tlbjogICAgJ00nXG4gICAgICAvLyBwYWRkZWQ6ICAgWydNTScsIDJdXG4gICAgICAvLyBvcmRpbmFsOiAgJ01vJ1xuICAgICAgLy8gY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHsgdGhpcy5tb250aCgpICsgMSB9XG4gICAgICBmdW5jdGlvbiBhZGRGb3JtYXRUb2tlbiAodG9rZW4sIHBhZGRlZCwgb3JkaW5hbCwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tjYWxsYmFja10oKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSA9IGZ1bmM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYWRkZWQpIHtcbiAgICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbcGFkZGVkWzBdXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB6ZXJvRmlsbChmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHBhZGRlZFsxXSwgcGFkZGVkWzJdKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9yZGluYWwpIHtcbiAgICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbb3JkaW5hbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkub3JkaW5hbChmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRva2VuKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgICBpZiAoaW5wdXQubWF0Y2goL1xcW1tcXHNcXFNdLykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL15cXFt8XFxdJC9nLCAnJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9cXFxcL2csICcnKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCkge1xuICAgICAgICAgIHZhciBhcnJheSA9IGZvcm1hdC5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSwgaSwgbGVuZ3RoO1xuXG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXSkge1xuICAgICAgICAgICAgICAgICAgYXJyYXlbaV0gPSBmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBhcnJheVtpXSA9IHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoYXJyYXlbaV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtb20pIHtcbiAgICAgICAgICAgICAgdmFyIG91dHB1dCA9ICcnLCBpO1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dCArPSBhcnJheVtpXSBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gYXJyYXlbaV0uY2FsbChtb20sIGZvcm1hdCkgOiBhcnJheVtpXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIGZvcm1hdCBkYXRlIHVzaW5nIG5hdGl2ZSBkYXRlIG9iamVjdFxuICAgICAgZnVuY3Rpb24gZm9ybWF0TW9tZW50KG0sIGZvcm1hdCkge1xuICAgICAgICAgIGlmICghbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG0ubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9ybWF0ID0gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbS5sb2NhbGVEYXRhKCkpO1xuICAgICAgICAgIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdID0gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gfHwgbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCk7XG5cbiAgICAgICAgICByZXR1cm4gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0obSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGV4cGFuZEZvcm1hdChmb3JtYXQsIGxvY2FsZSkge1xuICAgICAgICAgIHZhciBpID0gNTtcblxuICAgICAgICAgIGZ1bmN0aW9uIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2VucyhpbnB1dCkge1xuICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlLmxvbmdEYXRlRm9ybWF0KGlucHV0KSB8fCBpbnB1dDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICB3aGlsZSAoaSA+PSAwICYmIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy50ZXN0KGZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UobG9jYWxGb3JtYXR0aW5nVG9rZW5zLCByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMpO1xuICAgICAgICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXRjaDEgICAgICAgICA9IC9cXGQvOyAgICAgICAgICAgIC8vICAgICAgIDAgLSA5XG4gICAgICB2YXIgbWF0Y2gyICAgICAgICAgPSAvXFxkXFxkLzsgICAgICAgICAgLy8gICAgICAwMCAtIDk5XG4gICAgICB2YXIgbWF0Y2gzICAgICAgICAgPSAvXFxkezN9LzsgICAgICAgICAvLyAgICAgMDAwIC0gOTk5XG4gICAgICB2YXIgbWF0Y2g0ICAgICAgICAgPSAvXFxkezR9LzsgICAgICAgICAvLyAgICAwMDAwIC0gOTk5OVxuICAgICAgdmFyIG1hdGNoNiAgICAgICAgID0gL1srLV0/XFxkezZ9LzsgICAgLy8gLTk5OTk5OSAtIDk5OTk5OVxuICAgICAgdmFyIG1hdGNoMXRvMiAgICAgID0gL1xcZFxcZD8vOyAgICAgICAgIC8vICAgICAgIDAgLSA5OVxuICAgICAgdmFyIG1hdGNoM3RvNCAgICAgID0gL1xcZFxcZFxcZFxcZD8vOyAgICAgLy8gICAgIDk5OSAtIDk5OTlcbiAgICAgIHZhciBtYXRjaDV0bzYgICAgICA9IC9cXGRcXGRcXGRcXGRcXGRcXGQ/LzsgLy8gICA5OTk5OSAtIDk5OTk5OVxuICAgICAgdmFyIG1hdGNoMXRvMyAgICAgID0gL1xcZHsxLDN9LzsgICAgICAgLy8gICAgICAgMCAtIDk5OVxuICAgICAgdmFyIG1hdGNoMXRvNCAgICAgID0gL1xcZHsxLDR9LzsgICAgICAgLy8gICAgICAgMCAtIDk5OTlcbiAgICAgIHZhciBtYXRjaDF0bzYgICAgICA9IC9bKy1dP1xcZHsxLDZ9LzsgIC8vIC05OTk5OTkgLSA5OTk5OTlcblxuICAgICAgdmFyIG1hdGNoVW5zaWduZWQgID0gL1xcZCsvOyAgICAgICAgICAgLy8gICAgICAgMCAtIGluZlxuICAgICAgdmFyIG1hdGNoU2lnbmVkICAgID0gL1srLV0/XFxkKy87ICAgICAgLy8gICAgLWluZiAtIGluZlxuXG4gICAgICB2YXIgbWF0Y2hPZmZzZXQgICAgPSAvWnxbKy1dXFxkXFxkOj9cXGRcXGQvZ2k7IC8vICswMDowMCAtMDA6MDAgKzAwMDAgLTAwMDAgb3IgWlxuICAgICAgdmFyIG1hdGNoU2hvcnRPZmZzZXQgPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy9naTsgLy8gKzAwIC0wMCArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcblxuICAgICAgdmFyIG1hdGNoVGltZXN0YW1wID0gL1srLV0/XFxkKyhcXC5cXGR7MSwzfSk/LzsgLy8gMTIzNDU2Nzg5IDEyMzQ1Njc4OS4xMjNcblxuICAgICAgLy8gYW55IHdvcmQgKG9yIHR3bykgY2hhcmFjdGVycyBvciBudW1iZXJzIGluY2x1ZGluZyB0d28vdGhyZWUgd29yZCBtb250aCBpbiBhcmFiaWMuXG4gICAgICAvLyBpbmNsdWRlcyBzY290dGlzaCBnYWVsaWMgdHdvIHdvcmQgYW5kIGh5cGhlbmF0ZWQgbW9udGhzXG4gICAgICB2YXIgbWF0Y2hXb3JkID0gL1swLTldKlsnYS16XFx1MDBBMC1cXHUwNUZGXFx1MDcwMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSt8W1xcdTA2MDAtXFx1MDZGRlxcL10rKFxccyo/W1xcdTA2MDAtXFx1MDZGRl0rKXsxLDJ9L2k7XG5cblxuICAgICAgdmFyIHJlZ2V4ZXMgPSB7fTtcblxuICAgICAgZnVuY3Rpb24gYWRkUmVnZXhUb2tlbiAodG9rZW4sIHJlZ2V4LCBzdHJpY3RSZWdleCkge1xuICAgICAgICAgIHJlZ2V4ZXNbdG9rZW5dID0gaXNGdW5jdGlvbihyZWdleCkgPyByZWdleCA6IGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlRGF0YSkge1xuICAgICAgICAgICAgICByZXR1cm4gKGlzU3RyaWN0ICYmIHN0cmljdFJlZ2V4KSA/IHN0cmljdFJlZ2V4IDogcmVnZXg7XG4gICAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0UGFyc2VSZWdleEZvclRva2VuICh0b2tlbiwgY29uZmlnKSB7XG4gICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHJlZ2V4ZXMsIHRva2VuKSkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCh1bmVzY2FwZUZvcm1hdCh0b2tlbikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZWdleGVzW3Rva2VuXShjb25maWcuX3N0cmljdCwgY29uZmlnLl9sb2NhbGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBDb2RlIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNTYxNDkzL2lzLXRoZXJlLWEtcmVnZXhwLWVzY2FwZS1mdW5jdGlvbi1pbi1qYXZhc2NyaXB0XG4gICAgICBmdW5jdGlvbiB1bmVzY2FwZUZvcm1hdChzKSB7XG4gICAgICAgICAgcmV0dXJuIHJlZ2V4RXNjYXBlKHMucmVwbGFjZSgnXFxcXCcsICcnKS5yZXBsYWNlKC9cXFxcKFxcWyl8XFxcXChcXF0pfFxcWyhbXlxcXVxcW10qKVxcXXxcXFxcKC4pL2csIGZ1bmN0aW9uIChtYXRjaGVkLCBwMSwgcDIsIHAzLCBwNCkge1xuICAgICAgICAgICAgICByZXR1cm4gcDEgfHwgcDIgfHwgcDMgfHwgcDQ7XG4gICAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiByZWdleEVzY2FwZShzKSB7XG4gICAgICAgICAgcmV0dXJuIHMucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0b2tlbnMgPSB7fTtcblxuICAgICAgZnVuY3Rpb24gYWRkUGFyc2VUb2tlbiAodG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIGksIGZ1bmMgPSBjYWxsYmFjaztcbiAgICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICB0b2tlbiA9IFt0b2tlbl07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgICAgICAgICAgICBhcnJheVtjYWxsYmFja10gPSB0b0ludChpbnB1dCk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB0b2tlbnNbdG9rZW5baV1dID0gZnVuYztcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGFkZFdlZWtQYXJzZVRva2VuICh0b2tlbiwgY2FsbGJhY2spIHtcbiAgICAgICAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgICAgICAgIGNvbmZpZy5fdyA9IGNvbmZpZy5fdyB8fCB7fTtcbiAgICAgICAgICAgICAgY2FsbGJhY2soaW5wdXQsIGNvbmZpZy5fdywgY29uZmlnLCB0b2tlbik7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBpbnB1dCwgY29uZmlnKSB7XG4gICAgICAgICAgaWYgKGlucHV0ICE9IG51bGwgJiYgaGFzT3duUHJvcCh0b2tlbnMsIHRva2VuKSkge1xuICAgICAgICAgICAgICB0b2tlbnNbdG9rZW5dKGlucHV0LCBjb25maWcuX2EsIGNvbmZpZywgdG9rZW4pO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIFlFQVIgPSAwO1xuICAgICAgdmFyIE1PTlRIID0gMTtcbiAgICAgIHZhciBEQVRFID0gMjtcbiAgICAgIHZhciBIT1VSID0gMztcbiAgICAgIHZhciBNSU5VVEUgPSA0O1xuICAgICAgdmFyIFNFQ09ORCA9IDU7XG4gICAgICB2YXIgTUlMTElTRUNPTkQgPSA2O1xuICAgICAgdmFyIFdFRUsgPSA3O1xuICAgICAgdmFyIFdFRUtEQVkgPSA4O1xuXG4gICAgICB2YXIgaW5kZXhPZjtcblxuICAgICAgaWYgKEFycmF5LnByb3RvdHlwZS5pbmRleE9mKSB7XG4gICAgICAgICAgaW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmRleE9mID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgICAgLy8gSSBrbm93XG4gICAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXNbaV0gPT09IG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGF5c0luTW9udGgoeWVhciwgbW9udGgpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGggKyAxLCAwKSkuZ2V0VVRDRGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICAgIGFkZEZvcm1hdFRva2VuKCdNJywgWydNTScsIDJdLCAnTW8nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubW9udGgoKSArIDE7XG4gICAgICB9KTtcblxuICAgICAgYWRkRm9ybWF0VG9rZW4oJ01NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubW9udGhzU2hvcnQodGhpcywgZm9ybWF0KTtcbiAgICAgIH0pO1xuXG4gICAgICBhZGRGb3JtYXRUb2tlbignTU1NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubW9udGhzKHRoaXMsIGZvcm1hdCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gQUxJQVNFU1xuXG4gICAgICBhZGRVbml0QWxpYXMoJ21vbnRoJywgJ00nKTtcblxuICAgICAgLy8gUEFSU0lOR1xuXG4gICAgICBhZGRSZWdleFRva2VuKCdNJywgICAgbWF0Y2gxdG8yKTtcbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ01NJywgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgICBhZGRSZWdleFRva2VuKCdNTU0nLCAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgICByZXR1cm4gbG9jYWxlLm1vbnRoc1Nob3J0UmVnZXgoaXNTdHJpY3QpO1xuICAgICAgfSk7XG4gICAgICBhZGRSZWdleFRva2VuKCdNTU1NJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgICByZXR1cm4gbG9jYWxlLm1vbnRoc1JlZ2V4KGlzU3RyaWN0KTtcbiAgICAgIH0pO1xuXG4gICAgICBhZGRQYXJzZVRva2VuKFsnTScsICdNTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgICAgYXJyYXlbTU9OVEhdID0gdG9JbnQoaW5wdXQpIC0gMTtcbiAgICAgIH0pO1xuXG4gICAgICBhZGRQYXJzZVRva2VuKFsnTU1NJywgJ01NTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICAgIHZhciBtb250aCA9IGNvbmZpZy5fbG9jYWxlLm1vbnRoc1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgICAgICAgIC8vIGlmIHdlIGRpZG4ndCBmaW5kIGEgbW9udGggbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkLlxuICAgICAgICAgIGlmIChtb250aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGFycmF5W01PTlRIXSA9IG1vbnRoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRNb250aCA9IGlucHV0O1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBMT0NBTEVTXG5cbiAgICAgIHZhciBNT05USFNfSU5fRk9STUFUID0gL0Rbb0RdPyhcXFtbXlxcW1xcXV0qXFxdfFxccyspK01NTU0/LztcbiAgICAgIHZhciBkZWZhdWx0TG9jYWxlTW9udGhzID0gJ0phbnVhcnlfRmVicnVhcnlfTWFyY2hfQXByaWxfTWF5X0p1bmVfSnVseV9BdWd1c3RfU2VwdGVtYmVyX09jdG9iZXJfTm92ZW1iZXJfRGVjZW1iZXInLnNwbGl0KCdfJyk7XG4gICAgICBmdW5jdGlvbiBsb2NhbGVNb250aHMgKG0sIGZvcm1hdCkge1xuICAgICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocykgPyB0aGlzLl9tb250aHNbbS5tb250aCgpXSA6XG4gICAgICAgICAgICAgIHRoaXMuX21vbnRoc1tNT05USFNfSU5fRk9STUFULnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLm1vbnRoKCldO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0ID0gJ0phbl9GZWJfTWFyX0Fwcl9NYXlfSnVuX0p1bF9BdWdfU2VwX09jdF9Ob3ZfRGVjJy5zcGxpdCgnXycpO1xuICAgICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzU2hvcnQgKG0sIGZvcm1hdCkge1xuICAgICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KSA/IHRoaXMuX21vbnRoc1Nob3J0W20ubW9udGgoKV0gOlxuICAgICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFtNT05USFNfSU5fRk9STUFULnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLm1vbnRoKCldO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB1bml0c19tb250aF9faGFuZGxlU3RyaWN0UGFyc2UobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICAgIHZhciBpLCBpaSwgbW9tLCBsbGMgPSBtb250aE5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlKSB7XG4gICAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IHVzZWRcbiAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgIG1vbSA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdNTU0nKSB7XG4gICAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBsb2NhbGVNb250aHNQYXJzZSAobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVuaXRzX21vbnRoX19oYW5kbGVTdHJpY3RQYXJzZS5jYWxsKHRoaXMsIG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBUT0RPOiBhZGQgc29ydGluZ1xuICAgICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXJcbiAgICAgICAgICAvLyBzZWUgc29ydGluZyBpbiBjb21wdXRlTW9udGhzUGFyc2VcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgICAgbW9tID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghc3RyaWN0ICYmICF0aGlzLl9tb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKSArICd8XicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdNTU1NJyAmJiB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnTU1NJyAmJiB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl9tb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBNT01FTlRTXG5cbiAgICAgIGZ1bmN0aW9uIHNldE1vbnRoIChtb20sIHZhbHVlKSB7XG4gICAgICAgICAgdmFyIGRheU9mTW9udGg7XG5cbiAgICAgICAgICBpZiAoIW1vbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgICAgICAgcmV0dXJuIG1vbTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBpZiAoL15cXGQrJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gdG9JbnQodmFsdWUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFsdWUgPSBtb20ubG9jYWxlRGF0YSgpLm1vbnRoc1BhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIC8vIFRPRE86IEFub3RoZXIgc2lsZW50IGZhaWx1cmU/XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtb207XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkYXlPZk1vbnRoID0gTWF0aC5taW4obW9tLmRhdGUoKSwgZGF5c0luTW9udGgobW9tLnllYXIoKSwgdmFsdWUpKTtcbiAgICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgJ01vbnRoJ10odmFsdWUsIGRheU9mTW9udGgpO1xuICAgICAgICAgIHJldHVybiBtb207XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldFNldE1vbnRoICh2YWx1ZSkge1xuICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHNldE1vbnRoKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldF9zZXRfX2dldCh0aGlzLCAnTW9udGgnKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldERheXNJbk1vbnRoICgpIHtcbiAgICAgICAgICByZXR1cm4gZGF5c0luTW9udGgodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWZhdWx0TW9udGhzU2hvcnRSZWdleCA9IG1hdGNoV29yZDtcbiAgICAgIGZ1bmN0aW9uIG1vbnRoc1Nob3J0UmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgICAgY29tcHV0ZU1vbnRoc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCA6IHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZGVmYXVsdE1vbnRoc1JlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgICAgZnVuY3Rpb24gbW9udGhzUmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgICAgY29tcHV0ZU1vbnRoc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXg7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggOiB0aGlzLl9tb250aHNSZWdleDtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNvbXB1dGVNb250aHNQYXJzZSAoKSB7XG4gICAgICAgICAgZnVuY3Rpb24gY21wTGVuUmV2KGEsIGIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHNob3J0UGllY2VzID0gW10sIGxvbmdQaWVjZXMgPSBbXSwgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgICAgaSwgbW9tO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgICBtb20gPSBjcmVhdGVfdXRjX19jcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgICAgc2hvcnRQaWVjZXMucHVzaCh0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKHRoaXMubW9udGhzKG1vbSwgJycpKTtcbiAgICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XG4gICAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2godGhpcy5tb250aHNTaG9ydChtb20sICcnKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcbiAgICAgICAgICAvLyB3aWxsIG1hdGNoIHRoZSBsb25nZXIgcGllY2UuXG4gICAgICAgICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICAgIG1peGVkUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgICBzaG9ydFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKHNob3J0UGllY2VzW2ldKTtcbiAgICAgICAgICAgICAgbG9uZ1BpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKGxvbmdQaWVjZXNbaV0pO1xuICAgICAgICAgICAgICBtaXhlZFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKG1peGVkUGllY2VzW2ldKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9tb250aHNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgICAgdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjaGVja092ZXJmbG93IChtKSB7XG4gICAgICAgICAgdmFyIG92ZXJmbG93O1xuICAgICAgICAgIHZhciBhID0gbS5fYTtcblxuICAgICAgICAgIGlmIChhICYmIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9PT0gLTIpIHtcbiAgICAgICAgICAgICAgb3ZlcmZsb3cgPVxuICAgICAgICAgICAgICAgICAgYVtNT05USF0gICAgICAgPCAwIHx8IGFbTU9OVEhdICAgICAgID4gMTEgID8gTU9OVEggOlxuICAgICAgICAgICAgICAgICAgYVtEQVRFXSAgICAgICAgPCAxIHx8IGFbREFURV0gICAgICAgID4gZGF5c0luTW9udGgoYVtZRUFSXSwgYVtNT05USF0pID8gREFURSA6XG4gICAgICAgICAgICAgICAgICBhW0hPVVJdICAgICAgICA8IDAgfHwgYVtIT1VSXSAgICAgICAgPiAyNCB8fCAoYVtIT1VSXSA9PT0gMjQgJiYgKGFbTUlOVVRFXSAhPT0gMCB8fCBhW1NFQ09ORF0gIT09IDAgfHwgYVtNSUxMSVNFQ09ORF0gIT09IDApKSA/IEhPVVIgOlxuICAgICAgICAgICAgICAgICAgYVtNSU5VVEVdICAgICAgPCAwIHx8IGFbTUlOVVRFXSAgICAgID4gNTkgID8gTUlOVVRFIDpcbiAgICAgICAgICAgICAgICAgIGFbU0VDT05EXSAgICAgIDwgMCB8fCBhW1NFQ09ORF0gICAgICA+IDU5ICA/IFNFQ09ORCA6XG4gICAgICAgICAgICAgICAgICBhW01JTExJU0VDT05EXSA8IDAgfHwgYVtNSUxMSVNFQ09ORF0gPiA5OTkgPyBNSUxMSVNFQ09ORCA6XG4gICAgICAgICAgICAgICAgICAtMTtcblxuICAgICAgICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd0RheU9mWWVhciAmJiAob3ZlcmZsb3cgPCBZRUFSIHx8IG92ZXJmbG93ID4gREFURSkpIHtcbiAgICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gREFURTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd1dlZWtzICYmIG92ZXJmbG93ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla2RheSAmJiBvdmVyZmxvdyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gV0VFS0RBWTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9IG92ZXJmbG93O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBtO1xuICAgICAgfVxuXG4gICAgICAvLyBpc28gODYwMSByZWdleFxuICAgICAgLy8gMDAwMC0wMC0wMCAwMDAwLVcwMCBvciAwMDAwLVcwMC0wICsgVCArIDAwIG9yIDAwOjAwIG9yIDAwOjAwOjAwIG9yIDAwOjAwOjAwLjAwMCArICswMDowMCBvciArMDAwMCBvciArMDApXG4gICAgICB2YXIgZXh0ZW5kZWRJc29SZWdleCA9IC9eXFxzKigoPzpbKy1dXFxkezZ9fFxcZHs0fSktKD86XFxkXFxkLVxcZFxcZHxXXFxkXFxkLVxcZHxXXFxkXFxkfFxcZFxcZFxcZHxcXGRcXGQpKSg/OihUfCApKFxcZFxcZCg/OjpcXGRcXGQoPzo6XFxkXFxkKD86Wy4sXVxcZCspPyk/KT8pKFtcXCtcXC1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8vO1xuICAgICAgdmFyIGJhc2ljSXNvUmVnZXggPSAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pKD86XFxkXFxkXFxkXFxkfFdcXGRcXGRcXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkKSkoPzooVHwgKShcXGRcXGQoPzpcXGRcXGQoPzpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoW1xcK1xcLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPy87XG5cbiAgICAgIHZhciB0elJlZ2V4ID0gL1p8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8vO1xuXG4gICAgICB2YXIgaXNvRGF0ZXMgPSBbXG4gICAgICAgICAgWydZWVlZWVktTU0tREQnLCAvWystXVxcZHs2fS1cXGRcXGQtXFxkXFxkL10sXG4gICAgICAgICAgWydZWVlZLU1NLUREJywgL1xcZHs0fS1cXGRcXGQtXFxkXFxkL10sXG4gICAgICAgICAgWydHR0dHLVtXXVdXLUUnLCAvXFxkezR9LVdcXGRcXGQtXFxkL10sXG4gICAgICAgICAgWydHR0dHLVtXXVdXJywgL1xcZHs0fS1XXFxkXFxkLywgZmFsc2VdLFxuICAgICAgICAgIFsnWVlZWS1EREQnLCAvXFxkezR9LVxcZHszfS9dLFxuICAgICAgICAgIFsnWVlZWS1NTScsIC9cXGR7NH0tXFxkXFxkLywgZmFsc2VdLFxuICAgICAgICAgIFsnWVlZWVlZTU1ERCcsIC9bKy1dXFxkezEwfS9dLFxuICAgICAgICAgIFsnWVlZWU1NREQnLCAvXFxkezh9L10sXG4gICAgICAgICAgLy8gWVlZWU1NIGlzIE5PVCBhbGxvd2VkIGJ5IHRoZSBzdGFuZGFyZFxuICAgICAgICAgIFsnR0dHR1tXXVdXRScsIC9cXGR7NH1XXFxkezN9L10sXG4gICAgICAgICAgWydHR0dHW1ddV1cnLCAvXFxkezR9V1xcZHsyfS8sIGZhbHNlXSxcbiAgICAgICAgICBbJ1lZWVlEREQnLCAvXFxkezd9L11cbiAgICAgIF07XG5cbiAgICAgIC8vIGlzbyB0aW1lIGZvcm1hdHMgYW5kIHJlZ2V4ZXNcbiAgICAgIHZhciBpc29UaW1lcyA9IFtcbiAgICAgICAgICBbJ0hIOm1tOnNzLlNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGRcXC5cXGQrL10sXG4gICAgICAgICAgWydISDptbTpzcyxTU1NTJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkLFxcZCsvXSxcbiAgICAgICAgICBbJ0hIOm1tOnNzJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkL10sXG4gICAgICAgICAgWydISDptbScsIC9cXGRcXGQ6XFxkXFxkL10sXG4gICAgICAgICAgWydISG1tc3MuU1NTUycsIC9cXGRcXGRcXGRcXGRcXGRcXGRcXC5cXGQrL10sXG4gICAgICAgICAgWydISG1tc3MsU1NTUycsIC9cXGRcXGRcXGRcXGRcXGRcXGQsXFxkKy9dLFxuICAgICAgICAgIFsnSEhtbXNzJywgL1xcZFxcZFxcZFxcZFxcZFxcZC9dLFxuICAgICAgICAgIFsnSEhtbScsIC9cXGRcXGRcXGRcXGQvXSxcbiAgICAgICAgICBbJ0hIJywgL1xcZFxcZC9dXG4gICAgICBdO1xuXG4gICAgICB2YXIgYXNwTmV0SnNvblJlZ2V4ID0gL15cXC8/RGF0ZVxcKChcXC0/XFxkKykvaTtcblxuICAgICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXRcbiAgICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21JU08oY29uZmlnKSB7XG4gICAgICAgICAgdmFyIGksIGwsXG4gICAgICAgICAgICAgIHN0cmluZyA9IGNvbmZpZy5faSxcbiAgICAgICAgICAgICAgbWF0Y2ggPSBleHRlbmRlZElzb1JlZ2V4LmV4ZWMoc3RyaW5nKSB8fCBiYXNpY0lzb1JlZ2V4LmV4ZWMoc3RyaW5nKSxcbiAgICAgICAgICAgICAgYWxsb3dUaW1lLCBkYXRlRm9ybWF0LCB0aW1lRm9ybWF0LCB0ekZvcm1hdDtcblxuICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pc28gPSB0cnVlO1xuXG4gICAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29EYXRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpc29EYXRlc1tpXVsxXS5leGVjKG1hdGNoWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICAgIGRhdGVGb3JtYXQgPSBpc29EYXRlc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgICBhbGxvd1RpbWUgPSBpc29EYXRlc1tpXVsyXSAhPT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGRhdGVGb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG1hdGNoWzNdKSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvVGltZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGlzb1RpbWVzW2ldWzFdLmV4ZWMobWF0Y2hbM10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hdGNoWzJdIHNob3VsZCBiZSAnVCcgb3Igc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZUZvcm1hdCA9IChtYXRjaFsyXSB8fCAnICcpICsgaXNvVGltZXNbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmICh0aW1lRm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFhbGxvd1RpbWUgJiYgdGltZUZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobWF0Y2hbNF0pIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0elJlZ2V4LmV4ZWMobWF0Y2hbNF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdHpGb3JtYXQgPSAnWic7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25maWcuX2YgPSBkYXRlRm9ybWF0ICsgKHRpbWVGb3JtYXQgfHwgJycpICsgKHR6Rm9ybWF0IHx8ICcnKTtcbiAgICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXQgb3IgZmFsbGJhY2tcbiAgICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmcoY29uZmlnKSB7XG4gICAgICAgICAgdmFyIG1hdGNoZWQgPSBhc3BOZXRKc29uUmVnZXguZXhlYyhjb25maWcuX2kpO1xuXG4gICAgICAgICAgaWYgKG1hdGNoZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoK21hdGNoZWRbMV0pO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uZmlnRnJvbUlTTyhjb25maWcpO1xuICAgICAgICAgIGlmIChjb25maWcuX2lzVmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrID0gZGVwcmVjYXRlKFxuICAgICAgICAgICdtb21lbnQgY29uc3RydWN0aW9uIGZhbGxzIGJhY2sgdG8ganMgRGF0ZS4gVGhpcyBpcyAnICtcbiAgICAgICAgICAnZGlzY291cmFnZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB1cGNvbWluZyBtYWpvciAnICtcbiAgICAgICAgICAncmVsZWFzZS4gUGxlYXNlIHJlZmVyIHRvICcgK1xuICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTQwNyBmb3IgbW9yZSBpbmZvLicsXG4gICAgICAgICAgZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShjb25maWcuX2kgKyAoY29uZmlnLl91c2VVVEMgPyAnIFVUQycgOiAnJykpO1xuICAgICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZURhdGUgKHksIG0sIGQsIGgsIE0sIHMsIG1zKSB7XG4gICAgICAgICAgLy9jYW4ndCBqdXN0IGFwcGx5KCkgdG8gY3JlYXRlIGEgZGF0ZTpcbiAgICAgICAgICAvL2h0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTgxMzQ4L2luc3RhbnRpYXRpbmctYS1qYXZhc2NyaXB0LW9iamVjdC1ieS1jYWxsaW5nLXByb3RvdHlwZS1jb25zdHJ1Y3Rvci1hcHBseVxuICAgICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoeSwgbSwgZCwgaCwgTSwgcywgbXMpO1xuXG4gICAgICAgICAgLy90aGUgZGF0ZSBjb25zdHJ1Y3RvciByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDAgJiYgaXNGaW5pdGUoZGF0ZS5nZXRGdWxsWWVhcigpKSkge1xuICAgICAgICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY3JlYXRlVVRDRGF0ZSAoeSkge1xuICAgICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG5cbiAgICAgICAgICAvL3RoZSBEYXRlLlVUQyBmdW5jdGlvbiByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDAgJiYgaXNGaW5pdGUoZGF0ZS5nZXRVVENGdWxsWWVhcigpKSkge1xuICAgICAgICAgICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgIH1cblxuICAgICAgLy8gRk9STUFUVElOR1xuXG4gICAgICBhZGRGb3JtYXRUb2tlbignWScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgeSA9IHRoaXMueWVhcigpO1xuICAgICAgICAgIHJldHVybiB5IDw9IDk5OTkgPyAnJyArIHkgOiAnKycgKyB5O1xuICAgICAgfSk7XG5cbiAgICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVknLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnllYXIoKSAlIDEwMDtcbiAgICAgIH0pO1xuXG4gICAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVknLCAgIDRdLCAgICAgICAwLCAneWVhcicpO1xuICAgICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWScsICA1XSwgICAgICAgMCwgJ3llYXInKTtcbiAgICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVlZJywgNiwgdHJ1ZV0sIDAsICd5ZWFyJyk7XG5cbiAgICAgIC8vIEFMSUFTRVNcblxuICAgICAgYWRkVW5pdEFsaWFzKCd5ZWFyJywgJ3knKTtcblxuICAgICAgLy8gUEFSU0lOR1xuXG4gICAgICBhZGRSZWdleFRva2VuKCdZJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgICBhZGRSZWdleFRva2VuKCdZWScsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgICBhZGRSZWdleFRva2VuKCdZWVlZJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgICBhZGRSZWdleFRva2VuKCdZWVlZWScsICBtYXRjaDF0bzYsIG1hdGNoNik7XG4gICAgICBhZGRSZWdleFRva2VuKCdZWVlZWVknLCBtYXRjaDF0bzYsIG1hdGNoNik7XG5cbiAgICAgIGFkZFBhcnNlVG9rZW4oWydZWVlZWScsICdZWVlZWVknXSwgWUVBUik7XG4gICAgICBhZGRQYXJzZVRva2VuKCdZWVlZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICAgIGFycmF5W1lFQVJdID0gaW5wdXQubGVuZ3RoID09PSAyID8gdXRpbHNfaG9va3NfX2hvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KSA6IHRvSW50KGlucHV0KTtcbiAgICAgIH0pO1xuICAgICAgYWRkUGFyc2VUb2tlbignWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgICAgYXJyYXlbWUVBUl0gPSB1dGlsc19ob29rc19faG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xuICAgICAgfSk7XG4gICAgICBhZGRQYXJzZVRva2VuKCdZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICAgIGFycmF5W1lFQVJdID0gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBIRUxQRVJTXG5cbiAgICAgIGZ1bmN0aW9uIGRheXNJblllYXIoeWVhcikge1xuICAgICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHllYXIpID8gMzY2IDogMzY1O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgICAgICAgICByZXR1cm4gKHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDApIHx8IHllYXIgJSA0MDAgPT09IDA7XG4gICAgICB9XG5cbiAgICAgIC8vIEhPT0tTXG5cbiAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5wYXJzZVR3b0RpZ2l0WWVhciA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgIHJldHVybiB0b0ludChpbnB1dCkgKyAodG9JbnQoaW5wdXQpID4gNjggPyAxOTAwIDogMjAwMCk7XG4gICAgICB9O1xuXG4gICAgICAvLyBNT01FTlRTXG5cbiAgICAgIHZhciBnZXRTZXRZZWFyID0gbWFrZUdldFNldCgnRnVsbFllYXInLCB0cnVlKTtcblxuICAgICAgZnVuY3Rpb24gZ2V0SXNMZWFwWWVhciAoKSB7XG4gICAgICAgICAgcmV0dXJuIGlzTGVhcFllYXIodGhpcy55ZWFyKCkpO1xuICAgICAgfVxuXG4gICAgICAvLyBzdGFydC1vZi1maXJzdC13ZWVrIC0gc3RhcnQtb2YteWVhclxuICAgICAgZnVuY3Rpb24gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSB7XG4gICAgICAgICAgdmFyIC8vIGZpcnN0LXdlZWsgZGF5IC0tIHdoaWNoIGphbnVhcnkgaXMgYWx3YXlzIGluIHRoZSBmaXJzdCB3ZWVrICg0IGZvciBpc28sIDEgZm9yIG90aGVyKVxuICAgICAgICAgICAgICBmd2QgPSA3ICsgZG93IC0gZG95LFxuICAgICAgICAgICAgICAvLyBmaXJzdC13ZWVrIGRheSBsb2NhbCB3ZWVrZGF5IC0tIHdoaWNoIGxvY2FsIHdlZWtkYXkgaXMgZndkXG4gICAgICAgICAgICAgIGZ3ZGx3ID0gKDcgKyBjcmVhdGVVVENEYXRlKHllYXIsIDAsIGZ3ZCkuZ2V0VVRDRGF5KCkgLSBkb3cpICUgNztcblxuICAgICAgICAgIHJldHVybiAtZndkbHcgKyBmd2QgLSAxO1xuICAgICAgfVxuXG4gICAgICAvL2h0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZSNDYWxjdWxhdGluZ19hX2RhdGVfZ2l2ZW5fdGhlX3llYXIuMkNfd2Vla19udW1iZXJfYW5kX3dlZWtkYXlcbiAgICAgIGZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrcyh5ZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICAgIHZhciBsb2NhbFdlZWtkYXkgPSAoNyArIHdlZWtkYXkgLSBkb3cpICUgNyxcbiAgICAgICAgICAgICAgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSksXG4gICAgICAgICAgICAgIGRheU9mWWVhciA9IDEgKyA3ICogKHdlZWsgLSAxKSArIGxvY2FsV2Vla2RheSArIHdlZWtPZmZzZXQsXG4gICAgICAgICAgICAgIHJlc1llYXIsIHJlc0RheU9mWWVhcjtcblxuICAgICAgICAgIGlmIChkYXlPZlllYXIgPD0gMCkge1xuICAgICAgICAgICAgICByZXNZZWFyID0geWVhciAtIDE7XG4gICAgICAgICAgICAgIHJlc0RheU9mWWVhciA9IGRheXNJblllYXIocmVzWWVhcikgKyBkYXlPZlllYXI7XG4gICAgICAgICAgfSBlbHNlIGlmIChkYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXIpKSB7XG4gICAgICAgICAgICAgIHJlc1llYXIgPSB5ZWFyICsgMTtcbiAgICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyIC0gZGF5c0luWWVhcih5ZWFyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXNZZWFyID0geWVhcjtcbiAgICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHllYXI6IHJlc1llYXIsXG4gICAgICAgICAgICAgIGRheU9mWWVhcjogcmVzRGF5T2ZZZWFyXG4gICAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gd2Vla09mWWVhcihtb20sIGRvdywgZG95KSB7XG4gICAgICAgICAgdmFyIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQobW9tLnllYXIoKSwgZG93LCBkb3kpLFxuICAgICAgICAgICAgICB3ZWVrID0gTWF0aC5mbG9vcigobW9tLmRheU9mWWVhcigpIC0gd2Vla09mZnNldCAtIDEpIC8gNykgKyAxLFxuICAgICAgICAgICAgICByZXNXZWVrLCByZXNZZWFyO1xuXG4gICAgICAgICAgaWYgKHdlZWsgPCAxKSB7XG4gICAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpIC0gMTtcbiAgICAgICAgICAgICAgcmVzV2VlayA9IHdlZWsgKyB3ZWVrc0luWWVhcihyZXNZZWFyLCBkb3csIGRveSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh3ZWVrID4gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpKSB7XG4gICAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrIC0gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpO1xuICAgICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKSArIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCk7XG4gICAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHdlZWs6IHJlc1dlZWssXG4gICAgICAgICAgICAgIHllYXI6IHJlc1llYXJcbiAgICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB3ZWVrc0luWWVhcih5ZWFyLCBkb3csIGRveSkge1xuICAgICAgICAgIHZhciB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcbiAgICAgICAgICAgICAgd2Vla09mZnNldE5leHQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciArIDEsIGRvdywgZG95KTtcbiAgICAgICAgICByZXR1cm4gKGRheXNJblllYXIoeWVhcikgLSB3ZWVrT2Zmc2V0ICsgd2Vla09mZnNldE5leHQpIC8gNztcbiAgICAgIH1cblxuICAgICAgLy8gUGljayB0aGUgZmlyc3QgZGVmaW5lZCBvZiB0d28gb3IgdGhyZWUgYXJndW1lbnRzLlxuICAgICAgZnVuY3Rpb24gZGVmYXVsdHMoYSwgYiwgYykge1xuICAgICAgICAgIGlmIChhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChiICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZykge1xuICAgICAgICAgIC8vIGhvb2tzIGlzIGFjdHVhbGx5IHRoZSBleHBvcnRlZCBtb21lbnQgb2JqZWN0XG4gICAgICAgICAgdmFyIG5vd1ZhbHVlID0gbmV3IERhdGUodXRpbHNfaG9va3NfX2hvb2tzLm5vdygpKTtcbiAgICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtub3dWYWx1ZS5nZXRVVENGdWxsWWVhcigpLCBub3dWYWx1ZS5nZXRVVENNb250aCgpLCBub3dWYWx1ZS5nZXRVVENEYXRlKCldO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gW25vd1ZhbHVlLmdldEZ1bGxZZWFyKCksIG5vd1ZhbHVlLmdldE1vbnRoKCksIG5vd1ZhbHVlLmdldERhdGUoKV07XG4gICAgICB9XG5cbiAgICAgIC8vIGNvbnZlcnQgYW4gYXJyYXkgdG8gYSBkYXRlLlxuICAgICAgLy8gdGhlIGFycmF5IHNob3VsZCBtaXJyb3IgdGhlIHBhcmFtZXRlcnMgYmVsb3dcbiAgICAgIC8vIG5vdGU6IGFsbCB2YWx1ZXMgcGFzdCB0aGUgeWVhciBhcmUgb3B0aW9uYWwgYW5kIHdpbGwgZGVmYXVsdCB0byB0aGUgbG93ZXN0IHBvc3NpYmxlIHZhbHVlLlxuICAgICAgLy8gW3llYXIsIG1vbnRoLCBkYXkgLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmRdXG4gICAgICBmdW5jdGlvbiBjb25maWdGcm9tQXJyYXkgKGNvbmZpZykge1xuICAgICAgICAgIHZhciBpLCBkYXRlLCBpbnB1dCA9IFtdLCBjdXJyZW50RGF0ZSwgeWVhclRvVXNlO1xuXG4gICAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VycmVudERhdGUgPSBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZyk7XG5cbiAgICAgICAgICAvL2NvbXB1dGUgZGF5IG9mIHRoZSB5ZWFyIGZyb20gd2Vla3MgYW5kIHdlZWtkYXlzXG4gICAgICAgICAgaWYgKGNvbmZpZy5fdyAmJiBjb25maWcuX2FbREFURV0gPT0gbnVsbCAmJiBjb25maWcuX2FbTU9OVEhdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy9pZiB0aGUgZGF5IG9mIHRoZSB5ZWFyIGlzIHNldCwgZmlndXJlIG91dCB3aGF0IGl0IGlzXG4gICAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyKSB7XG4gICAgICAgICAgICAgIHllYXJUb1VzZSA9IGRlZmF1bHRzKGNvbmZpZy5fYVtZRUFSXSwgY3VycmVudERhdGVbWUVBUl0pO1xuXG4gICAgICAgICAgICAgIGlmIChjb25maWcuX2RheU9mWWVhciA+IGRheXNJblllYXIoeWVhclRvVXNlKSkge1xuICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93RGF5T2ZZZWFyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGRhdGUgPSBjcmVhdGVVVENEYXRlKHllYXJUb1VzZSwgMCwgY29uZmlnLl9kYXlPZlllYXIpO1xuICAgICAgICAgICAgICBjb25maWcuX2FbTU9OVEhdID0gZGF0ZS5nZXRVVENNb250aCgpO1xuICAgICAgICAgICAgICBjb25maWcuX2FbREFURV0gPSBkYXRlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBEZWZhdWx0IHRvIGN1cnJlbnQgZGF0ZS5cbiAgICAgICAgICAvLyAqIGlmIG5vIHllYXIsIG1vbnRoLCBkYXkgb2YgbW9udGggYXJlIGdpdmVuLCBkZWZhdWx0IHRvIHRvZGF5XG4gICAgICAgICAgLy8gKiBpZiBkYXkgb2YgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgbW9udGggYW5kIHllYXJcbiAgICAgICAgICAvLyAqIGlmIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG9ubHkgeWVhclxuICAgICAgICAgIC8vICogaWYgeWVhciBpcyBnaXZlbiwgZG9uJ3QgZGVmYXVsdCBhbnl0aGluZ1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAzICYmIGNvbmZpZy5fYVtpXSA9PSBudWxsOyArK2kpIHtcbiAgICAgICAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPSBjdXJyZW50RGF0ZVtpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBaZXJvIG91dCB3aGF0ZXZlciB3YXMgbm90IGRlZmF1bHRlZCwgaW5jbHVkaW5nIHRpbWVcbiAgICAgICAgICBmb3IgKDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IChjb25maWcuX2FbaV0gPT0gbnVsbCkgPyAoaSA9PT0gMiA/IDEgOiAwKSA6IGNvbmZpZy5fYVtpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDaGVjayBmb3IgMjQ6MDA6MDAuMDAwXG4gICAgICAgICAgaWYgKGNvbmZpZy5fYVtIT1VSXSA9PT0gMjQgJiZcbiAgICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtNSU5VVEVdID09PSAwICYmXG4gICAgICAgICAgICAgICAgICBjb25maWcuX2FbU0VDT05EXSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgY29uZmlnLl9hW01JTExJU0VDT05EXSA9PT0gMCkge1xuICAgICAgICAgICAgICBjb25maWcuX25leHREYXkgPSB0cnVlO1xuICAgICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbmZpZy5fZCA9IChjb25maWcuX3VzZVVUQyA/IGNyZWF0ZVVUQ0RhdGUgOiBjcmVhdGVEYXRlKS5hcHBseShudWxsLCBpbnB1dCk7XG4gICAgICAgICAgLy8gQXBwbHkgdGltZXpvbmUgb2Zmc2V0IGZyb20gaW5wdXQuIFRoZSBhY3R1YWwgdXRjT2Zmc2V0IGNhbiBiZSBjaGFuZ2VkXG4gICAgICAgICAgLy8gd2l0aCBwYXJzZVpvbmUuXG4gICAgICAgICAgaWYgKGNvbmZpZy5fdHptICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgY29uZmlnLl9kLnNldFVUQ01pbnV0ZXMoY29uZmlnLl9kLmdldFVUQ01pbnV0ZXMoKSAtIGNvbmZpZy5fdHptKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY29uZmlnLl9uZXh0RGF5KSB7XG4gICAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDI0O1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZykge1xuICAgICAgICAgIHZhciB3LCB3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3ksIHRlbXAsIHdlZWtkYXlPdmVyZmxvdztcblxuICAgICAgICAgIHcgPSBjb25maWcuX3c7XG4gICAgICAgICAgaWYgKHcuR0cgIT0gbnVsbCB8fCB3LlcgIT0gbnVsbCB8fCB3LkUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBkb3cgPSAxO1xuICAgICAgICAgICAgICBkb3kgPSA0O1xuXG4gICAgICAgICAgICAgIC8vIFRPRE86IFdlIG5lZWQgdG8gdGFrZSB0aGUgY3VycmVudCBpc29XZWVrWWVhciwgYnV0IHRoYXQgZGVwZW5kcyBvblxuICAgICAgICAgICAgICAvLyBob3cgd2UgaW50ZXJwcmV0IG5vdyAobG9jYWwsIHV0YywgZml4ZWQgb2Zmc2V0KS4gU28gY3JlYXRlXG4gICAgICAgICAgICAgIC8vIGEgbm93IHZlcnNpb24gb2YgY3VycmVudCBjb25maWcgKHRha2UgbG9jYWwvdXRjL29mZnNldCBmbGFncywgYW5kXG4gICAgICAgICAgICAgIC8vIGNyZWF0ZSBub3cpLlxuICAgICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuR0csIGNvbmZpZy5fYVtZRUFSXSwgd2Vla09mWWVhcihsb2NhbF9fY3JlYXRlTG9jYWwoKSwgMSwgNCkueWVhcik7XG4gICAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LlcsIDEpO1xuICAgICAgICAgICAgICB3ZWVrZGF5ID0gZGVmYXVsdHMody5FLCAxKTtcbiAgICAgICAgICAgICAgaWYgKHdlZWtkYXkgPCAxIHx8IHdlZWtkYXkgPiA3KSB7XG4gICAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZG93ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG93O1xuICAgICAgICAgICAgICBkb3kgPSBjb25maWcuX2xvY2FsZS5fd2Vlay5kb3k7XG5cbiAgICAgICAgICAgICAgd2Vla1llYXIgPSBkZWZhdWx0cyh3LmdnLCBjb25maWcuX2FbWUVBUl0sIHdlZWtPZlllYXIobG9jYWxfX2NyZWF0ZUxvY2FsKCksIGRvdywgZG95KS55ZWFyKTtcbiAgICAgICAgICAgICAgd2VlayA9IGRlZmF1bHRzKHcudywgMSk7XG5cbiAgICAgICAgICAgICAgaWYgKHcuZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAvLyB3ZWVrZGF5IC0tIGxvdyBkYXkgbnVtYmVycyBhcmUgY29uc2lkZXJlZCBuZXh0IHdlZWtcbiAgICAgICAgICAgICAgICAgIHdlZWtkYXkgPSB3LmQ7XG4gICAgICAgICAgICAgICAgICBpZiAod2Vla2RheSA8IDAgfHwgd2Vla2RheSA+IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHcuZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAvLyBsb2NhbCB3ZWVrZGF5IC0tIGNvdW50aW5nIHN0YXJ0cyBmcm9tIGJlZ2luaW5nIG9mIHdlZWtcbiAgICAgICAgICAgICAgICAgIHdlZWtkYXkgPSB3LmUgKyBkb3c7XG4gICAgICAgICAgICAgICAgICBpZiAody5lIDwgMCB8fCB3LmUgPiA2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gYmVnaW5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgICAgICAgd2Vla2RheSA9IGRvdztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAod2VlayA8IDEgfHwgd2VlayA+IHdlZWtzSW5ZZWFyKHdlZWtZZWFyLCBkb3csIGRveSkpIHtcbiAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla3MgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAod2Vla2RheU92ZXJmbG93ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla2RheSA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGVtcCA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xuICAgICAgICAgICAgICBjb25maWcuX2FbWUVBUl0gPSB0ZW1wLnllYXI7XG4gICAgICAgICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdGVtcC5kYXlPZlllYXI7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBjb25zdGFudCB0aGF0IHJlZmVycyB0byB0aGUgSVNPIHN0YW5kYXJkXG4gICAgICB1dGlsc19ob29rc19faG9va3MuSVNPXzg2MDEgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgZm9ybWF0IHN0cmluZ1xuICAgICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpIHtcbiAgICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gYW5vdGhlciBwYXJ0IG9mIHRoZSBjcmVhdGlvbiBmbG93IHRvIHByZXZlbnQgY2lyY3VsYXIgZGVwc1xuICAgICAgICAgIGlmIChjb25maWcuX2YgPT09IHV0aWxzX2hvb2tzX19ob29rcy5JU09fODYwMSkge1xuICAgICAgICAgICAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25maWcuX2EgPSBbXTtcbiAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IHRydWU7XG5cbiAgICAgICAgICAvLyBUaGlzIGFycmF5IGlzIHVzZWQgdG8gbWFrZSBhIERhdGUsIGVpdGhlciB3aXRoIGBuZXcgRGF0ZWAgb3IgYERhdGUuVVRDYFxuICAgICAgICAgIHZhciBzdHJpbmcgPSAnJyArIGNvbmZpZy5faSxcbiAgICAgICAgICAgICAgaSwgcGFyc2VkSW5wdXQsIHRva2VucywgdG9rZW4sIHNraXBwZWQsXG4gICAgICAgICAgICAgIHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG4gICAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggPSAwO1xuXG4gICAgICAgICAgdG9rZW5zID0gZXhwYW5kRm9ybWF0KGNvbmZpZy5fZiwgY29uZmlnLl9sb2NhbGUpLm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpIHx8IFtdO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgICAgcGFyc2VkSW5wdXQgPSAoc3RyaW5nLm1hdGNoKGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSkgfHwgW10pWzBdO1xuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygndG9rZW4nLCB0b2tlbiwgJ3BhcnNlZElucHV0JywgcGFyc2VkSW5wdXQsXG4gICAgICAgICAgICAgIC8vICAgICAgICAgJ3JlZ2V4JywgZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpKTtcbiAgICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgICBza2lwcGVkID0gc3RyaW5nLnN1YnN0cigwLCBzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkpO1xuICAgICAgICAgICAgICAgICAgaWYgKHNraXBwZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc2tpcHBlZCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2Uoc3RyaW5nLmluZGV4T2YocGFyc2VkSW5wdXQpICsgcGFyc2VkSW5wdXQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggKz0gcGFyc2VkSW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGRvbid0IHBhcnNlIGlmIGl0J3Mgbm90IGEga25vd24gdG9rZW5cbiAgICAgICAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBwYXJzZWRJbnB1dCwgY29uZmlnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChjb25maWcuX3N0cmljdCAmJiAhcGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGFkZCByZW1haW5pbmcgdW5wYXJzZWQgaW5wdXQgbGVuZ3RoIHRvIHRoZSBzdHJpbmdcbiAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5jaGFyc0xlZnRPdmVyID0gc3RyaW5nTGVuZ3RoIC0gdG90YWxQYXJzZWRJbnB1dExlbmd0aDtcbiAgICAgICAgICBpZiAoc3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChzdHJpbmcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGNsZWFyIF8xMmggZmxhZyBpZiBob3VyIGlzIDw9IDEyXG4gICAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPT09IHRydWUgJiZcbiAgICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA8PSAxMiAmJlxuICAgICAgICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID4gMCkge1xuICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnBhcnNlZERhdGVQYXJ0cyA9IGNvbmZpZy5fYS5zbGljZSgwKTtcbiAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5tZXJpZGllbSA9IGNvbmZpZy5fbWVyaWRpZW07XG4gICAgICAgICAgLy8gaGFuZGxlIG1lcmlkaWVtXG4gICAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gbWVyaWRpZW1GaXhXcmFwKGNvbmZpZy5fbG9jYWxlLCBjb25maWcuX2FbSE9VUl0sIGNvbmZpZy5fbWVyaWRpZW0pO1xuXG4gICAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgICAgICAgY2hlY2tPdmVyZmxvdyhjb25maWcpO1xuICAgICAgfVxuXG5cbiAgICAgIGZ1bmN0aW9uIG1lcmlkaWVtRml4V3JhcCAobG9jYWxlLCBob3VyLCBtZXJpZGllbSkge1xuICAgICAgICAgIHZhciBpc1BtO1xuXG4gICAgICAgICAgaWYgKG1lcmlkaWVtID09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gbm90aGluZyB0byBkb1xuICAgICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxvY2FsZS5tZXJpZGllbUhvdXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlLm1lcmlkaWVtSG91cihob3VyLCBtZXJpZGllbSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChsb2NhbGUuaXNQTSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIEZhbGxiYWNrXG4gICAgICAgICAgICAgIGlzUG0gPSBsb2NhbGUuaXNQTShtZXJpZGllbSk7XG4gICAgICAgICAgICAgIGlmIChpc1BtICYmIGhvdXIgPCAxMikge1xuICAgICAgICAgICAgICAgICAgaG91ciArPSAxMjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWlzUG0gJiYgaG91ciA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICAgIGhvdXIgPSAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IHN1cHBvc2VkIHRvIGhhcHBlblxuICAgICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGFycmF5IG9mIGZvcm1hdCBzdHJpbmdzXG4gICAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKSB7XG4gICAgICAgICAgdmFyIHRlbXBDb25maWcsXG4gICAgICAgICAgICAgIGJlc3RNb21lbnQsXG5cbiAgICAgICAgICAgICAgc2NvcmVUb0JlYXQsXG4gICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgIGN1cnJlbnRTY29yZTtcblxuICAgICAgICAgIGlmIChjb25maWcuX2YubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRGb3JtYXQgPSB0cnVlO1xuICAgICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbmZpZy5fZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBjdXJyZW50U2NvcmUgPSAwO1xuICAgICAgICAgICAgICB0ZW1wQ29uZmlnID0gY29weUNvbmZpZyh7fSwgY29uZmlnKTtcbiAgICAgICAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHRlbXBDb25maWcuX3VzZVVUQyA9IGNvbmZpZy5fdXNlVVRDO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRlbXBDb25maWcuX2YgPSBjb25maWcuX2ZbaV07XG4gICAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQodGVtcENvbmZpZyk7XG5cbiAgICAgICAgICAgICAgaWYgKCF2YWxpZF9faXNWYWxpZCh0ZW1wQ29uZmlnKSkge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbnkgaW5wdXQgdGhhdCB3YXMgbm90IHBhcnNlZCBhZGQgYSBwZW5hbHR5IGZvciB0aGF0IGZvcm1hdFxuICAgICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLmNoYXJzTGVmdE92ZXI7XG5cbiAgICAgICAgICAgICAgLy9vciB0b2tlbnNcbiAgICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS51bnVzZWRUb2tlbnMubGVuZ3RoICogMTA7XG5cbiAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnNjb3JlID0gY3VycmVudFNjb3JlO1xuXG4gICAgICAgICAgICAgIGlmIChzY29yZVRvQmVhdCA9PSBudWxsIHx8IGN1cnJlbnRTY29yZSA8IHNjb3JlVG9CZWF0KSB7XG4gICAgICAgICAgICAgICAgICBzY29yZVRvQmVhdCA9IGN1cnJlbnRTY29yZTtcbiAgICAgICAgICAgICAgICAgIGJlc3RNb21lbnQgPSB0ZW1wQ29uZmlnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXh0ZW5kKGNvbmZpZywgYmVzdE1vbWVudCB8fCB0ZW1wQ29uZmlnKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY29uZmlnRnJvbU9iamVjdChjb25maWcpIHtcbiAgICAgICAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaSA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGNvbmZpZy5faSk7XG4gICAgICAgICAgY29uZmlnLl9hID0gbWFwKFtpLnllYXIsIGkubW9udGgsIGkuZGF5IHx8IGkuZGF0ZSwgaS5ob3VyLCBpLm1pbnV0ZSwgaS5zZWNvbmQsIGkubWlsbGlzZWNvbmRdLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgIHJldHVybiBvYmogJiYgcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY3JlYXRlRnJvbUNvbmZpZyAoY29uZmlnKSB7XG4gICAgICAgICAgdmFyIHJlcyA9IG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhwcmVwYXJlQ29uZmlnKGNvbmZpZykpKTtcbiAgICAgICAgICBpZiAocmVzLl9uZXh0RGF5KSB7XG4gICAgICAgICAgICAgIC8vIEFkZGluZyBpcyBzbWFydCBlbm91Z2ggYXJvdW5kIERTVFxuICAgICAgICAgICAgICByZXMuYWRkKDEsICdkJyk7XG4gICAgICAgICAgICAgIHJlcy5fbmV4dERheSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwcmVwYXJlQ29uZmlnIChjb25maWcpIHtcbiAgICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2ksXG4gICAgICAgICAgICAgIGZvcm1hdCA9IGNvbmZpZy5fZjtcblxuICAgICAgICAgIGNvbmZpZy5fbG9jYWxlID0gY29uZmlnLl9sb2NhbGUgfHwgbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZShjb25maWcuX2wpO1xuXG4gICAgICAgICAgaWYgKGlucHV0ID09PSBudWxsIHx8IChmb3JtYXQgPT09IHVuZGVmaW5lZCAmJiBpbnB1dCA9PT0gJycpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YWxpZF9fY3JlYXRlSW52YWxpZCh7bnVsbElucHV0OiB0cnVlfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29uZmlnLl9pID0gaW5wdXQgPSBjb25maWcuX2xvY2FsZS5wcmVwYXJzZShpbnB1dCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzTW9tZW50KGlucHV0KSkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IE1vbWVudChjaGVja092ZXJmbG93KGlucHV0KSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQpIHtcbiAgICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xuICAgICAgICAgICAgICBjb25maWcuX2QgPSBpbnB1dDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25maWdGcm9tSW5wdXQoY29uZmlnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXZhbGlkX19pc1ZhbGlkKGNvbmZpZykpIHtcbiAgICAgICAgICAgICAgY29uZmlnLl9kID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjb25maWdGcm9tSW5wdXQoY29uZmlnKSB7XG4gICAgICAgICAgdmFyIGlucHV0ID0gY29uZmlnLl9pO1xuICAgICAgICAgIGlmIChpbnB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHV0aWxzX2hvb2tzX19ob29rcy5ub3coKSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XG4gICAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0LnZhbHVlT2YoKSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmcoY29uZmlnKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICAgIGNvbmZpZy5fYSA9IG1hcChpbnB1dC5zbGljZSgwKSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG9iaiwgMTApO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YoaW5wdXQpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICBjb25maWdGcm9tT2JqZWN0KGNvbmZpZyk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YoaW5wdXQpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAvLyBmcm9tIG1pbGxpc2Vjb25kc1xuICAgICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjcmVhdGVMb2NhbE9yVVRDIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgaXNVVEMpIHtcbiAgICAgICAgICB2YXIgYyA9IHt9O1xuXG4gICAgICAgICAgaWYgKHR5cGVvZihsb2NhbGUpID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgc3RyaWN0ID0gbG9jYWxlO1xuICAgICAgICAgICAgICBsb2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIG9iamVjdCBjb25zdHJ1Y3Rpb24gbXVzdCBiZSBkb25lIHRoaXMgd2F5LlxuICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNDIzXG4gICAgICAgICAgYy5faXNBTW9tZW50T2JqZWN0ID0gdHJ1ZTtcbiAgICAgICAgICBjLl91c2VVVEMgPSBjLl9pc1VUQyA9IGlzVVRDO1xuICAgICAgICAgIGMuX2wgPSBsb2NhbGU7XG4gICAgICAgICAgYy5faSA9IGlucHV0O1xuICAgICAgICAgIGMuX2YgPSBmb3JtYXQ7XG4gICAgICAgICAgYy5fc3RyaWN0ID0gc3RyaWN0O1xuXG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUZyb21Db25maWcoYyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGxvY2FsX19jcmVhdGVMb2NhbCAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvdG90eXBlTWluID0gZGVwcmVjYXRlKFxuICAgICAgICAgICAnbW9tZW50KCkubWluIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWF4IGluc3RlYWQuIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNTQ4JyxcbiAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgdmFyIG90aGVyID0gbG9jYWxfX2NyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyIDwgdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkX19jcmVhdGVJbnZhbGlkKCk7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgIH1cbiAgICAgICApO1xuXG4gICAgICB2YXIgcHJvdG90eXBlTWF4ID0gZGVwcmVjYXRlKFxuICAgICAgICAgICdtb21lbnQoKS5tYXggaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5taW4gaW5zdGVhZC4gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE1NDgnLFxuICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIG90aGVyID0gbG9jYWxfX2NyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBvdGhlciA+IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRfX2NyZWF0ZUludmFsaWQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIC8vIFBpY2sgYSBtb21lbnQgbSBmcm9tIG1vbWVudHMgc28gdGhhdCBtW2ZuXShvdGhlcikgaXMgdHJ1ZSBmb3IgYWxsXG4gICAgICAvLyBvdGhlci4gVGhpcyByZWxpZXMgb24gdGhlIGZ1bmN0aW9uIGZuIHRvIGJlIHRyYW5zaXRpdmUuXG4gICAgICAvL1xuICAgICAgLy8gbW9tZW50cyBzaG91bGQgZWl0aGVyIGJlIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzIG9yIGFuIGFycmF5LCB3aG9zZVxuICAgICAgLy8gZmlyc3QgZWxlbWVudCBpcyBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cy5cbiAgICAgIGZ1bmN0aW9uIHBpY2tCeShmbiwgbW9tZW50cykge1xuICAgICAgICAgIHZhciByZXMsIGk7XG4gICAgICAgICAgaWYgKG1vbWVudHMubGVuZ3RoID09PSAxICYmIGlzQXJyYXkobW9tZW50c1swXSkpIHtcbiAgICAgICAgICAgICAgbW9tZW50cyA9IG1vbWVudHNbMF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghbW9tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsX19jcmVhdGVMb2NhbCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXMgPSBtb21lbnRzWzBdO1xuICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBtb21lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGlmICghbW9tZW50c1tpXS5pc1ZhbGlkKCkgfHwgbW9tZW50c1tpXVtmbl0ocmVzKSkge1xuICAgICAgICAgICAgICAgICAgcmVzID0gbW9tZW50c1tpXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuXG4gICAgICAvLyBUT0RPOiBVc2UgW10uc29ydCBpbnN0ZWFkP1xuICAgICAgZnVuY3Rpb24gbWluICgpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICAgIHJldHVybiBwaWNrQnkoJ2lzQmVmb3JlJywgYXJncyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG1heCAoKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICAgICAgICByZXR1cm4gcGlja0J5KCdpc0FmdGVyJywgYXJncyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIERhdGUubm93ID8gRGF0ZS5ub3coKSA6ICsobmV3IERhdGUoKSk7XG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBEdXJhdGlvbiAoZHVyYXRpb24pIHtcbiAgICAgICAgICB2YXIgbm9ybWFsaXplZElucHV0ID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoZHVyYXRpb24pLFxuICAgICAgICAgICAgICB5ZWFycyA9IG5vcm1hbGl6ZWRJbnB1dC55ZWFyIHx8IDAsXG4gICAgICAgICAgICAgIHF1YXJ0ZXJzID0gbm9ybWFsaXplZElucHV0LnF1YXJ0ZXIgfHwgMCxcbiAgICAgICAgICAgICAgbW9udGhzID0gbm9ybWFsaXplZElucHV0Lm1vbnRoIHx8IDAsXG4gICAgICAgICAgICAgIHdlZWtzID0gbm9ybWFsaXplZElucHV0LndlZWsgfHwgMCxcbiAgICAgICAgICAgICAgZGF5cyA9IG5vcm1hbGl6ZWRJbnB1dC5kYXkgfHwgMCxcbiAgICAgICAgICAgICAgaG91cnMgPSBub3JtYWxpemVkSW5wdXQuaG91ciB8fCAwLFxuICAgICAgICAgICAgICBtaW51dGVzID0gbm9ybWFsaXplZElucHV0Lm1pbnV0ZSB8fCAwLFxuICAgICAgICAgICAgICBzZWNvbmRzID0gbm9ybWFsaXplZElucHV0LnNlY29uZCB8fCAwLFxuICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQubWlsbGlzZWNvbmQgfHwgMDtcblxuICAgICAgICAgIC8vIHJlcHJlc2VudGF0aW9uIGZvciBkYXRlQWRkUmVtb3ZlXG4gICAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gK21pbGxpc2Vjb25kcyArXG4gICAgICAgICAgICAgIHNlY29uZHMgKiAxZTMgKyAvLyAxMDAwXG4gICAgICAgICAgICAgIG1pbnV0ZXMgKiA2ZTQgKyAvLyAxMDAwICogNjBcbiAgICAgICAgICAgICAgaG91cnMgKiAxMDAwICogNjAgKiA2MDsgLy91c2luZyAxMDAwICogNjAgKiA2MCBpbnN0ZWFkIG9mIDM2ZTUgdG8gYXZvaWQgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yOTc4XG4gICAgICAgICAgLy8gQmVjYXVzZSBvZiBkYXRlQWRkUmVtb3ZlIHRyZWF0cyAyNCBob3VycyBhcyBkaWZmZXJlbnQgZnJvbSBhXG4gICAgICAgICAgLy8gZGF5IHdoZW4gd29ya2luZyBhcm91bmQgRFNULCB3ZSBuZWVkIHRvIHN0b3JlIHRoZW0gc2VwYXJhdGVseVxuICAgICAgICAgIHRoaXMuX2RheXMgPSArZGF5cyArXG4gICAgICAgICAgICAgIHdlZWtzICogNztcbiAgICAgICAgICAvLyBJdCBpcyBpbXBvc3NpYmxlIHRyYW5zbGF0ZSBtb250aHMgaW50byBkYXlzIHdpdGhvdXQga25vd2luZ1xuICAgICAgICAgIC8vIHdoaWNoIG1vbnRocyB5b3UgYXJlIGFyZSB0YWxraW5nIGFib3V0LCBzbyB3ZSBoYXZlIHRvIHN0b3JlXG4gICAgICAgICAgLy8gaXQgc2VwYXJhdGVseS5cbiAgICAgICAgICB0aGlzLl9tb250aHMgPSArbW9udGhzICtcbiAgICAgICAgICAgICAgcXVhcnRlcnMgKiAzICtcbiAgICAgICAgICAgICAgeWVhcnMgKiAxMjtcblxuICAgICAgICAgIHRoaXMuX2RhdGEgPSB7fTtcblxuICAgICAgICAgIHRoaXMuX2xvY2FsZSA9IGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUoKTtcblxuICAgICAgICAgIHRoaXMuX2J1YmJsZSgpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc0R1cmF0aW9uIChvYmopIHtcbiAgICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRHVyYXRpb247XG4gICAgICB9XG5cbiAgICAgIC8vIEZPUk1BVFRJTkdcblxuICAgICAgZnVuY3Rpb24gb2Zmc2V0ICh0b2tlbiwgc2VwYXJhdG9yKSB7XG4gICAgICAgICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMudXRjT2Zmc2V0KCk7XG4gICAgICAgICAgICAgIHZhciBzaWduID0gJysnO1xuICAgICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gLW9mZnNldDtcbiAgICAgICAgICAgICAgICAgIHNpZ24gPSAnLSc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHNpZ24gKyB6ZXJvRmlsbCh+fihvZmZzZXQgLyA2MCksIDIpICsgc2VwYXJhdG9yICsgemVyb0ZpbGwofn4ob2Zmc2V0KSAlIDYwLCAyKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgb2Zmc2V0KCdaJywgJzonKTtcbiAgICAgIG9mZnNldCgnWlonLCAnJyk7XG5cbiAgICAgIC8vIFBBUlNJTkdcblxuICAgICAgYWRkUmVnZXhUb2tlbignWicsICBtYXRjaFNob3J0T2Zmc2V0KTtcbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ1paJywgbWF0Y2hTaG9ydE9mZnNldCk7XG4gICAgICBhZGRQYXJzZVRva2VuKFsnWicsICdaWiddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgICBjb25maWcuX3VzZVVUQyA9IHRydWU7XG4gICAgICAgICAgY29uZmlnLl90em0gPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBIRUxQRVJTXG5cbiAgICAgIC8vIHRpbWV6b25lIGNodW5rZXJcbiAgICAgIC8vICcrMTA6MDAnID4gWycxMCcsICAnMDAnXVxuICAgICAgLy8gJy0xNTMwJyAgPiBbJy0xNScsICczMCddXG4gICAgICB2YXIgY2h1bmtPZmZzZXQgPSAvKFtcXCtcXC1dfFxcZFxcZCkvZ2k7XG5cbiAgICAgIGZ1bmN0aW9uIG9mZnNldEZyb21TdHJpbmcobWF0Y2hlciwgc3RyaW5nKSB7XG4gICAgICAgICAgdmFyIG1hdGNoZXMgPSAoKHN0cmluZyB8fCAnJykubWF0Y2gobWF0Y2hlcikgfHwgW10pO1xuICAgICAgICAgIHZhciBjaHVuayAgID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdIHx8IFtdO1xuICAgICAgICAgIHZhciBwYXJ0cyAgID0gKGNodW5rICsgJycpLm1hdGNoKGNodW5rT2Zmc2V0KSB8fCBbJy0nLCAwLCAwXTtcbiAgICAgICAgICB2YXIgbWludXRlcyA9ICsocGFydHNbMV0gKiA2MCkgKyB0b0ludChwYXJ0c1syXSk7XG5cbiAgICAgICAgICByZXR1cm4gcGFydHNbMF0gPT09ICcrJyA/IG1pbnV0ZXMgOiAtbWludXRlcztcbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJuIGEgbW9tZW50IGZyb20gaW5wdXQsIHRoYXQgaXMgbG9jYWwvdXRjL3pvbmUgZXF1aXZhbGVudCB0byBtb2RlbC5cbiAgICAgIGZ1bmN0aW9uIGNsb25lV2l0aE9mZnNldChpbnB1dCwgbW9kZWwpIHtcbiAgICAgICAgICB2YXIgcmVzLCBkaWZmO1xuICAgICAgICAgIGlmIChtb2RlbC5faXNVVEMpIHtcbiAgICAgICAgICAgICAgcmVzID0gbW9kZWwuY2xvbmUoKTtcbiAgICAgICAgICAgICAgZGlmZiA9IChpc01vbWVudChpbnB1dCkgfHwgaXNEYXRlKGlucHV0KSA/IGlucHV0LnZhbHVlT2YoKSA6IGxvY2FsX19jcmVhdGVMb2NhbChpbnB1dCkudmFsdWVPZigpKSAtIHJlcy52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgIC8vIFVzZSBsb3ctbGV2ZWwgYXBpLCBiZWNhdXNlIHRoaXMgZm4gaXMgbG93LWxldmVsIGFwaS5cbiAgICAgICAgICAgICAgcmVzLl9kLnNldFRpbWUocmVzLl9kLnZhbHVlT2YoKSArIGRpZmYpO1xuICAgICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0KHJlcywgZmFsc2UpO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpLmxvY2FsKCk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXREYXRlT2Zmc2V0IChtKSB7XG4gICAgICAgICAgLy8gT24gRmlyZWZveC4yNCBEYXRlI2dldFRpbWV6b25lT2Zmc2V0IHJldHVybnMgYSBmbG9hdGluZyBwb2ludC5cbiAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9wdWxsLzE4NzFcbiAgICAgICAgICByZXR1cm4gLU1hdGgucm91bmQobS5fZC5nZXRUaW1lem9uZU9mZnNldCgpIC8gMTUpICogMTU7XG4gICAgICB9XG5cbiAgICAgIC8vIEhPT0tTXG5cbiAgICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgYSBtb21lbnQgaXMgbXV0YXRlZC5cbiAgICAgIC8vIEl0IGlzIGludGVuZGVkIHRvIGtlZXAgdGhlIG9mZnNldCBpbiBzeW5jIHdpdGggdGhlIHRpbWV6b25lLlxuICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgICAvLyBNT01FTlRTXG5cbiAgICAgIC8vIGtlZXBMb2NhbFRpbWUgPSB0cnVlIG1lYW5zIG9ubHkgY2hhbmdlIHRoZSB0aW1lem9uZSwgd2l0aG91dFxuICAgICAgLy8gYWZmZWN0aW5nIHRoZSBsb2NhbCBob3VyLiBTbyA1OjMxOjI2ICswMzAwIC0tW3V0Y09mZnNldCgyLCB0cnVlKV0tLT5cbiAgICAgIC8vIDU6MzE6MjYgKzAyMDAgSXQgaXMgcG9zc2libGUgdGhhdCA1OjMxOjI2IGRvZXNuJ3QgZXhpc3Qgd2l0aCBvZmZzZXRcbiAgICAgIC8vICswMjAwLCBzbyB3ZSBhZGp1c3QgdGhlIHRpbWUgYXMgbmVlZGVkLCB0byBiZSB2YWxpZC5cbiAgICAgIC8vXG4gICAgICAvLyBLZWVwaW5nIHRoZSB0aW1lIGFjdHVhbGx5IGFkZHMvc3VidHJhY3RzIChvbmUgaG91cilcbiAgICAgIC8vIGZyb20gdGhlIGFjdHVhbCByZXByZXNlbnRlZCB0aW1lLiBUaGF0IGlzIHdoeSB3ZSBjYWxsIHVwZGF0ZU9mZnNldFxuICAgICAgLy8gYSBzZWNvbmQgdGltZS4gSW4gY2FzZSBpdCB3YW50cyB1cyB0byBjaGFuZ2UgdGhlIG9mZnNldCBhZ2FpblxuICAgICAgLy8gX2NoYW5nZUluUHJvZ3Jlc3MgPT0gdHJ1ZSBjYXNlLCB0aGVuIHdlIGhhdmUgdG8gYWRqdXN0LCBiZWNhdXNlXG4gICAgICAvLyB0aGVyZSBpcyBubyBzdWNoIHRpbWUgaW4gdGhlIGdpdmVuIHRpbWV6b25lLlxuICAgICAgZnVuY3Rpb24gZ2V0U2V0T2Zmc2V0IChpbnB1dCwga2VlcExvY2FsVGltZSkge1xuICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLl9vZmZzZXQgfHwgMCxcbiAgICAgICAgICAgICAgbG9jYWxBZGp1c3Q7XG4gICAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICBpbnB1dCA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hTaG9ydE9mZnNldCwgaW5wdXQpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGlucHV0KSA8IDE2KSB7XG4gICAgICAgICAgICAgICAgICBpbnB1dCA9IGlucHV0ICogNjA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1VUQyAmJiBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgICBsb2NhbEFkanVzdCA9IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5wdXQ7XG4gICAgICAgICAgICAgIHRoaXMuX2lzVVRDID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaWYgKGxvY2FsQWRqdXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuYWRkKGxvY2FsQWRqdXN0LCAnbScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChvZmZzZXQgIT09IGlucHV0KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWtlZXBMb2NhbFRpbWUgfHwgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICAgIGFkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QodGhpcywgY3JlYXRlX19jcmVhdGVEdXJhdGlvbihpbnB1dCAtIG9mZnNldCwgJ20nKSwgMSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gb2Zmc2V0IDogZ2V0RGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldFNldFpvbmUgKGlucHV0LCBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgIGlucHV0ID0gLWlucHV0O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoaW5wdXQsIGtlZXBMb2NhbFRpbWUpO1xuXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiAtdGhpcy51dGNPZmZzZXQoKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvVVRDIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb0xvY2FsIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2lzVVRDKSB7XG4gICAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgICAgICAgICAgICB0aGlzLl9pc1VUQyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgIGlmIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnN1YnRyYWN0KGdldERhdGVPZmZzZXQodGhpcyksICdtJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0ICgpIHtcbiAgICAgICAgICBpZiAodGhpcy5fdHptKSB7XG4gICAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KHRoaXMuX3R6bSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5faSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQob2Zmc2V0RnJvbVN0cmluZyhtYXRjaE9mZnNldCwgdGhpcy5faSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaGFzQWxpZ25lZEhvdXJPZmZzZXQgKGlucHV0KSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlucHV0ID0gaW5wdXQgPyBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpLnV0Y09mZnNldCgpIDogMDtcblxuICAgICAgICAgIHJldHVybiAodGhpcy51dGNPZmZzZXQoKSAtIGlucHV0KSAlIDYwID09PSAwO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZSAoKSB7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCgwKS51dGNPZmZzZXQoKSB8fFxuICAgICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgpID4gdGhpcy5jbG9uZSgpLm1vbnRoKDUpLnV0Y09mZnNldCgpXG4gICAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkICgpIHtcbiAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX2lzRFNUU2hpZnRlZCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgYyA9IHt9O1xuXG4gICAgICAgICAgY29weUNvbmZpZyhjLCB0aGlzKTtcbiAgICAgICAgICBjID0gcHJlcGFyZUNvbmZpZyhjKTtcblxuICAgICAgICAgIGlmIChjLl9hKSB7XG4gICAgICAgICAgICAgIHZhciBvdGhlciA9IGMuX2lzVVRDID8gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKGMuX2EpIDogbG9jYWxfX2NyZWF0ZUxvY2FsKGMuX2EpO1xuICAgICAgICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSB0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgICAgICAgY29tcGFyZUFycmF5cyhjLl9hLCBvdGhlci50b0FycmF5KCkpID4gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc0xvY2FsICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyAhdGhpcy5faXNVVEMgOiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaXNVdGNPZmZzZXQgKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2lzVVRDIDogZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzVXRjICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyAmJiB0aGlzLl9vZmZzZXQgPT09IDAgOiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gQVNQLk5FVCBqc29uIGRhdGUgZm9ybWF0IHJlZ2V4XG4gICAgICB2YXIgYXNwTmV0UmVnZXggPSAvXihcXC0pPyg/OihcXGQqKVsuIF0pPyhcXGQrKVxcOihcXGQrKSg/OlxcOihcXGQrKVxcLj8oXFxkezN9KT9cXGQqKT8kLztcblxuICAgICAgLy8gZnJvbSBodHRwOi8vZG9jcy5jbG9zdXJlLWxpYnJhcnkuZ29vZ2xlY29kZS5jb20vZ2l0L2Nsb3N1cmVfZ29vZ19kYXRlX2RhdGUuanMuc291cmNlLmh0bWxcbiAgICAgIC8vIHNvbWV3aGF0IG1vcmUgaW4gbGluZSB3aXRoIDQuNC4zLjIgMjAwNCBzcGVjLCBidXQgYWxsb3dzIGRlY2ltYWwgYW55d2hlcmVcbiAgICAgIC8vIGFuZCBmdXJ0aGVyIG1vZGlmaWVkIHRvIGFsbG93IGZvciBzdHJpbmdzIGNvbnRhaW5pbmcgYm90aCB3ZWVrIGFuZCBkYXlcbiAgICAgIHZhciBpc29SZWdleCA9IC9eKC0pP1AoPzooLT9bMC05LC5dKilZKT8oPzooLT9bMC05LC5dKilNKT8oPzooLT9bMC05LC5dKilXKT8oPzooLT9bMC05LC5dKilEKT8oPzpUKD86KC0/WzAtOSwuXSopSCk/KD86KC0/WzAtOSwuXSopTSk/KD86KC0/WzAtOSwuXSopUyk/KT8kLztcblxuICAgICAgZnVuY3Rpb24gY3JlYXRlX19jcmVhdGVEdXJhdGlvbiAoaW5wdXQsIGtleSkge1xuICAgICAgICAgIHZhciBkdXJhdGlvbiA9IGlucHV0LFxuICAgICAgICAgICAgICAvLyBtYXRjaGluZyBhZ2FpbnN0IHJlZ2V4cCBpcyBleHBlbnNpdmUsIGRvIGl0IG9uIGRlbWFuZFxuICAgICAgICAgICAgICBtYXRjaCA9IG51bGwsXG4gICAgICAgICAgICAgIHNpZ24sXG4gICAgICAgICAgICAgIHJldCxcbiAgICAgICAgICAgICAgZGlmZlJlcztcblxuICAgICAgICAgIGlmIChpc0R1cmF0aW9uKGlucHV0KSkge1xuICAgICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgIG1zIDogaW5wdXQuX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgICAgICAgIGQgIDogaW5wdXQuX2RheXMsXG4gICAgICAgICAgICAgICAgICBNICA6IGlucHV0Ll9tb250aHNcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgICAgZHVyYXRpb25ba2V5XSA9IGlucHV0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZHVyYXRpb24ubWlsbGlzZWNvbmRzID0gaW5wdXQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKCEhKG1hdGNoID0gYXNwTmV0UmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09ICctJykgPyAtMSA6IDE7XG4gICAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgeSAgOiAwLFxuICAgICAgICAgICAgICAgICAgZCAgOiB0b0ludChtYXRjaFtEQVRFXSkgICAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICAgIGggIDogdG9JbnQobWF0Y2hbSE9VUl0pICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgICBtICA6IHRvSW50KG1hdGNoW01JTlVURV0pICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgICAgcyAgOiB0b0ludChtYXRjaFtTRUNPTkRdKSAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICAgIG1zIDogdG9JbnQobWF0Y2hbTUlMTElTRUNPTkRdKSAqIHNpZ25cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCEhKG1hdGNoID0gaXNvUmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09ICctJykgPyAtMSA6IDE7XG4gICAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgeSA6IHBhcnNlSXNvKG1hdGNoWzJdLCBzaWduKSxcbiAgICAgICAgICAgICAgICAgIE0gOiBwYXJzZUlzbyhtYXRjaFszXSwgc2lnbiksXG4gICAgICAgICAgICAgICAgICB3IDogcGFyc2VJc28obWF0Y2hbNF0sIHNpZ24pLFxuICAgICAgICAgICAgICAgICAgZCA6IHBhcnNlSXNvKG1hdGNoWzVdLCBzaWduKSxcbiAgICAgICAgICAgICAgICAgIGggOiBwYXJzZUlzbyhtYXRjaFs2XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgICBtIDogcGFyc2VJc28obWF0Y2hbN10sIHNpZ24pLFxuICAgICAgICAgICAgICAgICAgcyA6IHBhcnNlSXNvKG1hdGNoWzhdLCBzaWduKVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSBpZiAoZHVyYXRpb24gPT0gbnVsbCkgey8vIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkdXJhdGlvbiA9PT0gJ29iamVjdCcgJiYgKCdmcm9tJyBpbiBkdXJhdGlvbiB8fCAndG8nIGluIGR1cmF0aW9uKSkge1xuICAgICAgICAgICAgICBkaWZmUmVzID0gbW9tZW50c0RpZmZlcmVuY2UobG9jYWxfX2NyZWF0ZUxvY2FsKGR1cmF0aW9uLmZyb20pLCBsb2NhbF9fY3JlYXRlTG9jYWwoZHVyYXRpb24udG8pKTtcblxuICAgICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgICBkdXJhdGlvbi5tcyA9IGRpZmZSZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgICBkdXJhdGlvbi5NID0gZGlmZlJlcy5tb250aHM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0ID0gbmV3IER1cmF0aW9uKGR1cmF0aW9uKTtcblxuICAgICAgICAgIGlmIChpc0R1cmF0aW9uKGlucHV0KSAmJiBoYXNPd25Qcm9wKGlucHV0LCAnX2xvY2FsZScpKSB7XG4gICAgICAgICAgICAgIHJldC5fbG9jYWxlID0gaW5wdXQuX2xvY2FsZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuXG4gICAgICBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uLmZuID0gRHVyYXRpb24ucHJvdG90eXBlO1xuXG4gICAgICBmdW5jdGlvbiBwYXJzZUlzbyAoaW5wLCBzaWduKSB7XG4gICAgICAgICAgLy8gV2UnZCBub3JtYWxseSB1c2Ugfn5pbnAgZm9yIHRoaXMsIGJ1dCB1bmZvcnR1bmF0ZWx5IGl0IGFsc29cbiAgICAgICAgICAvLyBjb252ZXJ0cyBmbG9hdHMgdG8gaW50cy5cbiAgICAgICAgICAvLyBpbnAgbWF5IGJlIHVuZGVmaW5lZCwgc28gY2FyZWZ1bCBjYWxsaW5nIHJlcGxhY2Ugb24gaXQuXG4gICAgICAgICAgdmFyIHJlcyA9IGlucCAmJiBwYXJzZUZsb2F0KGlucC5yZXBsYWNlKCcsJywgJy4nKSk7XG4gICAgICAgICAgLy8gYXBwbHkgc2lnbiB3aGlsZSB3ZSdyZSBhdCBpdFxuICAgICAgICAgIHJldHVybiAoaXNOYU4ocmVzKSA/IDAgOiByZXMpICogc2lnbjtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgICAgICAgIHZhciByZXMgPSB7bWlsbGlzZWNvbmRzOiAwLCBtb250aHM6IDB9O1xuXG4gICAgICAgICAgcmVzLm1vbnRocyA9IG90aGVyLm1vbnRoKCkgLSBiYXNlLm1vbnRoKCkgK1xuICAgICAgICAgICAgICAob3RoZXIueWVhcigpIC0gYmFzZS55ZWFyKCkpICogMTI7XG4gICAgICAgICAgaWYgKGJhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKS5pc0FmdGVyKG90aGVyKSkge1xuICAgICAgICAgICAgICAtLXJlcy5tb250aHM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzLm1pbGxpc2Vjb25kcyA9ICtvdGhlciAtICsoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpKTtcblxuICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgICAgICAgdmFyIHJlcztcbiAgICAgICAgICBpZiAoIShiYXNlLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7bWlsbGlzZWNvbmRzOiAwLCBtb250aHM6IDB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG90aGVyID0gY2xvbmVXaXRoT2Zmc2V0KG90aGVyLCBiYXNlKTtcbiAgICAgICAgICBpZiAoYmFzZS5pc0JlZm9yZShvdGhlcikpIHtcbiAgICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShvdGhlciwgYmFzZSk7XG4gICAgICAgICAgICAgIHJlcy5taWxsaXNlY29uZHMgPSAtcmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgICAgcmVzLm1vbnRocyA9IC1yZXMubW9udGhzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGFic1JvdW5kIChudW1iZXIpIHtcbiAgICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCgtMSAqIG51bWJlcikgKiAtMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVE9ETzogcmVtb3ZlICduYW1lJyBhcmcgYWZ0ZXIgZGVwcmVjYXRpb24gaXMgcmVtb3ZlZFxuICAgICAgZnVuY3Rpb24gY3JlYXRlQWRkZXIoZGlyZWN0aW9uLCBuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwsIHBlcmlvZCkge1xuICAgICAgICAgICAgICB2YXIgZHVyLCB0bXA7XG4gICAgICAgICAgICAgIC8vaW52ZXJ0IHRoZSBhcmd1bWVudHMsIGJ1dCBjb21wbGFpbiBhYm91dCBpdFxuICAgICAgICAgICAgICBpZiAocGVyaW9kICE9PSBudWxsICYmICFpc05hTigrcGVyaW9kKSkge1xuICAgICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKG5hbWUsICdtb21lbnQoKS4nICsgbmFtZSAgKyAnKHBlcmlvZCwgbnVtYmVyKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIG1vbWVudCgpLicgKyBuYW1lICsgJyhudW1iZXIsIHBlcmlvZCkuJyk7XG4gICAgICAgICAgICAgICAgICB0bXAgPSB2YWw7IHZhbCA9IHBlcmlvZDsgcGVyaW9kID0gdG1wO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFsID0gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyArdmFsIDogdmFsO1xuICAgICAgICAgICAgICBkdXIgPSBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uKHZhbCwgcGVyaW9kKTtcbiAgICAgICAgICAgICAgYWRkX3N1YnRyYWN0X19hZGRTdWJ0cmFjdCh0aGlzLCBkdXIsIGRpcmVjdGlvbik7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGFkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QgKG1vbSwgZHVyYXRpb24sIGlzQWRkaW5nLCB1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gZHVyYXRpb24uX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgICAgZGF5cyA9IGFic1JvdW5kKGR1cmF0aW9uLl9kYXlzKSxcbiAgICAgICAgICAgICAgbW9udGhzID0gYWJzUm91bmQoZHVyYXRpb24uX21vbnRocyk7XG5cbiAgICAgICAgICBpZiAoIW1vbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHVwZGF0ZU9mZnNldCA9IHVwZGF0ZU9mZnNldCA9PSBudWxsID8gdHJ1ZSA6IHVwZGF0ZU9mZnNldDtcblxuICAgICAgICAgIGlmIChtaWxsaXNlY29uZHMpIHtcbiAgICAgICAgICAgICAgbW9tLl9kLnNldFRpbWUobW9tLl9kLnZhbHVlT2YoKSArIG1pbGxpc2Vjb25kcyAqIGlzQWRkaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRheXMpIHtcbiAgICAgICAgICAgICAgZ2V0X3NldF9fc2V0KG1vbSwgJ0RhdGUnLCBnZXRfc2V0X19nZXQobW9tLCAnRGF0ZScpICsgZGF5cyAqIGlzQWRkaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vbnRocykge1xuICAgICAgICAgICAgICBzZXRNb250aChtb20sIGdldF9zZXRfX2dldChtb20sICdNb250aCcpICsgbW9udGhzICogaXNBZGRpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodXBkYXRlT2Zmc2V0KSB7XG4gICAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQobW9tLCBkYXlzIHx8IG1vbnRocyk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgYWRkX3N1YnRyYWN0X19hZGQgICAgICA9IGNyZWF0ZUFkZGVyKDEsICdhZGQnKTtcbiAgICAgIHZhciBhZGRfc3VidHJhY3RfX3N1YnRyYWN0ID0gY3JlYXRlQWRkZXIoLTEsICdzdWJ0cmFjdCcpO1xuXG4gICAgICBmdW5jdGlvbiBtb21lbnRfY2FsZW5kYXJfX2NhbGVuZGFyICh0aW1lLCBmb3JtYXRzKSB7XG4gICAgICAgICAgLy8gV2Ugd2FudCB0byBjb21wYXJlIHRoZSBzdGFydCBvZiB0b2RheSwgdnMgdGhpcy5cbiAgICAgICAgICAvLyBHZXR0aW5nIHN0YXJ0LW9mLXRvZGF5IGRlcGVuZHMgb24gd2hldGhlciB3ZSdyZSBsb2NhbC91dGMvb2Zmc2V0IG9yIG5vdC5cbiAgICAgICAgICB2YXIgbm93ID0gdGltZSB8fCBsb2NhbF9fY3JlYXRlTG9jYWwoKSxcbiAgICAgICAgICAgICAgc29kID0gY2xvbmVXaXRoT2Zmc2V0KG5vdywgdGhpcykuc3RhcnRPZignZGF5JyksXG4gICAgICAgICAgICAgIGRpZmYgPSB0aGlzLmRpZmYoc29kLCAnZGF5cycsIHRydWUpLFxuICAgICAgICAgICAgICBmb3JtYXQgPSBkaWZmIDwgLTYgPyAnc2FtZUVsc2UnIDpcbiAgICAgICAgICAgICAgICAgIGRpZmYgPCAtMSA/ICdsYXN0V2VlaycgOlxuICAgICAgICAgICAgICAgICAgZGlmZiA8IDAgPyAnbGFzdERheScgOlxuICAgICAgICAgICAgICAgICAgZGlmZiA8IDEgPyAnc2FtZURheScgOlxuICAgICAgICAgICAgICAgICAgZGlmZiA8IDIgPyAnbmV4dERheScgOlxuICAgICAgICAgICAgICAgICAgZGlmZiA8IDcgPyAnbmV4dFdlZWsnIDogJ3NhbWVFbHNlJztcblxuICAgICAgICAgIHZhciBvdXRwdXQgPSBmb3JtYXRzICYmIChpc0Z1bmN0aW9uKGZvcm1hdHNbZm9ybWF0XSkgPyBmb3JtYXRzW2Zvcm1hdF0oKSA6IGZvcm1hdHNbZm9ybWF0XSk7XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQob3V0cHV0IHx8IHRoaXMubG9jYWxlRGF0YSgpLmNhbGVuZGFyKGZvcm1hdCwgdGhpcywgbG9jYWxfX2NyZWF0ZUxvY2FsKG5vdykpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgTW9tZW50KHRoaXMpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc0FmdGVyIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKCFpc1VuZGVmaW5lZCh1bml0cykgPyB1bml0cyA6ICdtaWxsaXNlY29uZCcpO1xuICAgICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPiBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbG9jYWxJbnB1dC52YWx1ZU9mKCkgPCB0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cykudmFsdWVPZigpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaXNCZWZvcmUgKGlucHV0LCB1bml0cykge1xuICAgICAgICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHMoIWlzVW5kZWZpbmVkKHVuaXRzKSA/IHVuaXRzIDogJ21pbGxpc2Vjb25kJyk7XG4gICAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaXNCZXR3ZWVuIChmcm9tLCB0bywgdW5pdHMsIGluY2x1c2l2aXR5KSB7XG4gICAgICAgICAgaW5jbHVzaXZpdHkgPSBpbmNsdXNpdml0eSB8fCAnKCknO1xuICAgICAgICAgIHJldHVybiAoaW5jbHVzaXZpdHlbMF0gPT09ICcoJyA/IHRoaXMuaXNBZnRlcihmcm9tLCB1bml0cykgOiAhdGhpcy5pc0JlZm9yZShmcm9tLCB1bml0cykpICYmXG4gICAgICAgICAgICAgIChpbmNsdXNpdml0eVsxXSA9PT0gJyknID8gdGhpcy5pc0JlZm9yZSh0bywgdW5pdHMpIDogIXRoaXMuaXNBZnRlcih0bywgdW5pdHMpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaXNTYW1lIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KSxcbiAgICAgICAgICAgICAgaW5wdXRNcztcbiAgICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzIHx8ICdtaWxsaXNlY29uZCcpO1xuICAgICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPT09IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlucHV0TXMgPSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKS52YWx1ZU9mKCkgPD0gaW5wdXRNcyAmJiBpbnB1dE1zIDw9IHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaXNTYW1lT3JBZnRlciAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaXNTYW1lKGlucHV0LCB1bml0cykgfHwgdGhpcy5pc0FmdGVyKGlucHV0LHVuaXRzKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaXNTYW1lT3JCZWZvcmUgKGlucHV0LCB1bml0cykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNCZWZvcmUoaW5wdXQsdW5pdHMpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkaWZmIChpbnB1dCwgdW5pdHMsIGFzRmxvYXQpIHtcbiAgICAgICAgICB2YXIgdGhhdCxcbiAgICAgICAgICAgICAgem9uZURlbHRhLFxuICAgICAgICAgICAgICBkZWx0YSwgb3V0cHV0O1xuXG4gICAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoYXQgPSBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIHRoaXMpO1xuXG4gICAgICAgICAgaWYgKCF0aGF0LmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHpvbmVEZWx0YSA9ICh0aGF0LnV0Y09mZnNldCgpIC0gdGhpcy51dGNPZmZzZXQoKSkgKiA2ZTQ7XG5cbiAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgICAgICAgIGlmICh1bml0cyA9PT0gJ3llYXInIHx8IHVuaXRzID09PSAnbW9udGgnIHx8IHVuaXRzID09PSAncXVhcnRlcicpIHtcbiAgICAgICAgICAgICAgb3V0cHV0ID0gbW9udGhEaWZmKHRoaXMsIHRoYXQpO1xuICAgICAgICAgICAgICBpZiAodW5pdHMgPT09ICdxdWFydGVyJykge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0IC8gMztcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh1bml0cyA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgLyAxMjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRlbHRhID0gdGhpcyAtIHRoYXQ7XG4gICAgICAgICAgICAgIG91dHB1dCA9IHVuaXRzID09PSAnc2Vjb25kJyA/IGRlbHRhIC8gMWUzIDogLy8gMTAwMFxuICAgICAgICAgICAgICAgICAgdW5pdHMgPT09ICdtaW51dGUnID8gZGVsdGEgLyA2ZTQgOiAvLyAxMDAwICogNjBcbiAgICAgICAgICAgICAgICAgIHVuaXRzID09PSAnaG91cicgPyBkZWx0YSAvIDM2ZTUgOiAvLyAxMDAwICogNjAgKiA2MFxuICAgICAgICAgICAgICAgICAgdW5pdHMgPT09ICdkYXknID8gKGRlbHRhIC0gem9uZURlbHRhKSAvIDg2NGU1IDogLy8gMTAwMCAqIDYwICogNjAgKiAyNCwgbmVnYXRlIGRzdFxuICAgICAgICAgICAgICAgICAgdW5pdHMgPT09ICd3ZWVrJyA/IChkZWx0YSAtIHpvbmVEZWx0YSkgLyA2MDQ4ZTUgOiAvLyAxMDAwICogNjAgKiA2MCAqIDI0ICogNywgbmVnYXRlIGRzdFxuICAgICAgICAgICAgICAgICAgZGVsdGE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhc0Zsb2F0ID8gb3V0cHV0IDogYWJzRmxvb3Iob3V0cHV0KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbW9udGhEaWZmIChhLCBiKSB7XG4gICAgICAgICAgLy8gZGlmZmVyZW5jZSBpbiBtb250aHNcbiAgICAgICAgICB2YXIgd2hvbGVNb250aERpZmYgPSAoKGIueWVhcigpIC0gYS55ZWFyKCkpICogMTIpICsgKGIubW9udGgoKSAtIGEubW9udGgoKSksXG4gICAgICAgICAgICAgIC8vIGIgaXMgaW4gKGFuY2hvciAtIDEgbW9udGgsIGFuY2hvciArIDEgbW9udGgpXG4gICAgICAgICAgICAgIGFuY2hvciA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYsICdtb250aHMnKSxcbiAgICAgICAgICAgICAgYW5jaG9yMiwgYWRqdXN0O1xuXG4gICAgICAgICAgaWYgKGIgLSBhbmNob3IgPCAwKSB7XG4gICAgICAgICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmIC0gMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICAgICAgICBhZGp1c3QgPSAoYiAtIGFuY2hvcikgLyAoYW5jaG9yIC0gYW5jaG9yMik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgKyAxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAgIC8vIGxpbmVhciBhY3Jvc3MgdGhlIG1vbnRoXG4gICAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IyIC0gYW5jaG9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvL2NoZWNrIGZvciBuZWdhdGl2ZSB6ZXJvLCByZXR1cm4gemVybyBpZiBuZWdhdGl2ZSB6ZXJvXG4gICAgICAgICAgcmV0dXJuIC0od2hvbGVNb250aERpZmYgKyBhZGp1c3QpIHx8IDA7XG4gICAgICB9XG5cbiAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5kZWZhdWx0Rm9ybWF0ID0gJ1lZWVktTU0tRERUSEg6bW06c3NaJztcbiAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5kZWZhdWx0Rm9ybWF0VXRjID0gJ1lZWVktTU0tRERUSEg6bW06c3NbWl0nO1xuXG4gICAgICBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5sb2NhbGUoJ2VuJykuZm9ybWF0KCdkZGQgTU1NIEREIFlZWVkgSEg6bW06c3MgW0dNVF1aWicpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBtb21lbnRfZm9ybWF0X190b0lTT1N0cmluZyAoKSB7XG4gICAgICAgICAgdmFyIG0gPSB0aGlzLmNsb25lKCkudXRjKCk7XG4gICAgICAgICAgaWYgKDAgPCBtLnllYXIoKSAmJiBtLnllYXIoKSA8PSA5OTk5KSB7XG4gICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKSkge1xuICAgICAgICAgICAgICAgICAgLy8gbmF0aXZlIGltcGxlbWVudGF0aW9uIGlzIH41MHggZmFzdGVyLCB1c2UgaXQgd2hlbiB3ZSBjYW5cbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KG0sICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KG0sICdZWVlZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGZvcm1hdCAoaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgICBpZiAoIWlucHV0U3RyaW5nKSB7XG4gICAgICAgICAgICAgIGlucHV0U3RyaW5nID0gdGhpcy5pc1V0YygpID8gdXRpbHNfaG9va3NfX2hvb2tzLmRlZmF1bHRGb3JtYXRVdGMgOiB1dGlsc19ob29rc19faG9va3MuZGVmYXVsdEZvcm1hdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG91dHB1dCA9IGZvcm1hdE1vbWVudCh0aGlzLCBpbnB1dFN0cmluZyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLnBvc3Rmb3JtYXQob3V0cHV0KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZnJvbSAodGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgICAgICAgKChpc01vbWVudCh0aW1lKSAmJiB0aW1lLmlzVmFsaWQoKSkgfHxcbiAgICAgICAgICAgICAgICAgICBsb2NhbF9fY3JlYXRlTG9jYWwodGltZSkuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlX19jcmVhdGVEdXJhdGlvbih7dG86IHRoaXMsIGZyb206IHRpbWV9KS5sb2NhbGUodGhpcy5sb2NhbGUoKSkuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZnJvbU5vdyAod2l0aG91dFN1ZmZpeCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZyb20obG9jYWxfX2NyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0byAodGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgICAgICAgKChpc01vbWVudCh0aW1lKSAmJiB0aW1lLmlzVmFsaWQoKSkgfHxcbiAgICAgICAgICAgICAgICAgICBsb2NhbF9fY3JlYXRlTG9jYWwodGltZSkuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlX19jcmVhdGVEdXJhdGlvbih7ZnJvbTogdGhpcywgdG86IHRpbWV9KS5sb2NhbGUodGhpcy5sb2NhbGUoKSkuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdG9Ob3cgKHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50byhsb2NhbF9fY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHBhc3NlZCBhIGxvY2FsZSBrZXksIGl0IHdpbGwgc2V0IHRoZSBsb2NhbGUgZm9yIHRoaXNcbiAgICAgIC8vIGluc3RhbmNlLiAgT3RoZXJ3aXNlLCBpdCB3aWxsIHJldHVybiB0aGUgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbiAgICAgIC8vIHZhcmlhYmxlcyBmb3IgdGhpcyBpbnN0YW5jZS5cbiAgICAgIGZ1bmN0aW9uIGxvY2FsZSAoa2V5KSB7XG4gICAgICAgICAgdmFyIG5ld0xvY2FsZURhdGE7XG5cbiAgICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZS5fYWJicjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdMb2NhbGVEYXRhID0gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZShrZXkpO1xuICAgICAgICAgICAgICBpZiAobmV3TG9jYWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBuZXdMb2NhbGVEYXRhO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGxhbmcgPSBkZXByZWNhdGUoXG4gICAgICAgICAgJ21vbWVudCgpLmxhbmcoKSBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2UgbW9tZW50KCkubG9jYWxlRGF0YSgpIHRvIGdldCB0aGUgbGFuZ3VhZ2UgY29uZmlndXJhdGlvbi4gVXNlIG1vbWVudCgpLmxvY2FsZSgpIHRvIGNoYW5nZSBsYW5ndWFnZXMuJyxcbiAgICAgICAgICBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlKGtleSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICBmdW5jdGlvbiBsb2NhbGVEYXRhICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzdGFydE9mICh1bml0cykge1xuICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICAgIC8vIHRoZSBmb2xsb3dpbmcgc3dpdGNoIGludGVudGlvbmFsbHkgb21pdHMgYnJlYWsga2V5d29yZHNcbiAgICAgICAgICAvLyB0byB1dGlsaXplIGZhbGxpbmcgdGhyb3VnaCB0aGUgY2FzZXMuXG4gICAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICB0aGlzLm1vbnRoKDApO1xuICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgY2FzZSAncXVhcnRlcic6XG4gICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgICB0aGlzLmRhdGUoMSk7XG4gICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICBjYXNlICdpc29XZWVrJzpcbiAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgICB0aGlzLmhvdXJzKDApO1xuICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICAgIHRoaXMubWludXRlcygwKTtcbiAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgIHRoaXMuc2Vjb25kcygwKTtcbiAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgIHRoaXMubWlsbGlzZWNvbmRzKDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHdlZWtzIGFyZSBhIHNwZWNpYWwgY2FzZVxuICAgICAgICAgIGlmICh1bml0cyA9PT0gJ3dlZWsnKSB7XG4gICAgICAgICAgICAgIHRoaXMud2Vla2RheSgwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHVuaXRzID09PSAnaXNvV2VlaycpIHtcbiAgICAgICAgICAgICAgdGhpcy5pc29XZWVrZGF5KDEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHF1YXJ0ZXJzIGFyZSBhbHNvIHNwZWNpYWxcbiAgICAgICAgICBpZiAodW5pdHMgPT09ICdxdWFydGVyJykge1xuICAgICAgICAgICAgICB0aGlzLm1vbnRoKE1hdGguZmxvb3IodGhpcy5tb250aCgpIC8gMykgKiAzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZW5kT2YgKHVuaXRzKSB7XG4gICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgICAgaWYgKHVuaXRzID09PSB1bmRlZmluZWQgfHwgdW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gJ2RhdGUnIGlzIGFuIGFsaWFzIGZvciAnZGF5Jywgc28gaXQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYXMgc3VjaC5cbiAgICAgICAgICBpZiAodW5pdHMgPT09ICdkYXRlJykge1xuICAgICAgICAgICAgICB1bml0cyA9ICdkYXknO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0T2YodW5pdHMpLmFkZCgxLCAodW5pdHMgPT09ICdpc29XZWVrJyA/ICd3ZWVrJyA6IHVuaXRzKSkuc3VidHJhY3QoMSwgJ21zJyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRvX3R5cGVfX3ZhbHVlT2YgKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9kLnZhbHVlT2YoKSAtICgodGhpcy5fb2Zmc2V0IHx8IDApICogNjAwMDApO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB1bml4ICgpIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih0aGlzLnZhbHVlT2YoKSAvIDEwMDApO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0b0RhdGUgKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9vZmZzZXQgPyBuZXcgRGF0ZSh0aGlzLnZhbHVlT2YoKSkgOiB0aGlzLl9kO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0b0FycmF5ICgpIHtcbiAgICAgICAgICB2YXIgbSA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIFttLnllYXIoKSwgbS5tb250aCgpLCBtLmRhdGUoKSwgbS5ob3VyKCksIG0ubWludXRlKCksIG0uc2Vjb25kKCksIG0ubWlsbGlzZWNvbmQoKV07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRvT2JqZWN0ICgpIHtcbiAgICAgICAgICB2YXIgbSA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgeWVhcnM6IG0ueWVhcigpLFxuICAgICAgICAgICAgICBtb250aHM6IG0ubW9udGgoKSxcbiAgICAgICAgICAgICAgZGF0ZTogbS5kYXRlKCksXG4gICAgICAgICAgICAgIGhvdXJzOiBtLmhvdXJzKCksXG4gICAgICAgICAgICAgIG1pbnV0ZXM6IG0ubWludXRlcygpLFxuICAgICAgICAgICAgICBzZWNvbmRzOiBtLnNlY29uZHMoKSxcbiAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBtLm1pbGxpc2Vjb25kcygpXG4gICAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgICAgICAgICAvLyBuZXcgRGF0ZShOYU4pLnRvSlNPTigpID09PSBudWxsXG4gICAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy50b0lTT1N0cmluZygpIDogbnVsbDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbW9tZW50X3ZhbGlkX19pc1ZhbGlkICgpIHtcbiAgICAgICAgICByZXR1cm4gdmFsaWRfX2lzVmFsaWQodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHBhcnNpbmdGbGFncyAoKSB7XG4gICAgICAgICAgcmV0dXJuIGV4dGVuZCh7fSwgZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaW52YWxpZEF0ICgpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpLm92ZXJmbG93O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjcmVhdGlvbkRhdGEoKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgaW5wdXQ6IHRoaXMuX2ksXG4gICAgICAgICAgICAgIGZvcm1hdDogdGhpcy5fZixcbiAgICAgICAgICAgICAgbG9jYWxlOiB0aGlzLl9sb2NhbGUsXG4gICAgICAgICAgICAgIGlzVVRDOiB0aGlzLl9pc1VUQyxcbiAgICAgICAgICAgICAgc3RyaWN0OiB0aGlzLl9zdHJpY3RcbiAgICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnZ2cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLndlZWtZZWFyKCkgJSAxMDA7XG4gICAgICB9KTtcblxuICAgICAgYWRkRm9ybWF0VG9rZW4oMCwgWydHRycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaXNvV2Vla1llYXIoKSAlIDEwMDtcbiAgICAgIH0pO1xuXG4gICAgICBmdW5jdGlvbiBhZGRXZWVrWWVhckZvcm1hdFRva2VuICh0b2tlbiwgZ2V0dGVyKSB7XG4gICAgICAgICAgYWRkRm9ybWF0VG9rZW4oMCwgW3Rva2VuLCB0b2tlbi5sZW5ndGhdLCAwLCBnZXR0ZXIpO1xuICAgICAgfVxuXG4gICAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnJywgICAgICd3ZWVrWWVhcicpO1xuICAgICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZ2cnLCAgICAnd2Vla1llYXInKTtcbiAgICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0cnLCAgJ2lzb1dlZWtZZWFyJyk7XG4gICAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHRycsICdpc29XZWVrWWVhcicpO1xuXG4gICAgICAvLyBBTElBU0VTXG5cbiAgICAgIGFkZFVuaXRBbGlhcygnd2Vla1llYXInLCAnZ2cnKTtcbiAgICAgIGFkZFVuaXRBbGlhcygnaXNvV2Vla1llYXInLCAnR0cnKTtcblxuICAgICAgLy8gUEFSU0lOR1xuXG4gICAgICBhZGRSZWdleFRva2VuKCdHJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgICBhZGRSZWdleFRva2VuKCdnJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgICBhZGRSZWdleFRva2VuKCdHRycsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgICBhZGRSZWdleFRva2VuKCdnZycsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgICBhZGRSZWdleFRva2VuKCdHR0dHJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgICBhZGRSZWdleFRva2VuKCdnZ2dnJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgICBhZGRSZWdleFRva2VuKCdHR0dHRycsICBtYXRjaDF0bzYsIG1hdGNoNik7XG4gICAgICBhZGRSZWdleFRva2VuKCdnZ2dnZycsICBtYXRjaDF0bzYsIG1hdGNoNik7XG5cbiAgICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZ2dnZycsICdnZ2dnZycsICdHR0dHJywgJ0dHR0dHJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDIpXSA9IHRvSW50KGlucHV0KTtcbiAgICAgIH0pO1xuXG4gICAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2dnJywgJ0dHJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICAgIHdlZWtbdG9rZW5dID0gdXRpbHNfaG9va3NfX2hvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBNT01FTlRTXG5cbiAgICAgIGZ1bmN0aW9uIGdldFNldFdlZWtZZWFyIChpbnB1dCkge1xuICAgICAgICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKHRoaXMsXG4gICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgIHRoaXMud2VlaygpLFxuICAgICAgICAgICAgICAgICAgdGhpcy53ZWVrZGF5KCksXG4gICAgICAgICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3csXG4gICAgICAgICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3kpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRTZXRJU09XZWVrWWVhciAoaW5wdXQpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbCh0aGlzLFxuICAgICAgICAgICAgICAgICAgaW5wdXQsIHRoaXMuaXNvV2VlaygpLCB0aGlzLmlzb1dlZWtkYXkoKSwgMSwgNCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldElTT1dlZWtzSW5ZZWFyICgpIHtcbiAgICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIDEsIDQpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRXZWVrc0luWWVhciAoKSB7XG4gICAgICAgICAgdmFyIHdlZWtJbmZvID0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWs7XG4gICAgICAgICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMueWVhcigpLCB3ZWVrSW5mby5kb3csIHdlZWtJbmZvLmRveSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldFNldFdlZWtZZWFySGVscGVyKGlucHV0LCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICAgIHZhciB3ZWVrc1RhcmdldDtcbiAgICAgICAgICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gd2Vla09mWWVhcih0aGlzLCBkb3csIGRveSkueWVhcjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3ZWVrc1RhcmdldCA9IHdlZWtzSW5ZZWFyKGlucHV0LCBkb3csIGRveSk7XG4gICAgICAgICAgICAgIGlmICh3ZWVrID4gd2Vla3NUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgIHdlZWsgPSB3ZWVrc1RhcmdldDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gc2V0V2Vla0FsbC5jYWxsKHRoaXMsIGlucHV0LCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzZXRXZWVrQWxsKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICAgIHZhciBkYXlPZlllYXJEYXRhID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSksXG4gICAgICAgICAgICAgIGRhdGUgPSBjcmVhdGVVVENEYXRlKGRheU9mWWVhckRhdGEueWVhciwgMCwgZGF5T2ZZZWFyRGF0YS5kYXlPZlllYXIpO1xuXG4gICAgICAgICAgdGhpcy55ZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSk7XG4gICAgICAgICAgdGhpcy5tb250aChkYXRlLmdldFVUQ01vbnRoKCkpO1xuICAgICAgICAgIHRoaXMuZGF0ZShkYXRlLmdldFVUQ0RhdGUoKSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIEZPUk1BVFRJTkdcblxuICAgICAgYWRkRm9ybWF0VG9rZW4oJ1EnLCAwLCAnUW8nLCAncXVhcnRlcicpO1xuXG4gICAgICAvLyBBTElBU0VTXG5cbiAgICAgIGFkZFVuaXRBbGlhcygncXVhcnRlcicsICdRJyk7XG5cbiAgICAgIC8vIFBBUlNJTkdcblxuICAgICAgYWRkUmVnZXhUb2tlbignUScsIG1hdGNoMSk7XG4gICAgICBhZGRQYXJzZVRva2VuKCdRJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICAgIGFycmF5W01PTlRIXSA9ICh0b0ludChpbnB1dCkgLSAxKSAqIDM7XG4gICAgICB9KTtcblxuICAgICAgLy8gTU9NRU5UU1xuXG4gICAgICBmdW5jdGlvbiBnZXRTZXRRdWFydGVyIChpbnB1dCkge1xuICAgICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gTWF0aC5jZWlsKCh0aGlzLm1vbnRoKCkgKyAxKSAvIDMpIDogdGhpcy5tb250aCgoaW5wdXQgLSAxKSAqIDMgKyB0aGlzLm1vbnRoKCkgJSAzKTtcbiAgICAgIH1cblxuICAgICAgLy8gRk9STUFUVElOR1xuXG4gICAgICBhZGRGb3JtYXRUb2tlbigndycsIFsnd3cnLCAyXSwgJ3dvJywgJ3dlZWsnKTtcbiAgICAgIGFkZEZvcm1hdFRva2VuKCdXJywgWydXVycsIDJdLCAnV28nLCAnaXNvV2VlaycpO1xuXG4gICAgICAvLyBBTElBU0VTXG5cbiAgICAgIGFkZFVuaXRBbGlhcygnd2VlaycsICd3Jyk7XG4gICAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWsnLCAnVycpO1xuXG4gICAgICAvLyBQQVJTSU5HXG5cbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ3cnLCAgbWF0Y2gxdG8yKTtcbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ3d3JywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgICAgYWRkUmVnZXhUb2tlbignVycsICBtYXRjaDF0bzIpO1xuICAgICAgYWRkUmVnZXhUb2tlbignV1cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbiAgICAgIGFkZFdlZWtQYXJzZVRva2VuKFsndycsICd3dycsICdXJywgJ1dXJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDEpXSA9IHRvSW50KGlucHV0KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBIRUxQRVJTXG5cbiAgICAgIC8vIExPQ0FMRVNcblxuICAgICAgZnVuY3Rpb24gbG9jYWxlV2VlayAobW9tKSB7XG4gICAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIobW9tLCB0aGlzLl93ZWVrLmRvdywgdGhpcy5fd2Vlay5kb3kpLndlZWs7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWZhdWx0TG9jYWxlV2VlayA9IHtcbiAgICAgICAgICBkb3cgOiAwLCAvLyBTdW5kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICBkb3kgOiA2ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBsb2NhbGVGaXJzdERheU9mV2VlayAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG93O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBsb2NhbGVGaXJzdERheU9mWWVhciAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG95O1xuICAgICAgfVxuXG4gICAgICAvLyBNT01FTlRTXG5cbiAgICAgIGZ1bmN0aW9uIGdldFNldFdlZWsgKGlucHV0KSB7XG4gICAgICAgICAgdmFyIHdlZWsgPSB0aGlzLmxvY2FsZURhdGEoKS53ZWVrKHRoaXMpO1xuICAgICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0U2V0SVNPV2VlayAoaW5wdXQpIHtcbiAgICAgICAgICB2YXIgd2VlayA9IHdlZWtPZlllYXIodGhpcywgMSwgNCkud2VlaztcbiAgICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEZPUk1BVFRJTkdcblxuICAgICAgYWRkRm9ybWF0VG9rZW4oJ0QnLCBbJ0REJywgMl0sICdEbycsICdkYXRlJyk7XG5cbiAgICAgIC8vIEFMSUFTRVNcblxuICAgICAgYWRkVW5pdEFsaWFzKCdkYXRlJywgJ0QnKTtcblxuICAgICAgLy8gUEFSU0lOR1xuXG4gICAgICBhZGRSZWdleFRva2VuKCdEJywgIG1hdGNoMXRvMik7XG4gICAgICBhZGRSZWdleFRva2VuKCdERCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgICByZXR1cm4gaXNTdHJpY3QgPyBsb2NhbGUuX29yZGluYWxQYXJzZSA6IGxvY2FsZS5fb3JkaW5hbFBhcnNlTGVuaWVudDtcbiAgICAgIH0pO1xuXG4gICAgICBhZGRQYXJzZVRva2VuKFsnRCcsICdERCddLCBEQVRFKTtcbiAgICAgIGFkZFBhcnNlVG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICAgIGFycmF5W0RBVEVdID0gdG9JbnQoaW5wdXQubWF0Y2gobWF0Y2gxdG8yKVswXSwgMTApO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIE1PTUVOVFNcblxuICAgICAgdmFyIGdldFNldERheU9mTW9udGggPSBtYWtlR2V0U2V0KCdEYXRlJywgdHJ1ZSk7XG5cbiAgICAgIC8vIEZPUk1BVFRJTkdcblxuICAgICAgYWRkRm9ybWF0VG9rZW4oJ2QnLCAwLCAnZG8nLCAnZGF5Jyk7XG5cbiAgICAgIGFkZEZvcm1hdFRva2VuKCdkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNNaW4odGhpcywgZm9ybWF0KTtcbiAgICAgIH0pO1xuXG4gICAgICBhZGRGb3JtYXRUb2tlbignZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgICB9KTtcblxuICAgICAgYWRkRm9ybWF0VG9rZW4oJ2RkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzKHRoaXMsIGZvcm1hdCk7XG4gICAgICB9KTtcblxuICAgICAgYWRkRm9ybWF0VG9rZW4oJ2UnLCAwLCAwLCAnd2Vla2RheScpO1xuICAgICAgYWRkRm9ybWF0VG9rZW4oJ0UnLCAwLCAwLCAnaXNvV2Vla2RheScpO1xuXG4gICAgICAvLyBBTElBU0VTXG5cbiAgICAgIGFkZFVuaXRBbGlhcygnZGF5JywgJ2QnKTtcbiAgICAgIGFkZFVuaXRBbGlhcygnd2Vla2RheScsICdlJyk7XG4gICAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWtkYXknLCAnRScpO1xuXG4gICAgICAvLyBQQVJTSU5HXG5cbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ2QnLCAgICBtYXRjaDF0bzIpO1xuICAgICAgYWRkUmVnZXhUb2tlbignZScsICAgIG1hdGNoMXRvMik7XG4gICAgICBhZGRSZWdleFRva2VuKCdFJywgICAgbWF0Y2gxdG8yKTtcbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ2RkJywgICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNNaW5SZWdleChpc1N0cmljdCk7XG4gICAgICB9KTtcbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ2RkZCcsICAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzU2hvcnRSZWdleChpc1N0cmljdCk7XG4gICAgICB9KTtcbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ2RkZGQnLCAgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1JlZ2V4KGlzU3RyaWN0KTtcbiAgICAgIH0pO1xuXG4gICAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2RkJywgJ2RkZCcsICdkZGRkJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICAgIHZhciB3ZWVrZGF5ID0gY29uZmlnLl9sb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgZ2V0IGEgd2Vla2RheSBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWRcbiAgICAgICAgICBpZiAod2Vla2RheSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHdlZWsuZCA9IHdlZWtkYXk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZFdlZWtkYXkgPSBpbnB1dDtcbiAgICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgYWRkV2Vla1BhcnNlVG9rZW4oWydkJywgJ2UnLCAnRSddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgICB3ZWVrW3Rva2VuXSA9IHRvSW50KGlucHV0KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBIRUxQRVJTXG5cbiAgICAgIGZ1bmN0aW9uIHBhcnNlV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghaXNOYU4oaW5wdXQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChpbnB1dCwgMTApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlucHV0ID0gbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpO1xuICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gTE9DQUxFU1xuXG4gICAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzID0gJ1N1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5Jy5zcGxpdCgnXycpO1xuICAgICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXMgKG0sIGZvcm1hdCkge1xuICAgICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX3dlZWtkYXlzKSA/IHRoaXMuX3dlZWtkYXlzW20uZGF5KCldIDpcbiAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNbdGhpcy5fd2Vla2RheXMuaXNGb3JtYXQudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSddW20uZGF5KCldO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQgPSAnU3VuX01vbl9UdWVfV2VkX1RodV9GcmlfU2F0Jy5zcGxpdCgnXycpO1xuICAgICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNTaG9ydCAobSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0W20uZGF5KCldO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluID0gJ1N1X01vX1R1X1dlX1RoX0ZyX1NhJy5zcGxpdCgnXycpO1xuICAgICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNNaW4gKG0pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5bbS5kYXkoKV07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRheV9vZl93ZWVrX19oYW5kbGVTdHJpY3RQYXJzZSh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgICB2YXIgaSwgaWksIG1vbSwgbGxjID0gd2Vla2RheU5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2UpIHtcbiAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZSA9IFtdO1xuXG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgIG1vbSA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdkZGRkJykge1xuICAgICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAnZGRkJykge1xuICAgICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09ICdkZGQnKSB7XG4gICAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1BhcnNlICh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRheV9vZl93ZWVrX19oYW5kbGVTdHJpY3RQYXJzZS5jYWxsKHRoaXMsIHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuXG4gICAgICAgICAgICAgIG1vbSA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICdcXC4/JykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkZGQnICYmIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGRkJyAmJiB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZCcgJiYgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gTU9NRU5UU1xuXG4gICAgICBmdW5jdGlvbiBnZXRTZXREYXlPZldlZWsgKGlucHV0KSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBkYXkgPSB0aGlzLl9pc1VUQyA/IHRoaXMuX2QuZ2V0VVRDRGF5KCkgOiB0aGlzLl9kLmdldERheSgpO1xuICAgICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGlucHV0ID0gcGFyc2VXZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChpbnB1dCAtIGRheSwgJ2QnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gZGF5O1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgd2Vla2RheSA9ICh0aGlzLmRheSgpICsgNyAtIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdykgJSA3O1xuICAgICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2Vla2RheSA6IHRoaXMuYWRkKGlucHV0IC0gd2Vla2RheSwgJ2QnKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0U2V0SVNPRGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBiZWhhdmVzIHRoZSBzYW1lIGFzIG1vbWVudCNkYXkgZXhjZXB0XG4gICAgICAgICAgLy8gYXMgYSBnZXR0ZXIsIHJldHVybnMgNyBpbnN0ZWFkIG9mIDAgKDEtNyByYW5nZSBpbnN0ZWFkIG9mIDAtNilcbiAgICAgICAgICAvLyBhcyBhIHNldHRlciwgc3VuZGF5IHNob3VsZCBiZWxvbmcgdG8gdGhlIHByZXZpb3VzIHdlZWsuXG4gICAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB0aGlzLmRheSgpIHx8IDcgOiB0aGlzLmRheSh0aGlzLmRheSgpICUgNyA/IGlucHV0IDogaW5wdXQgLSA3KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRlZmF1bHRXZWVrZGF5c1JlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgICAgZnVuY3Rpb24gd2Vla2RheXNSZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgICAgZnVuY3Rpb24gd2Vla2RheXNTaG9ydFJlZ2V4IChpc1N0cmljdCkge1xuICAgICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgICBjb21wdXRlV2Vla2RheXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCA6IHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleDtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWZhdWx0V2Vla2RheXNNaW5SZWdleCA9IG1hdGNoV29yZDtcbiAgICAgIGZ1bmN0aW9uIHdlZWtkYXlzTWluUmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblJlZ2V4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCA6IHRoaXMuX3dlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG5cbiAgICAgIGZ1bmN0aW9uIGNvbXB1dGVXZWVrZGF5c1BhcnNlICgpIHtcbiAgICAgICAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xuICAgICAgICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbWluUGllY2VzID0gW10sIHNob3J0UGllY2VzID0gW10sIGxvbmdQaWVjZXMgPSBbXSwgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgICAgaSwgbW9tLCBtaW5wLCBzaG9ydHAsIGxvbmdwO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICAgIG1vbSA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgICAgbWlucCA9IHRoaXMud2Vla2RheXNNaW4obW9tLCAnJyk7XG4gICAgICAgICAgICAgIHNob3J0cCA9IHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKTtcbiAgICAgICAgICAgICAgbG9uZ3AgPSB0aGlzLndlZWtkYXlzKG1vbSwgJycpO1xuICAgICAgICAgICAgICBtaW5QaWVjZXMucHVzaChtaW5wKTtcbiAgICAgICAgICAgICAgc2hvcnRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICAgICAgICBsb25nUGllY2VzLnB1c2gobG9uZ3ApO1xuICAgICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKG1pbnApO1xuICAgICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHNob3J0cCk7XG4gICAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2gobG9uZ3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIHdlZWtkYXkgKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcbiAgICAgICAgICAvLyB3aWxsIG1hdGNoIHRoZSBsb25nZXIgcGllY2UuXG4gICAgICAgICAgbWluUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgICBzaG9ydFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgICAgbG9uZ1BpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgICAgbWl4ZWRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgICAgc2hvcnRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShzaG9ydFBpZWNlc1tpXSk7XG4gICAgICAgICAgICAgIGxvbmdQaWVjZXNbaV0gPSByZWdleEVzY2FwZShsb25nUGllY2VzW2ldKTtcbiAgICAgICAgICAgICAgbWl4ZWRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShtaXhlZFBpZWNlc1tpXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fd2Vla2RheXNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXggPSB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICAgIHRoaXMuX3dlZWtkYXlzTWluUmVnZXggPSB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuXG4gICAgICAgICAgdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIHNob3J0UGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgICB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWluUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgIH1cblxuICAgICAgLy8gRk9STUFUVElOR1xuXG4gICAgICBhZGRGb3JtYXRUb2tlbignREREJywgWydEREREJywgM10sICdERERvJywgJ2RheU9mWWVhcicpO1xuXG4gICAgICAvLyBBTElBU0VTXG5cbiAgICAgIGFkZFVuaXRBbGlhcygnZGF5T2ZZZWFyJywgJ0RERCcpO1xuXG4gICAgICAvLyBQQVJTSU5HXG5cbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ0RERCcsICBtYXRjaDF0bzMpO1xuICAgICAgYWRkUmVnZXhUb2tlbignRERERCcsIG1hdGNoMyk7XG4gICAgICBhZGRQYXJzZVRva2VuKFsnREREJywgJ0REREQnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0b0ludChpbnB1dCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gSEVMUEVSU1xuXG4gICAgICAvLyBNT01FTlRTXG5cbiAgICAgIGZ1bmN0aW9uIGdldFNldERheU9mWWVhciAoaW5wdXQpIHtcbiAgICAgICAgICB2YXIgZGF5T2ZZZWFyID0gTWF0aC5yb3VuZCgodGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpIC0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ3llYXInKSkgLyA4NjRlNSkgKyAxO1xuICAgICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gZGF5T2ZZZWFyIDogdGhpcy5hZGQoKGlucHV0IC0gZGF5T2ZZZWFyKSwgJ2QnKTtcbiAgICAgIH1cblxuICAgICAgLy8gRk9STUFUVElOR1xuXG4gICAgICBmdW5jdGlvbiBoRm9ybWF0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmhvdXJzKCkgJSAxMiB8fCAxMjtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24ga0Zvcm1hdCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5ob3VycygpIHx8IDI0O1xuICAgICAgfVxuXG4gICAgICBhZGRGb3JtYXRUb2tlbignSCcsIFsnSEgnLCAyXSwgMCwgJ2hvdXInKTtcbiAgICAgIGFkZEZvcm1hdFRva2VuKCdoJywgWydoaCcsIDJdLCAwLCBoRm9ybWF0KTtcbiAgICAgIGFkZEZvcm1hdFRva2VuKCdrJywgWydraycsIDJdLCAwLCBrRm9ybWF0KTtcblxuICAgICAgYWRkRm9ybWF0VG9rZW4oJ2htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gJycgKyBoRm9ybWF0LmFwcGx5KHRoaXMpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpO1xuICAgICAgfSk7XG5cbiAgICAgIGFkZEZvcm1hdFRva2VuKCdobW1zcycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gJycgKyBoRm9ybWF0LmFwcGx5KHRoaXMpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcbiAgICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5zZWNvbmRzKCksIDIpO1xuICAgICAgfSk7XG5cbiAgICAgIGFkZEZvcm1hdFRva2VuKCdIbW0nLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuICcnICsgdGhpcy5ob3VycygpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpO1xuICAgICAgfSk7XG5cbiAgICAgIGFkZEZvcm1hdFRva2VuKCdIbW1zcycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gJycgKyB0aGlzLmhvdXJzKCkgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMikgK1xuICAgICAgICAgICAgICB6ZXJvRmlsbCh0aGlzLnNlY29uZHMoKSwgMik7XG4gICAgICB9KTtcblxuICAgICAgZnVuY3Rpb24gbWVyaWRpZW0gKHRva2VuLCBsb3dlcmNhc2UpIHtcbiAgICAgICAgICBhZGRGb3JtYXRUb2tlbih0b2tlbiwgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubWVyaWRpZW0odGhpcy5ob3VycygpLCB0aGlzLm1pbnV0ZXMoKSwgbG93ZXJjYXNlKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgbWVyaWRpZW0oJ2EnLCB0cnVlKTtcbiAgICAgIG1lcmlkaWVtKCdBJywgZmFsc2UpO1xuXG4gICAgICAvLyBBTElBU0VTXG5cbiAgICAgIGFkZFVuaXRBbGlhcygnaG91cicsICdoJyk7XG5cbiAgICAgIC8vIFBBUlNJTkdcblxuICAgICAgZnVuY3Rpb24gbWF0Y2hNZXJpZGllbSAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICAgIHJldHVybiBsb2NhbGUuX21lcmlkaWVtUGFyc2U7XG4gICAgICB9XG5cbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ2EnLCAgbWF0Y2hNZXJpZGllbSk7XG4gICAgICBhZGRSZWdleFRva2VuKCdBJywgIG1hdGNoTWVyaWRpZW0pO1xuICAgICAgYWRkUmVnZXhUb2tlbignSCcsICBtYXRjaDF0bzIpO1xuICAgICAgYWRkUmVnZXhUb2tlbignaCcsICBtYXRjaDF0bzIpO1xuICAgICAgYWRkUmVnZXhUb2tlbignSEgnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgICBhZGRSZWdleFRva2VuKCdoaCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuICAgICAgYWRkUmVnZXhUb2tlbignaG1tJywgbWF0Y2gzdG80KTtcbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ2htbXNzJywgbWF0Y2g1dG82KTtcbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ0htbScsIG1hdGNoM3RvNCk7XG4gICAgICBhZGRSZWdleFRva2VuKCdIbW1zcycsIG1hdGNoNXRvNik7XG5cbiAgICAgIGFkZFBhcnNlVG9rZW4oWydIJywgJ0hIJ10sIEhPVVIpO1xuICAgICAgYWRkUGFyc2VUb2tlbihbJ2EnLCAnQSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgICBjb25maWcuX2lzUG0gPSBjb25maWcuX2xvY2FsZS5pc1BNKGlucHV0KTtcbiAgICAgICAgICBjb25maWcuX21lcmlkaWVtID0gaW5wdXQ7XG4gICAgICB9KTtcbiAgICAgIGFkZFBhcnNlVG9rZW4oWydoJywgJ2hoJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICBhZGRQYXJzZVRva2VuKCdobW0nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcbiAgICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvcykpO1xuICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICBhZGRQYXJzZVRva2VuKCdobW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNDtcbiAgICAgICAgICB2YXIgcG9zMiA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xuICAgICAgICAgIGFycmF5W1NFQ09ORF0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMikpO1xuICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICBhZGRQYXJzZVRva2VuKCdIbW0nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcbiAgICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvcykpO1xuICAgICAgfSk7XG4gICAgICBhZGRQYXJzZVRva2VuKCdIbW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNDtcbiAgICAgICAgICB2YXIgcG9zMiA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xuICAgICAgICAgIGFycmF5W1NFQ09ORF0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMikpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIExPQ0FMRVNcblxuICAgICAgZnVuY3Rpb24gbG9jYWxlSXNQTSAoaW5wdXQpIHtcbiAgICAgICAgICAvLyBJRTggUXVpcmtzIE1vZGUgJiBJRTcgU3RhbmRhcmRzIE1vZGUgZG8gbm90IGFsbG93IGFjY2Vzc2luZyBzdHJpbmdzIGxpa2UgYXJyYXlzXG4gICAgICAgICAgLy8gVXNpbmcgY2hhckF0IHNob3VsZCBiZSBtb3JlIGNvbXBhdGlibGUuXG4gICAgICAgICAgcmV0dXJuICgoaW5wdXQgKyAnJykudG9Mb3dlckNhc2UoKS5jaGFyQXQoMCkgPT09ICdwJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZSA9IC9bYXBdXFwuP20/XFwuPy9pO1xuICAgICAgZnVuY3Rpb24gbG9jYWxlTWVyaWRpZW0gKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XG4gICAgICAgICAgaWYgKGhvdXJzID4gMTEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAncG0nIDogJ1BNJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdhbScgOiAnQU0nO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuXG4gICAgICAvLyBNT01FTlRTXG5cbiAgICAgIC8vIFNldHRpbmcgdGhlIGhvdXIgc2hvdWxkIGtlZXAgdGhlIHRpbWUsIGJlY2F1c2UgdGhlIHVzZXIgZXhwbGljaXRseVxuICAgICAgLy8gc3BlY2lmaWVkIHdoaWNoIGhvdXIgaGUgd2FudHMuIFNvIHRyeWluZyB0byBtYWludGFpbiB0aGUgc2FtZSBob3VyIChpblxuICAgICAgLy8gYSBuZXcgdGltZXpvbmUpIG1ha2VzIHNlbnNlLiBBZGRpbmcvc3VidHJhY3RpbmcgaG91cnMgZG9lcyBub3QgZm9sbG93XG4gICAgICAvLyB0aGlzIHJ1bGUuXG4gICAgICB2YXIgZ2V0U2V0SG91ciA9IG1ha2VHZXRTZXQoJ0hvdXJzJywgdHJ1ZSk7XG5cbiAgICAgIC8vIEZPUk1BVFRJTkdcblxuICAgICAgYWRkRm9ybWF0VG9rZW4oJ20nLCBbJ21tJywgMl0sIDAsICdtaW51dGUnKTtcblxuICAgICAgLy8gQUxJQVNFU1xuXG4gICAgICBhZGRVbml0QWxpYXMoJ21pbnV0ZScsICdtJyk7XG5cbiAgICAgIC8vIFBBUlNJTkdcblxuICAgICAgYWRkUmVnZXhUb2tlbignbScsICBtYXRjaDF0bzIpO1xuICAgICAgYWRkUmVnZXhUb2tlbignbW0nLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgICBhZGRQYXJzZVRva2VuKFsnbScsICdtbSddLCBNSU5VVEUpO1xuXG4gICAgICAvLyBNT01FTlRTXG5cbiAgICAgIHZhciBnZXRTZXRNaW51dGUgPSBtYWtlR2V0U2V0KCdNaW51dGVzJywgZmFsc2UpO1xuXG4gICAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICAgIGFkZEZvcm1hdFRva2VuKCdzJywgWydzcycsIDJdLCAwLCAnc2Vjb25kJyk7XG5cbiAgICAgIC8vIEFMSUFTRVNcblxuICAgICAgYWRkVW5pdEFsaWFzKCdzZWNvbmQnLCAncycpO1xuXG4gICAgICAvLyBQQVJTSU5HXG5cbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ3MnLCAgbWF0Y2gxdG8yKTtcbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ3NzJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgICAgYWRkUGFyc2VUb2tlbihbJ3MnLCAnc3MnXSwgU0VDT05EKTtcblxuICAgICAgLy8gTU9NRU5UU1xuXG4gICAgICB2YXIgZ2V0U2V0U2Vjb25kID0gbWFrZUdldFNldCgnU2Vjb25kcycsIGZhbHNlKTtcblxuICAgICAgLy8gRk9STUFUVElOR1xuXG4gICAgICBhZGRGb3JtYXRUb2tlbignUycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTAwKTtcbiAgICAgIH0pO1xuXG4gICAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTApO1xuICAgICAgfSk7XG5cbiAgICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTJywgM10sIDAsICdtaWxsaXNlY29uZCcpO1xuICAgICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTJywgNF0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTA7XG4gICAgICB9KTtcbiAgICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1MnLCA1XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDA7XG4gICAgICB9KTtcbiAgICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTJywgNl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDtcbiAgICAgIH0pO1xuICAgICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTJywgN10sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDA7XG4gICAgICB9KTtcbiAgICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1MnLCA4XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDA7XG4gICAgICB9KTtcbiAgICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1NTJywgOV0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwMDtcbiAgICAgIH0pO1xuXG5cbiAgICAgIC8vIEFMSUFTRVNcblxuICAgICAgYWRkVW5pdEFsaWFzKCdtaWxsaXNlY29uZCcsICdtcycpO1xuXG4gICAgICAvLyBQQVJTSU5HXG5cbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ1MnLCAgICBtYXRjaDF0bzMsIG1hdGNoMSk7XG4gICAgICBhZGRSZWdleFRva2VuKCdTUycsICAgbWF0Y2gxdG8zLCBtYXRjaDIpO1xuICAgICAgYWRkUmVnZXhUb2tlbignU1NTJywgIG1hdGNoMXRvMywgbWF0Y2gzKTtcblxuICAgICAgdmFyIHRva2VuO1xuICAgICAgZm9yICh0b2tlbiA9ICdTU1NTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgICAgICAgIGFkZFJlZ2V4VG9rZW4odG9rZW4sIG1hdGNoVW5zaWduZWQpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwYXJzZU1zKGlucHV0LCBhcnJheSkge1xuICAgICAgICAgIGFycmF5W01JTExJU0VDT05EXSA9IHRvSW50KCgnMC4nICsgaW5wdXQpICogMTAwMCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodG9rZW4gPSAnUyc7IHRva2VuLmxlbmd0aCA8PSA5OyB0b2tlbiArPSAnUycpIHtcbiAgICAgICAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBwYXJzZU1zKTtcbiAgICAgIH1cbiAgICAgIC8vIE1PTUVOVFNcblxuICAgICAgdmFyIGdldFNldE1pbGxpc2Vjb25kID0gbWFrZUdldFNldCgnTWlsbGlzZWNvbmRzJywgZmFsc2UpO1xuXG4gICAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICAgIGFkZEZvcm1hdFRva2VuKCd6JywgIDAsIDAsICd6b25lQWJicicpO1xuICAgICAgYWRkRm9ybWF0VG9rZW4oJ3p6JywgMCwgMCwgJ3pvbmVOYW1lJyk7XG5cbiAgICAgIC8vIE1PTUVOVFNcblxuICAgICAgZnVuY3Rpb24gZ2V0Wm9uZUFiYnIgKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdVVEMnIDogJyc7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldFpvbmVOYW1lICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnQ29vcmRpbmF0ZWQgVW5pdmVyc2FsIFRpbWUnIDogJyc7XG4gICAgICB9XG5cbiAgICAgIHZhciBtb21lbnRQcm90b3R5cGVfX3Byb3RvID0gTW9tZW50LnByb3RvdHlwZTtcblxuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5hZGQgICAgICAgICAgICAgICA9IGFkZF9zdWJ0cmFjdF9fYWRkO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5jYWxlbmRhciAgICAgICAgICA9IG1vbWVudF9jYWxlbmRhcl9fY2FsZW5kYXI7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmNsb25lICAgICAgICAgICAgID0gY2xvbmU7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRpZmYgICAgICAgICAgICAgID0gZGlmZjtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZW5kT2YgICAgICAgICAgICAgPSBlbmRPZjtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZm9ybWF0ICAgICAgICAgICAgPSBmb3JtYXQ7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmZyb20gICAgICAgICAgICAgID0gZnJvbTtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZnJvbU5vdyAgICAgICAgICAgPSBmcm9tTm93O1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by50byAgICAgICAgICAgICAgICA9IHRvO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by50b05vdyAgICAgICAgICAgICA9IHRvTm93O1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5nZXQgICAgICAgICAgICAgICA9IGdldFNldDtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaW52YWxpZEF0ICAgICAgICAgPSBpbnZhbGlkQXQ7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzQWZ0ZXIgICAgICAgICAgID0gaXNBZnRlcjtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNCZWZvcmUgICAgICAgICAgPSBpc0JlZm9yZTtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNCZXR3ZWVuICAgICAgICAgPSBpc0JldHdlZW47XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzU2FtZSAgICAgICAgICAgID0gaXNTYW1lO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc1NhbWVPckFmdGVyICAgICA9IGlzU2FtZU9yQWZ0ZXI7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzU2FtZU9yQmVmb3JlICAgID0gaXNTYW1lT3JCZWZvcmU7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzVmFsaWQgICAgICAgICAgID0gbW9tZW50X3ZhbGlkX19pc1ZhbGlkO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5sYW5nICAgICAgICAgICAgICA9IGxhbmc7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmxvY2FsZSAgICAgICAgICAgID0gbG9jYWxlO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5sb2NhbGVEYXRhICAgICAgICA9IGxvY2FsZURhdGE7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1heCAgICAgICAgICAgICAgID0gcHJvdG90eXBlTWF4O1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5taW4gICAgICAgICAgICAgICA9IHByb3RvdHlwZU1pbjtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ucGFyc2luZ0ZsYWdzICAgICAgPSBwYXJzaW5nRmxhZ3M7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnNldCAgICAgICAgICAgICAgID0gZ2V0U2V0O1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5zdGFydE9mICAgICAgICAgICA9IHN0YXJ0T2Y7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnN1YnRyYWN0ICAgICAgICAgID0gYWRkX3N1YnRyYWN0X19zdWJ0cmFjdDtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9BcnJheSAgICAgICAgICAgPSB0b0FycmF5O1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by50b09iamVjdCAgICAgICAgICA9IHRvT2JqZWN0O1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by50b0RhdGUgICAgICAgICAgICA9IHRvRGF0ZTtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9JU09TdHJpbmcgICAgICAgPSBtb21lbnRfZm9ybWF0X190b0lTT1N0cmluZztcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9KU09OICAgICAgICAgICAgPSB0b0pTT047XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvU3RyaW5nICAgICAgICAgID0gdG9TdHJpbmc7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnVuaXggICAgICAgICAgICAgID0gdW5peDtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udmFsdWVPZiAgICAgICAgICAgPSB0b190eXBlX192YWx1ZU9mO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5jcmVhdGlvbkRhdGEgICAgICA9IGNyZWF0aW9uRGF0YTtcblxuICAgICAgLy8gWWVhclxuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by55ZWFyICAgICAgID0gZ2V0U2V0WWVhcjtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNMZWFwWWVhciA9IGdldElzTGVhcFllYXI7XG5cbiAgICAgIC8vIFdlZWsgWWVhclxuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by53ZWVrWWVhciAgICA9IGdldFNldFdlZWtZZWFyO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc29XZWVrWWVhciA9IGdldFNldElTT1dlZWtZZWFyO1xuXG4gICAgICAvLyBRdWFydGVyXG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnF1YXJ0ZXIgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnF1YXJ0ZXJzID0gZ2V0U2V0UXVhcnRlcjtcblxuICAgICAgLy8gTW9udGhcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubW9udGggICAgICAgPSBnZXRTZXRNb250aDtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGF5c0luTW9udGggPSBnZXREYXlzSW5Nb250aDtcblxuICAgICAgLy8gV2Vla1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by53ZWVrICAgICAgICAgICA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8ud2Vla3MgICAgICAgID0gZ2V0U2V0V2VlaztcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNvV2VlayAgICAgICAgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzb1dlZWtzICAgICA9IGdldFNldElTT1dlZWs7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLndlZWtzSW5ZZWFyICAgID0gZ2V0V2Vla3NJblllYXI7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzb1dlZWtzSW5ZZWFyID0gZ2V0SVNPV2Vla3NJblllYXI7XG5cbiAgICAgIC8vIERheVxuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5kYXRlICAgICAgID0gZ2V0U2V0RGF5T2ZNb250aDtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGF5ICAgICAgICA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGF5cyAgICAgICAgICAgICA9IGdldFNldERheU9mV2VlaztcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ud2Vla2RheSAgICA9IGdldFNldExvY2FsZURheU9mV2VlaztcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNvV2Vla2RheSA9IGdldFNldElTT0RheU9mV2VlaztcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGF5T2ZZZWFyICA9IGdldFNldERheU9mWWVhcjtcblxuICAgICAgLy8gSG91clxuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5ob3VyID0gbW9tZW50UHJvdG90eXBlX19wcm90by5ob3VycyA9IGdldFNldEhvdXI7XG5cbiAgICAgIC8vIE1pbnV0ZVxuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5taW51dGUgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1pbnV0ZXMgPSBnZXRTZXRNaW51dGU7XG5cbiAgICAgIC8vIFNlY29uZFxuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5zZWNvbmQgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnNlY29uZHMgPSBnZXRTZXRTZWNvbmQ7XG5cbiAgICAgIC8vIE1pbGxpc2Vjb25kXG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1pbGxpc2Vjb25kID0gbW9tZW50UHJvdG90eXBlX19wcm90by5taWxsaXNlY29uZHMgPSBnZXRTZXRNaWxsaXNlY29uZDtcblxuICAgICAgLy8gT2Zmc2V0XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnV0Y09mZnNldCAgICAgICAgICAgID0gZ2V0U2V0T2Zmc2V0O1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by51dGMgICAgICAgICAgICAgICAgICA9IHNldE9mZnNldFRvVVRDO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5sb2NhbCAgICAgICAgICAgICAgICA9IHNldE9mZnNldFRvTG9jYWw7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnBhcnNlWm9uZSAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQ7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmhhc0FsaWduZWRIb3VyT2Zmc2V0ID0gaGFzQWxpZ25lZEhvdXJPZmZzZXQ7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzRFNUICAgICAgICAgICAgICAgID0gaXNEYXlsaWdodFNhdmluZ1RpbWU7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzRFNUU2hpZnRlZCAgICAgICAgID0gaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0xvY2FsICAgICAgICAgICAgICA9IGlzTG9jYWw7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzVXRjT2Zmc2V0ICAgICAgICAgID0gaXNVdGNPZmZzZXQ7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzVXRjICAgICAgICAgICAgICAgID0gaXNVdGM7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzVVRDICAgICAgICAgICAgICAgID0gaXNVdGM7XG5cbiAgICAgIC8vIFRpbWV6b25lXG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnpvbmVBYmJyID0gZ2V0Wm9uZUFiYnI7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnpvbmVOYW1lID0gZ2V0Wm9uZU5hbWU7XG5cbiAgICAgIC8vIERlcHJlY2F0aW9uc1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by5kYXRlcyAgPSBkZXByZWNhdGUoJ2RhdGVzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBkYXRlIGluc3RlYWQuJywgZ2V0U2V0RGF5T2ZNb250aCk7XG4gICAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1vbnRocyA9IGRlcHJlY2F0ZSgnbW9udGhzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb250aCBpbnN0ZWFkJywgZ2V0U2V0TW9udGgpO1xuICAgICAgbW9tZW50UHJvdG90eXBlX19wcm90by55ZWFycyAgPSBkZXByZWNhdGUoJ3llYXJzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSB5ZWFyIGluc3RlYWQnLCBnZXRTZXRZZWFyKTtcbiAgICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uem9uZSAgID0gZGVwcmVjYXRlKCdtb21lbnQoKS56b25lIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQoKS51dGNPZmZzZXQgaW5zdGVhZC4gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE3NzknLCBnZXRTZXRab25lKTtcblxuICAgICAgdmFyIG1vbWVudFByb3RvdHlwZSA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG87XG5cbiAgICAgIGZ1bmN0aW9uIG1vbWVudF9fY3JlYXRlVW5peCAoaW5wdXQpIHtcbiAgICAgICAgICByZXR1cm4gbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0ICogMTAwMCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG1vbWVudF9fY3JlYXRlSW5ab25lICgpIHtcbiAgICAgICAgICByZXR1cm4gbG9jYWxfX2NyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cykucGFyc2Vab25lKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWZhdWx0Q2FsZW5kYXIgPSB7XG4gICAgICAgICAgc2FtZURheSA6ICdbVG9kYXkgYXRdIExUJyxcbiAgICAgICAgICBuZXh0RGF5IDogJ1tUb21vcnJvdyBhdF0gTFQnLFxuICAgICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW2F0XSBMVCcsXG4gICAgICAgICAgbGFzdERheSA6ICdbWWVzdGVyZGF5IGF0XSBMVCcsXG4gICAgICAgICAgbGFzdFdlZWsgOiAnW0xhc3RdIGRkZGQgW2F0XSBMVCcsXG4gICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIGxvY2FsZV9jYWxlbmRhcl9fY2FsZW5kYXIgKGtleSwgbW9tLCBub3cpIHtcbiAgICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fY2FsZW5kYXJba2V5XTtcbiAgICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihvdXRwdXQpID8gb3V0cHV0LmNhbGwobW9tLCBub3cpIDogb3V0cHV0O1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVmYXVsdExvbmdEYXRlRm9ybWF0ID0ge1xuICAgICAgICAgIExUUyAgOiAnaDptbTpzcyBBJyxcbiAgICAgICAgICBMVCAgIDogJ2g6bW0gQScsXG4gICAgICAgICAgTCAgICA6ICdNTS9ERC9ZWVlZJyxcbiAgICAgICAgICBMTCAgIDogJ01NTU0gRCwgWVlZWScsXG4gICAgICAgICAgTExMICA6ICdNTU1NIEQsIFlZWVkgaDptbSBBJyxcbiAgICAgICAgICBMTExMIDogJ2RkZGQsIE1NTU0gRCwgWVlZWSBoOm1tIEEnXG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBsb25nRGF0ZUZvcm1hdCAoa2V5KSB7XG4gICAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0sXG4gICAgICAgICAgICAgIGZvcm1hdFVwcGVyID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5LnRvVXBwZXJDYXNlKCldO1xuXG4gICAgICAgICAgaWYgKGZvcm1hdCB8fCAhZm9ybWF0VXBwZXIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldID0gZm9ybWF0VXBwZXIucmVwbGFjZSgvTU1NTXxNTXxERHxkZGRkL2csIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbC5zbGljZSgxKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybiB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVmYXVsdEludmFsaWREYXRlID0gJ0ludmFsaWQgZGF0ZSc7XG5cbiAgICAgIGZ1bmN0aW9uIGludmFsaWREYXRlICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5faW52YWxpZERhdGU7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWZhdWx0T3JkaW5hbCA9ICclZCc7XG4gICAgICB2YXIgZGVmYXVsdE9yZGluYWxQYXJzZSA9IC9cXGR7MSwyfS87XG5cbiAgICAgIGZ1bmN0aW9uIG9yZGluYWwgKG51bWJlcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9vcmRpbmFsLnJlcGxhY2UoJyVkJywgbnVtYmVyKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcHJlUGFyc2VQb3N0Rm9ybWF0IChzdHJpbmcpIHtcbiAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVmYXVsdFJlbGF0aXZlVGltZSA9IHtcbiAgICAgICAgICBmdXR1cmUgOiAnaW4gJXMnLFxuICAgICAgICAgIHBhc3QgICA6ICclcyBhZ28nLFxuICAgICAgICAgIHMgIDogJ2EgZmV3IHNlY29uZHMnLFxuICAgICAgICAgIG0gIDogJ2EgbWludXRlJyxcbiAgICAgICAgICBtbSA6ICclZCBtaW51dGVzJyxcbiAgICAgICAgICBoICA6ICdhbiBob3VyJyxcbiAgICAgICAgICBoaCA6ICclZCBob3VycycsXG4gICAgICAgICAgZCAgOiAnYSBkYXknLFxuICAgICAgICAgIGRkIDogJyVkIGRheXMnLFxuICAgICAgICAgIE0gIDogJ2EgbW9udGgnLFxuICAgICAgICAgIE1NIDogJyVkIG1vbnRocycsXG4gICAgICAgICAgeSAgOiAnYSB5ZWFyJyxcbiAgICAgICAgICB5eSA6ICclZCB5ZWFycydcbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIHJlbGF0aXZlX19yZWxhdGl2ZVRpbWUgKG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSkge1xuICAgICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbc3RyaW5nXTtcbiAgICAgICAgICByZXR1cm4gKGlzRnVuY3Rpb24ob3V0cHV0KSkgP1xuICAgICAgICAgICAgICBvdXRwdXQobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSA6XG4gICAgICAgICAgICAgIG91dHB1dC5yZXBsYWNlKC8lZC9pLCBudW1iZXIpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwYXN0RnV0dXJlIChkaWZmLCBvdXRwdXQpIHtcbiAgICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW2RpZmYgPiAwID8gJ2Z1dHVyZScgOiAncGFzdCddO1xuICAgICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKGZvcm1hdCkgPyBmb3JtYXQob3V0cHV0KSA6IGZvcm1hdC5yZXBsYWNlKC8lcy9pLCBvdXRwdXQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvdG90eXBlX19wcm90byA9IExvY2FsZS5wcm90b3R5cGU7XG5cbiAgICAgIHByb3RvdHlwZV9fcHJvdG8uX2NhbGVuZGFyICAgICAgID0gZGVmYXVsdENhbGVuZGFyO1xuICAgICAgcHJvdG90eXBlX19wcm90by5jYWxlbmRhciAgICAgICAgPSBsb2NhbGVfY2FsZW5kYXJfX2NhbGVuZGFyO1xuICAgICAgcHJvdG90eXBlX19wcm90by5fbG9uZ0RhdGVGb3JtYXQgPSBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQ7XG4gICAgICBwcm90b3R5cGVfX3Byb3RvLmxvbmdEYXRlRm9ybWF0ICA9IGxvbmdEYXRlRm9ybWF0O1xuICAgICAgcHJvdG90eXBlX19wcm90by5faW52YWxpZERhdGUgICAgPSBkZWZhdWx0SW52YWxpZERhdGU7XG4gICAgICBwcm90b3R5cGVfX3Byb3RvLmludmFsaWREYXRlICAgICA9IGludmFsaWREYXRlO1xuICAgICAgcHJvdG90eXBlX19wcm90by5fb3JkaW5hbCAgICAgICAgPSBkZWZhdWx0T3JkaW5hbDtcbiAgICAgIHByb3RvdHlwZV9fcHJvdG8ub3JkaW5hbCAgICAgICAgID0gb3JkaW5hbDtcbiAgICAgIHByb3RvdHlwZV9fcHJvdG8uX29yZGluYWxQYXJzZSAgID0gZGVmYXVsdE9yZGluYWxQYXJzZTtcbiAgICAgIHByb3RvdHlwZV9fcHJvdG8ucHJlcGFyc2UgICAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xuICAgICAgcHJvdG90eXBlX19wcm90by5wb3N0Zm9ybWF0ICAgICAgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG4gICAgICBwcm90b3R5cGVfX3Byb3RvLl9yZWxhdGl2ZVRpbWUgICA9IGRlZmF1bHRSZWxhdGl2ZVRpbWU7XG4gICAgICBwcm90b3R5cGVfX3Byb3RvLnJlbGF0aXZlVGltZSAgICA9IHJlbGF0aXZlX19yZWxhdGl2ZVRpbWU7XG4gICAgICBwcm90b3R5cGVfX3Byb3RvLnBhc3RGdXR1cmUgICAgICA9IHBhc3RGdXR1cmU7XG4gICAgICBwcm90b3R5cGVfX3Byb3RvLnNldCAgICAgICAgICAgICA9IGxvY2FsZV9zZXRfX3NldDtcblxuICAgICAgLy8gTW9udGhcbiAgICAgIHByb3RvdHlwZV9fcHJvdG8ubW9udGhzICAgICAgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzO1xuICAgICAgcHJvdG90eXBlX19wcm90by5fbW9udGhzICAgICAgICAgICA9IGRlZmF1bHRMb2NhbGVNb250aHM7XG4gICAgICBwcm90b3R5cGVfX3Byb3RvLm1vbnRoc1Nob3J0ICAgICAgID0gICAgICAgIGxvY2FsZU1vbnRoc1Nob3J0O1xuICAgICAgcHJvdG90eXBlX19wcm90by5fbW9udGhzU2hvcnQgICAgICA9IGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydDtcbiAgICAgIHByb3RvdHlwZV9fcHJvdG8ubW9udGhzUGFyc2UgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzUGFyc2U7XG4gICAgICBwcm90b3R5cGVfX3Byb3RvLl9tb250aHNSZWdleCAgICAgID0gZGVmYXVsdE1vbnRoc1JlZ2V4O1xuICAgICAgcHJvdG90eXBlX19wcm90by5tb250aHNSZWdleCAgICAgICA9IG1vbnRoc1JlZ2V4O1xuICAgICAgcHJvdG90eXBlX19wcm90by5fbW9udGhzU2hvcnRSZWdleCA9IGRlZmF1bHRNb250aHNTaG9ydFJlZ2V4O1xuICAgICAgcHJvdG90eXBlX19wcm90by5tb250aHNTaG9ydFJlZ2V4ICA9IG1vbnRoc1Nob3J0UmVnZXg7XG5cbiAgICAgIC8vIFdlZWtcbiAgICAgIHByb3RvdHlwZV9fcHJvdG8ud2VlayA9IGxvY2FsZVdlZWs7XG4gICAgICBwcm90b3R5cGVfX3Byb3RvLl93ZWVrID0gZGVmYXVsdExvY2FsZVdlZWs7XG4gICAgICBwcm90b3R5cGVfX3Byb3RvLmZpcnN0RGF5T2ZZZWFyID0gbG9jYWxlRmlyc3REYXlPZlllYXI7XG4gICAgICBwcm90b3R5cGVfX3Byb3RvLmZpcnN0RGF5T2ZXZWVrID0gbG9jYWxlRmlyc3REYXlPZldlZWs7XG5cbiAgICAgIC8vIERheSBvZiBXZWVrXG4gICAgICBwcm90b3R5cGVfX3Byb3RvLndlZWtkYXlzICAgICAgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzO1xuICAgICAgcHJvdG90eXBlX19wcm90by5fd2Vla2RheXMgICAgICA9IGRlZmF1bHRMb2NhbGVXZWVrZGF5cztcbiAgICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXNNaW4gICAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNNaW47XG4gICAgICBwcm90b3R5cGVfX3Byb3RvLl93ZWVrZGF5c01pbiAgID0gZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluO1xuICAgICAgcHJvdG90eXBlX19wcm90by53ZWVrZGF5c1Nob3J0ICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c1Nob3J0O1xuICAgICAgcHJvdG90eXBlX19wcm90by5fd2Vla2RheXNTaG9ydCA9IGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0O1xuICAgICAgcHJvdG90eXBlX19wcm90by53ZWVrZGF5c1BhcnNlICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c1BhcnNlO1xuXG4gICAgICBwcm90b3R5cGVfX3Byb3RvLl93ZWVrZGF5c1JlZ2V4ICAgICAgPSBkZWZhdWx0V2Vla2RheXNSZWdleDtcbiAgICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXNSZWdleCAgICAgICA9ICAgICAgICB3ZWVrZGF5c1JlZ2V4O1xuICAgICAgcHJvdG90eXBlX19wcm90by5fd2Vla2RheXNTaG9ydFJlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzU2hvcnRSZWdleDtcbiAgICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXNTaG9ydFJlZ2V4ICA9ICAgICAgICB3ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICBwcm90b3R5cGVfX3Byb3RvLl93ZWVrZGF5c01pblJlZ2V4ICAgPSBkZWZhdWx0V2Vla2RheXNNaW5SZWdleDtcbiAgICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXNNaW5SZWdleCAgICA9ICAgICAgICB3ZWVrZGF5c01pblJlZ2V4O1xuXG4gICAgICAvLyBIb3Vyc1xuICAgICAgcHJvdG90eXBlX19wcm90by5pc1BNID0gbG9jYWxlSXNQTTtcbiAgICAgIHByb3RvdHlwZV9fcHJvdG8uX21lcmlkaWVtUGFyc2UgPSBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZTtcbiAgICAgIHByb3RvdHlwZV9fcHJvdG8ubWVyaWRpZW0gPSBsb2NhbGVNZXJpZGllbTtcblxuICAgICAgZnVuY3Rpb24gbGlzdHNfX2dldCAoZm9ybWF0LCBpbmRleCwgZmllbGQsIHNldHRlcikge1xuICAgICAgICAgIHZhciBsb2NhbGUgPSBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKCk7XG4gICAgICAgICAgdmFyIHV0YyA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQygpLnNldChzZXR0ZXIsIGluZGV4KTtcbiAgICAgICAgICByZXR1cm4gbG9jYWxlW2ZpZWxkXSh1dGMsIGZvcm1hdCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGxpc3RNb250aHNJbXBsIChmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgZm9ybWF0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcblxuICAgICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBsaXN0c19fZ2V0KGZvcm1hdCwgaW5kZXgsIGZpZWxkLCAnbW9udGgnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgICAgb3V0W2ldID0gbGlzdHNfX2dldChmb3JtYXQsIGksIGZpZWxkLCAnbW9udGgnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgIH1cblxuICAgICAgLy8gKClcbiAgICAgIC8vICg1KVxuICAgICAgLy8gKGZtdCwgNSlcbiAgICAgIC8vIChmbXQpXG4gICAgICAvLyAodHJ1ZSlcbiAgICAgIC8vICh0cnVlLCA1KVxuICAgICAgLy8gKHRydWUsIGZtdCwgNSlcbiAgICAgIC8vICh0cnVlLCBmbXQpXG4gICAgICBmdW5jdGlvbiBsaXN0V2Vla2RheXNJbXBsIChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsIGZpZWxkKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBsb2NhbGVTb3J0ZWQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGZvcm1hdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZvcm1hdCA9IGxvY2FsZVNvcnRlZDtcbiAgICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICAgIGxvY2FsZVNvcnRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgZm9ybWF0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGxvY2FsZSA9IGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUoKSxcbiAgICAgICAgICAgICAgc2hpZnQgPSBsb2NhbGVTb3J0ZWQgPyBsb2NhbGUuX3dlZWsuZG93IDogMDtcblxuICAgICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBsaXN0c19fZ2V0KGZvcm1hdCwgKGluZGV4ICsgc2hpZnQpICUgNywgZmllbGQsICdkYXknKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgICBvdXRbaV0gPSBsaXN0c19fZ2V0KGZvcm1hdCwgKGkgKyBzaGlmdCkgJSA3LCBmaWVsZCwgJ2RheScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBsaXN0c19fbGlzdE1vbnRocyAoZm9ybWF0LCBpbmRleCkge1xuICAgICAgICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzJyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGxpc3RzX19saXN0TW9udGhzU2hvcnQgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gbGlzdE1vbnRoc0ltcGwoZm9ybWF0LCBpbmRleCwgJ21vbnRoc1Nob3J0Jyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGxpc3RzX19saXN0V2Vla2RheXMgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzJyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGxpc3RzX19saXN0V2Vla2RheXNTaG9ydCAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNTaG9ydCcpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBsaXN0c19fbGlzdFdlZWtkYXlzTWluIChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c01pbicpO1xuICAgICAgfVxuXG4gICAgICBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlKCdlbicsIHtcbiAgICAgICAgICBvcmRpbmFsUGFyc2U6IC9cXGR7MSwyfSh0aHxzdHxuZHxyZCkvLFxuICAgICAgICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICAgICAgICBvdXRwdXQgPSAodG9JbnQobnVtYmVyICUgMTAwIC8gMTApID09PSAxKSA/ICd0aCcgOlxuICAgICAgICAgICAgICAgICAgKGIgPT09IDEpID8gJ3N0JyA6XG4gICAgICAgICAgICAgICAgICAoYiA9PT0gMikgPyAnbmQnIDpcbiAgICAgICAgICAgICAgICAgIChiID09PSAzKSA/ICdyZCcgOiAndGgnO1xuICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG4gICAgICB1dGlsc19ob29rc19faG9va3MubGFuZyA9IGRlcHJlY2F0ZSgnbW9tZW50LmxhbmcgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGUgaW5zdGVhZC4nLCBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlKTtcbiAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5sYW5nRGF0YSA9IGRlcHJlY2F0ZSgnbW9tZW50LmxhbmdEYXRhIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlRGF0YSBpbnN0ZWFkLicsIGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUpO1xuXG4gICAgICB2YXIgbWF0aEFicyA9IE1hdGguYWJzO1xuXG4gICAgICBmdW5jdGlvbiBkdXJhdGlvbl9hYnNfX2FicyAoKSB7XG4gICAgICAgICAgdmFyIGRhdGEgICAgICAgICAgID0gdGhpcy5fZGF0YTtcblxuICAgICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9IG1hdGhBYnModGhpcy5fbWlsbGlzZWNvbmRzKTtcbiAgICAgICAgICB0aGlzLl9kYXlzICAgICAgICAgPSBtYXRoQWJzKHRoaXMuX2RheXMpO1xuICAgICAgICAgIHRoaXMuX21vbnRocyAgICAgICA9IG1hdGhBYnModGhpcy5fbW9udGhzKTtcblxuICAgICAgICAgIGRhdGEubWlsbGlzZWNvbmRzICA9IG1hdGhBYnMoZGF0YS5taWxsaXNlY29uZHMpO1xuICAgICAgICAgIGRhdGEuc2Vjb25kcyAgICAgICA9IG1hdGhBYnMoZGF0YS5zZWNvbmRzKTtcbiAgICAgICAgICBkYXRhLm1pbnV0ZXMgICAgICAgPSBtYXRoQWJzKGRhdGEubWludXRlcyk7XG4gICAgICAgICAgZGF0YS5ob3VycyAgICAgICAgID0gbWF0aEFicyhkYXRhLmhvdXJzKTtcbiAgICAgICAgICBkYXRhLm1vbnRocyAgICAgICAgPSBtYXRoQWJzKGRhdGEubW9udGhzKTtcbiAgICAgICAgICBkYXRhLnllYXJzICAgICAgICAgPSBtYXRoQWJzKGRhdGEueWVhcnMpO1xuXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QgKGR1cmF0aW9uLCBpbnB1dCwgdmFsdWUsIGRpcmVjdGlvbikge1xuICAgICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24oaW5wdXQsIHZhbHVlKTtcblxuICAgICAgICAgIGR1cmF0aW9uLl9taWxsaXNlY29uZHMgKz0gZGlyZWN0aW9uICogb3RoZXIuX21pbGxpc2Vjb25kcztcbiAgICAgICAgICBkdXJhdGlvbi5fZGF5cyAgICAgICAgICs9IGRpcmVjdGlvbiAqIG90aGVyLl9kYXlzO1xuICAgICAgICAgIGR1cmF0aW9uLl9tb250aHMgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX21vbnRocztcblxuICAgICAgICAgIHJldHVybiBkdXJhdGlvbi5fYnViYmxlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIGFkZCgxLCAncycpIG9yIGFkZChkdXJhdGlvbilcbiAgICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fYWRkIChpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19hZGRTdWJ0cmFjdCh0aGlzLCBpbnB1dCwgdmFsdWUsIDEpO1xuICAgICAgfVxuXG4gICAgICAvLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBzdWJ0cmFjdCgxLCAncycpIG9yIHN1YnRyYWN0KGR1cmF0aW9uKVxuICAgICAgZnVuY3Rpb24gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19zdWJ0cmFjdCAoaW5wdXQsIHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QodGhpcywgaW5wdXQsIHZhbHVlLCAtMSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGFic0NlaWwgKG51bWJlcikge1xuICAgICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYnViYmxlICgpIHtcbiAgICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzO1xuICAgICAgICAgIHZhciBkYXlzICAgICAgICAgPSB0aGlzLl9kYXlzO1xuICAgICAgICAgIHZhciBtb250aHMgICAgICAgPSB0aGlzLl9tb250aHM7XG4gICAgICAgICAgdmFyIGRhdGEgICAgICAgICA9IHRoaXMuX2RhdGE7XG4gICAgICAgICAgdmFyIHNlY29uZHMsIG1pbnV0ZXMsIGhvdXJzLCB5ZWFycywgbW9udGhzRnJvbURheXM7XG5cbiAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgbWl4IG9mIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB2YWx1ZXMsIGJ1YmJsZSBkb3duIGZpcnN0XG4gICAgICAgICAgLy8gY2hlY2s6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yMTY2XG4gICAgICAgICAgaWYgKCEoKG1pbGxpc2Vjb25kcyA+PSAwICYmIGRheXMgPj0gMCAmJiBtb250aHMgPj0gMCkgfHxcbiAgICAgICAgICAgICAgICAgIChtaWxsaXNlY29uZHMgPD0gMCAmJiBkYXlzIDw9IDAgJiYgbW9udGhzIDw9IDApKSkge1xuICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgKz0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzKSArIGRheXMpICogODY0ZTU7XG4gICAgICAgICAgICAgIGRheXMgPSAwO1xuICAgICAgICAgICAgICBtb250aHMgPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgY29kZSBidWJibGVzIHVwIHZhbHVlcywgc2VlIHRoZSB0ZXN0cyBmb3JcbiAgICAgICAgICAvLyBleGFtcGxlcyBvZiB3aGF0IHRoYXQgbWVhbnMuXG4gICAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHMgJSAxMDAwO1xuXG4gICAgICAgICAgc2Vjb25kcyAgICAgICAgICAgPSBhYnNGbG9vcihtaWxsaXNlY29uZHMgLyAxMDAwKTtcbiAgICAgICAgICBkYXRhLnNlY29uZHMgICAgICA9IHNlY29uZHMgJSA2MDtcblxuICAgICAgICAgIG1pbnV0ZXMgICAgICAgICAgID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgICBkYXRhLm1pbnV0ZXMgICAgICA9IG1pbnV0ZXMgJSA2MDtcblxuICAgICAgICAgIGhvdXJzICAgICAgICAgICAgID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICAgICAgICBkYXRhLmhvdXJzICAgICAgICA9IGhvdXJzICUgMjQ7XG5cbiAgICAgICAgICBkYXlzICs9IGFic0Zsb29yKGhvdXJzIC8gMjQpO1xuXG4gICAgICAgICAgLy8gY29udmVydCBkYXlzIHRvIG1vbnRoc1xuICAgICAgICAgIG1vbnRoc0Zyb21EYXlzID0gYWJzRmxvb3IoZGF5c1RvTW9udGhzKGRheXMpKTtcbiAgICAgICAgICBtb250aHMgKz0gbW9udGhzRnJvbURheXM7XG4gICAgICAgICAgZGF5cyAtPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHNGcm9tRGF5cykpO1xuXG4gICAgICAgICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgICAgICAgIHllYXJzID0gYWJzRmxvb3IobW9udGhzIC8gMTIpO1xuICAgICAgICAgIG1vbnRocyAlPSAxMjtcblxuICAgICAgICAgIGRhdGEuZGF5cyAgID0gZGF5cztcbiAgICAgICAgICBkYXRhLm1vbnRocyA9IG1vbnRocztcbiAgICAgICAgICBkYXRhLnllYXJzICA9IHllYXJzO1xuXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRheXNUb01vbnRocyAoZGF5cykge1xuICAgICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDE0NjA5NyBkYXlzICh0YWtpbmcgaW50byBhY2NvdW50IGxlYXAgeWVhciBydWxlcylcbiAgICAgICAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxMiBtb250aHMgPT09IDQ4MDBcbiAgICAgICAgICByZXR1cm4gZGF5cyAqIDQ4MDAgLyAxNDYwOTc7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG1vbnRoc1RvRGF5cyAobW9udGhzKSB7XG4gICAgICAgICAgLy8gdGhlIHJldmVyc2Ugb2YgZGF5c1RvTW9udGhzXG4gICAgICAgICAgcmV0dXJuIG1vbnRocyAqIDE0NjA5NyAvIDQ4MDA7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGFzICh1bml0cykge1xuICAgICAgICAgIHZhciBkYXlzO1xuICAgICAgICAgIHZhciBtb250aHM7XG4gICAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcblxuICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuXG4gICAgICAgICAgaWYgKHVuaXRzID09PSAnbW9udGgnIHx8IHVuaXRzID09PSAneWVhcicpIHtcbiAgICAgICAgICAgICAgZGF5cyAgID0gdGhpcy5fZGF5cyAgICsgbWlsbGlzZWNvbmRzIC8gODY0ZTU7XG4gICAgICAgICAgICAgIG1vbnRocyA9IHRoaXMuX21vbnRocyArIGRheXNUb01vbnRocyhkYXlzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHVuaXRzID09PSAnbW9udGgnID8gbW9udGhzIDogbW9udGhzIC8gMTI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gaGFuZGxlIG1pbGxpc2Vjb25kcyBzZXBhcmF0ZWx5IGJlY2F1c2Ugb2YgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgKGlzc3VlICMxODY3KVxuICAgICAgICAgICAgICBkYXlzID0gdGhpcy5fZGF5cyArIE1hdGgucm91bmQobW9udGhzVG9EYXlzKHRoaXMuX21vbnRocykpO1xuICAgICAgICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlICd3ZWVrJyAgIDogcmV0dXJuIGRheXMgLyA3ICAgICArIG1pbGxpc2Vjb25kcyAvIDYwNDhlNTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ2RheScgICAgOiByZXR1cm4gZGF5cyAgICAgICAgICsgbWlsbGlzZWNvbmRzIC8gODY0ZTU7XG4gICAgICAgICAgICAgICAgICBjYXNlICdob3VyJyAgIDogcmV0dXJuIGRheXMgKiAyNCAgICArIG1pbGxpc2Vjb25kcyAvIDM2ZTU7XG4gICAgICAgICAgICAgICAgICBjYXNlICdtaW51dGUnIDogcmV0dXJuIGRheXMgKiAxNDQwICArIG1pbGxpc2Vjb25kcyAvIDZlNDtcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ3NlY29uZCcgOiByZXR1cm4gZGF5cyAqIDg2NDAwICsgbWlsbGlzZWNvbmRzIC8gMTAwMDtcbiAgICAgICAgICAgICAgICAgIC8vIE1hdGguZmxvb3IgcHJldmVudHMgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgaGVyZVxuICAgICAgICAgICAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOiByZXR1cm4gTWF0aC5mbG9vcihkYXlzICogODY0ZTUpICsgbWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHVuaXQgJyArIHVuaXRzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVE9ETzogVXNlIHRoaXMuYXMoJ21zJyk/XG4gICAgICBmdW5jdGlvbiBkdXJhdGlvbl9hc19fdmFsdWVPZiAoKSB7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzICtcbiAgICAgICAgICAgICAgdGhpcy5fZGF5cyAqIDg2NGU1ICtcbiAgICAgICAgICAgICAgKHRoaXMuX21vbnRocyAlIDEyKSAqIDI1OTJlNiArXG4gICAgICAgICAgICAgIHRvSW50KHRoaXMuX21vbnRocyAvIDEyKSAqIDMxNTM2ZTZcbiAgICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBtYWtlQXMgKGFsaWFzKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXMoYWxpYXMpO1xuICAgICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciBhc01pbGxpc2Vjb25kcyA9IG1ha2VBcygnbXMnKTtcbiAgICAgIHZhciBhc1NlY29uZHMgICAgICA9IG1ha2VBcygncycpO1xuICAgICAgdmFyIGFzTWludXRlcyAgICAgID0gbWFrZUFzKCdtJyk7XG4gICAgICB2YXIgYXNIb3VycyAgICAgICAgPSBtYWtlQXMoJ2gnKTtcbiAgICAgIHZhciBhc0RheXMgICAgICAgICA9IG1ha2VBcygnZCcpO1xuICAgICAgdmFyIGFzV2Vla3MgICAgICAgID0gbWFrZUFzKCd3Jyk7XG4gICAgICB2YXIgYXNNb250aHMgICAgICAgPSBtYWtlQXMoJ00nKTtcbiAgICAgIHZhciBhc1llYXJzICAgICAgICA9IG1ha2VBcygneScpO1xuXG4gICAgICBmdW5jdGlvbiBkdXJhdGlvbl9nZXRfX2dldCAodW5pdHMpIHtcbiAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgICByZXR1cm4gdGhpc1t1bml0cyArICdzJ10oKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbWFrZUdldHRlcihuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFbbmFtZV07XG4gICAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IG1ha2VHZXR0ZXIoJ21pbGxpc2Vjb25kcycpO1xuICAgICAgdmFyIHNlY29uZHMgICAgICA9IG1ha2VHZXR0ZXIoJ3NlY29uZHMnKTtcbiAgICAgIHZhciBtaW51dGVzICAgICAgPSBtYWtlR2V0dGVyKCdtaW51dGVzJyk7XG4gICAgICB2YXIgaG91cnMgICAgICAgID0gbWFrZUdldHRlcignaG91cnMnKTtcbiAgICAgIHZhciBkYXlzICAgICAgICAgPSBtYWtlR2V0dGVyKCdkYXlzJyk7XG4gICAgICB2YXIgbW9udGhzICAgICAgID0gbWFrZUdldHRlcignbW9udGhzJyk7XG4gICAgICB2YXIgeWVhcnMgICAgICAgID0gbWFrZUdldHRlcigneWVhcnMnKTtcblxuICAgICAgZnVuY3Rpb24gd2Vla3MgKCkge1xuICAgICAgICAgIHJldHVybiBhYnNGbG9vcih0aGlzLmRheXMoKSAvIDcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xuICAgICAgdmFyIHRocmVzaG9sZHMgPSB7XG4gICAgICAgICAgczogNDUsICAvLyBzZWNvbmRzIHRvIG1pbnV0ZVxuICAgICAgICAgIG06IDQ1LCAgLy8gbWludXRlcyB0byBob3VyXG4gICAgICAgICAgaDogMjIsICAvLyBob3VycyB0byBkYXlcbiAgICAgICAgICBkOiAyNiwgIC8vIGRheXMgdG8gbW9udGhcbiAgICAgICAgICBNOiAxMSAgIC8vIG1vbnRocyB0byB5ZWFyXG4gICAgICB9O1xuXG4gICAgICAvLyBoZWxwZXIgZnVuY3Rpb24gZm9yIG1vbWVudC5mbi5mcm9tLCBtb21lbnQuZm4uZnJvbU5vdywgYW5kIG1vbWVudC5kdXJhdGlvbi5mbi5odW1hbml6ZVxuICAgICAgZnVuY3Rpb24gc3Vic3RpdHV0ZVRpbWVBZ28oc3RyaW5nLCBudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGlzRnV0dXJlLCBsb2NhbGUpIHtcbiAgICAgICAgICByZXR1cm4gbG9jYWxlLnJlbGF0aXZlVGltZShudW1iZXIgfHwgMSwgISF3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZHVyYXRpb25faHVtYW5pemVfX3JlbGF0aXZlVGltZSAocG9zTmVnRHVyYXRpb24sIHdpdGhvdXRTdWZmaXgsIGxvY2FsZSkge1xuICAgICAgICAgIHZhciBkdXJhdGlvbiA9IGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24ocG9zTmVnRHVyYXRpb24pLmFicygpO1xuICAgICAgICAgIHZhciBzZWNvbmRzICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdzJykpO1xuICAgICAgICAgIHZhciBtaW51dGVzICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdtJykpO1xuICAgICAgICAgIHZhciBob3VycyAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdoJykpO1xuICAgICAgICAgIHZhciBkYXlzICAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdkJykpO1xuICAgICAgICAgIHZhciBtb250aHMgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdNJykpO1xuICAgICAgICAgIHZhciB5ZWFycyAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCd5JykpO1xuXG4gICAgICAgICAgdmFyIGEgPSBzZWNvbmRzIDwgdGhyZXNob2xkcy5zICYmIFsncycsIHNlY29uZHNdICB8fFxuICAgICAgICAgICAgICAgICAgbWludXRlcyA8PSAxICAgICAgICAgICAmJiBbJ20nXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPCB0aHJlc2hvbGRzLm0gJiYgWydtbScsIG1pbnV0ZXNdIHx8XG4gICAgICAgICAgICAgICAgICBob3VycyAgIDw9IDEgICAgICAgICAgICYmIFsnaCddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgICAgaG91cnMgICA8IHRocmVzaG9sZHMuaCAmJiBbJ2hoJywgaG91cnNdICAgfHxcbiAgICAgICAgICAgICAgICAgIGRheXMgICAgPD0gMSAgICAgICAgICAgJiYgWydkJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgICBkYXlzICAgIDwgdGhyZXNob2xkcy5kICYmIFsnZGQnLCBkYXlzXSAgICB8fFxuICAgICAgICAgICAgICAgICAgbW9udGhzICA8PSAxICAgICAgICAgICAmJiBbJ00nXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICAgIG1vbnRocyAgPCB0aHJlc2hvbGRzLk0gJiYgWydNTScsIG1vbnRoc10gIHx8XG4gICAgICAgICAgICAgICAgICB5ZWFycyAgIDw9IDEgICAgICAgICAgICYmIFsneSddICAgICAgICAgICB8fCBbJ3l5JywgeWVhcnNdO1xuXG4gICAgICAgICAgYVsyXSA9IHdpdGhvdXRTdWZmaXg7XG4gICAgICAgICAgYVszXSA9ICtwb3NOZWdEdXJhdGlvbiA+IDA7XG4gICAgICAgICAgYVs0XSA9IGxvY2FsZTtcbiAgICAgICAgICByZXR1cm4gc3Vic3RpdHV0ZVRpbWVBZ28uYXBwbHkobnVsbCwgYSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgYSB0aHJlc2hvbGQgZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuICAgICAgZnVuY3Rpb24gZHVyYXRpb25faHVtYW5pemVfX2dldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZCAodGhyZXNob2xkLCBsaW1pdCkge1xuICAgICAgICAgIGlmICh0aHJlc2hvbGRzW3RocmVzaG9sZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsaW1pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aHJlc2hvbGRzW3RocmVzaG9sZF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocmVzaG9sZHNbdGhyZXNob2xkXSA9IGxpbWl0O1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBodW1hbml6ZSAod2l0aFN1ZmZpeCkge1xuICAgICAgICAgIHZhciBsb2NhbGUgPSB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgICB2YXIgb3V0cHV0ID0gZHVyYXRpb25faHVtYW5pemVfX3JlbGF0aXZlVGltZSh0aGlzLCAhd2l0aFN1ZmZpeCwgbG9jYWxlKTtcblxuICAgICAgICAgIGlmICh3aXRoU3VmZml4KSB7XG4gICAgICAgICAgICAgIG91dHB1dCA9IGxvY2FsZS5wYXN0RnV0dXJlKCt0aGlzLCBvdXRwdXQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBsb2NhbGUucG9zdGZvcm1hdChvdXRwdXQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNvX3N0cmluZ19fYWJzID0gTWF0aC5hYnM7XG5cbiAgICAgIGZ1bmN0aW9uIGlzb19zdHJpbmdfX3RvSVNPU3RyaW5nKCkge1xuICAgICAgICAgIC8vIGZvciBJU08gc3RyaW5ncyB3ZSBkbyBub3QgdXNlIHRoZSBub3JtYWwgYnViYmxpbmcgcnVsZXM6XG4gICAgICAgICAgLy8gICogbWlsbGlzZWNvbmRzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSBob3Vyc1xuICAgICAgICAgIC8vICAqIGRheXMgZG8gbm90IGJ1YmJsZSBhdCBhbGxcbiAgICAgICAgICAvLyAgKiBtb250aHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIHllYXJzXG4gICAgICAgICAgLy8gVGhpcyBpcyBiZWNhdXNlIHRoZXJlIGlzIG5vIGNvbnRleHQtZnJlZSBjb252ZXJzaW9uIGJldHdlZW4gaG91cnMgYW5kIGRheXNcbiAgICAgICAgICAvLyAodGhpbmsgb2YgY2xvY2sgY2hhbmdlcylcbiAgICAgICAgICAvLyBhbmQgYWxzbyBub3QgYmV0d2VlbiBkYXlzIGFuZCBtb250aHMgKDI4LTMxIGRheXMgcGVyIG1vbnRoKVxuICAgICAgICAgIHZhciBzZWNvbmRzID0gaXNvX3N0cmluZ19fYWJzKHRoaXMuX21pbGxpc2Vjb25kcykgLyAxMDAwO1xuICAgICAgICAgIHZhciBkYXlzICAgICAgICAgPSBpc29fc3RyaW5nX19hYnModGhpcy5fZGF5cyk7XG4gICAgICAgICAgdmFyIG1vbnRocyAgICAgICA9IGlzb19zdHJpbmdfX2Ficyh0aGlzLl9tb250aHMpO1xuICAgICAgICAgIHZhciBtaW51dGVzLCBob3VycywgeWVhcnM7XG5cbiAgICAgICAgICAvLyAzNjAwIHNlY29uZHMgLT4gNjAgbWludXRlcyAtPiAxIGhvdXJcbiAgICAgICAgICBtaW51dGVzICAgICAgICAgICA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgICAgICAgaG91cnMgICAgICAgICAgICAgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgICAgICAgIHNlY29uZHMgJT0gNjA7XG4gICAgICAgICAgbWludXRlcyAlPSA2MDtcblxuICAgICAgICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICAgICAgICB5ZWFycyAgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgICAgICAgbW9udGhzICU9IDEyO1xuXG5cbiAgICAgICAgICAvLyBpbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vZG9yZGlsbGUvbW9tZW50LWlzb2R1cmF0aW9uL2Jsb2IvbWFzdGVyL21vbWVudC5pc29kdXJhdGlvbi5qc1xuICAgICAgICAgIHZhciBZID0geWVhcnM7XG4gICAgICAgICAgdmFyIE0gPSBtb250aHM7XG4gICAgICAgICAgdmFyIEQgPSBkYXlzO1xuICAgICAgICAgIHZhciBoID0gaG91cnM7XG4gICAgICAgICAgdmFyIG0gPSBtaW51dGVzO1xuICAgICAgICAgIHZhciBzID0gc2Vjb25kcztcbiAgICAgICAgICB2YXIgdG90YWwgPSB0aGlzLmFzU2Vjb25kcygpO1xuXG4gICAgICAgICAgaWYgKCF0b3RhbCkge1xuICAgICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBzYW1lIGFzIEMjJ3MgKE5vZGEpIGFuZCBweXRob24gKGlzb2RhdGUpLi4uXG4gICAgICAgICAgICAgIC8vIGJ1dCBub3Qgb3RoZXIgSlMgKGdvb2cuZGF0ZSlcbiAgICAgICAgICAgICAgcmV0dXJuICdQMEQnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiAodG90YWwgPCAwID8gJy0nIDogJycpICtcbiAgICAgICAgICAgICAgJ1AnICtcbiAgICAgICAgICAgICAgKFkgPyBZICsgJ1knIDogJycpICtcbiAgICAgICAgICAgICAgKE0gPyBNICsgJ00nIDogJycpICtcbiAgICAgICAgICAgICAgKEQgPyBEICsgJ0QnIDogJycpICtcbiAgICAgICAgICAgICAgKChoIHx8IG0gfHwgcykgPyAnVCcgOiAnJykgK1xuICAgICAgICAgICAgICAoaCA/IGggKyAnSCcgOiAnJykgK1xuICAgICAgICAgICAgICAobSA/IG0gKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgICAocyA/IHMgKyAnUycgOiAnJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvID0gRHVyYXRpb24ucHJvdG90eXBlO1xuXG4gICAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFicyAgICAgICAgICAgID0gZHVyYXRpb25fYWJzX19hYnM7XG4gICAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFkZCAgICAgICAgICAgID0gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19hZGQ7XG4gICAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnN1YnRyYWN0ICAgICAgID0gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19zdWJ0cmFjdDtcbiAgICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXMgICAgICAgICAgICAgPSBhcztcbiAgICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNNaWxsaXNlY29uZHMgPSBhc01pbGxpc2Vjb25kcztcbiAgICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNTZWNvbmRzICAgICAgPSBhc1NlY29uZHM7XG4gICAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzTWludXRlcyAgICAgID0gYXNNaW51dGVzO1xuICAgICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc0hvdXJzICAgICAgICA9IGFzSG91cnM7XG4gICAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzRGF5cyAgICAgICAgID0gYXNEYXlzO1xuICAgICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc1dlZWtzICAgICAgICA9IGFzV2Vla3M7XG4gICAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzTW9udGhzICAgICAgID0gYXNNb250aHM7XG4gICAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzWWVhcnMgICAgICAgID0gYXNZZWFycztcbiAgICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8udmFsdWVPZiAgICAgICAgPSBkdXJhdGlvbl9hc19fdmFsdWVPZjtcbiAgICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uX2J1YmJsZSAgICAgICAgPSBidWJibGU7XG4gICAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmdldCAgICAgICAgICAgID0gZHVyYXRpb25fZ2V0X19nZXQ7XG4gICAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLm1pbGxpc2Vjb25kcyAgID0gbWlsbGlzZWNvbmRzO1xuICAgICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5zZWNvbmRzICAgICAgICA9IHNlY29uZHM7XG4gICAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLm1pbnV0ZXMgICAgICAgID0gbWludXRlcztcbiAgICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uaG91cnMgICAgICAgICAgPSBob3VycztcbiAgICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uZGF5cyAgICAgICAgICAgPSBkYXlzO1xuICAgICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by53ZWVrcyAgICAgICAgICA9IHdlZWtzO1xuICAgICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5tb250aHMgICAgICAgICA9IG1vbnRocztcbiAgICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ueWVhcnMgICAgICAgICAgPSB5ZWFycztcbiAgICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uaHVtYW5pemUgICAgICAgPSBodW1hbml6ZTtcbiAgICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8udG9JU09TdHJpbmcgICAgPSBpc29fc3RyaW5nX190b0lTT1N0cmluZztcbiAgICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8udG9TdHJpbmcgICAgICAgPSBpc29fc3RyaW5nX190b0lTT1N0cmluZztcbiAgICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8udG9KU09OICAgICAgICAgPSBpc29fc3RyaW5nX190b0lTT1N0cmluZztcbiAgICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubG9jYWxlICAgICAgICAgPSBsb2NhbGU7XG4gICAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmxvY2FsZURhdGEgICAgID0gbG9jYWxlRGF0YTtcblxuICAgICAgLy8gRGVwcmVjYXRpb25zXG4gICAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnRvSXNvU3RyaW5nID0gZGVwcmVjYXRlKCd0b0lzb1N0cmluZygpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdG9JU09TdHJpbmcoKSBpbnN0ZWFkIChub3RpY2UgdGhlIGNhcGl0YWxzKScsIGlzb19zdHJpbmdfX3RvSVNPU3RyaW5nKTtcbiAgICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubGFuZyA9IGxhbmc7XG5cbiAgICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuICAgICAgLy8gRk9STUFUVElOR1xuXG4gICAgICBhZGRGb3JtYXRUb2tlbignWCcsIDAsIDAsICd1bml4Jyk7XG4gICAgICBhZGRGb3JtYXRUb2tlbigneCcsIDAsIDAsICd2YWx1ZU9mJyk7XG5cbiAgICAgIC8vIFBBUlNJTkdcblxuICAgICAgYWRkUmVnZXhUb2tlbigneCcsIG1hdGNoU2lnbmVkKTtcbiAgICAgIGFkZFJlZ2V4VG9rZW4oJ1gnLCBtYXRjaFRpbWVzdGFtcCk7XG4gICAgICBhZGRQYXJzZVRva2VuKCdYJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUocGFyc2VGbG9hdChpbnB1dCwgMTApICogMTAwMCk7XG4gICAgICB9KTtcbiAgICAgIGFkZFBhcnNlVG9rZW4oJ3gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSh0b0ludChpbnB1dCkpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuXG4gICAgICB1dGlsc19ob29rc19faG9va3MudmVyc2lvbiA9ICcyLjEzLjAnO1xuXG4gICAgICBzZXRIb29rQ2FsbGJhY2sobG9jYWxfX2NyZWF0ZUxvY2FsKTtcblxuICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLmZuICAgICAgICAgICAgICAgICAgICA9IG1vbWVudFByb3RvdHlwZTtcbiAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5taW4gICAgICAgICAgICAgICAgICAgPSBtaW47XG4gICAgICB1dGlsc19ob29rc19faG9va3MubWF4ICAgICAgICAgICAgICAgICAgID0gbWF4O1xuICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLm5vdyAgICAgICAgICAgICAgICAgICA9IG5vdztcbiAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51dGMgICAgICAgICAgICAgICAgICAgPSBjcmVhdGVfdXRjX19jcmVhdGVVVEM7XG4gICAgICB1dGlsc19ob29rc19faG9va3MudW5peCAgICAgICAgICAgICAgICAgID0gbW9tZW50X19jcmVhdGVVbml4O1xuICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLm1vbnRocyAgICAgICAgICAgICAgICA9IGxpc3RzX19saXN0TW9udGhzO1xuICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLmlzRGF0ZSAgICAgICAgICAgICAgICA9IGlzRGF0ZTtcbiAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5sb2NhbGUgICAgICAgICAgICAgICAgPSBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlO1xuICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLmludmFsaWQgICAgICAgICAgICAgICA9IHZhbGlkX19jcmVhdGVJbnZhbGlkO1xuICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLmR1cmF0aW9uICAgICAgICAgICAgICA9IGNyZWF0ZV9fY3JlYXRlRHVyYXRpb247XG4gICAgICB1dGlsc19ob29rc19faG9va3MuaXNNb21lbnQgICAgICAgICAgICAgID0gaXNNb21lbnQ7XG4gICAgICB1dGlsc19ob29rc19faG9va3Mud2Vla2RheXMgICAgICAgICAgICAgID0gbGlzdHNfX2xpc3RXZWVrZGF5cztcbiAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5wYXJzZVpvbmUgICAgICAgICAgICAgPSBtb21lbnRfX2NyZWF0ZUluWm9uZTtcbiAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5sb2NhbGVEYXRhICAgICAgICAgICAgPSBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlO1xuICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLmlzRHVyYXRpb24gICAgICAgICAgICA9IGlzRHVyYXRpb247XG4gICAgICB1dGlsc19ob29rc19faG9va3MubW9udGhzU2hvcnQgICAgICAgICAgID0gbGlzdHNfX2xpc3RNb250aHNTaG9ydDtcbiAgICAgIHV0aWxzX2hvb2tzX19ob29rcy53ZWVrZGF5c01pbiAgICAgICAgICAgPSBsaXN0c19fbGlzdFdlZWtkYXlzTWluO1xuICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLmRlZmluZUxvY2FsZSAgICAgICAgICA9IGRlZmluZUxvY2FsZTtcbiAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVMb2NhbGUgICAgICAgICAgPSB1cGRhdGVMb2NhbGU7XG4gICAgICB1dGlsc19ob29rc19faG9va3MubG9jYWxlcyAgICAgICAgICAgICAgID0gbG9jYWxlX2xvY2FsZXNfX2xpc3RMb2NhbGVzO1xuICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLndlZWtkYXlzU2hvcnQgICAgICAgICA9IGxpc3RzX19saXN0V2Vla2RheXNTaG9ydDtcbiAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5ub3JtYWxpemVVbml0cyAgICAgICAgPSBub3JtYWxpemVVbml0cztcbiAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5yZWxhdGl2ZVRpbWVUaHJlc2hvbGQgPSBkdXJhdGlvbl9odW1hbml6ZV9fZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkO1xuICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnByb3RvdHlwZSAgICAgICAgICAgICA9IG1vbWVudFByb3RvdHlwZTtcblxuICAgICAgdmFyIF9tb21lbnQgPSB1dGlsc19ob29rc19faG9va3M7XG5cbiAgICAgIHJldHVybiBfbW9tZW50O1xuXG4gIH0pKTtcbiAgLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oNCkobW9kdWxlKSkpXG5cbi8qKiovIH0sXG4vKiA0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICBcdGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG4gIFx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcbiAgXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xuICBcdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG4gIFx0XHRtb2R1bGUuY2hpbGRyZW4gPSBbXTtcbiAgXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuICBcdH1cbiAgXHRyZXR1cm4gbW9kdWxlO1xuICB9XG5cblxuLyoqKi8gfSxcbi8qIDUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gIGZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0KHJlcSkge1xuICBcdHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIicuXCIpO1xuICB9XG4gIHdlYnBhY2tDb250ZXh0LmtleXMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIFtdOyB9O1xuICB3ZWJwYWNrQ29udGV4dC5yZXNvbHZlID0gd2VicGFja0NvbnRleHQ7XG4gIG1vZHVsZS5leHBvcnRzID0gd2VicGFja0NvbnRleHQ7XG4gIHdlYnBhY2tDb250ZXh0LmlkID0gNTtcblxuXG4vKioqLyB9LFxuLyogNiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgeyd1c2Ugc3RyaWN0JztcblxuICB2YXIgX3JuZztcblxuICB2YXIgZ2xvYmFsVmFyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IG51bGw7XG5cbiAgaWYgKGdsb2JhbFZhciAmJiBnbG9iYWxWYXIuY3J5cHRvICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAvLyBXSEFUV0cgY3J5cHRvLWJhc2VkIFJORyAtIGh0dHA6Ly93aWtpLndoYXR3Zy5vcmcvd2lraS9DcnlwdG9cbiAgICAvLyBNb2RlcmF0ZWx5IGZhc3QsIGhpZ2ggcXVhbGl0eVxuICAgIHZhciBfcm5kczggPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgX3JuZyA9IGZ1bmN0aW9uIHdoYXR3Z1JORygpIHtcbiAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoX3JuZHM4KTtcbiAgICAgIHJldHVybiBfcm5kczg7XG4gICAgfTtcbiAgfVxuXG4gIGlmICghX3JuZykge1xuICAgIC8vIE1hdGgucmFuZG9tKCktYmFzZWQgKFJORylcbiAgICAvL1xuICAgIC8vIElmIGFsbCBlbHNlIGZhaWxzLCB1c2UgTWF0aC5yYW5kb20oKS4gIEl0J3MgZmFzdCwgYnV0IGlzIG9mIHVuc3BlY2lmaWVkXG4gICAgLy8gcXVhbGl0eS5cbiAgICB2YXIgX3JuZHMgPSBuZXcgQXJyYXkoMTYpO1xuICAgIF9ybmcgPSBmdW5jdGlvbiBfcm5nKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIHI7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgIGlmICgoaSAmIDB4MDMpID09PSAwKSByID0gTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwO1xuICAgICAgICBfcm5kc1tpXSA9IHIgPj4+ICgoaSAmIDB4MDMpIDw8IDMpICYgMHhmZjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9ybmRzO1xuICAgIH07XG4gIH1cblxuICAvLyAgICAgdXVpZC5qc1xuICAvL1xuICAvLyAgICAgQ29weXJpZ2h0IChjKSAyMDEwLTIwMTIgUm9iZXJ0IEtpZWZmZXJcbiAgLy8gICAgIE1JVCBMaWNlbnNlIC0gaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXG4gIC8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuICBXZSBmZWF0dXJlXG4gIC8vIGRldGVjdCB0byBkZXRlcm1pbmUgdGhlIGJlc3QgUk5HIHNvdXJjZSwgbm9ybWFsaXppbmcgdG8gYSBmdW5jdGlvbiB0aGF0XG4gIC8vIHJldHVybnMgMTI4LWJpdHMgb2YgcmFuZG9tbmVzcywgc2luY2UgdGhhdCdzIHdoYXQncyB1c3VhbGx5IHJlcXVpcmVkXG5cbiAgLy92YXIgX3JuZyA9IHJlcXVpcmUoJy4vcm5nJyk7XG5cbiAgLy8gTWFwcyBmb3IgbnVtYmVyIDwtPiBoZXggc3RyaW5nIGNvbnZlcnNpb25cbiAgdmFyIF9ieXRlVG9IZXggPSBbXTtcbiAgdmFyIF9oZXhUb0J5dGUgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgIF9ieXRlVG9IZXhbaV0gPSAoaSArIDB4MTAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpO1xuICAgIF9oZXhUb0J5dGVbX2J5dGVUb0hleFtpXV0gPSBpO1xuICB9XG5cbiAgLy8gKipgcGFyc2UoKWAgLSBQYXJzZSBhIFVVSUQgaW50byBpdCdzIGNvbXBvbmVudCBieXRlcyoqXG4gIGZ1bmN0aW9uIHBhcnNlKHMsIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDAsXG4gICAgICAgIGlpID0gMDtcblxuICAgIGJ1ZiA9IGJ1ZiB8fCBbXTtcbiAgICBzLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvWzAtOWEtZl17Mn0vZywgZnVuY3Rpb24gKG9jdCkge1xuICAgICAgaWYgKGlpIDwgMTYpIHtcbiAgICAgICAgLy8gRG9uJ3Qgb3ZlcmZsb3chXG4gICAgICAgIGJ1ZltpICsgaWkrK10gPSBfaGV4VG9CeXRlW29jdF07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBaZXJvIG91dCByZW1haW5pbmcgYnl0ZXMgaWYgc3RyaW5nIHdhcyBzaG9ydFxuICAgIHdoaWxlIChpaSA8IDE2KSB7XG4gICAgICBidWZbaSArIGlpKytdID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmO1xuICB9XG5cbiAgLy8gKipgdW5wYXJzZSgpYCAtIENvbnZlcnQgVVVJRCBieXRlIGFycmF5IChhbGEgcGFyc2UoKSkgaW50byBhIHN0cmluZyoqXG4gIGZ1bmN0aW9uIHVucGFyc2UoYnVmLCBvZmZzZXQpIHtcbiAgICB2YXIgaSA9IG9mZnNldCB8fCAwLFxuICAgICAgICBidGggPSBfYnl0ZVRvSGV4O1xuICAgIHJldHVybiBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgJy0nICsgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgKyBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgJy0nICsgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dO1xuICB9XG5cbiAgLy8gKipgdjEoKWAgLSBHZW5lcmF0ZSB0aW1lLWJhc2VkIFVVSUQqKlxuICAvL1xuICAvLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vTGlvc0svVVVJRC5qc1xuICAvLyBhbmQgaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L3V1aWQuaHRtbFxuXG4gIC8vIHJhbmRvbSAjJ3Mgd2UgbmVlZCB0byBpbml0IG5vZGUgYW5kIGNsb2Nrc2VxXG4gIHZhciBfc2VlZEJ5dGVzID0gX3JuZygpO1xuXG4gIC8vIFBlciA0LjUsIGNyZWF0ZSBhbmQgNDgtYml0IG5vZGUgaWQsICg0NyByYW5kb20gYml0cyArIG11bHRpY2FzdCBiaXQgPSAxKVxuICB2YXIgX25vZGVJZCA9IFtfc2VlZEJ5dGVzWzBdIHwgMHgwMSwgX3NlZWRCeXRlc1sxXSwgX3NlZWRCeXRlc1syXSwgX3NlZWRCeXRlc1szXSwgX3NlZWRCeXRlc1s0XSwgX3NlZWRCeXRlc1s1XV07XG5cbiAgLy8gUGVyIDQuMi4yLCByYW5kb21pemUgKDE0IGJpdCkgY2xvY2tzZXFcbiAgdmFyIF9jbG9ja3NlcSA9IChfc2VlZEJ5dGVzWzZdIDw8IDggfCBfc2VlZEJ5dGVzWzddKSAmIDB4M2ZmZjtcblxuICAvLyBQcmV2aW91cyB1dWlkIGNyZWF0aW9uIHRpbWVcbiAgdmFyIF9sYXN0TVNlY3MgPSAwLFxuICAgICAgX2xhc3ROU2VjcyA9IDA7XG5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9icm9vZmEvbm9kZS11dWlkIGZvciBBUEkgZGV0YWlsc1xuICBmdW5jdGlvbiB2MShvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICAgIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuICAgIHZhciBiID0gYnVmIHx8IFtdO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXIgY2xvY2tzZXEgPSBvcHRpb25zLmNsb2Nrc2VxICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsb2Nrc2VxIDogX2Nsb2Nrc2VxO1xuXG4gICAgLy8gVVVJRCB0aW1lc3RhbXBzIGFyZSAxMDAgbmFuby1zZWNvbmQgdW5pdHMgc2luY2UgdGhlIEdyZWdvcmlhbiBlcG9jaCxcbiAgICAvLyAoMTU4Mi0xMC0xNSAwMDowMCkuICBKU051bWJlcnMgYXJlbid0IHByZWNpc2UgZW5vdWdoIGZvciB0aGlzLCBzb1xuICAgIC8vIHRpbWUgaXMgaGFuZGxlZCBpbnRlcm5hbGx5IGFzICdtc2VjcycgKGludGVnZXIgbWlsbGlzZWNvbmRzKSBhbmQgJ25zZWNzJ1xuICAgIC8vICgxMDAtbmFub3NlY29uZHMgb2Zmc2V0IGZyb20gbXNlY3MpIHNpbmNlIHVuaXggZXBvY2gsIDE5NzAtMDEtMDEgMDA6MDAuXG4gICAgdmFyIG1zZWNzID0gb3B0aW9ucy5tc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tc2VjcyA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgLy8gUGVyIDQuMi4xLjIsIHVzZSBjb3VudCBvZiB1dWlkJ3MgZ2VuZXJhdGVkIGR1cmluZyB0aGUgY3VycmVudCBjbG9ja1xuICAgIC8vIGN5Y2xlIHRvIHNpbXVsYXRlIGhpZ2hlciByZXNvbHV0aW9uIGNsb2NrXG4gICAgdmFyIG5zZWNzID0gb3B0aW9ucy5uc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uc2VjcyA6IF9sYXN0TlNlY3MgKyAxO1xuXG4gICAgLy8gVGltZSBzaW5jZSBsYXN0IHV1aWQgY3JlYXRpb24gKGluIG1zZWNzKVxuICAgIHZhciBkdCA9IG1zZWNzIC0gX2xhc3RNU2VjcyArIChuc2VjcyAtIF9sYXN0TlNlY3MpIC8gMTAwMDA7XG5cbiAgICAvLyBQZXIgNC4yLjEuMiwgQnVtcCBjbG9ja3NlcSBvbiBjbG9jayByZWdyZXNzaW9uXG4gICAgaWYgKGR0IDwgMCAmJiBvcHRpb25zLmNsb2Nrc2VxID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNsb2Nrc2VxID0gY2xvY2tzZXEgKyAxICYgMHgzZmZmO1xuICAgIH1cblxuICAgIC8vIFJlc2V0IG5zZWNzIGlmIGNsb2NrIHJlZ3Jlc3NlcyAobmV3IGNsb2Nrc2VxKSBvciB3ZSd2ZSBtb3ZlZCBvbnRvIGEgbmV3XG4gICAgLy8gdGltZSBpbnRlcnZhbFxuICAgIGlmICgoZHQgPCAwIHx8IG1zZWNzID4gX2xhc3RNU2VjcykgJiYgb3B0aW9ucy5uc2VjcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBuc2VjcyA9IDA7XG4gICAgfVxuXG4gICAgLy8gUGVyIDQuMi4xLjIgVGhyb3cgZXJyb3IgaWYgdG9vIG1hbnkgdXVpZHMgYXJlIHJlcXVlc3RlZFxuICAgIGlmIChuc2VjcyA+PSAxMDAwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1dWlkLnYxKCk6IENhblxcJ3QgY3JlYXRlIG1vcmUgdGhhbiAxME0gdXVpZHMvc2VjJyk7XG4gICAgfVxuXG4gICAgX2xhc3RNU2VjcyA9IG1zZWNzO1xuICAgIF9sYXN0TlNlY3MgPSBuc2VjcztcbiAgICBfY2xvY2tzZXEgPSBjbG9ja3NlcTtcblxuICAgIC8vIFBlciA0LjEuNCAtIENvbnZlcnQgZnJvbSB1bml4IGVwb2NoIHRvIEdyZWdvcmlhbiBlcG9jaFxuICAgIG1zZWNzICs9IDEyMjE5MjkyODAwMDAwO1xuXG4gICAgLy8gYHRpbWVfbG93YFxuICAgIHZhciB0bCA9ICgobXNlY3MgJiAweGZmZmZmZmYpICogMTAwMDAgKyBuc2VjcykgJSAweDEwMDAwMDAwMDtcbiAgICBiW2krK10gPSB0bCA+Pj4gMjQgJiAweGZmO1xuICAgIGJbaSsrXSA9IHRsID4+PiAxNiAmIDB4ZmY7XG4gICAgYltpKytdID0gdGwgPj4+IDggJiAweGZmO1xuICAgIGJbaSsrXSA9IHRsICYgMHhmZjtcblxuICAgIC8vIGB0aW1lX21pZGBcbiAgICB2YXIgdG1oID0gbXNlY3MgLyAweDEwMDAwMDAwMCAqIDEwMDAwICYgMHhmZmZmZmZmO1xuICAgIGJbaSsrXSA9IHRtaCA+Pj4gOCAmIDB4ZmY7XG4gICAgYltpKytdID0gdG1oICYgMHhmZjtcblxuICAgIC8vIGB0aW1lX2hpZ2hfYW5kX3ZlcnNpb25gXG4gICAgYltpKytdID0gdG1oID4+PiAyNCAmIDB4ZiB8IDB4MTA7IC8vIGluY2x1ZGUgdmVyc2lvblxuICAgIGJbaSsrXSA9IHRtaCA+Pj4gMTYgJiAweGZmO1xuXG4gICAgLy8gYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgIChQZXIgNC4yLjIgLSBpbmNsdWRlIHZhcmlhbnQpXG4gICAgYltpKytdID0gY2xvY2tzZXEgPj4+IDggfCAweDgwO1xuXG4gICAgLy8gYGNsb2NrX3NlcV9sb3dgXG4gICAgYltpKytdID0gY2xvY2tzZXEgJiAweGZmO1xuXG4gICAgLy8gYG5vZGVgXG4gICAgdmFyIG5vZGUgPSBvcHRpb25zLm5vZGUgfHwgX25vZGVJZDtcbiAgICBmb3IgKHZhciBuID0gMDsgbiA8IDY7IG4rKykge1xuICAgICAgYltpICsgbl0gPSBub2RlW25dO1xuICAgIH1cblxuICAgIHJldHVybiBidWYgPyBidWYgOiB1bnBhcnNlKGIpO1xuICB9XG5cbiAgLy8gKipgdjQoKWAgLSBHZW5lcmF0ZSByYW5kb20gVVVJRCoqXG5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9icm9vZmEvbm9kZS11dWlkIGZvciBBUEkgZGV0YWlsc1xuICBmdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICAgIC8vIERlcHJlY2F0ZWQgLSAnZm9ybWF0JyBhcmd1bWVudCwgYXMgc3VwcG9ydGVkIGluIHYxLjJcbiAgICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PSAnc3RyaW5nJykge1xuICAgICAgYnVmID0gb3B0aW9ucyA9PSAnYmluYXJ5JyA/IG5ldyBBcnJheSgxNikgOiBudWxsO1xuICAgICAgb3B0aW9ucyA9IG51bGw7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgX3JuZykoKTtcblxuICAgIC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcbiAgICBybmRzWzZdID0gcm5kc1s2XSAmIDB4MGYgfCAweDQwO1xuICAgIHJuZHNbOF0gPSBybmRzWzhdICYgMHgzZiB8IDB4ODA7XG5cbiAgICAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcbiAgICBpZiAoYnVmKSB7XG4gICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgMTY7IGlpKyspIHtcbiAgICAgICAgYnVmW2kgKyBpaV0gPSBybmRzW2lpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYnVmIHx8IHVucGFyc2Uocm5kcyk7XG4gIH1cblxuICAvLyBFeHBvcnQgcHVibGljIEFQSVxuICB2YXIgdXVpZCA9IHY0O1xuICB1dWlkLnYxID0gdjE7XG4gIHV1aWQudjQgPSB2NDtcbiAgdXVpZC5wYXJzZSA9IHBhcnNlO1xuICB1dWlkLnVucGFyc2UgPSB1bnBhcnNlO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gdXVpZDtcbiAgLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0oKSkpKVxuXG4vKioqLyB9LFxuLyogNyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIHV0aWxzXG4gIGV4cG9ydHMudXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4gIGV4cG9ydHMuRE9NdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cbiAgLy8gZGF0YVxuICBleHBvcnRzLkRhdGFTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuICBleHBvcnRzLkRhdGFWaWV3ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG4gIGV4cG9ydHMuUXVldWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblxuICAvLyBHcmFwaDNkXG4gIGV4cG9ydHMuR3JhcGgzZCA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuICBleHBvcnRzLmdyYXBoM2QgPSB7XG4gICAgQ2FtZXJhOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KSxcbiAgICBGaWx0ZXI6IF9fd2VicGFja19yZXF1aXJlX18oMTcpLFxuICAgIFBvaW50MmQ6IF9fd2VicGFja19yZXF1aXJlX18oMTUpLFxuICAgIFBvaW50M2Q6IF9fd2VicGFja19yZXF1aXJlX18oMTQpLFxuICAgIFNsaWRlcjogX193ZWJwYWNrX3JlcXVpcmVfXygxOCksXG4gICAgU3RlcE51bWJlcjogX193ZWJwYWNrX3JlcXVpcmVfXygxOSlcbiAgfTtcblxuICAvLyBidW5kbGVkIGV4dGVybmFsIGxpYnJhcmllc1xuICBleHBvcnRzLm1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4gIGV4cG9ydHMuSGFtbWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG4gIGV4cG9ydHMua2V5Y2hhcm0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcblxuLyoqKi8gfSxcbi8qIDggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBET00gdXRpbGl0eSBtZXRob2RzXG5cbiAgLyoqXG4gICAqIHRoaXMgcHJlcGFyZXMgdGhlIEpTT04gY29udGFpbmVyIGZvciBhbGxvY2F0aW5nIFNWRyBlbGVtZW50c1xuICAgKiBAcGFyYW0gSlNPTmNvbnRhaW5lclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZXhwb3J0cy5wcmVwYXJlRWxlbWVudHMgPSBmdW5jdGlvbiAoSlNPTmNvbnRhaW5lcikge1xuICAgIC8vIGNsZWFudXAgdGhlIHJlZHVuZGFudCBzdmdFbGVtZW50cztcbiAgICBmb3IgKHZhciBlbGVtZW50VHlwZSBpbiBKU09OY29udGFpbmVyKSB7XG4gICAgICBpZiAoSlNPTmNvbnRhaW5lci5oYXNPd25Qcm9wZXJ0eShlbGVtZW50VHlwZSkpIHtcbiAgICAgICAgSlNPTmNvbnRhaW5lcltlbGVtZW50VHlwZV0ucmVkdW5kYW50ID0gSlNPTmNvbnRhaW5lcltlbGVtZW50VHlwZV0udXNlZDtcbiAgICAgICAgSlNPTmNvbnRhaW5lcltlbGVtZW50VHlwZV0udXNlZCA9IFtdO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogdGhpcyBjbGVhbnMgdXAgYWxsIHRoZSB1bnVzZWQgU1ZHIGVsZW1lbnRzLiBCeSBhc2tpbmcgZm9yIHRoZSBwYXJlbnROb2RlLCB3ZSBvbmx5IG5lZWQgdG8gc3VwcGx5IHRoZSBKU09OIGNvbnRhaW5lciBmcm9tXG4gICAqIHdoaWNoIHRvIHJlbW92ZSB0aGUgcmVkdW5kYW50IGVsZW1lbnRzLlxuICAgKlxuICAgKiBAcGFyYW0gSlNPTmNvbnRhaW5lclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZXhwb3J0cy5jbGVhbnVwRWxlbWVudHMgPSBmdW5jdGlvbiAoSlNPTmNvbnRhaW5lcikge1xuICAgIC8vIGNsZWFudXAgdGhlIHJlZHVuZGFudCBzdmdFbGVtZW50cztcbiAgICBmb3IgKHZhciBlbGVtZW50VHlwZSBpbiBKU09OY29udGFpbmVyKSB7XG4gICAgICBpZiAoSlNPTmNvbnRhaW5lci5oYXNPd25Qcm9wZXJ0eShlbGVtZW50VHlwZSkpIHtcbiAgICAgICAgaWYgKEpTT05jb250YWluZXJbZWxlbWVudFR5cGVdLnJlZHVuZGFudCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgSlNPTmNvbnRhaW5lcltlbGVtZW50VHlwZV0ucmVkdW5kYW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBKU09OY29udGFpbmVyW2VsZW1lbnRUeXBlXS5yZWR1bmRhbnRbaV0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChKU09OY29udGFpbmVyW2VsZW1lbnRUeXBlXS5yZWR1bmRhbnRbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBKU09OY29udGFpbmVyW2VsZW1lbnRUeXBlXS5yZWR1bmRhbnQgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRW5zdXJlcyB0aGF0IGFsbCBlbGVtZW50cyBhcmUgcmVtb3ZlZCBmaXJzdCB1cCBzbyB0aGV5IGNhbiBiZSByZWNyZWF0ZWQgY2xlYW5seVxuICAgKiBAcGFyYW0gSlNPTmNvbnRhaW5lclxuICAgKi9cbiAgZXhwb3J0cy5yZXNldEVsZW1lbnRzID0gZnVuY3Rpb24gKEpTT05jb250YWluZXIpIHtcbiAgICBleHBvcnRzLnByZXBhcmVFbGVtZW50cyhKU09OY29udGFpbmVyKTtcbiAgICBleHBvcnRzLmNsZWFudXBFbGVtZW50cyhKU09OY29udGFpbmVyKTtcbiAgICBleHBvcnRzLnByZXBhcmVFbGVtZW50cyhKU09OY29udGFpbmVyKTtcbiAgfTtcblxuICAvKipcbiAgICogQWxsb2NhdGUgb3IgZ2VuZXJhdGUgYW4gU1ZHIGVsZW1lbnQgaWYgbmVlZGVkLiBTdG9yZSBhIHJlZmVyZW5jZSB0byBpdCBpbiB0aGUgSlNPTiBjb250YWluZXIgYW5kIGRyYXcgaXQgaW4gdGhlIHN2Z0NvbnRhaW5lclxuICAgKiB0aGUgSlNPTiBjb250YWluZXIgYW5kIHRoZSBTVkcgY29udGFpbmVyIGhhdmUgdG8gYmUgc3VwcGxpZWQgc28gb3RoZXIgc3ZnIGNvbnRhaW5lcnMgKGxpa2UgdGhlIGxlZ2VuZCkgY2FuIHVzZSB0aGlzLlxuICAgKlxuICAgKiBAcGFyYW0gZWxlbWVudFR5cGVcbiAgICogQHBhcmFtIEpTT05jb250YWluZXJcbiAgICogQHBhcmFtIHN2Z0NvbnRhaW5lclxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGV4cG9ydHMuZ2V0U1ZHRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50VHlwZSwgSlNPTmNvbnRhaW5lciwgc3ZnQ29udGFpbmVyKSB7XG4gICAgdmFyIGVsZW1lbnQ7XG4gICAgLy8gYWxsb2NhdGUgU1ZHIGVsZW1lbnQsIGlmIGl0IGRvZXNudCB5ZXQgZXhpc3QsIGNyZWF0ZSBvbmUuXG4gICAgaWYgKEpTT05jb250YWluZXIuaGFzT3duUHJvcGVydHkoZWxlbWVudFR5cGUpKSB7XG4gICAgICAvLyB0aGlzIGVsZW1lbnQgaGFzIGJlZW4gY3JlYXRlZCBiZWZvcmVcbiAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGlzIGFuIHJlZHVuZGFudCBlbGVtZW50XG4gICAgICBpZiAoSlNPTmNvbnRhaW5lcltlbGVtZW50VHlwZV0ucmVkdW5kYW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgZWxlbWVudCA9IEpTT05jb250YWluZXJbZWxlbWVudFR5cGVdLnJlZHVuZGFudFswXTtcbiAgICAgICAgSlNPTmNvbnRhaW5lcltlbGVtZW50VHlwZV0ucmVkdW5kYW50LnNoaWZ0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjcmVhdGUgYSBuZXcgZWxlbWVudCBhbmQgYWRkIGl0IHRvIHRoZSBTVkdcbiAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCBlbGVtZW50VHlwZSk7XG4gICAgICAgIHN2Z0NvbnRhaW5lci5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY3JlYXRlIGEgbmV3IGVsZW1lbnQgYW5kIGFkZCBpdCB0byB0aGUgU1ZHLCBhbHNvIGNyZWF0ZSBhIG5ldyBvYmplY3QgaW4gdGhlIHN2Z0VsZW1lbnRzIHRvIGtlZXAgdHJhY2sgb2YgaXQuXG4gICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIGVsZW1lbnRUeXBlKTtcbiAgICAgIEpTT05jb250YWluZXJbZWxlbWVudFR5cGVdID0geyB1c2VkOiBbXSwgcmVkdW5kYW50OiBbXSB9O1xuICAgICAgc3ZnQ29udGFpbmVyLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgIH1cbiAgICBKU09OY29udGFpbmVyW2VsZW1lbnRUeXBlXS51c2VkLnB1c2goZWxlbWVudCk7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFsbG9jYXRlIG9yIGdlbmVyYXRlIGFuIFNWRyBlbGVtZW50IGlmIG5lZWRlZC4gU3RvcmUgYSByZWZlcmVuY2UgdG8gaXQgaW4gdGhlIEpTT04gY29udGFpbmVyIGFuZCBkcmF3IGl0IGluIHRoZSBzdmdDb250YWluZXJcbiAgICogdGhlIEpTT04gY29udGFpbmVyIGFuZCB0aGUgU1ZHIGNvbnRhaW5lciBoYXZlIHRvIGJlIHN1cHBsaWVkIHNvIG90aGVyIHN2ZyBjb250YWluZXJzIChsaWtlIHRoZSBsZWdlbmQpIGNhbiB1c2UgdGhpcy5cbiAgICpcbiAgICogQHBhcmFtIGVsZW1lbnRUeXBlXG4gICAqIEBwYXJhbSBKU09OY29udGFpbmVyXG4gICAqIEBwYXJhbSBET01Db250YWluZXJcbiAgICogQHJldHVybnMgeyp9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBleHBvcnRzLmdldERPTUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudFR5cGUsIEpTT05jb250YWluZXIsIERPTUNvbnRhaW5lciwgaW5zZXJ0QmVmb3JlKSB7XG4gICAgdmFyIGVsZW1lbnQ7XG4gICAgLy8gYWxsb2NhdGUgRE9NIGVsZW1lbnQsIGlmIGl0IGRvZXNudCB5ZXQgZXhpc3QsIGNyZWF0ZSBvbmUuXG4gICAgaWYgKEpTT05jb250YWluZXIuaGFzT3duUHJvcGVydHkoZWxlbWVudFR5cGUpKSB7XG4gICAgICAvLyB0aGlzIGVsZW1lbnQgaGFzIGJlZW4gY3JlYXRlZCBiZWZvcmVcbiAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGlzIGFuIHJlZHVuZGFudCBlbGVtZW50XG4gICAgICBpZiAoSlNPTmNvbnRhaW5lcltlbGVtZW50VHlwZV0ucmVkdW5kYW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgZWxlbWVudCA9IEpTT05jb250YWluZXJbZWxlbWVudFR5cGVdLnJlZHVuZGFudFswXTtcbiAgICAgICAgSlNPTmNvbnRhaW5lcltlbGVtZW50VHlwZV0ucmVkdW5kYW50LnNoaWZ0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjcmVhdGUgYSBuZXcgZWxlbWVudCBhbmQgYWRkIGl0IHRvIHRoZSBTVkdcbiAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZWxlbWVudFR5cGUpO1xuICAgICAgICBpZiAoaW5zZXJ0QmVmb3JlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBET01Db250YWluZXIuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsIGluc2VydEJlZm9yZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgRE9NQ29udGFpbmVyLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNyZWF0ZSBhIG5ldyBlbGVtZW50IGFuZCBhZGQgaXQgdG8gdGhlIFNWRywgYWxzbyBjcmVhdGUgYSBuZXcgb2JqZWN0IGluIHRoZSBzdmdFbGVtZW50cyB0byBrZWVwIHRyYWNrIG9mIGl0LlxuICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZWxlbWVudFR5cGUpO1xuICAgICAgSlNPTmNvbnRhaW5lcltlbGVtZW50VHlwZV0gPSB7IHVzZWQ6IFtdLCByZWR1bmRhbnQ6IFtdIH07XG4gICAgICBpZiAoaW5zZXJ0QmVmb3JlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgRE9NQ29udGFpbmVyLmluc2VydEJlZm9yZShlbGVtZW50LCBpbnNlcnRCZWZvcmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgRE9NQ29udGFpbmVyLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICBKU09OY29udGFpbmVyW2VsZW1lbnRUeXBlXS51c2VkLnB1c2goZWxlbWVudCk7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIERyYXcgYSBwb2ludCBvYmplY3QuIFRoaXMgaXMgYSBzZXBhcmF0ZSBmdW5jdGlvbiBiZWNhdXNlIGl0IGNhbiBhbHNvIGJlIGNhbGxlZCBieSB0aGUgbGVnZW5kLlxuICAgKiBUaGUgcmVhc29uIHRoZSBKU09OY29udGFpbmVyIGFuZCB0aGUgdGFyZ2V0IFNWRyBzdmdDb250YWluZXIgaGF2ZSB0byBiZSBzdXBwbGllZCBpcyBzbyB0aGUgbGVnZW5kIGNhbiB1c2UgdGhlc2UgZnVuY3Rpb25zXG4gICAqIGFzIHdlbGwuXG4gICAqXG4gICAqIEBwYXJhbSB4XG4gICAqIEBwYXJhbSB5XG4gICAqIEBwYXJhbSBncm91cFRlbXBsYXRlOiBBIHRlbXBsYXRlIGNvbnRhaW5pbmcgdGhlIG5lY2Vzc2FyeSBpbmZvcm1hdGlvbiB0byBkcmF3IHRoZSBkYXRhcG9pbnQgZS5nLiwge3N0eWxlOiAnY2lyY2xlJywgc2l6ZTogNSwgY2xhc3NOYW1lOiAnY2xhc3NOYW1lJyB9XG4gICAqIEBwYXJhbSBKU09OY29udGFpbmVyXG4gICAqIEBwYXJhbSBzdmdDb250YWluZXJcbiAgICogQHBhcmFtIGxhYmVsT2JqXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgZXhwb3J0cy5kcmF3UG9pbnQgPSBmdW5jdGlvbiAoeCwgeSwgZ3JvdXBUZW1wbGF0ZSwgSlNPTmNvbnRhaW5lciwgc3ZnQ29udGFpbmVyLCBsYWJlbE9iaikge1xuICAgIHZhciBwb2ludDtcbiAgICBpZiAoZ3JvdXBUZW1wbGF0ZS5zdHlsZSA9PSAnY2lyY2xlJykge1xuICAgICAgcG9pbnQgPSBleHBvcnRzLmdldFNWR0VsZW1lbnQoJ2NpcmNsZScsIEpTT05jb250YWluZXIsIHN2Z0NvbnRhaW5lcik7XG4gICAgICBwb2ludC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImN4XCIsIHgpO1xuICAgICAgcG9pbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJjeVwiLCB5KTtcbiAgICAgIHBvaW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiclwiLCAwLjUgKiBncm91cFRlbXBsYXRlLnNpemUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludCA9IGV4cG9ydHMuZ2V0U1ZHRWxlbWVudCgncmVjdCcsIEpTT05jb250YWluZXIsIHN2Z0NvbnRhaW5lcik7XG4gICAgICBwb2ludC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInhcIiwgeCAtIDAuNSAqIGdyb3VwVGVtcGxhdGUuc2l6ZSk7XG4gICAgICBwb2ludC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgeSAtIDAuNSAqIGdyb3VwVGVtcGxhdGUuc2l6ZSk7XG4gICAgICBwb2ludC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIndpZHRoXCIsIGdyb3VwVGVtcGxhdGUuc2l6ZSk7XG4gICAgICBwb2ludC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImhlaWdodFwiLCBncm91cFRlbXBsYXRlLnNpemUpO1xuICAgIH1cblxuICAgIGlmIChncm91cFRlbXBsYXRlLnN0eWxlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwb2ludC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInN0eWxlXCIsIGdyb3VwVGVtcGxhdGUuc3R5bGVzKTtcbiAgICB9XG4gICAgcG9pbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJjbGFzc1wiLCBncm91cFRlbXBsYXRlLmNsYXNzTmFtZSArIFwiIHZpcy1wb2ludFwiKTtcbiAgICAvL2hhbmRsZSBsYWJlbFxuXG4gICAgaWYgKGxhYmVsT2JqKSB7XG4gICAgICB2YXIgbGFiZWwgPSBleHBvcnRzLmdldFNWR0VsZW1lbnQoJ3RleHQnLCBKU09OY29udGFpbmVyLCBzdmdDb250YWluZXIpO1xuICAgICAgaWYgKGxhYmVsT2JqLnhPZmZzZXQpIHtcbiAgICAgICAgeCA9IHggKyBsYWJlbE9iai54T2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICBpZiAobGFiZWxPYmoueU9mZnNldCkge1xuICAgICAgICB5ID0geSArIGxhYmVsT2JqLnlPZmZzZXQ7XG4gICAgICB9XG4gICAgICBpZiAobGFiZWxPYmouY29udGVudCkge1xuICAgICAgICBsYWJlbC50ZXh0Q29udGVudCA9IGxhYmVsT2JqLmNvbnRlbnQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChsYWJlbE9iai5jbGFzc05hbWUpIHtcbiAgICAgICAgbGFiZWwuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJjbGFzc1wiLCBsYWJlbE9iai5jbGFzc05hbWUgKyBcIiB2aXMtbGFiZWxcIik7XG4gICAgICB9XG4gICAgICBsYWJlbC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInhcIiwgeCk7XG4gICAgICBsYWJlbC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgeSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvaW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBkcmF3IGEgYmFyIFNWRyBlbGVtZW50IGNlbnRlcmVkIG9uIHRoZSBYIGNvb3JkaW5hdGVcbiAgICpcbiAgICogQHBhcmFtIHhcbiAgICogQHBhcmFtIHlcbiAgICogQHBhcmFtIGNsYXNzTmFtZVxuICAgKi9cbiAgZXhwb3J0cy5kcmF3QmFyID0gZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQsIGNsYXNzTmFtZSwgSlNPTmNvbnRhaW5lciwgc3ZnQ29udGFpbmVyLCBzdHlsZSkge1xuICAgIGlmIChoZWlnaHQgIT0gMCkge1xuICAgICAgaWYgKGhlaWdodCA8IDApIHtcbiAgICAgICAgaGVpZ2h0ICo9IC0xO1xuICAgICAgICB5IC09IGhlaWdodDtcbiAgICAgIH1cbiAgICAgIHZhciByZWN0ID0gZXhwb3J0cy5nZXRTVkdFbGVtZW50KCdyZWN0JywgSlNPTmNvbnRhaW5lciwgc3ZnQ29udGFpbmVyKTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ4XCIsIHggLSAwLjUgKiB3aWR0aCk7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCB5KTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ3aWR0aFwiLCB3aWR0aCk7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiaGVpZ2h0XCIsIGhlaWdodCk7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiY2xhc3NcIiwgY2xhc3NOYW1lKTtcbiAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwic3R5bGVcIiwgc3R5bGUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuLyoqKi8gfSxcbi8qIDkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4gIHZhciBRdWV1ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXG4gIC8qKlxuICAgKiBEYXRhU2V0XG4gICAqXG4gICAqIFVzYWdlOlxuICAgKiAgICAgdmFyIGRhdGFTZXQgPSBuZXcgRGF0YVNldCh7XG4gICAqICAgICAgICAgZmllbGRJZDogJ19pZCcsXG4gICAqICAgICAgICAgdHlwZToge1xuICAgKiAgICAgICAgICAgICAvLyAuLi5cbiAgICogICAgICAgICB9XG4gICAqICAgICB9KTtcbiAgICpcbiAgICogICAgIGRhdGFTZXQuYWRkKGl0ZW0pO1xuICAgKiAgICAgZGF0YVNldC5hZGQoZGF0YSk7XG4gICAqICAgICBkYXRhU2V0LnVwZGF0ZShpdGVtKTtcbiAgICogICAgIGRhdGFTZXQudXBkYXRlKGRhdGEpO1xuICAgKiAgICAgZGF0YVNldC5yZW1vdmUoaWQpO1xuICAgKiAgICAgZGF0YVNldC5yZW1vdmUoaWRzKTtcbiAgICogICAgIHZhciBkYXRhID0gZGF0YVNldC5nZXQoKTtcbiAgICogICAgIHZhciBkYXRhID0gZGF0YVNldC5nZXQoaWQpO1xuICAgKiAgICAgdmFyIGRhdGEgPSBkYXRhU2V0LmdldChpZHMpO1xuICAgKiAgICAgdmFyIGRhdGEgPSBkYXRhU2V0LmdldChpZHMsIG9wdGlvbnMsIGRhdGEpO1xuICAgKiAgICAgZGF0YVNldC5jbGVhcigpO1xuICAgKlxuICAgKiBBIGRhdGEgc2V0IGNhbjpcbiAgICogLSBhZGQvcmVtb3ZlL3VwZGF0ZSBkYXRhXG4gICAqIC0gZ2l2ZXMgdHJpZ2dlcnMgdXBvbiBjaGFuZ2VzIGluIHRoZSBkYXRhXG4gICAqIC0gY2FuICBpbXBvcnQvZXhwb3J0IGRhdGEgaW4gdmFyaW91cyBkYXRhIGZvcm1hdHNcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gW2RhdGFdICAgIE9wdGlvbmFsIGFycmF5IHdpdGggaW5pdGlhbCBkYXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICBBdmFpbGFibGUgb3B0aW9uczpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmd9IGZpZWxkSWQgRmllbGQgbmFtZSBvZiB0aGUgaWQgaW4gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zLCAnaWQnIGJ5IGRlZmF1bHQuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0LjxTdHJpbmcsIFN0cmluZ30gdHlwZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBIG1hcCB3aXRoIGZpZWxkIG5hbWVzIGFzIGtleSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIHRoZSBmaWVsZCB0eXBlIGFzIHZhbHVlLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAge09iamVjdH0gcXVldWUgICBRdWV1ZSBjaGFuZ2VzIHRvIHRoZSBEYXRhU2V0LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbHVzaCB0aGVtIGFsbCBhdCBvbmNlLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBRdWV1ZSBvcHRpb25zOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHtudW1iZXJ9IGRlbGF5ICBEZWxheSBpbiBtcywgbnVsbCBieSBkZWZhdWx0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0ge251bWJlcn0gbWF4ICAgIE1heGltdW0gbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhlIHF1ZXVlLCBJbmZpbml0eSBieSBkZWZhdWx0XG4gICAqIEBjb25zdHJ1Y3RvciBEYXRhU2V0XG4gICAqL1xuICAvLyBUT0RPOiBhZGQgYSBEYXRhU2V0IGNvbnN0cnVjdG9yIERhdGFTZXQoZGF0YSwgb3B0aW9ucylcbiAgZnVuY3Rpb24gRGF0YVNldChkYXRhLCBvcHRpb25zKSB7XG4gICAgLy8gY29ycmVjdGx5IHJlYWQgb3B0aW9uYWwgYXJndW1lbnRzXG4gICAgaWYgKGRhdGEgJiYgIUFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIG9wdGlvbnMgPSBkYXRhO1xuICAgICAgZGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5fZGF0YSA9IHt9OyAvLyBtYXAgd2l0aCBkYXRhIGluZGV4ZWQgYnkgaWRcbiAgICB0aGlzLmxlbmd0aCA9IDA7IC8vIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgRGF0YVNldFxuICAgIHRoaXMuX2ZpZWxkSWQgPSB0aGlzLl9vcHRpb25zLmZpZWxkSWQgfHwgJ2lkJzsgLy8gbmFtZSBvZiB0aGUgZmllbGQgY29udGFpbmluZyBpZFxuICAgIHRoaXMuX3R5cGUgPSB7fTsgLy8gaW50ZXJuYWwgZmllbGQgdHlwZXMgKE5PVEU6IHRoaXMgY2FuIGRpZmZlciBmcm9tIHRoaXMuX29wdGlvbnMudHlwZSlcblxuICAgIC8vIGFsbCB2YXJpYW50cyBvZiBhIERhdGUgYXJlIGludGVybmFsbHkgc3RvcmVkIGFzIERhdGUsIHNvIHdlIGNhbiBjb252ZXJ0XG4gICAgLy8gZnJvbSBldmVyeXRoaW5nIHRvIGV2ZXJ5dGhpbmcgKGFsc28gZnJvbSBJU09EYXRlIHRvIE51bWJlciBmb3IgZXhhbXBsZSlcbiAgICBpZiAodGhpcy5fb3B0aW9ucy50eXBlKSB7XG4gICAgICB2YXIgZmllbGRzID0gT2JqZWN0LmtleXModGhpcy5fb3B0aW9ucy50eXBlKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBmaWVsZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGZpZWxkID0gZmllbGRzW2ldO1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9vcHRpb25zLnR5cGVbZmllbGRdO1xuICAgICAgICBpZiAodmFsdWUgPT0gJ0RhdGUnIHx8IHZhbHVlID09ICdJU09EYXRlJyB8fCB2YWx1ZSA9PSAnQVNQRGF0ZScpIHtcbiAgICAgICAgICB0aGlzLl90eXBlW2ZpZWxkXSA9ICdEYXRlJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl90eXBlW2ZpZWxkXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuMS4xIChvciAyLjAuMD8pXG4gICAgaWYgKHRoaXMuX29wdGlvbnMuY29udmVydCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb24gXCJjb252ZXJ0XCIgaXMgZGVwcmVjYXRlZC4gVXNlIFwidHlwZVwiIGluc3RlYWQuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fc3Vic2NyaWJlcnMgPSB7fTsgLy8gZXZlbnQgc3Vic2NyaWJlcnNcblxuICAgIC8vIGFkZCBpbml0aWFsIGRhdGEgd2hlbiBwcm92aWRlZFxuICAgIGlmIChkYXRhKSB7XG4gICAgICB0aGlzLmFkZChkYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgIEF2YWlsYWJsZSBvcHRpb25zOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAge09iamVjdH0gcXVldWUgICBRdWV1ZSBjaGFuZ2VzIHRvIHRoZSBEYXRhU2V0LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbHVzaCB0aGVtIGFsbCBhdCBvbmNlLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBRdWV1ZSBvcHRpb25zOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHtudW1iZXJ9IGRlbGF5ICBEZWxheSBpbiBtcywgbnVsbCBieSBkZWZhdWx0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0ge251bWJlcn0gbWF4ICAgIE1heGltdW0gbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhlIHF1ZXVlLCBJbmZpbml0eSBieSBkZWZhdWx0XG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqL1xuICBEYXRhU2V0LnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnF1ZXVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChvcHRpb25zLnF1ZXVlID09PSBmYWxzZSkge1xuICAgICAgICAvLyBkZWxldGUgcXVldWUgaWYgbG9hZGVkXG4gICAgICAgIGlmICh0aGlzLl9xdWV1ZSkge1xuICAgICAgICAgIHRoaXMuX3F1ZXVlLmRlc3Ryb3koKTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fcXVldWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNyZWF0ZSBxdWV1ZSBhbmQgdXBkYXRlIGl0cyBvcHRpb25zXG4gICAgICAgIGlmICghdGhpcy5fcXVldWUpIHtcbiAgICAgICAgICB0aGlzLl9xdWV1ZSA9IFF1ZXVlLmV4dGVuZCh0aGlzLCB7XG4gICAgICAgICAgICByZXBsYWNlOiBbJ2FkZCcsICd1cGRhdGUnLCAncmVtb3ZlJ11cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfdHlwZW9mKG9wdGlvbnMucXVldWUpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHRoaXMuX3F1ZXVlLnNldE9wdGlvbnMob3B0aW9ucy5xdWV1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFN1YnNjcmliZSB0byBhbiBldmVudCwgYWRkIGFuIGV2ZW50IGxpc3RlbmVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCAgICAgICAgRXZlbnQgbmFtZS4gQXZhaWxhYmxlIGV2ZW50czogJ3B1dCcsICd1cGRhdGUnLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdyZW1vdmUnXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrICAgQ2FsbGJhY2sgbWV0aG9kLiBDYWxsZWQgd2l0aCB0aHJlZSBwYXJhbWV0ZXJzOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nfSBldmVudFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0IHwgbnVsbH0gcGFyYW1zXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmcgfCBOdW1iZXJ9IHNlbmRlcklkXG4gICAqL1xuICBEYXRhU2V0LnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudCwgY2FsbGJhY2spIHtcbiAgICB2YXIgc3Vic2NyaWJlcnMgPSB0aGlzLl9zdWJzY3JpYmVyc1tldmVudF07XG4gICAgaWYgKCFzdWJzY3JpYmVycykge1xuICAgICAgc3Vic2NyaWJlcnMgPSBbXTtcbiAgICAgIHRoaXMuX3N1YnNjcmliZXJzW2V2ZW50XSA9IHN1YnNjcmliZXJzO1xuICAgIH1cblxuICAgIHN1YnNjcmliZXJzLnB1c2goe1xuICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gICAgfSk7XG4gIH07XG5cbiAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgZGVwcmVjYXRlZCBmdW5jdGlvbiBzb21lIGRheSAocmVwbGFjZWQgd2l0aCBgb25gIHNpbmNlIHZlcnNpb24gMC41LCBkZXByZWNhdGVkIHNpbmNlIHY0LjApXG4gIERhdGFTZXQucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGFTZXQuc3Vic2NyaWJlIGlzIGRlcHJlY2F0ZWQuIFVzZSBEYXRhU2V0Lm9uIGluc3RlYWQuJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlIGZyb20gYW4gZXZlbnQsIHJlbW92ZSBhbiBldmVudCBsaXN0ZW5lclxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIERhdGFTZXQucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIChldmVudCwgY2FsbGJhY2spIHtcbiAgICB2YXIgc3Vic2NyaWJlcnMgPSB0aGlzLl9zdWJzY3JpYmVyc1tldmVudF07XG4gICAgaWYgKHN1YnNjcmliZXJzKSB7XG4gICAgICB0aGlzLl9zdWJzY3JpYmVyc1tldmVudF0gPSBzdWJzY3JpYmVycy5maWx0ZXIoZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBsaXN0ZW5lci5jYWxsYmFjayAhPSBjYWxsYmFjaztcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBUT0RPOiByZW1vdmUgdGhpcyBkZXByZWNhdGVkIGZ1bmN0aW9uIHNvbWUgZGF5IChyZXBsYWNlZCB3aXRoIGBvbmAgc2luY2UgdmVyc2lvbiAwLjUsIGRlcHJlY2F0ZWQgc2luY2UgdjQuMClcbiAgRGF0YVNldC5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhU2V0LnVuc3Vic2NyaWJlIGlzIGRlcHJlY2F0ZWQuIFVzZSBEYXRhU2V0Lm9mZiBpbnN0ZWFkLicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIGFuIGV2ZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdCB8IG51bGx9IHBhcmFtc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW3NlbmRlcklkXSAgICAgICBPcHRpb25hbCBpZCBvZiB0aGUgc2VuZGVyLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgRGF0YVNldC5wcm90b3R5cGUuX3RyaWdnZXIgPSBmdW5jdGlvbiAoZXZlbnQsIHBhcmFtcywgc2VuZGVySWQpIHtcbiAgICBpZiAoZXZlbnQgPT0gJyonKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB0cmlnZ2VyIGV2ZW50IConKTtcbiAgICB9XG5cbiAgICB2YXIgc3Vic2NyaWJlcnMgPSBbXTtcbiAgICBpZiAoZXZlbnQgaW4gdGhpcy5fc3Vic2NyaWJlcnMpIHtcbiAgICAgIHN1YnNjcmliZXJzID0gc3Vic2NyaWJlcnMuY29uY2F0KHRoaXMuX3N1YnNjcmliZXJzW2V2ZW50XSk7XG4gICAgfVxuICAgIGlmICgnKicgaW4gdGhpcy5fc3Vic2NyaWJlcnMpIHtcbiAgICAgIHN1YnNjcmliZXJzID0gc3Vic2NyaWJlcnMuY29uY2F0KHRoaXMuX3N1YnNjcmliZXJzWycqJ10pO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdWJzY3JpYmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIHN1YnNjcmliZXIgPSBzdWJzY3JpYmVyc1tpXTtcbiAgICAgIGlmIChzdWJzY3JpYmVyLmNhbGxiYWNrKSB7XG4gICAgICAgIHN1YnNjcmliZXIuY2FsbGJhY2soZXZlbnQsIHBhcmFtcywgc2VuZGVySWQgfHwgbnVsbCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgZGF0YS5cbiAgICogQWRkaW5nIGFuIGl0ZW0gd2lsbCBmYWlsIHdoZW4gdGhlcmUgYWxyZWFkeSBpcyBhbiBpdGVtIHdpdGggdGhlIHNhbWUgaWQuXG4gICAqIEBwYXJhbSB7T2JqZWN0IHwgQXJyYXl9IGRhdGFcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtzZW5kZXJJZF0gT3B0aW9uYWwgc2VuZGVyIGlkXG4gICAqIEByZXR1cm4ge0FycmF5fSBhZGRlZElkcyAgICAgIEFycmF5IHdpdGggdGhlIGlkcyBvZiB0aGUgYWRkZWQgaXRlbXNcbiAgICovXG4gIERhdGFTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChkYXRhLCBzZW5kZXJJZCkge1xuICAgIHZhciBhZGRlZElkcyA9IFtdLFxuICAgICAgICBpZCxcbiAgICAgICAgbWUgPSB0aGlzO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIC8vIEFycmF5XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZCA9IG1lLl9hZGRJdGVtKGRhdGFbaV0pO1xuICAgICAgICBhZGRlZElkcy5wdXNoKGlkKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgIC8vIFNpbmdsZSBpdGVtXG4gICAgICBpZCA9IG1lLl9hZGRJdGVtKGRhdGEpO1xuICAgICAgYWRkZWRJZHMucHVzaChpZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBkYXRhVHlwZScpO1xuICAgIH1cblxuICAgIGlmIChhZGRlZElkcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3RyaWdnZXIoJ2FkZCcsIHsgaXRlbXM6IGFkZGVkSWRzIH0sIHNlbmRlcklkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWRkZWRJZHM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBleGlzdGluZyBpdGVtcy4gV2hlbiBhbiBpdGVtIGRvZXMgbm90IGV4aXN0LCBpdCB3aWxsIGJlIGNyZWF0ZWRcbiAgICogQHBhcmFtIHtPYmplY3QgfCBBcnJheX0gZGF0YVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3NlbmRlcklkXSBPcHRpb25hbCBzZW5kZXIgaWRcbiAgICogQHJldHVybiB7QXJyYXl9IHVwZGF0ZWRJZHMgICAgIFRoZSBpZHMgb2YgdGhlIGFkZGVkIG9yIHVwZGF0ZWQgaXRlbXNcbiAgICovXG4gIERhdGFTZXQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBzZW5kZXJJZCkge1xuICAgIHZhciBhZGRlZElkcyA9IFtdO1xuICAgIHZhciB1cGRhdGVkSWRzID0gW107XG4gICAgdmFyIG9sZERhdGEgPSBbXTtcbiAgICB2YXIgdXBkYXRlZERhdGEgPSBbXTtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciBmaWVsZElkID0gbWUuX2ZpZWxkSWQ7XG5cbiAgICB2YXIgYWRkT3JVcGRhdGUgPSBmdW5jdGlvbiBhZGRPclVwZGF0ZShpdGVtKSB7XG4gICAgICB2YXIgaWQgPSBpdGVtW2ZpZWxkSWRdO1xuICAgICAgaWYgKG1lLl9kYXRhW2lkXSkge1xuICAgICAgICB2YXIgb2xkSXRlbSA9IHV0aWwuZXh0ZW5kKHt9LCBtZS5fZGF0YVtpZF0pO1xuICAgICAgICAvLyB1cGRhdGUgaXRlbVxuICAgICAgICBpZCA9IG1lLl91cGRhdGVJdGVtKGl0ZW0pO1xuICAgICAgICB1cGRhdGVkSWRzLnB1c2goaWQpO1xuICAgICAgICB1cGRhdGVkRGF0YS5wdXNoKGl0ZW0pO1xuICAgICAgICBvbGREYXRhLnB1c2gob2xkSXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBhZGQgbmV3IGl0ZW1cbiAgICAgICAgaWQgPSBtZS5fYWRkSXRlbShpdGVtKTtcbiAgICAgICAgYWRkZWRJZHMucHVzaChpZCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAvLyBBcnJheVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGRhdGFbaV0gaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICBhZGRPclVwZGF0ZShkYXRhW2ldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ0lnbm9yaW5nIGlucHV0IGl0ZW0sIHdoaWNoIGlzIG5vdCBhbiBvYmplY3QgYXQgaW5kZXggJyArIGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAvLyBTaW5nbGUgaXRlbVxuICAgICAgYWRkT3JVcGRhdGUoZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBkYXRhVHlwZScpO1xuICAgIH1cblxuICAgIGlmIChhZGRlZElkcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3RyaWdnZXIoJ2FkZCcsIHsgaXRlbXM6IGFkZGVkSWRzIH0sIHNlbmRlcklkKTtcbiAgICB9XG4gICAgaWYgKHVwZGF0ZWRJZHMubGVuZ3RoKSB7XG4gICAgICB2YXIgcHJvcHMgPSB7IGl0ZW1zOiB1cGRhdGVkSWRzLCBvbGREYXRhOiBvbGREYXRhLCBkYXRhOiB1cGRhdGVkRGF0YSB9O1xuICAgICAgLy8gVE9ETzogcmVtb3ZlIGRlcHJlY2F0ZWQgcHJvcGVydHkgJ2RhdGEnIHNvbWUgZGF5XG4gICAgICAvL09iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2RhdGEnLCB7XG4gICAgICAvLyAgJ2dldCc6IChmdW5jdGlvbigpIHtcbiAgICAgIC8vICAgIGNvbnNvbGUud2FybignUHJvcGVydHkgZGF0YSBpcyBkZXByZWNhdGVkLiBVc2UgRGF0YVNldC5nZXQoaWRzKSB0byByZXRyaWV2ZSB0aGUgbmV3IGRhdGEsIHVzZSB0aGUgb2xkRGF0YSBwcm9wZXJ0eSBvbiB0aGlzIG9iamVjdCB0byBnZXQgdGhlIG9sZCBkYXRhJyk7XG4gICAgICAvLyAgICByZXR1cm4gdXBkYXRlZERhdGE7XG4gICAgICAvLyAgfSkuYmluZCh0aGlzKVxuICAgICAgLy99KTtcbiAgICAgIHRoaXMuX3RyaWdnZXIoJ3VwZGF0ZScsIHByb3BzLCBzZW5kZXJJZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkZGVkSWRzLmNvbmNhdCh1cGRhdGVkSWRzKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGEgZGF0YSBpdGVtIG9yIG11bHRpcGxlIGl0ZW1zLlxuICAgKlxuICAgKiBVc2FnZTpcbiAgICpcbiAgICogICAgIGdldCgpXG4gICAqICAgICBnZXQob3B0aW9uczogT2JqZWN0KVxuICAgKlxuICAgKiAgICAgZ2V0KGlkOiBOdW1iZXIgfCBTdHJpbmcpXG4gICAqICAgICBnZXQoaWQ6IE51bWJlciB8IFN0cmluZywgb3B0aW9uczogT2JqZWN0KVxuICAgKlxuICAgKiAgICAgZ2V0KGlkczogTnVtYmVyW10gfCBTdHJpbmdbXSlcbiAgICogICAgIGdldChpZHM6IE51bWJlcltdIHwgU3RyaW5nW10sIG9wdGlvbnM6IE9iamVjdClcbiAgICpcbiAgICogV2hlcmU6XG4gICAqXG4gICAqIHtOdW1iZXIgfCBTdHJpbmd9IGlkICAgICAgICAgVGhlIGlkIG9mIGFuIGl0ZW1cbiAgICoge051bWJlcltdIHwgU3RyaW5ne319IGlkcyAgICBBbiBhcnJheSB3aXRoIGlkcyBvZiBpdGVtc1xuICAgKiB7T2JqZWN0fSBvcHRpb25zICAgICAgICAgICAgIEFuIE9iamVjdCB3aXRoIG9wdGlvbnMuIEF2YWlsYWJsZSBvcHRpb25zOlxuICAgKiB7U3RyaW5nfSBbcmV0dXJuVHlwZV0gICAgICAgIFR5cGUgb2YgZGF0YSB0byBiZSByZXR1cm5lZC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDYW4gYmUgJ0FycmF5JyAoZGVmYXVsdCkgb3IgJ09iamVjdCcuXG4gICAqIHtPYmplY3QuPFN0cmluZywgU3RyaW5nPn0gW3R5cGVdXG4gICAqIHtTdHJpbmdbXX0gW2ZpZWxkc10gICAgICAgICAgZmllbGQgbmFtZXMgdG8gYmUgcmV0dXJuZWRcbiAgICoge2Z1bmN0aW9ufSBbZmlsdGVyXSAgICAgICAgICBmaWx0ZXIgaXRlbXNcbiAgICoge1N0cmluZyB8IGZ1bmN0aW9ufSBbb3JkZXJdICBPcmRlciB0aGUgaXRlbXMgYnkgYSBmaWVsZCBuYW1lIG9yIGN1c3RvbSBzb3J0IGZ1bmN0aW9uLlxuICAgKiBAdGhyb3dzIEVycm9yXG4gICAqL1xuICBEYXRhU2V0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHZhciBtZSA9IHRoaXM7XG5cbiAgICAvLyBwYXJzZSB0aGUgYXJndW1lbnRzXG4gICAgdmFyIGlkLCBpZHMsIG9wdGlvbnM7XG4gICAgdmFyIGZpcnN0VHlwZSA9IHV0aWwuZ2V0VHlwZShhcmd1bWVudHNbMF0pO1xuICAgIGlmIChmaXJzdFR5cGUgPT0gJ1N0cmluZycgfHwgZmlyc3RUeXBlID09ICdOdW1iZXInKSB7XG4gICAgICAvLyBnZXQoaWQgWywgb3B0aW9uc10pXG4gICAgICBpZCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIG9wdGlvbnMgPSBhcmd1bWVudHNbMV07XG4gICAgfSBlbHNlIGlmIChmaXJzdFR5cGUgPT0gJ0FycmF5Jykge1xuICAgICAgLy8gZ2V0KGlkcyBbLCBvcHRpb25zXSlcbiAgICAgIGlkcyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIG9wdGlvbnMgPSBhcmd1bWVudHNbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGdldChbLCBvcHRpb25zXSlcbiAgICAgIG9wdGlvbnMgPSBhcmd1bWVudHNbMF07XG4gICAgfVxuXG4gICAgLy8gZGV0ZXJtaW5lIHRoZSByZXR1cm4gdHlwZVxuICAgIHZhciByZXR1cm5UeXBlO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmV0dXJuVHlwZSkge1xuICAgICAgdmFyIGFsbG93ZWRWYWx1ZXMgPSBbJ0FycmF5JywgJ09iamVjdCddO1xuICAgICAgcmV0dXJuVHlwZSA9IGFsbG93ZWRWYWx1ZXMuaW5kZXhPZihvcHRpb25zLnJldHVyblR5cGUpID09IC0xID8gJ0FycmF5JyA6IG9wdGlvbnMucmV0dXJuVHlwZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuVHlwZSA9ICdBcnJheSc7XG4gICAgfVxuXG4gICAgLy8gYnVpbGQgb3B0aW9uc1xuICAgIHZhciB0eXBlID0gb3B0aW9ucyAmJiBvcHRpb25zLnR5cGUgfHwgdGhpcy5fb3B0aW9ucy50eXBlO1xuICAgIHZhciBmaWx0ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMuZmlsdGVyO1xuICAgIHZhciBpdGVtcyA9IFtdLFxuICAgICAgICBpdGVtLFxuICAgICAgICBpdGVtSWRzLFxuICAgICAgICBpdGVtSWQsXG4gICAgICAgIGksXG4gICAgICAgIGxlbjtcblxuICAgIC8vIGNvbnZlcnQgaXRlbXNcbiAgICBpZiAoaWQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyByZXR1cm4gYSBzaW5nbGUgaXRlbVxuICAgICAgaXRlbSA9IG1lLl9nZXRJdGVtKGlkLCB0eXBlKTtcbiAgICAgIGlmIChpdGVtICYmIGZpbHRlciAmJiAhZmlsdGVyKGl0ZW0pKSB7XG4gICAgICAgIGl0ZW0gPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaWRzICE9IHVuZGVmaW5lZCkge1xuICAgICAgLy8gcmV0dXJuIGEgc3Vic2V0IG9mIGl0ZW1zXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IG1lLl9nZXRJdGVtKGlkc1tpXSwgdHlwZSk7XG4gICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlcihpdGVtKSkge1xuICAgICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmV0dXJuIGFsbCBpdGVtc1xuICAgICAgaXRlbUlkcyA9IE9iamVjdC5rZXlzKHRoaXMuX2RhdGEpO1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gaXRlbUlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpdGVtSWQgPSBpdGVtSWRzW2ldO1xuICAgICAgICBpdGVtID0gbWUuX2dldEl0ZW0oaXRlbUlkLCB0eXBlKTtcbiAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGl0ZW0pKSB7XG4gICAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG9yZGVyIHRoZSByZXN1bHRzXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5vcmRlciAmJiBpZCA9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3NvcnQoaXRlbXMsIG9wdGlvbnMub3JkZXIpO1xuICAgIH1cblxuICAgIC8vIGZpbHRlciBmaWVsZHMgb2YgdGhlIGl0ZW1zXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5maWVsZHMpIHtcbiAgICAgIHZhciBmaWVsZHMgPSBvcHRpb25zLmZpZWxkcztcbiAgICAgIGlmIChpZCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaXRlbSA9IHRoaXMuX2ZpbHRlckZpZWxkcyhpdGVtLCBmaWVsZHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpdGVtc1tpXSA9IHRoaXMuX2ZpbHRlckZpZWxkcyhpdGVtc1tpXSwgZmllbGRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJldHVybiB0aGUgcmVzdWx0c1xuICAgIGlmIChyZXR1cm5UeXBlID09ICdPYmplY3QnKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge30sXG4gICAgICAgICAgcmVzdWx0YW50O1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcmVzdWx0YW50ID0gaXRlbXNbaV07XG4gICAgICAgIHJlc3VsdFtyZXN1bHRhbnQuaWRdID0gcmVzdWx0YW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlkICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBhIHNpbmdsZSBpdGVtXG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8ganVzdCByZXR1cm4gb3VyIGFycmF5XG4gICAgICAgIHJldHVybiBpdGVtcztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBpZHMgb2YgYWxsIGl0ZW1zIG9yIGZyb20gYSBmaWx0ZXJlZCBzZXQgb2YgaXRlbXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgQW4gT2JqZWN0IHdpdGggb3B0aW9ucy4gQXZhaWxhYmxlIG9wdGlvbnM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2Z1bmN0aW9ufSBbZmlsdGVyXSBmaWx0ZXIgaXRlbXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nIHwgZnVuY3Rpb259IFtvcmRlcl0gT3JkZXIgdGhlIGl0ZW1zIGJ5XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgZmllbGQgbmFtZSBvciBjdXN0b20gc29ydCBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7QXJyYXl9IGlkc1xuICAgKi9cbiAgRGF0YVNldC5wcm90b3R5cGUuZ2V0SWRzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGEsXG4gICAgICAgIGZpbHRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5maWx0ZXIsXG4gICAgICAgIG9yZGVyID0gb3B0aW9ucyAmJiBvcHRpb25zLm9yZGVyLFxuICAgICAgICB0eXBlID0gb3B0aW9ucyAmJiBvcHRpb25zLnR5cGUgfHwgdGhpcy5fb3B0aW9ucy50eXBlLFxuICAgICAgICBpdGVtSWRzID0gT2JqZWN0LmtleXMoZGF0YSksXG4gICAgICAgIGksXG4gICAgICAgIGxlbixcbiAgICAgICAgaWQsXG4gICAgICAgIGl0ZW0sXG4gICAgICAgIGl0ZW1zLFxuICAgICAgICBpZHMgPSBbXTtcblxuICAgIGlmIChmaWx0ZXIpIHtcbiAgICAgIC8vIGdldCBmaWx0ZXJlZCBpdGVtc1xuICAgICAgaWYgKG9yZGVyKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBvcmRlcmVkIGxpc3RcbiAgICAgICAgaXRlbXMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gaXRlbUlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlkID0gaXRlbUlkc1tpXTtcbiAgICAgICAgICBpdGVtID0gdGhpcy5fZ2V0SXRlbShpZCwgdHlwZSk7XG4gICAgICAgICAgaWYgKGZpbHRlcihpdGVtKSkge1xuICAgICAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zb3J0KGl0ZW1zLCBvcmRlcik7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZHMucHVzaChpdGVtc1tpXVt0aGlzLl9maWVsZElkXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNyZWF0ZSB1bm9yZGVyZWQgbGlzdFxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtSWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWQgPSBpdGVtSWRzW2ldO1xuICAgICAgICAgIGl0ZW0gPSB0aGlzLl9nZXRJdGVtKGlkLCB0eXBlKTtcbiAgICAgICAgICBpZiAoZmlsdGVyKGl0ZW0pKSB7XG4gICAgICAgICAgICBpZHMucHVzaChpdGVtW3RoaXMuX2ZpZWxkSWRdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZ2V0IGFsbCBpdGVtc1xuICAgICAgaWYgKG9yZGVyKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBhbiBvcmRlcmVkIGxpc3RcbiAgICAgICAgaXRlbXMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gaXRlbUlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlkID0gaXRlbUlkc1tpXTtcbiAgICAgICAgICBpdGVtcy5wdXNoKGRhdGFbaWRdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NvcnQoaXRlbXMsIG9yZGVyKTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlkcy5wdXNoKGl0ZW1zW2ldW3RoaXMuX2ZpZWxkSWRdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY3JlYXRlIHVub3JkZXJlZCBsaXN0XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1JZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZCA9IGl0ZW1JZHNbaV07XG4gICAgICAgICAgaXRlbSA9IGRhdGFbaWRdO1xuICAgICAgICAgIGlkcy5wdXNoKGl0ZW1bdGhpcy5fZmllbGRJZF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGlkcztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgRGF0YVNldCBpdHNlbGYuIElzIG92ZXJ3cml0dGVuIGZvciBleGFtcGxlIGJ5IHRoZSBEYXRhVmlldyxcbiAgICogd2hpY2ggcmV0dXJucyB0aGUgRGF0YVNldCBpdCBpcyBjb25uZWN0ZWQgdG8gaW5zdGVhZC5cbiAgICovXG4gIERhdGFTZXQucHJvdG90eXBlLmdldERhdGFTZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgZXZlcnkgaXRlbSBpbiB0aGUgZGF0YXNldC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICBBdmFpbGFibGUgb3B0aW9uczpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0LjxTdHJpbmcsIFN0cmluZz59IFt0eXBlXVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmdbXX0gW2ZpZWxkc10gZmlsdGVyIGZpZWxkc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtmdW5jdGlvbn0gW2ZpbHRlcl0gZmlsdGVyIGl0ZW1zXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZyB8IGZ1bmN0aW9ufSBbb3JkZXJdIE9yZGVyIHRoZSBpdGVtcyBieVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIGZpZWxkIG5hbWUgb3IgY3VzdG9tIHNvcnQgZnVuY3Rpb24uXG4gICAqL1xuICBEYXRhU2V0LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgdmFyIGZpbHRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5maWx0ZXIsXG4gICAgICAgIHR5cGUgPSBvcHRpb25zICYmIG9wdGlvbnMudHlwZSB8fCB0aGlzLl9vcHRpb25zLnR5cGUsXG4gICAgICAgIGRhdGEgPSB0aGlzLl9kYXRhLFxuICAgICAgICBpdGVtSWRzID0gT2JqZWN0LmtleXMoZGF0YSksXG4gICAgICAgIGksXG4gICAgICAgIGxlbixcbiAgICAgICAgaXRlbSxcbiAgICAgICAgaWQ7XG5cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm9yZGVyKSB7XG4gICAgICAvLyBleGVjdXRlIGZvckVhY2ggb24gb3JkZXJlZCBsaXN0XG4gICAgICB2YXIgaXRlbXMgPSB0aGlzLmdldChvcHRpb25zKTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICBpZCA9IGl0ZW1bdGhpcy5fZmllbGRJZF07XG4gICAgICAgIGNhbGxiYWNrKGl0ZW0sIGlkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdW5vcmRlcmVkXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtSWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlkID0gaXRlbUlkc1tpXTtcbiAgICAgICAgaXRlbSA9IHRoaXMuX2dldEl0ZW0oaWQsIHR5cGUpO1xuICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoaXRlbSkpIHtcbiAgICAgICAgICBjYWxsYmFjayhpdGVtLCBpZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIE1hcCBldmVyeSBpdGVtIGluIHRoZSBkYXRhc2V0LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgIEF2YWlsYWJsZSBvcHRpb25zOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtPYmplY3QuPFN0cmluZywgU3RyaW5nPn0gW3R5cGVdXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZ1tdfSBbZmllbGRzXSBmaWx0ZXIgZmllbGRzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2Z1bmN0aW9ufSBbZmlsdGVyXSBmaWx0ZXIgaXRlbXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nIHwgZnVuY3Rpb259IFtvcmRlcl0gT3JkZXIgdGhlIGl0ZW1zIGJ5XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgZmllbGQgbmFtZSBvciBjdXN0b20gc29ydCBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7T2JqZWN0W119IG1hcHBlZEl0ZW1zXG4gICAqL1xuICBEYXRhU2V0LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICB2YXIgZmlsdGVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmZpbHRlcixcbiAgICAgICAgdHlwZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy50eXBlIHx8IHRoaXMuX29wdGlvbnMudHlwZSxcbiAgICAgICAgbWFwcGVkSXRlbXMgPSBbXSxcbiAgICAgICAgZGF0YSA9IHRoaXMuX2RhdGEsXG4gICAgICAgIGl0ZW1JZHMgPSBPYmplY3Qua2V5cyhkYXRhKSxcbiAgICAgICAgaSxcbiAgICAgICAgbGVuLFxuICAgICAgICBpZCxcbiAgICAgICAgaXRlbTtcblxuICAgIC8vIGNvbnZlcnQgYW5kIGZpbHRlciBpdGVtc1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1JZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlkID0gaXRlbUlkc1tpXTtcbiAgICAgIGl0ZW0gPSB0aGlzLl9nZXRJdGVtKGlkLCB0eXBlKTtcbiAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlcihpdGVtKSkge1xuICAgICAgICBtYXBwZWRJdGVtcy5wdXNoKGNhbGxiYWNrKGl0ZW0sIGlkKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gb3JkZXIgaXRlbXNcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm9yZGVyKSB7XG4gICAgICB0aGlzLl9zb3J0KG1hcHBlZEl0ZW1zLCBvcHRpb25zLm9yZGVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFwcGVkSXRlbXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpbHRlciB0aGUgZmllbGRzIG9mIGFuIGl0ZW1cbiAgICogQHBhcmFtIHtPYmplY3QgfCBudWxsfSBpdGVtXG4gICAqIEBwYXJhbSB7U3RyaW5nW119IGZpZWxkcyAgICAgRmllbGQgbmFtZXNcbiAgICogQHJldHVybiB7T2JqZWN0IHwgbnVsbH0gZmlsdGVyZWRJdGVtIG9yIG51bGwgaWYgbm8gaXRlbSBpcyBwcm92aWRlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgRGF0YVNldC5wcm90b3R5cGUuX2ZpbHRlckZpZWxkcyA9IGZ1bmN0aW9uIChpdGVtLCBmaWVsZHMpIHtcbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgIC8vIGl0ZW0gaXMgbnVsbFxuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuXG4gICAgdmFyIGZpbHRlcmVkSXRlbSA9IHt9LFxuICAgICAgICBpdGVtRmllbGRzID0gT2JqZWN0LmtleXMoaXRlbSksXG4gICAgICAgIGxlbiA9IGl0ZW1GaWVsZHMubGVuZ3RoLFxuICAgICAgICBpLFxuICAgICAgICBmaWVsZDtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGZpZWxkcykpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBmaWVsZCA9IGl0ZW1GaWVsZHNbaV07XG4gICAgICAgIGlmIChmaWVsZHMuaW5kZXhPZihmaWVsZCkgIT0gLTEpIHtcbiAgICAgICAgICBmaWx0ZXJlZEl0ZW1bZmllbGRdID0gaXRlbVtmaWVsZF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGZpZWxkID0gaXRlbUZpZWxkc1tpXTtcbiAgICAgICAgaWYgKGZpZWxkcy5oYXNPd25Qcm9wZXJ0eShmaWVsZCkpIHtcbiAgICAgICAgICBmaWx0ZXJlZEl0ZW1bZmllbGRzW2ZpZWxkXV0gPSBpdGVtW2ZpZWxkXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmaWx0ZXJlZEl0ZW07XG4gIH07XG5cbiAgLyoqXG4gICAqIFNvcnQgdGhlIHByb3ZpZGVkIGFycmF5IHdpdGggaXRlbXNcbiAgICogQHBhcmFtIHtPYmplY3RbXX0gaXRlbXNcbiAgICogQHBhcmFtIHtTdHJpbmcgfCBmdW5jdGlvbn0gb3JkZXIgICAgICBBIGZpZWxkIG5hbWUgb3IgY3VzdG9tIHNvcnQgZnVuY3Rpb24uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBEYXRhU2V0LnByb3RvdHlwZS5fc29ydCA9IGZ1bmN0aW9uIChpdGVtcywgb3JkZXIpIHtcbiAgICBpZiAodXRpbC5pc1N0cmluZyhvcmRlcikpIHtcbiAgICAgIC8vIG9yZGVyIGJ5IHByb3ZpZGVkIGZpZWxkIG5hbWVcbiAgICAgIHZhciBuYW1lID0gb3JkZXI7IC8vIGZpZWxkIG5hbWVcbiAgICAgIGl0ZW1zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIGF2ID0gYVtuYW1lXTtcbiAgICAgICAgdmFyIGJ2ID0gYltuYW1lXTtcbiAgICAgICAgcmV0dXJuIGF2ID4gYnYgPyAxIDogYXYgPCBidiA/IC0xIDogMDtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9yZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBvcmRlciBieSBzb3J0IGZ1bmN0aW9uXG4gICAgICBpdGVtcy5zb3J0KG9yZGVyKTtcbiAgICB9XG4gICAgLy8gVE9ETzogZXh0ZW5kIG9yZGVyIGJ5IGFuIE9iamVjdCB7ZmllbGQ6U3RyaW5nLCBkaXJlY3Rpb246U3RyaW5nfVxuICAgIC8vICAgICAgIHdoZXJlIGRpcmVjdGlvbiBjYW4gYmUgJ2FzYycgb3IgJ2Rlc2MnXG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09yZGVyIG11c3QgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZycpO1xuICAgICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gb2JqZWN0IGJ5IHBvaW50ZXIgb3IgYnkgaWRcbiAgICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXIgfCBPYmplY3QgfCBBcnJheX0gaWQgT2JqZWN0IG9yIGlkLCBvciBhbiBhcnJheSB3aXRoXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdHMgb3IgaWRzIHRvIGJlIHJlbW92ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtzZW5kZXJJZF0gT3B0aW9uYWwgc2VuZGVyIGlkXG4gICAqIEByZXR1cm4ge0FycmF5fSByZW1vdmVkSWRzXG4gICAqL1xuICBEYXRhU2V0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoaWQsIHNlbmRlcklkKSB7XG4gICAgdmFyIHJlbW92ZWRJZHMgPSBbXSxcbiAgICAgICAgaSxcbiAgICAgICAgbGVuLFxuICAgICAgICByZW1vdmVkSWQ7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShpZCkpIHtcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGlkLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHJlbW92ZWRJZCA9IHRoaXMuX3JlbW92ZShpZFtpXSk7XG4gICAgICAgIGlmIChyZW1vdmVkSWQgIT0gbnVsbCkge1xuICAgICAgICAgIHJlbW92ZWRJZHMucHVzaChyZW1vdmVkSWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZWRJZCA9IHRoaXMuX3JlbW92ZShpZCk7XG4gICAgICBpZiAocmVtb3ZlZElkICE9IG51bGwpIHtcbiAgICAgICAgcmVtb3ZlZElkcy5wdXNoKHJlbW92ZWRJZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlbW92ZWRJZHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl90cmlnZ2VyKCdyZW1vdmUnLCB7IGl0ZW1zOiByZW1vdmVkSWRzIH0sIHNlbmRlcklkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVtb3ZlZElkcztcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGl0ZW0gYnkgaXRzIGlkXG4gICAqIEBwYXJhbSB7TnVtYmVyIHwgU3RyaW5nIHwgT2JqZWN0fSBpZCAgIGlkIG9yIGl0ZW1cbiAgICogQHJldHVybnMge051bWJlciB8IFN0cmluZyB8IG51bGx9IGlkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBEYXRhU2V0LnByb3RvdHlwZS5fcmVtb3ZlID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgaWYgKHV0aWwuaXNOdW1iZXIoaWQpIHx8IHV0aWwuaXNTdHJpbmcoaWQpKSB7XG4gICAgICBpZiAodGhpcy5fZGF0YVtpZF0pIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2RhdGFbaWRdO1xuICAgICAgICB0aGlzLmxlbmd0aC0tO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpZCBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgdmFyIGl0ZW1JZCA9IGlkW3RoaXMuX2ZpZWxkSWRdO1xuICAgICAgaWYgKGl0ZW1JZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuX2RhdGFbaXRlbUlkXSkge1xuICAgICAgICBkZWxldGUgdGhpcy5fZGF0YVtpdGVtSWRdO1xuICAgICAgICB0aGlzLmxlbmd0aC0tO1xuICAgICAgICByZXR1cm4gaXRlbUlkO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogQ2xlYXIgdGhlIGRhdGFcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtzZW5kZXJJZF0gT3B0aW9uYWwgc2VuZGVyIGlkXG4gICAqIEByZXR1cm4ge0FycmF5fSByZW1vdmVkSWRzICAgIFRoZSBpZHMgb2YgYWxsIHJlbW92ZWQgaXRlbXNcbiAgICovXG4gIERhdGFTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKHNlbmRlcklkKSB7XG4gICAgdmFyIGlkcyA9IE9iamVjdC5rZXlzKHRoaXMuX2RhdGEpO1xuXG4gICAgdGhpcy5fZGF0YSA9IHt9O1xuICAgIHRoaXMubGVuZ3RoID0gMDtcblxuICAgIHRoaXMuX3RyaWdnZXIoJ3JlbW92ZScsIHsgaXRlbXM6IGlkcyB9LCBzZW5kZXJJZCk7XG5cbiAgICByZXR1cm4gaWRzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSBpdGVtIHdpdGggbWF4aW11bSB2YWx1ZSBvZiBhIHNwZWNpZmllZCBmaWVsZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAgICogQHJldHVybiB7T2JqZWN0IHwgbnVsbH0gaXRlbSAgSXRlbSBjb250YWluaW5nIG1heCB2YWx1ZSwgb3IgbnVsbCBpZiBubyBpdGVtc1xuICAgKi9cbiAgRGF0YVNldC5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhLFxuICAgICAgICBpdGVtSWRzID0gT2JqZWN0LmtleXMoZGF0YSksXG4gICAgICAgIG1heCA9IG51bGwsXG4gICAgICAgIG1heEZpZWxkID0gbnVsbCxcbiAgICAgICAgaSxcbiAgICAgICAgbGVuO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gaXRlbUlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGlkID0gaXRlbUlkc1tpXTtcbiAgICAgIHZhciBpdGVtID0gZGF0YVtpZF07XG4gICAgICB2YXIgaXRlbUZpZWxkID0gaXRlbVtmaWVsZF07XG4gICAgICBpZiAoaXRlbUZpZWxkICE9IG51bGwgJiYgKCFtYXggfHwgaXRlbUZpZWxkID4gbWF4RmllbGQpKSB7XG4gICAgICAgIG1heCA9IGl0ZW07XG4gICAgICAgIG1heEZpZWxkID0gaXRlbUZpZWxkO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXg7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpbmQgdGhlIGl0ZW0gd2l0aCBtaW5pbXVtIHZhbHVlIG9mIGEgc3BlY2lmaWVkIGZpZWxkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICAgKiBAcmV0dXJuIHtPYmplY3QgfCBudWxsfSBpdGVtICBJdGVtIGNvbnRhaW5pbmcgbWF4IHZhbHVlLCBvciBudWxsIGlmIG5vIGl0ZW1zXG4gICAqL1xuICBEYXRhU2V0LnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGEsXG4gICAgICAgIGl0ZW1JZHMgPSBPYmplY3Qua2V5cyhkYXRhKSxcbiAgICAgICAgbWluID0gbnVsbCxcbiAgICAgICAgbWluRmllbGQgPSBudWxsLFxuICAgICAgICBpLFxuICAgICAgICBsZW47XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtSWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgaWQgPSBpdGVtSWRzW2ldO1xuICAgICAgdmFyIGl0ZW0gPSBkYXRhW2lkXTtcbiAgICAgIHZhciBpdGVtRmllbGQgPSBpdGVtW2ZpZWxkXTtcbiAgICAgIGlmIChpdGVtRmllbGQgIT0gbnVsbCAmJiAoIW1pbiB8fCBpdGVtRmllbGQgPCBtaW5GaWVsZCkpIHtcbiAgICAgICAgbWluID0gaXRlbTtcbiAgICAgICAgbWluRmllbGQgPSBpdGVtRmllbGQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1pbjtcbiAgfTtcblxuICAvKipcbiAgICogRmluZCBhbGwgZGlzdGluY3QgdmFsdWVzIG9mIGEgc3BlY2lmaWVkIGZpZWxkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICAgKiBAcmV0dXJuIHtBcnJheX0gdmFsdWVzICBBcnJheSBjb250YWluaW5nIGFsbCBkaXN0aW5jdCB2YWx1ZXMuIElmIGRhdGEgaXRlbXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgZG8gbm90IGNvbnRhaW4gdGhlIHNwZWNpZmllZCBmaWVsZCBhcmUgaWdub3JlZC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgVGhlIHJldHVybmVkIGFycmF5IGlzIHVub3JkZXJlZC5cbiAgICovXG4gIERhdGFTZXQucHJvdG90eXBlLmRpc3RpbmN0ID0gZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgIHZhciBpdGVtSWRzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgIHZhciBmaWVsZFR5cGUgPSB0aGlzLl9vcHRpb25zLnR5cGUgJiYgdGhpcy5fb3B0aW9ucy50eXBlW2ZpZWxkXSB8fCBudWxsO1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGksIGosIGxlbjtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1JZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBpZCA9IGl0ZW1JZHNbaV07XG4gICAgICB2YXIgaXRlbSA9IGRhdGFbaWRdO1xuICAgICAgdmFyIHZhbHVlID0gaXRlbVtmaWVsZF07XG4gICAgICB2YXIgZXhpc3RzID0gZmFsc2U7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgY291bnQ7IGorKykge1xuICAgICAgICBpZiAodmFsdWVzW2pdID09IHZhbHVlKSB7XG4gICAgICAgICAgZXhpc3RzID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFleGlzdHMgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWx1ZXNbY291bnRdID0gdmFsdWU7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZpZWxkVHlwZSkge1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gdmFsdWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhbHVlc1tpXSA9IHV0aWwuY29udmVydCh2YWx1ZXNbaV0sIGZpZWxkVHlwZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGEgc2luZ2xlIGl0ZW0uIFdpbGwgZmFpbCB3aGVuIGFuIGl0ZW0gd2l0aCB0aGUgc2FtZSBpZCBhbHJlYWR5IGV4aXN0cy5cbiAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cbiAgICogQHJldHVybiB7U3RyaW5nfSBpZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgRGF0YVNldC5wcm90b3R5cGUuX2FkZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgIHZhciBpZCA9IGl0ZW1bdGhpcy5fZmllbGRJZF07XG5cbiAgICBpZiAoaWQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBjaGVjayB3aGV0aGVyIHRoaXMgaWQgaXMgYWxyZWFkeSB0YWtlblxuICAgICAgaWYgKHRoaXMuX2RhdGFbaWRdKSB7XG4gICAgICAgIC8vIGl0ZW0gYWxyZWFkeSBleGlzdHNcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYWRkIGl0ZW06IGl0ZW0gd2l0aCBpZCAnICsgaWQgKyAnIGFscmVhZHkgZXhpc3RzJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGdlbmVyYXRlIGFuIGlkXG4gICAgICBpZCA9IHV0aWwucmFuZG9tVVVJRCgpO1xuICAgICAgaXRlbVt0aGlzLl9maWVsZElkXSA9IGlkO1xuICAgIH1cblxuICAgIHZhciBkID0ge30sXG4gICAgICAgIGZpZWxkcyA9IE9iamVjdC5rZXlzKGl0ZW0pLFxuICAgICAgICBpLFxuICAgICAgICBsZW47XG4gICAgZm9yIChpID0gMCwgbGVuID0gZmllbGRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgZmllbGQgPSBmaWVsZHNbaV07XG4gICAgICB2YXIgZmllbGRUeXBlID0gdGhpcy5fdHlwZVtmaWVsZF07IC8vIHR5cGUgbWF5IGJlIHVuZGVmaW5lZFxuICAgICAgZFtmaWVsZF0gPSB1dGlsLmNvbnZlcnQoaXRlbVtmaWVsZF0sIGZpZWxkVHlwZSk7XG4gICAgfVxuICAgIHRoaXMuX2RhdGFbaWRdID0gZDtcbiAgICB0aGlzLmxlbmd0aCsrO1xuXG4gICAgcmV0dXJuIGlkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYW4gaXRlbS4gRmllbGRzIGNhbiBiZSBjb252ZXJ0ZWQgdG8gYSBzcGVjaWZpYyB0eXBlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICAgKiBAcGFyYW0ge09iamVjdC48U3RyaW5nLCBTdHJpbmc+fSBbdHlwZXNdICBmaWVsZCB0eXBlcyB0byBjb252ZXJ0XG4gICAqIEByZXR1cm4ge09iamVjdCB8IG51bGx9IGl0ZW1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIERhdGFTZXQucHJvdG90eXBlLl9nZXRJdGVtID0gZnVuY3Rpb24gKGlkLCB0eXBlcykge1xuICAgIHZhciBmaWVsZCwgdmFsdWUsIGksIGxlbjtcblxuICAgIC8vIGdldCB0aGUgaXRlbSBmcm9tIHRoZSBkYXRhc2V0XG4gICAgdmFyIHJhdyA9IHRoaXMuX2RhdGFbaWRdO1xuICAgIGlmICghcmF3KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IHRoZSBpdGVtcyBmaWVsZCB0eXBlc1xuICAgIHZhciBjb252ZXJ0ZWQgPSB7fSxcbiAgICAgICAgZmllbGRzID0gT2JqZWN0LmtleXMocmF3KTtcblxuICAgIGlmICh0eXBlcykge1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gZmllbGRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGZpZWxkID0gZmllbGRzW2ldO1xuICAgICAgICB2YWx1ZSA9IHJhd1tmaWVsZF07XG4gICAgICAgIGNvbnZlcnRlZFtmaWVsZF0gPSB1dGlsLmNvbnZlcnQodmFsdWUsIHR5cGVzW2ZpZWxkXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5vIGZpZWxkIHR5cGVzIHNwZWNpZmllZCwgbm8gY29udmVydGluZyBuZWVkZWRcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGZpZWxkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBmaWVsZCA9IGZpZWxkc1tpXTtcbiAgICAgICAgdmFsdWUgPSByYXdbZmllbGRdO1xuICAgICAgICBjb252ZXJ0ZWRbZmllbGRdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb252ZXJ0ZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBhIHNpbmdsZSBpdGVtOiBtZXJnZSB3aXRoIGV4aXN0aW5nIGl0ZW0uXG4gICAqIFdpbGwgZmFpbCB3aGVuIHRoZSBpdGVtIGhhcyBubyBpZCwgb3Igd2hlbiB0aGVyZSBkb2VzIG5vdCBleGlzdCBhbiBpdGVtXG4gICAqIHdpdGggdGhlIHNhbWUgaWQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG4gICAqIEByZXR1cm4ge1N0cmluZ30gaWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIERhdGFTZXQucHJvdG90eXBlLl91cGRhdGVJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICB2YXIgaWQgPSBpdGVtW3RoaXMuX2ZpZWxkSWRdO1xuICAgIGlmIChpZCA9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVwZGF0ZSBpdGVtOiBpdGVtIGhhcyBubyBpZCAoaXRlbTogJyArIEpTT04uc3RyaW5naWZ5KGl0ZW0pICsgJyknKTtcbiAgICB9XG4gICAgdmFyIGQgPSB0aGlzLl9kYXRhW2lkXTtcbiAgICBpZiAoIWQpIHtcbiAgICAgIC8vIGl0ZW0gZG9lc24ndCBleGlzdFxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdXBkYXRlIGl0ZW06IG5vIGl0ZW0gd2l0aCBpZCAnICsgaWQgKyAnIGZvdW5kJyk7XG4gICAgfVxuXG4gICAgLy8gbWVyZ2Ugd2l0aCBjdXJyZW50IGl0ZW1cbiAgICB2YXIgZmllbGRzID0gT2JqZWN0LmtleXMoaXRlbSk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGZpZWxkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGZpZWxkID0gZmllbGRzW2ldO1xuICAgICAgdmFyIGZpZWxkVHlwZSA9IHRoaXMuX3R5cGVbZmllbGRdOyAvLyB0eXBlIG1heSBiZSB1bmRlZmluZWRcbiAgICAgIGRbZmllbGRdID0gdXRpbC5jb252ZXJ0KGl0ZW1bZmllbGRdLCBmaWVsZFR5cGUpO1xuICAgIH1cblxuICAgIHJldHVybiBpZDtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IERhdGFTZXQ7XG5cbi8qKiovIH0sXG4vKiAxMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBBIHF1ZXVlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqICAgICAgICAgICAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gICAqICAgICAgICAgICAgLSBkZWxheTogbnVtYmVyICAgIFdoZW4gcHJvdmlkZWQsIHRoZSBxdWV1ZSB3aWxsIGJlIGZsdXNoZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0b21hdGljYWxseSBhZnRlciBhbiBpbmFjdGl2aXR5IG9mIHRoaXMgZGVsYXlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gbWlsbGlzZWNvbmRzLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IHZhbHVlIGlzIG51bGwuXG4gICAqICAgICAgICAgICAgLSBtYXg6IG51bWJlciAgICAgIFdoZW4gdGhlIHF1ZXVlIGV4Y2VlZHMgdGhlIGdpdmVuIG1heGltdW0gbnVtYmVyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIGVudHJpZXMsIHRoZSBxdWV1ZSBpcyBmbHVzaGVkIGF1dG9tYXRpY2FsbHkuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgdmFsdWUgb2YgbWF4IGlzIEluZmluaXR5LlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIFF1ZXVlKG9wdGlvbnMpIHtcbiAgICAvLyBvcHRpb25zXG4gICAgdGhpcy5kZWxheSA9IG51bGw7XG4gICAgdGhpcy5tYXggPSBJbmZpbml0eTtcblxuICAgIC8vIHByb3BlcnRpZXNcbiAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICAgIHRoaXMuX3RpbWVvdXQgPSBudWxsO1xuICAgIHRoaXMuX2V4dGVuZGVkID0gbnVsbDtcblxuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIHF1ZXVlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqICAgICAgICAgICAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gICAqICAgICAgICAgICAgLSBkZWxheTogbnVtYmVyICAgIFdoZW4gcHJvdmlkZWQsIHRoZSBxdWV1ZSB3aWxsIGJlIGZsdXNoZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0b21hdGljYWxseSBhZnRlciBhbiBpbmFjdGl2aXR5IG9mIHRoaXMgZGVsYXlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gbWlsbGlzZWNvbmRzLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IHZhbHVlIGlzIG51bGwuXG4gICAqICAgICAgICAgICAgLSBtYXg6IG51bWJlciAgICAgIFdoZW4gdGhlIHF1ZXVlIGV4Y2VlZHMgdGhlIGdpdmVuIG1heGltdW0gbnVtYmVyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIGVudHJpZXMsIHRoZSBxdWV1ZSBpcyBmbHVzaGVkIGF1dG9tYXRpY2FsbHkuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgdmFsdWUgb2YgbWF4IGlzIEluZmluaXR5LlxuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKi9cbiAgUXVldWUucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLmRlbGF5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5kZWxheSA9IG9wdGlvbnMuZGVsYXk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMubWF4ID0gb3B0aW9ucy5tYXg7XG4gICAgfVxuXG4gICAgdGhpcy5fZmx1c2hJZk5lZWRlZCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFeHRlbmQgYW4gb2JqZWN0IHdpdGggcXVldWluZyBmdW5jdGlvbmFsaXR5LlxuICAgKiBUaGUgb2JqZWN0IHdpbGwgYmUgZXh0ZW5kZWQgd2l0aCBhIGZ1bmN0aW9uIGZsdXNoLCBhbmQgdGhlIG1ldGhvZHMgcHJvdmlkZWRcbiAgICogaW4gb3B0aW9ucy5yZXBsYWNlIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBxdWV1ZWQgb25lcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiAgICAgICAgICAgIEF2YWlsYWJsZSBvcHRpb25zOlxuICAgKiAgICAgICAgICAgIC0gcmVwbGFjZTogQXJyYXkuPHN0cmluZz5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQSBsaXN0IHdpdGggbWV0aG9kIG5hbWVzIG9mIHRoZSBtZXRob2RzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uIHRoZSBvYmplY3QgdG8gYmUgcmVwbGFjZWQgd2l0aCBxdWV1ZWQgb25lcy5cbiAgICogICAgICAgICAgICAtIGRlbGF5OiBudW1iZXIgICAgV2hlbiBwcm92aWRlZCwgdGhlIHF1ZXVlIHdpbGwgYmUgZmx1c2hlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRvbWF0aWNhbGx5IGFmdGVyIGFuIGluYWN0aXZpdHkgb2YgdGhpcyBkZWxheVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiBtaWxsaXNlY29uZHMuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgdmFsdWUgaXMgbnVsbC5cbiAgICogICAgICAgICAgICAtIG1heDogbnVtYmVyICAgICAgV2hlbiB0aGUgcXVldWUgZXhjZWVkcyB0aGUgZ2l2ZW4gbWF4aW11bSBudW1iZXJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgZW50cmllcywgdGhlIHF1ZXVlIGlzIGZsdXNoZWQgYXV0b21hdGljYWxseS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCB2YWx1ZSBvZiBtYXggaXMgSW5maW5pdHkuXG4gICAqIEByZXR1cm4ge1F1ZXVlfSBSZXR1cm5zIHRoZSBjcmVhdGVkIHF1ZXVlXG4gICAqL1xuICBRdWV1ZS5leHRlbmQgPSBmdW5jdGlvbiAob2JqZWN0LCBvcHRpb25zKSB7XG4gICAgdmFyIHF1ZXVlID0gbmV3IFF1ZXVlKG9wdGlvbnMpO1xuXG4gICAgaWYgKG9iamVjdC5mbHVzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RhcmdldCBvYmplY3QgYWxyZWFkeSBoYXMgYSBwcm9wZXJ0eSBmbHVzaCcpO1xuICAgIH1cbiAgICBvYmplY3QuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICBxdWV1ZS5mbHVzaCgpO1xuICAgIH07XG5cbiAgICB2YXIgbWV0aG9kcyA9IFt7XG4gICAgICBuYW1lOiAnZmx1c2gnLFxuICAgICAgb3JpZ2luYWw6IHVuZGVmaW5lZFxuICAgIH1dO1xuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZXBsYWNlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbnMucmVwbGFjZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbmFtZSA9IG9wdGlvbnMucmVwbGFjZVtpXTtcbiAgICAgICAgbWV0aG9kcy5wdXNoKHtcbiAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgIG9yaWdpbmFsOiBvYmplY3RbbmFtZV1cbiAgICAgICAgfSk7XG4gICAgICAgIHF1ZXVlLnJlcGxhY2Uob2JqZWN0LCBuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBxdWV1ZS5fZXh0ZW5kZWQgPSB7XG4gICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgIG1ldGhvZHM6IG1ldGhvZHNcbiAgICB9O1xuXG4gICAgcmV0dXJuIHF1ZXVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXN0cm95IHRoZSBxdWV1ZS4gVGhlIHF1ZXVlIHdpbGwgZmlyc3QgZmx1c2ggYWxsIHF1ZXVlZCBhY3Rpb25zLCBhbmQgaW5cbiAgICogY2FzZSBpdCBoYXMgZXh0ZW5kZWQgYW4gb2JqZWN0LCB3aWxsIHJlc3RvcmUgdGhlIG9yaWdpbmFsIG9iamVjdC5cbiAgICovXG4gIFF1ZXVlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZmx1c2goKTtcblxuICAgIGlmICh0aGlzLl9leHRlbmRlZCkge1xuICAgICAgdmFyIG9iamVjdCA9IHRoaXMuX2V4dGVuZGVkLm9iamVjdDtcbiAgICAgIHZhciBtZXRob2RzID0gdGhpcy5fZXh0ZW5kZWQubWV0aG9kcztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbWV0aG9kID0gbWV0aG9kc1tpXTtcbiAgICAgICAgaWYgKG1ldGhvZC5vcmlnaW5hbCkge1xuICAgICAgICAgIG9iamVjdFttZXRob2QubmFtZV0gPSBtZXRob2Qub3JpZ2luYWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIG9iamVjdFttZXRob2QubmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2V4dGVuZGVkID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcGxhY2UgYSBtZXRob2Qgb24gYW4gb2JqZWN0IHdpdGggYSBxdWV1ZWQgdmVyc2lvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0ICAgT2JqZWN0IGhhdmluZyB0aGUgbWV0aG9kXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2QgICBUaGUgbWV0aG9kIG5hbWVcbiAgICovXG4gIFF1ZXVlLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gKG9iamVjdCwgbWV0aG9kKSB7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgb3JpZ2luYWwgPSBvYmplY3RbbWV0aG9kXTtcbiAgICBpZiAoIW9yaWdpbmFsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCAnICsgbWV0aG9kICsgJyB1bmRlZmluZWQnKTtcbiAgICB9XG5cbiAgICBvYmplY3RbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGNyZWF0ZSBhbiBBcnJheSB3aXRoIHRoZSBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgfVxuXG4gICAgICAvLyBhZGQgdGhpcyBjYWxsIHRvIHRoZSBxdWV1ZVxuICAgICAgbWUucXVldWUoe1xuICAgICAgICBhcmdzOiBhcmdzLFxuICAgICAgICBmbjogb3JpZ2luYWwsXG4gICAgICAgIGNvbnRleHQ6IHRoaXNcbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIFF1ZXVlIGEgY2FsbFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uIHwge2ZuOiBmdW5jdGlvbiwgYXJnczogQXJyYXl9IHwge2ZuOiBmdW5jdGlvbiwgYXJnczogQXJyYXksIGNvbnRleHQ6IE9iamVjdH19IGVudHJ5XG4gICAqL1xuICBRdWV1ZS5wcm90b3R5cGUucXVldWUgPSBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLl9xdWV1ZS5wdXNoKHsgZm46IGVudHJ5IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9xdWV1ZS5wdXNoKGVudHJ5KTtcbiAgICB9XG5cbiAgICB0aGlzLl9mbHVzaElmTmVlZGVkKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdGhlIHF1ZXVlIG5lZWRzIHRvIGJlIGZsdXNoZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFF1ZXVlLnByb3RvdHlwZS5fZmx1c2hJZk5lZWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBmbHVzaCB3aGVuIHRoZSBtYXhpbXVtIGlzIGV4Y2VlZGVkLlxuICAgIGlmICh0aGlzLl9xdWV1ZS5sZW5ndGggPiB0aGlzLm1heCkge1xuICAgICAgdGhpcy5mbHVzaCgpO1xuICAgIH1cblxuICAgIC8vIGZsdXNoIGFmdGVyIGEgcGVyaW9kIG9mIGluYWN0aXZpdHkgd2hlbiBhIGRlbGF5IGlzIGNvbmZpZ3VyZWRcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG4gICAgaWYgKHRoaXMucXVldWUubGVuZ3RoID4gMCAmJiB0eXBlb2YgdGhpcy5kZWxheSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1lLmZsdXNoKCk7XG4gICAgICB9LCB0aGlzLmRlbGF5KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEZsdXNoIGFsbCBxdWV1ZWQgY2FsbHNcbiAgICovXG4gIFF1ZXVlLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB3aGlsZSAodGhpcy5fcXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGVudHJ5ID0gdGhpcy5fcXVldWUuc2hpZnQoKTtcbiAgICAgIGVudHJ5LmZuLmFwcGx5KGVudHJ5LmNvbnRleHQgfHwgZW50cnkuZm4sIGVudHJ5LmFyZ3MgfHwgW10pO1xuICAgIH1cbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFF1ZXVlO1xuXG4vKioqLyB9LFxuLyogMTEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4gIHZhciBEYXRhU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxuICAvKipcbiAgICogRGF0YVZpZXdcbiAgICpcbiAgICogYSBkYXRhdmlldyBvZmZlcnMgYSBmaWx0ZXJlZCB2aWV3IG9uIGEgZGF0YXNldCBvciBhbiBvdGhlciBkYXRhdmlldy5cbiAgICpcbiAgICogQHBhcmFtIHtEYXRhU2V0IHwgRGF0YVZpZXd9IGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgIEF2YWlsYWJsZSBvcHRpb25zOiBzZWUgbWV0aG9kIGdldFxuICAgKlxuICAgKiBAY29uc3RydWN0b3IgRGF0YVZpZXdcbiAgICovXG4gIGZ1bmN0aW9uIERhdGFWaWV3KGRhdGEsIG9wdGlvbnMpIHtcbiAgICB0aGlzLl9kYXRhID0gbnVsbDtcbiAgICB0aGlzLl9pZHMgPSB7fTsgLy8gaWRzIG9mIHRoZSBpdGVtcyBjdXJyZW50bHkgaW4gbWVtb3J5IChqdXN0IGNvbnRhaW5zIGEgYm9vbGVhbiB0cnVlKVxuICAgIHRoaXMubGVuZ3RoID0gMDsgLy8gbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBEYXRhVmlld1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuX2ZpZWxkSWQgPSAnaWQnOyAvLyBuYW1lIG9mIHRoZSBmaWVsZCBjb250YWluaW5nIGlkXG4gICAgdGhpcy5fc3Vic2NyaWJlcnMgPSB7fTsgLy8gZXZlbnQgc3Vic2NyaWJlcnNcblxuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdGhpcy5saXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIG1lLl9vbkV2ZW50LmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICB0aGlzLnNldERhdGEoZGF0YSk7XG4gIH1cblxuICAvLyBUT0RPOiBpbXBsZW1lbnQgYSBmdW5jdGlvbiAuY29uZmlnKCkgdG8gZHluYW1pY2FsbHkgdXBkYXRlIHRoaW5ncyBsaWtlIGNvbmZpZ3VyZWQgZmlsdGVyXG4gIC8vIGFuZCB0cmlnZ2VyIGNoYW5nZXMgYWNjb3JkaW5nbHlcblxuICAvKipcbiAgICogU2V0IGEgZGF0YSBzb3VyY2UgZm9yIHRoZSB2aWV3XG4gICAqIEBwYXJhbSB7RGF0YVNldCB8IERhdGFWaWV3fSBkYXRhXG4gICAqL1xuICBEYXRhVmlldy5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIGlkcywgaWQsIGksIGxlbjtcblxuICAgIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgICAvLyB1bnN1YnNjcmliZSBmcm9tIGN1cnJlbnQgZGF0YXNldFxuICAgICAgaWYgKHRoaXMuX2RhdGEub2ZmKSB7XG4gICAgICAgIHRoaXMuX2RhdGEub2ZmKCcqJywgdGhpcy5saXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIC8vIHRyaWdnZXIgYSByZW1vdmUgb2YgYWxsIGl0ZW1zIGluIG1lbW9yeVxuICAgICAgaWRzID0gT2JqZWN0LmtleXModGhpcy5faWRzKTtcbiAgICAgIHRoaXMuX2lkcyA9IHt9O1xuICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5fdHJpZ2dlcigncmVtb3ZlJywgeyBpdGVtczogaWRzIH0pO1xuICAgIH1cblxuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuXG4gICAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICAgIC8vIHVwZGF0ZSBmaWVsZElkXG4gICAgICB0aGlzLl9maWVsZElkID0gdGhpcy5fb3B0aW9ucy5maWVsZElkIHx8IHRoaXMuX2RhdGEgJiYgdGhpcy5fZGF0YS5vcHRpb25zICYmIHRoaXMuX2RhdGEub3B0aW9ucy5maWVsZElkIHx8ICdpZCc7XG5cbiAgICAgIC8vIHRyaWdnZXIgYW4gYWRkIG9mIGFsbCBhZGRlZCBpdGVtc1xuICAgICAgaWRzID0gdGhpcy5fZGF0YS5nZXRJZHMoeyBmaWx0ZXI6IHRoaXMuX29wdGlvbnMgJiYgdGhpcy5fb3B0aW9ucy5maWx0ZXIgfSk7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWQgPSBpZHNbaV07XG4gICAgICAgIHRoaXMuX2lkc1tpZF0gPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5sZW5ndGggPSBpZHMubGVuZ3RoO1xuICAgICAgdGhpcy5fdHJpZ2dlcignYWRkJywgeyBpdGVtczogaWRzIH0pO1xuXG4gICAgICAvLyBzdWJzY3JpYmUgdG8gbmV3IGRhdGFzZXRcbiAgICAgIGlmICh0aGlzLl9kYXRhLm9uKSB7XG4gICAgICAgIHRoaXMuX2RhdGEub24oJyonLCB0aGlzLmxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlZnJlc2ggdGhlIERhdGFWaWV3LiBVc2VmdWwgd2hlbiB0aGUgRGF0YVZpZXcgaGFzIGEgZmlsdGVyIGZ1bmN0aW9uXG4gICAqIGNvbnRhaW5pbmcgYSB2YXJpYWJsZSBwYXJhbWV0ZXIuXG4gICAqL1xuICBEYXRhVmlldy5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaWQsIGksIGxlbjtcbiAgICB2YXIgaWRzID0gdGhpcy5fZGF0YS5nZXRJZHMoeyBmaWx0ZXI6IHRoaXMuX29wdGlvbnMgJiYgdGhpcy5fb3B0aW9ucy5maWx0ZXIgfSk7XG4gICAgdmFyIG9sZElkcyA9IE9iamVjdC5rZXlzKHRoaXMuX2lkcyk7XG4gICAgdmFyIG5ld0lkcyA9IHt9O1xuICAgIHZhciBhZGRlZCA9IFtdO1xuICAgIHZhciByZW1vdmVkID0gW107XG5cbiAgICAvLyBjaGVjayBmb3IgYWRkaXRpb25zXG4gICAgZm9yIChpID0gMCwgbGVuID0gaWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZCA9IGlkc1tpXTtcbiAgICAgIG5ld0lkc1tpZF0gPSB0cnVlO1xuICAgICAgaWYgKCF0aGlzLl9pZHNbaWRdKSB7XG4gICAgICAgIGFkZGVkLnB1c2goaWQpO1xuICAgICAgICB0aGlzLl9pZHNbaWRdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjaGVjayBmb3IgcmVtb3ZhbHNcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBvbGRJZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlkID0gb2xkSWRzW2ldO1xuICAgICAgaWYgKCFuZXdJZHNbaWRdKSB7XG4gICAgICAgIHJlbW92ZWQucHVzaChpZCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9pZHNbaWRdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoICs9IGFkZGVkLmxlbmd0aCAtIHJlbW92ZWQubGVuZ3RoO1xuXG4gICAgLy8gdHJpZ2dlciBldmVudHNcbiAgICBpZiAoYWRkZWQubGVuZ3RoKSB7XG4gICAgICB0aGlzLl90cmlnZ2VyKCdhZGQnLCB7IGl0ZW1zOiBhZGRlZCB9KTtcbiAgICB9XG4gICAgaWYgKHJlbW92ZWQubGVuZ3RoKSB7XG4gICAgICB0aGlzLl90cmlnZ2VyKCdyZW1vdmUnLCB7IGl0ZW1zOiByZW1vdmVkIH0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IGRhdGEgZnJvbSB0aGUgZGF0YSB2aWV3XG4gICAqXG4gICAqIFVzYWdlOlxuICAgKlxuICAgKiAgICAgZ2V0KClcbiAgICogICAgIGdldChvcHRpb25zOiBPYmplY3QpXG4gICAqICAgICBnZXQob3B0aW9uczogT2JqZWN0LCBkYXRhOiBBcnJheSB8IERhdGFUYWJsZSlcbiAgICpcbiAgICogICAgIGdldChpZDogTnVtYmVyKVxuICAgKiAgICAgZ2V0KGlkOiBOdW1iZXIsIG9wdGlvbnM6IE9iamVjdClcbiAgICogICAgIGdldChpZDogTnVtYmVyLCBvcHRpb25zOiBPYmplY3QsIGRhdGE6IEFycmF5IHwgRGF0YVRhYmxlKVxuICAgKlxuICAgKiAgICAgZ2V0KGlkczogTnVtYmVyW10pXG4gICAqICAgICBnZXQoaWRzOiBOdW1iZXJbXSwgb3B0aW9uczogT2JqZWN0KVxuICAgKiAgICAgZ2V0KGlkczogTnVtYmVyW10sIG9wdGlvbnM6IE9iamVjdCwgZGF0YTogQXJyYXkgfCBEYXRhVGFibGUpXG4gICAqXG4gICAqIFdoZXJlOlxuICAgKlxuICAgKiB7TnVtYmVyIHwgU3RyaW5nfSBpZCAgICAgICAgIFRoZSBpZCBvZiBhbiBpdGVtXG4gICAqIHtOdW1iZXJbXSB8IFN0cmluZ3t9fSBpZHMgICAgQW4gYXJyYXkgd2l0aCBpZHMgb2YgaXRlbXNcbiAgICoge09iamVjdH0gb3B0aW9ucyAgICAgICAgICAgICBBbiBPYmplY3Qgd2l0aCBvcHRpb25zLiBBdmFpbGFibGUgb3B0aW9uczpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nfSBbdHlwZV0gVHlwZSBvZiBkYXRhIHRvIGJlIHJldHVybmVkLiBDYW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmUgJ0RhdGFUYWJsZScgb3IgJ0FycmF5JyAoZGVmYXVsdClcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0LjxTdHJpbmcsIFN0cmluZz59IFtjb252ZXJ0XVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmdbXX0gW2ZpZWxkc10gZmllbGQgbmFtZXMgdG8gYmUgcmV0dXJuZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ZnVuY3Rpb259IFtmaWx0ZXJdIGZpbHRlciBpdGVtc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmcgfCBmdW5jdGlvbn0gW29yZGVyXSBPcmRlciB0aGUgaXRlbXMgYnlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBmaWVsZCBuYW1lIG9yIGN1c3RvbSBzb3J0IGZ1bmN0aW9uLlxuICAgKiB7QXJyYXkgfCBEYXRhVGFibGV9IFtkYXRhXSAgIElmIHByb3ZpZGVkLCBpdGVtcyB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoaXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheSBvciB0YWJsZS4gUmVxdWlyZWQgaW4gY2FzZSBvZiBHb29nbGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEYXRhVGFibGUuXG4gICAqIEBwYXJhbSBhcmdzXG4gICAqL1xuICBEYXRhVmlldy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuXG4gICAgLy8gcGFyc2UgdGhlIGFyZ3VtZW50c1xuICAgIHZhciBpZHMsIG9wdGlvbnMsIGRhdGE7XG4gICAgdmFyIGZpcnN0VHlwZSA9IHV0aWwuZ2V0VHlwZShhcmd1bWVudHNbMF0pO1xuICAgIGlmIChmaXJzdFR5cGUgPT0gJ1N0cmluZycgfHwgZmlyc3RUeXBlID09ICdOdW1iZXInIHx8IGZpcnN0VHlwZSA9PSAnQXJyYXknKSB7XG4gICAgICAvLyBnZXQoaWQocykgWywgb3B0aW9uc10gWywgZGF0YV0pXG4gICAgICBpZHMgPSBhcmd1bWVudHNbMF07IC8vIGNhbiBiZSBhIHNpbmdsZSBpZCBvciBhbiBhcnJheSB3aXRoIGlkc1xuICAgICAgb3B0aW9ucyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGRhdGEgPSBhcmd1bWVudHNbMl07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGdldChbLCBvcHRpb25zXSBbLCBkYXRhXSlcbiAgICAgIG9wdGlvbnMgPSBhcmd1bWVudHNbMF07XG4gICAgICBkYXRhID0gYXJndW1lbnRzWzFdO1xuICAgIH1cblxuICAgIC8vIGV4dGVuZCB0aGUgb3B0aW9ucyB3aXRoIHRoZSBkZWZhdWx0IG9wdGlvbnMgYW5kIHByb3ZpZGVkIG9wdGlvbnNcbiAgICB2YXIgdmlld09wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5fb3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAvLyBjcmVhdGUgYSBjb21iaW5lZCBmaWx0ZXIgbWV0aG9kIHdoZW4gbmVlZGVkXG4gICAgaWYgKHRoaXMuX29wdGlvbnMuZmlsdGVyICYmIG9wdGlvbnMgJiYgb3B0aW9ucy5maWx0ZXIpIHtcbiAgICAgIHZpZXdPcHRpb25zLmZpbHRlciA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBtZS5fb3B0aW9ucy5maWx0ZXIoaXRlbSkgJiYgb3B0aW9ucy5maWx0ZXIoaXRlbSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIGJ1aWxkIHVwIHRoZSBjYWxsIHRvIHRoZSBsaW5rZWQgZGF0YSBzZXRcbiAgICB2YXIgZ2V0QXJndW1lbnRzID0gW107XG4gICAgaWYgKGlkcyAhPSB1bmRlZmluZWQpIHtcbiAgICAgIGdldEFyZ3VtZW50cy5wdXNoKGlkcyk7XG4gICAgfVxuICAgIGdldEFyZ3VtZW50cy5wdXNoKHZpZXdPcHRpb25zKTtcbiAgICBnZXRBcmd1bWVudHMucHVzaChkYXRhKTtcblxuICAgIHJldHVybiB0aGlzLl9kYXRhICYmIHRoaXMuX2RhdGEuZ2V0LmFwcGx5KHRoaXMuX2RhdGEsIGdldEFyZ3VtZW50cyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBpZHMgb2YgYWxsIGl0ZW1zIG9yIGZyb20gYSBmaWx0ZXJlZCBzZXQgb2YgaXRlbXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgQW4gT2JqZWN0IHdpdGggb3B0aW9ucy4gQXZhaWxhYmxlIG9wdGlvbnM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2Z1bmN0aW9ufSBbZmlsdGVyXSBmaWx0ZXIgaXRlbXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nIHwgZnVuY3Rpb259IFtvcmRlcl0gT3JkZXIgdGhlIGl0ZW1zIGJ5XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgZmllbGQgbmFtZSBvciBjdXN0b20gc29ydCBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7QXJyYXl9IGlkc1xuICAgKi9cbiAgRGF0YVZpZXcucHJvdG90eXBlLmdldElkcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIGlkcztcblxuICAgIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgICB2YXIgZGVmYXVsdEZpbHRlciA9IHRoaXMuX29wdGlvbnMuZmlsdGVyO1xuICAgICAgdmFyIGZpbHRlcjtcblxuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5maWx0ZXIpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRGaWx0ZXIpIHtcbiAgICAgICAgICBmaWx0ZXIgPSBmdW5jdGlvbiBmaWx0ZXIoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRGaWx0ZXIoaXRlbSkgJiYgb3B0aW9ucy5maWx0ZXIoaXRlbSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaWx0ZXIgPSBvcHRpb25zLmZpbHRlcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlsdGVyID0gZGVmYXVsdEZpbHRlcjtcbiAgICAgIH1cblxuICAgICAgaWRzID0gdGhpcy5fZGF0YS5nZXRJZHMoe1xuICAgICAgICBmaWx0ZXI6IGZpbHRlcixcbiAgICAgICAgb3JkZXI6IG9wdGlvbnMgJiYgb3B0aW9ucy5vcmRlclxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlkcyA9IFtdO1xuICAgIH1cblxuICAgIHJldHVybiBpZHM7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1hcCBldmVyeSBpdGVtIGluIHRoZSBkYXRhc2V0LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgIEF2YWlsYWJsZSBvcHRpb25zOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtPYmplY3QuPFN0cmluZywgU3RyaW5nPn0gW3R5cGVdXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZ1tdfSBbZmllbGRzXSBmaWx0ZXIgZmllbGRzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2Z1bmN0aW9ufSBbZmlsdGVyXSBmaWx0ZXIgaXRlbXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nIHwgZnVuY3Rpb259IFtvcmRlcl0gT3JkZXIgdGhlIGl0ZW1zIGJ5XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgZmllbGQgbmFtZSBvciBjdXN0b20gc29ydCBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7T2JqZWN0W119IG1hcHBlZEl0ZW1zXG4gICAqL1xuICBEYXRhVmlldy5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgdmFyIG1hcHBlZEl0ZW1zID0gW107XG4gICAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICAgIHZhciBkZWZhdWx0RmlsdGVyID0gdGhpcy5fb3B0aW9ucy5maWx0ZXI7XG4gICAgICB2YXIgZmlsdGVyO1xuXG4gICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmZpbHRlcikge1xuICAgICAgICBpZiAoZGVmYXVsdEZpbHRlcikge1xuICAgICAgICAgIGZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlcihpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdEZpbHRlcihpdGVtKSAmJiBvcHRpb25zLmZpbHRlcihpdGVtKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaWx0ZXIgPSBkZWZhdWx0RmlsdGVyO1xuICAgICAgfVxuXG4gICAgICBtYXBwZWRJdGVtcyA9IHRoaXMuX2RhdGEubWFwKGNhbGxiYWNrLCB7XG4gICAgICAgIGZpbHRlcjogZmlsdGVyLFxuICAgICAgICBvcmRlcjogb3B0aW9ucyAmJiBvcHRpb25zLm9yZGVyXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWFwcGVkSXRlbXMgPSBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFwcGVkSXRlbXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgRGF0YVNldCB0byB3aGljaCB0aGlzIERhdGFWaWV3IGlzIGNvbm5lY3RlZC4gSW4gY2FzZSB0aGVyZSBpcyBhIGNoYWluXG4gICAqIG9mIG11bHRpcGxlIERhdGFWaWV3cywgdGhlIHJvb3QgRGF0YVNldCBvZiB0aGlzIGNoYWluIGlzIHJldHVybmVkLlxuICAgKiBAcmV0dXJuIHtEYXRhU2V0fSBkYXRhU2V0XG4gICAqL1xuICBEYXRhVmlldy5wcm90b3R5cGUuZ2V0RGF0YVNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YVNldCA9IHRoaXM7XG4gICAgd2hpbGUgKGRhdGFTZXQgaW5zdGFuY2VvZiBEYXRhVmlldykge1xuICAgICAgZGF0YVNldCA9IGRhdGFTZXQuX2RhdGE7XG4gICAgfVxuICAgIHJldHVybiBkYXRhU2V0IHx8IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV2ZW50IGxpc3RlbmVyLiBXaWxsIHByb3BhZ2F0ZSBhbGwgZXZlbnRzIGZyb20gdGhlIGNvbm5lY3RlZCBkYXRhIHNldCB0b1xuICAgKiB0aGUgc3Vic2NyaWJlcnMgb2YgdGhlIERhdGFWaWV3LCBidXQgd2lsbCBmaWx0ZXIgdGhlIGl0ZW1zIGFuZCBvbmx5IHRyaWdnZXJcbiAgICogd2hlbiB0aGVyZSBhcmUgY2hhbmdlcyBpbiB0aGUgZmlsdGVyZWQgZGF0YSBzZXQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdCB8IG51bGx9IHBhcmFtc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gc2VuZGVySWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIERhdGFWaWV3LnByb3RvdHlwZS5fb25FdmVudCA9IGZ1bmN0aW9uIChldmVudCwgcGFyYW1zLCBzZW5kZXJJZCkge1xuICAgIHZhciBpLCBsZW4sIGlkLCBpdGVtO1xuICAgIHZhciBpZHMgPSBwYXJhbXMgJiYgcGFyYW1zLml0ZW1zO1xuICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICB2YXIgdXBkYXRlZERhdGEgPSBbXTtcbiAgICB2YXIgYWRkZWQgPSBbXTtcbiAgICB2YXIgdXBkYXRlZCA9IFtdO1xuICAgIHZhciByZW1vdmVkID0gW107XG5cbiAgICBpZiAoaWRzICYmIGRhdGEpIHtcbiAgICAgIHN3aXRjaCAoZXZlbnQpIHtcbiAgICAgICAgY2FzZSAnYWRkJzpcbiAgICAgICAgICAvLyBmaWx0ZXIgdGhlIGlkcyBvZiB0aGUgYWRkZWQgaXRlbXNcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlkID0gaWRzW2ldO1xuICAgICAgICAgICAgaXRlbSA9IHRoaXMuZ2V0KGlkKTtcbiAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2lkc1tpZF0gPSB0cnVlO1xuICAgICAgICAgICAgICBhZGRlZC5wdXNoKGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd1cGRhdGUnOlxuICAgICAgICAgIC8vIGRldGVybWluZSB0aGUgZXZlbnQgZnJvbSB0aGUgdmlld3Mgdmlld3BvaW50OiBhbiB1cGRhdGVkXG4gICAgICAgICAgLy8gaXRlbSBjYW4gYmUgYWRkZWQsIHVwZGF0ZWQsIG9yIHJlbW92ZWQgZnJvbSB0aGlzIHZpZXcuXG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gaWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZCA9IGlkc1tpXTtcbiAgICAgICAgICAgIGl0ZW0gPSB0aGlzLmdldChpZCk7XG5cbiAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9pZHNbaWRdKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlZC5wdXNoKGlkKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVkRGF0YS5wdXNoKHBhcmFtcy5kYXRhW2ldKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pZHNbaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhZGRlZC5wdXNoKGlkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2lkc1tpZF0pIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5faWRzW2lkXTtcbiAgICAgICAgICAgICAgICByZW1vdmVkLnB1c2goaWQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG5vdGhpbmcgaW50ZXJlc3RpbmcgZm9yIG1lIDotKFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncmVtb3ZlJzpcbiAgICAgICAgICAvLyBmaWx0ZXIgdGhlIGlkcyBvZiB0aGUgcmVtb3ZlZCBpdGVtc1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWQgPSBpZHNbaV07XG4gICAgICAgICAgICBpZiAodGhpcy5faWRzW2lkXSkge1xuICAgICAgICAgICAgICBkZWxldGUgdGhpcy5faWRzW2lkXTtcbiAgICAgICAgICAgICAgcmVtb3ZlZC5wdXNoKGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdGhpcy5sZW5ndGggKz0gYWRkZWQubGVuZ3RoIC0gcmVtb3ZlZC5sZW5ndGg7XG5cbiAgICAgIGlmIChhZGRlZC5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fdHJpZ2dlcignYWRkJywgeyBpdGVtczogYWRkZWQgfSwgc2VuZGVySWQpO1xuICAgICAgfVxuICAgICAgaWYgKHVwZGF0ZWQubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX3RyaWdnZXIoJ3VwZGF0ZScsIHsgaXRlbXM6IHVwZGF0ZWQsIGRhdGE6IHVwZGF0ZWREYXRhIH0sIHNlbmRlcklkKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZW1vdmVkLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl90cmlnZ2VyKCdyZW1vdmUnLCB7IGl0ZW1zOiByZW1vdmVkIH0sIHNlbmRlcklkKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gY29weSBzdWJzY3JpcHRpb24gZnVuY3Rpb25hbGl0eSBmcm9tIERhdGFTZXRcbiAgRGF0YVZpZXcucHJvdG90eXBlLm9uID0gRGF0YVNldC5wcm90b3R5cGUub247XG4gIERhdGFWaWV3LnByb3RvdHlwZS5vZmYgPSBEYXRhU2V0LnByb3RvdHlwZS5vZmY7XG4gIERhdGFWaWV3LnByb3RvdHlwZS5fdHJpZ2dlciA9IERhdGFTZXQucHJvdG90eXBlLl90cmlnZ2VyO1xuXG4gIC8vIFRPRE86IG1ha2UgdGhlc2UgZnVuY3Rpb25zIGRlcHJlY2F0ZWQgKHJlcGxhY2VkIHdpdGggYG9uYCBhbmQgYG9mZmAgc2luY2UgdmVyc2lvbiAwLjUpXG4gIERhdGFWaWV3LnByb3RvdHlwZS5zdWJzY3JpYmUgPSBEYXRhVmlldy5wcm90b3R5cGUub247XG4gIERhdGFWaWV3LnByb3RvdHlwZS51bnN1YnNjcmliZSA9IERhdGFWaWV3LnByb3RvdHlwZS5vZmY7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBEYXRhVmlldztcblxuLyoqKi8gfSxcbi8qIDEyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbiAgdmFyIEVtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcbiAgdmFyIERhdGFTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuICB2YXIgRGF0YVZpZXcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcbiAgdmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuICB2YXIgUG9pbnQzZCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuICB2YXIgUG9pbnQyZCA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xuICB2YXIgQ2FtZXJhID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG4gIHZhciBGaWx0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcbiAgdmFyIFNsaWRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xuICB2YXIgU3RlcE51bWJlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3IgR3JhcGgzZFxuICAgKiBHcmFwaDNkIGRpc3BsYXlzIGRhdGEgaW4gM2QuXG4gICAqXG4gICAqIEdyYXBoM2QgaXMgZGV2ZWxvcGVkIGluIGphdmFzY3JpcHQgYXMgYSBHb29nbGUgVmlzdWFsaXphdGlvbiBDaGFydC5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZXIgICBUaGUgRE9NIGVsZW1lbnQgaW4gd2hpY2ggdGhlIEdyYXBoM2Qgd2lsbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlIGNyZWF0ZWQuIE5vcm1hbGx5IGEgZGl2IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7RGF0YVNldCB8IERhdGFWaWV3IHwgQXJyYXl9IFtkYXRhXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqL1xuICBmdW5jdGlvbiBHcmFwaDNkKGNvbnRhaW5lciwgZGF0YSwgb3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBHcmFwaDNkKSkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdDb25zdHJ1Y3RvciBtdXN0IGJlIGNhbGxlZCB3aXRoIHRoZSBuZXcgb3BlcmF0b3InKTtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgdmFyaWFibGVzIGFuZCBzZXQgZGVmYXVsdCB2YWx1ZXNcbiAgICB0aGlzLmNvbnRhaW5lckVsZW1lbnQgPSBjb250YWluZXI7XG4gICAgdGhpcy53aWR0aCA9ICc0MDBweCc7XG4gICAgdGhpcy5oZWlnaHQgPSAnNDAwcHgnO1xuICAgIHRoaXMubWFyZ2luID0gMTA7IC8vIHB4XG4gICAgdGhpcy5kZWZhdWx0WENlbnRlciA9ICc1NSUnO1xuICAgIHRoaXMuZGVmYXVsdFlDZW50ZXIgPSAnNTAlJztcblxuICAgIHRoaXMueExhYmVsID0gJ3gnO1xuICAgIHRoaXMueUxhYmVsID0gJ3knO1xuICAgIHRoaXMuekxhYmVsID0gJ3onO1xuXG4gICAgdmFyIHBhc3NWYWx1ZUZuID0gZnVuY3Rpb24gcGFzc1ZhbHVlRm4odikge1xuICAgICAgcmV0dXJuIHY7XG4gICAgfTtcbiAgICB0aGlzLnhWYWx1ZUxhYmVsID0gcGFzc1ZhbHVlRm47XG4gICAgdGhpcy55VmFsdWVMYWJlbCA9IHBhc3NWYWx1ZUZuO1xuICAgIHRoaXMuelZhbHVlTGFiZWwgPSBwYXNzVmFsdWVGbjtcblxuICAgIHRoaXMuZmlsdGVyTGFiZWwgPSAndGltZSc7XG4gICAgdGhpcy5sZWdlbmRMYWJlbCA9ICd2YWx1ZSc7XG5cbiAgICB0aGlzLnN0eWxlID0gR3JhcGgzZC5TVFlMRS5ET1Q7XG4gICAgdGhpcy5zaG93UGVyc3BlY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMuc2hvd0dyaWQgPSB0cnVlO1xuICAgIHRoaXMua2VlcEFzcGVjdFJhdGlvID0gdHJ1ZTtcbiAgICB0aGlzLnNob3dTaGFkb3cgPSBmYWxzZTtcbiAgICB0aGlzLnNob3dHcmF5Qm90dG9tID0gZmFsc2U7IC8vIFRPRE86IHRoaXMgZG9lcyBub3Qgd29yayBjb3JyZWN0bHlcbiAgICB0aGlzLnNob3dUb29sdGlwID0gZmFsc2U7XG4gICAgdGhpcy52ZXJ0aWNhbFJhdGlvID0gMC41OyAvLyAwLjEgdG8gMS4wLCB3aGVyZSAxLjAgcmVzdWx0cyBpbiBhICdjdWJlJ1xuXG4gICAgdGhpcy5hbmltYXRpb25JbnRlcnZhbCA9IDEwMDA7IC8vIG1pbGxpc2Vjb25kc1xuICAgIHRoaXMuYW5pbWF0aW9uUHJlbG9hZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5jYW1lcmEgPSBuZXcgQ2FtZXJhKCk7XG4gICAgdGhpcy5jYW1lcmEuc2V0QXJtUm90YXRpb24oMS4wLCAwLjUpO1xuICAgIHRoaXMuY2FtZXJhLnNldEFybUxlbmd0aCgxLjcpO1xuICAgIHRoaXMuZXllID0gbmV3IFBvaW50M2QoMCwgMCwgLTEpOyAvLyBUT0RPOiBzZXQgZXllLnogYWJvdXQgMy80IG9mIHRoZSB3aWR0aCBvZiB0aGUgd2luZG93P1xuXG4gICAgdGhpcy5kYXRhVGFibGUgPSBudWxsOyAvLyBUaGUgb3JpZ2luYWwgZGF0YSB0YWJsZVxuICAgIHRoaXMuZGF0YVBvaW50cyA9IG51bGw7IC8vIFRoZSB0YWJsZSB3aXRoIHBvaW50IG9iamVjdHNcblxuICAgIC8vIHRoZSBjb2x1bW4gaW5kZXhlc1xuICAgIHRoaXMuY29sWCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNvbFkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jb2xaID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY29sVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jb2xGaWx0ZXIgPSB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLnhNaW4gPSAwO1xuICAgIHRoaXMueFN0ZXAgPSB1bmRlZmluZWQ7IC8vIGF1dG8gYnkgZGVmYXVsdFxuICAgIHRoaXMueE1heCA9IDE7XG4gICAgdGhpcy55TWluID0gMDtcbiAgICB0aGlzLnlTdGVwID0gdW5kZWZpbmVkOyAvLyBhdXRvIGJ5IGRlZmF1bHRcbiAgICB0aGlzLnlNYXggPSAxO1xuICAgIHRoaXMuek1pbiA9IDA7XG4gICAgdGhpcy56U3RlcCA9IHVuZGVmaW5lZDsgLy8gYXV0byBieSBkZWZhdWx0XG4gICAgdGhpcy56TWF4ID0gMTtcbiAgICB0aGlzLnZhbHVlTWluID0gMDtcbiAgICB0aGlzLnZhbHVlTWF4ID0gMTtcbiAgICB0aGlzLnhCYXJXaWR0aCA9IDE7XG4gICAgdGhpcy55QmFyV2lkdGggPSAxO1xuICAgIC8vIFRPRE86IGN1c3RvbWl6ZSBheGlzIHJhbmdlXG5cbiAgICAvLyBjb2xvcnNcbiAgICB0aGlzLmF4aXNDb2xvciA9ICcjNEQ0RDREJztcbiAgICB0aGlzLmdyaWRDb2xvciA9ICcjRDNEM0QzJztcbiAgICB0aGlzLmRhdGFDb2xvciA9IHtcbiAgICAgIGZpbGw6ICcjN0RDMUZGJyxcbiAgICAgIHN0cm9rZTogJyMzMjY3RDInLFxuICAgICAgc3Ryb2tlV2lkdGg6IDEgLy8gcHhcbiAgICB9O1xuXG4gICAgdGhpcy5kb3RTaXplUmF0aW8gPSAwLjAyOyAvLyBzaXplIG9mIHRoZSBkb3RzIGFzIGEgZnJhY3Rpb24gb2YgdGhlIGdyYXBoIHdpZHRoXG5cbiAgICAvLyBjcmVhdGUgYSBmcmFtZSBhbmQgY2FudmFzXG4gICAgdGhpcy5jcmVhdGUoKTtcblxuICAgIC8vIGFwcGx5IG9wdGlvbnMgKGFsc28gd2hlbiB1bmRlZmluZWQpXG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgLy8gYXBwbHkgZGF0YVxuICAgIGlmIChkYXRhKSB7XG4gICAgICB0aGlzLnNldERhdGEoZGF0YSk7XG4gICAgfVxuICB9XG5cbiAgLy8gRXh0ZW5kIEdyYXBoM2Qgd2l0aCBhbiBFbWl0dGVyIG1peGluXG4gIEVtaXR0ZXIoR3JhcGgzZC5wcm90b3R5cGUpO1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIHNjYWxpbmcgdmFsdWVzLCBkZXBlbmRlbnQgb24gdGhlIHJhbmdlIGluIHgsIHksIGFuZCB6IGRpcmVjdGlvblxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX3NldFNjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2NhbGUgPSBuZXcgUG9pbnQzZCgxIC8gKHRoaXMueE1heCAtIHRoaXMueE1pbiksIDEgLyAodGhpcy55TWF4IC0gdGhpcy55TWluKSwgMSAvICh0aGlzLnpNYXggLSB0aGlzLnpNaW4pKTtcblxuICAgIC8vIGtlZXAgYXNwZWN0IHJhdGlvbiBiZXR3ZWVuIHggYW5kIHkgc2NhbGUgaWYgZGVzaXJlZFxuICAgIGlmICh0aGlzLmtlZXBBc3BlY3RSYXRpbykge1xuICAgICAgaWYgKHRoaXMuc2NhbGUueCA8IHRoaXMuc2NhbGUueSkge1xuICAgICAgICAvL25vaW5zcGVjdGlvbiBKU1N1c3BpY2lvdXNOYW1lQ29tYmluYXRpb25cbiAgICAgICAgdGhpcy5zY2FsZS55ID0gdGhpcy5zY2FsZS54O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9ub2luc3BlY3Rpb24gSlNTdXNwaWNpb3VzTmFtZUNvbWJpbmF0aW9uXG4gICAgICAgIHRoaXMuc2NhbGUueCA9IHRoaXMuc2NhbGUueTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzY2FsZSB0aGUgdmVydGljYWwgYXhpc1xuICAgIHRoaXMuc2NhbGUueiAqPSB0aGlzLnZlcnRpY2FsUmF0aW87XG4gICAgLy8gVE9ETzogY2FuIHRoaXMgYmUgYXV0b21hdGVkPyB2ZXJ0aWNhbFJhdGlvP1xuXG4gICAgLy8gZGV0ZXJtaW5lIHNjYWxlIGZvciAob3B0aW9uYWwpIHZhbHVlXG4gICAgdGhpcy5zY2FsZS52YWx1ZSA9IDEgLyAodGhpcy52YWx1ZU1heCAtIHRoaXMudmFsdWVNaW4pO1xuXG4gICAgLy8gcG9zaXRpb24gdGhlIGNhbWVyYSBhcm1cbiAgICB2YXIgeENlbnRlciA9ICh0aGlzLnhNYXggKyB0aGlzLnhNaW4pIC8gMiAqIHRoaXMuc2NhbGUueDtcbiAgICB2YXIgeUNlbnRlciA9ICh0aGlzLnlNYXggKyB0aGlzLnlNaW4pIC8gMiAqIHRoaXMuc2NhbGUueTtcbiAgICB2YXIgekNlbnRlciA9ICh0aGlzLnpNYXggKyB0aGlzLnpNaW4pIC8gMiAqIHRoaXMuc2NhbGUuejtcbiAgICB0aGlzLmNhbWVyYS5zZXRBcm1Mb2NhdGlvbih4Q2VudGVyLCB5Q2VudGVyLCB6Q2VudGVyKTtcbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydCBhIDNEIGxvY2F0aW9uIHRvIGEgMkQgbG9jYXRpb24gb24gc2NyZWVuXG4gICAqIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvM0RfcHJvamVjdGlvblxuICAgKiBAcGFyYW0ge1BvaW50M2R9IHBvaW50M2QgICBBIDNEIHBvaW50IHdpdGggcGFyYW1ldGVycyB4LCB5LCB6XG4gICAqIEByZXR1cm4ge1BvaW50MmR9IHBvaW50MmQgIEEgMkQgcG9pbnQgd2l0aCBwYXJhbWV0ZXJzIHgsIHlcbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLl9jb252ZXJ0M0R0bzJEID0gZnVuY3Rpb24gKHBvaW50M2QpIHtcbiAgICB2YXIgdHJhbnNsYXRpb24gPSB0aGlzLl9jb252ZXJ0UG9pbnRUb1RyYW5zbGF0aW9uKHBvaW50M2QpO1xuICAgIHJldHVybiB0aGlzLl9jb252ZXJ0VHJhbnNsYXRpb25Ub1NjcmVlbih0cmFuc2xhdGlvbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSAzRCBsb2NhdGlvbiBpdHMgdHJhbnNsYXRpb24gc2VlbiBmcm9tIHRoZSBjYW1lcmFcbiAgICogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS8zRF9wcm9qZWN0aW9uXG4gICAqIEBwYXJhbSB7UG9pbnQzZH0gcG9pbnQzZCAgICBBIDNEIHBvaW50IHdpdGggcGFyYW1ldGVycyB4LCB5LCB6XG4gICAqIEByZXR1cm4ge1BvaW50M2R9IHRyYW5zbGF0aW9uIEEgM0QgcG9pbnQgd2l0aCBwYXJhbWV0ZXJzIHgsIHksIHogVGhpcyBpc1xuICAgKiAgICAgICAgICAgICAgICAgICB0aGUgdHJhbnNsYXRpb24gb2YgdGhlIHBvaW50LCBzZWVuIGZyb20gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgIGNhbWVyYVxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX2NvbnZlcnRQb2ludFRvVHJhbnNsYXRpb24gPSBmdW5jdGlvbiAocG9pbnQzZCkge1xuICAgIHZhciBheCA9IHBvaW50M2QueCAqIHRoaXMuc2NhbGUueCxcbiAgICAgICAgYXkgPSBwb2ludDNkLnkgKiB0aGlzLnNjYWxlLnksXG4gICAgICAgIGF6ID0gcG9pbnQzZC56ICogdGhpcy5zY2FsZS56LFxuICAgICAgICBjeCA9IHRoaXMuY2FtZXJhLmdldENhbWVyYUxvY2F0aW9uKCkueCxcbiAgICAgICAgY3kgPSB0aGlzLmNhbWVyYS5nZXRDYW1lcmFMb2NhdGlvbigpLnksXG4gICAgICAgIGN6ID0gdGhpcy5jYW1lcmEuZ2V0Q2FtZXJhTG9jYXRpb24oKS56LFxuXG5cbiAgICAvLyBjYWxjdWxhdGUgYW5nbGVzXG4gICAgc2luVHggPSBNYXRoLnNpbih0aGlzLmNhbWVyYS5nZXRDYW1lcmFSb3RhdGlvbigpLngpLFxuICAgICAgICBjb3NUeCA9IE1hdGguY29zKHRoaXMuY2FtZXJhLmdldENhbWVyYVJvdGF0aW9uKCkueCksXG4gICAgICAgIHNpblR5ID0gTWF0aC5zaW4odGhpcy5jYW1lcmEuZ2V0Q2FtZXJhUm90YXRpb24oKS55KSxcbiAgICAgICAgY29zVHkgPSBNYXRoLmNvcyh0aGlzLmNhbWVyYS5nZXRDYW1lcmFSb3RhdGlvbigpLnkpLFxuICAgICAgICBzaW5UeiA9IE1hdGguc2luKHRoaXMuY2FtZXJhLmdldENhbWVyYVJvdGF0aW9uKCkueiksXG4gICAgICAgIGNvc1R6ID0gTWF0aC5jb3ModGhpcy5jYW1lcmEuZ2V0Q2FtZXJhUm90YXRpb24oKS56KSxcblxuXG4gICAgLy8gY2FsY3VsYXRlIHRyYW5zbGF0aW9uXG4gICAgZHggPSBjb3NUeSAqIChzaW5UeiAqIChheSAtIGN5KSArIGNvc1R6ICogKGF4IC0gY3gpKSAtIHNpblR5ICogKGF6IC0gY3opLFxuICAgICAgICBkeSA9IHNpblR4ICogKGNvc1R5ICogKGF6IC0gY3opICsgc2luVHkgKiAoc2luVHogKiAoYXkgLSBjeSkgKyBjb3NUeiAqIChheCAtIGN4KSkpICsgY29zVHggKiAoY29zVHogKiAoYXkgLSBjeSkgLSBzaW5UeiAqIChheCAtIGN4KSksXG4gICAgICAgIGR6ID0gY29zVHggKiAoY29zVHkgKiAoYXogLSBjeikgKyBzaW5UeSAqIChzaW5UeiAqIChheSAtIGN5KSArIGNvc1R6ICogKGF4IC0gY3gpKSkgLSBzaW5UeCAqIChjb3NUeiAqIChheSAtIGN5KSAtIHNpblR6ICogKGF4IC0gY3gpKTtcblxuICAgIHJldHVybiBuZXcgUG9pbnQzZChkeCwgZHksIGR6KTtcbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydCBhIHRyYW5zbGF0aW9uIHBvaW50IHRvIGEgcG9pbnQgb24gdGhlIHNjcmVlblxuICAgKiBAcGFyYW0ge1BvaW50M2R9IHRyYW5zbGF0aW9uICAgQSAzRCBwb2ludCB3aXRoIHBhcmFtZXRlcnMgeCwgeSwgeiBUaGlzIGlzXG4gICAqICAgICAgICAgICAgICAgICAgICB0aGUgdHJhbnNsYXRpb24gb2YgdGhlIHBvaW50LCBzZWVuIGZyb20gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICBjYW1lcmFcbiAgICogQHJldHVybiB7UG9pbnQyZH0gcG9pbnQyZCAgICBBIDJEIHBvaW50IHdpdGggcGFyYW1ldGVycyB4LCB5XG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5fY29udmVydFRyYW5zbGF0aW9uVG9TY3JlZW4gPSBmdW5jdGlvbiAodHJhbnNsYXRpb24pIHtcbiAgICB2YXIgZXggPSB0aGlzLmV5ZS54LFxuICAgICAgICBleSA9IHRoaXMuZXllLnksXG4gICAgICAgIGV6ID0gdGhpcy5leWUueixcbiAgICAgICAgZHggPSB0cmFuc2xhdGlvbi54LFxuICAgICAgICBkeSA9IHRyYW5zbGF0aW9uLnksXG4gICAgICAgIGR6ID0gdHJhbnNsYXRpb24uejtcblxuICAgIC8vIGNhbGN1bGF0ZSBwb3NpdGlvbiBvbiBzY3JlZW4gZnJvbSB0cmFuc2xhdGlvblxuICAgIHZhciBieDtcbiAgICB2YXIgYnk7XG4gICAgaWYgKHRoaXMuc2hvd1BlcnNwZWN0aXZlKSB7XG4gICAgICBieCA9IChkeCAtIGV4KSAqIChleiAvIGR6KTtcbiAgICAgIGJ5ID0gKGR5IC0gZXkpICogKGV6IC8gZHopO1xuICAgIH0gZWxzZSB7XG4gICAgICBieCA9IGR4ICogLShleiAvIHRoaXMuY2FtZXJhLmdldEFybUxlbmd0aCgpKTtcbiAgICAgIGJ5ID0gZHkgKiAtKGV6IC8gdGhpcy5jYW1lcmEuZ2V0QXJtTGVuZ3RoKCkpO1xuICAgIH1cblxuICAgIC8vIHNoaWZ0IGFuZCBzY2FsZSB0aGUgcG9pbnQgdG8gdGhlIGNlbnRlciBvZiB0aGUgc2NyZWVuXG4gICAgLy8gdXNlIHRoZSB3aWR0aCBvZiB0aGUgZ3JhcGggdG8gc2NhbGUgYm90aCBob3Jpem9udGFsbHkgYW5kIHZlcnRpY2FsbHkuXG4gICAgcmV0dXJuIG5ldyBQb2ludDJkKHRoaXMueGNlbnRlciArIGJ4ICogdGhpcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGgsIHRoaXMueWNlbnRlciAtIGJ5ICogdGhpcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGJhY2tncm91bmQgc3R5bGluZyBmb3IgdGhlIGdyYXBoXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwge2ZpbGw6IHN0cmluZywgc3Ryb2tlOiBzdHJpbmcsIHN0cm9rZVdpZHRoOiBzdHJpbmd9fSBiYWNrZ3JvdW5kQ29sb3JcbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLl9zZXRCYWNrZ3JvdW5kQ29sb3IgPSBmdW5jdGlvbiAoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgdmFyIGZpbGwgPSAnd2hpdGUnO1xuICAgIHZhciBzdHJva2UgPSAnZ3JheSc7XG4gICAgdmFyIHN0cm9rZVdpZHRoID0gMTtcblxuICAgIGlmICh0eXBlb2YgYmFja2dyb3VuZENvbG9yID09PSAnc3RyaW5nJykge1xuICAgICAgZmlsbCA9IGJhY2tncm91bmRDb2xvcjtcbiAgICAgIHN0cm9rZSA9ICdub25lJztcbiAgICAgIHN0cm9rZVdpZHRoID0gMDtcbiAgICB9IGVsc2UgaWYgKCh0eXBlb2YgYmFja2dyb3VuZENvbG9yID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihiYWNrZ3JvdW5kQ29sb3IpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IuZmlsbCAhPT0gdW5kZWZpbmVkKSBmaWxsID0gYmFja2dyb3VuZENvbG9yLmZpbGw7XG4gICAgICBpZiAoYmFja2dyb3VuZENvbG9yLnN0cm9rZSAhPT0gdW5kZWZpbmVkKSBzdHJva2UgPSBiYWNrZ3JvdW5kQ29sb3Iuc3Ryb2tlO1xuICAgICAgaWYgKGJhY2tncm91bmRDb2xvci5zdHJva2VXaWR0aCAhPT0gdW5kZWZpbmVkKSBzdHJva2VXaWR0aCA9IGJhY2tncm91bmRDb2xvci5zdHJva2VXaWR0aDtcbiAgICB9IGVsc2UgaWYgKGJhY2tncm91bmRDb2xvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyB1c2UgdXNlIGRlZmF1bHRzXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgJ1Vuc3VwcG9ydGVkIHR5cGUgb2YgYmFja2dyb3VuZENvbG9yJztcbiAgICAgIH1cblxuICAgIHRoaXMuZnJhbWUuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gZmlsbDtcbiAgICB0aGlzLmZyYW1lLnN0eWxlLmJvcmRlckNvbG9yID0gc3Ryb2tlO1xuICAgIHRoaXMuZnJhbWUuc3R5bGUuYm9yZGVyV2lkdGggPSBzdHJva2VXaWR0aCArICdweCc7XG4gICAgdGhpcy5mcmFtZS5zdHlsZS5ib3JkZXJTdHlsZSA9ICdzb2xpZCc7XG4gIH07XG5cbiAgLy8vIGVudW1lcmF0ZSB0aGUgYXZhaWxhYmxlIHN0eWxlc1xuICBHcmFwaDNkLlNUWUxFID0ge1xuICAgIEJBUjogMCxcbiAgICBCQVJDT0xPUjogMSxcbiAgICBCQVJTSVpFOiAyLFxuICAgIERPVDogMyxcbiAgICBET1RMSU5FOiA0LFxuICAgIERPVENPTE9SOiA1LFxuICAgIERPVFNJWkU6IDYsXG4gICAgR1JJRDogNyxcbiAgICBMSU5FOiA4LFxuICAgIFNVUkZBQ0U6IDlcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlldmUgdGhlIHN0eWxlIGluZGV4IGZyb20gZ2l2ZW4gc3R5bGVOYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZU5hbWUgIFN0eWxlIG5hbWUgc3VjaCBhcyAnZG90JywgJ2dyaWQnLCAnZG90LWxpbmUnXG4gICAqIEByZXR1cm4ge051bWJlcn0gc3R5bGVOdW1iZXIgRW51bWVyYXRpb24gdmFsdWUgcmVwcmVzZW50aW5nIHRoZSBzdHlsZSwgb3IgLTFcbiAgICogICAgICAgICAgICAgICAgd2hlbiBub3QgZm91bmRcbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLl9nZXRTdHlsZU51bWJlciA9IGZ1bmN0aW9uIChzdHlsZU5hbWUpIHtcbiAgICBzd2l0Y2ggKHN0eWxlTmFtZSkge1xuICAgICAgY2FzZSAnZG90JzpcbiAgICAgICAgcmV0dXJuIEdyYXBoM2QuU1RZTEUuRE9UO1xuICAgICAgY2FzZSAnZG90LWxpbmUnOlxuICAgICAgICByZXR1cm4gR3JhcGgzZC5TVFlMRS5ET1RMSU5FO1xuICAgICAgY2FzZSAnZG90LWNvbG9yJzpcbiAgICAgICAgcmV0dXJuIEdyYXBoM2QuU1RZTEUuRE9UQ09MT1I7XG4gICAgICBjYXNlICdkb3Qtc2l6ZSc6XG4gICAgICAgIHJldHVybiBHcmFwaDNkLlNUWUxFLkRPVFNJWkU7XG4gICAgICBjYXNlICdsaW5lJzpcbiAgICAgICAgcmV0dXJuIEdyYXBoM2QuU1RZTEUuTElORTtcbiAgICAgIGNhc2UgJ2dyaWQnOlxuICAgICAgICByZXR1cm4gR3JhcGgzZC5TVFlMRS5HUklEO1xuICAgICAgY2FzZSAnc3VyZmFjZSc6XG4gICAgICAgIHJldHVybiBHcmFwaDNkLlNUWUxFLlNVUkZBQ0U7XG4gICAgICBjYXNlICdiYXInOlxuICAgICAgICByZXR1cm4gR3JhcGgzZC5TVFlMRS5CQVI7XG4gICAgICBjYXNlICdiYXItY29sb3InOlxuICAgICAgICByZXR1cm4gR3JhcGgzZC5TVFlMRS5CQVJDT0xPUjtcbiAgICAgIGNhc2UgJ2Jhci1zaXplJzpcbiAgICAgICAgcmV0dXJuIEdyYXBoM2QuU1RZTEUuQkFSU0laRTtcbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgLyoqXG4gICAqIERldGVybWluZSB0aGUgaW5kZXhlcyBvZiB0aGUgZGF0YSBjb2x1bW5zLCBiYXNlZCBvbiB0aGUgZ2l2ZW4gc3R5bGUgYW5kIGRhdGFcbiAgICogQHBhcmFtIHtEYXRhU2V0fSBkYXRhXG4gICAqIEBwYXJhbSB7TnVtYmVyfSAgc3R5bGVcbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLl9kZXRlcm1pbmVDb2x1bW5JbmRleGVzID0gZnVuY3Rpb24gKGRhdGEsIHN0eWxlKSB7XG4gICAgaWYgKHRoaXMuc3R5bGUgPT09IEdyYXBoM2QuU1RZTEUuRE9UIHx8IHRoaXMuc3R5bGUgPT09IEdyYXBoM2QuU1RZTEUuRE9UTElORSB8fCB0aGlzLnN0eWxlID09PSBHcmFwaDNkLlNUWUxFLkxJTkUgfHwgdGhpcy5zdHlsZSA9PT0gR3JhcGgzZC5TVFlMRS5HUklEIHx8IHRoaXMuc3R5bGUgPT09IEdyYXBoM2QuU1RZTEUuU1VSRkFDRSB8fCB0aGlzLnN0eWxlID09PSBHcmFwaDNkLlNUWUxFLkJBUikge1xuICAgICAgLy8gMyBjb2x1bW5zIGV4cGVjdGVkLCBhbmQgb3B0aW9uYWxseSBhIDR0aCB3aXRoIGZpbHRlciB2YWx1ZXNcbiAgICAgIHRoaXMuY29sWCA9IDA7XG4gICAgICB0aGlzLmNvbFkgPSAxO1xuICAgICAgdGhpcy5jb2xaID0gMjtcbiAgICAgIHRoaXMuY29sVmFsdWUgPSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChkYXRhLmdldE51bWJlck9mQ29sdW1ucygpID4gMykge1xuICAgICAgICB0aGlzLmNvbEZpbHRlciA9IDM7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0eWxlID09PSBHcmFwaDNkLlNUWUxFLkRPVENPTE9SIHx8IHRoaXMuc3R5bGUgPT09IEdyYXBoM2QuU1RZTEUuRE9UU0laRSB8fCB0aGlzLnN0eWxlID09PSBHcmFwaDNkLlNUWUxFLkJBUkNPTE9SIHx8IHRoaXMuc3R5bGUgPT09IEdyYXBoM2QuU1RZTEUuQkFSU0laRSkge1xuICAgICAgLy8gNCBjb2x1bW5zIGV4cGVjdGVkLCBhbmQgb3B0aW9uYWxseSBhIDV0aCB3aXRoIGZpbHRlciB2YWx1ZXNcbiAgICAgIHRoaXMuY29sWCA9IDA7XG4gICAgICB0aGlzLmNvbFkgPSAxO1xuICAgICAgdGhpcy5jb2xaID0gMjtcbiAgICAgIHRoaXMuY29sVmFsdWUgPSAzO1xuXG4gICAgICBpZiAoZGF0YS5nZXROdW1iZXJPZkNvbHVtbnMoKSA+IDQpIHtcbiAgICAgICAgdGhpcy5jb2xGaWx0ZXIgPSA0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyAnVW5rbm93biBzdHlsZSBcIicgKyB0aGlzLnN0eWxlICsgJ1wiJztcbiAgICB9XG4gIH07XG5cbiAgR3JhcGgzZC5wcm90b3R5cGUuZ2V0TnVtYmVyT2ZSb3dzID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YS5sZW5ndGg7XG4gIH07XG5cbiAgR3JhcGgzZC5wcm90b3R5cGUuZ2V0TnVtYmVyT2ZDb2x1bW5zID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgY291bnRlciA9IDA7XG4gICAgZm9yICh2YXIgY29sdW1uIGluIGRhdGFbMF0pIHtcbiAgICAgIGlmIChkYXRhWzBdLmhhc093blByb3BlcnR5KGNvbHVtbikpIHtcbiAgICAgICAgY291bnRlcisrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcblxuICBHcmFwaDNkLnByb3RvdHlwZS5nZXREaXN0aW5jdFZhbHVlcyA9IGZ1bmN0aW9uIChkYXRhLCBjb2x1bW4pIHtcbiAgICB2YXIgZGlzdGluY3RWYWx1ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChkaXN0aW5jdFZhbHVlcy5pbmRleE9mKGRhdGFbaV1bY29sdW1uXSkgPT0gLTEpIHtcbiAgICAgICAgZGlzdGluY3RWYWx1ZXMucHVzaChkYXRhW2ldW2NvbHVtbl0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGlzdGluY3RWYWx1ZXM7XG4gIH07XG5cbiAgR3JhcGgzZC5wcm90b3R5cGUuZ2V0Q29sdW1uUmFuZ2UgPSBmdW5jdGlvbiAoZGF0YSwgY29sdW1uKSB7XG4gICAgdmFyIG1pbk1heCA9IHsgbWluOiBkYXRhWzBdW2NvbHVtbl0sIG1heDogZGF0YVswXVtjb2x1bW5dIH07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobWluTWF4Lm1pbiA+IGRhdGFbaV1bY29sdW1uXSkge1xuICAgICAgICBtaW5NYXgubWluID0gZGF0YVtpXVtjb2x1bW5dO1xuICAgICAgfVxuICAgICAgaWYgKG1pbk1heC5tYXggPCBkYXRhW2ldW2NvbHVtbl0pIHtcbiAgICAgICAgbWluTWF4Lm1heCA9IGRhdGFbaV1bY29sdW1uXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1pbk1heDtcbiAgfTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgZGF0YSBmcm9tIHRoZSBkYXRhIHRhYmxlLiBDYWxjdWxhdGUgbWluaW11bSBhbmQgbWF4aW11bSB2YWx1ZXNcbiAgICogYW5kIGNvbHVtbiBpbmRleCB2YWx1ZXNcbiAgICogQHBhcmFtIHtBcnJheSB8IERhdGFTZXQgfCBEYXRhVmlld30gcmF3RGF0YSAgIFRoZSBkYXRhIGNvbnRhaW5pbmcgdGhlIGl0ZW1zIGZvciB0aGUgR3JhcGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSAgICAgc3R5bGUgICBTdHlsZSBOdW1iZXJcbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLl9kYXRhSW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChyYXdEYXRhLCBzdHlsZSkge1xuICAgIHZhciBtZSA9IHRoaXM7XG5cbiAgICAvLyB1bnN1YnNjcmliZSBmcm9tIHRoZSBkYXRhVGFibGVcbiAgICBpZiAodGhpcy5kYXRhU2V0KSB7XG4gICAgICB0aGlzLmRhdGFTZXQub2ZmKCcqJywgdGhpcy5fb25DaGFuZ2UpO1xuICAgIH1cblxuICAgIGlmIChyYXdEYXRhID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHJhd0RhdGEpKSB7XG4gICAgICByYXdEYXRhID0gbmV3IERhdGFTZXQocmF3RGF0YSk7XG4gICAgfVxuXG4gICAgdmFyIGRhdGE7XG4gICAgaWYgKHJhd0RhdGEgaW5zdGFuY2VvZiBEYXRhU2V0IHx8IHJhd0RhdGEgaW5zdGFuY2VvZiBEYXRhVmlldykge1xuICAgICAgZGF0YSA9IHJhd0RhdGEuZ2V0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQXJyYXksIERhdGFTZXQsIG9yIERhdGFWaWV3IGV4cGVjdGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEubGVuZ3RoID09IDApIHJldHVybjtcblxuICAgIHRoaXMuZGF0YVNldCA9IHJhd0RhdGE7XG4gICAgdGhpcy5kYXRhVGFibGUgPSBkYXRhO1xuXG4gICAgLy8gc3Vic2NyaWJlIHRvIGNoYW5nZXMgaW4gdGhlIGRhdGFzZXRcbiAgICB0aGlzLl9vbkNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIG1lLnNldERhdGEobWUuZGF0YVNldCk7XG4gICAgfTtcbiAgICB0aGlzLmRhdGFTZXQub24oJyonLCB0aGlzLl9vbkNoYW5nZSk7XG5cbiAgICAvLyBfZGV0ZXJtaW5lQ29sdW1uSW5kZXhlc1xuICAgIC8vIGdldE51bWJlck9mUm93cyAocG9pbnRzKVxuICAgIC8vIGdldE51bWJlck9mQ29sdW1ucyAoeCx5LHosdix0LHQxLHQyLi4uKVxuICAgIC8vIGdldERpc3RpbmN0VmFsdWVzICh1bmlxdWUgdmFsdWVzPylcbiAgICAvLyBnZXRDb2x1bW5SYW5nZVxuXG4gICAgLy8gZGV0ZXJtaW5lIHRoZSBsb2NhdGlvbiBvZiB4LHkseix2YWx1ZSxmaWx0ZXIgY29sdW1uc1xuICAgIHRoaXMuY29sWCA9ICd4JztcbiAgICB0aGlzLmNvbFkgPSAneSc7XG4gICAgdGhpcy5jb2xaID0gJ3onO1xuICAgIHRoaXMuY29sVmFsdWUgPSAnc3R5bGUnO1xuICAgIHRoaXMuY29sRmlsdGVyID0gJ2ZpbHRlcic7XG5cbiAgICAvLyBjaGVjayBpZiBhIGZpbHRlciBjb2x1bW4gaXMgcHJvdmlkZWRcbiAgICBpZiAoZGF0YVswXS5oYXNPd25Qcm9wZXJ0eSgnZmlsdGVyJykpIHtcbiAgICAgIGlmICh0aGlzLmRhdGFGaWx0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmRhdGFGaWx0ZXIgPSBuZXcgRmlsdGVyKHJhd0RhdGEsIHRoaXMuY29sRmlsdGVyLCB0aGlzKTtcbiAgICAgICAgdGhpcy5kYXRhRmlsdGVyLnNldE9uTG9hZENhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBtZS5yZWRyYXcoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHdpdGhCYXJzID0gdGhpcy5zdHlsZSA9PSBHcmFwaDNkLlNUWUxFLkJBUiB8fCB0aGlzLnN0eWxlID09IEdyYXBoM2QuU1RZTEUuQkFSQ09MT1IgfHwgdGhpcy5zdHlsZSA9PSBHcmFwaDNkLlNUWUxFLkJBUlNJWkU7XG5cbiAgICAvLyBkZXRlcm1pbmUgYmFyV2lkdGggZnJvbSBkYXRhXG4gICAgaWYgKHdpdGhCYXJzKSB7XG4gICAgICBpZiAodGhpcy5kZWZhdWx0WEJhcldpZHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy54QmFyV2lkdGggPSB0aGlzLmRlZmF1bHRYQmFyV2lkdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZGF0YVggPSB0aGlzLmdldERpc3RpbmN0VmFsdWVzKGRhdGEsIHRoaXMuY29sWCk7XG4gICAgICAgIHRoaXMueEJhcldpZHRoID0gZGF0YVhbMV0gLSBkYXRhWFswXSB8fCAxO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5kZWZhdWx0WUJhcldpZHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy55QmFyV2lkdGggPSB0aGlzLmRlZmF1bHRZQmFyV2lkdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZGF0YVkgPSB0aGlzLmdldERpc3RpbmN0VmFsdWVzKGRhdGEsIHRoaXMuY29sWSk7XG4gICAgICAgIHRoaXMueUJhcldpZHRoID0gZGF0YVlbMV0gLSBkYXRhWVswXSB8fCAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNhbGN1bGF0ZSBtaW5pbXVtcyBhbmQgbWF4aW11bXNcbiAgICB2YXIgeFJhbmdlID0gdGhpcy5nZXRDb2x1bW5SYW5nZShkYXRhLCB0aGlzLmNvbFgpO1xuICAgIGlmICh3aXRoQmFycykge1xuICAgICAgeFJhbmdlLm1pbiAtPSB0aGlzLnhCYXJXaWR0aCAvIDI7XG4gICAgICB4UmFuZ2UubWF4ICs9IHRoaXMueEJhcldpZHRoIC8gMjtcbiAgICB9XG4gICAgdGhpcy54TWluID0gdGhpcy5kZWZhdWx0WE1pbiAhPT0gdW5kZWZpbmVkID8gdGhpcy5kZWZhdWx0WE1pbiA6IHhSYW5nZS5taW47XG4gICAgdGhpcy54TWF4ID0gdGhpcy5kZWZhdWx0WE1heCAhPT0gdW5kZWZpbmVkID8gdGhpcy5kZWZhdWx0WE1heCA6IHhSYW5nZS5tYXg7XG4gICAgaWYgKHRoaXMueE1heCA8PSB0aGlzLnhNaW4pIHRoaXMueE1heCA9IHRoaXMueE1pbiArIDE7XG4gICAgdGhpcy54U3RlcCA9IHRoaXMuZGVmYXVsdFhTdGVwICE9PSB1bmRlZmluZWQgPyB0aGlzLmRlZmF1bHRYU3RlcCA6ICh0aGlzLnhNYXggLSB0aGlzLnhNaW4pIC8gNTtcblxuICAgIHZhciB5UmFuZ2UgPSB0aGlzLmdldENvbHVtblJhbmdlKGRhdGEsIHRoaXMuY29sWSk7XG4gICAgaWYgKHdpdGhCYXJzKSB7XG4gICAgICB5UmFuZ2UubWluIC09IHRoaXMueUJhcldpZHRoIC8gMjtcbiAgICAgIHlSYW5nZS5tYXggKz0gdGhpcy55QmFyV2lkdGggLyAyO1xuICAgIH1cbiAgICB0aGlzLnlNaW4gPSB0aGlzLmRlZmF1bHRZTWluICE9PSB1bmRlZmluZWQgPyB0aGlzLmRlZmF1bHRZTWluIDogeVJhbmdlLm1pbjtcbiAgICB0aGlzLnlNYXggPSB0aGlzLmRlZmF1bHRZTWF4ICE9PSB1bmRlZmluZWQgPyB0aGlzLmRlZmF1bHRZTWF4IDogeVJhbmdlLm1heDtcbiAgICBpZiAodGhpcy55TWF4IDw9IHRoaXMueU1pbikgdGhpcy55TWF4ID0gdGhpcy55TWluICsgMTtcbiAgICB0aGlzLnlTdGVwID0gdGhpcy5kZWZhdWx0WVN0ZXAgIT09IHVuZGVmaW5lZCA/IHRoaXMuZGVmYXVsdFlTdGVwIDogKHRoaXMueU1heCAtIHRoaXMueU1pbikgLyA1O1xuXG4gICAgdmFyIHpSYW5nZSA9IHRoaXMuZ2V0Q29sdW1uUmFuZ2UoZGF0YSwgdGhpcy5jb2xaKTtcbiAgICB0aGlzLnpNaW4gPSB0aGlzLmRlZmF1bHRaTWluICE9PSB1bmRlZmluZWQgPyB0aGlzLmRlZmF1bHRaTWluIDogelJhbmdlLm1pbjtcbiAgICB0aGlzLnpNYXggPSB0aGlzLmRlZmF1bHRaTWF4ICE9PSB1bmRlZmluZWQgPyB0aGlzLmRlZmF1bHRaTWF4IDogelJhbmdlLm1heDtcbiAgICBpZiAodGhpcy56TWF4IDw9IHRoaXMuek1pbikgdGhpcy56TWF4ID0gdGhpcy56TWluICsgMTtcbiAgICB0aGlzLnpTdGVwID0gdGhpcy5kZWZhdWx0WlN0ZXAgIT09IHVuZGVmaW5lZCA/IHRoaXMuZGVmYXVsdFpTdGVwIDogKHRoaXMuek1heCAtIHRoaXMuek1pbikgLyA1O1xuXG4gICAgaWYgKHRoaXMuY29sVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHZhbHVlUmFuZ2UgPSB0aGlzLmdldENvbHVtblJhbmdlKGRhdGEsIHRoaXMuY29sVmFsdWUpO1xuICAgICAgdGhpcy52YWx1ZU1pbiA9IHRoaXMuZGVmYXVsdFZhbHVlTWluICE9PSB1bmRlZmluZWQgPyB0aGlzLmRlZmF1bHRWYWx1ZU1pbiA6IHZhbHVlUmFuZ2UubWluO1xuICAgICAgdGhpcy52YWx1ZU1heCA9IHRoaXMuZGVmYXVsdFZhbHVlTWF4ICE9PSB1bmRlZmluZWQgPyB0aGlzLmRlZmF1bHRWYWx1ZU1heCA6IHZhbHVlUmFuZ2UubWF4O1xuICAgICAgaWYgKHRoaXMudmFsdWVNYXggPD0gdGhpcy52YWx1ZU1pbikgdGhpcy52YWx1ZU1heCA9IHRoaXMudmFsdWVNaW4gKyAxO1xuICAgIH1cblxuICAgIC8vIHNldCB0aGUgc2NhbGUgZGVwZW5kZW50IG9uIHRoZSByYW5nZXMuXG4gICAgdGhpcy5fc2V0U2NhbGUoKTtcbiAgfTtcblxuICAvKipcbiAgICogRmlsdGVyIHRoZSBkYXRhIGJhc2VkIG9uIHRoZSBjdXJyZW50IGZpbHRlclxuICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhXG4gICAqIEByZXR1cm4ge0FycmF5fSBkYXRhUG9pbnRzICAgQXJyYXkgd2l0aCBwb2ludCBvYmplY3RzIHdoaWNoIGNhbiBiZSBkcmF3biBvbiBzY3JlZW5cbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLl9nZXREYXRhUG9pbnRzID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAvLyBUT0RPOiBzdG9yZSB0aGUgY3JlYXRlZCBtYXRyaXggZGF0YVBvaW50cyBpbiB0aGUgZmlsdGVycyBpbnN0ZWFkIG9mIHJlbG9hZGluZyBlYWNoIHRpbWVcbiAgICB2YXIgeCwgeSwgaSwgeiwgb2JqLCBwb2ludDtcblxuICAgIHZhciBkYXRhUG9pbnRzID0gW107XG5cbiAgICBpZiAodGhpcy5zdHlsZSA9PT0gR3JhcGgzZC5TVFlMRS5HUklEIHx8IHRoaXMuc3R5bGUgPT09IEdyYXBoM2QuU1RZTEUuU1VSRkFDRSkge1xuICAgICAgLy8gY29weSBhbGwgdmFsdWVzIGZyb20gdGhlIGdvb2dsZSBkYXRhIHRhYmxlIHRvIGEgbWF0cml4XG4gICAgICAvLyB0aGUgcHJvdmlkZWQgdmFsdWVzIGFyZSBzdXBwb3NlZCB0byBmb3JtIGEgZ3JpZCBvZiAoeCx5KSBwb3NpdGlvbnNcblxuICAgICAgLy8gY3JlYXRlIHR3byBsaXN0cyB3aXRoIGFsbCBwcmVzZW50IHggYW5kIHkgdmFsdWVzXG4gICAgICB2YXIgZGF0YVggPSBbXTtcbiAgICAgIHZhciBkYXRhWSA9IFtdO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZ2V0TnVtYmVyT2ZSb3dzKGRhdGEpOyBpKyspIHtcbiAgICAgICAgeCA9IGRhdGFbaV1bdGhpcy5jb2xYXSB8fCAwO1xuICAgICAgICB5ID0gZGF0YVtpXVt0aGlzLmNvbFldIHx8IDA7XG5cbiAgICAgICAgaWYgKGRhdGFYLmluZGV4T2YoeCkgPT09IC0xKSB7XG4gICAgICAgICAgZGF0YVgucHVzaCh4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YVkuaW5kZXhPZih5KSA9PT0gLTEpIHtcbiAgICAgICAgICBkYXRhWS5wdXNoKHkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3J0TnVtYmVyID0gZnVuY3Rpb24gc29ydE51bWJlcihhLCBiKSB7XG4gICAgICAgIHJldHVybiBhIC0gYjtcbiAgICAgIH07XG4gICAgICBkYXRhWC5zb3J0KHNvcnROdW1iZXIpO1xuICAgICAgZGF0YVkuc29ydChzb3J0TnVtYmVyKTtcblxuICAgICAgLy8gY3JlYXRlIGEgZ3JpZCwgYSAyZCBtYXRyaXgsIHdpdGggYWxsIHZhbHVlcy5cbiAgICAgIHZhciBkYXRhTWF0cml4ID0gW107IC8vIHRlbXBvcmFyeSBkYXRhIG1hdHJpeFxuICAgICAgZm9yIChpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgeCA9IGRhdGFbaV1bdGhpcy5jb2xYXSB8fCAwO1xuICAgICAgICB5ID0gZGF0YVtpXVt0aGlzLmNvbFldIHx8IDA7XG4gICAgICAgIHogPSBkYXRhW2ldW3RoaXMuY29sWl0gfHwgMDtcblxuICAgICAgICB2YXIgeEluZGV4ID0gZGF0YVguaW5kZXhPZih4KTsgLy8gVE9ETzogaW1wbGVtZW50IEFycmF5KCkuaW5kZXhPZigpIGZvciBJbnRlcm5ldCBFeHBsb3JlclxuICAgICAgICB2YXIgeUluZGV4ID0gZGF0YVkuaW5kZXhPZih5KTtcblxuICAgICAgICBpZiAoZGF0YU1hdHJpeFt4SW5kZXhdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkYXRhTWF0cml4W3hJbmRleF0gPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb2ludDNkID0gbmV3IFBvaW50M2QoKTtcbiAgICAgICAgcG9pbnQzZC54ID0geDtcbiAgICAgICAgcG9pbnQzZC55ID0geTtcbiAgICAgICAgcG9pbnQzZC56ID0gejtcblxuICAgICAgICBvYmogPSB7fTtcbiAgICAgICAgb2JqLnBvaW50ID0gcG9pbnQzZDtcbiAgICAgICAgb2JqLnRyYW5zID0gdW5kZWZpbmVkO1xuICAgICAgICBvYmouc2NyZWVuID0gdW5kZWZpbmVkO1xuICAgICAgICBvYmouYm90dG9tID0gbmV3IFBvaW50M2QoeCwgeSwgdGhpcy56TWluKTtcblxuICAgICAgICBkYXRhTWF0cml4W3hJbmRleF1beUluZGV4XSA9IG9iajtcblxuICAgICAgICBkYXRhUG9pbnRzLnB1c2gob2JqKTtcbiAgICAgIH1cblxuICAgICAgLy8gZmlsbCBpbiB0aGUgcG9pbnRlcnMgdG8gdGhlIG5laWdoYm9ycy5cbiAgICAgIGZvciAoeCA9IDA7IHggPCBkYXRhTWF0cml4Lmxlbmd0aDsgeCsrKSB7XG4gICAgICAgIGZvciAoeSA9IDA7IHkgPCBkYXRhTWF0cml4W3hdLmxlbmd0aDsgeSsrKSB7XG4gICAgICAgICAgaWYgKGRhdGFNYXRyaXhbeF1beV0pIHtcbiAgICAgICAgICAgIGRhdGFNYXRyaXhbeF1beV0ucG9pbnRSaWdodCA9IHggPCBkYXRhTWF0cml4Lmxlbmd0aCAtIDEgPyBkYXRhTWF0cml4W3ggKyAxXVt5XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGRhdGFNYXRyaXhbeF1beV0ucG9pbnRUb3AgPSB5IDwgZGF0YU1hdHJpeFt4XS5sZW5ndGggLSAxID8gZGF0YU1hdHJpeFt4XVt5ICsgMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBkYXRhTWF0cml4W3hdW3ldLnBvaW50Q3Jvc3MgPSB4IDwgZGF0YU1hdHJpeC5sZW5ndGggLSAxICYmIHkgPCBkYXRhTWF0cml4W3hdLmxlbmd0aCAtIDEgPyBkYXRhTWF0cml4W3ggKyAxXVt5ICsgMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vICdkb3QnLCAnZG90LWxpbmUnLCBldGMuXG4gICAgICAvLyBjb3B5IGFsbCB2YWx1ZXMgZnJvbSB0aGUgZ29vZ2xlIGRhdGEgdGFibGUgdG8gYSBsaXN0IHdpdGggUG9pbnQzZCBvYmplY3RzXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBwb2ludCA9IG5ldyBQb2ludDNkKCk7XG4gICAgICAgIHBvaW50LnggPSBkYXRhW2ldW3RoaXMuY29sWF0gfHwgMDtcbiAgICAgICAgcG9pbnQueSA9IGRhdGFbaV1bdGhpcy5jb2xZXSB8fCAwO1xuICAgICAgICBwb2ludC56ID0gZGF0YVtpXVt0aGlzLmNvbFpdIHx8IDA7XG5cbiAgICAgICAgaWYgKHRoaXMuY29sVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHBvaW50LnZhbHVlID0gZGF0YVtpXVt0aGlzLmNvbFZhbHVlXSB8fCAwO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqID0ge307XG4gICAgICAgIG9iai5wb2ludCA9IHBvaW50O1xuICAgICAgICBvYmouYm90dG9tID0gbmV3IFBvaW50M2QocG9pbnQueCwgcG9pbnQueSwgdGhpcy56TWluKTtcbiAgICAgICAgb2JqLnRyYW5zID0gdW5kZWZpbmVkO1xuICAgICAgICBvYmouc2NyZWVuID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGRhdGFQb2ludHMucHVzaChvYmopO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkYXRhUG9pbnRzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIG1haW4gZnJhbWUgZm9yIHRoZSBHcmFwaDNkLlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIG9uY2Ugd2hlbiBhIEdyYXBoM2Qgb2JqZWN0IGlzIGNyZWF0ZWQuIFRoZSBmcmFtZVxuICAgKiBjb250YWlucyBhIGNhbnZhcywgYW5kIHRoaXMgY2FudmFzIGNvbnRhaW5zIGFsbCBvYmplY3RzIGxpa2UgdGhlIGF4aXMgYW5kXG4gICAqIG5vZGVzLlxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHJlbW92ZSBhbGwgZWxlbWVudHMgZnJvbSB0aGUgY29udGFpbmVyIGVsZW1lbnQuXG4gICAgd2hpbGUgKHRoaXMuY29udGFpbmVyRWxlbWVudC5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyRWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLmNvbnRhaW5lckVsZW1lbnQuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgdGhpcy5mcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuZnJhbWUuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgIHRoaXMuZnJhbWUuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcblxuICAgIC8vIGNyZWF0ZSB0aGUgZ3JhcGggY2FudmFzIChIVE1MIGNhbnZhcyBlbGVtZW50KVxuICAgIHRoaXMuZnJhbWUuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgdGhpcy5mcmFtZS5jYW52YXMuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5mcmFtZS5jYW52YXMpO1xuICAgIC8vaWYgKCF0aGlzLmZyYW1lLmNhbnZhcy5nZXRDb250ZXh0KSB7XG4gICAge1xuICAgICAgdmFyIG5vQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XG4gICAgICBub0NhbnZhcy5zdHlsZS5jb2xvciA9ICdyZWQnO1xuICAgICAgbm9DYW52YXMuc3R5bGUuZm9udFdlaWdodCA9ICdib2xkJztcbiAgICAgIG5vQ2FudmFzLnN0eWxlLnBhZGRpbmcgPSAnMTBweCc7XG4gICAgICBub0NhbnZhcy5pbm5lckhUTUwgPSAnRXJyb3I6IHlvdXIgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IEhUTUwgY2FudmFzJztcbiAgICAgIHRoaXMuZnJhbWUuY2FudmFzLmFwcGVuZENoaWxkKG5vQ2FudmFzKTtcbiAgICB9XG5cbiAgICB0aGlzLmZyYW1lLmZpbHRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuZnJhbWUuZmlsdGVyLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICB0aGlzLmZyYW1lLmZpbHRlci5zdHlsZS5ib3R0b20gPSAnMHB4JztcbiAgICB0aGlzLmZyYW1lLmZpbHRlci5zdHlsZS5sZWZ0ID0gJzBweCc7XG4gICAgdGhpcy5mcmFtZS5maWx0ZXIuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmZyYW1lLmZpbHRlcik7XG5cbiAgICAvLyBhZGQgZXZlbnQgbGlzdGVuZXJzIHRvIGhhbmRsZSBtb3ZpbmcgYW5kIHpvb21pbmcgdGhlIGNvbnRlbnRzXG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgb25tb3VzZWRvd24gPSBmdW5jdGlvbiBvbm1vdXNlZG93bihldmVudCkge1xuICAgICAgbWUuX29uTW91c2VEb3duKGV2ZW50KTtcbiAgICB9O1xuICAgIHZhciBvbnRvdWNoc3RhcnQgPSBmdW5jdGlvbiBvbnRvdWNoc3RhcnQoZXZlbnQpIHtcbiAgICAgIG1lLl9vblRvdWNoU3RhcnQoZXZlbnQpO1xuICAgIH07XG4gICAgdmFyIG9ubW91c2V3aGVlbCA9IGZ1bmN0aW9uIG9ubW91c2V3aGVlbChldmVudCkge1xuICAgICAgbWUuX29uV2hlZWwoZXZlbnQpO1xuICAgIH07XG4gICAgdmFyIG9udG9vbHRpcCA9IGZ1bmN0aW9uIG9udG9vbHRpcChldmVudCkge1xuICAgICAgbWUuX29uVG9vbHRpcChldmVudCk7XG4gICAgfTtcbiAgICAvLyBUT0RPOiB0aGVzZSBldmVudHMgYXJlIG5ldmVyIGNsZWFuZWQgdXAuLi4gY2FuIGdpdmUgYSAnbWVtb3J5IGxlYWthZ2UnXG5cbiAgICB1dGlsLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5mcmFtZS5jYW52YXMsICdrZXlkb3duJywgb25rZXlkb3duKTtcbiAgICB1dGlsLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5mcmFtZS5jYW52YXMsICdtb3VzZWRvd24nLCBvbm1vdXNlZG93bik7XG4gICAgdXRpbC5hZGRFdmVudExpc3RlbmVyKHRoaXMuZnJhbWUuY2FudmFzLCAndG91Y2hzdGFydCcsIG9udG91Y2hzdGFydCk7XG4gICAgdXRpbC5hZGRFdmVudExpc3RlbmVyKHRoaXMuZnJhbWUuY2FudmFzLCAnbW91c2V3aGVlbCcsIG9ubW91c2V3aGVlbCk7XG4gICAgdXRpbC5hZGRFdmVudExpc3RlbmVyKHRoaXMuZnJhbWUuY2FudmFzLCAnbW91c2Vtb3ZlJywgb250b29sdGlwKTtcblxuICAgIC8vIGFkZCB0aGUgbmV3IGdyYXBoIHRvIHRoZSBjb250YWluZXIgZWxlbWVudFxuICAgIHRoaXMuY29udGFpbmVyRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmZyYW1lKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGEgbmV3IHNpemUgZm9yIHRoZSBncmFwaFxuICAgKiBAcGFyYW0ge3N0cmluZ30gd2lkdGggICBXaWR0aCBpbiBwaXhlbHMgb3IgcGVyY2VudGFnZSAoZm9yIGV4YW1wbGUgJzgwMHB4J1xuICAgKiAgICAgICAgICAgICBvciAnNTAlJylcbiAgICogQHBhcmFtIHtzdHJpbmd9IGhlaWdodCAgSGVpZ2h0IGluIHBpeGVscyBvciBwZXJjZW50YWdlICAoZm9yIGV4YW1wbGUgJzQwMHB4J1xuICAgKiAgICAgICAgICAgICBvciAnMzAlJylcbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLnNldFNpemUgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMuZnJhbWUuc3R5bGUud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmZyYW1lLnN0eWxlLmhlaWdodCA9IGhlaWdodDtcblxuICAgIHRoaXMuX3Jlc2l6ZUNhbnZhcygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXNpemUgdGhlIGNhbnZhcyB0byB0aGUgY3VycmVudCBzaXplIG9mIHRoZSBmcmFtZVxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX3Jlc2l6ZUNhbnZhcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZyYW1lLmNhbnZhcy5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICB0aGlzLmZyYW1lLmNhbnZhcy5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG5cbiAgICB0aGlzLmZyYW1lLmNhbnZhcy53aWR0aCA9IHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoO1xuICAgIHRoaXMuZnJhbWUuY2FudmFzLmhlaWdodCA9IHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodDtcblxuICAgIC8vIGFkanVzdCB3aXRoIGZvciBtYXJnaW5cbiAgICB0aGlzLmZyYW1lLmZpbHRlci5zdHlsZS53aWR0aCA9IHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoIC0gMiAqIDEwICsgJ3B4JztcbiAgfTtcblxuICAvKipcbiAgICogU3RhcnQgYW5pbWF0aW9uXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5hbmltYXRpb25TdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuZnJhbWUuZmlsdGVyIHx8ICF0aGlzLmZyYW1lLmZpbHRlci5zbGlkZXIpIHRocm93ICdObyBhbmltYXRpb24gYXZhaWxhYmxlJztcblxuICAgIHRoaXMuZnJhbWUuZmlsdGVyLnNsaWRlci5wbGF5KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0b3AgYW5pbWF0aW9uXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5hbmltYXRpb25TdG9wID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5mcmFtZS5maWx0ZXIgfHwgIXRoaXMuZnJhbWUuZmlsdGVyLnNsaWRlcikgcmV0dXJuO1xuXG4gICAgdGhpcy5mcmFtZS5maWx0ZXIuc2xpZGVyLnN0b3AoKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVzaXplIHRoZSBjZW50ZXIgcG9zaXRpb24gYmFzZWQgb24gdGhlIGN1cnJlbnQgdmFsdWVzIGluIHRoaXMuZGVmYXVsdFhDZW50ZXJcbiAgICogYW5kIHRoaXMuZGVmYXVsdFlDZW50ZXIgKHdoaWNoIGFyZSBzdHJpbmdzIHdpdGggYSBwZXJjZW50YWdlIG9yIGEgdmFsdWVcbiAgICogaW4gcGl4ZWxzKS4gVGhlIGNlbnRlciBwb3NpdGlvbnMgYXJlIHRoZSB2YXJpYWJsZXMgdGhpcy54Q2VudGVyXG4gICAqIGFuZCB0aGlzLnlDZW50ZXJcbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLl9yZXNpemVDZW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gY2FsY3VsYXRlIHRoZSBob3Jpem9udGFsIGNlbnRlciBwb3NpdGlvblxuICAgIGlmICh0aGlzLmRlZmF1bHRYQ2VudGVyLmNoYXJBdCh0aGlzLmRlZmF1bHRYQ2VudGVyLmxlbmd0aCAtIDEpID09PSAnJScpIHtcbiAgICAgIHRoaXMueGNlbnRlciA9IHBhcnNlRmxvYXQodGhpcy5kZWZhdWx0WENlbnRlcikgLyAxMDAgKiB0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy54Y2VudGVyID0gcGFyc2VGbG9hdCh0aGlzLmRlZmF1bHRYQ2VudGVyKTsgLy8gc3VwcG9zZWQgdG8gYmUgaW4gcHhcbiAgICB9XG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIHZlcnRpY2FsIGNlbnRlciBwb3NpdGlvblxuICAgIGlmICh0aGlzLmRlZmF1bHRZQ2VudGVyLmNoYXJBdCh0aGlzLmRlZmF1bHRZQ2VudGVyLmxlbmd0aCAtIDEpID09PSAnJScpIHtcbiAgICAgIHRoaXMueWNlbnRlciA9IHBhcnNlRmxvYXQodGhpcy5kZWZhdWx0WUNlbnRlcikgLyAxMDAgKiAodGhpcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0IC0gdGhpcy5mcmFtZS5maWx0ZXIuY2xpZW50SGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy55Y2VudGVyID0gcGFyc2VGbG9hdCh0aGlzLmRlZmF1bHRZQ2VudGVyKTsgLy8gc3VwcG9zZWQgdG8gYmUgaW4gcHhcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcm90YXRpb24gYW5kIGRpc3RhbmNlIG9mIHRoZSBjYW1lcmFcbiAgICogQHBhcmFtIHtPYmplY3R9IHBvcyAgIEFuIG9iamVjdCB3aXRoIHRoZSBjYW1lcmEgcG9zaXRpb24uIFRoZSBvYmplY3RcbiAgICogICAgICAgICAgICAgY29udGFpbnMgdGhyZWUgcGFyYW1ldGVyczpcbiAgICogICAgICAgICAgICAgLSBob3Jpem9udGFsIHtOdW1iZXJ9XG4gICAqICAgICAgICAgICAgIFRoZSBob3Jpem9udGFsIHJvdGF0aW9uLCBiZXR3ZWVuIDAgYW5kIDIqUEkuXG4gICAqICAgICAgICAgICAgIE9wdGlvbmFsLCBjYW4gYmUgbGVmdCB1bmRlZmluZWQuXG4gICAqICAgICAgICAgICAgIC0gdmVydGljYWwge051bWJlcn1cbiAgICogICAgICAgICAgICAgVGhlIHZlcnRpY2FsIHJvdGF0aW9uLCBiZXR3ZWVuIDAgYW5kIDAuNSpQSVxuICAgKiAgICAgICAgICAgICBpZiB2ZXJ0aWNhbD0wLjUqUEksIHRoZSBncmFwaCBpcyBzaG93biBmcm9tIHRoZVxuICAgKiAgICAgICAgICAgICB0b3AuIE9wdGlvbmFsLCBjYW4gYmUgbGVmdCB1bmRlZmluZWQuXG4gICAqICAgICAgICAgICAgIC0gZGlzdGFuY2Uge051bWJlcn1cbiAgICogICAgICAgICAgICAgVGhlIChub3JtYWxpemVkKSBkaXN0YW5jZSBvZiB0aGUgY2FtZXJhIHRvIHRoZVxuICAgKiAgICAgICAgICAgICBjZW50ZXIgb2YgdGhlIGdyYXBoLCBhIHZhbHVlIGJldHdlZW4gMC43MSBhbmQgNS4wLlxuICAgKiAgICAgICAgICAgICBPcHRpb25hbCwgY2FuIGJlIGxlZnQgdW5kZWZpbmVkLlxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuc2V0Q2FtZXJhUG9zaXRpb24gPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgaWYgKHBvcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHBvcy5ob3Jpem9udGFsICE9PSB1bmRlZmluZWQgJiYgcG9zLnZlcnRpY2FsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuY2FtZXJhLnNldEFybVJvdGF0aW9uKHBvcy5ob3Jpem9udGFsLCBwb3MudmVydGljYWwpO1xuICAgIH1cblxuICAgIGlmIChwb3MuZGlzdGFuY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5jYW1lcmEuc2V0QXJtTGVuZ3RoKHBvcy5kaXN0YW5jZSk7XG4gICAgfVxuXG4gICAgdGhpcy5yZWRyYXcoKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlldmUgdGhlIGN1cnJlbnQgY2FtZXJhIHJvdGF0aW9uXG4gICAqIEByZXR1cm4ge29iamVjdH0gICBBbiBvYmplY3Qgd2l0aCBwYXJhbWV0ZXJzIGhvcml6b250YWwsIHZlcnRpY2FsLCBhbmRcbiAgICogICAgICAgICAgZGlzdGFuY2VcbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLmdldENhbWVyYVBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwb3MgPSB0aGlzLmNhbWVyYS5nZXRBcm1Sb3RhdGlvbigpO1xuICAgIHBvcy5kaXN0YW5jZSA9IHRoaXMuY2FtZXJhLmdldEFybUxlbmd0aCgpO1xuICAgIHJldHVybiBwb3M7XG4gIH07XG5cbiAgLyoqXG4gICAqIExvYWQgZGF0YSBpbnRvIHRoZSAzRCBHcmFwaFxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX3JlYWREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAvLyByZWFkIHRoZSBkYXRhXG4gICAgdGhpcy5fZGF0YUluaXRpYWxpemUoZGF0YSwgdGhpcy5zdHlsZSk7XG5cbiAgICBpZiAodGhpcy5kYXRhRmlsdGVyKSB7XG4gICAgICAvLyBhcHBseSBmaWx0ZXJpbmdcbiAgICAgIHRoaXMuZGF0YVBvaW50cyA9IHRoaXMuZGF0YUZpbHRlci5fZ2V0RGF0YVBvaW50cygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBubyBmaWx0ZXJpbmcuIGxvYWQgYWxsIGRhdGFcbiAgICAgIHRoaXMuZGF0YVBvaW50cyA9IHRoaXMuX2dldERhdGFQb2ludHModGhpcy5kYXRhVGFibGUpO1xuICAgIH1cblxuICAgIC8vIGRyYXcgdGhlIGZpbHRlclxuICAgIHRoaXMuX3JlZHJhd0ZpbHRlcigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXBsYWNlIHRoZSBkYXRhc2V0IG9mIHRoZSBHcmFwaDNkXG4gICAqIEBwYXJhbSB7QXJyYXkgfCBEYXRhU2V0IHwgRGF0YVZpZXd9IGRhdGFcbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLnNldERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHRoaXMuX3JlYWREYXRhKGRhdGEpO1xuICAgIHRoaXMucmVkcmF3KCk7XG5cbiAgICAvLyBzdGFydCBhbmltYXRpb24gd2hlbiBvcHRpb24gaXMgdHJ1ZVxuICAgIGlmICh0aGlzLmFuaW1hdGlvbkF1dG9TdGFydCAmJiB0aGlzLmRhdGFGaWx0ZXIpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhcnQoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgb3B0aW9ucy4gT3B0aW9ucyB3aWxsIGJlIG1lcmdlZCB3aXRoIGN1cnJlbnQgb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIGNhbWVyYVBvc2l0aW9uID0gdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5hbmltYXRpb25TdG9wKCk7XG5cbiAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyByZXRyaWV2ZSBwYXJhbWV0ZXIgdmFsdWVzXG4gICAgICBpZiAob3B0aW9ucy53aWR0aCAhPT0gdW5kZWZpbmVkKSB0aGlzLndpZHRoID0gb3B0aW9ucy53aWR0aDtcbiAgICAgIGlmIChvcHRpb25zLmhlaWdodCAhPT0gdW5kZWZpbmVkKSB0aGlzLmhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0O1xuXG4gICAgICBpZiAob3B0aW9ucy54Q2VudGVyICE9PSB1bmRlZmluZWQpIHRoaXMuZGVmYXVsdFhDZW50ZXIgPSBvcHRpb25zLnhDZW50ZXI7XG4gICAgICBpZiAob3B0aW9ucy55Q2VudGVyICE9PSB1bmRlZmluZWQpIHRoaXMuZGVmYXVsdFlDZW50ZXIgPSBvcHRpb25zLnlDZW50ZXI7XG5cbiAgICAgIGlmIChvcHRpb25zLmZpbHRlckxhYmVsICE9PSB1bmRlZmluZWQpIHRoaXMuZmlsdGVyTGFiZWwgPSBvcHRpb25zLmZpbHRlckxhYmVsO1xuICAgICAgaWYgKG9wdGlvbnMubGVnZW5kTGFiZWwgIT09IHVuZGVmaW5lZCkgdGhpcy5sZWdlbmRMYWJlbCA9IG9wdGlvbnMubGVnZW5kTGFiZWw7XG4gICAgICBpZiAob3B0aW9ucy54TGFiZWwgIT09IHVuZGVmaW5lZCkgdGhpcy54TGFiZWwgPSBvcHRpb25zLnhMYWJlbDtcbiAgICAgIGlmIChvcHRpb25zLnlMYWJlbCAhPT0gdW5kZWZpbmVkKSB0aGlzLnlMYWJlbCA9IG9wdGlvbnMueUxhYmVsO1xuICAgICAgaWYgKG9wdGlvbnMuekxhYmVsICE9PSB1bmRlZmluZWQpIHRoaXMuekxhYmVsID0gb3B0aW9ucy56TGFiZWw7XG5cbiAgICAgIGlmIChvcHRpb25zLnhWYWx1ZUxhYmVsICE9PSB1bmRlZmluZWQpIHRoaXMueFZhbHVlTGFiZWwgPSBvcHRpb25zLnhWYWx1ZUxhYmVsO1xuICAgICAgaWYgKG9wdGlvbnMueVZhbHVlTGFiZWwgIT09IHVuZGVmaW5lZCkgdGhpcy55VmFsdWVMYWJlbCA9IG9wdGlvbnMueVZhbHVlTGFiZWw7XG4gICAgICBpZiAob3B0aW9ucy56VmFsdWVMYWJlbCAhPT0gdW5kZWZpbmVkKSB0aGlzLnpWYWx1ZUxhYmVsID0gb3B0aW9ucy56VmFsdWVMYWJlbDtcblxuICAgICAgaWYgKG9wdGlvbnMuZG90U2l6ZVJhdGlvICE9PSB1bmRlZmluZWQpIHRoaXMuZG90U2l6ZVJhdGlvID0gb3B0aW9ucy5kb3RTaXplUmF0aW87XG5cbiAgICAgIGlmIChvcHRpb25zLnN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHN0eWxlTnVtYmVyID0gdGhpcy5fZ2V0U3R5bGVOdW1iZXIob3B0aW9ucy5zdHlsZSk7XG4gICAgICAgIGlmIChzdHlsZU51bWJlciAhPT0gLTEpIHtcbiAgICAgICAgICB0aGlzLnN0eWxlID0gc3R5bGVOdW1iZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnNob3dHcmlkICE9PSB1bmRlZmluZWQpIHRoaXMuc2hvd0dyaWQgPSBvcHRpb25zLnNob3dHcmlkO1xuICAgICAgaWYgKG9wdGlvbnMuc2hvd1BlcnNwZWN0aXZlICE9PSB1bmRlZmluZWQpIHRoaXMuc2hvd1BlcnNwZWN0aXZlID0gb3B0aW9ucy5zaG93UGVyc3BlY3RpdmU7XG4gICAgICBpZiAob3B0aW9ucy5zaG93U2hhZG93ICE9PSB1bmRlZmluZWQpIHRoaXMuc2hvd1NoYWRvdyA9IG9wdGlvbnMuc2hvd1NoYWRvdztcbiAgICAgIGlmIChvcHRpb25zLnRvb2x0aXAgIT09IHVuZGVmaW5lZCkgdGhpcy5zaG93VG9vbHRpcCA9IG9wdGlvbnMudG9vbHRpcDtcbiAgICAgIGlmIChvcHRpb25zLnNob3dBbmltYXRpb25Db250cm9scyAhPT0gdW5kZWZpbmVkKSB0aGlzLnNob3dBbmltYXRpb25Db250cm9scyA9IG9wdGlvbnMuc2hvd0FuaW1hdGlvbkNvbnRyb2xzO1xuICAgICAgaWYgKG9wdGlvbnMua2VlcEFzcGVjdFJhdGlvICE9PSB1bmRlZmluZWQpIHRoaXMua2VlcEFzcGVjdFJhdGlvID0gb3B0aW9ucy5rZWVwQXNwZWN0UmF0aW87XG4gICAgICBpZiAob3B0aW9ucy52ZXJ0aWNhbFJhdGlvICE9PSB1bmRlZmluZWQpIHRoaXMudmVydGljYWxSYXRpbyA9IG9wdGlvbnMudmVydGljYWxSYXRpbztcblxuICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uSW50ZXJ2YWwgIT09IHVuZGVmaW5lZCkgdGhpcy5hbmltYXRpb25JbnRlcnZhbCA9IG9wdGlvbnMuYW5pbWF0aW9uSW50ZXJ2YWw7XG4gICAgICBpZiAob3B0aW9ucy5hbmltYXRpb25QcmVsb2FkICE9PSB1bmRlZmluZWQpIHRoaXMuYW5pbWF0aW9uUHJlbG9hZCA9IG9wdGlvbnMuYW5pbWF0aW9uUHJlbG9hZDtcbiAgICAgIGlmIChvcHRpb25zLmFuaW1hdGlvbkF1dG9TdGFydCAhPT0gdW5kZWZpbmVkKSB0aGlzLmFuaW1hdGlvbkF1dG9TdGFydCA9IG9wdGlvbnMuYW5pbWF0aW9uQXV0b1N0YXJ0O1xuXG4gICAgICBpZiAob3B0aW9ucy54QmFyV2lkdGggIT09IHVuZGVmaW5lZCkgdGhpcy5kZWZhdWx0WEJhcldpZHRoID0gb3B0aW9ucy54QmFyV2lkdGg7XG4gICAgICBpZiAob3B0aW9ucy55QmFyV2lkdGggIT09IHVuZGVmaW5lZCkgdGhpcy5kZWZhdWx0WUJhcldpZHRoID0gb3B0aW9ucy55QmFyV2lkdGg7XG5cbiAgICAgIGlmIChvcHRpb25zLnhNaW4gIT09IHVuZGVmaW5lZCkgdGhpcy5kZWZhdWx0WE1pbiA9IG9wdGlvbnMueE1pbjtcbiAgICAgIGlmIChvcHRpb25zLnhTdGVwICE9PSB1bmRlZmluZWQpIHRoaXMuZGVmYXVsdFhTdGVwID0gb3B0aW9ucy54U3RlcDtcbiAgICAgIGlmIChvcHRpb25zLnhNYXggIT09IHVuZGVmaW5lZCkgdGhpcy5kZWZhdWx0WE1heCA9IG9wdGlvbnMueE1heDtcbiAgICAgIGlmIChvcHRpb25zLnlNaW4gIT09IHVuZGVmaW5lZCkgdGhpcy5kZWZhdWx0WU1pbiA9IG9wdGlvbnMueU1pbjtcbiAgICAgIGlmIChvcHRpb25zLnlTdGVwICE9PSB1bmRlZmluZWQpIHRoaXMuZGVmYXVsdFlTdGVwID0gb3B0aW9ucy55U3RlcDtcbiAgICAgIGlmIChvcHRpb25zLnlNYXggIT09IHVuZGVmaW5lZCkgdGhpcy5kZWZhdWx0WU1heCA9IG9wdGlvbnMueU1heDtcbiAgICAgIGlmIChvcHRpb25zLnpNaW4gIT09IHVuZGVmaW5lZCkgdGhpcy5kZWZhdWx0Wk1pbiA9IG9wdGlvbnMuek1pbjtcbiAgICAgIGlmIChvcHRpb25zLnpTdGVwICE9PSB1bmRlZmluZWQpIHRoaXMuZGVmYXVsdFpTdGVwID0gb3B0aW9ucy56U3RlcDtcbiAgICAgIGlmIChvcHRpb25zLnpNYXggIT09IHVuZGVmaW5lZCkgdGhpcy5kZWZhdWx0Wk1heCA9IG9wdGlvbnMuek1heDtcbiAgICAgIGlmIChvcHRpb25zLnZhbHVlTWluICE9PSB1bmRlZmluZWQpIHRoaXMuZGVmYXVsdFZhbHVlTWluID0gb3B0aW9ucy52YWx1ZU1pbjtcbiAgICAgIGlmIChvcHRpb25zLnZhbHVlTWF4ICE9PSB1bmRlZmluZWQpIHRoaXMuZGVmYXVsdFZhbHVlTWF4ID0gb3B0aW9ucy52YWx1ZU1heDtcbiAgICAgIGlmIChvcHRpb25zLmJhY2tncm91bmRDb2xvciAhPT0gdW5kZWZpbmVkKSB0aGlzLl9zZXRCYWNrZ3JvdW5kQ29sb3Iob3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpO1xuXG4gICAgICBpZiAob3B0aW9ucy5jYW1lcmFQb3NpdGlvbiAhPT0gdW5kZWZpbmVkKSBjYW1lcmFQb3NpdGlvbiA9IG9wdGlvbnMuY2FtZXJhUG9zaXRpb247XG5cbiAgICAgIGlmIChjYW1lcmFQb3NpdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuY2FtZXJhLnNldEFybVJvdGF0aW9uKGNhbWVyYVBvc2l0aW9uLmhvcml6b250YWwsIGNhbWVyYVBvc2l0aW9uLnZlcnRpY2FsKTtcbiAgICAgICAgdGhpcy5jYW1lcmEuc2V0QXJtTGVuZ3RoKGNhbWVyYVBvc2l0aW9uLmRpc3RhbmNlKTtcbiAgICAgIH1cblxuICAgICAgLy8gY29sb3JzXG4gICAgICBpZiAob3B0aW9ucy5heGlzQ29sb3IgIT09IHVuZGVmaW5lZCkgdGhpcy5heGlzQ29sb3IgPSBvcHRpb25zLmF4aXNDb2xvcjtcbiAgICAgIGlmIChvcHRpb25zLmdyaWRDb2xvciAhPT0gdW5kZWZpbmVkKSB0aGlzLmdyaWRDb2xvciA9IG9wdGlvbnMuZ3JpZENvbG9yO1xuICAgICAgaWYgKG9wdGlvbnMuZGF0YUNvbG9yKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kYXRhQ29sb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhpcy5kYXRhQ29sb3IuZmlsbCA9IG9wdGlvbnMuZGF0YUNvbG9yO1xuICAgICAgICAgIHRoaXMuZGF0YUNvbG9yLnN0cm9rZSA9IG9wdGlvbnMuZGF0YUNvbG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChvcHRpb25zLmRhdGFDb2xvci5maWxsKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFDb2xvci5maWxsID0gb3B0aW9ucy5kYXRhQ29sb3IuZmlsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wdGlvbnMuZGF0YUNvbG9yLnN0cm9rZSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhQ29sb3Iuc3Ryb2tlID0gb3B0aW9ucy5kYXRhQ29sb3Iuc3Ryb2tlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3B0aW9ucy5kYXRhQ29sb3Iuc3Ryb2tlV2lkdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5kYXRhQ29sb3Iuc3Ryb2tlV2lkdGggPSBvcHRpb25zLmRhdGFDb2xvci5zdHJva2VXaWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNldFNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXG4gICAgLy8gcmUtbG9hZCB0aGUgZGF0YVxuICAgIGlmICh0aGlzLmRhdGFUYWJsZSkge1xuICAgICAgdGhpcy5zZXREYXRhKHRoaXMuZGF0YVRhYmxlKTtcbiAgICB9XG5cbiAgICAvLyBzdGFydCBhbmltYXRpb24gd2hlbiBvcHRpb24gaXMgdHJ1ZVxuICAgIGlmICh0aGlzLmFuaW1hdGlvbkF1dG9TdGFydCAmJiB0aGlzLmRhdGFGaWx0ZXIpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhcnQoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlZHJhdyB0aGUgR3JhcGguXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZGF0YVBvaW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyAnRXJyb3I6IGdyYXBoIGRhdGEgbm90IGluaXRpYWxpemVkJztcbiAgICB9XG5cbiAgICB0aGlzLl9yZXNpemVDYW52YXMoKTtcbiAgICB0aGlzLl9yZXNpemVDZW50ZXIoKTtcbiAgICB0aGlzLl9yZWRyYXdTbGlkZXIoKTtcbiAgICB0aGlzLl9yZWRyYXdDbGVhcigpO1xuICAgIHRoaXMuX3JlZHJhd0F4aXMoKTtcblxuICAgIGlmICh0aGlzLnN0eWxlID09PSBHcmFwaDNkLlNUWUxFLkdSSUQgfHwgdGhpcy5zdHlsZSA9PT0gR3JhcGgzZC5TVFlMRS5TVVJGQUNFKSB7XG4gICAgICB0aGlzLl9yZWRyYXdEYXRhR3JpZCgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdHlsZSA9PT0gR3JhcGgzZC5TVFlMRS5MSU5FKSB7XG4gICAgICB0aGlzLl9yZWRyYXdEYXRhTGluZSgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdHlsZSA9PT0gR3JhcGgzZC5TVFlMRS5CQVIgfHwgdGhpcy5zdHlsZSA9PT0gR3JhcGgzZC5TVFlMRS5CQVJDT0xPUiB8fCB0aGlzLnN0eWxlID09PSBHcmFwaDNkLlNUWUxFLkJBUlNJWkUpIHtcbiAgICAgIHRoaXMuX3JlZHJhd0RhdGFCYXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc3R5bGUgaXMgRE9ULCBET1RMSU5FLCBET1RDT0xPUiwgRE9UU0laRVxuICAgICAgdGhpcy5fcmVkcmF3RGF0YURvdCgpO1xuICAgIH1cblxuICAgIHRoaXMuX3JlZHJhd0luZm8oKTtcbiAgICB0aGlzLl9yZWRyYXdMZWdlbmQoKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2xlYXIgdGhlIGNhbnZhcyBiZWZvcmUgcmVkcmF3aW5nXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5fcmVkcmF3Q2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhbnZhcyA9IHRoaXMuZnJhbWUuY2FudmFzO1xuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgfTtcblxuICAvKipcbiAgICogUmVkcmF3IHRoZSBsZWdlbmQgc2hvd2luZyB0aGUgY29sb3JzXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5fcmVkcmF3TGVnZW5kID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB5O1xuXG4gICAgaWYgKHRoaXMuc3R5bGUgPT09IEdyYXBoM2QuU1RZTEUuRE9UQ09MT1IgfHwgdGhpcy5zdHlsZSA9PT0gR3JhcGgzZC5TVFlMRS5ET1RTSVpFKSB7XG5cbiAgICAgIHZhciBkb3RTaXplID0gdGhpcy5mcmFtZS5jbGllbnRXaWR0aCAqIHRoaXMuZG90U2l6ZVJhdGlvO1xuXG4gICAgICB2YXIgd2lkdGhNaW4sIHdpZHRoTWF4O1xuICAgICAgaWYgKHRoaXMuc3R5bGUgPT09IEdyYXBoM2QuU1RZTEUuRE9UU0laRSkge1xuICAgICAgICB3aWR0aE1pbiA9IGRvdFNpemUgLyAyOyAvLyBweFxuICAgICAgICB3aWR0aE1heCA9IGRvdFNpemUgLyAyICsgZG90U2l6ZSAqIDI7IC8vIFRvZG86IHB1dCB0aGlzIGluIG9uZSBmdW5jdGlvblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aWR0aE1pbiA9IDIwOyAvLyBweFxuICAgICAgICAgIHdpZHRoTWF4ID0gMjA7IC8vIHB4XG4gICAgICAgIH1cblxuICAgICAgdmFyIGhlaWdodCA9IE1hdGgubWF4KHRoaXMuZnJhbWUuY2xpZW50SGVpZ2h0ICogMC4yNSwgMTAwKTtcbiAgICAgIHZhciB0b3AgPSB0aGlzLm1hcmdpbjtcbiAgICAgIHZhciByaWdodCA9IHRoaXMuZnJhbWUuY2xpZW50V2lkdGggLSB0aGlzLm1hcmdpbjtcbiAgICAgIHZhciBsZWZ0ID0gcmlnaHQgLSB3aWR0aE1heDtcbiAgICAgIHZhciBib3R0b20gPSB0b3AgKyBoZWlnaHQ7XG4gICAgfVxuXG4gICAgdmFyIGNhbnZhcyA9IHRoaXMuZnJhbWUuY2FudmFzO1xuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICBjdHguZm9udCA9ICcxNHB4IGFyaWFsJzsgLy8gVE9ETzogcHV0IGluIG9wdGlvbnNcblxuICAgIGlmICh0aGlzLnN0eWxlID09PSBHcmFwaDNkLlNUWUxFLkRPVENPTE9SKSB7XG4gICAgICAvLyBkcmF3IHRoZSBjb2xvciBiYXJcbiAgICAgIHZhciB5bWluID0gMDtcbiAgICAgIHZhciB5bWF4ID0gaGVpZ2h0OyAvLyBUb2RvOiBtYWtlIGhlaWdodCBjdXN0b21pemFibGVcbiAgICAgIGZvciAoeSA9IHltaW47IHkgPCB5bWF4OyB5KyspIHtcbiAgICAgICAgdmFyIGYgPSAoeSAtIHltaW4pIC8gKHltYXggLSB5bWluKTtcblxuICAgICAgICAvL3ZhciB3aWR0aCA9IChkb3RTaXplIC8gMiArICgxLWYpICogZG90U2l6ZSAqIDIpOyAvLyBUb2RvOiBwdXQgdGhpcyBpbiBvbmUgZnVuY3Rpb25cbiAgICAgICAgdmFyIGh1ZSA9IGYgKiAyNDA7XG4gICAgICAgIHZhciBjb2xvciA9IHRoaXMuX2hzdjJyZ2IoaHVlLCAxLCAxKTtcblxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKGxlZnQsIHRvcCArIHkpO1xuICAgICAgICBjdHgubGluZVRvKHJpZ2h0LCB0b3AgKyB5KTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfVxuXG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmF4aXNDb2xvcjtcbiAgICAgIGN0eC5zdHJva2VSZWN0KGxlZnQsIHRvcCwgd2lkdGhNYXgsIGhlaWdodCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3R5bGUgPT09IEdyYXBoM2QuU1RZTEUuRE9UU0laRSkge1xuICAgICAgLy8gZHJhdyBib3JkZXIgYXJvdW5kIGNvbG9yIGJhclxuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5heGlzQ29sb3I7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5kYXRhQ29sb3IuZmlsbDtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8obGVmdCwgdG9wKTtcbiAgICAgIGN0eC5saW5lVG8ocmlnaHQsIHRvcCk7XG4gICAgICBjdHgubGluZVRvKHJpZ2h0IC0gd2lkdGhNYXggKyB3aWR0aE1pbiwgYm90dG9tKTtcbiAgICAgIGN0eC5saW5lVG8obGVmdCwgYm90dG9tKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3R5bGUgPT09IEdyYXBoM2QuU1RZTEUuRE9UQ09MT1IgfHwgdGhpcy5zdHlsZSA9PT0gR3JhcGgzZC5TVFlMRS5ET1RTSVpFKSB7XG4gICAgICAvLyBwcmludCB2YWx1ZXMgYWxvbmcgdGhlIGNvbG9yIGJhclxuICAgICAgdmFyIGdyaWRMaW5lTGVuID0gNTsgLy8gcHhcbiAgICAgIHZhciBzdGVwID0gbmV3IFN0ZXBOdW1iZXIodGhpcy52YWx1ZU1pbiwgdGhpcy52YWx1ZU1heCwgKHRoaXMudmFsdWVNYXggLSB0aGlzLnZhbHVlTWluKSAvIDUsIHRydWUpO1xuICAgICAgc3RlcC5zdGFydCgpO1xuICAgICAgaWYgKHN0ZXAuZ2V0Q3VycmVudCgpIDwgdGhpcy52YWx1ZU1pbikge1xuICAgICAgICBzdGVwLm5leHQoKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICghc3RlcC5lbmQoKSkge1xuICAgICAgICB5ID0gYm90dG9tIC0gKHN0ZXAuZ2V0Q3VycmVudCgpIC0gdGhpcy52YWx1ZU1pbikgLyAodGhpcy52YWx1ZU1heCAtIHRoaXMudmFsdWVNaW4pICogaGVpZ2h0O1xuXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhsZWZ0IC0gZ3JpZExpbmVMZW4sIHkpO1xuICAgICAgICBjdHgubGluZVRvKGxlZnQsIHkpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuYXhpc0NvbG9yO1xuICAgICAgICBjdHguZmlsbFRleHQoc3RlcC5nZXRDdXJyZW50KCksIGxlZnQgLSAyICogZ3JpZExpbmVMZW4sIHkpO1xuXG4gICAgICAgIHN0ZXAubmV4dCgpO1xuICAgICAgfVxuXG4gICAgICBjdHgudGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAndG9wJztcbiAgICAgIHZhciBsYWJlbCA9IHRoaXMubGVnZW5kTGFiZWw7XG4gICAgICBjdHguZmlsbFRleHQobGFiZWwsIHJpZ2h0LCBib3R0b20gKyB0aGlzLm1hcmdpbik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZWRyYXcgdGhlIGZpbHRlclxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX3JlZHJhd0ZpbHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZyYW1lLmZpbHRlci5pbm5lckhUTUwgPSAnJztcblxuICAgIGlmICh0aGlzLmRhdGFGaWx0ZXIpIHtcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAndmlzaWJsZSc6IHRoaXMuc2hvd0FuaW1hdGlvbkNvbnRyb2xzXG4gICAgICB9O1xuICAgICAgdmFyIHNsaWRlciA9IG5ldyBTbGlkZXIodGhpcy5mcmFtZS5maWx0ZXIsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5mcmFtZS5maWx0ZXIuc2xpZGVyID0gc2xpZGVyO1xuXG4gICAgICAvLyBUT0RPOiBjc3MgaGVyZSBpcyBub3QgbmljZSBoZXJlLi4uXG4gICAgICB0aGlzLmZyYW1lLmZpbHRlci5zdHlsZS5wYWRkaW5nID0gJzEwcHgnO1xuICAgICAgLy90aGlzLmZyYW1lLmZpbHRlci5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnI0VGRUZFRic7XG5cbiAgICAgIHNsaWRlci5zZXRWYWx1ZXModGhpcy5kYXRhRmlsdGVyLnZhbHVlcyk7XG4gICAgICBzbGlkZXIuc2V0UGxheUludGVydmFsKHRoaXMuYW5pbWF0aW9uSW50ZXJ2YWwpO1xuXG4gICAgICAvLyBjcmVhdGUgYW4gZXZlbnQgaGFuZGxlclxuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIHZhciBvbmNoYW5nZSA9IGZ1bmN0aW9uIG9uY2hhbmdlKCkge1xuICAgICAgICB2YXIgaW5kZXggPSBzbGlkZXIuZ2V0SW5kZXgoKTtcblxuICAgICAgICBtZS5kYXRhRmlsdGVyLnNlbGVjdFZhbHVlKGluZGV4KTtcbiAgICAgICAgbWUuZGF0YVBvaW50cyA9IG1lLmRhdGFGaWx0ZXIuX2dldERhdGFQb2ludHMoKTtcblxuICAgICAgICBtZS5yZWRyYXcoKTtcbiAgICAgIH07XG4gICAgICBzbGlkZXIuc2V0T25DaGFuZ2VDYWxsYmFjayhvbmNoYW5nZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZnJhbWUuZmlsdGVyLnNsaWRlciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlZHJhdyB0aGUgc2xpZGVyXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5fcmVkcmF3U2xpZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmZyYW1lLmZpbHRlci5zbGlkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5mcmFtZS5maWx0ZXIuc2xpZGVyLnJlZHJhdygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVkcmF3IGNvbW1vbiBpbmZvcm1hdGlvblxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX3JlZHJhd0luZm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZGF0YUZpbHRlcikge1xuICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuZnJhbWUuY2FudmFzO1xuICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICBjdHguZm9udCA9ICcxNHB4IGFyaWFsJzsgLy8gVE9ETzogcHV0IGluIG9wdGlvbnNcbiAgICAgIGN0eC5saW5lU3R5bGUgPSAnZ3JheSc7XG4gICAgICBjdHguZmlsbFN0eWxlID0gJ2dyYXknO1xuICAgICAgY3R4LnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAndG9wJztcblxuICAgICAgdmFyIHggPSB0aGlzLm1hcmdpbjtcbiAgICAgIHZhciB5ID0gdGhpcy5tYXJnaW47XG4gICAgICBjdHguZmlsbFRleHQodGhpcy5kYXRhRmlsdGVyLmdldExhYmVsKCkgKyAnOiAnICsgdGhpcy5kYXRhRmlsdGVyLmdldFNlbGVjdGVkVmFsdWUoKSwgeCwgeSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZWRyYXcgdGhlIGF4aXNcbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLl9yZWRyYXdBeGlzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYW52YXMgPSB0aGlzLmZyYW1lLmNhbnZhcyxcbiAgICAgICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyksXG4gICAgICAgIGZyb20sXG4gICAgICAgIHRvLFxuICAgICAgICBzdGVwLFxuICAgICAgICBwcmV0dHlTdGVwLFxuICAgICAgICB0ZXh0LFxuICAgICAgICB4VGV4dCxcbiAgICAgICAgeVRleHQsXG4gICAgICAgIHpUZXh0LFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIHhPZmZzZXQsXG4gICAgICAgIHlPZmZzZXQsXG4gICAgICAgIHhNaW4yZCxcbiAgICAgICAgeE1heDJkO1xuXG4gICAgLy8gVE9ETzogZ2V0IHRoZSBhY3R1YWwgcmVuZGVyZWQgc3R5bGUgb2YgdGhlIGNvbnRhaW5lckVsZW1lbnRcbiAgICAvL2N0eC5mb250ID0gdGhpcy5jb250YWluZXJFbGVtZW50LnN0eWxlLmZvbnQ7XG4gICAgY3R4LmZvbnQgPSAyNCAvIHRoaXMuY2FtZXJhLmdldEFybUxlbmd0aCgpICsgJ3B4IGFyaWFsJztcblxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgbGVuZ3RoIGZvciB0aGUgc2hvcnQgZ3JpZCBsaW5lc1xuICAgIHZhciBncmlkTGVuWCA9IDAuMDI1IC8gdGhpcy5zY2FsZS54O1xuICAgIHZhciBncmlkTGVuWSA9IDAuMDI1IC8gdGhpcy5zY2FsZS55O1xuICAgIHZhciB0ZXh0TWFyZ2luID0gNSAvIHRoaXMuY2FtZXJhLmdldEFybUxlbmd0aCgpOyAvLyBweFxuICAgIHZhciBhcm1BbmdsZSA9IHRoaXMuY2FtZXJhLmdldEFybVJvdGF0aW9uKCkuaG9yaXpvbnRhbDtcblxuICAgIC8vIGRyYXcgeC1ncmlkIGxpbmVzXG4gICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgcHJldHR5U3RlcCA9IHRoaXMuZGVmYXVsdFhTdGVwID09PSB1bmRlZmluZWQ7XG4gICAgc3RlcCA9IG5ldyBTdGVwTnVtYmVyKHRoaXMueE1pbiwgdGhpcy54TWF4LCB0aGlzLnhTdGVwLCBwcmV0dHlTdGVwKTtcbiAgICBzdGVwLnN0YXJ0KCk7XG4gICAgaWYgKHN0ZXAuZ2V0Q3VycmVudCgpIDwgdGhpcy54TWluKSB7XG4gICAgICBzdGVwLm5leHQoKTtcbiAgICB9XG4gICAgd2hpbGUgKCFzdGVwLmVuZCgpKSB7XG4gICAgICB2YXIgeCA9IHN0ZXAuZ2V0Q3VycmVudCgpO1xuXG4gICAgICBpZiAodGhpcy5zaG93R3JpZCkge1xuICAgICAgICBmcm9tID0gdGhpcy5fY29udmVydDNEdG8yRChuZXcgUG9pbnQzZCh4LCB0aGlzLnlNaW4sIHRoaXMuek1pbikpO1xuICAgICAgICB0byA9IHRoaXMuX2NvbnZlcnQzRHRvMkQobmV3IFBvaW50M2QoeCwgdGhpcy55TWF4LCB0aGlzLnpNaW4pKTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5ncmlkQ29sb3I7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhmcm9tLngsIGZyb20ueSk7XG4gICAgICAgIGN0eC5saW5lVG8odG8ueCwgdG8ueSk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyb20gPSB0aGlzLl9jb252ZXJ0M0R0bzJEKG5ldyBQb2ludDNkKHgsIHRoaXMueU1pbiwgdGhpcy56TWluKSk7XG4gICAgICAgIHRvID0gdGhpcy5fY29udmVydDNEdG8yRChuZXcgUG9pbnQzZCh4LCB0aGlzLnlNaW4gKyBncmlkTGVuWCwgdGhpcy56TWluKSk7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuYXhpc0NvbG9yO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8oZnJvbS54LCBmcm9tLnkpO1xuICAgICAgICBjdHgubGluZVRvKHRvLngsIHRvLnkpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgZnJvbSA9IHRoaXMuX2NvbnZlcnQzRHRvMkQobmV3IFBvaW50M2QoeCwgdGhpcy55TWF4LCB0aGlzLnpNaW4pKTtcbiAgICAgICAgdG8gPSB0aGlzLl9jb252ZXJ0M0R0bzJEKG5ldyBQb2ludDNkKHgsIHRoaXMueU1heCAtIGdyaWRMZW5YLCB0aGlzLnpNaW4pKTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5heGlzQ29sb3I7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhmcm9tLngsIGZyb20ueSk7XG4gICAgICAgIGN0eC5saW5lVG8odG8ueCwgdG8ueSk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIH1cblxuICAgICAgeVRleHQgPSBNYXRoLmNvcyhhcm1BbmdsZSkgPiAwID8gdGhpcy55TWluIDogdGhpcy55TWF4O1xuICAgICAgdGV4dCA9IHRoaXMuX2NvbnZlcnQzRHRvMkQobmV3IFBvaW50M2QoeCwgeVRleHQsIHRoaXMuek1pbikpO1xuICAgICAgaWYgKE1hdGguY29zKGFybUFuZ2xlICogMikgPiAwKSB7XG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICd0b3AnO1xuICAgICAgICB0ZXh0LnkgKz0gdGV4dE1hcmdpbjtcbiAgICAgIH0gZWxzZSBpZiAoTWF0aC5zaW4oYXJtQW5nbGUgKiAyKSA8IDApIHtcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgIH1cbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmF4aXNDb2xvcjtcbiAgICAgIGN0eC5maWxsVGV4dCgnICAnICsgdGhpcy54VmFsdWVMYWJlbChzdGVwLmdldEN1cnJlbnQoKSkgKyAnICAnLCB0ZXh0LngsIHRleHQueSk7XG5cbiAgICAgIHN0ZXAubmV4dCgpO1xuICAgIH1cblxuICAgIC8vIGRyYXcgeS1ncmlkIGxpbmVzXG4gICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgcHJldHR5U3RlcCA9IHRoaXMuZGVmYXVsdFlTdGVwID09PSB1bmRlZmluZWQ7XG4gICAgc3RlcCA9IG5ldyBTdGVwTnVtYmVyKHRoaXMueU1pbiwgdGhpcy55TWF4LCB0aGlzLnlTdGVwLCBwcmV0dHlTdGVwKTtcbiAgICBzdGVwLnN0YXJ0KCk7XG4gICAgaWYgKHN0ZXAuZ2V0Q3VycmVudCgpIDwgdGhpcy55TWluKSB7XG4gICAgICBzdGVwLm5leHQoKTtcbiAgICB9XG4gICAgd2hpbGUgKCFzdGVwLmVuZCgpKSB7XG4gICAgICBpZiAodGhpcy5zaG93R3JpZCkge1xuICAgICAgICBmcm9tID0gdGhpcy5fY29udmVydDNEdG8yRChuZXcgUG9pbnQzZCh0aGlzLnhNaW4sIHN0ZXAuZ2V0Q3VycmVudCgpLCB0aGlzLnpNaW4pKTtcbiAgICAgICAgdG8gPSB0aGlzLl9jb252ZXJ0M0R0bzJEKG5ldyBQb2ludDNkKHRoaXMueE1heCwgc3RlcC5nZXRDdXJyZW50KCksIHRoaXMuek1pbikpO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmdyaWRDb2xvcjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKGZyb20ueCwgZnJvbS55KTtcbiAgICAgICAgY3R4LmxpbmVUbyh0by54LCB0by55KTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJvbSA9IHRoaXMuX2NvbnZlcnQzRHRvMkQobmV3IFBvaW50M2QodGhpcy54TWluLCBzdGVwLmdldEN1cnJlbnQoKSwgdGhpcy56TWluKSk7XG4gICAgICAgIHRvID0gdGhpcy5fY29udmVydDNEdG8yRChuZXcgUG9pbnQzZCh0aGlzLnhNaW4gKyBncmlkTGVuWSwgc3RlcC5nZXRDdXJyZW50KCksIHRoaXMuek1pbikpO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmF4aXNDb2xvcjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKGZyb20ueCwgZnJvbS55KTtcbiAgICAgICAgY3R4LmxpbmVUbyh0by54LCB0by55KTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgIGZyb20gPSB0aGlzLl9jb252ZXJ0M0R0bzJEKG5ldyBQb2ludDNkKHRoaXMueE1heCwgc3RlcC5nZXRDdXJyZW50KCksIHRoaXMuek1pbikpO1xuICAgICAgICB0byA9IHRoaXMuX2NvbnZlcnQzRHRvMkQobmV3IFBvaW50M2QodGhpcy54TWF4IC0gZ3JpZExlblksIHN0ZXAuZ2V0Q3VycmVudCgpLCB0aGlzLnpNaW4pKTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5heGlzQ29sb3I7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhmcm9tLngsIGZyb20ueSk7XG4gICAgICAgIGN0eC5saW5lVG8odG8ueCwgdG8ueSk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIH1cblxuICAgICAgeFRleHQgPSBNYXRoLnNpbihhcm1BbmdsZSkgPiAwID8gdGhpcy54TWluIDogdGhpcy54TWF4O1xuICAgICAgdGV4dCA9IHRoaXMuX2NvbnZlcnQzRHRvMkQobmV3IFBvaW50M2QoeFRleHQsIHN0ZXAuZ2V0Q3VycmVudCgpLCB0aGlzLnpNaW4pKTtcbiAgICAgIGlmIChNYXRoLmNvcyhhcm1BbmdsZSAqIDIpIDwgMCkge1xuICAgICAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAndG9wJztcbiAgICAgICAgdGV4dC55ICs9IHRleHRNYXJnaW47XG4gICAgICB9IGVsc2UgaWYgKE1hdGguc2luKGFybUFuZ2xlICogMikgPiAwKSB7XG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICB9XG4gICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5heGlzQ29sb3I7XG4gICAgICBjdHguZmlsbFRleHQoJyAgJyArIHRoaXMueVZhbHVlTGFiZWwoc3RlcC5nZXRDdXJyZW50KCkpICsgJyAgJywgdGV4dC54LCB0ZXh0LnkpO1xuXG4gICAgICBzdGVwLm5leHQoKTtcbiAgICB9XG5cbiAgICAvLyBkcmF3IHotZ3JpZCBsaW5lcyBhbmQgYXhpc1xuICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgIHByZXR0eVN0ZXAgPSB0aGlzLmRlZmF1bHRaU3RlcCA9PT0gdW5kZWZpbmVkO1xuICAgIHN0ZXAgPSBuZXcgU3RlcE51bWJlcih0aGlzLnpNaW4sIHRoaXMuek1heCwgdGhpcy56U3RlcCwgcHJldHR5U3RlcCk7XG4gICAgc3RlcC5zdGFydCgpO1xuICAgIGlmIChzdGVwLmdldEN1cnJlbnQoKSA8IHRoaXMuek1pbikge1xuICAgICAgc3RlcC5uZXh0KCk7XG4gICAgfVxuICAgIHhUZXh0ID0gTWF0aC5jb3MoYXJtQW5nbGUpID4gMCA/IHRoaXMueE1pbiA6IHRoaXMueE1heDtcbiAgICB5VGV4dCA9IE1hdGguc2luKGFybUFuZ2xlKSA8IDAgPyB0aGlzLnlNaW4gOiB0aGlzLnlNYXg7XG4gICAgd2hpbGUgKCFzdGVwLmVuZCgpKSB7XG4gICAgICAvLyBUT0RPOiBtYWtlIHotZ3JpZCBsaW5lcyByZWFsbHkgM2Q/XG4gICAgICBmcm9tID0gdGhpcy5fY29udmVydDNEdG8yRChuZXcgUG9pbnQzZCh4VGV4dCwgeVRleHQsIHN0ZXAuZ2V0Q3VycmVudCgpKSk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmF4aXNDb2xvcjtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8oZnJvbS54LCBmcm9tLnkpO1xuICAgICAgY3R4LmxpbmVUbyhmcm9tLnggLSB0ZXh0TWFyZ2luLCBmcm9tLnkpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICBjdHgudGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmF4aXNDb2xvcjtcbiAgICAgIGN0eC5maWxsVGV4dCh0aGlzLnpWYWx1ZUxhYmVsKHN0ZXAuZ2V0Q3VycmVudCgpKSArICcgJywgZnJvbS54IC0gNSwgZnJvbS55KTtcblxuICAgICAgc3RlcC5uZXh0KCk7XG4gICAgfVxuICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgIGZyb20gPSB0aGlzLl9jb252ZXJ0M0R0bzJEKG5ldyBQb2ludDNkKHhUZXh0LCB5VGV4dCwgdGhpcy56TWluKSk7XG4gICAgdG8gPSB0aGlzLl9jb252ZXJ0M0R0bzJEKG5ldyBQb2ludDNkKHhUZXh0LCB5VGV4dCwgdGhpcy56TWF4KSk7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5heGlzQ29sb3I7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oZnJvbS54LCBmcm9tLnkpO1xuICAgIGN0eC5saW5lVG8odG8ueCwgdG8ueSk7XG4gICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgLy8gZHJhdyB4LWF4aXNcbiAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICAvLyBsaW5lIGF0IHlNaW5cbiAgICB4TWluMmQgPSB0aGlzLl9jb252ZXJ0M0R0bzJEKG5ldyBQb2ludDNkKHRoaXMueE1pbiwgdGhpcy55TWluLCB0aGlzLnpNaW4pKTtcbiAgICB4TWF4MmQgPSB0aGlzLl9jb252ZXJ0M0R0bzJEKG5ldyBQb2ludDNkKHRoaXMueE1heCwgdGhpcy55TWluLCB0aGlzLnpNaW4pKTtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmF4aXNDb2xvcjtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyh4TWluMmQueCwgeE1pbjJkLnkpO1xuICAgIGN0eC5saW5lVG8oeE1heDJkLngsIHhNYXgyZC55KTtcbiAgICBjdHguc3Ryb2tlKCk7XG4gICAgLy8gbGluZSBhdCB5bWF4XG4gICAgeE1pbjJkID0gdGhpcy5fY29udmVydDNEdG8yRChuZXcgUG9pbnQzZCh0aGlzLnhNaW4sIHRoaXMueU1heCwgdGhpcy56TWluKSk7XG4gICAgeE1heDJkID0gdGhpcy5fY29udmVydDNEdG8yRChuZXcgUG9pbnQzZCh0aGlzLnhNYXgsIHRoaXMueU1heCwgdGhpcy56TWluKSk7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5heGlzQ29sb3I7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oeE1pbjJkLngsIHhNaW4yZC55KTtcbiAgICBjdHgubGluZVRvKHhNYXgyZC54LCB4TWF4MmQueSk7XG4gICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgLy8gZHJhdyB5LWF4aXNcbiAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICAvLyBsaW5lIGF0IHhNaW5cbiAgICBmcm9tID0gdGhpcy5fY29udmVydDNEdG8yRChuZXcgUG9pbnQzZCh0aGlzLnhNaW4sIHRoaXMueU1pbiwgdGhpcy56TWluKSk7XG4gICAgdG8gPSB0aGlzLl9jb252ZXJ0M0R0bzJEKG5ldyBQb2ludDNkKHRoaXMueE1pbiwgdGhpcy55TWF4LCB0aGlzLnpNaW4pKTtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmF4aXNDb2xvcjtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyhmcm9tLngsIGZyb20ueSk7XG4gICAgY3R4LmxpbmVUbyh0by54LCB0by55KTtcbiAgICBjdHguc3Ryb2tlKCk7XG4gICAgLy8gbGluZSBhdCB4TWF4XG4gICAgZnJvbSA9IHRoaXMuX2NvbnZlcnQzRHRvMkQobmV3IFBvaW50M2QodGhpcy54TWF4LCB0aGlzLnlNaW4sIHRoaXMuek1pbikpO1xuICAgIHRvID0gdGhpcy5fY29udmVydDNEdG8yRChuZXcgUG9pbnQzZCh0aGlzLnhNYXgsIHRoaXMueU1heCwgdGhpcy56TWluKSk7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5heGlzQ29sb3I7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oZnJvbS54LCBmcm9tLnkpO1xuICAgIGN0eC5saW5lVG8odG8ueCwgdG8ueSk7XG4gICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgLy8gZHJhdyB4LWxhYmVsXG4gICAgdmFyIHhMYWJlbCA9IHRoaXMueExhYmVsO1xuICAgIGlmICh4TGFiZWwubGVuZ3RoID4gMCkge1xuICAgICAgeU9mZnNldCA9IDAuMSAvIHRoaXMuc2NhbGUueTtcbiAgICAgIHhUZXh0ID0gKHRoaXMueE1pbiArIHRoaXMueE1heCkgLyAyO1xuICAgICAgeVRleHQgPSBNYXRoLmNvcyhhcm1BbmdsZSkgPiAwID8gdGhpcy55TWluIC0geU9mZnNldCA6IHRoaXMueU1heCArIHlPZmZzZXQ7XG4gICAgICB0ZXh0ID0gdGhpcy5fY29udmVydDNEdG8yRChuZXcgUG9pbnQzZCh4VGV4dCwgeVRleHQsIHRoaXMuek1pbikpO1xuICAgICAgaWYgKE1hdGguY29zKGFybUFuZ2xlICogMikgPiAwKSB7XG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICd0b3AnO1xuICAgICAgfSBlbHNlIGlmIChNYXRoLnNpbihhcm1BbmdsZSAqIDIpIDwgMCkge1xuICAgICAgICBjdHgudGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgfVxuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuYXhpc0NvbG9yO1xuICAgICAgY3R4LmZpbGxUZXh0KHhMYWJlbCwgdGV4dC54LCB0ZXh0LnkpO1xuICAgIH1cblxuICAgIC8vIGRyYXcgeS1sYWJlbFxuICAgIHZhciB5TGFiZWwgPSB0aGlzLnlMYWJlbDtcbiAgICBpZiAoeUxhYmVsLmxlbmd0aCA+IDApIHtcbiAgICAgIHhPZmZzZXQgPSAwLjEgLyB0aGlzLnNjYWxlLng7XG4gICAgICB4VGV4dCA9IE1hdGguc2luKGFybUFuZ2xlKSA+IDAgPyB0aGlzLnhNaW4gLSB4T2Zmc2V0IDogdGhpcy54TWF4ICsgeE9mZnNldDtcbiAgICAgIHlUZXh0ID0gKHRoaXMueU1pbiArIHRoaXMueU1heCkgLyAyO1xuICAgICAgdGV4dCA9IHRoaXMuX2NvbnZlcnQzRHRvMkQobmV3IFBvaW50M2QoeFRleHQsIHlUZXh0LCB0aGlzLnpNaW4pKTtcbiAgICAgIGlmIChNYXRoLmNvcyhhcm1BbmdsZSAqIDIpIDwgMCkge1xuICAgICAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAndG9wJztcbiAgICAgIH0gZWxzZSBpZiAoTWF0aC5zaW4oYXJtQW5nbGUgKiAyKSA+IDApIHtcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgIH1cbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmF4aXNDb2xvcjtcbiAgICAgIGN0eC5maWxsVGV4dCh5TGFiZWwsIHRleHQueCwgdGV4dC55KTtcbiAgICB9XG5cbiAgICAvLyBkcmF3IHotbGFiZWxcbiAgICB2YXIgekxhYmVsID0gdGhpcy56TGFiZWw7XG4gICAgaWYgKHpMYWJlbC5sZW5ndGggPiAwKSB7XG4gICAgICBvZmZzZXQgPSAzMDsgLy8gcGl4ZWxzLiAgLy8gVE9ETzogcmVsYXRlIHRvIHRoZSBtYXggd2lkdGggb2YgdGhlIHZhbHVlcyBvbiB0aGUgeiBheGlzP1xuICAgICAgeFRleHQgPSBNYXRoLmNvcyhhcm1BbmdsZSkgPiAwID8gdGhpcy54TWluIDogdGhpcy54TWF4O1xuICAgICAgeVRleHQgPSBNYXRoLnNpbihhcm1BbmdsZSkgPCAwID8gdGhpcy55TWluIDogdGhpcy55TWF4O1xuICAgICAgelRleHQgPSAodGhpcy56TWluICsgdGhpcy56TWF4KSAvIDI7XG4gICAgICB0ZXh0ID0gdGhpcy5fY29udmVydDNEdG8yRChuZXcgUG9pbnQzZCh4VGV4dCwgeVRleHQsIHpUZXh0KSk7XG4gICAgICBjdHgudGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmF4aXNDb2xvcjtcbiAgICAgIGN0eC5maWxsVGV4dCh6TGFiZWwsIHRleHQueCAtIG9mZnNldCwgdGV4dC55KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgY29sb3IgYmFzZWQgb24gdGhlIGdpdmVuIHZhbHVlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gSCAgIEh1ZSwgYSB2YWx1ZSBiZSBiZXR3ZWVuIDAgYW5kIDM2MFxuICAgKiBAcGFyYW0ge051bWJlcn0gUyAgIFNhdHVyYXRpb24sIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBWICAgVmFsdWUsIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5faHN2MnJnYiA9IGZ1bmN0aW9uIChILCBTLCBWKSB7XG4gICAgdmFyIFIsIEcsIEIsIEMsIEhpLCBYO1xuXG4gICAgQyA9IFYgKiBTO1xuICAgIEhpID0gTWF0aC5mbG9vcihIIC8gNjApOyAvLyBoaSA9IDAsMSwyLDMsNCw1XG4gICAgWCA9IEMgKiAoMSAtIE1hdGguYWJzKEggLyA2MCAlIDIgLSAxKSk7XG5cbiAgICBzd2l0Y2ggKEhpKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIFIgPSBDO0cgPSBYO0IgPSAwO2JyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICBSID0gWDtHID0gQztCID0gMDticmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgUiA9IDA7RyA9IEM7QiA9IFg7YnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIFIgPSAwO0cgPSBYO0IgPSBDO2JyZWFrO1xuICAgICAgY2FzZSA0OlxuICAgICAgICBSID0gWDtHID0gMDtCID0gQzticmVhaztcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgUiA9IEM7RyA9IDA7QiA9IFg7YnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIFIgPSAwO0cgPSAwO0IgPSAwO2JyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiAnUkdCKCcgKyBwYXJzZUludChSICogMjU1KSArICcsJyArIHBhcnNlSW50KEcgKiAyNTUpICsgJywnICsgcGFyc2VJbnQoQiAqIDI1NSkgKyAnKSc7XG4gIH07XG5cbiAgLyoqXG4gICAqIERyYXcgYWxsIGRhdGFwb2ludHMgYXMgYSBncmlkXG4gICAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgd2hlbiB0aGUgc3R5bGUgaXMgJ2dyaWQnXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5fcmVkcmF3RGF0YUdyaWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhbnZhcyA9IHRoaXMuZnJhbWUuY2FudmFzLFxuICAgICAgICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgICAgcG9pbnQsXG4gICAgICAgIHJpZ2h0LFxuICAgICAgICB0b3AsXG4gICAgICAgIGNyb3NzLFxuICAgICAgICBpLFxuICAgICAgICB0b3BTaWRlVmlzaWJsZSxcbiAgICAgICAgZmlsbFN0eWxlLFxuICAgICAgICBzdHJva2VTdHlsZSxcbiAgICAgICAgbGluZVdpZHRoLFxuICAgICAgICBoLFxuICAgICAgICBzLFxuICAgICAgICB2LFxuICAgICAgICB6QXZnO1xuXG4gICAgY3R4LmxpbmVKb2luID0gJ3JvdW5kJztcbiAgICBjdHgubGluZUNhcCA9ICdyb3VuZCc7XG5cbiAgICBpZiAodGhpcy5kYXRhUG9pbnRzID09PSB1bmRlZmluZWQgfHwgdGhpcy5kYXRhUG9pbnRzLmxlbmd0aCA8PSAwKSByZXR1cm47IC8vIFRPRE86IHRocm93IGV4Y2VwdGlvbj9cblxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgdHJhbnNsYXRpb25zIGFuZCBzY3JlZW4gcG9zaXRpb24gb2YgYWxsIHBvaW50c1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmRhdGFQb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0cmFucyA9IHRoaXMuX2NvbnZlcnRQb2ludFRvVHJhbnNsYXRpb24odGhpcy5kYXRhUG9pbnRzW2ldLnBvaW50KTtcbiAgICAgIHZhciBzY3JlZW4gPSB0aGlzLl9jb252ZXJ0VHJhbnNsYXRpb25Ub1NjcmVlbih0cmFucyk7XG5cbiAgICAgIHRoaXMuZGF0YVBvaW50c1tpXS50cmFucyA9IHRyYW5zO1xuICAgICAgdGhpcy5kYXRhUG9pbnRzW2ldLnNjcmVlbiA9IHNjcmVlbjtcblxuICAgICAgLy8gY2FsY3VsYXRlIHRoZSB0cmFuc2xhdGlvbiBvZiB0aGUgcG9pbnQgYXQgdGhlIGJvdHRvbSAobmVlZGVkIGZvciBzb3J0aW5nKVxuICAgICAgdmFyIHRyYW5zQm90dG9tID0gdGhpcy5fY29udmVydFBvaW50VG9UcmFuc2xhdGlvbih0aGlzLmRhdGFQb2ludHNbaV0uYm90dG9tKTtcbiAgICAgIHRoaXMuZGF0YVBvaW50c1tpXS5kaXN0ID0gdGhpcy5zaG93UGVyc3BlY3RpdmUgPyB0cmFuc0JvdHRvbS5sZW5ndGgoKSA6IC10cmFuc0JvdHRvbS56O1xuICAgIH1cblxuICAgIC8vIHNvcnQgdGhlIHBvaW50cyBvbiBkZXB0aCBvZiB0aGVpciAoeCx5KSBwb3NpdGlvbiAobm90IG9uIHopXG4gICAgdmFyIHNvcnREZXB0aCA9IGZ1bmN0aW9uIHNvcnREZXB0aChhLCBiKSB7XG4gICAgICByZXR1cm4gYi5kaXN0IC0gYS5kaXN0O1xuICAgIH07XG4gICAgdGhpcy5kYXRhUG9pbnRzLnNvcnQoc29ydERlcHRoKTtcblxuICAgIGlmICh0aGlzLnN0eWxlID09PSBHcmFwaDNkLlNUWUxFLlNVUkZBQ0UpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmRhdGFQb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcG9pbnQgPSB0aGlzLmRhdGFQb2ludHNbaV07XG4gICAgICAgIHJpZ2h0ID0gdGhpcy5kYXRhUG9pbnRzW2ldLnBvaW50UmlnaHQ7XG4gICAgICAgIHRvcCA9IHRoaXMuZGF0YVBvaW50c1tpXS5wb2ludFRvcDtcbiAgICAgICAgY3Jvc3MgPSB0aGlzLmRhdGFQb2ludHNbaV0ucG9pbnRDcm9zcztcblxuICAgICAgICBpZiAocG9pbnQgIT09IHVuZGVmaW5lZCAmJiByaWdodCAhPT0gdW5kZWZpbmVkICYmIHRvcCAhPT0gdW5kZWZpbmVkICYmIGNyb3NzICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgIGlmICh0aGlzLnNob3dHcmF5Qm90dG9tIHx8IHRoaXMuc2hvd1NoYWRvdykge1xuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHRoZSB0d28gdmVjdG9ycyBmcm9tIGNlbnRlclxuICAgICAgICAgICAgLy8gdG8gbGVmdCBhbmQgcmlnaHQsIGluIG9yZGVyIHRvIGtub3cgd2hldGhlciB3ZSBhcmUgbG9va2luZyBhdCB0aGVcbiAgICAgICAgICAgIC8vIGJvdHRvbSBvciBhdCB0aGUgdG9wIHNpZGUuIFdlIGNhbiBhbHNvIHVzZSB0aGUgY3Jvc3MgcHJvZHVjdFxuICAgICAgICAgICAgLy8gZm9yIGNhbGN1bGF0aW5nIGxpZ2h0IGludGVuc2l0eVxuICAgICAgICAgICAgdmFyIGFEaWZmID0gUG9pbnQzZC5zdWJ0cmFjdChjcm9zcy50cmFucywgcG9pbnQudHJhbnMpO1xuICAgICAgICAgICAgdmFyIGJEaWZmID0gUG9pbnQzZC5zdWJ0cmFjdCh0b3AudHJhbnMsIHJpZ2h0LnRyYW5zKTtcbiAgICAgICAgICAgIHZhciBjcm9zc3Byb2R1Y3QgPSBQb2ludDNkLmNyb3NzUHJvZHVjdChhRGlmZiwgYkRpZmYpO1xuICAgICAgICAgICAgdmFyIGxlbiA9IGNyb3NzcHJvZHVjdC5sZW5ndGgoKTtcbiAgICAgICAgICAgIC8vIEZJWE1FOiB0aGVyZSBpcyBhIGJ1ZyB3aXRoIGRldGVybWluaW5nIHRoZSBzdXJmYWNlIHNpZGUgKHNoYWRvdyBvciBjb2xvcmVkKVxuXG4gICAgICAgICAgICB0b3BTaWRlVmlzaWJsZSA9IGNyb3NzcHJvZHVjdC56ID4gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9wU2lkZVZpc2libGUgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0b3BTaWRlVmlzaWJsZSkge1xuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIEh1ZSBmcm9tIHRoZSBjdXJyZW50IHZhbHVlLiBBdCB6TWluIHRoZSBodWUgaXMgMjQwLCBhdCB6TWF4IHRoZSBodWUgaXMgMFxuICAgICAgICAgICAgekF2ZyA9IChwb2ludC5wb2ludC56ICsgcmlnaHQucG9pbnQueiArIHRvcC5wb2ludC56ICsgY3Jvc3MucG9pbnQueikgLyA0O1xuICAgICAgICAgICAgaCA9ICgxIC0gKHpBdmcgLSB0aGlzLnpNaW4pICogdGhpcy5zY2FsZS56IC8gdGhpcy52ZXJ0aWNhbFJhdGlvKSAqIDI0MDtcbiAgICAgICAgICAgIHMgPSAxOyAvLyBzYXR1cmF0aW9uXG5cbiAgICAgICAgICAgIGlmICh0aGlzLnNob3dTaGFkb3cpIHtcbiAgICAgICAgICAgICAgdiA9IE1hdGgubWluKDEgKyBjcm9zc3Byb2R1Y3QueCAvIGxlbiAvIDIsIDEpOyAvLyB2YWx1ZS4gVE9ETzogc2NhbGVcbiAgICAgICAgICAgICAgZmlsbFN0eWxlID0gdGhpcy5faHN2MnJnYihoLCBzLCB2KTtcbiAgICAgICAgICAgICAgc3Ryb2tlU3R5bGUgPSBmaWxsU3R5bGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2ID0gMTtcbiAgICAgICAgICAgICAgZmlsbFN0eWxlID0gdGhpcy5faHN2MnJnYihoLCBzLCB2KTtcbiAgICAgICAgICAgICAgc3Ryb2tlU3R5bGUgPSB0aGlzLmF4aXNDb2xvcjsgLy8gVE9ETzogc2hvdWxkIGJlIGN1c3RvbWl6YWJsZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZpbGxTdHlsZSA9ICdncmF5JztcbiAgICAgICAgICAgICAgc3Ryb2tlU3R5bGUgPSB0aGlzLmF4aXNDb2xvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLl9nZXRTdHJva2VXaWR0aChwb2ludCk7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcbiAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZTtcbiAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgY3R4Lm1vdmVUbyhwb2ludC5zY3JlZW4ueCwgcG9pbnQuc2NyZWVuLnkpO1xuICAgICAgICAgIGN0eC5saW5lVG8ocmlnaHQuc2NyZWVuLngsIHJpZ2h0LnNjcmVlbi55KTtcbiAgICAgICAgICBjdHgubGluZVRvKGNyb3NzLnNjcmVlbi54LCBjcm9zcy5zY3JlZW4ueSk7XG4gICAgICAgICAgY3R4LmxpbmVUbyh0b3Auc2NyZWVuLngsIHRvcC5zY3JlZW4ueSk7XG4gICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgY3R4LnN0cm9rZSgpOyAvLyBUT0RPOiBvbmx5IGRyYXcgc3Ryb2tlIHdoZW4gc3Ryb2tlV2lkdGggPiAwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBncmlkIHN0eWxlXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmRhdGFQb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBwb2ludCA9IHRoaXMuZGF0YVBvaW50c1tpXTtcbiAgICAgICAgICByaWdodCA9IHRoaXMuZGF0YVBvaW50c1tpXS5wb2ludFJpZ2h0O1xuICAgICAgICAgIHRvcCA9IHRoaXMuZGF0YVBvaW50c1tpXS5wb2ludFRvcDtcblxuICAgICAgICAgIGlmIChwb2ludCAhPT0gdW5kZWZpbmVkICYmIHJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBIdWUgZnJvbSB0aGUgY3VycmVudCB2YWx1ZS4gQXQgek1pbiB0aGUgaHVlIGlzIDI0MCwgYXQgek1heCB0aGUgaHVlIGlzIDBcbiAgICAgICAgICAgIHpBdmcgPSAocG9pbnQucG9pbnQueiArIHJpZ2h0LnBvaW50LnopIC8gMjtcbiAgICAgICAgICAgIGggPSAoMSAtICh6QXZnIC0gdGhpcy56TWluKSAqIHRoaXMuc2NhbGUueiAvIHRoaXMudmVydGljYWxSYXRpbykgKiAyNDA7XG5cbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLl9nZXRTdHJva2VXaWR0aChwb2ludCkgKiAyO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5faHN2MnJnYihoLCAxLCAxKTtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8ocG9pbnQuc2NyZWVuLngsIHBvaW50LnNjcmVlbi55KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8ocmlnaHQuc2NyZWVuLngsIHJpZ2h0LnNjcmVlbi55KTtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocG9pbnQgIT09IHVuZGVmaW5lZCAmJiB0b3AgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIEh1ZSBmcm9tIHRoZSBjdXJyZW50IHZhbHVlLiBBdCB6TWluIHRoZSBodWUgaXMgMjQwLCBhdCB6TWF4IHRoZSBodWUgaXMgMFxuICAgICAgICAgICAgekF2ZyA9IChwb2ludC5wb2ludC56ICsgdG9wLnBvaW50LnopIC8gMjtcbiAgICAgICAgICAgIGggPSAoMSAtICh6QXZnIC0gdGhpcy56TWluKSAqIHRoaXMuc2NhbGUueiAvIHRoaXMudmVydGljYWxSYXRpbykgKiAyNDA7XG5cbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLl9nZXRTdHJva2VXaWR0aChwb2ludCkgKiAyO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5faHN2MnJnYihoLCAxLCAxKTtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8ocG9pbnQuc2NyZWVuLngsIHBvaW50LnNjcmVlbi55KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8odG9wLnNjcmVlbi54LCB0b3Auc2NyZWVuLnkpO1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICB9O1xuXG4gIEdyYXBoM2QucHJvdG90eXBlLl9nZXRTdHJva2VXaWR0aCA9IGZ1bmN0aW9uIChwb2ludCkge1xuICAgIGlmIChwb2ludCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodGhpcy5zaG93UGVyc3BlY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIDEgLyAtcG9pbnQudHJhbnMueiAqIHRoaXMuZGF0YUNvbG9yLnN0cm9rZVdpZHRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIC0odGhpcy5leWUueiAvIHRoaXMuY2FtZXJhLmdldEFybUxlbmd0aCgpKSAqIHRoaXMuZGF0YUNvbG9yLnN0cm9rZVdpZHRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmRhdGFDb2xvci5zdHJva2VXaWR0aDtcbiAgfTtcblxuICAvKipcbiAgICogRHJhdyBhbGwgZGF0YXBvaW50cyBhcyBkb3RzLlxuICAgKiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHdoZW4gdGhlIHN0eWxlIGlzICdkb3QnIG9yICdkb3QtbGluZSdcbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLl9yZWRyYXdEYXRhRG90ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYW52YXMgPSB0aGlzLmZyYW1lLmNhbnZhcztcbiAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgdmFyIGk7XG5cbiAgICBpZiAodGhpcy5kYXRhUG9pbnRzID09PSB1bmRlZmluZWQgfHwgdGhpcy5kYXRhUG9pbnRzLmxlbmd0aCA8PSAwKSByZXR1cm47IC8vIFRPRE86IHRocm93IGV4Y2VwdGlvbj9cblxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgdHJhbnNsYXRpb25zIG9mIGFsbCBwb2ludHNcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5kYXRhUG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdHJhbnMgPSB0aGlzLl9jb252ZXJ0UG9pbnRUb1RyYW5zbGF0aW9uKHRoaXMuZGF0YVBvaW50c1tpXS5wb2ludCk7XG4gICAgICB2YXIgc2NyZWVuID0gdGhpcy5fY29udmVydFRyYW5zbGF0aW9uVG9TY3JlZW4odHJhbnMpO1xuICAgICAgdGhpcy5kYXRhUG9pbnRzW2ldLnRyYW5zID0gdHJhbnM7XG4gICAgICB0aGlzLmRhdGFQb2ludHNbaV0uc2NyZWVuID0gc2NyZWVuO1xuXG4gICAgICAvLyBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGZyb20gdGhlIHBvaW50IGF0IHRoZSBib3R0b20gdG8gdGhlIGNhbWVyYVxuICAgICAgdmFyIHRyYW5zQm90dG9tID0gdGhpcy5fY29udmVydFBvaW50VG9UcmFuc2xhdGlvbih0aGlzLmRhdGFQb2ludHNbaV0uYm90dG9tKTtcbiAgICAgIHRoaXMuZGF0YVBvaW50c1tpXS5kaXN0ID0gdGhpcy5zaG93UGVyc3BlY3RpdmUgPyB0cmFuc0JvdHRvbS5sZW5ndGgoKSA6IC10cmFuc0JvdHRvbS56O1xuICAgIH1cblxuICAgIC8vIG9yZGVyIHRoZSB0cmFuc2xhdGVkIHBvaW50cyBieSBkZXB0aFxuICAgIHZhciBzb3J0RGVwdGggPSBmdW5jdGlvbiBzb3J0RGVwdGgoYSwgYikge1xuICAgICAgcmV0dXJuIGIuZGlzdCAtIGEuZGlzdDtcbiAgICB9O1xuICAgIHRoaXMuZGF0YVBvaW50cy5zb3J0KHNvcnREZXB0aCk7XG5cbiAgICAvLyBkcmF3IHRoZSBkYXRhcG9pbnRzIGFzIGNvbG9yZWQgY2lyY2xlc1xuICAgIHZhciBkb3RTaXplID0gdGhpcy5mcmFtZS5jbGllbnRXaWR0aCAqIHRoaXMuZG90U2l6ZVJhdGlvOyAvLyBweFxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmRhdGFQb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwb2ludCA9IHRoaXMuZGF0YVBvaW50c1tpXTtcblxuICAgICAgaWYgKHRoaXMuc3R5bGUgPT09IEdyYXBoM2QuU1RZTEUuRE9UTElORSkge1xuICAgICAgICAvLyBkcmF3IGEgdmVydGljYWwgbGluZSBmcm9tIHRoZSBib3R0b20gdG8gdGhlIGdyYXBoIHZhbHVlXG4gICAgICAgIC8vdmFyIGZyb20gPSB0aGlzLl9jb252ZXJ0M0R0bzJEKG5ldyBQb2ludDNkKHBvaW50LnBvaW50LngsIHBvaW50LnBvaW50LnksIHRoaXMuek1pbikpO1xuICAgICAgICB2YXIgZnJvbSA9IHRoaXMuX2NvbnZlcnQzRHRvMkQocG9pbnQuYm90dG9tKTtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuZ3JpZENvbG9yO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8oZnJvbS54LCBmcm9tLnkpO1xuICAgICAgICBjdHgubGluZVRvKHBvaW50LnNjcmVlbi54LCBwb2ludC5zY3JlZW4ueSk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIH1cblxuICAgICAgLy8gY2FsY3VsYXRlIHJhZGl1cyBmb3IgdGhlIGNpcmNsZVxuICAgICAgdmFyIHNpemU7XG4gICAgICBpZiAodGhpcy5zdHlsZSA9PT0gR3JhcGgzZC5TVFlMRS5ET1RTSVpFKSB7XG4gICAgICAgIHNpemUgPSBkb3RTaXplIC8gMiArIDIgKiBkb3RTaXplICogKHBvaW50LnBvaW50LnZhbHVlIC0gdGhpcy52YWx1ZU1pbikgLyAodGhpcy52YWx1ZU1heCAtIHRoaXMudmFsdWVNaW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2l6ZSA9IGRvdFNpemU7XG4gICAgICB9XG5cbiAgICAgIHZhciByYWRpdXM7XG4gICAgICBpZiAodGhpcy5zaG93UGVyc3BlY3RpdmUpIHtcbiAgICAgICAgcmFkaXVzID0gc2l6ZSAvIC1wb2ludC50cmFucy56O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmFkaXVzID0gc2l6ZSAqIC0odGhpcy5leWUueiAvIHRoaXMuY2FtZXJhLmdldEFybUxlbmd0aCgpKTtcbiAgICAgIH1cbiAgICAgIGlmIChyYWRpdXMgPCAwKSB7XG4gICAgICAgIHJhZGl1cyA9IDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBodWUsIGNvbG9yLCBib3JkZXJDb2xvcjtcbiAgICAgIGlmICh0aGlzLnN0eWxlID09PSBHcmFwaDNkLlNUWUxFLkRPVENPTE9SKSB7XG4gICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgY29sb3IgYmFzZWQgb24gdGhlIHZhbHVlXG4gICAgICAgIGh1ZSA9ICgxIC0gKHBvaW50LnBvaW50LnZhbHVlIC0gdGhpcy52YWx1ZU1pbikgKiB0aGlzLnNjYWxlLnZhbHVlKSAqIDI0MDtcbiAgICAgICAgY29sb3IgPSB0aGlzLl9oc3YycmdiKGh1ZSwgMSwgMSk7XG4gICAgICAgIGJvcmRlckNvbG9yID0gdGhpcy5faHN2MnJnYihodWUsIDEsIDAuOCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc3R5bGUgPT09IEdyYXBoM2QuU1RZTEUuRE9UU0laRSkge1xuICAgICAgICBjb2xvciA9IHRoaXMuZGF0YUNvbG9yLmZpbGw7XG4gICAgICAgIGJvcmRlckNvbG9yID0gdGhpcy5kYXRhQ29sb3Iuc3Ryb2tlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY2FsY3VsYXRlIEh1ZSBmcm9tIHRoZSBjdXJyZW50IHZhbHVlLiBBdCB6TWluIHRoZSBodWUgaXMgMjQwLCBhdCB6TWF4IHRoZSBodWUgaXMgMFxuICAgICAgICBodWUgPSAoMSAtIChwb2ludC5wb2ludC56IC0gdGhpcy56TWluKSAqIHRoaXMuc2NhbGUueiAvIHRoaXMudmVydGljYWxSYXRpbykgKiAyNDA7XG4gICAgICAgIGNvbG9yID0gdGhpcy5faHN2MnJnYihodWUsIDEsIDEpO1xuICAgICAgICBib3JkZXJDb2xvciA9IHRoaXMuX2hzdjJyZ2IoaHVlLCAxLCAwLjgpO1xuICAgICAgfVxuXG4gICAgICAvLyBkcmF3IHRoZSBjaXJjbGVcbiAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLl9nZXRTdHJva2VXaWR0aChwb2ludCk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBib3JkZXJDb2xvcjtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5hcmMocG9pbnQuc2NyZWVuLngsIHBvaW50LnNjcmVlbi55LCByYWRpdXMsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBEcmF3IGFsbCBkYXRhcG9pbnRzIGFzIGJhcnMuXG4gICAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgd2hlbiB0aGUgc3R5bGUgaXMgJ2JhcicsICdiYXItY29sb3InLCBvciAnYmFyLXNpemUnXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5fcmVkcmF3RGF0YUJhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FudmFzID0gdGhpcy5mcmFtZS5jYW52YXM7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHZhciBpLCBqLCBzdXJmYWNlLCBjb3JuZXJzO1xuXG4gICAgaWYgKHRoaXMuZGF0YVBvaW50cyA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuZGF0YVBvaW50cy5sZW5ndGggPD0gMCkgcmV0dXJuOyAvLyBUT0RPOiB0aHJvdyBleGNlcHRpb24/XG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIHRyYW5zbGF0aW9ucyBvZiBhbGwgcG9pbnRzXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZGF0YVBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRyYW5zID0gdGhpcy5fY29udmVydFBvaW50VG9UcmFuc2xhdGlvbih0aGlzLmRhdGFQb2ludHNbaV0ucG9pbnQpO1xuICAgICAgdmFyIHNjcmVlbiA9IHRoaXMuX2NvbnZlcnRUcmFuc2xhdGlvblRvU2NyZWVuKHRyYW5zKTtcbiAgICAgIHRoaXMuZGF0YVBvaW50c1tpXS50cmFucyA9IHRyYW5zO1xuICAgICAgdGhpcy5kYXRhUG9pbnRzW2ldLnNjcmVlbiA9IHNjcmVlbjtcblxuICAgICAgLy8gY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBwb2ludCBhdCB0aGUgYm90dG9tIHRvIHRoZSBjYW1lcmFcbiAgICAgIHZhciB0cmFuc0JvdHRvbSA9IHRoaXMuX2NvbnZlcnRQb2ludFRvVHJhbnNsYXRpb24odGhpcy5kYXRhUG9pbnRzW2ldLmJvdHRvbSk7XG4gICAgICB0aGlzLmRhdGFQb2ludHNbaV0uZGlzdCA9IHRoaXMuc2hvd1BlcnNwZWN0aXZlID8gdHJhbnNCb3R0b20ubGVuZ3RoKCkgOiAtdHJhbnNCb3R0b20uejtcbiAgICB9XG5cbiAgICAvLyBvcmRlciB0aGUgdHJhbnNsYXRlZCBwb2ludHMgYnkgZGVwdGhcbiAgICB2YXIgc29ydERlcHRoID0gZnVuY3Rpb24gc29ydERlcHRoKGEsIGIpIHtcbiAgICAgIHJldHVybiBiLmRpc3QgLSBhLmRpc3Q7XG4gICAgfTtcbiAgICB0aGlzLmRhdGFQb2ludHMuc29ydChzb3J0RGVwdGgpO1xuXG4gICAgY3R4LmxpbmVKb2luID0gJ3JvdW5kJztcbiAgICBjdHgubGluZUNhcCA9ICdyb3VuZCc7XG5cbiAgICAvLyBkcmF3IHRoZSBkYXRhcG9pbnRzIGFzIGJhcnNcbiAgICB2YXIgeFdpZHRoID0gdGhpcy54QmFyV2lkdGggLyAyO1xuICAgIHZhciB5V2lkdGggPSB0aGlzLnlCYXJXaWR0aCAvIDI7XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZGF0YVBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHBvaW50ID0gdGhpcy5kYXRhUG9pbnRzW2ldO1xuXG4gICAgICAvLyBkZXRlcm1pbmUgY29sb3JcbiAgICAgIHZhciBodWUsIGNvbG9yLCBib3JkZXJDb2xvcjtcbiAgICAgIGlmICh0aGlzLnN0eWxlID09PSBHcmFwaDNkLlNUWUxFLkJBUkNPTE9SKSB7XG4gICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgY29sb3IgYmFzZWQgb24gdGhlIHZhbHVlXG4gICAgICAgIGh1ZSA9ICgxIC0gKHBvaW50LnBvaW50LnZhbHVlIC0gdGhpcy52YWx1ZU1pbikgKiB0aGlzLnNjYWxlLnZhbHVlKSAqIDI0MDtcbiAgICAgICAgY29sb3IgPSB0aGlzLl9oc3YycmdiKGh1ZSwgMSwgMSk7XG4gICAgICAgIGJvcmRlckNvbG9yID0gdGhpcy5faHN2MnJnYihodWUsIDEsIDAuOCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc3R5bGUgPT09IEdyYXBoM2QuU1RZTEUuQkFSU0laRSkge1xuICAgICAgICBjb2xvciA9IHRoaXMuZGF0YUNvbG9yLmZpbGw7XG4gICAgICAgIGJvcmRlckNvbG9yID0gdGhpcy5kYXRhQ29sb3Iuc3Ryb2tlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY2FsY3VsYXRlIEh1ZSBmcm9tIHRoZSBjdXJyZW50IHZhbHVlLiBBdCB6TWluIHRoZSBodWUgaXMgMjQwLCBhdCB6TWF4IHRoZSBodWUgaXMgMFxuICAgICAgICBodWUgPSAoMSAtIChwb2ludC5wb2ludC56IC0gdGhpcy56TWluKSAqIHRoaXMuc2NhbGUueiAvIHRoaXMudmVydGljYWxSYXRpbykgKiAyNDA7XG4gICAgICAgIGNvbG9yID0gdGhpcy5faHN2MnJnYihodWUsIDEsIDEpO1xuICAgICAgICBib3JkZXJDb2xvciA9IHRoaXMuX2hzdjJyZ2IoaHVlLCAxLCAwLjgpO1xuICAgICAgfVxuXG4gICAgICAvLyBjYWxjdWxhdGUgc2l6ZSBmb3IgdGhlIGJhclxuICAgICAgaWYgKHRoaXMuc3R5bGUgPT09IEdyYXBoM2QuU1RZTEUuQkFSU0laRSkge1xuICAgICAgICB4V2lkdGggPSB0aGlzLnhCYXJXaWR0aCAvIDIgKiAoKHBvaW50LnBvaW50LnZhbHVlIC0gdGhpcy52YWx1ZU1pbikgLyAodGhpcy52YWx1ZU1heCAtIHRoaXMudmFsdWVNaW4pICogMC44ICsgMC4yKTtcbiAgICAgICAgeVdpZHRoID0gdGhpcy55QmFyV2lkdGggLyAyICogKChwb2ludC5wb2ludC52YWx1ZSAtIHRoaXMudmFsdWVNaW4pIC8gKHRoaXMudmFsdWVNYXggLSB0aGlzLnZhbHVlTWluKSAqIDAuOCArIDAuMik7XG4gICAgICB9XG5cbiAgICAgIC8vIGNhbGN1bGF0ZSBhbGwgY29ybmVyIHBvaW50c1xuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIHZhciBwb2ludDNkID0gcG9pbnQucG9pbnQ7XG4gICAgICB2YXIgdG9wID0gW3sgcG9pbnQ6IG5ldyBQb2ludDNkKHBvaW50M2QueCAtIHhXaWR0aCwgcG9pbnQzZC55IC0geVdpZHRoLCBwb2ludDNkLnopIH0sIHsgcG9pbnQ6IG5ldyBQb2ludDNkKHBvaW50M2QueCArIHhXaWR0aCwgcG9pbnQzZC55IC0geVdpZHRoLCBwb2ludDNkLnopIH0sIHsgcG9pbnQ6IG5ldyBQb2ludDNkKHBvaW50M2QueCArIHhXaWR0aCwgcG9pbnQzZC55ICsgeVdpZHRoLCBwb2ludDNkLnopIH0sIHsgcG9pbnQ6IG5ldyBQb2ludDNkKHBvaW50M2QueCAtIHhXaWR0aCwgcG9pbnQzZC55ICsgeVdpZHRoLCBwb2ludDNkLnopIH1dO1xuICAgICAgdmFyIGJvdHRvbSA9IFt7IHBvaW50OiBuZXcgUG9pbnQzZChwb2ludDNkLnggLSB4V2lkdGgsIHBvaW50M2QueSAtIHlXaWR0aCwgdGhpcy56TWluKSB9LCB7IHBvaW50OiBuZXcgUG9pbnQzZChwb2ludDNkLnggKyB4V2lkdGgsIHBvaW50M2QueSAtIHlXaWR0aCwgdGhpcy56TWluKSB9LCB7IHBvaW50OiBuZXcgUG9pbnQzZChwb2ludDNkLnggKyB4V2lkdGgsIHBvaW50M2QueSArIHlXaWR0aCwgdGhpcy56TWluKSB9LCB7IHBvaW50OiBuZXcgUG9pbnQzZChwb2ludDNkLnggLSB4V2lkdGgsIHBvaW50M2QueSArIHlXaWR0aCwgdGhpcy56TWluKSB9XTtcblxuICAgICAgLy8gY2FsY3VsYXRlIHNjcmVlbiBsb2NhdGlvbiBvZiB0aGUgcG9pbnRzXG4gICAgICB0b3AuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIG9iai5zY3JlZW4gPSBtZS5fY29udmVydDNEdG8yRChvYmoucG9pbnQpO1xuICAgICAgfSk7XG4gICAgICBib3R0b20uZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIG9iai5zY3JlZW4gPSBtZS5fY29udmVydDNEdG8yRChvYmoucG9pbnQpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGNyZWF0ZSBmaXZlIHNpZGVzLCBjYWxjdWxhdGUgYm90aCBjb3JuZXIgcG9pbnRzIGFuZCBjZW50ZXIgcG9pbnRzXG4gICAgICB2YXIgc3VyZmFjZXMgPSBbeyBjb3JuZXJzOiB0b3AsIGNlbnRlcjogUG9pbnQzZC5hdmcoYm90dG9tWzBdLnBvaW50LCBib3R0b21bMl0ucG9pbnQpIH0sIHsgY29ybmVyczogW3RvcFswXSwgdG9wWzFdLCBib3R0b21bMV0sIGJvdHRvbVswXV0sIGNlbnRlcjogUG9pbnQzZC5hdmcoYm90dG9tWzFdLnBvaW50LCBib3R0b21bMF0ucG9pbnQpIH0sIHsgY29ybmVyczogW3RvcFsxXSwgdG9wWzJdLCBib3R0b21bMl0sIGJvdHRvbVsxXV0sIGNlbnRlcjogUG9pbnQzZC5hdmcoYm90dG9tWzJdLnBvaW50LCBib3R0b21bMV0ucG9pbnQpIH0sIHsgY29ybmVyczogW3RvcFsyXSwgdG9wWzNdLCBib3R0b21bM10sIGJvdHRvbVsyXV0sIGNlbnRlcjogUG9pbnQzZC5hdmcoYm90dG9tWzNdLnBvaW50LCBib3R0b21bMl0ucG9pbnQpIH0sIHsgY29ybmVyczogW3RvcFszXSwgdG9wWzBdLCBib3R0b21bMF0sIGJvdHRvbVszXV0sIGNlbnRlcjogUG9pbnQzZC5hdmcoYm90dG9tWzBdLnBvaW50LCBib3R0b21bM10ucG9pbnQpIH1dO1xuICAgICAgcG9pbnQuc3VyZmFjZXMgPSBzdXJmYWNlcztcblxuICAgICAgLy8gY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBvZiBlYWNoIG9mIHRoZSBzdXJmYWNlIGNlbnRlcnMgdG8gdGhlIGNhbWVyYVxuICAgICAgZm9yIChqID0gMDsgaiA8IHN1cmZhY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHN1cmZhY2UgPSBzdXJmYWNlc1tqXTtcbiAgICAgICAgdmFyIHRyYW5zQ2VudGVyID0gdGhpcy5fY29udmVydFBvaW50VG9UcmFuc2xhdGlvbihzdXJmYWNlLmNlbnRlcik7XG4gICAgICAgIHN1cmZhY2UuZGlzdCA9IHRoaXMuc2hvd1BlcnNwZWN0aXZlID8gdHJhbnNDZW50ZXIubGVuZ3RoKCkgOiAtdHJhbnNDZW50ZXIuejtcbiAgICAgICAgLy8gVE9ETzogdGhpcyBkZXB0IGNhbGN1bGF0aW9uIGRvZXNuJ3Qgd29yayAxMDAlIG9mIHRoZSBjYXNlcyBkdWUgdG8gcGVyc3BlY3RpdmUsXG4gICAgICAgIC8vICAgICBidXQgdGhlIGN1cnJlbnQgc29sdXRpb24gaXMgZmFzdC9zaW1wbGUgYW5kIHdvcmtzIGluIDk5LjklIG9mIGFsbCBjYXNlc1xuICAgICAgICAvLyAgICAgdGhlIGlzc3VlIGlzIHZpc2libGUgaW4gZXhhbXBsZSAxNCwgd2l0aCBncmFwaC5zZXRDYW1lcmFQb3NpdGlvbih7aG9yaXpvbnRhbDogMi45NywgdmVydGljYWw6IDAuNSwgZGlzdGFuY2U6IDAuOX0pXG4gICAgICB9XG5cbiAgICAgIC8vIG9yZGVyIHRoZSBzdXJmYWNlcyBieSB0aGVpciAodHJhbnNsYXRlZCkgZGVwdGhcbiAgICAgIHN1cmZhY2VzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIGRpZmYgPSBiLmRpc3QgLSBhLmRpc3Q7XG4gICAgICAgIGlmIChkaWZmKSByZXR1cm4gZGlmZjtcblxuICAgICAgICAvLyBpZiBlcXVhbCBkZXB0aCwgc29ydCB0aGUgdG9wIHN1cmZhY2UgbGFzdFxuICAgICAgICBpZiAoYS5jb3JuZXJzID09PSB0b3ApIHJldHVybiAxO1xuICAgICAgICBpZiAoYi5jb3JuZXJzID09PSB0b3ApIHJldHVybiAtMTtcblxuICAgICAgICAvLyBib3RoIGFyZSBlcXVhbFxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBkcmF3IHRoZSBvcmRlcmVkIHN1cmZhY2VzXG4gICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5fZ2V0U3Ryb2tlV2lkdGgocG9pbnQpO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gYm9yZGVyQ29sb3I7XG4gICAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICAvLyBOT1RFOiB3ZSBzdGFydCBhdCBqPTIgaW5zdGVhZCBvZiBqPTAgYXMgd2UgZG9uJ3QgbmVlZCB0byBkcmF3IHRoZSB0d28gc3VyZmFjZXMgYXQgdGhlIGJhY2tzaWRlXG4gICAgICBmb3IgKGogPSAyOyBqIDwgc3VyZmFjZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgc3VyZmFjZSA9IHN1cmZhY2VzW2pdO1xuICAgICAgICBjb3JuZXJzID0gc3VyZmFjZS5jb3JuZXJzO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8oY29ybmVyc1szXS5zY3JlZW4ueCwgY29ybmVyc1szXS5zY3JlZW4ueSk7XG4gICAgICAgIGN0eC5saW5lVG8oY29ybmVyc1swXS5zY3JlZW4ueCwgY29ybmVyc1swXS5zY3JlZW4ueSk7XG4gICAgICAgIGN0eC5saW5lVG8oY29ybmVyc1sxXS5zY3JlZW4ueCwgY29ybmVyc1sxXS5zY3JlZW4ueSk7XG4gICAgICAgIGN0eC5saW5lVG8oY29ybmVyc1syXS5zY3JlZW4ueCwgY29ybmVyc1syXS5zY3JlZW4ueSk7XG4gICAgICAgIGN0eC5saW5lVG8oY29ybmVyc1szXS5zY3JlZW4ueCwgY29ybmVyc1szXS5zY3JlZW4ueSk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIERyYXcgYSBsaW5lIHRocm91Z2ggYWxsIGRhdGFwb2ludHMuXG4gICAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgd2hlbiB0aGUgc3R5bGUgaXMgJ2xpbmUnXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5fcmVkcmF3RGF0YUxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhbnZhcyA9IHRoaXMuZnJhbWUuY2FudmFzLFxuICAgICAgICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgICAgcG9pbnQsXG4gICAgICAgIGk7XG5cbiAgICBpZiAodGhpcy5kYXRhUG9pbnRzID09PSB1bmRlZmluZWQgfHwgdGhpcy5kYXRhUG9pbnRzLmxlbmd0aCA8PSAwKSByZXR1cm47IC8vIFRPRE86IHRocm93IGV4Y2VwdGlvbj9cblxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgdHJhbnNsYXRpb25zIG9mIGFsbCBwb2ludHNcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5kYXRhUG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdHJhbnMgPSB0aGlzLl9jb252ZXJ0UG9pbnRUb1RyYW5zbGF0aW9uKHRoaXMuZGF0YVBvaW50c1tpXS5wb2ludCk7XG4gICAgICB2YXIgc2NyZWVuID0gdGhpcy5fY29udmVydFRyYW5zbGF0aW9uVG9TY3JlZW4odHJhbnMpO1xuXG4gICAgICB0aGlzLmRhdGFQb2ludHNbaV0udHJhbnMgPSB0cmFucztcbiAgICAgIHRoaXMuZGF0YVBvaW50c1tpXS5zY3JlZW4gPSBzY3JlZW47XG4gICAgfVxuXG4gICAgLy8gc3RhcnQgdGhlIGxpbmVcbiAgICBpZiAodGhpcy5kYXRhUG9pbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHBvaW50ID0gdGhpcy5kYXRhUG9pbnRzWzBdO1xuXG4gICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5fZ2V0U3Ryb2tlV2lkdGgocG9pbnQpO1xuICAgICAgY3R4LmxpbmVKb2luID0gJ3JvdW5kJztcbiAgICAgIGN0eC5saW5lQ2FwID0gJ3JvdW5kJztcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuZGF0YUNvbG9yLnN0cm9rZTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8ocG9pbnQuc2NyZWVuLngsIHBvaW50LnNjcmVlbi55KTtcblxuICAgICAgLy8gZHJhdyB0aGUgZGF0YXBvaW50cyBhcyBjb2xvcmVkIGNpcmNsZXNcbiAgICAgIGZvciAoaSA9IDE7IGkgPCB0aGlzLmRhdGFQb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcG9pbnQgPSB0aGlzLmRhdGFQb2ludHNbaV07XG4gICAgICAgIGN0eC5saW5lVG8ocG9pbnQuc2NyZWVuLngsIHBvaW50LnNjcmVlbi55KTtcbiAgICAgIH1cblxuICAgICAgLy8gZmluaXNoIHRoZSBsaW5lXG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTdGFydCBhIG1vdmluZyBvcGVyYXRpb24gaW5zaWRlIHRoZSBwcm92aWRlZCBwYXJlbnQgZWxlbWVudFxuICAgKiBAcGFyYW0ge0V2ZW50fSAgICAgZXZlbnQgICAgIFRoZSBldmVudCB0aGF0IG9jY3VycmVkIChyZXF1aXJlZCBmb3JcbiAgICogICAgICAgICAgICAgICAgICByZXRyaWV2aW5nIHRoZSAgbW91c2UgcG9zaXRpb24pXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5fb25Nb3VzZURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBldmVudCA9IGV2ZW50IHx8IHdpbmRvdy5ldmVudDtcblxuICAgIC8vIGNoZWNrIGlmIG1vdXNlIGlzIHN0aWxsIGRvd24gKG1heSBiZSB1cCB3aGVuIGZvY3VzIGlzIGxvc3QgZm9yIGV4YW1wbGVcbiAgICAvLyBpbiBhbiBpZnJhbWUpXG4gICAgaWYgKHRoaXMubGVmdEJ1dHRvbkRvd24pIHtcbiAgICAgIHRoaXMuX29uTW91c2VVcChldmVudCk7XG4gICAgfVxuXG4gICAgLy8gb25seSByZWFjdCBvbiBsZWZ0IG1vdXNlIGJ1dHRvbiBkb3duXG4gICAgdGhpcy5sZWZ0QnV0dG9uRG93biA9IGV2ZW50LndoaWNoID8gZXZlbnQud2hpY2ggPT09IDEgOiBldmVudC5idXR0b24gPT09IDE7XG4gICAgaWYgKCF0aGlzLmxlZnRCdXR0b25Eb3duICYmICF0aGlzLnRvdWNoRG93bikgcmV0dXJuO1xuXG4gICAgLy8gZ2V0IG1vdXNlIHBvc2l0aW9uIChkaWZmZXJlbnQgY29kZSBmb3IgSUUgYW5kIGFsbCBvdGhlciBicm93c2VycylcbiAgICB0aGlzLnN0YXJ0TW91c2VYID0gZ2V0TW91c2VYKGV2ZW50KTtcbiAgICB0aGlzLnN0YXJ0TW91c2VZID0gZ2V0TW91c2VZKGV2ZW50KTtcblxuICAgIHRoaXMuc3RhcnRTdGFydCA9IG5ldyBEYXRlKHRoaXMuc3RhcnQpO1xuICAgIHRoaXMuc3RhcnRFbmQgPSBuZXcgRGF0ZSh0aGlzLmVuZCk7XG4gICAgdGhpcy5zdGFydEFybVJvdGF0aW9uID0gdGhpcy5jYW1lcmEuZ2V0QXJtUm90YXRpb24oKTtcblxuICAgIHRoaXMuZnJhbWUuc3R5bGUuY3Vyc29yID0gJ21vdmUnO1xuXG4gICAgLy8gYWRkIGV2ZW50IGxpc3RlbmVycyB0byBoYW5kbGUgbW92aW5nIHRoZSBjb250ZW50c1xuICAgIC8vIHdlIHN0b3JlIHRoZSBmdW5jdGlvbiBvbm1vdXNlbW92ZSBhbmQgb25tb3VzZXVwIGluIHRoZSBncmFwaCwgc28gd2UgY2FuXG4gICAgLy8gcmVtb3ZlIHRoZSBldmVudGxpc3RlbmVycyBsYXRlcm9uIGluIHRoZSBmdW5jdGlvbiBtb3VzZVVwKClcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHRoaXMub25tb3VzZW1vdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIG1lLl9vbk1vdXNlTW92ZShldmVudCk7XG4gICAgfTtcbiAgICB0aGlzLm9ubW91c2V1cCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgbWUuX29uTW91c2VVcChldmVudCk7XG4gICAgfTtcbiAgICB1dGlsLmFkZEV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsICdtb3VzZW1vdmUnLCBtZS5vbm1vdXNlbW92ZSk7XG4gICAgdXRpbC5hZGRFdmVudExpc3RlbmVyKGRvY3VtZW50LCAnbW91c2V1cCcsIG1lLm9ubW91c2V1cCk7XG4gICAgdXRpbC5wcmV2ZW50RGVmYXVsdChldmVudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gbW92aW5nIG9wZXJhdGluZy5cbiAgICogVGhpcyBmdW5jdGlvbiBhY3RpdmF0ZWQgZnJvbSB3aXRoaW4gdGhlIGZ1bmNpb24gR3JhcGgubW91c2VEb3duKCkuXG4gICAqIEBwYXJhbSB7RXZlbnR9ICAgZXZlbnQgIFdlbGwsIGVlaGgsIHRoZSBldmVudFxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX29uTW91c2VNb3ZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZXZlbnQgPSBldmVudCB8fCB3aW5kb3cuZXZlbnQ7XG5cbiAgICAvLyBjYWxjdWxhdGUgY2hhbmdlIGluIG1vdXNlIHBvc2l0aW9uXG4gICAgdmFyIGRpZmZYID0gcGFyc2VGbG9hdChnZXRNb3VzZVgoZXZlbnQpKSAtIHRoaXMuc3RhcnRNb3VzZVg7XG4gICAgdmFyIGRpZmZZID0gcGFyc2VGbG9hdChnZXRNb3VzZVkoZXZlbnQpKSAtIHRoaXMuc3RhcnRNb3VzZVk7XG5cbiAgICB2YXIgaG9yaXpvbnRhbE5ldyA9IHRoaXMuc3RhcnRBcm1Sb3RhdGlvbi5ob3Jpem9udGFsICsgZGlmZlggLyAyMDA7XG4gICAgdmFyIHZlcnRpY2FsTmV3ID0gdGhpcy5zdGFydEFybVJvdGF0aW9uLnZlcnRpY2FsICsgZGlmZlkgLyAyMDA7XG5cbiAgICB2YXIgc25hcEFuZ2xlID0gNDsgLy8gZGVncmVlc1xuICAgIHZhciBzbmFwVmFsdWUgPSBNYXRoLnNpbihzbmFwQW5nbGUgLyAzNjAgKiAyICogTWF0aC5QSSk7XG5cbiAgICAvLyBzbmFwIGhvcml6b250YWxseSB0byBuaWNlIGFuZ2xlcyBhdCAwcGksIDAuNXBpLCAxcGksIDEuNXBpLCBldGMuLi5cbiAgICAvLyB0aGUgLTAuMDAxIGlzIHRvIHRha2UgY2FyZSB0aGF0IHRoZSB2ZXJ0aWNhbCBheGlzIGlzIGFsd2F5cyBkcmF3biBhdCB0aGUgbGVmdCBmcm9udCBjb3JuZXJcbiAgICBpZiAoTWF0aC5hYnMoTWF0aC5zaW4oaG9yaXpvbnRhbE5ldykpIDwgc25hcFZhbHVlKSB7XG4gICAgICBob3Jpem9udGFsTmV3ID0gTWF0aC5yb3VuZChob3Jpem9udGFsTmV3IC8gTWF0aC5QSSkgKiBNYXRoLlBJIC0gMC4wMDE7XG4gICAgfVxuICAgIGlmIChNYXRoLmFicyhNYXRoLmNvcyhob3Jpem9udGFsTmV3KSkgPCBzbmFwVmFsdWUpIHtcbiAgICAgIGhvcml6b250YWxOZXcgPSAoTWF0aC5yb3VuZChob3Jpem9udGFsTmV3IC8gTWF0aC5QSSAtIDAuNSkgKyAwLjUpICogTWF0aC5QSSAtIDAuMDAxO1xuICAgIH1cblxuICAgIC8vIHNuYXAgdmVydGljYWxseSB0byBuaWNlIGFuZ2xlc1xuICAgIGlmIChNYXRoLmFicyhNYXRoLnNpbih2ZXJ0aWNhbE5ldykpIDwgc25hcFZhbHVlKSB7XG4gICAgICB2ZXJ0aWNhbE5ldyA9IE1hdGgucm91bmQodmVydGljYWxOZXcgLyBNYXRoLlBJKSAqIE1hdGguUEk7XG4gICAgfVxuICAgIGlmIChNYXRoLmFicyhNYXRoLmNvcyh2ZXJ0aWNhbE5ldykpIDwgc25hcFZhbHVlKSB7XG4gICAgICB2ZXJ0aWNhbE5ldyA9IChNYXRoLnJvdW5kKHZlcnRpY2FsTmV3IC8gTWF0aC5QSSAtIDAuNSkgKyAwLjUpICogTWF0aC5QSTtcbiAgICB9XG5cbiAgICB0aGlzLmNhbWVyYS5zZXRBcm1Sb3RhdGlvbihob3Jpem9udGFsTmV3LCB2ZXJ0aWNhbE5ldyk7XG4gICAgdGhpcy5yZWRyYXcoKTtcblxuICAgIC8vIGZpcmUgYSBjYW1lcmFQb3NpdGlvbkNoYW5nZSBldmVudFxuICAgIHZhciBwYXJhbWV0ZXJzID0gdGhpcy5nZXRDYW1lcmFQb3NpdGlvbigpO1xuICAgIHRoaXMuZW1pdCgnY2FtZXJhUG9zaXRpb25DaGFuZ2UnLCBwYXJhbWV0ZXJzKTtcblxuICAgIHV0aWwucHJldmVudERlZmF1bHQoZXZlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdG9wIG1vdmluZyBvcGVyYXRpbmcuXG4gICAqIFRoaXMgZnVuY3Rpb24gYWN0aXZhdGVkIGZyb20gd2l0aGluIHRoZSBmdW5jaW9uIEdyYXBoLm1vdXNlRG93bigpLlxuICAgKiBAcGFyYW0ge2V2ZW50fSAgZXZlbnQgICBUaGUgZXZlbnRcbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLl9vbk1vdXNlVXAgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB0aGlzLmZyYW1lLnN0eWxlLmN1cnNvciA9ICdhdXRvJztcbiAgICB0aGlzLmxlZnRCdXR0b25Eb3duID0gZmFsc2U7XG5cbiAgICAvLyByZW1vdmUgZXZlbnQgbGlzdGVuZXJzIGhlcmVcbiAgICB1dGlsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsICdtb3VzZW1vdmUnLCB0aGlzLm9ubW91c2Vtb3ZlKTtcbiAgICB1dGlsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsICdtb3VzZXVwJywgdGhpcy5vbm1vdXNldXApO1xuICAgIHV0aWwucHJldmVudERlZmF1bHQoZXZlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZnRlciBoYXZpbmcgbW92ZWQgdGhlIG1vdXNlLCBhIHRvb2x0aXAgc2hvdWxkIHBvcCB1cCB3aGVuIHRoZSBtb3VzZSBpcyByZXN0aW5nIG9uIGEgZGF0YSBwb2ludFxuICAgKiBAcGFyYW0ge0V2ZW50fSAgZXZlbnQgICBBIG1vdXNlIG1vdmUgZXZlbnRcbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLl9vblRvb2x0aXAgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZGVsYXkgPSAzMDA7IC8vIG1zXG4gICAgdmFyIGJvdW5kaW5nUmVjdCA9IHRoaXMuZnJhbWUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIG1vdXNlWCA9IGdldE1vdXNlWChldmVudCkgLSBib3VuZGluZ1JlY3QubGVmdDtcbiAgICB2YXIgbW91c2VZID0gZ2V0TW91c2VZKGV2ZW50KSAtIGJvdW5kaW5nUmVjdC50b3A7XG5cbiAgICBpZiAoIXRoaXMuc2hvd1Rvb2x0aXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50b29sdGlwVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudG9vbHRpcFRpbWVvdXQpO1xuICAgIH1cblxuICAgIC8vIChkZWxheWVkKSBkaXNwbGF5IG9mIGEgdG9vbHRpcCBvbmx5IGlmIG5vIG1vdXNlIGJ1dHRvbiBpcyBkb3duXG4gICAgaWYgKHRoaXMubGVmdEJ1dHRvbkRvd24pIHtcbiAgICAgIHRoaXMuX2hpZGVUb29sdGlwKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudG9vbHRpcCAmJiB0aGlzLnRvb2x0aXAuZGF0YVBvaW50KSB7XG4gICAgICAvLyB0b29sdGlwIGlzIGN1cnJlbnRseSB2aXNpYmxlXG4gICAgICB2YXIgZGF0YVBvaW50ID0gdGhpcy5fZGF0YVBvaW50RnJvbVhZKG1vdXNlWCwgbW91c2VZKTtcbiAgICAgIGlmIChkYXRhUG9pbnQgIT09IHRoaXMudG9vbHRpcC5kYXRhUG9pbnQpIHtcbiAgICAgICAgLy8gZGF0YXBvaW50IGNoYW5nZWRcbiAgICAgICAgaWYgKGRhdGFQb2ludCkge1xuICAgICAgICAgIHRoaXMuX3Nob3dUb29sdGlwKGRhdGFQb2ludCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5faGlkZVRvb2x0aXAoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0b29sdGlwIGlzIGN1cnJlbnRseSBub3QgdmlzaWJsZVxuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIHRoaXMudG9vbHRpcFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWUudG9vbHRpcFRpbWVvdXQgPSBudWxsO1xuXG4gICAgICAgIC8vIHNob3cgYSB0b29sdGlwIGlmIHdlIGhhdmUgYSBkYXRhIHBvaW50XG4gICAgICAgIHZhciBkYXRhUG9pbnQgPSBtZS5fZGF0YVBvaW50RnJvbVhZKG1vdXNlWCwgbW91c2VZKTtcbiAgICAgICAgaWYgKGRhdGFQb2ludCkge1xuICAgICAgICAgIG1lLl9zaG93VG9vbHRpcChkYXRhUG9pbnQpO1xuICAgICAgICB9XG4gICAgICB9LCBkZWxheSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciB0b3VjaHN0YXJ0IGV2ZW50IG9uIG1vYmlsZSBkZXZpY2VzXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5fb25Ub3VjaFN0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdGhpcy50b3VjaERvd24gPSB0cnVlO1xuXG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB0aGlzLm9udG91Y2htb3ZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBtZS5fb25Ub3VjaE1vdmUoZXZlbnQpO1xuICAgIH07XG4gICAgdGhpcy5vbnRvdWNoZW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBtZS5fb25Ub3VjaEVuZChldmVudCk7XG4gICAgfTtcbiAgICB1dGlsLmFkZEV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCBtZS5vbnRvdWNobW92ZSk7XG4gICAgdXRpbC5hZGRFdmVudExpc3RlbmVyKGRvY3VtZW50LCAndG91Y2hlbmQnLCBtZS5vbnRvdWNoZW5kKTtcblxuICAgIHRoaXMuX29uTW91c2VEb3duKGV2ZW50KTtcbiAgfTtcblxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBmb3IgdG91Y2htb3ZlIGV2ZW50IG9uIG1vYmlsZSBkZXZpY2VzXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5fb25Ub3VjaE1vdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB0aGlzLl9vbk1vdXNlTW92ZShldmVudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yIHRvdWNoZW5kIGV2ZW50IG9uIG1vYmlsZSBkZXZpY2VzXG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5fb25Ub3VjaEVuZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHRoaXMudG91Y2hEb3duID0gZmFsc2U7XG5cbiAgICB1dGlsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLm9udG91Y2htb3ZlKTtcbiAgICB1dGlsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMub250b3VjaGVuZCk7XG5cbiAgICB0aGlzLl9vbk1vdXNlVXAoZXZlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciBtb3VzZSB3aGVlbCBldmVudCwgdXNlZCB0byB6b29tIHRoZSBncmFwaFxuICAgKiBDb2RlIGZyb20gaHR0cDovL2Fkb21hcy5vcmcvamF2YXNjcmlwdC1tb3VzZS13aGVlbC9cbiAgICogQHBhcmFtIHtldmVudH0gIGV2ZW50ICAgVGhlIGV2ZW50XG4gICAqL1xuICBHcmFwaDNkLnByb3RvdHlwZS5fb25XaGVlbCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmICghZXZlbnQpIC8qIEZvciBJRS4gKi9cbiAgICAgIGV2ZW50ID0gd2luZG93LmV2ZW50O1xuXG4gICAgLy8gcmV0cmlldmUgZGVsdGFcbiAgICB2YXIgZGVsdGEgPSAwO1xuICAgIGlmIChldmVudC53aGVlbERlbHRhKSB7XG4gICAgICAvKiBJRS9PcGVyYS4gKi9cbiAgICAgIGRlbHRhID0gZXZlbnQud2hlZWxEZWx0YSAvIDEyMDtcbiAgICB9IGVsc2UgaWYgKGV2ZW50LmRldGFpbCkge1xuICAgICAgLyogTW96aWxsYSBjYXNlLiAqL1xuICAgICAgLy8gSW4gTW96aWxsYSwgc2lnbiBvZiBkZWx0YSBpcyBkaWZmZXJlbnQgdGhhbiBpbiBJRS5cbiAgICAgIC8vIEFsc28sIGRlbHRhIGlzIG11bHRpcGxlIG9mIDMuXG4gICAgICBkZWx0YSA9IC1ldmVudC5kZXRhaWwgLyAzO1xuICAgIH1cblxuICAgIC8vIElmIGRlbHRhIGlzIG5vbnplcm8sIGhhbmRsZSBpdC5cbiAgICAvLyBCYXNpY2FsbHksIGRlbHRhIGlzIG5vdyBwb3NpdGl2ZSBpZiB3aGVlbCB3YXMgc2Nyb2xsZWQgdXAsXG4gICAgLy8gYW5kIG5lZ2F0aXZlLCBpZiB3aGVlbCB3YXMgc2Nyb2xsZWQgZG93bi5cbiAgICBpZiAoZGVsdGEpIHtcbiAgICAgIHZhciBvbGRMZW5ndGggPSB0aGlzLmNhbWVyYS5nZXRBcm1MZW5ndGgoKTtcbiAgICAgIHZhciBuZXdMZW5ndGggPSBvbGRMZW5ndGggKiAoMSAtIGRlbHRhIC8gMTApO1xuXG4gICAgICB0aGlzLmNhbWVyYS5zZXRBcm1MZW5ndGgobmV3TGVuZ3RoKTtcbiAgICAgIHRoaXMucmVkcmF3KCk7XG5cbiAgICAgIHRoaXMuX2hpZGVUb29sdGlwKCk7XG4gICAgfVxuXG4gICAgLy8gZmlyZSBhIGNhbWVyYVBvc2l0aW9uQ2hhbmdlIGV2ZW50XG4gICAgdmFyIHBhcmFtZXRlcnMgPSB0aGlzLmdldENhbWVyYVBvc2l0aW9uKCk7XG4gICAgdGhpcy5lbWl0KCdjYW1lcmFQb3NpdGlvbkNoYW5nZScsIHBhcmFtZXRlcnMpO1xuXG4gICAgLy8gUHJldmVudCBkZWZhdWx0IGFjdGlvbnMgY2F1c2VkIGJ5IG1vdXNlIHdoZWVsLlxuICAgIC8vIFRoYXQgbWlnaHQgYmUgdWdseSwgYnV0IHdlIGhhbmRsZSBzY3JvbGxzIHNvbWVob3dcbiAgICAvLyBhbnl3YXksIHNvIGRvbid0IGJvdGhlciBoZXJlLi5cbiAgICB1dGlsLnByZXZlbnREZWZhdWx0KGV2ZW50KTtcbiAgfTtcblxuICAvKipcbiAgICogVGVzdCB3aGV0aGVyIGEgcG9pbnQgbGllcyBpbnNpZGUgZ2l2ZW4gMkQgdHJpYW5nbGVcbiAgICogQHBhcmFtIHtQb2ludDJkfSBwb2ludFxuICAgKiBAcGFyYW0ge1BvaW50MmRbXX0gdHJpYW5nbGVcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGdpdmVuIHBvaW50IGxpZXMgaW5zaWRlIG9yIG9uIHRoZSBlZGdlIG9mIHRoZSB0cmlhbmdsZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX2luc2lkZVRyaWFuZ2xlID0gZnVuY3Rpb24gKHBvaW50LCB0cmlhbmdsZSkge1xuICAgIHZhciBhID0gdHJpYW5nbGVbMF0sXG4gICAgICAgIGIgPSB0cmlhbmdsZVsxXSxcbiAgICAgICAgYyA9IHRyaWFuZ2xlWzJdO1xuXG4gICAgZnVuY3Rpb24gc2lnbih4KSB7XG4gICAgICByZXR1cm4geCA+IDAgPyAxIDogeCA8IDAgPyAtMSA6IDA7XG4gICAgfVxuXG4gICAgdmFyIGFzID0gc2lnbigoYi54IC0gYS54KSAqIChwb2ludC55IC0gYS55KSAtIChiLnkgLSBhLnkpICogKHBvaW50LnggLSBhLngpKTtcbiAgICB2YXIgYnMgPSBzaWduKChjLnggLSBiLngpICogKHBvaW50LnkgLSBiLnkpIC0gKGMueSAtIGIueSkgKiAocG9pbnQueCAtIGIueCkpO1xuICAgIHZhciBjcyA9IHNpZ24oKGEueCAtIGMueCkgKiAocG9pbnQueSAtIGMueSkgLSAoYS55IC0gYy55KSAqIChwb2ludC54IC0gYy54KSk7XG5cbiAgICAvLyBlYWNoIG9mIHRoZSB0aHJlZSBzaWducyBtdXN0IGJlIGVpdGhlciBlcXVhbCB0byBlYWNoIG90aGVyIG9yIHplcm9cbiAgICByZXR1cm4gKGFzID09IDAgfHwgYnMgPT0gMCB8fCBhcyA9PSBicykgJiYgKGJzID09IDAgfHwgY3MgPT0gMCB8fCBicyA9PSBjcykgJiYgKGFzID09IDAgfHwgY3MgPT0gMCB8fCBhcyA9PSBjcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpbmQgYSBkYXRhIHBvaW50IGNsb3NlIHRvIGdpdmVuIHNjcmVlbiBwb3NpdGlvbiAoeCwgeSlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICogQHJldHVybiB7T2JqZWN0IHwgbnVsbH0gVGhlIGNsb3Nlc3QgZGF0YSBwb2ludCBvciBudWxsIGlmIG5vdCBjbG9zZSB0byBhbnkgZGF0YSBwb2ludFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX2RhdGFQb2ludEZyb21YWSA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdmFyIGksXG4gICAgICAgIGRpc3RNYXggPSAxMDAsXG4gICAgICAgIC8vIHB4XG4gICAgZGF0YVBvaW50ID0gbnVsbCxcbiAgICAgICAgY2xvc2VzdERhdGFQb2ludCA9IG51bGwsXG4gICAgICAgIGNsb3Nlc3REaXN0ID0gbnVsbCxcbiAgICAgICAgY2VudGVyID0gbmV3IFBvaW50MmQoeCwgeSk7XG5cbiAgICBpZiAodGhpcy5zdHlsZSA9PT0gR3JhcGgzZC5TVFlMRS5CQVIgfHwgdGhpcy5zdHlsZSA9PT0gR3JhcGgzZC5TVFlMRS5CQVJDT0xPUiB8fCB0aGlzLnN0eWxlID09PSBHcmFwaDNkLlNUWUxFLkJBUlNJWkUpIHtcbiAgICAgIC8vIHRoZSBkYXRhIHBvaW50cyBhcmUgb3JkZXJlZCBmcm9tIGZhciBhd2F5IHRvIGNsb3Nlc3RcbiAgICAgIGZvciAoaSA9IHRoaXMuZGF0YVBvaW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBkYXRhUG9pbnQgPSB0aGlzLmRhdGFQb2ludHNbaV07XG4gICAgICAgIHZhciBzdXJmYWNlcyA9IGRhdGFQb2ludC5zdXJmYWNlcztcbiAgICAgICAgaWYgKHN1cmZhY2VzKSB7XG4gICAgICAgICAgZm9yICh2YXIgcyA9IHN1cmZhY2VzLmxlbmd0aCAtIDE7IHMgPj0gMDsgcy0tKSB7XG4gICAgICAgICAgICAvLyBzcGxpdCBlYWNoIHN1cmZhY2UgaW4gdHdvIHRyaWFuZ2xlcywgYW5kIHNlZSBpZiB0aGUgY2VudGVyIHBvaW50IGlzIGluc2lkZSBvbmUgb2YgdGhlc2VcbiAgICAgICAgICAgIHZhciBzdXJmYWNlID0gc3VyZmFjZXNbc107XG4gICAgICAgICAgICB2YXIgY29ybmVycyA9IHN1cmZhY2UuY29ybmVycztcbiAgICAgICAgICAgIHZhciB0cmlhbmdsZTEgPSBbY29ybmVyc1swXS5zY3JlZW4sIGNvcm5lcnNbMV0uc2NyZWVuLCBjb3JuZXJzWzJdLnNjcmVlbl07XG4gICAgICAgICAgICB2YXIgdHJpYW5nbGUyID0gW2Nvcm5lcnNbMl0uc2NyZWVuLCBjb3JuZXJzWzNdLnNjcmVlbiwgY29ybmVyc1swXS5zY3JlZW5dO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2luc2lkZVRyaWFuZ2xlKGNlbnRlciwgdHJpYW5nbGUxKSB8fCB0aGlzLl9pbnNpZGVUcmlhbmdsZShjZW50ZXIsIHRyaWFuZ2xlMikpIHtcbiAgICAgICAgICAgICAgLy8gcmV0dXJuIGltbWVkaWF0ZWx5IGF0IHRoZSBmaXJzdCBoaXRcbiAgICAgICAgICAgICAgcmV0dXJuIGRhdGFQb2ludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZmluZCB0aGUgY2xvc2VzdCBkYXRhIHBvaW50LCB1c2luZyBkaXN0YW5jZSB0byB0aGUgY2VudGVyIG9mIHRoZSBwb2ludCBvbiAyZCBzY3JlZW5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmRhdGFQb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGF0YVBvaW50ID0gdGhpcy5kYXRhUG9pbnRzW2ldO1xuICAgICAgICB2YXIgcG9pbnQgPSBkYXRhUG9pbnQuc2NyZWVuO1xuICAgICAgICBpZiAocG9pbnQpIHtcbiAgICAgICAgICB2YXIgZGlzdFggPSBNYXRoLmFicyh4IC0gcG9pbnQueCk7XG4gICAgICAgICAgdmFyIGRpc3RZID0gTWF0aC5hYnMoeSAtIHBvaW50LnkpO1xuICAgICAgICAgIHZhciBkaXN0ID0gTWF0aC5zcXJ0KGRpc3RYICogZGlzdFggKyBkaXN0WSAqIGRpc3RZKTtcblxuICAgICAgICAgIGlmICgoY2xvc2VzdERpc3QgPT09IG51bGwgfHwgZGlzdCA8IGNsb3Nlc3REaXN0KSAmJiBkaXN0IDwgZGlzdE1heCkge1xuICAgICAgICAgICAgY2xvc2VzdERpc3QgPSBkaXN0O1xuICAgICAgICAgICAgY2xvc2VzdERhdGFQb2ludCA9IGRhdGFQb2ludDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2xvc2VzdERhdGFQb2ludDtcbiAgfTtcblxuICAvKipcbiAgICogRGlzcGxheSBhIHRvb2x0aXAgZm9yIGdpdmVuIGRhdGEgcG9pbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFQb2ludFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgR3JhcGgzZC5wcm90b3R5cGUuX3Nob3dUb29sdGlwID0gZnVuY3Rpb24gKGRhdGFQb2ludCkge1xuICAgIHZhciBjb250ZW50LCBsaW5lLCBkb3Q7XG5cbiAgICBpZiAoIXRoaXMudG9vbHRpcCkge1xuICAgICAgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgY29udGVudC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICBjb250ZW50LnN0eWxlLnBhZGRpbmcgPSAnMTBweCc7XG4gICAgICBjb250ZW50LnN0eWxlLmJvcmRlciA9ICcxcHggc29saWQgIzRkNGQ0ZCc7XG4gICAgICBjb250ZW50LnN0eWxlLmNvbG9yID0gJyMxYTFhMWEnO1xuICAgICAgY29udGVudC5zdHlsZS5iYWNrZ3JvdW5kID0gJ3JnYmEoMjU1LDI1NSwyNTUsMC43KSc7XG4gICAgICBjb250ZW50LnN0eWxlLmJvcmRlclJhZGl1cyA9ICcycHgnO1xuICAgICAgY29udGVudC5zdHlsZS5ib3hTaGFkb3cgPSAnNXB4IDVweCAxMHB4IHJnYmEoMTI4LDEyOCwxMjgsMC41KSc7XG5cbiAgICAgIGxpbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGxpbmUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgbGluZS5zdHlsZS5oZWlnaHQgPSAnNDBweCc7XG4gICAgICBsaW5lLnN0eWxlLndpZHRoID0gJzAnO1xuICAgICAgbGluZS5zdHlsZS5ib3JkZXJMZWZ0ID0gJzFweCBzb2xpZCAjNGQ0ZDRkJztcblxuICAgICAgZG90ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkb3Quc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgZG90LnN0eWxlLmhlaWdodCA9ICcwJztcbiAgICAgIGRvdC5zdHlsZS53aWR0aCA9ICcwJztcbiAgICAgIGRvdC5zdHlsZS5ib3JkZXIgPSAnNXB4IHNvbGlkICM0ZDRkNGQnO1xuICAgICAgZG90LnN0eWxlLmJvcmRlclJhZGl1cyA9ICc1cHgnO1xuXG4gICAgICB0aGlzLnRvb2x0aXAgPSB7XG4gICAgICAgIGRhdGFQb2ludDogbnVsbCxcbiAgICAgICAgZG9tOiB7XG4gICAgICAgICAgY29udGVudDogY29udGVudCxcbiAgICAgICAgICBsaW5lOiBsaW5lLFxuICAgICAgICAgIGRvdDogZG90XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRlbnQgPSB0aGlzLnRvb2x0aXAuZG9tLmNvbnRlbnQ7XG4gICAgICBsaW5lID0gdGhpcy50b29sdGlwLmRvbS5saW5lO1xuICAgICAgZG90ID0gdGhpcy50b29sdGlwLmRvbS5kb3Q7XG4gICAgfVxuXG4gICAgdGhpcy5faGlkZVRvb2x0aXAoKTtcblxuICAgIHRoaXMudG9vbHRpcC5kYXRhUG9pbnQgPSBkYXRhUG9pbnQ7XG4gICAgaWYgKHR5cGVvZiB0aGlzLnNob3dUb29sdGlwID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb250ZW50LmlubmVySFRNTCA9IHRoaXMuc2hvd1Rvb2x0aXAoZGF0YVBvaW50LnBvaW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudC5pbm5lckhUTUwgPSAnPHRhYmxlPicgKyAnPHRyPjx0ZD4nICsgdGhpcy54TGFiZWwgKyAnOjwvdGQ+PHRkPicgKyBkYXRhUG9pbnQucG9pbnQueCArICc8L3RkPjwvdHI+JyArICc8dHI+PHRkPicgKyB0aGlzLnlMYWJlbCArICc6PC90ZD48dGQ+JyArIGRhdGFQb2ludC5wb2ludC55ICsgJzwvdGQ+PC90cj4nICsgJzx0cj48dGQ+JyArIHRoaXMuekxhYmVsICsgJzo8L3RkPjx0ZD4nICsgZGF0YVBvaW50LnBvaW50LnogKyAnPC90ZD48L3RyPicgKyAnPC90YWJsZT4nO1xuICAgIH1cblxuICAgIGNvbnRlbnQuc3R5bGUubGVmdCA9ICcwJztcbiAgICBjb250ZW50LnN0eWxlLnRvcCA9ICcwJztcbiAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQobGluZSk7XG4gICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZChkb3QpO1xuXG4gICAgLy8gY2FsY3VsYXRlIHNpemVzXG4gICAgdmFyIGNvbnRlbnRXaWR0aCA9IGNvbnRlbnQub2Zmc2V0V2lkdGg7XG4gICAgdmFyIGNvbnRlbnRIZWlnaHQgPSBjb250ZW50Lm9mZnNldEhlaWdodDtcbiAgICB2YXIgbGluZUhlaWdodCA9IGxpbmUub2Zmc2V0SGVpZ2h0O1xuICAgIHZhciBkb3RXaWR0aCA9IGRvdC5vZmZzZXRXaWR0aDtcbiAgICB2YXIgZG90SGVpZ2h0ID0gZG90Lm9mZnNldEhlaWdodDtcblxuICAgIHZhciBsZWZ0ID0gZGF0YVBvaW50LnNjcmVlbi54IC0gY29udGVudFdpZHRoIC8gMjtcbiAgICBsZWZ0ID0gTWF0aC5taW4oTWF0aC5tYXgobGVmdCwgMTApLCB0aGlzLmZyYW1lLmNsaWVudFdpZHRoIC0gMTAgLSBjb250ZW50V2lkdGgpO1xuXG4gICAgbGluZS5zdHlsZS5sZWZ0ID0gZGF0YVBvaW50LnNjcmVlbi54ICsgJ3B4JztcbiAgICBsaW5lLnN0eWxlLnRvcCA9IGRhdGFQb2ludC5zY3JlZW4ueSAtIGxpbmVIZWlnaHQgKyAncHgnO1xuICAgIGNvbnRlbnQuc3R5bGUubGVmdCA9IGxlZnQgKyAncHgnO1xuICAgIGNvbnRlbnQuc3R5bGUudG9wID0gZGF0YVBvaW50LnNjcmVlbi55IC0gbGluZUhlaWdodCAtIGNvbnRlbnRIZWlnaHQgKyAncHgnO1xuICAgIGRvdC5zdHlsZS5sZWZ0ID0gZGF0YVBvaW50LnNjcmVlbi54IC0gZG90V2lkdGggLyAyICsgJ3B4JztcbiAgICBkb3Quc3R5bGUudG9wID0gZGF0YVBvaW50LnNjcmVlbi55IC0gZG90SGVpZ2h0IC8gMiArICdweCc7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhpZGUgdGhlIHRvb2x0aXAgd2hlbiBkaXNwbGF5ZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEdyYXBoM2QucHJvdG90eXBlLl9oaWRlVG9vbHRpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy50b29sdGlwKSB7XG4gICAgICB0aGlzLnRvb2x0aXAuZGF0YVBvaW50ID0gbnVsbDtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiB0aGlzLnRvb2x0aXAuZG9tKSB7XG4gICAgICAgIGlmICh0aGlzLnRvb2x0aXAuZG9tLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgdmFyIGVsZW0gPSB0aGlzLnRvb2x0aXAuZG9tW3Byb3BdO1xuICAgICAgICAgIGlmIChlbGVtICYmIGVsZW0ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgZWxlbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSoqL1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGhvcml6b250YWwgbW91c2UgcG9zaXRpb24gZnJvbSBhIG1vdXNlIGV2ZW50XG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEByZXR1cm4ge051bWJlcn0gbW91c2UgeFxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0TW91c2VYKGV2ZW50KSB7XG4gICAgaWYgKCdjbGllbnRYJyBpbiBldmVudCkgcmV0dXJuIGV2ZW50LmNsaWVudFg7XG4gICAgcmV0dXJuIGV2ZW50LnRhcmdldFRvdWNoZXNbMF0gJiYgZXZlbnQudGFyZ2V0VG91Y2hlc1swXS5jbGllbnRYIHx8IDA7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB2ZXJ0aWNhbCBtb3VzZSBwb3NpdGlvbiBmcm9tIGEgbW91c2UgZXZlbnRcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHJldHVybiB7TnVtYmVyfSBtb3VzZSB5XG4gICAqL1xuICBmdW5jdGlvbiBnZXRNb3VzZVkoZXZlbnQpIHtcbiAgICBpZiAoJ2NsaWVudFknIGluIGV2ZW50KSByZXR1cm4gZXZlbnQuY2xpZW50WTtcbiAgICByZXR1cm4gZXZlbnQudGFyZ2V0VG91Y2hlc1swXSAmJiBldmVudC50YXJnZXRUb3VjaGVzWzBdLmNsaWVudFkgfHwgMDtcbiAgfVxuXG4gIG1vZHVsZS5leHBvcnRzID0gR3JhcGgzZDtcblxuLyoqKi8gfSxcbi8qIDEzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuICBcbiAgLyoqXG4gICAqIEV4cG9zZSBgRW1pdHRlcmAuXG4gICAqL1xuXG4gIG1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXG4gICAqXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XG4gICAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG4gICAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XG4gICAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICAvKipcbiAgICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEVtaXR0ZXIucHJvdG90eXBlLm9uID1cbiAgRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICAgICh0aGlzLl9jYWxsYmFja3NbZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XSB8fCBbXSlcbiAgICAgIC5wdXNoKGZuKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXG4gICAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKiBAcmV0dXJuIHtFbWl0dGVyfVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG4gICAgZnVuY3Rpb24gb24oKSB7XG4gICAgICBzZWxmLm9mZihldmVudCwgb24pO1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBvbi5mbiA9IGZuO1xuICAgIHRoaXMub24oZXZlbnQsIG9uKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcbiAgICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKiBAcmV0dXJuIHtFbWl0dGVyfVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBFbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxuICBFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gIEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gIEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblxuICAgIC8vIGFsbFxuICAgIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcbiAgICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XG5cbiAgICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXG4gICAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxuICAgIHZhciBjYjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgY2IgPSBjYWxsYmFja3NbaV07XG4gICAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtNaXhlZH0gLi4uXG4gICAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gICAqL1xuXG4gIEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG4gICAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG5cbiAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICAgIHJldHVybiB0aGlzLl9jYWxsYmFja3NbZXZlbnRdIHx8IFtdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBFbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gICAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XG4gIH07XG5cblxuLyoqKi8gfSxcbi8qIDE0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuICBcInVzZSBzdHJpY3RcIjtcblxuICAvKipcbiAgICogQHByb3RvdHlwZSBQb2ludDNkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbeF1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt5XVxuICAgKiBAcGFyYW0ge051bWJlcn0gW3pdXG4gICAqL1xuICBmdW5jdGlvbiBQb2ludDNkKHgsIHksIHopIHtcbiAgICB0aGlzLnggPSB4ICE9PSB1bmRlZmluZWQgPyB4IDogMDtcbiAgICB0aGlzLnkgPSB5ICE9PSB1bmRlZmluZWQgPyB5IDogMDtcbiAgICB0aGlzLnogPSB6ICE9PSB1bmRlZmluZWQgPyB6IDogMDtcbiAgfTtcblxuICAvKipcbiAgICogU3VidHJhY3QgdGhlIHR3byBwcm92aWRlZCBwb2ludHMsIHJldHVybnMgYS1iXG4gICAqIEBwYXJhbSB7UG9pbnQzZH0gYVxuICAgKiBAcGFyYW0ge1BvaW50M2R9IGJcbiAgICogQHJldHVybiB7UG9pbnQzZH0gYS1iXG4gICAqL1xuICBQb2ludDNkLnN1YnRyYWN0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICB2YXIgc3ViID0gbmV3IFBvaW50M2QoKTtcbiAgICBzdWIueCA9IGEueCAtIGIueDtcbiAgICBzdWIueSA9IGEueSAtIGIueTtcbiAgICBzdWIueiA9IGEueiAtIGIuejtcbiAgICByZXR1cm4gc3ViO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgdGhlIHR3byBwcm92aWRlZCBwb2ludHMsIHJldHVybnMgYStiXG4gICAqIEBwYXJhbSB7UG9pbnQzZH0gYVxuICAgKiBAcGFyYW0ge1BvaW50M2R9IGJcbiAgICogQHJldHVybiB7UG9pbnQzZH0gYStiXG4gICAqL1xuICBQb2ludDNkLmFkZCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIHN1bSA9IG5ldyBQb2ludDNkKCk7XG4gICAgc3VtLnggPSBhLnggKyBiLng7XG4gICAgc3VtLnkgPSBhLnkgKyBiLnk7XG4gICAgc3VtLnogPSBhLnogKyBiLno7XG4gICAgcmV0dXJuIHN1bTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBhdmVyYWdlIG9mIHR3byAzZCBwb2ludHNcbiAgICogQHBhcmFtIHtQb2ludDNkfSBhXG4gICAqIEBwYXJhbSB7UG9pbnQzZH0gYlxuICAgKiBAcmV0dXJuIHtQb2ludDNkfSBUaGUgYXZlcmFnZSwgKGErYikvMlxuICAgKi9cbiAgUG9pbnQzZC5hdmcgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBuZXcgUG9pbnQzZCgoYS54ICsgYi54KSAvIDIsIChhLnkgKyBiLnkpIC8gMiwgKGEueiArIGIueikgLyAyKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHRoZSB0d28gcHJvdmlkZWQgcG9pbnRzLCByZXR1cm5zIGF4YlxuICAgKiBEb2N1bWVudGF0aW9uOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Nyb3NzX3Byb2R1Y3RcbiAgICogQHBhcmFtIHtQb2ludDNkfSBhXG4gICAqIEBwYXJhbSB7UG9pbnQzZH0gYlxuICAgKiBAcmV0dXJuIHtQb2ludDNkfSBjcm9zcyBwcm9kdWN0IGF4YlxuICAgKi9cbiAgUG9pbnQzZC5jcm9zc1Byb2R1Y3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciBjcm9zc3Byb2R1Y3QgPSBuZXcgUG9pbnQzZCgpO1xuXG4gICAgY3Jvc3Nwcm9kdWN0LnggPSBhLnkgKiBiLnogLSBhLnogKiBiLnk7XG4gICAgY3Jvc3Nwcm9kdWN0LnkgPSBhLnogKiBiLnggLSBhLnggKiBiLno7XG4gICAgY3Jvc3Nwcm9kdWN0LnogPSBhLnggKiBiLnkgLSBhLnkgKiBiLng7XG5cbiAgICByZXR1cm4gY3Jvc3Nwcm9kdWN0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSdHJpZXZlIHRoZSBsZW5ndGggb2YgdGhlIHZlY3RvciAob3IgdGhlIGRpc3RhbmNlIGZyb20gdGhpcyBwb2ludCB0byB0aGUgb3JpZ2luXG4gICAqIEByZXR1cm4ge051bWJlcn0gIGxlbmd0aFxuICAgKi9cbiAgUG9pbnQzZC5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56KTtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFBvaW50M2Q7XG5cbi8qKiovIH0sXG4vKiAxNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgLyoqXG4gICAqIEBwcm90b3R5cGUgUG9pbnQyZFxuICAgKiBAcGFyYW0ge051bWJlcn0gW3hdXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbeV1cbiAgICovXG4gIGZ1bmN0aW9uIFBvaW50MmQoeCwgeSkge1xuICAgIHRoaXMueCA9IHggIT09IHVuZGVmaW5lZCA/IHggOiAwO1xuICAgIHRoaXMueSA9IHkgIT09IHVuZGVmaW5lZCA/IHkgOiAwO1xuICB9XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBQb2ludDJkO1xuXG4vKioqLyB9LFxuLyogMTYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgUG9pbnQzZCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXG4gIC8qKlxuICAgKiBAY2xhc3MgQ2FtZXJhXG4gICAqIFRoZSBjYW1lcmEgaXMgbW91bnRlZCBvbiBhICh2aXJ0dWFsKSBjYW1lcmEgYXJtLiBUaGUgY2FtZXJhIGFybSBjYW4gcm90YXRlXG4gICAqIFRoZSBjYW1lcmEgaXMgYWx3YXlzIGxvb2tpbmcgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgb3JpZ2luIG9mIHRoZSBhcm0uXG4gICAqIFRoaXMgd2F5LCB0aGUgY2FtZXJhIGFsd2F5cyByb3RhdGVzIGFyb3VuZCBvbmUgZml4ZWQgcG9pbnQsIHRoZSBsb2NhdGlvblxuICAgKiBvZiB0aGUgY2FtZXJhIGFybS5cbiAgICpcbiAgICogRG9jdW1lbnRhdGlvbjpcbiAgICogICBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpLzNEX3Byb2plY3Rpb25cbiAgICovXG4gIGZ1bmN0aW9uIENhbWVyYSgpIHtcbiAgICB0aGlzLmFybUxvY2F0aW9uID0gbmV3IFBvaW50M2QoKTtcbiAgICB0aGlzLmFybVJvdGF0aW9uID0ge307XG4gICAgdGhpcy5hcm1Sb3RhdGlvbi5ob3Jpem9udGFsID0gMDtcbiAgICB0aGlzLmFybVJvdGF0aW9uLnZlcnRpY2FsID0gMDtcbiAgICB0aGlzLmFybUxlbmd0aCA9IDEuNztcblxuICAgIHRoaXMuY2FtZXJhTG9jYXRpb24gPSBuZXcgUG9pbnQzZCgpO1xuICAgIHRoaXMuY2FtZXJhUm90YXRpb24gPSBuZXcgUG9pbnQzZCgwLjUgKiBNYXRoLlBJLCAwLCAwKTtcblxuICAgIHRoaXMuY2FsY3VsYXRlQ2FtZXJhT3JpZW50YXRpb24oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGxvY2F0aW9uIChvcmlnaW4pIG9mIHRoZSBhcm1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHggIE5vcm1hbGl6ZWQgdmFsdWUgb2YgeFxuICAgKiBAcGFyYW0ge051bWJlcn0geSAgTm9ybWFsaXplZCB2YWx1ZSBvZiB5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB6ICBOb3JtYWxpemVkIHZhbHVlIG9mIHpcbiAgICovXG4gIENhbWVyYS5wcm90b3R5cGUuc2V0QXJtTG9jYXRpb24gPSBmdW5jdGlvbiAoeCwgeSwgeikge1xuICAgIHRoaXMuYXJtTG9jYXRpb24ueCA9IHg7XG4gICAgdGhpcy5hcm1Mb2NhdGlvbi55ID0geTtcbiAgICB0aGlzLmFybUxvY2F0aW9uLnogPSB6O1xuXG4gICAgdGhpcy5jYWxjdWxhdGVDYW1lcmFPcmllbnRhdGlvbigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHJvdGF0aW9uIG9mIHRoZSBjYW1lcmEgYXJtXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBob3Jpem9udGFsICAgVGhlIGhvcml6b250YWwgcm90YXRpb24sIGJldHdlZW4gMCBhbmQgMipQSS5cbiAgICogICAgICAgICAgICAgICAgT3B0aW9uYWwsIGNhbiBiZSBsZWZ0IHVuZGVmaW5lZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZlcnRpY2FsICAgVGhlIHZlcnRpY2FsIHJvdGF0aW9uLCBiZXR3ZWVuIDAgYW5kIDAuNSpQSVxuICAgKiAgICAgICAgICAgICAgICBpZiB2ZXJ0aWNhbD0wLjUqUEksIHRoZSBncmFwaCBpcyBzaG93biBmcm9tIHRoZVxuICAgKiAgICAgICAgICAgICAgICB0b3AuIE9wdGlvbmFsLCBjYW4gYmUgbGVmdCB1bmRlZmluZWQuXG4gICAqL1xuICBDYW1lcmEucHJvdG90eXBlLnNldEFybVJvdGF0aW9uID0gZnVuY3Rpb24gKGhvcml6b250YWwsIHZlcnRpY2FsKSB7XG4gICAgaWYgKGhvcml6b250YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5hcm1Sb3RhdGlvbi5ob3Jpem9udGFsID0gaG9yaXpvbnRhbDtcbiAgICB9XG5cbiAgICBpZiAodmVydGljYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5hcm1Sb3RhdGlvbi52ZXJ0aWNhbCA9IHZlcnRpY2FsO1xuICAgICAgaWYgKHRoaXMuYXJtUm90YXRpb24udmVydGljYWwgPCAwKSB0aGlzLmFybVJvdGF0aW9uLnZlcnRpY2FsID0gMDtcbiAgICAgIGlmICh0aGlzLmFybVJvdGF0aW9uLnZlcnRpY2FsID4gMC41ICogTWF0aC5QSSkgdGhpcy5hcm1Sb3RhdGlvbi52ZXJ0aWNhbCA9IDAuNSAqIE1hdGguUEk7XG4gICAgfVxuXG4gICAgaWYgKGhvcml6b250YWwgIT09IHVuZGVmaW5lZCB8fCB2ZXJ0aWNhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmNhbGN1bGF0ZUNhbWVyYU9yaWVudGF0aW9uKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgY3VycmVudCBhcm0gcm90YXRpb25cbiAgICogQHJldHVybiB7b2JqZWN0fSAgIEFuIG9iamVjdCB3aXRoIHBhcmFtZXRlcnMgaG9yaXpvbnRhbCBhbmQgdmVydGljYWxcbiAgICovXG4gIENhbWVyYS5wcm90b3R5cGUuZ2V0QXJtUm90YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJvdCA9IHt9O1xuICAgIHJvdC5ob3Jpem9udGFsID0gdGhpcy5hcm1Sb3RhdGlvbi5ob3Jpem9udGFsO1xuICAgIHJvdC52ZXJ0aWNhbCA9IHRoaXMuYXJtUm90YXRpb24udmVydGljYWw7XG5cbiAgICByZXR1cm4gcm90O1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIChub3JtYWxpemVkKSBsZW5ndGggb2YgdGhlIGNhbWVyYSBhcm0uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggQSBsZW5ndGggYmV0d2VlbiAwLjcxIGFuZCA1LjBcbiAgICovXG4gIENhbWVyYS5wcm90b3R5cGUuc2V0QXJtTGVuZ3RoID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgdGhpcy5hcm1MZW5ndGggPSBsZW5ndGg7XG5cbiAgICAvLyBSYWRpdXMgbXVzdCBiZSBsYXJnZXIgdGhhbiB0aGUgY29ybmVyIG9mIHRoZSBncmFwaCxcbiAgICAvLyB3aGljaCBoYXMgYSBkaXN0YW5jZSBvZiBzcXJ0KDAuNV4yKzAuNV4yKSA9IDAuNzEgZnJvbSB0aGUgY2VudGVyIG9mIHRoZVxuICAgIC8vIGdyYXBoXG4gICAgaWYgKHRoaXMuYXJtTGVuZ3RoIDwgMC43MSkgdGhpcy5hcm1MZW5ndGggPSAwLjcxO1xuICAgIGlmICh0aGlzLmFybUxlbmd0aCA+IDUuMCkgdGhpcy5hcm1MZW5ndGggPSA1LjA7XG5cbiAgICB0aGlzLmNhbGN1bGF0ZUNhbWVyYU9yaWVudGF0aW9uKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSBhcm0gbGVuZ3RoXG4gICAqIEByZXR1cm4ge051bWJlcn0gbGVuZ3RoXG4gICAqL1xuICBDYW1lcmEucHJvdG90eXBlLmdldEFybUxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5hcm1MZW5ndGg7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSBjYW1lcmEgbG9jYXRpb25cbiAgICogQHJldHVybiB7UG9pbnQzZH0gY2FtZXJhTG9jYXRpb25cbiAgICovXG4gIENhbWVyYS5wcm90b3R5cGUuZ2V0Q2FtZXJhTG9jYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FtZXJhTG9jYXRpb247XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSBjYW1lcmEgcm90YXRpb25cbiAgICogQHJldHVybiB7UG9pbnQzZH0gY2FtZXJhUm90YXRpb25cbiAgICovXG4gIENhbWVyYS5wcm90b3R5cGUuZ2V0Q2FtZXJhUm90YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FtZXJhUm90YXRpb247XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgbG9jYXRpb24gYW5kIHJvdGF0aW9uIG9mIHRoZSBjYW1lcmEgYmFzZWQgb24gdGhlXG4gICAqIHBvc2l0aW9uIGFuZCBvcmllbnRhdGlvbiBvZiB0aGUgY2FtZXJhIGFybVxuICAgKi9cbiAgQ2FtZXJhLnByb3RvdHlwZS5jYWxjdWxhdGVDYW1lcmFPcmllbnRhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBjYWxjdWxhdGUgbG9jYXRpb24gb2YgdGhlIGNhbWVyYVxuICAgIHRoaXMuY2FtZXJhTG9jYXRpb24ueCA9IHRoaXMuYXJtTG9jYXRpb24ueCAtIHRoaXMuYXJtTGVuZ3RoICogTWF0aC5zaW4odGhpcy5hcm1Sb3RhdGlvbi5ob3Jpem9udGFsKSAqIE1hdGguY29zKHRoaXMuYXJtUm90YXRpb24udmVydGljYWwpO1xuICAgIHRoaXMuY2FtZXJhTG9jYXRpb24ueSA9IHRoaXMuYXJtTG9jYXRpb24ueSAtIHRoaXMuYXJtTGVuZ3RoICogTWF0aC5jb3ModGhpcy5hcm1Sb3RhdGlvbi5ob3Jpem9udGFsKSAqIE1hdGguY29zKHRoaXMuYXJtUm90YXRpb24udmVydGljYWwpO1xuICAgIHRoaXMuY2FtZXJhTG9jYXRpb24ueiA9IHRoaXMuYXJtTG9jYXRpb24ueiArIHRoaXMuYXJtTGVuZ3RoICogTWF0aC5zaW4odGhpcy5hcm1Sb3RhdGlvbi52ZXJ0aWNhbCk7XG5cbiAgICAvLyBjYWxjdWxhdGUgcm90YXRpb24gb2YgdGhlIGNhbWVyYVxuICAgIHRoaXMuY2FtZXJhUm90YXRpb24ueCA9IE1hdGguUEkgLyAyIC0gdGhpcy5hcm1Sb3RhdGlvbi52ZXJ0aWNhbDtcbiAgICB0aGlzLmNhbWVyYVJvdGF0aW9uLnkgPSAwO1xuICAgIHRoaXMuY2FtZXJhUm90YXRpb24ueiA9IC10aGlzLmFybVJvdGF0aW9uLmhvcml6b250YWw7XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBDYW1lcmE7XG5cbi8qKiovIH0sXG4vKiAxNyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBEYXRhVmlldyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG4gIC8qKlxuICAgKiBAY2xhc3MgRmlsdGVyXG4gICAqXG4gICAqIEBwYXJhbSB7RGF0YVNldH0gZGF0YSBUaGUgZ29vZ2xlIGRhdGEgdGFibGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9ICBjb2x1bW4gICAgICAgICAgICAgVGhlIGluZGV4IG9mIHRoZSBjb2x1bW4gdG8gYmUgZmlsdGVyZWRcbiAgICogQHBhcmFtIHtHcmFwaH0gZ3JhcGggICAgICAgICAgIFRoZSBncmFwaFxuICAgKi9cbiAgZnVuY3Rpb24gRmlsdGVyKGRhdGEsIGNvbHVtbiwgZ3JhcGgpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICAgIHRoaXMuZ3JhcGggPSBncmFwaDsgLy8gdGhlIHBhcmVudCBncmFwaFxuXG4gICAgdGhpcy5pbmRleCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnZhbHVlID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gcmVhZCBhbGwgZGlzdGluY3QgdmFsdWVzIGFuZCBzZWxlY3QgdGhlIGZpcnN0IG9uZVxuICAgIHRoaXMudmFsdWVzID0gZ3JhcGguZ2V0RGlzdGluY3RWYWx1ZXMoZGF0YS5nZXQoKSwgdGhpcy5jb2x1bW4pO1xuXG4gICAgLy8gc29ydCBib3RoIG51bWVyaWMgYW5kIHN0cmluZyB2YWx1ZXMgY29ycmVjdGx5XG4gICAgdGhpcy52YWx1ZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEgPiBiID8gMSA6IGEgPCBiID8gLTEgOiAwO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMudmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuc2VsZWN0VmFsdWUoMCk7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIGFuIGFycmF5IHdpdGggdGhlIGZpbHRlcmVkIGRhdGFwb2ludHMuIHRoaXMgd2lsbCBiZSBsb2FkZWQgYWZ0ZXJ3YXJkc1xuICAgIHRoaXMuZGF0YVBvaW50cyA9IFtdO1xuXG4gICAgdGhpcy5sb2FkZWQgPSBmYWxzZTtcbiAgICB0aGlzLm9uTG9hZENhbGxiYWNrID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKGdyYXBoLmFuaW1hdGlvblByZWxvYWQpIHtcbiAgICAgIHRoaXMubG9hZGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmxvYWRJbkJhY2tncm91bmQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2FkZWQgPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBsYWJlbFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IGxhYmVsXG4gICAqL1xuICBGaWx0ZXIucHJvdG90eXBlLmlzTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmxvYWRlZDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBsb2FkZWQgcHJvZ3Jlc3NcbiAgICogQHJldHVybiB7TnVtYmVyfSBwZXJjZW50YWdlIGJldHdlZW4gMCBhbmQgMTAwXG4gICAqL1xuICBGaWx0ZXIucHJvdG90eXBlLmdldExvYWRlZFByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW4gPSB0aGlzLnZhbHVlcy5sZW5ndGg7XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKHRoaXMuZGF0YVBvaW50c1tpXSkge1xuICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiBNYXRoLnJvdW5kKGkgLyBsZW4gKiAxMDApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGxhYmVsXG4gICAqIEByZXR1cm4ge3N0cmluZ30gbGFiZWxcbiAgICovXG4gIEZpbHRlci5wcm90b3R5cGUuZ2V0TGFiZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ3JhcGguZmlsdGVyTGFiZWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY29sdW1uSW5kZXggb2YgdGhlIGZpbHRlclxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGNvbHVtbkluZGV4XG4gICAqL1xuICBGaWx0ZXIucHJvdG90eXBlLmdldENvbHVtbiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jb2x1bW47XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHZhbHVlLiBSZXR1cm5zIHVuZGVmaW5lZCBpZiB0aGVyZSBpcyBubyBzZWxlY3Rpb25cbiAgICogQHJldHVybiB7Kn0gdmFsdWVcbiAgICovXG4gIEZpbHRlci5wcm90b3R5cGUuZ2V0U2VsZWN0ZWRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pbmRleCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIHRoaXMudmFsdWVzW3RoaXMuaW5kZXhdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBhbGwgdmFsdWVzIG9mIHRoZSBmaWx0ZXJcbiAgICogQHJldHVybiB7QXJyYXl9IHZhbHVlc1xuICAgKi9cbiAgRmlsdGVyLnByb3RvdHlwZS5nZXRWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBvbmUgdmFsdWUgb2YgdGhlIGZpbHRlclxuICAgKiBAcGFyYW0ge051bWJlcn0gIGluZGV4XG4gICAqIEByZXR1cm4geyp9IHZhbHVlXG4gICAqL1xuICBGaWx0ZXIucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID49IHRoaXMudmFsdWVzLmxlbmd0aCkgdGhyb3cgJ0Vycm9yOiBpbmRleCBvdXQgb2YgcmFuZ2UnO1xuXG4gICAgcmV0dXJuIHRoaXMudmFsdWVzW2luZGV4XTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlldmUgdGhlIChmaWx0ZXJlZCkgZGF0YVBvaW50cyBmb3IgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBmaWx0ZXIgaW5kZXhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtpbmRleF0gKG9wdGlvbmFsKVxuICAgKiBAcmV0dXJuIHtBcnJheX0gZGF0YVBvaW50c1xuICAgKi9cbiAgRmlsdGVyLnByb3RvdHlwZS5fZ2V0RGF0YVBvaW50cyA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSBpbmRleCA9IHRoaXMuaW5kZXg7XG5cbiAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkgcmV0dXJuIFtdO1xuXG4gICAgdmFyIGRhdGFQb2ludHM7XG4gICAgaWYgKHRoaXMuZGF0YVBvaW50c1tpbmRleF0pIHtcbiAgICAgIGRhdGFQb2ludHMgPSB0aGlzLmRhdGFQb2ludHNbaW5kZXhdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZiA9IHt9O1xuICAgICAgZi5jb2x1bW4gPSB0aGlzLmNvbHVtbjtcbiAgICAgIGYudmFsdWUgPSB0aGlzLnZhbHVlc1tpbmRleF07XG5cbiAgICAgIHZhciBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyh0aGlzLmRhdGEsIHsgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoaXRlbSkge1xuICAgICAgICAgIHJldHVybiBpdGVtW2YuY29sdW1uXSA9PSBmLnZhbHVlO1xuICAgICAgICB9IH0pLmdldCgpO1xuICAgICAgZGF0YVBvaW50cyA9IHRoaXMuZ3JhcGguX2dldERhdGFQb2ludHMoZGF0YVZpZXcpO1xuXG4gICAgICB0aGlzLmRhdGFQb2ludHNbaW5kZXhdID0gZGF0YVBvaW50cztcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YVBvaW50cztcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGEgY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiB0aGUgZmlsdGVyIGlzIGZ1bGx5IGxvYWRlZC5cbiAgICovXG4gIEZpbHRlci5wcm90b3R5cGUuc2V0T25Mb2FkQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB0aGlzLm9uTG9hZENhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIHZhbHVlIHRvIHRoZSBsaXN0IHdpdGggYXZhaWxhYmxlIHZhbHVlcyBmb3IgdGhpcyBmaWx0ZXJcbiAgICogTm8gZG91YmxlIGVudHJpZXMgd2lsbCBiZSBjcmVhdGVkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICovXG4gIEZpbHRlci5wcm90b3R5cGUuc2VsZWN0VmFsdWUgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPj0gdGhpcy52YWx1ZXMubGVuZ3RoKSB0aHJvdyAnRXJyb3I6IGluZGV4IG91dCBvZiByYW5nZSc7XG5cbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgdGhpcy52YWx1ZSA9IHRoaXMudmFsdWVzW2luZGV4XTtcbiAgfTtcblxuICAvKipcbiAgICogTG9hZCBhbGwgZmlsdGVyZWQgcm93cyBpbiB0aGUgYmFja2dyb3VuZCBvbmUgYnkgb25lXG4gICAqIFN0YXJ0IHRoaXMgbWV0aG9kIHdpdGhvdXQgcHJvdmlkaW5nIGFuIGluZGV4IVxuICAgKi9cbiAgRmlsdGVyLnByb3RvdHlwZS5sb2FkSW5CYWNrZ3JvdW5kID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIGluZGV4ID0gMDtcblxuICAgIHZhciBmcmFtZSA9IHRoaXMuZ3JhcGguZnJhbWU7XG5cbiAgICBpZiAoaW5kZXggPCB0aGlzLnZhbHVlcy5sZW5ndGgpIHtcbiAgICAgIHZhciBkYXRhUG9pbnRzVGVtcCA9IHRoaXMuX2dldERhdGFQb2ludHMoaW5kZXgpO1xuICAgICAgLy90aGlzLmdyYXBoLnJlZHJhd0luZm8oKTsgLy8gVE9ETzogbm90IG5lYXRcblxuICAgICAgLy8gY3JlYXRlIGEgcHJvZ3Jlc3MgYm94XG4gICAgICBpZiAoZnJhbWUucHJvZ3Jlc3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmcmFtZS5wcm9ncmVzcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICAgICAgICBmcmFtZS5wcm9ncmVzcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIGZyYW1lLnByb2dyZXNzLnN0eWxlLmNvbG9yID0gJ2dyYXknO1xuICAgICAgICBmcmFtZS5hcHBlbmRDaGlsZChmcmFtZS5wcm9ncmVzcyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvZ3Jlc3MgPSB0aGlzLmdldExvYWRlZFByb2dyZXNzKCk7XG4gICAgICBmcmFtZS5wcm9ncmVzcy5pbm5lckhUTUwgPSAnTG9hZGluZyBhbmltYXRpb24uLi4gJyArIHByb2dyZXNzICsgJyUnO1xuICAgICAgLy8gVE9ETzogdGhpcyBpcyBubyBuaWNlIHNvbHV0aW9uLi4uXG4gICAgICBmcmFtZS5wcm9ncmVzcy5zdHlsZS5ib3R0b20gPSA2MCArICdweCc7IC8vIFRPRE86IHVzZSBoZWlnaHQgb2Ygc2xpZGVyXG4gICAgICBmcmFtZS5wcm9ncmVzcy5zdHlsZS5sZWZ0ID0gMTAgKyAncHgnO1xuXG4gICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1lLmxvYWRJbkJhY2tncm91bmQoaW5kZXggKyAxKTtcbiAgICAgIH0sIDEwKTtcbiAgICAgIHRoaXMubG9hZGVkID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9hZGVkID0gdHJ1ZTtcblxuICAgICAgLy8gcmVtb3ZlIHRoZSBwcm9ncmVzcyBib3hcbiAgICAgIGlmIChmcmFtZS5wcm9ncmVzcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZyYW1lLnJlbW92ZUNoaWxkKGZyYW1lLnByb2dyZXNzKTtcbiAgICAgICAgZnJhbWUucHJvZ3Jlc3MgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9uTG9hZENhbGxiYWNrKSB0aGlzLm9uTG9hZENhbGxiYWNrKCk7XG4gICAgfVxuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gRmlsdGVyO1xuXG4vKioqLyB9LFxuLyogMTggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvciBTbGlkZXJcbiAgICpcbiAgICogQW4gaHRtbCBzbGlkZXIgY29udHJvbCB3aXRoIHN0YXJ0L3N0b3AvcHJldi9uZXh0IGJ1dHRvbnNcbiAgICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZXIgIFRoZSBlbGVtZW50IHdoZXJlIHRoZSBzbGlkZXIgd2lsbCBiZSBjcmVhdGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zICAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gICAqICAgICAgICAgICAgICAgICB7Ym9vbGVhbn0gdmlzaWJsZSAgIElmIHRydWUgKGRlZmF1bHQpIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsaWRlciBpcyB2aXNpYmxlLlxuICAgKi9cbiAgZnVuY3Rpb24gU2xpZGVyKGNvbnRhaW5lciwgb3B0aW9ucykge1xuICAgIGlmIChjb250YWluZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgJ0Vycm9yOiBObyBjb250YWluZXIgZWxlbWVudCBkZWZpbmVkJztcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy52aXNpYmxlID0gb3B0aW9ucyAmJiBvcHRpb25zLnZpc2libGUgIT0gdW5kZWZpbmVkID8gb3B0aW9ucy52aXNpYmxlIDogdHJ1ZTtcblxuICAgIGlmICh0aGlzLnZpc2libGUpIHtcbiAgICAgIHRoaXMuZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcbiAgICAgIC8vdGhpcy5mcmFtZS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnI0U1RTVFNSc7XG4gICAgICB0aGlzLmZyYW1lLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgdGhpcy5mcmFtZS5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmZyYW1lKTtcblxuICAgICAgdGhpcy5mcmFtZS5wcmV2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnSU5QVVQnKTtcbiAgICAgIHRoaXMuZnJhbWUucHJldi50eXBlID0gJ0JVVFRPTic7XG4gICAgICB0aGlzLmZyYW1lLnByZXYudmFsdWUgPSAnUHJldic7XG4gICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuZnJhbWUucHJldik7XG5cbiAgICAgIHRoaXMuZnJhbWUucGxheSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0lOUFVUJyk7XG4gICAgICB0aGlzLmZyYW1lLnBsYXkudHlwZSA9ICdCVVRUT04nO1xuICAgICAgdGhpcy5mcmFtZS5wbGF5LnZhbHVlID0gJ1BsYXknO1xuICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmZyYW1lLnBsYXkpO1xuXG4gICAgICB0aGlzLmZyYW1lLm5leHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdJTlBVVCcpO1xuICAgICAgdGhpcy5mcmFtZS5uZXh0LnR5cGUgPSAnQlVUVE9OJztcbiAgICAgIHRoaXMuZnJhbWUubmV4dC52YWx1ZSA9ICdOZXh0JztcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5mcmFtZS5uZXh0KTtcblxuICAgICAgdGhpcy5mcmFtZS5iYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdJTlBVVCcpO1xuICAgICAgdGhpcy5mcmFtZS5iYXIudHlwZSA9ICdCVVRUT04nO1xuICAgICAgdGhpcy5mcmFtZS5iYXIuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgdGhpcy5mcmFtZS5iYXIuc3R5bGUuYm9yZGVyID0gJzFweCBzb2xpZCByZWQnO1xuICAgICAgdGhpcy5mcmFtZS5iYXIuc3R5bGUud2lkdGggPSAnMTAwcHgnO1xuICAgICAgdGhpcy5mcmFtZS5iYXIuc3R5bGUuaGVpZ2h0ID0gJzZweCc7XG4gICAgICB0aGlzLmZyYW1lLmJhci5zdHlsZS5ib3JkZXJSYWRpdXMgPSAnMnB4JztcbiAgICAgIHRoaXMuZnJhbWUuYmFyLnN0eWxlLk1vekJvcmRlclJhZGl1cyA9ICcycHgnO1xuICAgICAgdGhpcy5mcmFtZS5iYXIuc3R5bGUuYm9yZGVyID0gJzFweCBzb2xpZCAjN0Y3RjdGJztcbiAgICAgIHRoaXMuZnJhbWUuYmFyLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcjRTVFNUU1JztcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5mcmFtZS5iYXIpO1xuXG4gICAgICB0aGlzLmZyYW1lLnNsaWRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnSU5QVVQnKTtcbiAgICAgIHRoaXMuZnJhbWUuc2xpZGUudHlwZSA9ICdCVVRUT04nO1xuICAgICAgdGhpcy5mcmFtZS5zbGlkZS5zdHlsZS5tYXJnaW4gPSAnMHB4JztcbiAgICAgIHRoaXMuZnJhbWUuc2xpZGUudmFsdWUgPSAnICc7XG4gICAgICB0aGlzLmZyYW1lLnNsaWRlLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgIHRoaXMuZnJhbWUuc2xpZGUuc3R5bGUubGVmdCA9ICctMTAwcHgnO1xuICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmZyYW1lLnNsaWRlKTtcblxuICAgICAgLy8gY3JlYXRlIGV2ZW50c1xuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIHRoaXMuZnJhbWUuc2xpZGUub25tb3VzZWRvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgbWUuX29uTW91c2VEb3duKGV2ZW50KTtcbiAgICAgIH07XG4gICAgICB0aGlzLmZyYW1lLnByZXYub25jbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBtZS5wcmV2KGV2ZW50KTtcbiAgICAgIH07XG4gICAgICB0aGlzLmZyYW1lLnBsYXkub25jbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBtZS50b2dnbGVQbGF5KGV2ZW50KTtcbiAgICAgIH07XG4gICAgICB0aGlzLmZyYW1lLm5leHQub25jbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBtZS5uZXh0KGV2ZW50KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gdW5kZWZpbmVkO1xuXG4gICAgdGhpcy52YWx1ZXMgPSBbXTtcbiAgICB0aGlzLmluZGV4ID0gdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5wbGF5VGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBsYXlJbnRlcnZhbCA9IDEwMDA7IC8vIG1pbGxpc2Vjb25kc1xuICAgIHRoaXMucGxheUxvb3AgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdCB0aGUgcHJldmlvdXMgaW5kZXhcbiAgICovXG4gIFNsaWRlci5wcm90b3R5cGUucHJldiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmdldEluZGV4KCk7XG4gICAgaWYgKGluZGV4ID4gMCkge1xuICAgICAgaW5kZXgtLTtcbiAgICAgIHRoaXMuc2V0SW5kZXgoaW5kZXgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2VsZWN0IHRoZSBuZXh0IGluZGV4XG4gICAqL1xuICBTbGlkZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5nZXRJbmRleCgpO1xuICAgIGlmIChpbmRleCA8IHRoaXMudmFsdWVzLmxlbmd0aCAtIDEpIHtcbiAgICAgIGluZGV4Kys7XG4gICAgICB0aGlzLnNldEluZGV4KGluZGV4KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNlbGVjdCB0aGUgbmV4dCBpbmRleFxuICAgKi9cbiAgU2xpZGVyLnByb3RvdHlwZS5wbGF5TmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhcnQgPSBuZXcgRGF0ZSgpO1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5nZXRJbmRleCgpO1xuICAgIGlmIChpbmRleCA8IHRoaXMudmFsdWVzLmxlbmd0aCAtIDEpIHtcbiAgICAgIGluZGV4Kys7XG4gICAgICB0aGlzLnNldEluZGV4KGluZGV4KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucGxheUxvb3ApIHtcbiAgICAgIC8vIGp1bXAgdG8gdGhlIHN0YXJ0XG4gICAgICBpbmRleCA9IDA7XG4gICAgICB0aGlzLnNldEluZGV4KGluZGV4KTtcbiAgICB9XG5cbiAgICB2YXIgZW5kID0gbmV3IERhdGUoKTtcbiAgICB2YXIgZGlmZiA9IGVuZCAtIHN0YXJ0O1xuXG4gICAgLy8gY2FsY3VsYXRlIGhvdyBtdWNoIHRpbWUgaXQgdG8gdG8gc2V0IHRoZSBpbmRleCBhbmQgdG8gZXhlY3V0ZSB0aGUgY2FsbGJhY2tcbiAgICAvLyBmdW5jdGlvbi5cbiAgICB2YXIgaW50ZXJ2YWwgPSBNYXRoLm1heCh0aGlzLnBsYXlJbnRlcnZhbCAtIGRpZmYsIDApO1xuICAgIC8vIGRvY3VtZW50LnRpdGxlID0gZGlmZiAvLyBUT0RPOiBjbGVhbnVwXG5cbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHRoaXMucGxheVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIG1lLnBsYXlOZXh0KCk7XG4gICAgfSwgaW50ZXJ2YWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUb2dnbGUgc3RhcnQgb3Igc3RvcCBwbGF5aW5nXG4gICAqL1xuICBTbGlkZXIucHJvdG90eXBlLnRvZ2dsZVBsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucGxheVRpbWVvdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5wbGF5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RvcCgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU3RhcnQgcGxheWluZ1xuICAgKi9cbiAgU2xpZGVyLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFRlc3Qgd2hldGhlciBhbHJlYWR5IHBsYXlpbmdcbiAgICBpZiAodGhpcy5wbGF5VGltZW91dCkgcmV0dXJuO1xuXG4gICAgdGhpcy5wbGF5TmV4dCgpO1xuXG4gICAgaWYgKHRoaXMuZnJhbWUpIHtcbiAgICAgIHRoaXMuZnJhbWUucGxheS52YWx1ZSA9ICdTdG9wJztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0b3AgcGxheWluZ1xuICAgKi9cbiAgU2xpZGVyLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5wbGF5VGltZW91dCk7XG4gICAgdGhpcy5wbGF5VGltZW91dCA9IHVuZGVmaW5lZDtcblxuICAgIGlmICh0aGlzLmZyYW1lKSB7XG4gICAgICB0aGlzLmZyYW1lLnBsYXkudmFsdWUgPSAnUGxheSc7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgYSBjYWxsYmFjayBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIHRyaWdnZXJlZCB3aGVuIHRoZSB2YWx1ZSBvZiB0aGVcbiAgICogc2xpZGVyIGJhciBoYXMgY2hhbmdlZC5cbiAgICovXG4gIFNsaWRlci5wcm90b3R5cGUuc2V0T25DaGFuZ2VDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGludGVydmFsIGZvciBwbGF5aW5nIHRoZSBsaXN0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbnRlcnZhbCAgIFRoZSBpbnRlcnZhbCBpbiBtaWxsaXNlY29uZHNcbiAgICovXG4gIFNsaWRlci5wcm90b3R5cGUuc2V0UGxheUludGVydmFsID0gZnVuY3Rpb24gKGludGVydmFsKSB7XG4gICAgdGhpcy5wbGF5SW50ZXJ2YWwgPSBpbnRlcnZhbDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlldmUgdGhlIGN1cnJlbnQgcGxheSBpbnRlcnZhbFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGludGVydmFsICAgVGhlIGludGVydmFsIGluIG1pbGxpc2Vjb25kc1xuICAgKi9cbiAgU2xpZGVyLnByb3RvdHlwZS5nZXRQbGF5SW50ZXJ2YWwgPSBmdW5jdGlvbiAoaW50ZXJ2YWwpIHtcbiAgICByZXR1cm4gdGhpcy5wbGF5SW50ZXJ2YWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBsb29waW5nIG9uIG9yIG9mZlxuICAgKiBAcGFyYXJtIHtib29sZWFufSBkb0xvb3AgIElmIHRydWUsIHRoZSBzbGlkZXIgd2lsbCBqdW1wIHRvIHRoZSBzdGFydCB3aGVuXG4gICAqICAgICAgICAgICAgICAgdGhlIGVuZCBpcyBwYXNzZWQsIGFuZCB3aWxsIGp1bXAgdG8gdGhlIGVuZFxuICAgKiAgICAgICAgICAgICAgIHdoZW4gdGhlIHN0YXJ0IGlzIHBhc3NlZC5cbiAgICovXG4gIFNsaWRlci5wcm90b3R5cGUuc2V0UGxheUxvb3AgPSBmdW5jdGlvbiAoZG9Mb29wKSB7XG4gICAgdGhpcy5wbGF5TG9vcCA9IGRvTG9vcDtcbiAgfTtcblxuICAvKipcbiAgICogRXhlY3V0ZSB0aGUgb25jaGFuZ2UgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICovXG4gIFNsaWRlci5wcm90b3R5cGUub25DaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMub25DaGFuZ2VDYWxsYmFjayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIHJlZHJhdyB0aGUgc2xpZGVyIG9uIHRoZSBjb3JyZWN0IHBsYWNlXG4gICAqL1xuICBTbGlkZXIucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5mcmFtZSkge1xuICAgICAgLy8gcmVzaXplIHRoZSBiYXJcbiAgICAgIHRoaXMuZnJhbWUuYmFyLnN0eWxlLnRvcCA9IHRoaXMuZnJhbWUuY2xpZW50SGVpZ2h0IC8gMiAtIHRoaXMuZnJhbWUuYmFyLm9mZnNldEhlaWdodCAvIDIgKyAncHgnO1xuICAgICAgdGhpcy5mcmFtZS5iYXIuc3R5bGUud2lkdGggPSB0aGlzLmZyYW1lLmNsaWVudFdpZHRoIC0gdGhpcy5mcmFtZS5wcmV2LmNsaWVudFdpZHRoIC0gdGhpcy5mcmFtZS5wbGF5LmNsaWVudFdpZHRoIC0gdGhpcy5mcmFtZS5uZXh0LmNsaWVudFdpZHRoIC0gMzAgKyAncHgnO1xuXG4gICAgICAvLyBwb3NpdGlvbiB0aGUgc2xpZGVyIGJ1dHRvblxuICAgICAgdmFyIGxlZnQgPSB0aGlzLmluZGV4VG9MZWZ0KHRoaXMuaW5kZXgpO1xuICAgICAgdGhpcy5mcmFtZS5zbGlkZS5zdHlsZS5sZWZ0ID0gbGVmdCArICdweCc7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGxpc3Qgd2l0aCB2YWx1ZXMgZm9yIHRoZSBzbGlkZXJcbiAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzICAgQSBqYXZhc2NyaXB0IGFycmF5IHdpdGggdmFsdWVzIChhbnkgdHlwZSlcbiAgICovXG4gIFNsaWRlci5wcm90b3R5cGUuc2V0VmFsdWVzID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuXG4gICAgaWYgKHRoaXMudmFsdWVzLmxlbmd0aCA+IDApIHRoaXMuc2V0SW5kZXgoMCk7ZWxzZSB0aGlzLmluZGV4ID0gdW5kZWZpbmVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZWxlY3QgYSB2YWx1ZSBieSBpdHMgaW5kZXhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqL1xuICBTbGlkZXIucHJvdG90eXBlLnNldEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgdGhpcy52YWx1ZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG5cbiAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgICB0aGlzLm9uQ2hhbmdlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93ICdFcnJvcjogaW5kZXggb3V0IG9mIHJhbmdlJztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIHJldHJpZXZlIHRoZSBpbmRleCBvZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHZhdWVcbiAgICogQHJldHVybiB7TnVtYmVyfSBpbmRleFxuICAgKi9cbiAgU2xpZGVyLnByb3RvdHlwZS5nZXRJbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbmRleDtcbiAgfTtcblxuICAvKipcbiAgICogcmV0cmlldmUgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCB2YWx1ZVxuICAgKiBAcmV0dXJuIHsqfSB2YWx1ZVxuICAgKi9cbiAgU2xpZGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzW3RoaXMuaW5kZXhdO1xuICB9O1xuXG4gIFNsaWRlci5wcm90b3R5cGUuX29uTW91c2VEb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gb25seSByZWFjdCBvbiBsZWZ0IG1vdXNlIGJ1dHRvbiBkb3duXG4gICAgdmFyIGxlZnRCdXR0b25Eb3duID0gZXZlbnQud2hpY2ggPyBldmVudC53aGljaCA9PT0gMSA6IGV2ZW50LmJ1dHRvbiA9PT0gMTtcbiAgICBpZiAoIWxlZnRCdXR0b25Eb3duKSByZXR1cm47XG5cbiAgICB0aGlzLnN0YXJ0Q2xpZW50WCA9IGV2ZW50LmNsaWVudFg7XG4gICAgdGhpcy5zdGFydFNsaWRlWCA9IHBhcnNlRmxvYXQodGhpcy5mcmFtZS5zbGlkZS5zdHlsZS5sZWZ0KTtcblxuICAgIHRoaXMuZnJhbWUuc3R5bGUuY3Vyc29yID0gJ21vdmUnO1xuXG4gICAgLy8gYWRkIGV2ZW50IGxpc3RlbmVycyB0byBoYW5kbGUgbW92aW5nIHRoZSBjb250ZW50c1xuICAgIC8vIHdlIHN0b3JlIHRoZSBmdW5jdGlvbiBvbm1vdXNlbW92ZSBhbmQgb25tb3VzZXVwIGluIHRoZSBncmFwaCwgc28gd2UgY2FuXG4gICAgLy8gcmVtb3ZlIHRoZSBldmVudGxpc3RlbmVycyBsYXRlcm9uIGluIHRoZSBmdW5jdGlvbiBtb3VzZVVwKClcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHRoaXMub25tb3VzZW1vdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIG1lLl9vbk1vdXNlTW92ZShldmVudCk7XG4gICAgfTtcbiAgICB0aGlzLm9ubW91c2V1cCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgbWUuX29uTW91c2VVcChldmVudCk7XG4gICAgfTtcbiAgICB1dGlsLmFkZEV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsICdtb3VzZW1vdmUnLCB0aGlzLm9ubW91c2Vtb3ZlKTtcbiAgICB1dGlsLmFkZEV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsICdtb3VzZXVwJywgdGhpcy5vbm1vdXNldXApO1xuICAgIHV0aWwucHJldmVudERlZmF1bHQoZXZlbnQpO1xuICB9O1xuXG4gIFNsaWRlci5wcm90b3R5cGUubGVmdFRvSW5kZXggPSBmdW5jdGlvbiAobGVmdCkge1xuICAgIHZhciB3aWR0aCA9IHBhcnNlRmxvYXQodGhpcy5mcmFtZS5iYXIuc3R5bGUud2lkdGgpIC0gdGhpcy5mcmFtZS5zbGlkZS5jbGllbnRXaWR0aCAtIDEwO1xuICAgIHZhciB4ID0gbGVmdCAtIDM7XG5cbiAgICB2YXIgaW5kZXggPSBNYXRoLnJvdW5kKHggLyB3aWR0aCAqICh0aGlzLnZhbHVlcy5sZW5ndGggLSAxKSk7XG4gICAgaWYgKGluZGV4IDwgMCkgaW5kZXggPSAwO1xuICAgIGlmIChpbmRleCA+IHRoaXMudmFsdWVzLmxlbmd0aCAtIDEpIGluZGV4ID0gdGhpcy52YWx1ZXMubGVuZ3RoIC0gMTtcblxuICAgIHJldHVybiBpbmRleDtcbiAgfTtcblxuICBTbGlkZXIucHJvdG90eXBlLmluZGV4VG9MZWZ0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgdmFyIHdpZHRoID0gcGFyc2VGbG9hdCh0aGlzLmZyYW1lLmJhci5zdHlsZS53aWR0aCkgLSB0aGlzLmZyYW1lLnNsaWRlLmNsaWVudFdpZHRoIC0gMTA7XG5cbiAgICB2YXIgeCA9IGluZGV4IC8gKHRoaXMudmFsdWVzLmxlbmd0aCAtIDEpICogd2lkdGg7XG4gICAgdmFyIGxlZnQgPSB4ICsgMztcblxuICAgIHJldHVybiBsZWZ0O1xuICB9O1xuXG4gIFNsaWRlci5wcm90b3R5cGUuX29uTW91c2VNb3ZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGRpZmYgPSBldmVudC5jbGllbnRYIC0gdGhpcy5zdGFydENsaWVudFg7XG4gICAgdmFyIHggPSB0aGlzLnN0YXJ0U2xpZGVYICsgZGlmZjtcblxuICAgIHZhciBpbmRleCA9IHRoaXMubGVmdFRvSW5kZXgoeCk7XG5cbiAgICB0aGlzLnNldEluZGV4KGluZGV4KTtcblxuICAgIHV0aWwucHJldmVudERlZmF1bHQoKTtcbiAgfTtcblxuICBTbGlkZXIucHJvdG90eXBlLl9vbk1vdXNlVXAgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB0aGlzLmZyYW1lLnN0eWxlLmN1cnNvciA9ICdhdXRvJztcblxuICAgIC8vIHJlbW92ZSBldmVudCBsaXN0ZW5lcnNcbiAgICB1dGlsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsICdtb3VzZW1vdmUnLCB0aGlzLm9ubW91c2Vtb3ZlKTtcbiAgICB1dGlsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsICdtb3VzZXVwJywgdGhpcy5vbm1vdXNldXApO1xuXG4gICAgdXRpbC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gU2xpZGVyO1xuXG4vKioqLyB9LFxuLyogMTkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIC8qKlxuICAgKiBAcHJvdG90eXBlIFN0ZXBOdW1iZXJcbiAgICogVGhlIGNsYXNzIFN0ZXBOdW1iZXIgaXMgYW4gaXRlcmF0b3IgZm9yIE51bWJlcnMuIFlvdSBwcm92aWRlIGEgc3RhcnQgYW5kIGVuZFxuICAgKiB2YWx1ZSwgYW5kIGEgYmVzdCBzdGVwIHNpemUuIFN0ZXBOdW1iZXIgaXRzZWxmIHJvdW5kcyB0byBmaXhlZCB2YWx1ZXMgYW5kXG4gICAqIGEgZmluZHMgdGhlIHN0ZXAgdGhhdCBiZXN0IGZpdHMgdGhlIHByb3ZpZGVkIHN0ZXAuXG4gICAqXG4gICAqIElmIHByZXR0eVN0ZXAgaXMgdHJ1ZSwgdGhlIHN0ZXAgc2l6ZSBpcyBjaG9zZW4gYXMgY2xvc2UgYXMgcG9zc2libGUgdG8gdGhlXG4gICAqIHByb3ZpZGVkIHN0ZXAsIGJ1dCBiZWluZyBhIHJvdW5kIHZhbHVlIGxpa2UgMSwgMiwgNSwgMTAsIDIwLCA1MCwgLi4uLlxuICAgKlxuICAgKiBFeGFtcGxlIHVzYWdlOlxuICAgKiAgIHZhciBzdGVwID0gbmV3IFN0ZXBOdW1iZXIoMCwgMTAsIDIuNSwgdHJ1ZSk7XG4gICAqICAgc3RlcC5zdGFydCgpO1xuICAgKiAgIHdoaWxlICghc3RlcC5lbmQoKSkge1xuICAgKiAgIGFsZXJ0KHN0ZXAuZ2V0Q3VycmVudCgpKTtcbiAgICogICBzdGVwLm5leHQoKTtcbiAgICogICB9XG4gICAqXG4gICAqIFZlcnNpb246IDEuMFxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgICAgIFRoZSBzdGFydCB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gZW5kICAgICBUaGUgZW5kIHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGVwICAgIE9wdGlvbmFsLiBTdGVwIHNpemUuIE11c3QgYmUgYSBwb3NpdGl2ZSB2YWx1ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBwcmV0dHlTdGVwIE9wdGlvbmFsLiBJZiB0cnVlLCB0aGUgc3RlcCBzaXplIGlzIHJvdW5kZWRcbiAgICogICAgICAgICAgICAgICBUbyBhIHByZXR0eSBzdGVwIHNpemUgKGxpa2UgMSwgMiwgNSwgMTAsIDIwLCA1MCwgLi4uKVxuICAgKi9cbiAgZnVuY3Rpb24gU3RlcE51bWJlcihzdGFydCwgZW5kLCBzdGVwLCBwcmV0dHlTdGVwKSB7XG4gICAgLy8gc2V0IGRlZmF1bHQgdmFsdWVzXG4gICAgdGhpcy5fc3RhcnQgPSAwO1xuICAgIHRoaXMuX2VuZCA9IDA7XG4gICAgdGhpcy5fc3RlcCA9IDE7XG4gICAgdGhpcy5wcmV0dHlTdGVwID0gdHJ1ZTtcbiAgICB0aGlzLnByZWNpc2lvbiA9IDU7XG5cbiAgICB0aGlzLl9jdXJyZW50ID0gMDtcbiAgICB0aGlzLnNldFJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXAsIHByZXR0eVN0ZXApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgYSBuZXcgcmFuZ2U6IHN0YXJ0LCBlbmQgYW5kIHN0ZXAuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCAgICAgVGhlIHN0YXJ0IHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgICAgIFRoZSBlbmQgdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0ZXAgICAgT3B0aW9uYWwuIFN0ZXAgc2l6ZS4gTXVzdCBiZSBhIHBvc2l0aXZlIHZhbHVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHByZXR0eVN0ZXAgT3B0aW9uYWwuIElmIHRydWUsIHRoZSBzdGVwIHNpemUgaXMgcm91bmRlZFxuICAgKiAgICAgICAgICAgICAgIFRvIGEgcHJldHR5IHN0ZXAgc2l6ZSAobGlrZSAxLCAyLCA1LCAxMCwgMjAsIDUwLCAuLi4pXG4gICAqL1xuICBTdGVwTnVtYmVyLnByb3RvdHlwZS5zZXRSYW5nZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBzdGVwLCBwcmV0dHlTdGVwKSB7XG4gICAgdGhpcy5fc3RhcnQgPSBzdGFydCA/IHN0YXJ0IDogMDtcbiAgICB0aGlzLl9lbmQgPSBlbmQgPyBlbmQgOiAwO1xuXG4gICAgdGhpcy5zZXRTdGVwKHN0ZXAsIHByZXR0eVN0ZXApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgYSBuZXcgc3RlcCBzaXplXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGVwICAgIE5ldyBzdGVwIHNpemUuIE11c3QgYmUgYSBwb3NpdGl2ZSB2YWx1ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHByZXR0eVN0ZXAgT3B0aW9uYWwuIElmIHRydWUsIHRoZSBwcm92aWRlZCBzdGVwIGlzIHJvdW5kZWRcbiAgICogICAgICAgICAgICAgICB0byBhIHByZXR0eSBzdGVwIHNpemUgKGxpa2UgMSwgMiwgNSwgMTAsIDIwLCA1MCwgLi4uKVxuICAgKi9cbiAgU3RlcE51bWJlci5wcm90b3R5cGUuc2V0U3RlcCA9IGZ1bmN0aW9uIChzdGVwLCBwcmV0dHlTdGVwKSB7XG4gICAgaWYgKHN0ZXAgPT09IHVuZGVmaW5lZCB8fCBzdGVwIDw9IDApIHJldHVybjtcblxuICAgIGlmIChwcmV0dHlTdGVwICE9PSB1bmRlZmluZWQpIHRoaXMucHJldHR5U3RlcCA9IHByZXR0eVN0ZXA7XG5cbiAgICBpZiAodGhpcy5wcmV0dHlTdGVwID09PSB0cnVlKSB0aGlzLl9zdGVwID0gU3RlcE51bWJlci5jYWxjdWxhdGVQcmV0dHlTdGVwKHN0ZXApO2Vsc2UgdGhpcy5fc3RlcCA9IHN0ZXA7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBhIG5pY2Ugc3RlcCBzaXplLCBjbG9zZXN0IHRvIHRoZSBkZXNpcmVkIHN0ZXAgc2l6ZS5cbiAgICogUmV0dXJucyBhIHZhbHVlIGluIG9uZSBvZiB0aGUgcmFuZ2VzIDEqMTBebiwgMioxMF5uLCBvciA1KjEwXm4sIHdoZXJlIG4gaXMgYW5cbiAgICogaW50ZWdlciBOdW1iZXIuIEZvciBleGFtcGxlIDEsIDIsIDUsIDEwLCAyMCwgNTAsIGV0Yy4uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gIHN0ZXAgIERlc2lyZWQgc3RlcCBzaXplXG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgIE5pY2Ugc3RlcCBzaXplXG4gICAqL1xuICBTdGVwTnVtYmVyLmNhbGN1bGF0ZVByZXR0eVN0ZXAgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgIHZhciBsb2cxMCA9IGZ1bmN0aW9uIGxvZzEwKHgpIHtcbiAgICAgIHJldHVybiBNYXRoLmxvZyh4KSAvIE1hdGguTE4xMDtcbiAgICB9O1xuXG4gICAgLy8gdHJ5IHRocmVlIHN0ZXBzIChtdWx0aXBsZSBvZiAxLCAyLCBvciA1XG4gICAgdmFyIHN0ZXAxID0gTWF0aC5wb3coMTAsIE1hdGgucm91bmQobG9nMTAoc3RlcCkpKSxcbiAgICAgICAgc3RlcDIgPSAyICogTWF0aC5wb3coMTAsIE1hdGgucm91bmQobG9nMTAoc3RlcCAvIDIpKSksXG4gICAgICAgIHN0ZXA1ID0gNSAqIE1hdGgucG93KDEwLCBNYXRoLnJvdW5kKGxvZzEwKHN0ZXAgLyA1KSkpO1xuXG4gICAgLy8gY2hvb3NlIHRoZSBiZXN0IHN0ZXAgKGNsb3Nlc3QgdG8gbWluaW11bSBzdGVwKVxuICAgIHZhciBwcmV0dHlTdGVwID0gc3RlcDE7XG4gICAgaWYgKE1hdGguYWJzKHN0ZXAyIC0gc3RlcCkgPD0gTWF0aC5hYnMocHJldHR5U3RlcCAtIHN0ZXApKSBwcmV0dHlTdGVwID0gc3RlcDI7XG4gICAgaWYgKE1hdGguYWJzKHN0ZXA1IC0gc3RlcCkgPD0gTWF0aC5hYnMocHJldHR5U3RlcCAtIHN0ZXApKSBwcmV0dHlTdGVwID0gc3RlcDU7XG5cbiAgICAvLyBmb3Igc2FmZXR5XG4gICAgaWYgKHByZXR0eVN0ZXAgPD0gMCkge1xuICAgICAgcHJldHR5U3RlcCA9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZXR0eVN0ZXA7XG4gIH07XG5cbiAgLyoqXG4gICAqIHJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIHN0ZXBcbiAgICogQHJldHVybiB7TnVtYmVyfSBjdXJyZW50IHZhbHVlXG4gICAqL1xuICBTdGVwTnVtYmVyLnByb3RvdHlwZS5nZXRDdXJyZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHRoaXMuX2N1cnJlbnQudG9QcmVjaXNpb24odGhpcy5wcmVjaXNpb24pKTtcbiAgfTtcblxuICAvKipcbiAgICogcmV0dXJucyB0aGUgY3VycmVudCBzdGVwIHNpemVcbiAgICogQHJldHVybiB7TnVtYmVyfSBjdXJyZW50IHN0ZXAgc2l6ZVxuICAgKi9cbiAgU3RlcE51bWJlci5wcm90b3R5cGUuZ2V0U3RlcCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RlcDtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBjdXJyZW50IHZhbHVlIHRvIHRoZSBsYXJnZXN0IHZhbHVlIHNtYWxsZXIgdGhhbiBzdGFydCwgd2hpY2hcbiAgICogaXMgYSBtdWx0aXBsZSBvZiB0aGUgc3RlcCBzaXplXG4gICAqL1xuICBTdGVwTnVtYmVyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jdXJyZW50ID0gdGhpcy5fc3RhcnQgLSB0aGlzLl9zdGFydCAlIHRoaXMuX3N0ZXA7XG4gIH07XG5cbiAgLyoqXG4gICAqIERvIGEgc3RlcCwgYWRkIHRoZSBzdGVwIHNpemUgdG8gdGhlIGN1cnJlbnQgdmFsdWVcbiAgICovXG4gIFN0ZXBOdW1iZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fY3VycmVudCArPSB0aGlzLl9zdGVwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgd2hldGhlciB0aGUgZW5kIGlzIHJlYWNoZWRcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gIFRydWUgaWYgdGhlIGN1cnJlbnQgdmFsdWUgaGFzIHBhc3NlZCB0aGUgZW5kIHZhbHVlLlxuICAgKi9cbiAgU3RlcE51bWJlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50ID4gdGhpcy5fZW5kO1xuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gU3RlcE51bWJlcjtcblxuLyoqKi8gfSxcbi8qIDIwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gT25seSBsb2FkIGhhbW1lci5qcyB3aGVuIGluIGEgYnJvd3NlciBlbnZpcm9ubWVudFxuICAvLyAobG9hZGluZyBoYW1tZXIuanMgaW4gYSBub2RlLmpzIGVudmlyb25tZW50IGdpdmVzIGVycm9ycylcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIHByb3BhZ2F0aW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG4gICAgdmFyIEhhbW1lciA9IHdpbmRvd1snSGFtbWVyJ10gfHwgX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBwcm9wYWdhdGluZyhIYW1tZXIsIHtcbiAgICAgIHByZXZlbnREZWZhdWx0OiAnbW91c2UnXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBFcnJvcignaGFtbWVyLmpzIGlzIG9ubHkgYXZhaWxhYmxlIGluIGEgYnJvd3Nlciwgbm90IGluIG5vZGUuanMuJyk7XG4gICAgfTtcbiAgfVxuXG4vKioqLyB9LFxuLyogMjEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gIHZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyd1c2Ugc3RyaWN0JztcblxuICAoZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgICBpZiAodHJ1ZSkge1xuICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgICAgIShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW10sIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9IChmYWN0b3J5KSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/IChfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18uYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXykpIDogX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAvLyBOb2RlLiBEb2VzIG5vdCB3b3JrIHdpdGggc3RyaWN0IENvbW1vbkpTLCBidXRcbiAgICAgIC8vIG9ubHkgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxuICAgICAgLy8gbGlrZSBOb2RlLlxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEJyb3dzZXIgZ2xvYmFscyAocm9vdCBpcyB3aW5kb3cpXG4gICAgICB3aW5kb3cucHJvcGFnYXRpbmcgPSBmYWN0b3J5KCk7XG4gICAgfVxuICB9KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2ZpcnN0VGFyZ2V0ID0gbnVsbDsgLy8gc2luZ2xldG9uLCB3aWxsIGNvbnRhaW4gdGhlIHRhcmdldCBlbGVtZW50IHdoZXJlIHRoZSB0b3VjaCBldmVudCBzdGFydGVkXG5cbiAgICAvKipcbiAgICAgKiBFeHRlbmQgYW4gSGFtbWVyLmpzIGluc3RhbmNlIHdpdGggZXZlbnQgcHJvcGFnYXRpb24uXG4gICAgICpcbiAgICAgKiBGZWF0dXJlczpcbiAgICAgKiAtIEV2ZW50cyBlbWl0dGVkIGJ5IGhhbW1lciB3aWxsIHByb3BhZ2F0ZSBpbiBvcmRlciBmcm9tIGNoaWxkIHRvIHBhcmVudFxuICAgICAqICAgZWxlbWVudHMuXG4gICAgICogLSBFdmVudHMgYXJlIGV4dGVuZGVkIHdpdGggYSBmdW5jdGlvbiBgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClgIHRvIHN0b3BcbiAgICAgKiAgIHByb3BhZ2F0aW9uIHRvIHBhcmVudCBlbGVtZW50cy5cbiAgICAgKiAtIEFuIG9wdGlvbiBgcHJldmVudERlZmF1bHRgIHRvIHN0b3AgYWxsIGRlZmF1bHQgYnJvd3NlciBiZWhhdmlvci5cbiAgICAgKlxuICAgICAqIFVzYWdlOlxuICAgICAqICAgdmFyIGhhbW1lciA9IHByb3BhZ2F0aW5nSGFtbWVyKG5ldyBIYW1tZXIoZWxlbWVudCkpO1xuICAgICAqICAgdmFyIGhhbW1lciA9IHByb3BhZ2F0aW5nSGFtbWVyKG5ldyBIYW1tZXIoZWxlbWVudCksIHtwcmV2ZW50RGVmYXVsdDogdHJ1ZX0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIHtIYW1tZXIuTWFuYWdlcn0gaGFtbWVyICAgQW4gaGFtbWVyIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgICAgIEF2YWlsYWJsZSBvcHRpb25zOlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gYHByZXZlbnREZWZhdWx0OiB0cnVlIHwgZmFsc2UgfCAnbW91c2UnIHwgJ3RvdWNoJyB8ICdwZW4nYC5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVuZm9yY2UgcHJldmVudGluZyB0aGUgZGVmYXVsdCBicm93c2VyIGJlaGF2aW9yLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2Fubm90IGJlIHNldCB0byBgZmFsc2VgLlxuICAgICAqIEByZXR1cm4ge0hhbW1lci5NYW5hZ2VyfSBSZXR1cm5zIHRoZSBzYW1lIGhhbW1lciBpbnN0YW5jZSB3aXRoIGV4dGVuZGVkXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uYWxpdHlcbiAgICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24gcHJvcGFnYXRpbmcoaGFtbWVyLCBvcHRpb25zKSB7XG4gICAgICB2YXIgX29wdGlvbnMgPSBvcHRpb25zIHx8IHtcbiAgICAgICAgcHJldmVudERlZmF1bHQ6IGZhbHNlXG4gICAgICB9O1xuXG4gICAgICBpZiAoaGFtbWVyLk1hbmFnZXIpIHtcbiAgICAgICAgLy8gVGhpcyBsb29rcyBsaWtlIHRoZSBIYW1tZXIgY29uc3RydWN0b3IuXG4gICAgICAgIC8vIE92ZXJsb2FkIHRoZSBjb25zdHJ1Y3RvcnMgd2l0aCBvdXIgb3duLlxuICAgICAgICB2YXIgSGFtbWVyID0gaGFtbWVyO1xuXG4gICAgICAgIHZhciBQcm9wYWdhdGluZ0hhbW1lciA9IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgICB2YXIgbyA9IE9iamVjdC5jcmVhdGUoX29wdGlvbnMpO1xuICAgICAgICAgIGlmIChvcHRpb25zKSBIYW1tZXIuYXNzaWduKG8sIG9wdGlvbnMpO1xuICAgICAgICAgIHJldHVybiBwcm9wYWdhdGluZyhuZXcgSGFtbWVyKGVsZW1lbnQsIG8pLCBvKTtcbiAgICAgICAgfTtcbiAgICAgICAgSGFtbWVyLmFzc2lnbihQcm9wYWdhdGluZ0hhbW1lciwgSGFtbWVyKTtcblxuICAgICAgICBQcm9wYWdhdGluZ0hhbW1lci5NYW5hZ2VyID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgICB2YXIgbyA9IE9iamVjdC5jcmVhdGUoX29wdGlvbnMpO1xuICAgICAgICAgIGlmIChvcHRpb25zKSBIYW1tZXIuYXNzaWduKG8sIG9wdGlvbnMpO1xuICAgICAgICAgIHJldHVybiBwcm9wYWdhdGluZyhuZXcgSGFtbWVyLk1hbmFnZXIoZWxlbWVudCwgbyksIG8pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBQcm9wYWdhdGluZ0hhbW1lcjtcbiAgICAgIH1cblxuICAgICAgLy8gY3JlYXRlIGEgd3JhcHBlciBvYmplY3Qgd2hpY2ggd2lsbCBvdmVycmlkZSB0aGUgZnVuY3Rpb25zXG4gICAgICAvLyBgb25gLCBgb2ZmYCwgYGRlc3Ryb3lgLCBhbmQgYGVtaXRgIG9mIHRoZSBoYW1tZXIgaW5zdGFuY2VcbiAgICAgIHZhciB3cmFwcGVyID0gT2JqZWN0LmNyZWF0ZShoYW1tZXIpO1xuXG4gICAgICAvLyBhdHRhY2ggdG8gRE9NIGVsZW1lbnRcbiAgICAgIHZhciBlbGVtZW50ID0gaGFtbWVyLmVsZW1lbnQ7XG5cbiAgICAgIGlmKCFlbGVtZW50LmhhbW1lcikgZWxlbWVudC5oYW1tZXIgPSBbXTtcbiAgICAgIGVsZW1lbnQuaGFtbWVyLnB1c2god3JhcHBlcik7XG5cbiAgICAgIC8vIHJlZ2lzdGVyIGFuIGV2ZW50IHRvIGNhdGNoIHRoZSBzdGFydCBvZiBhIGdlc3R1cmUgYW5kIHN0b3JlIHRoZVxuICAgICAgLy8gdGFyZ2V0IGluIGEgc2luZ2xldG9uXG4gICAgICBoYW1tZXIub24oJ2hhbW1lci5pbnB1dCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoX29wdGlvbnMucHJldmVudERlZmF1bHQgPT09IHRydWUgfHwgKF9vcHRpb25zLnByZXZlbnREZWZhdWx0ID09PSBldmVudC5wb2ludGVyVHlwZSkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudC5pc0ZpcnN0KSB7XG4gICAgICAgICAgX2ZpcnN0VGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLyoqIEB0eXBlIHtPYmplY3QuPFN0cmluZywgQXJyYXkuPGZ1bmN0aW9uPj59ICovXG4gICAgICB3cmFwcGVyLl9oYW5kbGVycyA9IHt9O1xuXG4gICAgICAvKipcbiAgICAgICAqIFJlZ2lzdGVyIGEgaGFuZGxlciBmb3Igb25lIG9yIG11bHRpcGxlIGV2ZW50c1xuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50cyAgICBBIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgd2l0aCBldmVudHNcbiAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgQSBjYWxsYmFjayBmdW5jdGlvbiwgY2FsbGVkIGFzIGhhbmRsZXIoZXZlbnQpXG4gICAgICAgKiBAcmV0dXJucyB7SGFtbWVyLk1hbmFnZXJ9IFJldHVybnMgdGhlIGhhbW1lciBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICB3cmFwcGVyLm9uID0gZnVuY3Rpb24gKGV2ZW50cywgaGFuZGxlcikge1xuICAgICAgICAvLyByZWdpc3RlciB0aGUgaGFuZGxlclxuICAgICAgICBzcGxpdChldmVudHMpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgdmFyIF9oYW5kbGVycyA9IHdyYXBwZXIuX2hhbmRsZXJzW2V2ZW50XTtcbiAgICAgICAgICBpZiAoIV9oYW5kbGVycykge1xuICAgICAgICAgICAgd3JhcHBlci5faGFuZGxlcnNbZXZlbnRdID0gX2hhbmRsZXJzID0gW107XG5cbiAgICAgICAgICAgIC8vIHJlZ2lzdGVyIHRoZSBzdGF0aWMsIHByb3BhZ2F0ZWQgaGFuZGxlclxuICAgICAgICAgICAgaGFtbWVyLm9uKGV2ZW50LCBwcm9wYWdhdGVkSGFuZGxlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9oYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogVW5yZWdpc3RlciBhIGhhbmRsZXIgZm9yIG9uZSBvciBtdWx0aXBsZSBldmVudHNcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudHMgICAgICBBIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgd2l0aCBldmVudHNcbiAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtoYW5kbGVyXSBPcHRpb25hbC4gVGhlIHJlZ2lzdGVyZWQgaGFuZGxlci4gSWYgbm90XG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZWQsIGFsbCBoYW5kbGVycyBmb3IgZ2l2ZW4gZXZlbnRzXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlIHJlbW92ZWQuXG4gICAgICAgKiBAcmV0dXJucyB7SGFtbWVyLk1hbmFnZXJ9ICAgUmV0dXJucyB0aGUgaGFtbWVyIGluc3RhbmNlXG4gICAgICAgKi9cbiAgICAgIHdyYXBwZXIub2ZmID0gZnVuY3Rpb24gKGV2ZW50cywgaGFuZGxlcikge1xuICAgICAgICAvLyB1bnJlZ2lzdGVyIHRoZSBoYW5kbGVyXG4gICAgICAgIHNwbGl0KGV2ZW50cykuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICB2YXIgX2hhbmRsZXJzID0gd3JhcHBlci5faGFuZGxlcnNbZXZlbnRdO1xuICAgICAgICAgIGlmIChfaGFuZGxlcnMpIHtcbiAgICAgICAgICAgIF9oYW5kbGVycyA9IGhhbmRsZXIgPyBfaGFuZGxlcnMuZmlsdGVyKGZ1bmN0aW9uIChoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoICE9PSBoYW5kbGVyO1xuICAgICAgICAgICAgfSkgOiBbXTtcblxuICAgICAgICAgICAgaWYgKF9oYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHdyYXBwZXIuX2hhbmRsZXJzW2V2ZW50XSA9IF9oYW5kbGVycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLyByZW1vdmUgc3RhdGljLCBwcm9wYWdhdGVkIGhhbmRsZXJcbiAgICAgICAgICAgICAgaGFtbWVyLm9mZihldmVudCwgcHJvcGFnYXRlZEhhbmRsZXIpO1xuICAgICAgICAgICAgICBkZWxldGUgd3JhcHBlci5faGFuZGxlcnNbZXZlbnRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIEVtaXQgdG8gdGhlIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZVxuICAgICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgICAqL1xuICAgICAgd3JhcHBlci5lbWl0ID0gZnVuY3Rpb24oZXZlbnRUeXBlLCBldmVudCkge1xuICAgICAgICBfZmlyc3RUYXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIGhhbW1lci5lbWl0KGV2ZW50VHlwZSwgZXZlbnQpO1xuICAgICAgfTtcblxuICAgICAgd3JhcHBlci5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBEZXRhY2ggZnJvbSBET00gZWxlbWVudFxuICAgICAgICB2YXIgaGFtbWVycyA9IGhhbW1lci5lbGVtZW50LmhhbW1lcjtcbiAgICAgICAgdmFyIGlkeCA9IGhhbW1lcnMuaW5kZXhPZih3cmFwcGVyKTtcbiAgICAgICAgaWYoaWR4ICE9PSAtMSkgaGFtbWVycy5zcGxpY2UoaWR4LDEpO1xuICAgICAgICBpZighaGFtbWVycy5sZW5ndGgpIGRlbGV0ZSBoYW1tZXIuZWxlbWVudC5oYW1tZXI7XG5cbiAgICAgICAgLy8gY2xlYXIgYWxsIGhhbmRsZXJzXG4gICAgICAgIHdyYXBwZXIuX2hhbmRsZXJzID0ge307XG5cbiAgICAgICAgLy8gY2FsbCBvcmlnaW5hbCBoYW1tZXIgZGVzdHJveVxuICAgICAgICBoYW1tZXIuZGVzdHJveSgpO1xuICAgICAgfTtcblxuICAgICAgLy8gc3BsaXQgYSBzdHJpbmcgd2l0aCBzcGFjZSBzZXBhcmF0ZWQgd29yZHNcbiAgICAgIGZ1bmN0aW9uIHNwbGl0KGV2ZW50cykge1xuICAgICAgICByZXR1cm4gZXZlbnRzLm1hdGNoKC9bXiBdKy9nKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBIHN0YXRpYyBldmVudCBoYW5kbGVyLCBhcHBseWluZyBldmVudCBwcm9wYWdhdGlvbi5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBwcm9wYWdhdGVkSGFuZGxlcihldmVudCkge1xuICAgICAgICAvLyBsZXQgb25seSBhIHNpbmdsZSBoYW1tZXIgaW5zdGFuY2UgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgICAgaWYgKGV2ZW50LnR5cGUgIT09ICdoYW1tZXIuaW5wdXQnKSB7XG4gICAgICAgICAgLy8gaXQgaXMgcG9zc2libGUgdGhhdCB0aGUgc2FtZSBzcmNFdmVudCBpcyB1c2VkIHdpdGggbXVsdGlwbGUgaGFtbWVyIGV2ZW50cyxcbiAgICAgICAgICAvLyB3ZSBrZWVwIHRyYWNrIG9uIHdoaWNoIGV2ZW50cyBhcmUgaGFuZGxlZCBpbiBhbiBvYmplY3QgX2hhbmRsZWRcbiAgICAgICAgICBpZiAoIWV2ZW50LnNyY0V2ZW50Ll9oYW5kbGVkKSB7XG4gICAgICAgICAgICBldmVudC5zcmNFdmVudC5faGFuZGxlZCA9IHt9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChldmVudC5zcmNFdmVudC5faGFuZGxlZFtldmVudC50eXBlXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV2ZW50LnNyY0V2ZW50Ll9oYW5kbGVkW2V2ZW50LnR5cGVdID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhdHRhY2ggYSBzdG9wUHJvcGFnYXRpb24gZnVuY3Rpb24gdG8gdGhlIGV2ZW50XG4gICAgICAgIHZhciBzdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvL3dyYXAgdGhlIHNyY0V2ZW50J3Mgc3RvcFByb3BhZ2F0aW9uIHRvIGFsc28gc3RvcCBoYW1tZXIgcHJvcGFnYXRpb246XG4gICAgICAgIHZhciBzcmNTdG9wID0gZXZlbnQuc3JjRXZlbnQuc3RvcFByb3BhZ2F0aW9uLmJpbmQoZXZlbnQuc3JjRXZlbnQpO1xuICAgICAgICBpZih0eXBlb2Ygc3JjU3RvcCA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBldmVudC5zcmNFdmVudC5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgc3JjU3RvcCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXR0YWNoIGZpcnN0VGFyZ2V0IHByb3BlcnR5IHRvIHRoZSBldmVudFxuICAgICAgICBldmVudC5maXJzdFRhcmdldCA9IF9maXJzdFRhcmdldDtcblxuICAgICAgICAvLyBwcm9wYWdhdGUgb3ZlciBhbGwgZWxlbWVudHMgKHVudGlsIHN0b3BwZWQpXG4gICAgICAgIHZhciBlbGVtID0gX2ZpcnN0VGFyZ2V0O1xuICAgICAgICB3aGlsZSAoZWxlbSAmJiAhc3RvcHBlZCkge1xuICAgICAgICAgIHZhciBlbGVtSGFtbWVyID0gZWxlbS5oYW1tZXI7XG4gICAgICAgICAgaWYoZWxlbUhhbW1lcil7XG4gICAgICAgICAgICB2YXIgX2hhbmRsZXJzO1xuICAgICAgICAgICAgZm9yKHZhciBrID0gMDsgayA8IGVsZW1IYW1tZXIubGVuZ3RoOyBrKyspe1xuICAgICAgICAgICAgICBfaGFuZGxlcnMgPSBlbGVtSGFtbWVyW2tdLl9oYW5kbGVyc1tldmVudC50eXBlXTtcbiAgICAgICAgICAgICAgaWYoX2hhbmRsZXJzKSBmb3IgKHZhciBpID0gMDsgaSA8IF9oYW5kbGVycy5sZW5ndGggJiYgIXN0b3BwZWQ7IGkrKykge1xuICAgICAgICAgICAgICAgIF9oYW5kbGVyc1tpXShldmVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbSA9IGVsZW0ucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9O1xuICB9KSk7XG5cblxuLyoqKi8gfSxcbi8qIDIyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICB2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187LyohIEhhbW1lci5KUyAtIHYyLjAuNiAtIDIwMTUtMTItMjNcbiAgICogaHR0cDovL2hhbW1lcmpzLmdpdGh1Yi5pby9cbiAgICpcbiAgICogQ29weXJpZ2h0IChjKSAyMDE1IEpvcmlrIFRhbmdlbGRlcjtcbiAgICogTGljZW5zZWQgdW5kZXIgdGhlICBsaWNlbnNlICovXG4gIChmdW5jdGlvbih3aW5kb3csIGRvY3VtZW50LCBleHBvcnROYW1lLCB1bmRlZmluZWQpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIFZFTkRPUl9QUkVGSVhFUyA9IFsnJywgJ3dlYmtpdCcsICdNb3onLCAnTVMnLCAnbXMnLCAnbyddO1xuICB2YXIgVEVTVF9FTEVNRU5UID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgdmFyIFRZUEVfRlVOQ1RJT04gPSAnZnVuY3Rpb24nO1xuXG4gIHZhciByb3VuZCA9IE1hdGgucm91bmQ7XG4gIHZhciBhYnMgPSBNYXRoLmFicztcbiAgdmFyIG5vdyA9IERhdGUubm93O1xuXG4gIC8qKlxuICAgKiBzZXQgYSB0aW1lb3V0IHdpdGggYSBnaXZlbiBzY29wZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZW91dFxuICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZnVuY3Rpb24gc2V0VGltZW91dENvbnRleHQoZm4sIHRpbWVvdXQsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiBzZXRUaW1lb3V0KGJpbmRGbihmbiwgY29udGV4dCksIHRpbWVvdXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIGlmIHRoZSBhcmd1bWVudCBpcyBhbiBhcnJheSwgd2Ugd2FudCB0byBleGVjdXRlIHRoZSBmbiBvbiBlYWNoIGVudHJ5XG4gICAqIGlmIGl0IGFpbnQgYW4gYXJyYXkgd2UgZG9uJ3Qgd2FudCB0byBkbyBhIHRoaW5nLlxuICAgKiB0aGlzIGlzIHVzZWQgYnkgYWxsIHRoZSBtZXRob2RzIHRoYXQgYWNjZXB0IGEgc2luZ2xlIGFuZCBhcnJheSBhcmd1bWVudC5cbiAgICogQHBhcmFtIHsqfEFycmF5fSBhcmdcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF1cbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuICBmdW5jdGlvbiBpbnZva2VBcnJheUFyZyhhcmcsIGZuLCBjb250ZXh0KSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgZWFjaChhcmcsIGNvbnRleHRbZm5dLCBjb250ZXh0KTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiB3YWxrIG9iamVjdHMgYW5kIGFycmF5c1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdG9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gICAqL1xuICBmdW5jdGlvbiBlYWNoKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICAgIHZhciBpO1xuXG4gICAgICBpZiAoIW9iaikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG9iai5mb3JFYWNoKSB7XG4gICAgICAgICAgb2JqLmZvckVhY2goaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgICAgfSBlbHNlIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpID0gMDtcbiAgICAgICAgICB3aGlsZSAoaSA8IG9iai5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgb2JqLmhhc093blByb3BlcnR5KGkpICYmIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiB3cmFwIGEgbWV0aG9kIHdpdGggYSBkZXByZWNhdGlvbiB3YXJuaW5nIGFuZCBzdGFjayB0cmFjZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBBIG5ldyBmdW5jdGlvbiB3cmFwcGluZyB0aGUgc3VwcGxpZWQgbWV0aG9kLlxuICAgKi9cbiAgZnVuY3Rpb24gZGVwcmVjYXRlKG1ldGhvZCwgbmFtZSwgbWVzc2FnZSkge1xuICAgICAgdmFyIGRlcHJlY2F0aW9uTWVzc2FnZSA9ICdERVBSRUNBVEVEIE1FVEhPRDogJyArIG5hbWUgKyAnXFxuJyArIG1lc3NhZ2UgKyAnIEFUIFxcbic7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ2dldC1zdGFjay10cmFjZScpO1xuICAgICAgICAgIHZhciBzdGFjayA9IGUgJiYgZS5zdGFjayA/IGUuc3RhY2sucmVwbGFjZSgvXlteXFwoXSs/W1xcbiRdL2dtLCAnJylcbiAgICAgICAgICAgICAgLnJlcGxhY2UoL15cXHMrYXRcXHMrL2dtLCAnJylcbiAgICAgICAgICAgICAgLnJlcGxhY2UoL15PYmplY3QuPGFub255bW91cz5cXHMqXFwoL2dtLCAne2Fub255bW91c30oKUAnKSA6ICdVbmtub3duIFN0YWNrIFRyYWNlJztcblxuICAgICAgICAgIHZhciBsb2cgPSB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUud2FybiB8fCB3aW5kb3cuY29uc29sZS5sb2cpO1xuICAgICAgICAgIGlmIChsb2cpIHtcbiAgICAgICAgICAgICAgbG9nLmNhbGwod2luZG93LmNvbnNvbGUsIGRlcHJlY2F0aW9uTWVzc2FnZSwgc3RhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIGV4dGVuZCBvYmplY3QuXG4gICAqIG1lYW5zIHRoYXQgcHJvcGVydGllcyBpbiBkZXN0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgdGhlIG9uZXMgaW4gc3JjLlxuICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBvYmplY3RzX3RvX2Fzc2lnblxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0YXJnZXRcbiAgICovXG4gIHZhciBhc3NpZ247XG4gIGlmICh0eXBlb2YgT2JqZWN0LmFzc2lnbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYXNzaWduID0gZnVuY3Rpb24gYXNzaWduKHRhcmdldCkge1xuICAgICAgICAgIGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCB8fCB0YXJnZXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG91dHB1dCA9IE9iamVjdCh0YXJnZXQpO1xuICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICAgICAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQgJiYgc291cmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBuZXh0S2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkobmV4dEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W25leHRLZXldID0gc291cmNlW25leHRLZXldO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgfTtcbiAgfSBlbHNlIHtcbiAgICAgIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG4gIH1cblxuICAvKipcbiAgICogZXh0ZW5kIG9iamVjdC5cbiAgICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIGluIGRlc3Qgd2lsbCBiZSBvdmVyd3JpdHRlbiBieSB0aGUgb25lcyBpbiBzcmMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzcmNcbiAgICogQHBhcmFtIHtCb29sZWFuPWZhbHNlfSBbbWVyZ2VdXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IGRlc3RcbiAgICovXG4gIHZhciBleHRlbmQgPSBkZXByZWNhdGUoZnVuY3Rpb24gZXh0ZW5kKGRlc3QsIHNyYywgbWVyZ2UpIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc3JjKTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHdoaWxlIChpIDwga2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAoIW1lcmdlIHx8IChtZXJnZSAmJiBkZXN0W2tleXNbaV1dID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgIGRlc3Rba2V5c1tpXV0gPSBzcmNba2V5c1tpXV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGkrKztcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXN0O1xuICB9LCAnZXh0ZW5kJywgJ1VzZSBgYXNzaWduYC4nKTtcblxuICAvKipcbiAgICogbWVyZ2UgdGhlIHZhbHVlcyBmcm9tIHNyYyBpbiB0aGUgZGVzdC5cbiAgICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIHRoYXQgZXhpc3QgaW4gZGVzdCB3aWxsIG5vdCBiZSBvdmVyd3JpdHRlbiBieSBzcmNcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlc3RcbiAgICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBkZXN0XG4gICAqL1xuICB2YXIgbWVyZ2UgPSBkZXByZWNhdGUoZnVuY3Rpb24gbWVyZ2UoZGVzdCwgc3JjKSB7XG4gICAgICByZXR1cm4gZXh0ZW5kKGRlc3QsIHNyYywgdHJ1ZSk7XG4gIH0sICdtZXJnZScsICdVc2UgYGFzc2lnbmAuJyk7XG5cbiAgLyoqXG4gICAqIHNpbXBsZSBjbGFzcyBpbmhlcml0YW5jZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjaGlsZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBiYXNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc11cbiAgICovXG4gIGZ1bmN0aW9uIGluaGVyaXQoY2hpbGQsIGJhc2UsIHByb3BlcnRpZXMpIHtcbiAgICAgIHZhciBiYXNlUCA9IGJhc2UucHJvdG90eXBlLFxuICAgICAgICAgIGNoaWxkUDtcblxuICAgICAgY2hpbGRQID0gY2hpbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShiYXNlUCk7XG4gICAgICBjaGlsZFAuY29uc3RydWN0b3IgPSBjaGlsZDtcbiAgICAgIGNoaWxkUC5fc3VwZXIgPSBiYXNlUDtcblxuICAgICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICBhc3NpZ24oY2hpbGRQLCBwcm9wZXJ0aWVzKTtcbiAgICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBzaW1wbGUgZnVuY3Rpb24gYmluZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBiaW5kRm4oZm4sIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBib3VuZEZuKCkge1xuICAgICAgICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBsZXQgYSBib29sZWFuIHZhbHVlIGFsc28gYmUgYSBmdW5jdGlvbiB0aGF0IG11c3QgcmV0dXJuIGEgYm9vbGVhblxuICAgKiB0aGlzIGZpcnN0IGl0ZW0gaW4gYXJncyB3aWxsIGJlIHVzZWQgYXMgdGhlIGNvbnRleHRcbiAgICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSB2YWxcbiAgICogQHBhcmFtIHtBcnJheX0gW2FyZ3NdXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gYm9vbE9yRm4odmFsLCBhcmdzKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PSBUWVBFX0ZVTkNUSU9OKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbC5hcHBseShhcmdzID8gYXJnc1swXSB8fCB1bmRlZmluZWQgOiB1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiB1c2UgdGhlIHZhbDIgd2hlbiB2YWwxIGlzIHVuZGVmaW5lZFxuICAgKiBAcGFyYW0geyp9IHZhbDFcbiAgICogQHBhcmFtIHsqfSB2YWwyXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgZnVuY3Rpb24gaWZVbmRlZmluZWQodmFsMSwgdmFsMikge1xuICAgICAgcmV0dXJuICh2YWwxID09PSB1bmRlZmluZWQpID8gdmFsMiA6IHZhbDE7XG4gIH1cblxuICAvKipcbiAgICogYWRkRXZlbnRMaXN0ZW5lciB3aXRoIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcnModGFyZ2V0LCB0eXBlcywgaGFuZGxlcikge1xuICAgICAgZWFjaChzcGxpdFN0cih0eXBlcyksIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZW1vdmVFdmVudExpc3RlbmVyIHdpdGggbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2VcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycyh0YXJnZXQsIHR5cGVzLCBoYW5kbGVyKSB7XG4gICAgICBlYWNoKHNwbGl0U3RyKHR5cGVzKSwgZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIGZpbmQgaWYgYSBub2RlIGlzIGluIHRoZSBnaXZlbiBwYXJlbnRcbiAgICogQG1ldGhvZCBoYXNQYXJlbnRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gZm91bmRcbiAgICovXG4gIGZ1bmN0aW9uIGhhc1BhcmVudChub2RlLCBwYXJlbnQpIHtcbiAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgaWYgKG5vZGUgPT0gcGFyZW50KSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIHNtYWxsIGluZGV4T2Ygd3JhcHBlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmaW5kXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBmb3VuZFxuICAgKi9cbiAgZnVuY3Rpb24gaW5TdHIoc3RyLCBmaW5kKSB7XG4gICAgICByZXR1cm4gc3RyLmluZGV4T2YoZmluZCkgPiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBzcGxpdCBzdHJpbmcgb24gd2hpdGVzcGFjZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICAqIEByZXR1cm5zIHtBcnJheX0gd29yZHNcbiAgICovXG4gIGZ1bmN0aW9uIHNwbGl0U3RyKHN0cikge1xuICAgICAgcmV0dXJuIHN0ci50cmltKCkuc3BsaXQoL1xccysvZyk7XG4gIH1cblxuICAvKipcbiAgICogZmluZCBpZiBhIGFycmF5IGNvbnRhaW5zIHRoZSBvYmplY3QgdXNpbmcgaW5kZXhPZiBvciBhIHNpbXBsZSBwb2x5RmlsbFxuICAgKiBAcGFyYW0ge0FycmF5fSBzcmNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtmaW5kQnlLZXldXG4gICAqIEByZXR1cm4ge0Jvb2xlYW58TnVtYmVyfSBmYWxzZSB3aGVuIG5vdCBmb3VuZCwgb3IgdGhlIGluZGV4XG4gICAqL1xuICBmdW5jdGlvbiBpbkFycmF5KHNyYywgZmluZCwgZmluZEJ5S2V5KSB7XG4gICAgICBpZiAoc3JjLmluZGV4T2YgJiYgIWZpbmRCeUtleSkge1xuICAgICAgICAgIHJldHVybiBzcmMuaW5kZXhPZihmaW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgIHdoaWxlIChpIDwgc3JjLmxlbmd0aCkge1xuICAgICAgICAgICAgICBpZiAoKGZpbmRCeUtleSAmJiBzcmNbaV1bZmluZEJ5S2V5XSA9PSBmaW5kKSB8fCAoIWZpbmRCeUtleSAmJiBzcmNbaV0gPT09IGZpbmQpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBjb252ZXJ0IGFycmF5LWxpa2Ugb2JqZWN0cyB0byByZWFsIGFycmF5c1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICovXG4gIGZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob2JqLCAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiB1bmlxdWUgYXJyYXkgd2l0aCBvYmplY3RzIGJhc2VkIG9uIGEga2V5IChsaWtlICdpZCcpIG9yIGp1c3QgYnkgdGhlIGFycmF5J3MgdmFsdWVcbiAgICogQHBhcmFtIHtBcnJheX0gc3JjIFt7aWQ6MX0se2lkOjJ9LHtpZDoxfV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtrZXldXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NvcnQ9RmFsc2VdXG4gICAqIEByZXR1cm5zIHtBcnJheX0gW3tpZDoxfSx7aWQ6Mn1dXG4gICAqL1xuICBmdW5jdGlvbiB1bmlxdWVBcnJheShzcmMsIGtleSwgc29ydCkge1xuICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgd2hpbGUgKGkgPCBzcmMubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHZhbCA9IGtleSA/IHNyY1tpXVtrZXldIDogc3JjW2ldO1xuICAgICAgICAgIGlmIChpbkFycmF5KHZhbHVlcywgdmFsKSA8IDApIHtcbiAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHNyY1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlc1tpXSA9IHZhbDtcbiAgICAgICAgICBpKys7XG4gICAgICB9XG5cbiAgICAgIGlmIChzb3J0KSB7XG4gICAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuc29ydCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLnNvcnQoZnVuY3Rpb24gc29ydFVuaXF1ZUFycmF5KGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBhW2tleV0gPiBiW2tleV07XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICAvKipcbiAgICogZ2V0IHRoZSBwcmVmaXhlZCBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcmV0dXJucyB7U3RyaW5nfFVuZGVmaW5lZH0gcHJlZml4ZWRcbiAgICovXG4gIGZ1bmN0aW9uIHByZWZpeGVkKG9iaiwgcHJvcGVydHkpIHtcbiAgICAgIHZhciBwcmVmaXgsIHByb3A7XG4gICAgICB2YXIgY2FtZWxQcm9wID0gcHJvcGVydHlbMF0udG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnNsaWNlKDEpO1xuXG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB3aGlsZSAoaSA8IFZFTkRPUl9QUkVGSVhFUy5sZW5ndGgpIHtcbiAgICAgICAgICBwcmVmaXggPSBWRU5ET1JfUFJFRklYRVNbaV07XG4gICAgICAgICAgcHJvcCA9IChwcmVmaXgpID8gcHJlZml4ICsgY2FtZWxQcm9wIDogcHJvcGVydHk7XG5cbiAgICAgICAgICBpZiAocHJvcCBpbiBvYmopIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb3A7XG4gICAgICAgICAgfVxuICAgICAgICAgIGkrKztcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogZ2V0IGEgdW5pcXVlIGlkXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IHVuaXF1ZUlkXG4gICAqL1xuICB2YXIgX3VuaXF1ZUlkID0gMTtcbiAgZnVuY3Rpb24gdW5pcXVlSWQoKSB7XG4gICAgICByZXR1cm4gX3VuaXF1ZUlkKys7XG4gIH1cblxuICAvKipcbiAgICogZ2V0IHRoZSB3aW5kb3cgb2JqZWN0IG9mIGFuIGVsZW1lbnRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcmV0dXJucyB7RG9jdW1lbnRWaWV3fFdpbmRvd31cbiAgICovXG4gIGZ1bmN0aW9uIGdldFdpbmRvd0ZvckVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgdmFyIGRvYyA9IGVsZW1lbnQub3duZXJEb2N1bWVudCB8fCBlbGVtZW50O1xuICAgICAgcmV0dXJuIChkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cpO1xuICB9XG5cbiAgdmFyIE1PQklMRV9SRUdFWCA9IC9tb2JpbGV8dGFibGV0fGlwKGFkfGhvbmV8b2QpfGFuZHJvaWQvaTtcblxuICB2YXIgU1VQUE9SVF9UT1VDSCA9ICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpO1xuICB2YXIgU1VQUE9SVF9QT0lOVEVSX0VWRU5UUyA9IHByZWZpeGVkKHdpbmRvdywgJ1BvaW50ZXJFdmVudCcpICE9PSB1bmRlZmluZWQ7XG4gIHZhciBTVVBQT1JUX09OTFlfVE9VQ0ggPSBTVVBQT1JUX1RPVUNIICYmIE1PQklMRV9SRUdFWC50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4gIHZhciBJTlBVVF9UWVBFX1RPVUNIID0gJ3RvdWNoJztcbiAgdmFyIElOUFVUX1RZUEVfUEVOID0gJ3Blbic7XG4gIHZhciBJTlBVVF9UWVBFX01PVVNFID0gJ21vdXNlJztcbiAgdmFyIElOUFVUX1RZUEVfS0lORUNUID0gJ2tpbmVjdCc7XG5cbiAgdmFyIENPTVBVVEVfSU5URVJWQUwgPSAyNTtcblxuICB2YXIgSU5QVVRfU1RBUlQgPSAxO1xuICB2YXIgSU5QVVRfTU9WRSA9IDI7XG4gIHZhciBJTlBVVF9FTkQgPSA0O1xuICB2YXIgSU5QVVRfQ0FOQ0VMID0gODtcblxuICB2YXIgRElSRUNUSU9OX05PTkUgPSAxO1xuICB2YXIgRElSRUNUSU9OX0xFRlQgPSAyO1xuICB2YXIgRElSRUNUSU9OX1JJR0hUID0gNDtcbiAgdmFyIERJUkVDVElPTl9VUCA9IDg7XG4gIHZhciBESVJFQ1RJT05fRE9XTiA9IDE2O1xuXG4gIHZhciBESVJFQ1RJT05fSE9SSVpPTlRBTCA9IERJUkVDVElPTl9MRUZUIHwgRElSRUNUSU9OX1JJR0hUO1xuICB2YXIgRElSRUNUSU9OX1ZFUlRJQ0FMID0gRElSRUNUSU9OX1VQIHwgRElSRUNUSU9OX0RPV047XG4gIHZhciBESVJFQ1RJT05fQUxMID0gRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUw7XG5cbiAgdmFyIFBST1BTX1hZID0gWyd4JywgJ3knXTtcbiAgdmFyIFBST1BTX0NMSUVOVF9YWSA9IFsnY2xpZW50WCcsICdjbGllbnRZJ107XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBuZXcgaW5wdXQgdHlwZSBtYW5hZ2VyXG4gICAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7SW5wdXR9XG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gSW5wdXQobWFuYWdlciwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XG4gICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICB0aGlzLmVsZW1lbnQgPSBtYW5hZ2VyLmVsZW1lbnQ7XG4gICAgICB0aGlzLnRhcmdldCA9IG1hbmFnZXIub3B0aW9ucy5pbnB1dFRhcmdldDtcblxuICAgICAgLy8gc21hbGxlciB3cmFwcGVyIGFyb3VuZCB0aGUgaGFuZGxlciwgZm9yIHRoZSBzY29wZSBhbmQgdGhlIGVuYWJsZWQgc3RhdGUgb2YgdGhlIG1hbmFnZXIsXG4gICAgICAvLyBzbyB3aGVuIGRpc2FibGVkIHRoZSBpbnB1dCBldmVudHMgYXJlIGNvbXBsZXRlbHkgYnlwYXNzZWQuXG4gICAgICB0aGlzLmRvbUhhbmRsZXIgPSBmdW5jdGlvbihldikge1xuICAgICAgICAgIGlmIChib29sT3JGbihtYW5hZ2VyLm9wdGlvbnMuZW5hYmxlLCBbbWFuYWdlcl0pKSB7XG4gICAgICAgICAgICAgIHNlbGYuaGFuZGxlcihldik7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5pbml0KCk7XG5cbiAgfVxuXG4gIElucHV0LnByb3RvdHlwZSA9IHtcbiAgICAgIC8qKlxuICAgICAgICogc2hvdWxkIGhhbmRsZSB0aGUgaW5wdXRFdmVudCBkYXRhIGFuZCB0cmlnZ2VyIHRoZSBjYWxsYmFja1xuICAgICAgICogQHZpcnR1YWxcbiAgICAgICAqL1xuICAgICAgaGFuZGxlcjogZnVuY3Rpb24oKSB7IH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogYmluZCB0aGUgZXZlbnRzXG4gICAgICAgKi9cbiAgICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuZXZFbCAmJiBhZGRFdmVudExpc3RlbmVycyh0aGlzLmVsZW1lbnQsIHRoaXMuZXZFbCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgICAgICB0aGlzLmV2VGFyZ2V0ICYmIGFkZEV2ZW50TGlzdGVuZXJzKHRoaXMudGFyZ2V0LCB0aGlzLmV2VGFyZ2V0LCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgICAgIHRoaXMuZXZXaW4gJiYgYWRkRXZlbnRMaXN0ZW5lcnMoZ2V0V2luZG93Rm9yRWxlbWVudCh0aGlzLmVsZW1lbnQpLCB0aGlzLmV2V2luLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiB1bmJpbmQgdGhlIGV2ZW50c1xuICAgICAgICovXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLmV2RWwgJiYgcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGhpcy5lbGVtZW50LCB0aGlzLmV2RWwsIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgICAgICAgdGhpcy5ldlRhcmdldCAmJiByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLnRhcmdldCwgdGhpcy5ldlRhcmdldCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgICAgICB0aGlzLmV2V2luICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKGdldFdpbmRvd0ZvckVsZW1lbnQodGhpcy5lbGVtZW50KSwgdGhpcy5ldldpbiwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogY3JlYXRlIG5ldyBpbnB1dCB0eXBlIG1hbmFnZXJcbiAgICogY2FsbGVkIGJ5IHRoZSBNYW5hZ2VyIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7SGFtbWVyfSBtYW5hZ2VyXG4gICAqIEByZXR1cm5zIHtJbnB1dH1cbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUlucHV0SW5zdGFuY2UobWFuYWdlcikge1xuICAgICAgdmFyIFR5cGU7XG4gICAgICB2YXIgaW5wdXRDbGFzcyA9IG1hbmFnZXIub3B0aW9ucy5pbnB1dENsYXNzO1xuXG4gICAgICBpZiAoaW5wdXRDbGFzcykge1xuICAgICAgICAgIFR5cGUgPSBpbnB1dENsYXNzO1xuICAgICAgfSBlbHNlIGlmIChTVVBQT1JUX1BPSU5URVJfRVZFTlRTKSB7XG4gICAgICAgICAgVHlwZSA9IFBvaW50ZXJFdmVudElucHV0O1xuICAgICAgfSBlbHNlIGlmIChTVVBQT1JUX09OTFlfVE9VQ0gpIHtcbiAgICAgICAgICBUeXBlID0gVG91Y2hJbnB1dDtcbiAgICAgIH0gZWxzZSBpZiAoIVNVUFBPUlRfVE9VQ0gpIHtcbiAgICAgICAgICBUeXBlID0gTW91c2VJbnB1dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgVHlwZSA9IFRvdWNoTW91c2VJbnB1dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgKFR5cGUpKG1hbmFnZXIsIGlucHV0SGFuZGxlcik7XG4gIH1cblxuICAvKipcbiAgICogaGFuZGxlIGlucHV0IGV2ZW50c1xuICAgKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZVxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICovXG4gIGZ1bmN0aW9uIGlucHV0SGFuZGxlcihtYW5hZ2VyLCBldmVudFR5cGUsIGlucHV0KSB7XG4gICAgICB2YXIgcG9pbnRlcnNMZW4gPSBpbnB1dC5wb2ludGVycy5sZW5ndGg7XG4gICAgICB2YXIgY2hhbmdlZFBvaW50ZXJzTGVuID0gaW5wdXQuY2hhbmdlZFBvaW50ZXJzLmxlbmd0aDtcbiAgICAgIHZhciBpc0ZpcnN0ID0gKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIChwb2ludGVyc0xlbiAtIGNoYW5nZWRQb2ludGVyc0xlbiA9PT0gMCkpO1xuICAgICAgdmFyIGlzRmluYWwgPSAoZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkgJiYgKHBvaW50ZXJzTGVuIC0gY2hhbmdlZFBvaW50ZXJzTGVuID09PSAwKSk7XG5cbiAgICAgIGlucHV0LmlzRmlyc3QgPSAhIWlzRmlyc3Q7XG4gICAgICBpbnB1dC5pc0ZpbmFsID0gISFpc0ZpbmFsO1xuXG4gICAgICBpZiAoaXNGaXJzdCkge1xuICAgICAgICAgIG1hbmFnZXIuc2Vzc2lvbiA9IHt9O1xuICAgICAgfVxuXG4gICAgICAvLyBzb3VyY2UgZXZlbnQgaXMgdGhlIG5vcm1hbGl6ZWQgdmFsdWUgb2YgdGhlIGRvbUV2ZW50c1xuICAgICAgLy8gbGlrZSAndG91Y2hzdGFydCwgbW91c2V1cCwgcG9pbnRlcmRvd24nXG4gICAgICBpbnB1dC5ldmVudFR5cGUgPSBldmVudFR5cGU7XG5cbiAgICAgIC8vIGNvbXB1dGUgc2NhbGUsIHJvdGF0aW9uIGV0Y1xuICAgICAgY29tcHV0ZUlucHV0RGF0YShtYW5hZ2VyLCBpbnB1dCk7XG5cbiAgICAgIC8vIGVtaXQgc2VjcmV0IGV2ZW50XG4gICAgICBtYW5hZ2VyLmVtaXQoJ2hhbW1lci5pbnB1dCcsIGlucHV0KTtcblxuICAgICAgbWFuYWdlci5yZWNvZ25pemUoaW5wdXQpO1xuICAgICAgbWFuYWdlci5zZXNzaW9uLnByZXZJbnB1dCA9IGlucHV0O1xuICB9XG5cbiAgLyoqXG4gICAqIGV4dGVuZCB0aGUgZGF0YSB3aXRoIHNvbWUgdXNhYmxlIHByb3BlcnRpZXMgbGlrZSBzY2FsZSwgcm90YXRlLCB2ZWxvY2l0eSBldGNcbiAgICogQHBhcmFtIHtPYmplY3R9IG1hbmFnZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAqL1xuICBmdW5jdGlvbiBjb21wdXRlSW5wdXREYXRhKG1hbmFnZXIsIGlucHV0KSB7XG4gICAgICB2YXIgc2Vzc2lvbiA9IG1hbmFnZXIuc2Vzc2lvbjtcbiAgICAgIHZhciBwb2ludGVycyA9IGlucHV0LnBvaW50ZXJzO1xuICAgICAgdmFyIHBvaW50ZXJzTGVuZ3RoID0gcG9pbnRlcnMubGVuZ3RoO1xuXG4gICAgICAvLyBzdG9yZSB0aGUgZmlyc3QgaW5wdXQgdG8gY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBhbmQgZGlyZWN0aW9uXG4gICAgICBpZiAoIXNlc3Npb24uZmlyc3RJbnB1dCkge1xuICAgICAgICAgIHNlc3Npb24uZmlyc3RJbnB1dCA9IHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KTtcbiAgICAgIH1cblxuICAgICAgLy8gdG8gY29tcHV0ZSBzY2FsZSBhbmQgcm90YXRpb24gd2UgbmVlZCB0byBzdG9yZSB0aGUgbXVsdGlwbGUgdG91Y2hlc1xuICAgICAgaWYgKHBvaW50ZXJzTGVuZ3RoID4gMSAmJiAhc2Vzc2lvbi5maXJzdE11bHRpcGxlKSB7XG4gICAgICAgICAgc2Vzc2lvbi5maXJzdE11bHRpcGxlID0gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpO1xuICAgICAgfSBlbHNlIGlmIChwb2ludGVyc0xlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHNlc3Npb24uZmlyc3RNdWx0aXBsZSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmlyc3RJbnB1dCA9IHNlc3Npb24uZmlyc3RJbnB1dDtcbiAgICAgIHZhciBmaXJzdE11bHRpcGxlID0gc2Vzc2lvbi5maXJzdE11bHRpcGxlO1xuICAgICAgdmFyIG9mZnNldENlbnRlciA9IGZpcnN0TXVsdGlwbGUgPyBmaXJzdE11bHRpcGxlLmNlbnRlciA6IGZpcnN0SW5wdXQuY2VudGVyO1xuXG4gICAgICB2YXIgY2VudGVyID0gaW5wdXQuY2VudGVyID0gZ2V0Q2VudGVyKHBvaW50ZXJzKTtcbiAgICAgIGlucHV0LnRpbWVTdGFtcCA9IG5vdygpO1xuICAgICAgaW5wdXQuZGVsdGFUaW1lID0gaW5wdXQudGltZVN0YW1wIC0gZmlyc3RJbnB1dC50aW1lU3RhbXA7XG5cbiAgICAgIGlucHV0LmFuZ2xlID0gZ2V0QW5nbGUob2Zmc2V0Q2VudGVyLCBjZW50ZXIpO1xuICAgICAgaW5wdXQuZGlzdGFuY2UgPSBnZXREaXN0YW5jZShvZmZzZXRDZW50ZXIsIGNlbnRlcik7XG5cbiAgICAgIGNvbXB1dGVEZWx0YVhZKHNlc3Npb24sIGlucHV0KTtcbiAgICAgIGlucHV0Lm9mZnNldERpcmVjdGlvbiA9IGdldERpcmVjdGlvbihpbnB1dC5kZWx0YVgsIGlucHV0LmRlbHRhWSk7XG5cbiAgICAgIHZhciBvdmVyYWxsVmVsb2NpdHkgPSBnZXRWZWxvY2l0eShpbnB1dC5kZWx0YVRpbWUsIGlucHV0LmRlbHRhWCwgaW5wdXQuZGVsdGFZKTtcbiAgICAgIGlucHV0Lm92ZXJhbGxWZWxvY2l0eVggPSBvdmVyYWxsVmVsb2NpdHkueDtcbiAgICAgIGlucHV0Lm92ZXJhbGxWZWxvY2l0eVkgPSBvdmVyYWxsVmVsb2NpdHkueTtcbiAgICAgIGlucHV0Lm92ZXJhbGxWZWxvY2l0eSA9IChhYnMob3ZlcmFsbFZlbG9jaXR5LngpID4gYWJzKG92ZXJhbGxWZWxvY2l0eS55KSkgPyBvdmVyYWxsVmVsb2NpdHkueCA6IG92ZXJhbGxWZWxvY2l0eS55O1xuXG4gICAgICBpbnB1dC5zY2FsZSA9IGZpcnN0TXVsdGlwbGUgPyBnZXRTY2FsZShmaXJzdE11bHRpcGxlLnBvaW50ZXJzLCBwb2ludGVycykgOiAxO1xuICAgICAgaW5wdXQucm90YXRpb24gPSBmaXJzdE11bHRpcGxlID8gZ2V0Um90YXRpb24oZmlyc3RNdWx0aXBsZS5wb2ludGVycywgcG9pbnRlcnMpIDogMDtcblxuICAgICAgaW5wdXQubWF4UG9pbnRlcnMgPSAhc2Vzc2lvbi5wcmV2SW5wdXQgPyBpbnB1dC5wb2ludGVycy5sZW5ndGggOiAoKGlucHV0LnBvaW50ZXJzLmxlbmd0aCA+XG4gICAgICAgICAgc2Vzc2lvbi5wcmV2SW5wdXQubWF4UG9pbnRlcnMpID8gaW5wdXQucG9pbnRlcnMubGVuZ3RoIDogc2Vzc2lvbi5wcmV2SW5wdXQubWF4UG9pbnRlcnMpO1xuXG4gICAgICBjb21wdXRlSW50ZXJ2YWxJbnB1dERhdGEoc2Vzc2lvbiwgaW5wdXQpO1xuXG4gICAgICAvLyBmaW5kIHRoZSBjb3JyZWN0IHRhcmdldFxuICAgICAgdmFyIHRhcmdldCA9IG1hbmFnZXIuZWxlbWVudDtcbiAgICAgIGlmIChoYXNQYXJlbnQoaW5wdXQuc3JjRXZlbnQudGFyZ2V0LCB0YXJnZXQpKSB7XG4gICAgICAgICAgdGFyZ2V0ID0gaW5wdXQuc3JjRXZlbnQudGFyZ2V0O1xuICAgICAgfVxuICAgICAgaW5wdXQudGFyZ2V0ID0gdGFyZ2V0O1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcHV0ZURlbHRhWFkoc2Vzc2lvbiwgaW5wdXQpIHtcbiAgICAgIHZhciBjZW50ZXIgPSBpbnB1dC5jZW50ZXI7XG4gICAgICB2YXIgb2Zmc2V0ID0gc2Vzc2lvbi5vZmZzZXREZWx0YSB8fCB7fTtcbiAgICAgIHZhciBwcmV2RGVsdGEgPSBzZXNzaW9uLnByZXZEZWx0YSB8fCB7fTtcbiAgICAgIHZhciBwcmV2SW5wdXQgPSBzZXNzaW9uLnByZXZJbnB1dCB8fCB7fTtcblxuICAgICAgaWYgKGlucHV0LmV2ZW50VHlwZSA9PT0gSU5QVVRfU1RBUlQgfHwgcHJldklucHV0LmV2ZW50VHlwZSA9PT0gSU5QVVRfRU5EKSB7XG4gICAgICAgICAgcHJldkRlbHRhID0gc2Vzc2lvbi5wcmV2RGVsdGEgPSB7XG4gICAgICAgICAgICAgIHg6IHByZXZJbnB1dC5kZWx0YVggfHwgMCxcbiAgICAgICAgICAgICAgeTogcHJldklucHV0LmRlbHRhWSB8fCAwXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIG9mZnNldCA9IHNlc3Npb24ub2Zmc2V0RGVsdGEgPSB7XG4gICAgICAgICAgICAgIHg6IGNlbnRlci54LFxuICAgICAgICAgICAgICB5OiBjZW50ZXIueVxuICAgICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlucHV0LmRlbHRhWCA9IHByZXZEZWx0YS54ICsgKGNlbnRlci54IC0gb2Zmc2V0LngpO1xuICAgICAgaW5wdXQuZGVsdGFZID0gcHJldkRlbHRhLnkgKyAoY2VudGVyLnkgLSBvZmZzZXQueSk7XG4gIH1cblxuICAvKipcbiAgICogdmVsb2NpdHkgaXMgY2FsY3VsYXRlZCBldmVyeSB4IG1zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXNzaW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgKi9cbiAgZnVuY3Rpb24gY29tcHV0ZUludGVydmFsSW5wdXREYXRhKHNlc3Npb24sIGlucHV0KSB7XG4gICAgICB2YXIgbGFzdCA9IHNlc3Npb24ubGFzdEludGVydmFsIHx8IGlucHV0LFxuICAgICAgICAgIGRlbHRhVGltZSA9IGlucHV0LnRpbWVTdGFtcCAtIGxhc3QudGltZVN0YW1wLFxuICAgICAgICAgIHZlbG9jaXR5LCB2ZWxvY2l0eVgsIHZlbG9jaXR5WSwgZGlyZWN0aW9uO1xuXG4gICAgICBpZiAoaW5wdXQuZXZlbnRUeXBlICE9IElOUFVUX0NBTkNFTCAmJiAoZGVsdGFUaW1lID4gQ09NUFVURV9JTlRFUlZBTCB8fCBsYXN0LnZlbG9jaXR5ID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgdmFyIGRlbHRhWCA9IGlucHV0LmRlbHRhWCAtIGxhc3QuZGVsdGFYO1xuICAgICAgICAgIHZhciBkZWx0YVkgPSBpbnB1dC5kZWx0YVkgLSBsYXN0LmRlbHRhWTtcblxuICAgICAgICAgIHZhciB2ID0gZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCBkZWx0YVgsIGRlbHRhWSk7XG4gICAgICAgICAgdmVsb2NpdHlYID0gdi54O1xuICAgICAgICAgIHZlbG9jaXR5WSA9IHYueTtcbiAgICAgICAgICB2ZWxvY2l0eSA9IChhYnModi54KSA+IGFicyh2LnkpKSA/IHYueCA6IHYueTtcbiAgICAgICAgICBkaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24oZGVsdGFYLCBkZWx0YVkpO1xuXG4gICAgICAgICAgc2Vzc2lvbi5sYXN0SW50ZXJ2YWwgPSBpbnB1dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdXNlIGxhdGVzdCB2ZWxvY2l0eSBpbmZvIGlmIGl0IGRvZXNuJ3Qgb3ZlcnRha2UgYSBtaW5pbXVtIHBlcmlvZFxuICAgICAgICAgIHZlbG9jaXR5ID0gbGFzdC52ZWxvY2l0eTtcbiAgICAgICAgICB2ZWxvY2l0eVggPSBsYXN0LnZlbG9jaXR5WDtcbiAgICAgICAgICB2ZWxvY2l0eVkgPSBsYXN0LnZlbG9jaXR5WTtcbiAgICAgICAgICBkaXJlY3Rpb24gPSBsYXN0LmRpcmVjdGlvbjtcbiAgICAgIH1cblxuICAgICAgaW5wdXQudmVsb2NpdHkgPSB2ZWxvY2l0eTtcbiAgICAgIGlucHV0LnZlbG9jaXR5WCA9IHZlbG9jaXR5WDtcbiAgICAgIGlucHV0LnZlbG9jaXR5WSA9IHZlbG9jaXR5WTtcbiAgICAgIGlucHV0LmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBjcmVhdGUgYSBzaW1wbGUgY2xvbmUgZnJvbSB0aGUgaW5wdXQgdXNlZCBmb3Igc3RvcmFnZSBvZiBmaXJzdElucHV0IGFuZCBmaXJzdE11bHRpcGxlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBjbG9uZWRJbnB1dERhdGFcbiAgICovXG4gIGZ1bmN0aW9uIHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KSB7XG4gICAgICAvLyBtYWtlIGEgc2ltcGxlIGNvcHkgb2YgdGhlIHBvaW50ZXJzIGJlY2F1c2Ugd2Ugd2lsbCBnZXQgYSByZWZlcmVuY2UgaWYgd2UgZG9uJ3RcbiAgICAgIC8vIHdlIG9ubHkgbmVlZCBjbGllbnRYWSBmb3IgdGhlIGNhbGN1bGF0aW9uc1xuICAgICAgdmFyIHBvaW50ZXJzID0gW107XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB3aGlsZSAoaSA8IGlucHV0LnBvaW50ZXJzLmxlbmd0aCkge1xuICAgICAgICAgIHBvaW50ZXJzW2ldID0ge1xuICAgICAgICAgICAgICBjbGllbnRYOiByb3VuZChpbnB1dC5wb2ludGVyc1tpXS5jbGllbnRYKSxcbiAgICAgICAgICAgICAgY2xpZW50WTogcm91bmQoaW5wdXQucG9pbnRlcnNbaV0uY2xpZW50WSlcbiAgICAgICAgICB9O1xuICAgICAgICAgIGkrKztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0aW1lU3RhbXA6IG5vdygpLFxuICAgICAgICAgIHBvaW50ZXJzOiBwb2ludGVycyxcbiAgICAgICAgICBjZW50ZXI6IGdldENlbnRlcihwb2ludGVycyksXG4gICAgICAgICAgZGVsdGFYOiBpbnB1dC5kZWx0YVgsXG4gICAgICAgICAgZGVsdGFZOiBpbnB1dC5kZWx0YVlcbiAgICAgIH07XG4gIH1cblxuICAvKipcbiAgICogZ2V0IHRoZSBjZW50ZXIgb2YgYWxsIHRoZSBwb2ludGVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludGVyc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9IGNlbnRlciBjb250YWlucyBgeGAgYW5kIGB5YCBwcm9wZXJ0aWVzXG4gICAqL1xuICBmdW5jdGlvbiBnZXRDZW50ZXIocG9pbnRlcnMpIHtcbiAgICAgIHZhciBwb2ludGVyc0xlbmd0aCA9IHBvaW50ZXJzLmxlbmd0aDtcblxuICAgICAgLy8gbm8gbmVlZCB0byBsb29wIHdoZW4gb25seSBvbmUgdG91Y2hcbiAgICAgIGlmIChwb2ludGVyc0xlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHg6IHJvdW5kKHBvaW50ZXJzWzBdLmNsaWVudFgpLFxuICAgICAgICAgICAgICB5OiByb3VuZChwb2ludGVyc1swXS5jbGllbnRZKVxuICAgICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciB4ID0gMCwgeSA9IDAsIGkgPSAwO1xuICAgICAgd2hpbGUgKGkgPCBwb2ludGVyc0xlbmd0aCkge1xuICAgICAgICAgIHggKz0gcG9pbnRlcnNbaV0uY2xpZW50WDtcbiAgICAgICAgICB5ICs9IHBvaW50ZXJzW2ldLmNsaWVudFk7XG4gICAgICAgICAgaSsrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHJvdW5kKHggLyBwb2ludGVyc0xlbmd0aCksXG4gICAgICAgICAgeTogcm91bmQoeSAvIHBvaW50ZXJzTGVuZ3RoKVxuICAgICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdGhlIHZlbG9jaXR5IGJldHdlZW4gdHdvIHBvaW50cy4gdW5pdCBpcyBpbiBweCBwZXIgbXMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVRpbWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICogQHJldHVybiB7T2JqZWN0fSB2ZWxvY2l0eSBgeGAgYW5kIGB5YFxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCB4LCB5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHggLyBkZWx0YVRpbWUgfHwgMCxcbiAgICAgICAgICB5OiB5IC8gZGVsdGFUaW1lIHx8IDBcbiAgICAgIH07XG4gIH1cblxuICAvKipcbiAgICogZ2V0IHRoZSBkaXJlY3Rpb24gYmV0d2VlbiB0d28gcG9pbnRzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAqIEByZXR1cm4ge051bWJlcn0gZGlyZWN0aW9uXG4gICAqL1xuICBmdW5jdGlvbiBnZXREaXJlY3Rpb24oeCwgeSkge1xuICAgICAgaWYgKHggPT09IHkpIHtcbiAgICAgICAgICByZXR1cm4gRElSRUNUSU9OX05PTkU7XG4gICAgICB9XG5cbiAgICAgIGlmIChhYnMoeCkgPj0gYWJzKHkpKSB7XG4gICAgICAgICAgcmV0dXJuIHggPCAwID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XG4gICAgICB9XG4gICAgICByZXR1cm4geSA8IDAgPyBESVJFQ1RJT05fVVAgOiBESVJFQ1RJT05fRE9XTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdGhlIGFic29sdXRlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuICAgKiBAcGFyYW0ge09iamVjdH0gcDEge3gsIHl9XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwMiB7eCwgeX1cbiAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BzXSBjb250YWluaW5nIHggYW5kIHkga2V5c1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGRpc3RhbmNlXG4gICAqL1xuICBmdW5jdGlvbiBnZXREaXN0YW5jZShwMSwgcDIsIHByb3BzKSB7XG4gICAgICBpZiAoIXByb3BzKSB7XG4gICAgICAgICAgcHJvcHMgPSBQUk9QU19YWTtcbiAgICAgIH1cbiAgICAgIHZhciB4ID0gcDJbcHJvcHNbMF1dIC0gcDFbcHJvcHNbMF1dLFxuICAgICAgICAgIHkgPSBwMltwcm9wc1sxXV0gLSBwMVtwcm9wc1sxXV07XG5cbiAgICAgIHJldHVybiBNYXRoLnNxcnQoKHggKiB4KSArICh5ICogeSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB0aGUgYW5nbGUgYmV0d2VlbiB0d28gY29vcmRpbmF0ZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IHAxXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwMlxuICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcHNdIGNvbnRhaW5pbmcgeCBhbmQgeSBrZXlzXG4gICAqIEByZXR1cm4ge051bWJlcn0gYW5nbGVcbiAgICovXG4gIGZ1bmN0aW9uIGdldEFuZ2xlKHAxLCBwMiwgcHJvcHMpIHtcbiAgICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgICBwcm9wcyA9IFBST1BTX1hZO1xuICAgICAgfVxuICAgICAgdmFyIHggPSBwMltwcm9wc1swXV0gLSBwMVtwcm9wc1swXV0sXG4gICAgICAgICAgeSA9IHAyW3Byb3BzWzFdXSAtIHAxW3Byb3BzWzFdXTtcbiAgICAgIHJldHVybiBNYXRoLmF0YW4yKHksIHgpICogMTgwIC8gTWF0aC5QSTtcbiAgfVxuXG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdGhlIHJvdGF0aW9uIGRlZ3JlZXMgYmV0d2VlbiB0d28gcG9pbnRlcnNldHNcbiAgICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgcG9pbnRlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gZW5kIGFycmF5IG9mIHBvaW50ZXJzXG4gICAqIEByZXR1cm4ge051bWJlcn0gcm90YXRpb25cbiAgICovXG4gIGZ1bmN0aW9uIGdldFJvdGF0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHJldHVybiBnZXRBbmdsZShlbmRbMV0sIGVuZFswXSwgUFJPUFNfQ0xJRU5UX1hZKSArIGdldEFuZ2xlKHN0YXJ0WzFdLCBzdGFydFswXSwgUFJPUFNfQ0xJRU5UX1hZKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdGhlIHNjYWxlIGZhY3RvciBiZXR3ZWVuIHR3byBwb2ludGVyc2V0c1xuICAgKiBubyBzY2FsZSBpcyAxLCBhbmQgZ29lcyBkb3duIHRvIDAgd2hlbiBwaW5jaGVkIHRvZ2V0aGVyLCBhbmQgYmlnZ2VyIHdoZW4gcGluY2hlZCBvdXRcbiAgICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgcG9pbnRlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gZW5kIGFycmF5IG9mIHBvaW50ZXJzXG4gICAqIEByZXR1cm4ge051bWJlcn0gc2NhbGVcbiAgICovXG4gIGZ1bmN0aW9uIGdldFNjYWxlKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHJldHVybiBnZXREaXN0YW5jZShlbmRbMF0sIGVuZFsxXSwgUFJPUFNfQ0xJRU5UX1hZKSAvIGdldERpc3RhbmNlKHN0YXJ0WzBdLCBzdGFydFsxXSwgUFJPUFNfQ0xJRU5UX1hZKTtcbiAgfVxuXG4gIHZhciBNT1VTRV9JTlBVVF9NQVAgPSB7XG4gICAgICBtb3VzZWRvd246IElOUFVUX1NUQVJULFxuICAgICAgbW91c2Vtb3ZlOiBJTlBVVF9NT1ZFLFxuICAgICAgbW91c2V1cDogSU5QVVRfRU5EXG4gIH07XG5cbiAgdmFyIE1PVVNFX0VMRU1FTlRfRVZFTlRTID0gJ21vdXNlZG93bic7XG4gIHZhciBNT1VTRV9XSU5ET1dfRVZFTlRTID0gJ21vdXNlbW92ZSBtb3VzZXVwJztcblxuICAvKipcbiAgICogTW91c2UgZXZlbnRzIGlucHV0XG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyBJbnB1dFxuICAgKi9cbiAgZnVuY3Rpb24gTW91c2VJbnB1dCgpIHtcbiAgICAgIHRoaXMuZXZFbCA9IE1PVVNFX0VMRU1FTlRfRVZFTlRTO1xuICAgICAgdGhpcy5ldldpbiA9IE1PVVNFX1dJTkRPV19FVkVOVFM7XG5cbiAgICAgIHRoaXMuYWxsb3cgPSB0cnVlOyAvLyB1c2VkIGJ5IElucHV0LlRvdWNoTW91c2UgdG8gZGlzYWJsZSBtb3VzZSBldmVudHNcbiAgICAgIHRoaXMucHJlc3NlZCA9IGZhbHNlOyAvLyBtb3VzZWRvd24gc3RhdGVcblxuICAgICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGluaGVyaXQoTW91c2VJbnB1dCwgSW5wdXQsIHtcbiAgICAgIC8qKlxuICAgICAgICogaGFuZGxlIG1vdXNlIGV2ZW50c1xuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAgICAgKi9cbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIE1FaGFuZGxlcihldikge1xuICAgICAgICAgIHZhciBldmVudFR5cGUgPSBNT1VTRV9JTlBVVF9NQVBbZXYudHlwZV07XG5cbiAgICAgICAgICAvLyBvbiBzdGFydCB3ZSB3YW50IHRvIGhhdmUgdGhlIGxlZnQgbW91c2UgYnV0dG9uIGRvd25cbiAgICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgZXYuYnV0dG9uID09PSAwKSB7XG4gICAgICAgICAgICAgIHRoaXMucHJlc3NlZCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX01PVkUgJiYgZXYud2hpY2ggIT09IDEpIHtcbiAgICAgICAgICAgICAgZXZlbnRUeXBlID0gSU5QVVRfRU5EO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIG1vdXNlIG11c3QgYmUgZG93biwgYW5kIG1vdXNlIGV2ZW50cyBhcmUgYWxsb3dlZCAoc2VlIHRoZSBUb3VjaE1vdXNlIGlucHV0KVxuICAgICAgICAgIGlmICghdGhpcy5wcmVzc2VkIHx8ICF0aGlzLmFsbG93KSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XG4gICAgICAgICAgICAgIHRoaXMucHJlc3NlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCBldmVudFR5cGUsIHtcbiAgICAgICAgICAgICAgcG9pbnRlcnM6IFtldl0sXG4gICAgICAgICAgICAgIGNoYW5nZWRQb2ludGVyczogW2V2XSxcbiAgICAgICAgICAgICAgcG9pbnRlclR5cGU6IElOUFVUX1RZUEVfTU9VU0UsXG4gICAgICAgICAgICAgIHNyY0V2ZW50OiBldlxuICAgICAgICAgIH0pO1xuICAgICAgfVxuICB9KTtcblxuICB2YXIgUE9JTlRFUl9JTlBVVF9NQVAgPSB7XG4gICAgICBwb2ludGVyZG93bjogSU5QVVRfU1RBUlQsXG4gICAgICBwb2ludGVybW92ZTogSU5QVVRfTU9WRSxcbiAgICAgIHBvaW50ZXJ1cDogSU5QVVRfRU5ELFxuICAgICAgcG9pbnRlcmNhbmNlbDogSU5QVVRfQ0FOQ0VMLFxuICAgICAgcG9pbnRlcm91dDogSU5QVVRfQ0FOQ0VMXG4gIH07XG5cbiAgLy8gaW4gSUUxMCB0aGUgcG9pbnRlciB0eXBlcyBpcyBkZWZpbmVkIGFzIGFuIGVudW1cbiAgdmFyIElFMTBfUE9JTlRFUl9UWVBFX0VOVU0gPSB7XG4gICAgICAyOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgICAgMzogSU5QVVRfVFlQRV9QRU4sXG4gICAgICA0OiBJTlBVVF9UWVBFX01PVVNFLFxuICAgICAgNTogSU5QVVRfVFlQRV9LSU5FQ1QgLy8gc2VlIGh0dHBzOi8vdHdpdHRlci5jb20vamFjb2Jyb3NzaS9zdGF0dXMvNDgwNTk2NDM4NDg5ODkwODE2XG4gIH07XG5cbiAgdmFyIFBPSU5URVJfRUxFTUVOVF9FVkVOVFMgPSAncG9pbnRlcmRvd24nO1xuICB2YXIgUE9JTlRFUl9XSU5ET1dfRVZFTlRTID0gJ3BvaW50ZXJtb3ZlIHBvaW50ZXJ1cCBwb2ludGVyY2FuY2VsJztcblxuICAvLyBJRTEwIGhhcyBwcmVmaXhlZCBzdXBwb3J0LCBhbmQgY2FzZS1zZW5zaXRpdmVcbiAgaWYgKHdpbmRvdy5NU1BvaW50ZXJFdmVudCAmJiAhd2luZG93LlBvaW50ZXJFdmVudCkge1xuICAgICAgUE9JTlRFUl9FTEVNRU5UX0VWRU5UUyA9ICdNU1BvaW50ZXJEb3duJztcbiAgICAgIFBPSU5URVJfV0lORE9XX0VWRU5UUyA9ICdNU1BvaW50ZXJNb3ZlIE1TUG9pbnRlclVwIE1TUG9pbnRlckNhbmNlbCc7XG4gIH1cblxuICAvKipcbiAgICogUG9pbnRlciBldmVudHMgaW5wdXRcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIElucHV0XG4gICAqL1xuICBmdW5jdGlvbiBQb2ludGVyRXZlbnRJbnB1dCgpIHtcbiAgICAgIHRoaXMuZXZFbCA9IFBPSU5URVJfRUxFTUVOVF9FVkVOVFM7XG4gICAgICB0aGlzLmV2V2luID0gUE9JTlRFUl9XSU5ET1dfRVZFTlRTO1xuXG4gICAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICB0aGlzLnN0b3JlID0gKHRoaXMubWFuYWdlci5zZXNzaW9uLnBvaW50ZXJFdmVudHMgPSBbXSk7XG4gIH1cblxuICBpbmhlcml0KFBvaW50ZXJFdmVudElucHV0LCBJbnB1dCwge1xuICAgICAgLyoqXG4gICAgICAgKiBoYW5kbGUgbW91c2UgZXZlbnRzXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICAgICAqL1xuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gUEVoYW5kbGVyKGV2KSB7XG4gICAgICAgICAgdmFyIHN0b3JlID0gdGhpcy5zdG9yZTtcbiAgICAgICAgICB2YXIgcmVtb3ZlUG9pbnRlciA9IGZhbHNlO1xuXG4gICAgICAgICAgdmFyIGV2ZW50VHlwZU5vcm1hbGl6ZWQgPSBldi50eXBlLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnbXMnLCAnJyk7XG4gICAgICAgICAgdmFyIGV2ZW50VHlwZSA9IFBPSU5URVJfSU5QVVRfTUFQW2V2ZW50VHlwZU5vcm1hbGl6ZWRdO1xuICAgICAgICAgIHZhciBwb2ludGVyVHlwZSA9IElFMTBfUE9JTlRFUl9UWVBFX0VOVU1bZXYucG9pbnRlclR5cGVdIHx8IGV2LnBvaW50ZXJUeXBlO1xuXG4gICAgICAgICAgdmFyIGlzVG91Y2ggPSAocG9pbnRlclR5cGUgPT0gSU5QVVRfVFlQRV9UT1VDSCk7XG5cbiAgICAgICAgICAvLyBnZXQgaW5kZXggb2YgdGhlIGV2ZW50IGluIHRoZSBzdG9yZVxuICAgICAgICAgIHZhciBzdG9yZUluZGV4ID0gaW5BcnJheShzdG9yZSwgZXYucG9pbnRlcklkLCAncG9pbnRlcklkJyk7XG5cbiAgICAgICAgICAvLyBzdGFydCBhbmQgbW91c2UgbXVzdCBiZSBkb3duXG4gICAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIChldi5idXR0b24gPT09IDAgfHwgaXNUb3VjaCkpIHtcbiAgICAgICAgICAgICAgaWYgKHN0b3JlSW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgICBzdG9yZS5wdXNoKGV2KTtcbiAgICAgICAgICAgICAgICAgIHN0b3JlSW5kZXggPSBzdG9yZS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgICAgICAgICByZW1vdmVQb2ludGVyID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBpdCBub3QgZm91bmQsIHNvIHRoZSBwb2ludGVyIGhhc24ndCBiZWVuIGRvd24gKHNvIGl0J3MgcHJvYmFibHkgYSBob3ZlcilcbiAgICAgICAgICBpZiAoc3RvcmVJbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgZXZlbnQgaW4gdGhlIHN0b3JlXG4gICAgICAgICAgc3RvcmVbc3RvcmVJbmRleF0gPSBldjtcblxuICAgICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCBldmVudFR5cGUsIHtcbiAgICAgICAgICAgICAgcG9pbnRlcnM6IHN0b3JlLFxuICAgICAgICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IFtldl0sXG4gICAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBwb2ludGVyVHlwZSxcbiAgICAgICAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAocmVtb3ZlUG9pbnRlcikge1xuICAgICAgICAgICAgICAvLyByZW1vdmUgZnJvbSB0aGUgc3RvcmVcbiAgICAgICAgICAgICAgc3RvcmUuc3BsaWNlKHN0b3JlSW5kZXgsIDEpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgfSk7XG5cbiAgdmFyIFNJTkdMRV9UT1VDSF9JTlBVVF9NQVAgPSB7XG4gICAgICB0b3VjaHN0YXJ0OiBJTlBVVF9TVEFSVCxcbiAgICAgIHRvdWNobW92ZTogSU5QVVRfTU9WRSxcbiAgICAgIHRvdWNoZW5kOiBJTlBVVF9FTkQsXG4gICAgICB0b3VjaGNhbmNlbDogSU5QVVRfQ0FOQ0VMXG4gIH07XG5cbiAgdmFyIFNJTkdMRV9UT1VDSF9UQVJHRVRfRVZFTlRTID0gJ3RvdWNoc3RhcnQnO1xuICB2YXIgU0lOR0xFX1RPVUNIX1dJTkRPV19FVkVOVFMgPSAndG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWwnO1xuXG4gIC8qKlxuICAgKiBUb3VjaCBldmVudHMgaW5wdXRcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIElucHV0XG4gICAqL1xuICBmdW5jdGlvbiBTaW5nbGVUb3VjaElucHV0KCkge1xuICAgICAgdGhpcy5ldlRhcmdldCA9IFNJTkdMRV9UT1VDSF9UQVJHRVRfRVZFTlRTO1xuICAgICAgdGhpcy5ldldpbiA9IFNJTkdMRV9UT1VDSF9XSU5ET1dfRVZFTlRTO1xuICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG5cbiAgICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBpbmhlcml0KFNpbmdsZVRvdWNoSW5wdXQsIElucHV0LCB7XG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBURWhhbmRsZXIoZXYpIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IFNJTkdMRV9UT1VDSF9JTlBVVF9NQVBbZXYudHlwZV07XG5cbiAgICAgICAgICAvLyBzaG91bGQgd2UgaGFuZGxlIHRoZSB0b3VjaCBldmVudHM/XG4gICAgICAgICAgaWYgKHR5cGUgPT09IElOUFVUX1NUQVJUKSB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB0b3VjaGVzID0gbm9ybWFsaXplU2luZ2xlVG91Y2hlcy5jYWxsKHRoaXMsIGV2LCB0eXBlKTtcblxuICAgICAgICAgIC8vIHdoZW4gZG9uZSwgcmVzZXQgdGhlIHN0YXJ0ZWQgc3RhdGVcbiAgICAgICAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmIHRvdWNoZXNbMF0ubGVuZ3RoIC0gdG91Y2hlc1sxXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIHR5cGUsIHtcbiAgICAgICAgICAgICAgcG9pbnRlcnM6IHRvdWNoZXNbMF0sXG4gICAgICAgICAgICAgIGNoYW5nZWRQb2ludGVyczogdG91Y2hlc1sxXSxcbiAgICAgICAgICAgICAgcG9pbnRlclR5cGU6IElOUFVUX1RZUEVfVE9VQ0gsXG4gICAgICAgICAgICAgIHNyY0V2ZW50OiBldlxuICAgICAgICAgIH0pO1xuICAgICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQHRoaXMge1RvdWNoSW5wdXR9XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKiBAcGFyYW0ge051bWJlcn0gdHlwZSBmbGFnXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR8QXJyYXl9IFthbGwsIGNoYW5nZWRdXG4gICAqL1xuICBmdW5jdGlvbiBub3JtYWxpemVTaW5nbGVUb3VjaGVzKGV2LCB0eXBlKSB7XG4gICAgICB2YXIgYWxsID0gdG9BcnJheShldi50b3VjaGVzKTtcbiAgICAgIHZhciBjaGFuZ2VkID0gdG9BcnJheShldi5jaGFuZ2VkVG91Y2hlcyk7XG5cbiAgICAgIGlmICh0eXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICAgICAgICBhbGwgPSB1bmlxdWVBcnJheShhbGwuY29uY2F0KGNoYW5nZWQpLCAnaWRlbnRpZmllcicsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW2FsbCwgY2hhbmdlZF07XG4gIH1cblxuICB2YXIgVE9VQ0hfSU5QVVRfTUFQID0ge1xuICAgICAgdG91Y2hzdGFydDogSU5QVVRfU1RBUlQsXG4gICAgICB0b3VjaG1vdmU6IElOUFVUX01PVkUsXG4gICAgICB0b3VjaGVuZDogSU5QVVRfRU5ELFxuICAgICAgdG91Y2hjYW5jZWw6IElOUFVUX0NBTkNFTFxuICB9O1xuXG4gIHZhciBUT1VDSF9UQVJHRVRfRVZFTlRTID0gJ3RvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kIHRvdWNoY2FuY2VsJztcblxuICAvKipcbiAgICogTXVsdGktdXNlciB0b3VjaCBldmVudHMgaW5wdXRcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIElucHV0XG4gICAqL1xuICBmdW5jdGlvbiBUb3VjaElucHV0KCkge1xuICAgICAgdGhpcy5ldlRhcmdldCA9IFRPVUNIX1RBUkdFVF9FVkVOVFM7XG4gICAgICB0aGlzLnRhcmdldElkcyA9IHt9O1xuXG4gICAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgaW5oZXJpdChUb3VjaElucHV0LCBJbnB1dCwge1xuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gTVRFaGFuZGxlcihldikge1xuICAgICAgICAgIHZhciB0eXBlID0gVE9VQ0hfSU5QVVRfTUFQW2V2LnR5cGVdO1xuICAgICAgICAgIHZhciB0b3VjaGVzID0gZ2V0VG91Y2hlcy5jYWxsKHRoaXMsIGV2LCB0eXBlKTtcbiAgICAgICAgICBpZiAoIXRvdWNoZXMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCB0eXBlLCB7XG4gICAgICAgICAgICAgIHBvaW50ZXJzOiB0b3VjaGVzWzBdLFxuICAgICAgICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IHRvdWNoZXNbMV0sXG4gICAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgICAgICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtUb3VjaElucHV0fVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHR5cGUgZmxhZ1xuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfEFycmF5fSBbYWxsLCBjaGFuZ2VkXVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0VG91Y2hlcyhldiwgdHlwZSkge1xuICAgICAgdmFyIGFsbFRvdWNoZXMgPSB0b0FycmF5KGV2LnRvdWNoZXMpO1xuICAgICAgdmFyIHRhcmdldElkcyA9IHRoaXMudGFyZ2V0SWRzO1xuXG4gICAgICAvLyB3aGVuIHRoZXJlIGlzIG9ubHkgb25lIHRvdWNoLCB0aGUgcHJvY2VzcyBjYW4gYmUgc2ltcGxpZmllZFxuICAgICAgaWYgKHR5cGUgJiAoSU5QVVRfU1RBUlQgfCBJTlBVVF9NT1ZFKSAmJiBhbGxUb3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHRhcmdldElkc1thbGxUb3VjaGVzWzBdLmlkZW50aWZpZXJdID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gW2FsbFRvdWNoZXMsIGFsbFRvdWNoZXNdO1xuICAgICAgfVxuXG4gICAgICB2YXIgaSxcbiAgICAgICAgICB0YXJnZXRUb3VjaGVzLFxuICAgICAgICAgIGNoYW5nZWRUb3VjaGVzID0gdG9BcnJheShldi5jaGFuZ2VkVG91Y2hlcyksXG4gICAgICAgICAgY2hhbmdlZFRhcmdldFRvdWNoZXMgPSBbXSxcbiAgICAgICAgICB0YXJnZXQgPSB0aGlzLnRhcmdldDtcblxuICAgICAgLy8gZ2V0IHRhcmdldCB0b3VjaGVzIGZyb20gdG91Y2hlc1xuICAgICAgdGFyZ2V0VG91Y2hlcyA9IGFsbFRvdWNoZXMuZmlsdGVyKGZ1bmN0aW9uKHRvdWNoKSB7XG4gICAgICAgICAgcmV0dXJuIGhhc1BhcmVudCh0b3VjaC50YXJnZXQsIHRhcmdldCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gY29sbGVjdCB0b3VjaGVzXG4gICAgICBpZiAodHlwZSA9PT0gSU5QVVRfU1RBUlQpIHtcbiAgICAgICAgICBpID0gMDtcbiAgICAgICAgICB3aGlsZSAoaSA8IHRhcmdldFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRhcmdldElkc1t0YXJnZXRUb3VjaGVzW2ldLmlkZW50aWZpZXJdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZmlsdGVyIGNoYW5nZWQgdG91Y2hlcyB0byBvbmx5IGNvbnRhaW4gdG91Y2hlcyB0aGF0IGV4aXN0IGluIHRoZSBjb2xsZWN0ZWQgdGFyZ2V0IGlkc1xuICAgICAgaSA9IDA7XG4gICAgICB3aGlsZSAoaSA8IGNoYW5nZWRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgICAgIGlmICh0YXJnZXRJZHNbY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcl0pIHtcbiAgICAgICAgICAgICAgY2hhbmdlZFRhcmdldFRvdWNoZXMucHVzaChjaGFuZ2VkVG91Y2hlc1tpXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gY2xlYW51cCByZW1vdmVkIHRvdWNoZXNcbiAgICAgICAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXRJZHNbY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcl07XG4gICAgICAgICAgfVxuICAgICAgICAgIGkrKztcbiAgICAgIH1cblxuICAgICAgaWYgKCFjaGFuZ2VkVGFyZ2V0VG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgICAgLy8gbWVyZ2UgdGFyZ2V0VG91Y2hlcyB3aXRoIGNoYW5nZWRUYXJnZXRUb3VjaGVzIHNvIGl0IGNvbnRhaW5zIEFMTCB0b3VjaGVzLCBpbmNsdWRpbmcgJ2VuZCcgYW5kICdjYW5jZWwnXG4gICAgICAgICAgdW5pcXVlQXJyYXkodGFyZ2V0VG91Y2hlcy5jb25jYXQoY2hhbmdlZFRhcmdldFRvdWNoZXMpLCAnaWRlbnRpZmllcicsIHRydWUpLFxuICAgICAgICAgIGNoYW5nZWRUYXJnZXRUb3VjaGVzXG4gICAgICBdO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbWJpbmVkIHRvdWNoIGFuZCBtb3VzZSBpbnB1dFxuICAgKlxuICAgKiBUb3VjaCBoYXMgYSBoaWdoZXIgcHJpb3JpdHkgdGhlbiBtb3VzZSwgYW5kIHdoaWxlIHRvdWNoaW5nIG5vIG1vdXNlIGV2ZW50cyBhcmUgYWxsb3dlZC5cbiAgICogVGhpcyBiZWNhdXNlIHRvdWNoIGRldmljZXMgYWxzbyBlbWl0IG1vdXNlIGV2ZW50cyB3aGlsZSBkb2luZyBhIHRvdWNoLlxuICAgKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMgSW5wdXRcbiAgICovXG4gIGZ1bmN0aW9uIFRvdWNoTW91c2VJbnB1dCgpIHtcbiAgICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgIHZhciBoYW5kbGVyID0gYmluZEZuKHRoaXMuaGFuZGxlciwgdGhpcyk7XG4gICAgICB0aGlzLnRvdWNoID0gbmV3IFRvdWNoSW5wdXQodGhpcy5tYW5hZ2VyLCBoYW5kbGVyKTtcbiAgICAgIHRoaXMubW91c2UgPSBuZXcgTW91c2VJbnB1dCh0aGlzLm1hbmFnZXIsIGhhbmRsZXIpO1xuICB9XG5cbiAgaW5oZXJpdChUb3VjaE1vdXNlSW5wdXQsIElucHV0LCB7XG4gICAgICAvKipcbiAgICAgICAqIGhhbmRsZSBtb3VzZSBhbmQgdG91Y2ggZXZlbnRzXG4gICAgICAgKiBAcGFyYW0ge0hhbW1lcn0gbWFuYWdlclxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGlucHV0RXZlbnRcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgICAqL1xuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gVE1FaGFuZGxlcihtYW5hZ2VyLCBpbnB1dEV2ZW50LCBpbnB1dERhdGEpIHtcbiAgICAgICAgICB2YXIgaXNUb3VjaCA9IChpbnB1dERhdGEucG9pbnRlclR5cGUgPT0gSU5QVVRfVFlQRV9UT1VDSCksXG4gICAgICAgICAgICAgIGlzTW91c2UgPSAoaW5wdXREYXRhLnBvaW50ZXJUeXBlID09IElOUFVUX1RZUEVfTU9VU0UpO1xuXG4gICAgICAgICAgLy8gd2hlbiB3ZSdyZSBpbiBhIHRvdWNoIGV2ZW50LCBzbyAgYmxvY2sgYWxsIHVwY29taW5nIG1vdXNlIGV2ZW50c1xuICAgICAgICAgIC8vIG1vc3QgbW9iaWxlIGJyb3dzZXIgYWxzbyBlbWl0IG1vdXNlZXZlbnRzLCByaWdodCBhZnRlciB0b3VjaHN0YXJ0XG4gICAgICAgICAgaWYgKGlzVG91Y2gpIHtcbiAgICAgICAgICAgICAgdGhpcy5tb3VzZS5hbGxvdyA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNNb3VzZSAmJiAhdGhpcy5tb3VzZS5hbGxvdykge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gcmVzZXQgdGhlIGFsbG93TW91c2Ugd2hlbiB3ZSdyZSBkb25lXG4gICAgICAgICAgaWYgKGlucHV0RXZlbnQgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgICAgICAgICB0aGlzLm1vdXNlLmFsbG93ID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmNhbGxiYWNrKG1hbmFnZXIsIGlucHV0RXZlbnQsIGlucHV0RGF0YSk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIHJlbW92ZSB0aGUgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgKi9cbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgICAgdGhpcy50b3VjaC5kZXN0cm95KCk7XG4gICAgICAgICAgdGhpcy5tb3VzZS5kZXN0cm95KCk7XG4gICAgICB9XG4gIH0pO1xuXG4gIHZhciBQUkVGSVhFRF9UT1VDSF9BQ1RJT04gPSBwcmVmaXhlZChURVNUX0VMRU1FTlQuc3R5bGUsICd0b3VjaEFjdGlvbicpO1xuICB2YXIgTkFUSVZFX1RPVUNIX0FDVElPTiA9IFBSRUZJWEVEX1RPVUNIX0FDVElPTiAhPT0gdW5kZWZpbmVkO1xuXG4gIC8vIG1hZ2ljYWwgdG91Y2hBY3Rpb24gdmFsdWVcbiAgdmFyIFRPVUNIX0FDVElPTl9DT01QVVRFID0gJ2NvbXB1dGUnO1xuICB2YXIgVE9VQ0hfQUNUSU9OX0FVVE8gPSAnYXV0byc7XG4gIHZhciBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OID0gJ21hbmlwdWxhdGlvbic7IC8vIG5vdCBpbXBsZW1lbnRlZFxuICB2YXIgVE9VQ0hfQUNUSU9OX05PTkUgPSAnbm9uZSc7XG4gIHZhciBUT1VDSF9BQ1RJT05fUEFOX1ggPSAncGFuLXgnO1xuICB2YXIgVE9VQ0hfQUNUSU9OX1BBTl9ZID0gJ3Bhbi15JztcblxuICAvKipcbiAgICogVG91Y2ggQWN0aW9uXG4gICAqIHNldHMgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5IG9yIHVzZXMgdGhlIGpzIGFsdGVybmF0aXZlXG4gICAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBUb3VjaEFjdGlvbihtYW5hZ2VyLCB2YWx1ZSkge1xuICAgICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICAgIHRoaXMuc2V0KHZhbHVlKTtcbiAgfVxuXG4gIFRvdWNoQWN0aW9uLnByb3RvdHlwZSA9IHtcbiAgICAgIC8qKlxuICAgICAgICogc2V0IHRoZSB0b3VjaEFjdGlvbiB2YWx1ZSBvbiB0aGUgZWxlbWVudCBvciBlbmFibGUgdGhlIHBvbHlmaWxsXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgICAqL1xuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIC8vIGZpbmQgb3V0IHRoZSB0b3VjaC1hY3Rpb24gYnkgdGhlIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgICAgaWYgKHZhbHVlID09IFRPVUNIX0FDVElPTl9DT01QVVRFKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5jb21wdXRlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKE5BVElWRV9UT1VDSF9BQ1RJT04gJiYgdGhpcy5tYW5hZ2VyLmVsZW1lbnQuc3R5bGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVsZW1lbnQuc3R5bGVbUFJFRklYRURfVE9VQ0hfQUNUSU9OXSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmFjdGlvbnMgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICoganVzdCByZS1zZXQgdGhlIHRvdWNoQWN0aW9uIHZhbHVlXG4gICAgICAgKi9cbiAgICAgIHVwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5zZXQodGhpcy5tYW5hZ2VyLm9wdGlvbnMudG91Y2hBY3Rpb24pO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBjb21wdXRlIHRoZSB2YWx1ZSBmb3IgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5IGJhc2VkIG9uIHRoZSByZWNvZ25pemVyJ3Mgc2V0dGluZ3NcbiAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHZhbHVlXG4gICAgICAgKi9cbiAgICAgIGNvbXB1dGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBhY3Rpb25zID0gW107XG4gICAgICAgICAgZWFjaCh0aGlzLm1hbmFnZXIucmVjb2duaXplcnMsIGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICAgICAgICAgICAgaWYgKGJvb2xPckZuKHJlY29nbml6ZXIub3B0aW9ucy5lbmFibGUsIFtyZWNvZ25pemVyXSkpIHtcbiAgICAgICAgICAgICAgICAgIGFjdGlvbnMgPSBhY3Rpb25zLmNvbmNhdChyZWNvZ25pemVyLmdldFRvdWNoQWN0aW9uKCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGNsZWFuVG91Y2hBY3Rpb25zKGFjdGlvbnMuam9pbignICcpKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogdGhpcyBtZXRob2QgaXMgY2FsbGVkIG9uIGVhY2ggaW5wdXQgY3ljbGUgYW5kIHByb3ZpZGVzIHRoZSBwcmV2ZW50aW5nIG9mIHRoZSBicm93c2VyIGJlaGF2aW9yXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICAgICAqL1xuICAgICAgcHJldmVudERlZmF1bHRzOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICAgIC8vIG5vdCBuZWVkZWQgd2l0aCBuYXRpdmUgc3VwcG9ydCBmb3IgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5XG4gICAgICAgICAgaWYgKE5BVElWRV9UT1VDSF9BQ1RJT04pIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzcmNFdmVudCA9IGlucHV0LnNyY0V2ZW50O1xuICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSBpbnB1dC5vZmZzZXREaXJlY3Rpb247XG5cbiAgICAgICAgICAvLyBpZiB0aGUgdG91Y2ggYWN0aW9uIGRpZCBwcmV2ZW50ZWQgb25jZSB0aGlzIHNlc3Npb25cbiAgICAgICAgICBpZiAodGhpcy5tYW5hZ2VyLnNlc3Npb24ucHJldmVudGVkKSB7XG4gICAgICAgICAgICAgIHNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgYWN0aW9ucyA9IHRoaXMuYWN0aW9ucztcbiAgICAgICAgICB2YXIgaGFzTm9uZSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9OT05FKTtcbiAgICAgICAgICB2YXIgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSk7XG4gICAgICAgICAgdmFyIGhhc1BhblggPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1gpO1xuXG4gICAgICAgICAgaWYgKGhhc05vbmUpIHtcbiAgICAgICAgICAgICAgLy9kbyBub3QgcHJldmVudCBkZWZhdWx0cyBpZiB0aGlzIGlzIGEgdGFwIGdlc3R1cmVcblxuICAgICAgICAgICAgICB2YXIgaXNUYXBQb2ludGVyID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSAxO1xuICAgICAgICAgICAgICB2YXIgaXNUYXBNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgMjtcbiAgICAgICAgICAgICAgdmFyIGlzVGFwVG91Y2hUaW1lID0gaW5wdXQuZGVsdGFUaW1lIDwgMjUwO1xuXG4gICAgICAgICAgICAgIGlmIChpc1RhcFBvaW50ZXIgJiYgaXNUYXBNb3ZlbWVudCAmJiBpc1RhcFRvdWNoVGltZSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGhhc1BhblggJiYgaGFzUGFuWSkge1xuICAgICAgICAgICAgICAvLyBgcGFuLXggcGFuLXlgIG1lYW5zIGJyb3dzZXIgaGFuZGxlcyBhbGwgc2Nyb2xsaW5nL3Bhbm5pbmcsIGRvIG5vdCBwcmV2ZW50XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaGFzTm9uZSB8fFxuICAgICAgICAgICAgICAoaGFzUGFuWSAmJiBkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkgfHxcbiAgICAgICAgICAgICAgKGhhc1BhblggJiYgZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcmV2ZW50U3JjKHNyY0V2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIGNhbGwgcHJldmVudERlZmF1bHQgdG8gcHJldmVudCB0aGUgYnJvd3NlcidzIGRlZmF1bHQgYmVoYXZpb3IgKHNjcm9sbGluZyBpbiBtb3N0IGNhc2VzKVxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IHNyY0V2ZW50XG4gICAgICAgKi9cbiAgICAgIHByZXZlbnRTcmM6IGZ1bmN0aW9uKHNyY0V2ZW50KSB7XG4gICAgICAgICAgdGhpcy5tYW5hZ2VyLnNlc3Npb24ucHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgICBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiB3aGVuIHRoZSB0b3VjaEFjdGlvbnMgYXJlIGNvbGxlY3RlZCB0aGV5IGFyZSBub3QgYSB2YWxpZCB2YWx1ZSwgc28gd2UgbmVlZCB0byBjbGVhbiB0aGluZ3MgdXAuICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvbnNcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBmdW5jdGlvbiBjbGVhblRvdWNoQWN0aW9ucyhhY3Rpb25zKSB7XG4gICAgICAvLyBub25lXG4gICAgICBpZiAoaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX05PTkUpKSB7XG4gICAgICAgICAgcmV0dXJuIFRPVUNIX0FDVElPTl9OT05FO1xuICAgICAgfVxuXG4gICAgICB2YXIgaGFzUGFuWCA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWCk7XG4gICAgICB2YXIgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSk7XG5cbiAgICAgIC8vIGlmIGJvdGggcGFuLXggYW5kIHBhbi15IGFyZSBzZXQgKGRpZmZlcmVudCByZWNvZ25pemVyc1xuICAgICAgLy8gZm9yIGRpZmZlcmVudCBkaXJlY3Rpb25zLCBlLmcuIGhvcml6b250YWwgcGFuIGJ1dCB2ZXJ0aWNhbCBzd2lwZT8pXG4gICAgICAvLyB3ZSBuZWVkIG5vbmUgKGFzIG90aGVyd2lzZSB3aXRoIHBhbi14IHBhbi15IGNvbWJpbmVkIG5vbmUgb2YgdGhlc2VcbiAgICAgIC8vIHJlY29nbml6ZXJzIHdpbGwgd29yaywgc2luY2UgdGhlIGJyb3dzZXIgd291bGQgaGFuZGxlIGFsbCBwYW5uaW5nXG4gICAgICBpZiAoaGFzUGFuWCAmJiBoYXNQYW5ZKSB7XG4gICAgICAgICAgcmV0dXJuIFRPVUNIX0FDVElPTl9OT05FO1xuICAgICAgfVxuXG4gICAgICAvLyBwYW4teCBPUiBwYW4teVxuICAgICAgaWYgKGhhc1BhblggfHwgaGFzUGFuWSkge1xuICAgICAgICAgIHJldHVybiBoYXNQYW5YID8gVE9VQ0hfQUNUSU9OX1BBTl9YIDogVE9VQ0hfQUNUSU9OX1BBTl9ZO1xuICAgICAgfVxuXG4gICAgICAvLyBtYW5pcHVsYXRpb25cbiAgICAgIGlmIChpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OKSkge1xuICAgICAgICAgIHJldHVybiBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX0FVVE87XG4gIH1cblxuICAvKipcbiAgICogUmVjb2duaXplciBmbG93IGV4cGxhaW5lZDsgKlxuICAgKiBBbGwgcmVjb2duaXplcnMgaGF2ZSB0aGUgaW5pdGlhbCBzdGF0ZSBvZiBQT1NTSUJMRSB3aGVuIGEgaW5wdXQgc2Vzc2lvbiBzdGFydHMuXG4gICAqIFRoZSBkZWZpbml0aW9uIG9mIGEgaW5wdXQgc2Vzc2lvbiBpcyBmcm9tIHRoZSBmaXJzdCBpbnB1dCB1bnRpbCB0aGUgbGFzdCBpbnB1dCwgd2l0aCBhbGwgaXQncyBtb3ZlbWVudCBpbiBpdC4gKlxuICAgKiBFeGFtcGxlIHNlc3Npb24gZm9yIG1vdXNlLWlucHV0OiBtb3VzZWRvd24gLT4gbW91c2Vtb3ZlIC0+IG1vdXNldXBcbiAgICpcbiAgICogT24gZWFjaCByZWNvZ25pemluZyBjeWNsZSAoc2VlIE1hbmFnZXIucmVjb2duaXplKSB0aGUgLnJlY29nbml6ZSgpIG1ldGhvZCBpcyBleGVjdXRlZFxuICAgKiB3aGljaCBkZXRlcm1pbmVzIHdpdGggc3RhdGUgaXQgc2hvdWxkIGJlLlxuICAgKlxuICAgKiBJZiB0aGUgcmVjb2duaXplciBoYXMgdGhlIHN0YXRlIEZBSUxFRCwgQ0FOQ0VMTEVEIG9yIFJFQ09HTklaRUQgKGVxdWFscyBFTkRFRCksIGl0IGlzIHJlc2V0IHRvXG4gICAqIFBPU1NJQkxFIHRvIGdpdmUgaXQgYW5vdGhlciBjaGFuZ2Ugb24gdGhlIG5leHQgY3ljbGUuXG4gICAqXG4gICAqICAgICAgICAgICAgICAgUG9zc2libGVcbiAgICogICAgICAgICAgICAgICAgICB8XG4gICAqICAgICAgICAgICAgKy0tLS0tKy0tLS0tLS0tLS0tLS0tLStcbiAgICogICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgfFxuICAgKiAgICAgICstLS0tLSstLS0tLSsgICAgICAgICAgICAgICB8XG4gICAqICAgICAgfCAgICAgICAgICAgfCAgICAgICAgICAgICAgIHxcbiAgICogICBGYWlsZWQgICAgICBDYW5jZWxsZWQgICAgICAgICAgfFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0rLS0tLS0tK1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfFxuICAgKiAgICAgICAgICAgICAgICAgICAgICBSZWNvZ25pemVkICAgICAgIEJlZ2FuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDaGFuZ2VkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVuZGVkL1JlY29nbml6ZWRcbiAgICovXG4gIHZhciBTVEFURV9QT1NTSUJMRSA9IDE7XG4gIHZhciBTVEFURV9CRUdBTiA9IDI7XG4gIHZhciBTVEFURV9DSEFOR0VEID0gNDtcbiAgdmFyIFNUQVRFX0VOREVEID0gODtcbiAgdmFyIFNUQVRFX1JFQ09HTklaRUQgPSBTVEFURV9FTkRFRDtcbiAgdmFyIFNUQVRFX0NBTkNFTExFRCA9IDE2O1xuICB2YXIgU1RBVEVfRkFJTEVEID0gMzI7XG5cbiAgLyoqXG4gICAqIFJlY29nbml6ZXJcbiAgICogRXZlcnkgcmVjb2duaXplciBuZWVkcyB0byBleHRlbmQgZnJvbSB0aGlzIGNsYXNzLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIFJlY29nbml6ZXIob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gYXNzaWduKHt9LCB0aGlzLmRlZmF1bHRzLCBvcHRpb25zIHx8IHt9KTtcblxuICAgICAgdGhpcy5pZCA9IHVuaXF1ZUlkKCk7XG5cbiAgICAgIHRoaXMubWFuYWdlciA9IG51bGw7XG5cbiAgICAgIC8vIGRlZmF1bHQgaXMgZW5hYmxlIHRydWVcbiAgICAgIHRoaXMub3B0aW9ucy5lbmFibGUgPSBpZlVuZGVmaW5lZCh0aGlzLm9wdGlvbnMuZW5hYmxlLCB0cnVlKTtcblxuICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1BPU1NJQkxFO1xuXG4gICAgICB0aGlzLnNpbXVsdGFuZW91cyA9IHt9O1xuICAgICAgdGhpcy5yZXF1aXJlRmFpbCA9IFtdO1xuICB9XG5cbiAgUmVjb2duaXplci5wcm90b3R5cGUgPSB7XG4gICAgICAvKipcbiAgICAgICAqIEB2aXJ0dWFsXG4gICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICovXG4gICAgICBkZWZhdWx0czoge30sXG5cbiAgICAgIC8qKlxuICAgICAgICogc2V0IG9wdGlvbnNcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICAgKiBAcmV0dXJuIHtSZWNvZ25pemVyfVxuICAgICAgICovXG4gICAgICBzZXQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICBhc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgICAgIC8vIGFsc28gdXBkYXRlIHRoZSB0b3VjaEFjdGlvbiwgaW4gY2FzZSBzb21ldGhpbmcgY2hhbmdlZCBhYm91dCB0aGUgZGlyZWN0aW9ucy9lbmFibGVkIHN0YXRlXG4gICAgICAgICAgdGhpcy5tYW5hZ2VyICYmIHRoaXMubWFuYWdlci50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogcmVjb2duaXplIHNpbXVsdGFuZW91cyB3aXRoIGFuIG90aGVyIHJlY29nbml6ZXIuXG4gICAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICAgICAqL1xuICAgICAgcmVjb2duaXplV2l0aDogZnVuY3Rpb24ob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ3JlY29nbml6ZVdpdGgnLCB0aGlzKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc2ltdWx0YW5lb3VzID0gdGhpcy5zaW11bHRhbmVvdXM7XG4gICAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgICAgIGlmICghc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF0pIHtcbiAgICAgICAgICAgICAgc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF0gPSBvdGhlclJlY29nbml6ZXI7XG4gICAgICAgICAgICAgIG90aGVyUmVjb2duaXplci5yZWNvZ25pemVXaXRoKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogZHJvcCB0aGUgc2ltdWx0YW5lb3VzIGxpbmsuIGl0IGRvZXNudCByZW1vdmUgdGhlIGxpbmsgb24gdGhlIG90aGVyIHJlY29nbml6ZXIuXG4gICAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICAgICAqL1xuICAgICAgZHJvcFJlY29nbml6ZVdpdGg6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdkcm9wUmVjb2duaXplV2l0aCcsIHRoaXMpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5zaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogcmVjb2duaXplciBjYW4gb25seSBydW4gd2hlbiBhbiBvdGhlciBpcyBmYWlsaW5nXG4gICAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICAgICAqL1xuICAgICAgcmVxdWlyZUZhaWx1cmU6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdyZXF1aXJlRmFpbHVyZScsIHRoaXMpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByZXF1aXJlRmFpbCA9IHRoaXMucmVxdWlyZUZhaWw7XG4gICAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgICAgIGlmIChpbkFycmF5KHJlcXVpcmVGYWlsLCBvdGhlclJlY29nbml6ZXIpID09PSAtMSkge1xuICAgICAgICAgICAgICByZXF1aXJlRmFpbC5wdXNoKG90aGVyUmVjb2duaXplcik7XG4gICAgICAgICAgICAgIG90aGVyUmVjb2duaXplci5yZXF1aXJlRmFpbHVyZSh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIGRyb3AgdGhlIHJlcXVpcmVGYWlsdXJlIGxpbmsuIGl0IGRvZXMgbm90IHJlbW92ZSB0aGUgbGluayBvbiB0aGUgb3RoZXIgcmVjb2duaXplci5cbiAgICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAgICovXG4gICAgICBkcm9wUmVxdWlyZUZhaWx1cmU6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdkcm9wUmVxdWlyZUZhaWx1cmUnLCB0aGlzKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgICAgICAgdmFyIGluZGV4ID0gaW5BcnJheSh0aGlzLnJlcXVpcmVGYWlsLCBvdGhlclJlY29nbml6ZXIpO1xuICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgIHRoaXMucmVxdWlyZUZhaWwuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIGhhcyByZXF1aXJlIGZhaWx1cmVzIGJvb2xlYW5cbiAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICovXG4gICAgICBoYXNSZXF1aXJlRmFpbHVyZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVpcmVGYWlsLmxlbmd0aCA+IDA7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIGlmIHRoZSByZWNvZ25pemVyIGNhbiByZWNvZ25pemUgc2ltdWx0YW5lb3VzIHdpdGggYW4gb3RoZXIgcmVjb2duaXplclxuICAgICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAgICovXG4gICAgICBjYW5SZWNvZ25pemVXaXRoOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgICAgICByZXR1cm4gISF0aGlzLnNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBZb3Ugc2hvdWxkIHVzZSBgdHJ5RW1pdGAgaW5zdGVhZCBvZiBgZW1pdGAgZGlyZWN0bHkgdG8gY2hlY2tcbiAgICAgICAqIHRoYXQgYWxsIHRoZSBuZWVkZWQgcmVjb2duaXplcnMgaGFzIGZhaWxlZCBiZWZvcmUgZW1pdHRpbmcuXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICAgICAqL1xuICAgICAgZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGVtaXQoZXZlbnQpIHtcbiAgICAgICAgICAgICAgc2VsZi5tYW5hZ2VyLmVtaXQoZXZlbnQsIGlucHV0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyAncGFuc3RhcnQnIGFuZCAncGFubW92ZSdcbiAgICAgICAgICBpZiAoc3RhdGUgPCBTVEFURV9FTkRFRCkge1xuICAgICAgICAgICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCArIHN0YXRlU3RyKHN0YXRlKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZW1pdChzZWxmLm9wdGlvbnMuZXZlbnQpOyAvLyBzaW1wbGUgJ2V2ZW50TmFtZScgZXZlbnRzXG5cbiAgICAgICAgICBpZiAoaW5wdXQuYWRkaXRpb25hbEV2ZW50KSB7IC8vIGFkZGl0aW9uYWwgZXZlbnQocGFubGVmdCwgcGFucmlnaHQsIHBpbmNoaW4sIHBpbmNob3V0Li4uKVxuICAgICAgICAgICAgICBlbWl0KGlucHV0LmFkZGl0aW9uYWxFdmVudCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gcGFuZW5kIGFuZCBwYW5jYW5jZWxcbiAgICAgICAgICBpZiAoc3RhdGUgPj0gU1RBVEVfRU5ERUQpIHtcbiAgICAgICAgICAgICAgZW1pdChzZWxmLm9wdGlvbnMuZXZlbnQgKyBzdGF0ZVN0cihzdGF0ZSkpO1xuICAgICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQ2hlY2sgdGhhdCBhbGwgdGhlIHJlcXVpcmUgZmFpbHVyZSByZWNvZ25pemVycyBoYXMgZmFpbGVkLFxuICAgICAgICogaWYgdHJ1ZSwgaXQgZW1pdHMgYSBnZXN0dXJlIGV2ZW50LFxuICAgICAgICogb3RoZXJ3aXNlLCBzZXR1cCB0aGUgc3RhdGUgdG8gRkFJTEVELlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICAgKi9cbiAgICAgIHRyeUVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgICAgaWYgKHRoaXMuY2FuRW1pdCgpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmVtaXQoaW5wdXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBpdCdzIGZhaWxpbmcgYW55d2F5XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogY2FuIHdlIGVtaXQ/XG4gICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAqL1xuICAgICAgY2FuRW1pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgIHdoaWxlIChpIDwgdGhpcy5yZXF1aXJlRmFpbC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgaWYgKCEodGhpcy5yZXF1aXJlRmFpbFtpXS5zdGF0ZSAmIChTVEFURV9GQUlMRUQgfCBTVEFURV9QT1NTSUJMRSkpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogdXBkYXRlIHRoZSByZWNvZ25pemVyXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAgICAgKi9cbiAgICAgIHJlY29nbml6ZTogZnVuY3Rpb24oaW5wdXREYXRhKSB7XG4gICAgICAgICAgLy8gbWFrZSBhIG5ldyBjb3B5IG9mIHRoZSBpbnB1dERhdGFcbiAgICAgICAgICAvLyBzbyB3ZSBjYW4gY2hhbmdlIHRoZSBpbnB1dERhdGEgd2l0aG91dCBtZXNzaW5nIHVwIHRoZSBvdGhlciByZWNvZ25pemVyc1xuICAgICAgICAgIHZhciBpbnB1dERhdGFDbG9uZSA9IGFzc2lnbih7fSwgaW5wdXREYXRhKTtcblxuICAgICAgICAgIC8vIGlzIGlzIGVuYWJsZWQgYW5kIGFsbG93IHJlY29nbml6aW5nP1xuICAgICAgICAgIGlmICghYm9vbE9yRm4odGhpcy5vcHRpb25zLmVuYWJsZSwgW3RoaXMsIGlucHV0RGF0YUNsb25lXSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gcmVzZXQgd2hlbiB3ZSd2ZSByZWFjaGVkIHRoZSBlbmRcbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZSAmIChTVEFURV9SRUNPR05JWkVEIHwgU1RBVEVfQ0FOQ0VMTEVEIHwgU1RBVEVfRkFJTEVEKSkge1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUE9TU0lCTEU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMucHJvY2VzcyhpbnB1dERhdGFDbG9uZSk7XG5cbiAgICAgICAgICAvLyB0aGUgcmVjb2duaXplciBoYXMgcmVjb2duaXplZCBhIGdlc3R1cmVcbiAgICAgICAgICAvLyBzbyB0cmlnZ2VyIGFuIGV2ZW50XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEIHwgU1RBVEVfRU5ERUQgfCBTVEFURV9DQU5DRUxMRUQpKSB7XG4gICAgICAgICAgICAgIHRoaXMudHJ5RW1pdChpbnB1dERhdGFDbG9uZSk7XG4gICAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiByZXR1cm4gdGhlIHN0YXRlIG9mIHRoZSByZWNvZ25pemVyXG4gICAgICAgKiB0aGUgYWN0dWFsIHJlY29nbml6aW5nIGhhcHBlbnMgaW4gdGhpcyBtZXRob2RcbiAgICAgICAqIEB2aXJ0dWFsXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAgICAgKiBAcmV0dXJucyB7Q29uc3R9IFNUQVRFXG4gICAgICAgKi9cbiAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0RGF0YSkgeyB9LCAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblxuICAgICAgLyoqXG4gICAgICAgKiByZXR1cm4gdGhlIHByZWZlcnJlZCB0b3VjaC1hY3Rpb25cbiAgICAgICAqIEB2aXJ0dWFsXG4gICAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICAgKi9cbiAgICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHsgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBjYWxsZWQgd2hlbiB0aGUgZ2VzdHVyZSBpc24ndCBhbGxvd2VkIHRvIHJlY29nbml6ZVxuICAgICAgICogbGlrZSB3aGVuIGFub3RoZXIgaXMgYmVpbmcgcmVjb2duaXplZCBvciBpdCBpcyBkaXNhYmxlZFxuICAgICAgICogQHZpcnR1YWxcbiAgICAgICAqL1xuICAgICAgcmVzZXQ6IGZ1bmN0aW9uKCkgeyB9XG4gIH07XG5cbiAgLyoqXG4gICAqIGdldCBhIHVzYWJsZSBzdHJpbmcsIHVzZWQgYXMgZXZlbnQgcG9zdGZpeFxuICAgKiBAcGFyYW0ge0NvbnN0fSBzdGF0ZVxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBzdGF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gc3RhdGVTdHIoc3RhdGUpIHtcbiAgICAgIGlmIChzdGF0ZSAmIFNUQVRFX0NBTkNFTExFRCkge1xuICAgICAgICAgIHJldHVybiAnY2FuY2VsJztcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUgJiBTVEFURV9FTkRFRCkge1xuICAgICAgICAgIHJldHVybiAnZW5kJztcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUgJiBTVEFURV9DSEFOR0VEKSB7XG4gICAgICAgICAgcmV0dXJuICdtb3ZlJztcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUgJiBTVEFURV9CRUdBTikge1xuICAgICAgICAgIHJldHVybiAnc3RhcnQnO1xuICAgICAgfVxuICAgICAgcmV0dXJuICcnO1xuICB9XG5cbiAgLyoqXG4gICAqIGRpcmVjdGlvbiBjb25zIHRvIHN0cmluZ1xuICAgKiBAcGFyYW0ge0NvbnN0fSBkaXJlY3Rpb25cbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICovXG4gIGZ1bmN0aW9uIGRpcmVjdGlvblN0cihkaXJlY3Rpb24pIHtcbiAgICAgIGlmIChkaXJlY3Rpb24gPT0gRElSRUNUSU9OX0RPV04pIHtcbiAgICAgICAgICByZXR1cm4gJ2Rvd24nO1xuICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT0gRElSRUNUSU9OX1VQKSB7XG4gICAgICAgICAgcmV0dXJuICd1cCc7XG4gICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fTEVGVCkge1xuICAgICAgICAgIHJldHVybiAnbGVmdCc7XG4gICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fUklHSFQpIHtcbiAgICAgICAgICByZXR1cm4gJ3JpZ2h0JztcbiAgICAgIH1cbiAgICAgIHJldHVybiAnJztcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgYSByZWNvZ25pemVyIGJ5IG5hbWUgaWYgaXQgaXMgYm91bmQgdG8gYSBtYW5hZ2VyXG4gICAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IG90aGVyUmVjb2duaXplclxuICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IHJlY29nbml6ZXJcbiAgICogQHJldHVybnMge1JlY29nbml6ZXJ9XG4gICAqL1xuICBmdW5jdGlvbiBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgcmVjb2duaXplcikge1xuICAgICAgdmFyIG1hbmFnZXIgPSByZWNvZ25pemVyLm1hbmFnZXI7XG4gICAgICBpZiAobWFuYWdlcikge1xuICAgICAgICAgIHJldHVybiBtYW5hZ2VyLmdldChvdGhlclJlY29nbml6ZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG90aGVyUmVjb2duaXplcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIHJlY29nbml6ZXIgaXMganVzdCB1c2VkIGFzIGEgYmFzZSBmb3IgdGhlIHNpbXBsZSBhdHRyaWJ1dGUgcmVjb2duaXplcnMuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gICAqL1xuICBmdW5jdGlvbiBBdHRyUmVjb2duaXplcigpIHtcbiAgICAgIFJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGluaGVyaXQoQXR0clJlY29nbml6ZXIsIFJlY29nbml6ZXIsIHtcbiAgICAgIC8qKlxuICAgICAgICogQG5hbWVzcGFjZVxuICAgICAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXG4gICAgICAgKi9cbiAgICAgIGRlZmF1bHRzOiB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgICAgICovXG4gICAgICAgICAgcG9pbnRlcnM6IDFcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBjaGVjayBpZiBpdCB0aGUgcmVjb2duaXplciByZWNlaXZlcyB2YWxpZCBpbnB1dCwgbGlrZSBpbnB1dC5kaXN0YW5jZSA+IDEwLlxuICAgICAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufSByZWNvZ25pemVkXG4gICAgICAgKi9cbiAgICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICAgIHZhciBvcHRpb25Qb2ludGVycyA9IHRoaXMub3B0aW9ucy5wb2ludGVycztcbiAgICAgICAgICByZXR1cm4gb3B0aW9uUG9pbnRlcnMgPT09IDAgfHwgaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25Qb2ludGVycztcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUHJvY2VzcyB0aGUgaW5wdXQgYW5kIHJldHVybiB0aGUgc3RhdGUgZm9yIHRoZSByZWNvZ25pemVyXG4gICAgICAgKiBAbWVtYmVyb2YgQXR0clJlY29nbml6ZXJcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAgICogQHJldHVybnMgeyp9IFN0YXRlXG4gICAgICAgKi9cbiAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICB2YXIgZXZlbnRUeXBlID0gaW5wdXQuZXZlbnRUeXBlO1xuXG4gICAgICAgICAgdmFyIGlzUmVjb2duaXplZCA9IHN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCk7XG4gICAgICAgICAgdmFyIGlzVmFsaWQgPSB0aGlzLmF0dHJUZXN0KGlucHV0KTtcblxuICAgICAgICAgIC8vIG9uIGNhbmNlbCBpbnB1dCBhbmQgd2UndmUgcmVjb2duaXplZCBiZWZvcmUsIHJldHVybiBTVEFURV9DQU5DRUxMRURcbiAgICAgICAgICBpZiAoaXNSZWNvZ25pemVkICYmIChldmVudFR5cGUgJiBJTlBVVF9DQU5DRUwgfHwgIWlzVmFsaWQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0NBTkNFTExFRDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzUmVjb2duaXplZCB8fCBpc1ZhbGlkKSB7XG4gICAgICAgICAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0VOREVEO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCEoc3RhdGUgJiBTVEFURV9CRUdBTikpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBTVEFURV9CRUdBTjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9DSEFOR0VEO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUGFuXG4gICAqIFJlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb3duIGFuZCBtb3ZlZCBpbiB0aGUgYWxsb3dlZCBkaXJlY3Rpb24uXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICAgKi9cbiAgZnVuY3Rpb24gUGFuUmVjb2duaXplcigpIHtcbiAgICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgIHRoaXMucFggPSBudWxsO1xuICAgICAgdGhpcy5wWSA9IG51bGw7XG4gIH1cblxuICBpbmhlcml0KFBhblJlY29nbml6ZXIsIEF0dHJSZWNvZ25pemVyLCB7XG4gICAgICAvKipcbiAgICAgICAqIEBuYW1lc3BhY2VcbiAgICAgICAqIEBtZW1iZXJvZiBQYW5SZWNvZ25pemVyXG4gICAgICAgKi9cbiAgICAgIGRlZmF1bHRzOiB7XG4gICAgICAgICAgZXZlbnQ6ICdwYW4nLFxuICAgICAgICAgIHRocmVzaG9sZDogMTAsXG4gICAgICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICAgICAgZGlyZWN0aW9uOiBESVJFQ1RJT05fQUxMXG4gICAgICB9LFxuXG4gICAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb247XG4gICAgICAgICAgdmFyIGFjdGlvbnMgPSBbXTtcbiAgICAgICAgICBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHtcbiAgICAgICAgICAgICAgYWN0aW9ucy5wdXNoKFRPVUNIX0FDVElPTl9QQU5fWSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fVkVSVElDQUwpIHtcbiAgICAgICAgICAgICAgYWN0aW9ucy5wdXNoKFRPVUNIX0FDVElPTl9QQU5fWCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhY3Rpb25zO1xuICAgICAgfSxcblxuICAgICAgZGlyZWN0aW9uVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICB2YXIgaGFzTW92ZWQgPSB0cnVlO1xuICAgICAgICAgIHZhciBkaXN0YW5jZSA9IGlucHV0LmRpc3RhbmNlO1xuICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSBpbnB1dC5kaXJlY3Rpb247XG4gICAgICAgICAgdmFyIHggPSBpbnB1dC5kZWx0YVg7XG4gICAgICAgICAgdmFyIHkgPSBpbnB1dC5kZWx0YVk7XG5cbiAgICAgICAgICAvLyBsb2NrIHRvIGF4aXM/XG4gICAgICAgICAgaWYgKCEoZGlyZWN0aW9uICYgb3B0aW9ucy5kaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLmRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XG4gICAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSAoeCA9PT0gMCkgPyBESVJFQ1RJT05fTk9ORSA6ICh4IDwgMCkgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgICAgICAgICAgICAgICAgIGhhc01vdmVkID0geCAhPSB0aGlzLnBYO1xuICAgICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhpbnB1dC5kZWx0YVgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gKHkgPT09IDApID8gRElSRUNUSU9OX05PTkUgOiAoeSA8IDApID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG4gICAgICAgICAgICAgICAgICBoYXNNb3ZlZCA9IHkgIT0gdGhpcy5wWTtcbiAgICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5hYnMoaW5wdXQuZGVsdGFZKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpbnB1dC5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgICAgICAgcmV0dXJuIGhhc01vdmVkICYmIGRpc3RhbmNlID4gb3B0aW9ucy50aHJlc2hvbGQgJiYgZGlyZWN0aW9uICYgb3B0aW9ucy5kaXJlY3Rpb247XG4gICAgICB9LFxuXG4gICAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgICByZXR1cm4gQXR0clJlY29nbml6ZXIucHJvdG90eXBlLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmXG4gICAgICAgICAgICAgICh0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4gfHwgKCEodGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKSAmJiB0aGlzLmRpcmVjdGlvblRlc3QoaW5wdXQpKSk7XG4gICAgICB9LFxuXG4gICAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuXG4gICAgICAgICAgdGhpcy5wWCA9IGlucHV0LmRlbHRhWDtcbiAgICAgICAgICB0aGlzLnBZID0gaW5wdXQuZGVsdGFZO1xuXG4gICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGRpcmVjdGlvblN0cihpbnB1dC5kaXJlY3Rpb24pO1xuXG4gICAgICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgICBpbnB1dC5hZGRpdGlvbmFsRXZlbnQgPSB0aGlzLm9wdGlvbnMuZXZlbnQgKyBkaXJlY3Rpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3N1cGVyLmVtaXQuY2FsbCh0aGlzLCBpbnB1dCk7XG4gICAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBQaW5jaFxuICAgKiBSZWNvZ25pemVkIHdoZW4gdHdvIG9yIG1vcmUgcG9pbnRlcnMgYXJlIG1vdmluZyB0b3dhcmQgKHpvb20taW4pIG9yIGF3YXkgZnJvbSBlYWNoIG90aGVyICh6b29tLW91dCkuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICAgKi9cbiAgZnVuY3Rpb24gUGluY2hSZWNvZ25pemVyKCkge1xuICAgICAgQXR0clJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGluaGVyaXQoUGluY2hSZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xuICAgICAgLyoqXG4gICAgICAgKiBAbmFtZXNwYWNlXG4gICAgICAgKiBAbWVtYmVyb2YgUGluY2hSZWNvZ25pemVyXG4gICAgICAgKi9cbiAgICAgIGRlZmF1bHRzOiB7XG4gICAgICAgICAgZXZlbnQ6ICdwaW5jaCcsXG4gICAgICAgICAgdGhyZXNob2xkOiAwLFxuICAgICAgICAgIHBvaW50ZXJzOiAyXG4gICAgICB9LFxuXG4gICAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTk9ORV07XG4gICAgICB9LFxuXG4gICAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc3VwZXIuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiZcbiAgICAgICAgICAgICAgKE1hdGguYWJzKGlucHV0LnNjYWxlIC0gMSkgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkIHx8IHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTik7XG4gICAgICB9LFxuXG4gICAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICAgIGlmIChpbnB1dC5zY2FsZSAhPT0gMSkge1xuICAgICAgICAgICAgICB2YXIgaW5PdXQgPSBpbnB1dC5zY2FsZSA8IDEgPyAnaW4nIDogJ291dCc7XG4gICAgICAgICAgICAgIGlucHV0LmFkZGl0aW9uYWxFdmVudCA9IHRoaXMub3B0aW9ucy5ldmVudCArIGluT3V0O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9zdXBlci5lbWl0LmNhbGwodGhpcywgaW5wdXQpO1xuICAgICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUHJlc3NcbiAgICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvd24gZm9yIHggbXMgd2l0aG91dCBhbnkgbW92ZW1lbnQuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gICAqL1xuICBmdW5jdGlvbiBQcmVzc1JlY29nbml6ZXIoKSB7XG4gICAgICBSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICAgIHRoaXMuX2lucHV0ID0gbnVsbDtcbiAgfVxuXG4gIGluaGVyaXQoUHJlc3NSZWNvZ25pemVyLCBSZWNvZ25pemVyLCB7XG4gICAgICAvKipcbiAgICAgICAqIEBuYW1lc3BhY2VcbiAgICAgICAqIEBtZW1iZXJvZiBQcmVzc1JlY29nbml6ZXJcbiAgICAgICAqL1xuICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgICBldmVudDogJ3ByZXNzJyxcbiAgICAgICAgICBwb2ludGVyczogMSxcbiAgICAgICAgICB0aW1lOiAyNTEsIC8vIG1pbmltYWwgdGltZSBvZiB0aGUgcG9pbnRlciB0byBiZSBwcmVzc2VkXG4gICAgICAgICAgdGhyZXNob2xkOiA5IC8vIGEgbWluaW1hbCBtb3ZlbWVudCBpcyBvaywgYnV0IGtlZXAgaXQgbG93XG4gICAgICB9LFxuXG4gICAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fQVVUT107XG4gICAgICB9LFxuXG4gICAgICBwcm9jZXNzOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAgIHZhciB2YWxpZFBvaW50ZXJzID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25zLnBvaW50ZXJzO1xuICAgICAgICAgIHZhciB2YWxpZE1vdmVtZW50ID0gaW5wdXQuZGlzdGFuY2UgPCBvcHRpb25zLnRocmVzaG9sZDtcbiAgICAgICAgICB2YXIgdmFsaWRUaW1lID0gaW5wdXQuZGVsdGFUaW1lID4gb3B0aW9ucy50aW1lO1xuXG4gICAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcblxuICAgICAgICAgIC8vIHdlIG9ubHkgYWxsb3cgbGl0dGxlIG1vdmVtZW50XG4gICAgICAgICAgLy8gYW5kIHdlJ3ZlIHJlYWNoZWQgYW4gZW5kIGV2ZW50LCBzbyBhIHRhcCBpcyBwb3NzaWJsZVxuICAgICAgICAgIGlmICghdmFsaWRNb3ZlbWVudCB8fCAhdmFsaWRQb2ludGVycyB8fCAoaW5wdXQuZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkgJiYgIXZhbGlkVGltZSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpIHtcbiAgICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXRDb250ZXh0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgICAgICAgICAgICB0aGlzLnRyeUVtaXQoKTtcbiAgICAgICAgICAgICAgfSwgb3B0aW9ucy50aW1lLCB0aGlzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICAgIH0sXG5cbiAgICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICAgICAgfSxcblxuICAgICAgZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU1RBVEVfUkVDT0dOSVpFRCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlucHV0ICYmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQpKSB7XG4gICAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCArICd1cCcsIGlucHV0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9pbnB1dC50aW1lU3RhbXAgPSBub3coKTtcbiAgICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LCB0aGlzLl9pbnB1dCk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUm90YXRlXG4gICAqIFJlY29nbml6ZWQgd2hlbiB0d28gb3IgbW9yZSBwb2ludGVyIGFyZSBtb3ZpbmcgaW4gYSBjaXJjdWxhciBtb3Rpb24uXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICAgKi9cbiAgZnVuY3Rpb24gUm90YXRlUmVjb2duaXplcigpIHtcbiAgICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBpbmhlcml0KFJvdGF0ZVJlY29nbml6ZXIsIEF0dHJSZWNvZ25pemVyLCB7XG4gICAgICAvKipcbiAgICAgICAqIEBuYW1lc3BhY2VcbiAgICAgICAqIEBtZW1iZXJvZiBSb3RhdGVSZWNvZ25pemVyXG4gICAgICAgKi9cbiAgICAgIGRlZmF1bHRzOiB7XG4gICAgICAgICAgZXZlbnQ6ICdyb3RhdGUnLFxuICAgICAgICAgIHRocmVzaG9sZDogMCxcbiAgICAgICAgICBwb2ludGVyczogMlxuICAgICAgfSxcblxuICAgICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX05PTkVdO1xuICAgICAgfSxcblxuICAgICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3N1cGVyLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmXG4gICAgICAgICAgICAgIChNYXRoLmFicyhpbnB1dC5yb3RhdGlvbikgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkIHx8IHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTik7XG4gICAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBTd2lwZVxuICAgKiBSZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgbW92aW5nIGZhc3QgKHZlbG9jaXR5KSwgd2l0aCBlbm91Z2ggZGlzdGFuY2UgaW4gdGhlIGFsbG93ZWQgZGlyZWN0aW9uLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAgICovXG4gIGZ1bmN0aW9uIFN3aXBlUmVjb2duaXplcigpIHtcbiAgICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBpbmhlcml0KFN3aXBlUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAgIC8qKlxuICAgICAgICogQG5hbWVzcGFjZVxuICAgICAgICogQG1lbWJlcm9mIFN3aXBlUmVjb2duaXplclxuICAgICAgICovXG4gICAgICBkZWZhdWx0czoge1xuICAgICAgICAgIGV2ZW50OiAnc3dpcGUnLFxuICAgICAgICAgIHRocmVzaG9sZDogMTAsXG4gICAgICAgICAgdmVsb2NpdHk6IDAuMyxcbiAgICAgICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMLFxuICAgICAgICAgIHBvaW50ZXJzOiAxXG4gICAgICB9LFxuXG4gICAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIFBhblJlY29nbml6ZXIucHJvdG90eXBlLmdldFRvdWNoQWN0aW9uLmNhbGwodGhpcyk7XG4gICAgICB9LFxuXG4gICAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgICAgICAgICB2YXIgdmVsb2NpdHk7XG5cbiAgICAgICAgICBpZiAoZGlyZWN0aW9uICYgKERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMKSkge1xuICAgICAgICAgICAgICB2ZWxvY2l0eSA9IGlucHV0Lm92ZXJhbGxWZWxvY2l0eTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XG4gICAgICAgICAgICAgIHZlbG9jaXR5ID0gaW5wdXQub3ZlcmFsbFZlbG9jaXR5WDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkge1xuICAgICAgICAgICAgICB2ZWxvY2l0eSA9IGlucHV0Lm92ZXJhbGxWZWxvY2l0eVk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3N1cGVyLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmXG4gICAgICAgICAgICAgIGRpcmVjdGlvbiAmIGlucHV0Lm9mZnNldERpcmVjdGlvbiAmJlxuICAgICAgICAgICAgICBpbnB1dC5kaXN0YW5jZSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgJiZcbiAgICAgICAgICAgICAgaW5wdXQubWF4UG9pbnRlcnMgPT0gdGhpcy5vcHRpb25zLnBvaW50ZXJzICYmXG4gICAgICAgICAgICAgIGFicyh2ZWxvY2l0eSkgPiB0aGlzLm9wdGlvbnMudmVsb2NpdHkgJiYgaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfRU5EO1xuICAgICAgfSxcblxuICAgICAgZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gZGlyZWN0aW9uU3RyKGlucHV0Lm9mZnNldERpcmVjdGlvbik7XG4gICAgICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQgKyBkaXJlY3Rpb24sIGlucHV0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIGlucHV0KTtcbiAgICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEEgdGFwIGlzIGVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvaW5nIGEgc21hbGwgdGFwL2NsaWNrLiBNdWx0aXBsZSB0YXBzIGFyZSByZWNvZ25pemVkIGlmIHRoZXkgb2NjdXJcbiAgICogYmV0d2VlbiB0aGUgZ2l2ZW4gaW50ZXJ2YWwgYW5kIHBvc2l0aW9uLiBUaGUgZGVsYXkgb3B0aW9uIGNhbiBiZSB1c2VkIHRvIHJlY29nbml6ZSBtdWx0aS10YXBzIHdpdGhvdXQgZmlyaW5nXG4gICAqIGEgc2luZ2xlIHRhcC5cbiAgICpcbiAgICogVGhlIGV2ZW50RGF0YSBmcm9tIHRoZSBlbWl0dGVkIGV2ZW50IGNvbnRhaW5zIHRoZSBwcm9wZXJ0eSBgdGFwQ291bnRgLCB3aGljaCBjb250YWlucyB0aGUgYW1vdW50IG9mXG4gICAqIG11bHRpLXRhcHMgYmVpbmcgcmVjb2duaXplZC5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAgICovXG4gIGZ1bmN0aW9uIFRhcFJlY29nbml6ZXIoKSB7XG4gICAgICBSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgIC8vIHByZXZpb3VzIHRpbWUgYW5kIGNlbnRlcixcbiAgICAgIC8vIHVzZWQgZm9yIHRhcCBjb3VudGluZ1xuICAgICAgdGhpcy5wVGltZSA9IGZhbHNlO1xuICAgICAgdGhpcy5wQ2VudGVyID0gZmFsc2U7XG5cbiAgICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICAgIHRoaXMuX2lucHV0ID0gbnVsbDtcbiAgICAgIHRoaXMuY291bnQgPSAwO1xuICB9XG5cbiAgaW5oZXJpdChUYXBSZWNvZ25pemVyLCBSZWNvZ25pemVyLCB7XG4gICAgICAvKipcbiAgICAgICAqIEBuYW1lc3BhY2VcbiAgICAgICAqIEBtZW1iZXJvZiBQaW5jaFJlY29nbml6ZXJcbiAgICAgICAqL1xuICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgICBldmVudDogJ3RhcCcsXG4gICAgICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICAgICAgdGFwczogMSxcbiAgICAgICAgICBpbnRlcnZhbDogMzAwLCAvLyBtYXggdGltZSBiZXR3ZWVuIHRoZSBtdWx0aS10YXAgdGFwc1xuICAgICAgICAgIHRpbWU6IDI1MCwgLy8gbWF4IHRpbWUgb2YgdGhlIHBvaW50ZXIgdG8gYmUgZG93biAobGlrZSBmaW5nZXIgb24gdGhlIHNjcmVlbilcbiAgICAgICAgICB0aHJlc2hvbGQ6IDksIC8vIGEgbWluaW1hbCBtb3ZlbWVudCBpcyBvaywgYnV0IGtlZXAgaXQgbG93XG4gICAgICAgICAgcG9zVGhyZXNob2xkOiAxMCAvLyBhIG11bHRpLXRhcCBjYW4gYmUgYSBiaXQgb2ZmIHRoZSBpbml0aWFsIHBvc2l0aW9uXG4gICAgICB9LFxuXG4gICAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OXTtcbiAgICAgIH0sXG5cbiAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAgICAgICB2YXIgdmFsaWRQb2ludGVycyA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9ucy5wb2ludGVycztcbiAgICAgICAgICB2YXIgdmFsaWRNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgb3B0aW9ucy50aHJlc2hvbGQ7XG4gICAgICAgICAgdmFyIHZhbGlkVG91Y2hUaW1lID0gaW5wdXQuZGVsdGFUaW1lIDwgb3B0aW9ucy50aW1lO1xuXG4gICAgICAgICAgdGhpcy5yZXNldCgpO1xuXG4gICAgICAgICAgaWYgKChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9TVEFSVCkgJiYgKHRoaXMuY291bnQgPT09IDApKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmZhaWxUaW1lb3V0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gd2Ugb25seSBhbGxvdyBsaXR0bGUgbW92ZW1lbnRcbiAgICAgICAgICAvLyBhbmQgd2UndmUgcmVhY2hlZCBhbiBlbmQgZXZlbnQsIHNvIGEgdGFwIGlzIHBvc3NpYmxlXG4gICAgICAgICAgaWYgKHZhbGlkTW92ZW1lbnQgJiYgdmFsaWRUb3VjaFRpbWUgJiYgdmFsaWRQb2ludGVycykge1xuICAgICAgICAgICAgICBpZiAoaW5wdXQuZXZlbnRUeXBlICE9IElOUFVUX0VORCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmFpbFRpbWVvdXQoKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciB2YWxpZEludGVydmFsID0gdGhpcy5wVGltZSA/IChpbnB1dC50aW1lU3RhbXAgLSB0aGlzLnBUaW1lIDwgb3B0aW9ucy5pbnRlcnZhbCkgOiB0cnVlO1xuICAgICAgICAgICAgICB2YXIgdmFsaWRNdWx0aVRhcCA9ICF0aGlzLnBDZW50ZXIgfHwgZ2V0RGlzdGFuY2UodGhpcy5wQ2VudGVyLCBpbnB1dC5jZW50ZXIpIDwgb3B0aW9ucy5wb3NUaHJlc2hvbGQ7XG5cbiAgICAgICAgICAgICAgdGhpcy5wVGltZSA9IGlucHV0LnRpbWVTdGFtcDtcbiAgICAgICAgICAgICAgdGhpcy5wQ2VudGVyID0gaW5wdXQuY2VudGVyO1xuXG4gICAgICAgICAgICAgIGlmICghdmFsaWRNdWx0aVRhcCB8fCAhdmFsaWRJbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5jb3VudCA9IDE7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmNvdW50ICs9IDE7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLl9pbnB1dCA9IGlucHV0O1xuXG4gICAgICAgICAgICAgIC8vIGlmIHRhcCBjb3VudCBtYXRjaGVzIHdlIGhhdmUgcmVjb2duaXplZCBpdCxcbiAgICAgICAgICAgICAgLy8gZWxzZSBpdCBoYXMgYmVnYW4gcmVjb2duaXppbmcuLi5cbiAgICAgICAgICAgICAgdmFyIHRhcENvdW50ID0gdGhpcy5jb3VudCAlIG9wdGlvbnMudGFwcztcbiAgICAgICAgICAgICAgaWYgKHRhcENvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAvLyBubyBmYWlsaW5nIHJlcXVpcmVtZW50cywgaW1tZWRpYXRlbHkgdHJpZ2dlciB0aGUgdGFwIGV2ZW50XG4gICAgICAgICAgICAgICAgICAvLyBvciB3YWl0IGFzIGxvbmcgYXMgdGhlIG11bHRpdGFwIGludGVydmFsIHRvIHRyaWdnZXJcbiAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXNSZXF1aXJlRmFpbHVyZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXRDb250ZXh0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cnlFbWl0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgfSwgb3B0aW9ucy5pbnRlcnZhbCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX0JFR0FOO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gICAgICB9LFxuXG4gICAgICBmYWlsVGltZW91dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0Q29udGV4dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcbiAgICAgICAgICB9LCB0aGlzLm9wdGlvbnMuaW50ZXJ2YWwsIHRoaXMpO1xuICAgICAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gICAgICB9LFxuXG4gICAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgICAgIH0sXG5cbiAgICAgIGVtaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09IFNUQVRFX1JFQ09HTklaRUQpIHtcbiAgICAgICAgICAgICAgdGhpcy5faW5wdXQudGFwQ291bnQgPSB0aGlzLmNvdW50O1xuICAgICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIHRoaXMuX2lucHV0KTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBTaW1wbGUgd2F5IHRvIGNyZWF0ZSBhIG1hbmFnZXIgd2l0aCBhIGRlZmF1bHQgc2V0IG9mIHJlY29nbml6ZXJzLlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBIYW1tZXIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICBvcHRpb25zLnJlY29nbml6ZXJzID0gaWZVbmRlZmluZWQob3B0aW9ucy5yZWNvZ25pemVycywgSGFtbWVyLmRlZmF1bHRzLnByZXNldCk7XG4gICAgICByZXR1cm4gbmV3IE1hbmFnZXIoZWxlbWVudCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQGNvbnN0IHtzdHJpbmd9XG4gICAqL1xuICBIYW1tZXIuVkVSU0lPTiA9ICcyLjAuNic7XG5cbiAgLyoqXG4gICAqIGRlZmF1bHQgc2V0dGluZ3NcbiAgICogQG5hbWVzcGFjZVxuICAgKi9cbiAgSGFtbWVyLmRlZmF1bHRzID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBzZXQgaWYgRE9NIGV2ZW50cyBhcmUgYmVpbmcgdHJpZ2dlcmVkLlxuICAgICAgICogQnV0IHRoaXMgaXMgc2xvd2VyIGFuZCB1bnVzZWQgYnkgc2ltcGxlIGltcGxlbWVudGF0aW9ucywgc28gZGlzYWJsZWQgYnkgZGVmYXVsdC5cbiAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAqL1xuICAgICAgZG9tRXZlbnRzOiBmYWxzZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgdmFsdWUgZm9yIHRoZSB0b3VjaEFjdGlvbiBwcm9wZXJ0eS9mYWxsYmFjay5cbiAgICAgICAqIFdoZW4gc2V0IHRvIGBjb21wdXRlYCBpdCB3aWxsIG1hZ2ljYWxseSBzZXQgdGhlIGNvcnJlY3QgdmFsdWUgYmFzZWQgb24gdGhlIGFkZGVkIHJlY29nbml6ZXJzLlxuICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAqIEBkZWZhdWx0IGNvbXB1dGVcbiAgICAgICAqL1xuICAgICAgdG91Y2hBY3Rpb246IFRPVUNIX0FDVElPTl9DT01QVVRFLFxuXG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICovXG4gICAgICBlbmFibGU6IHRydWUsXG5cbiAgICAgIC8qKlxuICAgICAgICogRVhQRVJJTUVOVEFMIEZFQVRVUkUgLS0gY2FuIGJlIHJlbW92ZWQvY2hhbmdlZFxuICAgICAgICogQ2hhbmdlIHRoZSBwYXJlbnQgaW5wdXQgdGFyZ2V0IGVsZW1lbnQuXG4gICAgICAgKiBJZiBOdWxsLCB0aGVuIGl0IGlzIGJlaW5nIHNldCB0aGUgdG8gbWFpbiBlbGVtZW50LlxuICAgICAgICogQHR5cGUge051bGx8RXZlbnRUYXJnZXR9XG4gICAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICAgKi9cbiAgICAgIGlucHV0VGFyZ2V0OiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICAqIGZvcmNlIGFuIGlucHV0IGNsYXNzXG4gICAgICAgKiBAdHlwZSB7TnVsbHxGdW5jdGlvbn1cbiAgICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgICAqL1xuICAgICAgaW5wdXRDbGFzczogbnVsbCxcblxuICAgICAgLyoqXG4gICAgICAgKiBEZWZhdWx0IHJlY29nbml6ZXIgc2V0dXAgd2hlbiBjYWxsaW5nIGBIYW1tZXIoKWBcbiAgICAgICAqIFdoZW4gY3JlYXRpbmcgYSBuZXcgTWFuYWdlciB0aGVzZSB3aWxsIGJlIHNraXBwZWQuXG4gICAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICAgKi9cbiAgICAgIHByZXNldDogW1xuICAgICAgICAgIC8vIFJlY29nbml6ZXJDbGFzcywgb3B0aW9ucywgW3JlY29nbml6ZVdpdGgsIC4uLl0sIFtyZXF1aXJlRmFpbHVyZSwgLi4uXVxuICAgICAgICAgIFtSb3RhdGVSZWNvZ25pemVyLCB7ZW5hYmxlOiBmYWxzZX1dLFxuICAgICAgICAgIFtQaW5jaFJlY29nbml6ZXIsIHtlbmFibGU6IGZhbHNlfSwgWydyb3RhdGUnXV0sXG4gICAgICAgICAgW1N3aXBlUmVjb2duaXplciwge2RpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUx9XSxcbiAgICAgICAgICBbUGFuUmVjb2duaXplciwge2RpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUx9LCBbJ3N3aXBlJ11dLFxuICAgICAgICAgIFtUYXBSZWNvZ25pemVyXSxcbiAgICAgICAgICBbVGFwUmVjb2duaXplciwge2V2ZW50OiAnZG91YmxldGFwJywgdGFwczogMn0sIFsndGFwJ11dLFxuICAgICAgICAgIFtQcmVzc1JlY29nbml6ZXJdXG4gICAgICBdLFxuXG4gICAgICAvKipcbiAgICAgICAqIFNvbWUgQ1NTIHByb3BlcnRpZXMgY2FuIGJlIHVzZWQgdG8gaW1wcm92ZSB0aGUgd29ya2luZyBvZiBIYW1tZXIuXG4gICAgICAgKiBBZGQgdGhlbSB0byB0aGlzIG1ldGhvZCBhbmQgdGhleSB3aWxsIGJlIHNldCB3aGVuIGNyZWF0aW5nIGEgbmV3IE1hbmFnZXIuXG4gICAgICAgKiBAbmFtZXNwYWNlXG4gICAgICAgKi9cbiAgICAgIGNzc1Byb3BzOiB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogRGlzYWJsZXMgdGV4dCBzZWxlY3Rpb24gdG8gaW1wcm92ZSB0aGUgZHJhZ2dpbmcgZ2VzdHVyZS4gTWFpbmx5IGZvciBkZXNrdG9wIGJyb3dzZXJzLlxuICAgICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgICAgICovXG4gICAgICAgICAgdXNlclNlbGVjdDogJ25vbmUnLFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogRGlzYWJsZSB0aGUgV2luZG93cyBQaG9uZSBncmlwcGVycyB3aGVuIHByZXNzaW5nIGFuIGVsZW1lbnQuXG4gICAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICAgKi9cbiAgICAgICAgICB0b3VjaFNlbGVjdDogJ25vbmUnLFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogRGlzYWJsZXMgdGhlIGRlZmF1bHQgY2FsbG91dCBzaG93biB3aGVuIHlvdSB0b3VjaCBhbmQgaG9sZCBhIHRvdWNoIHRhcmdldC5cbiAgICAgICAgICAgKiBPbiBpT1MsIHdoZW4geW91IHRvdWNoIGFuZCBob2xkIGEgdG91Y2ggdGFyZ2V0IHN1Y2ggYXMgYSBsaW5rLCBTYWZhcmkgZGlzcGxheXNcbiAgICAgICAgICAgKiBhIGNhbGxvdXQgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbGluay4gVGhpcyBwcm9wZXJ0eSBhbGxvd3MgeW91IHRvIGRpc2FibGUgdGhhdCBjYWxsb3V0LlxuICAgICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgICAgICovXG4gICAgICAgICAgdG91Y2hDYWxsb3V0OiAnbm9uZScsXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBTcGVjaWZpZXMgd2hldGhlciB6b29taW5nIGlzIGVuYWJsZWQuIFVzZWQgYnkgSUUxMD5cbiAgICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICAgICAqL1xuICAgICAgICAgIGNvbnRlbnRab29taW5nOiAnbm9uZScsXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBTcGVjaWZpZXMgdGhhdCBhbiBlbnRpcmUgZWxlbWVudCBzaG91bGQgYmUgZHJhZ2dhYmxlIGluc3RlYWQgb2YgaXRzIGNvbnRlbnRzLiBNYWlubHkgZm9yIGRlc2t0b3AgYnJvd3NlcnMuXG4gICAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICAgKi9cbiAgICAgICAgICB1c2VyRHJhZzogJ25vbmUnLFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogT3ZlcnJpZGVzIHRoZSBoaWdobGlnaHQgY29sb3Igc2hvd24gd2hlbiB0aGUgdXNlciB0YXBzIGEgbGluayBvciBhIEphdmFTY3JpcHRcbiAgICAgICAgICAgKiBjbGlja2FibGUgZWxlbWVudCBpbiBpT1MuIFRoaXMgcHJvcGVydHkgb2JleXMgdGhlIGFscGhhIHZhbHVlLCBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICAgKiBAZGVmYXVsdCAncmdiYSgwLDAsMCwwKSdcbiAgICAgICAgICAgKi9cbiAgICAgICAgICB0YXBIaWdobGlnaHRDb2xvcjogJ3JnYmEoMCwwLDAsMCknXG4gICAgICB9XG4gIH07XG5cbiAgdmFyIFNUT1AgPSAxO1xuICB2YXIgRk9SQ0VEX1NUT1AgPSAyO1xuXG4gIC8qKlxuICAgKiBNYW5hZ2VyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIE1hbmFnZXIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gYXNzaWduKHt9LCBIYW1tZXIuZGVmYXVsdHMsIG9wdGlvbnMgfHwge30pO1xuXG4gICAgICB0aGlzLm9wdGlvbnMuaW5wdXRUYXJnZXQgPSB0aGlzLm9wdGlvbnMuaW5wdXRUYXJnZXQgfHwgZWxlbWVudDtcblxuICAgICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgICAgdGhpcy5zZXNzaW9uID0ge307XG4gICAgICB0aGlzLnJlY29nbml6ZXJzID0gW107XG5cbiAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLmlucHV0ID0gY3JlYXRlSW5wdXRJbnN0YW5jZSh0aGlzKTtcbiAgICAgIHRoaXMudG91Y2hBY3Rpb24gPSBuZXcgVG91Y2hBY3Rpb24odGhpcywgdGhpcy5vcHRpb25zLnRvdWNoQWN0aW9uKTtcblxuICAgICAgdG9nZ2xlQ3NzUHJvcHModGhpcywgdHJ1ZSk7XG5cbiAgICAgIGVhY2godGhpcy5vcHRpb25zLnJlY29nbml6ZXJzLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgdmFyIHJlY29nbml6ZXIgPSB0aGlzLmFkZChuZXcgKGl0ZW1bMF0pKGl0ZW1bMV0pKTtcbiAgICAgICAgICBpdGVtWzJdICYmIHJlY29nbml6ZXIucmVjb2duaXplV2l0aChpdGVtWzJdKTtcbiAgICAgICAgICBpdGVtWzNdICYmIHJlY29nbml6ZXIucmVxdWlyZUZhaWx1cmUoaXRlbVszXSk7XG4gICAgICB9LCB0aGlzKTtcbiAgfVxuXG4gIE1hbmFnZXIucHJvdG90eXBlID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBzZXQgb3B0aW9uc1xuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgICAqIEByZXR1cm5zIHtNYW5hZ2VyfVxuICAgICAgICovXG4gICAgICBzZXQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICBhc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgICAgIC8vIE9wdGlvbnMgdGhhdCBuZWVkIGEgbGl0dGxlIG1vcmUgc2V0dXBcbiAgICAgICAgICBpZiAob3B0aW9ucy50b3VjaEFjdGlvbikge1xuICAgICAgICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3B0aW9ucy5pbnB1dFRhcmdldCkge1xuICAgICAgICAgICAgICAvLyBDbGVhbiB1cCBleGlzdGluZyBldmVudCBsaXN0ZW5lcnMgYW5kIHJlaW5pdGlhbGl6ZVxuICAgICAgICAgICAgICB0aGlzLmlucHV0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgdGhpcy5pbnB1dC50YXJnZXQgPSBvcHRpb25zLmlucHV0VGFyZ2V0O1xuICAgICAgICAgICAgICB0aGlzLmlucHV0LmluaXQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIHN0b3AgcmVjb2duaXppbmcgZm9yIHRoaXMgc2Vzc2lvbi5cbiAgICAgICAqIFRoaXMgc2Vzc2lvbiB3aWxsIGJlIGRpc2NhcmRlZCwgd2hlbiBhIG5ldyBbaW5wdXRdc3RhcnQgZXZlbnQgaXMgZmlyZWQuXG4gICAgICAgKiBXaGVuIGZvcmNlZCwgdGhlIHJlY29nbml6ZXIgY3ljbGUgaXMgc3RvcHBlZCBpbW1lZGlhdGVseS5cbiAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZvcmNlXVxuICAgICAgICovXG4gICAgICBzdG9wOiBmdW5jdGlvbihmb3JjZSkge1xuICAgICAgICAgIHRoaXMuc2Vzc2lvbi5zdG9wcGVkID0gZm9yY2UgPyBGT1JDRURfU1RPUCA6IFNUT1A7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIHJ1biB0aGUgcmVjb2duaXplcnMhXG4gICAgICAgKiBjYWxsZWQgYnkgdGhlIGlucHV0SGFuZGxlciBmdW5jdGlvbiBvbiBldmVyeSBtb3ZlbWVudCBvZiB0aGUgcG9pbnRlcnMgKHRvdWNoZXMpXG4gICAgICAgKiBpdCB3YWxrcyB0aHJvdWdoIGFsbCB0aGUgcmVjb2duaXplcnMgYW5kIHRyaWVzIHRvIGRldGVjdCB0aGUgZ2VzdHVyZSB0aGF0IGlzIGJlaW5nIG1hZGVcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgICAqL1xuICAgICAgcmVjb2duaXplOiBmdW5jdGlvbihpbnB1dERhdGEpIHtcbiAgICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcbiAgICAgICAgICBpZiAoc2Vzc2lvbi5zdG9wcGVkKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBydW4gdGhlIHRvdWNoLWFjdGlvbiBwb2x5ZmlsbFxuICAgICAgICAgIHRoaXMudG91Y2hBY3Rpb24ucHJldmVudERlZmF1bHRzKGlucHV0RGF0YSk7XG5cbiAgICAgICAgICB2YXIgcmVjb2duaXplcjtcbiAgICAgICAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzO1xuXG4gICAgICAgICAgLy8gdGhpcyBob2xkcyB0aGUgcmVjb2duaXplciB0aGF0IGlzIGJlaW5nIHJlY29nbml6ZWQuXG4gICAgICAgICAgLy8gc28gdGhlIHJlY29nbml6ZXIncyBzdGF0ZSBuZWVkcyB0byBiZSBCRUdBTiwgQ0hBTkdFRCwgRU5ERUQgb3IgUkVDT0dOSVpFRFxuICAgICAgICAgIC8vIGlmIG5vIHJlY29nbml6ZXIgaXMgZGV0ZWN0aW5nIGEgdGhpbmcsIGl0IGlzIHNldCB0byBgbnVsbGBcbiAgICAgICAgICB2YXIgY3VyUmVjb2duaXplciA9IHNlc3Npb24uY3VyUmVjb2duaXplcjtcblxuICAgICAgICAgIC8vIHJlc2V0IHdoZW4gdGhlIGxhc3QgcmVjb2duaXplciBpcyByZWNvZ25pemVkXG4gICAgICAgICAgLy8gb3Igd2hlbiB3ZSdyZSBpbiBhIG5ldyBzZXNzaW9uXG4gICAgICAgICAgaWYgKCFjdXJSZWNvZ25pemVyIHx8IChjdXJSZWNvZ25pemVyICYmIGN1clJlY29nbml6ZXIuc3RhdGUgJiBTVEFURV9SRUNPR05JWkVEKSkge1xuICAgICAgICAgICAgICBjdXJSZWNvZ25pemVyID0gc2Vzc2lvbi5jdXJSZWNvZ25pemVyID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgd2hpbGUgKGkgPCByZWNvZ25pemVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVjb2duaXplciA9IHJlY29nbml6ZXJzW2ldO1xuXG4gICAgICAgICAgICAgIC8vIGZpbmQgb3V0IGlmIHdlIGFyZSBhbGxvd2VkIHRyeSB0byByZWNvZ25pemUgdGhlIGlucHV0IGZvciB0aGlzIG9uZS5cbiAgICAgICAgICAgICAgLy8gMS4gICBhbGxvdyBpZiB0aGUgc2Vzc2lvbiBpcyBOT1QgZm9yY2VkIHN0b3BwZWQgKHNlZSB0aGUgLnN0b3AoKSBtZXRob2QpXG4gICAgICAgICAgICAgIC8vIDIuICAgYWxsb3cgaWYgd2Ugc3RpbGwgaGF2ZW4ndCByZWNvZ25pemVkIGEgZ2VzdHVyZSBpbiB0aGlzIHNlc3Npb24sIG9yIHRoZSB0aGlzIHJlY29nbml6ZXIgaXMgdGhlIG9uZVxuICAgICAgICAgICAgICAvLyAgICAgIHRoYXQgaXMgYmVpbmcgcmVjb2duaXplZC5cbiAgICAgICAgICAgICAgLy8gMy4gICBhbGxvdyBpZiB0aGUgcmVjb2duaXplciBpcyBhbGxvd2VkIHRvIHJ1biBzaW11bHRhbmVvdXMgd2l0aCB0aGUgY3VycmVudCByZWNvZ25pemVkIHJlY29nbml6ZXIuXG4gICAgICAgICAgICAgIC8vICAgICAgdGhpcyBjYW4gYmUgc2V0dXAgd2l0aCB0aGUgYHJlY29nbml6ZVdpdGgoKWAgbWV0aG9kIG9uIHRoZSByZWNvZ25pemVyLlxuICAgICAgICAgICAgICBpZiAoc2Vzc2lvbi5zdG9wcGVkICE9PSBGT1JDRURfU1RPUCAmJiAoIC8vIDFcbiAgICAgICAgICAgICAgICAgICAgICAhY3VyUmVjb2duaXplciB8fCByZWNvZ25pemVyID09IGN1clJlY29nbml6ZXIgfHwgLy8gMlxuICAgICAgICAgICAgICAgICAgICAgIHJlY29nbml6ZXIuY2FuUmVjb2duaXplV2l0aChjdXJSZWNvZ25pemVyKSkpIHsgLy8gM1xuICAgICAgICAgICAgICAgICAgcmVjb2duaXplci5yZWNvZ25pemUoaW5wdXREYXRhKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJlY29nbml6ZXIucmVzZXQoKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIGlmIHRoZSByZWNvZ25pemVyIGhhcyBiZWVuIHJlY29nbml6aW5nIHRoZSBpbnB1dCBhcyBhIHZhbGlkIGdlc3R1cmUsIHdlIHdhbnQgdG8gc3RvcmUgdGhpcyBvbmUgYXMgdGhlXG4gICAgICAgICAgICAgIC8vIGN1cnJlbnQgYWN0aXZlIHJlY29nbml6ZXIuIGJ1dCBvbmx5IGlmIHdlIGRvbid0IGFscmVhZHkgaGF2ZSBhbiBhY3RpdmUgcmVjb2duaXplclxuICAgICAgICAgICAgICBpZiAoIWN1clJlY29nbml6ZXIgJiYgcmVjb2duaXplci5zdGF0ZSAmIChTVEFURV9CRUdBTiB8IFNUQVRFX0NIQU5HRUQgfCBTVEFURV9FTkRFRCkpIHtcbiAgICAgICAgICAgICAgICAgIGN1clJlY29nbml6ZXIgPSBzZXNzaW9uLmN1clJlY29nbml6ZXIgPSByZWNvZ25pemVyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIGdldCBhIHJlY29nbml6ZXIgYnkgaXRzIGV2ZW50IG5hbWUuXG4gICAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSByZWNvZ25pemVyXG4gICAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcnxOdWxsfVxuICAgICAgICovXG4gICAgICBnZXQ6IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICAgICAgICBpZiAocmVjb2duaXplciBpbnN0YW5jZW9mIFJlY29nbml6ZXIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlY29nbml6ZXI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJlY29nbml6ZXJzID0gdGhpcy5yZWNvZ25pemVycztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlY29nbml6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmIChyZWNvZ25pemVyc1tpXS5vcHRpb25zLmV2ZW50ID09IHJlY29nbml6ZXIpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZWNvZ25pemVyc1tpXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogYWRkIGEgcmVjb2duaXplciB0byB0aGUgbWFuYWdlclxuICAgICAgICogZXhpc3RpbmcgcmVjb2duaXplcnMgd2l0aCB0aGUgc2FtZSBldmVudCBuYW1lIHdpbGwgYmUgcmVtb3ZlZFxuICAgICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSByZWNvZ25pemVyXG4gICAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcnxNYW5hZ2VyfVxuICAgICAgICovXG4gICAgICBhZGQ6IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcocmVjb2duaXplciwgJ2FkZCcsIHRoaXMpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHJlbW92ZSBleGlzdGluZ1xuICAgICAgICAgIHZhciBleGlzdGluZyA9IHRoaXMuZ2V0KHJlY29nbml6ZXIub3B0aW9ucy5ldmVudCk7XG4gICAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgICAgIHRoaXMucmVtb3ZlKGV4aXN0aW5nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnJlY29nbml6ZXJzLnB1c2gocmVjb2duaXplcik7XG4gICAgICAgICAgcmVjb2duaXplci5tYW5hZ2VyID0gdGhpcztcblxuICAgICAgICAgIHRoaXMudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgICAgICAgcmV0dXJuIHJlY29nbml6ZXI7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIHJlbW92ZSBhIHJlY29nbml6ZXIgYnkgbmFtZSBvciBpbnN0YW5jZVxuICAgICAgICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gcmVjb2duaXplclxuICAgICAgICogQHJldHVybnMge01hbmFnZXJ9XG4gICAgICAgKi9cbiAgICAgIHJlbW92ZTogZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhyZWNvZ25pemVyLCAncmVtb3ZlJywgdGhpcykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVjb2duaXplciA9IHRoaXMuZ2V0KHJlY29nbml6ZXIpO1xuXG4gICAgICAgICAgLy8gbGV0J3MgbWFrZSBzdXJlIHRoaXMgcmVjb2duaXplciBleGlzdHNcbiAgICAgICAgICBpZiAocmVjb2duaXplcikge1xuICAgICAgICAgICAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzO1xuICAgICAgICAgICAgICB2YXIgaW5kZXggPSBpbkFycmF5KHJlY29nbml6ZXJzLCByZWNvZ25pemVyKTtcblxuICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICByZWNvZ25pemVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBiaW5kIGV2ZW50XG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRzXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAgICAgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSB0aGlzXG4gICAgICAgKi9cbiAgICAgIG9uOiBmdW5jdGlvbihldmVudHMsIGhhbmRsZXIpIHtcbiAgICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzO1xuICAgICAgICAgIGVhY2goc3BsaXRTdHIoZXZlbnRzKSwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgaGFuZGxlcnNbZXZlbnRdID0gaGFuZGxlcnNbZXZlbnRdIHx8IFtdO1xuICAgICAgICAgICAgICBoYW5kbGVyc1tldmVudF0ucHVzaChoYW5kbGVyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogdW5iaW5kIGV2ZW50LCBsZWF2ZSBlbWl0IGJsYW5rIHRvIHJlbW92ZSBhbGwgaGFuZGxlcnNcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudHNcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtoYW5kbGVyXVxuICAgICAgICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gdGhpc1xuICAgICAgICovXG4gICAgICBvZmY6IGZ1bmN0aW9uKGV2ZW50cywgaGFuZGxlcikge1xuICAgICAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnM7XG4gICAgICAgICAgZWFjaChzcGxpdFN0cihldmVudHMpLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSBoYW5kbGVyc1tldmVudF07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBoYW5kbGVyc1tldmVudF0gJiYgaGFuZGxlcnNbZXZlbnRdLnNwbGljZShpbkFycmF5KGhhbmRsZXJzW2V2ZW50XSwgaGFuZGxlciksIDEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIGVtaXQgZXZlbnQgdG8gdGhlIGxpc3RlbmVyc1xuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAgICovXG4gICAgICBlbWl0OiBmdW5jdGlvbihldmVudCwgZGF0YSkge1xuICAgICAgICAgIC8vIHdlIGFsc28gd2FudCB0byB0cmlnZ2VyIGRvbSBldmVudHNcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRvbUV2ZW50cykge1xuICAgICAgICAgICAgICB0cmlnZ2VyRG9tRXZlbnQoZXZlbnQsIGRhdGEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIG5vIGhhbmRsZXJzLCBzbyBza2lwIGl0IGFsbFxuICAgICAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnNbZXZlbnRdICYmIHRoaXMuaGFuZGxlcnNbZXZlbnRdLnNsaWNlKCk7XG4gICAgICAgICAgaWYgKCFoYW5kbGVycyB8fCAhaGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkYXRhLnR5cGUgPSBldmVudDtcbiAgICAgICAgICBkYXRhLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGRhdGEuc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgIHdoaWxlIChpIDwgaGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGhhbmRsZXJzW2ldKGRhdGEpO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBkZXN0cm95IHRoZSBtYW5hZ2VyIGFuZCB1bmJpbmRzIGFsbCBldmVudHNcbiAgICAgICAqIGl0IGRvZXNuJ3QgdW5iaW5kIGRvbSBldmVudHMsIHRoYXQgaXMgdGhlIHVzZXIgb3duIHJlc3BvbnNpYmlsaXR5XG4gICAgICAgKi9cbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuZWxlbWVudCAmJiB0b2dnbGVDc3NQcm9wcyh0aGlzLCBmYWxzZSk7XG5cbiAgICAgICAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgICAgICAgdGhpcy5zZXNzaW9uID0ge307XG4gICAgICAgICAgdGhpcy5pbnB1dC5kZXN0cm95KCk7XG4gICAgICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogYWRkL3JlbW92ZSB0aGUgY3NzIHByb3BlcnRpZXMgYXMgZGVmaW5lZCBpbiBtYW5hZ2VyLm9wdGlvbnMuY3NzUHJvcHNcbiAgICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWRkXG4gICAqL1xuICBmdW5jdGlvbiB0b2dnbGVDc3NQcm9wcyhtYW5hZ2VyLCBhZGQpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gbWFuYWdlci5lbGVtZW50O1xuICAgICAgaWYgKCFlbGVtZW50LnN0eWxlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWFjaChtYW5hZ2VyLm9wdGlvbnMuY3NzUHJvcHMsIGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgICAgZWxlbWVudC5zdHlsZVtwcmVmaXhlZChlbGVtZW50LnN0eWxlLCBuYW1lKV0gPSBhZGQgPyB2YWx1ZSA6ICcnO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogdHJpZ2dlciBkb20gZXZlbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqL1xuICBmdW5jdGlvbiB0cmlnZ2VyRG9tRXZlbnQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBnZXN0dXJlRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgIGdlc3R1cmVFdmVudC5pbml0RXZlbnQoZXZlbnQsIHRydWUsIHRydWUpO1xuICAgICAgZ2VzdHVyZUV2ZW50Lmdlc3R1cmUgPSBkYXRhO1xuICAgICAgZGF0YS50YXJnZXQuZGlzcGF0Y2hFdmVudChnZXN0dXJlRXZlbnQpO1xuICB9XG5cbiAgYXNzaWduKEhhbW1lciwge1xuICAgICAgSU5QVVRfU1RBUlQ6IElOUFVUX1NUQVJULFxuICAgICAgSU5QVVRfTU9WRTogSU5QVVRfTU9WRSxcbiAgICAgIElOUFVUX0VORDogSU5QVVRfRU5ELFxuICAgICAgSU5QVVRfQ0FOQ0VMOiBJTlBVVF9DQU5DRUwsXG5cbiAgICAgIFNUQVRFX1BPU1NJQkxFOiBTVEFURV9QT1NTSUJMRSxcbiAgICAgIFNUQVRFX0JFR0FOOiBTVEFURV9CRUdBTixcbiAgICAgIFNUQVRFX0NIQU5HRUQ6IFNUQVRFX0NIQU5HRUQsXG4gICAgICBTVEFURV9FTkRFRDogU1RBVEVfRU5ERUQsXG4gICAgICBTVEFURV9SRUNPR05JWkVEOiBTVEFURV9SRUNPR05JWkVELFxuICAgICAgU1RBVEVfQ0FOQ0VMTEVEOiBTVEFURV9DQU5DRUxMRUQsXG4gICAgICBTVEFURV9GQUlMRUQ6IFNUQVRFX0ZBSUxFRCxcblxuICAgICAgRElSRUNUSU9OX05PTkU6IERJUkVDVElPTl9OT05FLFxuICAgICAgRElSRUNUSU9OX0xFRlQ6IERJUkVDVElPTl9MRUZULFxuICAgICAgRElSRUNUSU9OX1JJR0hUOiBESVJFQ1RJT05fUklHSFQsXG4gICAgICBESVJFQ1RJT05fVVA6IERJUkVDVElPTl9VUCxcbiAgICAgIERJUkVDVElPTl9ET1dOOiBESVJFQ1RJT05fRE9XTixcbiAgICAgIERJUkVDVElPTl9IT1JJWk9OVEFMOiBESVJFQ1RJT05fSE9SSVpPTlRBTCxcbiAgICAgIERJUkVDVElPTl9WRVJUSUNBTDogRElSRUNUSU9OX1ZFUlRJQ0FMLFxuICAgICAgRElSRUNUSU9OX0FMTDogRElSRUNUSU9OX0FMTCxcblxuICAgICAgTWFuYWdlcjogTWFuYWdlcixcbiAgICAgIElucHV0OiBJbnB1dCxcbiAgICAgIFRvdWNoQWN0aW9uOiBUb3VjaEFjdGlvbixcblxuICAgICAgVG91Y2hJbnB1dDogVG91Y2hJbnB1dCxcbiAgICAgIE1vdXNlSW5wdXQ6IE1vdXNlSW5wdXQsXG4gICAgICBQb2ludGVyRXZlbnRJbnB1dDogUG9pbnRlckV2ZW50SW5wdXQsXG4gICAgICBUb3VjaE1vdXNlSW5wdXQ6IFRvdWNoTW91c2VJbnB1dCxcbiAgICAgIFNpbmdsZVRvdWNoSW5wdXQ6IFNpbmdsZVRvdWNoSW5wdXQsXG5cbiAgICAgIFJlY29nbml6ZXI6IFJlY29nbml6ZXIsXG4gICAgICBBdHRyUmVjb2duaXplcjogQXR0clJlY29nbml6ZXIsXG4gICAgICBUYXA6IFRhcFJlY29nbml6ZXIsXG4gICAgICBQYW46IFBhblJlY29nbml6ZXIsXG4gICAgICBTd2lwZTogU3dpcGVSZWNvZ25pemVyLFxuICAgICAgUGluY2g6IFBpbmNoUmVjb2duaXplcixcbiAgICAgIFJvdGF0ZTogUm90YXRlUmVjb2duaXplcixcbiAgICAgIFByZXNzOiBQcmVzc1JlY29nbml6ZXIsXG5cbiAgICAgIG9uOiBhZGRFdmVudExpc3RlbmVycyxcbiAgICAgIG9mZjogcmVtb3ZlRXZlbnRMaXN0ZW5lcnMsXG4gICAgICBlYWNoOiBlYWNoLFxuICAgICAgbWVyZ2U6IG1lcmdlLFxuICAgICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgICBhc3NpZ246IGFzc2lnbixcbiAgICAgIGluaGVyaXQ6IGluaGVyaXQsXG4gICAgICBiaW5kRm46IGJpbmRGbixcbiAgICAgIHByZWZpeGVkOiBwcmVmaXhlZFxuICB9KTtcblxuICAvLyB0aGlzIHByZXZlbnRzIGVycm9ycyB3aGVuIEhhbW1lciBpcyBsb2FkZWQgaW4gdGhlIHByZXNlbmNlIG9mIGFuIEFNRFxuICAvLyAgc3R5bGUgbG9hZGVyIGJ1dCBieSBzY3JpcHQgdGFnLCBub3QgYnkgdGhlIGxvYWRlci5cbiAgdmFyIGZyZWVHbG9iYWwgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9KSk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICBmcmVlR2xvYmFsLkhhbW1lciA9IEhhbW1lcjtcblxuICBpZiAodHJ1ZSkge1xuICAgICAgIShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBIYW1tZXI7XG4gICAgICB9LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gSGFtbWVyO1xuICB9IGVsc2Uge1xuICAgICAgd2luZG93W2V4cG9ydE5hbWVdID0gSGFtbWVyO1xuICB9XG5cbiAgfSkod2luZG93LCBkb2N1bWVudCwgJ0hhbW1lcicpO1xuXG5cbi8qKiovIH0sXG4vKiAyMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgdmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187XCJ1c2Ugc3RyaWN0XCI7XG4gIC8qKlxuICAgKiBDcmVhdGVkIGJ5IEFsZXggb24gMTEvNi8yMDE0LlxuICAgKi9cblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vdW1kanMvdW1kL2Jsb2IvbWFzdGVyL3JldHVybkV4cG9ydHMuanMjTDQwLUw2MFxuICAvLyBpZiB0aGUgbW9kdWxlIGhhcyBubyBkZXBlbmRlbmNpZXMsIHRoZSBhYm92ZSBwYXR0ZXJuIGNhbiBiZSBzaW1wbGlmaWVkIHRvXG4gIChmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICAgIGlmICh0cnVlKSB7XG4gICAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgICAhKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID0gKGZhY3RvcnkpLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9ICh0eXBlb2YgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID09PSAnZnVuY3Rpb24nID8gKF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXy5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSkgOiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18pLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIC8vIE5vZGUuIERvZXMgbm90IHdvcmsgd2l0aCBzdHJpY3QgQ29tbW9uSlMsIGJ1dFxuICAgICAgLy8gb25seSBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMsXG4gICAgICAvLyBsaWtlIE5vZGUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQnJvd3NlciBnbG9iYWxzIChyb290IGlzIHdpbmRvdylcbiAgICAgIHJvb3Qua2V5Y2hhcm0gPSBmYWN0b3J5KCk7XG4gICAgfVxuICB9KHRoaXMsIGZ1bmN0aW9uICgpIHtcblxuICAgIGZ1bmN0aW9uIGtleWNoYXJtKG9wdGlvbnMpIHtcbiAgICAgIHZhciBwcmV2ZW50RGVmYXVsdCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5wcmV2ZW50RGVmYXVsdCB8fCBmYWxzZTtcblxuICAgICAgdmFyIGNvbnRhaW5lciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jb250YWluZXIgfHwgd2luZG93O1xuXG4gICAgICB2YXIgX2V4cG9ydEZ1bmN0aW9ucyA9IHt9O1xuICAgICAgdmFyIF9ib3VuZCA9IHtrZXlkb3duOnt9LCBrZXl1cDp7fX07XG4gICAgICB2YXIgX2tleXMgPSB7fTtcbiAgICAgIHZhciBpO1xuXG4gICAgICAvLyBhIC0gelxuICAgICAgZm9yIChpID0gOTc7IGkgPD0gMTIyOyBpKyspIHtfa2V5c1tTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IHtjb2RlOjY1ICsgKGkgLSA5NyksIHNoaWZ0OiBmYWxzZX07fVxuICAgICAgLy8gQSAtIFpcbiAgICAgIGZvciAoaSA9IDY1OyBpIDw9IDkwOyBpKyspIHtfa2V5c1tTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IHtjb2RlOmksIHNoaWZ0OiB0cnVlfTt9XG4gICAgICAvLyAwIC0gOVxuICAgICAgZm9yIChpID0gMDsgIGkgPD0gOTsgICBpKyspIHtfa2V5c1snJyArIGldID0ge2NvZGU6NDggKyBpLCBzaGlmdDogZmFsc2V9O31cbiAgICAgIC8vIEYxIC0gRjEyXG4gICAgICBmb3IgKGkgPSAxOyAgaSA8PSAxMjsgICBpKyspIHtfa2V5c1snRicgKyBpXSA9IHtjb2RlOjExMSArIGksIHNoaWZ0OiBmYWxzZX07fVxuICAgICAgLy8gbnVtMCAtIG51bTlcbiAgICAgIGZvciAoaSA9IDA7ICBpIDw9IDk7ICAgaSsrKSB7X2tleXNbJ251bScgKyBpXSA9IHtjb2RlOjk2ICsgaSwgc2hpZnQ6IGZhbHNlfTt9XG5cbiAgICAgIC8vIG51bXBhZCBtaXNjXG4gICAgICBfa2V5c1snbnVtKiddID0ge2NvZGU6MTA2LCBzaGlmdDogZmFsc2V9O1xuICAgICAgX2tleXNbJ251bSsnXSA9IHtjb2RlOjEwNywgc2hpZnQ6IGZhbHNlfTtcbiAgICAgIF9rZXlzWydudW0tJ10gPSB7Y29kZToxMDksIHNoaWZ0OiBmYWxzZX07XG4gICAgICBfa2V5c1snbnVtLyddID0ge2NvZGU6MTExLCBzaGlmdDogZmFsc2V9O1xuICAgICAgX2tleXNbJ251bS4nXSA9IHtjb2RlOjExMCwgc2hpZnQ6IGZhbHNlfTtcbiAgICAgIC8vIGFycm93c1xuICAgICAgX2tleXNbJ2xlZnQnXSAgPSB7Y29kZTozNywgc2hpZnQ6IGZhbHNlfTtcbiAgICAgIF9rZXlzWyd1cCddICAgID0ge2NvZGU6MzgsIHNoaWZ0OiBmYWxzZX07XG4gICAgICBfa2V5c1sncmlnaHQnXSA9IHtjb2RlOjM5LCBzaGlmdDogZmFsc2V9O1xuICAgICAgX2tleXNbJ2Rvd24nXSAgPSB7Y29kZTo0MCwgc2hpZnQ6IGZhbHNlfTtcbiAgICAgIC8vIGV4dHJhIGtleXNcbiAgICAgIF9rZXlzWydzcGFjZSddID0ge2NvZGU6MzIsIHNoaWZ0OiBmYWxzZX07XG4gICAgICBfa2V5c1snZW50ZXInXSA9IHtjb2RlOjEzLCBzaGlmdDogZmFsc2V9O1xuICAgICAgX2tleXNbJ3NoaWZ0J10gPSB7Y29kZToxNiwgc2hpZnQ6IHVuZGVmaW5lZH07XG4gICAgICBfa2V5c1snZXNjJ10gICA9IHtjb2RlOjI3LCBzaGlmdDogZmFsc2V9O1xuICAgICAgX2tleXNbJ2JhY2tzcGFjZSddID0ge2NvZGU6OCwgc2hpZnQ6IGZhbHNlfTtcbiAgICAgIF9rZXlzWyd0YWInXSAgICAgICA9IHtjb2RlOjksIHNoaWZ0OiBmYWxzZX07XG4gICAgICBfa2V5c1snY3RybCddICAgICAgPSB7Y29kZToxNywgc2hpZnQ6IGZhbHNlfTtcbiAgICAgIF9rZXlzWydhbHQnXSAgICAgICA9IHtjb2RlOjE4LCBzaGlmdDogZmFsc2V9O1xuICAgICAgX2tleXNbJ2RlbGV0ZSddICAgID0ge2NvZGU6NDYsIHNoaWZ0OiBmYWxzZX07XG4gICAgICBfa2V5c1sncGFnZXVwJ10gICAgPSB7Y29kZTozMywgc2hpZnQ6IGZhbHNlfTtcbiAgICAgIF9rZXlzWydwYWdlZG93biddICA9IHtjb2RlOjM0LCBzaGlmdDogZmFsc2V9O1xuICAgICAgLy8gc3ltYm9sc1xuICAgICAgX2tleXNbJz0nXSAgICAgPSB7Y29kZToxODcsIHNoaWZ0OiBmYWxzZX07XG4gICAgICBfa2V5c1snLSddICAgICA9IHtjb2RlOjE4OSwgc2hpZnQ6IGZhbHNlfTtcbiAgICAgIF9rZXlzWyddJ10gICAgID0ge2NvZGU6MjIxLCBzaGlmdDogZmFsc2V9O1xuICAgICAgX2tleXNbJ1snXSAgICAgPSB7Y29kZToyMTksIHNoaWZ0OiBmYWxzZX07XG5cblxuXG4gICAgICB2YXIgZG93biA9IGZ1bmN0aW9uKGV2ZW50KSB7aGFuZGxlRXZlbnQoZXZlbnQsJ2tleWRvd24nKTt9O1xuICAgICAgdmFyIHVwID0gZnVuY3Rpb24oZXZlbnQpIHtoYW5kbGVFdmVudChldmVudCwna2V5dXAnKTt9O1xuXG4gICAgICAvLyBoYW5kbGUgdGhlIGFjdHVhbHkgYm91bmQga2V5IHdpdGggdGhlIGV2ZW50XG4gICAgICB2YXIgaGFuZGxlRXZlbnQgPSBmdW5jdGlvbihldmVudCx0eXBlKSB7XG4gICAgICAgIGlmIChfYm91bmRbdHlwZV1bZXZlbnQua2V5Q29kZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBib3VuZCA9IF9ib3VuZFt0eXBlXVtldmVudC5rZXlDb2RlXTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYm91bmRbaV0uc2hpZnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBib3VuZFtpXS5mbihldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChib3VuZFtpXS5zaGlmdCA9PSB0cnVlICYmIGV2ZW50LnNoaWZ0S2V5ID09IHRydWUpIHtcbiAgICAgICAgICAgICAgYm91bmRbaV0uZm4oZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYm91bmRbaV0uc2hpZnQgPT0gZmFsc2UgJiYgZXZlbnQuc2hpZnRLZXkgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgYm91bmRbaV0uZm4oZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwcmV2ZW50RGVmYXVsdCA9PSB0cnVlKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gYmluZCBhIGtleSB0byBhIGNhbGxiYWNrXG4gICAgICBfZXhwb3J0RnVuY3Rpb25zLmJpbmQgPSBmdW5jdGlvbihrZXksIGNhbGxiYWNrLCB0eXBlKSB7XG4gICAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0eXBlID0gJ2tleWRvd24nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfa2V5c1trZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBrZXk6IFwiICsga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2JvdW5kW3R5cGVdW19rZXlzW2tleV0uY29kZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIF9ib3VuZFt0eXBlXVtfa2V5c1trZXldLmNvZGVdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgX2JvdW5kW3R5cGVdW19rZXlzW2tleV0uY29kZV0ucHVzaCh7Zm46Y2FsbGJhY2ssIHNoaWZ0Ol9rZXlzW2tleV0uc2hpZnR9KTtcbiAgICAgIH07XG5cblxuICAgICAgLy8gYmluZCBhbGwga2V5cyB0byBhIGNhbGwgYmFjayAoZGVtbyBwdXJwb3NlcylcbiAgICAgIF9leHBvcnRGdW5jdGlvbnMuYmluZEFsbCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCB0eXBlKSB7XG4gICAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0eXBlID0gJ2tleWRvd24nO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBfa2V5cykge1xuICAgICAgICAgIGlmIChfa2V5cy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBfZXhwb3J0RnVuY3Rpb25zLmJpbmQoa2V5LGNhbGxiYWNrLHR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gZ2V0IHRoZSBrZXkgbGFiZWwgZnJvbSBhbiBldmVudFxuICAgICAgX2V4cG9ydEZ1bmN0aW9ucy5nZXRLZXkgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gX2tleXMpIHtcbiAgICAgICAgICBpZiAoX2tleXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5ID09IHRydWUgJiYgX2tleXNba2V5XS5zaGlmdCA9PSB0cnVlICYmIGV2ZW50LmtleUNvZGUgPT0gX2tleXNba2V5XS5jb2RlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5zaGlmdEtleSA9PSBmYWxzZSAmJiBfa2V5c1trZXldLnNoaWZ0ID09IGZhbHNlICYmIGV2ZW50LmtleUNvZGUgPT0gX2tleXNba2V5XS5jb2RlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXlDb2RlID09IF9rZXlzW2tleV0uY29kZSAmJiBrZXkgPT0gJ3NoaWZ0Jykge1xuICAgICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJ1bmtub3duIGtleSwgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWRcIjtcbiAgICAgIH07XG5cbiAgICAgIC8vIHVuYmluZCBlaXRoZXIgYSBzcGVjaWZpYyBjYWxsYmFjayBmcm9tIGEga2V5IG9yIGFsbCBvZiB0aGVtIChieSBsZWF2aW5nIGNhbGxiYWNrIHVuZGVmaW5lZClcbiAgICAgIF9leHBvcnRGdW5jdGlvbnMudW5iaW5kID0gZnVuY3Rpb24oa2V5LCBjYWxsYmFjaywgdHlwZSkge1xuICAgICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdHlwZSA9ICdrZXlkb3duJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2tleXNba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQga2V5OiBcIiArIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgbmV3QmluZGluZ3MgPSBbXTtcbiAgICAgICAgICB2YXIgYm91bmQgPSBfYm91bmRbdHlwZV1bX2tleXNba2V5XS5jb2RlXTtcbiAgICAgICAgICBpZiAoYm91bmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAoIShib3VuZFtpXS5mbiA9PSBjYWxsYmFjayAmJiBib3VuZFtpXS5zaGlmdCA9PSBfa2V5c1trZXldLnNoaWZ0KSkge1xuICAgICAgICAgICAgICAgIG5ld0JpbmRpbmdzLnB1c2goX2JvdW5kW3R5cGVdW19rZXlzW2tleV0uY29kZV1baV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIF9ib3VuZFt0eXBlXVtfa2V5c1trZXldLmNvZGVdID0gbmV3QmluZGluZ3M7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgX2JvdW5kW3R5cGVdW19rZXlzW2tleV0uY29kZV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gcmVzZXQgYWxsIGJvdW5kIHZhcmlhYmxlcy5cbiAgICAgIF9leHBvcnRGdW5jdGlvbnMucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgX2JvdW5kID0ge2tleWRvd246e30sIGtleXVwOnt9fTtcbiAgICAgIH07XG5cbiAgICAgIC8vIHVuYmluZCBhbGwgbGlzdGVuZXJzIGFuZCByZXNldCBhbGwgdmFyaWFibGVzLlxuICAgICAgX2V4cG9ydEZ1bmN0aW9ucy5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIF9ib3VuZCA9IHtrZXlkb3duOnt9LCBrZXl1cDp7fX07XG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZG93biwgdHJ1ZSk7XG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIHVwLCB0cnVlKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIGNyZWF0ZSBsaXN0ZW5lcnMuXG4gICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsZG93bix0cnVlKTtcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsdXAsdHJ1ZSk7XG5cbiAgICAgIC8vIHJldHVybiB0aGUgcHVibGljIGZ1bmN0aW9ucy5cbiAgICAgIHJldHVybiBfZXhwb3J0RnVuY3Rpb25zO1xuICAgIH1cblxuICAgIHJldHVybiBrZXljaGFybTtcbiAgfSkpO1xuXG5cblxuXG4vKioqLyB9LFxuLyogMjQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyB1dGlsc1xuICBleHBvcnRzLnV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuICBleHBvcnRzLkRPTXV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG4gIC8vIGRhdGFcbiAgZXhwb3J0cy5EYXRhU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcbiAgZXhwb3J0cy5EYXRhVmlldyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuICBleHBvcnRzLlF1ZXVlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cbiAgLy8gVGltZWxpbmVcbiAgZXhwb3J0cy5UaW1lbGluZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xuICBleHBvcnRzLkdyYXBoMmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwKTtcbiAgZXhwb3J0cy50aW1lbGluZSA9IHtcbiAgICBDb3JlOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKSxcbiAgICBEYXRlVXRpbDogX193ZWJwYWNrX3JlcXVpcmVfXygzMiksXG4gICAgUmFuZ2U6IF9fd2VicGFja19yZXF1aXJlX18oMzApLFxuICAgIHN0YWNrOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KSxcbiAgICBUaW1lU3RlcDogX193ZWJwYWNrX3JlcXVpcmVfXygzNSksXG5cbiAgICBjb21wb25lbnRzOiB7XG4gICAgICBpdGVtczoge1xuICAgICAgICBJdGVtOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KSxcbiAgICAgICAgQmFja2dyb3VuZEl0ZW06IF9fd2VicGFja19yZXF1aXJlX18oNDMpLFxuICAgICAgICBCb3hJdGVtOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKSxcbiAgICAgICAgUG9pbnRJdGVtOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKSxcbiAgICAgICAgUmFuZ2VJdGVtOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KVxuICAgICAgfSxcblxuICAgICAgQmFja2dyb3VuZEdyb3VwOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwKSxcbiAgICAgIENvbXBvbmVudDogX193ZWJwYWNrX3JlcXVpcmVfXygzMSksXG4gICAgICBDdXJyZW50VGltZTogX193ZWJwYWNrX3JlcXVpcmVfXyg0OCksXG4gICAgICBDdXN0b21UaW1lOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2KSxcbiAgICAgIERhdGFBeGlzOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyKSxcbiAgICAgIERhdGFTY2FsZTogX193ZWJwYWNrX3JlcXVpcmVfXyg1MyksXG4gICAgICBHcmFwaEdyb3VwOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDU0KSxcbiAgICAgIEdyb3VwOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KSxcbiAgICAgIEl0ZW1TZXQ6IF9fd2VicGFja19yZXF1aXJlX18oMzQpLFxuICAgICAgTGVnZW5kOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDU4KSxcbiAgICAgIExpbmVHcmFwaDogX193ZWJwYWNrX3JlcXVpcmVfXyg1MSksXG4gICAgICBUaW1lQXhpczogX193ZWJwYWNrX3JlcXVpcmVfXyg0NClcbiAgICB9XG4gIH07XG5cbiAgLy8gYnVuZGxlZCBleHRlcm5hbCBsaWJyYXJpZXNcbiAgZXhwb3J0cy5tb21lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuICBleHBvcnRzLkhhbW1lciA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuICBleHBvcnRzLmtleWNoYXJtID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5cbi8qKiovIH0sXG4vKiAyNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBfQ29uZmlndXJhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XG5cbiAgdmFyIF9Db25maWd1cmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ29uZmlndXJhdG9yKTtcblxuICB2YXIgX1ZhbGlkYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xuXG4gIHZhciBfVmFsaWRhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1ZhbGlkYXRvcik7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuICB2YXIgRW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuICB2YXIgSGFtbWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG4gIHZhciBtb21lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4gIHZhciBEYXRhU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcbiAgdmFyIERhdGFWaWV3ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG4gIHZhciBSYW5nZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzApO1xuICB2YXIgQ29yZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xuICB2YXIgVGltZUF4aXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KTtcbiAgdmFyIEN1cnJlbnRUaW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OCk7XG4gIHZhciBDdXN0b21UaW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nik7XG4gIHZhciBJdGVtU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XG5cbiAgdmFyIHByaW50U3R5bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KS5wcmludFN0eWxlO1xuICB2YXIgYWxsT3B0aW9ucyA9IF9fd2VicGFja19yZXF1aXJlX18oNDkpLmFsbE9wdGlvbnM7XG4gIHZhciBjb25maWd1cmVPcHRpb25zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OSkuY29uZmlndXJlT3B0aW9ucztcblxuICAvKipcbiAgICogQ3JlYXRlIGEgdGltZWxpbmUgdmlzdWFsaXphdGlvblxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXJcbiAgICogQHBhcmFtIHt2aXMuRGF0YVNldCB8IHZpcy5EYXRhVmlldyB8IEFycmF5fSBbaXRlbXNdXG4gICAqIEBwYXJhbSB7dmlzLkRhdGFTZXQgfCB2aXMuRGF0YVZpZXcgfCBBcnJheX0gW2dyb3Vwc11cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgU2VlIFRpbWVsaW5lLnNldE9wdGlvbnMgZm9yIHRoZSBhdmFpbGFibGUgb3B0aW9ucy5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIENvcmVcbiAgICovXG4gIGZ1bmN0aW9uIFRpbWVsaW5lKGNvbnRhaW5lciwgaXRlbXMsIGdyb3Vwcywgb3B0aW9ucykge1xuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRpbWVsaW5lKSkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdDb25zdHJ1Y3RvciBtdXN0IGJlIGNhbGxlZCB3aXRoIHRoZSBuZXcgb3BlcmF0b3InKTtcbiAgICB9XG5cbiAgICAvLyBpZiB0aGUgdGhpcmQgZWxlbWVudCBpcyBvcHRpb25zLCB0aGUgZm9ydGggaXMgZ3JvdXBzIChvcHRpb25hbGx5KTtcbiAgICBpZiAoIShBcnJheS5pc0FycmF5KGdyb3VwcykgfHwgZ3JvdXBzIGluc3RhbmNlb2YgRGF0YVNldCB8fCBncm91cHMgaW5zdGFuY2VvZiBEYXRhVmlldykgJiYgZ3JvdXBzIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICB2YXIgZm9ydGhBcmd1bWVudCA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0gZ3JvdXBzO1xuICAgICAgZ3JvdXBzID0gZm9ydGhBcmd1bWVudDtcbiAgICB9XG5cbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBzdGFydDogbnVsbCxcbiAgICAgIGVuZDogbnVsbCxcblxuICAgICAgYXV0b1Jlc2l6ZTogdHJ1ZSxcbiAgICAgIHRocm90dGxlUmVkcmF3OiAwLCAvLyBtc1xuXG4gICAgICBvcmllbnRhdGlvbjoge1xuICAgICAgICBheGlzOiAnYm90dG9tJywgLy8gYXhpcyBvcmllbnRhdGlvbjogJ2JvdHRvbScsICd0b3AnLCBvciAnYm90aCdcbiAgICAgICAgaXRlbTogJ2JvdHRvbScgLy8gbm90IHJlbGV2YW50XG4gICAgICB9LFxuICAgICAgcnRsOiBmYWxzZSxcbiAgICAgIG1vbWVudDogbW9tZW50LFxuXG4gICAgICB3aWR0aDogbnVsbCxcbiAgICAgIGhlaWdodDogbnVsbCxcbiAgICAgIG1heEhlaWdodDogbnVsbCxcbiAgICAgIG1pbkhlaWdodDogbnVsbFxuICAgIH07XG4gICAgdGhpcy5vcHRpb25zID0gdXRpbC5kZWVwRXh0ZW5kKHt9LCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICAgIC8vIENyZWF0ZSB0aGUgRE9NLCBwcm9wcywgYW5kIGVtaXR0ZXJcbiAgICB0aGlzLl9jcmVhdGUoY29udGFpbmVyKTtcblxuICAgIC8vIGFsbCBjb21wb25lbnRzIGxpc3RlZCBoZXJlIHdpbGwgYmUgcmVwYWludGVkIGF1dG9tYXRpY2FsbHlcbiAgICB0aGlzLmNvbXBvbmVudHMgPSBbXTtcblxuICAgIHRoaXMuYm9keSA9IHtcbiAgICAgIGRvbTogdGhpcy5kb20sXG4gICAgICBkb21Qcm9wczogdGhpcy5wcm9wcyxcbiAgICAgIGVtaXR0ZXI6IHtcbiAgICAgICAgb246IHRoaXMub24uYmluZCh0aGlzKSxcbiAgICAgICAgb2ZmOiB0aGlzLm9mZi5iaW5kKHRoaXMpLFxuICAgICAgICBlbWl0OiB0aGlzLmVtaXQuYmluZCh0aGlzKVxuICAgICAgfSxcbiAgICAgIGhpZGRlbkRhdGVzOiBbXSxcbiAgICAgIHV0aWw6IHtcbiAgICAgICAgZ2V0U2NhbGU6IGZ1bmN0aW9uIGdldFNjYWxlKCkge1xuICAgICAgICAgIHJldHVybiBtZS50aW1lQXhpcy5zdGVwLnNjYWxlO1xuICAgICAgICB9LFxuICAgICAgICBnZXRTdGVwOiBmdW5jdGlvbiBnZXRTdGVwKCkge1xuICAgICAgICAgIHJldHVybiBtZS50aW1lQXhpcy5zdGVwLnN0ZXA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9TY3JlZW46IG1lLl90b1NjcmVlbi5iaW5kKG1lKSxcbiAgICAgICAgdG9HbG9iYWxTY3JlZW46IG1lLl90b0dsb2JhbFNjcmVlbi5iaW5kKG1lKSwgLy8gdGhpcyByZWZlcnMgdG8gdGhlIHJvb3Qud2lkdGhcbiAgICAgICAgdG9UaW1lOiBtZS5fdG9UaW1lLmJpbmQobWUpLFxuICAgICAgICB0b0dsb2JhbFRpbWU6IG1lLl90b0dsb2JhbFRpbWUuYmluZChtZSlcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gcmFuZ2VcbiAgICB0aGlzLnJhbmdlID0gbmV3IFJhbmdlKHRoaXMuYm9keSk7XG4gICAgdGhpcy5jb21wb25lbnRzLnB1c2godGhpcy5yYW5nZSk7XG4gICAgdGhpcy5ib2R5LnJhbmdlID0gdGhpcy5yYW5nZTtcblxuICAgIC8vIHRpbWUgYXhpc1xuICAgIHRoaXMudGltZUF4aXMgPSBuZXcgVGltZUF4aXModGhpcy5ib2R5KTtcbiAgICB0aGlzLnRpbWVBeGlzMiA9IG51bGw7IC8vIHVzZWQgaW4gY2FzZSBvZiBvcmllbnRhdGlvbiBvcHRpb24gJ2JvdGgnXG4gICAgdGhpcy5jb21wb25lbnRzLnB1c2godGhpcy50aW1lQXhpcyk7XG5cbiAgICAvLyBjdXJyZW50IHRpbWUgYmFyXG4gICAgdGhpcy5jdXJyZW50VGltZSA9IG5ldyBDdXJyZW50VGltZSh0aGlzLmJvZHkpO1xuICAgIHRoaXMuY29tcG9uZW50cy5wdXNoKHRoaXMuY3VycmVudFRpbWUpO1xuXG4gICAgLy8gaXRlbSBzZXRcbiAgICB0aGlzLml0ZW1TZXQgPSBuZXcgSXRlbVNldCh0aGlzLmJvZHksIHRoaXMub3B0aW9ucyk7XG4gICAgdGhpcy5jb21wb25lbnRzLnB1c2godGhpcy5pdGVtU2V0KTtcblxuICAgIHRoaXMuaXRlbXNEYXRhID0gbnVsbDsgLy8gRGF0YVNldFxuICAgIHRoaXMuZ3JvdXBzRGF0YSA9IG51bGw7IC8vIERhdGFTZXRcblxuICAgIHRoaXMub24oJ3RhcCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgbWUuZW1pdCgnY2xpY2snLCBtZS5nZXRFdmVudFByb3BlcnRpZXMoZXZlbnQpKTtcbiAgICB9KTtcbiAgICB0aGlzLm9uKCdkb3VibGV0YXAnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIG1lLmVtaXQoJ2RvdWJsZUNsaWNrJywgbWUuZ2V0RXZlbnRQcm9wZXJ0aWVzKGV2ZW50KSk7XG4gICAgfSk7XG4gICAgdGhpcy5kb20ucm9vdC5vbmNvbnRleHRtZW51ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBtZS5lbWl0KCdjb250ZXh0bWVudScsIG1lLmdldEV2ZW50UHJvcGVydGllcyhldmVudCkpO1xuICAgIH07XG5cbiAgICAvL1NpbmdsZSB0aW1lIGF1dG9zY2FsZS9maXRcbiAgICB0aGlzLmZpdERvbmUgPSBmYWxzZTtcbiAgICB0aGlzLm9uKCdjaGFuZ2VkJywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuaXRlbXNEYXRhID09IG51bGwpIHJldHVybjtcbiAgICAgIGlmICghbWUuZml0RG9uZSkge1xuICAgICAgICBtZS5maXREb25lID0gdHJ1ZTtcbiAgICAgICAgaWYgKG1lLm9wdGlvbnMuc3RhcnQgIT0gdW5kZWZpbmVkIHx8IG1lLm9wdGlvbnMuZW5kICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChtZS5vcHRpb25zLnN0YXJ0ID09IHVuZGVmaW5lZCB8fCBtZS5vcHRpb25zLmVuZCA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IG1lLmdldEl0ZW1SYW5nZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzdGFydCA9IG1lLm9wdGlvbnMuc3RhcnQgIT0gdW5kZWZpbmVkID8gbWUub3B0aW9ucy5zdGFydCA6IHJhbmdlLm1pbjtcbiAgICAgICAgICB2YXIgZW5kID0gbWUub3B0aW9ucy5lbmQgIT0gdW5kZWZpbmVkID8gbWUub3B0aW9ucy5lbmQgOiByYW5nZS5tYXg7XG5cbiAgICAgICAgICBtZS5zZXRXaW5kb3coc3RhcnQsIGVuZCwgeyBhbmltYXRpb246IGZhbHNlIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1lLmZpdCh7IGFuaW1hdGlvbjogZmFsc2UgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGFwcGx5IG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8vIElNUE9SVEFOVDogVEhJUyBIQVBQRU5TIEJFRk9SRSBTRVQgSVRFTVMhXG4gICAgaWYgKGdyb3Vwcykge1xuICAgICAgdGhpcy5zZXRHcm91cHMoZ3JvdXBzKTtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgaXRlbXNldFxuICAgIGlmIChpdGVtcykge1xuICAgICAgdGhpcy5zZXRJdGVtcyhpdGVtcyk7XG4gICAgfVxuXG4gICAgLy8gZHJhdyBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICB0aGlzLl9yZWRyYXcoKTtcbiAgfVxuXG4gIC8vIEV4dGVuZCB0aGUgZnVuY3Rpb25hbGl0eSBmcm9tIENvcmVcbiAgVGltZWxpbmUucHJvdG90eXBlID0gbmV3IENvcmUoKTtcblxuICAvKipcbiAgICogTG9hZCBhIGNvbmZpZ3VyYXRvclxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBUaW1lbGluZS5wcm90b3R5cGUuX2NyZWF0ZUNvbmZpZ3VyYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IF9Db25maWd1cmF0b3IyLmRlZmF1bHQodGhpcywgdGhpcy5kb20uY29udGFpbmVyLCBjb25maWd1cmVPcHRpb25zKTtcbiAgfTtcblxuICAvKipcbiAgICogRm9yY2UgYSByZWRyYXcuIFRoZSBzaXplIG9mIGFsbCBpdGVtcyB3aWxsIGJlIHJlY2FsY3VsYXRlZC5cbiAgICogQ2FuIGJlIHVzZWZ1bCB0byBtYW51YWxseSByZWRyYXcgd2hlbiBvcHRpb24gYXV0b1Jlc2l6ZT1mYWxzZSBhbmQgdGhlIHdpbmRvd1xuICAgKiBoYXMgYmVlbiByZXNpemVkLCBvciB3aGVuIHRoZSBpdGVtcyBDU1MgaGFzIGJlZW4gY2hhbmdlZC5cbiAgICpcbiAgICogTm90ZTogdGhpcyBmdW5jdGlvbiB3aWxsIGJlIG92ZXJyaWRkZW4gb24gY29uc3RydWN0aW9uIHdpdGggYSB0cm90dGxlZCB2ZXJzaW9uXG4gICAqL1xuICBUaW1lbGluZS5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXRlbVNldCAmJiB0aGlzLml0ZW1TZXQubWFya0RpcnR5KHsgcmVmcmVzaEl0ZW1zOiB0cnVlIH0pO1xuICAgIHRoaXMuX3JlZHJhdygpO1xuICB9O1xuXG4gIFRpbWVsaW5lLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAvLyB2YWxpZGF0ZSBvcHRpb25zXG4gICAgdmFyIGVycm9yRm91bmQgPSBfVmFsaWRhdG9yMi5kZWZhdWx0LnZhbGlkYXRlKG9wdGlvbnMsIGFsbE9wdGlvbnMpO1xuXG4gICAgaWYgKGVycm9yRm91bmQgPT09IHRydWUpIHtcbiAgICAgIGNvbnNvbGUubG9nKCclY0Vycm9ycyBoYXZlIGJlZW4gZm91bmQgaW4gdGhlIHN1cHBsaWVkIG9wdGlvbnMgb2JqZWN0LicsIHByaW50U3R5bGUpO1xuICAgIH1cblxuICAgIENvcmUucHJvdG90eXBlLnNldE9wdGlvbnMuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICAgIGlmICgndHlwZScgaW4gb3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMudHlwZSAhPT0gdGhpcy5vcHRpb25zLnR5cGUpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnR5cGUgPSBvcHRpb25zLnR5cGU7XG5cbiAgICAgICAgLy8gZm9yY2UgcmVjcmVhdGlvbiBvZiBhbGwgaXRlbXNcbiAgICAgICAgdmFyIGl0ZW1zRGF0YSA9IHRoaXMuaXRlbXNEYXRhO1xuICAgICAgICBpZiAoaXRlbXNEYXRhKSB7XG4gICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgdGhpcy5zZXRJdGVtcyhudWxsKTsgLy8gcmVtb3ZlIGFsbFxuICAgICAgICAgIHRoaXMuc2V0SXRlbXMoaXRlbXNEYXRhKTsgLy8gYWRkIGFsbFxuICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbik7IC8vIHJlc3RvcmUgc2VsZWN0aW9uXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBpdGVtc1xuICAgKiBAcGFyYW0ge3Zpcy5EYXRhU2V0IHwgQXJyYXkgfCBudWxsfSBpdGVtc1xuICAgKi9cbiAgVGltZWxpbmUucHJvdG90eXBlLnNldEl0ZW1zID0gZnVuY3Rpb24gKGl0ZW1zKSB7XG4gICAgLy8gY29udmVydCB0byB0eXBlIERhdGFTZXQgd2hlbiBuZWVkZWRcbiAgICB2YXIgbmV3RGF0YVNldDtcbiAgICBpZiAoIWl0ZW1zKSB7XG4gICAgICBuZXdEYXRhU2V0ID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGl0ZW1zIGluc3RhbmNlb2YgRGF0YVNldCB8fCBpdGVtcyBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG4gICAgICBuZXdEYXRhU2V0ID0gaXRlbXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHR1cm4gYW4gYXJyYXkgaW50byBhIGRhdGFzZXRcbiAgICAgIG5ld0RhdGFTZXQgPSBuZXcgRGF0YVNldChpdGVtcywge1xuICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgc3RhcnQ6ICdEYXRlJyxcbiAgICAgICAgICBlbmQ6ICdEYXRlJ1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBzZXQgaXRlbXNcbiAgICB0aGlzLml0ZW1zRGF0YSA9IG5ld0RhdGFTZXQ7XG4gICAgdGhpcy5pdGVtU2V0ICYmIHRoaXMuaXRlbVNldC5zZXRJdGVtcyhuZXdEYXRhU2V0KTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGdyb3Vwc1xuICAgKiBAcGFyYW0ge3Zpcy5EYXRhU2V0IHwgQXJyYXl9IGdyb3Vwc1xuICAgKi9cbiAgVGltZWxpbmUucHJvdG90eXBlLnNldEdyb3VwcyA9IGZ1bmN0aW9uIChncm91cHMpIHtcbiAgICAvLyBjb252ZXJ0IHRvIHR5cGUgRGF0YVNldCB3aGVuIG5lZWRlZFxuICAgIHZhciBuZXdEYXRhU2V0O1xuICAgIGlmICghZ3JvdXBzKSB7XG4gICAgICBuZXdEYXRhU2V0ID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGdyb3VwcyBpbnN0YW5jZW9mIERhdGFTZXQgfHwgZ3JvdXBzIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICAgIG5ld0RhdGFTZXQgPSBncm91cHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHR1cm4gYW4gYXJyYXkgaW50byBhIGRhdGFzZXRcbiAgICAgIG5ld0RhdGFTZXQgPSBuZXcgRGF0YVNldChncm91cHMpO1xuICAgIH1cblxuICAgIHRoaXMuZ3JvdXBzRGF0YSA9IG5ld0RhdGFTZXQ7XG4gICAgdGhpcy5pdGVtU2V0LnNldEdyb3VwcyhuZXdEYXRhU2V0KTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGJvdGggaXRlbXMgYW5kIGdyb3VwcyBpbiBvbmUgZ29cbiAgICogQHBhcmFtIHt7aXRlbXM6IEFycmF5IHwgdmlzLkRhdGFTZXQsIGdyb3VwczogQXJyYXkgfCB2aXMuRGF0YVNldH19IGRhdGFcbiAgICovXG4gIFRpbWVsaW5lLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAoZGF0YSAmJiBkYXRhLmdyb3Vwcykge1xuICAgICAgdGhpcy5zZXRHcm91cHMoZGF0YS5ncm91cHMpO1xuICAgIH1cblxuICAgIGlmIChkYXRhICYmIGRhdGEuaXRlbXMpIHtcbiAgICAgIHRoaXMuc2V0SXRlbXMoZGF0YS5pdGVtcyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgc2VsZWN0ZWQgaXRlbXMgYnkgdGhlaXIgaWQuIFJlcGxhY2VzIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuICAgKiBVbmtub3duIGlkJ3MgYXJlIHNpbGVudGx5IGlnbm9yZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nW10gfCBzdHJpbmd9IFtpZHNdICBBbiBhcnJheSB3aXRoIHplcm8gb3IgbW9yZSBpZCdzIG9mIHRoZSBpdGVtcyB0byBiZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQuIElmIGlkcyBpcyBhbiBlbXB0eSBhcnJheSwgYWxsIGl0ZW1zIHdpbGwgYmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuc2VsZWN0ZWQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgICBBdmFpbGFibGUgb3B0aW9uczpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBmb2N1czogYm9vbGVhbmBcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiB0cnVlLCBmb2N1cyB3aWxsIGJlIHNldCB0byB0aGUgc2VsZWN0ZWQgaXRlbShzKVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGFuaW1hdGlvbjogYm9vbGVhbiB8IHtkdXJhdGlvbjogbnVtYmVyLCBlYXNpbmdGdW5jdGlvbjogc3RyaW5nfWBcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiB0cnVlIChkZWZhdWx0KSwgdGhlIHJhbmdlIGlzIGFuaW1hdGVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc21vb3RobHkgdG8gdGhlIG5ldyB3aW5kb3cuIEFuIG9iamVjdCBjYW4gYmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlZCB0byBzcGVjaWZ5IGR1cmF0aW9uIGFuZCBlYXNpbmcgZnVuY3Rpb24uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCBkdXJhdGlvbiBpcyA1MDAgbXMsIGFuZCBkZWZhdWx0IGVhc2luZ1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGlzICdlYXNlSW5PdXRRdWFkJy5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPbmx5IGFwcGxpY2FibGUgd2hlbiBvcHRpb24gZm9jdXMgaXMgdHJ1ZS5cbiAgICovXG4gIFRpbWVsaW5lLnByb3RvdHlwZS5zZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoaWRzLCBvcHRpb25zKSB7XG4gICAgdGhpcy5pdGVtU2V0ICYmIHRoaXMuaXRlbVNldC5zZXRTZWxlY3Rpb24oaWRzKTtcblxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZm9jdXMpIHtcbiAgICAgIHRoaXMuZm9jdXMoaWRzLCBvcHRpb25zKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2VsZWN0ZWQgaXRlbXMgYnkgdGhlaXIgaWRcbiAgICogQHJldHVybiB7QXJyYXl9IGlkcyAgVGhlIGlkcyBvZiB0aGUgc2VsZWN0ZWQgaXRlbXNcbiAgICovXG4gIFRpbWVsaW5lLnByb3RvdHlwZS5nZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbVNldCAmJiB0aGlzLml0ZW1TZXQuZ2V0U2VsZWN0aW9uKCkgfHwgW107XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkanVzdCB0aGUgdmlzaWJsZSB3aW5kb3cgc3VjaCB0aGF0IHRoZSBzZWxlY3RlZCBpdGVtIChvciBtdWx0aXBsZSBpdGVtcylcbiAgICogYXJlIGNlbnRlcmVkIG9uIHNjcmVlbi5cbiAgICogQHBhcmFtIHtTdHJpbmcgfCBTdHJpbmdbXX0gaWQgICAgIEFuIGl0ZW0gaWQgb3IgYXJyYXkgd2l0aCBpdGVtIGlkc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgICAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgYW5pbWF0aW9uOiBib29sZWFuIHwge2R1cmF0aW9uOiBudW1iZXIsIGVhc2luZ0Z1bmN0aW9uOiBzdHJpbmd9YFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHRydWUgKGRlZmF1bHQpLCB0aGUgcmFuZ2UgaXMgYW5pbWF0ZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbW9vdGhseSB0byB0aGUgbmV3IHdpbmRvdy4gQW4gb2JqZWN0IGNhbiBiZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVkIHRvIHNwZWNpZnkgZHVyYXRpb24gYW5kIGVhc2luZyBmdW5jdGlvbi5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IGR1cmF0aW9uIGlzIDUwMCBtcywgYW5kIGRlZmF1bHQgZWFzaW5nXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gaXMgJ2Vhc2VJbk91dFF1YWQnLlxuICAgKi9cbiAgVGltZWxpbmUucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKGlkLCBvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLml0ZW1zRGF0YSB8fCBpZCA9PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgIHZhciBpZHMgPSBBcnJheS5pc0FycmF5KGlkKSA/IGlkIDogW2lkXTtcblxuICAgIC8vIGdldCB0aGUgc3BlY2lmaWVkIGl0ZW0ocylcbiAgICB2YXIgaXRlbXNEYXRhID0gdGhpcy5pdGVtc0RhdGEuZ2V0RGF0YVNldCgpLmdldChpZHMsIHtcbiAgICAgIHR5cGU6IHtcbiAgICAgICAgc3RhcnQ6ICdEYXRlJyxcbiAgICAgICAgZW5kOiAnRGF0ZSdcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGNhbGN1bGF0ZSBtaW5pbXVtIHN0YXJ0IGFuZCBtYXhpbXVtIGVuZCBvZiBzcGVjaWZpZWQgaXRlbXNcbiAgICB2YXIgc3RhcnQgPSBudWxsO1xuICAgIHZhciBlbmQgPSBudWxsO1xuICAgIGl0ZW1zRGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtRGF0YSkge1xuICAgICAgdmFyIHMgPSBpdGVtRGF0YS5zdGFydC52YWx1ZU9mKCk7XG4gICAgICB2YXIgZSA9ICdlbmQnIGluIGl0ZW1EYXRhID8gaXRlbURhdGEuZW5kLnZhbHVlT2YoKSA6IGl0ZW1EYXRhLnN0YXJ0LnZhbHVlT2YoKTtcblxuICAgICAgaWYgKHN0YXJ0ID09PSBudWxsIHx8IHMgPCBzdGFydCkge1xuICAgICAgICBzdGFydCA9IHM7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmQgPT09IG51bGwgfHwgZSA+IGVuZCkge1xuICAgICAgICBlbmQgPSBlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHN0YXJ0ICE9PSBudWxsICYmIGVuZCAhPT0gbnVsbCkge1xuICAgICAgLy8gY2FsY3VsYXRlIHRoZSBuZXcgbWlkZGxlIGFuZCBpbnRlcnZhbCBmb3IgdGhlIHdpbmRvd1xuICAgICAgdmFyIG1pZGRsZSA9IChzdGFydCArIGVuZCkgLyAyO1xuICAgICAgdmFyIGludGVydmFsID0gTWF0aC5tYXgodGhpcy5yYW5nZS5lbmQgLSB0aGlzLnJhbmdlLnN0YXJ0LCAoZW5kIC0gc3RhcnQpICogMS4xKTtcblxuICAgICAgdmFyIGFuaW1hdGlvbiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5hbmltYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYW5pbWF0aW9uIDogdHJ1ZTtcbiAgICAgIHRoaXMucmFuZ2Uuc2V0UmFuZ2UobWlkZGxlIC0gaW50ZXJ2YWwgLyAyLCBtaWRkbGUgKyBpbnRlcnZhbCAvIDIsIGFuaW1hdGlvbik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgVGltZWxpbmUgd2luZG93IHN1Y2ggdGhhdCBpdCBmaXRzIGFsbCBpdGVtc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICBBdmFpbGFibGUgb3B0aW9uczpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBhbmltYXRpb246IGJvb2xlYW4gfCB7ZHVyYXRpb246IG51bWJlciwgZWFzaW5nRnVuY3Rpb246IHN0cmluZ31gXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgdHJ1ZSAoZGVmYXVsdCksIHRoZSByYW5nZSBpcyBhbmltYXRlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtb290aGx5IHRvIHRoZSBuZXcgd2luZG93LiBBbiBvYmplY3QgY2FuIGJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZWQgdG8gc3BlY2lmeSBkdXJhdGlvbiBhbmQgZWFzaW5nIGZ1bmN0aW9uLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgZHVyYXRpb24gaXMgNTAwIG1zLCBhbmQgZGVmYXVsdCBlYXNpbmdcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBpcyAnZWFzZUluT3V0UXVhZCcuXG4gICAqL1xuICBUaW1lbGluZS5wcm90b3R5cGUuZml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgYW5pbWF0aW9uID0gb3B0aW9ucyAmJiBvcHRpb25zLmFuaW1hdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5hbmltYXRpb24gOiB0cnVlO1xuICAgIHZhciByYW5nZTtcblxuICAgIHZhciBkYXRhc2V0ID0gdGhpcy5pdGVtc0RhdGEgJiYgdGhpcy5pdGVtc0RhdGEuZ2V0RGF0YVNldCgpO1xuICAgIGlmIChkYXRhc2V0Lmxlbmd0aCA9PT0gMSAmJiBkYXRhc2V0LmdldCgpWzBdLmVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBhIHNpbmdsZSBpdGVtIC0+IGRvbid0IGZpdCwganVzdCBzaG93IGEgcmFuZ2UgYXJvdW5kIHRoZSBpdGVtIGZyb20gLTQgdG8gKzMgZGF5c1xuICAgICAgcmFuZ2UgPSB0aGlzLmdldERhdGFSYW5nZSgpO1xuICAgICAgdGhpcy5tb3ZlVG8ocmFuZ2UubWluLnZhbHVlT2YoKSwgeyBhbmltYXRpb246IGFuaW1hdGlvbiB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhhY3RseSBmaXQgdGhlIGl0ZW1zIChwbHVzIGEgc21hbGwgbWFyZ2luKVxuICAgICAgcmFuZ2UgPSB0aGlzLmdldEl0ZW1SYW5nZSgpO1xuICAgICAgdGhpcy5yYW5nZS5zZXRSYW5nZShyYW5nZS5taW4sIHJhbmdlLm1heCwgYW5pbWF0aW9uKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIERldGVybWluZSB0aGUgcmFuZ2Ugb2YgdGhlIGl0ZW1zLCB0YWtpbmcgaW50byBhY2NvdW50IHRoZWlyIGFjdHVhbCB3aWR0aFxuICAgKiBhbmQgYSBtYXJnaW4gb2YgMTAgcGl4ZWxzIG9uIGJvdGggc2lkZXMuXG4gICAqIEByZXR1cm4ge3ttaW46IERhdGUgfCBudWxsLCBtYXg6IERhdGUgfCBudWxsfX1cbiAgICovXG4gIFRpbWVsaW5lLnByb3RvdHlwZS5nZXRJdGVtUmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIC8vIGdldCBhIHJvdWdoIGFwcHJveGltYXRpb24gZm9yIHRoZSByYW5nZSBiYXNlZCBvbiB0aGUgaXRlbXMgc3RhcnQgYW5kIGVuZCBkYXRlc1xuICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0RGF0YVJhbmdlKCk7XG4gICAgdmFyIG1pbiA9IHJhbmdlLm1pbiAhPT0gbnVsbCA/IHJhbmdlLm1pbi52YWx1ZU9mKCkgOiBudWxsO1xuICAgIHZhciBtYXggPSByYW5nZS5tYXggIT09IG51bGwgPyByYW5nZS5tYXgudmFsdWVPZigpIDogbnVsbDtcbiAgICB2YXIgbWluSXRlbSA9IG51bGw7XG4gICAgdmFyIG1heEl0ZW0gPSBudWxsO1xuXG4gICAgaWYgKG1pbiAhPSBudWxsICYmIG1heCAhPSBudWxsKSB7XG4gICAgICB2YXIgaW50ZXJ2YWw7XG4gICAgICB2YXIgZmFjdG9yO1xuICAgICAgdmFyIGxocztcbiAgICAgIHZhciByaHM7XG4gICAgICB2YXIgZGVsdGE7XG5cbiAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBnZXRTdGFydCA9IGZ1bmN0aW9uIGdldFN0YXJ0KGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gdXRpbC5jb252ZXJ0KGl0ZW0uZGF0YS5zdGFydCwgJ0RhdGUnKS52YWx1ZU9mKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGdldEVuZCA9IGZ1bmN0aW9uIGdldEVuZChpdGVtKSB7XG4gICAgICAgICAgdmFyIGVuZCA9IGl0ZW0uZGF0YS5lbmQgIT0gdW5kZWZpbmVkID8gaXRlbS5kYXRhLmVuZCA6IGl0ZW0uZGF0YS5zdGFydDtcbiAgICAgICAgICByZXR1cm4gdXRpbC5jb252ZXJ0KGVuZCwgJ0RhdGUnKS52YWx1ZU9mKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBkYXRlIG9mIHRoZSBsZWZ0IHNpZGUgYW5kIHJpZ2h0IHNpZGUgb2YgdGhlIGl0ZW1zIGdpdmVuXG5cblxuICAgICAgICBpbnRlcnZhbCA9IG1heCAtIG1pbjsgLy8gbXNcblxuICAgICAgICBpZiAoaW50ZXJ2YWwgPD0gMCkge1xuICAgICAgICAgIGludGVydmFsID0gMTA7XG4gICAgICAgIH1cbiAgICAgICAgZmFjdG9yID0gaW50ZXJ2YWwgLyBfdGhpcy5wcm9wcy5jZW50ZXIud2lkdGg7XG4gICAgICAgIHV0aWwuZm9yRWFjaChfdGhpcy5pdGVtU2V0Lml0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIGl0ZW0uc2hvdygpO1xuICAgICAgICAgIGl0ZW0ucmVwb3NpdGlvblgoKTtcblxuICAgICAgICAgIHZhciBzdGFydCA9IGdldFN0YXJ0KGl0ZW0pO1xuICAgICAgICAgIHZhciBlbmQgPSBnZXRFbmQoaXRlbSk7XG5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0U2lkZSA9IHN0YXJ0IC0gKGl0ZW0uZ2V0V2lkdGhSaWdodCgpICsgMTApICogZmFjdG9yO1xuICAgICAgICAgICAgdmFyIGVuZFNpZGUgPSBlbmQgKyAoaXRlbS5nZXRXaWR0aExlZnQoKSArIDEwKSAqIGZhY3RvcjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHN0YXJ0U2lkZSA9IHN0YXJ0IC0gKGl0ZW0uZ2V0V2lkdGhMZWZ0KCkgKyAxMCkgKiBmYWN0b3I7XG4gICAgICAgICAgICB2YXIgZW5kU2lkZSA9IGVuZCArIChpdGVtLmdldFdpZHRoUmlnaHQoKSArIDEwKSAqIGZhY3RvcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3RhcnRTaWRlIDwgbWluKSB7XG4gICAgICAgICAgICBtaW4gPSBzdGFydFNpZGU7XG4gICAgICAgICAgICBtaW5JdGVtID0gaXRlbTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVuZFNpZGUgPiBtYXgpIHtcbiAgICAgICAgICAgIG1heCA9IGVuZFNpZGU7XG4gICAgICAgICAgICBtYXhJdGVtID0gaXRlbTtcbiAgICAgICAgICB9XG4gICAgICAgIH0uYmluZChfdGhpcykpO1xuXG4gICAgICAgIGlmIChtaW5JdGVtICYmIG1heEl0ZW0pIHtcbiAgICAgICAgICBsaHMgPSBtaW5JdGVtLmdldFdpZHRoTGVmdCgpICsgMTA7XG4gICAgICAgICAgcmhzID0gbWF4SXRlbS5nZXRXaWR0aFJpZ2h0KCkgKyAxMDtcbiAgICAgICAgICBkZWx0YSA9IF90aGlzLnByb3BzLmNlbnRlci53aWR0aCAtIGxocyAtIHJoczsgLy8gcHhcblxuICAgICAgICAgIGlmIChkZWx0YSA+IDApIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgICAgICAgICBtaW4gPSBnZXRTdGFydChtaW5JdGVtKSAtIHJocyAqIGludGVydmFsIC8gZGVsdGE7IC8vIG1zXG4gICAgICAgICAgICAgIG1heCA9IGdldEVuZChtYXhJdGVtKSArIGxocyAqIGludGVydmFsIC8gZGVsdGE7IC8vIG1zXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1pbiA9IGdldFN0YXJ0KG1pbkl0ZW0pIC0gbGhzICogaW50ZXJ2YWwgLyBkZWx0YTsgLy8gbXNcbiAgICAgICAgICAgICAgICBtYXggPSBnZXRFbmQobWF4SXRlbSkgKyByaHMgKiBpbnRlcnZhbCAvIGRlbHRhOyAvLyBtc1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSgpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBtaW46IG1pbiAhPSBudWxsID8gbmV3IERhdGUobWluKSA6IG51bGwsXG4gICAgICBtYXg6IG1heCAhPSBudWxsID8gbmV3IERhdGUobWF4KSA6IG51bGxcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGRhdGEgcmFuZ2Ugb2YgdGhlIGl0ZW1zIHN0YXJ0IGFuZCBlbmQgZGF0ZXNcbiAgICogQHJldHVybnMge3ttaW46IERhdGUgfCBudWxsLCBtYXg6IERhdGUgfCBudWxsfX1cbiAgICovXG4gIFRpbWVsaW5lLnByb3RvdHlwZS5nZXREYXRhUmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1pbiA9IG51bGw7XG4gICAgdmFyIG1heCA9IG51bGw7XG5cbiAgICB2YXIgZGF0YXNldCA9IHRoaXMuaXRlbXNEYXRhICYmIHRoaXMuaXRlbXNEYXRhLmdldERhdGFTZXQoKTtcbiAgICBpZiAoZGF0YXNldCkge1xuICAgICAgZGF0YXNldC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHV0aWwuY29udmVydChpdGVtLnN0YXJ0LCAnRGF0ZScpLnZhbHVlT2YoKTtcbiAgICAgICAgdmFyIGVuZCA9IHV0aWwuY29udmVydChpdGVtLmVuZCAhPSB1bmRlZmluZWQgPyBpdGVtLmVuZCA6IGl0ZW0uc3RhcnQsICdEYXRlJykudmFsdWVPZigpO1xuICAgICAgICBpZiAobWluID09PSBudWxsIHx8IHN0YXJ0IDwgbWluKSB7XG4gICAgICAgICAgbWluID0gc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBlbmQgPiBtYXgpIHtcbiAgICAgICAgICBtYXggPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBtaW46IG1pbiAhPSBudWxsID8gbmV3IERhdGUobWluKSA6IG51bGwsXG4gICAgICBtYXg6IG1heCAhPSBudWxsID8gbmV3IERhdGUobWF4KSA6IG51bGxcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBUaW1lbGluZSByZWxhdGVkIGluZm9ybWF0aW9uIGZyb20gYW4gZXZlbnRcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCByZWxhdGVkIGluZm9ybWF0aW9uLCBsaWtlIG9uIHdoaWNoIGFyZWFcbiAgICogICAgICAgICAgICAgICAgICBUaGUgZXZlbnQgaGFwcGVuZWQsIHdoZXRoZXIgY2xpY2tlZCBvbiBhbiBpdGVtLCBldGMuXG4gICAqL1xuICBUaW1lbGluZS5wcm90b3R5cGUuZ2V0RXZlbnRQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGNsaWVudFggPSBldmVudC5jZW50ZXIgPyBldmVudC5jZW50ZXIueCA6IGV2ZW50LmNsaWVudFg7XG4gICAgdmFyIGNsaWVudFkgPSBldmVudC5jZW50ZXIgPyBldmVudC5jZW50ZXIueSA6IGV2ZW50LmNsaWVudFk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgIHZhciB4ID0gdXRpbC5nZXRBYnNvbHV0ZVJpZ2h0KHRoaXMuZG9tLmNlbnRlckNvbnRhaW5lcikgLSBjbGllbnRYO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgeCA9IGNsaWVudFggLSB1dGlsLmdldEFic29sdXRlTGVmdCh0aGlzLmRvbS5jZW50ZXJDb250YWluZXIpO1xuICAgIH1cbiAgICB2YXIgeSA9IGNsaWVudFkgLSB1dGlsLmdldEFic29sdXRlVG9wKHRoaXMuZG9tLmNlbnRlckNvbnRhaW5lcik7XG5cbiAgICB2YXIgaXRlbSA9IHRoaXMuaXRlbVNldC5pdGVtRnJvbVRhcmdldChldmVudCk7XG4gICAgdmFyIGdyb3VwID0gdGhpcy5pdGVtU2V0Lmdyb3VwRnJvbVRhcmdldChldmVudCk7XG4gICAgdmFyIGN1c3RvbVRpbWUgPSBDdXN0b21UaW1lLmN1c3RvbVRpbWVGcm9tVGFyZ2V0KGV2ZW50KTtcblxuICAgIHZhciBzbmFwID0gdGhpcy5pdGVtU2V0Lm9wdGlvbnMuc25hcCB8fCBudWxsO1xuICAgIHZhciBzY2FsZSA9IHRoaXMuYm9keS51dGlsLmdldFNjYWxlKCk7XG4gICAgdmFyIHN0ZXAgPSB0aGlzLmJvZHkudXRpbC5nZXRTdGVwKCk7XG4gICAgdmFyIHRpbWUgPSB0aGlzLl90b1RpbWUoeCk7XG4gICAgdmFyIHNuYXBwZWRUaW1lID0gc25hcCA/IHNuYXAodGltZSwgc2NhbGUsIHN0ZXApIDogdGltZTtcblxuICAgIHZhciBlbGVtZW50ID0gdXRpbC5nZXRUYXJnZXQoZXZlbnQpO1xuICAgIHZhciB3aGF0ID0gbnVsbDtcbiAgICBpZiAoaXRlbSAhPSBudWxsKSB7XG4gICAgICB3aGF0ID0gJ2l0ZW0nO1xuICAgIH0gZWxzZSBpZiAoY3VzdG9tVGltZSAhPSBudWxsKSB7XG4gICAgICB3aGF0ID0gJ2N1c3RvbS10aW1lJztcbiAgICB9IGVsc2UgaWYgKHV0aWwuaGFzUGFyZW50KGVsZW1lbnQsIHRoaXMudGltZUF4aXMuZG9tLmZvcmVncm91bmQpKSB7XG4gICAgICB3aGF0ID0gJ2F4aXMnO1xuICAgIH0gZWxzZSBpZiAodGhpcy50aW1lQXhpczIgJiYgdXRpbC5oYXNQYXJlbnQoZWxlbWVudCwgdGhpcy50aW1lQXhpczIuZG9tLmZvcmVncm91bmQpKSB7XG4gICAgICB3aGF0ID0gJ2F4aXMnO1xuICAgIH0gZWxzZSBpZiAodXRpbC5oYXNQYXJlbnQoZWxlbWVudCwgdGhpcy5pdGVtU2V0LmRvbS5sYWJlbFNldCkpIHtcbiAgICAgIHdoYXQgPSAnZ3JvdXAtbGFiZWwnO1xuICAgIH0gZWxzZSBpZiAodXRpbC5oYXNQYXJlbnQoZWxlbWVudCwgdGhpcy5jdXJyZW50VGltZS5iYXIpKSB7XG4gICAgICB3aGF0ID0gJ2N1cnJlbnQtdGltZSc7XG4gICAgfSBlbHNlIGlmICh1dGlsLmhhc1BhcmVudChlbGVtZW50LCB0aGlzLmRvbS5jZW50ZXIpKSB7XG4gICAgICB3aGF0ID0gJ2JhY2tncm91bmQnO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBldmVudDogZXZlbnQsXG4gICAgICBpdGVtOiBpdGVtID8gaXRlbS5pZCA6IG51bGwsXG4gICAgICBncm91cDogZ3JvdXAgPyBncm91cC5ncm91cElkIDogbnVsbCxcbiAgICAgIHdoYXQ6IHdoYXQsXG4gICAgICBwYWdlWDogZXZlbnQuc3JjRXZlbnQgPyBldmVudC5zcmNFdmVudC5wYWdlWCA6IGV2ZW50LnBhZ2VYLFxuICAgICAgcGFnZVk6IGV2ZW50LnNyY0V2ZW50ID8gZXZlbnQuc3JjRXZlbnQucGFnZVkgOiBldmVudC5wYWdlWSxcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5LFxuICAgICAgdGltZTogdGltZSxcbiAgICAgIHNuYXBwZWRUaW1lOiBzbmFwcGVkVGltZVxuICAgIH07XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBUaW1lbGluZTtcblxuLyoqKi8gfSxcbi8qIDI2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX0NvbG9yUGlja2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XG5cbiAgdmFyIF9Db2xvclBpY2tlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Db2xvclBpY2tlcik7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuICAvKipcbiAgICogVGhlIHdheSB0aGlzIHdvcmtzIGlzIGZvciBhbGwgcHJvcGVydGllcyBvZiB0aGlzLnBvc3NpYmxlIG9wdGlvbnMsIHlvdSBjYW4gc3VwcGx5IHRoZSBwcm9wZXJ0eSBuYW1lIGluIGFueSBmb3JtIHRvIGxpc3QgdGhlIG9wdGlvbnMuXG4gICAqIEJvb2xlYW4gb3B0aW9ucyBhcmUgcmVjb2duaXNlZCBhcyBCb29sZWFuXG4gICAqIE51bWJlciBvcHRpb25zIHNob3VsZCBiZSB3cml0dGVuIGFzIGFycmF5OiBbZGVmYXVsdCB2YWx1ZSwgbWluIHZhbHVlLCBtYXggdmFsdWUsIHN0ZXBzaXplXVxuICAgKiBDb2xvcnMgc2hvdWxkIGJlIHdyaXR0ZW4gYXMgYXJyYXk6IFsnY29sb3InLCAnI2ZmZmZmZiddXG4gICAqIFN0cmluZ3Mgd2l0aCBzaG91bGQgYmUgd3JpdHRlbiBhcyBhcnJheTogW29wdGlvbjEsIG9wdGlvbjIsIG9wdGlvbjMsIC4uXVxuICAgKlxuICAgKiBUaGUgb3B0aW9ucyBhcmUgbWF0Y2hlZCB3aXRoIHRoZWlyIGNvdW50ZXJwYXJ0cyBpbiBlYWNoIG9mIHRoZSBtb2R1bGVzIGFuZCB0aGUgdmFsdWVzIHVzZWQgaW4gdGhlIGNvbmZpZ3VyYXRpb24gYXJlXG4gICAqXG4gICAqIEBwYXJhbSBwYXJlbnRNb2R1bGUgICAgICAgIHwgdGhlIGxvY2F0aW9uIHdoZXJlIHBhcmVudE1vZHVsZS5zZXRPcHRpb25zKCkgY2FuIGJlIGNhbGxlZFxuICAgKiBAcGFyYW0gZGVmYXVsdENvbnRhaW5lciAgICB8IHRoZSBkZWZhdWx0IGNvbnRhaW5lciBvZiB0aGUgbW9kdWxlXG4gICAqIEBwYXJhbSBjb25maWd1cmVPcHRpb25zICAgIHwgdGhlIGZ1bGx5IGNvbmZpZ3VyZWQgYW5kIHByZWRlZmluZWQgb3B0aW9ucyBzZXQgZm91bmQgaW4gYWxsT3B0aW9ucy5qc1xuICAgKiBAcGFyYW0gcGl4ZWxSYXRpbyAgICAgICAgICB8IGNhbnZhcyBwaXhlbCByYXRpb1xuICAgKi9cblxuICB2YXIgQ29uZmlndXJhdG9yID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbmZpZ3VyYXRvcihwYXJlbnRNb2R1bGUsIGRlZmF1bHRDb250YWluZXIsIGNvbmZpZ3VyZU9wdGlvbnMpIHtcbiAgICAgIHZhciBwaXhlbFJhdGlvID0gYXJndW1lbnRzLmxlbmd0aCA8PSAzIHx8IGFyZ3VtZW50c1szXSA9PT0gdW5kZWZpbmVkID8gMSA6IGFyZ3VtZW50c1szXTtcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbmZpZ3VyYXRvcik7XG5cbiAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50TW9kdWxlO1xuICAgICAgdGhpcy5jaGFuZ2VkT3B0aW9ucyA9IFtdO1xuICAgICAgdGhpcy5jb250YWluZXIgPSBkZWZhdWx0Q29udGFpbmVyO1xuICAgICAgdGhpcy5hbGxvd0NyZWF0aW9uID0gZmFsc2U7XG5cbiAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgdGhpcy5wb3B1cENvdW50ZXIgPSAwO1xuICAgICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGZpbHRlcjogdHJ1ZSxcbiAgICAgICAgY29udGFpbmVyOiB1bmRlZmluZWQsXG4gICAgICAgIHNob3dCdXR0b246IHRydWVcbiAgICAgIH07XG4gICAgICB1dGlsLmV4dGVuZCh0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gICAgICB0aGlzLmNvbmZpZ3VyZU9wdGlvbnMgPSBjb25maWd1cmVPcHRpb25zO1xuICAgICAgdGhpcy5tb2R1bGVPcHRpb25zID0ge307XG4gICAgICB0aGlzLmRvbUVsZW1lbnRzID0gW107XG4gICAgICB0aGlzLnBvcHVwRGl2ID0ge307XG4gICAgICB0aGlzLnBvcHVwTGltaXQgPSA1O1xuICAgICAgdGhpcy5wb3B1cEhpc3RvcnkgPSB7fTtcbiAgICAgIHRoaXMuY29sb3JQaWNrZXIgPSBuZXcgX0NvbG9yUGlja2VyMi5kZWZhdWx0KHBpeGVsUmF0aW8pO1xuICAgICAgdGhpcy53cmFwcGVyID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJlZnJlc2ggYWxsIG9wdGlvbnMuXG4gICAgICogQmVjYXVzZSBhbGwgbW9kdWxlcyBwYXJzZSB0aGVpciBvcHRpb25zIGJ5IHRoZW1zZWx2ZXMsIHdlIGp1c3QgdXNlIHRoZWlyIG9wdGlvbnMuIFdlIGNvcHkgdGhlbSBoZXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKENvbmZpZ3VyYXRvciwgW3tcbiAgICAgIGtleTogJ3NldE9wdGlvbnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gcmVzZXQgdGhlIHBvcHVwIGhpc3RvcnkgYmVjYXVzZSB0aGUgaW5kaWNlcyBtYXkgaGF2ZSBiZWVuIGNoYW5nZWQuXG4gICAgICAgICAgdGhpcy5wb3B1cEhpc3RvcnkgPSB7fTtcbiAgICAgICAgICB0aGlzLl9yZW1vdmVQb3B1cCgpO1xuXG4gICAgICAgICAgdmFyIGVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5maWx0ZXIgPSBvcHRpb25zO1xuICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZmlsdGVyID0gb3B0aW9ucy5qb2luKCk7XG4gICAgICAgICAgfSBlbHNlIGlmICgodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9wdGlvbnMpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNvbnRhaW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5jb250YWluZXIgPSBvcHRpb25zLmNvbnRhaW5lcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmZpbHRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5maWx0ZXIgPSBvcHRpb25zLmZpbHRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3dCdXR0b24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuc2hvd0J1dHRvbiA9IG9wdGlvbnMuc2hvd0J1dHRvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmVuYWJsZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBlbmFibGVkID0gb3B0aW9ucy5lbmFibGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmZpbHRlciA9IHRydWU7XG4gICAgICAgICAgICBlbmFibGVkID0gb3B0aW9ucztcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZmlsdGVyID0gb3B0aW9ucztcbiAgICAgICAgICAgIGVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmZpbHRlciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2xlYW4oKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzZXRNb2R1bGVPcHRpb25zJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRNb2R1bGVPcHRpb25zKG1vZHVsZU9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5tb2R1bGVPcHRpb25zID0gbW9kdWxlT3B0aW9ucztcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5fY2xlYW4oKTtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNvbnRhaW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMub3B0aW9ucy5jb250YWluZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2NyZWF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlIGFsbCBET00gZWxlbWVudHNcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19jcmVhdGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5fY2xlYW4oKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkT3B0aW9ucyA9IFtdO1xuXG4gICAgICAgIHZhciBmaWx0ZXIgPSB0aGlzLm9wdGlvbnMuZmlsdGVyO1xuICAgICAgICB2YXIgY291bnRlciA9IDA7XG4gICAgICAgIHZhciBzaG93ID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIG9wdGlvbiBpbiB0aGlzLmNvbmZpZ3VyZU9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmVPcHRpb25zLmhhc093blByb3BlcnR5KG9wdGlvbikpIHtcbiAgICAgICAgICAgIHRoaXMuYWxsb3dDcmVhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgc2hvdyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgc2hvdyA9IGZpbHRlcihvcHRpb24sIFtdKTtcbiAgICAgICAgICAgICAgc2hvdyA9IHNob3cgfHwgdGhpcy5faGFuZGxlT2JqZWN0KHRoaXMuY29uZmlndXJlT3B0aW9uc1tvcHRpb25dLCBbb3B0aW9uXSwgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZpbHRlciA9PT0gdHJ1ZSB8fCBmaWx0ZXIuaW5kZXhPZihvcHRpb24pICE9PSAtMSkge1xuICAgICAgICAgICAgICBzaG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNob3cgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHRoaXMuYWxsb3dDcmVhdGlvbiA9IHRydWU7XG5cbiAgICAgICAgICAgICAgLy8gbGluZWJyZWFrIGJldHdlZW4gY2F0ZWdvcmllc1xuICAgICAgICAgICAgICBpZiAoY291bnRlciA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYWtlSXRlbShbXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gYSBoZWFkZXIgZm9yIHRoZSBjYXRlZ29yeVxuICAgICAgICAgICAgICB0aGlzLl9tYWtlSGVhZGVyKG9wdGlvbik7XG5cbiAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBzdWIgb3B0aW9uc1xuICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVPYmplY3QodGhpcy5jb25maWd1cmVPcHRpb25zW29wdGlvbl0sIFtvcHRpb25dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvdW50ZXIrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNob3dCdXR0b24gPT09IHRydWUpIHtcbiAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGdlbmVyYXRlQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBnZW5lcmF0ZUJ1dHRvbi5jbGFzc05hbWUgPSAndmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1idXR0b24nO1xuICAgICAgICAgICAgZ2VuZXJhdGVCdXR0b24uaW5uZXJIVE1MID0gJ2dlbmVyYXRlIG9wdGlvbnMnO1xuICAgICAgICAgICAgZ2VuZXJhdGVCdXR0b24ub25jbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXMuX3ByaW50T3B0aW9ucygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdlbmVyYXRlQnV0dG9uLm9ubW91c2VvdmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBnZW5lcmF0ZUJ1dHRvbi5jbGFzc05hbWUgPSAndmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1idXR0b24gaG92ZXInO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdlbmVyYXRlQnV0dG9uLm9ubW91c2VvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGdlbmVyYXRlQnV0dG9uLmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWJ1dHRvbic7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBfdGhpcy5vcHRpb25zQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBfdGhpcy5vcHRpb25zQ29udGFpbmVyLmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLW9wdGlvbi1jb250YWluZXInO1xuXG4gICAgICAgICAgICBfdGhpcy5kb21FbGVtZW50cy5wdXNoKF90aGlzLm9wdGlvbnNDb250YWluZXIpO1xuICAgICAgICAgICAgX3RoaXMuZG9tRWxlbWVudHMucHVzaChnZW5lcmF0ZUJ1dHRvbik7XG4gICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3B1c2goKTtcbiAgICAgICAgLy9+IHRoaXMuY29sb3JQaWNrZXIuaW5zZXJ0VG8odGhpcy5jb250YWluZXIpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGRyYXcgYWxsIERPTSBlbGVtZW50cyBvbiB0aGUgc2NyZWVuXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfcHVzaCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3B1c2goKSB7XG4gICAgICAgIHRoaXMud3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLndyYXBwZXIuY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uLXdyYXBwZXInO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLndyYXBwZXIpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZG9tRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLndyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy5kb21FbGVtZW50c1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zaG93UG9wdXBJZk5lZWRlZCgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGRlbGV0ZSBhbGwgRE9NIGVsZW1lbnRzXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY2xlYW4nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jbGVhbigpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRvbUVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy53cmFwcGVyLnJlbW92ZUNoaWxkKHRoaXMuZG9tRWxlbWVudHNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMud3JhcHBlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy53cmFwcGVyKTtcbiAgICAgICAgICB0aGlzLndyYXBwZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kb21FbGVtZW50cyA9IFtdO1xuXG4gICAgICAgIHRoaXMuX3JlbW92ZVBvcHVwKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBhY3R1YWxPcHRpb25zIGlmIGl0IGV4aXN0c1xuICAgICAgICogQHBhcmFtIHthcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19nZXRWYWx1ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFZhbHVlKHBhdGgpIHtcbiAgICAgICAgdmFyIGJhc2UgPSB0aGlzLm1vZHVsZU9wdGlvbnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChiYXNlW3BhdGhbaV1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJhc2UgPSBiYXNlW3BhdGhbaV1dO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiYXNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGFsbCBvcHRpb24gZWxlbWVudHMgYXJlIHdyYXBwZWQgaW4gYW4gaXRlbVxuICAgICAgICogQHBhcmFtIHBhdGhcbiAgICAgICAqIEBwYXJhbSBkb21FbGVtZW50c1xuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX21ha2VJdGVtJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZUl0ZW0ocGF0aCkge1xuICAgICAgICB2YXIgX2FyZ3VtZW50cyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHRoaXMuYWxsb3dDcmVhdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBfbGVuLCBkb21FbGVtZW50cywgX2tleTtcblxuICAgICAgICAgIHZhciBfcmV0MiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBpdGVtLmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWl0ZW0gdmlzLWNvbmZpZy1zJyArIHBhdGgubGVuZ3RoO1xuXG4gICAgICAgICAgICBmb3IgKF9sZW4gPSBfYXJndW1lbnRzLmxlbmd0aCwgZG9tRWxlbWVudHMgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgICAgIGRvbUVsZW1lbnRzW19rZXkgLSAxXSA9IF9hcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRvbUVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgaXRlbS5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3RoaXMyLmRvbUVsZW1lbnRzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB2OiBfdGhpczIuZG9tRWxlbWVudHMubGVuZ3RoXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0oKTtcblxuICAgICAgICAgIGlmICgodHlwZW9mIF9yZXQyID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihfcmV0MikpID09PSBcIm9iamVjdFwiKSByZXR1cm4gX3JldDIudjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBoZWFkZXIgZm9yIG1ham9yIHN1YmplY3RzXG4gICAgICAgKiBAcGFyYW0gbmFtZVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX21ha2VIZWFkZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlSGVhZGVyKG5hbWUpIHtcbiAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBkaXYuY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctaGVhZGVyJztcbiAgICAgICAgZGl2LmlubmVySFRNTCA9IG5hbWU7XG4gICAgICAgIHRoaXMuX21ha2VJdGVtKFtdLCBkaXYpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIG1ha2UgYSBsYWJlbCwgaWYgaXQgaXMgYW4gb2JqZWN0IGxhYmVsLCBpdCBnZXRzIGRpZmZlcmVudCBzdHlsaW5nLlxuICAgICAgICogQHBhcmFtIG5hbWVcbiAgICAgICAqIEBwYXJhbSBwYXRoXG4gICAgICAgKiBAcGFyYW0gb2JqZWN0TGFiZWxcbiAgICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19tYWtlTGFiZWwnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlTGFiZWwobmFtZSwgcGF0aCkge1xuICAgICAgICB2YXIgb2JqZWN0TGFiZWwgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1syXTtcblxuICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGRpdi5jbGFzc05hbWUgPSAndmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1sYWJlbCB2aXMtY29uZmlnLXMnICsgcGF0aC5sZW5ndGg7XG4gICAgICAgIGlmIChvYmplY3RMYWJlbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSAnPGk+PGI+JyArIG5hbWUgKyAnOjwvYj48L2k+JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gbmFtZSArICc6JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGl2O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIG1ha2UgYSBkcm9wZG93biBsaXN0IGZvciBtdWx0aXBsZSBwb3NzaWJsZSBzdHJpbmcgb3B0b2luc1xuICAgICAgICogQHBhcmFtIGFyclxuICAgICAgICogQHBhcmFtIHZhbHVlXG4gICAgICAgKiBAcGFyYW0gcGF0aFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX21ha2VEcm9wZG93bicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VEcm9wZG93bihhcnIsIHZhbHVlLCBwYXRoKSB7XG4gICAgICAgIHZhciBzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcbiAgICAgICAgc2VsZWN0LmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLXNlbGVjdCc7XG4gICAgICAgIHZhciBzZWxlY3RlZFZhbHVlID0gMDtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoYXJyLmluZGV4T2YodmFsdWUpICE9PSAtMSkge1xuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZSA9IGFyci5pbmRleE9mKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBvcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgICAgICAgICBvcHRpb24udmFsdWUgPSBhcnJbaV07XG4gICAgICAgICAgaWYgKGkgPT09IHNlbGVjdGVkVmFsdWUpIHtcbiAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9ICdzZWxlY3RlZCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9wdGlvbi5pbm5lckhUTUwgPSBhcnJbaV07XG4gICAgICAgICAgc2VsZWN0LmFwcGVuZENoaWxkKG9wdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBzZWxlY3Qub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbWUuX3VwZGF0ZSh0aGlzLnZhbHVlLCBwYXRoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbGFiZWwgPSB0aGlzLl9tYWtlTGFiZWwocGF0aFtwYXRoLmxlbmd0aCAtIDFdLCBwYXRoKTtcbiAgICAgICAgdGhpcy5fbWFrZUl0ZW0ocGF0aCwgbGFiZWwsIHNlbGVjdCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogbWFrZSBhIHJhbmdlIG9iamVjdCBmb3IgbnVtZXJpYyBvcHRpb25zXG4gICAgICAgKiBAcGFyYW0gYXJyXG4gICAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgICAqIEBwYXJhbSBwYXRoXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfbWFrZVJhbmdlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZVJhbmdlKGFyciwgdmFsdWUsIHBhdGgpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IGFyclswXTtcbiAgICAgICAgdmFyIG1pbiA9IGFyclsxXTtcbiAgICAgICAgdmFyIG1heCA9IGFyclsyXTtcbiAgICAgICAgdmFyIHN0ZXAgPSBhcnJbM107XG4gICAgICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIHJhbmdlLmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLXJhbmdlJztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByYW5nZS50eXBlID0gJ3JhbmdlJzsgLy8gbm90IHN1cHBvcnRlZCBvbiBJRTlcbiAgICAgICAgICByYW5nZS5taW4gPSBtaW47XG4gICAgICAgICAgcmFuZ2UubWF4ID0gbWF4O1xuICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgIHJhbmdlLnN0ZXAgPSBzdGVwO1xuXG4gICAgICAgIC8vIHNldCB1cCB0aGUgcG9wdXAgc2V0dGluZ3MgaW4gY2FzZSB0aGV5IGFyZSBuZWVkZWQuXG4gICAgICAgIHZhciBwb3B1cFN0cmluZyA9ICcnO1xuICAgICAgICB2YXIgcG9wdXBWYWx1ZSA9IDA7XG5cbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgZmFjdG9yID0gMS4yMDtcbiAgICAgICAgICBpZiAodmFsdWUgPCAwICYmIHZhbHVlICogZmFjdG9yIDwgbWluKSB7XG4gICAgICAgICAgICByYW5nZS5taW4gPSBNYXRoLmNlaWwodmFsdWUgKiBmYWN0b3IpO1xuICAgICAgICAgICAgcG9wdXBWYWx1ZSA9IHJhbmdlLm1pbjtcbiAgICAgICAgICAgIHBvcHVwU3RyaW5nID0gJ3JhbmdlIGluY3JlYXNlZCc7XG4gICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSAvIGZhY3RvciA8IG1pbikge1xuICAgICAgICAgICAgcmFuZ2UubWluID0gTWF0aC5jZWlsKHZhbHVlIC8gZmFjdG9yKTtcbiAgICAgICAgICAgIHBvcHVwVmFsdWUgPSByYW5nZS5taW47XG4gICAgICAgICAgICBwb3B1cFN0cmluZyA9ICdyYW5nZSBpbmNyZWFzZWQnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUgKiBmYWN0b3IgPiBtYXggJiYgbWF4ICE9PSAxKSB7XG4gICAgICAgICAgICByYW5nZS5tYXggPSBNYXRoLmNlaWwodmFsdWUgKiBmYWN0b3IpO1xuICAgICAgICAgICAgcG9wdXBWYWx1ZSA9IHJhbmdlLm1heDtcbiAgICAgICAgICAgIHBvcHVwU3RyaW5nID0gJ3JhbmdlIGluY3JlYXNlZCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJhbmdlLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmFuZ2UudmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICBpbnB1dC5jbGFzc05hbWUgPSAndmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1yYW5nZWlucHV0JztcbiAgICAgICAgaW5wdXQudmFsdWUgPSByYW5nZS52YWx1ZTtcblxuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICByYW5nZS5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpbnB1dC52YWx1ZSA9IHRoaXMudmFsdWU7bWUuX3VwZGF0ZShOdW1iZXIodGhpcy52YWx1ZSksIHBhdGgpO1xuICAgICAgICB9O1xuICAgICAgICByYW5nZS5vbmlucHV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlucHV0LnZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbGFiZWwgPSB0aGlzLl9tYWtlTGFiZWwocGF0aFtwYXRoLmxlbmd0aCAtIDFdLCBwYXRoKTtcbiAgICAgICAgdmFyIGl0ZW1JbmRleCA9IHRoaXMuX21ha2VJdGVtKHBhdGgsIGxhYmVsLCByYW5nZSwgaW5wdXQpO1xuXG4gICAgICAgIC8vIGlmIGEgcG9wdXAgaXMgbmVlZGVkIEFORCBpdCBoYXMgbm90IGJlZW4gc2hvd24gZm9yIHRoaXMgdmFsdWUsIHNob3cgaXQuXG4gICAgICAgIGlmIChwb3B1cFN0cmluZyAhPT0gJycgJiYgdGhpcy5wb3B1cEhpc3RvcnlbaXRlbUluZGV4XSAhPT0gcG9wdXBWYWx1ZSkge1xuICAgICAgICAgIHRoaXMucG9wdXBIaXN0b3J5W2l0ZW1JbmRleF0gPSBwb3B1cFZhbHVlO1xuICAgICAgICAgIHRoaXMuX3NldHVwUG9wdXAocG9wdXBTdHJpbmcsIGl0ZW1JbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBwcmVwYXJlIHRoZSBwb3B1cFxuICAgICAgICogQHBhcmFtIHN0cmluZ1xuICAgICAgICogQHBhcmFtIGluZGV4XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc2V0dXBQb3B1cCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwUG9wdXAoc3RyaW5nLCBpbmRleCkge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICBpZiAodGhpcy5pbml0aWFsaXplZCA9PT0gdHJ1ZSAmJiB0aGlzLmFsbG93Q3JlYXRpb24gPT09IHRydWUgJiYgdGhpcy5wb3B1cENvdW50ZXIgPCB0aGlzLnBvcHVwTGltaXQpIHtcbiAgICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICBkaXYuaWQgPSBcInZpcy1jb25maWd1cmF0aW9uLXBvcHVwXCI7XG4gICAgICAgICAgZGl2LmNsYXNzTmFtZSA9IFwidmlzLWNvbmZpZ3VyYXRpb24tcG9wdXBcIjtcbiAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gc3RyaW5nO1xuICAgICAgICAgIGRpdi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLl9yZW1vdmVQb3B1cCgpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5wb3B1cENvdW50ZXIgKz0gMTtcbiAgICAgICAgICB0aGlzLnBvcHVwRGl2ID0geyBodG1sOiBkaXYsIGluZGV4OiBpbmRleCB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogcmVtb3ZlIHRoZSBwb3B1cCBmcm9tIHRoZSBkb21cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19yZW1vdmVQb3B1cCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZVBvcHVwKCkge1xuICAgICAgICBpZiAodGhpcy5wb3B1cERpdi5odG1sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnBvcHVwRGl2Lmh0bWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnBvcHVwRGl2Lmh0bWwpO1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBvcHVwRGl2LmhpZGVUaW1lb3V0KTtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5wb3B1cERpdi5kZWxldGVUaW1lb3V0KTtcbiAgICAgICAgICB0aGlzLnBvcHVwRGl2ID0ge307XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTaG93IHRoZSBwb3B1cCBpZiBpdCBpcyBuZWVkZWQuXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc2hvd1BvcHVwSWZOZWVkZWQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zaG93UG9wdXBJZk5lZWRlZCgpIHtcbiAgICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHRoaXMucG9wdXBEaXYuaHRtbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIGNvcnJlc3BvbmRpbmdFbGVtZW50ID0gdGhpcy5kb21FbGVtZW50c1t0aGlzLnBvcHVwRGl2LmluZGV4XTtcbiAgICAgICAgICB2YXIgcmVjdCA9IGNvcnJlc3BvbmRpbmdFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgIHRoaXMucG9wdXBEaXYuaHRtbC5zdHlsZS5sZWZ0ID0gcmVjdC5sZWZ0ICsgXCJweFwiO1xuICAgICAgICAgIHRoaXMucG9wdXBEaXYuaHRtbC5zdHlsZS50b3AgPSByZWN0LnRvcCAtIDMwICsgXCJweFwiOyAvLyAzMCBpcyB0aGUgaGVpZ2h0O1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5wb3B1cERpdi5odG1sKTtcbiAgICAgICAgICB0aGlzLnBvcHVwRGl2LmhpZGVUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczQucG9wdXBEaXYuaHRtbC5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgICB9LCAxNTAwKTtcbiAgICAgICAgICB0aGlzLnBvcHVwRGl2LmRlbGV0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzNC5fcmVtb3ZlUG9wdXAoKTtcbiAgICAgICAgICB9LCAxODAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIG1ha2UgYSBjaGVja2JveCBmb3IgYm9vbGVhbiBvcHRpb25zLlxuICAgICAgICogQHBhcmFtIGRlZmF1bHRWYWx1ZVxuICAgICAgICogQHBhcmFtIHZhbHVlXG4gICAgICAgKiBAcGFyYW0gcGF0aFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX21ha2VDaGVja2JveCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VDaGVja2JveChkZWZhdWx0VmFsdWUsIHZhbHVlLCBwYXRoKSB7XG4gICAgICAgIHZhciBjaGVja2JveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIGNoZWNrYm94LnR5cGUgPSAnY2hlY2tib3gnO1xuICAgICAgICBjaGVja2JveC5jbGFzc05hbWUgPSAndmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1jaGVja2JveCc7XG4gICAgICAgIGNoZWNrYm94LmNoZWNrZWQgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY2hlY2tib3guY2hlY2tlZCA9IHZhbHVlO1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoKHR5cGVvZiBkZWZhdWx0VmFsdWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGRlZmF1bHRWYWx1ZSkpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IGRlZmF1bHRWYWx1ZS5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkT3B0aW9ucy5wdXNoKHsgcGF0aDogcGF0aCwgdmFsdWU6IHZhbHVlIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmNoYW5nZWRPcHRpb25zLnB1c2goeyBwYXRoOiBwYXRoLCB2YWx1ZTogdmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgY2hlY2tib3gub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbWUuX3VwZGF0ZSh0aGlzLmNoZWNrZWQsIHBhdGgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBsYWJlbCA9IHRoaXMuX21ha2VMYWJlbChwYXRoW3BhdGgubGVuZ3RoIC0gMV0sIHBhdGgpO1xuICAgICAgICB0aGlzLl9tYWtlSXRlbShwYXRoLCBsYWJlbCwgY2hlY2tib3gpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIG1ha2UgYSB0ZXh0IGlucHV0IGZpZWxkIGZvciBzdHJpbmcgb3B0aW9ucy5cbiAgICAgICAqIEBwYXJhbSBkZWZhdWx0VmFsdWVcbiAgICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAgICogQHBhcmFtIHBhdGhcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19tYWtlVGV4dElucHV0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZVRleHRJbnB1dChkZWZhdWx0VmFsdWUsIHZhbHVlLCBwYXRoKSB7XG4gICAgICAgIHZhciBjaGVja2JveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIGNoZWNrYm94LnR5cGUgPSAndGV4dCc7XG4gICAgICAgIGNoZWNrYm94LmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLXRleHQnO1xuICAgICAgICBjaGVja2JveC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgIT09IGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgIHRoaXMuY2hhbmdlZE9wdGlvbnMucHVzaCh7IHBhdGg6IHBhdGgsIHZhbHVlOiB2YWx1ZSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIGNoZWNrYm94Lm9uY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG1lLl91cGRhdGUodGhpcy52YWx1ZSwgcGF0aCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGxhYmVsID0gdGhpcy5fbWFrZUxhYmVsKHBhdGhbcGF0aC5sZW5ndGggLSAxXSwgcGF0aCk7XG4gICAgICAgIHRoaXMuX21ha2VJdGVtKHBhdGgsIGxhYmVsLCBjaGVja2JveCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogbWFrZSBhIGNvbG9yIGZpZWxkIHdpdGggYSBjb2xvciBwaWNrZXIgZm9yIGNvbG9yIGZpZWxkc1xuICAgICAgICogQHBhcmFtIGFyclxuICAgICAgICogQHBhcmFtIHZhbHVlXG4gICAgICAgKiBAcGFyYW0gcGF0aFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX21ha2VDb2xvckZpZWxkJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZUNvbG9yRmllbGQoYXJyLCB2YWx1ZSwgcGF0aCkge1xuICAgICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgICB2YXIgZGVmYXVsdENvbG9yID0gYXJyWzFdO1xuICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRDb2xvciA6IHZhbHVlO1xuXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgZGl2LmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWNvbG9yQmxvY2snO1xuICAgICAgICAgIGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkaXYuY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctY29sb3JCbG9jayBub25lJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gdmFsdWUgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRDb2xvciA6IHZhbHVlO1xuICAgICAgICBkaXYub25jbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczUuX3Nob3dDb2xvclBpY2tlcih2YWx1ZSwgZGl2LCBwYXRoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbGFiZWwgPSB0aGlzLl9tYWtlTGFiZWwocGF0aFtwYXRoLmxlbmd0aCAtIDFdLCBwYXRoKTtcbiAgICAgICAgdGhpcy5fbWFrZUl0ZW0ocGF0aCwgbGFiZWwsIGRpdik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogdXNlZCBieSB0aGUgY29sb3IgYnV0dG9ucyB0byBjYWxsIHRoZSBjb2xvciBwaWNrZXIuXG4gICAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAgICogQHBhcmFtIGRpdlxuICAgICAgICogQHBhcmFtIHBhdGhcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19zaG93Q29sb3JQaWNrZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zaG93Q29sb3JQaWNrZXIodmFsdWUsIGRpdiwgcGF0aCkge1xuICAgICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgICAvLyBjbGVhciB0aGUgY2FsbGJhY2sgZnJvbSB0aGlzIGRpdlxuICAgICAgICBkaXYub25jbGljayA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgICAgIHRoaXMuY29sb3JQaWNrZXIuaW5zZXJ0VG8oZGl2KTtcbiAgICAgICAgdGhpcy5jb2xvclBpY2tlci5zaG93KCk7XG5cbiAgICAgICAgdGhpcy5jb2xvclBpY2tlci5zZXRDb2xvcih2YWx1ZSk7XG4gICAgICAgIHRoaXMuY29sb3JQaWNrZXIuc2V0VXBkYXRlQ2FsbGJhY2soZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgICAgdmFyIGNvbG9yU3RyaW5nID0gJ3JnYmEoJyArIGNvbG9yLnIgKyAnLCcgKyBjb2xvci5nICsgJywnICsgY29sb3IuYiArICcsJyArIGNvbG9yLmEgKyAnKSc7XG4gICAgICAgICAgZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yU3RyaW5nO1xuICAgICAgICAgIF90aGlzNi5fdXBkYXRlKGNvbG9yU3RyaW5nLCBwYXRoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gb24gY2xvc2Ugb2YgdGhlIGNvbG9ycGlja2VyLCByZXN0b3JlIHRoZSBjYWxsYmFjay5cbiAgICAgICAgdGhpcy5jb2xvclBpY2tlci5zZXRDbG9zZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkaXYub25jbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzNi5fc2hvd0NvbG9yUGlja2VyKHZhbHVlLCBkaXYsIHBhdGgpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHBhcnNlIGFuIG9iamVjdCBhbmQgZHJhdyB0aGUgY29ycmVjdCBpdGVtc1xuICAgICAgICogQHBhcmFtIG9ialxuICAgICAgICogQHBhcmFtIHBhdGhcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19oYW5kbGVPYmplY3QnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVPYmplY3Qob2JqKSB7XG4gICAgICAgIHZhciBwYXRoID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gW10gOiBhcmd1bWVudHNbMV07XG4gICAgICAgIHZhciBjaGVja09ubHkgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1syXTtcblxuICAgICAgICB2YXIgc2hvdyA9IGZhbHNlO1xuICAgICAgICB2YXIgZmlsdGVyID0gdGhpcy5vcHRpb25zLmZpbHRlcjtcbiAgICAgICAgdmFyIHZpc2libGVJblNldCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBzdWJPYmogaW4gb2JqKSB7XG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShzdWJPYmopKSB7XG4gICAgICAgICAgICBzaG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBpdGVtID0gb2JqW3N1Yk9ial07XG4gICAgICAgICAgICB2YXIgbmV3UGF0aCA9IHV0aWwuY29weUFuZEV4dGVuZEFycmF5KHBhdGgsIHN1Yk9iaik7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBzaG93ID0gZmlsdGVyKHN1Yk9iaiwgcGF0aCk7XG5cbiAgICAgICAgICAgICAgLy8gaWYgbmVlZGVkIHdlIG11c3QgZ28gZGVlcGVyIGludG8gdGhlIG9iamVjdC5cbiAgICAgICAgICAgICAgaWYgKHNob3cgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoaXRlbSBpbnN0YW5jZW9mIEFycmF5KSAmJiB0eXBlb2YgaXRlbSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIGl0ZW0gIT09ICdib29sZWFuJyAmJiBpdGVtIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmFsbG93Q3JlYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIHNob3cgPSB0aGlzLl9oYW5kbGVPYmplY3QoaXRlbSwgbmV3UGF0aCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICB0aGlzLmFsbG93Q3JlYXRpb24gPSBjaGVja09ubHkgPT09IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2hvdyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgdmlzaWJsZUluU2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fZ2V0VmFsdWUobmV3UGF0aCk7XG5cbiAgICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZUFycmF5KGl0ZW0sIHZhbHVlLCBuZXdQYXRoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYWtlVGV4dElucHV0KGl0ZW0sIHZhbHVlLCBuZXdQYXRoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFrZUNoZWNrYm94KGl0ZW0sIHZhbHVlLCBuZXdQYXRoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgLy8gY29sbGFwc2UgdGhlIHBoeXNpY3Mgb3B0aW9ucyB0aGF0IGFyZSBub3QgZW5hYmxlZFxuICAgICAgICAgICAgICAgIHZhciBkcmF3ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAocGF0aC5pbmRleE9mKCdwaHlzaWNzJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy5tb2R1bGVPcHRpb25zLnBoeXNpY3Muc29sdmVyICE9PSBzdWJPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhdyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChkcmF3ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAvLyBpbml0aWFsbHkgY29sbGFwc2Ugb3B0aW9ucyB3aXRoIGFuIGRpc2FibGVkIGVuYWJsZWQgb3B0aW9uLlxuICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uZW5hYmxlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmFibGVkUGF0aCA9IHV0aWwuY29weUFuZEV4dGVuZEFycmF5KG5ld1BhdGgsICdlbmFibGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmFibGVkVmFsdWUgPSB0aGlzLl9nZXRWYWx1ZShlbmFibGVkUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmFibGVkVmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFiZWwgPSB0aGlzLl9tYWtlTGFiZWwoc3ViT2JqLCBuZXdQYXRoLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYWtlSXRlbShuZXdQYXRoLCBsYWJlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgdmlzaWJsZUluU2V0ID0gdGhpcy5faGFuZGxlT2JqZWN0KGl0ZW0sIG5ld1BhdGgpIHx8IHZpc2libGVJblNldDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYWtlQ2hlY2tib3goaXRlbSwgZW5hYmxlZFZhbHVlLCBuZXdQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9sYWJlbCA9IHRoaXMuX21ha2VMYWJlbChzdWJPYmosIG5ld1BhdGgsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYWtlSXRlbShuZXdQYXRoLCBfbGFiZWwpO1xuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlSW5TZXQgPSB0aGlzLl9oYW5kbGVPYmplY3QoaXRlbSwgbmV3UGF0aCkgfHwgdmlzaWJsZUluU2V0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdkb250IGtub3cgaG93IHRvIGhhbmRsZScsIGl0ZW0sIHN1Yk9iaiwgbmV3UGF0aCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZpc2libGVJblNldDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBoYW5kbGUgdGhlIGFycmF5IHR5cGUgb2Ygb3B0aW9uXG4gICAgICAgKiBAcGFyYW0gb3B0aW9uTmFtZVxuICAgICAgICogQHBhcmFtIGFyclxuICAgICAgICogQHBhcmFtIHZhbHVlXG4gICAgICAgKiBAcGFyYW0gcGF0aFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2hhbmRsZUFycmF5JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlQXJyYXkoYXJyLCB2YWx1ZSwgcGF0aCkge1xuICAgICAgICBpZiAodHlwZW9mIGFyclswXSA9PT0gJ3N0cmluZycgJiYgYXJyWzBdID09PSAnY29sb3InKSB7XG4gICAgICAgICAgdGhpcy5fbWFrZUNvbG9yRmllbGQoYXJyLCB2YWx1ZSwgcGF0aCk7XG4gICAgICAgICAgaWYgKGFyclsxXSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlZE9wdGlvbnMucHVzaCh7IHBhdGg6IHBhdGgsIHZhbHVlOiB2YWx1ZSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyclswXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aGlzLl9tYWtlRHJvcGRvd24oYXJyLCB2YWx1ZSwgcGF0aCk7XG4gICAgICAgICAgaWYgKGFyclswXSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlZE9wdGlvbnMucHVzaCh7IHBhdGg6IHBhdGgsIHZhbHVlOiB2YWx1ZSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyclswXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0aGlzLl9tYWtlUmFuZ2UoYXJyLCB2YWx1ZSwgcGF0aCk7XG4gICAgICAgICAgaWYgKGFyclswXSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlZE9wdGlvbnMucHVzaCh7IHBhdGg6IHBhdGgsIHZhbHVlOiBOdW1iZXIodmFsdWUpIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGNhbGxlZCB0byB1cGRhdGUgdGhlIG5ldHdvcmsgd2l0aCB0aGUgbmV3IHNldHRpbmdzLlxuICAgICAgICogQHBhcmFtIHZhbHVlXG4gICAgICAgKiBAcGFyYW0gcGF0aFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3VwZGF0ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZSh2YWx1ZSwgcGF0aCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuX2NvbnN0cnVjdE9wdGlvbnModmFsdWUsIHBhdGgpO1xuXG4gICAgICAgIGlmICh0aGlzLnBhcmVudC5ib2R5ICYmIHRoaXMucGFyZW50LmJvZHkuZW1pdHRlciAmJiB0aGlzLnBhcmVudC5ib2R5LmVtaXR0ZXIuZW1pdCkge1xuICAgICAgICAgIHRoaXMucGFyZW50LmJvZHkuZW1pdHRlci5lbWl0KFwiY29uZmlnQ2hhbmdlXCIsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnBhcmVudC5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19jb25zdHJ1Y3RPcHRpb25zJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY29uc3RydWN0T3B0aW9ucyh2YWx1ZSwgcGF0aCkge1xuICAgICAgICB2YXIgb3B0aW9uc09iaiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzJdO1xuXG4gICAgICAgIHZhciBwb2ludGVyID0gb3B0aW9uc09iajtcblxuICAgICAgICAvLyB3aGVuIGRyb3Bkb3duIGJveGVzIGNhbiBiZSBzdHJpbmcgb3IgYm9vbGVhbiwgd2UgdHlwZWNhc3QgaXQgaW50byBjb3JyZWN0IHR5cGVzXG4gICAgICAgIHZhbHVlID0gdmFsdWUgPT09ICd0cnVlJyA/IHRydWUgOiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gJ2ZhbHNlJyA/IGZhbHNlIDogdmFsdWU7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHBhdGhbaV0gIT09ICdnbG9iYWwnKSB7XG4gICAgICAgICAgICBpZiAocG9pbnRlcltwYXRoW2ldXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHBvaW50ZXJbcGF0aFtpXV0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpICE9PSBwYXRoLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgcG9pbnRlciA9IHBvaW50ZXJbcGF0aFtpXV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwb2ludGVyW3BhdGhbaV1dID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRpb25zT2JqO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19wcmludE9wdGlvbnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9wcmludE9wdGlvbnMoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5nZXRPcHRpb25zKCk7XG4gICAgICAgIHRoaXMub3B0aW9uc0NvbnRhaW5lci5pbm5lckhUTUwgPSAnPHByZT52YXIgb3B0aW9ucyA9ICcgKyBKU09OLnN0cmluZ2lmeShvcHRpb25zLCBudWxsLCAyKSArICc8L3ByZT4nO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldE9wdGlvbnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldE9wdGlvbnMoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGFuZ2VkT3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuX2NvbnN0cnVjdE9wdGlvbnModGhpcy5jaGFuZ2VkT3B0aW9uc1tpXS52YWx1ZSwgdGhpcy5jaGFuZ2VkT3B0aW9uc1tpXS5wYXRoLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQ29uZmlndXJhdG9yO1xuICB9KCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gQ29uZmlndXJhdG9yO1xuXG4vKioqLyB9LFxuLyogMjcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgdmFyIEhhbW1lciA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuICB2YXIgaGFtbWVyVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbiAgdmFyIENvbG9yUGlja2VyID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbG9yUGlja2VyKCkge1xuICAgICAgdmFyIHBpeGVsUmF0aW8gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyAxIDogYXJndW1lbnRzWzBdO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29sb3JQaWNrZXIpO1xuXG4gICAgICB0aGlzLnBpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xuICAgICAgdGhpcy5nZW5lcmF0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMgPSB7IHg6IDI4OSAvIDIsIHk6IDI4OSAvIDIgfTtcbiAgICAgIHRoaXMuciA9IDI4OSAqIDAuNDk7XG4gICAgICB0aGlzLmNvbG9yID0geyByOiAyNTUsIGc6IDI1NSwgYjogMjU1LCBhOiAxLjAgfTtcbiAgICAgIHRoaXMuaHVlQ2lyY2xlID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5pbml0aWFsQ29sb3IgPSB7IHI6IDI1NSwgZzogMjU1LCBiOiAyNTUsIGE6IDEuMCB9O1xuICAgICAgdGhpcy5wcmV2aW91c0NvbG9yID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5hcHBsaWVkID0gZmFsc2U7XG5cbiAgICAgIC8vIGJvdW5kIGJ5XG4gICAgICB0aGlzLnVwZGF0ZUNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICB0aGlzLmNsb3NlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgICAgLy8gY3JlYXRlIGFsbCBET00gZWxlbWVudHNcbiAgICAgIHRoaXMuX2NyZWF0ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRoaXMgaW5zZXJ0cyB0aGUgY29sb3JQaWNrZXIgaW50byBhIGRpdiBmcm9tIHRoZSBET01cbiAgICAgKiBAcGFyYW0gY29udGFpbmVyXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhDb2xvclBpY2tlciwgW3tcbiAgICAgIGtleTogJ2luc2VydFRvJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRUbyhjb250YWluZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFtbWVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmhhbW1lci5kZXN0cm95KCk7XG4gICAgICAgICAgdGhpcy5oYW1tZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZnJhbWUpO1xuICAgICAgICB0aGlzLl9iaW5kSGFtbWVyKCk7XG5cbiAgICAgICAgdGhpcy5fc2V0U2l6ZSgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHRoZSBjYWxsYmFjayBpcyBleGVjdXRlZCBvbiBhcHBseSBhbmQgc2F2ZS4gQmluZCBpdCB0byB0aGUgYXBwbGljYXRpb25cbiAgICAgICAqIEBwYXJhbSBjYWxsYmFja1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzZXRVcGRhdGVDYWxsYmFjaycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VXBkYXRlQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRoaXMudXBkYXRlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBhdHRlbXB0ZWQgdG8gc2V0IGFzIGNvbG9yUGlja2VyIHVwZGF0ZSBjYWxsYmFjayBpcyBub3QgYSBmdW5jdGlvbi5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiB0aGUgY2FsbGJhY2sgaXMgZXhlY3V0ZWQgb24gYXBwbHkgYW5kIHNhdmUuIEJpbmQgaXQgdG8gdGhlIGFwcGxpY2F0aW9uXG4gICAgICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc2V0Q2xvc2VDYWxsYmFjaycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q2xvc2VDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhpcy5jbG9zZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gYXR0ZW1wdGVkIHRvIHNldCBhcyBjb2xvclBpY2tlciBjbG9zaW5nIGNhbGxiYWNrIGlzIG5vdCBhIGZ1bmN0aW9uLlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19pc0NvbG9yU3RyaW5nJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNDb2xvclN0cmluZyhjb2xvcikge1xuICAgICAgICB2YXIgaHRtbENvbG9ycyA9IHsgYmxhY2s6ICcjMDAwMDAwJywgbmF2eTogJyMwMDAwODAnLCBkYXJrYmx1ZTogJyMwMDAwOEInLCBtZWRpdW1ibHVlOiAnIzAwMDBDRCcsIGJsdWU6ICcjMDAwMEZGJywgZGFya2dyZWVuOiAnIzAwNjQwMCcsIGdyZWVuOiAnIzAwODAwMCcsIHRlYWw6ICcjMDA4MDgwJywgZGFya2N5YW46ICcjMDA4QjhCJywgZGVlcHNreWJsdWU6ICcjMDBCRkZGJywgZGFya3R1cnF1b2lzZTogJyMwMENFRDEnLCBtZWRpdW1zcHJpbmdncmVlbjogJyMwMEZBOUEnLCBsaW1lOiAnIzAwRkYwMCcsIHNwcmluZ2dyZWVuOiAnIzAwRkY3RicsIGFxdWE6ICcjMDBGRkZGJywgY3lhbjogJyMwMEZGRkYnLCBtaWRuaWdodGJsdWU6ICcjMTkxOTcwJywgZG9kZ2VyYmx1ZTogJyMxRTkwRkYnLCBsaWdodHNlYWdyZWVuOiAnIzIwQjJBQScsIGZvcmVzdGdyZWVuOiAnIzIyOEIyMicsIHNlYWdyZWVuOiAnIzJFOEI1NycsIGRhcmtzbGF0ZWdyYXk6ICcjMkY0RjRGJywgbGltZWdyZWVuOiAnIzMyQ0QzMicsIG1lZGl1bXNlYWdyZWVuOiAnIzNDQjM3MScsIHR1cnF1b2lzZTogJyM0MEUwRDAnLCByb3lhbGJsdWU6ICcjNDE2OUUxJywgc3RlZWxibHVlOiAnIzQ2ODJCNCcsIGRhcmtzbGF0ZWJsdWU6ICcjNDgzRDhCJywgbWVkaXVtdHVycXVvaXNlOiAnIzQ4RDFDQycsIGluZGlnbzogJyM0QjAwODInLCBkYXJrb2xpdmVncmVlbjogJyM1NTZCMkYnLCBjYWRldGJsdWU6ICcjNUY5RUEwJywgY29ybmZsb3dlcmJsdWU6ICcjNjQ5NUVEJywgbWVkaXVtYXF1YW1hcmluZTogJyM2NkNEQUEnLCBkaW1ncmF5OiAnIzY5Njk2OScsIHNsYXRlYmx1ZTogJyM2QTVBQ0QnLCBvbGl2ZWRyYWI6ICcjNkI4RTIzJywgc2xhdGVncmF5OiAnIzcwODA5MCcsIGxpZ2h0c2xhdGVncmF5OiAnIzc3ODg5OScsIG1lZGl1bXNsYXRlYmx1ZTogJyM3QjY4RUUnLCBsYXduZ3JlZW46ICcjN0NGQzAwJywgY2hhcnRyZXVzZTogJyM3RkZGMDAnLCBhcXVhbWFyaW5lOiAnIzdGRkZENCcsIG1hcm9vbjogJyM4MDAwMDAnLCBwdXJwbGU6ICcjODAwMDgwJywgb2xpdmU6ICcjODA4MDAwJywgZ3JheTogJyM4MDgwODAnLCBza3libHVlOiAnIzg3Q0VFQicsIGxpZ2h0c2t5Ymx1ZTogJyM4N0NFRkEnLCBibHVldmlvbGV0OiAnIzhBMkJFMicsIGRhcmtyZWQ6ICcjOEIwMDAwJywgZGFya21hZ2VudGE6ICcjOEIwMDhCJywgc2FkZGxlYnJvd246ICcjOEI0NTEzJywgZGFya3NlYWdyZWVuOiAnIzhGQkM4RicsIGxpZ2h0Z3JlZW46ICcjOTBFRTkwJywgbWVkaXVtcHVycGxlOiAnIzkzNzBEOCcsIGRhcmt2aW9sZXQ6ICcjOTQwMEQzJywgcGFsZWdyZWVuOiAnIzk4RkI5OCcsIGRhcmtvcmNoaWQ6ICcjOTkzMkNDJywgeWVsbG93Z3JlZW46ICcjOUFDRDMyJywgc2llbm5hOiAnI0EwNTIyRCcsIGJyb3duOiAnI0E1MkEyQScsIGRhcmtncmF5OiAnI0E5QTlBOScsIGxpZ2h0Ymx1ZTogJyNBREQ4RTYnLCBncmVlbnllbGxvdzogJyNBREZGMkYnLCBwYWxldHVycXVvaXNlOiAnI0FGRUVFRScsIGxpZ2h0c3RlZWxibHVlOiAnI0IwQzRERScsIHBvd2RlcmJsdWU6ICcjQjBFMEU2JywgZmlyZWJyaWNrOiAnI0IyMjIyMicsIGRhcmtnb2xkZW5yb2Q6ICcjQjg4NjBCJywgbWVkaXVtb3JjaGlkOiAnI0JBNTVEMycsIHJvc3licm93bjogJyNCQzhGOEYnLCBkYXJra2hha2k6ICcjQkRCNzZCJywgc2lsdmVyOiAnI0MwQzBDMCcsIG1lZGl1bXZpb2xldHJlZDogJyNDNzE1ODUnLCBpbmRpYW5yZWQ6ICcjQ0Q1QzVDJywgcGVydTogJyNDRDg1M0YnLCBjaG9jb2xhdGU6ICcjRDI2OTFFJywgdGFuOiAnI0QyQjQ4QycsIGxpZ2h0Z3JleTogJyNEM0QzRDMnLCBwYWxldmlvbGV0cmVkOiAnI0Q4NzA5MycsIHRoaXN0bGU6ICcjRDhCRkQ4Jywgb3JjaGlkOiAnI0RBNzBENicsIGdvbGRlbnJvZDogJyNEQUE1MjAnLCBjcmltc29uOiAnI0RDMTQzQycsIGdhaW5zYm9ybzogJyNEQ0RDREMnLCBwbHVtOiAnI0REQTBERCcsIGJ1cmx5d29vZDogJyNERUI4ODcnLCBsaWdodGN5YW46ICcjRTBGRkZGJywgbGF2ZW5kZXI6ICcjRTZFNkZBJywgZGFya3NhbG1vbjogJyNFOTk2N0EnLCB2aW9sZXQ6ICcjRUU4MkVFJywgcGFsZWdvbGRlbnJvZDogJyNFRUU4QUEnLCBsaWdodGNvcmFsOiAnI0YwODA4MCcsIGtoYWtpOiAnI0YwRTY4QycsIGFsaWNlYmx1ZTogJyNGMEY4RkYnLCBob25leWRldzogJyNGMEZGRjAnLCBhenVyZTogJyNGMEZGRkYnLCBzYW5keWJyb3duOiAnI0Y0QTQ2MCcsIHdoZWF0OiAnI0Y1REVCMycsIGJlaWdlOiAnI0Y1RjVEQycsIHdoaXRlc21va2U6ICcjRjVGNUY1JywgbWludGNyZWFtOiAnI0Y1RkZGQScsIGdob3N0d2hpdGU6ICcjRjhGOEZGJywgc2FsbW9uOiAnI0ZBODA3MicsIGFudGlxdWV3aGl0ZTogJyNGQUVCRDcnLCBsaW5lbjogJyNGQUYwRTYnLCBsaWdodGdvbGRlbnJvZHllbGxvdzogJyNGQUZBRDInLCBvbGRsYWNlOiAnI0ZERjVFNicsIHJlZDogJyNGRjAwMDAnLCBmdWNoc2lhOiAnI0ZGMDBGRicsIG1hZ2VudGE6ICcjRkYwMEZGJywgZGVlcHBpbms6ICcjRkYxNDkzJywgb3JhbmdlcmVkOiAnI0ZGNDUwMCcsIHRvbWF0bzogJyNGRjYzNDcnLCBob3RwaW5rOiAnI0ZGNjlCNCcsIGNvcmFsOiAnI0ZGN0Y1MCcsIGRhcmtvcmFuZ2U6ICcjRkY4QzAwJywgbGlnaHRzYWxtb246ICcjRkZBMDdBJywgb3JhbmdlOiAnI0ZGQTUwMCcsIGxpZ2h0cGluazogJyNGRkI2QzEnLCBwaW5rOiAnI0ZGQzBDQicsIGdvbGQ6ICcjRkZENzAwJywgcGVhY2hwdWZmOiAnI0ZGREFCOScsIG5hdmFqb3doaXRlOiAnI0ZGREVBRCcsIG1vY2Nhc2luOiAnI0ZGRTRCNScsIGJpc3F1ZTogJyNGRkU0QzQnLCBtaXN0eXJvc2U6ICcjRkZFNEUxJywgYmxhbmNoZWRhbG1vbmQ6ICcjRkZFQkNEJywgcGFwYXlhd2hpcDogJyNGRkVGRDUnLCBsYXZlbmRlcmJsdXNoOiAnI0ZGRjBGNScsIHNlYXNoZWxsOiAnI0ZGRjVFRScsIGNvcm5zaWxrOiAnI0ZGRjhEQycsIGxlbW9uY2hpZmZvbjogJyNGRkZBQ0QnLCBmbG9yYWx3aGl0ZTogJyNGRkZBRjAnLCBzbm93OiAnI0ZGRkFGQScsIHllbGxvdzogJyNGRkZGMDAnLCBsaWdodHllbGxvdzogJyNGRkZGRTAnLCBpdm9yeTogJyNGRkZGRjAnLCB3aGl0ZTogJyNGRkZGRkYnIH07XG4gICAgICAgIGlmICh0eXBlb2YgY29sb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIGh0bWxDb2xvcnNbY29sb3JdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0IHRoZSBjb2xvciBvZiB0aGUgY29sb3JQaWNrZXJcbiAgICAgICAqIFN1cHBvcnRlZCBmb3JtYXRzOlxuICAgICAgICogJ3JlZCcgICAgICAgICAgICAgICAgICAgLS0+IEhUTUwgY29sb3Igc3RyaW5nXG4gICAgICAgKiAnI2ZmZmZmZicgICAgICAgICAgICAgICAtLT4gaGV4IHN0cmluZ1xuICAgICAgICogJ3JiZygyNTUsMjU1LDI1NSknICAgICAgLS0+IHJnYiBzdHJpbmdcbiAgICAgICAqICdyZ2JhKDI1NSwyNTUsMjU1LDEuMCknIC0tPiByZ2JhIHN0cmluZ1xuICAgICAgICoge3I6MjU1LGc6MjU1LGI6MjU1fSAgICAgLS0+IHJnYiBvYmplY3RcbiAgICAgICAqIHtyOjI1NSxnOjI1NSxiOjI1NSxhOjEuMH0gLS0+IHJnYmEgb2JqZWN0XG4gICAgICAgKiBAcGFyYW0gY29sb3JcbiAgICAgICAqIEBwYXJhbSBzZXRJbml0aWFsXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NldENvbG9yJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDb2xvcihjb2xvcikge1xuICAgICAgICB2YXIgc2V0SW5pdGlhbCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgaWYgKGNvbG9yID09PSAnbm9uZScpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmdiYSA9IHZvaWQgMDtcblxuICAgICAgICAvLyBpZiBhIGh0bWwgY29sb3Igc2hvcnRoYW5kIGlzIHVzZWQsIGNvbnZlcnQgdG8gaGV4XG4gICAgICAgIHZhciBodG1sQ29sb3IgPSB0aGlzLl9pc0NvbG9yU3RyaW5nKGNvbG9yKTtcbiAgICAgICAgaWYgKGh0bWxDb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29sb3IgPSBodG1sQ29sb3I7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBmb3JtYXRcbiAgICAgICAgaWYgKHV0aWwuaXNTdHJpbmcoY29sb3IpID09PSB0cnVlKSB7XG4gICAgICAgICAgaWYgKHV0aWwuaXNWYWxpZFJHQihjb2xvcikgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHZhciByZ2JhQXJyYXkgPSBjb2xvci5zdWJzdHIoNCkuc3Vic3RyKDAsIGNvbG9yLmxlbmd0aCAtIDUpLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICByZ2JhID0geyByOiByZ2JhQXJyYXlbMF0sIGc6IHJnYmFBcnJheVsxXSwgYjogcmdiYUFycmF5WzJdLCBhOiAxLjAgfTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHV0aWwuaXNWYWxpZFJHQkEoY29sb3IpID09PSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgX3JnYmFBcnJheSA9IGNvbG9yLnN1YnN0cig1KS5zdWJzdHIoMCwgY29sb3IubGVuZ3RoIC0gNikuc3BsaXQoJywnKTtcbiAgICAgICAgICAgIHJnYmEgPSB7IHI6IF9yZ2JhQXJyYXlbMF0sIGc6IF9yZ2JhQXJyYXlbMV0sIGI6IF9yZ2JhQXJyYXlbMl0sIGE6IF9yZ2JhQXJyYXlbM10gfTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHV0aWwuaXNWYWxpZEhleChjb2xvcikgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHZhciByZ2JPYmogPSB1dGlsLmhleFRvUkdCKGNvbG9yKTtcbiAgICAgICAgICAgIHJnYmEgPSB7IHI6IHJnYk9iai5yLCBnOiByZ2JPYmouZywgYjogcmdiT2JqLmIsIGE6IDEuMCB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY29sb3IgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChjb2xvci5yICE9PSB1bmRlZmluZWQgJiYgY29sb3IuZyAhPT0gdW5kZWZpbmVkICYmIGNvbG9yLmIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB2YXIgYWxwaGEgPSBjb2xvci5hICE9PSB1bmRlZmluZWQgPyBjb2xvci5hIDogJzEuMCc7XG4gICAgICAgICAgICAgIHJnYmEgPSB7IHI6IGNvbG9yLnIsIGc6IGNvbG9yLmcsIGI6IGNvbG9yLmIsIGE6IGFscGhhIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IGNvbG9yXG4gICAgICAgIGlmIChyZ2JhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGNvbG9yIHBhc3NlZCB0byB0aGUgY29sb3JQaWNrZXIuIFN1cHBvcnRlZCBhcmUgc3RyaW5nczogcmdiLCBoZXgsIHJnYmEuIE9iamVjdDogcmdiICh7cjpyLGc6ZyxiOmIsW2E6YV19KS4gU3VwcGxpZWQ6IFwiICsgSlNPTi5zdHJpbmdpZnkoY29sb3IpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9zZXRDb2xvcihyZ2JhLCBzZXRJbml0aWFsKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHRoaXMgc2hvd3MgdGhlIGNvbG9yIHBpY2tlci5cbiAgICAgICAqIFRoZSBodWUgY2lyY2xlIGlzIGNvbnN0cnVjdGVkIG9uY2UgYW5kIHN0b3JlZC5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc2hvdycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2hvdygpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VDYWxsYmFjayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5jbG9zZUNhbGxiYWNrKCk7XG4gICAgICAgICAgdGhpcy5jbG9zZUNhbGxiYWNrID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hcHBsaWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIHRoaXMuX2dlbmVyYXRlSHVlQ2lyY2xlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBQUklWQVRFIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbiAgICAgIC8qKlxuICAgICAgICogSGlkZSB0aGUgcGlja2VyLiBJcyBjYWxsZWQgYnkgdGhlIGNhbmNlbCBidXR0b24uXG4gICAgICAgKiBPcHRpb25hbCBib29sZWFuIHRvIHN0b3JlIHRoZSBwcmV2aW91cyBjb2xvciBmb3IgZWFzeSBhY2Nlc3MgbGF0ZXIgb24uXG4gICAgICAgKiBAcGFyYW0gc3RvcmVQcmV2aW91c1xuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2hpZGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oaWRlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBzdG9yZVByZXZpb3VzID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgICAvLyBzdG9yZSB0aGUgcHJldmlvdXMgY29sb3IgZm9yIG5leHQgdGltZTtcbiAgICAgICAgaWYgKHN0b3JlUHJldmlvdXMgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLnByZXZpb3VzQ29sb3IgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5jb2xvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5hcHBsaWVkID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVDYWxsYmFjayh0aGlzLmluaXRpYWxDb2xvcik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgICAgLy8gY2FsbCB0aGUgY2xvc2luZyBjYWxsYmFjaywgcmVzdG9yaW5nIHRoZSBvbmNsaWNrIG1ldGhvZC5cbiAgICAgICAgLy8gdGhpcyBpcyBpbiBhIHNldFRpbWVvdXQgYmVjYXVzZSBpdCB3aWxsIHRyaWdnZXIgdGhlIHNob3cgYWdhaW4gYmVmb3JlIHRoZSBjbGljayBpcyBkb25lLlxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoX3RoaXMuY2xvc2VDYWxsYmFjayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBfdGhpcy5jbG9zZUNhbGxiYWNrKCk7XG4gICAgICAgICAgICBfdGhpcy5jbG9zZUNhbGxiYWNrID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogYm91bmQgdG8gdGhlIHNhdmUgYnV0dG9uLiBTYXZlcyBhbmQgaGlkZXMuXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc2F2ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NhdmUoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQ2FsbGJhY2sodGhpcy5jb2xvcik7XG4gICAgICAgIHRoaXMuYXBwbGllZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9oaWRlKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQm91bmQgdG8gYXBwbHkgYnV0dG9uLiBTYXZlcyBidXQgZG9lcyBub3QgY2xvc2UuIElzIHVuZG9uZSBieSB0aGUgY2FuY2VsIGJ1dHRvbi5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19hcHBseScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2FwcGx5KCkge1xuICAgICAgICB0aGlzLmFwcGxpZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnVwZGF0ZUNhbGxiYWNrKHRoaXMuY29sb3IpO1xuICAgICAgICB0aGlzLl91cGRhdGVQaWNrZXIodGhpcy5jb2xvcik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogbG9hZCB0aGUgY29sb3IgZnJvbSB0aGUgcHJldmlvdXMgc2Vzc2lvbi5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19sb2FkTGFzdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2xvYWRMYXN0KCkge1xuICAgICAgICBpZiAodGhpcy5wcmV2aW91c0NvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnNldENvbG9yKHRoaXMucHJldmlvdXNDb2xvciwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFsZXJ0KFwiVGhlcmUgaXMgbm8gbGFzdCBjb2xvciB0byBsb2FkLi4uXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogc2V0IHRoZSBjb2xvciwgcGxhY2UgdGhlIHBpY2tlclxuICAgICAgICogQHBhcmFtIHJnYmFcbiAgICAgICAqIEBwYXJhbSBzZXRJbml0aWFsXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc2V0Q29sb3InLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRDb2xvcihyZ2JhKSB7XG4gICAgICAgIHZhciBzZXRJbml0aWFsID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICAvLyBzdG9yZSB0aGUgaW5pdGlhbCBjb2xvclxuICAgICAgICBpZiAoc2V0SW5pdGlhbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuaW5pdGlhbENvbG9yID0gdXRpbC5leHRlbmQoe30sIHJnYmEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb2xvciA9IHJnYmE7XG4gICAgICAgIHZhciBoc3YgPSB1dGlsLlJHQlRvSFNWKHJnYmEuciwgcmdiYS5nLCByZ2JhLmIpO1xuXG4gICAgICAgIHZhciBhbmdsZUNvbnZlcnQgPSAyICogTWF0aC5QSTtcbiAgICAgICAgdmFyIHJhZGl1cyA9IHRoaXMuciAqIGhzdi5zO1xuICAgICAgICB2YXIgeCA9IHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueCArIHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlQ29udmVydCAqIGhzdi5oKTtcbiAgICAgICAgdmFyIHkgPSB0aGlzLmNlbnRlckNvb3JkaW5hdGVzLnkgKyByYWRpdXMgKiBNYXRoLmNvcyhhbmdsZUNvbnZlcnQgKiBoc3YuaCk7XG5cbiAgICAgICAgdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLnN0eWxlLmxlZnQgPSB4IC0gMC41ICogdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLmNsaWVudFdpZHRoICsgJ3B4JztcbiAgICAgICAgdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLnN0eWxlLnRvcCA9IHkgLSAwLjUgKiB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3IuY2xpZW50SGVpZ2h0ICsgJ3B4JztcblxuICAgICAgICB0aGlzLl91cGRhdGVQaWNrZXIocmdiYSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogYm91bmQgdG8gb3BhY2l0eSBjb250cm9sXG4gICAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19zZXRPcGFjaXR5JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0T3BhY2l0eSh2YWx1ZSkge1xuICAgICAgICB0aGlzLmNvbG9yLmEgPSB2YWx1ZSAvIDEwMDtcbiAgICAgICAgdGhpcy5fdXBkYXRlUGlja2VyKHRoaXMuY29sb3IpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGJvdW5kIHRvIGJyaWdodG5lc3MgY29udHJvbFxuICAgICAgICogQHBhcmFtIHZhbHVlXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc2V0QnJpZ2h0bmVzcycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldEJyaWdodG5lc3ModmFsdWUpIHtcbiAgICAgICAgdmFyIGhzdiA9IHV0aWwuUkdCVG9IU1YodGhpcy5jb2xvci5yLCB0aGlzLmNvbG9yLmcsIHRoaXMuY29sb3IuYik7XG4gICAgICAgIGhzdi52ID0gdmFsdWUgLyAxMDA7XG4gICAgICAgIHZhciByZ2JhID0gdXRpbC5IU1ZUb1JHQihoc3YuaCwgaHN2LnMsIGhzdi52KTtcbiAgICAgICAgcmdiYVsnYSddID0gdGhpcy5jb2xvci5hO1xuICAgICAgICB0aGlzLmNvbG9yID0gcmdiYTtcbiAgICAgICAgdGhpcy5fdXBkYXRlUGlja2VyKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogdXBkYXRlIHRoZSBjb2xvciBwaWNrZXIuIEEgYmxhY2sgY2lyY2xlIG92ZXJsYXlzIHRoZSBodWUgY2lyY2xlIHRvIG1pbWljIHRoZSBicmlnaHRuZXNzIGRlY3JlYXNpbmcuXG4gICAgICAgKiBAcGFyYW0gcmdiYVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3VwZGF0ZVBpY2tlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZVBpY2tlcigpIHtcbiAgICAgICAgdmFyIHJnYmEgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB0aGlzLmNvbG9yIDogYXJndW1lbnRzWzBdO1xuXG4gICAgICAgIHZhciBoc3YgPSB1dGlsLlJHQlRvSFNWKHJnYmEuciwgcmdiYS5nLCByZ2JhLmIpO1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5jb2xvclBpY2tlckNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBpZiAodGhpcy5waXhlbFJhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5waXhlbFJhdGlvID0gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIC8gKGN0eC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDEpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0odGhpcy5waXhlbFJhdGlvLCAwLCAwLCB0aGlzLnBpeGVsUmF0aW8sIDAsIDApO1xuXG4gICAgICAgIC8vIGNsZWFyIHRoZSBjYW52YXNcbiAgICAgICAgdmFyIHcgPSB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmNsaWVudFdpZHRoO1xuICAgICAgICB2YXIgaCA9IHRoaXMuY29sb3JQaWNrZXJDYW52YXMuY2xpZW50SGVpZ2h0O1xuICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHcsIGgpO1xuXG4gICAgICAgIGN0eC5wdXRJbWFnZURhdGEodGhpcy5odWVDaXJjbGUsIDAsIDApO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3JnYmEoMCwwLDAsJyArICgxIC0gaHN2LnYpICsgJyknO1xuICAgICAgICBjdHguY2lyY2xlKHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueCwgdGhpcy5jZW50ZXJDb29yZGluYXRlcy55LCB0aGlzLnIpO1xuICAgICAgICBjdHguZmlsbCgpO1xuXG4gICAgICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlLnZhbHVlID0gMTAwICogaHN2LnY7XG4gICAgICAgIHRoaXMub3BhY2l0eVJhbmdlLnZhbHVlID0gMTAwICogcmdiYS5hO1xuXG4gICAgICAgIHRoaXMuaW5pdGlhbENvbG9yRGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdyZ2JhKCcgKyB0aGlzLmluaXRpYWxDb2xvci5yICsgJywnICsgdGhpcy5pbml0aWFsQ29sb3IuZyArICcsJyArIHRoaXMuaW5pdGlhbENvbG9yLmIgKyAnLCcgKyB0aGlzLmluaXRpYWxDb2xvci5hICsgJyknO1xuICAgICAgICB0aGlzLm5ld0NvbG9yRGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdyZ2JhKCcgKyB0aGlzLmNvbG9yLnIgKyAnLCcgKyB0aGlzLmNvbG9yLmcgKyAnLCcgKyB0aGlzLmNvbG9yLmIgKyAnLCcgKyB0aGlzLmNvbG9yLmEgKyAnKSc7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogdXNlZCBieSBjcmVhdGUgdG8gc2V0IHRoZSBzaXplIG9mIHRoZSBjYW52YXMuXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc2V0U2l6ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFNpemUoKSB7XG4gICAgICAgIHRoaXMuY29sb3JQaWNrZXJDYW52YXMuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICAgIHRoaXMuY29sb3JQaWNrZXJDYW52YXMuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuXG4gICAgICAgIHRoaXMuY29sb3JQaWNrZXJDYW52YXMud2lkdGggPSAyODkgKiB0aGlzLnBpeGVsUmF0aW87XG4gICAgICAgIHRoaXMuY29sb3JQaWNrZXJDYW52YXMuaGVpZ2h0ID0gMjg5ICogdGhpcy5waXhlbFJhdGlvO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGNyZWF0ZSBhbGwgZG9tIGVsZW1lbnRzXG4gICAgICAgKiBUT0RPOiBjbGVhbnVwLCBsb3RzIG9mIHNpbWlsYXIgZG9tIGVsZW1lbnRzXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY3JlYXRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlKCkge1xuICAgICAgICB0aGlzLmZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuZnJhbWUuY2xhc3NOYW1lID0gJ3Zpcy1jb2xvci1waWNrZXInO1xuXG4gICAgICAgIHRoaXMuY29sb3JQaWNrZXJEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5jbGFzc05hbWUgPSAndmlzLXNlbGVjdG9yJztcbiAgICAgICAgdGhpcy5jb2xvclBpY2tlckRpdi5hcHBlbmRDaGlsZCh0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3IpO1xuXG4gICAgICAgIHRoaXMuY29sb3JQaWNrZXJDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgdGhpcy5jb2xvclBpY2tlckRpdi5hcHBlbmRDaGlsZCh0aGlzLmNvbG9yUGlja2VyQ2FudmFzKTtcblxuICAgICAgICBpZiAoIXRoaXMuY29sb3JQaWNrZXJDYW52YXMuZ2V0Q29udGV4dCkge1xuICAgICAgICAgIHZhciBub0NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICAgICAgICAgIG5vQ2FudmFzLnN0eWxlLmNvbG9yID0gJ3JlZCc7XG4gICAgICAgICAgbm9DYW52YXMuc3R5bGUuZm9udFdlaWdodCA9ICdib2xkJztcbiAgICAgICAgICBub0NhbnZhcy5zdHlsZS5wYWRkaW5nID0gJzEwcHgnO1xuICAgICAgICAgIG5vQ2FudmFzLmlubmVySFRNTCA9ICdFcnJvcjogeW91ciBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgSFRNTCBjYW52YXMnO1xuICAgICAgICAgIHRoaXMuY29sb3JQaWNrZXJDYW52YXMuYXBwZW5kQ2hpbGQobm9DYW52YXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjdHggPSB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgICB0aGlzLnBpeGVsUmF0aW8gPSAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkgLyAoY3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMSk7XG5cbiAgICAgICAgICB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKS5zZXRUcmFuc2Zvcm0odGhpcy5waXhlbFJhdGlvLCAwLCAwLCB0aGlzLnBpeGVsUmF0aW8sIDAsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb2xvclBpY2tlckRpdi5jbGFzc05hbWUgPSAndmlzLWNvbG9yJztcblxuICAgICAgICB0aGlzLm9wYWNpdHlEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5vcGFjaXR5RGl2LmNsYXNzTmFtZSA9ICd2aXMtb3BhY2l0eSc7XG5cbiAgICAgICAgdGhpcy5icmlnaHRuZXNzRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuYnJpZ2h0bmVzc0Rpdi5jbGFzc05hbWUgPSAndmlzLWJyaWdodG5lc3MnO1xuXG4gICAgICAgIHRoaXMuYXJyb3dEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5hcnJvd0Rpdi5jbGFzc05hbWUgPSAndmlzLWFycm93JztcblxuICAgICAgICB0aGlzLm9wYWNpdHlSYW5nZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5vcGFjaXR5UmFuZ2UudHlwZSA9ICdyYW5nZSc7IC8vIE5vdCBzdXBwb3J0ZWQgb24gSUU5XG4gICAgICAgICAgdGhpcy5vcGFjaXR5UmFuZ2UubWluID0gJzAnO1xuICAgICAgICAgIHRoaXMub3BhY2l0eVJhbmdlLm1heCA9ICcxMDAnO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgIHRoaXMub3BhY2l0eVJhbmdlLnZhbHVlID0gJzEwMCc7XG4gICAgICAgIHRoaXMub3BhY2l0eVJhbmdlLmNsYXNzTmFtZSA9ICd2aXMtcmFuZ2UnO1xuXG4gICAgICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmJyaWdodG5lc3NSYW5nZS50eXBlID0gJ3JhbmdlJzsgLy8gTm90IHN1cHBvcnRlZCBvbiBJRTlcbiAgICAgICAgICB0aGlzLmJyaWdodG5lc3NSYW5nZS5taW4gPSAnMCc7XG4gICAgICAgICAgdGhpcy5icmlnaHRuZXNzUmFuZ2UubWF4ID0gJzEwMCc7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgdGhpcy5icmlnaHRuZXNzUmFuZ2UudmFsdWUgPSAnMTAwJztcbiAgICAgICAgdGhpcy5icmlnaHRuZXNzUmFuZ2UuY2xhc3NOYW1lID0gJ3Zpcy1yYW5nZSc7XG5cbiAgICAgICAgdGhpcy5vcGFjaXR5RGl2LmFwcGVuZENoaWxkKHRoaXMub3BhY2l0eVJhbmdlKTtcbiAgICAgICAgdGhpcy5icmlnaHRuZXNzRGl2LmFwcGVuZENoaWxkKHRoaXMuYnJpZ2h0bmVzc1JhbmdlKTtcblxuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB0aGlzLm9wYWNpdHlSYW5nZS5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBtZS5fc2V0T3BhY2l0eSh0aGlzLnZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vcGFjaXR5UmFuZ2Uub25pbnB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBtZS5fc2V0T3BhY2l0eSh0aGlzLnZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5icmlnaHRuZXNzUmFuZ2Uub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbWUuX3NldEJyaWdodG5lc3ModGhpcy52YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlLm9uaW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbWUuX3NldEJyaWdodG5lc3ModGhpcy52YWx1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5icmlnaHRuZXNzTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmJyaWdodG5lc3NMYWJlbC5jbGFzc05hbWUgPSBcInZpcy1sYWJlbCB2aXMtYnJpZ2h0bmVzc1wiO1xuICAgICAgICB0aGlzLmJyaWdodG5lc3NMYWJlbC5pbm5lckhUTUwgPSAnYnJpZ2h0bmVzczonO1xuXG4gICAgICAgIHRoaXMub3BhY2l0eUxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5vcGFjaXR5TGFiZWwuY2xhc3NOYW1lID0gXCJ2aXMtbGFiZWwgdmlzLW9wYWNpdHlcIjtcbiAgICAgICAgdGhpcy5vcGFjaXR5TGFiZWwuaW5uZXJIVE1MID0gJ29wYWNpdHk6JztcblxuICAgICAgICB0aGlzLm5ld0NvbG9yRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5uZXdDb2xvckRpdi5jbGFzc05hbWUgPSBcInZpcy1uZXctY29sb3JcIjtcbiAgICAgICAgdGhpcy5uZXdDb2xvckRpdi5pbm5lckhUTUwgPSAnbmV3JztcblxuICAgICAgICB0aGlzLmluaXRpYWxDb2xvckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuaW5pdGlhbENvbG9yRGl2LmNsYXNzTmFtZSA9IFwidmlzLWluaXRpYWwtY29sb3JcIjtcbiAgICAgICAgdGhpcy5pbml0aWFsQ29sb3JEaXYuaW5uZXJIVE1MID0gJ2luaXRpYWwnO1xuXG4gICAgICAgIHRoaXMuY2FuY2VsQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5jYW5jZWxCdXR0b24uY2xhc3NOYW1lID0gXCJ2aXMtYnV0dG9uIHZpcy1jYW5jZWxcIjtcbiAgICAgICAgdGhpcy5jYW5jZWxCdXR0b24uaW5uZXJIVE1MID0gJ2NhbmNlbCc7XG4gICAgICAgIHRoaXMuY2FuY2VsQnV0dG9uLm9uY2xpY2sgPSB0aGlzLl9oaWRlLmJpbmQodGhpcywgZmFsc2UpO1xuXG4gICAgICAgIHRoaXMuYXBwbHlCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmFwcGx5QnV0dG9uLmNsYXNzTmFtZSA9IFwidmlzLWJ1dHRvbiB2aXMtYXBwbHlcIjtcbiAgICAgICAgdGhpcy5hcHBseUJ1dHRvbi5pbm5lckhUTUwgPSAnYXBwbHknO1xuICAgICAgICB0aGlzLmFwcGx5QnV0dG9uLm9uY2xpY2sgPSB0aGlzLl9hcHBseS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuc2F2ZUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuc2F2ZUJ1dHRvbi5jbGFzc05hbWUgPSBcInZpcy1idXR0b24gdmlzLXNhdmVcIjtcbiAgICAgICAgdGhpcy5zYXZlQnV0dG9uLmlubmVySFRNTCA9ICdzYXZlJztcbiAgICAgICAgdGhpcy5zYXZlQnV0dG9uLm9uY2xpY2sgPSB0aGlzLl9zYXZlLmJpbmQodGhpcyk7XG5cbiAgICAgICAgdGhpcy5sb2FkQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5sb2FkQnV0dG9uLmNsYXNzTmFtZSA9IFwidmlzLWJ1dHRvbiB2aXMtbG9hZFwiO1xuICAgICAgICB0aGlzLmxvYWRCdXR0b24uaW5uZXJIVE1MID0gJ2xvYWQgbGFzdCc7XG4gICAgICAgIHRoaXMubG9hZEJ1dHRvbi5vbmNsaWNrID0gdGhpcy5fbG9hZExhc3QuYmluZCh0aGlzKTtcblxuICAgICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuY29sb3JQaWNrZXJEaXYpO1xuICAgICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuYXJyb3dEaXYpO1xuICAgICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuYnJpZ2h0bmVzc0xhYmVsKTtcbiAgICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmJyaWdodG5lc3NEaXYpO1xuICAgICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMub3BhY2l0eUxhYmVsKTtcbiAgICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLm9wYWNpdHlEaXYpO1xuICAgICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMubmV3Q29sb3JEaXYpO1xuICAgICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuaW5pdGlhbENvbG9yRGl2KTtcblxuICAgICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuY2FuY2VsQnV0dG9uKTtcbiAgICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmFwcGx5QnV0dG9uKTtcbiAgICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLnNhdmVCdXR0b24pO1xuICAgICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMubG9hZEJ1dHRvbik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogYmluZCBoYW1tZXIgdG8gdGhlIGNvbG9yIHBpY2tlclxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2JpbmRIYW1tZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9iaW5kSGFtbWVyKCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICB0aGlzLmRyYWcgPSB7fTtcbiAgICAgICAgdGhpcy5waW5jaCA9IHt9O1xuICAgICAgICB0aGlzLmhhbW1lciA9IG5ldyBIYW1tZXIodGhpcy5jb2xvclBpY2tlckNhbnZhcyk7XG4gICAgICAgIHRoaXMuaGFtbWVyLmdldCgncGluY2gnKS5zZXQoeyBlbmFibGU6IHRydWUgfSk7XG5cbiAgICAgICAgaGFtbWVyVXRpbC5vblRvdWNoKHRoaXMuaGFtbWVyLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBfdGhpczIuX21vdmVTZWxlY3RvcihldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhhbW1lci5vbigndGFwJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgX3RoaXMyLl9tb3ZlU2VsZWN0b3IoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5oYW1tZXIub24oJ3BhbnN0YXJ0JywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgX3RoaXMyLl9tb3ZlU2VsZWN0b3IoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5oYW1tZXIub24oJ3Bhbm1vdmUnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBfdGhpczIuX21vdmVTZWxlY3RvcihldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhhbW1lci5vbigncGFuZW5kJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgX3RoaXMyLl9tb3ZlU2VsZWN0b3IoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBnZW5lcmF0ZSB0aGUgaHVlIGNpcmNsZS4gVGhpcyBpcyByZWxhdGl2ZWx5IGhlYXZ5ICgyMDBtcykgYW5kIGlzIGRvbmUgb25seSBvbmNlIG9uIHRoZSBmaXJzdCB0aW1lIGl0IGlzIHNob3duLlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2dlbmVyYXRlSHVlQ2lyY2xlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2VuZXJhdGVIdWVDaXJjbGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmdlbmVyYXRlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5jb2xvclBpY2tlckNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgIGlmICh0aGlzLnBpeGVsUmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucGl4ZWxSYXRpbyA9ICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSAvIChjdHgud2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHguYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4LnNldFRyYW5zZm9ybSh0aGlzLnBpeGVsUmF0aW8sIDAsIDAsIHRoaXMucGl4ZWxSYXRpbywgMCwgMCk7XG5cbiAgICAgICAgICAvLyBjbGVhciB0aGUgY2FudmFzXG4gICAgICAgICAgdmFyIHcgPSB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmNsaWVudFdpZHRoO1xuICAgICAgICAgIHZhciBoID0gdGhpcy5jb2xvclBpY2tlckNhbnZhcy5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3LCBoKTtcblxuICAgICAgICAgIC8vIGRyYXcgaHVlIGNpcmNsZVxuICAgICAgICAgIHZhciB4ID0gdm9pZCAwLFxuICAgICAgICAgICAgICB5ID0gdm9pZCAwLFxuICAgICAgICAgICAgICBodWUgPSB2b2lkIDAsXG4gICAgICAgICAgICAgIHNhdCA9IHZvaWQgMDtcbiAgICAgICAgICB0aGlzLmNlbnRlckNvb3JkaW5hdGVzID0geyB4OiB3ICogMC41LCB5OiBoICogMC41IH07XG4gICAgICAgICAgdGhpcy5yID0gMC40OSAqIHc7XG4gICAgICAgICAgdmFyIGFuZ2xlQ29udmVydCA9IDIgKiBNYXRoLlBJIC8gMzYwO1xuICAgICAgICAgIHZhciBoZmFjID0gMSAvIDM2MDtcbiAgICAgICAgICB2YXIgc2ZhYyA9IDEgLyB0aGlzLnI7XG4gICAgICAgICAgdmFyIHJnYiA9IHZvaWQgMDtcbiAgICAgICAgICBmb3IgKGh1ZSA9IDA7IGh1ZSA8IDM2MDsgaHVlKyspIHtcbiAgICAgICAgICAgIGZvciAoc2F0ID0gMDsgc2F0IDwgdGhpcy5yOyBzYXQrKykge1xuICAgICAgICAgICAgICB4ID0gdGhpcy5jZW50ZXJDb29yZGluYXRlcy54ICsgc2F0ICogTWF0aC5zaW4oYW5nbGVDb252ZXJ0ICogaHVlKTtcbiAgICAgICAgICAgICAgeSA9IHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueSArIHNhdCAqIE1hdGguY29zKGFuZ2xlQ29udmVydCAqIGh1ZSk7XG4gICAgICAgICAgICAgIHJnYiA9IHV0aWwuSFNWVG9SR0IoaHVlICogaGZhYywgc2F0ICogc2ZhYywgMSk7XG4gICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAncmdiKCcgKyByZ2IuciArICcsJyArIHJnYi5nICsgJywnICsgcmdiLmIgKyAnKSc7XG4gICAgICAgICAgICAgIGN0eC5maWxsUmVjdCh4IC0gMC41LCB5IC0gMC41LCAyLCAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ3JnYmEoMCwwLDAsMSknO1xuICAgICAgICAgIGN0eC5jaXJjbGUodGhpcy5jZW50ZXJDb29yZGluYXRlcy54LCB0aGlzLmNlbnRlckNvb3JkaW5hdGVzLnksIHRoaXMucik7XG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgICAgdGhpcy5odWVDaXJjbGUgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHcsIGgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBtb3ZlIHRoZSBzZWxlY3Rvci4gVGhpcyBpcyBjYWxsZWQgYnkgaGFtbWVyIGZ1bmN0aW9ucy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19tb3ZlU2VsZWN0b3InLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9tb3ZlU2VsZWN0b3IoZXZlbnQpIHtcbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmNvbG9yUGlja2VyRGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgbGVmdCA9IGV2ZW50LmNlbnRlci54IC0gcmVjdC5sZWZ0O1xuICAgICAgICB2YXIgdG9wID0gZXZlbnQuY2VudGVyLnkgLSByZWN0LnRvcDtcblxuICAgICAgICB2YXIgY2VudGVyWSA9IDAuNSAqIHRoaXMuY29sb3JQaWNrZXJEaXYuY2xpZW50SGVpZ2h0O1xuICAgICAgICB2YXIgY2VudGVyWCA9IDAuNSAqIHRoaXMuY29sb3JQaWNrZXJEaXYuY2xpZW50V2lkdGg7XG5cbiAgICAgICAgdmFyIHggPSBsZWZ0IC0gY2VudGVyWDtcbiAgICAgICAgdmFyIHkgPSB0b3AgLSBjZW50ZXJZO1xuXG4gICAgICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbjIoeCwgeSk7XG4gICAgICAgIHZhciByYWRpdXMgPSAwLjk4ICogTWF0aC5taW4oTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpLCBjZW50ZXJYKTtcblxuICAgICAgICB2YXIgbmV3VG9wID0gTWF0aC5jb3MoYW5nbGUpICogcmFkaXVzICsgY2VudGVyWTtcbiAgICAgICAgdmFyIG5ld0xlZnQgPSBNYXRoLnNpbihhbmdsZSkgKiByYWRpdXMgKyBjZW50ZXJYO1xuXG4gICAgICAgIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5zdHlsZS50b3AgPSBuZXdUb3AgLSAwLjUgKiB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3IuY2xpZW50SGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLnN0eWxlLmxlZnQgPSBuZXdMZWZ0IC0gMC41ICogdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLmNsaWVudFdpZHRoICsgJ3B4JztcblxuICAgICAgICAvLyBzZXQgY29sb3JcbiAgICAgICAgdmFyIGggPSBhbmdsZSAvICgyICogTWF0aC5QSSk7XG4gICAgICAgIGggPSBoIDwgMCA/IGggKyAxIDogaDtcbiAgICAgICAgdmFyIHMgPSByYWRpdXMgLyB0aGlzLnI7XG4gICAgICAgIHZhciBoc3YgPSB1dGlsLlJHQlRvSFNWKHRoaXMuY29sb3IuciwgdGhpcy5jb2xvci5nLCB0aGlzLmNvbG9yLmIpO1xuICAgICAgICBoc3YuaCA9IGg7XG4gICAgICAgIGhzdi5zID0gcztcbiAgICAgICAgdmFyIHJnYmEgPSB1dGlsLkhTVlRvUkdCKGhzdi5oLCBoc3YucywgaHN2LnYpO1xuICAgICAgICByZ2JhWydhJ10gPSB0aGlzLmNvbG9yLmE7XG4gICAgICAgIHRoaXMuY29sb3IgPSByZ2JhO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBwcmV2aWV3c1xuICAgICAgICB0aGlzLmluaXRpYWxDb2xvckRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiYSgnICsgdGhpcy5pbml0aWFsQ29sb3IuciArICcsJyArIHRoaXMuaW5pdGlhbENvbG9yLmcgKyAnLCcgKyB0aGlzLmluaXRpYWxDb2xvci5iICsgJywnICsgdGhpcy5pbml0aWFsQ29sb3IuYSArICcpJztcbiAgICAgICAgdGhpcy5uZXdDb2xvckRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiYSgnICsgdGhpcy5jb2xvci5yICsgJywnICsgdGhpcy5jb2xvci5nICsgJywnICsgdGhpcy5jb2xvci5iICsgJywnICsgdGhpcy5jb2xvci5hICsgJyknO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBDb2xvclBpY2tlcjtcbiAgfSgpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IENvbG9yUGlja2VyO1xuXG4vKioqLyB9LFxuLyogMjggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgSGFtbWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgdG91Y2ggZXZlbnQsIHRha2luZyBwbGFjZSBiZWZvcmUgYSBnZXN0dXJlXG4gICAqIEBwYXJhbSB7SGFtbWVyfSBoYW1tZXIgICAgICAgQSBoYW1tZXIgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgICBDYWxsYmFjaywgY2FsbGVkIGFzIGNhbGxiYWNrKGV2ZW50KVxuICAgKi9cbiAgZXhwb3J0cy5vblRvdWNoID0gZnVuY3Rpb24gKGhhbW1lciwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjay5pbnB1dEhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5pc0ZpcnN0KSB7XG4gICAgICAgIGNhbGxiYWNrKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaGFtbWVyLm9uKCdoYW1tZXIuaW5wdXQnLCBjYWxsYmFjay5pbnB1dEhhbmRsZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIHJlbGVhc2UgZXZlbnQsIHRha2luZyBwbGFjZSBhZnRlciBhIGdlc3R1cmVcbiAgICogQHBhcmFtIHtIYW1tZXJ9IGhhbW1lciAgICAgICBBIGhhbW1lciBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAgIENhbGxiYWNrLCBjYWxsZWQgYXMgY2FsbGJhY2soZXZlbnQpXG4gICAqL1xuICBleHBvcnRzLm9uUmVsZWFzZSA9IGZ1bmN0aW9uIChoYW1tZXIsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2suaW5wdXRIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQuaXNGaW5hbCkge1xuICAgICAgICBjYWxsYmFjayhldmVudCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBoYW1tZXIub24oJ2hhbW1lci5pbnB1dCcsIGNhbGxiYWNrLmlucHV0SGFuZGxlcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVucmVnaXN0ZXIgYSB0b3VjaCBldmVudCwgdGFraW5nIHBsYWNlIGJlZm9yZSBhIGdlc3R1cmVcbiAgICogQHBhcmFtIHtIYW1tZXJ9IGhhbW1lciAgICAgICBBIGhhbW1lciBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAgIENhbGxiYWNrLCBjYWxsZWQgYXMgY2FsbGJhY2soZXZlbnQpXG4gICAqL1xuICBleHBvcnRzLm9mZlRvdWNoID0gZnVuY3Rpb24gKGhhbW1lciwgY2FsbGJhY2spIHtcbiAgICBoYW1tZXIub2ZmKCdoYW1tZXIuaW5wdXQnLCBjYWxsYmFjay5pbnB1dEhhbmRsZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVbnJlZ2lzdGVyIGEgcmVsZWFzZSBldmVudCwgdGFraW5nIHBsYWNlIGJlZm9yZSBhIGdlc3R1cmVcbiAgICogQHBhcmFtIHtIYW1tZXJ9IGhhbW1lciAgICAgICBBIGhhbW1lciBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAgIENhbGxiYWNrLCBjYWxsZWQgYXMgY2FsbGJhY2soZXZlbnQpXG4gICAqL1xuICBleHBvcnRzLm9mZlJlbGVhc2UgPSBleHBvcnRzLm9mZlRvdWNoO1xuXG4gIC8qKlxuICAgKiBIYWNrIHRoZSBQaW5jaFJlY29nbml6ZXIgc3VjaCB0aGF0IGl0IGRvZXNuJ3QgcHJldmVudCBkZWZhdWx0IGJlaGF2aW9yXG4gICAqIGZvciB2ZXJ0aWNhbCBwYW5uaW5nLlxuICAgKlxuICAgKiBZZWFoIC4uLiB0aGlzIGlzIHF1aXRlIGEgaGFjayAuLi4gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9oYW1tZXJqcy9oYW1tZXIuanMvaXNzdWVzLzkzMlxuICAgKlxuICAgKiBAcGFyYW0ge0hhbW1lci5QaW5jaH0gcGluY2hSZWNvZ25pemVyXG4gICAqIEByZXR1cm4ge0hhbW1lci5QaW5jaH0gcmV0dXJucyB0aGUgcGluY2hSZWNvZ25pemVyXG4gICAqL1xuICBleHBvcnRzLmRpc2FibGVQcmV2ZW50RGVmYXVsdFZlcnRpY2FsbHkgPSBmdW5jdGlvbiAocGluY2hSZWNvZ25pemVyKSB7XG4gICAgdmFyIFRPVUNIX0FDVElPTl9QQU5fWSA9ICdwYW4teSc7XG5cbiAgICBwaW5jaFJlY29nbml6ZXIuZ2V0VG91Y2hBY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBkZWZhdWx0IG1ldGhvZCByZXR1cm5zIFtUT1VDSF9BQ1RJT05fTk9ORV1cbiAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX1BBTl9ZXTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHBpbmNoUmVjb2duaXplcjtcbiAgfTtcblxuLyoqKi8gfSxcbi8qIDI5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuICB2YXIgZXJyb3JGb3VuZCA9IGZhbHNlO1xuICB2YXIgYWxsT3B0aW9ucyA9IHZvaWQgMDtcbiAgdmFyIHByaW50U3R5bGUgPSAnYmFja2dyb3VuZDogI0ZGZWVlZTsgY29sb3I6ICNkZDAwMDAnO1xuICAvKipcbiAgICogIFVzZWQgdG8gdmFsaWRhdGUgb3B0aW9ucy5cbiAgICovXG5cbiAgdmFyIFZhbGlkYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWYWxpZGF0b3IoKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVmFsaWRhdG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYWluIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHBhcmFtIHN1Yk9iamVjdFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoVmFsaWRhdG9yLCBudWxsLCBbe1xuICAgICAga2V5OiAndmFsaWRhdGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRlKG9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbnMsIHN1Yk9iamVjdCkge1xuICAgICAgICBlcnJvckZvdW5kID0gZmFsc2U7XG4gICAgICAgIGFsbE9wdGlvbnMgPSByZWZlcmVuY2VPcHRpb25zO1xuICAgICAgICB2YXIgdXNlZE9wdGlvbnMgPSByZWZlcmVuY2VPcHRpb25zO1xuICAgICAgICBpZiAoc3ViT2JqZWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB1c2VkT3B0aW9ucyA9IHJlZmVyZW5jZU9wdGlvbnNbc3ViT2JqZWN0XTtcbiAgICAgICAgfVxuICAgICAgICBWYWxpZGF0b3IucGFyc2Uob3B0aW9ucywgdXNlZE9wdGlvbnMsIFtdKTtcbiAgICAgICAgcmV0dXJuIGVycm9yRm91bmQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogV2lsbCB0cmF2ZXJzZSBhbiBvYmplY3QgcmVjdXJzaXZlbHkgYW5kIGNoZWNrIGV2ZXJ5IHZhbHVlXG4gICAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAgICogQHBhcmFtIHJlZmVyZW5jZU9wdGlvbnNcbiAgICAgICAqIEBwYXJhbSBwYXRoXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3BhcnNlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShvcHRpb25zLCByZWZlcmVuY2VPcHRpb25zLCBwYXRoKSB7XG4gICAgICAgIGZvciAodmFyIG9wdGlvbiBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkob3B0aW9uKSkge1xuICAgICAgICAgICAgVmFsaWRhdG9yLmNoZWNrKG9wdGlvbiwgb3B0aW9ucywgcmVmZXJlbmNlT3B0aW9ucywgcGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2hlY2sgZXZlcnkgdmFsdWUuIElmIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3QsIGNhbGwgdGhlIHBhcnNlIGZ1bmN0aW9uIG9uIHRoYXQgb2JqZWN0LlxuICAgICAgICogQHBhcmFtIG9wdGlvblxuICAgICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgICAqIEBwYXJhbSByZWZlcmVuY2VPcHRpb25zXG4gICAgICAgKiBAcGFyYW0gcGF0aFxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdjaGVjaycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2sob3B0aW9uLCBvcHRpb25zLCByZWZlcmVuY2VPcHRpb25zLCBwYXRoKSB7XG4gICAgICAgIGlmIChyZWZlcmVuY2VPcHRpb25zW29wdGlvbl0gPT09IHVuZGVmaW5lZCAmJiByZWZlcmVuY2VPcHRpb25zLl9fYW55X18gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIFZhbGlkYXRvci5nZXRTdWdnZXN0aW9uKG9wdGlvbiwgcmVmZXJlbmNlT3B0aW9ucywgcGF0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVmZXJlbmNlT3B0aW9uc1tvcHRpb25dID09PSB1bmRlZmluZWQgJiYgcmVmZXJlbmNlT3B0aW9ucy5fX2FueV9fICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBfX2FueV9fIGlzIGEgd2lsZGNhcmQuIEFueSB2YWx1ZSBpcyBhY2NlcHRlZCBhbmQgd2lsbCBiZSBmdXJ0aGVyIGFuYWx5c2VkIGJ5IHJlZmVyZW5jZS5cbiAgICAgICAgICBpZiAoVmFsaWRhdG9yLmdldFR5cGUob3B0aW9uc1tvcHRpb25dKSA9PT0gJ29iamVjdCcgJiYgcmVmZXJlbmNlT3B0aW9uc1snX19hbnlfXyddLl9fdHlwZV9fICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBhbnkgc3ViZ3JvdXAgaXMgbm90IGEgcHJlZGVmaW5lZCBvYmplY3QgaW50IGhlIGNvbmZpZ3VyYXRvciB3ZSBkbyBub3QgbG9vayBkZWVwZXIgaW50byB0aGUgb2JqZWN0LlxuICAgICAgICAgICAgVmFsaWRhdG9yLmNoZWNrRmllbGRzKG9wdGlvbiwgb3B0aW9ucywgcmVmZXJlbmNlT3B0aW9ucywgJ19fYW55X18nLCByZWZlcmVuY2VPcHRpb25zWydfX2FueV9fJ10uX190eXBlX18sIHBhdGgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBWYWxpZGF0b3IuY2hlY2tGaWVsZHMob3B0aW9uLCBvcHRpb25zLCByZWZlcmVuY2VPcHRpb25zLCAnX19hbnlfXycsIHJlZmVyZW5jZU9wdGlvbnNbJ19fYW55X18nXSwgcGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFNpbmNlIGFsbCBvcHRpb25zIGluIHRoZSByZWZlcmVuY2UgYXJlIG9iamVjdHMsIHdlIGNhbiBjaGVjayB3aGV0aGVyIHRoZXkgYXJlIHN1cHBvc2VkIHRvIGJlIG9iamVjdCB0byBsb29rIGZvciB0aGUgX190eXBlX18gZmllbGQuXG4gICAgICAgICAgaWYgKHJlZmVyZW5jZU9wdGlvbnNbb3B0aW9uXS5fX3R5cGVfXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGlzIHNob3VsZCBiZSBhbiBvYmplY3QsIHdlIGNoZWNrIGlmIHRoZSBjb3JyZWN0IHR5cGUgaGFzIGJlZW4gc3VwcGxpZWQgdG8gYWNjb3VudCBmb3Igc2hvcnRoYW5kIG9wdGlvbnMuXG4gICAgICAgICAgICBWYWxpZGF0b3IuY2hlY2tGaWVsZHMob3B0aW9uLCBvcHRpb25zLCByZWZlcmVuY2VPcHRpb25zLCBvcHRpb24sIHJlZmVyZW5jZU9wdGlvbnNbb3B0aW9uXS5fX3R5cGVfXywgcGF0aCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFZhbGlkYXRvci5jaGVja0ZpZWxkcyhvcHRpb24sIG9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbnMsIG9wdGlvbiwgcmVmZXJlbmNlT3B0aW9uc1tvcHRpb25dLCBwYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9ICBvcHRpb24gICAgIHwgdGhlIG9wdGlvbiBwcm9wZXJ0eVxuICAgICAgICogQHBhcmFtIHtPYmplY3R9ICBvcHRpb25zICAgIHwgVGhlIHN1cHBsaWVkIG9wdGlvbnMgb2JqZWN0XG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gIHJlZmVyZW5jZU9wdGlvbnMgICAgfCBUaGUgcmVmZXJlbmNlIG9wdGlvbnMgY29udGFpbmluZyBhbGwgb3B0aW9ucyBhbmQgdGhlaXIgYWxsb3dlZCBmb3JtYXRzXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gIHJlZmVyZW5jZU9wdGlvbiAgICAgfCBVc3VhbGx5IHRoaXMgaXMgdGhlIHNhbWUgYXMgb3B0aW9uLCBleGNlcHQgd2hlbiBoYW5kbGluZyBhbiBfX2FueV9fIHRhZy5cbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgcmVmT3B0aW9uVHlwZSAgICAgICB8IFRoaXMgaXMgdGhlIHR5cGUgb2JqZWN0IGZyb20gdGhlIHJlZmVyZW5jZSBvcHRpb25zXG4gICAgICAgKiBAcGFyYW0ge0FycmF5fSAgIHBhdGggICAgICB8IHdoZXJlIGluIHRoZSBvYmplY3QgaXMgdGhlIG9wdGlvblxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdjaGVja0ZpZWxkcycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tGaWVsZHMob3B0aW9uLCBvcHRpb25zLCByZWZlcmVuY2VPcHRpb25zLCByZWZlcmVuY2VPcHRpb24sIHJlZk9wdGlvbk9iaiwgcGF0aCkge1xuICAgICAgICB2YXIgb3B0aW9uVHlwZSA9IFZhbGlkYXRvci5nZXRUeXBlKG9wdGlvbnNbb3B0aW9uXSk7XG4gICAgICAgIHZhciByZWZPcHRpb25UeXBlID0gcmVmT3B0aW9uT2JqW29wdGlvblR5cGVdO1xuICAgICAgICBpZiAocmVmT3B0aW9uVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gaWYgdGhlIHR5cGUgaXMgY29ycmVjdCwgd2UgY2hlY2sgaWYgaXQgaXMgc3VwcG9zZWQgdG8gYmUgb25lIG9mIGEgZmV3IHNlbGVjdCB2YWx1ZXNcbiAgICAgICAgICBpZiAoVmFsaWRhdG9yLmdldFR5cGUocmVmT3B0aW9uVHlwZSkgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgIGlmIChyZWZPcHRpb25UeXBlLmluZGV4T2Yob3B0aW9uc1tvcHRpb25dKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJyVjSW52YWxpZCBvcHRpb24gZGV0ZWN0ZWQgaW4gXCInICsgb3B0aW9uICsgJ1wiLicgKyAnIEFsbG93ZWQgdmFsdWVzIGFyZTonICsgVmFsaWRhdG9yLnByaW50KHJlZk9wdGlvblR5cGUpICsgJyBub3QgXCInICsgb3B0aW9uc1tvcHRpb25dICsgJ1wiLiAnICsgVmFsaWRhdG9yLnByaW50TG9jYXRpb24ocGF0aCwgb3B0aW9uKSwgcHJpbnRTdHlsZSk7XG4gICAgICAgICAgICAgIGVycm9yRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25UeXBlID09PSAnb2JqZWN0JyAmJiByZWZlcmVuY2VPcHRpb24gIT09IFwiX19hbnlfX1wiKSB7XG4gICAgICAgICAgICAgIHBhdGggPSB1dGlsLmNvcHlBbmRFeHRlbmRBcnJheShwYXRoLCBvcHRpb24pO1xuICAgICAgICAgICAgICBWYWxpZGF0b3IucGFyc2Uob3B0aW9uc1tvcHRpb25dLCByZWZlcmVuY2VPcHRpb25zW3JlZmVyZW5jZU9wdGlvbl0sIHBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9uVHlwZSA9PT0gJ29iamVjdCcgJiYgcmVmZXJlbmNlT3B0aW9uICE9PSBcIl9fYW55X19cIikge1xuICAgICAgICAgICAgcGF0aCA9IHV0aWwuY29weUFuZEV4dGVuZEFycmF5KHBhdGgsIG9wdGlvbik7XG4gICAgICAgICAgICBWYWxpZGF0b3IucGFyc2Uob3B0aW9uc1tvcHRpb25dLCByZWZlcmVuY2VPcHRpb25zW3JlZmVyZW5jZU9wdGlvbl0sIHBhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChyZWZPcHRpb25PYmpbJ2FueSddID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyB0eXBlIG9mIHRoZSBmaWVsZCBpcyBpbmNvcnJlY3QgYW5kIHRoZSBmaWVsZCBjYW5ub3QgYmUgYW55XG4gICAgICAgICAgY29uc29sZS5sb2coJyVjSW52YWxpZCB0eXBlIHJlY2VpdmVkIGZvciBcIicgKyBvcHRpb24gKyAnXCIuIEV4cGVjdGVkOiAnICsgVmFsaWRhdG9yLnByaW50KE9iamVjdC5rZXlzKHJlZk9wdGlvbk9iaikpICsgJy4gUmVjZWl2ZWQgWycgKyBvcHRpb25UeXBlICsgJ10gXCInICsgb3B0aW9uc1tvcHRpb25dICsgJ1wiJyArIFZhbGlkYXRvci5wcmludExvY2F0aW9uKHBhdGgsIG9wdGlvbiksIHByaW50U3R5bGUpO1xuICAgICAgICAgIGVycm9yRm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0VHlwZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VHlwZShvYmplY3QpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2Ygb2JqZWN0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvYmplY3QpO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGlmIChvYmplY3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBCb29sZWFuKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2Jvb2xlYW4nO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gJ251bWJlcic7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiAnc3RyaW5nJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqZWN0Lm5vZGVUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAnZG9tJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdC5faXNBTW9tZW50T2JqZWN0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gJ21vbWVudCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHJldHVybiAnbnVtYmVyJztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICByZXR1cm4gJ2Jvb2xlYW4nO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuICdzdHJpbmcnO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXRTdWdnZXN0aW9uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdWdnZXN0aW9uKG9wdGlvbiwgb3B0aW9ucywgcGF0aCkge1xuICAgICAgICB2YXIgbG9jYWxTZWFyY2ggPSBWYWxpZGF0b3IuZmluZEluT3B0aW9ucyhvcHRpb24sIG9wdGlvbnMsIHBhdGgsIGZhbHNlKTtcbiAgICAgICAgdmFyIGdsb2JhbFNlYXJjaCA9IFZhbGlkYXRvci5maW5kSW5PcHRpb25zKG9wdGlvbiwgYWxsT3B0aW9ucywgW10sIHRydWUpO1xuXG4gICAgICAgIHZhciBsb2NhbFNlYXJjaFRocmVzaG9sZCA9IDg7XG4gICAgICAgIHZhciBnbG9iYWxTZWFyY2hUaHJlc2hvbGQgPSA0O1xuXG4gICAgICAgIGlmIChsb2NhbFNlYXJjaC5pbmRleE1hdGNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnJWNVbmtub3duIG9wdGlvbiBkZXRlY3RlZDogXCInICsgb3B0aW9uICsgJ1wiIGluICcgKyBWYWxpZGF0b3IucHJpbnRMb2NhdGlvbihsb2NhbFNlYXJjaC5wYXRoLCBvcHRpb24sICcnKSArICdQZXJoYXBzIGl0IHdhcyBpbmNvbXBsZXRlPyBEaWQgeW91IG1lYW46IFwiJyArIGxvY2FsU2VhcmNoLmluZGV4TWF0Y2ggKyAnXCI/XFxuXFxuJywgcHJpbnRTdHlsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZ2xvYmFsU2VhcmNoLmRpc3RhbmNlIDw9IGdsb2JhbFNlYXJjaFRocmVzaG9sZCAmJiBsb2NhbFNlYXJjaC5kaXN0YW5jZSA+IGdsb2JhbFNlYXJjaC5kaXN0YW5jZSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCclY1Vua25vd24gb3B0aW9uIGRldGVjdGVkOiBcIicgKyBvcHRpb24gKyAnXCIgaW4gJyArIFZhbGlkYXRvci5wcmludExvY2F0aW9uKGxvY2FsU2VhcmNoLnBhdGgsIG9wdGlvbiwgJycpICsgJ1BlcmhhcHMgaXQgd2FzIG1pc3BsYWNlZD8gTWF0Y2hpbmcgb3B0aW9uIGZvdW5kIGF0OiAnICsgVmFsaWRhdG9yLnByaW50TG9jYXRpb24oZ2xvYmFsU2VhcmNoLnBhdGgsIGdsb2JhbFNlYXJjaC5jbG9zZXN0TWF0Y2gsICcnKSwgcHJpbnRTdHlsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobG9jYWxTZWFyY2guZGlzdGFuY2UgPD0gbG9jYWxTZWFyY2hUaHJlc2hvbGQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnJWNVbmtub3duIG9wdGlvbiBkZXRlY3RlZDogXCInICsgb3B0aW9uICsgJ1wiLiBEaWQgeW91IG1lYW4gXCInICsgbG9jYWxTZWFyY2guY2xvc2VzdE1hdGNoICsgJ1wiPycgKyBWYWxpZGF0b3IucHJpbnRMb2NhdGlvbihsb2NhbFNlYXJjaC5wYXRoLCBvcHRpb24pLCBwcmludFN0eWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnJWNVbmtub3duIG9wdGlvbiBkZXRlY3RlZDogXCInICsgb3B0aW9uICsgJ1wiLiBEaWQgeW91IG1lYW4gb25lIG9mIHRoZXNlOiAnICsgVmFsaWRhdG9yLnByaW50KE9iamVjdC5rZXlzKG9wdGlvbnMpKSArIFZhbGlkYXRvci5wcmludExvY2F0aW9uKHBhdGgsIG9wdGlvbiksIHByaW50U3R5bGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZXJyb3JGb3VuZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogdHJhdmVyc2UgdGhlIG9wdGlvbnMgaW4gc2VhcmNoIGZvciBhIG1hdGNoLlxuICAgICAgICogQHBhcmFtIG9wdGlvblxuICAgICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgICAqIEBwYXJhbSBwYXRoXG4gICAgICAgKiBAcGFyYW0gcmVjdXJzaXZlXG4gICAgICAgKiBAcmV0dXJucyB7e2Nsb3Nlc3RNYXRjaDogc3RyaW5nLCBwYXRoOiBBcnJheSwgZGlzdGFuY2U6IG51bWJlcn19XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2ZpbmRJbk9wdGlvbnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRJbk9wdGlvbnMob3B0aW9uLCBvcHRpb25zLCBwYXRoKSB7XG4gICAgICAgIHZhciByZWN1cnNpdmUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDMgfHwgYXJndW1lbnRzWzNdID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1szXTtcblxuICAgICAgICB2YXIgbWluID0gMWU5O1xuICAgICAgICB2YXIgY2xvc2VzdE1hdGNoID0gJyc7XG4gICAgICAgIHZhciBjbG9zZXN0TWF0Y2hQYXRoID0gW107XG4gICAgICAgIHZhciBsb3dlckNhc2VPcHRpb24gPSBvcHRpb24udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIGluZGV4TWF0Y2ggPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAodmFyIG9wIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICB2YXIgZGlzdGFuY2UgPSB2b2lkIDA7XG4gICAgICAgICAgaWYgKG9wdGlvbnNbb3BdLl9fdHlwZV9fICE9PSB1bmRlZmluZWQgJiYgcmVjdXJzaXZlID09PSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gVmFsaWRhdG9yLmZpbmRJbk9wdGlvbnMob3B0aW9uLCBvcHRpb25zW29wXSwgdXRpbC5jb3B5QW5kRXh0ZW5kQXJyYXkocGF0aCwgb3ApKTtcbiAgICAgICAgICAgIGlmIChtaW4gPiByZXN1bHQuZGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgY2xvc2VzdE1hdGNoID0gcmVzdWx0LmNsb3Nlc3RNYXRjaDtcbiAgICAgICAgICAgICAgY2xvc2VzdE1hdGNoUGF0aCA9IHJlc3VsdC5wYXRoO1xuICAgICAgICAgICAgICBtaW4gPSByZXN1bHQuZGlzdGFuY2U7XG4gICAgICAgICAgICAgIGluZGV4TWF0Y2ggPSByZXN1bHQuaW5kZXhNYXRjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG9wLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihsb3dlckNhc2VPcHRpb24pICE9PSAtMSkge1xuICAgICAgICAgICAgICBpbmRleE1hdGNoID0gb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXN0YW5jZSA9IFZhbGlkYXRvci5sZXZlbnNodGVpbkRpc3RhbmNlKG9wdGlvbiwgb3ApO1xuICAgICAgICAgICAgaWYgKG1pbiA+IGRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgIGNsb3Nlc3RNYXRjaCA9IG9wO1xuICAgICAgICAgICAgICBjbG9zZXN0TWF0Y2hQYXRoID0gdXRpbC5jb3B5QXJyYXkocGF0aCk7XG4gICAgICAgICAgICAgIG1pbiA9IGRpc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBjbG9zZXN0TWF0Y2g6IGNsb3Nlc3RNYXRjaCwgcGF0aDogY2xvc2VzdE1hdGNoUGF0aCwgZGlzdGFuY2U6IG1pbiwgaW5kZXhNYXRjaDogaW5kZXhNYXRjaCB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3ByaW50TG9jYXRpb24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByaW50TG9jYXRpb24ocGF0aCwgb3B0aW9uKSB7XG4gICAgICAgIHZhciBwcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyAnUHJvYmxlbSB2YWx1ZSBmb3VuZCBhdDogXFxuJyA6IGFyZ3VtZW50c1syXTtcblxuICAgICAgICB2YXIgc3RyID0gJ1xcblxcbicgKyBwcmVmaXggKyAnb3B0aW9ucyA9IHtcXG4nO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGkgKyAxOyBqKyspIHtcbiAgICAgICAgICAgIHN0ciArPSAnICAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHIgKz0gcGF0aFtpXSArICc6IHtcXG4nO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBwYXRoLmxlbmd0aCArIDE7IF9qKyspIHtcbiAgICAgICAgICBzdHIgKz0gJyAgJztcbiAgICAgICAgfVxuICAgICAgICBzdHIgKz0gb3B0aW9uICsgJ1xcbic7XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBwYXRoLmxlbmd0aCArIDE7IF9pKyspIHtcbiAgICAgICAgICBmb3IgKHZhciBfajIgPSAwOyBfajIgPCBwYXRoLmxlbmd0aCAtIF9pOyBfajIrKykge1xuICAgICAgICAgICAgc3RyICs9ICcgICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0ciArPSAnfVxcbic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0ciArICdcXG5cXG4nO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3ByaW50JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwcmludChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvcHRpb25zKS5yZXBsYWNlKC8oXFxcIil8KFxcWyl8KFxcXSl8KCxcIl9fdHlwZV9fXCIpL2csIFwiXCIpLnJlcGxhY2UoLyhcXCwpL2csICcsICcpO1xuICAgICAgfVxuXG4gICAgICAvLyBDb21wdXRlIHRoZSBlZGl0IGRpc3RhbmNlIGJldHdlZW4gdGhlIHR3byBnaXZlbiBzdHJpbmdzXG4gICAgICAvLyBodHRwOi8vZW4ud2lraWJvb2tzLm9yZy93aWtpL0FsZ29yaXRobV9JbXBsZW1lbnRhdGlvbi9TdHJpbmdzL0xldmVuc2h0ZWluX2Rpc3RhbmNlI0phdmFTY3JpcHRcbiAgICAgIC8qXG4gICAgICAgQ29weXJpZ2h0IChjKSAyMDExIEFuZHJlaSBNYWNrZW56aWVcbiAgICAgICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdsZXZlbnNodGVpbkRpc3RhbmNlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBsZXZlbnNodGVpbkRpc3RhbmNlKGEsIGIpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoID09PSAwKSByZXR1cm4gYi5sZW5ndGg7XG4gICAgICAgIGlmIChiLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGEubGVuZ3RoO1xuXG4gICAgICAgIHZhciBtYXRyaXggPSBbXTtcblxuICAgICAgICAvLyBpbmNyZW1lbnQgYWxvbmcgdGhlIGZpcnN0IGNvbHVtbiBvZiBlYWNoIHJvd1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8PSBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbWF0cml4W2ldID0gW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW5jcmVtZW50IGVhY2ggY29sdW1uIGluIHRoZSBmaXJzdCByb3dcbiAgICAgICAgdmFyIGo7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPD0gYS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIG1hdHJpeFswXVtqXSA9IGo7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaWxsIGluIHRoZSByZXN0IG9mIHRoZSBtYXRyaXhcbiAgICAgICAgZm9yIChpID0gMTsgaSA8PSBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZm9yIChqID0gMTsgaiA8PSBhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoYi5jaGFyQXQoaSAtIDEpID09IGEuY2hhckF0KGogLSAxKSkge1xuICAgICAgICAgICAgICBtYXRyaXhbaV1bal0gPSBtYXRyaXhbaSAtIDFdW2ogLSAxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hdHJpeFtpXVtqXSA9IE1hdGgubWluKG1hdHJpeFtpIC0gMV1baiAtIDFdICsgMSwgLy8gc3Vic3RpdHV0aW9uXG4gICAgICAgICAgICAgIE1hdGgubWluKG1hdHJpeFtpXVtqIC0gMV0gKyAxLCAvLyBpbnNlcnRpb25cbiAgICAgICAgICAgICAgbWF0cml4W2kgLSAxXVtqXSArIDEpKTsgLy8gZGVsZXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWF0cml4W2IubGVuZ3RoXVthLmxlbmd0aF07XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFZhbGlkYXRvcjtcbiAgfSgpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IFZhbGlkYXRvcjtcbiAgZXhwb3J0cy5wcmludFN0eWxlID0gcHJpbnRTdHlsZTtcblxuLyoqKi8gfSxcbi8qIDMwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbiAgdmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuICB2YXIgaGFtbWVyVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xuICB2YXIgbW9tZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbiAgdmFyIENvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xuICB2YXIgRGF0ZVV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yIFJhbmdlXG4gICAqIEEgUmFuZ2UgY29udHJvbHMgYSBudW1lcmljIHJhbmdlIHdpdGggYSBzdGFydCBhbmQgZW5kIHZhbHVlLlxuICAgKiBUaGUgUmFuZ2UgYWRqdXN0cyB0aGUgcmFuZ2UgYmFzZWQgb24gbW91c2UgZXZlbnRzIG9yIHByb2dyYW1tYXRpYyBjaGFuZ2VzLFxuICAgKiBhbmQgdHJpZ2dlcnMgZXZlbnRzIHdoZW4gdGhlIHJhbmdlIGlzIGNoYW5naW5nIG9yIGhhcyBiZWVuIGNoYW5nZWQuXG4gICAqIEBwYXJhbSB7e2RvbTogT2JqZWN0LCBkb21Qcm9wczogT2JqZWN0LCBlbWl0dGVyOiBFbWl0dGVyfX0gYm9keVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgIFNlZSBkZXNjcmlwdGlvbiBhdCBSYW5nZS5zZXRPcHRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBSYW5nZShib2R5LCBvcHRpb25zKSB7XG4gICAgdmFyIG5vdyA9IG1vbWVudCgpLmhvdXJzKDApLm1pbnV0ZXMoMCkuc2Vjb25kcygwKS5taWxsaXNlY29uZHMoMCk7XG4gICAgdGhpcy5zdGFydCA9IG5vdy5jbG9uZSgpLmFkZCgtMywgJ2RheXMnKS52YWx1ZU9mKCk7IC8vIE51bWJlclxuICAgIHRoaXMuZW5kID0gbm93LmNsb25lKCkuYWRkKDQsICdkYXlzJykudmFsdWVPZigpOyAvLyBOdW1iZXJcblxuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5kZWx0YURpZmZlcmVuY2UgPSAwO1xuICAgIHRoaXMuc2NhbGVPZmZzZXQgPSAwO1xuICAgIHRoaXMuc3RhcnRUb0Zyb250ID0gZmFsc2U7XG4gICAgdGhpcy5lbmRUb0Zyb250ID0gdHJ1ZTtcblxuICAgIC8vIGRlZmF1bHQgb3B0aW9uc1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBydGw6IGZhbHNlLFxuICAgICAgc3RhcnQ6IG51bGwsXG4gICAgICBlbmQ6IG51bGwsXG4gICAgICBtb21lbnQ6IG1vbWVudCxcbiAgICAgIGRpcmVjdGlvbjogJ2hvcml6b250YWwnLCAvLyAnaG9yaXpvbnRhbCcgb3IgJ3ZlcnRpY2FsJ1xuICAgICAgbW92ZWFibGU6IHRydWUsXG4gICAgICB6b29tYWJsZTogdHJ1ZSxcbiAgICAgIG1pbjogbnVsbCxcbiAgICAgIG1heDogbnVsbCxcbiAgICAgIHpvb21NaW46IDEwLCAvLyBtaWxsaXNlY29uZHNcbiAgICAgIHpvb21NYXg6IDEwMDAgKiA2MCAqIDYwICogMjQgKiAzNjUgKiAxMDAwMCAvLyBtaWxsaXNlY29uZHNcbiAgICB9O1xuICAgIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcbiAgICB0aGlzLnByb3BzID0ge1xuICAgICAgdG91Y2g6IHt9XG4gICAgfTtcbiAgICB0aGlzLmFuaW1hdGlvblRpbWVyID0gbnVsbDtcblxuICAgIC8vIGRyYWcgbGlzdGVuZXJzIGZvciBkcmFnZ2luZ1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdwYW5zdGFydCcsIHRoaXMuX29uRHJhZ1N0YXJ0LmJpbmQodGhpcykpO1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdwYW5tb3ZlJywgdGhpcy5fb25EcmFnLmJpbmQodGhpcykpO1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdwYW5lbmQnLCB0aGlzLl9vbkRyYWdFbmQuYmluZCh0aGlzKSk7XG5cbiAgICAvLyBtb3VzZSB3aGVlbCBmb3Igem9vbWluZ1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdtb3VzZXdoZWVsJywgdGhpcy5fb25Nb3VzZVdoZWVsLmJpbmQodGhpcykpO1xuXG4gICAgLy8gcGluY2ggdG8gem9vbVxuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCd0b3VjaCcsIHRoaXMuX29uVG91Y2guYmluZCh0aGlzKSk7XG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ3BpbmNoJywgdGhpcy5fb25QaW5jaC5iaW5kKHRoaXMpKTtcblxuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIFJhbmdlLnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnQoKTtcblxuICAvKipcbiAgICogU2V0IG9wdGlvbnMgZm9yIHRoZSByYW5nZSBjb250cm9sbGVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zICAgICAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge051bWJlciB8IERhdGUgfCBTdHJpbmd9IHN0YXJ0ICBTdGFydCBkYXRlIGZvciB0aGUgcmFuZ2VcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyIHwgRGF0ZSB8IFN0cmluZ30gZW5kICAgIEVuZCBkYXRlIGZvciB0aGUgcmFuZ2VcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyfSBtaW4gICAgTWluaW11bSB2YWx1ZSBmb3Igc3RhcnRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyfSBtYXggICAgTWF4aW11bSB2YWx1ZSBmb3IgZW5kXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge051bWJlcn0gem9vbU1pbiAgICBTZXQgYSBtaW5pbXVtIHZhbHVlIGZvclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGVuZCAtIHN0YXJ0KS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyfSB6b29tTWF4ICAgIFNldCBhIG1heGltdW0gdmFsdWUgZm9yXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZW5kIC0gc3RhcnQpLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtCb29sZWFufSBtb3ZlYWJsZSBFbmFibGUgbW92aW5nIG9mIHRoZSByYW5nZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieSBkcmFnZ2luZy4gVHJ1ZSBieSBkZWZhdWx0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0Jvb2xlYW59IHpvb21hYmxlIEVuYWJsZSB6b29taW5nIG9mIHRoZSByYW5nZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieSBwaW5jaGluZy9zY3JvbGxpbmcuIFRydWUgYnkgZGVmYXVsdFxuICAgKi9cbiAgUmFuZ2UucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAvLyBjb3B5IHRoZSBvcHRpb25zIHRoYXQgd2Uga25vd1xuICAgICAgdmFyIGZpZWxkcyA9IFsnZGlyZWN0aW9uJywgJ21pbicsICdtYXgnLCAnem9vbU1pbicsICd6b29tTWF4JywgJ21vdmVhYmxlJywgJ3pvb21hYmxlJywgJ21vbWVudCcsICdhY3RpdmF0ZScsICdoaWRkZW5EYXRlcycsICd6b29tS2V5JywgJ3J0bCddO1xuICAgICAgdXRpbC5zZWxlY3RpdmVFeHRlbmQoZmllbGRzLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICBpZiAoJ3N0YXJ0JyBpbiBvcHRpb25zIHx8ICdlbmQnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gYXBwbHkgYSBuZXcgcmFuZ2UuIGJvdGggc3RhcnQgYW5kIGVuZCBhcmUgb3B0aW9uYWxcbiAgICAgICAgdGhpcy5zZXRSYW5nZShvcHRpb25zLnN0YXJ0LCBvcHRpb25zLmVuZCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUZXN0IHdoZXRoZXIgZGlyZWN0aW9uIGhhcyBhIHZhbGlkIHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkaXJlY3Rpb24gICAgJ2hvcml6b250YWwnIG9yICd2ZXJ0aWNhbCdcbiAgICovXG4gIGZ1bmN0aW9uIHZhbGlkYXRlRGlyZWN0aW9uKGRpcmVjdGlvbikge1xuICAgIGlmIChkaXJlY3Rpb24gIT0gJ2hvcml6b250YWwnICYmIGRpcmVjdGlvbiAhPSAndmVydGljYWwnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGRpcmVjdGlvbiBcIicgKyBkaXJlY3Rpb24gKyAnXCIuICcgKyAnQ2hvb3NlIFwiaG9yaXpvbnRhbFwiIG9yIFwidmVydGljYWxcIi4nKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IGEgbmV3IHN0YXJ0IGFuZCBlbmQgcmFuZ2VcbiAgICogQHBhcmFtIHtEYXRlIHwgTnVtYmVyIHwgU3RyaW5nfSBbc3RhcnRdXG4gICAqIEBwYXJhbSB7RGF0ZSB8IE51bWJlciB8IFN0cmluZ30gW2VuZF1cbiAgICogQHBhcmFtIHtib29sZWFuIHwge2R1cmF0aW9uOiBudW1iZXIsIGVhc2luZ0Z1bmN0aW9uOiBzdHJpbmd9fSBbYW5pbWF0aW9uPWZhbHNlXVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHRydWUgKGRlZmF1bHQpLCB0aGUgcmFuZ2UgaXMgYW5pbWF0ZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbW9vdGhseSB0byB0aGUgbmV3IHdpbmRvdy4gQW4gb2JqZWN0IGNhbiBiZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVkIHRvIHNwZWNpZnkgZHVyYXRpb24gYW5kIGVhc2luZyBmdW5jdGlvbi5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IGR1cmF0aW9uIGlzIDUwMCBtcywgYW5kIGRlZmF1bHQgZWFzaW5nXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gaXMgJ2Vhc2VJbk91dFF1YWQnLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtieVVzZXI9ZmFsc2VdXG4gICAqXG4gICAqL1xuICBSYW5nZS5wcm90b3R5cGUuc2V0UmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgYW5pbWF0aW9uLCBieVVzZXIpIHtcbiAgICBpZiAoYnlVc2VyICE9PSB0cnVlKSB7XG4gICAgICBieVVzZXIgPSBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGZpbmFsU3RhcnQgPSBzdGFydCAhPSB1bmRlZmluZWQgPyB1dGlsLmNvbnZlcnQoc3RhcnQsICdEYXRlJykudmFsdWVPZigpIDogbnVsbDtcbiAgICB2YXIgZmluYWxFbmQgPSBlbmQgIT0gdW5kZWZpbmVkID8gdXRpbC5jb252ZXJ0KGVuZCwgJ0RhdGUnKS52YWx1ZU9mKCkgOiBudWxsO1xuICAgIHRoaXMuX2NhbmNlbEFuaW1hdGlvbigpO1xuXG4gICAgaWYgKGFuaW1hdGlvbikge1xuICAgICAgLy8gdHJ1ZSBvciBhbiBPYmplY3RcbiAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICB2YXIgaW5pdFN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICAgIHZhciBpbml0RW5kID0gdGhpcy5lbmQ7XG4gICAgICB2YXIgZHVyYXRpb24gPSAodHlwZW9mIGFuaW1hdGlvbiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYW5pbWF0aW9uKSkgPT09ICdvYmplY3QnICYmICdkdXJhdGlvbicgaW4gYW5pbWF0aW9uID8gYW5pbWF0aW9uLmR1cmF0aW9uIDogNTAwO1xuICAgICAgdmFyIGVhc2luZ05hbWUgPSAodHlwZW9mIGFuaW1hdGlvbiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYW5pbWF0aW9uKSkgPT09ICdvYmplY3QnICYmICdlYXNpbmdGdW5jdGlvbicgaW4gYW5pbWF0aW9uID8gYW5pbWF0aW9uLmVhc2luZ0Z1bmN0aW9uIDogJ2Vhc2VJbk91dFF1YWQnO1xuICAgICAgdmFyIGVhc2luZ0Z1bmN0aW9uID0gdXRpbC5lYXNpbmdGdW5jdGlvbnNbZWFzaW5nTmFtZV07XG4gICAgICBpZiAoIWVhc2luZ0Z1bmN0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlYXNpbmcgZnVuY3Rpb24gJyArIEpTT04uc3RyaW5naWZ5KGVhc2luZ05hbWUpICsgJy4gJyArICdDaG9vc2UgZnJvbTogJyArIE9iamVjdC5rZXlzKHV0aWwuZWFzaW5nRnVuY3Rpb25zKS5qb2luKCcsICcpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGluaXRUaW1lID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG4gICAgICB2YXIgYW55Q2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICB2YXIgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIGlmICghbWUucHJvcHMudG91Y2guZHJhZ2dpbmcpIHtcbiAgICAgICAgICB2YXIgbm93ID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG4gICAgICAgICAgdmFyIHRpbWUgPSBub3cgLSBpbml0VGltZTtcbiAgICAgICAgICB2YXIgZWFzZSA9IGVhc2luZ0Z1bmN0aW9uKHRpbWUgLyBkdXJhdGlvbik7XG4gICAgICAgICAgdmFyIGRvbmUgPSB0aW1lID4gZHVyYXRpb247XG4gICAgICAgICAgdmFyIHMgPSBkb25lIHx8IGZpbmFsU3RhcnQgPT09IG51bGwgPyBmaW5hbFN0YXJ0IDogaW5pdFN0YXJ0ICsgKGZpbmFsU3RhcnQgLSBpbml0U3RhcnQpICogZWFzZTtcbiAgICAgICAgICB2YXIgZSA9IGRvbmUgfHwgZmluYWxFbmQgPT09IG51bGwgPyBmaW5hbEVuZCA6IGluaXRFbmQgKyAoZmluYWxFbmQgLSBpbml0RW5kKSAqIGVhc2U7XG5cbiAgICAgICAgICBjaGFuZ2VkID0gbWUuX2FwcGx5UmFuZ2UocywgZSk7XG4gICAgICAgICAgRGF0ZVV0aWwudXBkYXRlSGlkZGVuRGF0ZXMobWUub3B0aW9ucy5tb21lbnQsIG1lLmJvZHksIG1lLm9wdGlvbnMuaGlkZGVuRGF0ZXMpO1xuICAgICAgICAgIGFueUNoYW5nZWQgPSBhbnlDaGFuZ2VkIHx8IGNoYW5nZWQ7XG4gICAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgIG1lLmJvZHkuZW1pdHRlci5lbWl0KCdyYW5nZWNoYW5nZScsIHsgc3RhcnQ6IG5ldyBEYXRlKG1lLnN0YXJ0KSwgZW5kOiBuZXcgRGF0ZShtZS5lbmQpLCBieVVzZXI6IGJ5VXNlciB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgaWYgKGFueUNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgbWUuYm9keS5lbWl0dGVyLmVtaXQoJ3JhbmdlY2hhbmdlZCcsIHsgc3RhcnQ6IG5ldyBEYXRlKG1lLnN0YXJ0KSwgZW5kOiBuZXcgRGF0ZShtZS5lbmQpLCBieVVzZXI6IGJ5VXNlciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gYW5pbWF0ZSB3aXRoIGFzIGhpZ2ggYXMgcG9zc2libGUgZnJhbWUgcmF0ZSwgbGVhdmUgMjAgbXMgaW4gYmV0d2VlblxuICAgICAgICAgICAgLy8gZWFjaCB0byBwcmV2ZW50IHRoZSBicm93c2VyIGZyb20gYmxvY2tpbmdcbiAgICAgICAgICAgIG1lLmFuaW1hdGlvblRpbWVyID0gc2V0VGltZW91dChuZXh0LCAyMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gbmV4dCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY2hhbmdlZCA9IHRoaXMuX2FwcGx5UmFuZ2UoZmluYWxTdGFydCwgZmluYWxFbmQpO1xuICAgICAgRGF0ZVV0aWwudXBkYXRlSGlkZGVuRGF0ZXModGhpcy5vcHRpb25zLm1vbWVudCwgdGhpcy5ib2R5LCB0aGlzLm9wdGlvbnMuaGlkZGVuRGF0ZXMpO1xuICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHsgc3RhcnQ6IG5ldyBEYXRlKHRoaXMuc3RhcnQpLCBlbmQ6IG5ldyBEYXRlKHRoaXMuZW5kKSwgYnlVc2VyOiBieVVzZXIgfTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgncmFuZ2VjaGFuZ2UnLCBwYXJhbXMpO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdyYW5nZWNoYW5nZWQnLCBwYXJhbXMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU3RvcCBhbiBhbmltYXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFJhbmdlLnByb3RvdHlwZS5fY2FuY2VsQW5pbWF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmFuaW1hdGlvblRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5hbmltYXRpb25UaW1lcik7XG4gICAgICB0aGlzLmFuaW1hdGlvblRpbWVyID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBhIG5ldyBzdGFydCBhbmQgZW5kIHJhbmdlLiBUaGlzIG1ldGhvZCBpcyB0aGUgc2FtZSBhcyBzZXRSYW5nZSwgYnV0XG4gICAqIGRvZXMgbm90IHRyaWdnZXIgYSByYW5nZSBjaGFuZ2UgYW5kIHJhbmdlIGNoYW5nZWQgZXZlbnQsIGFuZCBpdCByZXR1cm5zXG4gICAqIHRydWUgd2hlbiB0aGUgcmFuZ2UgaXMgY2hhbmdlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0XVxuICAgKiBAcGFyYW0ge051bWJlcn0gW2VuZF1cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gY2hhbmdlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgUmFuZ2UucHJvdG90eXBlLl9hcHBseVJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgbmV3U3RhcnQgPSBzdGFydCAhPSBudWxsID8gdXRpbC5jb252ZXJ0KHN0YXJ0LCAnRGF0ZScpLnZhbHVlT2YoKSA6IHRoaXMuc3RhcnQsXG4gICAgICAgIG5ld0VuZCA9IGVuZCAhPSBudWxsID8gdXRpbC5jb252ZXJ0KGVuZCwgJ0RhdGUnKS52YWx1ZU9mKCkgOiB0aGlzLmVuZCxcbiAgICAgICAgbWF4ID0gdGhpcy5vcHRpb25zLm1heCAhPSBudWxsID8gdXRpbC5jb252ZXJ0KHRoaXMub3B0aW9ucy5tYXgsICdEYXRlJykudmFsdWVPZigpIDogbnVsbCxcbiAgICAgICAgbWluID0gdGhpcy5vcHRpb25zLm1pbiAhPSBudWxsID8gdXRpbC5jb252ZXJ0KHRoaXMub3B0aW9ucy5taW4sICdEYXRlJykudmFsdWVPZigpIDogbnVsbCxcbiAgICAgICAgZGlmZjtcblxuICAgIC8vIGNoZWNrIGZvciB2YWxpZCBudW1iZXJcbiAgICBpZiAoaXNOYU4obmV3U3RhcnQpIHx8IG5ld1N0YXJ0ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhcnQgXCInICsgc3RhcnQgKyAnXCInKTtcbiAgICB9XG4gICAgaWYgKGlzTmFOKG5ld0VuZCkgfHwgbmV3RW5kID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZW5kIFwiJyArIGVuZCArICdcIicpO1xuICAgIH1cblxuICAgIC8vIHByZXZlbnQgc3RhcnQgPCBlbmRcbiAgICBpZiAobmV3RW5kIDwgbmV3U3RhcnQpIHtcbiAgICAgIG5ld0VuZCA9IG5ld1N0YXJ0O1xuICAgIH1cblxuICAgIC8vIHByZXZlbnQgc3RhcnQgPCBtaW5cbiAgICBpZiAobWluICE9PSBudWxsKSB7XG4gICAgICBpZiAobmV3U3RhcnQgPCBtaW4pIHtcbiAgICAgICAgZGlmZiA9IG1pbiAtIG5ld1N0YXJ0O1xuICAgICAgICBuZXdTdGFydCArPSBkaWZmO1xuICAgICAgICBuZXdFbmQgKz0gZGlmZjtcblxuICAgICAgICAvLyBwcmV2ZW50IGVuZCA+IG1heFxuICAgICAgICBpZiAobWF4ICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAobmV3RW5kID4gbWF4KSB7XG4gICAgICAgICAgICBuZXdFbmQgPSBtYXg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcHJldmVudCBlbmQgPiBtYXhcbiAgICBpZiAobWF4ICE9PSBudWxsKSB7XG4gICAgICBpZiAobmV3RW5kID4gbWF4KSB7XG4gICAgICAgIGRpZmYgPSBuZXdFbmQgLSBtYXg7XG4gICAgICAgIG5ld1N0YXJ0IC09IGRpZmY7XG4gICAgICAgIG5ld0VuZCAtPSBkaWZmO1xuXG4gICAgICAgIC8vIHByZXZlbnQgc3RhcnQgPCBtaW5cbiAgICAgICAgaWYgKG1pbiAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKG5ld1N0YXJ0IDwgbWluKSB7XG4gICAgICAgICAgICBuZXdTdGFydCA9IG1pbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwcmV2ZW50IChlbmQtc3RhcnQpIDwgem9vbU1pblxuICAgIGlmICh0aGlzLm9wdGlvbnMuem9vbU1pbiAhPT0gbnVsbCkge1xuICAgICAgdmFyIHpvb21NaW4gPSBwYXJzZUZsb2F0KHRoaXMub3B0aW9ucy56b29tTWluKTtcbiAgICAgIGlmICh6b29tTWluIDwgMCkge1xuICAgICAgICB6b29tTWluID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChuZXdFbmQgLSBuZXdTdGFydCA8IHpvb21NaW4pIHtcbiAgICAgICAgaWYgKHRoaXMuZW5kIC0gdGhpcy5zdGFydCA9PT0gem9vbU1pbiAmJiBuZXdTdGFydCA+IHRoaXMuc3RhcnQgJiYgbmV3RW5kIDwgdGhpcy5lbmQpIHtcbiAgICAgICAgICAvLyBpZ25vcmUgdGhpcyBhY3Rpb24sIHdlIGFyZSBhbHJlYWR5IHpvb21lZCB0byB0aGUgbWluaW11bVxuICAgICAgICAgIG5ld1N0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICAgICAgICBuZXdFbmQgPSB0aGlzLmVuZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB6b29tIHRvIHRoZSBtaW5pbXVtXG4gICAgICAgICAgZGlmZiA9IHpvb21NaW4gLSAobmV3RW5kIC0gbmV3U3RhcnQpO1xuICAgICAgICAgIG5ld1N0YXJ0IC09IGRpZmYgLyAyO1xuICAgICAgICAgIG5ld0VuZCArPSBkaWZmIC8gMjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHByZXZlbnQgKGVuZC1zdGFydCkgPiB6b29tTWF4XG4gICAgaWYgKHRoaXMub3B0aW9ucy56b29tTWF4ICE9PSBudWxsKSB7XG4gICAgICB2YXIgem9vbU1heCA9IHBhcnNlRmxvYXQodGhpcy5vcHRpb25zLnpvb21NYXgpO1xuICAgICAgaWYgKHpvb21NYXggPCAwKSB7XG4gICAgICAgIHpvb21NYXggPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV3RW5kIC0gbmV3U3RhcnQgPiB6b29tTWF4KSB7XG4gICAgICAgIGlmICh0aGlzLmVuZCAtIHRoaXMuc3RhcnQgPT09IHpvb21NYXggJiYgbmV3U3RhcnQgPCB0aGlzLnN0YXJ0ICYmIG5ld0VuZCA+IHRoaXMuZW5kKSB7XG4gICAgICAgICAgLy8gaWdub3JlIHRoaXMgYWN0aW9uLCB3ZSBhcmUgYWxyZWFkeSB6b29tZWQgdG8gdGhlIG1heGltdW1cbiAgICAgICAgICBuZXdTdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgICAgICAgbmV3RW5kID0gdGhpcy5lbmQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gem9vbSB0byB0aGUgbWF4aW11bVxuICAgICAgICAgIGRpZmYgPSBuZXdFbmQgLSBuZXdTdGFydCAtIHpvb21NYXg7XG4gICAgICAgICAgbmV3U3RhcnQgKz0gZGlmZiAvIDI7XG4gICAgICAgICAgbmV3RW5kIC09IGRpZmYgLyAyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoYW5nZWQgPSB0aGlzLnN0YXJ0ICE9IG5ld1N0YXJ0IHx8IHRoaXMuZW5kICE9IG5ld0VuZDtcblxuICAgIC8vIGlmIHRoZSBuZXcgcmFuZ2UgZG9lcyBOT1Qgb3ZlcmxhcCB3aXRoIHRoZSBvbGQgcmFuZ2UsIGVtaXQgY2hlY2tSYW5nZWRJdGVtcyB0byBhdm9pZCBub3Qgc2hvd2luZyByYW5nZWQgaXRlbXMgKHJhbmdlZCBtZWFuaW5nIGhhcyBlbmQgdGltZSwgbm90IG5lY2Vzc2FyaWx5IG9mIHR5cGUgUmFuZ2UpXG4gICAgaWYgKCEobmV3U3RhcnQgPj0gdGhpcy5zdGFydCAmJiBuZXdTdGFydCA8PSB0aGlzLmVuZCB8fCBuZXdFbmQgPj0gdGhpcy5zdGFydCAmJiBuZXdFbmQgPD0gdGhpcy5lbmQpICYmICEodGhpcy5zdGFydCA+PSBuZXdTdGFydCAmJiB0aGlzLnN0YXJ0IDw9IG5ld0VuZCB8fCB0aGlzLmVuZCA+PSBuZXdTdGFydCAmJiB0aGlzLmVuZCA8PSBuZXdFbmQpKSB7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdjaGVja1JhbmdlZEl0ZW1zJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGFydCA9IG5ld1N0YXJ0O1xuICAgIHRoaXMuZW5kID0gbmV3RW5kO1xuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgY3VycmVudCByYW5nZS5cbiAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBzdGFydCBhbmQgZW5kIHByb3BlcnRpZXNcbiAgICovXG4gIFJhbmdlLnByb3RvdHlwZS5nZXRSYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHRoaXMuc3RhcnQsXG4gICAgICBlbmQ6IHRoaXMuZW5kXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBjb252ZXJzaW9uIG9mZnNldCBhbmQgc2NhbGUgZm9yIGN1cnJlbnQgcmFuZ2UsIGJhc2VkIG9uXG4gICAqIHRoZSBwcm92aWRlZCB3aWR0aFxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICogQHJldHVybnMge3tvZmZzZXQ6IG51bWJlciwgc2NhbGU6IG51bWJlcn19IGNvbnZlcnNpb25cbiAgICovXG4gIFJhbmdlLnByb3RvdHlwZS5jb252ZXJzaW9uID0gZnVuY3Rpb24gKHdpZHRoLCB0b3RhbEhpZGRlbikge1xuICAgIHJldHVybiBSYW5nZS5jb252ZXJzaW9uKHRoaXMuc3RhcnQsIHRoaXMuZW5kLCB3aWR0aCwgdG90YWxIaWRkZW4pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdGF0aWMgbWV0aG9kIHRvIGNhbGN1bGF0ZSB0aGUgY29udmVyc2lvbiBvZmZzZXQgYW5kIHNjYWxlIGZvciBhIHJhbmdlLFxuICAgKiBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgc3RhcnQsIGVuZCwgYW5kIHdpZHRoXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFxuICAgKiBAcGFyYW0ge051bWJlcn0gZW5kXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgKiBAcmV0dXJucyB7e29mZnNldDogbnVtYmVyLCBzY2FsZTogbnVtYmVyfX0gY29udmVyc2lvblxuICAgKi9cbiAgUmFuZ2UuY29udmVyc2lvbiA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCB3aWR0aCwgdG90YWxIaWRkZW4pIHtcbiAgICBpZiAodG90YWxIaWRkZW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdG90YWxIaWRkZW4gPSAwO1xuICAgIH1cbiAgICBpZiAod2lkdGggIT0gMCAmJiBlbmQgLSBzdGFydCAhPSAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvZmZzZXQ6IHN0YXJ0LFxuICAgICAgICBzY2FsZTogd2lkdGggLyAoZW5kIC0gc3RhcnQgLSB0b3RhbEhpZGRlbilcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgc2NhbGU6IDFcbiAgICAgIH07XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTdGFydCBkcmFnZ2luZyBob3Jpem9udGFsbHkgb3IgdmVydGljYWxseVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgUmFuZ2UucHJvdG90eXBlLl9vbkRyYWdTdGFydCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHRoaXMuZGVsdGFEaWZmZXJlbmNlID0gMDtcbiAgICB0aGlzLnByZXZpb3VzRGVsdGEgPSAwO1xuXG4gICAgLy8gb25seSBhbGxvdyBkcmFnZ2luZyB3aGVuIGNvbmZpZ3VyZWQgYXMgbW92YWJsZVxuICAgIGlmICghdGhpcy5vcHRpb25zLm1vdmVhYmxlKSByZXR1cm47XG5cbiAgICAvLyBvbmx5IHN0YXJ0IGRyYWdnaW5nIHdoZW4gdGhlIG1vdXNlIGlzIGluc2lkZSB0aGUgY3VycmVudCByYW5nZVxuICAgIGlmICghdGhpcy5faXNJbnNpZGVSYW5nZShldmVudCkpIHJldHVybjtcblxuICAgIC8vIHJlZnVzZSB0byBkcmFnIHdoZW4gd2Ugd2hlcmUgcGluY2hpbmcgdG8gcHJldmVudCB0aGUgdGltZWxpbmUgbWFrZSBhIGp1bXBcbiAgICAvLyB3aGVuIHJlbGVhc2luZyB0aGUgZmluZ2VycyBpbiBvcHBvc2l0ZSBvcmRlciBmcm9tIHRoZSB0b3VjaCBzY3JlZW5cbiAgICBpZiAoIXRoaXMucHJvcHMudG91Y2guYWxsb3dEcmFnZ2luZykgcmV0dXJuO1xuXG4gICAgdGhpcy5wcm9wcy50b3VjaC5zdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgdGhpcy5wcm9wcy50b3VjaC5lbmQgPSB0aGlzLmVuZDtcbiAgICB0aGlzLnByb3BzLnRvdWNoLmRyYWdnaW5nID0gdHJ1ZTtcblxuICAgIGlmICh0aGlzLmJvZHkuZG9tLnJvb3QpIHtcbiAgICAgIHRoaXMuYm9keS5kb20ucm9vdC5zdHlsZS5jdXJzb3IgPSAnbW92ZSc7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGRyYWdnaW5nIG9wZXJhdGlvblxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgUmFuZ2UucHJvdG90eXBlLl9vbkRyYWcgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMucHJvcHMudG91Y2guZHJhZ2dpbmcpIHJldHVybjtcblxuICAgIC8vIG9ubHkgYWxsb3cgZHJhZ2dpbmcgd2hlbiBjb25maWd1cmVkIGFzIG1vdmFibGVcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5tb3ZlYWJsZSkgcmV0dXJuO1xuXG4gICAgLy8gVE9ETzogdGhpcyBtYXkgYmUgcmVkdW5kYW50IGluIGhhbW1lcmpzMlxuICAgIC8vIHJlZnVzZSB0byBkcmFnIHdoZW4gd2Ugd2hlcmUgcGluY2hpbmcgdG8gcHJldmVudCB0aGUgdGltZWxpbmUgbWFrZSBhIGp1bXBcbiAgICAvLyB3aGVuIHJlbGVhc2luZyB0aGUgZmluZ2VycyBpbiBvcHBvc2l0ZSBvcmRlciBmcm9tIHRoZSB0b3VjaCBzY3JlZW5cbiAgICBpZiAoIXRoaXMucHJvcHMudG91Y2guYWxsb3dEcmFnZ2luZykgcmV0dXJuO1xuXG4gICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb247XG4gICAgdmFsaWRhdGVEaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICB2YXIgZGVsdGEgPSBkaXJlY3Rpb24gPT0gJ2hvcml6b250YWwnID8gZXZlbnQuZGVsdGFYIDogZXZlbnQuZGVsdGFZO1xuICAgIGRlbHRhIC09IHRoaXMuZGVsdGFEaWZmZXJlbmNlO1xuICAgIHZhciBpbnRlcnZhbCA9IHRoaXMucHJvcHMudG91Y2guZW5kIC0gdGhpcy5wcm9wcy50b3VjaC5zdGFydDtcblxuICAgIC8vIG5vcm1hbGl6ZSBkcmFnZ2luZyBzcGVlZCBpZiBjdXRvdXQgaXMgaW4gYmV0d2Vlbi5cbiAgICB2YXIgZHVyYXRpb24gPSBEYXRlVXRpbC5nZXRIaWRkZW5EdXJhdGlvbkJldHdlZW4odGhpcy5ib2R5LmhpZGRlbkRhdGVzLCB0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG4gICAgaW50ZXJ2YWwgLT0gZHVyYXRpb247XG5cbiAgICB2YXIgd2lkdGggPSBkaXJlY3Rpb24gPT0gJ2hvcml6b250YWwnID8gdGhpcy5ib2R5LmRvbVByb3BzLmNlbnRlci53aWR0aCA6IHRoaXMuYm9keS5kb21Qcm9wcy5jZW50ZXIuaGVpZ2h0O1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgIHZhciBkaWZmUmFuZ2UgPSBkZWx0YSAvIHdpZHRoICogaW50ZXJ2YWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkaWZmUmFuZ2UgPSAtZGVsdGEgLyB3aWR0aCAqIGludGVydmFsO1xuICAgIH1cblxuICAgIHZhciBuZXdTdGFydCA9IHRoaXMucHJvcHMudG91Y2guc3RhcnQgKyBkaWZmUmFuZ2U7XG4gICAgdmFyIG5ld0VuZCA9IHRoaXMucHJvcHMudG91Y2guZW5kICsgZGlmZlJhbmdlO1xuXG4gICAgLy8gc25hcHBpbmcgdGltZXMgYXdheSBmcm9tIGhpZGRlbiB6b25lc1xuICAgIHZhciBzYWZlU3RhcnQgPSBEYXRlVXRpbC5zbmFwQXdheUZyb21IaWRkZW4odGhpcy5ib2R5LmhpZGRlbkRhdGVzLCBuZXdTdGFydCwgdGhpcy5wcmV2aW91c0RlbHRhIC0gZGVsdGEsIHRydWUpO1xuICAgIHZhciBzYWZlRW5kID0gRGF0ZVV0aWwuc25hcEF3YXlGcm9tSGlkZGVuKHRoaXMuYm9keS5oaWRkZW5EYXRlcywgbmV3RW5kLCB0aGlzLnByZXZpb3VzRGVsdGEgLSBkZWx0YSwgdHJ1ZSk7XG4gICAgaWYgKHNhZmVTdGFydCAhPSBuZXdTdGFydCB8fCBzYWZlRW5kICE9IG5ld0VuZCkge1xuICAgICAgdGhpcy5kZWx0YURpZmZlcmVuY2UgKz0gZGVsdGE7XG4gICAgICB0aGlzLnByb3BzLnRvdWNoLnN0YXJ0ID0gc2FmZVN0YXJ0O1xuICAgICAgdGhpcy5wcm9wcy50b3VjaC5lbmQgPSBzYWZlRW5kO1xuICAgICAgdGhpcy5fb25EcmFnKGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnByZXZpb3VzRGVsdGEgPSBkZWx0YTtcbiAgICB0aGlzLl9hcHBseVJhbmdlKG5ld1N0YXJ0LCBuZXdFbmQpO1xuXG4gICAgdmFyIHN0YXJ0RGF0ZSA9IG5ldyBEYXRlKHRoaXMuc3RhcnQpO1xuICAgIHZhciBlbmREYXRlID0gbmV3IERhdGUodGhpcy5lbmQpO1xuXG4gICAgLy8gZmlyZSBhIHJhbmdlY2hhbmdlIGV2ZW50XG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgncmFuZ2VjaGFuZ2UnLCB7XG4gICAgICBzdGFydDogc3RhcnREYXRlLFxuICAgICAgZW5kOiBlbmREYXRlLFxuICAgICAgYnlVc2VyOiB0cnVlXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0b3AgZHJhZ2dpbmcgb3BlcmF0aW9uXG4gICAqIEBwYXJhbSB7ZXZlbnR9IGV2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBSYW5nZS5wcm90b3R5cGUuX29uRHJhZ0VuZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmICghdGhpcy5wcm9wcy50b3VjaC5kcmFnZ2luZykgcmV0dXJuO1xuXG4gICAgLy8gb25seSBhbGxvdyBkcmFnZ2luZyB3aGVuIGNvbmZpZ3VyZWQgYXMgbW92YWJsZVxuICAgIGlmICghdGhpcy5vcHRpb25zLm1vdmVhYmxlKSByZXR1cm47XG5cbiAgICAvLyBUT0RPOiB0aGlzIG1heSBiZSByZWR1bmRhbnQgaW4gaGFtbWVyanMyXG4gICAgLy8gcmVmdXNlIHRvIGRyYWcgd2hlbiB3ZSB3aGVyZSBwaW5jaGluZyB0byBwcmV2ZW50IHRoZSB0aW1lbGluZSBtYWtlIGEganVtcFxuICAgIC8vIHdoZW4gcmVsZWFzaW5nIHRoZSBmaW5nZXJzIGluIG9wcG9zaXRlIG9yZGVyIGZyb20gdGhlIHRvdWNoIHNjcmVlblxuICAgIGlmICghdGhpcy5wcm9wcy50b3VjaC5hbGxvd0RyYWdnaW5nKSByZXR1cm47XG5cbiAgICB0aGlzLnByb3BzLnRvdWNoLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuYm9keS5kb20ucm9vdCkge1xuICAgICAgdGhpcy5ib2R5LmRvbS5yb290LnN0eWxlLmN1cnNvciA9ICdhdXRvJztcbiAgICB9XG5cbiAgICAvLyBmaXJlIGEgcmFuZ2VjaGFuZ2VkIGV2ZW50XG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgncmFuZ2VjaGFuZ2VkJywge1xuICAgICAgc3RhcnQ6IG5ldyBEYXRlKHRoaXMuc3RhcnQpLFxuICAgICAgZW5kOiBuZXcgRGF0ZSh0aGlzLmVuZCksXG4gICAgICBieVVzZXI6IHRydWVcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBmb3IgbW91c2Ugd2hlZWwgZXZlbnQsIHVzZWQgdG8gem9vbVxuICAgKiBDb2RlIGZyb20gaHR0cDovL2Fkb21hcy5vcmcvamF2YXNjcmlwdC1tb3VzZS13aGVlbC9cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFJhbmdlLnByb3RvdHlwZS5fb25Nb3VzZVdoZWVsID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gb25seSBhbGxvdyB6b29taW5nIHdoZW4gY29uZmlndXJlZCBhcyB6b29tYWJsZSBhbmQgbW92ZWFibGVcbiAgICBpZiAoISh0aGlzLm9wdGlvbnMuem9vbWFibGUgJiYgdGhpcy5vcHRpb25zLm1vdmVhYmxlKSkgcmV0dXJuO1xuXG4gICAgLy8gb25seSB6b29tIHdoZW4gdGhlIG1vdXNlIGlzIGluc2lkZSB0aGUgY3VycmVudCByYW5nZVxuICAgIGlmICghdGhpcy5faXNJbnNpZGVSYW5nZShldmVudCkpIHJldHVybjtcblxuICAgIC8vIG9ubHkgem9vbSB3aGVuIHRoZSBhY2NvcmRpbmcga2V5IGlzIHByZXNzZWQgYW5kIHRoZSB6b29tS2V5IG9wdGlvbiBpcyBzZXRcbiAgICBpZiAodGhpcy5vcHRpb25zLnpvb21LZXkgJiYgIWV2ZW50W3RoaXMub3B0aW9ucy56b29tS2V5XSkgcmV0dXJuO1xuXG4gICAgLy8gcmV0cmlldmUgZGVsdGFcbiAgICB2YXIgZGVsdGEgPSAwO1xuICAgIGlmIChldmVudC53aGVlbERlbHRhKSB7XG4gICAgICAvKiBJRS9PcGVyYS4gKi9cbiAgICAgIGRlbHRhID0gZXZlbnQud2hlZWxEZWx0YSAvIDEyMDtcbiAgICB9IGVsc2UgaWYgKGV2ZW50LmRldGFpbCkge1xuICAgICAgLyogTW96aWxsYSBjYXNlLiAqL1xuICAgICAgLy8gSW4gTW96aWxsYSwgc2lnbiBvZiBkZWx0YSBpcyBkaWZmZXJlbnQgdGhhbiBpbiBJRS5cbiAgICAgIC8vIEFsc28sIGRlbHRhIGlzIG11bHRpcGxlIG9mIDMuXG4gICAgICBkZWx0YSA9IC1ldmVudC5kZXRhaWwgLyAzO1xuICAgIH1cblxuICAgIC8vIElmIGRlbHRhIGlzIG5vbnplcm8sIGhhbmRsZSBpdC5cbiAgICAvLyBCYXNpY2FsbHksIGRlbHRhIGlzIG5vdyBwb3NpdGl2ZSBpZiB3aGVlbCB3YXMgc2Nyb2xsZWQgdXAsXG4gICAgLy8gYW5kIG5lZ2F0aXZlLCBpZiB3aGVlbCB3YXMgc2Nyb2xsZWQgZG93bi5cbiAgICBpZiAoZGVsdGEpIHtcbiAgICAgIC8vIHBlcmZvcm0gdGhlIHpvb20gYWN0aW9uLiBEZWx0YSBpcyBub3JtYWxseSAxIG9yIC0xXG5cbiAgICAgIC8vIGFkanVzdCBhIG5lZ2F0aXZlIGRlbHRhIHN1Y2ggdGhhdCB6b29taW5nIGluIHdpdGggZGVsdGEgMC4xXG4gICAgICAvLyBlcXVhbHMgem9vbWluZyBvdXQgd2l0aCBhIGRlbHRhIC0wLjFcbiAgICAgIHZhciBzY2FsZTtcbiAgICAgIGlmIChkZWx0YSA8IDApIHtcbiAgICAgICAgc2NhbGUgPSAxIC0gZGVsdGEgLyA1O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NhbGUgPSAxIC8gKDEgKyBkZWx0YSAvIDUpO1xuICAgICAgfVxuXG4gICAgICAvLyBjYWxjdWxhdGUgY2VudGVyLCB0aGUgZGF0ZSB0byB6b29tIGFyb3VuZFxuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoeyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZIH0sIHRoaXMuYm9keS5kb20uY2VudGVyKTtcbiAgICAgIHZhciBwb2ludGVyRGF0ZSA9IHRoaXMuX3BvaW50ZXJUb0RhdGUocG9pbnRlcik7XG5cbiAgICAgIHRoaXMuem9vbShzY2FsZSwgcG9pbnRlckRhdGUsIGRlbHRhKTtcbiAgICB9XG5cbiAgICAvLyBQcmV2ZW50IGRlZmF1bHQgYWN0aW9ucyBjYXVzZWQgYnkgbW91c2Ugd2hlZWxcbiAgICAvLyAoZWxzZSB0aGUgcGFnZSBhbmQgdGltZWxpbmUgYm90aCB6b29tIGFuZCBzY3JvbGwpXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfTtcblxuICAvKipcbiAgICogU3RhcnQgb2YgYSB0b3VjaCBnZXN0dXJlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBSYW5nZS5wcm90b3R5cGUuX29uVG91Y2ggPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB0aGlzLnByb3BzLnRvdWNoLnN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICB0aGlzLnByb3BzLnRvdWNoLmVuZCA9IHRoaXMuZW5kO1xuICAgIHRoaXMucHJvcHMudG91Y2guYWxsb3dEcmFnZ2luZyA9IHRydWU7XG4gICAgdGhpcy5wcm9wcy50b3VjaC5jZW50ZXIgPSBudWxsO1xuICAgIHRoaXMuc2NhbGVPZmZzZXQgPSAwO1xuICAgIHRoaXMuZGVsdGFEaWZmZXJlbmNlID0gMDtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIHBpbmNoIGV2ZW50XG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBSYW5nZS5wcm90b3R5cGUuX29uUGluY2ggPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBvbmx5IGFsbG93IHpvb21pbmcgd2hlbiBjb25maWd1cmVkIGFzIHpvb21hYmxlIGFuZCBtb3ZlYWJsZVxuICAgIGlmICghKHRoaXMub3B0aW9ucy56b29tYWJsZSAmJiB0aGlzLm9wdGlvbnMubW92ZWFibGUpKSByZXR1cm47XG5cbiAgICB0aGlzLnByb3BzLnRvdWNoLmFsbG93RHJhZ2dpbmcgPSBmYWxzZTtcblxuICAgIGlmICghdGhpcy5wcm9wcy50b3VjaC5jZW50ZXIpIHtcbiAgICAgIHRoaXMucHJvcHMudG91Y2guY2VudGVyID0gdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlciwgdGhpcy5ib2R5LmRvbS5jZW50ZXIpO1xuICAgIH1cblxuICAgIHZhciBzY2FsZSA9IDEgLyAoZXZlbnQuc2NhbGUgKyB0aGlzLnNjYWxlT2Zmc2V0KTtcbiAgICB2YXIgY2VudGVyRGF0ZSA9IHRoaXMuX3BvaW50ZXJUb0RhdGUodGhpcy5wcm9wcy50b3VjaC5jZW50ZXIpO1xuXG4gICAgdmFyIGhpZGRlbkR1cmF0aW9uID0gRGF0ZVV0aWwuZ2V0SGlkZGVuRHVyYXRpb25CZXR3ZWVuKHRoaXMuYm9keS5oaWRkZW5EYXRlcywgdGhpcy5zdGFydCwgdGhpcy5lbmQpO1xuICAgIHZhciBoaWRkZW5EdXJhdGlvbkJlZm9yZSA9IERhdGVVdGlsLmdldEhpZGRlbkR1cmF0aW9uQmVmb3JlKHRoaXMub3B0aW9ucy5tb21lbnQsIHRoaXMuYm9keS5oaWRkZW5EYXRlcywgdGhpcywgY2VudGVyRGF0ZSk7XG4gICAgdmFyIGhpZGRlbkR1cmF0aW9uQWZ0ZXIgPSBoaWRkZW5EdXJhdGlvbiAtIGhpZGRlbkR1cmF0aW9uQmVmb3JlO1xuXG4gICAgLy8gY2FsY3VsYXRlIG5ldyBzdGFydCBhbmQgZW5kXG4gICAgdmFyIG5ld1N0YXJ0ID0gY2VudGVyRGF0ZSAtIGhpZGRlbkR1cmF0aW9uQmVmb3JlICsgKHRoaXMucHJvcHMudG91Y2guc3RhcnQgLSAoY2VudGVyRGF0ZSAtIGhpZGRlbkR1cmF0aW9uQmVmb3JlKSkgKiBzY2FsZTtcbiAgICB2YXIgbmV3RW5kID0gY2VudGVyRGF0ZSArIGhpZGRlbkR1cmF0aW9uQWZ0ZXIgKyAodGhpcy5wcm9wcy50b3VjaC5lbmQgLSAoY2VudGVyRGF0ZSArIGhpZGRlbkR1cmF0aW9uQWZ0ZXIpKSAqIHNjYWxlO1xuXG4gICAgLy8gc25hcHBpbmcgdGltZXMgYXdheSBmcm9tIGhpZGRlbiB6b25lc1xuICAgIHRoaXMuc3RhcnRUb0Zyb250ID0gMSAtIHNjYWxlIDw9IDA7IC8vIHVzZWQgdG8gZG8gdGhlIHJpZ2h0IGF1dG8gY29ycmVjdGlvbiB3aXRoIHBlcmlvZGljIGhpZGRlbiB0aW1lc1xuICAgIHRoaXMuZW5kVG9Gcm9udCA9IHNjYWxlIC0gMSA8PSAwOyAvLyB1c2VkIHRvIGRvIHRoZSByaWdodCBhdXRvIGNvcnJlY3Rpb24gd2l0aCBwZXJpb2RpYyBoaWRkZW4gdGltZXNcblxuICAgIHZhciBzYWZlU3RhcnQgPSBEYXRlVXRpbC5zbmFwQXdheUZyb21IaWRkZW4odGhpcy5ib2R5LmhpZGRlbkRhdGVzLCBuZXdTdGFydCwgMSAtIHNjYWxlLCB0cnVlKTtcbiAgICB2YXIgc2FmZUVuZCA9IERhdGVVdGlsLnNuYXBBd2F5RnJvbUhpZGRlbih0aGlzLmJvZHkuaGlkZGVuRGF0ZXMsIG5ld0VuZCwgc2NhbGUgLSAxLCB0cnVlKTtcbiAgICBpZiAoc2FmZVN0YXJ0ICE9IG5ld1N0YXJ0IHx8IHNhZmVFbmQgIT0gbmV3RW5kKSB7XG4gICAgICB0aGlzLnByb3BzLnRvdWNoLnN0YXJ0ID0gc2FmZVN0YXJ0O1xuICAgICAgdGhpcy5wcm9wcy50b3VjaC5lbmQgPSBzYWZlRW5kO1xuICAgICAgdGhpcy5zY2FsZU9mZnNldCA9IDEgLSBldmVudC5zY2FsZTtcbiAgICAgIG5ld1N0YXJ0ID0gc2FmZVN0YXJ0O1xuICAgICAgbmV3RW5kID0gc2FmZUVuZDtcbiAgICB9XG5cbiAgICB0aGlzLnNldFJhbmdlKG5ld1N0YXJ0LCBuZXdFbmQsIGZhbHNlLCB0cnVlKTtcblxuICAgIHRoaXMuc3RhcnRUb0Zyb250ID0gZmFsc2U7IC8vIHJldmVydCB0byBkZWZhdWx0XG4gICAgdGhpcy5lbmRUb0Zyb250ID0gdHJ1ZTsgLy8gcmV2ZXJ0IHRvIGRlZmF1bHRcbiAgfTtcblxuICAvKipcbiAgICogVGVzdCB3aGV0aGVyIHRoZSBtb3VzZSBmcm9tIGEgbW91c2UgZXZlbnQgaXMgaW5zaWRlIHRoZSB2aXNpYmxlIHdpbmRvdyxcbiAgICogYmV0d2VlbiB0aGUgY3VycmVudCBzdGFydCBhbmQgZW5kIGRhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSB3aGVuIGluc2lkZSB0aGUgdmlzaWJsZSB3aW5kb3dcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFJhbmdlLnByb3RvdHlwZS5faXNJbnNpZGVSYW5nZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGNhbGN1bGF0ZSB0aGUgdGltZSB3aGVyZSB0aGUgbW91c2UgaXMsIGNoZWNrIHdoZXRoZXIgaW5zaWRlXG4gICAgLy8gYW5kIG5vIHNjcm9sbCBhY3Rpb24gc2hvdWxkIGhhcHBlbi5cbiAgICB2YXIgY2xpZW50WCA9IGV2ZW50LmNlbnRlciA/IGV2ZW50LmNlbnRlci54IDogZXZlbnQuY2xpZW50WDtcbiAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgdmFyIHggPSBjbGllbnRYIC0gdXRpbC5nZXRBYnNvbHV0ZUxlZnQodGhpcy5ib2R5LmRvbS5jZW50ZXJDb250YWluZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgeCA9IHV0aWwuZ2V0QWJzb2x1dGVSaWdodCh0aGlzLmJvZHkuZG9tLmNlbnRlckNvbnRhaW5lcikgLSBjbGllbnRYO1xuICAgIH1cbiAgICB2YXIgdGltZSA9IHRoaXMuYm9keS51dGlsLnRvVGltZSh4KTtcblxuICAgIHJldHVybiB0aW1lID49IHRoaXMuc3RhcnQgJiYgdGltZSA8PSB0aGlzLmVuZDtcbiAgfTtcblxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGNhbGN1bGF0ZSB0aGUgY2VudGVyIGRhdGUgZm9yIHpvb21pbmdcbiAgICogQHBhcmFtIHt7eDogTnVtYmVyLCB5OiBOdW1iZXJ9fSBwb2ludGVyXG4gICAqIEByZXR1cm4ge251bWJlcn0gZGF0ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgUmFuZ2UucHJvdG90eXBlLl9wb2ludGVyVG9EYXRlID0gZnVuY3Rpb24gKHBvaW50ZXIpIHtcbiAgICB2YXIgY29udmVyc2lvbjtcbiAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcblxuICAgIHZhbGlkYXRlRGlyZWN0aW9uKGRpcmVjdGlvbik7XG5cbiAgICBpZiAoZGlyZWN0aW9uID09ICdob3Jpem9udGFsJykge1xuICAgICAgcmV0dXJuIHRoaXMuYm9keS51dGlsLnRvVGltZShwb2ludGVyLngpLnZhbHVlT2YoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGhlaWdodCA9IHRoaXMuYm9keS5kb21Qcm9wcy5jZW50ZXIuaGVpZ2h0O1xuICAgICAgY29udmVyc2lvbiA9IHRoaXMuY29udmVyc2lvbihoZWlnaHQpO1xuICAgICAgcmV0dXJuIHBvaW50ZXIueSAvIGNvbnZlcnNpb24uc2NhbGUgKyBjb252ZXJzaW9uLm9mZnNldDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcG9pbnRlciBsb2NhdGlvbiByZWxhdGl2ZSB0byB0aGUgbG9jYXRpb24gb2YgdGhlIGRvbSBlbGVtZW50XG4gICAqIEBwYXJhbSB7e3g6IE51bWJlciwgeTogTnVtYmVyfX0gdG91Y2hcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50ICAgSFRNTCBET00gZWxlbWVudFxuICAgKiBAcmV0dXJuIHt7eDogTnVtYmVyLCB5OiBOdW1iZXJ9fSBwb2ludGVyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBSYW5nZS5wcm90b3R5cGUuZ2V0UG9pbnRlciA9IGZ1bmN0aW9uICh0b3VjaCwgZWxlbWVudCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMucnRsKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB1dGlsLmdldEFic29sdXRlUmlnaHQoZWxlbWVudCkgLSB0b3VjaC54LFxuICAgICAgICB5OiB0b3VjaC55IC0gdXRpbC5nZXRBYnNvbHV0ZVRvcChlbGVtZW50KVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogdG91Y2gueCAtIHV0aWwuZ2V0QWJzb2x1dGVMZWZ0KGVsZW1lbnQpLFxuICAgICAgICB5OiB0b3VjaC55IC0gdXRpbC5nZXRBYnNvbHV0ZVRvcChlbGVtZW50KVxuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFpvb20gdGhlIHJhbmdlIHRoZSBnaXZlbiBzY2FsZSBpbiBvciBvdXQuIFN0YXJ0IGFuZCBlbmQgZGF0ZSB3aWxsXG4gICAqIGJlIGFkanVzdGVkLCBhbmQgdGhlIHRpbWVsaW5lIHdpbGwgYmUgcmVkcmF3bi4gWW91IGNhbiBvcHRpb25hbGx5IGdpdmUgYVxuICAgKiBkYXRlIGFyb3VuZCB3aGljaCB0byB6b29tLlxuICAgKiBGb3IgZXhhbXBsZSwgdHJ5IHNjYWxlID0gMC45IG9yIDEuMVxuICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgICAgICBTY2FsaW5nIGZhY3Rvci4gVmFsdWVzIGFib3ZlIDEgd2lsbCB6b29tIG91dCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzIGJlbG93IDEgd2lsbCB6b29tIGluLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NlbnRlcl0gICBWYWx1ZSByZXByZXNlbnRpbmcgYSBkYXRlIGFyb3VuZCB3aGljaCB3aWxsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlIHpvb21lZC5cbiAgICovXG4gIFJhbmdlLnByb3RvdHlwZS56b29tID0gZnVuY3Rpb24gKHNjYWxlLCBjZW50ZXIsIGRlbHRhKSB7XG4gICAgLy8gaWYgY2VudGVyRGF0ZSBpcyBub3QgcHJvdmlkZWQsIHRha2UgaXQgaGFsZiBiZXR3ZWVuIHN0YXJ0IERhdGUgYW5kIGVuZCBEYXRlXG4gICAgaWYgKGNlbnRlciA9PSBudWxsKSB7XG4gICAgICBjZW50ZXIgPSAodGhpcy5zdGFydCArIHRoaXMuZW5kKSAvIDI7XG4gICAgfVxuXG4gICAgdmFyIGhpZGRlbkR1cmF0aW9uID0gRGF0ZVV0aWwuZ2V0SGlkZGVuRHVyYXRpb25CZXR3ZWVuKHRoaXMuYm9keS5oaWRkZW5EYXRlcywgdGhpcy5zdGFydCwgdGhpcy5lbmQpO1xuICAgIHZhciBoaWRkZW5EdXJhdGlvbkJlZm9yZSA9IERhdGVVdGlsLmdldEhpZGRlbkR1cmF0aW9uQmVmb3JlKHRoaXMub3B0aW9ucy5tb21lbnQsIHRoaXMuYm9keS5oaWRkZW5EYXRlcywgdGhpcywgY2VudGVyKTtcbiAgICB2YXIgaGlkZGVuRHVyYXRpb25BZnRlciA9IGhpZGRlbkR1cmF0aW9uIC0gaGlkZGVuRHVyYXRpb25CZWZvcmU7XG5cbiAgICAvLyBjYWxjdWxhdGUgbmV3IHN0YXJ0IGFuZCBlbmRcbiAgICB2YXIgbmV3U3RhcnQgPSBjZW50ZXIgLSBoaWRkZW5EdXJhdGlvbkJlZm9yZSArICh0aGlzLnN0YXJ0IC0gKGNlbnRlciAtIGhpZGRlbkR1cmF0aW9uQmVmb3JlKSkgKiBzY2FsZTtcbiAgICB2YXIgbmV3RW5kID0gY2VudGVyICsgaGlkZGVuRHVyYXRpb25BZnRlciArICh0aGlzLmVuZCAtIChjZW50ZXIgKyBoaWRkZW5EdXJhdGlvbkFmdGVyKSkgKiBzY2FsZTtcblxuICAgIC8vIHNuYXBwaW5nIHRpbWVzIGF3YXkgZnJvbSBoaWRkZW4gem9uZXNcbiAgICB0aGlzLnN0YXJ0VG9Gcm9udCA9IGRlbHRhID4gMCA/IGZhbHNlIDogdHJ1ZTsgLy8gdXNlZCB0byBkbyB0aGUgcmlnaHQgYXV0b2NvcnJlY3Rpb24gd2l0aCBwZXJpb2RpYyBoaWRkZW4gdGltZXNcbiAgICB0aGlzLmVuZFRvRnJvbnQgPSAtZGVsdGEgPiAwID8gZmFsc2UgOiB0cnVlOyAvLyB1c2VkIHRvIGRvIHRoZSByaWdodCBhdXRvY29ycmVjdGlvbiB3aXRoIHBlcmlvZGljIGhpZGRlbiB0aW1lc1xuICAgIHZhciBzYWZlU3RhcnQgPSBEYXRlVXRpbC5zbmFwQXdheUZyb21IaWRkZW4odGhpcy5ib2R5LmhpZGRlbkRhdGVzLCBuZXdTdGFydCwgZGVsdGEsIHRydWUpO1xuICAgIHZhciBzYWZlRW5kID0gRGF0ZVV0aWwuc25hcEF3YXlGcm9tSGlkZGVuKHRoaXMuYm9keS5oaWRkZW5EYXRlcywgbmV3RW5kLCAtZGVsdGEsIHRydWUpO1xuICAgIGlmIChzYWZlU3RhcnQgIT0gbmV3U3RhcnQgfHwgc2FmZUVuZCAhPSBuZXdFbmQpIHtcbiAgICAgIG5ld1N0YXJ0ID0gc2FmZVN0YXJ0O1xuICAgICAgbmV3RW5kID0gc2FmZUVuZDtcbiAgICB9XG5cbiAgICB0aGlzLnNldFJhbmdlKG5ld1N0YXJ0LCBuZXdFbmQsIGZhbHNlLCB0cnVlKTtcblxuICAgIHRoaXMuc3RhcnRUb0Zyb250ID0gZmFsc2U7IC8vIHJldmVydCB0byBkZWZhdWx0XG4gICAgdGhpcy5lbmRUb0Zyb250ID0gdHJ1ZTsgLy8gcmV2ZXJ0IHRvIGRlZmF1bHRcbiAgfTtcblxuICAvKipcbiAgICogTW92ZSB0aGUgcmFuZ2Ugd2l0aCBhIGdpdmVuIGRlbHRhIHRvIHRoZSBsZWZ0IG9yIHJpZ2h0LiBTdGFydCBhbmQgZW5kXG4gICAqIHZhbHVlIHdpbGwgYmUgYWRqdXN0ZWQuIEZvciBleGFtcGxlLCB0cnkgZGVsdGEgPSAwLjEgb3IgLTAuMVxuICAgKiBAcGFyYW0ge051bWJlcn0gIGRlbHRhICAgICBNb3ZpbmcgYW1vdW50LiBQb3NpdGl2ZSB2YWx1ZSB3aWxsIG1vdmUgcmlnaHQsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5lZ2F0aXZlIHZhbHVlIHdpbGwgbW92ZSBsZWZ0XG4gICAqL1xuICBSYW5nZS5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgIC8vIHpvb20gc3RhcnQgRGF0ZSBhbmQgZW5kIERhdGUgcmVsYXRpdmUgdG8gdGhlIGNlbnRlckRhdGVcbiAgICB2YXIgZGlmZiA9IHRoaXMuZW5kIC0gdGhpcy5zdGFydDtcblxuICAgIC8vIGFwcGx5IG5ldyB2YWx1ZXNcbiAgICB2YXIgbmV3U3RhcnQgPSB0aGlzLnN0YXJ0ICsgZGlmZiAqIGRlbHRhO1xuICAgIHZhciBuZXdFbmQgPSB0aGlzLmVuZCArIGRpZmYgKiBkZWx0YTtcblxuICAgIC8vIFRPRE86IHJlY2tvbiB3aXRoIG1pbiBhbmQgbWF4IHJhbmdlXG5cbiAgICB0aGlzLnN0YXJ0ID0gbmV3U3RhcnQ7XG4gICAgdGhpcy5lbmQgPSBuZXdFbmQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1vdmUgdGhlIHJhbmdlIHRvIGEgbmV3IGNlbnRlciBwb2ludFxuICAgKiBAcGFyYW0ge051bWJlcn0gbW92ZVRvICAgICAgTmV3IGNlbnRlciBwb2ludCBvZiB0aGUgcmFuZ2VcbiAgICovXG4gIFJhbmdlLnByb3RvdHlwZS5tb3ZlVG8gPSBmdW5jdGlvbiAobW92ZVRvKSB7XG4gICAgdmFyIGNlbnRlciA9ICh0aGlzLnN0YXJ0ICsgdGhpcy5lbmQpIC8gMjtcblxuICAgIHZhciBkaWZmID0gY2VudGVyIC0gbW92ZVRvO1xuXG4gICAgLy8gY2FsY3VsYXRlIG5ldyBzdGFydCBhbmQgZW5kXG4gICAgdmFyIG5ld1N0YXJ0ID0gdGhpcy5zdGFydCAtIGRpZmY7XG4gICAgdmFyIG5ld0VuZCA9IHRoaXMuZW5kIC0gZGlmZjtcblxuICAgIHRoaXMuc2V0UmFuZ2UobmV3U3RhcnQsIG5ld0VuZCk7XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBSYW5nZTtcblxuLyoqKi8gfSxcbi8qIDMxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuICBcInVzZSBzdHJpY3RcIjtcblxuICAvKipcbiAgICogUHJvdG90eXBlIGZvciB2aXN1YWwgY29tcG9uZW50c1xuICAgKiBAcGFyYW0ge3tkb206IE9iamVjdCwgZG9tUHJvcHM6IE9iamVjdCwgZW1pdHRlcjogRW1pdHRlciwgcmFuZ2U6IFJhbmdlfX0gW2JvZHldXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICovXG4gIGZ1bmN0aW9uIENvbXBvbmVudChib2R5LCBvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gbnVsbDtcbiAgICB0aGlzLnByb3BzID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgb3B0aW9ucyBmb3IgdGhlIGNvbXBvbmVudC4gVGhlIG5ldyBvcHRpb25zIHdpbGwgYmUgbWVyZ2VkIGludG8gdGhlXG4gICAqIGN1cnJlbnQgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIENvbXBvbmVudC5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIHV0aWwuZXh0ZW5kKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXBhaW50IHRoZSBjb21wb25lbnRcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBjb21wb25lbnQgaXMgcmVzaXplZFxuICAgKi9cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gc2hvdWxkIGJlIGltcGxlbWVudGVkIGJ5IHRoZSBjb21wb25lbnRcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlc3Ryb3kgdGhlIGNvbXBvbmVudC4gQ2xlYW51cCBET00gYW5kIGV2ZW50IGxpc3RlbmVyc1xuICAgKi9cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBieSB0aGUgY29tcG9uZW50XG4gIH07XG5cbiAgLyoqXG4gICAqIFRlc3Qgd2hldGhlciB0aGUgY29tcG9uZW50IGlzIHJlc2l6ZWQgc2luY2UgdGhlIGxhc3QgdGltZSBfaXNSZXNpemVkKCkgd2FzXG4gICAqIGNhbGxlZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBjb21wb25lbnQgaXMgcmVzaXplZFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBDb21wb25lbnQucHJvdG90eXBlLl9pc1Jlc2l6ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc2l6ZWQgPSB0aGlzLnByb3BzLl9wcmV2aW91c1dpZHRoICE9PSB0aGlzLnByb3BzLndpZHRoIHx8IHRoaXMucHJvcHMuX3ByZXZpb3VzSGVpZ2h0ICE9PSB0aGlzLnByb3BzLmhlaWdodDtcblxuICAgIHRoaXMucHJvcHMuX3ByZXZpb3VzV2lkdGggPSB0aGlzLnByb3BzLndpZHRoO1xuICAgIHRoaXMucHJvcHMuX3ByZXZpb3VzSGVpZ2h0ID0gdGhpcy5wcm9wcy5oZWlnaHQ7XG5cbiAgICByZXR1cm4gcmVzaXplZDtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudDtcblxuLyoqKi8gfSxcbi8qIDMyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuICBcInVzZSBzdHJpY3RcIjtcblxuICAvKipcbiAgICogdXNlZCBpbiBDb3JlIHRvIGNvbnZlcnQgdGhlIG9wdGlvbnMgaW50byBhIHZvbGF0aWxlIHZhcmlhYmxlXG4gICAqIFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBtb21lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtBcnJheSB8IE9iamVjdH0gaGlkZGVuRGF0ZXNcbiAgICovXG4gIGV4cG9ydHMuY29udmVydEhpZGRlbk9wdGlvbnMgPSBmdW5jdGlvbiAobW9tZW50LCBib2R5LCBoaWRkZW5EYXRlcykge1xuICAgIGlmIChoaWRkZW5EYXRlcyAmJiAhQXJyYXkuaXNBcnJheShoaWRkZW5EYXRlcykpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmNvbnZlcnRIaWRkZW5PcHRpb25zKG1vbWVudCwgYm9keSwgW2hpZGRlbkRhdGVzXSk7XG4gICAgfVxuXG4gICAgYm9keS5oaWRkZW5EYXRlcyA9IFtdO1xuICAgIGlmIChoaWRkZW5EYXRlcykge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaGlkZGVuRGF0ZXMpID09IHRydWUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoaWRkZW5EYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChoaWRkZW5EYXRlc1tpXS5yZXBlYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGRhdGVJdGVtID0ge307XG4gICAgICAgICAgICBkYXRlSXRlbS5zdGFydCA9IG1vbWVudChoaWRkZW5EYXRlc1tpXS5zdGFydCkudG9EYXRlKCkudmFsdWVPZigpO1xuICAgICAgICAgICAgZGF0ZUl0ZW0uZW5kID0gbW9tZW50KGhpZGRlbkRhdGVzW2ldLmVuZCkudG9EYXRlKCkudmFsdWVPZigpO1xuICAgICAgICAgICAgYm9keS5oaWRkZW5EYXRlcy5wdXNoKGRhdGVJdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYm9keS5oaWRkZW5EYXRlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIGEuc3RhcnQgLSBiLnN0YXJ0O1xuICAgICAgICB9KTsgLy8gc29ydCBieSBzdGFydCB0aW1lXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBjcmVhdGUgbmV3IGVudHJlZXMgZm9yIHRoZSByZXBlYXRpbmcgaGlkZGVuIGRhdGVzXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1vbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0FycmF5IHwgT2JqZWN0fSBoaWRkZW5EYXRlc1xuICAgKi9cbiAgZXhwb3J0cy51cGRhdGVIaWRkZW5EYXRlcyA9IGZ1bmN0aW9uIChtb21lbnQsIGJvZHksIGhpZGRlbkRhdGVzKSB7XG4gICAgaWYgKGhpZGRlbkRhdGVzICYmICFBcnJheS5pc0FycmF5KGhpZGRlbkRhdGVzKSkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMudXBkYXRlSGlkZGVuRGF0ZXMobW9tZW50LCBib2R5LCBbaGlkZGVuRGF0ZXNdKTtcbiAgICB9XG5cbiAgICBpZiAoaGlkZGVuRGF0ZXMgJiYgYm9keS5kb21Qcm9wcy5jZW50ZXJDb250YWluZXIud2lkdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgZXhwb3J0cy5jb252ZXJ0SGlkZGVuT3B0aW9ucyhtb21lbnQsIGJvZHksIGhpZGRlbkRhdGVzKTtcblxuICAgICAgdmFyIHN0YXJ0ID0gbW9tZW50KGJvZHkucmFuZ2Uuc3RhcnQpO1xuICAgICAgdmFyIGVuZCA9IG1vbWVudChib2R5LnJhbmdlLmVuZCk7XG5cbiAgICAgIHZhciB0b3RhbFJhbmdlID0gYm9keS5yYW5nZS5lbmQgLSBib2R5LnJhbmdlLnN0YXJ0O1xuICAgICAgdmFyIHBpeGVsVGltZSA9IHRvdGFsUmFuZ2UgLyBib2R5LmRvbVByb3BzLmNlbnRlckNvbnRhaW5lci53aWR0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoaWRkZW5EYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaGlkZGVuRGF0ZXNbaV0ucmVwZWF0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgc3RhcnREYXRlID0gbW9tZW50KGhpZGRlbkRhdGVzW2ldLnN0YXJ0KTtcbiAgICAgICAgICB2YXIgZW5kRGF0ZSA9IG1vbWVudChoaWRkZW5EYXRlc1tpXS5lbmQpO1xuXG4gICAgICAgICAgaWYgKHN0YXJ0RGF0ZS5fZCA9PSBcIkludmFsaWQgRGF0ZVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdXBwbGllZCBzdGFydCBkYXRlIGlzIG5vdCB2YWxpZDogXCIgKyBoaWRkZW5EYXRlc1tpXS5zdGFydCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbmREYXRlLl9kID09IFwiSW52YWxpZCBEYXRlXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN1cHBsaWVkIGVuZCBkYXRlIGlzIG5vdCB2YWxpZDogXCIgKyBoaWRkZW5EYXRlc1tpXS5lbmQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBkdXJhdGlvbiA9IGVuZERhdGUgLSBzdGFydERhdGU7XG4gICAgICAgICAgaWYgKGR1cmF0aW9uID49IDQgKiBwaXhlbFRpbWUpIHtcblxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgICAgICB2YXIgcnVuVW50aWwgPSBlbmQuY2xvbmUoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoaGlkZGVuRGF0ZXNbaV0ucmVwZWF0KSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJkYWlseVwiOlxuICAgICAgICAgICAgICAgIC8vIGNhc2Ugb2YgdGltZVxuICAgICAgICAgICAgICAgIGlmIChzdGFydERhdGUuZGF5KCkgIT0gZW5kRGF0ZS5kYXkoKSkge1xuICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhcnREYXRlLmRheU9mWWVhcihzdGFydC5kYXlPZlllYXIoKSk7XG4gICAgICAgICAgICAgICAgc3RhcnREYXRlLnllYXIoc3RhcnQueWVhcigpKTtcbiAgICAgICAgICAgICAgICBzdGFydERhdGUuc3VidHJhY3QoNywgJ2RheXMnKTtcblxuICAgICAgICAgICAgICAgIGVuZERhdGUuZGF5T2ZZZWFyKHN0YXJ0LmRheU9mWWVhcigpKTtcbiAgICAgICAgICAgICAgICBlbmREYXRlLnllYXIoc3RhcnQueWVhcigpKTtcbiAgICAgICAgICAgICAgICBlbmREYXRlLnN1YnRyYWN0KDcgLSBvZmZzZXQsICdkYXlzJyk7XG5cbiAgICAgICAgICAgICAgICBydW5VbnRpbC5hZGQoMSwgJ3dlZWtzJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJ3ZWVrbHlcIjpcbiAgICAgICAgICAgICAgICB2YXIgZGF5T2Zmc2V0ID0gZW5kRGF0ZS5kaWZmKHN0YXJ0RGF0ZSwgJ2RheXMnKTtcbiAgICAgICAgICAgICAgICB2YXIgZGF5ID0gc3RhcnREYXRlLmRheSgpO1xuXG4gICAgICAgICAgICAgICAgLy8gc2V0IHRoZSBzdGFydCBkYXRlIHRvIHRoZSByYW5nZS5zdGFydFxuICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS5kYXRlKHN0YXJ0LmRhdGUoKSk7XG4gICAgICAgICAgICAgICAgc3RhcnREYXRlLm1vbnRoKHN0YXJ0Lm1vbnRoKCkpO1xuICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS55ZWFyKHN0YXJ0LnllYXIoKSk7XG4gICAgICAgICAgICAgICAgZW5kRGF0ZSA9IHN0YXJ0RGF0ZS5jbG9uZSgpO1xuXG4gICAgICAgICAgICAgICAgLy8gZm9yY2VcbiAgICAgICAgICAgICAgICBzdGFydERhdGUuZGF5KGRheSk7XG4gICAgICAgICAgICAgICAgZW5kRGF0ZS5kYXkoZGF5KTtcbiAgICAgICAgICAgICAgICBlbmREYXRlLmFkZChkYXlPZmZzZXQsICdkYXlzJyk7XG5cbiAgICAgICAgICAgICAgICBzdGFydERhdGUuc3VidHJhY3QoMSwgJ3dlZWtzJyk7XG4gICAgICAgICAgICAgICAgZW5kRGF0ZS5zdWJ0cmFjdCgxLCAnd2Vla3MnKTtcblxuICAgICAgICAgICAgICAgIHJ1blVudGlsLmFkZCgxLCAnd2Vla3MnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcIm1vbnRobHlcIjpcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnREYXRlLm1vbnRoKCkgIT0gZW5kRGF0ZS5tb250aCgpKSB7XG4gICAgICAgICAgICAgICAgICBvZmZzZXQgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGFydERhdGUubW9udGgoc3RhcnQubW9udGgoKSk7XG4gICAgICAgICAgICAgICAgc3RhcnREYXRlLnllYXIoc3RhcnQueWVhcigpKTtcbiAgICAgICAgICAgICAgICBzdGFydERhdGUuc3VidHJhY3QoMSwgJ21vbnRocycpO1xuXG4gICAgICAgICAgICAgICAgZW5kRGF0ZS5tb250aChzdGFydC5tb250aCgpKTtcbiAgICAgICAgICAgICAgICBlbmREYXRlLnllYXIoc3RhcnQueWVhcigpKTtcbiAgICAgICAgICAgICAgICBlbmREYXRlLnN1YnRyYWN0KDEsICdtb250aHMnKTtcbiAgICAgICAgICAgICAgICBlbmREYXRlLmFkZChvZmZzZXQsICdtb250aHMnKTtcblxuICAgICAgICAgICAgICAgIHJ1blVudGlsLmFkZCgxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJ5ZWFybHlcIjpcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnREYXRlLnllYXIoKSAhPSBlbmREYXRlLnllYXIoKSkge1xuICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhcnREYXRlLnllYXIoc3RhcnQueWVhcigpKTtcbiAgICAgICAgICAgICAgICBzdGFydERhdGUuc3VidHJhY3QoMSwgJ3llYXJzJyk7XG4gICAgICAgICAgICAgICAgZW5kRGF0ZS55ZWFyKHN0YXJ0LnllYXIoKSk7XG4gICAgICAgICAgICAgICAgZW5kRGF0ZS5zdWJ0cmFjdCgxLCAneWVhcnMnKTtcbiAgICAgICAgICAgICAgICBlbmREYXRlLmFkZChvZmZzZXQsICd5ZWFycycpO1xuXG4gICAgICAgICAgICAgICAgcnVuVW50aWwuYWRkKDEsICd5ZWFycycpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiV3JvbmcgcmVwZWF0IGZvcm1hdCwgYWxsb3dlZCBhcmU6IGRhaWx5LCB3ZWVrbHksIG1vbnRobHksIHllYXJseS4gR2l2ZW46XCIsIGhpZGRlbkRhdGVzW2ldLnJlcGVhdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKHN0YXJ0RGF0ZSA8IHJ1blVudGlsKSB7XG4gICAgICAgICAgICAgIGJvZHkuaGlkZGVuRGF0ZXMucHVzaCh7IHN0YXJ0OiBzdGFydERhdGUudmFsdWVPZigpLCBlbmQ6IGVuZERhdGUudmFsdWVPZigpIH0pO1xuICAgICAgICAgICAgICBzd2l0Y2ggKGhpZGRlbkRhdGVzW2ldLnJlcGVhdCkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJkYWlseVwiOlxuICAgICAgICAgICAgICAgICAgc3RhcnREYXRlLmFkZCgxLCAnZGF5cycpO1xuICAgICAgICAgICAgICAgICAgZW5kRGF0ZS5hZGQoMSwgJ2RheXMnKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ3ZWVrbHlcIjpcbiAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS5hZGQoMSwgJ3dlZWtzJyk7XG4gICAgICAgICAgICAgICAgICBlbmREYXRlLmFkZCgxLCAnd2Vla3MnKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJtb250aGx5XCI6XG4gICAgICAgICAgICAgICAgICBzdGFydERhdGUuYWRkKDEsICdtb250aHMnKTtcbiAgICAgICAgICAgICAgICAgIGVuZERhdGUuYWRkKDEsICdtb250aHMnKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ5ZWFybHlcIjpcbiAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS5hZGQoMSwgJ3knKTtcbiAgICAgICAgICAgICAgICAgIGVuZERhdGUuYWRkKDEsICd5Jyk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJXcm9uZyByZXBlYXQgZm9ybWF0LCBhbGxvd2VkIGFyZTogZGFpbHksIHdlZWtseSwgbW9udGhseSwgeWVhcmx5LiBHaXZlbjpcIiwgaGlkZGVuRGF0ZXNbaV0ucmVwZWF0KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYm9keS5oaWRkZW5EYXRlcy5wdXNoKHsgc3RhcnQ6IHN0YXJ0RGF0ZS52YWx1ZU9mKCksIGVuZDogZW5kRGF0ZS52YWx1ZU9mKCkgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyByZW1vdmUgZHVwbGljYXRlcywgbWVyZ2Ugd2hlcmUgcG9zc2libGVcbiAgICAgIGV4cG9ydHMucmVtb3ZlRHVwbGljYXRlcyhib2R5KTtcbiAgICAgIC8vIGVuc3VyZSB0aGUgbmV3IHBvc2l0aW9ucyBhcmUgbm90IG9uIGhpZGRlbiBkYXRlc1xuICAgICAgdmFyIHN0YXJ0SGlkZGVuID0gZXhwb3J0cy5pc0hpZGRlbihib2R5LnJhbmdlLnN0YXJ0LCBib2R5LmhpZGRlbkRhdGVzKTtcbiAgICAgIHZhciBlbmRIaWRkZW4gPSBleHBvcnRzLmlzSGlkZGVuKGJvZHkucmFuZ2UuZW5kLCBib2R5LmhpZGRlbkRhdGVzKTtcbiAgICAgIHZhciByYW5nZVN0YXJ0ID0gYm9keS5yYW5nZS5zdGFydDtcbiAgICAgIHZhciByYW5nZUVuZCA9IGJvZHkucmFuZ2UuZW5kO1xuICAgICAgaWYgKHN0YXJ0SGlkZGVuLmhpZGRlbiA9PSB0cnVlKSB7XG4gICAgICAgIHJhbmdlU3RhcnQgPSBib2R5LnJhbmdlLnN0YXJ0VG9Gcm9udCA9PSB0cnVlID8gc3RhcnRIaWRkZW4uc3RhcnREYXRlIC0gMSA6IHN0YXJ0SGlkZGVuLmVuZERhdGUgKyAxO1xuICAgICAgfVxuICAgICAgaWYgKGVuZEhpZGRlbi5oaWRkZW4gPT0gdHJ1ZSkge1xuICAgICAgICByYW5nZUVuZCA9IGJvZHkucmFuZ2UuZW5kVG9Gcm9udCA9PSB0cnVlID8gZW5kSGlkZGVuLnN0YXJ0RGF0ZSAtIDEgOiBlbmRIaWRkZW4uZW5kRGF0ZSArIDE7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnRIaWRkZW4uaGlkZGVuID09IHRydWUgfHwgZW5kSGlkZGVuLmhpZGRlbiA9PSB0cnVlKSB7XG4gICAgICAgIGJvZHkucmFuZ2UuX2FwcGx5UmFuZ2UocmFuZ2VTdGFydCwgcmFuZ2VFbmQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogcmVtb3ZlIGR1cGxpY2F0ZXMgZnJvbSB0aGUgaGlkZGVuIGRhdGVzIGxpc3QuIER1cGxpY2F0ZXMgYXJlIGV2aWwuIFRoZXkgbWVzcyBldmVyeXRoaW5nIHVwLlxuICAgKiBTY2FsZXMgd2l0aCBOXjJcbiAgICogQHBhcmFtIGJvZHlcbiAgICovXG4gIGV4cG9ydHMucmVtb3ZlRHVwbGljYXRlcyA9IGZ1bmN0aW9uIChib2R5KSB7XG4gICAgdmFyIGhpZGRlbkRhdGVzID0gYm9keS5oaWRkZW5EYXRlcztcbiAgICB2YXIgc2FmZURhdGVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoaWRkZW5EYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBoaWRkZW5EYXRlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoaSAhPSBqICYmIGhpZGRlbkRhdGVzW2pdLnJlbW92ZSAhPSB0cnVlICYmIGhpZGRlbkRhdGVzW2ldLnJlbW92ZSAhPSB0cnVlKSB7XG4gICAgICAgICAgLy8gaiBpbnNpZGUgaVxuICAgICAgICAgIGlmIChoaWRkZW5EYXRlc1tqXS5zdGFydCA+PSBoaWRkZW5EYXRlc1tpXS5zdGFydCAmJiBoaWRkZW5EYXRlc1tqXS5lbmQgPD0gaGlkZGVuRGF0ZXNbaV0uZW5kKSB7XG4gICAgICAgICAgICBoaWRkZW5EYXRlc1tqXS5yZW1vdmUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBqIHN0YXJ0IGluc2lkZSBpXG4gICAgICAgICAgZWxzZSBpZiAoaGlkZGVuRGF0ZXNbal0uc3RhcnQgPj0gaGlkZGVuRGF0ZXNbaV0uc3RhcnQgJiYgaGlkZGVuRGF0ZXNbal0uc3RhcnQgPD0gaGlkZGVuRGF0ZXNbaV0uZW5kKSB7XG4gICAgICAgICAgICAgIGhpZGRlbkRhdGVzW2ldLmVuZCA9IGhpZGRlbkRhdGVzW2pdLmVuZDtcbiAgICAgICAgICAgICAgaGlkZGVuRGF0ZXNbal0ucmVtb3ZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGogZW5kIGluc2lkZSBpXG4gICAgICAgICAgICBlbHNlIGlmIChoaWRkZW5EYXRlc1tqXS5lbmQgPj0gaGlkZGVuRGF0ZXNbaV0uc3RhcnQgJiYgaGlkZGVuRGF0ZXNbal0uZW5kIDw9IGhpZGRlbkRhdGVzW2ldLmVuZCkge1xuICAgICAgICAgICAgICAgIGhpZGRlbkRhdGVzW2ldLnN0YXJ0ID0gaGlkZGVuRGF0ZXNbal0uc3RhcnQ7XG4gICAgICAgICAgICAgICAgaGlkZGVuRGF0ZXNbal0ucmVtb3ZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoaWRkZW5EYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGhpZGRlbkRhdGVzW2ldLnJlbW92ZSAhPT0gdHJ1ZSkge1xuICAgICAgICBzYWZlRGF0ZXMucHVzaChoaWRkZW5EYXRlc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYm9keS5oaWRkZW5EYXRlcyA9IHNhZmVEYXRlcztcbiAgICBib2R5LmhpZGRlbkRhdGVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLnN0YXJ0IC0gYi5zdGFydDtcbiAgICB9KTsgLy8gc29ydCBieSBzdGFydCB0aW1lXG4gIH07XG5cbiAgZXhwb3J0cy5wcmludERhdGVzID0gZnVuY3Rpb24gKGRhdGVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc29sZS5sb2coaSwgbmV3IERhdGUoZGF0ZXNbaV0uc3RhcnQpLCBuZXcgRGF0ZShkYXRlc1tpXS5lbmQpLCBkYXRlc1tpXS5zdGFydCwgZGF0ZXNbaV0uZW5kLCBkYXRlc1tpXS5yZW1vdmUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVXNlZCBpbiBUaW1lU3RlcCB0byBhdm9pZCB0aGUgaGlkZGVuIHRpbWVzLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBtb21lbnRcbiAgICogQHBhcmFtIHtUaW1lU3RlcH0gdGltZVN0ZXBcbiAgICogQHBhcmFtIHByZXZpb3VzVGltZVxuICAgKi9cbiAgZXhwb3J0cy5zdGVwT3ZlckhpZGRlbkRhdGVzID0gZnVuY3Rpb24gKG1vbWVudCwgdGltZVN0ZXAsIHByZXZpb3VzVGltZSkge1xuICAgIHZhciBzdGVwSW5IaWRkZW4gPSBmYWxzZTtcbiAgICB2YXIgY3VycmVudFZhbHVlID0gdGltZVN0ZXAuY3VycmVudC52YWx1ZU9mKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aW1lU3RlcC5oaWRkZW5EYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHN0YXJ0RGF0ZSA9IHRpbWVTdGVwLmhpZGRlbkRhdGVzW2ldLnN0YXJ0O1xuICAgICAgdmFyIGVuZERhdGUgPSB0aW1lU3RlcC5oaWRkZW5EYXRlc1tpXS5lbmQ7XG4gICAgICBpZiAoY3VycmVudFZhbHVlID49IHN0YXJ0RGF0ZSAmJiBjdXJyZW50VmFsdWUgPCBlbmREYXRlKSB7XG4gICAgICAgIHN0ZXBJbkhpZGRlbiA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdGVwSW5IaWRkZW4gPT0gdHJ1ZSAmJiBjdXJyZW50VmFsdWUgPCB0aW1lU3RlcC5fZW5kLnZhbHVlT2YoKSAmJiBjdXJyZW50VmFsdWUgIT0gcHJldmlvdXNUaW1lKSB7XG4gICAgICB2YXIgcHJldlZhbHVlID0gbW9tZW50KHByZXZpb3VzVGltZSk7XG4gICAgICB2YXIgbmV3VmFsdWUgPSBtb21lbnQoZW5kRGF0ZSk7XG4gICAgICAvL2NoZWNrIGlmIHRoZSBuZXh0IHN0ZXAgc2hvdWxkIGJlIG1ham9yXG4gICAgICBpZiAocHJldlZhbHVlLnllYXIoKSAhPSBuZXdWYWx1ZS55ZWFyKCkpIHtcbiAgICAgICAgdGltZVN0ZXAuc3dpdGNoZWRZZWFyID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAocHJldlZhbHVlLm1vbnRoKCkgIT0gbmV3VmFsdWUubW9udGgoKSkge1xuICAgICAgICB0aW1lU3RlcC5zd2l0Y2hlZE1vbnRoID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAocHJldlZhbHVlLmRheU9mWWVhcigpICE9IG5ld1ZhbHVlLmRheU9mWWVhcigpKSB7XG4gICAgICAgIHRpbWVTdGVwLnN3aXRjaGVkRGF5ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdGltZVN0ZXAuY3VycmVudCA9IG5ld1ZhbHVlO1xuICAgIH1cbiAgfTtcblxuICAvLy8qKlxuICAvLyAqIFVzZWQgaW4gVGltZVN0ZXAgdG8gYXZvaWQgdGhlIGhpZGRlbiB0aW1lcy5cbiAgLy8gKiBAcGFyYW0gdGltZVN0ZXBcbiAgLy8gKiBAcGFyYW0gcHJldmlvdXNUaW1lXG4gIC8vICovXG4gIC8vZXhwb3J0cy5jaGVja0ZpcnN0U3RlcCA9IGZ1bmN0aW9uKHRpbWVTdGVwKSB7XG4gIC8vICB2YXIgc3RlcEluSGlkZGVuID0gZmFsc2U7XG4gIC8vICB2YXIgY3VycmVudFZhbHVlID0gdGltZVN0ZXAuY3VycmVudC52YWx1ZU9mKCk7XG4gIC8vICBmb3IgKHZhciBpID0gMDsgaSA8IHRpbWVTdGVwLmhpZGRlbkRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gIC8vICAgIHZhciBzdGFydERhdGUgPSB0aW1lU3RlcC5oaWRkZW5EYXRlc1tpXS5zdGFydDtcbiAgLy8gICAgdmFyIGVuZERhdGUgPSB0aW1lU3RlcC5oaWRkZW5EYXRlc1tpXS5lbmQ7XG4gIC8vICAgIGlmIChjdXJyZW50VmFsdWUgPj0gc3RhcnREYXRlICYmIGN1cnJlbnRWYWx1ZSA8IGVuZERhdGUpIHtcbiAgLy8gICAgICBzdGVwSW5IaWRkZW4gPSB0cnVlO1xuICAvLyAgICAgIGJyZWFrO1xuICAvLyAgICB9XG4gIC8vICB9XG4gIC8vXG4gIC8vICBpZiAoc3RlcEluSGlkZGVuID09IHRydWUgJiYgY3VycmVudFZhbHVlIDw9IHRpbWVTdGVwLl9lbmQudmFsdWVPZigpKSB7XG4gIC8vICAgIHZhciBuZXdWYWx1ZSA9IG1vbWVudChlbmREYXRlKTtcbiAgLy8gICAgdGltZVN0ZXAuY3VycmVudCA9IG5ld1ZhbHVlLnRvRGF0ZSgpO1xuICAvLyAgfVxuICAvL307XG5cbiAgLyoqXG4gICAqIHJlcGxhY2VzIHRoZSBDb3JlIHRvU2NyZWVuIG1ldGhvZHNcbiAgICogQHBhcmFtIENvcmVcbiAgICogQHBhcmFtIHRpbWVcbiAgICogQHBhcmFtIHdpZHRoXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBleHBvcnRzLnRvU2NyZWVuID0gZnVuY3Rpb24gKENvcmUsIHRpbWUsIHdpZHRoKSB7XG4gICAgaWYgKENvcmUuYm9keS5oaWRkZW5EYXRlcy5sZW5ndGggPT0gMCkge1xuICAgICAgdmFyIGNvbnZlcnNpb24gPSBDb3JlLnJhbmdlLmNvbnZlcnNpb24od2lkdGgpO1xuICAgICAgcmV0dXJuICh0aW1lLnZhbHVlT2YoKSAtIGNvbnZlcnNpb24ub2Zmc2V0KSAqIGNvbnZlcnNpb24uc2NhbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBoaWRkZW4gPSBleHBvcnRzLmlzSGlkZGVuKHRpbWUsIENvcmUuYm9keS5oaWRkZW5EYXRlcyk7XG4gICAgICBpZiAoaGlkZGVuLmhpZGRlbiA9PSB0cnVlKSB7XG4gICAgICAgIHRpbWUgPSBoaWRkZW4uc3RhcnREYXRlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZHVyYXRpb24gPSBleHBvcnRzLmdldEhpZGRlbkR1cmF0aW9uQmV0d2VlbihDb3JlLmJvZHkuaGlkZGVuRGF0ZXMsIENvcmUucmFuZ2Uuc3RhcnQsIENvcmUucmFuZ2UuZW5kKTtcbiAgICAgIHRpbWUgPSBleHBvcnRzLmNvcnJlY3RUaW1lRm9ySGlkZGVuKENvcmUub3B0aW9ucy5tb21lbnQsIENvcmUuYm9keS5oaWRkZW5EYXRlcywgQ29yZS5yYW5nZSwgdGltZSk7XG5cbiAgICAgIHZhciBjb252ZXJzaW9uID0gQ29yZS5yYW5nZS5jb252ZXJzaW9uKHdpZHRoLCBkdXJhdGlvbik7XG4gICAgICByZXR1cm4gKHRpbWUudmFsdWVPZigpIC0gY29udmVyc2lvbi5vZmZzZXQpICogY29udmVyc2lvbi5zY2FsZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIHRoZSBjb3JlIHRvVGltZSBtZXRob2RzXG4gICAqIEBwYXJhbSBib2R5XG4gICAqIEBwYXJhbSByYW5nZVxuICAgKiBAcGFyYW0geFxuICAgKiBAcGFyYW0gd2lkdGhcbiAgICogQHJldHVybnMge0RhdGV9XG4gICAqL1xuICBleHBvcnRzLnRvVGltZSA9IGZ1bmN0aW9uIChDb3JlLCB4LCB3aWR0aCkge1xuICAgIGlmIChDb3JlLmJvZHkuaGlkZGVuRGF0ZXMubGVuZ3RoID09IDApIHtcbiAgICAgIHZhciBjb252ZXJzaW9uID0gQ29yZS5yYW5nZS5jb252ZXJzaW9uKHdpZHRoKTtcbiAgICAgIHJldHVybiBuZXcgRGF0ZSh4IC8gY29udmVyc2lvbi5zY2FsZSArIGNvbnZlcnNpb24ub2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGhpZGRlbkR1cmF0aW9uID0gZXhwb3J0cy5nZXRIaWRkZW5EdXJhdGlvbkJldHdlZW4oQ29yZS5ib2R5LmhpZGRlbkRhdGVzLCBDb3JlLnJhbmdlLnN0YXJ0LCBDb3JlLnJhbmdlLmVuZCk7XG4gICAgICB2YXIgdG90YWxEdXJhdGlvbiA9IENvcmUucmFuZ2UuZW5kIC0gQ29yZS5yYW5nZS5zdGFydCAtIGhpZGRlbkR1cmF0aW9uO1xuICAgICAgdmFyIHBhcnRpYWxEdXJhdGlvbiA9IHRvdGFsRHVyYXRpb24gKiB4IC8gd2lkdGg7XG4gICAgICB2YXIgYWNjdW11bGF0ZWRIaWRkZW5EdXJhdGlvbiA9IGV4cG9ydHMuZ2V0QWNjdW11bGF0ZWRIaWRkZW5EdXJhdGlvbihDb3JlLmJvZHkuaGlkZGVuRGF0ZXMsIENvcmUucmFuZ2UsIHBhcnRpYWxEdXJhdGlvbik7XG5cbiAgICAgIHZhciBuZXdUaW1lID0gbmV3IERhdGUoYWNjdW11bGF0ZWRIaWRkZW5EdXJhdGlvbiArIHBhcnRpYWxEdXJhdGlvbiArIENvcmUucmFuZ2Uuc3RhcnQpO1xuICAgICAgcmV0dXJuIG5ld1RpbWU7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTdXBwb3J0IGZ1bmN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBoaWRkZW5EYXRlc1xuICAgKiBAcGFyYW0gcmFuZ2VcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGV4cG9ydHMuZ2V0SGlkZGVuRHVyYXRpb25CZXR3ZWVuID0gZnVuY3Rpb24gKGhpZGRlbkRhdGVzLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIGR1cmF0aW9uID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhpZGRlbkRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc3RhcnREYXRlID0gaGlkZGVuRGF0ZXNbaV0uc3RhcnQ7XG4gICAgICB2YXIgZW5kRGF0ZSA9IGhpZGRlbkRhdGVzW2ldLmVuZDtcbiAgICAgIC8vIGlmIHRpbWUgYWZ0ZXIgdGhlIGN1dG91dCwgYW5kIHRoZVxuICAgICAgaWYgKHN0YXJ0RGF0ZSA+PSBzdGFydCAmJiBlbmREYXRlIDwgZW5kKSB7XG4gICAgICAgIGR1cmF0aW9uICs9IGVuZERhdGUgLSBzdGFydERhdGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkdXJhdGlvbjtcbiAgfTtcblxuICAvKipcbiAgICogU3VwcG9ydCBmdW5jdGlvblxuICAgKiBAcGFyYW0gbW9tZW50XG4gICAqIEBwYXJhbSBoaWRkZW5EYXRlc1xuICAgKiBAcGFyYW0gcmFuZ2VcbiAgICogQHBhcmFtIHRpbWVcbiAgICogQHJldHVybnMge3tkdXJhdGlvbjogbnVtYmVyLCB0aW1lOiAqLCBvZmZzZXQ6IG51bWJlcn19XG4gICAqL1xuICBleHBvcnRzLmNvcnJlY3RUaW1lRm9ySGlkZGVuID0gZnVuY3Rpb24gKG1vbWVudCwgaGlkZGVuRGF0ZXMsIHJhbmdlLCB0aW1lKSB7XG4gICAgdGltZSA9IG1vbWVudCh0aW1lKS50b0RhdGUoKS52YWx1ZU9mKCk7XG4gICAgdGltZSAtPSBleHBvcnRzLmdldEhpZGRlbkR1cmF0aW9uQmVmb3JlKG1vbWVudCwgaGlkZGVuRGF0ZXMsIHJhbmdlLCB0aW1lKTtcbiAgICByZXR1cm4gdGltZTtcbiAgfTtcblxuICBleHBvcnRzLmdldEhpZGRlbkR1cmF0aW9uQmVmb3JlID0gZnVuY3Rpb24gKG1vbWVudCwgaGlkZGVuRGF0ZXMsIHJhbmdlLCB0aW1lKSB7XG4gICAgdmFyIHRpbWVPZmZzZXQgPSAwO1xuICAgIHRpbWUgPSBtb21lbnQodGltZSkudG9EYXRlKCkudmFsdWVPZigpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoaWRkZW5EYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHN0YXJ0RGF0ZSA9IGhpZGRlbkRhdGVzW2ldLnN0YXJ0O1xuICAgICAgdmFyIGVuZERhdGUgPSBoaWRkZW5EYXRlc1tpXS5lbmQ7XG4gICAgICAvLyBpZiB0aW1lIGFmdGVyIHRoZSBjdXRvdXQsIGFuZCB0aGVcbiAgICAgIGlmIChzdGFydERhdGUgPj0gcmFuZ2Uuc3RhcnQgJiYgZW5kRGF0ZSA8IHJhbmdlLmVuZCkge1xuICAgICAgICBpZiAodGltZSA+PSBlbmREYXRlKSB7XG4gICAgICAgICAgdGltZU9mZnNldCArPSBlbmREYXRlIC0gc3RhcnREYXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aW1lT2Zmc2V0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBzdW0gdGhlIGR1cmF0aW9uIGZyb20gc3RhcnQgdG8gZmluaXNoLCBpbmNsdWRpbmcgdGhlIGhpZGRlbiBkdXJhdGlvbixcbiAgICogdW50aWwgdGhlIHJlcXVpcmVkIGFtb3VudCBoYXMgYmVlbiByZWFjaGVkLCByZXR1cm4gdGhlIGFjY3VtdWxhdGVkIGhpZGRlbiBkdXJhdGlvblxuICAgKiBAcGFyYW0gaGlkZGVuRGF0ZXNcbiAgICogQHBhcmFtIHJhbmdlXG4gICAqIEBwYXJhbSB0aW1lXG4gICAqIEByZXR1cm5zIHt7ZHVyYXRpb246IG51bWJlciwgdGltZTogKiwgb2Zmc2V0OiBudW1iZXJ9fVxuICAgKi9cbiAgZXhwb3J0cy5nZXRBY2N1bXVsYXRlZEhpZGRlbkR1cmF0aW9uID0gZnVuY3Rpb24gKGhpZGRlbkRhdGVzLCByYW5nZSwgcmVxdWlyZWREdXJhdGlvbikge1xuICAgIHZhciBoaWRkZW5EdXJhdGlvbiA9IDA7XG4gICAgdmFyIGR1cmF0aW9uID0gMDtcbiAgICB2YXIgcHJldmlvdXNQb2ludCA9IHJhbmdlLnN0YXJ0O1xuICAgIC8vZXhwb3J0cy5wcmludERhdGVzKGhpZGRlbkRhdGVzKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGlkZGVuRGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzdGFydERhdGUgPSBoaWRkZW5EYXRlc1tpXS5zdGFydDtcbiAgICAgIHZhciBlbmREYXRlID0gaGlkZGVuRGF0ZXNbaV0uZW5kO1xuICAgICAgLy8gaWYgdGltZSBhZnRlciB0aGUgY3V0b3V0LCBhbmQgdGhlXG4gICAgICBpZiAoc3RhcnREYXRlID49IHJhbmdlLnN0YXJ0ICYmIGVuZERhdGUgPCByYW5nZS5lbmQpIHtcbiAgICAgICAgZHVyYXRpb24gKz0gc3RhcnREYXRlIC0gcHJldmlvdXNQb2ludDtcbiAgICAgICAgcHJldmlvdXNQb2ludCA9IGVuZERhdGU7XG4gICAgICAgIGlmIChkdXJhdGlvbiA+PSByZXF1aXJlZER1cmF0aW9uKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGlkZGVuRHVyYXRpb24gKz0gZW5kRGF0ZSAtIHN0YXJ0RGF0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBoaWRkZW5EdXJhdGlvbjtcbiAgfTtcblxuICAvKipcbiAgICogdXNlZCB0byBzdGVwIG92ZXIgdG8gZWl0aGVyIHNpZGUgb2YgYSBoaWRkZW4gYmxvY2suIENvcnJlY3Rpb24gaXMgZGlzYWJsZWQgb24gdGFibGV0cywgbWlnaHQgYmUgc2V0IHRvIHRydWVcbiAgICogQHBhcmFtIGhpZGRlbkRhdGVzXG4gICAqIEBwYXJhbSB0aW1lXG4gICAqIEBwYXJhbSBkaXJlY3Rpb25cbiAgICogQHBhcmFtIGNvcnJlY3Rpb25FbmFibGVkXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgZXhwb3J0cy5zbmFwQXdheUZyb21IaWRkZW4gPSBmdW5jdGlvbiAoaGlkZGVuRGF0ZXMsIHRpbWUsIGRpcmVjdGlvbiwgY29ycmVjdGlvbkVuYWJsZWQpIHtcbiAgICB2YXIgaXNIaWRkZW4gPSBleHBvcnRzLmlzSGlkZGVuKHRpbWUsIGhpZGRlbkRhdGVzKTtcbiAgICBpZiAoaXNIaWRkZW4uaGlkZGVuID09IHRydWUpIHtcbiAgICAgIGlmIChkaXJlY3Rpb24gPCAwKSB7XG4gICAgICAgIGlmIChjb3JyZWN0aW9uRW5hYmxlZCA9PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuIGlzSGlkZGVuLnN0YXJ0RGF0ZSAtIChpc0hpZGRlbi5lbmREYXRlIC0gdGltZSkgLSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBpc0hpZGRlbi5zdGFydERhdGUgLSAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY29ycmVjdGlvbkVuYWJsZWQgPT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybiBpc0hpZGRlbi5lbmREYXRlICsgKHRpbWUgLSBpc0hpZGRlbi5zdGFydERhdGUpICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gaXNIaWRkZW4uZW5kRGF0ZSArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRpbWU7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRpbWUgaXMgaGlkZGVuXG4gICAqXG4gICAqIEBwYXJhbSB0aW1lXG4gICAqIEBwYXJhbSBoaWRkZW5EYXRlc1xuICAgKiBAcmV0dXJucyB7e2hpZGRlbjogYm9vbGVhbiwgc3RhcnREYXRlOiBXaW5kb3cuc3RhcnQsIGVuZERhdGU6ICp9fVxuICAgKi9cbiAgZXhwb3J0cy5pc0hpZGRlbiA9IGZ1bmN0aW9uICh0aW1lLCBoaWRkZW5EYXRlcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGlkZGVuRGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzdGFydERhdGUgPSBoaWRkZW5EYXRlc1tpXS5zdGFydDtcbiAgICAgIHZhciBlbmREYXRlID0gaGlkZGVuRGF0ZXNbaV0uZW5kO1xuXG4gICAgICBpZiAodGltZSA+PSBzdGFydERhdGUgJiYgdGltZSA8IGVuZERhdGUpIHtcbiAgICAgICAgLy8gaWYgdGhlIHN0YXJ0IGlzIGVudGVyaW5nIGEgaGlkZGVuIHpvbmVcbiAgICAgICAgcmV0dXJuIHsgaGlkZGVuOiB0cnVlLCBzdGFydERhdGU6IHN0YXJ0RGF0ZSwgZW5kRGF0ZTogZW5kRGF0ZSB9O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgaGlkZGVuOiBmYWxzZSwgc3RhcnREYXRlOiBzdGFydERhdGUsIGVuZERhdGU6IGVuZERhdGUgfTtcbiAgfTtcblxuLyoqKi8gfSxcbi8qIDMzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbiAgdmFyIEVtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcbiAgdmFyIEhhbW1lciA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuICB2YXIgaGFtbWVyVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4gIHZhciBEYXRhU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcbiAgdmFyIERhdGFWaWV3ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG4gIHZhciBSYW5nZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzApO1xuICB2YXIgSXRlbVNldCA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xuICB2YXIgVGltZUF4aXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KTtcbiAgdmFyIEFjdGl2YXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oNDUpO1xuICB2YXIgRGF0ZVV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcbiAgdmFyIEN1c3RvbVRpbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2KTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgdGltZWxpbmUgdmlzdWFsaXphdGlvblxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIENvcmUoKSB7fVxuXG4gIC8vIHR1cm4gQ29yZSBpbnRvIGFuIGV2ZW50IGVtaXR0ZXJcbiAgRW1pdHRlcihDb3JlLnByb3RvdHlwZSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgbWFpbiBET00gZm9yIHRoZSBDb3JlOiBhIHJvb3QgcGFuZWwgY29udGFpbmluZyBsZWZ0LCByaWdodCxcbiAgICogdG9wLCBib3R0b20sIGNvbnRlbnQsIGFuZCBiYWNrZ3JvdW5kIHBhbmVsLlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRhaW5lciAgVGhlIGNvbnRhaW5lciBlbGVtZW50IHdoZXJlIHRoZSBDb3JlIHdpbGxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlIGF0dGFjaGVkLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBDb3JlLnByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgIHRoaXMuZG9tID0ge307XG5cbiAgICB0aGlzLmRvbS5jb250YWluZXIgPSBjb250YWluZXI7XG5cbiAgICB0aGlzLmRvbS5yb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5kb20uYmFja2dyb3VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuZG9tLmJhY2tncm91bmRWZXJ0aWNhbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuZG9tLmJhY2tncm91bmRIb3Jpem9udGFsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5kb20uY2VudGVyQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5kb20ubGVmdENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuZG9tLnJpZ2h0Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5kb20uY2VudGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5kb20ubGVmdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuZG9tLnJpZ2h0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5kb20udG9wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5kb20uYm90dG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5kb20uc2hhZG93VG9wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5kb20uc2hhZG93Qm90dG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5kb20uc2hhZG93VG9wTGVmdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuZG9tLnNoYWRvd0JvdHRvbUxlZnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmRvbS5zaGFkb3dUb3BSaWdodCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuZG9tLnNoYWRvd0JvdHRvbVJpZ2h0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICB0aGlzLmRvbS5yb290LmNsYXNzTmFtZSA9ICd2aXMtdGltZWxpbmUnO1xuICAgIHRoaXMuZG9tLmJhY2tncm91bmQuY2xhc3NOYW1lID0gJ3Zpcy1wYW5lbCB2aXMtYmFja2dyb3VuZCc7XG4gICAgdGhpcy5kb20uYmFja2dyb3VuZFZlcnRpY2FsLmNsYXNzTmFtZSA9ICd2aXMtcGFuZWwgdmlzLWJhY2tncm91bmQgdmlzLXZlcnRpY2FsJztcbiAgICB0aGlzLmRvbS5iYWNrZ3JvdW5kSG9yaXpvbnRhbC5jbGFzc05hbWUgPSAndmlzLXBhbmVsIHZpcy1iYWNrZ3JvdW5kIHZpcy1ob3Jpem9udGFsJztcbiAgICB0aGlzLmRvbS5jZW50ZXJDb250YWluZXIuY2xhc3NOYW1lID0gJ3Zpcy1wYW5lbCB2aXMtY2VudGVyJztcbiAgICB0aGlzLmRvbS5sZWZ0Q29udGFpbmVyLmNsYXNzTmFtZSA9ICd2aXMtcGFuZWwgdmlzLWxlZnQnO1xuICAgIHRoaXMuZG9tLnJpZ2h0Q29udGFpbmVyLmNsYXNzTmFtZSA9ICd2aXMtcGFuZWwgdmlzLXJpZ2h0JztcbiAgICB0aGlzLmRvbS50b3AuY2xhc3NOYW1lID0gJ3Zpcy1wYW5lbCB2aXMtdG9wJztcbiAgICB0aGlzLmRvbS5ib3R0b20uY2xhc3NOYW1lID0gJ3Zpcy1wYW5lbCB2aXMtYm90dG9tJztcbiAgICB0aGlzLmRvbS5sZWZ0LmNsYXNzTmFtZSA9ICd2aXMtY29udGVudCc7XG4gICAgdGhpcy5kb20uY2VudGVyLmNsYXNzTmFtZSA9ICd2aXMtY29udGVudCc7XG4gICAgdGhpcy5kb20ucmlnaHQuY2xhc3NOYW1lID0gJ3Zpcy1jb250ZW50JztcbiAgICB0aGlzLmRvbS5zaGFkb3dUb3AuY2xhc3NOYW1lID0gJ3Zpcy1zaGFkb3cgdmlzLXRvcCc7XG4gICAgdGhpcy5kb20uc2hhZG93Qm90dG9tLmNsYXNzTmFtZSA9ICd2aXMtc2hhZG93IHZpcy1ib3R0b20nO1xuICAgIHRoaXMuZG9tLnNoYWRvd1RvcExlZnQuY2xhc3NOYW1lID0gJ3Zpcy1zaGFkb3cgdmlzLXRvcCc7XG4gICAgdGhpcy5kb20uc2hhZG93Qm90dG9tTGVmdC5jbGFzc05hbWUgPSAndmlzLXNoYWRvdyB2aXMtYm90dG9tJztcbiAgICB0aGlzLmRvbS5zaGFkb3dUb3BSaWdodC5jbGFzc05hbWUgPSAndmlzLXNoYWRvdyB2aXMtdG9wJztcbiAgICB0aGlzLmRvbS5zaGFkb3dCb3R0b21SaWdodC5jbGFzc05hbWUgPSAndmlzLXNoYWRvdyB2aXMtYm90dG9tJztcblxuICAgIHRoaXMuZG9tLnJvb3QuYXBwZW5kQ2hpbGQodGhpcy5kb20uYmFja2dyb3VuZCk7XG4gICAgdGhpcy5kb20ucm9vdC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5iYWNrZ3JvdW5kVmVydGljYWwpO1xuICAgIHRoaXMuZG9tLnJvb3QuYXBwZW5kQ2hpbGQodGhpcy5kb20uYmFja2dyb3VuZEhvcml6b250YWwpO1xuICAgIHRoaXMuZG9tLnJvb3QuYXBwZW5kQ2hpbGQodGhpcy5kb20uY2VudGVyQ29udGFpbmVyKTtcbiAgICB0aGlzLmRvbS5yb290LmFwcGVuZENoaWxkKHRoaXMuZG9tLmxlZnRDb250YWluZXIpO1xuICAgIHRoaXMuZG9tLnJvb3QuYXBwZW5kQ2hpbGQodGhpcy5kb20ucmlnaHRDb250YWluZXIpO1xuICAgIHRoaXMuZG9tLnJvb3QuYXBwZW5kQ2hpbGQodGhpcy5kb20udG9wKTtcbiAgICB0aGlzLmRvbS5yb290LmFwcGVuZENoaWxkKHRoaXMuZG9tLmJvdHRvbSk7XG5cbiAgICB0aGlzLmRvbS5jZW50ZXJDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb20uY2VudGVyKTtcbiAgICB0aGlzLmRvbS5sZWZ0Q29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZG9tLmxlZnQpO1xuICAgIHRoaXMuZG9tLnJpZ2h0Q29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZG9tLnJpZ2h0KTtcblxuICAgIHRoaXMuZG9tLmNlbnRlckNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRvbS5zaGFkb3dUb3ApO1xuICAgIHRoaXMuZG9tLmNlbnRlckNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRvbS5zaGFkb3dCb3R0b20pO1xuICAgIHRoaXMuZG9tLmxlZnRDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb20uc2hhZG93VG9wTGVmdCk7XG4gICAgdGhpcy5kb20ubGVmdENvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRvbS5zaGFkb3dCb3R0b21MZWZ0KTtcbiAgICB0aGlzLmRvbS5yaWdodENvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRvbS5zaGFkb3dUb3BSaWdodCk7XG4gICAgdGhpcy5kb20ucmlnaHRDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb20uc2hhZG93Qm90dG9tUmlnaHQpO1xuXG4gICAgdGhpcy5vbigncmFuZ2VjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5pbml0aWFsRHJhd0RvbmUgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5fcmVkcmF3KCk7IC8vIHRoaXMgYWxsb3dzIG92ZXJyaWRpbmcgdGhlIF9yZWRyYXcgbWV0aG9kXG4gICAgICB9XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLm9uKCd0b3VjaCcsIHRoaXMuX29uVG91Y2guYmluZCh0aGlzKSk7XG4gICAgdGhpcy5vbigncGFuJywgdGhpcy5fb25EcmFnLmJpbmQodGhpcykpO1xuXG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB0aGlzLm9uKCdfY2hhbmdlJywgZnVuY3Rpb24gKHByb3BlcnRpZXMpIHtcbiAgICAgIGlmIChwcm9wZXJ0aWVzICYmIHByb3BlcnRpZXMucXVldWUgPT0gdHJ1ZSkge1xuICAgICAgICAvLyByZWRyYXcgb25jZSBvbiBuZXh0IHRpY2tcbiAgICAgICAgaWYgKCFtZS5fcmVkcmF3VGltZXIpIHtcbiAgICAgICAgICBtZS5fcmVkcmF3VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG1lLl9yZWRyYXdUaW1lciA9IG51bGw7XG4gICAgICAgICAgICBtZS5fcmVkcmF3KCk7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlZHJhdyBpbW1lZGlhdGVseVxuICAgICAgICBtZS5fcmVkcmF3KCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBjcmVhdGUgZXZlbnQgbGlzdGVuZXJzIGZvciBhbGwgaW50ZXJlc3RpbmcgZXZlbnRzLCB0aGVzZSBldmVudHMgd2lsbCBiZVxuICAgIC8vIGVtaXR0ZWQgdmlhIGVtaXR0ZXJcbiAgICB0aGlzLmhhbW1lciA9IG5ldyBIYW1tZXIodGhpcy5kb20ucm9vdCk7XG4gICAgdmFyIHBpbmNoUmVjb2duaXplciA9IHRoaXMuaGFtbWVyLmdldCgncGluY2gnKS5zZXQoeyBlbmFibGU6IHRydWUgfSk7XG4gICAgaGFtbWVyVXRpbC5kaXNhYmxlUHJldmVudERlZmF1bHRWZXJ0aWNhbGx5KHBpbmNoUmVjb2duaXplcik7XG4gICAgdGhpcy5oYW1tZXIuZ2V0KCdwYW4nKS5zZXQoeyB0aHJlc2hvbGQ6IDUsIGRpcmVjdGlvbjogSGFtbWVyLkRJUkVDVElPTl9IT1JJWk9OVEFMIH0pO1xuICAgIHRoaXMubGlzdGVuZXJzID0ge307XG5cbiAgICB2YXIgZXZlbnRzID0gWyd0YXAnLCAnZG91YmxldGFwJywgJ3ByZXNzJywgJ3BpbmNoJywgJ3BhbicsICdwYW5zdGFydCcsICdwYW5tb3ZlJywgJ3BhbmVuZCdcbiAgICAvLyBUT0RPOiBjbGVhbnVwXG4gICAgLy8ndG91Y2gnLCAncGluY2gnLFxuICAgIC8vJ3RhcCcsICdkb3VibGV0YXAnLCAnaG9sZCcsXG4gICAgLy8nZHJhZ3N0YXJ0JywgJ2RyYWcnLCAnZHJhZ2VuZCcsXG4gICAgLy8nbW91c2V3aGVlbCcsICdET01Nb3VzZVNjcm9sbCcgLy8gRE9NTW91c2VTY3JvbGwgaXMgbmVlZGVkIGZvciBGaXJlZm94XG4gICAgXTtcbiAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gbGlzdGVuZXIoZXZlbnQpIHtcbiAgICAgICAgaWYgKG1lLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgICBtZS5lbWl0KHR5cGUsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIG1lLmhhbW1lci5vbih0eXBlLCBsaXN0ZW5lcik7XG4gICAgICBtZS5saXN0ZW5lcnNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICB9KTtcblxuICAgIC8vIGVtdWxhdGUgYSB0b3VjaCBldmVudCAoZW1pdHRlZCBiZWZvcmUgdGhlIHN0YXJ0IG9mIGEgcGFuLCBwaW5jaCwgdGFwLCBvciBwcmVzcylcbiAgICBoYW1tZXJVdGlsLm9uVG91Y2godGhpcy5oYW1tZXIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgbWUuZW1pdCgndG91Y2gnLCBldmVudCk7XG4gICAgfS5iaW5kKHRoaXMpKTtcblxuICAgIC8vIGVtdWxhdGUgYSByZWxlYXNlIGV2ZW50IChlbWl0dGVkIGFmdGVyIGEgcGFuLCBwaW5jaCwgdGFwLCBvciBwcmVzcylcbiAgICBoYW1tZXJVdGlsLm9uUmVsZWFzZSh0aGlzLmhhbW1lciwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBtZS5lbWl0KCdyZWxlYXNlJywgZXZlbnQpO1xuICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICBmdW5jdGlvbiBvbk1vdXNlV2hlZWwoZXZlbnQpIHtcbiAgICAgIGlmIChtZS5pc0FjdGl2ZSgpKSB7XG4gICAgICAgIG1lLmVtaXQoJ21vdXNld2hlZWwnLCBldmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZG9tLnJvb3QuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIG9uTW91c2VXaGVlbCk7XG4gICAgdGhpcy5kb20ucm9vdC5hZGRFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIG9uTW91c2VXaGVlbCk7XG5cbiAgICAvLyBzaXplIHByb3BlcnRpZXMgb2YgZWFjaCBvZiB0aGUgcGFuZWxzXG4gICAgdGhpcy5wcm9wcyA9IHtcbiAgICAgIHJvb3Q6IHt9LFxuICAgICAgYmFja2dyb3VuZDoge30sXG4gICAgICBjZW50ZXJDb250YWluZXI6IHt9LFxuICAgICAgbGVmdENvbnRhaW5lcjoge30sXG4gICAgICByaWdodENvbnRhaW5lcjoge30sXG4gICAgICBjZW50ZXI6IHt9LFxuICAgICAgbGVmdDoge30sXG4gICAgICByaWdodDoge30sXG4gICAgICB0b3A6IHt9LFxuICAgICAgYm90dG9tOiB7fSxcbiAgICAgIGJvcmRlcjoge30sXG4gICAgICBzY3JvbGxUb3A6IDAsXG4gICAgICBzY3JvbGxUb3BNaW46IDBcbiAgICB9O1xuXG4gICAgdGhpcy5jdXN0b21UaW1lcyA9IFtdO1xuXG4gICAgLy8gc3RvcmUgc3RhdGUgaW5mb3JtYXRpb24gbmVlZGVkIGZvciB0b3VjaCBldmVudHNcbiAgICB0aGlzLnRvdWNoID0ge307XG5cbiAgICB0aGlzLnJlZHJhd0NvdW50ID0gMDtcbiAgICB0aGlzLmluaXRpYWxEcmF3RG9uZSA9IGZhbHNlO1xuXG4gICAgLy8gYXR0YWNoIHRoZSByb290IHBhbmVsIHRvIHRoZSBwcm92aWRlZCBjb250YWluZXJcbiAgICBpZiAoIWNvbnRhaW5lcikgdGhyb3cgbmV3IEVycm9yKCdObyBjb250YWluZXIgcHJvdmlkZWQnKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb20ucm9vdCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBvcHRpb25zLiBPcHRpb25zIHdpbGwgYmUgcGFzc2VkIHRvIGFsbCBjb21wb25lbnRzIGxvYWRlZCBpbiB0aGUgVGltZWxpbmUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nfSBvcmllbnRhdGlvblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZlcnRpY2FsIG9yaWVudGF0aW9uIGZvciB0aGUgVGltZWxpbmUsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuIGJlICdib3R0b20nIChkZWZhdWx0KSBvciAndG9wJy5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nIHwgTnVtYmVyfSB3aWR0aFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdpZHRoIGZvciB0aGUgdGltZWxpbmUsIGEgbnVtYmVyIGluIHBpeGVscyBvclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgY3NzIHN0cmluZyBsaWtlICcxMDAwcHgnIG9yICc3NSUnLiAnMTAwJScgYnkgZGVmYXVsdC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nIHwgTnVtYmVyfSBoZWlnaHRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGaXhlZCBoZWlnaHQgZm9yIHRoZSBUaW1lbGluZSwgYSBudW1iZXIgaW4gcGl4ZWxzIG9yXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBjc3Mgc3RyaW5nIGxpa2UgJzQwMHB4JyBvciAnNzUlJy4gSWYgdW5kZWZpbmVkLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBUaW1lbGluZSB3aWxsIGF1dG9tYXRpY2FsbHkgc2l6ZSBzdWNoIHRoYXRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdHMgY29udGVudHMgZml0LlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmcgfCBOdW1iZXJ9IG1pbkhlaWdodFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1pbmltdW0gaGVpZ2h0IGZvciB0aGUgVGltZWxpbmUsIGEgbnVtYmVyIGluIHBpeGVscyBvclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgY3NzIHN0cmluZyBsaWtlICc0MDBweCcgb3IgJzc1JScuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZyB8IE51bWJlcn0gbWF4SGVpZ2h0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF4aW11bSBoZWlnaHQgZm9yIHRoZSBUaW1lbGluZSwgYSBudW1iZXIgaW4gcGl4ZWxzIG9yXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBjc3Mgc3RyaW5nIGxpa2UgJzQwMHB4JyBvciAnNzUlJy5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyIHwgRGF0ZSB8IFN0cmluZ30gc3RhcnRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTdGFydCBkYXRlIGZvciB0aGUgdmlzaWJsZSB3aW5kb3dcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyIHwgRGF0ZSB8IFN0cmluZ30gZW5kXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRW5kIGRhdGUgZm9yIHRoZSB2aXNpYmxlIHdpbmRvd1xuICAgKi9cbiAgQ29yZS5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIC8vIGNvcHkgdGhlIGtub3duIG9wdGlvbnNcbiAgICAgIHZhciBmaWVsZHMgPSBbJ3dpZHRoJywgJ2hlaWdodCcsICdtaW5IZWlnaHQnLCAnbWF4SGVpZ2h0JywgJ2F1dG9SZXNpemUnLCAnc3RhcnQnLCAnZW5kJywgJ2NsaWNrVG9Vc2UnLCAnZGF0YUF0dHJpYnV0ZXMnLCAnaGlkZGVuRGF0ZXMnLCAnbG9jYWxlJywgJ2xvY2FsZXMnLCAnbW9tZW50JywgJ3J0bCcsICd0aHJvdHRsZVJlZHJhdyddO1xuICAgICAgdXRpbC5zZWxlY3RpdmVFeHRlbmQoZmllbGRzLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgICB2YXIgY29udGVudENvbnRhaW5lciA9IHRoaXMuZG9tLmxlZnRDb250YWluZXI7XG4gICAgICAgIHRoaXMuZG9tLmxlZnRDb250YWluZXIgPSB0aGlzLmRvbS5yaWdodENvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5kb20ucmlnaHRDb250YWluZXIgPSBjb250ZW50Q29udGFpbmVyO1xuICAgICAgICB0aGlzLmRvbS5jb250YWluZXIuc3R5bGUuZGlyZWN0aW9uID0gXCJydGxcIjtcbiAgICAgICAgdGhpcy5kb20uYmFja2dyb3VuZFZlcnRpY2FsLmNsYXNzTmFtZSA9ICd2aXMtcGFuZWwgdmlzLWJhY2tncm91bmQgdmlzLXZlcnRpY2FsLXJ0bCc7XG4gICAgICB9XG5cbiAgICAgIHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbiA9IHsgaXRlbTogdW5kZWZpbmVkLCBheGlzOiB1bmRlZmluZWQgfTtcbiAgICAgIGlmICgnb3JpZW50YXRpb24nIGluIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm9yaWVudGF0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbiA9IHtcbiAgICAgICAgICAgIGl0ZW06IG9wdGlvbnMub3JpZW50YXRpb24sXG4gICAgICAgICAgICBheGlzOiBvcHRpb25zLm9yaWVudGF0aW9uXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKG9wdGlvbnMub3JpZW50YXRpb24pID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGlmICgnaXRlbScgaW4gb3B0aW9ucy5vcmllbnRhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uLml0ZW0gPSBvcHRpb25zLm9yaWVudGF0aW9uLml0ZW07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgnYXhpcycgaW4gb3B0aW9ucy5vcmllbnRhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uLmF4aXMgPSBvcHRpb25zLm9yaWVudGF0aW9uLmF4aXM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uYXhpcyA9PT0gJ2JvdGgnKSB7XG4gICAgICAgIGlmICghdGhpcy50aW1lQXhpczIpIHtcbiAgICAgICAgICB2YXIgdGltZUF4aXMyID0gdGhpcy50aW1lQXhpczIgPSBuZXcgVGltZUF4aXModGhpcy5ib2R5KTtcbiAgICAgICAgICB0aW1lQXhpczIuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX29wdGlvbnMgPSBvcHRpb25zID8gdXRpbC5leHRlbmQoe30sIG9wdGlvbnMpIDoge307XG4gICAgICAgICAgICBfb3B0aW9ucy5vcmllbnRhdGlvbiA9ICd0b3AnOyAvLyBvdmVycmlkZSB0aGUgb3JpZW50YXRpb24gb3B0aW9uLCBhbHdheXMgdG9wXG4gICAgICAgICAgICBUaW1lQXhpcy5wcm90b3R5cGUuc2V0T3B0aW9ucy5jYWxsKHRpbWVBeGlzMiwgX29wdGlvbnMpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5jb21wb25lbnRzLnB1c2godGltZUF4aXMyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMudGltZUF4aXMyKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5jb21wb25lbnRzLmluZGV4T2YodGhpcy50aW1lQXhpczIpO1xuICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnRpbWVBeGlzMi5kZXN0cm95KCk7XG4gICAgICAgICAgdGhpcy50aW1lQXhpczIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHRoZSBncmFwaDJkJ3MgZHJhd1BvaW50cyBpcyBhIGZ1bmN0aW9uIGRlbGVnYXRlIHRoZSBjYWxsYmFjayB0byB0aGUgb25SZW5kZXIgcHJvcGVydHlcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kcmF3UG9pbnRzID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb3B0aW9ucy5kcmF3UG9pbnRzID0ge1xuICAgICAgICAgIG9uUmVuZGVyOiBvcHRpb25zLmRyYXdQb2ludHNcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKCdoaWRkZW5EYXRlcycgaW4gdGhpcy5vcHRpb25zKSB7XG4gICAgICAgIERhdGVVdGlsLmNvbnZlcnRIaWRkZW5PcHRpb25zKHRoaXMub3B0aW9ucy5tb21lbnQsIHRoaXMuYm9keSwgdGhpcy5vcHRpb25zLmhpZGRlbkRhdGVzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCdjbGlja1RvVXNlJyBpbiBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmNsaWNrVG9Vc2UpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuYWN0aXZhdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2YXRvciA9IG5ldyBBY3RpdmF0b3IodGhpcy5kb20ucm9vdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLmFjdGl2YXRvcikge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmF0b3IuZGVzdHJveSgpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuYWN0aXZhdG9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoJ3Nob3dDdXN0b21UaW1lJyBpbiBvcHRpb25zKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT3B0aW9uIGBzaG93Q3VzdG9tVGltZWAgaXMgZGVwcmVjYXRlZC4gQ3JlYXRlIGEgY3VzdG9tIHRpbWUgYmFyIHZpYSB0aW1lbGluZS5hZGRDdXN0b21UaW1lKHRpbWUgWywgaWRdKScpO1xuICAgICAgfVxuXG4gICAgICAvLyBlbmFibGUvZGlzYWJsZSBhdXRvUmVzaXplXG4gICAgICB0aGlzLl9pbml0QXV0b1Jlc2l6ZSgpO1xuICAgIH1cblxuICAgIC8vIHByb3BhZ2F0ZSBvcHRpb25zIHRvIGFsbCBjb21wb25lbnRzXG4gICAgdGhpcy5jb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgcmV0dXJuIGNvbXBvbmVudC5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH0pO1xuXG4gICAgLy8gZW5hYmxlL2Rpc2FibGUgY29uZmlndXJlXG4gICAgaWYgKCdjb25maWd1cmUnIGluIG9wdGlvbnMpIHtcbiAgICAgIGlmICghdGhpcy5jb25maWd1cmF0b3IpIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0b3IgPSB0aGlzLl9jcmVhdGVDb25maWd1cmF0b3IoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb25maWd1cmF0b3Iuc2V0T3B0aW9ucyhvcHRpb25zLmNvbmZpZ3VyZSk7XG5cbiAgICAgIC8vIGNvbGxlY3QgdGhlIHNldHRpbmdzIG9mIGFsbCBjb21wb25lbnRzLCBhbmQgcGFzcyB0aGVtIHRvIHRoZSBjb25maWd1cmF0aW9uIHN5c3RlbVxuICAgICAgdmFyIGFwcGxpZWRPcHRpb25zID0gdXRpbC5kZWVwRXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMpO1xuICAgICAgdGhpcy5jb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICB1dGlsLmRlZXBFeHRlbmQoYXBwbGllZE9wdGlvbnMsIGNvbXBvbmVudC5vcHRpb25zKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jb25maWd1cmF0b3Iuc2V0TW9kdWxlT3B0aW9ucyh7IGdsb2JhbDogYXBwbGllZE9wdGlvbnMgfSk7XG4gICAgfVxuXG4gICAgLy8gb3ZlcnJpZGUgcmVkcmF3IHdpdGggYSB0aHJvdHRsZWQgdmVyc2lvblxuICAgIGlmICghdGhpcy5fb3JpZ1JlZHJhdykge1xuICAgICAgdGhpcy5fb3JpZ1JlZHJhdyA9IHRoaXMuX3JlZHJhdy5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fcmVkcmF3ID0gdXRpbC50aHJvdHRsZSh0aGlzLl9vcmlnUmVkcmF3LCB0aGlzLm9wdGlvbnMudGhyb3R0bGVSZWRyYXcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOb3QgdGhlIGluaXRpYWwgcnVuOiByZWRyYXcgZXZlcnl0aGluZ1xuICAgICAgdGhpcy5fcmVkcmF3KCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgVGltZWxpbmUgaXMgYWN0aXZlLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIENvcmUucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhdGhpcy5hY3RpdmF0b3IgfHwgdGhpcy5hY3RpdmF0b3IuYWN0aXZlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXN0cm95IHRoZSBDb3JlLCBjbGVhbiB1cCBhbGwgRE9NIGVsZW1lbnRzIGFuZCBldmVudCBsaXN0ZW5lcnMuXG4gICAqL1xuICBDb3JlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHVuYmluZCBkYXRhc2V0c1xuICAgIHRoaXMuc2V0SXRlbXMobnVsbCk7XG4gICAgdGhpcy5zZXRHcm91cHMobnVsbCk7XG5cbiAgICAvLyByZW1vdmUgYWxsIGV2ZW50IGxpc3RlbmVyc1xuICAgIHRoaXMub2ZmKCk7XG5cbiAgICAvLyBzdG9wIGNoZWNraW5nIGZvciBjaGFuZ2VkIHNpemVcbiAgICB0aGlzLl9zdG9wQXV0b1Jlc2l6ZSgpO1xuXG4gICAgLy8gcmVtb3ZlIGZyb20gRE9NXG4gICAgaWYgKHRoaXMuZG9tLnJvb3QucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5kb20ucm9vdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLnJvb3QpO1xuICAgIH1cbiAgICB0aGlzLmRvbSA9IG51bGw7XG5cbiAgICAvLyByZW1vdmUgQWN0aXZhdG9yXG4gICAgaWYgKHRoaXMuYWN0aXZhdG9yKSB7XG4gICAgICB0aGlzLmFjdGl2YXRvci5kZXN0cm95KCk7XG4gICAgICBkZWxldGUgdGhpcy5hY3RpdmF0b3I7XG4gICAgfVxuXG4gICAgLy8gY2xlYW51cCBoYW1tZXIgdG91Y2ggZXZlbnRzXG4gICAgZm9yICh2YXIgZXZlbnQgaW4gdGhpcy5saXN0ZW5lcnMpIHtcbiAgICAgIGlmICh0aGlzLmxpc3RlbmVycy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMubGlzdGVuZXJzW2V2ZW50XTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5saXN0ZW5lcnMgPSBudWxsO1xuICAgIHRoaXMuaGFtbWVyID0gbnVsbDtcblxuICAgIC8vIGdpdmUgYWxsIGNvbXBvbmVudHMgdGhlIG9wcG9ydHVuaXR5IHRvIGNsZWFudXBcbiAgICB0aGlzLmNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICByZXR1cm4gY29tcG9uZW50LmRlc3Ryb3koKTtcbiAgICB9KTtcblxuICAgIHRoaXMuYm9keSA9IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBhIGN1c3RvbSB0aW1lIGJhclxuICAgKiBAcGFyYW0ge0RhdGV9IHRpbWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtpZD11bmRlZmluZWRdIE9wdGlvbmFsIGlkIG9mIHRoZSBjdXN0b20gdGltZSBiYXIgdG8gYmUgYWRqdXN0ZWQuXG4gICAqL1xuICBDb3JlLnByb3RvdHlwZS5zZXRDdXN0b21UaW1lID0gZnVuY3Rpb24gKHRpbWUsIGlkKSB7XG4gICAgdmFyIGN1c3RvbVRpbWVzID0gdGhpcy5jdXN0b21UaW1lcy5maWx0ZXIoZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgcmV0dXJuIGlkID09PSBjb21wb25lbnQub3B0aW9ucy5pZDtcbiAgICB9KTtcblxuICAgIGlmIChjdXN0b21UaW1lcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gY3VzdG9tIHRpbWUgYmFyIGZvdW5kIHdpdGggaWQgJyArIEpTT04uc3RyaW5naWZ5KGlkKSk7XG4gICAgfVxuXG4gICAgaWYgKGN1c3RvbVRpbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGN1c3RvbVRpbWVzWzBdLnNldEN1c3RvbVRpbWUodGltZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgY3VycmVudCBjdXN0b20gdGltZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtpZD11bmRlZmluZWRdICAgIElkIG9mIHRoZSBjdXN0b20gdGltZSBiYXIuXG4gICAqIEByZXR1cm4ge0RhdGUgfCB1bmRlZmluZWR9IGN1c3RvbVRpbWVcbiAgICovXG4gIENvcmUucHJvdG90eXBlLmdldEN1c3RvbVRpbWUgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgY3VzdG9tVGltZXMgPSB0aGlzLmN1c3RvbVRpbWVzLmZpbHRlcihmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICByZXR1cm4gY29tcG9uZW50Lm9wdGlvbnMuaWQgPT09IGlkO1xuICAgIH0pO1xuXG4gICAgaWYgKGN1c3RvbVRpbWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjdXN0b20gdGltZSBiYXIgZm91bmQgd2l0aCBpZCAnICsgSlNPTi5zdHJpbmdpZnkoaWQpKTtcbiAgICB9XG4gICAgcmV0dXJuIGN1c3RvbVRpbWVzWzBdLmdldEN1c3RvbVRpbWUoKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGEgY3VzdG9tIHRpdGxlIGZvciB0aGUgY3VzdG9tIHRpbWUgYmFyLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3RpdGxlXSBDdXN0b20gdGl0bGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtpZD11bmRlZmluZWRdICAgIElkIG9mIHRoZSBjdXN0b20gdGltZSBiYXIuXG4gICAqL1xuICBDb3JlLnByb3RvdHlwZS5zZXRDdXN0b21UaW1lVGl0bGUgPSBmdW5jdGlvbiAodGl0bGUsIGlkKSB7XG4gICAgdmFyIGN1c3RvbVRpbWVzID0gdGhpcy5jdXN0b21UaW1lcy5maWx0ZXIoZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgcmV0dXJuIGNvbXBvbmVudC5vcHRpb25zLmlkID09PSBpZDtcbiAgICB9KTtcblxuICAgIGlmIChjdXN0b21UaW1lcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gY3VzdG9tIHRpbWUgYmFyIGZvdW5kIHdpdGggaWQgJyArIEpTT04uc3RyaW5naWZ5KGlkKSk7XG4gICAgfVxuICAgIGlmIChjdXN0b21UaW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gY3VzdG9tVGltZXNbMF0uc2V0Q3VzdG9tVGl0bGUodGl0bGUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlldmUgbWV0YSBpbmZvcm1hdGlvbiBmcm9tIGFuIGV2ZW50LlxuICAgKiBTaG91bGQgYmUgb3ZlcnJpZGRlbiBieSBjbGFzc2VzIGV4dGVuZGluZyBDb3JlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHdpdGggcmVsYXRlZCBpbmZvcm1hdGlvbi5cbiAgICovXG4gIENvcmUucHJvdG90eXBlLmdldEV2ZW50UHJvcGVydGllcyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiB7IGV2ZW50OiBldmVudCB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgY3VzdG9tIHZlcnRpY2FsIGJhclxuICAgKiBAcGFyYW0ge0RhdGUgfCBTdHJpbmcgfCBOdW1iZXJ9IFt0aW1lXSAgQSBEYXRlLCB1bml4IHRpbWVzdGFtcCwgb3JcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElTTyBkYXRlIHN0cmluZy4gVGltZSBwb2ludCB3aGVyZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG5ldyBiYXIgc2hvdWxkIGJlIHBsYWNlZC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIG5vdCBwcm92aWRlZCwgYG5ldyBEYXRlKClgIHdpbGxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlIHVzZWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyIHwgU3RyaW5nfSBbaWQ9dW5kZWZpbmVkXSBJZCBvZiB0aGUgbmV3IGJhci4gT3B0aW9uYWxcbiAgICogQHJldHVybiB7TnVtYmVyIHwgU3RyaW5nfSAgICAgICAgICAgICAgIFJldHVybnMgdGhlIGlkIG9mIHRoZSBuZXcgYmFyXG4gICAqL1xuICBDb3JlLnByb3RvdHlwZS5hZGRDdXN0b21UaW1lID0gZnVuY3Rpb24gKHRpbWUsIGlkKSB7XG4gICAgdmFyIHRpbWVzdGFtcCA9IHRpbWUgIT09IHVuZGVmaW5lZCA/IHV0aWwuY29udmVydCh0aW1lLCAnRGF0ZScpLnZhbHVlT2YoKSA6IG5ldyBEYXRlKCk7XG5cbiAgICB2YXIgZXhpc3RzID0gdGhpcy5jdXN0b21UaW1lcy5zb21lKGZ1bmN0aW9uIChjdXN0b21UaW1lKSB7XG4gICAgICByZXR1cm4gY3VzdG9tVGltZS5vcHRpb25zLmlkID09PSBpZDtcbiAgICB9KTtcbiAgICBpZiAoZXhpc3RzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgY3VzdG9tIHRpbWUgd2l0aCBpZCAnICsgSlNPTi5zdHJpbmdpZnkoaWQpICsgJyBhbHJlYWR5IGV4aXN0cycpO1xuICAgIH1cblxuICAgIHZhciBjdXN0b21UaW1lID0gbmV3IEN1c3RvbVRpbWUodGhpcy5ib2R5LCB1dGlsLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLCB7XG4gICAgICB0aW1lOiB0aW1lc3RhbXAsXG4gICAgICBpZDogaWRcbiAgICB9KSk7XG5cbiAgICB0aGlzLmN1c3RvbVRpbWVzLnB1c2goY3VzdG9tVGltZSk7XG4gICAgdGhpcy5jb21wb25lbnRzLnB1c2goY3VzdG9tVGltZSk7XG4gICAgdGhpcy5fcmVkcmF3KCk7XG5cbiAgICByZXR1cm4gaWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBwcmV2aW91c2x5IGFkZGVkIGN1c3RvbSBiYXJcbiAgICogQHBhcmFtIHtpbnR9IGlkIElEIG9mIHRoZSBjdXN0b20gYmFyIHRvIGJlIHJlbW92ZWRcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgYmFyIGV4aXN0cyBhbmQgaXMgcmVtb3ZlZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuICBDb3JlLnByb3RvdHlwZS5yZW1vdmVDdXN0b21UaW1lID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGN1c3RvbVRpbWVzID0gdGhpcy5jdXN0b21UaW1lcy5maWx0ZXIoZnVuY3Rpb24gKGJhcikge1xuICAgICAgcmV0dXJuIGJhci5vcHRpb25zLmlkID09PSBpZDtcbiAgICB9KTtcblxuICAgIGlmIChjdXN0b21UaW1lcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gY3VzdG9tIHRpbWUgYmFyIGZvdW5kIHdpdGggaWQgJyArIEpTT04uc3RyaW5naWZ5KGlkKSk7XG4gICAgfVxuXG4gICAgY3VzdG9tVGltZXMuZm9yRWFjaChmdW5jdGlvbiAoY3VzdG9tVGltZSkge1xuICAgICAgdGhpcy5jdXN0b21UaW1lcy5zcGxpY2UodGhpcy5jdXN0b21UaW1lcy5pbmRleE9mKGN1c3RvbVRpbWUpLCAxKTtcbiAgICAgIHRoaXMuY29tcG9uZW50cy5zcGxpY2UodGhpcy5jb21wb25lbnRzLmluZGV4T2YoY3VzdG9tVGltZSksIDEpO1xuICAgICAgY3VzdG9tVGltZS5kZXN0cm95KCk7XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBpZCdzIG9mIHRoZSBjdXJyZW50bHkgdmlzaWJsZSBpdGVtcy5cbiAgICogQHJldHVybnMge0FycmF5fSBUaGUgaWRzIG9mIHRoZSB2aXNpYmxlIGl0ZW1zXG4gICAqL1xuICBDb3JlLnByb3RvdHlwZS5nZXRWaXNpYmxlSXRlbXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbVNldCAmJiB0aGlzLml0ZW1TZXQuZ2V0VmlzaWJsZUl0ZW1zKCkgfHwgW107XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBDb3JlIHdpbmRvdyBzdWNoIHRoYXQgaXQgZml0cyBhbGwgaXRlbXNcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgYW5pbWF0aW9uOiBib29sZWFuIHwge2R1cmF0aW9uOiBudW1iZXIsIGVhc2luZ0Z1bmN0aW9uOiBzdHJpbmd9YFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHRydWUgKGRlZmF1bHQpLCB0aGUgcmFuZ2UgaXMgYW5pbWF0ZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbW9vdGhseSB0byB0aGUgbmV3IHdpbmRvdy4gQW4gb2JqZWN0IGNhbiBiZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVkIHRvIHNwZWNpZnkgZHVyYXRpb24gYW5kIGVhc2luZyBmdW5jdGlvbi5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IGR1cmF0aW9uIGlzIDUwMCBtcywgYW5kIGRlZmF1bHQgZWFzaW5nXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gaXMgJ2Vhc2VJbk91dFF1YWQnLlxuICAgKi9cbiAgQ29yZS5wcm90b3R5cGUuZml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldERhdGFSYW5nZSgpO1xuXG4gICAgLy8gc2tpcCByYW5nZSBzZXQgaWYgdGhlcmUgaXMgbm8gbWluIGFuZCBtYXggZGF0ZVxuICAgIGlmIChyYW5nZS5taW4gPT09IG51bGwgJiYgcmFuZ2UubWF4ID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYSBtYXJnaW4gb2YgMSUgbGVmdCBhbmQgcmlnaHQgb2YgdGhlIGRhdGFcbiAgICB2YXIgaW50ZXJ2YWwgPSByYW5nZS5tYXggLSByYW5nZS5taW47XG4gICAgdmFyIG1pbiA9IG5ldyBEYXRlKHJhbmdlLm1pbi52YWx1ZU9mKCkgLSBpbnRlcnZhbCAqIDAuMDEpO1xuICAgIHZhciBtYXggPSBuZXcgRGF0ZShyYW5nZS5tYXgudmFsdWVPZigpICsgaW50ZXJ2YWwgKiAwLjAxKTtcbiAgICB2YXIgYW5pbWF0aW9uID0gb3B0aW9ucyAmJiBvcHRpb25zLmFuaW1hdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5hbmltYXRpb24gOiB0cnVlO1xuICAgIHRoaXMucmFuZ2Uuc2V0UmFuZ2UobWluLCBtYXgsIGFuaW1hdGlvbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgZGF0YSByYW5nZSBvZiB0aGUgaXRlbXMgc3RhcnQgYW5kIGVuZCBkYXRlc1xuICAgKiBAcmV0dXJucyB7e21pbjogRGF0ZSB8IG51bGwsIG1heDogRGF0ZSB8IG51bGx9fVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBDb3JlLnByb3RvdHlwZS5nZXREYXRhUmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gbXVzdCBiZSBpbXBsZW1lbnRlZCBieSBUaW1lbGluZSBhbmQgR3JhcGgyZFxuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludm9rZSBhYnN0cmFjdCBtZXRob2QgZ2V0RGF0YVJhbmdlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdmlzaWJsZSB3aW5kb3cuIEJvdGggcGFyYW1ldGVycyBhcmUgb3B0aW9uYWwsIHlvdSBjYW4gY2hhbmdlIG9ubHlcbiAgICogc3RhcnQgb3Igb25seSBlbmQuIFN5bnRheDpcbiAgICpcbiAgICogICAgIFRpbWVMaW5lLnNldFdpbmRvdyhzdGFydCwgZW5kKVxuICAgKiAgICAgVGltZUxpbmUuc2V0V2luZG93KHN0YXJ0LCBlbmQsIG9wdGlvbnMpXG4gICAqICAgICBUaW1lTGluZS5zZXRXaW5kb3cocmFuZ2UpXG4gICAqXG4gICAqIFdoZXJlIHN0YXJ0IGFuZCBlbmQgY2FuIGJlIGEgRGF0ZSwgbnVtYmVyLCBvciBzdHJpbmcsIGFuZCByYW5nZSBpcyBhblxuICAgKiBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIHN0YXJ0IGFuZCBlbmQuXG4gICAqXG4gICAqIEBwYXJhbSB7RGF0ZSB8IE51bWJlciB8IFN0cmluZyB8IE9iamVjdH0gW3N0YXJ0XSBTdGFydCBkYXRlIG9mIHZpc2libGUgd2luZG93XG4gICAqIEBwYXJhbSB7RGF0ZSB8IE51bWJlciB8IFN0cmluZ30gW2VuZF0gICAgICAgICAgICBFbmQgZGF0ZSBvZiB2aXNpYmxlIHdpbmRvd1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICBBdmFpbGFibGUgb3B0aW9uczpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBhbmltYXRpb246IGJvb2xlYW4gfCB7ZHVyYXRpb246IG51bWJlciwgZWFzaW5nRnVuY3Rpb246IHN0cmluZ31gXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgdHJ1ZSAoZGVmYXVsdCksIHRoZSByYW5nZSBpcyBhbmltYXRlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtb290aGx5IHRvIHRoZSBuZXcgd2luZG93LiBBbiBvYmplY3QgY2FuIGJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZWQgdG8gc3BlY2lmeSBkdXJhdGlvbiBhbmQgZWFzaW5nIGZ1bmN0aW9uLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgZHVyYXRpb24gaXMgNTAwIG1zLCBhbmQgZGVmYXVsdCBlYXNpbmdcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBpcyAnZWFzZUluT3V0UXVhZCcuXG4gICAqL1xuICBDb3JlLnByb3RvdHlwZS5zZXRXaW5kb3cgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgb3B0aW9ucykge1xuICAgIHZhciBhbmltYXRpb247XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuICAgICAgdmFyIHJhbmdlID0gYXJndW1lbnRzWzBdO1xuICAgICAgYW5pbWF0aW9uID0gcmFuZ2UuYW5pbWF0aW9uICE9PSB1bmRlZmluZWQgPyByYW5nZS5hbmltYXRpb24gOiB0cnVlO1xuICAgICAgdGhpcy5yYW5nZS5zZXRSYW5nZShyYW5nZS5zdGFydCwgcmFuZ2UuZW5kLCBhbmltYXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbmltYXRpb24gPSBvcHRpb25zICYmIG9wdGlvbnMuYW5pbWF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmFuaW1hdGlvbiA6IHRydWU7XG4gICAgICB0aGlzLnJhbmdlLnNldFJhbmdlKHN0YXJ0LCBlbmQsIGFuaW1hdGlvbik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBNb3ZlIHRoZSB3aW5kb3cgc3VjaCB0aGF0IGdpdmVuIHRpbWUgaXMgY2VudGVyZWQgb24gc2NyZWVuLlxuICAgKiBAcGFyYW0ge0RhdGUgfCBOdW1iZXIgfCBTdHJpbmd9IHRpbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgYW5pbWF0aW9uOiBib29sZWFuIHwge2R1cmF0aW9uOiBudW1iZXIsIGVhc2luZ0Z1bmN0aW9uOiBzdHJpbmd9YFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHRydWUgKGRlZmF1bHQpLCB0aGUgcmFuZ2UgaXMgYW5pbWF0ZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbW9vdGhseSB0byB0aGUgbmV3IHdpbmRvdy4gQW4gb2JqZWN0IGNhbiBiZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVkIHRvIHNwZWNpZnkgZHVyYXRpb24gYW5kIGVhc2luZyBmdW5jdGlvbi5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IGR1cmF0aW9uIGlzIDUwMCBtcywgYW5kIGRlZmF1bHQgZWFzaW5nXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gaXMgJ2Vhc2VJbk91dFF1YWQnLlxuICAgKi9cbiAgQ29yZS5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24gKHRpbWUsIG9wdGlvbnMpIHtcbiAgICB2YXIgaW50ZXJ2YWwgPSB0aGlzLnJhbmdlLmVuZCAtIHRoaXMucmFuZ2Uuc3RhcnQ7XG4gICAgdmFyIHQgPSB1dGlsLmNvbnZlcnQodGltZSwgJ0RhdGUnKS52YWx1ZU9mKCk7XG5cbiAgICB2YXIgc3RhcnQgPSB0IC0gaW50ZXJ2YWwgLyAyO1xuICAgIHZhciBlbmQgPSB0ICsgaW50ZXJ2YWwgLyAyO1xuICAgIHZhciBhbmltYXRpb24gPSBvcHRpb25zICYmIG9wdGlvbnMuYW5pbWF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmFuaW1hdGlvbiA6IHRydWU7XG5cbiAgICB0aGlzLnJhbmdlLnNldFJhbmdlKHN0YXJ0LCBlbmQsIGFuaW1hdGlvbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmlzaWJsZSB3aW5kb3dcbiAgICogQHJldHVybiB7e3N0YXJ0OiBEYXRlLCBlbmQ6IERhdGV9fSAgIFZpc2libGUgcmFuZ2VcbiAgICovXG4gIENvcmUucHJvdG90eXBlLmdldFdpbmRvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmFuZ2UgPSB0aGlzLnJhbmdlLmdldFJhbmdlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBuZXcgRGF0ZShyYW5nZS5zdGFydCksXG4gICAgICBlbmQ6IG5ldyBEYXRlKHJhbmdlLmVuZClcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBGb3JjZSBhIHJlZHJhdy4gQ2FuIGJlIG92ZXJyaWRkZW4gYnkgaW1wbGVtZW50YXRpb25zIG9mIENvcmVcbiAgICpcbiAgICogTm90ZTogdGhpcyBmdW5jdGlvbiB3aWxsIGJlIG92ZXJyaWRkZW4gb24gY29uc3RydWN0aW9uIHdpdGggYSB0cm90dGxlZCB2ZXJzaW9uXG4gICAqL1xuICBDb3JlLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcmVkcmF3KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlZHJhdyBmb3IgaW50ZXJuYWwgdXNlLiBSZWRyYXdzIGFsbCBjb21wb25lbnRzLiBTZWUgYWxzbyB0aGUgcHVibGljXG4gICAqIG1ldGhvZCByZWRyYXcuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIENvcmUucHJvdG90eXBlLl9yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZWRyYXdDb3VudCsrO1xuICAgIHZhciByZXNpemVkID0gZmFsc2U7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgZG9tID0gdGhpcy5kb207XG5cbiAgICBpZiAoIWRvbSB8fCAhZG9tLmNvbnRhaW5lciB8fCBkb20ucm9vdC5vZmZzZXRXaWR0aCA9PSAwKSByZXR1cm47IC8vIHdoZW4gZGVzdHJveWVkLCBvciBpbnZpc2libGVcblxuICAgIERhdGVVdGlsLnVwZGF0ZUhpZGRlbkRhdGVzKHRoaXMub3B0aW9ucy5tb21lbnQsIHRoaXMuYm9keSwgdGhpcy5vcHRpb25zLmhpZGRlbkRhdGVzKTtcblxuICAgIC8vIHVwZGF0ZSBjbGFzcyBuYW1lc1xuICAgIGlmIChvcHRpb25zLm9yaWVudGF0aW9uID09ICd0b3AnKSB7XG4gICAgICB1dGlsLmFkZENsYXNzTmFtZShkb20ucm9vdCwgJ3Zpcy10b3AnKTtcbiAgICAgIHV0aWwucmVtb3ZlQ2xhc3NOYW1lKGRvbS5yb290LCAndmlzLWJvdHRvbScpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1dGlsLnJlbW92ZUNsYXNzTmFtZShkb20ucm9vdCwgJ3Zpcy10b3AnKTtcbiAgICAgIHV0aWwuYWRkQ2xhc3NOYW1lKGRvbS5yb290LCAndmlzLWJvdHRvbScpO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSByb290IHdpZHRoIGFuZCBoZWlnaHQgb3B0aW9uc1xuICAgIGRvbS5yb290LnN0eWxlLm1heEhlaWdodCA9IHV0aWwub3B0aW9uLmFzU2l6ZShvcHRpb25zLm1heEhlaWdodCwgJycpO1xuICAgIGRvbS5yb290LnN0eWxlLm1pbkhlaWdodCA9IHV0aWwub3B0aW9uLmFzU2l6ZShvcHRpb25zLm1pbkhlaWdodCwgJycpO1xuICAgIGRvbS5yb290LnN0eWxlLndpZHRoID0gdXRpbC5vcHRpb24uYXNTaXplKG9wdGlvbnMud2lkdGgsICcnKTtcblxuICAgIC8vIGNhbGN1bGF0ZSBib3JkZXIgd2lkdGhzXG4gICAgcHJvcHMuYm9yZGVyLmxlZnQgPSAoZG9tLmNlbnRlckNvbnRhaW5lci5vZmZzZXRXaWR0aCAtIGRvbS5jZW50ZXJDb250YWluZXIuY2xpZW50V2lkdGgpIC8gMjtcbiAgICBwcm9wcy5ib3JkZXIucmlnaHQgPSBwcm9wcy5ib3JkZXIubGVmdDtcbiAgICBwcm9wcy5ib3JkZXIudG9wID0gKGRvbS5jZW50ZXJDb250YWluZXIub2Zmc2V0SGVpZ2h0IC0gZG9tLmNlbnRlckNvbnRhaW5lci5jbGllbnRIZWlnaHQpIC8gMjtcbiAgICBwcm9wcy5ib3JkZXIuYm90dG9tID0gcHJvcHMuYm9yZGVyLnRvcDtcbiAgICB2YXIgYm9yZGVyUm9vdEhlaWdodCA9IGRvbS5yb290Lm9mZnNldEhlaWdodCAtIGRvbS5yb290LmNsaWVudEhlaWdodDtcbiAgICB2YXIgYm9yZGVyUm9vdFdpZHRoID0gZG9tLnJvb3Qub2Zmc2V0V2lkdGggLSBkb20ucm9vdC5jbGllbnRXaWR0aDtcblxuICAgIC8vIHdvcmthcm91bmQgZm9yIGEgYnVnIGluIElFOiB0aGUgY2xpZW50V2lkdGggb2YgYW4gZWxlbWVudCB3aXRoXG4gICAgLy8gYSBoZWlnaHQ6MHB4IGFuZCBvdmVyZmxvdzpoaWRkZW4gaXMgbm90IGNhbGN1bGF0ZWQgYW5kIGFsd2F5cyBoYXMgdmFsdWUgMFxuICAgIGlmIChkb20uY2VudGVyQ29udGFpbmVyLmNsaWVudEhlaWdodCA9PT0gMCkge1xuICAgICAgcHJvcHMuYm9yZGVyLmxlZnQgPSBwcm9wcy5ib3JkZXIudG9wO1xuICAgICAgcHJvcHMuYm9yZGVyLnJpZ2h0ID0gcHJvcHMuYm9yZGVyLmxlZnQ7XG4gICAgfVxuICAgIGlmIChkb20ucm9vdC5jbGllbnRIZWlnaHQgPT09IDApIHtcbiAgICAgIGJvcmRlclJvb3RXaWR0aCA9IGJvcmRlclJvb3RIZWlnaHQ7XG4gICAgfVxuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBoZWlnaHRzLiBJZiBhbnkgb2YgdGhlIHNpZGUgcGFuZWxzIGlzIGVtcHR5LCB3ZSBzZXQgdGhlIGhlaWdodCB0b1xuICAgIC8vIG1pbnVzIHRoZSBib3JkZXIgd2lkdGgsIHN1Y2ggdGhhdCB0aGUgYm9yZGVyIHdpbGwgYmUgaW52aXNpYmxlXG4gICAgcHJvcHMuY2VudGVyLmhlaWdodCA9IGRvbS5jZW50ZXIub2Zmc2V0SGVpZ2h0O1xuICAgIHByb3BzLmxlZnQuaGVpZ2h0ID0gZG9tLmxlZnQub2Zmc2V0SGVpZ2h0O1xuICAgIHByb3BzLnJpZ2h0LmhlaWdodCA9IGRvbS5yaWdodC5vZmZzZXRIZWlnaHQ7XG4gICAgcHJvcHMudG9wLmhlaWdodCA9IGRvbS50b3AuY2xpZW50SGVpZ2h0IHx8IC1wcm9wcy5ib3JkZXIudG9wO1xuICAgIHByb3BzLmJvdHRvbS5oZWlnaHQgPSBkb20uYm90dG9tLmNsaWVudEhlaWdodCB8fCAtcHJvcHMuYm9yZGVyLmJvdHRvbTtcblxuICAgIC8vIFRPRE86IGNvbXBlbnNhdGUgYm9yZGVycyB3aGVuIGFueSBvZiB0aGUgcGFuZWxzIGlzIGVtcHR5LlxuXG4gICAgLy8gYXBwbHkgYXV0byBoZWlnaHRcbiAgICAvLyBUT0RPOiBvbmx5IGNhbGN1bGF0ZSBhdXRvSGVpZ2h0IHdoZW4gbmVlZGVkIChlbHNlIHdlIGNhdXNlIGFuIGV4dHJhIHJlZmxvdy9yZXBhaW50IG9mIHRoZSBET00pXG4gICAgdmFyIGNvbnRlbnRIZWlnaHQgPSBNYXRoLm1heChwcm9wcy5sZWZ0LmhlaWdodCwgcHJvcHMuY2VudGVyLmhlaWdodCwgcHJvcHMucmlnaHQuaGVpZ2h0KTtcbiAgICB2YXIgYXV0b0hlaWdodCA9IHByb3BzLnRvcC5oZWlnaHQgKyBjb250ZW50SGVpZ2h0ICsgcHJvcHMuYm90dG9tLmhlaWdodCArIGJvcmRlclJvb3RIZWlnaHQgKyBwcm9wcy5ib3JkZXIudG9wICsgcHJvcHMuYm9yZGVyLmJvdHRvbTtcbiAgICBkb20ucm9vdC5zdHlsZS5oZWlnaHQgPSB1dGlsLm9wdGlvbi5hc1NpemUob3B0aW9ucy5oZWlnaHQsIGF1dG9IZWlnaHQgKyAncHgnKTtcblxuICAgIC8vIGNhbGN1bGF0ZSBoZWlnaHRzIG9mIHRoZSBjb250ZW50IHBhbmVsc1xuICAgIHByb3BzLnJvb3QuaGVpZ2h0ID0gZG9tLnJvb3Qub2Zmc2V0SGVpZ2h0O1xuICAgIHByb3BzLmJhY2tncm91bmQuaGVpZ2h0ID0gcHJvcHMucm9vdC5oZWlnaHQgLSBib3JkZXJSb290SGVpZ2h0O1xuICAgIHZhciBjb250YWluZXJIZWlnaHQgPSBwcm9wcy5yb290LmhlaWdodCAtIHByb3BzLnRvcC5oZWlnaHQgLSBwcm9wcy5ib3R0b20uaGVpZ2h0IC0gYm9yZGVyUm9vdEhlaWdodDtcbiAgICBwcm9wcy5jZW50ZXJDb250YWluZXIuaGVpZ2h0ID0gY29udGFpbmVySGVpZ2h0O1xuICAgIHByb3BzLmxlZnRDb250YWluZXIuaGVpZ2h0ID0gY29udGFpbmVySGVpZ2h0O1xuICAgIHByb3BzLnJpZ2h0Q29udGFpbmVyLmhlaWdodCA9IHByb3BzLmxlZnRDb250YWluZXIuaGVpZ2h0O1xuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSB3aWR0aHMgb2YgdGhlIHBhbmVsc1xuICAgIHByb3BzLnJvb3Qud2lkdGggPSBkb20ucm9vdC5vZmZzZXRXaWR0aDtcbiAgICBwcm9wcy5iYWNrZ3JvdW5kLndpZHRoID0gcHJvcHMucm9vdC53aWR0aCAtIGJvcmRlclJvb3RXaWR0aDtcbiAgICBwcm9wcy5sZWZ0LndpZHRoID0gZG9tLmxlZnRDb250YWluZXIuY2xpZW50V2lkdGggfHwgLXByb3BzLmJvcmRlci5sZWZ0O1xuICAgIHByb3BzLmxlZnRDb250YWluZXIud2lkdGggPSBwcm9wcy5sZWZ0LndpZHRoO1xuICAgIHByb3BzLnJpZ2h0LndpZHRoID0gZG9tLnJpZ2h0Q29udGFpbmVyLmNsaWVudFdpZHRoIHx8IC1wcm9wcy5ib3JkZXIucmlnaHQ7XG4gICAgcHJvcHMucmlnaHRDb250YWluZXIud2lkdGggPSBwcm9wcy5yaWdodC53aWR0aDtcbiAgICB2YXIgY2VudGVyV2lkdGggPSBwcm9wcy5yb290LndpZHRoIC0gcHJvcHMubGVmdC53aWR0aCAtIHByb3BzLnJpZ2h0LndpZHRoIC0gYm9yZGVyUm9vdFdpZHRoO1xuICAgIHByb3BzLmNlbnRlci53aWR0aCA9IGNlbnRlcldpZHRoO1xuICAgIHByb3BzLmNlbnRlckNvbnRhaW5lci53aWR0aCA9IGNlbnRlcldpZHRoO1xuICAgIHByb3BzLnRvcC53aWR0aCA9IGNlbnRlcldpZHRoO1xuICAgIHByb3BzLmJvdHRvbS53aWR0aCA9IGNlbnRlcldpZHRoO1xuXG4gICAgLy8gcmVzaXplIHRoZSBwYW5lbHNcbiAgICBkb20uYmFja2dyb3VuZC5zdHlsZS5oZWlnaHQgPSBwcm9wcy5iYWNrZ3JvdW5kLmhlaWdodCArICdweCc7XG4gICAgZG9tLmJhY2tncm91bmRWZXJ0aWNhbC5zdHlsZS5oZWlnaHQgPSBwcm9wcy5iYWNrZ3JvdW5kLmhlaWdodCArICdweCc7XG4gICAgZG9tLmJhY2tncm91bmRIb3Jpem9udGFsLnN0eWxlLmhlaWdodCA9IHByb3BzLmNlbnRlckNvbnRhaW5lci5oZWlnaHQgKyAncHgnO1xuICAgIGRvbS5jZW50ZXJDb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gcHJvcHMuY2VudGVyQ29udGFpbmVyLmhlaWdodCArICdweCc7XG4gICAgZG9tLmxlZnRDb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gcHJvcHMubGVmdENvbnRhaW5lci5oZWlnaHQgKyAncHgnO1xuICAgIGRvbS5yaWdodENvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBwcm9wcy5yaWdodENvbnRhaW5lci5oZWlnaHQgKyAncHgnO1xuXG4gICAgZG9tLmJhY2tncm91bmQuc3R5bGUud2lkdGggPSBwcm9wcy5iYWNrZ3JvdW5kLndpZHRoICsgJ3B4JztcbiAgICBkb20uYmFja2dyb3VuZFZlcnRpY2FsLnN0eWxlLndpZHRoID0gcHJvcHMuY2VudGVyQ29udGFpbmVyLndpZHRoICsgJ3B4JztcbiAgICBkb20uYmFja2dyb3VuZEhvcml6b250YWwuc3R5bGUud2lkdGggPSBwcm9wcy5iYWNrZ3JvdW5kLndpZHRoICsgJ3B4JztcbiAgICBkb20uY2VudGVyQ29udGFpbmVyLnN0eWxlLndpZHRoID0gcHJvcHMuY2VudGVyLndpZHRoICsgJ3B4JztcbiAgICBkb20udG9wLnN0eWxlLndpZHRoID0gcHJvcHMudG9wLndpZHRoICsgJ3B4JztcbiAgICBkb20uYm90dG9tLnN0eWxlLndpZHRoID0gcHJvcHMuYm90dG9tLndpZHRoICsgJ3B4JztcblxuICAgIC8vIHJlcG9zaXRpb24gdGhlIHBhbmVsc1xuICAgIGRvbS5iYWNrZ3JvdW5kLnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgZG9tLmJhY2tncm91bmQuc3R5bGUudG9wID0gJzAnO1xuICAgIGRvbS5iYWNrZ3JvdW5kVmVydGljYWwuc3R5bGUubGVmdCA9IHByb3BzLmxlZnQud2lkdGggKyBwcm9wcy5ib3JkZXIubGVmdCArICdweCc7XG4gICAgZG9tLmJhY2tncm91bmRWZXJ0aWNhbC5zdHlsZS50b3AgPSAnMCc7XG4gICAgZG9tLmJhY2tncm91bmRIb3Jpem9udGFsLnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgZG9tLmJhY2tncm91bmRIb3Jpem9udGFsLnN0eWxlLnRvcCA9IHByb3BzLnRvcC5oZWlnaHQgKyAncHgnO1xuICAgIGRvbS5jZW50ZXJDb250YWluZXIuc3R5bGUubGVmdCA9IHByb3BzLmxlZnQud2lkdGggKyAncHgnO1xuICAgIGRvbS5jZW50ZXJDb250YWluZXIuc3R5bGUudG9wID0gcHJvcHMudG9wLmhlaWdodCArICdweCc7XG4gICAgZG9tLmxlZnRDb250YWluZXIuc3R5bGUubGVmdCA9ICcwJztcbiAgICBkb20ubGVmdENvbnRhaW5lci5zdHlsZS50b3AgPSBwcm9wcy50b3AuaGVpZ2h0ICsgJ3B4JztcbiAgICBkb20ucmlnaHRDb250YWluZXIuc3R5bGUubGVmdCA9IHByb3BzLmxlZnQud2lkdGggKyBwcm9wcy5jZW50ZXIud2lkdGggKyAncHgnO1xuICAgIGRvbS5yaWdodENvbnRhaW5lci5zdHlsZS50b3AgPSBwcm9wcy50b3AuaGVpZ2h0ICsgJ3B4JztcbiAgICBkb20udG9wLnN0eWxlLmxlZnQgPSBwcm9wcy5sZWZ0LndpZHRoICsgJ3B4JztcbiAgICBkb20udG9wLnN0eWxlLnRvcCA9ICcwJztcbiAgICBkb20uYm90dG9tLnN0eWxlLmxlZnQgPSBwcm9wcy5sZWZ0LndpZHRoICsgJ3B4JztcbiAgICBkb20uYm90dG9tLnN0eWxlLnRvcCA9IHByb3BzLnRvcC5oZWlnaHQgKyBwcm9wcy5jZW50ZXJDb250YWluZXIuaGVpZ2h0ICsgJ3B4JztcblxuICAgIC8vIHVwZGF0ZSB0aGUgc2Nyb2xsVG9wLCBmZWFzaWJsZSByYW5nZSBmb3IgdGhlIG9mZnNldCBjYW4gYmUgY2hhbmdlZFxuICAgIC8vIHdoZW4gdGhlIGhlaWdodCBvZiB0aGUgQ29yZSBvciBvZiB0aGUgY29udGVudHMgb2YgdGhlIGNlbnRlciBjaGFuZ2VkXG4gICAgdGhpcy5fdXBkYXRlU2Nyb2xsVG9wKCk7XG5cbiAgICAvLyByZXBvc2l0aW9uIHRoZSBzY3JvbGxhYmxlIGNvbnRlbnRzXG4gICAgdmFyIG9mZnNldCA9IHRoaXMucHJvcHMuc2Nyb2xsVG9wO1xuICAgIGlmIChvcHRpb25zLm9yaWVudGF0aW9uLml0ZW0gIT0gJ3RvcCcpIHtcbiAgICAgIG9mZnNldCArPSBNYXRoLm1heCh0aGlzLnByb3BzLmNlbnRlckNvbnRhaW5lci5oZWlnaHQgLSB0aGlzLnByb3BzLmNlbnRlci5oZWlnaHQgLSB0aGlzLnByb3BzLmJvcmRlci50b3AgLSB0aGlzLnByb3BzLmJvcmRlci5ib3R0b20sIDApO1xuICAgIH1cbiAgICBkb20uY2VudGVyLnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgZG9tLmNlbnRlci5zdHlsZS50b3AgPSBvZmZzZXQgKyAncHgnO1xuICAgIGRvbS5sZWZ0LnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgZG9tLmxlZnQuc3R5bGUudG9wID0gb2Zmc2V0ICsgJ3B4JztcbiAgICBkb20ucmlnaHQuc3R5bGUubGVmdCA9ICcwJztcbiAgICBkb20ucmlnaHQuc3R5bGUudG9wID0gb2Zmc2V0ICsgJ3B4JztcblxuICAgIC8vIHNob3cgc2hhZG93cyB3aGVuIHZlcnRpY2FsIHNjcm9sbGluZyBpcyBhdmFpbGFibGVcbiAgICB2YXIgdmlzaWJpbGl0eVRvcCA9IHRoaXMucHJvcHMuc2Nyb2xsVG9wID09IDAgPyAnaGlkZGVuJyA6ICcnO1xuICAgIHZhciB2aXNpYmlsaXR5Qm90dG9tID0gdGhpcy5wcm9wcy5zY3JvbGxUb3AgPT0gdGhpcy5wcm9wcy5zY3JvbGxUb3BNaW4gPyAnaGlkZGVuJyA6ICcnO1xuICAgIGRvbS5zaGFkb3dUb3Auc3R5bGUudmlzaWJpbGl0eSA9IHZpc2liaWxpdHlUb3A7XG4gICAgZG9tLnNoYWRvd0JvdHRvbS5zdHlsZS52aXNpYmlsaXR5ID0gdmlzaWJpbGl0eUJvdHRvbTtcbiAgICBkb20uc2hhZG93VG9wTGVmdC5zdHlsZS52aXNpYmlsaXR5ID0gdmlzaWJpbGl0eVRvcDtcbiAgICBkb20uc2hhZG93Qm90dG9tTGVmdC5zdHlsZS52aXNpYmlsaXR5ID0gdmlzaWJpbGl0eUJvdHRvbTtcbiAgICBkb20uc2hhZG93VG9wUmlnaHQuc3R5bGUudmlzaWJpbGl0eSA9IHZpc2liaWxpdHlUb3A7XG4gICAgZG9tLnNoYWRvd0JvdHRvbVJpZ2h0LnN0eWxlLnZpc2liaWxpdHkgPSB2aXNpYmlsaXR5Qm90dG9tO1xuXG4gICAgLy8gZW5hYmxlL2Rpc2FibGUgdmVydGljYWwgcGFubmluZ1xuICAgIHZhciBjb250ZW50c092ZXJmbG93ID0gdGhpcy5wcm9wcy5jZW50ZXIuaGVpZ2h0ID4gdGhpcy5wcm9wcy5jZW50ZXJDb250YWluZXIuaGVpZ2h0O1xuICAgIHRoaXMuaGFtbWVyLmdldCgncGFuJykuc2V0KHtcbiAgICAgIGRpcmVjdGlvbjogY29udGVudHNPdmVyZmxvdyA/IEhhbW1lci5ESVJFQ1RJT05fQUxMIDogSGFtbWVyLkRJUkVDVElPTl9IT1JJWk9OVEFMXG4gICAgfSk7XG5cbiAgICAvLyByZWRyYXcgYWxsIGNvbXBvbmVudHNcbiAgICB0aGlzLmNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICByZXNpemVkID0gY29tcG9uZW50LnJlZHJhdygpIHx8IHJlc2l6ZWQ7XG4gICAgfSk7XG4gICAgdmFyIE1BWF9SRURSQVcgPSA1O1xuICAgIGlmIChyZXNpemVkKSB7XG4gICAgICBpZiAodGhpcy5yZWRyYXdDb3VudCA8IE1BWF9SRURSQVcpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2NoYW5nZScpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZygnV0FSTklORzogaW5maW5pdGUgbG9vcCBpbiByZWRyYXc/Jyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVkcmF3Q291bnQgPSAwO1xuICAgIH1cbiAgICB0aGlzLmluaXRpYWxEcmF3RG9uZSA9IHRydWU7XG5cbiAgICAvL0VtaXQgcHVibGljICdjaGFuZ2VkJyBldmVudCBmb3IgVUkgdXBkYXRlcywgc2VlIGlzc3VlICMxNTkyXG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImNoYW5nZWRcIik7XG4gIH07XG5cbiAgLy8gVE9ETzogZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuMS4wLCByZW1vdmUgc29tZSBkYXlcbiAgQ29yZS5wcm90b3R5cGUucmVwYWludCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIHJlcGFpbnQgaXMgZGVwcmVjYXRlZC4gVXNlIHJlZHJhdyBpbnN0ZWFkLicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgYSBjdXJyZW50IHRpbWUuIFRoaXMgY2FuIGJlIHVzZWQgZm9yIGV4YW1wbGUgdG8gZW5zdXJlIHRoYXQgYSBjbGllbnQnc1xuICAgKiB0aW1lIGlzIHN5bmNocm9uaXplZCB3aXRoIGEgc2hhcmVkIHNlcnZlciB0aW1lLlxuICAgKiBPbmx5IGFwcGxpY2FibGUgd2hlbiBvcHRpb24gYHNob3dDdXJyZW50VGltZWAgaXMgdHJ1ZS5cbiAgICogQHBhcmFtIHtEYXRlIHwgU3RyaW5nIHwgTnVtYmVyfSB0aW1lICAgICBBIERhdGUsIHVuaXggdGltZXN0YW1wLCBvclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElTTyBkYXRlIHN0cmluZy5cbiAgICovXG4gIENvcmUucHJvdG90eXBlLnNldEN1cnJlbnRUaW1lID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICBpZiAoIXRoaXMuY3VycmVudFRpbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT3B0aW9uIHNob3dDdXJyZW50VGltZSBtdXN0IGJlIHRydWUnKTtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnRUaW1lLnNldEN1cnJlbnRUaW1lKHRpbWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgdGltZS5cbiAgICogT25seSBhcHBsaWNhYmxlIHdoZW4gb3B0aW9uIGBzaG93Q3VycmVudFRpbWVgIGlzIHRydWUuXG4gICAqIEByZXR1cm4ge0RhdGV9IFJldHVybnMgdGhlIGN1cnJlbnQgdGltZS5cbiAgICovXG4gIENvcmUucHJvdG90eXBlLmdldEN1cnJlbnRUaW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5jdXJyZW50VGltZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb24gc2hvd0N1cnJlbnRUaW1lIG11c3QgYmUgdHJ1ZScpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmN1cnJlbnRUaW1lLmdldEN1cnJlbnRUaW1lKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBwb3NpdGlvbiBvbiBzY3JlZW4gKHBpeGVscykgdG8gYSBkYXRldGltZVxuICAgKiBAcGFyYW0ge2ludH0gICAgIHggICAgUG9zaXRpb24gb24gdGhlIHNjcmVlbiBpbiBwaXhlbHNcbiAgICogQHJldHVybiB7RGF0ZX0gICB0aW1lIFRoZSBkYXRldGltZSB0aGUgY29ycmVzcG9uZHMgd2l0aCBnaXZlbiBwb3NpdGlvbiB4XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIC8vIFRPRE86IG1vdmUgdGhpcyBmdW5jdGlvbiB0byBSYW5nZVxuICBDb3JlLnByb3RvdHlwZS5fdG9UaW1lID0gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gRGF0ZVV0aWwudG9UaW1lKHRoaXMsIHgsIHRoaXMucHJvcHMuY2VudGVyLndpZHRoKTtcbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydCBhIHBvc2l0aW9uIG9uIHRoZSBnbG9iYWwgc2NyZWVuIChwaXhlbHMpIHRvIGEgZGF0ZXRpbWVcbiAgICogQHBhcmFtIHtpbnR9ICAgICB4ICAgIFBvc2l0aW9uIG9uIHRoZSBzY3JlZW4gaW4gcGl4ZWxzXG4gICAqIEByZXR1cm4ge0RhdGV9ICAgdGltZSBUaGUgZGF0ZXRpbWUgdGhlIGNvcnJlc3BvbmRzIHdpdGggZ2l2ZW4gcG9zaXRpb24geFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICAvLyBUT0RPOiBtb3ZlIHRoaXMgZnVuY3Rpb24gdG8gUmFuZ2VcbiAgQ29yZS5wcm90b3R5cGUuX3RvR2xvYmFsVGltZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIERhdGVVdGlsLnRvVGltZSh0aGlzLCB4LCB0aGlzLnByb3BzLnJvb3Qud2lkdGgpO1xuICAgIC8vdmFyIGNvbnZlcnNpb24gPSB0aGlzLnJhbmdlLmNvbnZlcnNpb24odGhpcy5wcm9wcy5yb290LndpZHRoKTtcbiAgICAvL3JldHVybiBuZXcgRGF0ZSh4IC8gY29udmVyc2lvbi5zY2FsZSArIGNvbnZlcnNpb24ub2Zmc2V0KTtcbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydCBhIGRhdGV0aW1lIChEYXRlIG9iamVjdCkgaW50byBhIHBvc2l0aW9uIG9uIHRoZSBzY3JlZW5cbiAgICogQHBhcmFtIHtEYXRlfSAgIHRpbWUgQSBkYXRlXG4gICAqIEByZXR1cm4ge2ludH0gICB4ICAgIFRoZSBwb3NpdGlvbiBvbiB0aGUgc2NyZWVuIGluIHBpeGVscyB3aGljaCBjb3JyZXNwb25kc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICB3aXRoIHRoZSBnaXZlbiBkYXRlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICAvLyBUT0RPOiBtb3ZlIHRoaXMgZnVuY3Rpb24gdG8gUmFuZ2VcbiAgQ29yZS5wcm90b3R5cGUuX3RvU2NyZWVuID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICByZXR1cm4gRGF0ZVV0aWwudG9TY3JlZW4odGhpcywgdGltZSwgdGhpcy5wcm9wcy5jZW50ZXIud2lkdGgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgZGF0ZXRpbWUgKERhdGUgb2JqZWN0KSBpbnRvIGEgcG9zaXRpb24gb24gdGhlIHJvb3RcbiAgICogVGhpcyBpcyB1c2VkIHRvIGdldCB0aGUgcGl4ZWwgZGVuc2l0eSBlc3RpbWF0ZSBmb3IgdGhlIHNjcmVlbiwgbm90IHRoZSBjZW50ZXIgcGFuZWxcbiAgICogQHBhcmFtIHtEYXRlfSAgIHRpbWUgQSBkYXRlXG4gICAqIEByZXR1cm4ge2ludH0gICB4ICAgIFRoZSBwb3NpdGlvbiBvbiByb290IGluIHBpeGVscyB3aGljaCBjb3JyZXNwb25kc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICB3aXRoIHRoZSBnaXZlbiBkYXRlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICAvLyBUT0RPOiBtb3ZlIHRoaXMgZnVuY3Rpb24gdG8gUmFuZ2VcbiAgQ29yZS5wcm90b3R5cGUuX3RvR2xvYmFsU2NyZWVuID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICByZXR1cm4gRGF0ZVV0aWwudG9TY3JlZW4odGhpcywgdGltZSwgdGhpcy5wcm9wcy5yb290LndpZHRoKTtcbiAgICAvL3ZhciBjb252ZXJzaW9uID0gdGhpcy5yYW5nZS5jb252ZXJzaW9uKHRoaXMucHJvcHMucm9vdC53aWR0aCk7XG4gICAgLy9yZXR1cm4gKHRpbWUudmFsdWVPZigpIC0gY29udmVyc2lvbi5vZmZzZXQpICogY29udmVyc2lvbi5zY2FsZTtcbiAgfTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB3YXRjaGluZyB3aGVuIG9wdGlvbiBhdXRvUmVzaXplIGlzIHRydWVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIENvcmUucHJvdG90eXBlLl9pbml0QXV0b1Jlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9SZXNpemUgPT0gdHJ1ZSkge1xuICAgICAgdGhpcy5fc3RhcnRBdXRvUmVzaXplKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3N0b3BBdXRvUmVzaXplKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBXYXRjaCBmb3IgY2hhbmdlcyBpbiB0aGUgc2l6ZSBvZiB0aGUgY29udGFpbmVyLiBPbiByZXNpemUsIHRoZSBQYW5lbCB3aWxsXG4gICAqIGF1dG9tYXRpY2FsbHkgcmVkcmF3IGl0c2VsZi5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIENvcmUucHJvdG90eXBlLl9zdGFydEF1dG9SZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1lID0gdGhpcztcblxuICAgIHRoaXMuX3N0b3BBdXRvUmVzaXplKCk7XG5cbiAgICB0aGlzLl9vblJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChtZS5vcHRpb25zLmF1dG9SZXNpemUgIT0gdHJ1ZSkge1xuICAgICAgICAvLyBzdG9wIHdhdGNoaW5nIHdoZW4gdGhlIG9wdGlvbiBhdXRvUmVzaXplIGlzIGNoYW5nZWQgdG8gZmFsc2VcbiAgICAgICAgbWUuX3N0b3BBdXRvUmVzaXplKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG1lLmRvbS5yb290KSB7XG4gICAgICAgIC8vIGNoZWNrIHdoZXRoZXIgdGhlIGZyYW1lIGlzIHJlc2l6ZWRcbiAgICAgICAgLy8gTm90ZTogd2UgY29tcGFyZSBvZmZzZXRXaWR0aCBoZXJlLCBub3QgY2xpZW50V2lkdGguIEZvciBzb21lIHJlYXNvbixcbiAgICAgICAgLy8gSUUgZG9lcyBub3QgcmVzdG9yZSB0aGUgY2xpZW50V2lkdGggZnJvbSAwIHRvIHRoZSBhY3R1YWwgd2lkdGggYWZ0ZXJcbiAgICAgICAgLy8gY2hhbmdpbmcgdGhlIHRpbWVsaW5lJ3MgY29udGFpbmVyIGRpc3BsYXkgc3R5bGUgZnJvbSBub25lIHRvIHZpc2libGVcbiAgICAgICAgaWYgKG1lLmRvbS5yb290Lm9mZnNldFdpZHRoICE9IG1lLnByb3BzLmxhc3RXaWR0aCB8fCBtZS5kb20ucm9vdC5vZmZzZXRIZWlnaHQgIT0gbWUucHJvcHMubGFzdEhlaWdodCkge1xuICAgICAgICAgIG1lLnByb3BzLmxhc3RXaWR0aCA9IG1lLmRvbS5yb290Lm9mZnNldFdpZHRoO1xuICAgICAgICAgIG1lLnByb3BzLmxhc3RIZWlnaHQgPSBtZS5kb20ucm9vdC5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgICBtZS5ib2R5LmVtaXR0ZXIuZW1pdCgnX2NoYW5nZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIGFkZCBldmVudCBsaXN0ZW5lciB0byB3aW5kb3cgcmVzaXplXG4gICAgdXRpbC5hZGRFdmVudExpc3RlbmVyKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplKTtcblxuICAgIC8vUHJldmVudCBpbml0aWFsIHVubmVjZXNzYXJ5IHJlZHJhd1xuICAgIGlmIChtZS5kb20ucm9vdCkge1xuICAgICAgbWUucHJvcHMubGFzdFdpZHRoID0gbWUuZG9tLnJvb3Qub2Zmc2V0V2lkdGg7XG4gICAgICBtZS5wcm9wcy5sYXN0SGVpZ2h0ID0gbWUuZG9tLnJvb3Qub2Zmc2V0SGVpZ2h0O1xuICAgIH1cblxuICAgIHRoaXMud2F0Y2hUaW1lciA9IHNldEludGVydmFsKHRoaXMuX29uUmVzaXplLCAxMDAwKTtcbiAgfTtcblxuICAvKipcbiAgICogU3RvcCB3YXRjaGluZyBmb3IgYSByZXNpemUgb2YgdGhlIGZyYW1lLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQ29yZS5wcm90b3R5cGUuX3N0b3BBdXRvUmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLndhdGNoVGltZXIpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy53YXRjaFRpbWVyKTtcbiAgICAgIHRoaXMud2F0Y2hUaW1lciA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgZXZlbnQgbGlzdGVuZXIgb24gd2luZG93LnJlc2l6ZVxuICAgIGlmICh0aGlzLl9vblJlc2l6ZSkge1xuICAgICAgdXRpbC5yZW1vdmVFdmVudExpc3RlbmVyKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplKTtcbiAgICAgIHRoaXMuX29uUmVzaXplID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0YXJ0IG1vdmluZyB0aGUgdGltZWxpbmUgdmVydGljYWxseVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQ29yZS5wcm90b3R5cGUuX29uVG91Y2ggPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB0aGlzLnRvdWNoLmFsbG93RHJhZ2dpbmcgPSB0cnVlO1xuICAgIHRoaXMudG91Y2guaW5pdGlhbFNjcm9sbFRvcCA9IHRoaXMucHJvcHMuc2Nyb2xsVG9wO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdGFydCBtb3ZpbmcgdGhlIHRpbWVsaW5lIHZlcnRpY2FsbHlcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIENvcmUucHJvdG90eXBlLl9vblBpbmNoID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdGhpcy50b3VjaC5hbGxvd0RyYWdnaW5nID0gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1vdmUgdGhlIHRpbWVsaW5lIHZlcnRpY2FsbHlcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIENvcmUucHJvdG90eXBlLl9vbkRyYWcgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyByZWZ1c2UgdG8gZHJhZyB3aGVuIHdlIHdoZXJlIHBpbmNoaW5nIHRvIHByZXZlbnQgdGhlIHRpbWVsaW5lIG1ha2UgYSBqdW1wXG4gICAgLy8gd2hlbiByZWxlYXNpbmcgdGhlIGZpbmdlcnMgaW4gb3Bwb3NpdGUgb3JkZXIgZnJvbSB0aGUgdG91Y2ggc2NyZWVuXG4gICAgaWYgKCF0aGlzLnRvdWNoLmFsbG93RHJhZ2dpbmcpIHJldHVybjtcblxuICAgIHZhciBkZWx0YSA9IGV2ZW50LmRlbHRhWTtcblxuICAgIHZhciBvbGRTY3JvbGxUb3AgPSB0aGlzLl9nZXRTY3JvbGxUb3AoKTtcbiAgICB2YXIgbmV3U2Nyb2xsVG9wID0gdGhpcy5fc2V0U2Nyb2xsVG9wKHRoaXMudG91Y2guaW5pdGlhbFNjcm9sbFRvcCArIGRlbHRhKTtcblxuICAgIGlmIChuZXdTY3JvbGxUb3AgIT0gb2xkU2Nyb2xsVG9wKSB7XG4gICAgICB0aGlzLmVtaXQoXCJ2ZXJ0aWNhbERyYWdcIik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBcHBseSBhIHNjcm9sbFRvcFxuICAgKiBAcGFyYW0ge051bWJlcn0gc2Nyb2xsVG9wXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHNjcm9sbFRvcCAgUmV0dXJucyB0aGUgYXBwbGllZCBzY3JvbGxUb3BcbiAgICogQHByaXZhdGVcbiAgICovXG4gIENvcmUucHJvdG90eXBlLl9zZXRTY3JvbGxUb3AgPSBmdW5jdGlvbiAoc2Nyb2xsVG9wKSB7XG4gICAgdGhpcy5wcm9wcy5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgdGhpcy5fdXBkYXRlU2Nyb2xsVG9wKCk7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMuc2Nyb2xsVG9wO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGN1cnJlbnQgc2Nyb2xsVG9wIHdoZW4gdGhlIGhlaWdodCBvZiAgdGhlIGNvbnRhaW5lcnMgaGFzIGJlZW4gY2hhbmdlZFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBzY3JvbGxUb3AgIFJldHVybnMgdGhlIGFwcGxpZWQgc2Nyb2xsVG9wXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBDb3JlLnByb3RvdHlwZS5fdXBkYXRlU2Nyb2xsVG9wID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHJlY2FsY3VsYXRlIHRoZSBzY3JvbGxUb3BNaW5cbiAgICB2YXIgc2Nyb2xsVG9wTWluID0gTWF0aC5taW4odGhpcy5wcm9wcy5jZW50ZXJDb250YWluZXIuaGVpZ2h0IC0gdGhpcy5wcm9wcy5jZW50ZXIuaGVpZ2h0LCAwKTsgLy8gaXMgbmVnYXRpdmUgb3IgemVyb1xuICAgIGlmIChzY3JvbGxUb3BNaW4gIT0gdGhpcy5wcm9wcy5zY3JvbGxUb3BNaW4pIHtcbiAgICAgIC8vIGluIGNhc2Ugb2YgYm90dG9tIG9yaWVudGF0aW9uLCBjaGFuZ2UgdGhlIHNjcm9sbFRvcCBzdWNoIHRoYXQgdGhlIGNvbnRlbnRzXG4gICAgICAvLyBkbyBub3QgbW92ZSByZWxhdGl2ZSB0byB0aGUgdGltZSBheGlzIGF0IHRoZSBib3R0b21cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uaXRlbSAhPSAndG9wJykge1xuICAgICAgICB0aGlzLnByb3BzLnNjcm9sbFRvcCArPSBzY3JvbGxUb3BNaW4gLSB0aGlzLnByb3BzLnNjcm9sbFRvcE1pbjtcbiAgICAgIH1cbiAgICAgIHRoaXMucHJvcHMuc2Nyb2xsVG9wTWluID0gc2Nyb2xsVG9wTWluO1xuICAgIH1cblxuICAgIC8vIGxpbWl0IHRoZSBzY3JvbGxUb3AgdG8gdGhlIGZlYXNpYmxlIHNjcm9sbCByYW5nZVxuICAgIGlmICh0aGlzLnByb3BzLnNjcm9sbFRvcCA+IDApIHRoaXMucHJvcHMuc2Nyb2xsVG9wID0gMDtcbiAgICBpZiAodGhpcy5wcm9wcy5zY3JvbGxUb3AgPCBzY3JvbGxUb3BNaW4pIHRoaXMucHJvcHMuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wTWluO1xuXG4gICAgcmV0dXJuIHRoaXMucHJvcHMuc2Nyb2xsVG9wO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgc2Nyb2xsVG9wXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IHNjcm9sbFRvcFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQ29yZS5wcm90b3R5cGUuX2dldFNjcm9sbFRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5zY3JvbGxUb3A7XG4gIH07XG5cbiAgLyoqXG4gICAqIExvYWQgYSBjb25maWd1cmF0b3JcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQ29yZS5wcm90b3R5cGUuX2NyZWF0ZUNvbmZpZ3VyYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZva2UgYWJzdHJhY3QgbWV0aG9kIF9jcmVhdGVDb25maWd1cmF0b3InKTtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IENvcmU7XG5cbi8qKiovIH0sXG4vKiAzNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG4gIHZhciBIYW1tZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcbiAgdmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuICB2YXIgRGF0YVNldCA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG4gIHZhciBEYXRhVmlldyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuICB2YXIgVGltZVN0ZXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KTtcbiAgdmFyIENvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xuICB2YXIgR3JvdXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KTtcbiAgdmFyIEJhY2tncm91bmRHcm91cCA9IF9fd2VicGFja19yZXF1aXJlX18oNDApO1xuICB2YXIgQm94SXRlbSA9IF9fd2VicGFja19yZXF1aXJlX18oNDEpO1xuICB2YXIgUG9pbnRJdGVtID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mik7XG4gIHZhciBSYW5nZUl0ZW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KTtcbiAgdmFyIEJhY2tncm91bmRJdGVtID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Myk7XG5cbiAgdmFyIFVOR1JPVVBFRCA9ICdfX3VuZ3JvdXBlZF9fJzsgLy8gcmVzZXJ2ZWQgZ3JvdXAgaWQgZm9yIHVuZ3JvdXBlZCBpdGVtc1xuICB2YXIgQkFDS0dST1VORCA9ICdfX2JhY2tncm91bmRfXyc7IC8vIHJlc2VydmVkIGdyb3VwIGlkIGZvciBiYWNrZ3JvdW5kIGl0ZW1zIHdpdGhvdXQgZ3JvdXBcblxuICAvKipcbiAgICogQW4gSXRlbVNldCBob2xkcyBhIHNldCBvZiBpdGVtcyBhbmQgcmFuZ2VzIHdoaWNoIGNhbiBiZSBkaXNwbGF5ZWQgaW4gYVxuICAgKiByYW5nZS4gVGhlIHdpZHRoIGlzIGRldGVybWluZWQgYnkgdGhlIHBhcmVudCBvZiB0aGUgSXRlbVNldCwgYW5kIHRoZSBoZWlnaHRcbiAgICogaXMgZGV0ZXJtaW5lZCBieSB0aGUgc2l6ZSBvZiB0aGUgaXRlbXMuXG4gICAqIEBwYXJhbSB7e2RvbTogT2JqZWN0LCBkb21Qcm9wczogT2JqZWN0LCBlbWl0dGVyOiBFbWl0dGVyLCByYW5nZTogUmFuZ2V9fSBib2R5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgICBTZWUgSXRlbVNldC5zZXRPcHRpb25zIGZvciB0aGUgYXZhaWxhYmxlIG9wdGlvbnMuXG4gICAqIEBjb25zdHJ1Y3RvciBJdGVtU2V0XG4gICAqIEBleHRlbmRzIENvbXBvbmVudFxuICAgKi9cbiAgZnVuY3Rpb24gSXRlbVNldChib2R5LCBvcHRpb25zKSB7XG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgcnRsOiBmYWxzZSxcbiAgICAgIHR5cGU6IG51bGwsIC8vICdib3gnLCAncG9pbnQnLCAncmFuZ2UnLCAnYmFja2dyb3VuZCdcbiAgICAgIG9yaWVudGF0aW9uOiB7XG4gICAgICAgIGl0ZW06ICdib3R0b20nIC8vIGl0ZW0gb3JpZW50YXRpb246ICd0b3AnIG9yICdib3R0b20nXG4gICAgICB9LFxuICAgICAgYWxpZ246ICdhdXRvJywgLy8gYWxpZ25tZW50IG9mIGJveCBpdGVtc1xuICAgICAgc3RhY2s6IHRydWUsXG4gICAgICBncm91cE9yZGVyU3dhcDogZnVuY3Rpb24gZ3JvdXBPcmRlclN3YXAoZnJvbUdyb3VwLCB0b0dyb3VwLCBncm91cHMpIHtcbiAgICAgICAgdmFyIHRhcmdldE9yZGVyID0gdG9Hcm91cC5vcmRlcjtcbiAgICAgICAgdG9Hcm91cC5vcmRlciA9IGZyb21Hcm91cC5vcmRlcjtcbiAgICAgICAgZnJvbUdyb3VwLm9yZGVyID0gdGFyZ2V0T3JkZXI7XG4gICAgICB9LFxuICAgICAgZ3JvdXBPcmRlcjogJ29yZGVyJyxcblxuICAgICAgc2VsZWN0YWJsZTogdHJ1ZSxcbiAgICAgIG11bHRpc2VsZWN0OiBmYWxzZSxcbiAgICAgIGl0ZW1zQWx3YXlzRHJhZ2dhYmxlOiBmYWxzZSxcblxuICAgICAgZWRpdGFibGU6IHtcbiAgICAgICAgdXBkYXRlVGltZTogZmFsc2UsXG4gICAgICAgIHVwZGF0ZUdyb3VwOiBmYWxzZSxcbiAgICAgICAgYWRkOiBmYWxzZSxcbiAgICAgICAgcmVtb3ZlOiBmYWxzZVxuICAgICAgfSxcblxuICAgICAgZ3JvdXBFZGl0YWJsZToge1xuICAgICAgICBvcmRlcjogZmFsc2UsXG4gICAgICAgIGFkZDogZmFsc2UsXG4gICAgICAgIHJlbW92ZTogZmFsc2VcbiAgICAgIH0sXG5cbiAgICAgIHNuYXA6IFRpbWVTdGVwLnNuYXAsXG5cbiAgICAgIG9uQWRkOiBmdW5jdGlvbiBvbkFkZChpdGVtLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayhpdGVtKTtcbiAgICAgIH0sXG4gICAgICBvblVwZGF0ZTogZnVuY3Rpb24gb25VcGRhdGUoaXRlbSwgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soaXRlbSk7XG4gICAgICB9LFxuICAgICAgb25Nb3ZlOiBmdW5jdGlvbiBvbk1vdmUoaXRlbSwgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soaXRlbSk7XG4gICAgICB9LFxuICAgICAgb25SZW1vdmU6IGZ1bmN0aW9uIG9uUmVtb3ZlKGl0ZW0sIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKGl0ZW0pO1xuICAgICAgfSxcbiAgICAgIG9uTW92aW5nOiBmdW5jdGlvbiBvbk1vdmluZyhpdGVtLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayhpdGVtKTtcbiAgICAgIH0sXG4gICAgICBvbkFkZEdyb3VwOiBmdW5jdGlvbiBvbkFkZEdyb3VwKGl0ZW0sIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKGl0ZW0pO1xuICAgICAgfSxcbiAgICAgIG9uTW92ZUdyb3VwOiBmdW5jdGlvbiBvbk1vdmVHcm91cChpdGVtLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayhpdGVtKTtcbiAgICAgIH0sXG4gICAgICBvblJlbW92ZUdyb3VwOiBmdW5jdGlvbiBvblJlbW92ZUdyb3VwKGl0ZW0sIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKGl0ZW0pO1xuICAgICAgfSxcblxuICAgICAgbWFyZ2luOiB7XG4gICAgICAgIGl0ZW06IHtcbiAgICAgICAgICBob3Jpem9udGFsOiAxMCxcbiAgICAgICAgICB2ZXJ0aWNhbDogMTBcbiAgICAgICAgfSxcbiAgICAgICAgYXhpczogMjBcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gb3B0aW9ucyBpcyBzaGFyZWQgYnkgdGhpcyBJdGVtU2V0IGFuZCBhbGwgaXRzIGl0ZW1zXG4gICAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoe30sIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gICAgLy8gb3B0aW9ucyBmb3IgZ2V0dGluZyBpdGVtcyBmcm9tIHRoZSBEYXRhU2V0IHdpdGggdGhlIGNvcnJlY3QgdHlwZVxuICAgIHRoaXMuaXRlbU9wdGlvbnMgPSB7XG4gICAgICB0eXBlOiB7IHN0YXJ0OiAnRGF0ZScsIGVuZDogJ0RhdGUnIH1cbiAgICB9O1xuXG4gICAgdGhpcy5jb252ZXJzaW9uID0ge1xuICAgICAgdG9TY3JlZW46IGJvZHkudXRpbC50b1NjcmVlbixcbiAgICAgIHRvVGltZTogYm9keS51dGlsLnRvVGltZVxuICAgIH07XG4gICAgdGhpcy5kb20gPSB7fTtcbiAgICB0aGlzLnByb3BzID0ge307XG4gICAgdGhpcy5oYW1tZXIgPSBudWxsO1xuXG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB0aGlzLml0ZW1zRGF0YSA9IG51bGw7IC8vIERhdGFTZXRcbiAgICB0aGlzLmdyb3Vwc0RhdGEgPSBudWxsOyAvLyBEYXRhU2V0XG5cbiAgICAvLyBsaXN0ZW5lcnMgZm9yIHRoZSBEYXRhU2V0IG9mIHRoZSBpdGVtc1xuICAgIHRoaXMuaXRlbUxpc3RlbmVycyA9IHtcbiAgICAgICdhZGQnOiBmdW5jdGlvbiBhZGQoZXZlbnQsIHBhcmFtcywgc2VuZGVySWQpIHtcbiAgICAgICAgbWUuX29uQWRkKHBhcmFtcy5pdGVtcyk7XG4gICAgICB9LFxuICAgICAgJ3VwZGF0ZSc6IGZ1bmN0aW9uIHVwZGF0ZShldmVudCwgcGFyYW1zLCBzZW5kZXJJZCkge1xuICAgICAgICBtZS5fb25VcGRhdGUocGFyYW1zLml0ZW1zKTtcbiAgICAgIH0sXG4gICAgICAncmVtb3ZlJzogZnVuY3Rpb24gcmVtb3ZlKGV2ZW50LCBwYXJhbXMsIHNlbmRlcklkKSB7XG4gICAgICAgIG1lLl9vblJlbW92ZShwYXJhbXMuaXRlbXMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBsaXN0ZW5lcnMgZm9yIHRoZSBEYXRhU2V0IG9mIHRoZSBncm91cHNcbiAgICB0aGlzLmdyb3VwTGlzdGVuZXJzID0ge1xuICAgICAgJ2FkZCc6IGZ1bmN0aW9uIGFkZChldmVudCwgcGFyYW1zLCBzZW5kZXJJZCkge1xuICAgICAgICBtZS5fb25BZGRHcm91cHMocGFyYW1zLml0ZW1zKTtcbiAgICAgIH0sXG4gICAgICAndXBkYXRlJzogZnVuY3Rpb24gdXBkYXRlKGV2ZW50LCBwYXJhbXMsIHNlbmRlcklkKSB7XG4gICAgICAgIG1lLl9vblVwZGF0ZUdyb3VwcyhwYXJhbXMuaXRlbXMpO1xuICAgICAgfSxcbiAgICAgICdyZW1vdmUnOiBmdW5jdGlvbiByZW1vdmUoZXZlbnQsIHBhcmFtcywgc2VuZGVySWQpIHtcbiAgICAgICAgbWUuX29uUmVtb3ZlR3JvdXBzKHBhcmFtcy5pdGVtcyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuaXRlbXMgPSB7fTsgLy8gb2JqZWN0IHdpdGggYW4gSXRlbSBmb3IgZXZlcnkgZGF0YSBpdGVtXG4gICAgdGhpcy5ncm91cHMgPSB7fTsgLy8gR3JvdXAgb2JqZWN0IGZvciBldmVyeSBncm91cFxuICAgIHRoaXMuZ3JvdXBJZHMgPSBbXTtcblxuICAgIHRoaXMuc2VsZWN0aW9uID0gW107IC8vIGxpc3Qgd2l0aCB0aGUgaWRzIG9mIGFsbCBzZWxlY3RlZCBub2Rlc1xuICAgIHRoaXMuc3RhY2tEaXJ0eSA9IHRydWU7IC8vIGlmIHRydWUsIGFsbCBpdGVtcyB3aWxsIGJlIHJlc3RhY2tlZCBvbiBuZXh0IHJlZHJhd1xuXG4gICAgdGhpcy50b3VjaFBhcmFtcyA9IHt9OyAvLyBzdG9yZXMgcHJvcGVydGllcyB3aGlsZSBkcmFnZ2luZ1xuICAgIHRoaXMuZ3JvdXBUb3VjaFBhcmFtcyA9IHt9O1xuICAgIC8vIGNyZWF0ZSB0aGUgSFRNTCBET01cblxuICAgIHRoaXMuX2NyZWF0ZSgpO1xuXG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG5cbiAgSXRlbVNldC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50KCk7XG5cbiAgLy8gYXZhaWxhYmxlIGl0ZW0gdHlwZXMgd2lsbCBiZSByZWdpc3RlcmVkIGhlcmVcbiAgSXRlbVNldC50eXBlcyA9IHtcbiAgICBiYWNrZ3JvdW5kOiBCYWNrZ3JvdW5kSXRlbSxcbiAgICBib3g6IEJveEl0ZW0sXG4gICAgcmFuZ2U6IFJhbmdlSXRlbSxcbiAgICBwb2ludDogUG9pbnRJdGVtXG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgSFRNTCBET00gZm9yIHRoZSBJdGVtU2V0XG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGZyYW1lLmNsYXNzTmFtZSA9ICd2aXMtaXRlbXNldCc7XG4gICAgZnJhbWVbJ3RpbWVsaW5lLWl0ZW1zZXQnXSA9IHRoaXM7XG4gICAgdGhpcy5kb20uZnJhbWUgPSBmcmFtZTtcblxuICAgIC8vIGNyZWF0ZSBiYWNrZ3JvdW5kIHBhbmVsXG4gICAgdmFyIGJhY2tncm91bmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBiYWNrZ3JvdW5kLmNsYXNzTmFtZSA9ICd2aXMtYmFja2dyb3VuZCc7XG4gICAgZnJhbWUuYXBwZW5kQ2hpbGQoYmFja2dyb3VuZCk7XG4gICAgdGhpcy5kb20uYmFja2dyb3VuZCA9IGJhY2tncm91bmQ7XG5cbiAgICAvLyBjcmVhdGUgZm9yZWdyb3VuZCBwYW5lbFxuICAgIHZhciBmb3JlZ3JvdW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZm9yZWdyb3VuZC5jbGFzc05hbWUgPSAndmlzLWZvcmVncm91bmQnO1xuICAgIGZyYW1lLmFwcGVuZENoaWxkKGZvcmVncm91bmQpO1xuICAgIHRoaXMuZG9tLmZvcmVncm91bmQgPSBmb3JlZ3JvdW5kO1xuXG4gICAgLy8gY3JlYXRlIGF4aXMgcGFuZWxcbiAgICB2YXIgYXhpcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGF4aXMuY2xhc3NOYW1lID0gJ3Zpcy1heGlzJztcbiAgICB0aGlzLmRvbS5heGlzID0gYXhpcztcblxuICAgIC8vIGNyZWF0ZSBsYWJlbHNldFxuICAgIHZhciBsYWJlbFNldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGxhYmVsU2V0LmNsYXNzTmFtZSA9ICd2aXMtbGFiZWxzZXQnO1xuICAgIHRoaXMuZG9tLmxhYmVsU2V0ID0gbGFiZWxTZXQ7XG5cbiAgICAvLyBjcmVhdGUgdW5ncm91cGVkIEdyb3VwXG4gICAgdGhpcy5fdXBkYXRlVW5ncm91cGVkKCk7XG5cbiAgICAvLyBjcmVhdGUgYmFja2dyb3VuZCBHcm91cFxuICAgIHZhciBiYWNrZ3JvdW5kR3JvdXAgPSBuZXcgQmFja2dyb3VuZEdyb3VwKEJBQ0tHUk9VTkQsIG51bGwsIHRoaXMpO1xuICAgIGJhY2tncm91bmRHcm91cC5zaG93KCk7XG4gICAgdGhpcy5ncm91cHNbQkFDS0dST1VORF0gPSBiYWNrZ3JvdW5kR3JvdXA7XG5cbiAgICAvLyBhdHRhY2ggZXZlbnQgbGlzdGVuZXJzXG4gICAgLy8gTm90ZTogd2UgYmluZCB0byB0aGUgY2VudGVyQ29udGFpbmVyIGZvciB0aGUgY2FzZSB3aGVyZSB0aGUgaGVpZ2h0XG4gICAgLy8gICAgICAgb2YgdGhlIGNlbnRlciBjb250YWluZXIgaXMgbGFyZ2VyIHRoYW4gb2YgdGhlIEl0ZW1TZXQsIHNvIHdlXG4gICAgLy8gICAgICAgY2FuIGNsaWNrIGluIHRoZSBlbXB0eSBhcmVhIHRvIGNyZWF0ZSBhIG5ldyBpdGVtIG9yIGRlc2VsZWN0IGFuIGl0ZW0uXG4gICAgdGhpcy5oYW1tZXIgPSBuZXcgSGFtbWVyKHRoaXMuYm9keS5kb20uY2VudGVyQ29udGFpbmVyKTtcblxuICAgIC8vIGRyYWcgaXRlbXMgd2hlbiBzZWxlY3RlZFxuICAgIHRoaXMuaGFtbWVyLm9uKCdoYW1tZXIuaW5wdXQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5pc0ZpcnN0KSB7XG4gICAgICAgIHRoaXMuX29uVG91Y2goZXZlbnQpO1xuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5oYW1tZXIub24oJ3BhbnN0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5oYW1tZXIub24oJ3Bhbm1vdmUnLCB0aGlzLl9vbkRyYWcuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5oYW1tZXIub24oJ3BhbmVuZCcsIHRoaXMuX29uRHJhZ0VuZC5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmhhbW1lci5nZXQoJ3BhbicpLnNldCh7IHRocmVzaG9sZDogNSwgZGlyZWN0aW9uOiBIYW1tZXIuRElSRUNUSU9OX0hPUklaT05UQUwgfSk7XG5cbiAgICAvLyBzaW5nbGUgc2VsZWN0IChvciB1bnNlbGVjdCkgd2hlbiB0YXBwaW5nIGFuIGl0ZW1cbiAgICB0aGlzLmhhbW1lci5vbigndGFwJywgdGhpcy5fb25TZWxlY3RJdGVtLmJpbmQodGhpcykpO1xuXG4gICAgLy8gbXVsdGkgc2VsZWN0IHdoZW4gaG9sZGluZyBtb3VzZS90b3VjaCwgb3Igb24gY3RybCtjbGlja1xuICAgIHRoaXMuaGFtbWVyLm9uKCdwcmVzcycsIHRoaXMuX29uTXVsdGlTZWxlY3RJdGVtLmJpbmQodGhpcykpO1xuXG4gICAgLy8gYWRkIGl0ZW0gb24gZG91YmxldGFwXG4gICAgdGhpcy5oYW1tZXIub24oJ2RvdWJsZXRhcCcsIHRoaXMuX29uQWRkSXRlbS5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmdyb3VwSGFtbWVyID0gbmV3IEhhbW1lcih0aGlzLmJvZHkuZG9tLmxlZnRDb250YWluZXIpO1xuXG4gICAgdGhpcy5ncm91cEhhbW1lci5vbigncGFuc3RhcnQnLCB0aGlzLl9vbkdyb3VwRHJhZ1N0YXJ0LmJpbmQodGhpcykpO1xuICAgIHRoaXMuZ3JvdXBIYW1tZXIub24oJ3Bhbm1vdmUnLCB0aGlzLl9vbkdyb3VwRHJhZy5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmdyb3VwSGFtbWVyLm9uKCdwYW5lbmQnLCB0aGlzLl9vbkdyb3VwRHJhZ0VuZC5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmdyb3VwSGFtbWVyLmdldCgncGFuJykuc2V0KHsgdGhyZXNob2xkOiA1LCBkaXJlY3Rpb246IEhhbW1lci5ESVJFQ1RJT05fSE9SSVpPTlRBTCB9KTtcblxuICAgIC8vIGF0dGFjaCB0byB0aGUgRE9NXG4gICAgdGhpcy5zaG93KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBvcHRpb25zIGZvciB0aGUgSXRlbVNldC4gRXhpc3Rpbmcgb3B0aW9ucyB3aWxsIGJlIGV4dGVuZGVkL292ZXJ3cml0dGVuLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBmb2xsb3dpbmcgb3B0aW9ucyBhcmUgYXZhaWxhYmxlOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmd9IHR5cGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IHR5cGUgZm9yIHRoZSBpdGVtcy4gQ2hvb3NlIGZyb20gJ2JveCdcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZGVmYXVsdCksICdwb2ludCcsICdyYW5nZScsIG9yICdiYWNrZ3JvdW5kJy5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZGVmYXVsdCBzdHlsZSBjYW4gYmUgb3ZlcndyaXR0ZW4gYnlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRpdmlkdWFsIGl0ZW1zLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmd9IGFsaWduXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQWxpZ25tZW50IGZvciB0aGUgaXRlbXMsIG9ubHkgYXBwbGljYWJsZSBmb3JcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBCb3hJdGVtLiBDaG9vc2UgJ2NlbnRlcicgKGRlZmF1bHQpLCAnbGVmdCcsIG9yXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JpZ2h0Jy5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nfSBvcmllbnRhdGlvbi5pdGVtXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT3JpZW50YXRpb24gb2YgdGhlIGl0ZW0gc2V0LiBDaG9vc2UgJ3RvcCcgb3JcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYm90dG9tJyAoZGVmYXVsdCkuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAge0Z1bmN0aW9ufSBncm91cE9yZGVyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQSBzb3J0aW5nIGZ1bmN0aW9uIGZvciBvcmRlcmluZyBncm91cHNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB7Qm9vbGVhbn0gc3RhY2tcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiB0cnVlIChkZWZhdWx0KSwgaXRlbXMgd2lsbCBiZSBzdGFja2VkIG9uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wIG9mIGVhY2ggb3RoZXIuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAge051bWJlcn0gbWFyZ2luLmF4aXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXJnaW4gYmV0d2VlbiB0aGUgYXhpcyBhbmQgdGhlIGl0ZW1zIGluIHBpeGVscy5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IGlzIDIwLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtOdW1iZXJ9IG1hcmdpbi5pdGVtLmhvcml6b250YWxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBIb3Jpem9udGFsIG1hcmdpbiBiZXR3ZWVuIGl0ZW1zIGluIHBpeGVscy5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IGlzIDEwLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtOdW1iZXJ9IG1hcmdpbi5pdGVtLnZlcnRpY2FsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVmVydGljYWwgTWFyZ2luIGJldHdlZW4gaXRlbXMgaW4gcGl4ZWxzLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgaXMgMTAuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAge051bWJlcn0gbWFyZ2luLml0ZW1cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXJnaW4gYmV0d2VlbiBpdGVtcyBpbiBwaXhlbHMgaW4gYm90aCBob3Jpem9udGFsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIHZlcnRpY2FsIGRpcmVjdGlvbi4gRGVmYXVsdCBpcyAxMC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyfSBtYXJnaW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXQgbWFyZ2luIGZvciBib3RoIGF4aXMgYW5kIGl0ZW1zIGluIHBpeGVscy5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB7Qm9vbGVhbn0gc2VsZWN0YWJsZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHRydWUgKGRlZmF1bHQpLCBpdGVtcyBjYW4gYmUgc2VsZWN0ZWQuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAge0Jvb2xlYW59IG11bHRpc2VsZWN0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgdHJ1ZSwgbXVsdGlwbGUgaXRlbXMgY2FuIGJlIHNlbGVjdGVkLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZhbHNlIGJ5IGRlZmF1bHQuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAge0Jvb2xlYW59IGVkaXRhYmxlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2V0IGFsbCBlZGl0YWJsZSBvcHRpb25zIHRvIHRydWUgb3IgZmFsc2VcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB7Qm9vbGVhbn0gZWRpdGFibGUudXBkYXRlVGltZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFsbG93IGRyYWdnaW5nIGFuIGl0ZW0gdG8gYW4gb3RoZXIgbW9tZW50IGluIHRpbWVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB7Qm9vbGVhbn0gZWRpdGFibGUudXBkYXRlR3JvdXBcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbGxvdyBkcmFnZ2luZyBhbiBpdGVtIHRvIGFuIG90aGVyIGdyb3VwXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAge0Jvb2xlYW59IGVkaXRhYmxlLmFkZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFsbG93IGNyZWF0aW5nIG5ldyBpdGVtcyBvbiBkb3VibGUgdGFwXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAge0Jvb2xlYW59IGVkaXRhYmxlLnJlbW92ZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFsbG93IHJlbW92aW5nIGl0ZW1zIGJ5IGNsaWNraW5nIHRoZSBkZWxldGUgYnV0dG9uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wIHJpZ2h0IG9mIGEgc2VsZWN0ZWQgaXRlbS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB7RnVuY3Rpb24oaXRlbTogSXRlbSwgY2FsbGJhY2s6IEZ1bmN0aW9uKX0gb25BZGRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDYWxsYmFjayBmdW5jdGlvbiB0cmlnZ2VyZWQgd2hlbiBhbiBpdGVtIGlzIGFib3V0IHRvIGJlIGFkZGVkOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZW4gdGhlIHVzZXIgZG91YmxlIHRhcHMgYW4gZW1wdHkgc3BhY2UgaW4gdGhlIFRpbWVsaW5lLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtGdW5jdGlvbihpdGVtOiBJdGVtLCBjYWxsYmFjazogRnVuY3Rpb24pfSBvblVwZGF0ZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENhbGxiYWNrIGZ1bmN0aW9uIGZpcmVkIHdoZW4gYW4gaXRlbSBpcyBhYm91dCB0byBiZSB1cGRhdGVkLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoaXMgZnVuY3Rpb24gdHlwaWNhbGx5IGhhcyB0byBzaG93IGEgZGlhbG9nIHdoZXJlIHRoZSB1c2VyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlIHRoZSBpdGVtLiBJZiBub3QgaW1wbGVtZW50ZWQsIG5vdGhpbmcgaGFwcGVucy5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB7RnVuY3Rpb24oaXRlbTogSXRlbSwgY2FsbGJhY2s6IEZ1bmN0aW9uKX0gb25Nb3ZlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRmlyZWQgd2hlbiBhbiBpdGVtIGhhcyBiZWVuIG1vdmVkLiBJZiBub3QgaW1wbGVtZW50ZWQsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG1vdmUgYWN0aW9uIHdpbGwgYmUgYWNjZXB0ZWQuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAge0Z1bmN0aW9uKGl0ZW06IEl0ZW0sIGNhbGxiYWNrOiBGdW5jdGlvbil9IG9uUmVtb3ZlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRmlyZWQgd2hlbiBhbiBpdGVtIGlzIGFib3V0IHRvIGJlIGRlbGV0ZWQuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgbm90IGltcGxlbWVudGVkLCB0aGUgaXRlbSB3aWxsIGJlIGFsd2F5cyByZW1vdmVkLlxuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIC8vIGNvcHkgYWxsIG9wdGlvbnMgdGhhdCB3ZSBrbm93XG4gICAgICB2YXIgZmllbGRzID0gWyd0eXBlJywgJ3J0bCcsICdhbGlnbicsICdvcmRlcicsICdzdGFjaycsICdzZWxlY3RhYmxlJywgJ211bHRpc2VsZWN0JywgJ2l0ZW1zQWx3YXlzRHJhZ2dhYmxlJywgJ211bHRpc2VsZWN0UGVyR3JvdXAnLCAnZ3JvdXBPcmRlcicsICdkYXRhQXR0cmlidXRlcycsICd0ZW1wbGF0ZScsICdncm91cFRlbXBsYXRlJywgJ2hpZGUnLCAnc25hcCcsICdncm91cE9yZGVyU3dhcCddO1xuICAgICAgdXRpbC5zZWxlY3RpdmVFeHRlbmQoZmllbGRzLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICBpZiAoJ29yaWVudGF0aW9uJyBpbiBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5vcmllbnRhdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uaXRlbSA9IG9wdGlvbnMub3JpZW50YXRpb24gPT09ICd0b3AnID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKG9wdGlvbnMub3JpZW50YXRpb24pID09PSAnb2JqZWN0JyAmJiAnaXRlbScgaW4gb3B0aW9ucy5vcmllbnRhdGlvbikge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5pdGVtID0gb3B0aW9ucy5vcmllbnRhdGlvbi5pdGVtO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICgnbWFyZ2luJyBpbiBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5tYXJnaW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLm1hcmdpbi5heGlzID0gb3B0aW9ucy5tYXJnaW47XG4gICAgICAgICAgdGhpcy5vcHRpb25zLm1hcmdpbi5pdGVtLmhvcml6b250YWwgPSBvcHRpb25zLm1hcmdpbjtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMubWFyZ2luLml0ZW0udmVydGljYWwgPSBvcHRpb25zLm1hcmdpbjtcbiAgICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKG9wdGlvbnMubWFyZ2luKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB1dGlsLnNlbGVjdGl2ZUV4dGVuZChbJ2F4aXMnXSwgdGhpcy5vcHRpb25zLm1hcmdpbiwgb3B0aW9ucy5tYXJnaW4pO1xuICAgICAgICAgIGlmICgnaXRlbScgaW4gb3B0aW9ucy5tYXJnaW4pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5tYXJnaW4uaXRlbSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLm1hcmdpbi5pdGVtLmhvcml6b250YWwgPSBvcHRpb25zLm1hcmdpbi5pdGVtO1xuICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMubWFyZ2luLml0ZW0udmVydGljYWwgPSBvcHRpb25zLm1hcmdpbi5pdGVtO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKG9wdGlvbnMubWFyZ2luLml0ZW0pID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICB1dGlsLnNlbGVjdGl2ZUV4dGVuZChbJ2hvcml6b250YWwnLCAndmVydGljYWwnXSwgdGhpcy5vcHRpb25zLm1hcmdpbi5pdGVtLCBvcHRpb25zLm1hcmdpbi5pdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCdlZGl0YWJsZScgaW4gb3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZWRpdGFibGUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5lZGl0YWJsZS51cGRhdGVUaW1lID0gb3B0aW9ucy5lZGl0YWJsZTtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZWRpdGFibGUudXBkYXRlR3JvdXAgPSBvcHRpb25zLmVkaXRhYmxlO1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5lZGl0YWJsZS5hZGQgPSBvcHRpb25zLmVkaXRhYmxlO1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5lZGl0YWJsZS5yZW1vdmUgPSBvcHRpb25zLmVkaXRhYmxlO1xuICAgICAgICB9IGVsc2UgaWYgKF90eXBlb2Yob3B0aW9ucy5lZGl0YWJsZSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdXRpbC5zZWxlY3RpdmVFeHRlbmQoWyd1cGRhdGVUaW1lJywgJ3VwZGF0ZUdyb3VwJywgJ2FkZCcsICdyZW1vdmUnXSwgdGhpcy5vcHRpb25zLmVkaXRhYmxlLCBvcHRpb25zLmVkaXRhYmxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoJ2dyb3VwRWRpdGFibGUnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmdyb3VwRWRpdGFibGUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5ncm91cEVkaXRhYmxlLm9yZGVyID0gb3B0aW9ucy5ncm91cEVkaXRhYmxlO1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5ncm91cEVkaXRhYmxlLmFkZCA9IG9wdGlvbnMuZ3JvdXBFZGl0YWJsZTtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZ3JvdXBFZGl0YWJsZS5yZW1vdmUgPSBvcHRpb25zLmdyb3VwRWRpdGFibGU7XG4gICAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihvcHRpb25zLmdyb3VwRWRpdGFibGUpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHV0aWwuc2VsZWN0aXZlRXh0ZW5kKFsnb3JkZXInLCAnYWRkJywgJ3JlbW92ZSddLCB0aGlzLm9wdGlvbnMuZ3JvdXBFZGl0YWJsZSwgb3B0aW9ucy5ncm91cEVkaXRhYmxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBjYWxsYmFjayBmdW5jdGlvbnNcbiAgICAgIHZhciBhZGRDYWxsYmFjayA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBmbiA9IG9wdGlvbnNbbmFtZV07XG4gICAgICAgIGlmIChmbikge1xuICAgICAgICAgIGlmICghKGZuIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbiAnICsgbmFtZSArICcgbXVzdCBiZSBhIGZ1bmN0aW9uICcgKyBuYW1lICsgJyhpdGVtLCBjYWxsYmFjayknKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5vcHRpb25zW25hbWVdID0gZm47XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKTtcbiAgICAgIFsnb25BZGQnLCAnb25VcGRhdGUnLCAnb25SZW1vdmUnLCAnb25Nb3ZlJywgJ29uTW92aW5nJywgJ29uQWRkR3JvdXAnLCAnb25Nb3ZlR3JvdXAnLCAnb25SZW1vdmVHcm91cCddLmZvckVhY2goYWRkQ2FsbGJhY2spO1xuXG4gICAgICAvLyBmb3JjZSB0aGUgaXRlbVNldCB0byByZWZyZXNoOiBvcHRpb25zIGxpa2Ugb3JpZW50YXRpb24gYW5kIG1hcmdpbnMgbWF5IGJlIGNoYW5nZWRcbiAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBNYXJrIHRoZSBJdGVtU2V0IGRpcnR5IHNvIGl0IHdpbGwgcmVmcmVzaCBldmVyeXRoaW5nIHdpdGggbmV4dCByZWRyYXcuXG4gICAqIE9wdGlvbmFsbHksIGFsbCBpdGVtcyBjYW4gYmUgbWFya2VkIGFzIGRpcnR5IGFuZCBiZSByZWZyZXNoZWQuXG4gICAqIEBwYXJhbSB7e3JlZnJlc2hJdGVtczogYm9vbGVhbn19IFtvcHRpb25zXVxuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUubWFya0RpcnR5ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLmdyb3VwSWRzID0gW107XG4gICAgdGhpcy5zdGFja0RpcnR5ID0gdHJ1ZTtcblxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVmcmVzaEl0ZW1zKSB7XG4gICAgICB1dGlsLmZvckVhY2godGhpcy5pdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaXRlbS5kaXJ0eSA9IHRydWU7XG4gICAgICAgIGlmIChpdGVtLmRpc3BsYXllZCkgaXRlbS5yZWRyYXcoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRGVzdHJveSB0aGUgSXRlbVNldFxuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmhpZGUoKTtcbiAgICB0aGlzLnNldEl0ZW1zKG51bGwpO1xuICAgIHRoaXMuc2V0R3JvdXBzKG51bGwpO1xuXG4gICAgdGhpcy5oYW1tZXIgPSBudWxsO1xuXG4gICAgdGhpcy5ib2R5ID0gbnVsbDtcbiAgICB0aGlzLmNvbnZlcnNpb24gPSBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIaWRlIHRoZSBjb21wb25lbnQgZnJvbSB0aGUgRE9NXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHJlbW92ZSB0aGUgZnJhbWUgY29udGFpbmluZyB0aGUgaXRlbXNcbiAgICBpZiAodGhpcy5kb20uZnJhbWUucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5kb20uZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbS5mcmFtZSk7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIHRoZSBheGlzIHdpdGggZG90c1xuICAgIGlmICh0aGlzLmRvbS5heGlzLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuZG9tLmF4aXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbS5heGlzKTtcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgdGhlIGxhYmVsc2V0IGNvbnRhaW5pbmcgYWxsIGdyb3VwIGxhYmVsc1xuICAgIGlmICh0aGlzLmRvbS5sYWJlbFNldC5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLmRvbS5sYWJlbFNldC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLmxhYmVsU2V0KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNob3cgdGhlIGNvbXBvbmVudCBpbiB0aGUgRE9NICh3aGVuIG5vdCBhbHJlYWR5IHZpc2libGUpLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBjaGFuZ2VkXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHNob3cgZnJhbWUgY29udGFpbmluZyB0aGUgaXRlbXNcbiAgICBpZiAoIXRoaXMuZG9tLmZyYW1lLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuYm9keS5kb20uY2VudGVyLmFwcGVuZENoaWxkKHRoaXMuZG9tLmZyYW1lKTtcbiAgICB9XG5cbiAgICAvLyBzaG93IGF4aXMgd2l0aCBkb3RzXG4gICAgaWYgKCF0aGlzLmRvbS5heGlzLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuYm9keS5kb20uYmFja2dyb3VuZFZlcnRpY2FsLmFwcGVuZENoaWxkKHRoaXMuZG9tLmF4aXMpO1xuICAgIH1cblxuICAgIC8vIHNob3cgbGFiZWxzZXQgY29udGFpbmluZyBsYWJlbHNcbiAgICBpZiAoIXRoaXMuZG9tLmxhYmVsU2V0LnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuYm9keS5kb20ubGVmdC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5sYWJlbFNldCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgc2VsZWN0ZWQgaXRlbXMgYnkgdGhlaXIgaWQuIFJlcGxhY2VzIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuICAgKiBVbmtub3duIGlkJ3MgYXJlIHNpbGVudGx5IGlnbm9yZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nW10gfCBzdHJpbmd9IFtpZHNdIEFuIGFycmF5IHdpdGggemVybyBvciBtb3JlIGlkJ3Mgb2YgdGhlIGl0ZW1zIHRvIGJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkLCBvciBhIHNpbmdsZSBpdGVtIGlkLiBJZiBpZHMgaXMgdW5kZWZpbmVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGFuIGVtcHR5IGFycmF5LCBhbGwgaXRlbXMgd2lsbCBiZSB1bnNlbGVjdGVkLlxuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUuc2V0U2VsZWN0aW9uID0gZnVuY3Rpb24gKGlkcykge1xuICAgIHZhciBpLCBpaSwgaWQsIGl0ZW07XG5cbiAgICBpZiAoaWRzID09IHVuZGVmaW5lZCkgaWRzID0gW107XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGlkcykpIGlkcyA9IFtpZHNdO1xuXG4gICAgLy8gdW5zZWxlY3QgY3VycmVudGx5IHNlbGVjdGVkIGl0ZW1zXG4gICAgZm9yIChpID0gMCwgaWkgPSB0aGlzLnNlbGVjdGlvbi5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBpZCA9IHRoaXMuc2VsZWN0aW9uW2ldO1xuICAgICAgaXRlbSA9IHRoaXMuaXRlbXNbaWRdO1xuICAgICAgaWYgKGl0ZW0pIGl0ZW0udW5zZWxlY3QoKTtcbiAgICB9XG5cbiAgICAvLyBzZWxlY3QgaXRlbXNcbiAgICB0aGlzLnNlbGVjdGlvbiA9IFtdO1xuICAgIGZvciAoaSA9IDAsIGlpID0gaWRzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGlkID0gaWRzW2ldO1xuICAgICAgaXRlbSA9IHRoaXMuaXRlbXNbaWRdO1xuICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24ucHVzaChpZCk7XG4gICAgICAgIGl0ZW0uc2VsZWN0KCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNlbGVjdGVkIGl0ZW1zIGJ5IHRoZWlyIGlkXG4gICAqIEByZXR1cm4ge0FycmF5fSBpZHMgIFRoZSBpZHMgb2YgdGhlIHNlbGVjdGVkIGl0ZW1zXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5nZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uLmNvbmNhdChbXSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaWQncyBvZiB0aGUgY3VycmVudGx5IHZpc2libGUgaXRlbXMuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gVGhlIGlkcyBvZiB0aGUgdmlzaWJsZSBpdGVtc1xuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUuZ2V0VmlzaWJsZUl0ZW1zID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByYW5nZSA9IHRoaXMuYm9keS5yYW5nZS5nZXRSYW5nZSgpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgIHZhciByaWdodCA9IHRoaXMuYm9keS51dGlsLnRvU2NyZWVuKHJhbmdlLnN0YXJ0KTtcbiAgICAgIHZhciBsZWZ0ID0gdGhpcy5ib2R5LnV0aWwudG9TY3JlZW4ocmFuZ2UuZW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxlZnQgPSB0aGlzLmJvZHkudXRpbC50b1NjcmVlbihyYW5nZS5zdGFydCk7XG4gICAgICB2YXIgcmlnaHQgPSB0aGlzLmJvZHkudXRpbC50b1NjcmVlbihyYW5nZS5lbmQpO1xuICAgIH1cblxuICAgIHZhciBpZHMgPSBbXTtcbiAgICBmb3IgKHZhciBncm91cElkIGluIHRoaXMuZ3JvdXBzKSB7XG4gICAgICBpZiAodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkoZ3JvdXBJZCkpIHtcbiAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cHNbZ3JvdXBJZF07XG4gICAgICAgIHZhciByYXdWaXNpYmxlSXRlbXMgPSBncm91cC52aXNpYmxlSXRlbXM7XG5cbiAgICAgICAgLy8gZmlsdGVyIHRoZSBcInJhd1wiIHNldCB3aXRoIHZpc2libGVJdGVtcyBpbnRvIGEgc2V0IHdoaWNoIGlzIHJlYWxseVxuICAgICAgICAvLyB2aXNpYmxlIGJ5IHBpeGVsc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhd1Zpc2libGVJdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBpdGVtID0gcmF3VmlzaWJsZUl0ZW1zW2ldO1xuICAgICAgICAgIC8vIFRPRE86IGFsc28gY2hlY2sgd2hldGhlciB2aXNpYmxlIHZlcnRpY2FsbHlcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgICAgICAgaWYgKGl0ZW0ucmlnaHQgPCBsZWZ0ICYmIGl0ZW0ucmlnaHQgKyBpdGVtLndpZHRoID4gcmlnaHQpIHtcbiAgICAgICAgICAgICAgaWRzLnB1c2goaXRlbS5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpdGVtLmxlZnQgPCByaWdodCAmJiBpdGVtLmxlZnQgKyBpdGVtLndpZHRoID4gbGVmdCkge1xuICAgICAgICAgICAgICBpZHMucHVzaChpdGVtLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaWRzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXNlbGVjdCBhIHNlbGVjdGVkIGl0ZW1cbiAgICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXJ9IGlkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5fZGVzZWxlY3QgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5zZWxlY3Rpb247XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gc2VsZWN0aW9uLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGlmIChzZWxlY3Rpb25baV0gPT0gaWQpIHtcbiAgICAgICAgLy8gbm9uLXN0cmljdCBjb21wYXJpc29uIVxuICAgICAgICBzZWxlY3Rpb24uc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcGFpbnQgdGhlIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGNvbXBvbmVudCBpcyByZXNpemVkXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1hcmdpbiA9IHRoaXMub3B0aW9ucy5tYXJnaW4sXG4gICAgICAgIHJhbmdlID0gdGhpcy5ib2R5LnJhbmdlLFxuICAgICAgICBhc1NpemUgPSB1dGlsLm9wdGlvbi5hc1NpemUsXG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIG9yaWVudGF0aW9uID0gb3B0aW9ucy5vcmllbnRhdGlvbi5pdGVtLFxuICAgICAgICByZXNpemVkID0gZmFsc2UsXG4gICAgICAgIGZyYW1lID0gdGhpcy5kb20uZnJhbWU7XG5cbiAgICAvLyByZWNhbGN1bGF0ZSBhYnNvbHV0ZSBwb3NpdGlvbiAoYmVmb3JlIHJlZHJhd2luZyBncm91cHMpXG4gICAgdGhpcy5wcm9wcy50b3AgPSB0aGlzLmJvZHkuZG9tUHJvcHMudG9wLmhlaWdodCArIHRoaXMuYm9keS5kb21Qcm9wcy5ib3JkZXIudG9wO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgIHRoaXMucHJvcHMucmlnaHQgPSB0aGlzLmJvZHkuZG9tUHJvcHMucmlnaHQud2lkdGggKyB0aGlzLmJvZHkuZG9tUHJvcHMuYm9yZGVyLnJpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByb3BzLmxlZnQgPSB0aGlzLmJvZHkuZG9tUHJvcHMubGVmdC53aWR0aCArIHRoaXMuYm9keS5kb21Qcm9wcy5ib3JkZXIubGVmdDtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgY2xhc3MgbmFtZVxuICAgIGZyYW1lLmNsYXNzTmFtZSA9ICd2aXMtaXRlbXNldCc7XG5cbiAgICAvLyByZW9yZGVyIHRoZSBncm91cHMgKGlmIG5lZWRlZClcbiAgICByZXNpemVkID0gdGhpcy5fb3JkZXJHcm91cHMoKSB8fCByZXNpemVkO1xuXG4gICAgLy8gY2hlY2sgd2hldGhlciB6b29tZWQgKGluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIHJlLXN0YWNrIGV2ZXJ5dGhpbmcpXG4gICAgLy8gVE9ETzogd291bGQgYmUgbmljZXIgdG8gZ2V0IHRoaXMgYXMgYSB0cmlnZ2VyIGZyb20gUmFuZ2VcbiAgICB2YXIgdmlzaWJsZUludGVydmFsID0gcmFuZ2UuZW5kIC0gcmFuZ2Uuc3RhcnQ7XG4gICAgdmFyIHpvb21lZCA9IHZpc2libGVJbnRlcnZhbCAhPSB0aGlzLmxhc3RWaXNpYmxlSW50ZXJ2YWwgfHwgdGhpcy5wcm9wcy53aWR0aCAhPSB0aGlzLnByb3BzLmxhc3RXaWR0aDtcbiAgICBpZiAoem9vbWVkKSB0aGlzLnN0YWNrRGlydHkgPSB0cnVlO1xuICAgIHRoaXMubGFzdFZpc2libGVJbnRlcnZhbCA9IHZpc2libGVJbnRlcnZhbDtcbiAgICB0aGlzLnByb3BzLmxhc3RXaWR0aCA9IHRoaXMucHJvcHMud2lkdGg7XG5cbiAgICB2YXIgcmVzdGFjayA9IHRoaXMuc3RhY2tEaXJ0eTtcbiAgICB2YXIgZmlyc3RHcm91cCA9IHRoaXMuX2ZpcnN0R3JvdXAoKTtcbiAgICB2YXIgZmlyc3RNYXJnaW4gPSB7XG4gICAgICBpdGVtOiBtYXJnaW4uaXRlbSxcbiAgICAgIGF4aXM6IG1hcmdpbi5heGlzXG4gICAgfTtcbiAgICB2YXIgbm9uRmlyc3RNYXJnaW4gPSB7XG4gICAgICBpdGVtOiBtYXJnaW4uaXRlbSxcbiAgICAgIGF4aXM6IG1hcmdpbi5pdGVtLnZlcnRpY2FsIC8gMlxuICAgIH07XG4gICAgdmFyIGhlaWdodCA9IDA7XG4gICAgdmFyIG1pbkhlaWdodCA9IG1hcmdpbi5heGlzICsgbWFyZ2luLml0ZW0udmVydGljYWw7XG5cbiAgICAvLyByZWRyYXcgdGhlIGJhY2tncm91bmQgZ3JvdXBcbiAgICB0aGlzLmdyb3Vwc1tCQUNLR1JPVU5EXS5yZWRyYXcocmFuZ2UsIG5vbkZpcnN0TWFyZ2luLCByZXN0YWNrKTtcblxuICAgIC8vIHJlZHJhdyBhbGwgcmVndWxhciBncm91cHNcbiAgICB1dGlsLmZvckVhY2godGhpcy5ncm91cHMsIGZ1bmN0aW9uIChncm91cCkge1xuICAgICAgdmFyIGdyb3VwTWFyZ2luID0gZ3JvdXAgPT0gZmlyc3RHcm91cCA/IGZpcnN0TWFyZ2luIDogbm9uRmlyc3RNYXJnaW47XG4gICAgICB2YXIgZ3JvdXBSZXNpemVkID0gZ3JvdXAucmVkcmF3KHJhbmdlLCBncm91cE1hcmdpbiwgcmVzdGFjayk7XG4gICAgICByZXNpemVkID0gZ3JvdXBSZXNpemVkIHx8IHJlc2l6ZWQ7XG4gICAgICBoZWlnaHQgKz0gZ3JvdXAuaGVpZ2h0O1xuICAgIH0pO1xuICAgIGhlaWdodCA9IE1hdGgubWF4KGhlaWdodCwgbWluSGVpZ2h0KTtcbiAgICB0aGlzLnN0YWNrRGlydHkgPSBmYWxzZTtcblxuICAgIC8vIHVwZGF0ZSBmcmFtZSBoZWlnaHRcbiAgICBmcmFtZS5zdHlsZS5oZWlnaHQgPSBhc1NpemUoaGVpZ2h0KTtcblxuICAgIC8vIGNhbGN1bGF0ZSBhY3R1YWwgc2l6ZVxuICAgIHRoaXMucHJvcHMud2lkdGggPSBmcmFtZS5vZmZzZXRXaWR0aDtcbiAgICB0aGlzLnByb3BzLmhlaWdodCA9IGhlaWdodDtcblxuICAgIC8vIHJlcG9zaXRpb24gYXhpc1xuICAgIHRoaXMuZG9tLmF4aXMuc3R5bGUudG9wID0gYXNTaXplKG9yaWVudGF0aW9uID09ICd0b3AnID8gdGhpcy5ib2R5LmRvbVByb3BzLnRvcC5oZWlnaHQgKyB0aGlzLmJvZHkuZG9tUHJvcHMuYm9yZGVyLnRvcCA6IHRoaXMuYm9keS5kb21Qcm9wcy50b3AuaGVpZ2h0ICsgdGhpcy5ib2R5LmRvbVByb3BzLmNlbnRlckNvbnRhaW5lci5oZWlnaHQpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMucnRsKSB7XG4gICAgICB0aGlzLmRvbS5heGlzLnN0eWxlLnJpZ2h0ID0gJzAnO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRvbS5heGlzLnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgaWYgdGhpcyBjb21wb25lbnQgaXMgcmVzaXplZFxuICAgIHJlc2l6ZWQgPSB0aGlzLl9pc1Jlc2l6ZWQoKSB8fCByZXNpemVkO1xuXG4gICAgcmV0dXJuIHJlc2l6ZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZmlyc3QgZ3JvdXAsIGFsaWduZWQgd2l0aCB0aGUgYXhpc1xuICAgKiBAcmV0dXJuIHtHcm91cCB8IG51bGx9IGZpcnN0R3JvdXBcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLl9maXJzdEdyb3VwID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmaXJzdEdyb3VwSW5kZXggPSB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uaXRlbSA9PSAndG9wJyA/IDAgOiB0aGlzLmdyb3VwSWRzLmxlbmd0aCAtIDE7XG4gICAgdmFyIGZpcnN0R3JvdXBJZCA9IHRoaXMuZ3JvdXBJZHNbZmlyc3RHcm91cEluZGV4XTtcbiAgICB2YXIgZmlyc3RHcm91cCA9IHRoaXMuZ3JvdXBzW2ZpcnN0R3JvdXBJZF0gfHwgdGhpcy5ncm91cHNbVU5HUk9VUEVEXTtcblxuICAgIHJldHVybiBmaXJzdEdyb3VwIHx8IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBvciBkZWxldGUgdGhlIGdyb3VwIGhvbGRpbmcgYWxsIHVuZ3JvdXBlZCBpdGVtcy4gVGhpcyBncm91cCBpcyB1c2VkIHdoZW5cbiAgICogdGhlcmUgYXJlIG5vIGdyb3VwcyBzcGVjaWZpZWQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLl91cGRhdGVVbmdyb3VwZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVuZ3JvdXBlZCA9IHRoaXMuZ3JvdXBzW1VOR1JPVVBFRF07XG4gICAgdmFyIGJhY2tncm91bmQgPSB0aGlzLmdyb3Vwc1tCQUNLR1JPVU5EXTtcbiAgICB2YXIgaXRlbSwgaXRlbUlkO1xuXG4gICAgaWYgKHRoaXMuZ3JvdXBzRGF0YSkge1xuICAgICAgLy8gcmVtb3ZlIHRoZSBncm91cCBob2xkaW5nIGFsbCB1bmdyb3VwZWQgaXRlbXNcbiAgICAgIGlmICh1bmdyb3VwZWQpIHtcbiAgICAgICAgdW5ncm91cGVkLmhpZGUoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuZ3JvdXBzW1VOR1JPVVBFRF07XG5cbiAgICAgICAgZm9yIChpdGVtSWQgaW4gdGhpcy5pdGVtcykge1xuICAgICAgICAgIGlmICh0aGlzLml0ZW1zLmhhc093blByb3BlcnR5KGl0ZW1JZCkpIHtcbiAgICAgICAgICAgIGl0ZW0gPSB0aGlzLml0ZW1zW2l0ZW1JZF07XG4gICAgICAgICAgICBpdGVtLnBhcmVudCAmJiBpdGVtLnBhcmVudC5yZW1vdmUoaXRlbSk7XG4gICAgICAgICAgICB2YXIgZ3JvdXBJZCA9IHRoaXMuX2dldEdyb3VwSWQoaXRlbS5kYXRhKTtcbiAgICAgICAgICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXBzW2dyb3VwSWRdO1xuICAgICAgICAgICAgZ3JvdXAgJiYgZ3JvdXAuYWRkKGl0ZW0pIHx8IGl0ZW0uaGlkZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjcmVhdGUgYSBncm91cCBob2xkaW5nIGFsbCAodW5maWx0ZXJlZCkgaXRlbXNcbiAgICAgIGlmICghdW5ncm91cGVkKSB7XG4gICAgICAgIHZhciBpZCA9IG51bGw7XG4gICAgICAgIHZhciBkYXRhID0gbnVsbDtcbiAgICAgICAgdW5ncm91cGVkID0gbmV3IEdyb3VwKGlkLCBkYXRhLCB0aGlzKTtcbiAgICAgICAgdGhpcy5ncm91cHNbVU5HUk9VUEVEXSA9IHVuZ3JvdXBlZDtcblxuICAgICAgICBmb3IgKGl0ZW1JZCBpbiB0aGlzLml0ZW1zKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaXRlbXMuaGFzT3duUHJvcGVydHkoaXRlbUlkKSkge1xuICAgICAgICAgICAgaXRlbSA9IHRoaXMuaXRlbXNbaXRlbUlkXTtcbiAgICAgICAgICAgIHVuZ3JvdXBlZC5hZGQoaXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdW5ncm91cGVkLnNob3coKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZWxlbWVudCBmb3IgdGhlIGxhYmVsc2V0XG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBsYWJlbFNldFxuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUuZ2V0TGFiZWxTZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZG9tLmxhYmVsU2V0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgaXRlbXNcbiAgICogQHBhcmFtIHt2aXMuRGF0YVNldCB8IG51bGx9IGl0ZW1zXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5zZXRJdGVtcyA9IGZ1bmN0aW9uIChpdGVtcykge1xuICAgIHZhciBtZSA9IHRoaXMsXG4gICAgICAgIGlkcyxcbiAgICAgICAgb2xkSXRlbXNEYXRhID0gdGhpcy5pdGVtc0RhdGE7XG5cbiAgICAvLyByZXBsYWNlIHRoZSBkYXRhc2V0XG4gICAgaWYgKCFpdGVtcykge1xuICAgICAgdGhpcy5pdGVtc0RhdGEgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAoaXRlbXMgaW5zdGFuY2VvZiBEYXRhU2V0IHx8IGl0ZW1zIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICAgIHRoaXMuaXRlbXNEYXRhID0gaXRlbXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0RhdGEgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBEYXRhU2V0IG9yIERhdGFWaWV3Jyk7XG4gICAgfVxuXG4gICAgaWYgKG9sZEl0ZW1zRGF0YSkge1xuICAgICAgLy8gdW5zdWJzY3JpYmUgZnJvbSBvbGQgZGF0YXNldFxuICAgICAgdXRpbC5mb3JFYWNoKHRoaXMuaXRlbUxpc3RlbmVycywgZnVuY3Rpb24gKGNhbGxiYWNrLCBldmVudCkge1xuICAgICAgICBvbGRJdGVtc0RhdGEub2ZmKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgICB9KTtcblxuICAgICAgLy8gcmVtb3ZlIGFsbCBkcmF3biBpdGVtc1xuICAgICAgaWRzID0gb2xkSXRlbXNEYXRhLmdldElkcygpO1xuICAgICAgdGhpcy5fb25SZW1vdmUoaWRzKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pdGVtc0RhdGEpIHtcbiAgICAgIC8vIHN1YnNjcmliZSB0byBuZXcgZGF0YXNldFxuICAgICAgdmFyIGlkID0gdGhpcy5pZDtcbiAgICAgIHV0aWwuZm9yRWFjaCh0aGlzLml0ZW1MaXN0ZW5lcnMsIGZ1bmN0aW9uIChjYWxsYmFjaywgZXZlbnQpIHtcbiAgICAgICAgbWUuaXRlbXNEYXRhLm9uKGV2ZW50LCBjYWxsYmFjaywgaWQpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGFkZCBhbGwgbmV3IGl0ZW1zXG4gICAgICBpZHMgPSB0aGlzLml0ZW1zRGF0YS5nZXRJZHMoKTtcbiAgICAgIHRoaXMuX29uQWRkKGlkcyk7XG5cbiAgICAgIC8vIHVwZGF0ZSB0aGUgZ3JvdXAgaG9sZGluZyBhbGwgdW5ncm91cGVkIGl0ZW1zXG4gICAgICB0aGlzLl91cGRhdGVVbmdyb3VwZWQoKTtcbiAgICB9XG5cbiAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfY2hhbmdlJywgeyBxdWV1ZTogdHJ1ZSB9KTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IGl0ZW1zXG4gICAqIEByZXR1cm5zIHt2aXMuRGF0YVNldCB8IG51bGx9XG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5nZXRJdGVtcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtc0RhdGE7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBncm91cHNcbiAgICogQHBhcmFtIHt2aXMuRGF0YVNldH0gZ3JvdXBzXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5zZXRHcm91cHMgPSBmdW5jdGlvbiAoZ3JvdXBzKSB7XG4gICAgdmFyIG1lID0gdGhpcyxcbiAgICAgICAgaWRzO1xuXG4gICAgLy8gdW5zdWJzY3JpYmUgZnJvbSBjdXJyZW50IGRhdGFzZXRcbiAgICBpZiAodGhpcy5ncm91cHNEYXRhKSB7XG4gICAgICB1dGlsLmZvckVhY2godGhpcy5ncm91cExpc3RlbmVycywgZnVuY3Rpb24gKGNhbGxiYWNrLCBldmVudCkge1xuICAgICAgICBtZS5ncm91cHNEYXRhLm9mZihldmVudCwgY2FsbGJhY2spO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHJlbW92ZSBhbGwgZHJhd24gZ3JvdXBzXG4gICAgICBpZHMgPSB0aGlzLmdyb3Vwc0RhdGEuZ2V0SWRzKCk7XG4gICAgICB0aGlzLmdyb3Vwc0RhdGEgPSBudWxsO1xuICAgICAgdGhpcy5fb25SZW1vdmVHcm91cHMoaWRzKTsgLy8gbm90ZTogdGhpcyB3aWxsIGNhdXNlIGEgcmVkcmF3XG4gICAgfVxuXG4gICAgLy8gcmVwbGFjZSB0aGUgZGF0YXNldFxuICAgIGlmICghZ3JvdXBzKSB7XG4gICAgICB0aGlzLmdyb3Vwc0RhdGEgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAoZ3JvdXBzIGluc3RhbmNlb2YgRGF0YVNldCB8fCBncm91cHMgaW5zdGFuY2VvZiBEYXRhVmlldykge1xuICAgICAgdGhpcy5ncm91cHNEYXRhID0gZ3JvdXBzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdEYXRhIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgRGF0YVNldCBvciBEYXRhVmlldycpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmdyb3Vwc0RhdGEpIHtcbiAgICAgIC8vIHN1YnNjcmliZSB0byBuZXcgZGF0YXNldFxuICAgICAgdmFyIGlkID0gdGhpcy5pZDtcbiAgICAgIHV0aWwuZm9yRWFjaCh0aGlzLmdyb3VwTGlzdGVuZXJzLCBmdW5jdGlvbiAoY2FsbGJhY2ssIGV2ZW50KSB7XG4gICAgICAgIG1lLmdyb3Vwc0RhdGEub24oZXZlbnQsIGNhbGxiYWNrLCBpZCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gZHJhdyBhbGwgbXNcbiAgICAgIGlkcyA9IHRoaXMuZ3JvdXBzRGF0YS5nZXRJZHMoKTtcbiAgICAgIHRoaXMuX29uQWRkR3JvdXBzKGlkcyk7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIHRoZSBncm91cCBob2xkaW5nIGFsbCB1bmdyb3VwZWQgaXRlbXNcbiAgICB0aGlzLl91cGRhdGVVbmdyb3VwZWQoKTtcblxuICAgIC8vIHVwZGF0ZSB0aGUgb3JkZXIgb2YgYWxsIGl0ZW1zIGluIGVhY2ggZ3JvdXBcbiAgICB0aGlzLl9vcmRlcigpO1xuXG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2NoYW5nZScsIHsgcXVldWU6IHRydWUgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBncm91cHNcbiAgICogQHJldHVybnMge3Zpcy5EYXRhU2V0IHwgbnVsbH0gZ3JvdXBzXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5nZXRHcm91cHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ3JvdXBzRGF0YTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGl0ZW0gYnkgaXRzIGlkXG4gICAqIEBwYXJhbSB7U3RyaW5nIHwgTnVtYmVyfSBpZFxuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUucmVtb3ZlSXRlbSA9IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gdGhpcy5pdGVtc0RhdGEuZ2V0KGlkKSxcbiAgICAgICAgZGF0YXNldCA9IHRoaXMuaXRlbXNEYXRhLmdldERhdGFTZXQoKTtcblxuICAgIGlmIChpdGVtKSB7XG4gICAgICAvLyBjb25maXJtIGRlbGV0aW9uXG4gICAgICB0aGlzLm9wdGlvbnMub25SZW1vdmUoaXRlbSwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAvLyByZW1vdmUgYnkgaWQgaGVyZSwgaXQgaXMgcG9zc2libGUgdGhhdCBhbiBpdGVtIGhhcyBubyBpZCBkZWZpbmVkXG4gICAgICAgICAgLy8gaXRzZWxmLCBzbyBiZXR0ZXIgbm90IGRlbGV0ZSBieSB0aGUgaXRlbSBpdHNlbGZcbiAgICAgICAgICBkYXRhc2V0LnJlbW92ZShpZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSB0aW1lIG9mIGFuIGl0ZW0gYmFzZWQgb24gaXQncyBkYXRhIGFuZCBvcHRpb25zLnR5cGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1EYXRhXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHR5cGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLl9nZXRUeXBlID0gZnVuY3Rpb24gKGl0ZW1EYXRhKSB7XG4gICAgcmV0dXJuIGl0ZW1EYXRhLnR5cGUgfHwgdGhpcy5vcHRpb25zLnR5cGUgfHwgKGl0ZW1EYXRhLmVuZCA/ICdyYW5nZScgOiAnYm94Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZ3JvdXAgaWQgZm9yIGFuIGl0ZW1cbiAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1EYXRhXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGdyb3VwSWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLl9nZXRHcm91cElkID0gZnVuY3Rpb24gKGl0ZW1EYXRhKSB7XG4gICAgdmFyIHR5cGUgPSB0aGlzLl9nZXRUeXBlKGl0ZW1EYXRhKTtcbiAgICBpZiAodHlwZSA9PSAnYmFja2dyb3VuZCcgJiYgaXRlbURhdGEuZ3JvdXAgPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gQkFDS0dST1VORDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZ3JvdXBzRGF0YSA/IGl0ZW1EYXRhLmdyb3VwIDogVU5HUk9VUEVEO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIHVwZGF0ZWQgaXRlbXNcbiAgICogQHBhcmFtIHtOdW1iZXJbXX0gaWRzXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLl9vblVwZGF0ZSA9IGZ1bmN0aW9uIChpZHMpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuXG4gICAgaWRzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICB2YXIgaXRlbURhdGEgPSBtZS5pdGVtc0RhdGEuZ2V0KGlkLCBtZS5pdGVtT3B0aW9ucyk7XG4gICAgICB2YXIgaXRlbSA9IG1lLml0ZW1zW2lkXTtcbiAgICAgIHZhciB0eXBlID0gbWUuX2dldFR5cGUoaXRlbURhdGEpO1xuXG4gICAgICB2YXIgY29uc3RydWN0b3IgPSBJdGVtU2V0LnR5cGVzW3R5cGVdO1xuICAgICAgdmFyIHNlbGVjdGVkO1xuXG4gICAgICBpZiAoaXRlbSkge1xuICAgICAgICAvLyB1cGRhdGUgaXRlbVxuICAgICAgICBpZiAoIWNvbnN0cnVjdG9yIHx8ICEoaXRlbSBpbnN0YW5jZW9mIGNvbnN0cnVjdG9yKSkge1xuICAgICAgICAgIC8vIGl0ZW0gdHlwZSBoYXMgY2hhbmdlZCwgZGVsZXRlIHRoZSBpdGVtIGFuZCByZWNyZWF0ZSBpdFxuICAgICAgICAgIHNlbGVjdGVkID0gaXRlbS5zZWxlY3RlZDsgLy8gcHJlc2VydmUgc2VsZWN0aW9uIG9mIHRoaXMgaXRlbVxuICAgICAgICAgIG1lLl9yZW1vdmVJdGVtKGl0ZW0pO1xuICAgICAgICAgIGl0ZW0gPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1lLl91cGRhdGVJdGVtKGl0ZW0sIGl0ZW1EYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgLy8gY3JlYXRlIGl0ZW1cbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgaXRlbSA9IG5ldyBjb25zdHJ1Y3RvcihpdGVtRGF0YSwgbWUuY29udmVyc2lvbiwgbWUub3B0aW9ucyk7XG4gICAgICAgICAgaXRlbS5pZCA9IGlkOyAvLyBUT0RPOiBub3Qgc28gbmljZSBzZXR0aW5nIGlkIGFmdGVyd2FyZHNcbiAgICAgICAgICBtZS5fYWRkSXRlbShpdGVtKTtcbiAgICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnB1c2goaWQpO1xuICAgICAgICAgICAgaXRlbS5zZWxlY3QoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSAncmFuZ2VvdmVyZmxvdycpIHtcbiAgICAgICAgICAvLyBUT0RPOiBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi4xLjAgKG9yIDMuMC4wPykuIGNsZWFudXAgc29tZSBkYXlcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJdGVtIHR5cGUgXCJyYW5nZW92ZXJmbG93XCIgaXMgZGVwcmVjYXRlZC4gVXNlIGNzcyBzdHlsaW5nIGluc3RlYWQ6ICcgKyAnLnZpcy1pdGVtLnZpcy1yYW5nZSAudmlzLWl0ZW0tY29udGVudCB7b3ZlcmZsb3c6IHZpc2libGU7fScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gaXRlbSB0eXBlIFwiJyArIHR5cGUgKyAnXCInKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICB0aGlzLl9vcmRlcigpO1xuICAgIHRoaXMuc3RhY2tEaXJ0eSA9IHRydWU7IC8vIGZvcmNlIHJlLXN0YWNraW5nIG9mIGFsbCBpdGVtcyBuZXh0IHJlZHJhd1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19jaGFuZ2UnLCB7IHF1ZXVlOiB0cnVlIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYWRkZWQgaXRlbXNcbiAgICogQHBhcmFtIHtOdW1iZXJbXX0gaWRzXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLl9vbkFkZCA9IEl0ZW1TZXQucHJvdG90eXBlLl9vblVwZGF0ZTtcblxuICAvKipcbiAgICogSGFuZGxlIHJlbW92ZWQgaXRlbXNcbiAgICogQHBhcmFtIHtOdW1iZXJbXX0gaWRzXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLl9vblJlbW92ZSA9IGZ1bmN0aW9uIChpZHMpIHtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgaWRzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICB2YXIgaXRlbSA9IG1lLml0ZW1zW2lkXTtcbiAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICAgIG1lLl9yZW1vdmVJdGVtKGl0ZW0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGNvdW50KSB7XG4gICAgICAvLyB1cGRhdGUgb3JkZXJcbiAgICAgIHRoaXMuX29yZGVyKCk7XG4gICAgICB0aGlzLnN0YWNrRGlydHkgPSB0cnVlOyAvLyBmb3JjZSByZS1zdGFja2luZyBvZiBhbGwgaXRlbXMgbmV4dCByZWRyYXdcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19jaGFuZ2UnLCB7IHF1ZXVlOiB0cnVlIH0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBvcmRlciBvZiBpdGVtIGluIGFsbCBncm91cHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLl9vcmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyByZW9yZGVyIHRoZSBpdGVtcyBpbiBhbGwgZ3JvdXBzXG4gICAgLy8gVE9ETzogb3B0aW1pemF0aW9uOiBvbmx5IHJlb3JkZXIgZ3JvdXBzIGFmZmVjdGVkIGJ5IHRoZSBjaGFuZ2VkIGl0ZW1zXG4gICAgdXRpbC5mb3JFYWNoKHRoaXMuZ3JvdXBzLCBmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICAgIGdyb3VwLm9yZGVyKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSB1cGRhdGVkIGdyb3Vwc1xuICAgKiBAcGFyYW0ge051bWJlcltdfSBpZHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLl9vblVwZGF0ZUdyb3VwcyA9IGZ1bmN0aW9uIChpZHMpIHtcbiAgICB0aGlzLl9vbkFkZEdyb3VwcyhpZHMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgY2hhbmdlZCBncm91cHMgKGFkZGVkIG9yIHVwZGF0ZWQpXG4gICAqIEBwYXJhbSB7TnVtYmVyW119IGlkc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUuX29uQWRkR3JvdXBzID0gZnVuY3Rpb24gKGlkcykge1xuICAgIHZhciBtZSA9IHRoaXM7XG5cbiAgICBpZHMuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHZhciBncm91cERhdGEgPSBtZS5ncm91cHNEYXRhLmdldChpZCk7XG4gICAgICB2YXIgZ3JvdXAgPSBtZS5ncm91cHNbaWRdO1xuXG4gICAgICBpZiAoIWdyb3VwKSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciByZXNlcnZlZCBpZHNcbiAgICAgICAgaWYgKGlkID09IFVOR1JPVVBFRCB8fCBpZCA9PSBCQUNLR1JPVU5EKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGdyb3VwIGlkLiAnICsgaWQgKyAnIGlzIGEgcmVzZXJ2ZWQgaWQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ3JvdXBPcHRpb25zID0gT2JqZWN0LmNyZWF0ZShtZS5vcHRpb25zKTtcbiAgICAgICAgdXRpbC5leHRlbmQoZ3JvdXBPcHRpb25zLCB7XG4gICAgICAgICAgaGVpZ2h0OiBudWxsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGdyb3VwID0gbmV3IEdyb3VwKGlkLCBncm91cERhdGEsIG1lKTtcbiAgICAgICAgbWUuZ3JvdXBzW2lkXSA9IGdyb3VwO1xuXG4gICAgICAgIC8vIGFkZCBpdGVtcyB3aXRoIHRoaXMgZ3JvdXBJZCB0byB0aGUgbmV3IGdyb3VwXG4gICAgICAgIGZvciAodmFyIGl0ZW1JZCBpbiBtZS5pdGVtcykge1xuICAgICAgICAgIGlmIChtZS5pdGVtcy5oYXNPd25Qcm9wZXJ0eShpdGVtSWQpKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IG1lLml0ZW1zW2l0ZW1JZF07XG4gICAgICAgICAgICBpZiAoaXRlbS5kYXRhLmdyb3VwID09IGlkKSB7XG4gICAgICAgICAgICAgIGdyb3VwLmFkZChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBncm91cC5vcmRlcigpO1xuICAgICAgICBncm91cC5zaG93KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1cGRhdGUgZ3JvdXBcbiAgICAgICAgZ3JvdXAuc2V0RGF0YShncm91cERhdGEpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2NoYW5nZScsIHsgcXVldWU6IHRydWUgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSByZW1vdmVkIGdyb3Vwc1xuICAgKiBAcGFyYW0ge051bWJlcltdfSBpZHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLl9vblJlbW92ZUdyb3VwcyA9IGZ1bmN0aW9uIChpZHMpIHtcbiAgICB2YXIgZ3JvdXBzID0gdGhpcy5ncm91cHM7XG4gICAgaWRzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICB2YXIgZ3JvdXAgPSBncm91cHNbaWRdO1xuXG4gICAgICBpZiAoZ3JvdXApIHtcbiAgICAgICAgZ3JvdXAuaGlkZSgpO1xuICAgICAgICBkZWxldGUgZ3JvdXBzW2lkXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMubWFya0RpcnR5KCk7XG5cbiAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfY2hhbmdlJywgeyBxdWV1ZTogdHJ1ZSB9KTtcbiAgfTtcblxuICAvKipcbiAgICogUmVvcmRlciB0aGUgZ3JvdXBzIGlmIG5lZWRlZFxuICAgKiBAcmV0dXJuIHtib29sZWFufSBjaGFuZ2VkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5fb3JkZXJHcm91cHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZ3JvdXBzRGF0YSkge1xuICAgICAgLy8gcmVvcmRlciB0aGUgZ3JvdXBzXG4gICAgICB2YXIgZ3JvdXBJZHMgPSB0aGlzLmdyb3Vwc0RhdGEuZ2V0SWRzKHtcbiAgICAgICAgb3JkZXI6IHRoaXMub3B0aW9ucy5ncm91cE9yZGVyXG4gICAgICB9KTtcblxuICAgICAgdmFyIGNoYW5nZWQgPSAhdXRpbC5lcXVhbEFycmF5KGdyb3VwSWRzLCB0aGlzLmdyb3VwSWRzKTtcbiAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgIC8vIGhpZGUgYWxsIGdyb3VwcywgcmVtb3ZlcyB0aGVtIGZyb20gdGhlIERPTVxuICAgICAgICB2YXIgZ3JvdXBzID0gdGhpcy5ncm91cHM7XG4gICAgICAgIGdyb3VwSWRzLmZvckVhY2goZnVuY3Rpb24gKGdyb3VwSWQpIHtcbiAgICAgICAgICBncm91cHNbZ3JvdXBJZF0uaGlkZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBzaG93IHRoZSBncm91cHMgYWdhaW4sIGF0dGFjaCB0aGVtIHRvIHRoZSBET00gaW4gY29ycmVjdCBvcmRlclxuICAgICAgICBncm91cElkcy5mb3JFYWNoKGZ1bmN0aW9uIChncm91cElkKSB7XG4gICAgICAgICAgZ3JvdXBzW2dyb3VwSWRdLnNob3coKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5ncm91cElkcyA9IGdyb3VwSWRzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQWRkIGEgbmV3IGl0ZW1cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5fYWRkSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgdGhpcy5pdGVtc1tpdGVtLmlkXSA9IGl0ZW07XG5cbiAgICAvLyBhZGQgdG8gZ3JvdXBcbiAgICB2YXIgZ3JvdXBJZCA9IHRoaXMuX2dldEdyb3VwSWQoaXRlbS5kYXRhKTtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3Vwc1tncm91cElkXTtcbiAgICBpZiAoZ3JvdXApIGdyb3VwLmFkZChpdGVtKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIGFuIGV4aXN0aW5nIGl0ZW1cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtRGF0YVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUuX3VwZGF0ZUl0ZW0gPSBmdW5jdGlvbiAoaXRlbSwgaXRlbURhdGEpIHtcbiAgICB2YXIgb2xkR3JvdXBJZCA9IGl0ZW0uZGF0YS5ncm91cDtcbiAgICB2YXIgb2xkU3ViR3JvdXBJZCA9IGl0ZW0uZGF0YS5zdWJncm91cDtcblxuICAgIC8vIHVwZGF0ZSB0aGUgaXRlbXMgZGF0YSAod2lsbCByZWRyYXcgdGhlIGl0ZW0gd2hlbiBkaXNwbGF5ZWQpXG4gICAgaXRlbS5zZXREYXRhKGl0ZW1EYXRhKTtcblxuICAgIC8vIHVwZGF0ZSBncm91cFxuICAgIGlmIChvbGRHcm91cElkICE9IGl0ZW0uZGF0YS5ncm91cCB8fCBvbGRTdWJHcm91cElkICE9IGl0ZW0uZGF0YS5zdWJncm91cCkge1xuICAgICAgdmFyIG9sZEdyb3VwID0gdGhpcy5ncm91cHNbb2xkR3JvdXBJZF07XG4gICAgICBpZiAob2xkR3JvdXApIG9sZEdyb3VwLnJlbW92ZShpdGVtKTtcblxuICAgICAgdmFyIGdyb3VwSWQgPSB0aGlzLl9nZXRHcm91cElkKGl0ZW0uZGF0YSk7XG4gICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3Vwc1tncm91cElkXTtcbiAgICAgIGlmIChncm91cCkgZ3JvdXAuYWRkKGl0ZW0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRGVsZXRlIGFuIGl0ZW0gZnJvbSB0aGUgSXRlbVNldDogcmVtb3ZlIGl0IGZyb20gdGhlIERPTSwgZnJvbSB0aGUgbWFwXG4gICAqIHdpdGggaXRlbXMsIGFuZCBmcm9tIHRoZSBtYXAgd2l0aCB2aXNpYmxlIGl0ZW1zLCBhbmQgZnJvbSB0aGUgc2VsZWN0aW9uXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUuX3JlbW92ZUl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgIC8vIHJlbW92ZSBmcm9tIERPTVxuICAgIGl0ZW0uaGlkZSgpO1xuXG4gICAgLy8gcmVtb3ZlIGZyb20gaXRlbXNcbiAgICBkZWxldGUgdGhpcy5pdGVtc1tpdGVtLmlkXTtcblxuICAgIC8vIHJlbW92ZSBmcm9tIHNlbGVjdGlvblxuICAgIHZhciBpbmRleCA9IHRoaXMuc2VsZWN0aW9uLmluZGV4T2YoaXRlbS5pZCk7XG4gICAgaWYgKGluZGV4ICE9IC0xKSB0aGlzLnNlbGVjdGlvbi5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgLy8gcmVtb3ZlIGZyb20gZ3JvdXBcbiAgICBpdGVtLnBhcmVudCAmJiBpdGVtLnBhcmVudC5yZW1vdmUoaXRlbSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBhcnJheSBjb250YWluaW5nIGFsbCBpdGVtcyBiZWluZyBhIHJhbmdlIChoYXZpbmcgYW4gZW5kIGRhdGUpXG4gICAqIEBwYXJhbSBhcnJheVxuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5fY29uc3RydWN0QnlFbmRBcnJheSA9IGZ1bmN0aW9uIChhcnJheSkge1xuICAgIHZhciBlbmRBcnJheSA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFycmF5W2ldIGluc3RhbmNlb2YgUmFuZ2VJdGVtKSB7XG4gICAgICAgIGVuZEFycmF5LnB1c2goYXJyYXlbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW5kQXJyYXk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIHRoZSBjbGlja2VkIGl0ZW0gb24gdG91Y2gsIGJlZm9yZSBkcmFnU3RhcnQgaXMgaW5pdGlhdGVkLlxuICAgKlxuICAgKiBkcmFnU3RhcnQgaXMgaW5pdGlhdGVkIGZyb20gYSBtb3VzZW1vdmUgZXZlbnQsIEFGVEVSIHRoZSBtb3VzZS90b3VjaCBpc1xuICAgKiBhbHJlYWR5IG1vdmluZy4gVGhlcmVmb3JlLCB0aGUgbW91c2UvdG91Y2ggY2FuIHNvbWV0aW1lcyBiZSBhYm92ZSBhbiBvdGhlclxuICAgKiBET00gZWxlbWVudCB0aGFuIHRoZSBpdGVtIGl0c2VsZi5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLl9vblRvdWNoID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gc3RvcmUgdGhlIHRvdWNoZWQgaXRlbSwgdXNlZCBpbiBfb25EcmFnU3RhcnRcbiAgICB0aGlzLnRvdWNoUGFyYW1zLml0ZW0gPSB0aGlzLml0ZW1Gcm9tVGFyZ2V0KGV2ZW50KTtcbiAgICB0aGlzLnRvdWNoUGFyYW1zLmRyYWdMZWZ0SXRlbSA9IGV2ZW50LnRhcmdldC5kcmFnTGVmdEl0ZW0gfHwgZmFsc2U7XG4gICAgdGhpcy50b3VjaFBhcmFtcy5kcmFnUmlnaHRJdGVtID0gZXZlbnQudGFyZ2V0LmRyYWdSaWdodEl0ZW0gfHwgZmFsc2U7XG4gICAgdGhpcy50b3VjaFBhcmFtcy5pdGVtUHJvcHMgPSBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHaXZlbiBhbiBncm91cCBpZCwgcmV0dXJucyB0aGUgaW5kZXggaXQgaGFzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gZ3JvdXBJRFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUuX2dldEdyb3VwSW5kZXggPSBmdW5jdGlvbiAoZ3JvdXBJZCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ncm91cElkcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGdyb3VwSWQgPT0gdGhpcy5ncm91cElkc1tpXSkgcmV0dXJuIGk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTdGFydCBkcmFnZ2luZyB0aGUgc2VsZWN0ZWQgZXZlbnRzXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5fb25EcmFnU3RhcnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgaXRlbSA9IHRoaXMudG91Y2hQYXJhbXMuaXRlbSB8fCBudWxsO1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdmFyIHByb3BzO1xuXG4gICAgaWYgKGl0ZW0gJiYgKGl0ZW0uc2VsZWN0ZWQgfHwgdGhpcy5vcHRpb25zLml0ZW1zQWx3YXlzRHJhZ2dhYmxlKSkge1xuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5lZGl0YWJsZS51cGRhdGVUaW1lICYmICF0aGlzLm9wdGlvbnMuZWRpdGFibGUudXBkYXRlR3JvdXAgJiYgIWl0ZW0uZWRpdGFibGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBvdmVycmlkZSBvcHRpb25zLmVkaXRhYmxlXG4gICAgICBpZiAoaXRlbS5lZGl0YWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZHJhZ0xlZnRJdGVtID0gdGhpcy50b3VjaFBhcmFtcy5kcmFnTGVmdEl0ZW07XG4gICAgICB2YXIgZHJhZ1JpZ2h0SXRlbSA9IHRoaXMudG91Y2hQYXJhbXMuZHJhZ1JpZ2h0SXRlbTtcblxuICAgICAgaWYgKGRyYWdMZWZ0SXRlbSkge1xuICAgICAgICBwcm9wcyA9IHtcbiAgICAgICAgICBpdGVtOiBkcmFnTGVmdEl0ZW0sXG4gICAgICAgICAgaW5pdGlhbFg6IGV2ZW50LmNlbnRlci54LFxuICAgICAgICAgIGRyYWdMZWZ0OiB0cnVlLFxuICAgICAgICAgIGRhdGE6IHRoaXMuX2Nsb25lSXRlbURhdGEoaXRlbS5kYXRhKVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMudG91Y2hQYXJhbXMuaXRlbVByb3BzID0gW3Byb3BzXTtcbiAgICAgIH0gZWxzZSBpZiAoZHJhZ1JpZ2h0SXRlbSkge1xuICAgICAgICBwcm9wcyA9IHtcbiAgICAgICAgICBpdGVtOiBkcmFnUmlnaHRJdGVtLFxuICAgICAgICAgIGluaXRpYWxYOiBldmVudC5jZW50ZXIueCxcbiAgICAgICAgICBkcmFnUmlnaHQ6IHRydWUsXG4gICAgICAgICAgZGF0YTogdGhpcy5fY2xvbmVJdGVtRGF0YShpdGVtLmRhdGEpXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy50b3VjaFBhcmFtcy5pdGVtUHJvcHMgPSBbcHJvcHNdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50b3VjaFBhcmFtcy5zZWxlY3RlZEl0ZW0gPSBpdGVtO1xuXG4gICAgICAgIHZhciBiYXNlR3JvdXBJbmRleCA9IHRoaXMuX2dldEdyb3VwSW5kZXgoaXRlbS5kYXRhLmdyb3VwKTtcblxuICAgICAgICB2YXIgaXRlbXNUb0RyYWcgPSB0aGlzLm9wdGlvbnMuaXRlbXNBbHdheXNEcmFnZ2FibGUgJiYgIWl0ZW0uc2VsZWN0ZWQgPyBbaXRlbS5pZF0gOiB0aGlzLmdldFNlbGVjdGlvbigpO1xuXG4gICAgICAgIHRoaXMudG91Y2hQYXJhbXMuaXRlbVByb3BzID0gaXRlbXNUb0RyYWcubWFwKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgIHZhciBpdGVtID0gbWUuaXRlbXNbaWRdO1xuICAgICAgICAgIHZhciBncm91cEluZGV4ID0gbWUuX2dldEdyb3VwSW5kZXgoaXRlbS5kYXRhLmdyb3VwKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICAgIGluaXRpYWxYOiBldmVudC5jZW50ZXIueCxcbiAgICAgICAgICAgIGdyb3VwT2Zmc2V0OiBiYXNlR3JvdXBJbmRleCAtIGdyb3VwSW5kZXgsXG4gICAgICAgICAgICBkYXRhOiB0aGlzLl9jbG9uZUl0ZW1EYXRhKGl0ZW0uZGF0YSlcbiAgICAgICAgICB9O1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgfVxuXG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5lZGl0YWJsZS5hZGQgJiYgKGV2ZW50LnNyY0V2ZW50LmN0cmxLZXkgfHwgZXZlbnQuc3JjRXZlbnQubWV0YUtleSkpIHtcbiAgICAgIC8vIGNyZWF0ZSBhIG5ldyByYW5nZSBpdGVtIHdoZW4gZHJhZ2dpbmcgd2l0aCBjdHJsIGtleSBkb3duXG4gICAgICB0aGlzLl9vbkRyYWdTdGFydEFkZEl0ZW0oZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU3RhcnQgY3JlYXRpbmcgYSBuZXcgcmFuZ2UgaXRlbSBieSBkcmFnZ2luZy5cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLl9vbkRyYWdTdGFydEFkZEl0ZW0gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgc25hcCA9IHRoaXMub3B0aW9ucy5zbmFwIHx8IG51bGw7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgdmFyIHhBYnMgPSB1dGlsLmdldEFic29sdXRlUmlnaHQodGhpcy5kb20uZnJhbWUpO1xuICAgICAgdmFyIHggPSB4QWJzIC0gZXZlbnQuY2VudGVyLnggKyAxMDsgLy8gcGx1cyAxMCB0byBjb21wZW5zYXRlIGZvciB0aGUgZHJhZyBzdGFydGluZyBhcyBzb29uIGFzIHlvdSd2ZSBtb3ZlZCAxMHB4XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHhBYnMgPSB1dGlsLmdldEFic29sdXRlTGVmdCh0aGlzLmRvbS5mcmFtZSk7XG4gICAgICAgIHZhciB4ID0gZXZlbnQuY2VudGVyLnggLSB4QWJzIC0gMTA7IC8vIG1pbnVzIDEwIHRvIGNvbXBlbnNhdGUgZm9yIHRoZSBkcmFnIHN0YXJ0aW5nIGFzIHNvb24gYXMgeW91J3ZlIG1vdmVkIDEwcHhcbiAgICAgIH1cblxuICAgIHZhciB0aW1lID0gdGhpcy5ib2R5LnV0aWwudG9UaW1lKHgpO1xuICAgIHZhciBzY2FsZSA9IHRoaXMuYm9keS51dGlsLmdldFNjYWxlKCk7XG4gICAgdmFyIHN0ZXAgPSB0aGlzLmJvZHkudXRpbC5nZXRTdGVwKCk7XG4gICAgdmFyIHN0YXJ0ID0gc25hcCA/IHNuYXAodGltZSwgc2NhbGUsIHN0ZXApIDogdGltZTtcbiAgICB2YXIgZW5kID0gc3RhcnQ7XG5cbiAgICB2YXIgaXRlbURhdGEgPSB7XG4gICAgICB0eXBlOiAncmFuZ2UnLFxuICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgZW5kOiBlbmQsXG4gICAgICBjb250ZW50OiAnbmV3IGl0ZW0nXG4gICAgfTtcblxuICAgIHZhciBpZCA9IHV0aWwucmFuZG9tVVVJRCgpO1xuICAgIGl0ZW1EYXRhW3RoaXMuaXRlbXNEYXRhLl9maWVsZElkXSA9IGlkO1xuXG4gICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cEZyb21UYXJnZXQoZXZlbnQpO1xuICAgIGlmIChncm91cCkge1xuICAgICAgaXRlbURhdGEuZ3JvdXAgPSBncm91cC5ncm91cElkO1xuICAgIH1cbiAgICB2YXIgbmV3SXRlbSA9IG5ldyBSYW5nZUl0ZW0oaXRlbURhdGEsIHRoaXMuY29udmVyc2lvbiwgdGhpcy5vcHRpb25zKTtcbiAgICBuZXdJdGVtLmlkID0gaWQ7IC8vIFRPRE86IG5vdCBzbyBuaWNlIHNldHRpbmcgaWQgYWZ0ZXJ3YXJkc1xuICAgIG5ld0l0ZW0uZGF0YSA9IHRoaXMuX2Nsb25lSXRlbURhdGEoaXRlbURhdGEpO1xuICAgIHRoaXMuX2FkZEl0ZW0obmV3SXRlbSk7XG5cbiAgICB2YXIgcHJvcHMgPSB7XG4gICAgICBpdGVtOiBuZXdJdGVtLFxuICAgICAgaW5pdGlhbFg6IGV2ZW50LmNlbnRlci54LFxuICAgICAgZGF0YTogbmV3SXRlbS5kYXRhXG4gICAgfTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMucnRsKSB7XG4gICAgICBwcm9wcy5kcmFnTGVmdCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3BzLmRyYWdSaWdodCA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMudG91Y2hQYXJhbXMuaXRlbVByb3BzID0gW3Byb3BzXTtcblxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEcmFnIHNlbGVjdGVkIGl0ZW1zXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5fb25EcmFnID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMudG91Y2hQYXJhbXMuaXRlbVByb3BzKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIHZhciBzbmFwID0gdGhpcy5vcHRpb25zLnNuYXAgfHwgbnVsbDtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgICAgdmFyIHhPZmZzZXQgPSB0aGlzLmJvZHkuZG9tLnJvb3Qub2Zmc2V0TGVmdCArIHRoaXMuYm9keS5kb21Qcm9wcy5yaWdodC53aWR0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB4T2Zmc2V0ID0gdGhpcy5ib2R5LmRvbS5yb290Lm9mZnNldExlZnQgKyB0aGlzLmJvZHkuZG9tUHJvcHMubGVmdC53aWR0aDtcbiAgICAgIH1cblxuICAgICAgdmFyIHNjYWxlID0gdGhpcy5ib2R5LnV0aWwuZ2V0U2NhbGUoKTtcbiAgICAgIHZhciBzdGVwID0gdGhpcy5ib2R5LnV0aWwuZ2V0U3RlcCgpO1xuXG4gICAgICAvL29ubHkgY2FsY3VsYXRlIHRoZSBuZXcgZ3JvdXAgZm9yIHRoZSBpdGVtIHRoYXQncyBhY3R1YWxseSBkcmFnZ2VkXG4gICAgICB2YXIgc2VsZWN0ZWRJdGVtID0gdGhpcy50b3VjaFBhcmFtcy5zZWxlY3RlZEl0ZW07XG4gICAgICB2YXIgdXBkYXRlR3JvdXBBbGxvd2VkID0gbWUub3B0aW9ucy5lZGl0YWJsZS51cGRhdGVHcm91cDtcbiAgICAgIHZhciBuZXdHcm91cEJhc2UgPSBudWxsO1xuICAgICAgaWYgKHVwZGF0ZUdyb3VwQWxsb3dlZCAmJiBzZWxlY3RlZEl0ZW0pIHtcbiAgICAgICAgaWYgKHNlbGVjdGVkSXRlbS5kYXRhLmdyb3VwICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIGRyYWcgZnJvbSBvbmUgZ3JvdXAgdG8gYW5vdGhlclxuICAgICAgICAgIHZhciBncm91cCA9IG1lLmdyb3VwRnJvbVRhcmdldChldmVudCk7XG4gICAgICAgICAgaWYgKGdyb3VwKSB7XG4gICAgICAgICAgICAvL3dlIGtub3cgdGhlIG9mZnNldCBmb3IgYWxsIGl0ZW1zLCBzbyB0aGUgbmV3IGdyb3VwIGZvciBhbGwgaXRlbXNcbiAgICAgICAgICAgIC8vd2lsbCBiZSByZWxhdGl2ZSB0byB0aGlzIG9uZS5cbiAgICAgICAgICAgIG5ld0dyb3VwQmFzZSA9IHRoaXMuX2dldEdyb3VwSW5kZXgoZ3JvdXAuZ3JvdXBJZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG1vdmVcbiAgICAgIHRoaXMudG91Y2hQYXJhbXMuaXRlbVByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gbWUuYm9keS51dGlsLnRvVGltZShldmVudC5jZW50ZXIueCAtIHhPZmZzZXQpO1xuICAgICAgICB2YXIgaW5pdGlhbCA9IG1lLmJvZHkudXRpbC50b1RpbWUocHJvcHMuaW5pdGlhbFggLSB4T2Zmc2V0KTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgICAgIHZhciBvZmZzZXQgPSAtKGN1cnJlbnQgLSBpbml0aWFsKTsgLy8gbXNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBjdXJyZW50IC0gaW5pdGlhbDsgLy8gbXNcbiAgICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZW1EYXRhID0gdGhpcy5fY2xvbmVJdGVtRGF0YShwcm9wcy5pdGVtLmRhdGEpOyAvLyBjbG9uZSB0aGUgZGF0YVxuICAgICAgICBpZiAocHJvcHMuaXRlbS5lZGl0YWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdXBkYXRlVGltZUFsbG93ZWQgPSBtZS5vcHRpb25zLmVkaXRhYmxlLnVwZGF0ZVRpbWUgfHwgcHJvcHMuaXRlbS5lZGl0YWJsZSA9PT0gdHJ1ZTtcbiAgICAgICAgaWYgKHVwZGF0ZVRpbWVBbGxvd2VkKSB7XG4gICAgICAgICAgaWYgKHByb3BzLmRyYWdMZWZ0KSB7XG4gICAgICAgICAgICAvLyBkcmFnIGxlZnQgc2lkZSBvZiBhIHJhbmdlIGl0ZW1cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucnRsKSB7XG4gICAgICAgICAgICAgIGlmIChpdGVtRGF0YS5lbmQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluaXRpYWxFbmQgPSB1dGlsLmNvbnZlcnQocHJvcHMuZGF0YS5lbmQsICdEYXRlJyk7XG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IG5ldyBEYXRlKGluaXRpYWxFbmQudmFsdWVPZigpICsgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBwYXNzIGEgTW9tZW50IGluc3RlYWQgb2YgYSBEYXRlIHRvIHNuYXAoKS4gKEJyZWFraW5nIGNoYW5nZSlcbiAgICAgICAgICAgICAgICBpdGVtRGF0YS5lbmQgPSBzbmFwID8gc25hcChlbmQsIHNjYWxlLCBzdGVwKSA6IGVuZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGl0ZW1EYXRhLnN0YXJ0ICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBpbml0aWFsU3RhcnQgPSB1dGlsLmNvbnZlcnQocHJvcHMuZGF0YS5zdGFydCwgJ0RhdGUnKTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBuZXcgRGF0ZShpbml0aWFsU3RhcnQudmFsdWVPZigpICsgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBwYXNzIGEgTW9tZW50IGluc3RlYWQgb2YgYSBEYXRlIHRvIHNuYXAoKS4gKEJyZWFraW5nIGNoYW5nZSlcbiAgICAgICAgICAgICAgICBpdGVtRGF0YS5zdGFydCA9IHNuYXAgPyBzbmFwKHN0YXJ0LCBzY2FsZSwgc3RlcCkgOiBzdGFydDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAocHJvcHMuZHJhZ1JpZ2h0KSB7XG4gICAgICAgICAgICAvLyBkcmFnIHJpZ2h0IHNpZGUgb2YgYSByYW5nZSBpdGVtXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgICAgICAgICBpZiAoaXRlbURhdGEuc3RhcnQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluaXRpYWxTdGFydCA9IHV0aWwuY29udmVydChwcm9wcy5kYXRhLnN0YXJ0LCAnRGF0ZScpO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IG5ldyBEYXRlKGluaXRpYWxTdGFydC52YWx1ZU9mKCkgKyBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IHBhc3MgYSBNb21lbnQgaW5zdGVhZCBvZiBhIERhdGUgdG8gc25hcCgpLiAoQnJlYWtpbmcgY2hhbmdlKVxuICAgICAgICAgICAgICAgIGl0ZW1EYXRhLnN0YXJ0ID0gc25hcCA/IHNuYXAoc3RhcnQsIHNjYWxlLCBzdGVwKSA6IHN0YXJ0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoaXRlbURhdGEuZW5kICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBpbml0aWFsRW5kID0gdXRpbC5jb252ZXJ0KHByb3BzLmRhdGEuZW5kLCAnRGF0ZScpO1xuICAgICAgICAgICAgICAgIHZhciBlbmQgPSBuZXcgRGF0ZShpbml0aWFsRW5kLnZhbHVlT2YoKSArIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogcGFzcyBhIE1vbWVudCBpbnN0ZWFkIG9mIGEgRGF0ZSB0byBzbmFwKCkuIChCcmVha2luZyBjaGFuZ2UpXG4gICAgICAgICAgICAgICAgaXRlbURhdGEuZW5kID0gc25hcCA/IHNuYXAoZW5kLCBzY2FsZSwgc3RlcCkgOiBlbmQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZHJhZyBib3RoIHN0YXJ0IGFuZCBlbmRcbiAgICAgICAgICAgIGlmIChpdGVtRGF0YS5zdGFydCAhPSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgICB2YXIgaW5pdGlhbFN0YXJ0ID0gdXRpbC5jb252ZXJ0KHByb3BzLmRhdGEuc3RhcnQsICdEYXRlJykudmFsdWVPZigpO1xuICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBuZXcgRGF0ZShpbml0aWFsU3RhcnQgKyBvZmZzZXQpO1xuXG4gICAgICAgICAgICAgIGlmIChpdGVtRGF0YS5lbmQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluaXRpYWxFbmQgPSB1dGlsLmNvbnZlcnQocHJvcHMuZGF0YS5lbmQsICdEYXRlJyk7XG4gICAgICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gaW5pdGlhbEVuZC52YWx1ZU9mKCkgLSBpbml0aWFsU3RhcnQudmFsdWVPZigpO1xuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogcGFzcyBhIE1vbWVudCBpbnN0ZWFkIG9mIGEgRGF0ZSB0byBzbmFwKCkuIChCcmVha2luZyBjaGFuZ2UpXG4gICAgICAgICAgICAgICAgaXRlbURhdGEuc3RhcnQgPSBzbmFwID8gc25hcChzdGFydCwgc2NhbGUsIHN0ZXApIDogc3RhcnQ7XG4gICAgICAgICAgICAgICAgaXRlbURhdGEuZW5kID0gbmV3IERhdGUoaXRlbURhdGEuc3RhcnQudmFsdWVPZigpICsgZHVyYXRpb24pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IHBhc3MgYSBNb21lbnQgaW5zdGVhZCBvZiBhIERhdGUgdG8gc25hcCgpLiAoQnJlYWtpbmcgY2hhbmdlKVxuICAgICAgICAgICAgICAgIGl0ZW1EYXRhLnN0YXJ0ID0gc25hcCA/IHNuYXAoc3RhcnQsIHNjYWxlLCBzdGVwKSA6IHN0YXJ0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHVwZGF0ZUdyb3VwQWxsb3dlZCA9IG1lLm9wdGlvbnMuZWRpdGFibGUudXBkYXRlR3JvdXAgfHwgcHJvcHMuaXRlbS5lZGl0YWJsZSA9PT0gdHJ1ZTtcblxuICAgICAgICBpZiAodXBkYXRlR3JvdXBBbGxvd2VkICYmICFwcm9wcy5kcmFnTGVmdCAmJiAhcHJvcHMuZHJhZ1JpZ2h0ICYmIG5ld0dyb3VwQmFzZSAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKGl0ZW1EYXRhLmdyb3VwICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIG5ld09mZnNldCA9IG5ld0dyb3VwQmFzZSAtIHByb3BzLmdyb3VwT2Zmc2V0O1xuXG4gICAgICAgICAgICAvL21ha2Ugc3VyZSB3ZSBzdGF5IGluIGJvdW5kc1xuICAgICAgICAgICAgbmV3T2Zmc2V0ID0gTWF0aC5tYXgoMCwgbmV3T2Zmc2V0KTtcbiAgICAgICAgICAgIG5ld09mZnNldCA9IE1hdGgubWluKG1lLmdyb3VwSWRzLmxlbmd0aCAtIDEsIG5ld09mZnNldCk7XG5cbiAgICAgICAgICAgIGl0ZW1EYXRhLmdyb3VwID0gbWUuZ3JvdXBJZHNbbmV3T2Zmc2V0XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25maXJtIG1vdmluZyB0aGUgaXRlbVxuICAgICAgICBpdGVtRGF0YSA9IHRoaXMuX2Nsb25lSXRlbURhdGEoaXRlbURhdGEpOyAvLyBjb252ZXJ0IHN0YXJ0IGFuZCBlbmQgdG8gdGhlIGNvcnJlY3QgdHlwZVxuICAgICAgICBtZS5vcHRpb25zLm9uTW92aW5nKGl0ZW1EYXRhLCBmdW5jdGlvbiAoaXRlbURhdGEpIHtcbiAgICAgICAgICBpZiAoaXRlbURhdGEpIHtcbiAgICAgICAgICAgIHByb3BzLml0ZW0uc2V0RGF0YSh0aGlzLl9jbG9uZUl0ZW1EYXRhKGl0ZW1EYXRhLCAnRGF0ZScpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICB0aGlzLnN0YWNrRGlydHkgPSB0cnVlOyAvLyBmb3JjZSByZS1zdGFja2luZyBvZiBhbGwgaXRlbXMgbmV4dCByZWRyYXdcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19jaGFuZ2UnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIE1vdmUgYW4gaXRlbSB0byBhbm90aGVyIGdyb3VwXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlcn0gZ3JvdXBJZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUuX21vdmVUb0dyb3VwID0gZnVuY3Rpb24gKGl0ZW0sIGdyb3VwSWQpIHtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3Vwc1tncm91cElkXTtcbiAgICBpZiAoZ3JvdXAgJiYgZ3JvdXAuZ3JvdXBJZCAhPSBpdGVtLmRhdGEuZ3JvdXApIHtcbiAgICAgIHZhciBvbGRHcm91cCA9IGl0ZW0ucGFyZW50O1xuICAgICAgb2xkR3JvdXAucmVtb3ZlKGl0ZW0pO1xuICAgICAgb2xkR3JvdXAub3JkZXIoKTtcbiAgICAgIGdyb3VwLmFkZChpdGVtKTtcbiAgICAgIGdyb3VwLm9yZGVyKCk7XG5cbiAgICAgIGl0ZW0uZGF0YS5ncm91cCA9IGdyb3VwLmdyb3VwSWQ7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBFbmQgb2YgZHJhZ2dpbmcgc2VsZWN0ZWQgaXRlbXNcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLl9vbkRyYWdFbmQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAodGhpcy50b3VjaFBhcmFtcy5pdGVtUHJvcHMpIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgdmFyIGRhdGFzZXQgPSB0aGlzLml0ZW1zRGF0YS5nZXREYXRhU2V0KCk7XG4gICAgICB2YXIgaXRlbVByb3BzID0gdGhpcy50b3VjaFBhcmFtcy5pdGVtUHJvcHM7XG4gICAgICB0aGlzLnRvdWNoUGFyYW1zLml0ZW1Qcm9wcyA9IG51bGw7XG5cbiAgICAgIGl0ZW1Qcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgICB2YXIgaWQgPSBwcm9wcy5pdGVtLmlkO1xuICAgICAgICB2YXIgZXhpc3RzID0gbWUuaXRlbXNEYXRhLmdldChpZCwgbWUuaXRlbU9wdGlvbnMpICE9IG51bGw7XG5cbiAgICAgICAgaWYgKCFleGlzdHMpIHtcbiAgICAgICAgICAvLyBhZGQgYSBuZXcgaXRlbVxuICAgICAgICAgIG1lLm9wdGlvbnMub25BZGQocHJvcHMuaXRlbS5kYXRhLCBmdW5jdGlvbiAoaXRlbURhdGEpIHtcbiAgICAgICAgICAgIG1lLl9yZW1vdmVJdGVtKHByb3BzLml0ZW0pOyAvLyByZW1vdmUgdGVtcG9yYXJ5IGl0ZW1cbiAgICAgICAgICAgIGlmIChpdGVtRGF0YSkge1xuICAgICAgICAgICAgICBtZS5pdGVtc0RhdGEuZ2V0RGF0YVNldCgpLmFkZChpdGVtRGF0YSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGZvcmNlIHJlLXN0YWNraW5nIG9mIGFsbCBpdGVtcyBuZXh0IHJlZHJhd1xuICAgICAgICAgICAgbWUuc3RhY2tEaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICBtZS5ib2R5LmVtaXR0ZXIuZW1pdCgnX2NoYW5nZScpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHVwZGF0ZSBleGlzdGluZyBpdGVtXG4gICAgICAgICAgdmFyIGl0ZW1EYXRhID0gdGhpcy5fY2xvbmVJdGVtRGF0YShwcm9wcy5pdGVtLmRhdGEpOyAvLyBjb252ZXJ0IHN0YXJ0IGFuZCBlbmQgdG8gdGhlIGNvcnJlY3QgdHlwZVxuICAgICAgICAgIG1lLm9wdGlvbnMub25Nb3ZlKGl0ZW1EYXRhLCBmdW5jdGlvbiAoaXRlbURhdGEpIHtcbiAgICAgICAgICAgIGlmIChpdGVtRGF0YSkge1xuICAgICAgICAgICAgICAvLyBhcHBseSBjaGFuZ2VzXG4gICAgICAgICAgICAgIGl0ZW1EYXRhW2RhdGFzZXQuX2ZpZWxkSWRdID0gaWQ7IC8vIGVuc3VyZSB0aGUgaXRlbSBjb250YWlucyBpdHMgaWQgKGNhbiBiZSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgIGRhdGFzZXQudXBkYXRlKGl0ZW1EYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHJlc3RvcmUgb3JpZ2luYWwgdmFsdWVzXG4gICAgICAgICAgICAgIHByb3BzLml0ZW0uc2V0RGF0YShwcm9wcy5kYXRhKTtcblxuICAgICAgICAgICAgICBtZS5zdGFja0RpcnR5ID0gdHJ1ZTsgLy8gZm9yY2UgcmUtc3RhY2tpbmcgb2YgYWxsIGl0ZW1zIG5leHQgcmVkcmF3XG4gICAgICAgICAgICAgIG1lLmJvZHkuZW1pdHRlci5lbWl0KCdfY2hhbmdlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfVxuICB9O1xuXG4gIEl0ZW1TZXQucHJvdG90eXBlLl9vbkdyb3VwRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ncm91cEVkaXRhYmxlLm9yZGVyKSB7XG4gICAgICB0aGlzLmdyb3VwVG91Y2hQYXJhbXMuZ3JvdXAgPSB0aGlzLmdyb3VwRnJvbVRhcmdldChldmVudCk7XG5cbiAgICAgIGlmICh0aGlzLmdyb3VwVG91Y2hQYXJhbXMuZ3JvdXApIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgdGhpcy5ncm91cFRvdWNoUGFyYW1zLm9yaWdpbmFsT3JkZXIgPSB0aGlzLmdyb3Vwc0RhdGEuZ2V0SWRzKHtcbiAgICAgICAgICBvcmRlcjogdGhpcy5vcHRpb25zLmdyb3VwT3JkZXJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEl0ZW1TZXQucHJvdG90eXBlLl9vbkdyb3VwRHJhZyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZ3JvdXBFZGl0YWJsZS5vcmRlciAmJiB0aGlzLmdyb3VwVG91Y2hQYXJhbXMuZ3JvdXApIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAvLyBkcmFnIGZyb20gb25lIGdyb3VwIHRvIGFub3RoZXJcbiAgICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXBGcm9tVGFyZ2V0KGV2ZW50KTtcblxuICAgICAgLy8gdHJ5IHRvIGF2b2lkIHRvZ2dsaW5nIHdoZW4gZ3JvdXBzIGRpZmZlciBpbiBoZWlnaHRcbiAgICAgIGlmIChncm91cCAmJiBncm91cC5oZWlnaHQgIT0gdGhpcy5ncm91cFRvdWNoUGFyYW1zLmdyb3VwLmhlaWdodCkge1xuICAgICAgICB2YXIgbW92aW5nVXAgPSBncm91cC50b3AgPCB0aGlzLmdyb3VwVG91Y2hQYXJhbXMuZ3JvdXAudG9wO1xuICAgICAgICB2YXIgY2xpZW50WSA9IGV2ZW50LmNlbnRlciA/IGV2ZW50LmNlbnRlci55IDogZXZlbnQuY2xpZW50WTtcbiAgICAgICAgdmFyIHRhcmdldEdyb3VwVG9wID0gdXRpbC5nZXRBYnNvbHV0ZVRvcChncm91cC5kb20uZm9yZWdyb3VuZCk7XG4gICAgICAgIHZhciBkcmFnZ2VkR3JvdXBIZWlnaHQgPSB0aGlzLmdyb3VwVG91Y2hQYXJhbXMuZ3JvdXAuaGVpZ2h0O1xuICAgICAgICBpZiAobW92aW5nVXApIHtcbiAgICAgICAgICAvLyBza2lwIHN3YXBwaW5nIHRoZSBncm91cHMgd2hlbiB0aGUgZHJhZ2dlZCBncm91cCBpcyBub3QgYmVsb3cgY2xpZW50WSBhZnRlcndhcmRzXG4gICAgICAgICAgaWYgKHRhcmdldEdyb3VwVG9wICsgZHJhZ2dlZEdyb3VwSGVpZ2h0IDwgY2xpZW50WSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdGFyZ2V0R3JvdXBIZWlnaHQgPSBncm91cC5oZWlnaHQ7XG4gICAgICAgICAgLy8gc2tpcCBzd2FwcGluZyB0aGUgZ3JvdXBzIHdoZW4gdGhlIGRyYWdnZWQgZ3JvdXAgaXMgbm90IGJlbG93IGNsaWVudFkgYWZ0ZXJ3YXJkc1xuICAgICAgICAgIGlmICh0YXJnZXRHcm91cFRvcCArIHRhcmdldEdyb3VwSGVpZ2h0IC0gZHJhZ2dlZEdyb3VwSGVpZ2h0ID4gY2xpZW50WSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZ3JvdXAgJiYgZ3JvdXAgIT0gdGhpcy5ncm91cFRvdWNoUGFyYW1zLmdyb3VwKSB7XG4gICAgICAgIHZhciBncm91cHNEYXRhID0gdGhpcy5ncm91cHNEYXRhO1xuICAgICAgICB2YXIgdGFyZ2V0R3JvdXAgPSBncm91cHNEYXRhLmdldChncm91cC5ncm91cElkKTtcbiAgICAgICAgdmFyIGRyYWdnZWRHcm91cCA9IGdyb3Vwc0RhdGEuZ2V0KHRoaXMuZ3JvdXBUb3VjaFBhcmFtcy5ncm91cC5ncm91cElkKTtcblxuICAgICAgICAvLyBzd2l0Y2ggZ3JvdXBzXG4gICAgICAgIGlmIChkcmFnZ2VkR3JvdXAgJiYgdGFyZ2V0R3JvdXApIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZ3JvdXBPcmRlclN3YXAoZHJhZ2dlZEdyb3VwLCB0YXJnZXRHcm91cCwgdGhpcy5ncm91cHNEYXRhKTtcbiAgICAgICAgICB0aGlzLmdyb3Vwc0RhdGEudXBkYXRlKGRyYWdnZWRHcm91cCk7XG4gICAgICAgICAgdGhpcy5ncm91cHNEYXRhLnVwZGF0ZSh0YXJnZXRHcm91cCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmZXRjaCBjdXJyZW50IG9yZGVyIG9mIGdyb3Vwc1xuICAgICAgICB2YXIgbmV3T3JkZXIgPSB0aGlzLmdyb3Vwc0RhdGEuZ2V0SWRzKHtcbiAgICAgICAgICBvcmRlcjogdGhpcy5vcHRpb25zLmdyb3VwT3JkZXJcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gaW4gY2FzZSBvZiBjaGFuZ2VzIHNpbmNlIF9vbkdyb3VwRHJhZ1N0YXJ0XG4gICAgICAgIGlmICghdXRpbC5lcXVhbEFycmF5KG5ld09yZGVyLCB0aGlzLmdyb3VwVG91Y2hQYXJhbXMub3JpZ2luYWxPcmRlcikpIHtcbiAgICAgICAgICB2YXIgZ3JvdXBzRGF0YSA9IHRoaXMuZ3JvdXBzRGF0YTtcbiAgICAgICAgICB2YXIgb3JpZ09yZGVyID0gdGhpcy5ncm91cFRvdWNoUGFyYW1zLm9yaWdpbmFsT3JkZXI7XG4gICAgICAgICAgdmFyIGRyYWdnZWRJZCA9IHRoaXMuZ3JvdXBUb3VjaFBhcmFtcy5ncm91cC5ncm91cElkO1xuICAgICAgICAgIHZhciBudW1Hcm91cHMgPSBNYXRoLm1pbihvcmlnT3JkZXIubGVuZ3RoLCBuZXdPcmRlci5sZW5ndGgpO1xuICAgICAgICAgIHZhciBjdXJQb3MgPSAwO1xuICAgICAgICAgIHZhciBuZXdPZmZzZXQgPSAwO1xuICAgICAgICAgIHZhciBvcmdPZmZzZXQgPSAwO1xuICAgICAgICAgIHdoaWxlIChjdXJQb3MgPCBudW1Hcm91cHMpIHtcbiAgICAgICAgICAgIC8vIGFzIGxvbmcgYXMgdGhlIGdyb3VwcyBhcmUgd2hlcmUgdGhleSBzaG91bGQgYmUgc3RlcCBkb3duIGFsb25nIHRoZSBncm91cHMgb3JkZXJcbiAgICAgICAgICAgIHdoaWxlIChjdXJQb3MgKyBuZXdPZmZzZXQgPCBudW1Hcm91cHMgJiYgY3VyUG9zICsgb3JnT2Zmc2V0IDwgbnVtR3JvdXBzICYmIG5ld09yZGVyW2N1clBvcyArIG5ld09mZnNldF0gPT0gb3JpZ09yZGVyW2N1clBvcyArIG9yZ09mZnNldF0pIHtcbiAgICAgICAgICAgICAgY3VyUG9zKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFsbCBva1xuICAgICAgICAgICAgaWYgKGN1clBvcyArIG5ld09mZnNldCA+PSBudW1Hcm91cHMpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG5vdCBhbGwgb2tcbiAgICAgICAgICAgIC8vIGlmIGRyYWdnZWQgZ3JvdXAgd2FzIG1vdmUgdXB3YXJkcyBldmVyeXRoaW5nIGJlbG93IHNob3VsZCBoYXZlIGFuIG9mZnNldFxuICAgICAgICAgICAgaWYgKG5ld09yZGVyW2N1clBvcyArIG5ld09mZnNldF0gPT0gZHJhZ2dlZElkKSB7XG4gICAgICAgICAgICAgIG5ld09mZnNldCA9IDE7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgZHJhZ2dlZCBncm91cCB3YXMgbW92ZSBkb3dud2FyZHMgZXZlcnl0aGluZyBhYm92ZSBzaG91bGQgaGF2ZSBhbiBvZmZzZXRcbiAgICAgICAgICAgIGVsc2UgaWYgKG9yaWdPcmRlcltjdXJQb3MgKyBvcmdPZmZzZXRdID09IGRyYWdnZWRJZCkge1xuICAgICAgICAgICAgICAgIG9yZ09mZnNldCA9IDE7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gZm91bmQgYSBncm91cCAoYXBhcnQgZnJvbSBkcmFnZ2VkIGdyb3VwKSB0aGF0IGhhcyB0aGUgd3JvbmcgcG9zaXRpb24gLT4gc3dpdGNoIHdpdGggdGhlXG4gICAgICAgICAgICAgIC8vIGdyb3VwIGF0IHRoZSBwb3NpdGlvbiB3aGVyZSBvdGhlciBvbmUgc2hvdWxkIGJlLCBmaXggaW5kZXggYXJyYXlzIGFuZCBjb250aW51ZVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciBzbGlwcGVkUG9zaXRpb24gPSBuZXdPcmRlci5pbmRleE9mKG9yaWdPcmRlcltjdXJQb3MgKyBvcmdPZmZzZXRdKTtcbiAgICAgICAgICAgICAgICAgIHZhciBzd2l0Y2hHcm91cCA9IGdyb3Vwc0RhdGEuZ2V0KG5ld09yZGVyW2N1clBvcyArIG5ld09mZnNldF0pO1xuICAgICAgICAgICAgICAgICAgdmFyIHNob3VsZEJlR3JvdXAgPSBncm91cHNEYXRhLmdldChvcmlnT3JkZXJbY3VyUG9zICsgb3JnT2Zmc2V0XSk7XG4gICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZ3JvdXBPcmRlclN3YXAoc3dpdGNoR3JvdXAsIHNob3VsZEJlR3JvdXAsIGdyb3Vwc0RhdGEpO1xuICAgICAgICAgICAgICAgICAgZ3JvdXBzRGF0YS51cGRhdGUoc3dpdGNoR3JvdXApO1xuICAgICAgICAgICAgICAgICAgZ3JvdXBzRGF0YS51cGRhdGUoc2hvdWxkQmVHcm91cCk7XG5cbiAgICAgICAgICAgICAgICAgIHZhciBzd2l0Y2hHcm91cElkID0gbmV3T3JkZXJbY3VyUG9zICsgbmV3T2Zmc2V0XTtcbiAgICAgICAgICAgICAgICAgIG5ld09yZGVyW2N1clBvcyArIG5ld09mZnNldF0gPSBvcmlnT3JkZXJbY3VyUG9zICsgb3JnT2Zmc2V0XTtcbiAgICAgICAgICAgICAgICAgIG5ld09yZGVyW3NsaXBwZWRQb3NpdGlvbl0gPSBzd2l0Y2hHcm91cElkO1xuXG4gICAgICAgICAgICAgICAgICBjdXJQb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEl0ZW1TZXQucHJvdG90eXBlLl9vbkdyb3VwRHJhZ0VuZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZ3JvdXBFZGl0YWJsZS5vcmRlciAmJiB0aGlzLmdyb3VwVG91Y2hQYXJhbXMuZ3JvdXApIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAvLyB1cGRhdGUgZXhpc3RpbmcgZ3JvdXBcbiAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICB2YXIgaWQgPSBtZS5ncm91cFRvdWNoUGFyYW1zLmdyb3VwLmdyb3VwSWQ7XG4gICAgICB2YXIgZGF0YXNldCA9IG1lLmdyb3Vwc0RhdGEuZ2V0RGF0YVNldCgpO1xuICAgICAgdmFyIGdyb3VwRGF0YSA9IHV0aWwuZXh0ZW5kKHt9LCBkYXRhc2V0LmdldChpZCkpOyAvLyBjbG9uZSB0aGUgZGF0YVxuICAgICAgbWUub3B0aW9ucy5vbk1vdmVHcm91cChncm91cERhdGEsIGZ1bmN0aW9uIChncm91cERhdGEpIHtcbiAgICAgICAgaWYgKGdyb3VwRGF0YSkge1xuICAgICAgICAgIC8vIGFwcGx5IGNoYW5nZXNcbiAgICAgICAgICBncm91cERhdGFbZGF0YXNldC5fZmllbGRJZF0gPSBpZDsgLy8gZW5zdXJlIHRoZSBncm91cCBjb250YWlucyBpdHMgaWQgKGNhbiBiZSB1bmRlZmluZWQpXG4gICAgICAgICAgZGF0YXNldC51cGRhdGUoZ3JvdXBEYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIC8vIGZldGNoIGN1cnJlbnQgb3JkZXIgb2YgZ3JvdXBzXG4gICAgICAgICAgdmFyIG5ld09yZGVyID0gZGF0YXNldC5nZXRJZHMoe1xuICAgICAgICAgICAgb3JkZXI6IG1lLm9wdGlvbnMuZ3JvdXBPcmRlclxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gcmVzdG9yZSBvcmlnaW5hbCBvcmRlclxuICAgICAgICAgIGlmICghdXRpbC5lcXVhbEFycmF5KG5ld09yZGVyLCBtZS5ncm91cFRvdWNoUGFyYW1zLm9yaWdpbmFsT3JkZXIpKSB7XG4gICAgICAgICAgICB2YXIgb3JpZ09yZGVyID0gbWUuZ3JvdXBUb3VjaFBhcmFtcy5vcmlnaW5hbE9yZGVyO1xuICAgICAgICAgICAgdmFyIG51bUdyb3VwcyA9IE1hdGgubWluKG9yaWdPcmRlci5sZW5ndGgsIG5ld09yZGVyLmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgY3VyUG9zID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJQb3MgPCBudW1Hcm91cHMpIHtcbiAgICAgICAgICAgICAgLy8gYXMgbG9uZyBhcyB0aGUgZ3JvdXBzIGFyZSB3aGVyZSB0aGV5IHNob3VsZCBiZSBzdGVwIGRvd24gYWxvbmcgdGhlIGdyb3VwcyBvcmRlclxuICAgICAgICAgICAgICB3aGlsZSAoY3VyUG9zIDwgbnVtR3JvdXBzICYmIG5ld09yZGVyW2N1clBvc10gPT0gb3JpZ09yZGVyW2N1clBvc10pIHtcbiAgICAgICAgICAgICAgICBjdXJQb3MrKztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIGFsbCBva1xuICAgICAgICAgICAgICBpZiAoY3VyUG9zID49IG51bUdyb3Vwcykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gZm91bmQgYSBncm91cCB0aGF0IGhhcyB0aGUgd3JvbmcgcG9zaXRpb24gLT4gc3dpdGNoIHdpdGggdGhlXG4gICAgICAgICAgICAgIC8vIGdyb3VwIGF0IHRoZSBwb3NpdGlvbiB3aGVyZSBvdGhlciBvbmUgc2hvdWxkIGJlLCBmaXggaW5kZXggYXJyYXlzIGFuZCBjb250aW51ZVxuICAgICAgICAgICAgICB2YXIgc2xpcHBlZFBvc2l0aW9uID0gbmV3T3JkZXIuaW5kZXhPZihvcmlnT3JkZXJbY3VyUG9zXSk7XG4gICAgICAgICAgICAgIHZhciBzd2l0Y2hHcm91cCA9IGRhdGFzZXQuZ2V0KG5ld09yZGVyW2N1clBvc10pO1xuICAgICAgICAgICAgICB2YXIgc2hvdWxkQmVHcm91cCA9IGRhdGFzZXQuZ2V0KG9yaWdPcmRlcltjdXJQb3NdKTtcbiAgICAgICAgICAgICAgbWUub3B0aW9ucy5ncm91cE9yZGVyU3dhcChzd2l0Y2hHcm91cCwgc2hvdWxkQmVHcm91cCwgZGF0YXNldCk7XG4gICAgICAgICAgICAgIGdyb3Vwc0RhdGEudXBkYXRlKHN3aXRjaEdyb3VwKTtcbiAgICAgICAgICAgICAgZ3JvdXBzRGF0YS51cGRhdGUoc2hvdWxkQmVHcm91cCk7XG5cbiAgICAgICAgICAgICAgdmFyIHN3aXRjaEdyb3VwSWQgPSBuZXdPcmRlcltjdXJQb3NdO1xuICAgICAgICAgICAgICBuZXdPcmRlcltjdXJQb3NdID0gb3JpZ09yZGVyW2N1clBvc107XG4gICAgICAgICAgICAgIG5ld09yZGVyW3NsaXBwZWRQb3NpdGlvbl0gPSBzd2l0Y2hHcm91cElkO1xuXG4gICAgICAgICAgICAgIGN1clBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIG1lLmJvZHkuZW1pdHRlci5lbWl0KCdncm91cERyYWdnZWQnLCB7IGdyb3VwSWQ6IGlkIH0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIHNlbGVjdGluZy9kZXNlbGVjdGluZyBhbiBpdGVtIHdoZW4gdGFwcGluZyBpdFxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUuX29uU2VsZWN0SXRlbSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmICghdGhpcy5vcHRpb25zLnNlbGVjdGFibGUpIHJldHVybjtcblxuICAgIHZhciBjdHJsS2V5ID0gZXZlbnQuc3JjRXZlbnQgJiYgKGV2ZW50LnNyY0V2ZW50LmN0cmxLZXkgfHwgZXZlbnQuc3JjRXZlbnQubWV0YUtleSk7XG4gICAgdmFyIHNoaWZ0S2V5ID0gZXZlbnQuc3JjRXZlbnQgJiYgZXZlbnQuc3JjRXZlbnQuc2hpZnRLZXk7XG4gICAgaWYgKGN0cmxLZXkgfHwgc2hpZnRLZXkpIHtcbiAgICAgIHRoaXMuX29uTXVsdGlTZWxlY3RJdGVtKGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgb2xkU2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcblxuICAgIHZhciBpdGVtID0gdGhpcy5pdGVtRnJvbVRhcmdldChldmVudCk7XG4gICAgdmFyIHNlbGVjdGlvbiA9IGl0ZW0gPyBbaXRlbS5pZF0gOiBbXTtcbiAgICB0aGlzLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuXG4gICAgdmFyIG5ld1NlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAvLyBlbWl0IGEgc2VsZWN0IGV2ZW50LFxuICAgIC8vIGV4Y2VwdCB3aGVuIG9sZCBzZWxlY3Rpb24gaXMgZW1wdHkgYW5kIG5ldyBzZWxlY3Rpb24gaXMgc3RpbGwgZW1wdHlcbiAgICBpZiAobmV3U2VsZWN0aW9uLmxlbmd0aCA+IDAgfHwgb2xkU2VsZWN0aW9uLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3NlbGVjdCcsIHtcbiAgICAgICAgaXRlbXM6IG5ld1NlbGVjdGlvbixcbiAgICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBjcmVhdGlvbiBhbmQgdXBkYXRlcyBvZiBhbiBpdGVtIG9uIGRvdWJsZSB0YXBcbiAgICogQHBhcmFtIGV2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBJdGVtU2V0LnByb3RvdHlwZS5fb25BZGRJdGVtID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuc2VsZWN0YWJsZSkgcmV0dXJuO1xuICAgIGlmICghdGhpcy5vcHRpb25zLmVkaXRhYmxlLmFkZCkgcmV0dXJuO1xuXG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgc25hcCA9IHRoaXMub3B0aW9ucy5zbmFwIHx8IG51bGw7XG4gICAgdmFyIGl0ZW0gPSB0aGlzLml0ZW1Gcm9tVGFyZ2V0KGV2ZW50KTtcblxuICAgIGlmIChpdGVtKSB7XG4gICAgICAvLyB1cGRhdGUgaXRlbVxuXG4gICAgICAvLyBleGVjdXRlIGFzeW5jIGhhbmRsZXIgdG8gdXBkYXRlIHRoZSBpdGVtIChvciBjYW5jZWwgaXQpXG4gICAgICB2YXIgaXRlbURhdGEgPSBtZS5pdGVtc0RhdGEuZ2V0KGl0ZW0uaWQpOyAvLyBnZXQgYSBjbG9uZSBvZiB0aGUgZGF0YSBmcm9tIHRoZSBkYXRhc2V0XG4gICAgICB0aGlzLm9wdGlvbnMub25VcGRhdGUoaXRlbURhdGEsIGZ1bmN0aW9uIChpdGVtRGF0YSkge1xuICAgICAgICBpZiAoaXRlbURhdGEpIHtcbiAgICAgICAgICBtZS5pdGVtc0RhdGEuZ2V0RGF0YVNldCgpLnVwZGF0ZShpdGVtRGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhZGQgaXRlbVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgICAgdmFyIHhBYnMgPSB1dGlsLmdldEFic29sdXRlUmlnaHQodGhpcy5kb20uZnJhbWUpO1xuICAgICAgICB2YXIgeCA9IHhBYnMgLSBldmVudC5jZW50ZXIueDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB4QWJzID0gdXRpbC5nZXRBYnNvbHV0ZUxlZnQodGhpcy5kb20uZnJhbWUpO1xuICAgICAgICB2YXIgeCA9IGV2ZW50LmNlbnRlci54IC0geEFicztcbiAgICAgIH1cbiAgICAgIC8vIHZhciB4QWJzID0gdXRpbC5nZXRBYnNvbHV0ZUxlZnQodGhpcy5kb20uZnJhbWUpO1xuICAgICAgLy8gdmFyIHggPSBldmVudC5jZW50ZXIueCAtIHhBYnM7XG4gICAgICB2YXIgc3RhcnQgPSB0aGlzLmJvZHkudXRpbC50b1RpbWUoeCk7XG4gICAgICB2YXIgc2NhbGUgPSB0aGlzLmJvZHkudXRpbC5nZXRTY2FsZSgpO1xuICAgICAgdmFyIHN0ZXAgPSB0aGlzLmJvZHkudXRpbC5nZXRTdGVwKCk7XG5cbiAgICAgIHZhciBuZXdJdGVtRGF0YSA9IHtcbiAgICAgICAgc3RhcnQ6IHNuYXAgPyBzbmFwKHN0YXJ0LCBzY2FsZSwgc3RlcCkgOiBzdGFydCxcbiAgICAgICAgY29udGVudDogJ25ldyBpdGVtJ1xuICAgICAgfTtcblxuICAgICAgLy8gd2hlbiBkZWZhdWx0IHR5cGUgaXMgYSByYW5nZSwgYWRkIGEgZGVmYXVsdCBlbmQgZGF0ZSB0byB0aGUgbmV3IGl0ZW1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudHlwZSA9PT0gJ3JhbmdlJykge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5ib2R5LnV0aWwudG9UaW1lKHggKyB0aGlzLnByb3BzLndpZHRoIC8gNSk7XG4gICAgICAgIG5ld0l0ZW1EYXRhLmVuZCA9IHNuYXAgPyBzbmFwKGVuZCwgc2NhbGUsIHN0ZXApIDogZW5kO1xuICAgICAgfVxuXG4gICAgICBuZXdJdGVtRGF0YVt0aGlzLml0ZW1zRGF0YS5fZmllbGRJZF0gPSB1dGlsLnJhbmRvbVVVSUQoKTtcblxuICAgICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cEZyb21UYXJnZXQoZXZlbnQpO1xuICAgICAgaWYgKGdyb3VwKSB7XG4gICAgICAgIG5ld0l0ZW1EYXRhLmdyb3VwID0gZ3JvdXAuZ3JvdXBJZDtcbiAgICAgIH1cblxuICAgICAgLy8gZXhlY3V0ZSBhc3luYyBoYW5kbGVyIHRvIGN1c3RvbWl6ZSAob3IgY2FuY2VsKSBhZGRpbmcgYW4gaXRlbVxuICAgICAgbmV3SXRlbURhdGEgPSB0aGlzLl9jbG9uZUl0ZW1EYXRhKG5ld0l0ZW1EYXRhKTsgLy8gY29udmVydCBzdGFydCBhbmQgZW5kIHRvIHRoZSBjb3JyZWN0IHR5cGVcbiAgICAgIHRoaXMub3B0aW9ucy5vbkFkZChuZXdJdGVtRGF0YSwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICBtZS5pdGVtc0RhdGEuZ2V0RGF0YVNldCgpLmFkZChpdGVtKTtcbiAgICAgICAgICAvLyBUT0RPOiBuZWVkIHRvIHRyaWdnZXIgYSByZWRyYXc/XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIHNlbGVjdGluZy9kZXNlbGVjdGluZyBtdWx0aXBsZSBpdGVtcyB3aGVuIGhvbGRpbmcgYW4gaXRlbVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUuX29uTXVsdGlTZWxlY3RJdGVtID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuc2VsZWN0YWJsZSkgcmV0dXJuO1xuXG4gICAgdmFyIGl0ZW0gPSB0aGlzLml0ZW1Gcm9tVGFyZ2V0KGV2ZW50KTtcblxuICAgIGlmIChpdGVtKSB7XG4gICAgICAvLyBtdWx0aSBzZWxlY3QgaXRlbXMgKGlmIGFsbG93ZWQpXG5cbiAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLm9wdGlvbnMubXVsdGlzZWxlY3QgPyB0aGlzLmdldFNlbGVjdGlvbigpIC8vIHRha2UgY3VycmVudCBzZWxlY3Rpb25cbiAgICAgIDogW107IC8vIGRlc2VsZWN0IGN1cnJlbnQgc2VsZWN0aW9uXG5cbiAgICAgIHZhciBzaGlmdEtleSA9IGV2ZW50LnNyY0V2ZW50ICYmIGV2ZW50LnNyY0V2ZW50LnNoaWZ0S2V5IHx8IGZhbHNlO1xuXG4gICAgICBpZiAoc2hpZnRLZXkgJiYgdGhpcy5vcHRpb25zLm11bHRpc2VsZWN0KSB7XG4gICAgICAgIC8vIHNlbGVjdCBhbGwgaXRlbXMgYmV0d2VlbiB0aGUgb2xkIHNlbGVjdGlvbiBhbmQgdGhlIHRhcHBlZCBpdGVtXG4gICAgICAgIHZhciBpdGVtR3JvdXAgPSB0aGlzLml0ZW1zRGF0YS5nZXQoaXRlbS5pZCkuZ3JvdXA7XG5cbiAgICAgICAgLy8gd2hlbiBmaWx0ZXJpbmcgZ2V0IHRoZSBncm91cCBvZiB0aGUgbGFzdCBzZWxlY3RlZCBpdGVtXG4gICAgICAgIHZhciBsYXN0U2VsZWN0ZWRHcm91cCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5tdWx0aXNlbGVjdFBlckdyb3VwKSB7XG4gICAgICAgICAgaWYgKHNlbGVjdGlvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsYXN0U2VsZWN0ZWRHcm91cCA9IHRoaXMuaXRlbXNEYXRhLmdldChzZWxlY3Rpb25bMF0pLmdyb3VwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRldGVybWluZSB0aGUgc2VsZWN0aW9uIHJhbmdlXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLm11bHRpc2VsZWN0UGVyR3JvdXAgfHwgbGFzdFNlbGVjdGVkR3JvdXAgPT0gdW5kZWZpbmVkIHx8IGxhc3RTZWxlY3RlZEdyb3VwID09IGl0ZW1Hcm91cCkge1xuICAgICAgICAgIHNlbGVjdGlvbi5wdXNoKGl0ZW0uaWQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByYW5nZSA9IEl0ZW1TZXQuX2dldEl0ZW1SYW5nZSh0aGlzLml0ZW1zRGF0YS5nZXQoc2VsZWN0aW9uLCB0aGlzLml0ZW1PcHRpb25zKSk7XG5cbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMubXVsdGlzZWxlY3RQZXJHcm91cCB8fCBsYXN0U2VsZWN0ZWRHcm91cCA9PSBpdGVtR3JvdXApIHtcbiAgICAgICAgICAvLyBzZWxlY3QgYWxsIGl0ZW1zIHdpdGhpbiB0aGUgc2VsZWN0aW9uIHJhbmdlXG4gICAgICAgICAgc2VsZWN0aW9uID0gW107XG4gICAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5pdGVtcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXRlbXMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICAgIHZhciBfaXRlbSA9IHRoaXMuaXRlbXNbaWRdO1xuICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBfaXRlbS5kYXRhLnN0YXJ0O1xuICAgICAgICAgICAgICB2YXIgZW5kID0gX2l0ZW0uZGF0YS5lbmQgIT09IHVuZGVmaW5lZCA/IF9pdGVtLmRhdGEuZW5kIDogc3RhcnQ7XG5cbiAgICAgICAgICAgICAgaWYgKHN0YXJ0ID49IHJhbmdlLm1pbiAmJiBlbmQgPD0gcmFuZ2UubWF4ICYmICghdGhpcy5vcHRpb25zLm11bHRpc2VsZWN0UGVyR3JvdXAgfHwgbGFzdFNlbGVjdGVkR3JvdXAgPT0gdGhpcy5pdGVtc0RhdGEuZ2V0KF9pdGVtLmlkKS5ncm91cCkgJiYgIShfaXRlbSBpbnN0YW5jZW9mIEJhY2tncm91bmRJdGVtKSkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5wdXNoKF9pdGVtLmlkKTsgLy8gZG8gbm90IHVzZSBpZCBidXQgaXRlbS5pZCwgaWQgaXRzZWxmIGlzIHN0cmluZ2lmaWVkXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gYWRkL3JlbW92ZSB0aGlzIGl0ZW0gZnJvbSB0aGUgY3VycmVudCBzZWxlY3Rpb25cbiAgICAgICAgICB2YXIgaW5kZXggPSBzZWxlY3Rpb24uaW5kZXhPZihpdGVtLmlkKTtcbiAgICAgICAgICBpZiAoaW5kZXggPT0gLTEpIHtcbiAgICAgICAgICAgIC8vIGl0ZW0gaXMgbm90IHlldCBzZWxlY3RlZCAtPiBzZWxlY3QgaXRcbiAgICAgICAgICAgIHNlbGVjdGlvbi5wdXNoKGl0ZW0uaWQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpdGVtIGlzIGFscmVhZHkgc2VsZWN0ZWQgLT4gZGVzZWxlY3QgaXRcbiAgICAgICAgICAgIHNlbGVjdGlvbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICB0aGlzLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdzZWxlY3QnLCB7XG4gICAgICAgIGl0ZW1zOiB0aGlzLmdldFNlbGVjdGlvbigpLFxuICAgICAgICBldmVudDogZXZlbnRcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSB0aW1lIHJhbmdlIG9mIGEgbGlzdCBvZiBpdGVtc1xuICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBpdGVtc0RhdGFcbiAgICogQHJldHVybiB7e21pbjogRGF0ZSwgbWF4OiBEYXRlfX0gUmV0dXJucyB0aGUgcmFuZ2Ugb2YgdGhlIHByb3ZpZGVkIGl0ZW1zXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBJdGVtU2V0Ll9nZXRJdGVtUmFuZ2UgPSBmdW5jdGlvbiAoaXRlbXNEYXRhKSB7XG4gICAgdmFyIG1heCA9IG51bGw7XG4gICAgdmFyIG1pbiA9IG51bGw7XG5cbiAgICBpdGVtc0RhdGEuZm9yRWFjaChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgaWYgKG1pbiA9PSBudWxsIHx8IGRhdGEuc3RhcnQgPCBtaW4pIHtcbiAgICAgICAgbWluID0gZGF0YS5zdGFydDtcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEuZW5kICE9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAobWF4ID09IG51bGwgfHwgZGF0YS5lbmQgPiBtYXgpIHtcbiAgICAgICAgICBtYXggPSBkYXRhLmVuZDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG1heCA9PSBudWxsIHx8IGRhdGEuc3RhcnQgPiBtYXgpIHtcbiAgICAgICAgICBtYXggPSBkYXRhLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbWluOiBtaW4sXG4gICAgICBtYXg6IG1heFxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpbmQgYW4gaXRlbSBmcm9tIGFuIGV2ZW50IHRhcmdldDpcbiAgICogc2VhcmNoZXMgZm9yIHRoZSBhdHRyaWJ1dGUgJ3RpbWVsaW5lLWl0ZW0nIGluIHRoZSBldmVudCB0YXJnZXQncyBlbGVtZW50IHRyZWVcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHJldHVybiB7SXRlbSB8IG51bGx9IGl0ZW1cbiAgICovXG4gIEl0ZW1TZXQucHJvdG90eXBlLml0ZW1Gcm9tVGFyZ2V0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICB3aGlsZSAodGFyZ2V0KSB7XG4gICAgICBpZiAodGFyZ2V0Lmhhc093blByb3BlcnR5KCd0aW1lbGluZS1pdGVtJykpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldFsndGltZWxpbmUtaXRlbSddO1xuICAgICAgfVxuICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpbmQgdGhlIEdyb3VwIGZyb20gYW4gZXZlbnQgdGFyZ2V0OlxuICAgKiBzZWFyY2hlcyBmb3IgdGhlIGF0dHJpYnV0ZSAndGltZWxpbmUtZ3JvdXAnIGluIHRoZSBldmVudCB0YXJnZXQncyBlbGVtZW50IHRyZWVcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHJldHVybiB7R3JvdXAgfCBudWxsfSBncm91cFxuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUuZ3JvdXBGcm9tVGFyZ2V0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGNsaWVudFkgPSBldmVudC5jZW50ZXIgPyBldmVudC5jZW50ZXIueSA6IGV2ZW50LmNsaWVudFk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdyb3VwSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZ3JvdXBJZCA9IHRoaXMuZ3JvdXBJZHNbaV07XG4gICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3Vwc1tncm91cElkXTtcbiAgICAgIHZhciBmb3JlZ3JvdW5kID0gZ3JvdXAuZG9tLmZvcmVncm91bmQ7XG4gICAgICB2YXIgdG9wID0gdXRpbC5nZXRBYnNvbHV0ZVRvcChmb3JlZ3JvdW5kKTtcbiAgICAgIGlmIChjbGllbnRZID4gdG9wICYmIGNsaWVudFkgPCB0b3AgKyBmb3JlZ3JvdW5kLm9mZnNldEhlaWdodCkge1xuICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uaXRlbSA9PT0gJ3RvcCcpIHtcbiAgICAgICAgaWYgKGkgPT09IHRoaXMuZ3JvdXBJZHMubGVuZ3RoIC0gMSAmJiBjbGllbnRZID4gdG9wKSB7XG4gICAgICAgICAgcmV0dXJuIGdyb3VwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaSA9PT0gMCAmJiBjbGllbnRZIDwgdG9wICsgZm9yZWdyb3VuZC5vZmZzZXQpIHtcbiAgICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogRmluZCB0aGUgSXRlbVNldCBmcm9tIGFuIGV2ZW50IHRhcmdldDpcbiAgICogc2VhcmNoZXMgZm9yIHRoZSBhdHRyaWJ1dGUgJ3RpbWVsaW5lLWl0ZW1zZXQnIGluIHRoZSBldmVudCB0YXJnZXQncyBlbGVtZW50IHRyZWVcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHJldHVybiB7SXRlbVNldCB8IG51bGx9IGl0ZW1cbiAgICovXG4gIEl0ZW1TZXQuaXRlbVNldEZyb21UYXJnZXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgIHdoaWxlICh0YXJnZXQpIHtcbiAgICAgIGlmICh0YXJnZXQuaGFzT3duUHJvcGVydHkoJ3RpbWVsaW5lLWl0ZW1zZXQnKSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0Wyd0aW1lbGluZS1pdGVtc2V0J107XG4gICAgICB9XG4gICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogQ2xvbmUgdGhlIGRhdGEgb2YgYW4gaXRlbSwgYW5kIFwibm9ybWFsaXplXCIgaXQ6IGNvbnZlcnQgdGhlIHN0YXJ0IGFuZCBlbmQgZGF0ZVxuICAgKiB0byB0aGUgdHlwZSAoRGF0ZSwgTW9tZW50LCAuLi4pIGNvbmZpZ3VyZWQgaW4gdGhlIERhdGFTZXQuIElmIG5vdCBjb25maWd1cmVkLFxuICAgKiBzdGFydCBhbmQgZW5kIGFyZSBjb252ZXJ0ZWQgdG8gRGF0ZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1EYXRhLCB0eXBpY2FsbHkgYGl0ZW0uZGF0YWBcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSAgT3B0aW9uYWwgRGF0ZSB0eXBlLiBJZiBub3QgcHJvdmlkZWQsIHRoZSB0eXBlIGZyb20gdGhlIERhdGFTZXQgaXMgdGFrZW5cbiAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY2xvbmVkIG9iamVjdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgSXRlbVNldC5wcm90b3R5cGUuX2Nsb25lSXRlbURhdGEgPSBmdW5jdGlvbiAoaXRlbURhdGEsIHR5cGUpIHtcbiAgICB2YXIgY2xvbmUgPSB1dGlsLmV4dGVuZCh7fSwgaXRlbURhdGEpO1xuXG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICAvLyBjb252ZXJ0IHN0YXJ0IGFuZCBlbmQgZGF0ZSB0byB0aGUgdHlwZSAoRGF0ZSwgTW9tZW50LCAuLi4pIGNvbmZpZ3VyZWQgaW4gdGhlIERhdGFTZXRcbiAgICAgIHR5cGUgPSB0aGlzLml0ZW1zRGF0YS5nZXREYXRhU2V0KCkuX29wdGlvbnMudHlwZTtcbiAgICB9XG5cbiAgICBpZiAoY2xvbmUuc3RhcnQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICBjbG9uZS5zdGFydCA9IHV0aWwuY29udmVydChjbG9uZS5zdGFydCwgdHlwZSAmJiB0eXBlLnN0YXJ0IHx8ICdEYXRlJyk7XG4gICAgfVxuICAgIGlmIChjbG9uZS5lbmQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICBjbG9uZS5lbmQgPSB1dGlsLmNvbnZlcnQoY2xvbmUuZW5kLCB0eXBlICYmIHR5cGUuZW5kIHx8ICdEYXRlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lO1xuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gSXRlbVNldDtcblxuLyoqKi8gfSxcbi8qIDM1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4gIHZhciBEYXRlVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvciAgVGltZVN0ZXBcbiAgICogVGhlIGNsYXNzIFRpbWVTdGVwIGlzIGFuIGl0ZXJhdG9yIGZvciBkYXRlcy4gWW91IHByb3ZpZGUgYSBzdGFydCBkYXRlIGFuZCBhblxuICAgKiBlbmQgZGF0ZS4gVGhlIGNsYXNzIGl0c2VsZiBkZXRlcm1pbmVzIHRoZSBiZXN0IHNjYWxlIChzdGVwIHNpemUpIGJhc2VkIG9uIHRoZVxuICAgKiBwcm92aWRlZCBzdGFydCBEYXRlLCBlbmQgRGF0ZSwgYW5kIG1pbmltdW1TdGVwLlxuICAgKlxuICAgKiBJZiBtaW5pbXVtU3RlcCBpcyBwcm92aWRlZCwgdGhlIHN0ZXAgc2l6ZSBpcyBjaG9zZW4gYXMgY2xvc2UgYXMgcG9zc2libGVcbiAgICogdG8gdGhlIG1pbmltdW1TdGVwIGJ1dCBsYXJnZXIgdGhhbiBtaW5pbXVtU3RlcC4gSWYgbWluaW11bVN0ZXAgaXMgbm90XG4gICAqIHByb3ZpZGVkLCB0aGUgc2NhbGUgaXMgc2V0IHRvIDEgREFZLlxuICAgKiBUaGUgbWluaW11bVN0ZXAgc2hvdWxkIGNvcnJlc3BvbmQgd2l0aCB0aGUgb25zY3JlZW4gc2l6ZSBvZiBhYm91dCA2IGNoYXJhY3RlcnNcbiAgICpcbiAgICogQWx0ZXJuYXRpdmVseSwgeW91IGNhbiBzZXQgYSBzY2FsZSBieSBoYW5kLlxuICAgKiBBZnRlciBjcmVhdGlvbiwgeW91IGNhbiBpbml0aWFsaXplIHRoZSBjbGFzcyBieSBleGVjdXRpbmcgZmlyc3QoKS4gVGhlbiB5b3VcbiAgICogY2FuIGl0ZXJhdGUgZnJvbSB0aGUgc3RhcnQgZGF0ZSB0byB0aGUgZW5kIGRhdGUgdmlhIG5leHQoKS4gWW91IGNhbiBjaGVjayBpZlxuICAgKiB0aGUgZW5kIGRhdGUgaXMgcmVhY2hlZCB3aXRoIHRoZSBmdW5jdGlvbiBoYXNOZXh0KCkuIEFmdGVyIGVhY2ggc3RlcCwgeW91IGNhblxuICAgKiByZXRyaWV2ZSB0aGUgY3VycmVudCBkYXRlIHZpYSBnZXRDdXJyZW50KCkuXG4gICAqIFRoZSBUaW1lU3RlcCBoYXMgc2NhbGVzIHJhbmdpbmcgZnJvbSBtaWxsaXNlY29uZHMsIHNlY29uZHMsIG1pbnV0ZXMsIGhvdXJzLFxuICAgKiBkYXlzLCB0byB5ZWFycy5cbiAgICpcbiAgICogVmVyc2lvbjogMS4yXG4gICAqXG4gICAqIEBwYXJhbSB7RGF0ZX0gW3N0YXJ0XSAgICAgICAgIFRoZSBzdGFydCBkYXRlLCBmb3IgZXhhbXBsZSBuZXcgRGF0ZSgyMDEwLCA5LCAyMSlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3IgbmV3IERhdGUoMjAxMCwgOSwgMjEsIDIzLCA0NSwgMDApXG4gICAqIEBwYXJhbSB7RGF0ZX0gW2VuZF0gICAgICAgICAgIFRoZSBlbmQgZGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW21pbmltdW1TdGVwXSBPcHRpb25hbC4gTWluaW11bSBzdGVwIHNpemUgaW4gbWlsbGlzZWNvbmRzXG4gICAqL1xuICBmdW5jdGlvbiBUaW1lU3RlcChzdGFydCwgZW5kLCBtaW5pbXVtU3RlcCwgaGlkZGVuRGF0ZXMpIHtcbiAgICB0aGlzLm1vbWVudCA9IG1vbWVudDtcblxuICAgIC8vIHZhcmlhYmxlc1xuICAgIHRoaXMuY3VycmVudCA9IHRoaXMubW9tZW50KCk7XG4gICAgdGhpcy5fc3RhcnQgPSB0aGlzLm1vbWVudCgpO1xuICAgIHRoaXMuX2VuZCA9IHRoaXMubW9tZW50KCk7XG5cbiAgICB0aGlzLmF1dG9TY2FsZSA9IHRydWU7XG4gICAgdGhpcy5zY2FsZSA9ICdkYXknO1xuICAgIHRoaXMuc3RlcCA9IDE7XG5cbiAgICAvLyBpbml0aWFsaXplIHRoZSByYW5nZVxuICAgIHRoaXMuc2V0UmFuZ2Uoc3RhcnQsIGVuZCwgbWluaW11bVN0ZXApO1xuXG4gICAgLy8gaGlkZGVuIERhdGVzIG9wdGlvbnNcbiAgICB0aGlzLnN3aXRjaGVkRGF5ID0gZmFsc2U7XG4gICAgdGhpcy5zd2l0Y2hlZE1vbnRoID0gZmFsc2U7XG4gICAgdGhpcy5zd2l0Y2hlZFllYXIgPSBmYWxzZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoaWRkZW5EYXRlcykpIHtcbiAgICAgIHRoaXMuaGlkZGVuRGF0ZXMgPSBoaWRkZW5EYXRlcztcbiAgICB9IGVsc2UgaWYgKGhpZGRlbkRhdGVzICE9IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5oaWRkZW5EYXRlcyA9IFtoaWRkZW5EYXRlc107XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGlkZGVuRGF0ZXMgPSBbXTtcbiAgICB9XG5cbiAgICB0aGlzLmZvcm1hdCA9IFRpbWVTdGVwLkZPUk1BVDsgLy8gZGVmYXVsdCBmb3JtYXR0aW5nXG4gIH1cblxuICAvLyBUaW1lIGZvcm1hdHRpbmdcbiAgVGltZVN0ZXAuRk9STUFUID0ge1xuICAgIG1pbm9yTGFiZWxzOiB7XG4gICAgICBtaWxsaXNlY29uZDogJ1NTUycsXG4gICAgICBzZWNvbmQ6ICdzJyxcbiAgICAgIG1pbnV0ZTogJ0hIOm1tJyxcbiAgICAgIGhvdXI6ICdISDptbScsXG4gICAgICB3ZWVrZGF5OiAnZGRkIEQnLFxuICAgICAgZGF5OiAnRCcsXG4gICAgICBtb250aDogJ01NTScsXG4gICAgICB5ZWFyOiAnWVlZWSdcbiAgICB9LFxuICAgIG1ham9yTGFiZWxzOiB7XG4gICAgICBtaWxsaXNlY29uZDogJ0hIOm1tOnNzJyxcbiAgICAgIHNlY29uZDogJ0QgTU1NTSBISDptbScsXG4gICAgICBtaW51dGU6ICdkZGQgRCBNTU1NJyxcbiAgICAgIGhvdXI6ICdkZGQgRCBNTU1NJyxcbiAgICAgIHdlZWtkYXk6ICdNTU1NIFlZWVknLFxuICAgICAgZGF5OiAnTU1NTSBZWVlZJyxcbiAgICAgIG1vbnRoOiAnWVlZWScsXG4gICAgICB5ZWFyOiAnJ1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0IGN1c3RvbSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgbW9tZW50LiBDYW4gYmUgdXNlZCB0byBzZXQgZGF0ZXNcbiAgICogdG8gVVRDIG9yIHRvIHNldCBhIHV0Y09mZnNldC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gbW9tZW50XG4gICAqL1xuICBUaW1lU3RlcC5wcm90b3R5cGUuc2V0TW9tZW50ID0gZnVuY3Rpb24gKG1vbWVudCkge1xuICAgIHRoaXMubW9tZW50ID0gbW9tZW50O1xuXG4gICAgLy8gdXBkYXRlIHRoZSBkYXRlIHByb3BlcnRpZXMsIGNhbiBoYXZlIGEgbmV3IHV0Y09mZnNldFxuICAgIHRoaXMuY3VycmVudCA9IHRoaXMubW9tZW50KHRoaXMuY3VycmVudCk7XG4gICAgdGhpcy5fc3RhcnQgPSB0aGlzLm1vbWVudCh0aGlzLl9zdGFydCk7XG4gICAgdGhpcy5fZW5kID0gdGhpcy5tb21lbnQodGhpcy5fZW5kKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGN1c3RvbSBmb3JtYXR0aW5nIGZvciB0aGUgbWlub3IgYW4gbWFqb3IgbGFiZWxzIG9mIHRoZSBUaW1lU3RlcC5cbiAgICogQm90aCBgbWlub3JMYWJlbHNgIGFuZCBgbWFqb3JMYWJlbHNgIGFyZSBhbiBPYmplY3Qgd2l0aCBwcm9wZXJ0aWVzOlxuICAgKiAnbWlsbGlzZWNvbmQnLCAnc2Vjb25kJywgJ21pbnV0ZScsICdob3VyJywgJ3dlZWtkYXknLCAnZGF5JywgJ21vbnRoJywgJ3llYXInLlxuICAgKiBAcGFyYW0ge3ttaW5vckxhYmVsczogT2JqZWN0LCBtYWpvckxhYmVsczogT2JqZWN0fX0gZm9ybWF0XG4gICAqL1xuICBUaW1lU3RlcC5wcm90b3R5cGUuc2V0Rm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIHZhciBkZWZhdWx0Rm9ybWF0ID0gdXRpbC5kZWVwRXh0ZW5kKHt9LCBUaW1lU3RlcC5GT1JNQVQpO1xuICAgIHRoaXMuZm9ybWF0ID0gdXRpbC5kZWVwRXh0ZW5kKGRlZmF1bHRGb3JtYXQsIGZvcm1hdCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBhIG5ldyByYW5nZVxuICAgKiBJZiBtaW5pbXVtU3RlcCBpcyBwcm92aWRlZCwgdGhlIHN0ZXAgc2l6ZSBpcyBjaG9zZW4gYXMgY2xvc2UgYXMgcG9zc2libGVcbiAgICogdG8gdGhlIG1pbmltdW1TdGVwIGJ1dCBsYXJnZXIgdGhhbiBtaW5pbXVtU3RlcC4gSWYgbWluaW11bVN0ZXAgaXMgbm90XG4gICAqIHByb3ZpZGVkLCB0aGUgc2NhbGUgaXMgc2V0IHRvIDEgREFZLlxuICAgKiBUaGUgbWluaW11bVN0ZXAgc2hvdWxkIGNvcnJlc3BvbmQgd2l0aCB0aGUgb25zY3JlZW4gc2l6ZSBvZiBhYm91dCA2IGNoYXJhY3RlcnNcbiAgICogQHBhcmFtIHtEYXRlfSBbc3RhcnRdICAgICAgVGhlIHN0YXJ0IGRhdGUgYW5kIHRpbWUuXG4gICAqIEBwYXJhbSB7RGF0ZX0gW2VuZF0gICAgICAgIFRoZSBlbmQgZGF0ZSBhbmQgdGltZS5cbiAgICogQHBhcmFtIHtpbnR9IFttaW5pbXVtU3RlcF0gT3B0aW9uYWwuIE1pbmltdW0gc3RlcCBzaXplIGluIG1pbGxpc2Vjb25kc1xuICAgKi9cbiAgVGltZVN0ZXAucHJvdG90eXBlLnNldFJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIG1pbmltdW1TdGVwKSB7XG4gICAgaWYgKCEoc3RhcnQgaW5zdGFuY2VvZiBEYXRlKSB8fCAhKGVuZCBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICB0aHJvdyBcIk5vIGxlZ2FsIHN0YXJ0IG9yIGVuZCBkYXRlIGluIG1ldGhvZCBzZXRSYW5nZVwiO1xuICAgIH1cblxuICAgIHRoaXMuX3N0YXJ0ID0gc3RhcnQgIT0gdW5kZWZpbmVkID8gdGhpcy5tb21lbnQoc3RhcnQudmFsdWVPZigpKSA6IG5ldyBEYXRlKCk7XG4gICAgdGhpcy5fZW5kID0gZW5kICE9IHVuZGVmaW5lZCA/IHRoaXMubW9tZW50KGVuZC52YWx1ZU9mKCkpIDogbmV3IERhdGUoKTtcblxuICAgIGlmICh0aGlzLmF1dG9TY2FsZSkge1xuICAgICAgdGhpcy5zZXRNaW5pbXVtU3RlcChtaW5pbXVtU3RlcCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHJhbmdlIGl0ZXJhdG9yIHRvIHRoZSBzdGFydCBkYXRlLlxuICAgKi9cbiAgVGltZVN0ZXAucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY3VycmVudCA9IHRoaXMuX3N0YXJ0LmNsb25lKCk7XG4gICAgdGhpcy5yb3VuZFRvTWlub3IoKTtcbiAgfTtcblxuICAvKipcbiAgICogUm91bmQgdGhlIGN1cnJlbnQgZGF0ZSB0byB0aGUgZmlyc3QgbWlub3IgZGF0ZSB2YWx1ZVxuICAgKiBUaGlzIG11c3QgYmUgZXhlY3V0ZWQgb25jZSB3aGVuIHRoZSBjdXJyZW50IGRhdGUgaXMgc2V0IHRvIHN0YXJ0IERhdGVcbiAgICovXG4gIFRpbWVTdGVwLnByb3RvdHlwZS5yb3VuZFRvTWlub3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gcm91bmQgdG8gZmxvb3JcbiAgICAvLyBJTVBPUlRBTlQ6IHdlIGhhdmUgbm8gYnJlYWtzIGluIHRoaXMgc3dpdGNoISAodGhpcyBpcyBubyBidWcpXG4gICAgLy8gbm9pbnNwZWN0aW9uIEZhbGxUaHJvdWdoSW5Td2l0Y2hTdGF0ZW1lbnRKU1xuICAgIHN3aXRjaCAodGhpcy5zY2FsZSkge1xuICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgIHRoaXMuY3VycmVudC55ZWFyKHRoaXMuc3RlcCAqIE1hdGguZmxvb3IodGhpcy5jdXJyZW50LnllYXIoKSAvIHRoaXMuc3RlcCkpO1xuICAgICAgICB0aGlzLmN1cnJlbnQubW9udGgoMCk7XG4gICAgICBjYXNlICdtb250aCc6XG4gICAgICAgIHRoaXMuY3VycmVudC5kYXRlKDEpO1xuICAgICAgY2FzZSAnZGF5JzogLy8gaW50ZW50aW9uYWwgZmFsbCB0aHJvdWdoXG4gICAgICBjYXNlICd3ZWVrZGF5JzpcbiAgICAgICAgdGhpcy5jdXJyZW50LmhvdXJzKDApO1xuICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgIHRoaXMuY3VycmVudC5taW51dGVzKDApO1xuICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgdGhpcy5jdXJyZW50LnNlY29uZHMoMCk7XG4gICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICB0aGlzLmN1cnJlbnQubWlsbGlzZWNvbmRzKDApO1xuICAgICAgLy9jYXNlICdtaWxsaXNlY29uZCc6IC8vIG5vdGhpbmcgdG8gZG8gZm9yIG1pbGxpc2Vjb25kc1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN0ZXAgIT0gMSkge1xuICAgICAgLy8gcm91bmQgZG93biB0byB0aGUgZmlyc3QgbWlub3IgdmFsdWUgdGhhdCBpcyBhIG11bHRpcGxlIG9mIHRoZSBjdXJyZW50IHN0ZXAgc2l6ZVxuICAgICAgc3dpdGNoICh0aGlzLnNjYWxlKSB7XG4gICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuc3VidHJhY3QodGhpcy5jdXJyZW50Lm1pbGxpc2Vjb25kcygpICUgdGhpcy5zdGVwLCAnbWlsbGlzZWNvbmRzJyk7YnJlYWs7XG4gICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgdGhpcy5jdXJyZW50LnN1YnRyYWN0KHRoaXMuY3VycmVudC5zZWNvbmRzKCkgJSB0aGlzLnN0ZXAsICdzZWNvbmRzJyk7YnJlYWs7XG4gICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgdGhpcy5jdXJyZW50LnN1YnRyYWN0KHRoaXMuY3VycmVudC5taW51dGVzKCkgJSB0aGlzLnN0ZXAsICdtaW51dGVzJyk7YnJlYWs7XG4gICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgIHRoaXMuY3VycmVudC5zdWJ0cmFjdCh0aGlzLmN1cnJlbnQuaG91cnMoKSAlIHRoaXMuc3RlcCwgJ2hvdXJzJyk7YnJlYWs7XG4gICAgICAgIGNhc2UgJ3dlZWtkYXknOiAvLyBpbnRlbnRpb25hbCBmYWxsIHRocm91Z2hcbiAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuc3VidHJhY3QoKHRoaXMuY3VycmVudC5kYXRlKCkgLSAxKSAlIHRoaXMuc3RlcCwgJ2RheScpO2JyZWFrO1xuICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgdGhpcy5jdXJyZW50LnN1YnRyYWN0KHRoaXMuY3VycmVudC5tb250aCgpICUgdGhpcy5zdGVwLCAnbW9udGgnKTticmVhaztcbiAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgdGhpcy5jdXJyZW50LnN1YnRyYWN0KHRoaXMuY3VycmVudC55ZWFyKCkgJSB0aGlzLnN0ZXAsICd5ZWFyJyk7YnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgdGhlcmUgaXMgYSBuZXh0IHN0ZXBcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gIHRydWUgaWYgdGhlIGN1cnJlbnQgZGF0ZSBoYXMgbm90IHBhc3NlZCB0aGUgZW5kIGRhdGVcbiAgICovXG4gIFRpbWVTdGVwLnByb3RvdHlwZS5oYXNOZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnQudmFsdWVPZigpIDw9IHRoaXMuX2VuZC52YWx1ZU9mKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERvIHRoZSBuZXh0IHN0ZXBcbiAgICovXG4gIFRpbWVTdGVwLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcmV2ID0gdGhpcy5jdXJyZW50LnZhbHVlT2YoKTtcblxuICAgIC8vIFR3byBjYXNlcywgbmVlZGVkIHRvIHByZXZlbnQgaXNzdWVzIHdpdGggc3dpdGNoaW5nIGRheWxpZ2h0IHNhdmluZ3NcbiAgICAvLyAoZW5kIG9mIE1hcmNoIGFuZCBlbmQgb2YgT2N0b2JlcilcbiAgICBpZiAodGhpcy5jdXJyZW50Lm1vbnRoKCkgPCA2KSB7XG4gICAgICBzd2l0Y2ggKHRoaXMuc2NhbGUpIHtcbiAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgICAgICAgIHRoaXMuY3VycmVudC5hZGQodGhpcy5zdGVwLCAnbWlsbGlzZWNvbmQnKTticmVhaztcbiAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuYWRkKHRoaXMuc3RlcCwgJ3NlY29uZCcpO2JyZWFrO1xuICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgIHRoaXMuY3VycmVudC5hZGQodGhpcy5zdGVwLCAnbWludXRlJyk7YnJlYWs7XG4gICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgIHRoaXMuY3VycmVudC5hZGQodGhpcy5zdGVwLCAnaG91cicpO1xuICAgICAgICAgIC8vIGluIGNhc2Ugb2Ygc2tpcHBpbmcgYW4gaG91ciBmb3IgZGF5bGlnaHQgc2F2aW5ncywgYWRqdXN0IHRoZSBob3VyIGFnYWluIChlbHNlIHlvdSBnZXQ6IDBoIDVoIDloIC4uLiBpbnN0ZWFkIG9mIDBoIDRoIDhoIC4uLilcbiAgICAgICAgICAvLyBUT0RPOiBpcyB0aGlzIHN0aWxsIG5lZWRlZCBub3cgd2UgdXNlIHRoZSBmdW5jdGlvbiBvZiBtb21lbnQuanM/XG4gICAgICAgICAgdGhpcy5jdXJyZW50LnN1YnRyYWN0KHRoaXMuY3VycmVudC5ob3VycygpICUgdGhpcy5zdGVwLCAnaG91cicpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd3ZWVrZGF5JzogLy8gaW50ZW50aW9uYWwgZmFsbCB0aHJvdWdoXG4gICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgdGhpcy5jdXJyZW50LmFkZCh0aGlzLnN0ZXAsICdkYXknKTticmVhaztcbiAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgIHRoaXMuY3VycmVudC5hZGQodGhpcy5zdGVwLCAnbW9udGgnKTticmVhaztcbiAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgdGhpcy5jdXJyZW50LmFkZCh0aGlzLnN0ZXAsICd5ZWFyJyk7YnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAodGhpcy5zY2FsZSkge1xuICAgICAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgICAgICAgdGhpcy5jdXJyZW50LmFkZCh0aGlzLnN0ZXAsICdtaWxsaXNlY29uZCcpO2JyZWFrO1xuICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgIHRoaXMuY3VycmVudC5hZGQodGhpcy5zdGVwLCAnc2Vjb25kJyk7YnJlYWs7XG4gICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgdGhpcy5jdXJyZW50LmFkZCh0aGlzLnN0ZXAsICdtaW51dGUnKTticmVhaztcbiAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgdGhpcy5jdXJyZW50LmFkZCh0aGlzLnN0ZXAsICdob3VyJyk7YnJlYWs7XG4gICAgICAgIGNhc2UgJ3dlZWtkYXknOiAvLyBpbnRlbnRpb25hbCBmYWxsIHRocm91Z2hcbiAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuYWRkKHRoaXMuc3RlcCwgJ2RheScpO2JyZWFrO1xuICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgdGhpcy5jdXJyZW50LmFkZCh0aGlzLnN0ZXAsICdtb250aCcpO2JyZWFrO1xuICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuYWRkKHRoaXMuc3RlcCwgJ3llYXInKTticmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdGVwICE9IDEpIHtcbiAgICAgIC8vIHJvdW5kIGRvd24gdG8gdGhlIGNvcnJlY3QgbWFqb3IgdmFsdWVcbiAgICAgIHN3aXRjaCAodGhpcy5zY2FsZSkge1xuICAgICAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgICAgICAgaWYgKHRoaXMuY3VycmVudC5taWxsaXNlY29uZHMoKSA8IHRoaXMuc3RlcCkgdGhpcy5jdXJyZW50Lm1pbGxpc2Vjb25kcygwKTticmVhaztcbiAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICBpZiAodGhpcy5jdXJyZW50LnNlY29uZHMoKSA8IHRoaXMuc3RlcCkgdGhpcy5jdXJyZW50LnNlY29uZHMoMCk7YnJlYWs7XG4gICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgaWYgKHRoaXMuY3VycmVudC5taW51dGVzKCkgPCB0aGlzLnN0ZXApIHRoaXMuY3VycmVudC5taW51dGVzKDApO2JyZWFrO1xuICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICBpZiAodGhpcy5jdXJyZW50LmhvdXJzKCkgPCB0aGlzLnN0ZXApIHRoaXMuY3VycmVudC5ob3VycygwKTticmVhaztcbiAgICAgICAgY2FzZSAnd2Vla2RheSc6IC8vIGludGVudGlvbmFsIGZhbGwgdGhyb3VnaFxuICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnQuZGF0ZSgpIDwgdGhpcy5zdGVwICsgMSkgdGhpcy5jdXJyZW50LmRhdGUoMSk7YnJlYWs7XG4gICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICBpZiAodGhpcy5jdXJyZW50Lm1vbnRoKCkgPCB0aGlzLnN0ZXApIHRoaXMuY3VycmVudC5tb250aCgwKTticmVhaztcbiAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgYnJlYWs7IC8vIG5vdGhpbmcgdG8gZG8gZm9yIHllYXJcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzYWZldHkgbWVjaGFuaXNtOiBpZiBjdXJyZW50IHRpbWUgaXMgc3RpbGwgdW5jaGFuZ2VkLCBtb3ZlIHRvIHRoZSBlbmRcbiAgICBpZiAodGhpcy5jdXJyZW50LnZhbHVlT2YoKSA9PSBwcmV2KSB7XG4gICAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLl9lbmQuY2xvbmUoKTtcbiAgICB9XG5cbiAgICBEYXRlVXRpbC5zdGVwT3ZlckhpZGRlbkRhdGVzKHRoaXMubW9tZW50LCB0aGlzLCBwcmV2KTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IGRhdGV0aW1lXG4gICAqIEByZXR1cm4ge01vbWVudH0gIGN1cnJlbnQgVGhlIGN1cnJlbnQgZGF0ZVxuICAgKi9cbiAgVGltZVN0ZXAucHJvdG90eXBlLmdldEN1cnJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudDtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGEgY3VzdG9tIHNjYWxlLiBBdXRvc2NhbGluZyB3aWxsIGJlIGRpc2FibGVkLlxuICAgKiBGb3IgZXhhbXBsZSBzZXRTY2FsZSgnbWludXRlJywgNSkgd2lsbCByZXN1bHRcbiAgICogaW4gbWlub3Igc3RlcHMgb2YgNSBtaW51dGVzLCBhbmQgbWFqb3Igc3RlcHMgb2YgYW4gaG91ci5cbiAgICpcbiAgICogQHBhcmFtIHt7c2NhbGU6IHN0cmluZywgc3RlcDogbnVtYmVyfX0gcGFyYW1zXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFuIG9iamVjdCBjb250YWluaW5nIHR3byBwcm9wZXJ0aWVzOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIEEgc3RyaW5nICdzY2FsZScuIENob29zZSBmcm9tICdtaWxsaXNlY29uZCcsICdzZWNvbmQnLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdtaW51dGUnLCAnaG91cicsICd3ZWVrZGF5JywgJ2RheScsICdtb250aCcsICd5ZWFyJy5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBBIG51bWJlciAnc3RlcCcuIEEgc3RlcCBzaXplLCBieSBkZWZhdWx0IDEuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2hvb3NlIGZvciBleGFtcGxlIDEsIDIsIDUsIG9yIDEwLlxuICAgKi9cbiAgVGltZVN0ZXAucHJvdG90eXBlLnNldFNjYWxlID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIGlmIChwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcy5zY2FsZSA9PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5zY2FsZSA9IHBhcmFtcy5zY2FsZTtcbiAgICAgIHRoaXMuc3RlcCA9IHBhcmFtcy5zdGVwID4gMCA/IHBhcmFtcy5zdGVwIDogMTtcbiAgICAgIHRoaXMuYXV0b1NjYWxlID0gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBFbmFibGUgb3IgZGlzYWJsZSBhdXRvc2NhbGluZ1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZSAgSWYgdHJ1ZSwgYXV0b2FzY2FsaW5nIGlzIHNldCB0cnVlXG4gICAqL1xuICBUaW1lU3RlcC5wcm90b3R5cGUuc2V0QXV0b1NjYWxlID0gZnVuY3Rpb24gKGVuYWJsZSkge1xuICAgIHRoaXMuYXV0b1NjYWxlID0gZW5hYmxlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBdXRvbWF0aWNhbGx5IGRldGVybWluZSB0aGUgc2NhbGUgdGhhdCBiZXN0cyBmaXRzIHRoZSBwcm92aWRlZCBtaW5pbXVtIHN0ZXBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFttaW5pbXVtU3RlcF0gIFRoZSBtaW5pbXVtIHN0ZXAgc2l6ZSBpbiBtaWxsaXNlY29uZHNcbiAgICovXG4gIFRpbWVTdGVwLnByb3RvdHlwZS5zZXRNaW5pbXVtU3RlcCA9IGZ1bmN0aW9uIChtaW5pbXVtU3RlcCkge1xuICAgIGlmIChtaW5pbXVtU3RlcCA9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvL3ZhciBiID0gYXNjICsgZHM7XG5cbiAgICB2YXIgc3RlcFllYXIgPSAxMDAwICogNjAgKiA2MCAqIDI0ICogMzAgKiAxMjtcbiAgICB2YXIgc3RlcE1vbnRoID0gMTAwMCAqIDYwICogNjAgKiAyNCAqIDMwO1xuICAgIHZhciBzdGVwRGF5ID0gMTAwMCAqIDYwICogNjAgKiAyNDtcbiAgICB2YXIgc3RlcEhvdXIgPSAxMDAwICogNjAgKiA2MDtcbiAgICB2YXIgc3RlcE1pbnV0ZSA9IDEwMDAgKiA2MDtcbiAgICB2YXIgc3RlcFNlY29uZCA9IDEwMDA7XG4gICAgdmFyIHN0ZXBNaWxsaXNlY29uZCA9IDE7XG5cbiAgICAvLyBmaW5kIHRoZSBzbWFsbGVzdCBzdGVwIHRoYXQgaXMgbGFyZ2VyIHRoYW4gdGhlIHByb3ZpZGVkIG1pbmltdW1TdGVwXG4gICAgaWYgKHN0ZXBZZWFyICogMTAwMCA+IG1pbmltdW1TdGVwKSB7XG4gICAgICB0aGlzLnNjYWxlID0gJ3llYXInO3RoaXMuc3RlcCA9IDEwMDA7XG4gICAgfVxuICAgIGlmIChzdGVwWWVhciAqIDUwMCA+IG1pbmltdW1TdGVwKSB7XG4gICAgICB0aGlzLnNjYWxlID0gJ3llYXInO3RoaXMuc3RlcCA9IDUwMDtcbiAgICB9XG4gICAgaWYgKHN0ZXBZZWFyICogMTAwID4gbWluaW11bVN0ZXApIHtcbiAgICAgIHRoaXMuc2NhbGUgPSAneWVhcic7dGhpcy5zdGVwID0gMTAwO1xuICAgIH1cbiAgICBpZiAoc3RlcFllYXIgKiA1MCA+IG1pbmltdW1TdGVwKSB7XG4gICAgICB0aGlzLnNjYWxlID0gJ3llYXInO3RoaXMuc3RlcCA9IDUwO1xuICAgIH1cbiAgICBpZiAoc3RlcFllYXIgKiAxMCA+IG1pbmltdW1TdGVwKSB7XG4gICAgICB0aGlzLnNjYWxlID0gJ3llYXInO3RoaXMuc3RlcCA9IDEwO1xuICAgIH1cbiAgICBpZiAoc3RlcFllYXIgKiA1ID4gbWluaW11bVN0ZXApIHtcbiAgICAgIHRoaXMuc2NhbGUgPSAneWVhcic7dGhpcy5zdGVwID0gNTtcbiAgICB9XG4gICAgaWYgKHN0ZXBZZWFyID4gbWluaW11bVN0ZXApIHtcbiAgICAgIHRoaXMuc2NhbGUgPSAneWVhcic7dGhpcy5zdGVwID0gMTtcbiAgICB9XG4gICAgaWYgKHN0ZXBNb250aCAqIDMgPiBtaW5pbXVtU3RlcCkge1xuICAgICAgdGhpcy5zY2FsZSA9ICdtb250aCc7dGhpcy5zdGVwID0gMztcbiAgICB9XG4gICAgaWYgKHN0ZXBNb250aCA+IG1pbmltdW1TdGVwKSB7XG4gICAgICB0aGlzLnNjYWxlID0gJ21vbnRoJzt0aGlzLnN0ZXAgPSAxO1xuICAgIH1cbiAgICBpZiAoc3RlcERheSAqIDUgPiBtaW5pbXVtU3RlcCkge1xuICAgICAgdGhpcy5zY2FsZSA9ICdkYXknO3RoaXMuc3RlcCA9IDU7XG4gICAgfVxuICAgIGlmIChzdGVwRGF5ICogMiA+IG1pbmltdW1TdGVwKSB7XG4gICAgICB0aGlzLnNjYWxlID0gJ2RheSc7dGhpcy5zdGVwID0gMjtcbiAgICB9XG4gICAgaWYgKHN0ZXBEYXkgPiBtaW5pbXVtU3RlcCkge1xuICAgICAgdGhpcy5zY2FsZSA9ICdkYXknO3RoaXMuc3RlcCA9IDE7XG4gICAgfVxuICAgIGlmIChzdGVwRGF5IC8gMiA+IG1pbmltdW1TdGVwKSB7XG4gICAgICB0aGlzLnNjYWxlID0gJ3dlZWtkYXknO3RoaXMuc3RlcCA9IDE7XG4gICAgfVxuICAgIGlmIChzdGVwSG91ciAqIDQgPiBtaW5pbXVtU3RlcCkge1xuICAgICAgdGhpcy5zY2FsZSA9ICdob3VyJzt0aGlzLnN0ZXAgPSA0O1xuICAgIH1cbiAgICBpZiAoc3RlcEhvdXIgPiBtaW5pbXVtU3RlcCkge1xuICAgICAgdGhpcy5zY2FsZSA9ICdob3VyJzt0aGlzLnN0ZXAgPSAxO1xuICAgIH1cbiAgICBpZiAoc3RlcE1pbnV0ZSAqIDE1ID4gbWluaW11bVN0ZXApIHtcbiAgICAgIHRoaXMuc2NhbGUgPSAnbWludXRlJzt0aGlzLnN0ZXAgPSAxNTtcbiAgICB9XG4gICAgaWYgKHN0ZXBNaW51dGUgKiAxMCA+IG1pbmltdW1TdGVwKSB7XG4gICAgICB0aGlzLnNjYWxlID0gJ21pbnV0ZSc7dGhpcy5zdGVwID0gMTA7XG4gICAgfVxuICAgIGlmIChzdGVwTWludXRlICogNSA+IG1pbmltdW1TdGVwKSB7XG4gICAgICB0aGlzLnNjYWxlID0gJ21pbnV0ZSc7dGhpcy5zdGVwID0gNTtcbiAgICB9XG4gICAgaWYgKHN0ZXBNaW51dGUgPiBtaW5pbXVtU3RlcCkge1xuICAgICAgdGhpcy5zY2FsZSA9ICdtaW51dGUnO3RoaXMuc3RlcCA9IDE7XG4gICAgfVxuICAgIGlmIChzdGVwU2Vjb25kICogMTUgPiBtaW5pbXVtU3RlcCkge1xuICAgICAgdGhpcy5zY2FsZSA9ICdzZWNvbmQnO3RoaXMuc3RlcCA9IDE1O1xuICAgIH1cbiAgICBpZiAoc3RlcFNlY29uZCAqIDEwID4gbWluaW11bVN0ZXApIHtcbiAgICAgIHRoaXMuc2NhbGUgPSAnc2Vjb25kJzt0aGlzLnN0ZXAgPSAxMDtcbiAgICB9XG4gICAgaWYgKHN0ZXBTZWNvbmQgKiA1ID4gbWluaW11bVN0ZXApIHtcbiAgICAgIHRoaXMuc2NhbGUgPSAnc2Vjb25kJzt0aGlzLnN0ZXAgPSA1O1xuICAgIH1cbiAgICBpZiAoc3RlcFNlY29uZCA+IG1pbmltdW1TdGVwKSB7XG4gICAgICB0aGlzLnNjYWxlID0gJ3NlY29uZCc7dGhpcy5zdGVwID0gMTtcbiAgICB9XG4gICAgaWYgKHN0ZXBNaWxsaXNlY29uZCAqIDIwMCA+IG1pbmltdW1TdGVwKSB7XG4gICAgICB0aGlzLnNjYWxlID0gJ21pbGxpc2Vjb25kJzt0aGlzLnN0ZXAgPSAyMDA7XG4gICAgfVxuICAgIGlmIChzdGVwTWlsbGlzZWNvbmQgKiAxMDAgPiBtaW5pbXVtU3RlcCkge1xuICAgICAgdGhpcy5zY2FsZSA9ICdtaWxsaXNlY29uZCc7dGhpcy5zdGVwID0gMTAwO1xuICAgIH1cbiAgICBpZiAoc3RlcE1pbGxpc2Vjb25kICogNTAgPiBtaW5pbXVtU3RlcCkge1xuICAgICAgdGhpcy5zY2FsZSA9ICdtaWxsaXNlY29uZCc7dGhpcy5zdGVwID0gNTA7XG4gICAgfVxuICAgIGlmIChzdGVwTWlsbGlzZWNvbmQgKiAxMCA+IG1pbmltdW1TdGVwKSB7XG4gICAgICB0aGlzLnNjYWxlID0gJ21pbGxpc2Vjb25kJzt0aGlzLnN0ZXAgPSAxMDtcbiAgICB9XG4gICAgaWYgKHN0ZXBNaWxsaXNlY29uZCAqIDUgPiBtaW5pbXVtU3RlcCkge1xuICAgICAgdGhpcy5zY2FsZSA9ICdtaWxsaXNlY29uZCc7dGhpcy5zdGVwID0gNTtcbiAgICB9XG4gICAgaWYgKHN0ZXBNaWxsaXNlY29uZCA+IG1pbmltdW1TdGVwKSB7XG4gICAgICB0aGlzLnNjYWxlID0gJ21pbGxpc2Vjb25kJzt0aGlzLnN0ZXAgPSAxO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU25hcCBhIGRhdGUgdG8gYSByb3VuZGVkIHZhbHVlLlxuICAgKiBUaGUgc25hcCBpbnRlcnZhbHMgYXJlIGRlcGVuZGVudCBvbiB0aGUgY3VycmVudCBzY2FsZSBhbmQgc3RlcC5cbiAgICogU3RhdGljIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7RGF0ZX0gZGF0ZSAgICB0aGUgZGF0ZSB0byBiZSBzbmFwcGVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2NhbGUgQ3VycmVudCBzY2FsZSwgY2FuIGJlICdtaWxsaXNlY29uZCcsICdzZWNvbmQnLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgJ21pbnV0ZScsICdob3VyJywgJ3dlZWtkYXksICdkYXknLCAnbW9udGgnLCAneWVhcicuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwICBDdXJyZW50IHN0ZXAgKDEsIDIsIDQsIDUsIC4uLlxuICAgKiBAcmV0dXJuIHtEYXRlfSBzbmFwcGVkRGF0ZVxuICAgKi9cbiAgVGltZVN0ZXAuc25hcCA9IGZ1bmN0aW9uIChkYXRlLCBzY2FsZSwgc3RlcCkge1xuICAgIHZhciBjbG9uZSA9IG1vbWVudChkYXRlKTtcblxuICAgIGlmIChzY2FsZSA9PSAneWVhcicpIHtcbiAgICAgIHZhciB5ZWFyID0gY2xvbmUueWVhcigpICsgTWF0aC5yb3VuZChjbG9uZS5tb250aCgpIC8gMTIpO1xuICAgICAgY2xvbmUueWVhcihNYXRoLnJvdW5kKHllYXIgLyBzdGVwKSAqIHN0ZXApO1xuICAgICAgY2xvbmUubW9udGgoMCk7XG4gICAgICBjbG9uZS5kYXRlKDApO1xuICAgICAgY2xvbmUuaG91cnMoMCk7XG4gICAgICBjbG9uZS5taW51dGVzKDApO1xuICAgICAgY2xvbmUuc2Vjb25kcygwKTtcbiAgICAgIGNsb25lLm1pbGxpc2Vjb25kcygwKTtcbiAgICB9IGVsc2UgaWYgKHNjYWxlID09ICdtb250aCcpIHtcbiAgICAgIGlmIChjbG9uZS5kYXRlKCkgPiAxNSkge1xuICAgICAgICBjbG9uZS5kYXRlKDEpO1xuICAgICAgICBjbG9uZS5hZGQoMSwgJ21vbnRoJyk7XG4gICAgICAgIC8vIGltcG9ydGFudDogZmlyc3Qgc2V0IERhdGUgdG8gMSwgYWZ0ZXIgdGhhdCBjaGFuZ2UgdGhlIG1vbnRoLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbG9uZS5kYXRlKDEpO1xuICAgICAgICB9XG5cbiAgICAgIGNsb25lLmhvdXJzKDApO1xuICAgICAgY2xvbmUubWludXRlcygwKTtcbiAgICAgIGNsb25lLnNlY29uZHMoMCk7XG4gICAgICBjbG9uZS5taWxsaXNlY29uZHMoMCk7XG4gICAgfSBlbHNlIGlmIChzY2FsZSA9PSAnZGF5Jykge1xuICAgICAgLy9ub2luc3BlY3Rpb24gRmFsbHRocm91Z2hJblN3aXRjaFN0YXRlbWVudEpTXG4gICAgICBzd2l0Y2ggKHN0ZXApIHtcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgY2xvbmUuaG91cnMoTWF0aC5yb3VuZChjbG9uZS5ob3VycygpIC8gMjQpICogMjQpO2JyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNsb25lLmhvdXJzKE1hdGgucm91bmQoY2xvbmUuaG91cnMoKSAvIDEyKSAqIDEyKTticmVhaztcbiAgICAgIH1cbiAgICAgIGNsb25lLm1pbnV0ZXMoMCk7XG4gICAgICBjbG9uZS5zZWNvbmRzKDApO1xuICAgICAgY2xvbmUubWlsbGlzZWNvbmRzKDApO1xuICAgIH0gZWxzZSBpZiAoc2NhbGUgPT0gJ3dlZWtkYXknKSB7XG4gICAgICAvL25vaW5zcGVjdGlvbiBGYWxsdGhyb3VnaEluU3dpdGNoU3RhdGVtZW50SlNcbiAgICAgIHN3aXRjaCAoc3RlcCkge1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBjbG9uZS5ob3VycyhNYXRoLnJvdW5kKGNsb25lLmhvdXJzKCkgLyAxMikgKiAxMik7YnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY2xvbmUuaG91cnMoTWF0aC5yb3VuZChjbG9uZS5ob3VycygpIC8gNikgKiA2KTticmVhaztcbiAgICAgIH1cbiAgICAgIGNsb25lLm1pbnV0ZXMoMCk7XG4gICAgICBjbG9uZS5zZWNvbmRzKDApO1xuICAgICAgY2xvbmUubWlsbGlzZWNvbmRzKDApO1xuICAgIH0gZWxzZSBpZiAoc2NhbGUgPT0gJ2hvdXInKSB7XG4gICAgICBzd2l0Y2ggKHN0ZXApIHtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIGNsb25lLm1pbnV0ZXMoTWF0aC5yb3VuZChjbG9uZS5taW51dGVzKCkgLyA2MCkgKiA2MCk7YnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY2xvbmUubWludXRlcyhNYXRoLnJvdW5kKGNsb25lLm1pbnV0ZXMoKSAvIDMwKSAqIDMwKTticmVhaztcbiAgICAgIH1cbiAgICAgIGNsb25lLnNlY29uZHMoMCk7XG4gICAgICBjbG9uZS5taWxsaXNlY29uZHMoMCk7XG4gICAgfSBlbHNlIGlmIChzY2FsZSA9PSAnbWludXRlJykge1xuICAgICAgLy9ub2luc3BlY3Rpb24gRmFsbHRocm91Z2hJblN3aXRjaFN0YXRlbWVudEpTXG4gICAgICBzd2l0Y2ggKHN0ZXApIHtcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICBjbG9uZS5taW51dGVzKE1hdGgucm91bmQoY2xvbmUubWludXRlcygpIC8gNSkgKiA1KTtcbiAgICAgICAgICBjbG9uZS5zZWNvbmRzKDApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgY2xvbmUuc2Vjb25kcyhNYXRoLnJvdW5kKGNsb25lLnNlY29uZHMoKSAvIDYwKSAqIDYwKTticmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjbG9uZS5zZWNvbmRzKE1hdGgucm91bmQoY2xvbmUuc2Vjb25kcygpIC8gMzApICogMzApO2JyZWFrO1xuICAgICAgfVxuICAgICAgY2xvbmUubWlsbGlzZWNvbmRzKDApO1xuICAgIH0gZWxzZSBpZiAoc2NhbGUgPT0gJ3NlY29uZCcpIHtcbiAgICAgIC8vbm9pbnNwZWN0aW9uIEZhbGx0aHJvdWdoSW5Td2l0Y2hTdGF0ZW1lbnRKU1xuICAgICAgc3dpdGNoIChzdGVwKSB7XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgY2xvbmUuc2Vjb25kcyhNYXRoLnJvdW5kKGNsb25lLnNlY29uZHMoKSAvIDUpICogNSk7XG4gICAgICAgICAgY2xvbmUubWlsbGlzZWNvbmRzKDApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgY2xvbmUubWlsbGlzZWNvbmRzKE1hdGgucm91bmQoY2xvbmUubWlsbGlzZWNvbmRzKCkgLyAxMDAwKSAqIDEwMDApO2JyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNsb25lLm1pbGxpc2Vjb25kcyhNYXRoLnJvdW5kKGNsb25lLm1pbGxpc2Vjb25kcygpIC8gNTAwKSAqIDUwMCk7YnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzY2FsZSA9PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICB2YXIgX3N0ZXAgPSBzdGVwID4gNSA/IHN0ZXAgLyAyIDogMTtcbiAgICAgIGNsb25lLm1pbGxpc2Vjb25kcyhNYXRoLnJvdW5kKGNsb25lLm1pbGxpc2Vjb25kcygpIC8gX3N0ZXApICogX3N0ZXApO1xuICAgIH1cblxuICAgIHJldHVybiBjbG9uZTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIGN1cnJlbnQgdmFsdWUgaXMgYSBtYWpvciB2YWx1ZSAoZm9yIGV4YW1wbGUgd2hlbiB0aGUgc3RlcFxuICAgKiBpcyBEQVksIGEgbWFqb3IgdmFsdWUgaXMgZWFjaCBmaXJzdCBkYXkgb2YgdGhlIE1PTlRIKVxuICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIGN1cnJlbnQgZGF0ZSBpcyBtYWpvciwgZWxzZSBmYWxzZS5cbiAgICovXG4gIFRpbWVTdGVwLnByb3RvdHlwZS5pc01ham9yID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnN3aXRjaGVkWWVhciA9PSB0cnVlKSB7XG4gICAgICB0aGlzLnN3aXRjaGVkWWVhciA9IGZhbHNlO1xuICAgICAgc3dpdGNoICh0aGlzLnNjYWxlKSB7XG4gICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgIGNhc2UgJ3dlZWtkYXknOlxuICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuc3dpdGNoZWRNb250aCA9PSB0cnVlKSB7XG4gICAgICB0aGlzLnN3aXRjaGVkTW9udGggPSBmYWxzZTtcbiAgICAgIHN3aXRjaCAodGhpcy5zY2FsZSkge1xuICAgICAgICBjYXNlICd3ZWVrZGF5JzpcbiAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLnN3aXRjaGVkRGF5ID09IHRydWUpIHtcbiAgICAgIHRoaXMuc3dpdGNoZWREYXkgPSBmYWxzZTtcbiAgICAgIHN3aXRjaCAodGhpcy5zY2FsZSkge1xuICAgICAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGF0ZSA9IHRoaXMubW9tZW50KHRoaXMuY3VycmVudCk7XG4gICAgc3dpdGNoICh0aGlzLnNjYWxlKSB7XG4gICAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgICAgIHJldHVybiBkYXRlLm1pbGxpc2Vjb25kcygpID09IDA7XG4gICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICByZXR1cm4gZGF0ZS5zZWNvbmRzKCkgPT0gMDtcbiAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgIHJldHVybiBkYXRlLmhvdXJzKCkgPT0gMCAmJiBkYXRlLm1pbnV0ZXMoKSA9PSAwO1xuICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgIHJldHVybiBkYXRlLmhvdXJzKCkgPT0gMDtcbiAgICAgIGNhc2UgJ3dlZWtkYXknOiAvLyBpbnRlbnRpb25hbCBmYWxsIHRocm91Z2hcbiAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgIHJldHVybiBkYXRlLmRhdGUoKSA9PSAxO1xuICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICByZXR1cm4gZGF0ZS5tb250aCgpID09IDA7XG4gICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBmb3JtYXR0ZWQgdGV4dCBmb3IgdGhlIG1pbm9yIGF4aXNsYWJlbCwgZGVwZW5kaW5nIG9uIHRoZSBjdXJyZW50XG4gICAqIGRhdGUgYW5kIHRoZSBzY2FsZS4gRm9yIGV4YW1wbGUgd2hlbiBzY2FsZSBpcyBNSU5VVEUsIHRoZSBjdXJyZW50IHRpbWUgaXNcbiAgICogZm9ybWF0dGVkIGFzIFwiaGg6bW1cIi5cbiAgICogQHBhcmFtIHtEYXRlfSBbZGF0ZV0gY3VzdG9tIGRhdGUuIGlmIG5vdCBwcm92aWRlZCwgY3VycmVudCBkYXRlIGlzIHRha2VuXG4gICAqL1xuICBUaW1lU3RlcC5wcm90b3R5cGUuZ2V0TGFiZWxNaW5vciA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgaWYgKGRhdGUgPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkYXRlID0gdGhpcy5jdXJyZW50O1xuICAgIH1cblxuICAgIHZhciBmb3JtYXQgPSB0aGlzLmZvcm1hdC5taW5vckxhYmVsc1t0aGlzLnNjYWxlXTtcbiAgICByZXR1cm4gZm9ybWF0ICYmIGZvcm1hdC5sZW5ndGggPiAwID8gdGhpcy5tb21lbnQoZGF0ZSkuZm9ybWF0KGZvcm1hdCkgOiAnJztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBmb3JtYXR0ZWQgdGV4dCBmb3IgdGhlIG1ham9yIGF4aXMgbGFiZWwsIGRlcGVuZGluZyBvbiB0aGUgY3VycmVudFxuICAgKiBkYXRlIGFuZCB0aGUgc2NhbGUuIEZvciBleGFtcGxlIHdoZW4gc2NhbGUgaXMgTUlOVVRFLCB0aGUgbWFqb3Igc2NhbGUgaXNcbiAgICogaG91cnMsIGFuZCB0aGUgaG91ciB3aWxsIGJlIGZvcm1hdHRlZCBhcyBcImhoXCIuXG4gICAqIEBwYXJhbSB7RGF0ZX0gW2RhdGVdIGN1c3RvbSBkYXRlLiBpZiBub3QgcHJvdmlkZWQsIGN1cnJlbnQgZGF0ZSBpcyB0YWtlblxuICAgKi9cbiAgVGltZVN0ZXAucHJvdG90eXBlLmdldExhYmVsTWFqb3IgPSBmdW5jdGlvbiAoZGF0ZSkge1xuICAgIGlmIChkYXRlID09IHVuZGVmaW5lZCkge1xuICAgICAgZGF0ZSA9IHRoaXMuY3VycmVudDtcbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0ID0gdGhpcy5mb3JtYXQubWFqb3JMYWJlbHNbdGhpcy5zY2FsZV07XG4gICAgcmV0dXJuIGZvcm1hdCAmJiBmb3JtYXQubGVuZ3RoID4gMCA/IHRoaXMubW9tZW50KGRhdGUpLmZvcm1hdChmb3JtYXQpIDogJyc7XG4gIH07XG5cbiAgVGltZVN0ZXAucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX21vbWVudCA9IHRoaXMubW9tZW50O1xuICAgIHZhciBtID0gdGhpcy5tb21lbnQodGhpcy5jdXJyZW50KTtcbiAgICB2YXIgY3VycmVudCA9IG0ubG9jYWxlID8gbS5sb2NhbGUoJ2VuJykgOiBtLmxhbmcoJ2VuJyk7IC8vIG9sZCB2ZXJzaW9ucyBvZiBtb21lbnQgaGF2ZSAubGFuZygpIGZ1bmN0aW9uXG4gICAgdmFyIHN0ZXAgPSB0aGlzLnN0ZXA7XG5cbiAgICBmdW5jdGlvbiBldmVuKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgLyBzdGVwICUgMiA9PSAwID8gJyB2aXMtZXZlbicgOiAnIHZpcy1vZGQnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvZGF5KGRhdGUpIHtcbiAgICAgIGlmIChkYXRlLmlzU2FtZShuZXcgRGF0ZSgpLCAnZGF5JykpIHtcbiAgICAgICAgcmV0dXJuICcgdmlzLXRvZGF5JztcbiAgICAgIH1cbiAgICAgIGlmIChkYXRlLmlzU2FtZShfbW9tZW50KCkuYWRkKDEsICdkYXknKSwgJ2RheScpKSB7XG4gICAgICAgIHJldHVybiAnIHZpcy10b21vcnJvdyc7XG4gICAgICB9XG4gICAgICBpZiAoZGF0ZS5pc1NhbWUoX21vbWVudCgpLmFkZCgtMSwgJ2RheScpLCAnZGF5JykpIHtcbiAgICAgICAgcmV0dXJuICcgdmlzLXllc3RlcmRheSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3VycmVudFdlZWsoZGF0ZSkge1xuICAgICAgcmV0dXJuIGRhdGUuaXNTYW1lKG5ldyBEYXRlKCksICd3ZWVrJykgPyAnIHZpcy1jdXJyZW50LXdlZWsnIDogJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3VycmVudE1vbnRoKGRhdGUpIHtcbiAgICAgIHJldHVybiBkYXRlLmlzU2FtZShuZXcgRGF0ZSgpLCAnbW9udGgnKSA/ICcgdmlzLWN1cnJlbnQtbW9udGgnIDogJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3VycmVudFllYXIoZGF0ZSkge1xuICAgICAgcmV0dXJuIGRhdGUuaXNTYW1lKG5ldyBEYXRlKCksICd5ZWFyJykgPyAnIHZpcy1jdXJyZW50LXllYXInIDogJyc7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLnNjYWxlKSB7XG4gICAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgICAgIHJldHVybiBldmVuKGN1cnJlbnQubWlsbGlzZWNvbmRzKCkpLnRyaW0oKTtcblxuICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgcmV0dXJuIGV2ZW4oY3VycmVudC5zZWNvbmRzKCkpLnRyaW0oKTtcblxuICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgcmV0dXJuIGV2ZW4oY3VycmVudC5taW51dGVzKCkpLnRyaW0oKTtcblxuICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgIHZhciBob3VycyA9IGN1cnJlbnQuaG91cnMoKTtcbiAgICAgICAgaWYgKHRoaXMuc3RlcCA9PSA0KSB7XG4gICAgICAgICAgaG91cnMgPSBob3VycyArICctaCcgKyAoaG91cnMgKyA0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ3Zpcy1oJyArIGhvdXJzICsgdG9kYXkoY3VycmVudCkgKyBldmVuKGN1cnJlbnQuaG91cnMoKSk7XG5cbiAgICAgIGNhc2UgJ3dlZWtkYXknOlxuICAgICAgICByZXR1cm4gJ3Zpcy0nICsgY3VycmVudC5mb3JtYXQoJ2RkZGQnKS50b0xvd2VyQ2FzZSgpICsgdG9kYXkoY3VycmVudCkgKyBjdXJyZW50V2VlayhjdXJyZW50KSArIGV2ZW4oY3VycmVudC5kYXRlKCkpO1xuXG4gICAgICBjYXNlICdkYXknOlxuICAgICAgICB2YXIgZGF5ID0gY3VycmVudC5kYXRlKCk7XG4gICAgICAgIHZhciBtb250aCA9IGN1cnJlbnQuZm9ybWF0KCdNTU1NJykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuICd2aXMtZGF5JyArIGRheSArICcgdmlzLScgKyBtb250aCArIGN1cnJlbnRNb250aChjdXJyZW50KSArIGV2ZW4oZGF5IC0gMSk7XG5cbiAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgcmV0dXJuICd2aXMtJyArIGN1cnJlbnQuZm9ybWF0KCdNTU1NJykudG9Mb3dlckNhc2UoKSArIGN1cnJlbnRNb250aChjdXJyZW50KSArIGV2ZW4oY3VycmVudC5tb250aCgpKTtcblxuICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgIHZhciB5ZWFyID0gY3VycmVudC55ZWFyKCk7XG4gICAgICAgIHJldHVybiAndmlzLXllYXInICsgeWVhciArIGN1cnJlbnRZZWFyKGN1cnJlbnQpICsgZXZlbih5ZWFyKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFRpbWVTdGVwO1xuXG4vKioqLyB9LFxuLyogMzYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4gIHZhciBzdGFjayA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpO1xuICB2YXIgUmFuZ2VJdGVtID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOCk7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvciBHcm91cFxuICAgKiBAcGFyYW0ge051bWJlciB8IFN0cmluZ30gZ3JvdXBJZFxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKiBAcGFyYW0ge0l0ZW1TZXR9IGl0ZW1TZXRcbiAgICovXG4gIGZ1bmN0aW9uIEdyb3VwKGdyb3VwSWQsIGRhdGEsIGl0ZW1TZXQpIHtcbiAgICB0aGlzLmdyb3VwSWQgPSBncm91cElkO1xuICAgIHRoaXMuc3ViZ3JvdXBzID0ge307XG4gICAgdGhpcy5zdWJncm91cEluZGV4ID0gMDtcbiAgICB0aGlzLnN1Ymdyb3VwT3JkZXJlciA9IGRhdGEgJiYgZGF0YS5zdWJncm91cE9yZGVyO1xuICAgIHRoaXMuaXRlbVNldCA9IGl0ZW1TZXQ7XG5cbiAgICB0aGlzLmRvbSA9IHt9O1xuICAgIHRoaXMucHJvcHMgPSB7XG4gICAgICBsYWJlbDoge1xuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwXG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmNsYXNzTmFtZSA9IG51bGw7XG5cbiAgICB0aGlzLml0ZW1zID0ge307IC8vIGl0ZW1zIGZpbHRlcmVkIGJ5IGdyb3VwSWQgb2YgdGhpcyBncm91cFxuICAgIHRoaXMudmlzaWJsZUl0ZW1zID0gW107IC8vIGl0ZW1zIGN1cnJlbnRseSB2aXNpYmxlIGluIHdpbmRvd1xuICAgIHRoaXMub3JkZXJlZEl0ZW1zID0ge1xuICAgICAgYnlTdGFydDogW10sXG4gICAgICBieUVuZDogW11cbiAgICB9O1xuICAgIHRoaXMuY2hlY2tSYW5nZWRJdGVtcyA9IGZhbHNlOyAvLyBuZWVkZWQgdG8gcmVmcmVzaCB0aGUgcmFuZ2VkIGl0ZW1zIGlmIHRoZSB3aW5kb3cgaXMgcHJvZ3JhbWF0aWNhbGx5IGNoYW5nZWQgd2l0aCBOTyBvdmVybGFwLlxuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdGhpcy5pdGVtU2V0LmJvZHkuZW1pdHRlci5vbihcImNoZWNrUmFuZ2VkSXRlbXNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgbWUuY2hlY2tSYW5nZWRJdGVtcyA9IHRydWU7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9jcmVhdGUoKTtcblxuICAgIHRoaXMuc2V0RGF0YShkYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgRE9NIGVsZW1lbnRzIGZvciB0aGUgZ3JvdXBcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEdyb3VwLnByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGlmICh0aGlzLml0ZW1TZXQub3B0aW9ucy5ncm91cEVkaXRhYmxlLm9yZGVyKSB7XG4gICAgICBsYWJlbC5jbGFzc05hbWUgPSAndmlzLWxhYmVsIGRyYWdnYWJsZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhYmVsLmNsYXNzTmFtZSA9ICd2aXMtbGFiZWwnO1xuICAgIH1cbiAgICB0aGlzLmRvbS5sYWJlbCA9IGxhYmVsO1xuXG4gICAgdmFyIGlubmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgaW5uZXIuY2xhc3NOYW1lID0gJ3Zpcy1pbm5lcic7XG4gICAgbGFiZWwuYXBwZW5kQ2hpbGQoaW5uZXIpO1xuICAgIHRoaXMuZG9tLmlubmVyID0gaW5uZXI7XG5cbiAgICB2YXIgZm9yZWdyb3VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGZvcmVncm91bmQuY2xhc3NOYW1lID0gJ3Zpcy1ncm91cCc7XG4gICAgZm9yZWdyb3VuZFsndGltZWxpbmUtZ3JvdXAnXSA9IHRoaXM7XG4gICAgdGhpcy5kb20uZm9yZWdyb3VuZCA9IGZvcmVncm91bmQ7XG5cbiAgICB0aGlzLmRvbS5iYWNrZ3JvdW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5kb20uYmFja2dyb3VuZC5jbGFzc05hbWUgPSAndmlzLWdyb3VwJztcblxuICAgIHRoaXMuZG9tLmF4aXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmRvbS5heGlzLmNsYXNzTmFtZSA9ICd2aXMtZ3JvdXAnO1xuXG4gICAgLy8gY3JlYXRlIGEgaGlkZGVuIG1hcmtlciB0byBkZXRlY3Qgd2hlbiB0aGUgVGltZWxpbmVzIGNvbnRhaW5lciBpcyBhdHRhY2hlZFxuICAgIC8vIHRvIHRoZSBET00sIG9yIHRoZSBzdHlsZSBvZiBhIHBhcmVudCBvZiB0aGUgVGltZWxpbmUgaXMgY2hhbmdlZCBmcm9tXG4gICAgLy8gZGlzcGxheTpub25lIGlzIGNoYW5nZWQgdG8gdmlzaWJsZS5cbiAgICB0aGlzLmRvbS5tYXJrZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmRvbS5tYXJrZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgIHRoaXMuZG9tLm1hcmtlci5pbm5lckhUTUwgPSAnPyc7XG4gICAgdGhpcy5kb20uYmFja2dyb3VuZC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5tYXJrZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGdyb3VwIGRhdGEgZm9yIHRoaXMgZ3JvdXBcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgICBHcm91cCBkYXRhLCBjYW4gY29udGFpbiBwcm9wZXJ0aWVzIGNvbnRlbnQgYW5kIGNsYXNzTmFtZVxuICAgKi9cbiAgR3JvdXAucHJvdG90eXBlLnNldERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIC8vIHVwZGF0ZSBjb250ZW50c1xuICAgIHZhciBjb250ZW50O1xuICAgIGlmICh0aGlzLml0ZW1TZXQub3B0aW9ucyAmJiB0aGlzLml0ZW1TZXQub3B0aW9ucy5ncm91cFRlbXBsYXRlKSB7XG4gICAgICBjb250ZW50ID0gdGhpcy5pdGVtU2V0Lm9wdGlvbnMuZ3JvdXBUZW1wbGF0ZShkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudCA9IGRhdGEgJiYgZGF0YS5jb250ZW50O1xuICAgIH1cblxuICAgIGlmIChjb250ZW50IGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgdGhpcy5kb20uaW5uZXIuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgICB3aGlsZSAodGhpcy5kb20uaW5uZXIuZmlyc3RDaGlsZCkge1xuICAgICAgICB0aGlzLmRvbS5pbm5lci5yZW1vdmVDaGlsZCh0aGlzLmRvbS5pbm5lci5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZG9tLmlubmVyLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgIH0gZWxzZSBpZiAoY29udGVudCAhPT0gdW5kZWZpbmVkICYmIGNvbnRlbnQgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuZG9tLmlubmVyLmlubmVySFRNTCA9IGNvbnRlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZG9tLmlubmVyLmlubmVySFRNTCA9IHRoaXMuZ3JvdXBJZCB8fCAnJzsgLy8gZ3JvdXBJZCBjYW4gYmUgbnVsbFxuICAgIH1cblxuICAgIC8vIHVwZGF0ZSB0aXRsZVxuICAgIHRoaXMuZG9tLmxhYmVsLnRpdGxlID0gZGF0YSAmJiBkYXRhLnRpdGxlIHx8ICcnO1xuXG4gICAgaWYgKCF0aGlzLmRvbS5pbm5lci5maXJzdENoaWxkKSB7XG4gICAgICB1dGlsLmFkZENsYXNzTmFtZSh0aGlzLmRvbS5pbm5lciwgJ3Zpcy1oaWRkZW4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXRpbC5yZW1vdmVDbGFzc05hbWUodGhpcy5kb20uaW5uZXIsICd2aXMtaGlkZGVuJyk7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGNsYXNzTmFtZVxuICAgIHZhciBjbGFzc05hbWUgPSBkYXRhICYmIGRhdGEuY2xhc3NOYW1lIHx8IG51bGw7XG4gICAgaWYgKGNsYXNzTmFtZSAhPSB0aGlzLmNsYXNzTmFtZSkge1xuICAgICAgaWYgKHRoaXMuY2xhc3NOYW1lKSB7XG4gICAgICAgIHV0aWwucmVtb3ZlQ2xhc3NOYW1lKHRoaXMuZG9tLmxhYmVsLCB0aGlzLmNsYXNzTmFtZSk7XG4gICAgICAgIHV0aWwucmVtb3ZlQ2xhc3NOYW1lKHRoaXMuZG9tLmZvcmVncm91bmQsIHRoaXMuY2xhc3NOYW1lKTtcbiAgICAgICAgdXRpbC5yZW1vdmVDbGFzc05hbWUodGhpcy5kb20uYmFja2dyb3VuZCwgdGhpcy5jbGFzc05hbWUpO1xuICAgICAgICB1dGlsLnJlbW92ZUNsYXNzTmFtZSh0aGlzLmRvbS5heGlzLCB0aGlzLmNsYXNzTmFtZSk7XG4gICAgICB9XG4gICAgICB1dGlsLmFkZENsYXNzTmFtZSh0aGlzLmRvbS5sYWJlbCwgY2xhc3NOYW1lKTtcbiAgICAgIHV0aWwuYWRkQ2xhc3NOYW1lKHRoaXMuZG9tLmZvcmVncm91bmQsIGNsYXNzTmFtZSk7XG4gICAgICB1dGlsLmFkZENsYXNzTmFtZSh0aGlzLmRvbS5iYWNrZ3JvdW5kLCBjbGFzc05hbWUpO1xuICAgICAgdXRpbC5hZGRDbGFzc05hbWUodGhpcy5kb20uYXhpcywgY2xhc3NOYW1lKTtcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBzdHlsZVxuICAgIGlmICh0aGlzLnN0eWxlKSB7XG4gICAgICB1dGlsLnJlbW92ZUNzc1RleHQodGhpcy5kb20ubGFiZWwsIHRoaXMuc3R5bGUpO1xuICAgICAgdGhpcy5zdHlsZSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChkYXRhICYmIGRhdGEuc3R5bGUpIHtcbiAgICAgIHV0aWwuYWRkQ3NzVGV4dCh0aGlzLmRvbS5sYWJlbCwgZGF0YS5zdHlsZSk7XG4gICAgICB0aGlzLnN0eWxlID0gZGF0YS5zdHlsZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgd2lkdGggb2YgdGhlIGdyb3VwIGxhYmVsXG4gICAqIEByZXR1cm4ge251bWJlcn0gd2lkdGhcbiAgICovXG4gIEdyb3VwLnByb3RvdHlwZS5nZXRMYWJlbFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLmxhYmVsLndpZHRoO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXBhaW50IHRoaXMgZ3JvdXBcbiAgICogQHBhcmFtIHt7c3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXJ9fSByYW5nZVxuICAgKiBAcGFyYW0ge3tpdGVtOiB7aG9yaXpvbnRhbDogbnVtYmVyLCB2ZXJ0aWNhbDogbnVtYmVyfSwgYXhpczogbnVtYmVyfX0gbWFyZ2luXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Jlc3RhY2s9ZmFsc2VdICBGb3JjZSByZXN0YWNraW5nIG9mIGFsbCBpdGVtc1xuICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGdyb3VwIGlzIHJlc2l6ZWRcbiAgICovXG4gIEdyb3VwLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbiAocmFuZ2UsIG1hcmdpbiwgcmVzdGFjaykge1xuICAgIHZhciByZXNpemVkID0gZmFsc2U7XG5cbiAgICAvLyBmb3JjZSByZWNhbGN1bGF0aW9uIG9mIHRoZSBoZWlnaHQgb2YgdGhlIGl0ZW1zIHdoZW4gdGhlIG1hcmtlciBoZWlnaHQgY2hhbmdlZFxuICAgIC8vIChkdWUgdG8gdGhlIFRpbWVsaW5lIGJlaW5nIGF0dGFjaGVkIHRvIHRoZSBET00gb3IgY2hhbmdlZCBmcm9tIGRpc3BsYXk6bm9uZSB0byB2aXNpYmxlKVxuICAgIHZhciBtYXJrZXJIZWlnaHQgPSB0aGlzLmRvbS5tYXJrZXIuY2xpZW50SGVpZ2h0O1xuICAgIGlmIChtYXJrZXJIZWlnaHQgIT0gdGhpcy5sYXN0TWFya2VySGVpZ2h0KSB7XG4gICAgICB0aGlzLmxhc3RNYXJrZXJIZWlnaHQgPSBtYXJrZXJIZWlnaHQ7XG5cbiAgICAgIHV0aWwuZm9yRWFjaCh0aGlzLml0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpdGVtLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgaWYgKGl0ZW0uZGlzcGxheWVkKSBpdGVtLnJlZHJhdygpO1xuICAgICAgfSk7XG5cbiAgICAgIHJlc3RhY2sgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIHJlY2FsY3VsYXRlIHRoZSBoZWlnaHQgb2YgdGhlIHN1Ymdyb3Vwc1xuICAgIHRoaXMuX2NhbGN1bGF0ZVN1Ykdyb3VwSGVpZ2h0cygpO1xuXG4gICAgLy8gcmVwb3NpdGlvbiB2aXNpYmxlIGl0ZW1zIHZlcnRpY2FsbHlcbiAgICBpZiAodHlwZW9mIHRoaXMuaXRlbVNldC5vcHRpb25zLm9yZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBhIGN1c3RvbSBvcmRlciBmdW5jdGlvblxuXG4gICAgICBpZiAocmVzdGFjaykge1xuICAgICAgICAvLyBicnV0ZSBmb3JjZSByZXN0YWNrIG9mIGFsbCBpdGVtc1xuXG4gICAgICAgIC8vIHNob3cgYWxsIGl0ZW1zXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBsaW1pdFNpemUgPSBmYWxzZTtcbiAgICAgICAgdXRpbC5mb3JFYWNoKHRoaXMuaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgaWYgKCFpdGVtLmRpc3BsYXllZCkge1xuICAgICAgICAgICAgaXRlbS5yZWRyYXcoKTtcbiAgICAgICAgICAgIG1lLnZpc2libGVJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpdGVtLnJlcG9zaXRpb25YKGxpbWl0U2l6ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIG9yZGVyIGFsbCBpdGVtcyBhbmQgZm9yY2UgYSByZXN0YWNraW5nXG4gICAgICAgIHZhciBjdXN0b21PcmRlcmVkSXRlbXMgPSB0aGlzLm9yZGVyZWRJdGVtcy5ieVN0YXJ0LnNsaWNlKCkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIHJldHVybiBtZS5pdGVtU2V0Lm9wdGlvbnMub3JkZXIoYS5kYXRhLCBiLmRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RhY2suc3RhY2soY3VzdG9tT3JkZXJlZEl0ZW1zLCBtYXJnaW4sIHRydWUgLyogcmVzdGFjaz10cnVlICovKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy52aXNpYmxlSXRlbXMgPSB0aGlzLl91cGRhdGVWaXNpYmxlSXRlbXModGhpcy5vcmRlcmVkSXRlbXMsIHRoaXMudmlzaWJsZUl0ZW1zLCByYW5nZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5vIGN1c3RvbSBvcmRlciBmdW5jdGlvbiwgbGF6eSBzdGFja2luZ1xuXG4gICAgICB0aGlzLnZpc2libGVJdGVtcyA9IHRoaXMuX3VwZGF0ZVZpc2libGVJdGVtcyh0aGlzLm9yZGVyZWRJdGVtcywgdGhpcy52aXNpYmxlSXRlbXMsIHJhbmdlKTtcbiAgICAgIGlmICh0aGlzLml0ZW1TZXQub3B0aW9ucy5zdGFjaykge1xuICAgICAgICAvLyBUT0RPOiB1Z2x5IHdheSB0byBhY2Nlc3Mgb3B0aW9ucy4uLlxuICAgICAgICBzdGFjay5zdGFjayh0aGlzLnZpc2libGVJdGVtcywgbWFyZ2luLCByZXN0YWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vIHN0YWNraW5nXG4gICAgICAgIHN0YWNrLm5vc3RhY2sodGhpcy52aXNpYmxlSXRlbXMsIG1hcmdpbiwgdGhpcy5zdWJncm91cHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJlY2FsY3VsYXRlIHRoZSBoZWlnaHQgb2YgdGhlIGdyb3VwXG4gICAgdmFyIGhlaWdodCA9IHRoaXMuX2NhbGN1bGF0ZUhlaWdodChtYXJnaW4pO1xuXG4gICAgLy8gY2FsY3VsYXRlIGFjdHVhbCBzaXplIGFuZCBwb3NpdGlvblxuICAgIHZhciBmb3JlZ3JvdW5kID0gdGhpcy5kb20uZm9yZWdyb3VuZDtcbiAgICB0aGlzLnRvcCA9IGZvcmVncm91bmQub2Zmc2V0VG9wO1xuICAgIHRoaXMucmlnaHQgPSBmb3JlZ3JvdW5kLm9mZnNldExlZnQ7XG4gICAgdGhpcy53aWR0aCA9IGZvcmVncm91bmQub2Zmc2V0V2lkdGg7XG4gICAgcmVzaXplZCA9IHV0aWwudXBkYXRlUHJvcGVydHkodGhpcywgJ2hlaWdodCcsIGhlaWdodCkgfHwgcmVzaXplZDtcbiAgICAvLyByZWNhbGN1bGF0ZSBzaXplIG9mIGxhYmVsXG4gICAgcmVzaXplZCA9IHV0aWwudXBkYXRlUHJvcGVydHkodGhpcy5wcm9wcy5sYWJlbCwgJ3dpZHRoJywgdGhpcy5kb20uaW5uZXIuY2xpZW50V2lkdGgpIHx8IHJlc2l6ZWQ7XG4gICAgcmVzaXplZCA9IHV0aWwudXBkYXRlUHJvcGVydHkodGhpcy5wcm9wcy5sYWJlbCwgJ2hlaWdodCcsIHRoaXMuZG9tLmlubmVyLmNsaWVudEhlaWdodCkgfHwgcmVzaXplZDtcblxuICAgIC8vIGFwcGx5IG5ldyBoZWlnaHRcbiAgICB0aGlzLmRvbS5iYWNrZ3JvdW5kLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgdGhpcy5kb20uZm9yZWdyb3VuZC5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgIHRoaXMuZG9tLmxhYmVsLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cbiAgICAvLyB1cGRhdGUgdmVydGljYWwgcG9zaXRpb24gb2YgaXRlbXMgYWZ0ZXIgdGhleSBhcmUgcmUtc3RhY2tlZCBhbmQgdGhlIGhlaWdodCBvZiB0aGUgZ3JvdXAgaXMgY2FsY3VsYXRlZFxuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHRoaXMudmlzaWJsZUl0ZW1zLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gdGhpcy52aXNpYmxlSXRlbXNbaV07XG4gICAgICBpdGVtLnJlcG9zaXRpb25ZKG1hcmdpbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc2l6ZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIHJlY2FsY3VsYXRlIHRoZSBoZWlnaHQgb2YgdGhlIHN1Ymdyb3Vwc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgR3JvdXAucHJvdG90eXBlLl9jYWxjdWxhdGVTdWJHcm91cEhlaWdodHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuc3ViZ3JvdXBzKS5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgbWUgPSB0aGlzO1xuXG4gICAgICB0aGlzLnJlc2V0U3ViZ3JvdXBzKCk7XG5cbiAgICAgIHV0aWwuZm9yRWFjaCh0aGlzLnZpc2libGVJdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0uZGF0YS5zdWJncm91cCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbWUuc3ViZ3JvdXBzW2l0ZW0uZGF0YS5zdWJncm91cF0uaGVpZ2h0ID0gTWF0aC5tYXgobWUuc3ViZ3JvdXBzW2l0ZW0uZGF0YS5zdWJncm91cF0uaGVpZ2h0LCBpdGVtLmhlaWdodCk7XG4gICAgICAgICAgbWUuc3ViZ3JvdXBzW2l0ZW0uZGF0YS5zdWJncm91cF0udmlzaWJsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogcmVjYWxjdWxhdGUgdGhlIGhlaWdodCBvZiB0aGUgZ3JvdXBcbiAgICogQHBhcmFtIHt7aXRlbToge2hvcml6b250YWw6IG51bWJlciwgdmVydGljYWw6IG51bWJlcn0sIGF4aXM6IG51bWJlcn19IG1hcmdpblxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBoZWlnaHRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEdyb3VwLnByb3RvdHlwZS5fY2FsY3VsYXRlSGVpZ2h0ID0gZnVuY3Rpb24gKG1hcmdpbikge1xuICAgIC8vIHJlY2FsY3VsYXRlIHRoZSBoZWlnaHQgb2YgdGhlIGdyb3VwXG4gICAgdmFyIGhlaWdodDtcbiAgICB2YXIgdmlzaWJsZUl0ZW1zID0gdGhpcy52aXNpYmxlSXRlbXM7XG4gICAgaWYgKHZpc2libGVJdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgbWluID0gdmlzaWJsZUl0ZW1zWzBdLnRvcDtcbiAgICAgIHZhciBtYXggPSB2aXNpYmxlSXRlbXNbMF0udG9wICsgdmlzaWJsZUl0ZW1zWzBdLmhlaWdodDtcbiAgICAgIHV0aWwuZm9yRWFjaCh2aXNpYmxlSXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgaXRlbS50b3ApO1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIGl0ZW0udG9wICsgaXRlbS5oZWlnaHQpO1xuICAgICAgfSk7XG4gICAgICBpZiAobWluID4gbWFyZ2luLmF4aXMpIHtcbiAgICAgICAgLy8gdGhlcmUgaXMgYW4gZW1wdHkgZ2FwIGJldHdlZW4gdGhlIGxvd2VzdCBpdGVtIGFuZCB0aGUgYXhpc1xuICAgICAgICB2YXIgb2Zmc2V0ID0gbWluIC0gbWFyZ2luLmF4aXM7XG4gICAgICAgIG1heCAtPSBvZmZzZXQ7XG4gICAgICAgIHV0aWwuZm9yRWFjaCh2aXNpYmxlSXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgaXRlbS50b3AgLT0gb2Zmc2V0O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGhlaWdodCA9IG1heCArIG1hcmdpbi5pdGVtLnZlcnRpY2FsIC8gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVpZ2h0ID0gMDtcbiAgICB9XG4gICAgaGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0LCB0aGlzLnByb3BzLmxhYmVsLmhlaWdodCk7XG5cbiAgICByZXR1cm4gaGVpZ2h0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBTaG93IHRoaXMgZ3JvdXA6IGF0dGFjaCB0byB0aGUgRE9NXG4gICAqL1xuICBHcm91cC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuZG9tLmxhYmVsLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuaXRlbVNldC5kb20ubGFiZWxTZXQuYXBwZW5kQ2hpbGQodGhpcy5kb20ubGFiZWwpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5kb20uZm9yZWdyb3VuZC5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLml0ZW1TZXQuZG9tLmZvcmVncm91bmQuYXBwZW5kQ2hpbGQodGhpcy5kb20uZm9yZWdyb3VuZCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmRvbS5iYWNrZ3JvdW5kLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuaXRlbVNldC5kb20uYmFja2dyb3VuZC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5iYWNrZ3JvdW5kKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZG9tLmF4aXMucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5pdGVtU2V0LmRvbS5heGlzLmFwcGVuZENoaWxkKHRoaXMuZG9tLmF4aXMpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSGlkZSB0aGlzIGdyb3VwOiByZW1vdmUgZnJvbSB0aGUgRE9NXG4gICAqL1xuICBHcm91cC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGFiZWwgPSB0aGlzLmRvbS5sYWJlbDtcbiAgICBpZiAobGFiZWwucGFyZW50Tm9kZSkge1xuICAgICAgbGFiZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsYWJlbCk7XG4gICAgfVxuXG4gICAgdmFyIGZvcmVncm91bmQgPSB0aGlzLmRvbS5mb3JlZ3JvdW5kO1xuICAgIGlmIChmb3JlZ3JvdW5kLnBhcmVudE5vZGUpIHtcbiAgICAgIGZvcmVncm91bmQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChmb3JlZ3JvdW5kKTtcbiAgICB9XG5cbiAgICB2YXIgYmFja2dyb3VuZCA9IHRoaXMuZG9tLmJhY2tncm91bmQ7XG4gICAgaWYgKGJhY2tncm91bmQucGFyZW50Tm9kZSkge1xuICAgICAgYmFja2dyb3VuZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGJhY2tncm91bmQpO1xuICAgIH1cblxuICAgIHZhciBheGlzID0gdGhpcy5kb20uYXhpcztcbiAgICBpZiAoYXhpcy5wYXJlbnROb2RlKSB7XG4gICAgICBheGlzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYXhpcyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYW4gaXRlbSB0byB0aGUgZ3JvdXBcbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBHcm91cC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICB0aGlzLml0ZW1zW2l0ZW0uaWRdID0gaXRlbTtcbiAgICBpdGVtLnNldFBhcmVudCh0aGlzKTtcblxuICAgIC8vIGFkZCB0b1xuICAgIGlmIChpdGVtLmRhdGEuc3ViZ3JvdXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHRoaXMuc3ViZ3JvdXBzW2l0ZW0uZGF0YS5zdWJncm91cF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnN1Ymdyb3Vwc1tpdGVtLmRhdGEuc3ViZ3JvdXBdID0geyBoZWlnaHQ6IDAsIHZpc2libGU6IGZhbHNlLCBpbmRleDogdGhpcy5zdWJncm91cEluZGV4LCBpdGVtczogW10gfTtcbiAgICAgICAgdGhpcy5zdWJncm91cEluZGV4Kys7XG4gICAgICB9XG4gICAgICB0aGlzLnN1Ymdyb3Vwc1tpdGVtLmRhdGEuc3ViZ3JvdXBdLml0ZW1zLnB1c2goaXRlbSk7XG4gICAgfVxuICAgIHRoaXMub3JkZXJTdWJncm91cHMoKTtcblxuICAgIGlmICh0aGlzLnZpc2libGVJdGVtcy5pbmRleE9mKGl0ZW0pID09IC0xKSB7XG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLml0ZW1TZXQuYm9keS5yYW5nZTsgLy8gVE9ETzogbm90IG5pY2UgYWNjZXNzaW5nIHRoZSByYW5nZSBsaWtlIHRoaXNcbiAgICAgIHRoaXMuX2NoZWNrSWZWaXNpYmxlKGl0ZW0sIHRoaXMudmlzaWJsZUl0ZW1zLCByYW5nZSk7XG4gICAgfVxuICB9O1xuXG4gIEdyb3VwLnByb3RvdHlwZS5vcmRlclN1Ymdyb3VwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5zdWJncm91cE9yZGVyZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHNvcnRBcnJheSA9IFtdO1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLnN1Ymdyb3VwT3JkZXJlciA9PSAnc3RyaW5nJykge1xuICAgICAgICBmb3IgKHZhciBzdWJncm91cCBpbiB0aGlzLnN1Ymdyb3Vwcykge1xuICAgICAgICAgIHNvcnRBcnJheS5wdXNoKHsgc3ViZ3JvdXA6IHN1Ymdyb3VwLCBzb3J0RmllbGQ6IHRoaXMuc3ViZ3JvdXBzW3N1Ymdyb3VwXS5pdGVtc1swXS5kYXRhW3RoaXMuc3ViZ3JvdXBPcmRlcmVyXSB9KTtcbiAgICAgICAgfVxuICAgICAgICBzb3J0QXJyYXkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIHJldHVybiBhLnNvcnRGaWVsZCAtIGIuc29ydEZpZWxkO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuc3ViZ3JvdXBPcmRlcmVyID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm9yICh2YXIgc3ViZ3JvdXAgaW4gdGhpcy5zdWJncm91cHMpIHtcbiAgICAgICAgICBzb3J0QXJyYXkucHVzaCh0aGlzLnN1Ymdyb3Vwc1tzdWJncm91cF0uaXRlbXNbMF0uZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgc29ydEFycmF5LnNvcnQodGhpcy5zdWJncm91cE9yZGVyZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc29ydEFycmF5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3J0QXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLnN1Ymdyb3Vwc1tzb3J0QXJyYXlbaV0uc3ViZ3JvdXBdLmluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBHcm91cC5wcm90b3R5cGUucmVzZXRTdWJncm91cHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgc3ViZ3JvdXAgaW4gdGhpcy5zdWJncm91cHMpIHtcbiAgICAgIGlmICh0aGlzLnN1Ymdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShzdWJncm91cCkpIHtcbiAgICAgICAgdGhpcy5zdWJncm91cHNbc3ViZ3JvdXBdLnZpc2libGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBpdGVtIGZyb20gdGhlIGdyb3VwXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgR3JvdXAucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgZGVsZXRlIHRoaXMuaXRlbXNbaXRlbS5pZF07XG4gICAgaXRlbS5zZXRQYXJlbnQobnVsbCk7XG5cbiAgICAvLyByZW1vdmUgZnJvbSB2aXNpYmxlIGl0ZW1zXG4gICAgdmFyIGluZGV4ID0gdGhpcy52aXNpYmxlSXRlbXMuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAoaW5kZXggIT0gLTEpIHRoaXMudmlzaWJsZUl0ZW1zLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICBpZiAoaXRlbS5kYXRhLnN1Ymdyb3VwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBzdWJncm91cCA9IHRoaXMuc3ViZ3JvdXBzW2l0ZW0uZGF0YS5zdWJncm91cF07XG4gICAgICBpZiAoc3ViZ3JvdXApIHtcbiAgICAgICAgdmFyIGl0ZW1JbmRleCA9IHN1Ymdyb3VwLml0ZW1zLmluZGV4T2YoaXRlbSk7XG4gICAgICAgIHN1Ymdyb3VwLml0ZW1zLnNwbGljZShpdGVtSW5kZXgsIDEpO1xuICAgICAgICBpZiAoIXN1Ymdyb3VwLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnN1Ymdyb3Vwc1tpdGVtLmRhdGEuc3ViZ3JvdXBdO1xuICAgICAgICAgIHRoaXMuc3ViZ3JvdXBJbmRleC0tO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3JkZXJTdWJncm91cHMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBpdGVtIGZyb20gdGhlIGNvcnJlc3BvbmRpbmcgRGF0YVNldFxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIEdyb3VwLnByb3RvdHlwZS5yZW1vdmVGcm9tRGF0YVNldCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgdGhpcy5pdGVtU2V0LnJlbW92ZUl0ZW0oaXRlbS5pZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlb3JkZXIgdGhlIGl0ZW1zXG4gICAqL1xuICBHcm91cC5wcm90b3R5cGUub3JkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFycmF5ID0gdXRpbC50b0FycmF5KHRoaXMuaXRlbXMpO1xuICAgIHZhciBzdGFydEFycmF5ID0gW107XG4gICAgdmFyIGVuZEFycmF5ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXJyYXlbaV0uZGF0YS5lbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbmRBcnJheS5wdXNoKGFycmF5W2ldKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0QXJyYXkucHVzaChhcnJheVtpXSk7XG4gICAgfVxuICAgIHRoaXMub3JkZXJlZEl0ZW1zID0ge1xuICAgICAgYnlTdGFydDogc3RhcnRBcnJheSxcbiAgICAgIGJ5RW5kOiBlbmRBcnJheVxuICAgIH07XG5cbiAgICBzdGFjay5vcmRlckJ5U3RhcnQodGhpcy5vcmRlcmVkSXRlbXMuYnlTdGFydCk7XG4gICAgc3RhY2sub3JkZXJCeUVuZCh0aGlzLm9yZGVyZWRJdGVtcy5ieUVuZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgdmlzaWJsZSBpdGVtc1xuICAgKiBAcGFyYW0ge3tieVN0YXJ0OiBJdGVtW10sIGJ5RW5kOiBJdGVtW119fSBvcmRlcmVkSXRlbXMgICBBbGwgaXRlbXMgb3JkZXJlZCBieSBzdGFydCBkYXRlIGFuZCBieSBlbmQgZGF0ZVxuICAgKiBAcGFyYW0ge0l0ZW1bXX0gdmlzaWJsZUl0ZW1zICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgcHJldmlvdXNseSB2aXNpYmxlIGl0ZW1zLlxuICAgKiBAcGFyYW0ge3tzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcn19IHJhbmdlICAgICAgICAgICAgICBWaXNpYmxlIHJhbmdlXG4gICAqIEByZXR1cm4ge0l0ZW1bXX0gdmlzaWJsZUl0ZW1zICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBuZXcgdmlzaWJsZSBpdGVtcy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIEdyb3VwLnByb3RvdHlwZS5fdXBkYXRlVmlzaWJsZUl0ZW1zID0gZnVuY3Rpb24gKG9yZGVyZWRJdGVtcywgb2xkVmlzaWJsZUl0ZW1zLCByYW5nZSkge1xuICAgIHZhciB2aXNpYmxlSXRlbXMgPSBbXTtcbiAgICB2YXIgdmlzaWJsZUl0ZW1zTG9va3VwID0ge307IC8vIHdlIGtlZXAgdGhpcyB0byBxdWlja2x5IGxvb2sgdXAgaWYgYW4gaXRlbSBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgbGlzdCB3aXRob3V0IHVzaW5nIGluZGV4T2Ygb24gdmlzaWJsZUl0ZW1zXG4gICAgdmFyIGludGVydmFsID0gKHJhbmdlLmVuZCAtIHJhbmdlLnN0YXJ0KSAvIDQ7XG4gICAgdmFyIGxvd2VyQm91bmQgPSByYW5nZS5zdGFydCAtIGludGVydmFsO1xuICAgIHZhciB1cHBlckJvdW5kID0gcmFuZ2UuZW5kICsgaW50ZXJ2YWw7XG4gICAgdmFyIGl0ZW0sIGk7XG5cbiAgICAvLyB0aGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gZG8gdGhlIGJpbmFyeSBzZWFyY2guXG4gICAgdmFyIHNlYXJjaEZ1bmN0aW9uID0gZnVuY3Rpb24gc2VhcmNoRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA8IGxvd2VyQm91bmQpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA8PSB1cHBlckJvdW5kKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIGZpcnN0IGNoZWNrIGlmIHRoZSBpdGVtcyB0aGF0IHdlcmUgaW4gdmlldyBwcmV2aW91c2x5IGFyZSBzdGlsbCBpbiB2aWV3LlxuICAgIC8vIElNUE9SVEFOVDogdGhpcyBoYW5kbGVzIHRoZSBjYXNlIGZvciB0aGUgaXRlbXMgd2l0aCBzdGFydGRhdGUgYmVmb3JlIHRoZSB3aW5kb3cgYW5kIGVuZGRhdGUgYWZ0ZXIgdGhlIHdpbmRvdyFcbiAgICAvLyBhbHNvIGNsZWFucyB1cCBpbnZpc2libGUgaXRlbXMuXG4gICAgaWYgKG9sZFZpc2libGVJdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgb2xkVmlzaWJsZUl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrSWZWaXNpYmxlV2l0aFJlZmVyZW5jZShvbGRWaXNpYmxlSXRlbXNbaV0sIHZpc2libGVJdGVtcywgdmlzaWJsZUl0ZW1zTG9va3VwLCByYW5nZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gd2UgZG8gYSBiaW5hcnkgc2VhcmNoIGZvciB0aGUgaXRlbXMgdGhhdCBoYXZlIG9ubHkgc3RhcnQgdmFsdWVzLlxuICAgIHZhciBpbml0aWFsUG9zQnlTdGFydCA9IHV0aWwuYmluYXJ5U2VhcmNoQ3VzdG9tKG9yZGVyZWRJdGVtcy5ieVN0YXJ0LCBzZWFyY2hGdW5jdGlvbiwgJ2RhdGEnLCAnc3RhcnQnKTtcblxuICAgIC8vIHRyYWNlIHRoZSB2aXNpYmxlIGl0ZW1zIGZyb20gdGhlIGluaXRhbCBzdGFydCBwb3MgYm90aCB3YXlzIHVudGlsIGFuIGludmlzaWJsZSBpdGVtIGlzIGZvdW5kLCB3ZSBvbmx5IGxvb2sgYXQgdGhlIHN0YXJ0IHZhbHVlcy5cbiAgICB0aGlzLl90cmFjZVZpc2libGUoaW5pdGlhbFBvc0J5U3RhcnQsIG9yZGVyZWRJdGVtcy5ieVN0YXJ0LCB2aXNpYmxlSXRlbXMsIHZpc2libGVJdGVtc0xvb2t1cCwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtLmRhdGEuc3RhcnQgPCBsb3dlckJvdW5kIHx8IGl0ZW0uZGF0YS5zdGFydCA+IHVwcGVyQm91bmQ7XG4gICAgfSk7XG5cbiAgICAvLyBpZiB0aGUgd2luZG93IGhhcyBjaGFuZ2VkIHByb2dyYW1tYXRpY2FsbHkgd2l0aG91dCBvdmVybGFwcGluZyB0aGUgb2xkIHdpbmRvdywgdGhlIHJhbmdlZCBpdGVtcyB3aXRoIHN0YXJ0IDwgbG93ZXJCb3VuZCBhbmQgZW5kID4gdXBwZXJib3VuZCBhcmUgbm90IHNob3duLlxuICAgIC8vIFdlIHRoZXJlZm9yZSBoYXZlIHRvIGJydXRlIGZvcmNlIGNoZWNrIGFsbCBpdGVtcyBpbiB0aGUgYnlFbmQgbGlzdFxuICAgIGlmICh0aGlzLmNoZWNrUmFuZ2VkSXRlbXMgPT0gdHJ1ZSkge1xuICAgICAgdGhpcy5jaGVja1JhbmdlZEl0ZW1zID0gZmFsc2U7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgb3JkZXJlZEl0ZW1zLmJ5RW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrSWZWaXNpYmxlV2l0aFJlZmVyZW5jZShvcmRlcmVkSXRlbXMuYnlFbmRbaV0sIHZpc2libGVJdGVtcywgdmlzaWJsZUl0ZW1zTG9va3VwLCByYW5nZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHdlIGRvIGEgYmluYXJ5IHNlYXJjaCBmb3IgdGhlIGl0ZW1zIHRoYXQgaGF2ZSBkZWZpbmVkIGVuZCB0aW1lcy5cbiAgICAgIHZhciBpbml0aWFsUG9zQnlFbmQgPSB1dGlsLmJpbmFyeVNlYXJjaEN1c3RvbShvcmRlcmVkSXRlbXMuYnlFbmQsIHNlYXJjaEZ1bmN0aW9uLCAnZGF0YScsICdlbmQnKTtcblxuICAgICAgLy8gdHJhY2UgdGhlIHZpc2libGUgaXRlbXMgZnJvbSB0aGUgaW5pdGFsIHN0YXJ0IHBvcyBib3RoIHdheXMgdW50aWwgYW4gaW52aXNpYmxlIGl0ZW0gaXMgZm91bmQsIHdlIG9ubHkgbG9vayBhdCB0aGUgZW5kIHZhbHVlcy5cbiAgICAgIHRoaXMuX3RyYWNlVmlzaWJsZShpbml0aWFsUG9zQnlFbmQsIG9yZGVyZWRJdGVtcy5ieUVuZCwgdmlzaWJsZUl0ZW1zLCB2aXNpYmxlSXRlbXNMb29rdXAsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLmRhdGEuZW5kIDwgbG93ZXJCb3VuZCB8fCBpdGVtLmRhdGEuZW5kID4gdXBwZXJCb3VuZDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGZpbmFsbHksIHdlIHJlcG9zaXRpb24gYWxsIHRoZSB2aXNpYmxlIGl0ZW1zLlxuICAgIGZvciAoaSA9IDA7IGkgPCB2aXNpYmxlSXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGl0ZW0gPSB2aXNpYmxlSXRlbXNbaV07XG4gICAgICBpZiAoIWl0ZW0uZGlzcGxheWVkKSBpdGVtLnNob3coKTtcbiAgICAgIC8vIHJlcG9zaXRpb24gaXRlbSBob3Jpem9udGFsbHlcbiAgICAgIGl0ZW0ucmVwb3NpdGlvblgoKTtcbiAgICB9XG5cbiAgICAvLyBkZWJ1Z1xuICAgIC8vY29uc29sZS5sb2coXCJuZXcgbGluZVwiKVxuICAgIC8vaWYgKHRoaXMuZ3JvdXBJZCA9PSBudWxsKSB7XG4gICAgLy8gIGZvciAoaSA9IDA7IGkgPCBvcmRlcmVkSXRlbXMuYnlTdGFydC5sZW5ndGg7IGkrKykge1xuICAgIC8vICAgIGl0ZW0gPSBvcmRlcmVkSXRlbXMuYnlTdGFydFtpXS5kYXRhO1xuICAgIC8vICAgIGNvbnNvbGUubG9nKCdzdGFydCcsaSxpbml0aWFsUG9zQnlTdGFydCwgaXRlbS5zdGFydC52YWx1ZU9mKCksIGl0ZW0uY29udGVudCwgaXRlbS5zdGFydCA+PSBsb3dlckJvdW5kICYmIGl0ZW0uc3RhcnQgPD0gdXBwZXJCb3VuZCxpID09IGluaXRpYWxQb3NCeVN0YXJ0ID8gXCI8LS0tLS0tLS0tLS0tLS0tLS0tLSBIRVJFRUVFXCIgOiBcIlwiKVxuICAgIC8vICB9XG4gICAgLy8gIGZvciAoaSA9IDA7IGkgPCBvcmRlcmVkSXRlbXMuYnlFbmQubGVuZ3RoOyBpKyspIHtcbiAgICAvLyAgICBpdGVtID0gb3JkZXJlZEl0ZW1zLmJ5RW5kW2ldLmRhdGE7XG4gICAgLy8gICAgY29uc29sZS5sb2coJ3JhbmdlRW5kJyxpLGluaXRpYWxQb3NCeUVuZCwgaXRlbS5lbmQudmFsdWVPZigpLCBpdGVtLmNvbnRlbnQsIGl0ZW0uZW5kID49IHJhbmdlLnN0YXJ0ICYmIGl0ZW0uZW5kIDw9IHJhbmdlLmVuZCxpID09IGluaXRpYWxQb3NCeUVuZCA/IFwiPC0tLS0tLS0tLS0tLS0tLS0tLS0gSEVSRUVFRVwiIDogXCJcIilcbiAgICAvLyAgfVxuICAgIC8vfVxuXG4gICAgcmV0dXJuIHZpc2libGVJdGVtcztcbiAgfTtcblxuICBHcm91cC5wcm90b3R5cGUuX3RyYWNlVmlzaWJsZSA9IGZ1bmN0aW9uIChpbml0aWFsUG9zLCBpdGVtcywgdmlzaWJsZUl0ZW1zLCB2aXNpYmxlSXRlbXNMb29rdXAsIGJyZWFrQ29uZGl0aW9uKSB7XG4gICAgdmFyIGl0ZW07XG4gICAgdmFyIGk7XG5cbiAgICBpZiAoaW5pdGlhbFBvcyAhPSAtMSkge1xuICAgICAgZm9yIChpID0gaW5pdGlhbFBvczsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICBpZiAoYnJlYWtDb25kaXRpb24oaXRlbSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodmlzaWJsZUl0ZW1zTG9va3VwW2l0ZW0uaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZpc2libGVJdGVtc0xvb2t1cFtpdGVtLmlkXSA9IHRydWU7XG4gICAgICAgICAgICB2aXNpYmxlSXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gaW5pdGlhbFBvcyArIDE7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIGlmIChicmVha0NvbmRpdGlvbihpdGVtKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh2aXNpYmxlSXRlbXNMb29rdXBbaXRlbS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmlzaWJsZUl0ZW1zTG9va3VwW2l0ZW0uaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIHZpc2libGVJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogdGhpcyBmdW5jdGlvbiBpcyB2ZXJ5IHNpbWlsYXIgdG8gdGhlIF9jaGVja0lmSW52aXNpYmxlKCkgYnV0IGl0IGRvZXMgbm90XG4gICAqIHJldHVybiBib29sZWFucywgaGlkZXMgdGhlIGl0ZW0gaWYgaXQgc2hvdWxkIG5vdCBiZSBzZWVuIGFuZCBhbHdheXMgYWRkcyB0b1xuICAgKiB0aGUgdmlzaWJsZUl0ZW1zLlxuICAgKiB0aGlzIG9uZSBpcyBmb3IgYnJ1dGUgZm9yY2luZyBhbmQgaGlkaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICogQHBhcmFtIHtBcnJheX0gdmlzaWJsZUl0ZW1zXG4gICAqIEBwYXJhbSB7e3N0YXJ0Om51bWJlciwgZW5kOm51bWJlcn19IHJhbmdlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBHcm91cC5wcm90b3R5cGUuX2NoZWNrSWZWaXNpYmxlID0gZnVuY3Rpb24gKGl0ZW0sIHZpc2libGVJdGVtcywgcmFuZ2UpIHtcbiAgICBpZiAoaXRlbS5pc1Zpc2libGUocmFuZ2UpKSB7XG4gICAgICBpZiAoIWl0ZW0uZGlzcGxheWVkKSBpdGVtLnNob3coKTtcbiAgICAgIC8vIHJlcG9zaXRpb24gaXRlbSBob3Jpem9udGFsbHlcbiAgICAgIGl0ZW0ucmVwb3NpdGlvblgoKTtcbiAgICAgIHZpc2libGVJdGVtcy5wdXNoKGl0ZW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXRlbS5kaXNwbGF5ZWQpIGl0ZW0uaGlkZSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogdGhpcyBmdW5jdGlvbiBpcyB2ZXJ5IHNpbWlsYXIgdG8gdGhlIF9jaGVja0lmSW52aXNpYmxlKCkgYnV0IGl0IGRvZXMgbm90XG4gICAqIHJldHVybiBib29sZWFucywgaGlkZXMgdGhlIGl0ZW0gaWYgaXQgc2hvdWxkIG5vdCBiZSBzZWVuIGFuZCBhbHdheXMgYWRkcyB0b1xuICAgKiB0aGUgdmlzaWJsZUl0ZW1zLlxuICAgKiB0aGlzIG9uZSBpcyBmb3IgYnJ1dGUgZm9yY2luZyBhbmQgaGlkaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICogQHBhcmFtIHtBcnJheX0gdmlzaWJsZUl0ZW1zXG4gICAqIEBwYXJhbSB7e3N0YXJ0Om51bWJlciwgZW5kOm51bWJlcn19IHJhbmdlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBHcm91cC5wcm90b3R5cGUuX2NoZWNrSWZWaXNpYmxlV2l0aFJlZmVyZW5jZSA9IGZ1bmN0aW9uIChpdGVtLCB2aXNpYmxlSXRlbXMsIHZpc2libGVJdGVtc0xvb2t1cCwgcmFuZ2UpIHtcbiAgICBpZiAoaXRlbS5pc1Zpc2libGUocmFuZ2UpKSB7XG4gICAgICBpZiAodmlzaWJsZUl0ZW1zTG9va3VwW2l0ZW0uaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmlzaWJsZUl0ZW1zTG9va3VwW2l0ZW0uaWRdID0gdHJ1ZTtcbiAgICAgICAgdmlzaWJsZUl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpdGVtLmRpc3BsYXllZCkgaXRlbS5oaWRlKCk7XG4gICAgfVxuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gR3JvdXA7XG5cbi8qKiovIH0sXG4vKiAzNyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIFV0aWxpdHkgZnVuY3Rpb25zIGZvciBvcmRlcmluZyBhbmQgc3RhY2tpbmcgb2YgaXRlbXNcbiAgdmFyIEVQU0lMT04gPSAwLjAwMTsgLy8gdXNlZCB3aGVuIGNoZWNraW5nIGNvbGxpc2lvbnMsIHRvIHByZXZlbnQgcm91bmQtb2ZmIGVycm9yc1xuXG4gIC8qKlxuICAgKiBPcmRlciBpdGVtcyBieSB0aGVpciBzdGFydCBkYXRhXG4gICAqIEBwYXJhbSB7SXRlbVtdfSBpdGVtc1xuICAgKi9cbiAgZXhwb3J0cy5vcmRlckJ5U3RhcnQgPSBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgICBpdGVtcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYS5kYXRhLnN0YXJ0IC0gYi5kYXRhLnN0YXJ0O1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBPcmRlciBpdGVtcyBieSB0aGVpciBlbmQgZGF0ZS4gSWYgdGhleSBoYXZlIG5vIGVuZCBkYXRlLCB0aGVpciBzdGFydCBkYXRlXG4gICAqIGlzIHVzZWQuXG4gICAqIEBwYXJhbSB7SXRlbVtdfSBpdGVtc1xuICAgKi9cbiAgZXhwb3J0cy5vcmRlckJ5RW5kID0gZnVuY3Rpb24gKGl0ZW1zKSB7XG4gICAgaXRlbXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgdmFyIGFUaW1lID0gJ2VuZCcgaW4gYS5kYXRhID8gYS5kYXRhLmVuZCA6IGEuZGF0YS5zdGFydCxcbiAgICAgICAgICBiVGltZSA9ICdlbmQnIGluIGIuZGF0YSA/IGIuZGF0YS5lbmQgOiBiLmRhdGEuc3RhcnQ7XG5cbiAgICAgIHJldHVybiBhVGltZSAtIGJUaW1lO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGp1c3QgdmVydGljYWwgcG9zaXRpb25zIG9mIHRoZSBpdGVtcyBzdWNoIHRoYXQgdGhleSBkb24ndCBvdmVybGFwIGVhY2hcbiAgICogb3RoZXIuXG4gICAqIEBwYXJhbSB7SXRlbVtdfSBpdGVtc1xuICAgKiAgICAgICAgICAgIEFsbCB2aXNpYmxlIGl0ZW1zXG4gICAqIEBwYXJhbSB7e2l0ZW06IHtob3Jpem9udGFsOiBudW1iZXIsIHZlcnRpY2FsOiBudW1iZXJ9LCBheGlzOiBudW1iZXJ9fSBtYXJnaW5cbiAgICogICAgICAgICAgICBNYXJnaW5zIGJldHdlZW4gaXRlbXMgYW5kIGJldHdlZW4gaXRlbXMgYW5kIHRoZSBheGlzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmb3JjZT1mYWxzZV1cbiAgICogICAgICAgICAgICBJZiB0cnVlLCBhbGwgaXRlbXMgd2lsbCBiZSByZXBvc2l0aW9uZWQuIElmIGZhbHNlIChkZWZhdWx0KSwgb25seVxuICAgKiAgICAgICAgICAgIGl0ZW1zIGhhdmluZyBhIHRvcD09PW51bGwgd2lsbCBiZSByZS1zdGFja2VkXG4gICAqL1xuICBleHBvcnRzLnN0YWNrID0gZnVuY3Rpb24gKGl0ZW1zLCBtYXJnaW4sIGZvcmNlKSB7XG4gICAgdmFyIGksIGlNYXg7XG4gICAgaWYgKGZvcmNlKSB7XG4gICAgICAvLyByZXNldCB0b3AgcG9zaXRpb24gb2YgYWxsIGl0ZW1zXG4gICAgICBmb3IgKGkgPSAwLCBpTWF4ID0gaXRlbXMubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICAgIGl0ZW1zW2ldLnRvcCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2FsY3VsYXRlIG5ldywgbm9uLW92ZXJsYXBwaW5nIHBvc2l0aW9uc1xuICAgIGZvciAoaSA9IDAsIGlNYXggPSBpdGVtcy5sZW5ndGg7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gaXRlbXNbaV07XG4gICAgICBpZiAoaXRlbS5zdGFjayAmJiBpdGVtLnRvcCA9PT0gbnVsbCkge1xuICAgICAgICAvLyBpbml0aWFsaXplIHRvcCBwb3NpdGlvblxuICAgICAgICBpdGVtLnRvcCA9IG1hcmdpbi5heGlzO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAvLyBUT0RPOiBvcHRpbWl6ZSBjaGVja2luZyBmb3Igb3ZlcmxhcC4gd2hlbiB0aGVyZSBpcyBhIGdhcCB3aXRob3V0IGl0ZW1zLFxuICAgICAgICAgIC8vICAgICAgIHlvdSBvbmx5IG5lZWQgdG8gY2hlY2sgZm9yIGl0ZW1zIGZyb20gdGhlIG5leHQgaXRlbSBvbiwgbm90IGZyb20gemVyb1xuICAgICAgICAgIHZhciBjb2xsaWRpbmdJdGVtID0gbnVsbDtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgamogPSBpdGVtcy5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBpdGVtc1tqXTtcbiAgICAgICAgICAgIGlmIChvdGhlci50b3AgIT09IG51bGwgJiYgb3RoZXIgIT09IGl0ZW0gJiYgb3RoZXIuc3RhY2sgJiYgZXhwb3J0cy5jb2xsaXNpb24oaXRlbSwgb3RoZXIsIG1hcmdpbi5pdGVtLCBvdGhlci5vcHRpb25zLnJ0bCkpIHtcbiAgICAgICAgICAgICAgY29sbGlkaW5nSXRlbSA9IG90aGVyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY29sbGlkaW5nSXRlbSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBhIGNvbGxpc2lvbi4gUmVwb3NpdGlvbiB0aGUgaXRlbXMgYWJvdmUgdGhlIGNvbGxpZGluZyBlbGVtZW50XG4gICAgICAgICAgICBpdGVtLnRvcCA9IGNvbGxpZGluZ0l0ZW0udG9wICsgY29sbGlkaW5nSXRlbS5oZWlnaHQgKyBtYXJnaW4uaXRlbS52ZXJ0aWNhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGNvbGxpZGluZ0l0ZW0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQWRqdXN0IHZlcnRpY2FsIHBvc2l0aW9ucyBvZiB0aGUgaXRlbXMgd2l0aG91dCBzdGFja2luZyB0aGVtXG4gICAqIEBwYXJhbSB7SXRlbVtdfSBpdGVtc1xuICAgKiAgICAgICAgICAgIEFsbCB2aXNpYmxlIGl0ZW1zXG4gICAqIEBwYXJhbSB7e2l0ZW06IHtob3Jpem9udGFsOiBudW1iZXIsIHZlcnRpY2FsOiBudW1iZXJ9LCBheGlzOiBudW1iZXJ9fSBtYXJnaW5cbiAgICogICAgICAgICAgICBNYXJnaW5zIGJldHdlZW4gaXRlbXMgYW5kIGJldHdlZW4gaXRlbXMgYW5kIHRoZSBheGlzLlxuICAgKi9cbiAgZXhwb3J0cy5ub3N0YWNrID0gZnVuY3Rpb24gKGl0ZW1zLCBtYXJnaW4sIHN1Ymdyb3Vwcykge1xuICAgIHZhciBpLCBpTWF4LCBuZXdUb3A7XG5cbiAgICAvLyByZXNldCB0b3AgcG9zaXRpb24gb2YgYWxsIGl0ZW1zXG4gICAgZm9yIChpID0gMCwgaU1heCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgaWYgKGl0ZW1zW2ldLmRhdGEuc3ViZ3JvdXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdUb3AgPSBtYXJnaW4uYXhpcztcbiAgICAgICAgZm9yICh2YXIgc3ViZ3JvdXAgaW4gc3ViZ3JvdXBzKSB7XG4gICAgICAgICAgaWYgKHN1Ymdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShzdWJncm91cCkpIHtcbiAgICAgICAgICAgIGlmIChzdWJncm91cHNbc3ViZ3JvdXBdLnZpc2libGUgPT0gdHJ1ZSAmJiBzdWJncm91cHNbc3ViZ3JvdXBdLmluZGV4IDwgc3ViZ3JvdXBzW2l0ZW1zW2ldLmRhdGEuc3ViZ3JvdXBdLmluZGV4KSB7XG4gICAgICAgICAgICAgIG5ld1RvcCArPSBzdWJncm91cHNbc3ViZ3JvdXBdLmhlaWdodCArIG1hcmdpbi5pdGVtLnZlcnRpY2FsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpdGVtc1tpXS50b3AgPSBuZXdUb3A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVtc1tpXS50b3AgPSBtYXJnaW4uYXhpcztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFRlc3QgaWYgdGhlIHR3byBwcm92aWRlZCBpdGVtcyBjb2xsaWRlXG4gICAqIFRoZSBpdGVtcyBtdXN0IGhhdmUgcGFyYW1ldGVycyBsZWZ0LCB3aWR0aCwgdG9wLCBhbmQgaGVpZ2h0LlxuICAgKiBAcGFyYW0ge0l0ZW19IGEgICAgICAgICAgVGhlIGZpcnN0IGl0ZW1cbiAgICogQHBhcmFtIHtJdGVtfSBiICAgICAgICAgIFRoZSBzZWNvbmQgaXRlbVxuICAgKiBAcGFyYW0ge3tob3Jpem9udGFsOiBudW1iZXIsIHZlcnRpY2FsOiBudW1iZXJ9fSBtYXJnaW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIEFuIG9iamVjdCBjb250YWluaW5nIGEgaG9yaXpvbnRhbCBhbmQgdmVydGljYWxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW0gcmVxdWlyZWQgbWFyZ2luLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJ0bFxuICAgKiBAcmV0dXJuIHtib29sZWFufSAgICAgICAgdHJ1ZSBpZiBhIGFuZCBiIGNvbGxpZGUsIGVsc2UgZmFsc2VcbiAgICovXG4gIGV4cG9ydHMuY29sbGlzaW9uID0gZnVuY3Rpb24gKGEsIGIsIG1hcmdpbiwgcnRsKSB7XG4gICAgaWYgKHJ0bCkge1xuICAgICAgcmV0dXJuIGEucmlnaHQgLSBtYXJnaW4uaG9yaXpvbnRhbCArIEVQU0lMT04gPCBiLnJpZ2h0ICsgYi53aWR0aCAmJiBhLnJpZ2h0ICsgYS53aWR0aCArIG1hcmdpbi5ob3Jpem9udGFsIC0gRVBTSUxPTiA+IGIucmlnaHQgJiYgYS50b3AgLSBtYXJnaW4udmVydGljYWwgKyBFUFNJTE9OIDwgYi50b3AgKyBiLmhlaWdodCAmJiBhLnRvcCArIGEuaGVpZ2h0ICsgbWFyZ2luLnZlcnRpY2FsIC0gRVBTSUxPTiA+IGIudG9wO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYS5sZWZ0IC0gbWFyZ2luLmhvcml6b250YWwgKyBFUFNJTE9OIDwgYi5sZWZ0ICsgYi53aWR0aCAmJiBhLmxlZnQgKyBhLndpZHRoICsgbWFyZ2luLmhvcml6b250YWwgLSBFUFNJTE9OID4gYi5sZWZ0ICYmIGEudG9wIC0gbWFyZ2luLnZlcnRpY2FsICsgRVBTSUxPTiA8IGIudG9wICsgYi5oZWlnaHQgJiYgYS50b3AgKyBhLmhlaWdodCArIG1hcmdpbi52ZXJ0aWNhbCAtIEVQU0lMT04gPiBiLnRvcDtcbiAgICB9XG4gIH07XG5cbi8qKiovIH0sXG4vKiAzOCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBIYW1tZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcbiAgdmFyIEl0ZW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KTtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yIFJhbmdlSXRlbVxuICAgKiBAZXh0ZW5kcyBJdGVtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICAgICAgICAgIE9iamVjdCBjb250YWluaW5nIHBhcmFtZXRlcnMgc3RhcnQsIGVuZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50LCBjbGFzc05hbWUuXG4gICAqIEBwYXJhbSB7e3RvU2NyZWVuOiBmdW5jdGlvbiwgdG9UaW1lOiBmdW5jdGlvbn19IGNvbnZlcnNpb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29udmVyc2lvbiBmdW5jdGlvbnMgZnJvbSB0aW1lIHRvIHNjcmVlbiBhbmQgdmljZSB2ZXJzYVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgICAgICBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogZGVzY3JpYmUgb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gUmFuZ2VJdGVtKGRhdGEsIGNvbnZlcnNpb24sIG9wdGlvbnMpIHtcbiAgICB0aGlzLnByb3BzID0ge1xuICAgICAgY29udGVudDoge1xuICAgICAgICB3aWR0aDogMFxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5vdmVyZmxvdyA9IGZhbHNlOyAvLyBpZiBjb250ZW50cyBjYW4gb3ZlcmZsb3cgKGNzcyBzdHlsaW5nKSwgdGhpcyBmbGFnIGlzIHNldCB0byB0cnVlXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAvLyB2YWxpZGF0ZSBkYXRhXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIGlmIChkYXRhLnN0YXJ0ID09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3BlcnR5IFwic3RhcnRcIiBtaXNzaW5nIGluIGl0ZW0gJyArIGRhdGEuaWQpO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEuZW5kID09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3BlcnR5IFwiZW5kXCIgbWlzc2luZyBpbiBpdGVtICcgKyBkYXRhLmlkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBJdGVtLmNhbGwodGhpcywgZGF0YSwgY29udmVyc2lvbiwgb3B0aW9ucyk7XG4gIH1cblxuICBSYW5nZUl0ZW0ucHJvdG90eXBlID0gbmV3IEl0ZW0obnVsbCwgbnVsbCwgbnVsbCk7XG5cbiAgUmFuZ2VJdGVtLnByb3RvdHlwZS5iYXNlQ2xhc3NOYW1lID0gJ3Zpcy1pdGVtIHZpcy1yYW5nZSc7XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdGhpcyBpdGVtIGlzIHZpc2libGUgaW5zaWRlIGdpdmVuIHJhbmdlXG4gICAqIEByZXR1cm5zIHt7c3RhcnQ6IE51bWJlciwgZW5kOiBOdW1iZXJ9fSByYW5nZSB3aXRoIGEgdGltZXN0YW1wIGZvciBzdGFydCBhbmQgZW5kXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZpc2libGVcbiAgICovXG4gIFJhbmdlSXRlbS5wcm90b3R5cGUuaXNWaXNpYmxlID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgLy8gZGV0ZXJtaW5lIHZpc2liaWxpdHlcbiAgICByZXR1cm4gdGhpcy5kYXRhLnN0YXJ0IDwgcmFuZ2UuZW5kICYmIHRoaXMuZGF0YS5lbmQgPiByYW5nZS5zdGFydDtcbiAgfTtcblxuICAvKipcbiAgICogUmVwYWludCB0aGUgaXRlbVxuICAgKi9cbiAgUmFuZ2VJdGVtLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRvbSA9IHRoaXMuZG9tO1xuICAgIGlmICghZG9tKSB7XG4gICAgICAvLyBjcmVhdGUgRE9NXG4gICAgICB0aGlzLmRvbSA9IHt9O1xuICAgICAgZG9tID0gdGhpcy5kb207XG5cbiAgICAgIC8vIGJhY2tncm91bmQgYm94XG4gICAgICBkb20uYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAvLyBjbGFzc05hbWUgaXMgdXBkYXRlZCBpbiByZWRyYXcoKVxuXG4gICAgICAvLyBmcmFtZSBib3ggKHRvIHByZXZlbnQgdGhlIGl0ZW0gY29udGVudHMgZnJvbSBvdmVyZmxvd2luZ1xuICAgICAgZG9tLmZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkb20uZnJhbWUuY2xhc3NOYW1lID0gJ3Zpcy1pdGVtLW92ZXJmbG93JztcbiAgICAgIGRvbS5ib3guYXBwZW5kQ2hpbGQoZG9tLmZyYW1lKTtcblxuICAgICAgLy8gY29udGVudHMgYm94XG4gICAgICBkb20uY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZG9tLmNvbnRlbnQuY2xhc3NOYW1lID0gJ3Zpcy1pdGVtLWNvbnRlbnQnO1xuICAgICAgZG9tLmZyYW1lLmFwcGVuZENoaWxkKGRvbS5jb250ZW50KTtcblxuICAgICAgLy8gYXR0YWNoIHRoaXMgaXRlbSBhcyBhdHRyaWJ1dGVcbiAgICAgIGRvbS5ib3hbJ3RpbWVsaW5lLWl0ZW0nXSA9IHRoaXM7XG5cbiAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIGFwcGVuZCBET00gdG8gcGFyZW50IERPTVxuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlZHJhdyBpdGVtOiBubyBwYXJlbnQgYXR0YWNoZWQnKTtcbiAgICB9XG4gICAgaWYgKCFkb20uYm94LnBhcmVudE5vZGUpIHtcbiAgICAgIHZhciBmb3JlZ3JvdW5kID0gdGhpcy5wYXJlbnQuZG9tLmZvcmVncm91bmQ7XG4gICAgICBpZiAoIWZvcmVncm91bmQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVkcmF3IGl0ZW06IHBhcmVudCBoYXMgbm8gZm9yZWdyb3VuZCBjb250YWluZXIgZWxlbWVudCcpO1xuICAgICAgfVxuICAgICAgZm9yZWdyb3VuZC5hcHBlbmRDaGlsZChkb20uYm94KTtcbiAgICB9XG4gICAgdGhpcy5kaXNwbGF5ZWQgPSB0cnVlO1xuXG4gICAgLy8gVXBkYXRlIERPTSB3aGVuIGl0ZW0gaXMgbWFya2VkIGRpcnR5LiBBbiBpdGVtIGlzIG1hcmtlZCBkaXJ0eSB3aGVuOlxuICAgIC8vIC0gdGhlIGl0ZW0gaXMgbm90IHlldCByZW5kZXJlZFxuICAgIC8vIC0gdGhlIGl0ZW0ncyBkYXRhIGlzIGNoYW5nZWRcbiAgICAvLyAtIHRoZSBpdGVtIGlzIHNlbGVjdGVkL2Rlc2VsZWN0ZWRcbiAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgdGhpcy5fdXBkYXRlQ29udGVudHModGhpcy5kb20uY29udGVudCk7XG4gICAgICB0aGlzLl91cGRhdGVUaXRsZSh0aGlzLmRvbS5ib3gpO1xuICAgICAgdGhpcy5fdXBkYXRlRGF0YUF0dHJpYnV0ZXModGhpcy5kb20uYm94KTtcbiAgICAgIHRoaXMuX3VwZGF0ZVN0eWxlKHRoaXMuZG9tLmJveCk7XG5cbiAgICAgIHZhciBlZGl0YWJsZSA9ICh0aGlzLm9wdGlvbnMuZWRpdGFibGUudXBkYXRlVGltZSB8fCB0aGlzLm9wdGlvbnMuZWRpdGFibGUudXBkYXRlR3JvdXAgfHwgdGhpcy5lZGl0YWJsZSA9PT0gdHJ1ZSkgJiYgdGhpcy5lZGl0YWJsZSAhPT0gZmFsc2U7XG5cbiAgICAgIC8vIHVwZGF0ZSBjbGFzc1xuICAgICAgdmFyIGNsYXNzTmFtZSA9ICh0aGlzLmRhdGEuY2xhc3NOYW1lID8gJyAnICsgdGhpcy5kYXRhLmNsYXNzTmFtZSA6ICcnKSArICh0aGlzLnNlbGVjdGVkID8gJyB2aXMtc2VsZWN0ZWQnIDogJycpICsgKGVkaXRhYmxlID8gJyB2aXMtZWRpdGFibGUnIDogJyB2aXMtcmVhZG9ubHknKTtcbiAgICAgIGRvbS5ib3guY2xhc3NOYW1lID0gdGhpcy5iYXNlQ2xhc3NOYW1lICsgY2xhc3NOYW1lO1xuXG4gICAgICAvLyBkZXRlcm1pbmUgZnJvbSBjc3Mgd2hldGhlciB0aGlzIGJveCBoYXMgb3ZlcmZsb3dcbiAgICAgIHRoaXMub3ZlcmZsb3cgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb20uZnJhbWUpLm92ZXJmbG93ICE9PSAnaGlkZGVuJztcblxuICAgICAgLy8gcmVjYWxjdWxhdGUgc2l6ZVxuICAgICAgLy8gdHVybiBvZmYgbWF4LXdpZHRoIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHRoZSByZWFsIHdpZHRoXG4gICAgICAvLyB0aGlzIGNhdXNlcyBhbiBleHRyYSBicm93c2VyIHJlcGFpbnQvcmVmbG93LCBidXQgc28gYmUgaXRcbiAgICAgIHRoaXMuZG9tLmNvbnRlbnQuc3R5bGUubWF4V2lkdGggPSAnbm9uZSc7XG4gICAgICB0aGlzLnByb3BzLmNvbnRlbnQud2lkdGggPSB0aGlzLmRvbS5jb250ZW50Lm9mZnNldFdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmRvbS5ib3gub2Zmc2V0SGVpZ2h0O1xuICAgICAgdGhpcy5kb20uY29udGVudC5zdHlsZS5tYXhXaWR0aCA9ICcnO1xuXG4gICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuX3JlcGFpbnREZWxldGVCdXR0b24oZG9tLmJveCk7XG4gICAgdGhpcy5fcmVwYWludERyYWdMZWZ0KCk7XG4gICAgdGhpcy5fcmVwYWludERyYWdSaWdodCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTaG93IHRoZSBpdGVtIGluIHRoZSBET00gKHdoZW4gbm90IGFscmVhZHkgdmlzaWJsZSkuIFRoZSBpdGVtcyBET00gd2lsbFxuICAgKiBiZSBjcmVhdGVkIHdoZW4gbmVlZGVkLlxuICAgKi9cbiAgUmFuZ2VJdGVtLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5kaXNwbGF5ZWQpIHtcbiAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBIaWRlIHRoZSBpdGVtIGZyb20gdGhlIERPTSAod2hlbiB2aXNpYmxlKVxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBjaGFuZ2VkXG4gICAqL1xuICBSYW5nZUl0ZW0ucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZGlzcGxheWVkKSB7XG4gICAgICB2YXIgYm94ID0gdGhpcy5kb20uYm94O1xuXG4gICAgICBpZiAoYm94LnBhcmVudE5vZGUpIHtcbiAgICAgICAgYm94LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYm94KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kaXNwbGF5ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcG9zaXRpb24gdGhlIGl0ZW0gaG9yaXpvbnRhbGx5XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2xpbWl0U2l6ZT10cnVlXSBJZiB0cnVlIChkZWZhdWx0KSwgdGhlIHdpZHRoIG9mIHRoZSByYW5nZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSB3aWxsIGJlIGxpbWl0ZWQsIGFzIHRoZSBicm93c2VyIGNhbm5vdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheSB2ZXJ5IHdpZGUgZGl2cy4gVGhpcyBtZWFucyB0aG91Z2hcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQgdGhlIGFwcGxpZWQgbGVmdCBhbmQgd2lkdGggbWF5XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3QgY29ycmVzcG9uZCB0byB0aGUgcmFuZ2VzIHN0YXJ0IGFuZCBlbmRcbiAgICogQE92ZXJyaWRlXG4gICAqL1xuICBSYW5nZUl0ZW0ucHJvdG90eXBlLnJlcG9zaXRpb25YID0gZnVuY3Rpb24gKGxpbWl0U2l6ZSkge1xuICAgIHZhciBwYXJlbnRXaWR0aCA9IHRoaXMucGFyZW50LndpZHRoO1xuICAgIHZhciBzdGFydCA9IHRoaXMuY29udmVyc2lvbi50b1NjcmVlbih0aGlzLmRhdGEuc3RhcnQpO1xuICAgIHZhciBlbmQgPSB0aGlzLmNvbnZlcnNpb24udG9TY3JlZW4odGhpcy5kYXRhLmVuZCk7XG4gICAgdmFyIGNvbnRlbnRTdGFydFBvc2l0aW9uO1xuICAgIHZhciBjb250ZW50V2lkdGg7XG5cbiAgICAvLyBsaW1pdCB0aGUgd2lkdGggb2YgdGhlIHJhbmdlLCBhcyBicm93c2VycyBjYW5ub3QgZHJhdyB2ZXJ5IHdpZGUgZGl2c1xuICAgIGlmIChsaW1pdFNpemUgPT09IHVuZGVmaW5lZCB8fCBsaW1pdFNpemUgPT09IHRydWUpIHtcbiAgICAgIGlmIChzdGFydCA8IC1wYXJlbnRXaWR0aCkge1xuICAgICAgICBzdGFydCA9IC1wYXJlbnRXaWR0aDtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQgPiAyICogcGFyZW50V2lkdGgpIHtcbiAgICAgICAgZW5kID0gMiAqIHBhcmVudFdpZHRoO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgYm94V2lkdGggPSBNYXRoLm1heChlbmQgLSBzdGFydCwgMSk7XG5cbiAgICBpZiAodGhpcy5vdmVyZmxvdykge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgICAgdGhpcy5yaWdodCA9IHN0YXJ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sZWZ0ID0gc3RhcnQ7XG4gICAgICB9XG4gICAgICB0aGlzLndpZHRoID0gYm94V2lkdGggKyB0aGlzLnByb3BzLmNvbnRlbnQud2lkdGg7XG4gICAgICBjb250ZW50V2lkdGggPSB0aGlzLnByb3BzLmNvbnRlbnQud2lkdGg7XG5cbiAgICAgIC8vIE5vdGU6IFRoZSBjYWxjdWxhdGlvbiBvZiB3aWR0aCBpcyBhbiBvcHRpbWlzdGljIGNhbGN1bGF0aW9uLCBnaXZpbmdcbiAgICAgIC8vICAgICAgIGEgd2lkdGggd2hpY2ggd2lsbCBub3QgY2hhbmdlIHdoZW4gbW92aW5nIHRoZSBUaW1lbGluZVxuICAgICAgLy8gICAgICAgU28gbm8gcmUtc3RhY2tpbmcgbmVlZGVkLCB3aGljaCBpcyBuaWNlciBmb3IgdGhlIGV5ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgICAgIHRoaXMucmlnaHQgPSBzdGFydDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxlZnQgPSBzdGFydDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndpZHRoID0gYm94V2lkdGg7XG4gICAgICAgIGNvbnRlbnRXaWR0aCA9IE1hdGgubWluKGVuZCAtIHN0YXJ0LCB0aGlzLnByb3BzLmNvbnRlbnQud2lkdGgpO1xuICAgICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgIHRoaXMuZG9tLmJveC5zdHlsZS5yaWdodCA9IHRoaXMucmlnaHQgKyAncHgnO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRvbS5ib3guc3R5bGUubGVmdCA9IHRoaXMubGVmdCArICdweCc7XG4gICAgfVxuICAgIHRoaXMuZG9tLmJveC5zdHlsZS53aWR0aCA9IGJveFdpZHRoICsgJ3B4JztcblxuICAgIHN3aXRjaCAodGhpcy5vcHRpb25zLmFsaWduKSB7XG4gICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgICAgICB0aGlzLmRvbS5jb250ZW50LnN0eWxlLnJpZ2h0ID0gJzAnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZG9tLmNvbnRlbnQuc3R5bGUubGVmdCA9ICcwJztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgICAgIHRoaXMuZG9tLmNvbnRlbnQuc3R5bGUucmlnaHQgPSBNYXRoLm1heChib3hXaWR0aCAtIGNvbnRlbnRXaWR0aCwgMCkgKyAncHgnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZG9tLmNvbnRlbnQuc3R5bGUubGVmdCA9IE1hdGgubWF4KGJveFdpZHRoIC0gY29udGVudFdpZHRoLCAwKSArICdweCc7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucnRsKSB7XG4gICAgICAgICAgdGhpcy5kb20uY29udGVudC5zdHlsZS5yaWdodCA9IE1hdGgubWF4KChib3hXaWR0aCAtIGNvbnRlbnRXaWR0aCkgLyAyLCAwKSArICdweCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kb20uY29udGVudC5zdHlsZS5sZWZ0ID0gTWF0aC5tYXgoKGJveFdpZHRoIC0gY29udGVudFdpZHRoKSAvIDIsIDApICsgJ3B4JztcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyAnYXV0bydcbiAgICAgICAgLy8gd2hlbiByYW5nZSBleGNlZWRzIGxlZnQgb2YgdGhlIHdpbmRvdywgcG9zaXRpb24gdGhlIGNvbnRlbnRzIGF0IHRoZSBsZWZ0IG9mIHRoZSB2aXNpYmxlIGFyZWFcbiAgICAgICAgaWYgKHRoaXMub3ZlcmZsb3cpIHtcbiAgICAgICAgICBpZiAoZW5kID4gMCkge1xuICAgICAgICAgICAgY29udGVudFN0YXJ0UG9zaXRpb24gPSBNYXRoLm1heCgtc3RhcnQsIDApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZW50U3RhcnRQb3NpdGlvbiA9IC1jb250ZW50V2lkdGg7IC8vIGVuc3VyZSBpdCdzIG5vdCB2aXNpYmxlIGFueW1vcmVcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnRTdGFydFBvc2l0aW9uID0gLXN0YXJ0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29udGVudFN0YXJ0UG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgICAgICB0aGlzLmRvbS5jb250ZW50LnN0eWxlLnJpZ2h0ID0gY29udGVudFN0YXJ0UG9zaXRpb24gKyAncHgnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZG9tLmNvbnRlbnQuc3R5bGUubGVmdCA9IGNvbnRlbnRTdGFydFBvc2l0aW9uICsgJ3B4JztcbiAgICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVwb3NpdGlvbiB0aGUgaXRlbSB2ZXJ0aWNhbGx5XG4gICAqIEBPdmVycmlkZVxuICAgKi9cbiAgUmFuZ2VJdGVtLnByb3RvdHlwZS5yZXBvc2l0aW9uWSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3JpZW50YXRpb24gPSB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uaXRlbTtcbiAgICB2YXIgYm94ID0gdGhpcy5kb20uYm94O1xuXG4gICAgaWYgKG9yaWVudGF0aW9uID09ICd0b3AnKSB7XG4gICAgICBib3guc3R5bGUudG9wID0gdGhpcy50b3AgKyAncHgnO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3guc3R5bGUudG9wID0gdGhpcy5wYXJlbnQuaGVpZ2h0IC0gdGhpcy50b3AgLSB0aGlzLmhlaWdodCArICdweCc7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXBhaW50IGEgZHJhZyBhcmVhIG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIHJhbmdlIHdoZW4gdGhlIHJhbmdlIGlzIHNlbGVjdGVkXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIFJhbmdlSXRlbS5wcm90b3R5cGUuX3JlcGFpbnREcmFnTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5zZWxlY3RlZCAmJiB0aGlzLm9wdGlvbnMuZWRpdGFibGUudXBkYXRlVGltZSAmJiAhdGhpcy5kb20uZHJhZ0xlZnQpIHtcbiAgICAgIC8vIGNyZWF0ZSBhbmQgc2hvdyBkcmFnIGFyZWFcbiAgICAgIHZhciBkcmFnTGVmdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZHJhZ0xlZnQuY2xhc3NOYW1lID0gJ3Zpcy1kcmFnLWxlZnQnO1xuICAgICAgZHJhZ0xlZnQuZHJhZ0xlZnRJdGVtID0gdGhpcztcblxuICAgICAgdGhpcy5kb20uYm94LmFwcGVuZENoaWxkKGRyYWdMZWZ0KTtcbiAgICAgIHRoaXMuZG9tLmRyYWdMZWZ0ID0gZHJhZ0xlZnQ7XG4gICAgfSBlbHNlIGlmICghdGhpcy5zZWxlY3RlZCAmJiB0aGlzLmRvbS5kcmFnTGVmdCkge1xuICAgICAgLy8gZGVsZXRlIGRyYWcgYXJlYVxuICAgICAgaWYgKHRoaXMuZG9tLmRyYWdMZWZ0LnBhcmVudE5vZGUpIHtcbiAgICAgICAgdGhpcy5kb20uZHJhZ0xlZnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbS5kcmFnTGVmdCk7XG4gICAgICB9XG4gICAgICB0aGlzLmRvbS5kcmFnTGVmdCA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXBhaW50IGEgZHJhZyBhcmVhIG9uIHRoZSByaWdodCBzaWRlIG9mIHRoZSByYW5nZSB3aGVuIHRoZSByYW5nZSBpcyBzZWxlY3RlZFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBSYW5nZUl0ZW0ucHJvdG90eXBlLl9yZXBhaW50RHJhZ1JpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnNlbGVjdGVkICYmIHRoaXMub3B0aW9ucy5lZGl0YWJsZS51cGRhdGVUaW1lICYmICF0aGlzLmRvbS5kcmFnUmlnaHQpIHtcbiAgICAgIC8vIGNyZWF0ZSBhbmQgc2hvdyBkcmFnIGFyZWFcbiAgICAgIHZhciBkcmFnUmlnaHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRyYWdSaWdodC5jbGFzc05hbWUgPSAndmlzLWRyYWctcmlnaHQnO1xuICAgICAgZHJhZ1JpZ2h0LmRyYWdSaWdodEl0ZW0gPSB0aGlzO1xuXG4gICAgICB0aGlzLmRvbS5ib3guYXBwZW5kQ2hpbGQoZHJhZ1JpZ2h0KTtcbiAgICAgIHRoaXMuZG9tLmRyYWdSaWdodCA9IGRyYWdSaWdodDtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnNlbGVjdGVkICYmIHRoaXMuZG9tLmRyYWdSaWdodCkge1xuICAgICAgLy8gZGVsZXRlIGRyYWcgYXJlYVxuICAgICAgaWYgKHRoaXMuZG9tLmRyYWdSaWdodC5wYXJlbnROb2RlKSB7XG4gICAgICAgIHRoaXMuZG9tLmRyYWdSaWdodC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLmRyYWdSaWdodCk7XG4gICAgICB9XG4gICAgICB0aGlzLmRvbS5kcmFnUmlnaHQgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFJhbmdlSXRlbTtcblxuLyoqKi8gfSxcbi8qIDM5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIEhhbW1lciA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvciBJdGVtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICAgICAgICAgIE9iamVjdCBjb250YWluaW5nIChvcHRpb25hbCkgcGFyYW1ldGVycyB0eXBlLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCwgZW5kLCBjb250ZW50LCBncm91cCwgY2xhc3NOYW1lLlxuICAgKiBAcGFyYW0ge3t0b1NjcmVlbjogZnVuY3Rpb24sIHRvVGltZTogZnVuY3Rpb259fSBjb252ZXJzaW9uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbnZlcnNpb24gZnVuY3Rpb25zIGZyb20gdGltZSB0byBzY3JlZW4gYW5kIHZpY2UgdmVyc2FcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgICAgICAgICAgQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGRlc2NyaWJlIGF2YWlsYWJsZSBvcHRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBJdGVtKGRhdGEsIGNvbnZlcnNpb24sIG9wdGlvbnMpIHtcbiAgICB0aGlzLmlkID0gbnVsbDtcbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLmRvbSA9IG51bGw7XG4gICAgdGhpcy5jb252ZXJzaW9uID0gY29udmVyc2lvbiB8fCB7fTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuZGlzcGxheWVkID0gZmFsc2U7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG5cbiAgICB0aGlzLnRvcCA9IG51bGw7XG4gICAgdGhpcy5yaWdodCA9IG51bGw7XG4gICAgdGhpcy5sZWZ0ID0gbnVsbDtcbiAgICB0aGlzLndpZHRoID0gbnVsbDtcbiAgICB0aGlzLmhlaWdodCA9IG51bGw7XG5cbiAgICB0aGlzLmVkaXRhYmxlID0gbnVsbDtcbiAgICBpZiAodGhpcy5kYXRhICYmIHRoaXMuZGF0YS5oYXNPd25Qcm9wZXJ0eSgnZWRpdGFibGUnKSAmJiB0eXBlb2YgdGhpcy5kYXRhLmVkaXRhYmxlID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHRoaXMuZWRpdGFibGUgPSBkYXRhLmVkaXRhYmxlO1xuICAgIH1cbiAgfVxuXG4gIEl0ZW0ucHJvdG90eXBlLnN0YWNrID0gdHJ1ZTtcblxuICAvKipcbiAgICogU2VsZWN0IGN1cnJlbnQgaXRlbVxuICAgKi9cbiAgSXRlbS5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2VsZWN0ZWQgPSB0cnVlO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIGlmICh0aGlzLmRpc3BsYXllZCkgdGhpcy5yZWRyYXcoKTtcbiAgfTtcblxuICAvKipcbiAgICogVW5zZWxlY3QgY3VycmVudCBpdGVtXG4gICAqL1xuICBJdGVtLnByb3RvdHlwZS51bnNlbGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgaWYgKHRoaXMuZGlzcGxheWVkKSB0aGlzLnJlZHJhdygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgZGF0YSBmb3IgdGhlIGl0ZW0uIEV4aXN0aW5nIGRhdGEgd2lsbCBiZSB1cGRhdGVkLiBUaGUgaWQgc2hvdWxkIG5vdFxuICAgKiBiZSBjaGFuZ2VkLiBXaGVuIHRoZSBpdGVtIGlzIGRpc3BsYXllZCwgaXQgd2lsbCBiZSByZWRyYXduIGltbWVkaWF0ZWx5LlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKi9cbiAgSXRlbS5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIGdyb3VwQ2hhbmdlZCA9IGRhdGEuZ3JvdXAgIT0gdW5kZWZpbmVkICYmIHRoaXMuZGF0YS5ncm91cCAhPSBkYXRhLmdyb3VwO1xuICAgIGlmIChncm91cENoYW5nZWQpIHtcbiAgICAgIHRoaXMucGFyZW50Lml0ZW1TZXQuX21vdmVUb0dyb3VwKHRoaXMsIGRhdGEuZ3JvdXApO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KCdlZGl0YWJsZScpICYmIHR5cGVvZiBkYXRhLmVkaXRhYmxlID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHRoaXMuZWRpdGFibGUgPSBkYXRhLmVkaXRhYmxlO1xuICAgIH1cblxuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgaWYgKHRoaXMuZGlzcGxheWVkKSB0aGlzLnJlZHJhdygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgYSBwYXJlbnQgZm9yIHRoZSBpdGVtXG4gICAqIEBwYXJhbSB7SXRlbVNldCB8IEdyb3VwfSBwYXJlbnRcbiAgICovXG4gIEl0ZW0ucHJvdG90eXBlLnNldFBhcmVudCA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICBpZiAodGhpcy5kaXNwbGF5ZWQpIHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciB0aGlzIGl0ZW0gaXMgdmlzaWJsZSBpbnNpZGUgZ2l2ZW4gcmFuZ2VcbiAgICogQHJldHVybnMge3tzdGFydDogTnVtYmVyLCBlbmQ6IE51bWJlcn19IHJhbmdlIHdpdGggYSB0aW1lc3RhbXAgZm9yIHN0YXJ0IGFuZCBlbmRcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmlzaWJsZVxuICAgKi9cbiAgSXRlbS5wcm90b3R5cGUuaXNWaXNpYmxlID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgLy8gU2hvdWxkIGJlIGltcGxlbWVudGVkIGJ5IEl0ZW0gaW1wbGVtZW50YXRpb25zXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTaG93IHRoZSBJdGVtIGluIHRoZSBET00gKHdoZW4gbm90IGFscmVhZHkgdmlzaWJsZSlcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gY2hhbmdlZFxuICAgKi9cbiAgSXRlbS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhpZGUgdGhlIEl0ZW0gZnJvbSB0aGUgRE9NICh3aGVuIHZpc2libGUpXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGNoYW5nZWRcbiAgICovXG4gIEl0ZW0ucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXBhaW50IHRoZSBpdGVtXG4gICAqL1xuICBJdGVtLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gc2hvdWxkIGJlIGltcGxlbWVudGVkIGJ5IHRoZSBpdGVtXG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcG9zaXRpb24gdGhlIEl0ZW0gaG9yaXpvbnRhbGx5XG4gICAqL1xuICBJdGVtLnByb3RvdHlwZS5yZXBvc2l0aW9uWCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgYnkgdGhlIGl0ZW1cbiAgfTtcblxuICAvKipcbiAgICogUmVwb3NpdGlvbiB0aGUgSXRlbSB2ZXJ0aWNhbGx5XG4gICAqL1xuICBJdGVtLnByb3RvdHlwZS5yZXBvc2l0aW9uWSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgYnkgdGhlIGl0ZW1cbiAgfTtcblxuICAvKipcbiAgICogUmVwYWludCBhIGRlbGV0ZSBidXR0b24gb24gdGhlIHRvcCByaWdodCBvZiB0aGUgaXRlbSB3aGVuIHRoZSBpdGVtIGlzIHNlbGVjdGVkXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGFuY2hvclxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBJdGVtLnByb3RvdHlwZS5fcmVwYWludERlbGV0ZUJ1dHRvbiA9IGZ1bmN0aW9uIChhbmNob3IpIHtcbiAgICB2YXIgZWRpdGFibGUgPSAodGhpcy5vcHRpb25zLmVkaXRhYmxlLnJlbW92ZSB8fCB0aGlzLmRhdGEuZWRpdGFibGUgPT09IHRydWUpICYmIHRoaXMuZGF0YS5lZGl0YWJsZSAhPT0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5zZWxlY3RlZCAmJiBlZGl0YWJsZSAmJiAhdGhpcy5kb20uZGVsZXRlQnV0dG9uKSB7XG4gICAgICAvLyBjcmVhdGUgYW5kIHNob3cgYnV0dG9uXG4gICAgICB2YXIgbWUgPSB0aGlzO1xuXG4gICAgICB2YXIgZGVsZXRlQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucnRsKSB7XG4gICAgICAgIGRlbGV0ZUJ1dHRvbi5jbGFzc05hbWUgPSAndmlzLWRlbGV0ZS1ydGwnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlQnV0dG9uLmNsYXNzTmFtZSA9ICd2aXMtZGVsZXRlJztcbiAgICAgIH1cbiAgICAgIGRlbGV0ZUJ1dHRvbi50aXRsZSA9ICdEZWxldGUgdGhpcyBpdGVtJztcblxuICAgICAgLy8gVE9ETzogYmUgYWJsZSB0byBkZXN0cm95IHRoZSBkZWxldGUgYnV0dG9uXG4gICAgICBuZXcgSGFtbWVyKGRlbGV0ZUJ1dHRvbikub24oJ3RhcCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgbWUucGFyZW50LnJlbW92ZUZyb21EYXRhU2V0KG1lKTtcbiAgICAgIH0pO1xuXG4gICAgICBhbmNob3IuYXBwZW5kQ2hpbGQoZGVsZXRlQnV0dG9uKTtcbiAgICAgIHRoaXMuZG9tLmRlbGV0ZUJ1dHRvbiA9IGRlbGV0ZUJ1dHRvbjtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnNlbGVjdGVkICYmIHRoaXMuZG9tLmRlbGV0ZUJ1dHRvbikge1xuICAgICAgLy8gcmVtb3ZlIGJ1dHRvblxuICAgICAgaWYgKHRoaXMuZG9tLmRlbGV0ZUJ1dHRvbi5wYXJlbnROb2RlKSB7XG4gICAgICAgIHRoaXMuZG9tLmRlbGV0ZUJ1dHRvbi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLmRlbGV0ZUJ1dHRvbik7XG4gICAgICB9XG4gICAgICB0aGlzLmRvbS5kZWxldGVCdXR0b24gPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0IEhUTUwgY29udGVudHMgZm9yIHRoZSBpdGVtXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAgIEhUTUwgZWxlbWVudCB0byBmaWxsIHdpdGggdGhlIGNvbnRlbnRzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBJdGVtLnByb3RvdHlwZS5fdXBkYXRlQ29udGVudHMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHZhciBjb250ZW50O1xuICAgIGlmICh0aGlzLm9wdGlvbnMudGVtcGxhdGUpIHtcbiAgICAgIHZhciBpdGVtRGF0YSA9IHRoaXMucGFyZW50Lml0ZW1TZXQuaXRlbXNEYXRhLmdldCh0aGlzLmlkKTsgLy8gZ2V0IGEgY2xvbmUgb2YgdGhlIGRhdGEgZnJvbSB0aGUgZGF0YXNldFxuICAgICAgY29udGVudCA9IHRoaXMub3B0aW9ucy50ZW1wbGF0ZShpdGVtRGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRlbnQgPSB0aGlzLmRhdGEuY29udGVudDtcbiAgICB9XG5cbiAgICB2YXIgY2hhbmdlZCA9IHRoaXMuX2NvbnRlbnRUb1N0cmluZyh0aGlzLmNvbnRlbnQpICE9PSB0aGlzLl9jb250ZW50VG9TdHJpbmcoY29udGVudCk7XG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIC8vIG9ubHkgcmVwbGFjZSB0aGUgY29udGVudCB3aGVuIGNoYW5nZWRcbiAgICAgIGlmIChjb250ZW50IGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9ICcnO1xuICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgICAgfSBlbHNlIGlmIChjb250ZW50ICE9IHVuZGVmaW5lZCkge1xuICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9IGNvbnRlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoISh0aGlzLmRhdGEudHlwZSA9PSAnYmFja2dyb3VuZCcgJiYgdGhpcy5kYXRhLmNvbnRlbnQgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3BlcnR5IFwiY29udGVudFwiIG1pc3NpbmcgaW4gaXRlbSAnICsgdGhpcy5pZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBIVE1MIGNvbnRlbnRzIGZvciB0aGUgaXRlbVxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgICBIVE1MIGVsZW1lbnQgdG8gZmlsbCB3aXRoIHRoZSBjb250ZW50c1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgSXRlbS5wcm90b3R5cGUuX3VwZGF0ZVRpdGxlID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICBpZiAodGhpcy5kYXRhLnRpdGxlICE9IG51bGwpIHtcbiAgICAgIGVsZW1lbnQudGl0bGUgPSB0aGlzLmRhdGEudGl0bGUgfHwgJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd2aXMtdGl0bGUnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgZGF0YUF0dHJpYnV0ZXMgdGltZWxpbmUgb3B0aW9uIGFuZCBzZXQgYXMgZGF0YS0gYXR0cmlidXRlcyBvbiBkb20uY29udGVudFxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgICBIVE1MIGVsZW1lbnQgdG8gd2hpY2ggdGhlIGF0dHJpYnV0ZXMgd2lsbCBiZSBhdHRhY2hlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgSXRlbS5wcm90b3R5cGUuX3VwZGF0ZURhdGFBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmRhdGFBdHRyaWJ1dGVzICYmIHRoaXMub3B0aW9ucy5kYXRhQXR0cmlidXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IFtdO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLm9wdGlvbnMuZGF0YUF0dHJpYnV0ZXMpKSB7XG4gICAgICAgIGF0dHJpYnV0ZXMgPSB0aGlzLm9wdGlvbnMuZGF0YUF0dHJpYnV0ZXM7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5kYXRhQXR0cmlidXRlcyA9PSAnYWxsJykge1xuICAgICAgICBhdHRyaWJ1dGVzID0gT2JqZWN0LmtleXModGhpcy5kYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuYW1lID0gYXR0cmlidXRlc1tpXTtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5kYXRhW25hbWVdO1xuXG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtJyArIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS0nICsgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBjdXN0b20gc3R5bGVzIG9mIHRoZSBlbGVtZW50XG4gICAqIEBwYXJhbSBlbGVtZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBJdGVtLnByb3RvdHlwZS5fdXBkYXRlU3R5bGUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIC8vIHJlbW92ZSBvbGQgc3R5bGVzXG4gICAgaWYgKHRoaXMuc3R5bGUpIHtcbiAgICAgIHV0aWwucmVtb3ZlQ3NzVGV4dChlbGVtZW50LCB0aGlzLnN0eWxlKTtcbiAgICAgIHRoaXMuc3R5bGUgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIGFwcGVuZCBuZXcgc3R5bGVzXG4gICAgaWYgKHRoaXMuZGF0YS5zdHlsZSkge1xuICAgICAgdXRpbC5hZGRDc3NUZXh0KGVsZW1lbnQsIHRoaXMuZGF0YS5zdHlsZSk7XG4gICAgICB0aGlzLnN0eWxlID0gdGhpcy5kYXRhLnN0eWxlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU3RyaW5naWZ5IHRoZSBpdGVtcyBjb250ZW50c1xuICAgKiBAcGFyYW0ge3N0cmluZyB8IEVsZW1lbnQgfCB1bmRlZmluZWR9IGNvbnRlbnRcbiAgICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIEl0ZW0ucHJvdG90eXBlLl9jb250ZW50VG9TdHJpbmcgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHJldHVybiBjb250ZW50O1xuICAgIGlmIChjb250ZW50ICYmICdvdXRlckhUTUwnIGluIGNvbnRlbnQpIHJldHVybiBjb250ZW50Lm91dGVySFRNTDtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB3aWR0aCBvZiB0aGUgaXRlbSBsZWZ0IGZyb20gaXRzIHN0YXJ0IGRhdGVcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgSXRlbS5wcm90b3R5cGUuZ2V0V2lkdGhMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHdpZHRoIG9mIHRoZSBpdGVtIHJpZ2h0IGZyb20gdGhlIG1heCBvZiBpdHMgc3RhcnQgYW5kIGVuZCBkYXRlXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIEl0ZW0ucHJvdG90eXBlLmdldFdpZHRoUmlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIDA7XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBJdGVtO1xuXG4vKioqLyB9LFxuLyogNDAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4gIHZhciBHcm91cCA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpO1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3IgQmFja2dyb3VuZEdyb3VwXG4gICAqIEBwYXJhbSB7TnVtYmVyIHwgU3RyaW5nfSBncm91cElkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEBwYXJhbSB7SXRlbVNldH0gaXRlbVNldFxuICAgKi9cbiAgZnVuY3Rpb24gQmFja2dyb3VuZEdyb3VwKGdyb3VwSWQsIGRhdGEsIGl0ZW1TZXQpIHtcbiAgICBHcm91cC5jYWxsKHRoaXMsIGdyb3VwSWQsIGRhdGEsIGl0ZW1TZXQpO1xuXG4gICAgdGhpcy53aWR0aCA9IDA7XG4gICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgIHRoaXMudG9wID0gMDtcbiAgICB0aGlzLmxlZnQgPSAwO1xuICB9XG5cbiAgQmFja2dyb3VuZEdyb3VwLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3JvdXAucHJvdG90eXBlKTtcblxuICAvKipcbiAgICogUmVwYWludCB0aGlzIGdyb3VwXG4gICAqIEBwYXJhbSB7e3N0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyfX0gcmFuZ2VcbiAgICogQHBhcmFtIHt7aXRlbToge2hvcml6b250YWw6IG51bWJlciwgdmVydGljYWw6IG51bWJlcn0sIGF4aXM6IG51bWJlcn19IG1hcmdpblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXN0YWNrPWZhbHNlXSAgRm9yY2UgcmVzdGFja2luZyBvZiBhbGwgaXRlbXNcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBncm91cCBpcyByZXNpemVkXG4gICAqL1xuICBCYWNrZ3JvdW5kR3JvdXAucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uIChyYW5nZSwgbWFyZ2luLCByZXN0YWNrKSB7XG4gICAgdmFyIHJlc2l6ZWQgPSBmYWxzZTtcblxuICAgIHRoaXMudmlzaWJsZUl0ZW1zID0gdGhpcy5fdXBkYXRlVmlzaWJsZUl0ZW1zKHRoaXMub3JkZXJlZEl0ZW1zLCB0aGlzLnZpc2libGVJdGVtcywgcmFuZ2UpO1xuXG4gICAgLy8gY2FsY3VsYXRlIGFjdHVhbCBzaXplXG4gICAgdGhpcy53aWR0aCA9IHRoaXMuZG9tLmJhY2tncm91bmQub2Zmc2V0V2lkdGg7XG5cbiAgICAvLyBhcHBseSBuZXcgaGVpZ2h0IChqdXN0IGFsd2F5cyB6ZXJvIGZvciBCYWNrZ3JvdW5kR3JvdXBcbiAgICB0aGlzLmRvbS5iYWNrZ3JvdW5kLnN0eWxlLmhlaWdodCA9ICcwJztcblxuICAgIC8vIHVwZGF0ZSB2ZXJ0aWNhbCBwb3NpdGlvbiBvZiBpdGVtcyBhZnRlciB0aGV5IGFyZSByZS1zdGFja2VkIGFuZCB0aGUgaGVpZ2h0IG9mIHRoZSBncm91cCBpcyBjYWxjdWxhdGVkXG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdGhpcy52aXNpYmxlSXRlbXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSB0aGlzLnZpc2libGVJdGVtc1tpXTtcbiAgICAgIGl0ZW0ucmVwb3NpdGlvblkobWFyZ2luKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzaXplZDtcbiAgfTtcblxuICAvKipcbiAgICogU2hvdyB0aGlzIGdyb3VwOiBhdHRhY2ggdG8gdGhlIERPTVxuICAgKi9cbiAgQmFja2dyb3VuZEdyb3VwLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5kb20uYmFja2dyb3VuZC5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLml0ZW1TZXQuZG9tLmJhY2tncm91bmQuYXBwZW5kQ2hpbGQodGhpcy5kb20uYmFja2dyb3VuZCk7XG4gICAgfVxuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gQmFja2dyb3VuZEdyb3VwO1xuXG4vKioqLyB9LFxuLyogNDEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgSXRlbSA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvciBCb3hJdGVtXG4gICAqIEBleHRlbmRzIEl0ZW1cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgICAgICAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVycyBzdGFydFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50LCBjbGFzc05hbWUuXG4gICAqIEBwYXJhbSB7e3RvU2NyZWVuOiBmdW5jdGlvbiwgdG9UaW1lOiBmdW5jdGlvbn19IGNvbnZlcnNpb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29udmVyc2lvbiBmdW5jdGlvbnMgZnJvbSB0aW1lIHRvIHNjcmVlbiBhbmQgdmljZSB2ZXJzYVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgICAgICBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogZGVzY3JpYmUgYXZhaWxhYmxlIG9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIEJveEl0ZW0oZGF0YSwgY29udmVyc2lvbiwgb3B0aW9ucykge1xuICAgIHRoaXMucHJvcHMgPSB7XG4gICAgICBkb3Q6IHtcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMFxuICAgICAgfSxcbiAgICAgIGxpbmU6IHtcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMFxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAvLyB2YWxpZGF0ZSBkYXRhXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIGlmIChkYXRhLnN0YXJ0ID09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3BlcnR5IFwic3RhcnRcIiBtaXNzaW5nIGluIGl0ZW0gJyArIGRhdGEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIEl0ZW0uY2FsbCh0aGlzLCBkYXRhLCBjb252ZXJzaW9uLCBvcHRpb25zKTtcbiAgfVxuXG4gIEJveEl0ZW0ucHJvdG90eXBlID0gbmV3IEl0ZW0obnVsbCwgbnVsbCwgbnVsbCk7XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdGhpcyBpdGVtIGlzIHZpc2libGUgaW5zaWRlIGdpdmVuIHJhbmdlXG4gICAqIEByZXR1cm5zIHt7c3RhcnQ6IE51bWJlciwgZW5kOiBOdW1iZXJ9fSByYW5nZSB3aXRoIGEgdGltZXN0YW1wIGZvciBzdGFydCBhbmQgZW5kXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZpc2libGVcbiAgICovXG4gIEJveEl0ZW0ucHJvdG90eXBlLmlzVmlzaWJsZSA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgIC8vIGRldGVybWluZSB2aXNpYmlsaXR5XG4gICAgLy8gVE9ETzogYWNjb3VudCBmb3IgdGhlIHJlYWwgd2lkdGggb2YgdGhlIGl0ZW0uIFJpZ2h0IG5vdyB3ZSBqdXN0IGFkZCAxLzQgdG8gdGhlIHdpbmRvd1xuICAgIHZhciBpbnRlcnZhbCA9IChyYW5nZS5lbmQgLSByYW5nZS5zdGFydCkgLyA0O1xuICAgIHJldHVybiB0aGlzLmRhdGEuc3RhcnQgPiByYW5nZS5zdGFydCAtIGludGVydmFsICYmIHRoaXMuZGF0YS5zdGFydCA8IHJhbmdlLmVuZCArIGludGVydmFsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXBhaW50IHRoZSBpdGVtXG4gICAqL1xuICBCb3hJdGVtLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRvbSA9IHRoaXMuZG9tO1xuICAgIGlmICghZG9tKSB7XG4gICAgICAvLyBjcmVhdGUgRE9NXG4gICAgICB0aGlzLmRvbSA9IHt9O1xuICAgICAgZG9tID0gdGhpcy5kb207XG5cbiAgICAgIC8vIGNyZWF0ZSBtYWluIGJveFxuICAgICAgZG9tLmJveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuXG4gICAgICAvLyBjb250ZW50cyBib3ggKGluc2lkZSB0aGUgYmFja2dyb3VuZCBib3gpLiB1c2VkIGZvciBtYWtpbmcgbWFyZ2luc1xuICAgICAgZG9tLmNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcbiAgICAgIGRvbS5jb250ZW50LmNsYXNzTmFtZSA9ICd2aXMtaXRlbS1jb250ZW50JztcbiAgICAgIGRvbS5ib3guYXBwZW5kQ2hpbGQoZG9tLmNvbnRlbnQpO1xuXG4gICAgICAvLyBsaW5lIHRvIGF4aXNcbiAgICAgIGRvbS5saW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XG4gICAgICBkb20ubGluZS5jbGFzc05hbWUgPSAndmlzLWxpbmUnO1xuXG4gICAgICAvLyBkb3Qgb24gYXhpc1xuICAgICAgZG9tLmRvdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICAgICAgZG9tLmRvdC5jbGFzc05hbWUgPSAndmlzLWRvdCc7XG5cbiAgICAgIC8vIGF0dGFjaCB0aGlzIGl0ZW0gYXMgYXR0cmlidXRlXG4gICAgICBkb20uYm94Wyd0aW1lbGluZS1pdGVtJ10gPSB0aGlzO1xuXG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBhcHBlbmQgRE9NIHRvIHBhcmVudCBET01cbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWRyYXcgaXRlbTogbm8gcGFyZW50IGF0dGFjaGVkJyk7XG4gICAgfVxuICAgIGlmICghZG9tLmJveC5wYXJlbnROb2RlKSB7XG4gICAgICB2YXIgZm9yZWdyb3VuZCA9IHRoaXMucGFyZW50LmRvbS5mb3JlZ3JvdW5kO1xuICAgICAgaWYgKCFmb3JlZ3JvdW5kKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWRyYXcgaXRlbTogcGFyZW50IGhhcyBubyBmb3JlZ3JvdW5kIGNvbnRhaW5lciBlbGVtZW50Jyk7XG4gICAgICBmb3JlZ3JvdW5kLmFwcGVuZENoaWxkKGRvbS5ib3gpO1xuICAgIH1cbiAgICBpZiAoIWRvbS5saW5lLnBhcmVudE5vZGUpIHtcbiAgICAgIHZhciBiYWNrZ3JvdW5kID0gdGhpcy5wYXJlbnQuZG9tLmJhY2tncm91bmQ7XG4gICAgICBpZiAoIWJhY2tncm91bmQpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlZHJhdyBpdGVtOiBwYXJlbnQgaGFzIG5vIGJhY2tncm91bmQgY29udGFpbmVyIGVsZW1lbnQnKTtcbiAgICAgIGJhY2tncm91bmQuYXBwZW5kQ2hpbGQoZG9tLmxpbmUpO1xuICAgIH1cbiAgICBpZiAoIWRvbS5kb3QucGFyZW50Tm9kZSkge1xuICAgICAgdmFyIGF4aXMgPSB0aGlzLnBhcmVudC5kb20uYXhpcztcbiAgICAgIGlmICghYmFja2dyb3VuZCkgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVkcmF3IGl0ZW06IHBhcmVudCBoYXMgbm8gYXhpcyBjb250YWluZXIgZWxlbWVudCcpO1xuICAgICAgYXhpcy5hcHBlbmRDaGlsZChkb20uZG90KTtcbiAgICB9XG4gICAgdGhpcy5kaXNwbGF5ZWQgPSB0cnVlO1xuXG4gICAgLy8gVXBkYXRlIERPTSB3aGVuIGl0ZW0gaXMgbWFya2VkIGRpcnR5LiBBbiBpdGVtIGlzIG1hcmtlZCBkaXJ0eSB3aGVuOlxuICAgIC8vIC0gdGhlIGl0ZW0gaXMgbm90IHlldCByZW5kZXJlZFxuICAgIC8vIC0gdGhlIGl0ZW0ncyBkYXRhIGlzIGNoYW5nZWRcbiAgICAvLyAtIHRoZSBpdGVtIGlzIHNlbGVjdGVkL2Rlc2VsZWN0ZWRcbiAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgdGhpcy5fdXBkYXRlQ29udGVudHModGhpcy5kb20uY29udGVudCk7XG4gICAgICB0aGlzLl91cGRhdGVUaXRsZSh0aGlzLmRvbS5ib3gpO1xuICAgICAgdGhpcy5fdXBkYXRlRGF0YUF0dHJpYnV0ZXModGhpcy5kb20uYm94KTtcbiAgICAgIHRoaXMuX3VwZGF0ZVN0eWxlKHRoaXMuZG9tLmJveCk7XG5cbiAgICAgIHZhciBlZGl0YWJsZSA9ICh0aGlzLm9wdGlvbnMuZWRpdGFibGUudXBkYXRlVGltZSB8fCB0aGlzLm9wdGlvbnMuZWRpdGFibGUudXBkYXRlR3JvdXAgfHwgdGhpcy5lZGl0YWJsZSA9PT0gdHJ1ZSkgJiYgdGhpcy5lZGl0YWJsZSAhPT0gZmFsc2U7XG5cbiAgICAgIC8vIHVwZGF0ZSBjbGFzc1xuICAgICAgdmFyIGNsYXNzTmFtZSA9ICh0aGlzLmRhdGEuY2xhc3NOYW1lID8gJyAnICsgdGhpcy5kYXRhLmNsYXNzTmFtZSA6ICcnKSArICh0aGlzLnNlbGVjdGVkID8gJyB2aXMtc2VsZWN0ZWQnIDogJycpICsgKGVkaXRhYmxlID8gJyB2aXMtZWRpdGFibGUnIDogJyB2aXMtcmVhZG9ubHknKTtcbiAgICAgIGRvbS5ib3guY2xhc3NOYW1lID0gJ3Zpcy1pdGVtIHZpcy1ib3gnICsgY2xhc3NOYW1lO1xuICAgICAgZG9tLmxpbmUuY2xhc3NOYW1lID0gJ3Zpcy1pdGVtIHZpcy1saW5lJyArIGNsYXNzTmFtZTtcbiAgICAgIGRvbS5kb3QuY2xhc3NOYW1lID0gJ3Zpcy1pdGVtIHZpcy1kb3QnICsgY2xhc3NOYW1lO1xuXG4gICAgICAvLyByZWNhbGN1bGF0ZSBzaXplXG4gICAgICB0aGlzLnByb3BzLmRvdC5oZWlnaHQgPSBkb20uZG90Lm9mZnNldEhlaWdodDtcbiAgICAgIHRoaXMucHJvcHMuZG90LndpZHRoID0gZG9tLmRvdC5vZmZzZXRXaWR0aDtcbiAgICAgIHRoaXMucHJvcHMubGluZS53aWR0aCA9IGRvbS5saW5lLm9mZnNldFdpZHRoO1xuICAgICAgdGhpcy53aWR0aCA9IGRvbS5ib3gub2Zmc2V0V2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IGRvbS5ib3gub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVwYWludERlbGV0ZUJ1dHRvbihkb20uYm94KTtcbiAgfTtcblxuICAvKipcbiAgICogU2hvdyB0aGUgaXRlbSBpbiB0aGUgRE9NICh3aGVuIG5vdCBhbHJlYWR5IGRpc3BsYXllZCkuIFRoZSBpdGVtcyBET00gd2lsbFxuICAgKiBiZSBjcmVhdGVkIHdoZW4gbmVlZGVkLlxuICAgKi9cbiAgQm94SXRlbS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuZGlzcGxheWVkKSB7XG4gICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSGlkZSB0aGUgaXRlbSBmcm9tIHRoZSBET00gKHdoZW4gdmlzaWJsZSlcbiAgICovXG4gIEJveEl0ZW0ucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZGlzcGxheWVkKSB7XG4gICAgICB2YXIgZG9tID0gdGhpcy5kb207XG5cbiAgICAgIGlmIChkb20uYm94LnBhcmVudE5vZGUpIGRvbS5ib3gucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkb20uYm94KTtcbiAgICAgIGlmIChkb20ubGluZS5wYXJlbnROb2RlKSBkb20ubGluZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRvbS5saW5lKTtcbiAgICAgIGlmIChkb20uZG90LnBhcmVudE5vZGUpIGRvbS5kb3QucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkb20uZG90KTtcblxuICAgICAgdGhpcy5kaXNwbGF5ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcG9zaXRpb24gdGhlIGl0ZW0gaG9yaXpvbnRhbGx5XG4gICAqIEBPdmVycmlkZVxuICAgKi9cbiAgQm94SXRlbS5wcm90b3R5cGUucmVwb3NpdGlvblggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5jb252ZXJzaW9uLnRvU2NyZWVuKHRoaXMuZGF0YS5zdGFydCk7XG4gICAgdmFyIGFsaWduID0gdGhpcy5vcHRpb25zLmFsaWduO1xuXG4gICAgLy8gY2FsY3VsYXRlIGxlZnQgcG9zaXRpb24gb2YgdGhlIGJveFxuICAgIGlmIChhbGlnbiA9PSAncmlnaHQnKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgICB0aGlzLnJpZ2h0ID0gc3RhcnQgLSB0aGlzLndpZHRoO1xuXG4gICAgICAgIC8vIHJlcG9zaXRpb24gYm94LCBsaW5lLCBhbmQgZG90XG4gICAgICAgIHRoaXMuZG9tLmJveC5zdHlsZS5yaWdodCA9IHRoaXMucmlnaHQgKyAncHgnO1xuICAgICAgICB0aGlzLmRvbS5saW5lLnN0eWxlLnJpZ2h0ID0gc3RhcnQgLSB0aGlzLnByb3BzLmxpbmUud2lkdGggKyAncHgnO1xuICAgICAgICB0aGlzLmRvbS5kb3Quc3R5bGUucmlnaHQgPSBzdGFydCAtIHRoaXMucHJvcHMubGluZS53aWR0aCAvIDIgLSB0aGlzLnByb3BzLmRvdC53aWR0aCAvIDIgKyAncHgnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sZWZ0ID0gc3RhcnQgLSB0aGlzLndpZHRoO1xuXG4gICAgICAgIC8vIHJlcG9zaXRpb24gYm94LCBsaW5lLCBhbmQgZG90XG4gICAgICAgIHRoaXMuZG9tLmJveC5zdHlsZS5sZWZ0ID0gdGhpcy5sZWZ0ICsgJ3B4JztcbiAgICAgICAgdGhpcy5kb20ubGluZS5zdHlsZS5sZWZ0ID0gc3RhcnQgLSB0aGlzLnByb3BzLmxpbmUud2lkdGggKyAncHgnO1xuICAgICAgICB0aGlzLmRvbS5kb3Quc3R5bGUubGVmdCA9IHN0YXJ0IC0gdGhpcy5wcm9wcy5saW5lLndpZHRoIC8gMiAtIHRoaXMucHJvcHMuZG90LndpZHRoIC8gMiArICdweCc7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhbGlnbiA9PSAnbGVmdCcpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucnRsKSB7XG4gICAgICAgIHRoaXMucmlnaHQgPSBzdGFydDtcblxuICAgICAgICAvLyByZXBvc2l0aW9uIGJveCwgbGluZSwgYW5kIGRvdFxuICAgICAgICB0aGlzLmRvbS5ib3guc3R5bGUucmlnaHQgPSB0aGlzLnJpZ2h0ICsgJ3B4JztcbiAgICAgICAgdGhpcy5kb20ubGluZS5zdHlsZS5yaWdodCA9IHN0YXJ0ICsgJ3B4JztcbiAgICAgICAgdGhpcy5kb20uZG90LnN0eWxlLnJpZ2h0ID0gc3RhcnQgKyB0aGlzLnByb3BzLmxpbmUud2lkdGggLyAyIC0gdGhpcy5wcm9wcy5kb3Qud2lkdGggLyAyICsgJ3B4JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGVmdCA9IHN0YXJ0O1xuXG4gICAgICAgIC8vIHJlcG9zaXRpb24gYm94LCBsaW5lLCBhbmQgZG90XG4gICAgICAgIHRoaXMuZG9tLmJveC5zdHlsZS5sZWZ0ID0gdGhpcy5sZWZ0ICsgJ3B4JztcbiAgICAgICAgdGhpcy5kb20ubGluZS5zdHlsZS5sZWZ0ID0gc3RhcnQgKyAncHgnO1xuICAgICAgICB0aGlzLmRvbS5kb3Quc3R5bGUubGVmdCA9IHN0YXJ0ICsgdGhpcy5wcm9wcy5saW5lLndpZHRoIC8gMiAtIHRoaXMucHJvcHMuZG90LndpZHRoIC8gMiArICdweCc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGRlZmF1bHQgb3IgJ2NlbnRlcidcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucnRsKSB7XG4gICAgICAgIHRoaXMucmlnaHQgPSBzdGFydCAtIHRoaXMud2lkdGggLyAyO1xuXG4gICAgICAgIC8vIHJlcG9zaXRpb24gYm94LCBsaW5lLCBhbmQgZG90XG4gICAgICAgIHRoaXMuZG9tLmJveC5zdHlsZS5yaWdodCA9IHRoaXMucmlnaHQgKyAncHgnO1xuICAgICAgICB0aGlzLmRvbS5saW5lLnN0eWxlLnJpZ2h0ID0gc3RhcnQgLSB0aGlzLnByb3BzLmxpbmUud2lkdGggKyAncHgnO1xuICAgICAgICB0aGlzLmRvbS5kb3Quc3R5bGUucmlnaHQgPSBzdGFydCAtIHRoaXMucHJvcHMuZG90LndpZHRoIC8gMiArICdweCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxlZnQgPSBzdGFydCAtIHRoaXMud2lkdGggLyAyO1xuXG4gICAgICAgIC8vIHJlcG9zaXRpb24gYm94LCBsaW5lLCBhbmQgZG90XG4gICAgICAgIHRoaXMuZG9tLmJveC5zdHlsZS5sZWZ0ID0gdGhpcy5sZWZ0ICsgJ3B4JztcbiAgICAgICAgdGhpcy5kb20ubGluZS5zdHlsZS5sZWZ0ID0gc3RhcnQgLSB0aGlzLnByb3BzLmxpbmUud2lkdGggLyAyICsgJ3B4JztcbiAgICAgICAgdGhpcy5kb20uZG90LnN0eWxlLmxlZnQgPSBzdGFydCAtIHRoaXMucHJvcHMuZG90LndpZHRoIC8gMiArICdweCc7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXBvc2l0aW9uIHRoZSBpdGVtIHZlcnRpY2FsbHlcbiAgICogQE92ZXJyaWRlXG4gICAqL1xuICBCb3hJdGVtLnByb3RvdHlwZS5yZXBvc2l0aW9uWSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3JpZW50YXRpb24gPSB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uaXRlbTtcbiAgICB2YXIgYm94ID0gdGhpcy5kb20uYm94O1xuICAgIHZhciBsaW5lID0gdGhpcy5kb20ubGluZTtcbiAgICB2YXIgZG90ID0gdGhpcy5kb20uZG90O1xuXG4gICAgaWYgKG9yaWVudGF0aW9uID09ICd0b3AnKSB7XG4gICAgICBib3guc3R5bGUudG9wID0gKHRoaXMudG9wIHx8IDApICsgJ3B4JztcblxuICAgICAgbGluZS5zdHlsZS50b3AgPSAnMCc7XG4gICAgICBsaW5lLnN0eWxlLmhlaWdodCA9IHRoaXMucGFyZW50LnRvcCArIHRoaXMudG9wICsgMSArICdweCc7XG4gICAgICBsaW5lLnN0eWxlLmJvdHRvbSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvcmllbnRhdGlvbiAnYm90dG9tJ1xuICAgICAgdmFyIGl0ZW1TZXRIZWlnaHQgPSB0aGlzLnBhcmVudC5pdGVtU2V0LnByb3BzLmhlaWdodDsgLy8gVE9ETzogdGhpcyBpcyBuYXN0eVxuICAgICAgdmFyIGxpbmVIZWlnaHQgPSBpdGVtU2V0SGVpZ2h0IC0gdGhpcy5wYXJlbnQudG9wIC0gdGhpcy5wYXJlbnQuaGVpZ2h0ICsgdGhpcy50b3A7XG5cbiAgICAgIGJveC5zdHlsZS50b3AgPSAodGhpcy5wYXJlbnQuaGVpZ2h0IC0gdGhpcy50b3AgLSB0aGlzLmhlaWdodCB8fCAwKSArICdweCc7XG4gICAgICBsaW5lLnN0eWxlLnRvcCA9IGl0ZW1TZXRIZWlnaHQgLSBsaW5lSGVpZ2h0ICsgJ3B4JztcbiAgICAgIGxpbmUuc3R5bGUuYm90dG9tID0gJzAnO1xuICAgIH1cblxuICAgIGRvdC5zdHlsZS50b3AgPSAtdGhpcy5wcm9wcy5kb3QuaGVpZ2h0IC8gMiArICdweCc7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgd2lkdGggb2YgdGhlIGl0ZW0gbGVmdCBmcm9tIGl0cyBzdGFydCBkYXRlXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIEJveEl0ZW0ucHJvdG90eXBlLmdldFdpZHRoTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy53aWR0aCAvIDI7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgd2lkdGggb2YgdGhlIGl0ZW0gcmlnaHQgZnJvbSBpdHMgc3RhcnQgZGF0ZVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBCb3hJdGVtLnByb3RvdHlwZS5nZXRXaWR0aFJpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLndpZHRoIC8gMjtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IEJveEl0ZW07XG5cbi8qKiovIH0sXG4vKiA0MiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBJdGVtID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvciBQb2ludEl0ZW1cbiAgICogQGV4dGVuZHMgSXRlbVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAgICAgICAgICAgICBPYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJzIHN0YXJ0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQsIGNsYXNzTmFtZS5cbiAgICogQHBhcmFtIHt7dG9TY3JlZW46IGZ1bmN0aW9uLCB0b1RpbWU6IGZ1bmN0aW9ufX0gY29udmVyc2lvblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb252ZXJzaW9uIGZ1bmN0aW9ucyBmcm9tIHRpbWUgdG8gc2NyZWVuIGFuZCB2aWNlIHZlcnNhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgICAgIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBkZXNjcmliZSBhdmFpbGFibGUgb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gUG9pbnRJdGVtKGRhdGEsIGNvbnZlcnNpb24sIG9wdGlvbnMpIHtcbiAgICB0aGlzLnByb3BzID0ge1xuICAgICAgZG90OiB7XG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMFxuICAgICAgfSxcbiAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICBtYXJnaW5MZWZ0OiAwLFxuICAgICAgICBtYXJnaW5SaWdodDogMFxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAvLyB2YWxpZGF0ZSBkYXRhXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIGlmIChkYXRhLnN0YXJ0ID09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3BlcnR5IFwic3RhcnRcIiBtaXNzaW5nIGluIGl0ZW0gJyArIGRhdGEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIEl0ZW0uY2FsbCh0aGlzLCBkYXRhLCBjb252ZXJzaW9uLCBvcHRpb25zKTtcbiAgfVxuXG4gIFBvaW50SXRlbS5wcm90b3R5cGUgPSBuZXcgSXRlbShudWxsLCBudWxsLCBudWxsKTtcblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciB0aGlzIGl0ZW0gaXMgdmlzaWJsZSBpbnNpZGUgZ2l2ZW4gcmFuZ2VcbiAgICogQHJldHVybnMge3tzdGFydDogTnVtYmVyLCBlbmQ6IE51bWJlcn19IHJhbmdlIHdpdGggYSB0aW1lc3RhbXAgZm9yIHN0YXJ0IGFuZCBlbmRcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmlzaWJsZVxuICAgKi9cbiAgUG9pbnRJdGVtLnByb3RvdHlwZS5pc1Zpc2libGUgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAvLyBkZXRlcm1pbmUgdmlzaWJpbGl0eVxuICAgIC8vIFRPRE86IGFjY291bnQgZm9yIHRoZSByZWFsIHdpZHRoIG9mIHRoZSBpdGVtLiBSaWdodCBub3cgd2UganVzdCBhZGQgMS80IHRvIHRoZSB3aW5kb3dcbiAgICB2YXIgaW50ZXJ2YWwgPSAocmFuZ2UuZW5kIC0gcmFuZ2Uuc3RhcnQpIC8gNDtcbiAgICByZXR1cm4gdGhpcy5kYXRhLnN0YXJ0ID4gcmFuZ2Uuc3RhcnQgLSBpbnRlcnZhbCAmJiB0aGlzLmRhdGEuc3RhcnQgPCByYW5nZS5lbmQgKyBpbnRlcnZhbDtcbiAgfTtcblxuICAvKipcbiAgICogUmVwYWludCB0aGUgaXRlbVxuICAgKi9cbiAgUG9pbnRJdGVtLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRvbSA9IHRoaXMuZG9tO1xuICAgIGlmICghZG9tKSB7XG4gICAgICAvLyBjcmVhdGUgRE9NXG4gICAgICB0aGlzLmRvbSA9IHt9O1xuICAgICAgZG9tID0gdGhpcy5kb207XG5cbiAgICAgIC8vIGJhY2tncm91bmQgYm94XG4gICAgICBkb20ucG9pbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIC8vIGNsYXNzTmFtZSBpcyB1cGRhdGVkIGluIHJlZHJhdygpXG5cbiAgICAgIC8vIGNvbnRlbnRzIGJveCwgcmlnaHQgZnJvbSB0aGUgZG90XG4gICAgICBkb20uY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZG9tLmNvbnRlbnQuY2xhc3NOYW1lID0gJ3Zpcy1pdGVtLWNvbnRlbnQnO1xuICAgICAgZG9tLnBvaW50LmFwcGVuZENoaWxkKGRvbS5jb250ZW50KTtcblxuICAgICAgLy8gZG90IGF0IHN0YXJ0XG4gICAgICBkb20uZG90ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkb20ucG9pbnQuYXBwZW5kQ2hpbGQoZG9tLmRvdCk7XG5cbiAgICAgIC8vIGF0dGFjaCB0aGlzIGl0ZW0gYXMgYXR0cmlidXRlXG4gICAgICBkb20ucG9pbnRbJ3RpbWVsaW5lLWl0ZW0nXSA9IHRoaXM7XG5cbiAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIGFwcGVuZCBET00gdG8gcGFyZW50IERPTVxuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlZHJhdyBpdGVtOiBubyBwYXJlbnQgYXR0YWNoZWQnKTtcbiAgICB9XG4gICAgaWYgKCFkb20ucG9pbnQucGFyZW50Tm9kZSkge1xuICAgICAgdmFyIGZvcmVncm91bmQgPSB0aGlzLnBhcmVudC5kb20uZm9yZWdyb3VuZDtcbiAgICAgIGlmICghZm9yZWdyb3VuZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWRyYXcgaXRlbTogcGFyZW50IGhhcyBubyBmb3JlZ3JvdW5kIGNvbnRhaW5lciBlbGVtZW50Jyk7XG4gICAgICB9XG4gICAgICBmb3JlZ3JvdW5kLmFwcGVuZENoaWxkKGRvbS5wb2ludCk7XG4gICAgfVxuICAgIHRoaXMuZGlzcGxheWVkID0gdHJ1ZTtcblxuICAgIC8vIFVwZGF0ZSBET00gd2hlbiBpdGVtIGlzIG1hcmtlZCBkaXJ0eS4gQW4gaXRlbSBpcyBtYXJrZWQgZGlydHkgd2hlbjpcbiAgICAvLyAtIHRoZSBpdGVtIGlzIG5vdCB5ZXQgcmVuZGVyZWRcbiAgICAvLyAtIHRoZSBpdGVtJ3MgZGF0YSBpcyBjaGFuZ2VkXG4gICAgLy8gLSB0aGUgaXRlbSBpcyBzZWxlY3RlZC9kZXNlbGVjdGVkXG4gICAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUNvbnRlbnRzKHRoaXMuZG9tLmNvbnRlbnQpO1xuICAgICAgdGhpcy5fdXBkYXRlVGl0bGUodGhpcy5kb20ucG9pbnQpO1xuICAgICAgdGhpcy5fdXBkYXRlRGF0YUF0dHJpYnV0ZXModGhpcy5kb20ucG9pbnQpO1xuICAgICAgdGhpcy5fdXBkYXRlU3R5bGUodGhpcy5kb20ucG9pbnQpO1xuXG4gICAgICB2YXIgZWRpdGFibGUgPSAodGhpcy5vcHRpb25zLmVkaXRhYmxlLnVwZGF0ZVRpbWUgfHwgdGhpcy5vcHRpb25zLmVkaXRhYmxlLnVwZGF0ZUdyb3VwIHx8IHRoaXMuZWRpdGFibGUgPT09IHRydWUpICYmIHRoaXMuZWRpdGFibGUgIT09IGZhbHNlO1xuXG4gICAgICAvLyB1cGRhdGUgY2xhc3NcbiAgICAgIHZhciBjbGFzc05hbWUgPSAodGhpcy5kYXRhLmNsYXNzTmFtZSA/ICcgJyArIHRoaXMuZGF0YS5jbGFzc05hbWUgOiAnJykgKyAodGhpcy5zZWxlY3RlZCA/ICcgdmlzLXNlbGVjdGVkJyA6ICcnKSArIChlZGl0YWJsZSA/ICcgdmlzLWVkaXRhYmxlJyA6ICcgdmlzLXJlYWRvbmx5Jyk7XG4gICAgICBkb20ucG9pbnQuY2xhc3NOYW1lID0gJ3Zpcy1pdGVtIHZpcy1wb2ludCcgKyBjbGFzc05hbWU7XG4gICAgICBkb20uZG90LmNsYXNzTmFtZSA9ICd2aXMtaXRlbSB2aXMtZG90JyArIGNsYXNzTmFtZTtcblxuICAgICAgLy8gcmVjYWxjdWxhdGUgc2l6ZSBvZiBkb3QgYW5kIGNvbnRlbnRzXG4gICAgICB0aGlzLnByb3BzLmRvdC53aWR0aCA9IGRvbS5kb3Qub2Zmc2V0V2lkdGg7XG4gICAgICB0aGlzLnByb3BzLmRvdC5oZWlnaHQgPSBkb20uZG90Lm9mZnNldEhlaWdodDtcbiAgICAgIHRoaXMucHJvcHMuY29udGVudC5oZWlnaHQgPSBkb20uY29udGVudC5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgIC8vIHJlc2l6ZSBjb250ZW50c1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgICAgZG9tLmNvbnRlbnQuc3R5bGUubWFyZ2luUmlnaHQgPSAyICogdGhpcy5wcm9wcy5kb3Qud2lkdGggKyAncHgnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9tLmNvbnRlbnQuc3R5bGUubWFyZ2luTGVmdCA9IDIgKiB0aGlzLnByb3BzLmRvdC53aWR0aCArICdweCc7XG4gICAgICB9XG4gICAgICAvL2RvbS5jb250ZW50LnN0eWxlLm1hcmdpblJpZ2h0ID0gLi4uICsgJ3B4JzsgLy8gVE9ETzogbWFyZ2luIHJpZ2h0XG5cbiAgICAgIC8vIHJlY2FsY3VsYXRlIHNpemVcbiAgICAgIHRoaXMud2lkdGggPSBkb20ucG9pbnQub2Zmc2V0V2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IGRvbS5wb2ludC5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgIC8vIHJlcG9zaXRpb24gdGhlIGRvdFxuICAgICAgZG9tLmRvdC5zdHlsZS50b3AgPSAodGhpcy5oZWlnaHQgLSB0aGlzLnByb3BzLmRvdC5oZWlnaHQpIC8gMiArICdweCc7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgICBkb20uZG90LnN0eWxlLnJpZ2h0ID0gdGhpcy5wcm9wcy5kb3Qud2lkdGggLyAyICsgJ3B4JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbS5kb3Quc3R5bGUubGVmdCA9IHRoaXMucHJvcHMuZG90LndpZHRoIC8gMiArICdweCc7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZXBhaW50RGVsZXRlQnV0dG9uKGRvbS5wb2ludCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNob3cgdGhlIGl0ZW0gaW4gdGhlIERPTSAod2hlbiBub3QgYWxyZWFkeSB2aXNpYmxlKS4gVGhlIGl0ZW1zIERPTSB3aWxsXG4gICAqIGJlIGNyZWF0ZWQgd2hlbiBuZWVkZWQuXG4gICAqL1xuICBQb2ludEl0ZW0ucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmRpc3BsYXllZCkge1xuICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhpZGUgdGhlIGl0ZW0gZnJvbSB0aGUgRE9NICh3aGVuIHZpc2libGUpXG4gICAqL1xuICBQb2ludEl0ZW0ucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZGlzcGxheWVkKSB7XG4gICAgICBpZiAodGhpcy5kb20ucG9pbnQucGFyZW50Tm9kZSkge1xuICAgICAgICB0aGlzLmRvbS5wb2ludC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLnBvaW50KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kaXNwbGF5ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcG9zaXRpb24gdGhlIGl0ZW0gaG9yaXpvbnRhbGx5XG4gICAqIEBPdmVycmlkZVxuICAgKi9cbiAgUG9pbnRJdGVtLnByb3RvdHlwZS5yZXBvc2l0aW9uWCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLmNvbnZlcnNpb24udG9TY3JlZW4odGhpcy5kYXRhLnN0YXJ0KTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMucnRsKSB7XG4gICAgICB0aGlzLnJpZ2h0ID0gc3RhcnQgLSB0aGlzLnByb3BzLmRvdC53aWR0aDtcblxuICAgICAgLy8gcmVwb3NpdGlvbiBwb2ludFxuICAgICAgdGhpcy5kb20ucG9pbnQuc3R5bGUucmlnaHQgPSB0aGlzLnJpZ2h0ICsgJ3B4JztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sZWZ0ID0gc3RhcnQgLSB0aGlzLnByb3BzLmRvdC53aWR0aDtcblxuICAgICAgLy8gcmVwb3NpdGlvbiBwb2ludFxuICAgICAgdGhpcy5kb20ucG9pbnQuc3R5bGUubGVmdCA9IHRoaXMubGVmdCArICdweCc7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXBvc2l0aW9uIHRoZSBpdGVtIHZlcnRpY2FsbHlcbiAgICogQE92ZXJyaWRlXG4gICAqL1xuICBQb2ludEl0ZW0ucHJvdG90eXBlLnJlcG9zaXRpb25ZID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcmllbnRhdGlvbiA9IHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5pdGVtO1xuICAgIHZhciBwb2ludCA9IHRoaXMuZG9tLnBvaW50O1xuICAgIGlmIChvcmllbnRhdGlvbiA9PSAndG9wJykge1xuICAgICAgcG9pbnQuc3R5bGUudG9wID0gdGhpcy50b3AgKyAncHgnO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludC5zdHlsZS50b3AgPSB0aGlzLnBhcmVudC5oZWlnaHQgLSB0aGlzLnRvcCAtIHRoaXMuaGVpZ2h0ICsgJ3B4JztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgd2lkdGggb2YgdGhlIGl0ZW0gbGVmdCBmcm9tIGl0cyBzdGFydCBkYXRlXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIFBvaW50SXRlbS5wcm90b3R5cGUuZ2V0V2lkdGhMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLmRvdC53aWR0aDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB3aWR0aCBvZiB0aGUgaXRlbSByaWdodCBmcm9tICBpdHMgc3RhcnQgZGF0ZVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBQb2ludEl0ZW0ucHJvdG90eXBlLmdldFdpZHRoUmlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMuZG90LndpZHRoO1xuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gUG9pbnRJdGVtO1xuXG4vKioqLyB9LFxuLyogNDMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgSGFtbWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG4gIHZhciBJdGVtID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XG4gIHZhciBCYWNrZ3JvdW5kR3JvdXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwKTtcbiAgdmFyIFJhbmdlSXRlbSA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpO1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3IgQmFja2dyb3VuZEl0ZW1cbiAgICogQGV4dGVuZHMgSXRlbVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAgICAgICAgICAgICBPYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJzIHN0YXJ0LCBlbmRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCwgY2xhc3NOYW1lLlxuICAgKiBAcGFyYW0ge3t0b1NjcmVlbjogZnVuY3Rpb24sIHRvVGltZTogZnVuY3Rpb259fSBjb252ZXJzaW9uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbnZlcnNpb24gZnVuY3Rpb25zIGZyb20gdGltZSB0byBzY3JlZW4gYW5kIHZpY2UgdmVyc2FcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICAgICAgQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGRlc2NyaWJlIG9wdGlvbnNcbiAgICovXG4gIC8vIFRPRE86IGltcGxlbWVudCBzdXBwb3J0IGZvciB0aGUgQmFja2dyb3VuZEl0ZW0ganVzdCBoYXZpbmcgYSBzdGFydCwgdGhlbiBiZWluZyBkaXNwbGF5ZWQgYXMgYSBzb3J0IG9mIGFuIGFubm90YXRpb25cbiAgZnVuY3Rpb24gQmFja2dyb3VuZEl0ZW0oZGF0YSwgY29udmVyc2lvbiwgb3B0aW9ucykge1xuICAgIHRoaXMucHJvcHMgPSB7XG4gICAgICBjb250ZW50OiB7XG4gICAgICAgIHdpZHRoOiAwXG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLm92ZXJmbG93ID0gZmFsc2U7IC8vIGlmIGNvbnRlbnRzIGNhbiBvdmVyZmxvdyAoY3NzIHN0eWxpbmcpLCB0aGlzIGZsYWcgaXMgc2V0IHRvIHRydWVcblxuICAgIC8vIHZhbGlkYXRlIGRhdGFcbiAgICBpZiAoZGF0YSkge1xuICAgICAgaWYgKGRhdGEuc3RhcnQgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvcGVydHkgXCJzdGFydFwiIG1pc3NpbmcgaW4gaXRlbSAnICsgZGF0YS5pZCk7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YS5lbmQgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvcGVydHkgXCJlbmRcIiBtaXNzaW5nIGluIGl0ZW0gJyArIGRhdGEuaWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIEl0ZW0uY2FsbCh0aGlzLCBkYXRhLCBjb252ZXJzaW9uLCBvcHRpb25zKTtcbiAgfVxuXG4gIEJhY2tncm91bmRJdGVtLnByb3RvdHlwZSA9IG5ldyBJdGVtKG51bGwsIG51bGwsIG51bGwpO1xuXG4gIEJhY2tncm91bmRJdGVtLnByb3RvdHlwZS5iYXNlQ2xhc3NOYW1lID0gJ3Zpcy1pdGVtIHZpcy1iYWNrZ3JvdW5kJztcbiAgQmFja2dyb3VuZEl0ZW0ucHJvdG90eXBlLnN0YWNrID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdGhpcyBpdGVtIGlzIHZpc2libGUgaW5zaWRlIGdpdmVuIHJhbmdlXG4gICAqIEByZXR1cm5zIHt7c3RhcnQ6IE51bWJlciwgZW5kOiBOdW1iZXJ9fSByYW5nZSB3aXRoIGEgdGltZXN0YW1wIGZvciBzdGFydCBhbmQgZW5kXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZpc2libGVcbiAgICovXG4gIEJhY2tncm91bmRJdGVtLnByb3RvdHlwZS5pc1Zpc2libGUgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAvLyBkZXRlcm1pbmUgdmlzaWJpbGl0eVxuICAgIHJldHVybiB0aGlzLmRhdGEuc3RhcnQgPCByYW5nZS5lbmQgJiYgdGhpcy5kYXRhLmVuZCA+IHJhbmdlLnN0YXJ0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXBhaW50IHRoZSBpdGVtXG4gICAqL1xuICBCYWNrZ3JvdW5kSXRlbS5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkb20gPSB0aGlzLmRvbTtcbiAgICBpZiAoIWRvbSkge1xuICAgICAgLy8gY3JlYXRlIERPTVxuICAgICAgdGhpcy5kb20gPSB7fTtcbiAgICAgIGRvbSA9IHRoaXMuZG9tO1xuXG4gICAgICAvLyBiYWNrZ3JvdW5kIGJveFxuICAgICAgZG9tLmJveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgLy8gY2xhc3NOYW1lIGlzIHVwZGF0ZWQgaW4gcmVkcmF3KClcblxuICAgICAgLy8gZnJhbWUgYm94ICh0byBwcmV2ZW50IHRoZSBpdGVtIGNvbnRlbnRzIGZyb20gb3ZlcmZsb3dpbmdcbiAgICAgIGRvbS5mcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZG9tLmZyYW1lLmNsYXNzTmFtZSA9ICd2aXMtaXRlbS1vdmVyZmxvdyc7XG4gICAgICBkb20uYm94LmFwcGVuZENoaWxkKGRvbS5mcmFtZSk7XG5cbiAgICAgIC8vIGNvbnRlbnRzIGJveFxuICAgICAgZG9tLmNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRvbS5jb250ZW50LmNsYXNzTmFtZSA9ICd2aXMtaXRlbS1jb250ZW50JztcbiAgICAgIGRvbS5mcmFtZS5hcHBlbmRDaGlsZChkb20uY29udGVudCk7XG5cbiAgICAgIC8vIE5vdGU6IHdlIGRvIE5PVCBhdHRhY2ggdGhpcyBpdGVtIGFzIGF0dHJpYnV0ZSB0byB0aGUgRE9NLFxuICAgICAgLy8gICAgICAgc3VjaCB0aGF0IGJhY2tncm91bmQgaXRlbXMgY2Fubm90IGJlIHNlbGVjdGVkXG4gICAgICAvL2RvbS5ib3hbJ3RpbWVsaW5lLWl0ZW0nXSA9IHRoaXM7XG5cbiAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIGFwcGVuZCBET00gdG8gcGFyZW50IERPTVxuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlZHJhdyBpdGVtOiBubyBwYXJlbnQgYXR0YWNoZWQnKTtcbiAgICB9XG4gICAgaWYgKCFkb20uYm94LnBhcmVudE5vZGUpIHtcbiAgICAgIHZhciBiYWNrZ3JvdW5kID0gdGhpcy5wYXJlbnQuZG9tLmJhY2tncm91bmQ7XG4gICAgICBpZiAoIWJhY2tncm91bmQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVkcmF3IGl0ZW06IHBhcmVudCBoYXMgbm8gYmFja2dyb3VuZCBjb250YWluZXIgZWxlbWVudCcpO1xuICAgICAgfVxuICAgICAgYmFja2dyb3VuZC5hcHBlbmRDaGlsZChkb20uYm94KTtcbiAgICB9XG4gICAgdGhpcy5kaXNwbGF5ZWQgPSB0cnVlO1xuXG4gICAgLy8gVXBkYXRlIERPTSB3aGVuIGl0ZW0gaXMgbWFya2VkIGRpcnR5LiBBbiBpdGVtIGlzIG1hcmtlZCBkaXJ0eSB3aGVuOlxuICAgIC8vIC0gdGhlIGl0ZW0gaXMgbm90IHlldCByZW5kZXJlZFxuICAgIC8vIC0gdGhlIGl0ZW0ncyBkYXRhIGlzIGNoYW5nZWRcbiAgICAvLyAtIHRoZSBpdGVtIGlzIHNlbGVjdGVkL2Rlc2VsZWN0ZWRcbiAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgdGhpcy5fdXBkYXRlQ29udGVudHModGhpcy5kb20uY29udGVudCk7XG4gICAgICB0aGlzLl91cGRhdGVUaXRsZSh0aGlzLmRvbS5jb250ZW50KTtcbiAgICAgIHRoaXMuX3VwZGF0ZURhdGFBdHRyaWJ1dGVzKHRoaXMuZG9tLmNvbnRlbnQpO1xuICAgICAgdGhpcy5fdXBkYXRlU3R5bGUodGhpcy5kb20uYm94KTtcblxuICAgICAgLy8gdXBkYXRlIGNsYXNzXG4gICAgICB2YXIgY2xhc3NOYW1lID0gKHRoaXMuZGF0YS5jbGFzc05hbWUgPyAnICcgKyB0aGlzLmRhdGEuY2xhc3NOYW1lIDogJycpICsgKHRoaXMuc2VsZWN0ZWQgPyAnIHZpcy1zZWxlY3RlZCcgOiAnJyk7XG4gICAgICBkb20uYm94LmNsYXNzTmFtZSA9IHRoaXMuYmFzZUNsYXNzTmFtZSArIGNsYXNzTmFtZTtcblxuICAgICAgLy8gZGV0ZXJtaW5lIGZyb20gY3NzIHdoZXRoZXIgdGhpcyBib3ggaGFzIG92ZXJmbG93XG4gICAgICB0aGlzLm92ZXJmbG93ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9tLmNvbnRlbnQpLm92ZXJmbG93ICE9PSAnaGlkZGVuJztcblxuICAgICAgLy8gcmVjYWxjdWxhdGUgc2l6ZVxuICAgICAgdGhpcy5wcm9wcy5jb250ZW50LndpZHRoID0gdGhpcy5kb20uY29udGVudC5vZmZzZXRXaWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gMDsgLy8gc2V0IGhlaWdodCB6ZXJvLCBzbyB0aGlzIGl0ZW0gd2lsbCBiZSBpZ25vcmVkIHdoZW4gc3RhY2tpbmcgaXRlbXNcblxuICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2hvdyB0aGUgaXRlbSBpbiB0aGUgRE9NICh3aGVuIG5vdCBhbHJlYWR5IHZpc2libGUpLiBUaGUgaXRlbXMgRE9NIHdpbGxcbiAgICogYmUgY3JlYXRlZCB3aGVuIG5lZWRlZC5cbiAgICovXG4gIEJhY2tncm91bmRJdGVtLnByb3RvdHlwZS5zaG93ID0gUmFuZ2VJdGVtLnByb3RvdHlwZS5zaG93O1xuXG4gIC8qKlxuICAgKiBIaWRlIHRoZSBpdGVtIGZyb20gdGhlIERPTSAod2hlbiB2aXNpYmxlKVxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBjaGFuZ2VkXG4gICAqL1xuICBCYWNrZ3JvdW5kSXRlbS5wcm90b3R5cGUuaGlkZSA9IFJhbmdlSXRlbS5wcm90b3R5cGUuaGlkZTtcblxuICAvKipcbiAgICogUmVwb3NpdGlvbiB0aGUgaXRlbSBob3Jpem9udGFsbHlcbiAgICogQE92ZXJyaWRlXG4gICAqL1xuICBCYWNrZ3JvdW5kSXRlbS5wcm90b3R5cGUucmVwb3NpdGlvblggPSBSYW5nZUl0ZW0ucHJvdG90eXBlLnJlcG9zaXRpb25YO1xuXG4gIC8qKlxuICAgKiBSZXBvc2l0aW9uIHRoZSBpdGVtIHZlcnRpY2FsbHlcbiAgICogQE92ZXJyaWRlXG4gICAqL1xuICBCYWNrZ3JvdW5kSXRlbS5wcm90b3R5cGUucmVwb3NpdGlvblkgPSBmdW5jdGlvbiAobWFyZ2luKSB7XG4gICAgdmFyIG9uVG9wID0gdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uLml0ZW0gPT09ICd0b3AnO1xuICAgIHRoaXMuZG9tLmNvbnRlbnQuc3R5bGUudG9wID0gb25Ub3AgPyAnJyA6ICcwJztcbiAgICB0aGlzLmRvbS5jb250ZW50LnN0eWxlLmJvdHRvbSA9IG9uVG9wID8gJzAnIDogJyc7XG4gICAgdmFyIGhlaWdodDtcblxuICAgIC8vIHNwZWNpYWwgcG9zaXRpb25pbmcgZm9yIHN1Ymdyb3Vwc1xuICAgIGlmICh0aGlzLmRhdGEuc3ViZ3JvdXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gVE9ETzogaW5zdGVhZCBvZiBjYWxjdWxhdGluZyB0aGUgdG9wIHBvc2l0aW9uIG9mIHRoZSBzdWJncm91cHMgaGVyZSBmb3IgZXZlcnkgQmFja2dyb3VuZEl0ZW0sIGNhbGN1bGF0ZSB0aGUgdG9wIG9mIHRoZSBzdWJncm91cCBvbmNlIGluIEl0ZW1zZXRcblxuICAgICAgdmFyIGl0ZW1TdWJncm91cCA9IHRoaXMuZGF0YS5zdWJncm91cDtcbiAgICAgIHZhciBzdWJncm91cHMgPSB0aGlzLnBhcmVudC5zdWJncm91cHM7XG4gICAgICB2YXIgc3ViZ3JvdXBJbmRleCA9IHN1Ymdyb3Vwc1tpdGVtU3ViZ3JvdXBdLmluZGV4O1xuICAgICAgLy8gaWYgdGhlIG9yaWVudGF0aW9uIGlzIHRvcCwgd2UgbmVlZCB0byB0YWtlIHRoZSBkaWZmZXJlbmNlIGluIGhlaWdodCBpbnRvIGFjY291bnQuXG4gICAgICBpZiAob25Ub3AgPT0gdHJ1ZSkge1xuICAgICAgICAvLyB0aGUgZmlyc3Qgc3ViZ3JvdXAgd2lsbCBoYXZlIHRvIGFjY291bnQgZm9yIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSB0b3AgdG8gdGhlIGZpcnN0IGl0ZW0uXG4gICAgICAgIGhlaWdodCA9IHRoaXMucGFyZW50LnN1Ymdyb3Vwc1tpdGVtU3ViZ3JvdXBdLmhlaWdodCArIG1hcmdpbi5pdGVtLnZlcnRpY2FsO1xuICAgICAgICBoZWlnaHQgKz0gc3ViZ3JvdXBJbmRleCA9PSAwID8gbWFyZ2luLmF4aXMgLSAwLjUgKiBtYXJnaW4uaXRlbS52ZXJ0aWNhbCA6IDA7XG4gICAgICAgIHZhciBuZXdUb3AgPSB0aGlzLnBhcmVudC50b3A7XG4gICAgICAgIGZvciAodmFyIHN1Ymdyb3VwIGluIHN1Ymdyb3Vwcykge1xuICAgICAgICAgIGlmIChzdWJncm91cHMuaGFzT3duUHJvcGVydHkoc3ViZ3JvdXApKSB7XG4gICAgICAgICAgICBpZiAoc3ViZ3JvdXBzW3N1Ymdyb3VwXS52aXNpYmxlID09IHRydWUgJiYgc3ViZ3JvdXBzW3N1Ymdyb3VwXS5pbmRleCA8IHN1Ymdyb3VwSW5kZXgpIHtcbiAgICAgICAgICAgICAgbmV3VG9wICs9IHN1Ymdyb3Vwc1tzdWJncm91cF0uaGVpZ2h0ICsgbWFyZ2luLml0ZW0udmVydGljYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhlIG90aGVycyB3aWxsIGhhdmUgdG8gYmUgb2Zmc2V0IGRvd253YXJkcyB3aXRoIHRoaXMgc2FtZSBkaXN0YW5jZS5cbiAgICAgICAgbmV3VG9wICs9IHN1Ymdyb3VwSW5kZXggIT0gMCA/IG1hcmdpbi5heGlzIC0gMC41ICogbWFyZ2luLml0ZW0udmVydGljYWwgOiAwO1xuICAgICAgICB0aGlzLmRvbS5ib3guc3R5bGUudG9wID0gbmV3VG9wICsgJ3B4JztcbiAgICAgICAgdGhpcy5kb20uYm94LnN0eWxlLmJvdHRvbSA9ICcnO1xuICAgICAgfVxuICAgICAgLy8gYW5kIHdoZW4gdGhlIG9yaWVudGF0aW9uIGlzIGJvdHRvbTpcbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBuZXdUb3AgPSB0aGlzLnBhcmVudC50b3A7XG4gICAgICAgICAgdmFyIHRvdGFsSGVpZ2h0ID0gMDtcbiAgICAgICAgICBmb3IgKHZhciBzdWJncm91cCBpbiBzdWJncm91cHMpIHtcbiAgICAgICAgICAgIGlmIChzdWJncm91cHMuaGFzT3duUHJvcGVydHkoc3ViZ3JvdXApKSB7XG4gICAgICAgICAgICAgIGlmIChzdWJncm91cHNbc3ViZ3JvdXBdLnZpc2libGUgPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdIZWlnaHQgPSBzdWJncm91cHNbc3ViZ3JvdXBdLmhlaWdodCArIG1hcmdpbi5pdGVtLnZlcnRpY2FsO1xuICAgICAgICAgICAgICAgIHRvdGFsSGVpZ2h0ICs9IG5ld0hlaWdodDtcbiAgICAgICAgICAgICAgICBpZiAoc3ViZ3JvdXBzW3N1Ymdyb3VwXS5pbmRleCA+IHN1Ymdyb3VwSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgIG5ld1RvcCArPSBuZXdIZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGhlaWdodCA9IHRoaXMucGFyZW50LnN1Ymdyb3Vwc1tpdGVtU3ViZ3JvdXBdLmhlaWdodCArIG1hcmdpbi5pdGVtLnZlcnRpY2FsO1xuICAgICAgICAgIHRoaXMuZG9tLmJveC5zdHlsZS50b3AgPSB0aGlzLnBhcmVudC5oZWlnaHQgLSB0b3RhbEhlaWdodCArIG5ld1RvcCArICdweCc7XG4gICAgICAgICAgdGhpcy5kb20uYm94LnN0eWxlLmJvdHRvbSA9ICcnO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGFuZCBpbiB0aGUgY2FzZSBvZiBubyBzdWJncm91cHM6XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIHdlIHdhbnQgYmFja2dyb3VuZHMgd2l0aCBncm91cHMgdG8gb25seSBzaG93IGluIGdyb3Vwcy5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50IGluc3RhbmNlb2YgQmFja2dyb3VuZEdyb3VwKSB7XG4gICAgICAgICAgLy8gaWYgdGhlIGl0ZW0gaXMgbm90IGluIGEgZ3JvdXA6XG4gICAgICAgICAgaGVpZ2h0ID0gTWF0aC5tYXgodGhpcy5wYXJlbnQuaGVpZ2h0LCB0aGlzLnBhcmVudC5pdGVtU2V0LmJvZHkuZG9tUHJvcHMuY2VudGVyLmhlaWdodCwgdGhpcy5wYXJlbnQuaXRlbVNldC5ib2R5LmRvbVByb3BzLmNlbnRlckNvbnRhaW5lci5oZWlnaHQpO1xuICAgICAgICAgIHRoaXMuZG9tLmJveC5zdHlsZS50b3AgPSBvblRvcCA/ICcwJyA6ICcnO1xuICAgICAgICAgIHRoaXMuZG9tLmJveC5zdHlsZS5ib3R0b20gPSBvblRvcCA/ICcnIDogJzAnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhlaWdodCA9IHRoaXMucGFyZW50LmhlaWdodDtcbiAgICAgICAgICAvLyBzYW1lIGFsaWdubWVudCBmb3IgaXRlbXMgd2hlbiBvcmllbnRhdGlvbiBpcyB0b3Agb3IgYm90dG9tXG4gICAgICAgICAgdGhpcy5kb20uYm94LnN0eWxlLnRvcCA9IHRoaXMucGFyZW50LnRvcCArICdweCc7XG4gICAgICAgICAgdGhpcy5kb20uYm94LnN0eWxlLmJvdHRvbSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgdGhpcy5kb20uYm94LnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBCYWNrZ3JvdW5kSXRlbTtcblxuLyoqKi8gfSxcbi8qIDQ0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbiAgdmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuICB2YXIgQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSk7XG4gIHZhciBUaW1lU3RlcCA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpO1xuICB2YXIgRGF0ZVV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcbiAgdmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbiAgLyoqXG4gICAqIEEgaG9yaXpvbnRhbCB0aW1lIGF4aXNcbiAgICogQHBhcmFtIHt7ZG9tOiBPYmplY3QsIGRvbVByb3BzOiBPYmplY3QsIGVtaXR0ZXI6IEVtaXR0ZXIsIHJhbmdlOiBSYW5nZX19IGJvZHlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICAgICAgU2VlIFRpbWVBeGlzLnNldE9wdGlvbnMgZm9yIHRoZSBhdmFpbGFibGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5cbiAgICogQGNvbnN0cnVjdG9yIFRpbWVBeGlzXG4gICAqIEBleHRlbmRzIENvbXBvbmVudFxuICAgKi9cbiAgZnVuY3Rpb24gVGltZUF4aXMoYm9keSwgb3B0aW9ucykge1xuICAgIHRoaXMuZG9tID0ge1xuICAgICAgZm9yZWdyb3VuZDogbnVsbCxcbiAgICAgIGxpbmVzOiBbXSxcbiAgICAgIG1ham9yVGV4dHM6IFtdLFxuICAgICAgbWlub3JUZXh0czogW10sXG4gICAgICByZWR1bmRhbnQ6IHtcbiAgICAgICAgbGluZXM6IFtdLFxuICAgICAgICBtYWpvclRleHRzOiBbXSxcbiAgICAgICAgbWlub3JUZXh0czogW11cbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMucHJvcHMgPSB7XG4gICAgICByYW5nZToge1xuICAgICAgICBzdGFydDogMCxcbiAgICAgICAgZW5kOiAwLFxuICAgICAgICBtaW5pbXVtU3RlcDogMFxuICAgICAgfSxcbiAgICAgIGxpbmVUb3A6IDBcbiAgICB9O1xuXG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIG9yaWVudGF0aW9uOiB7XG4gICAgICAgIGF4aXM6ICdib3R0b20nXG4gICAgICB9LCAvLyBheGlzIG9yaWVudGF0aW9uOiAndG9wJyBvciAnYm90dG9tJ1xuICAgICAgc2hvd01pbm9yTGFiZWxzOiB0cnVlLFxuICAgICAgc2hvd01ham9yTGFiZWxzOiB0cnVlLFxuICAgICAgbWF4TWlub3JDaGFyczogNyxcbiAgICAgIGZvcm1hdDogVGltZVN0ZXAuRk9STUFULFxuICAgICAgbW9tZW50OiBtb21lbnQsXG4gICAgICB0aW1lQXhpczogbnVsbFxuICAgIH07XG4gICAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoe30sIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcblxuICAgIC8vIGNyZWF0ZSB0aGUgSFRNTCBET01cbiAgICB0aGlzLl9jcmVhdGUoKTtcblxuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIFRpbWVBeGlzLnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnQoKTtcblxuICAvKipcbiAgICogU2V0IG9wdGlvbnMgZm9yIHRoZSBUaW1lQXhpcy5cbiAgICogUGFyYW1ldGVycyB3aWxsIGJlIG1lcmdlZCBpbiBjdXJyZW50IG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zICBBdmFpbGFibGUgb3B0aW9uczpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmd9IFtvcmllbnRhdGlvbi5heGlzXVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAge2Jvb2xlYW59IFtzaG93TWlub3JMYWJlbHNdXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICB7Ym9vbGVhbn0gW3Nob3dNYWpvckxhYmVsc11cbiAgICovXG4gIFRpbWVBeGlzLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgLy8gY29weSBhbGwgb3B0aW9ucyB0aGF0IHdlIGtub3dcbiAgICAgIHV0aWwuc2VsZWN0aXZlRXh0ZW5kKFsnc2hvd01pbm9yTGFiZWxzJywgJ3Nob3dNYWpvckxhYmVscycsICdtYXhNaW5vckNoYXJzJywgJ2hpZGRlbkRhdGVzJywgJ3RpbWVBeGlzJywgJ21vbWVudCcsICdydGwnXSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgLy8gZGVlcCBjb3B5IHRoZSBmb3JtYXQgb3B0aW9uc1xuICAgICAgdXRpbC5zZWxlY3RpdmVEZWVwRXh0ZW5kKFsnZm9ybWF0J10sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgIGlmICgnb3JpZW50YXRpb24nIGluIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm9yaWVudGF0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5heGlzID0gb3B0aW9ucy5vcmllbnRhdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKG9wdGlvbnMub3JpZW50YXRpb24pID09PSAnb2JqZWN0JyAmJiAnYXhpcycgaW4gb3B0aW9ucy5vcmllbnRhdGlvbikge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5heGlzID0gb3B0aW9ucy5vcmllbnRhdGlvbi5heGlzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGFwcGx5IGxvY2FsZSB0byBtb21lbnQuanNcbiAgICAgIC8vIFRPRE86IG5vdCBzbyBuaWNlLCB0aGlzIGlzIGFwcGxpZWQgZ2xvYmFsbHkgdG8gbW9tZW50LmpzXG4gICAgICBpZiAoJ2xvY2FsZScgaW4gb3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIG1vbWVudC5sb2NhbGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBtb21lbnQuanMgMi44LjErXG4gICAgICAgICAgbW9tZW50LmxvY2FsZShvcHRpb25zLmxvY2FsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbW9tZW50Lmxhbmcob3B0aW9ucy5sb2NhbGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIEhUTUwgRE9NIGZvciB0aGUgVGltZUF4aXNcbiAgICovXG4gIFRpbWVBeGlzLnByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZG9tLmZvcmVncm91bmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmRvbS5iYWNrZ3JvdW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICB0aGlzLmRvbS5mb3JlZ3JvdW5kLmNsYXNzTmFtZSA9ICd2aXMtdGltZS1heGlzIHZpcy1mb3JlZ3JvdW5kJztcbiAgICB0aGlzLmRvbS5iYWNrZ3JvdW5kLmNsYXNzTmFtZSA9ICd2aXMtdGltZS1heGlzIHZpcy1iYWNrZ3JvdW5kJztcbiAgfTtcblxuICAvKipcbiAgICogRGVzdHJveSB0aGUgVGltZUF4aXNcbiAgICovXG4gIFRpbWVBeGlzLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHJlbW92ZSBmcm9tIERPTVxuICAgIGlmICh0aGlzLmRvbS5mb3JlZ3JvdW5kLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuZG9tLmZvcmVncm91bmQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbS5mb3JlZ3JvdW5kKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZG9tLmJhY2tncm91bmQucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5kb20uYmFja2dyb3VuZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLmJhY2tncm91bmQpO1xuICAgIH1cblxuICAgIHRoaXMuYm9keSA9IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcGFpbnQgdGhlIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGNvbXBvbmVudCBpcyByZXNpemVkXG4gICAqL1xuICBUaW1lQXhpcy5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGZvcmVncm91bmQgPSB0aGlzLmRvbS5mb3JlZ3JvdW5kO1xuICAgIHZhciBiYWNrZ3JvdW5kID0gdGhpcy5kb20uYmFja2dyb3VuZDtcblxuICAgIC8vIGRldGVybWluZSB0aGUgY29ycmVjdCBwYXJlbnQgRE9NIGVsZW1lbnQgKGRlcGVuZGluZyBvbiBvcHRpb24gb3JpZW50YXRpb24pXG4gICAgdmFyIHBhcmVudCA9IHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5heGlzID09ICd0b3AnID8gdGhpcy5ib2R5LmRvbS50b3AgOiB0aGlzLmJvZHkuZG9tLmJvdHRvbTtcbiAgICB2YXIgcGFyZW50Q2hhbmdlZCA9IGZvcmVncm91bmQucGFyZW50Tm9kZSAhPT0gcGFyZW50O1xuXG4gICAgLy8gY2FsY3VsYXRlIGNoYXJhY3RlciB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgdGhpcy5fY2FsY3VsYXRlQ2hhclNpemUoKTtcblxuICAgIC8vIFRPRE86IHJlY2FsY3VsYXRlIHNpemVzIG9ubHkgbmVlZGVkIHdoZW4gcGFyZW50IGlzIHJlc2l6ZWQgb3Igb3B0aW9ucyBpcyBjaGFuZ2VkXG4gICAgdmFyIHNob3dNaW5vckxhYmVscyA9IHRoaXMub3B0aW9ucy5zaG93TWlub3JMYWJlbHMgJiYgdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uLmF4aXMgIT09ICdub25lJztcbiAgICB2YXIgc2hvd01ham9yTGFiZWxzID0gdGhpcy5vcHRpb25zLnNob3dNYWpvckxhYmVscyAmJiB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uYXhpcyAhPT0gJ25vbmUnO1xuXG4gICAgLy8gZGV0ZXJtaW5lIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBlbGVtZW5zIGZvciB0aGUgYXhpc1xuICAgIHByb3BzLm1pbm9yTGFiZWxIZWlnaHQgPSBzaG93TWlub3JMYWJlbHMgPyBwcm9wcy5taW5vckNoYXJIZWlnaHQgOiAwO1xuICAgIHByb3BzLm1ham9yTGFiZWxIZWlnaHQgPSBzaG93TWFqb3JMYWJlbHMgPyBwcm9wcy5tYWpvckNoYXJIZWlnaHQgOiAwO1xuICAgIHByb3BzLmhlaWdodCA9IHByb3BzLm1pbm9yTGFiZWxIZWlnaHQgKyBwcm9wcy5tYWpvckxhYmVsSGVpZ2h0O1xuICAgIHByb3BzLndpZHRoID0gZm9yZWdyb3VuZC5vZmZzZXRXaWR0aDtcblxuICAgIHByb3BzLm1pbm9yTGluZUhlaWdodCA9IHRoaXMuYm9keS5kb21Qcm9wcy5yb290LmhlaWdodCAtIHByb3BzLm1ham9yTGFiZWxIZWlnaHQgLSAodGhpcy5vcHRpb25zLm9yaWVudGF0aW9uLmF4aXMgPT0gJ3RvcCcgPyB0aGlzLmJvZHkuZG9tUHJvcHMuYm90dG9tLmhlaWdodCA6IHRoaXMuYm9keS5kb21Qcm9wcy50b3AuaGVpZ2h0KTtcbiAgICBwcm9wcy5taW5vckxpbmVXaWR0aCA9IDE7IC8vIFRPRE86IHJlYWxseSBjYWxjdWxhdGUgd2lkdGhcbiAgICBwcm9wcy5tYWpvckxpbmVIZWlnaHQgPSBwcm9wcy5taW5vckxpbmVIZWlnaHQgKyBwcm9wcy5tYWpvckxhYmVsSGVpZ2h0O1xuICAgIHByb3BzLm1ham9yTGluZVdpZHRoID0gMTsgLy8gVE9ETzogcmVhbGx5IGNhbGN1bGF0ZSB3aWR0aFxuXG4gICAgLy8gIHRha2UgZm9yZWdyb3VuZCBhbmQgYmFja2dyb3VuZCBvZmZsaW5lIHdoaWxlIHVwZGF0aW5nIChpcyBhbG1vc3QgdHdpY2UgYXMgZmFzdClcbiAgICB2YXIgZm9yZWdyb3VuZE5leHRTaWJsaW5nID0gZm9yZWdyb3VuZC5uZXh0U2libGluZztcbiAgICB2YXIgYmFja2dyb3VuZE5leHRTaWJsaW5nID0gYmFja2dyb3VuZC5uZXh0U2libGluZztcbiAgICBmb3JlZ3JvdW5kLnBhcmVudE5vZGUgJiYgZm9yZWdyb3VuZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGZvcmVncm91bmQpO1xuICAgIGJhY2tncm91bmQucGFyZW50Tm9kZSAmJiBiYWNrZ3JvdW5kLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYmFja2dyb3VuZCk7XG5cbiAgICBmb3JlZ3JvdW5kLnN0eWxlLmhlaWdodCA9IHRoaXMucHJvcHMuaGVpZ2h0ICsgJ3B4JztcblxuICAgIHRoaXMuX3JlcGFpbnRMYWJlbHMoKTtcblxuICAgIC8vIHB1dCBET00gb25saW5lIGFnYWluIChhdCB0aGUgc2FtZSBwbGFjZSlcbiAgICBpZiAoZm9yZWdyb3VuZE5leHRTaWJsaW5nKSB7XG4gICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGZvcmVncm91bmQsIGZvcmVncm91bmROZXh0U2libGluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChmb3JlZ3JvdW5kKTtcbiAgICB9XG4gICAgaWYgKGJhY2tncm91bmROZXh0U2libGluZykge1xuICAgICAgdGhpcy5ib2R5LmRvbS5iYWNrZ3JvdW5kVmVydGljYWwuaW5zZXJ0QmVmb3JlKGJhY2tncm91bmQsIGJhY2tncm91bmROZXh0U2libGluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYm9keS5kb20uYmFja2dyb3VuZFZlcnRpY2FsLmFwcGVuZENoaWxkKGJhY2tncm91bmQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5faXNSZXNpemVkKCkgfHwgcGFyZW50Q2hhbmdlZDtcbiAgfTtcblxuICAvKipcbiAgICogUmVwYWludCBtYWpvciBhbmQgbWlub3IgdGV4dCBsYWJlbHMgYW5kIHZlcnRpY2FsIGdyaWQgbGluZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFRpbWVBeGlzLnByb3RvdHlwZS5fcmVwYWludExhYmVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3JpZW50YXRpb24gPSB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uYXhpcztcblxuICAgIC8vIGNhbGN1bGF0ZSByYW5nZSBhbmQgc3RlcCAoc3RlcCBzdWNoIHRoYXQgd2UgaGF2ZSBzcGFjZSBmb3IgNyBjaGFyYWN0ZXJzIHBlciBsYWJlbClcbiAgICB2YXIgc3RhcnQgPSB1dGlsLmNvbnZlcnQodGhpcy5ib2R5LnJhbmdlLnN0YXJ0LCAnTnVtYmVyJyk7XG4gICAgdmFyIGVuZCA9IHV0aWwuY29udmVydCh0aGlzLmJvZHkucmFuZ2UuZW5kLCAnTnVtYmVyJyk7XG4gICAgdmFyIHRpbWVMYWJlbHNpemUgPSB0aGlzLmJvZHkudXRpbC50b1RpbWUoKHRoaXMucHJvcHMubWlub3JDaGFyV2lkdGggfHwgMTApICogdGhpcy5vcHRpb25zLm1heE1pbm9yQ2hhcnMpLnZhbHVlT2YoKTtcbiAgICB2YXIgbWluaW11bVN0ZXAgPSB0aW1lTGFiZWxzaXplIC0gRGF0ZVV0aWwuZ2V0SGlkZGVuRHVyYXRpb25CZWZvcmUodGhpcy5vcHRpb25zLm1vbWVudCwgdGhpcy5ib2R5LmhpZGRlbkRhdGVzLCB0aGlzLmJvZHkucmFuZ2UsIHRpbWVMYWJlbHNpemUpO1xuICAgIG1pbmltdW1TdGVwIC09IHRoaXMuYm9keS51dGlsLnRvVGltZSgwKS52YWx1ZU9mKCk7XG5cbiAgICB2YXIgc3RlcCA9IG5ldyBUaW1lU3RlcChuZXcgRGF0ZShzdGFydCksIG5ldyBEYXRlKGVuZCksIG1pbmltdW1TdGVwLCB0aGlzLmJvZHkuaGlkZGVuRGF0ZXMpO1xuICAgIHN0ZXAuc2V0TW9tZW50KHRoaXMub3B0aW9ucy5tb21lbnQpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZm9ybWF0KSB7XG4gICAgICBzdGVwLnNldEZvcm1hdCh0aGlzLm9wdGlvbnMuZm9ybWF0KTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy50aW1lQXhpcykge1xuICAgICAgc3RlcC5zZXRTY2FsZSh0aGlzLm9wdGlvbnMudGltZUF4aXMpO1xuICAgIH1cbiAgICB0aGlzLnN0ZXAgPSBzdGVwO1xuXG4gICAgLy8gTW92ZSBhbGwgRE9NIGVsZW1lbnRzIHRvIGEgXCJyZWR1bmRhbnRcIiBsaXN0LCB3aGVyZSB0aGV5XG4gICAgLy8gY2FuIGJlIHBpY2tlZCBmb3IgcmUtdXNlLCBhbmQgY2xlYXIgdGhlIGxpc3RzIHdpdGggbGluZXMgYW5kIHRleHRzLlxuICAgIC8vIEF0IHRoZSBlbmQgb2YgdGhlIGZ1bmN0aW9uIF9yZXBhaW50TGFiZWxzLCBsZWZ0IG92ZXIgZWxlbWVudHMgd2lsbCBiZSBjbGVhbmVkIHVwXG4gICAgdmFyIGRvbSA9IHRoaXMuZG9tO1xuICAgIGRvbS5yZWR1bmRhbnQubGluZXMgPSBkb20ubGluZXM7XG4gICAgZG9tLnJlZHVuZGFudC5tYWpvclRleHRzID0gZG9tLm1ham9yVGV4dHM7XG4gICAgZG9tLnJlZHVuZGFudC5taW5vclRleHRzID0gZG9tLm1pbm9yVGV4dHM7XG4gICAgZG9tLmxpbmVzID0gW107XG4gICAgZG9tLm1ham9yVGV4dHMgPSBbXTtcbiAgICBkb20ubWlub3JUZXh0cyA9IFtdO1xuXG4gICAgdmFyIGN1cnJlbnQ7XG4gICAgdmFyIG5leHQ7XG4gICAgdmFyIHg7XG4gICAgdmFyIHhOZXh0O1xuICAgIHZhciBpc01ham9yLCBuZXh0SXNNYWpvcjtcbiAgICB2YXIgd2lkdGggPSAwLFxuICAgICAgICBwcmV2V2lkdGg7XG4gICAgdmFyIGxpbmU7XG4gICAgdmFyIGxhYmVsTWlub3I7XG4gICAgdmFyIHhGaXJzdE1ham9yTGFiZWwgPSB1bmRlZmluZWQ7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgTUFYID0gMTAwMDtcbiAgICB2YXIgY2xhc3NOYW1lO1xuXG4gICAgc3RlcC5zdGFydCgpO1xuICAgIG5leHQgPSBzdGVwLmdldEN1cnJlbnQoKTtcbiAgICB4TmV4dCA9IHRoaXMuYm9keS51dGlsLnRvU2NyZWVuKG5leHQpO1xuICAgIHdoaWxlIChzdGVwLmhhc05leHQoKSAmJiBjb3VudCA8IE1BWCkge1xuICAgICAgY291bnQrKztcblxuICAgICAgaXNNYWpvciA9IHN0ZXAuaXNNYWpvcigpO1xuICAgICAgY2xhc3NOYW1lID0gc3RlcC5nZXRDbGFzc05hbWUoKTtcbiAgICAgIGxhYmVsTWlub3IgPSBzdGVwLmdldExhYmVsTWlub3IoKTtcblxuICAgICAgY3VycmVudCA9IG5leHQ7XG4gICAgICB4ID0geE5leHQ7XG5cbiAgICAgIHN0ZXAubmV4dCgpO1xuICAgICAgbmV4dCA9IHN0ZXAuZ2V0Q3VycmVudCgpO1xuICAgICAgbmV4dElzTWFqb3IgPSBzdGVwLmlzTWFqb3IoKTtcbiAgICAgIHhOZXh0ID0gdGhpcy5ib2R5LnV0aWwudG9TY3JlZW4obmV4dCk7XG5cbiAgICAgIHByZXZXaWR0aCA9IHdpZHRoO1xuICAgICAgd2lkdGggPSB4TmV4dCAtIHg7XG4gICAgICB2YXIgc2hvd01pbm9yR3JpZCA9IHdpZHRoID49IHByZXZXaWR0aCAqIDAuNDsgLy8gcHJldmVudCBkaXNwbGF5aW5nIG9mIHRoZSAzMXRoIG9mIHRoZSBtb250aCBvbiBhIHNjYWxlIG9mIDUgZGF5c1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNob3dNaW5vckxhYmVscyAmJiBzaG93TWlub3JHcmlkKSB7XG4gICAgICAgIHZhciBsYWJlbCA9IHRoaXMuX3JlcGFpbnRNaW5vclRleHQoeCwgbGFiZWxNaW5vciwgb3JpZW50YXRpb24sIGNsYXNzTmFtZSk7XG4gICAgICAgIGxhYmVsLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnOyAvLyBzZXQgd2lkdGggdG8gcHJldmVudCBvdmVyZmxvd1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNNYWpvciAmJiB0aGlzLm9wdGlvbnMuc2hvd01ham9yTGFiZWxzKSB7XG4gICAgICAgIGlmICh4ID4gMCkge1xuICAgICAgICAgIGlmICh4Rmlyc3RNYWpvckxhYmVsID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgeEZpcnN0TWFqb3JMYWJlbCA9IHg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxhYmVsID0gdGhpcy5fcmVwYWludE1ham9yVGV4dCh4LCBzdGVwLmdldExhYmVsTWFqb3IoKSwgb3JpZW50YXRpb24sIGNsYXNzTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGluZSA9IHRoaXMuX3JlcGFpbnRNYWpvckxpbmUoeCwgd2lkdGgsIG9yaWVudGF0aW9uLCBjbGFzc05hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbWlub3IgbGluZVxuICAgICAgICBpZiAoc2hvd01pbm9yR3JpZCkge1xuICAgICAgICAgIGxpbmUgPSB0aGlzLl9yZXBhaW50TWlub3JMaW5lKHgsIHdpZHRoLCBvcmllbnRhdGlvbiwgY2xhc3NOYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobGluZSkge1xuICAgICAgICAgICAgLy8gYWRqdXN0IHRoZSB3aWR0aCBvZiB0aGUgcHJldmlvdXMgZ3JpZFxuICAgICAgICAgICAgbGluZS5zdHlsZS53aWR0aCA9IHBhcnNlSW50KGxpbmUuc3R5bGUud2lkdGgpICsgd2lkdGggKyAncHgnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb3VudCA9PT0gTUFYICYmICF3YXJuZWRGb3JPdmVyZmxvdykge1xuICAgICAgY29uc29sZS53YXJuKCdTb21ldGhpbmcgaXMgd3Jvbmcgd2l0aCB0aGUgVGltZWxpbmUgc2NhbGUuIExpbWl0ZWQgZHJhd2luZyBvZiBncmlkIGxpbmVzIHRvICcgKyBNQVggKyAnIGxpbmVzLicpO1xuICAgICAgd2FybmVkRm9yT3ZlcmZsb3cgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBhIG1ham9yIGxhYmVsIG9uIHRoZSBsZWZ0IHdoZW4gbmVlZGVkXG4gICAgaWYgKHRoaXMub3B0aW9ucy5zaG93TWFqb3JMYWJlbHMpIHtcbiAgICAgIHZhciBsZWZ0VGltZSA9IHRoaXMuYm9keS51dGlsLnRvVGltZSgwKSxcbiAgICAgICAgICBsZWZ0VGV4dCA9IHN0ZXAuZ2V0TGFiZWxNYWpvcihsZWZ0VGltZSksXG4gICAgICAgICAgd2lkdGhUZXh0ID0gbGVmdFRleHQubGVuZ3RoICogKHRoaXMucHJvcHMubWFqb3JDaGFyV2lkdGggfHwgMTApICsgMTA7IC8vIHVwcGVyIGJvdW5kIGVzdGltYXRpb25cblxuICAgICAgaWYgKHhGaXJzdE1ham9yTGFiZWwgPT0gdW5kZWZpbmVkIHx8IHdpZHRoVGV4dCA8IHhGaXJzdE1ham9yTGFiZWwpIHtcbiAgICAgICAgdGhpcy5fcmVwYWludE1ham9yVGV4dCgwLCBsZWZ0VGV4dCwgb3JpZW50YXRpb24sIGNsYXNzTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2xlYW51cCBsZWZ0b3ZlciBET00gZWxlbWVudHMgZnJvbSB0aGUgcmVkdW5kYW50IGxpc3RcbiAgICB1dGlsLmZvckVhY2godGhpcy5kb20ucmVkdW5kYW50LCBmdW5jdGlvbiAoYXJyKSB7XG4gICAgICB3aGlsZSAoYXJyLmxlbmd0aCkge1xuICAgICAgICB2YXIgZWxlbSA9IGFyci5wb3AoKTtcbiAgICAgICAgaWYgKGVsZW0gJiYgZWxlbS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgZWxlbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG1pbm9yIGxhYmVsIGZvciB0aGUgYXhpcyBhdCBwb3NpdGlvbiB4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcmllbnRhdGlvbiAgIFwidG9wXCIgb3IgXCJib3R0b21cIiAoZGVmYXVsdClcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZVxuICAgKiBAcmV0dXJuIHtFbGVtZW50fSBSZXR1cm5zIHRoZSBIVE1MIGVsZW1lbnQgb2YgdGhlIGNyZWF0ZWQgbGFiZWxcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFRpbWVBeGlzLnByb3RvdHlwZS5fcmVwYWludE1pbm9yVGV4dCA9IGZ1bmN0aW9uICh4LCB0ZXh0LCBvcmllbnRhdGlvbiwgY2xhc3NOYW1lKSB7XG4gICAgLy8gcmV1c2UgcmVkdW5kYW50IGxhYmVsXG4gICAgdmFyIGxhYmVsID0gdGhpcy5kb20ucmVkdW5kYW50Lm1pbm9yVGV4dHMuc2hpZnQoKTtcblxuICAgIGlmICghbGFiZWwpIHtcbiAgICAgIC8vIGNyZWF0ZSBuZXcgbGFiZWxcbiAgICAgIHZhciBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgICAgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGxhYmVsLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgICAgdGhpcy5kb20uZm9yZWdyb3VuZC5hcHBlbmRDaGlsZChsYWJlbCk7XG4gICAgfVxuICAgIHRoaXMuZG9tLm1pbm9yVGV4dHMucHVzaChsYWJlbCk7XG5cbiAgICBsYWJlbC5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZSA9IHRleHQ7XG5cbiAgICBsYWJlbC5zdHlsZS50b3AgPSBvcmllbnRhdGlvbiA9PSAndG9wJyA/IHRoaXMucHJvcHMubWFqb3JMYWJlbEhlaWdodCArICdweCcgOiAnMCc7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgbGFiZWwuc3R5bGUubGVmdCA9IFwiXCI7XG4gICAgICBsYWJlbC5zdHlsZS5yaWdodCA9IHggKyAncHgnO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYWJlbC5zdHlsZS5sZWZ0ID0geCArICdweCc7XG4gICAgfTtcbiAgICBsYWJlbC5jbGFzc05hbWUgPSAndmlzLXRleHQgdmlzLW1pbm9yICcgKyBjbGFzc05hbWU7XG4gICAgLy9sYWJlbC50aXRsZSA9IHRpdGxlOyAgLy8gVE9ETzogdGhpcyBpcyBhIGhlYXZ5IG9wZXJhdGlvblxuXG4gICAgcmV0dXJuIGxhYmVsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBNYWpvciBsYWJlbCBmb3IgdGhlIGF4aXMgYXQgcG9zaXRpb24geFxuICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZW50YXRpb24gICBcInRvcFwiIG9yIFwiYm90dG9tXCIgKGRlZmF1bHQpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWVcbiAgICogQHJldHVybiB7RWxlbWVudH0gUmV0dXJucyB0aGUgSFRNTCBlbGVtZW50IG9mIHRoZSBjcmVhdGVkIGxhYmVsXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBUaW1lQXhpcy5wcm90b3R5cGUuX3JlcGFpbnRNYWpvclRleHQgPSBmdW5jdGlvbiAoeCwgdGV4dCwgb3JpZW50YXRpb24sIGNsYXNzTmFtZSkge1xuICAgIC8vIHJldXNlIHJlZHVuZGFudCBsYWJlbFxuICAgIHZhciBsYWJlbCA9IHRoaXMuZG9tLnJlZHVuZGFudC5tYWpvclRleHRzLnNoaWZ0KCk7XG5cbiAgICBpZiAoIWxhYmVsKSB7XG4gICAgICAvLyBjcmVhdGUgbGFiZWxcbiAgICAgIHZhciBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCk7XG4gICAgICBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgbGFiZWwuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgICB0aGlzLmRvbS5mb3JlZ3JvdW5kLmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgICB9XG4gICAgdGhpcy5kb20ubWFqb3JUZXh0cy5wdXNoKGxhYmVsKTtcblxuICAgIGxhYmVsLmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlID0gdGV4dDtcbiAgICBsYWJlbC5jbGFzc05hbWUgPSAndmlzLXRleHQgdmlzLW1ham9yICcgKyBjbGFzc05hbWU7XG4gICAgLy9sYWJlbC50aXRsZSA9IHRpdGxlOyAvLyBUT0RPOiB0aGlzIGlzIGEgaGVhdnkgb3BlcmF0aW9uXG5cbiAgICBsYWJlbC5zdHlsZS50b3AgPSBvcmllbnRhdGlvbiA9PSAndG9wJyA/ICcwJyA6IHRoaXMucHJvcHMubWlub3JMYWJlbEhlaWdodCArICdweCc7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgIGxhYmVsLnN0eWxlLmxlZnQgPSBcIlwiO1xuICAgICAgbGFiZWwuc3R5bGUucmlnaHQgPSB4ICsgJ3B4JztcbiAgICB9IGVsc2Uge1xuICAgICAgbGFiZWwuc3R5bGUubGVmdCA9IHggKyAncHgnO1xuICAgIH07XG5cbiAgICByZXR1cm4gbGFiZWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG1pbm9yIGxpbmUgZm9yIHRoZSBheGlzIGF0IHBvc2l0aW9uIHhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcmllbnRhdGlvbiAgIFwidG9wXCIgb3IgXCJib3R0b21cIiAoZGVmYXVsdClcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZVxuICAgKiBAcmV0dXJuIHtFbGVtZW50fSBSZXR1cm5zIHRoZSBjcmVhdGVkIGxpbmVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFRpbWVBeGlzLnByb3RvdHlwZS5fcmVwYWludE1pbm9yTGluZSA9IGZ1bmN0aW9uICh4LCB3aWR0aCwgb3JpZW50YXRpb24sIGNsYXNzTmFtZSkge1xuICAgIC8vIHJldXNlIHJlZHVuZGFudCBsaW5lXG4gICAgdmFyIGxpbmUgPSB0aGlzLmRvbS5yZWR1bmRhbnQubGluZXMuc2hpZnQoKTtcbiAgICBpZiAoIWxpbmUpIHtcbiAgICAgIC8vIGNyZWF0ZSB2ZXJ0aWNhbCBsaW5lXG4gICAgICBsaW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLmRvbS5iYWNrZ3JvdW5kLmFwcGVuZENoaWxkKGxpbmUpO1xuICAgIH1cbiAgICB0aGlzLmRvbS5saW5lcy5wdXNoKGxpbmUpO1xuXG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICBpZiAob3JpZW50YXRpb24gPT0gJ3RvcCcpIHtcbiAgICAgIGxpbmUuc3R5bGUudG9wID0gcHJvcHMubWFqb3JMYWJlbEhlaWdodCArICdweCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmUuc3R5bGUudG9wID0gdGhpcy5ib2R5LmRvbVByb3BzLnRvcC5oZWlnaHQgKyAncHgnO1xuICAgIH1cbiAgICBsaW5lLnN0eWxlLmhlaWdodCA9IHByb3BzLm1pbm9yTGluZUhlaWdodCArICdweCc7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgIGxpbmUuc3R5bGUubGVmdCA9IFwiXCI7XG4gICAgICBsaW5lLnN0eWxlLnJpZ2h0ID0geCAtIHByb3BzLm1pbm9yTGluZVdpZHRoIC8gMiArICdweCc7XG4gICAgICBsaW5lLmNsYXNzTmFtZSA9ICd2aXMtZ3JpZCB2aXMtdmVydGljYWwtcnRsIHZpcy1taW5vciAnICsgY2xhc3NOYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lLnN0eWxlLmxlZnQgPSB4IC0gcHJvcHMubWlub3JMaW5lV2lkdGggLyAyICsgJ3B4JztcbiAgICAgIGxpbmUuY2xhc3NOYW1lID0gJ3Zpcy1ncmlkIHZpcy12ZXJ0aWNhbCB2aXMtbWlub3IgJyArIGNsYXNzTmFtZTtcbiAgICB9O1xuICAgIGxpbmUuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG5cbiAgICByZXR1cm4gbGluZTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgTWFqb3IgbGluZSBmb3IgdGhlIGF4aXMgYXQgcG9zaXRpb24geFxuICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWVudGF0aW9uICAgXCJ0b3BcIiBvciBcImJvdHRvbVwiIChkZWZhdWx0KVxuICAgKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9IFJldHVybnMgdGhlIGNyZWF0ZWQgbGluZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgVGltZUF4aXMucHJvdG90eXBlLl9yZXBhaW50TWFqb3JMaW5lID0gZnVuY3Rpb24gKHgsIHdpZHRoLCBvcmllbnRhdGlvbiwgY2xhc3NOYW1lKSB7XG4gICAgLy8gcmV1c2UgcmVkdW5kYW50IGxpbmVcbiAgICB2YXIgbGluZSA9IHRoaXMuZG9tLnJlZHVuZGFudC5saW5lcy5zaGlmdCgpO1xuICAgIGlmICghbGluZSkge1xuICAgICAgLy8gY3JlYXRlIHZlcnRpY2FsIGxpbmVcbiAgICAgIGxpbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMuZG9tLmJhY2tncm91bmQuYXBwZW5kQ2hpbGQobGluZSk7XG4gICAgfVxuICAgIHRoaXMuZG9tLmxpbmVzLnB1c2gobGluZSk7XG5cbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIGlmIChvcmllbnRhdGlvbiA9PSAndG9wJykge1xuICAgICAgbGluZS5zdHlsZS50b3AgPSAnMCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmUuc3R5bGUudG9wID0gdGhpcy5ib2R5LmRvbVByb3BzLnRvcC5oZWlnaHQgKyAncHgnO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMucnRsKSB7XG4gICAgICBsaW5lLnN0eWxlLmxlZnQgPSBcIlwiO1xuICAgICAgbGluZS5zdHlsZS5yaWdodCA9IHggLSBwcm9wcy5tYWpvckxpbmVXaWR0aCAvIDIgKyAncHgnO1xuICAgICAgbGluZS5jbGFzc05hbWUgPSAndmlzLWdyaWQgdmlzLXZlcnRpY2FsLXJ0bCB2aXMtbWFqb3IgJyArIGNsYXNzTmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZS5zdHlsZS5sZWZ0ID0geCAtIHByb3BzLm1ham9yTGluZVdpZHRoIC8gMiArICdweCc7XG4gICAgICBsaW5lLmNsYXNzTmFtZSA9ICd2aXMtZ3JpZCB2aXMtdmVydGljYWwgdmlzLW1ham9yICcgKyBjbGFzc05hbWU7XG4gICAgfVxuXG4gICAgbGluZS5zdHlsZS5oZWlnaHQgPSBwcm9wcy5tYWpvckxpbmVIZWlnaHQgKyAncHgnO1xuICAgIGxpbmUuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG5cbiAgICByZXR1cm4gbGluZTtcbiAgfTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHRoZSBzaXplIG9mIHRleHQgb24gdGhlIGF4aXMgKGJvdGggbWFqb3IgYW5kIG1pbm9yIGF4aXMpLlxuICAgKiBUaGUgc2l6ZSBpcyBjYWxjdWxhdGVkIG9ubHkgb25jZSBhbmQgdGhlbiBjYWNoZWQgaW4gdGhpcy5wcm9wcy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFRpbWVBeGlzLnByb3RvdHlwZS5fY2FsY3VsYXRlQ2hhclNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gTm90ZTogV2UgY2FsY3VsYXRlIGNoYXIgc2l6ZSB3aXRoIGV2ZXJ5IHJlZHJhdy4gU2l6ZSBtYXkgY2hhbmdlLCBmb3JcbiAgICAvLyBleGFtcGxlIHdoZW4gYW55IG9mIHRoZSB0aW1lbGluZXMgcGFyZW50cyBoYWQgZGlzcGxheTpub25lIGZvciBleGFtcGxlLlxuXG4gICAgLy8gZGV0ZXJtaW5lIHRoZSBjaGFyIHdpZHRoIGFuZCBoZWlnaHQgb24gdGhlIG1pbm9yIGF4aXNcbiAgICBpZiAoIXRoaXMuZG9tLm1lYXN1cmVDaGFyTWlub3IpIHtcbiAgICAgIHRoaXMuZG9tLm1lYXN1cmVDaGFyTWlub3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcbiAgICAgIHRoaXMuZG9tLm1lYXN1cmVDaGFyTWlub3IuY2xhc3NOYW1lID0gJ3Zpcy10ZXh0IHZpcy1taW5vciB2aXMtbWVhc3VyZSc7XG4gICAgICB0aGlzLmRvbS5tZWFzdXJlQ2hhck1pbm9yLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcblxuICAgICAgdGhpcy5kb20ubWVhc3VyZUNoYXJNaW5vci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnMCcpKTtcbiAgICAgIHRoaXMuZG9tLmZvcmVncm91bmQuYXBwZW5kQ2hpbGQodGhpcy5kb20ubWVhc3VyZUNoYXJNaW5vcik7XG4gICAgfVxuICAgIHRoaXMucHJvcHMubWlub3JDaGFySGVpZ2h0ID0gdGhpcy5kb20ubWVhc3VyZUNoYXJNaW5vci5jbGllbnRIZWlnaHQ7XG4gICAgdGhpcy5wcm9wcy5taW5vckNoYXJXaWR0aCA9IHRoaXMuZG9tLm1lYXN1cmVDaGFyTWlub3IuY2xpZW50V2lkdGg7XG5cbiAgICAvLyBkZXRlcm1pbmUgdGhlIGNoYXIgd2lkdGggYW5kIGhlaWdodCBvbiB0aGUgbWFqb3IgYXhpc1xuICAgIGlmICghdGhpcy5kb20ubWVhc3VyZUNoYXJNYWpvcikge1xuICAgICAgdGhpcy5kb20ubWVhc3VyZUNoYXJNYWpvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICAgICAgdGhpcy5kb20ubWVhc3VyZUNoYXJNYWpvci5jbGFzc05hbWUgPSAndmlzLXRleHQgdmlzLW1ham9yIHZpcy1tZWFzdXJlJztcbiAgICAgIHRoaXMuZG9tLm1lYXN1cmVDaGFyTWFqb3Iuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuXG4gICAgICB0aGlzLmRvbS5tZWFzdXJlQ2hhck1ham9yLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcwJykpO1xuICAgICAgdGhpcy5kb20uZm9yZWdyb3VuZC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5tZWFzdXJlQ2hhck1ham9yKTtcbiAgICB9XG4gICAgdGhpcy5wcm9wcy5tYWpvckNoYXJIZWlnaHQgPSB0aGlzLmRvbS5tZWFzdXJlQ2hhck1ham9yLmNsaWVudEhlaWdodDtcbiAgICB0aGlzLnByb3BzLm1ham9yQ2hhcldpZHRoID0gdGhpcy5kb20ubWVhc3VyZUNoYXJNYWpvci5jbGllbnRXaWR0aDtcbiAgfTtcblxuICB2YXIgd2FybmVkRm9yT3ZlcmZsb3cgPSBmYWxzZTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFRpbWVBeGlzO1xuXG4vKioqLyB9LFxuLyogNDUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIga2V5Y2hhcm0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcbiAgdmFyIEVtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcbiAgdmFyIEhhbW1lciA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbiAgLyoqXG4gICAqIFR1cm4gYW4gZWxlbWVudCBpbnRvIGFuIGNsaWNrVG9Vc2UgZWxlbWVudC5cbiAgICogV2hlbiBub3QgYWN0aXZlLCB0aGUgZWxlbWVudCBoYXMgYSB0cmFuc3BhcmVudCBvdmVybGF5LiBXaGVuIHRoZSBvdmVybGF5IGlzXG4gICAqIGNsaWNrZWQsIHRoZSBtb2RlIGlzIGNoYW5nZWQgdG8gYWN0aXZlLlxuICAgKiBXaGVuIGFjdGl2ZSwgdGhlIGVsZW1lbnQgaXMgZGlzcGxheWVkIHdpdGggYSBibHVlIGJvcmRlciBhcm91bmQgaXQsIGFuZFxuICAgKiB0aGUgaW50ZXJhY3RpdmUgY29udGVudHMgb2YgdGhlIGVsZW1lbnQgY2FuIGJlIHVzZWQuIFdoZW4gY2xpY2tlZCBvdXRzaWRlXG4gICAqIHRoZSBlbGVtZW50LCB0aGUgZWxlbWVudHMgbW9kZSBpcyBjaGFuZ2VkIHRvIGluYWN0aXZlLlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRhaW5lclxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIEFjdGl2YXRvcihjb250YWluZXIpIHtcbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5kb20gPSB7XG4gICAgICBjb250YWluZXI6IGNvbnRhaW5lclxuICAgIH07XG5cbiAgICB0aGlzLmRvbS5vdmVybGF5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5kb20ub3ZlcmxheS5jbGFzc05hbWUgPSAndmlzLW92ZXJsYXknO1xuXG4gICAgdGhpcy5kb20uY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZG9tLm92ZXJsYXkpO1xuXG4gICAgdGhpcy5oYW1tZXIgPSBIYW1tZXIodGhpcy5kb20ub3ZlcmxheSk7XG4gICAgdGhpcy5oYW1tZXIub24oJ3RhcCcsIHRoaXMuX29uVGFwT3ZlcmxheS5iaW5kKHRoaXMpKTtcblxuICAgIC8vIGJsb2NrIGFsbCB0b3VjaCBldmVudHMgKGV4Y2VwdCB0YXApXG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgZXZlbnRzID0gWyd0YXAnLCAnZG91YmxldGFwJywgJ3ByZXNzJywgJ3BpbmNoJywgJ3BhbicsICdwYW5zdGFydCcsICdwYW5tb3ZlJywgJ3BhbmVuZCddO1xuICAgIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgbWUuaGFtbWVyLm9uKGV2ZW50LCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIGF0dGFjaCBhIGNsaWNrIGV2ZW50IHRvIHRoZSB3aW5kb3csIGluIG9yZGVyIHRvIGRlYWN0aXZhdGUgd2hlbiBjbGlja2luZyBvdXRzaWRlIHRoZSB0aW1lbGluZVxuICAgIGlmIChkb2N1bWVudCAmJiBkb2N1bWVudC5ib2R5KSB7XG4gICAgICB0aGlzLm9uQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKCFfaGFzUGFyZW50KGV2ZW50LnRhcmdldCwgY29udGFpbmVyKSkge1xuICAgICAgICAgIG1lLmRlYWN0aXZhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uQ2xpY2spO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmtleWNoYXJtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMua2V5Y2hhcm0uZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLmtleWNoYXJtID0ga2V5Y2hhcm0oKTtcblxuICAgIC8vIGtleWNoYXJtIGxpc3RlbmVyIG9ubHkgYm91bmRlZCB3aGVuIGFjdGl2ZSlcbiAgICB0aGlzLmVzY0xpc3RlbmVyID0gdGhpcy5kZWFjdGl2YXRlLmJpbmQodGhpcyk7XG4gIH1cblxuICAvLyB0dXJuIGludG8gYW4gZXZlbnQgZW1pdHRlclxuICBFbWl0dGVyKEFjdGl2YXRvci5wcm90b3R5cGUpO1xuXG4gIC8vIFRoZSBjdXJyZW50bHkgYWN0aXZlIGFjdGl2YXRvclxuICBBY3RpdmF0b3IuY3VycmVudCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIERlc3Ryb3kgdGhlIGFjdGl2YXRvci4gQ2xlYW5zIHVwIGFsbCBjcmVhdGVkIERPTSBhbmQgZXZlbnQgbGlzdGVuZXJzXG4gICAqL1xuICBBY3RpdmF0b3IucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kZWFjdGl2YXRlKCk7XG5cbiAgICAvLyByZW1vdmUgZG9tXG4gICAgdGhpcy5kb20ub3ZlcmxheS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLm92ZXJsYXkpO1xuXG4gICAgLy8gcmVtb3ZlIGdsb2JhbCBldmVudCBsaXN0ZW5lclxuICAgIGlmICh0aGlzLm9uQ2xpY2spIHtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uQ2xpY2spO1xuICAgIH1cblxuICAgIC8vIGNsZWFudXAgaGFtbWVyIGluc3RhbmNlc1xuICAgIHRoaXMuaGFtbWVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmhhbW1lciA9IG51bGw7XG4gICAgLy8gRklYTUU6IGNsZWFuaW5nIHVwIGhhbW1lciBpbnN0YW5jZXMgZG9lc24ndCB3b3JrIChUaW1lbGluZSBub3QgcmVtb3ZlZCBmcm9tIG1lbW9yeSlcbiAgfTtcblxuICAvKipcbiAgICogQWN0aXZhdGUgdGhlIGVsZW1lbnRcbiAgICogT3ZlcmxheSBpcyBoaWRkZW4sIGVsZW1lbnQgaXMgZGVjb3JhdGVkIHdpdGggYSBibHVlIHNoYWRvdyBib3JkZXJcbiAgICovXG4gIEFjdGl2YXRvci5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gd2UgYWxsb3cgb25seSBvbmUgYWN0aXZlIGFjdGl2YXRvciBhdCBhIHRpbWVcbiAgICBpZiAoQWN0aXZhdG9yLmN1cnJlbnQpIHtcbiAgICAgIEFjdGl2YXRvci5jdXJyZW50LmRlYWN0aXZhdGUoKTtcbiAgICB9XG4gICAgQWN0aXZhdG9yLmN1cnJlbnQgPSB0aGlzO1xuXG4gICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMuZG9tLm92ZXJsYXkuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB1dGlsLmFkZENsYXNzTmFtZSh0aGlzLmRvbS5jb250YWluZXIsICd2aXMtYWN0aXZlJyk7XG5cbiAgICB0aGlzLmVtaXQoJ2NoYW5nZScpO1xuICAgIHRoaXMuZW1pdCgnYWN0aXZhdGUnKTtcblxuICAgIC8vIHVnbHkgaGFjazogYmluZCBFU0MgYWZ0ZXIgZW1pdHRpbmcgdGhlIGV2ZW50cywgYXMgdGhlIE5ldHdvcmsgcmViaW5kcyBhbGxcbiAgICAvLyBrZXlib2FyZCBldmVudHMgb24gYSAnY2hhbmdlJyBldmVudFxuICAgIHRoaXMua2V5Y2hhcm0uYmluZCgnZXNjJywgdGhpcy5lc2NMaXN0ZW5lcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlYWN0aXZhdGUgdGhlIGVsZW1lbnRcbiAgICogT3ZlcmxheSBpcyBkaXNwbGF5ZWQgb24gdG9wIG9mIHRoZSBlbGVtZW50XG4gICAqL1xuICBBY3RpdmF0b3IucHJvdG90eXBlLmRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLmRvbS5vdmVybGF5LnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICB1dGlsLnJlbW92ZUNsYXNzTmFtZSh0aGlzLmRvbS5jb250YWluZXIsICd2aXMtYWN0aXZlJyk7XG4gICAgdGhpcy5rZXljaGFybS51bmJpbmQoJ2VzYycsIHRoaXMuZXNjTGlzdGVuZXIpO1xuXG4gICAgdGhpcy5lbWl0KCdjaGFuZ2UnKTtcbiAgICB0aGlzLmVtaXQoJ2RlYWN0aXZhdGUnKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGEgdGFwIGV2ZW50OiBhY3RpdmF0ZSB0aGUgY29udGFpbmVyXG4gICAqIEBwYXJhbSBldmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQWN0aXZhdG9yLnByb3RvdHlwZS5fb25UYXBPdmVybGF5ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYWN0aXZhdGUgdGhlIGNvbnRhaW5lclxuICAgIHRoaXMuYWN0aXZhdGUoKTtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfTtcblxuICAvKipcbiAgICogVGVzdCB3aGV0aGVyIHRoZSBlbGVtZW50IGhhcyB0aGUgcmVxdWVzdGVkIHBhcmVudCBlbGVtZW50IHNvbWV3aGVyZSBpblxuICAgKiBpdHMgY2hhaW4gb2YgcGFyZW50IG5vZGVzLlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIHdoZW4gdGhlIHBhcmVudCBpcyBmb3VuZCBzb21ld2hlcmUgaW4gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICBjaGFpbiBvZiBwYXJlbnQgbm9kZXMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfaGFzUGFyZW50KGVsZW1lbnQsIHBhcmVudCkge1xuICAgIHdoaWxlIChlbGVtZW50KSB7XG4gICAgICBpZiAoZWxlbWVudCA9PT0gcGFyZW50KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBBY3RpdmF0b3I7XG5cbi8qKiovIH0sXG4vKiA0NiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBIYW1tZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcbiAgdmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuICB2YXIgQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSk7XG4gIHZhciBtb21lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuICB2YXIgbG9jYWxlcyA9IF9fd2VicGFja19yZXF1aXJlX18oNDcpO1xuXG4gIC8qKlxuICAgKiBBIGN1c3RvbSB0aW1lIGJhclxuICAgKiBAcGFyYW0ge3tyYW5nZTogUmFuZ2UsIGRvbTogT2JqZWN0fX0gYm9keVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgICAgICBBdmFpbGFibGUgcGFyYW1ldGVyczpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge251bWJlciB8IHN0cmluZ30gaWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3N0cmluZ30gbG9jYWxlc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nfSBsb2NhbGVcbiAgICogQGNvbnN0cnVjdG9yIEN1c3RvbVRpbWVcbiAgICogQGV4dGVuZHMgQ29tcG9uZW50XG4gICAqL1xuXG4gIGZ1bmN0aW9uIEN1c3RvbVRpbWUoYm9keSwgb3B0aW9ucykge1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG5cbiAgICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgbW9tZW50OiBtb21lbnQsXG4gICAgICBsb2NhbGVzOiBsb2NhbGVzLFxuICAgICAgbG9jYWxlOiAnZW4nLFxuICAgICAgaWQ6IHVuZGVmaW5lZCxcbiAgICAgIHRpdGxlOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMudGltZSkge1xuICAgICAgdGhpcy5jdXN0b21UaW1lID0gb3B0aW9ucy50aW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN1c3RvbVRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgIH1cblxuICAgIHRoaXMuZXZlbnRQYXJhbXMgPSB7fTsgLy8gc3RvcmVzIHN0YXRlIHBhcmFtZXRlcnMgd2hpbGUgZHJhZ2dpbmcgdGhlIGJhclxuXG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgLy8gY3JlYXRlIHRoZSBET01cbiAgICB0aGlzLl9jcmVhdGUoKTtcbiAgfVxuXG4gIEN1c3RvbVRpbWUucHJvdG90eXBlID0gbmV3IENvbXBvbmVudCgpO1xuXG4gIC8qKlxuICAgKiBTZXQgb3B0aW9ucyBmb3IgdGhlIGNvbXBvbmVudC4gT3B0aW9ucyB3aWxsIGJlIG1lcmdlZCBpbiBjdXJyZW50IG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zICBBdmFpbGFibGUgcGFyYW1ldGVyczpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge251bWJlciB8IHN0cmluZ30gaWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3N0cmluZ30gbG9jYWxlc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nfSBsb2NhbGVcbiAgICovXG4gIEN1c3RvbVRpbWUucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAvLyBjb3B5IGFsbCBvcHRpb25zIHRoYXQgd2Uga25vd1xuICAgICAgdXRpbC5zZWxlY3RpdmVFeHRlbmQoWydtb21lbnQnLCAnbG9jYWxlJywgJ2xvY2FsZXMnLCAnaWQnXSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgRE9NIGZvciB0aGUgY3VzdG9tIHRpbWVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEN1c3RvbVRpbWUucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGJhclsnY3VzdG9tLXRpbWUnXSA9IHRoaXM7XG4gICAgYmFyLmNsYXNzTmFtZSA9ICd2aXMtY3VzdG9tLXRpbWUgJyArICh0aGlzLm9wdGlvbnMuaWQgfHwgJycpO1xuICAgIGJhci5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgYmFyLnN0eWxlLnRvcCA9ICcwcHgnO1xuICAgIGJhci5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgdGhpcy5iYXIgPSBiYXI7XG5cbiAgICB2YXIgZHJhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRyYWcuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgIGRyYWcuc3R5bGUudG9wID0gJzBweCc7XG4gICAgZHJhZy5zdHlsZS5sZWZ0ID0gJy0xMHB4JztcbiAgICBkcmFnLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICBkcmFnLnN0eWxlLndpZHRoID0gJzIwcHgnO1xuICAgIGJhci5hcHBlbmRDaGlsZChkcmFnKTtcblxuICAgIC8vIGF0dGFjaCBldmVudCBsaXN0ZW5lcnNcbiAgICB0aGlzLmhhbW1lciA9IG5ldyBIYW1tZXIoZHJhZyk7XG4gICAgdGhpcy5oYW1tZXIub24oJ3BhbnN0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5oYW1tZXIub24oJ3Bhbm1vdmUnLCB0aGlzLl9vbkRyYWcuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5oYW1tZXIub24oJ3BhbmVuZCcsIHRoaXMuX29uRHJhZ0VuZC5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmhhbW1lci5nZXQoJ3BhbicpLnNldCh7IHRocmVzaG9sZDogNSwgZGlyZWN0aW9uOiBIYW1tZXIuRElSRUNUSU9OX0hPUklaT05UQUwgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlc3Ryb3kgdGhlIEN1c3RvbVRpbWUgYmFyXG4gICAqL1xuICBDdXN0b21UaW1lLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaGlkZSgpO1xuXG4gICAgdGhpcy5oYW1tZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuaGFtbWVyID0gbnVsbDtcblxuICAgIHRoaXMuYm9keSA9IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcGFpbnQgdGhlIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGNvbXBvbmVudCBpcyByZXNpemVkXG4gICAqL1xuICBDdXN0b21UaW1lLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXMuYm9keS5kb20uYmFja2dyb3VuZFZlcnRpY2FsO1xuICAgIGlmICh0aGlzLmJhci5wYXJlbnROb2RlICE9IHBhcmVudCkge1xuICAgICAgLy8gYXR0YWNoIHRvIHRoZSBkb21cbiAgICAgIGlmICh0aGlzLmJhci5wYXJlbnROb2RlKSB7XG4gICAgICAgIHRoaXMuYmFyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5iYXIpO1xuICAgICAgfVxuICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHRoaXMuYmFyKTtcbiAgICB9XG5cbiAgICB2YXIgeCA9IHRoaXMuYm9keS51dGlsLnRvU2NyZWVuKHRoaXMuY3VzdG9tVGltZSk7XG5cbiAgICB2YXIgbG9jYWxlID0gdGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV07XG4gICAgaWYgKCFsb2NhbGUpIHtcbiAgICAgIGlmICghdGhpcy53YXJuZWQpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1dBUk5JTkc6IG9wdGlvbnMubG9jYWxlc1tcXCcnICsgdGhpcy5vcHRpb25zLmxvY2FsZSArICdcXCddIG5vdCBmb3VuZC4gU2VlIGh0dHA6Ly92aXNqcy5vcmcvZG9jcy90aW1lbGluZS5odG1sI0xvY2FsaXphdGlvbicpO1xuICAgICAgICB0aGlzLndhcm5lZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBsb2NhbGUgPSB0aGlzLm9wdGlvbnMubG9jYWxlc1snZW4nXTsgLy8gZmFsbCBiYWNrIG9uIGVuZ2xpc2ggd2hlbiBub3QgYXZhaWxhYmxlXG4gICAgfVxuXG4gICAgdmFyIHRpdGxlID0gdGhpcy5vcHRpb25zLnRpdGxlO1xuICAgIC8vIFRvIGhpZGUgdGhlIHRpdGxlIGNvbXBsZXRlbHkgdXNlIGVtcHR5IHN0cmluZyAnJy5cbiAgICBpZiAodGl0bGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGl0bGUgPSBsb2NhbGUudGltZSArICc6ICcgKyB0aGlzLm9wdGlvbnMubW9tZW50KHRoaXMuY3VzdG9tVGltZSkuZm9ybWF0KCdkZGRkLCBNTU1NIERvIFlZWVksIEg6bW06c3MnKTtcbiAgICAgIHRpdGxlID0gdGl0bGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0aXRsZS5zdWJzdHJpbmcoMSk7XG4gICAgfVxuXG4gICAgdGhpcy5iYXIuc3R5bGUubGVmdCA9IHggKyAncHgnO1xuICAgIHRoaXMuYmFyLnRpdGxlID0gdGl0bGU7XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgQ3VzdG9tVGltZSBmcm9tIHRoZSBET01cbiAgICovXG4gIEN1c3RvbVRpbWUucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gcmVtb3ZlIHRoZSBsaW5lIGZyb20gdGhlIERPTVxuICAgIGlmICh0aGlzLmJhci5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLmJhci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuYmFyKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBjdXN0b20gdGltZS5cbiAgICogQHBhcmFtIHtEYXRlIHwgbnVtYmVyIHwgc3RyaW5nfSB0aW1lXG4gICAqL1xuICBDdXN0b21UaW1lLnByb3RvdHlwZS5zZXRDdXN0b21UaW1lID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICB0aGlzLmN1c3RvbVRpbWUgPSB1dGlsLmNvbnZlcnQodGltZSwgJ0RhdGUnKTtcbiAgICB0aGlzLnJlZHJhdygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgY3VycmVudCBjdXN0b20gdGltZS5cbiAgICogQHJldHVybiB7RGF0ZX0gY3VzdG9tVGltZVxuICAgKi9cbiAgQ3VzdG9tVGltZS5wcm90b3R5cGUuZ2V0Q3VzdG9tVGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IERhdGUodGhpcy5jdXN0b21UaW1lLnZhbHVlT2YoKSk7XG4gIH07XG5cbiAgLyoqXG4gICAgKiBTZXQgY3VzdG9tIHRpdGxlLlxuICAgICogQHBhcmFtIHtEYXRlIHwgbnVtYmVyIHwgc3RyaW5nfSB0aXRsZVxuICAgICovXG4gIEN1c3RvbVRpbWUucHJvdG90eXBlLnNldEN1c3RvbVRpdGxlID0gZnVuY3Rpb24gKHRpdGxlKSB7XG4gICAgdGhpcy5vcHRpb25zLnRpdGxlID0gdGl0bGU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0YXJ0IG1vdmluZyBob3Jpem9udGFsbHlcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEN1c3RvbVRpbWUucHJvdG90eXBlLl9vbkRyYWdTdGFydCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHRoaXMuZXZlbnRQYXJhbXMuZHJhZ2dpbmcgPSB0cnVlO1xuICAgIHRoaXMuZXZlbnRQYXJhbXMuY3VzdG9tVGltZSA9IHRoaXMuY3VzdG9tVGltZTtcblxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQZXJmb3JtIG1vdmluZyBvcGVyYXRpbmcuXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBDdXN0b21UaW1lLnByb3RvdHlwZS5fb25EcmFnID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmV2ZW50UGFyYW1zLmRyYWdnaW5nKSByZXR1cm47XG5cbiAgICB2YXIgeCA9IHRoaXMuYm9keS51dGlsLnRvU2NyZWVuKHRoaXMuZXZlbnRQYXJhbXMuY3VzdG9tVGltZSkgKyBldmVudC5kZWx0YVg7XG4gICAgdmFyIHRpbWUgPSB0aGlzLmJvZHkudXRpbC50b1RpbWUoeCk7XG5cbiAgICB0aGlzLnNldEN1c3RvbVRpbWUodGltZSk7XG5cbiAgICAvLyBmaXJlIGEgdGltZWNoYW5nZSBldmVudFxuICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3RpbWVjaGFuZ2UnLCB7XG4gICAgICBpZDogdGhpcy5vcHRpb25zLmlkLFxuICAgICAgdGltZTogbmV3IERhdGUodGhpcy5jdXN0b21UaW1lLnZhbHVlT2YoKSlcbiAgICB9KTtcblxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdG9wIG1vdmluZyBvcGVyYXRpbmcuXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBDdXN0b21UaW1lLnByb3RvdHlwZS5fb25EcmFnRW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmV2ZW50UGFyYW1zLmRyYWdnaW5nKSByZXR1cm47XG5cbiAgICAvLyBmaXJlIGEgdGltZWNoYW5nZWQgZXZlbnRcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCd0aW1lY2hhbmdlZCcsIHtcbiAgICAgIGlkOiB0aGlzLm9wdGlvbnMuaWQsXG4gICAgICB0aW1lOiBuZXcgRGF0ZSh0aGlzLmN1c3RvbVRpbWUudmFsdWVPZigpKVxuICAgIH0pO1xuXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpbmQgYSBjdXN0b20gdGltZSBmcm9tIGFuIGV2ZW50IHRhcmdldDpcbiAgICogc2VhcmNoZXMgZm9yIHRoZSBhdHRyaWJ1dGUgJ2N1c3RvbS10aW1lJyBpbiB0aGUgZXZlbnQgdGFyZ2V0J3MgZWxlbWVudCB0cmVlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEByZXR1cm4ge0N1c3RvbVRpbWUgfCBudWxsfSBjdXN0b21UaW1lXG4gICAqL1xuICBDdXN0b21UaW1lLmN1c3RvbVRpbWVGcm9tVGFyZ2V0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICB3aGlsZSAodGFyZ2V0KSB7XG4gICAgICBpZiAodGFyZ2V0Lmhhc093blByb3BlcnR5KCdjdXN0b20tdGltZScpKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXRbJ2N1c3RvbS10aW1lJ107XG4gICAgICB9XG4gICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IEN1c3RvbVRpbWU7XG5cbi8qKiovIH0sXG4vKiA0NyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIEVuZ2xpc2hcbiAgZXhwb3J0c1snZW4nXSA9IHtcbiAgICBjdXJyZW50OiAnY3VycmVudCcsXG4gICAgdGltZTogJ3RpbWUnXG4gIH07XG4gIGV4cG9ydHNbJ2VuX0VOJ10gPSBleHBvcnRzWydlbiddO1xuICBleHBvcnRzWydlbl9VUyddID0gZXhwb3J0c1snZW4nXTtcblxuICAvLyBEdXRjaFxuICBleHBvcnRzWydubCddID0ge1xuICAgIGN1cnJlbnQ6ICdodWlkaWdlJyxcbiAgICB0aW1lOiAndGlqZCdcbiAgfTtcbiAgZXhwb3J0c1snbmxfTkwnXSA9IGV4cG9ydHNbJ25sJ107XG4gIGV4cG9ydHNbJ25sX0JFJ10gPSBleHBvcnRzWydubCddO1xuXG4vKioqLyB9LFxuLyogNDggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4gIHZhciBDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKTtcbiAgdmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4gIHZhciBsb2NhbGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nyk7XG5cbiAgLyoqXG4gICAqIEEgY3VycmVudCB0aW1lIGJhclxuICAgKiBAcGFyYW0ge3tyYW5nZTogUmFuZ2UsIGRvbTogT2JqZWN0LCBkb21Qcm9wczogT2JqZWN0fX0gYm9keVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgICAgICBBdmFpbGFibGUgcGFyYW1ldGVyczpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0Jvb2xlYW59IFtzaG93Q3VycmVudFRpbWVdXG4gICAqIEBjb25zdHJ1Y3RvciBDdXJyZW50VGltZVxuICAgKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAgICovXG4gIGZ1bmN0aW9uIEN1cnJlbnRUaW1lKGJvZHksIG9wdGlvbnMpIHtcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuXG4gICAgLy8gZGVmYXVsdCBvcHRpb25zXG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIHJ0bDogZmFsc2UsXG4gICAgICBzaG93Q3VycmVudFRpbWU6IHRydWUsXG5cbiAgICAgIG1vbWVudDogbW9tZW50LFxuICAgICAgbG9jYWxlczogbG9jYWxlcyxcbiAgICAgIGxvY2FsZTogJ2VuJ1xuICAgIH07XG4gICAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoe30sIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuICAgIHRoaXMub2Zmc2V0ID0gMDtcblxuICAgIHRoaXMuX2NyZWF0ZSgpO1xuXG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG5cbiAgQ3VycmVudFRpbWUucHJvdG90eXBlID0gbmV3IENvbXBvbmVudCgpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIEhUTUwgRE9NIGZvciB0aGUgY3VycmVudCB0aW1lIGJhclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQ3VycmVudFRpbWUucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGJhci5jbGFzc05hbWUgPSAndmlzLWN1cnJlbnQtdGltZSc7XG4gICAgYmFyLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBiYXIuc3R5bGUudG9wID0gJzBweCc7XG4gICAgYmFyLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcblxuICAgIHRoaXMuYmFyID0gYmFyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXN0cm95IHRoZSBDdXJyZW50VGltZSBiYXJcbiAgICovXG4gIEN1cnJlbnRUaW1lLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMub3B0aW9ucy5zaG93Q3VycmVudFRpbWUgPSBmYWxzZTtcbiAgICB0aGlzLnJlZHJhdygpOyAvLyB3aWxsIHJlbW92ZSB0aGUgYmFyIGZyb20gdGhlIERPTSBhbmQgc3RvcCByZWZyZXNoaW5nXG5cbiAgICB0aGlzLmJvZHkgPSBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgb3B0aW9ucyBmb3IgdGhlIGNvbXBvbmVudC4gT3B0aW9ucyB3aWxsIGJlIG1lcmdlZCBpbiBjdXJyZW50IG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zICBBdmFpbGFibGUgcGFyYW1ldGVyczpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHtib29sZWFufSBbc2hvd0N1cnJlbnRUaW1lXVxuICAgKi9cbiAgQ3VycmVudFRpbWUucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAvLyBjb3B5IGFsbCBvcHRpb25zIHRoYXQgd2Uga25vd1xuICAgICAgdXRpbC5zZWxlY3RpdmVFeHRlbmQoWydydGwnLCAnc2hvd0N1cnJlbnRUaW1lJywgJ21vbWVudCcsICdsb2NhbGUnLCAnbG9jYWxlcyddLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVwYWludCB0aGUgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgY29tcG9uZW50IGlzIHJlc2l6ZWRcbiAgICovXG4gIEN1cnJlbnRUaW1lLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5zaG93Q3VycmVudFRpbWUpIHtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLmJvZHkuZG9tLmJhY2tncm91bmRWZXJ0aWNhbDtcbiAgICAgIGlmICh0aGlzLmJhci5wYXJlbnROb2RlICE9IHBhcmVudCkge1xuICAgICAgICAvLyBhdHRhY2ggdG8gdGhlIGRvbVxuICAgICAgICBpZiAodGhpcy5iYXIucGFyZW50Tm9kZSkge1xuICAgICAgICAgIHRoaXMuYmFyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5iYXIpO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZCh0aGlzLmJhcik7XG5cbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm93ID0gdGhpcy5vcHRpb25zLm1vbWVudChuZXcgRGF0ZSgpLnZhbHVlT2YoKSArIHRoaXMub2Zmc2V0KTtcbiAgICAgIHZhciB4ID0gdGhpcy5ib2R5LnV0aWwudG9TY3JlZW4obm93KTtcblxuICAgICAgdmFyIGxvY2FsZSA9IHRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdO1xuICAgICAgaWYgKCFsb2NhbGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLndhcm5lZCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdXQVJOSU5HOiBvcHRpb25zLmxvY2FsZXNbXFwnJyArIHRoaXMub3B0aW9ucy5sb2NhbGUgKyAnXFwnXSBub3QgZm91bmQuIFNlZSBodHRwOi8vdmlzanMub3JnL2RvY3MvdGltZWxpbmUvI0xvY2FsaXphdGlvbicpO1xuICAgICAgICAgIHRoaXMud2FybmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsb2NhbGUgPSB0aGlzLm9wdGlvbnMubG9jYWxlc1snZW4nXTsgLy8gZmFsbCBiYWNrIG9uIGVuZ2xpc2ggd2hlbiBub3QgYXZhaWxhYmxlXG4gICAgICB9XG4gICAgICB2YXIgdGl0bGUgPSBsb2NhbGUuY3VycmVudCArICcgJyArIGxvY2FsZS50aW1lICsgJzogJyArIG5vdy5mb3JtYXQoJ2RkZGQsIE1NTU0gRG8gWVlZWSwgSDptbTpzcycpO1xuICAgICAgdGl0bGUgPSB0aXRsZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRpdGxlLnN1YnN0cmluZygxKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgICAgdGhpcy5iYXIuc3R5bGUucmlnaHQgPSB4ICsgJ3B4JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYmFyLnN0eWxlLmxlZnQgPSB4ICsgJ3B4JztcbiAgICAgIH1cbiAgICAgIHRoaXMuYmFyLnRpdGxlID0gdGl0bGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlbW92ZSB0aGUgbGluZSBmcm9tIHRoZSBET01cbiAgICAgIGlmICh0aGlzLmJhci5wYXJlbnROb2RlKSB7XG4gICAgICAgIHRoaXMuYmFyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5iYXIpO1xuICAgICAgfVxuICAgICAgdGhpcy5zdG9wKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdGFydCBhdXRvIHJlZnJlc2hpbmcgdGhlIGN1cnJlbnQgdGltZSBiYXJcbiAgICovXG4gIEN1cnJlbnRUaW1lLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgbWUuc3RvcCgpO1xuXG4gICAgICAvLyBkZXRlcm1pbmUgaW50ZXJ2YWwgdG8gcmVmcmVzaFxuICAgICAgdmFyIHNjYWxlID0gbWUuYm9keS5yYW5nZS5jb252ZXJzaW9uKG1lLmJvZHkuZG9tUHJvcHMuY2VudGVyLndpZHRoKS5zY2FsZTtcbiAgICAgIHZhciBpbnRlcnZhbCA9IDEgLyBzY2FsZSAvIDEwO1xuICAgICAgaWYgKGludGVydmFsIDwgMzApIGludGVydmFsID0gMzA7XG4gICAgICBpZiAoaW50ZXJ2YWwgPiAxMDAwKSBpbnRlcnZhbCA9IDEwMDA7XG5cbiAgICAgIG1lLnJlZHJhdygpO1xuICAgICAgbWUuYm9keS5lbWl0dGVyLmVtaXQoJ2N1cnJlbnRUaW1lVGljaycpO1xuXG4gICAgICAvLyBzdGFydCBhIHJlbmRlclRpbWVyIHRvIGFkanVzdCBmb3IgdGhlIG5ldyB0aW1lXG4gICAgICBtZS5jdXJyZW50VGltZVRpbWVyID0gc2V0VGltZW91dCh1cGRhdGUsIGludGVydmFsKTtcbiAgICB9XG5cbiAgICB1cGRhdGUoKTtcbiAgfTtcblxuICAvKipcbiAgICogU3RvcCBhdXRvIHJlZnJlc2hpbmcgdGhlIGN1cnJlbnQgdGltZSBiYXJcbiAgICovXG4gIEN1cnJlbnRUaW1lLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnRUaW1lVGltZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY3VycmVudFRpbWVUaW1lcik7XG4gICAgICBkZWxldGUgdGhpcy5jdXJyZW50VGltZVRpbWVyO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0IGEgY3VycmVudCB0aW1lLiBUaGlzIGNhbiBiZSB1c2VkIGZvciBleGFtcGxlIHRvIGVuc3VyZSB0aGF0IGEgY2xpZW50J3NcbiAgICogdGltZSBpcyBzeW5jaHJvbml6ZWQgd2l0aCBhIHNoYXJlZCBzZXJ2ZXIgdGltZS5cbiAgICogQHBhcmFtIHtEYXRlIHwgU3RyaW5nIHwgTnVtYmVyfSB0aW1lICAgICBBIERhdGUsIHVuaXggdGltZXN0YW1wLCBvclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElTTyBkYXRlIHN0cmluZy5cbiAgICovXG4gIEN1cnJlbnRUaW1lLnByb3RvdHlwZS5zZXRDdXJyZW50VGltZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgdmFyIHQgPSB1dGlsLmNvbnZlcnQodGltZSwgJ0RhdGUnKS52YWx1ZU9mKCk7XG4gICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkudmFsdWVPZigpO1xuICAgIHRoaXMub2Zmc2V0ID0gdCAtIG5vdztcbiAgICB0aGlzLnJlZHJhdygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgdGltZS5cbiAgICogQHJldHVybiB7RGF0ZX0gUmV0dXJucyB0aGUgY3VycmVudCB0aW1lLlxuICAgKi9cbiAgQ3VycmVudFRpbWUucHJvdG90eXBlLmdldEN1cnJlbnRUaW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZShuZXcgRGF0ZSgpLnZhbHVlT2YoKSArIHRoaXMub2Zmc2V0KTtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IEN1cnJlbnRUaW1lO1xuXG4vKioqLyB9LFxuLyogNDkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcbiAgLyoqXG4gICAqIFRoaXMgb2JqZWN0IGNvbnRhaW5zIGFsbCBwb3NzaWJsZSBvcHRpb25zLiBJdCB3aWxsIGNoZWNrIGlmIHRoZSB0eXBlcyBhcmUgY29ycmVjdCwgaWYgcmVxdWlyZWQgaWYgdGhlIG9wdGlvbiBpcyBvbmVcbiAgICogb2YgdGhlIGFsbG93ZWQgdmFsdWVzLlxuICAgKlxuICAgKiBfX2FueV9fIG1lYW5zIHRoYXQgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IGRvZXMgbm90IG1hdHRlci5cbiAgICogX190eXBlX18gaXMgYSByZXF1aXJlZCBmaWVsZCBmb3IgYWxsIG9iamVjdHMgYW5kIGNvbnRhaW5zIHRoZSBhbGxvd2VkIHR5cGVzIG9mIGFsbCBvYmplY3RzXG4gICAqL1xuICB2YXIgc3RyaW5nID0gJ3N0cmluZyc7XG4gIHZhciBib29sZWFuID0gJ2Jvb2xlYW4nO1xuICB2YXIgbnVtYmVyID0gJ251bWJlcic7XG4gIHZhciBhcnJheSA9ICdhcnJheSc7XG4gIHZhciBkYXRlID0gJ2RhdGUnO1xuICB2YXIgb2JqZWN0ID0gJ29iamVjdCc7IC8vIHNob3VsZCBvbmx5IGJlIGluIGEgX190eXBlX18gcHJvcGVydHlcbiAgdmFyIGRvbSA9ICdkb20nO1xuICB2YXIgbW9tZW50ID0gJ21vbWVudCc7XG4gIHZhciBhbnkgPSAnYW55JztcblxuICB2YXIgYWxsT3B0aW9ucyA9IHtcbiAgICBjb25maWd1cmU6IHtcbiAgICAgIGVuYWJsZWQ6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgZmlsdGVyOiB7IGJvb2xlYW46IGJvb2xlYW4sICdmdW5jdGlvbic6ICdmdW5jdGlvbicgfSxcbiAgICAgIGNvbnRhaW5lcjogeyBkb206IGRvbSB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIGJvb2xlYW46IGJvb2xlYW4sICdmdW5jdGlvbic6ICdmdW5jdGlvbicgfVxuICAgIH0sXG5cbiAgICAvL2dsb2JhbHMgOlxuICAgIGFsaWduOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgcnRsOiB7IGJvb2xlYW46IGJvb2xlYW4sICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgIGF1dG9SZXNpemU6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgIHRocm90dGxlUmVkcmF3OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgY2xpY2tUb1VzZTogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgZGF0YUF0dHJpYnV0ZXM6IHsgc3RyaW5nOiBzdHJpbmcsIGFycmF5OiBhcnJheSB9LFxuICAgIGVkaXRhYmxlOiB7XG4gICAgICBhZGQ6IHsgYm9vbGVhbjogYm9vbGVhbiwgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICByZW1vdmU6IHsgYm9vbGVhbjogYm9vbGVhbiwgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICB1cGRhdGVHcm91cDogeyBib29sZWFuOiBib29sZWFuLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgIHVwZGF0ZVRpbWU6IHsgYm9vbGVhbjogYm9vbGVhbiwgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICBfX3R5cGVfXzogeyBib29sZWFuOiBib29sZWFuLCBvYmplY3Q6IG9iamVjdCB9XG4gICAgfSxcbiAgICBlbmQ6IHsgbnVtYmVyOiBudW1iZXIsIGRhdGU6IGRhdGUsIHN0cmluZzogc3RyaW5nLCBtb21lbnQ6IG1vbWVudCB9LFxuICAgIGZvcm1hdDoge1xuICAgICAgbWlub3JMYWJlbHM6IHtcbiAgICAgICAgbWlsbGlzZWNvbmQ6IHsgc3RyaW5nOiBzdHJpbmcsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgICBzZWNvbmQ6IHsgc3RyaW5nOiBzdHJpbmcsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgICBtaW51dGU6IHsgc3RyaW5nOiBzdHJpbmcsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgICBob3VyOiB7IHN0cmluZzogc3RyaW5nLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgICAgd2Vla2RheTogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICAgIGRheTogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICAgIG1vbnRoOiB7IHN0cmluZzogc3RyaW5nLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgICAgeWVhcjogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0IH1cbiAgICAgIH0sXG4gICAgICBtYWpvckxhYmVsczoge1xuICAgICAgICBtaWxsaXNlY29uZDogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICAgIHNlY29uZDogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICAgIG1pbnV0ZTogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICAgIGhvdXI6IHsgc3RyaW5nOiBzdHJpbmcsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgICB3ZWVrZGF5OiB7IHN0cmluZzogc3RyaW5nLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgICAgZGF5OiB7IHN0cmluZzogc3RyaW5nLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgICAgbW9udGg6IHsgc3RyaW5nOiBzdHJpbmcsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgICB5ZWFyOiB7IHN0cmluZzogc3RyaW5nLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0IH1cbiAgICB9LFxuICAgIG1vbWVudDogeyAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH0sXG4gICAgZ3JvdXBPcmRlcjogeyBzdHJpbmc6IHN0cmluZywgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgIGdyb3VwRWRpdGFibGU6IHtcbiAgICAgIGFkZDogeyBib29sZWFuOiBib29sZWFuLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgIHJlbW92ZTogeyBib29sZWFuOiBib29sZWFuLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgIG9yZGVyOiB7IGJvb2xlYW46IGJvb2xlYW4sICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgX190eXBlX186IHsgYm9vbGVhbjogYm9vbGVhbiwgb2JqZWN0OiBvYmplY3QgfVxuICAgIH0sXG4gICAgZ3JvdXBPcmRlclN3YXA6IHsgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgIGhlaWdodDogeyBzdHJpbmc6IHN0cmluZywgbnVtYmVyOiBudW1iZXIgfSxcbiAgICBoaWRkZW5EYXRlczoge1xuICAgICAgc3RhcnQ6IHsgZGF0ZTogZGF0ZSwgbnVtYmVyOiBudW1iZXIsIHN0cmluZzogc3RyaW5nLCBtb21lbnQ6IG1vbWVudCB9LFxuICAgICAgZW5kOiB7IGRhdGU6IGRhdGUsIG51bWJlcjogbnVtYmVyLCBzdHJpbmc6IHN0cmluZywgbW9tZW50OiBtb21lbnQgfSxcbiAgICAgIHJlcGVhdDogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIGFycmF5OiBhcnJheSB9XG4gICAgfSxcbiAgICBpdGVtc0Fsd2F5c0RyYWdnYWJsZTogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgbG9jYWxlOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgbG9jYWxlczoge1xuICAgICAgX19hbnlfXzogeyBhbnk6IGFueSB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICAgIH0sXG4gICAgbWFyZ2luOiB7XG4gICAgICBheGlzOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICBpdGVtOiB7XG4gICAgICAgIGhvcml6b250YWw6IHsgbnVtYmVyOiBudW1iZXIsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgICB2ZXJ0aWNhbDogeyBudW1iZXI6IG51bWJlciwgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBudW1iZXI6IG51bWJlciB9XG4gICAgICB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIG51bWJlcjogbnVtYmVyIH1cbiAgICB9LFxuICAgIG1heDogeyBkYXRlOiBkYXRlLCBudW1iZXI6IG51bWJlciwgc3RyaW5nOiBzdHJpbmcsIG1vbWVudDogbW9tZW50IH0sXG4gICAgbWF4SGVpZ2h0OiB7IG51bWJlcjogbnVtYmVyLCBzdHJpbmc6IHN0cmluZyB9LFxuICAgIG1heE1pbm9yQ2hhcnM6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICBtaW46IHsgZGF0ZTogZGF0ZSwgbnVtYmVyOiBudW1iZXIsIHN0cmluZzogc3RyaW5nLCBtb21lbnQ6IG1vbWVudCB9LFxuICAgIG1pbkhlaWdodDogeyBudW1iZXI6IG51bWJlciwgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICBtb3ZlYWJsZTogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgbXVsdGlzZWxlY3Q6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgIG11bHRpc2VsZWN0UGVyR3JvdXA6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgIG9uQWRkOiB7ICdmdW5jdGlvbic6ICdmdW5jdGlvbicgfSxcbiAgICBvblVwZGF0ZTogeyAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH0sXG4gICAgb25Nb3ZlOiB7ICdmdW5jdGlvbic6ICdmdW5jdGlvbicgfSxcbiAgICBvbk1vdmluZzogeyAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH0sXG4gICAgb25SZW1vdmU6IHsgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgIG9uQWRkR3JvdXA6IHsgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgIG9uTW92ZUdyb3VwOiB7ICdmdW5jdGlvbic6ICdmdW5jdGlvbicgfSxcbiAgICBvblJlbW92ZUdyb3VwOiB7ICdmdW5jdGlvbic6ICdmdW5jdGlvbicgfSxcbiAgICBvcmRlcjogeyAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH0sXG4gICAgb3JpZW50YXRpb246IHtcbiAgICAgIGF4aXM6IHsgc3RyaW5nOiBzdHJpbmcsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgaXRlbTogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICBfX3R5cGVfXzogeyBzdHJpbmc6IHN0cmluZywgb2JqZWN0OiBvYmplY3QgfVxuICAgIH0sXG4gICAgc2VsZWN0YWJsZTogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgc2hvd0N1cnJlbnRUaW1lOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICBzaG93TWFqb3JMYWJlbHM6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgIHNob3dNaW5vckxhYmVsczogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgc3RhY2s6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgIHNuYXA6IHsgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJywgJ251bGwnOiAnbnVsbCcgfSxcbiAgICBzdGFydDogeyBkYXRlOiBkYXRlLCBudW1iZXI6IG51bWJlciwgc3RyaW5nOiBzdHJpbmcsIG1vbWVudDogbW9tZW50IH0sXG4gICAgdGVtcGxhdGU6IHsgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgIGdyb3VwVGVtcGxhdGU6IHsgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgIHRpbWVBeGlzOiB7XG4gICAgICBzY2FsZTogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICBzdGVwOiB7IG51bWJlcjogbnVtYmVyLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0IH1cbiAgICB9LFxuICAgIHR5cGU6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICB3aWR0aDogeyBzdHJpbmc6IHN0cmluZywgbnVtYmVyOiBudW1iZXIgfSxcbiAgICB6b29tYWJsZTogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgem9vbUtleTogeyBzdHJpbmc6IFsnY3RybEtleScsICdhbHRLZXknLCAnbWV0YUtleScsICcnXSB9LFxuICAgIHpvb21NYXg6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICB6b29tTWluOiB7IG51bWJlcjogbnVtYmVyIH0sXG5cbiAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gIH07XG5cbiAgdmFyIGNvbmZpZ3VyZU9wdGlvbnMgPSB7XG4gICAgZ2xvYmFsOiB7XG4gICAgICBhbGlnbjogWydjZW50ZXInLCAnbGVmdCcsICdyaWdodCddLFxuICAgICAgZGlyZWN0aW9uOiBmYWxzZSxcbiAgICAgIGF1dG9SZXNpemU6IHRydWUsXG4gICAgICB0aHJvdHRsZVJlZHJhdzogWzEwLCAwLCAxMDAwLCAxMF0sXG4gICAgICBjbGlja1RvVXNlOiBmYWxzZSxcbiAgICAgIC8vIGRhdGFBdHRyaWJ1dGVzOiBbJ2FsbCddLCAvLyBGSVhNRTogY2FuIGJlICdhbGwnIG9yIHN0cmluZ1tdXG4gICAgICBlZGl0YWJsZToge1xuICAgICAgICBhZGQ6IGZhbHNlLFxuICAgICAgICByZW1vdmU6IGZhbHNlLFxuICAgICAgICB1cGRhdGVHcm91cDogZmFsc2UsXG4gICAgICAgIHVwZGF0ZVRpbWU6IGZhbHNlXG4gICAgICB9LFxuICAgICAgZW5kOiAnJyxcbiAgICAgIGZvcm1hdDoge1xuICAgICAgICBtaW5vckxhYmVsczoge1xuICAgICAgICAgIG1pbGxpc2Vjb25kOiAnU1NTJyxcbiAgICAgICAgICBzZWNvbmQ6ICdzJyxcbiAgICAgICAgICBtaW51dGU6ICdISDptbScsXG4gICAgICAgICAgaG91cjogJ0hIOm1tJyxcbiAgICAgICAgICB3ZWVrZGF5OiAnZGRkIEQnLFxuICAgICAgICAgIGRheTogJ0QnLFxuICAgICAgICAgIG1vbnRoOiAnTU1NJyxcbiAgICAgICAgICB5ZWFyOiAnWVlZWSdcbiAgICAgICAgfSxcbiAgICAgICAgbWFqb3JMYWJlbHM6IHtcbiAgICAgICAgICBtaWxsaXNlY29uZDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICBzZWNvbmQ6ICdEIE1NTU0gSEg6bW0nLFxuICAgICAgICAgIG1pbnV0ZTogJ2RkZCBEIE1NTU0nLFxuICAgICAgICAgIGhvdXI6ICdkZGQgRCBNTU1NJyxcbiAgICAgICAgICB3ZWVrZGF5OiAnTU1NTSBZWVlZJyxcbiAgICAgICAgICBkYXk6ICdNTU1NIFlZWVknLFxuICAgICAgICAgIG1vbnRoOiAnWVlZWScsXG4gICAgICAgICAgeWVhcjogJydcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLy9ncm91cE9yZGVyOiB7c3RyaW5nLCAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgICAgIGdyb3Vwc0RyYWdnYWJsZTogZmFsc2UsXG4gICAgICBoZWlnaHQ6ICcnLFxuICAgICAgLy9oaWRkZW5EYXRlczoge29iamVjdCwgYXJyYXl9LFxuICAgICAgbG9jYWxlOiAnJyxcbiAgICAgIG1hcmdpbjoge1xuICAgICAgICBheGlzOiBbMjAsIDAsIDEwMCwgMV0sXG4gICAgICAgIGl0ZW06IHtcbiAgICAgICAgICBob3Jpem9udGFsOiBbMTAsIDAsIDEwMCwgMV0sXG4gICAgICAgICAgdmVydGljYWw6IFsxMCwgMCwgMTAwLCAxXVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbWF4OiAnJyxcbiAgICAgIG1heEhlaWdodDogJycsXG4gICAgICBtYXhNaW5vckNoYXJzOiBbNywgMCwgMjAsIDFdLFxuICAgICAgbWluOiAnJyxcbiAgICAgIG1pbkhlaWdodDogJycsXG4gICAgICBtb3ZlYWJsZTogZmFsc2UsXG4gICAgICBtdWx0aXNlbGVjdDogZmFsc2UsXG4gICAgICBtdWx0aXNlbGVjdFBlckdyb3VwOiBmYWxzZSxcbiAgICAgIC8vb25BZGQ6IHsnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgICAgIC8vb25VcGRhdGU6IHsnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgICAgIC8vb25Nb3ZlOiB7J2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJ30sXG4gICAgICAvL29uTW92aW5nOiB7J2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJ30sXG4gICAgICAvL29uUmVuYW1lOiB7J2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJ30sXG4gICAgICAvL29yZGVyOiB7J2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJ30sXG4gICAgICBvcmllbnRhdGlvbjoge1xuICAgICAgICBheGlzOiBbJ2JvdGgnLCAnYm90dG9tJywgJ3RvcCddLFxuICAgICAgICBpdGVtOiBbJ2JvdHRvbScsICd0b3AnXVxuICAgICAgfSxcbiAgICAgIHNlbGVjdGFibGU6IHRydWUsXG4gICAgICBzaG93Q3VycmVudFRpbWU6IGZhbHNlLFxuICAgICAgc2hvd01ham9yTGFiZWxzOiB0cnVlLFxuICAgICAgc2hvd01pbm9yTGFiZWxzOiB0cnVlLFxuICAgICAgc3RhY2s6IHRydWUsXG4gICAgICAvL3NuYXA6IHsnZnVuY3Rpb24nOiAnZnVuY3Rpb24nLCBuYWRhfSxcbiAgICAgIHN0YXJ0OiAnJyxcbiAgICAgIC8vdGVtcGxhdGU6IHsnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgICAgIC8vdGltZUF4aXM6IHtcbiAgICAgIC8vICBzY2FsZTogWydtaWxsaXNlY29uZCcsICdzZWNvbmQnLCAnbWludXRlJywgJ2hvdXInLCAnd2Vla2RheScsICdkYXknLCAnbW9udGgnLCAneWVhciddLFxuICAgICAgLy8gIHN0ZXA6IFsxLCAxLCAxMCwgMV1cbiAgICAgIC8vfSxcbiAgICAgIHR5cGU6IFsnYm94JywgJ3BvaW50JywgJ3JhbmdlJywgJ2JhY2tncm91bmQnXSxcbiAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICB6b29tYWJsZTogdHJ1ZSxcbiAgICAgIHpvb21LZXk6IFsnY3RybEtleScsICdhbHRLZXknLCAnbWV0YUtleScsICcnXSxcbiAgICAgIHpvb21NYXg6IFszMTUzNjAwMDAwMDAwMDAsIDEwLCAzMTUzNjAwMDAwMDAwMDAsIDFdLFxuICAgICAgem9vbU1pbjogWzEwLCAxMCwgMzE1MzYwMDAwMDAwMDAwLCAxXVxuICAgIH1cbiAgfTtcblxuICBleHBvcnRzLmFsbE9wdGlvbnMgPSBhbGxPcHRpb25zO1xuICBleHBvcnRzLmNvbmZpZ3VyZU9wdGlvbnMgPSBjb25maWd1cmVPcHRpb25zO1xuXG4vKioqLyB9LFxuLyogNTAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgX0NvbmZpZ3VyYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpO1xuXG4gIHZhciBfQ29uZmlndXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NvbmZpZ3VyYXRvcik7XG5cbiAgdmFyIF9WYWxpZGF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KTtcblxuICB2YXIgX1ZhbGlkYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9WYWxpZGF0b3IpO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbiAgdmFyIEVtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcbiAgdmFyIEhhbW1lciA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuICB2YXIgbW9tZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbiAgdmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuICB2YXIgRGF0YVNldCA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG4gIHZhciBEYXRhVmlldyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuICB2YXIgUmFuZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKTtcbiAgdmFyIENvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbiAgdmFyIFRpbWVBeGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NCk7XG4gIHZhciBDdXJyZW50VGltZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDgpO1xuICB2YXIgQ3VzdG9tVGltZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDYpO1xuICB2YXIgTGluZUdyYXBoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MSk7XG5cbiAgdmFyIHByaW50U3R5bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KS5wcmludFN0eWxlO1xuICB2YXIgYWxsT3B0aW9ucyA9IF9fd2VicGFja19yZXF1aXJlX18oNTkpLmFsbE9wdGlvbnM7XG4gIHZhciBjb25maWd1cmVPcHRpb25zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OSkuY29uZmlndXJlT3B0aW9ucztcblxuICAvKipcbiAgICogQ3JlYXRlIGEgdGltZWxpbmUgdmlzdWFsaXphdGlvblxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXJcbiAgICogQHBhcmFtIHt2aXMuRGF0YVNldCB8IEFycmF5fSBbaXRlbXNdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gIFNlZSBHcmFwaDJkLnNldE9wdGlvbnMgZm9yIHRoZSBhdmFpbGFibGUgb3B0aW9ucy5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIENvcmVcbiAgICovXG4gIGZ1bmN0aW9uIEdyYXBoMmQoY29udGFpbmVyLCBpdGVtcywgZ3JvdXBzLCBvcHRpb25zKSB7XG4gICAgLy8gaWYgdGhlIHRoaXJkIGVsZW1lbnQgaXMgb3B0aW9ucywgdGhlIGZvcnRoIGlzIGdyb3VwcyAob3B0aW9uYWxseSk7XG4gICAgaWYgKCEoQXJyYXkuaXNBcnJheShncm91cHMpIHx8IGdyb3VwcyBpbnN0YW5jZW9mIERhdGFTZXQgfHwgZ3JvdXBzIGluc3RhbmNlb2YgRGF0YVZpZXcpICYmIGdyb3VwcyBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgdmFyIGZvcnRoQXJndW1lbnQgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IGdyb3VwcztcbiAgICAgIGdyb3VwcyA9IGZvcnRoQXJndW1lbnQ7XG4gICAgfVxuXG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgc3RhcnQ6IG51bGwsXG4gICAgICBlbmQ6IG51bGwsXG5cbiAgICAgIGF1dG9SZXNpemU6IHRydWUsXG5cbiAgICAgIG9yaWVudGF0aW9uOiB7XG4gICAgICAgIGF4aXM6ICdib3R0b20nLCAvLyBheGlzIG9yaWVudGF0aW9uOiAnYm90dG9tJywgJ3RvcCcsIG9yICdib3RoJ1xuICAgICAgICBpdGVtOiAnYm90dG9tJyAvLyBub3QgcmVsZXZhbnQgZm9yIEdyYXBoMmRcbiAgICAgIH0sXG5cbiAgICAgIG1vbWVudDogbW9tZW50LFxuXG4gICAgICB3aWR0aDogbnVsbCxcbiAgICAgIGhlaWdodDogbnVsbCxcbiAgICAgIG1heEhlaWdodDogbnVsbCxcbiAgICAgIG1pbkhlaWdodDogbnVsbFxuICAgIH07XG4gICAgdGhpcy5vcHRpb25zID0gdXRpbC5kZWVwRXh0ZW5kKHt9LCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICAgIC8vIENyZWF0ZSB0aGUgRE9NLCBwcm9wcywgYW5kIGVtaXR0ZXJcbiAgICB0aGlzLl9jcmVhdGUoY29udGFpbmVyKTtcblxuICAgIC8vIGFsbCBjb21wb25lbnRzIGxpc3RlZCBoZXJlIHdpbGwgYmUgcmVwYWludGVkIGF1dG9tYXRpY2FsbHlcbiAgICB0aGlzLmNvbXBvbmVudHMgPSBbXTtcblxuICAgIHRoaXMuYm9keSA9IHtcbiAgICAgIGRvbTogdGhpcy5kb20sXG4gICAgICBkb21Qcm9wczogdGhpcy5wcm9wcyxcbiAgICAgIGVtaXR0ZXI6IHtcbiAgICAgICAgb246IHRoaXMub24uYmluZCh0aGlzKSxcbiAgICAgICAgb2ZmOiB0aGlzLm9mZi5iaW5kKHRoaXMpLFxuICAgICAgICBlbWl0OiB0aGlzLmVtaXQuYmluZCh0aGlzKVxuICAgICAgfSxcbiAgICAgIGhpZGRlbkRhdGVzOiBbXSxcbiAgICAgIHV0aWw6IHtcbiAgICAgICAgdG9TY3JlZW46IG1lLl90b1NjcmVlbi5iaW5kKG1lKSxcbiAgICAgICAgdG9HbG9iYWxTY3JlZW46IG1lLl90b0dsb2JhbFNjcmVlbi5iaW5kKG1lKSwgLy8gdGhpcyByZWZlcnMgdG8gdGhlIHJvb3Qud2lkdGhcbiAgICAgICAgdG9UaW1lOiBtZS5fdG9UaW1lLmJpbmQobWUpLFxuICAgICAgICB0b0dsb2JhbFRpbWU6IG1lLl90b0dsb2JhbFRpbWUuYmluZChtZSlcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gcmFuZ2VcbiAgICB0aGlzLnJhbmdlID0gbmV3IFJhbmdlKHRoaXMuYm9keSk7XG4gICAgdGhpcy5jb21wb25lbnRzLnB1c2godGhpcy5yYW5nZSk7XG4gICAgdGhpcy5ib2R5LnJhbmdlID0gdGhpcy5yYW5nZTtcblxuICAgIC8vIHRpbWUgYXhpc1xuICAgIHRoaXMudGltZUF4aXMgPSBuZXcgVGltZUF4aXModGhpcy5ib2R5KTtcbiAgICB0aGlzLmNvbXBvbmVudHMucHVzaCh0aGlzLnRpbWVBeGlzKTtcbiAgICAvL3RoaXMuYm9keS51dGlsLnNuYXAgPSB0aGlzLnRpbWVBeGlzLnNuYXAuYmluZCh0aGlzLnRpbWVBeGlzKTtcblxuICAgIC8vIGN1cnJlbnQgdGltZSBiYXJcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gbmV3IEN1cnJlbnRUaW1lKHRoaXMuYm9keSk7XG4gICAgdGhpcy5jb21wb25lbnRzLnB1c2godGhpcy5jdXJyZW50VGltZSk7XG5cbiAgICAvLyBpdGVtIHNldFxuICAgIHRoaXMubGluZWdyYXBoID0gbmV3IExpbmVHcmFwaCh0aGlzLmJvZHkpO1xuXG4gICAgdGhpcy5jb21wb25lbnRzLnB1c2godGhpcy5saW5lZ3JhcGgpO1xuXG4gICAgdGhpcy5pdGVtc0RhdGEgPSBudWxsOyAvLyBEYXRhU2V0XG4gICAgdGhpcy5ncm91cHNEYXRhID0gbnVsbDsgLy8gRGF0YVNldFxuXG4gICAgdGhpcy5vbigndGFwJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBtZS5lbWl0KCdjbGljaycsIG1lLmdldEV2ZW50UHJvcGVydGllcyhldmVudCkpO1xuICAgIH0pO1xuICAgIHRoaXMub24oJ2RvdWJsZXRhcCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgbWUuZW1pdCgnZG91YmxlQ2xpY2snLCBtZS5nZXRFdmVudFByb3BlcnRpZXMoZXZlbnQpKTtcbiAgICB9KTtcbiAgICB0aGlzLmRvbS5yb290Lm9uY29udGV4dG1lbnUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIG1lLmVtaXQoJ2NvbnRleHRtZW51JywgbWUuZ2V0RXZlbnRQcm9wZXJ0aWVzKGV2ZW50KSk7XG4gICAgfTtcblxuICAgIC8vIGFwcGx5IG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8vIElNUE9SVEFOVDogVEhJUyBIQVBQRU5TIEJFRk9SRSBTRVQgSVRFTVMhXG4gICAgaWYgKGdyb3Vwcykge1xuICAgICAgdGhpcy5zZXRHcm91cHMoZ3JvdXBzKTtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgaXRlbXNldFxuICAgIGlmIChpdGVtcykge1xuICAgICAgdGhpcy5zZXRJdGVtcyhpdGVtcyk7XG4gICAgfVxuXG4gICAgLy8gZHJhdyBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICB0aGlzLl9yZWRyYXcoKTtcbiAgfVxuXG4gIC8vIEV4dGVuZCB0aGUgZnVuY3Rpb25hbGl0eSBmcm9tIENvcmVcbiAgR3JhcGgyZC5wcm90b3R5cGUgPSBuZXcgQ29yZSgpO1xuXG4gIEdyYXBoMmQucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIC8vIHZhbGlkYXRlIG9wdGlvbnNcbiAgICB2YXIgZXJyb3JGb3VuZCA9IF9WYWxpZGF0b3IyLmRlZmF1bHQudmFsaWRhdGUob3B0aW9ucywgYWxsT3B0aW9ucyk7XG4gICAgaWYgKGVycm9yRm91bmQgPT09IHRydWUpIHtcbiAgICAgIGNvbnNvbGUubG9nKCclY0Vycm9ycyBoYXZlIGJlZW4gZm91bmQgaW4gdGhlIHN1cHBsaWVkIG9wdGlvbnMgb2JqZWN0LicsIHByaW50U3R5bGUpO1xuICAgIH1cblxuICAgIENvcmUucHJvdG90eXBlLnNldE9wdGlvbnMuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGl0ZW1zXG4gICAqIEBwYXJhbSB7dmlzLkRhdGFTZXQgfCBBcnJheSB8IG51bGx9IGl0ZW1zXG4gICAqL1xuICBHcmFwaDJkLnByb3RvdHlwZS5zZXRJdGVtcyA9IGZ1bmN0aW9uIChpdGVtcykge1xuICAgIHZhciBpbml0aWFsTG9hZCA9IHRoaXMuaXRlbXNEYXRhID09IG51bGw7XG5cbiAgICAvLyBjb252ZXJ0IHRvIHR5cGUgRGF0YVNldCB3aGVuIG5lZWRlZFxuICAgIHZhciBuZXdEYXRhU2V0O1xuICAgIGlmICghaXRlbXMpIHtcbiAgICAgIG5ld0RhdGFTZXQgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAoaXRlbXMgaW5zdGFuY2VvZiBEYXRhU2V0IHx8IGl0ZW1zIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICAgIG5ld0RhdGFTZXQgPSBpdGVtcztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdHVybiBhbiBhcnJheSBpbnRvIGEgZGF0YXNldFxuICAgICAgbmV3RGF0YVNldCA9IG5ldyBEYXRhU2V0KGl0ZW1zLCB7XG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICBzdGFydDogJ0RhdGUnLFxuICAgICAgICAgIGVuZDogJ0RhdGUnXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHNldCBpdGVtc1xuICAgIHRoaXMuaXRlbXNEYXRhID0gbmV3RGF0YVNldDtcbiAgICB0aGlzLmxpbmVncmFwaCAmJiB0aGlzLmxpbmVncmFwaC5zZXRJdGVtcyhuZXdEYXRhU2V0KTtcblxuICAgIGlmIChpbml0aWFsTG9hZCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGFydCAhPSB1bmRlZmluZWQgfHwgdGhpcy5vcHRpb25zLmVuZCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5vcHRpb25zLnN0YXJ0ICE9IHVuZGVmaW5lZCA/IHRoaXMub3B0aW9ucy5zdGFydCA6IG51bGw7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLm9wdGlvbnMuZW5kICE9IHVuZGVmaW5lZCA/IHRoaXMub3B0aW9ucy5lbmQgOiBudWxsO1xuICAgICAgICB0aGlzLnNldFdpbmRvdyhzdGFydCwgZW5kLCB7IGFuaW1hdGlvbjogZmFsc2UgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZpdCh7IGFuaW1hdGlvbjogZmFsc2UgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgZ3JvdXBzXG4gICAqIEBwYXJhbSB7dmlzLkRhdGFTZXQgfCBBcnJheX0gZ3JvdXBzXG4gICAqL1xuICBHcmFwaDJkLnByb3RvdHlwZS5zZXRHcm91cHMgPSBmdW5jdGlvbiAoZ3JvdXBzKSB7XG4gICAgLy8gY29udmVydCB0byB0eXBlIERhdGFTZXQgd2hlbiBuZWVkZWRcbiAgICB2YXIgbmV3RGF0YVNldDtcbiAgICBpZiAoIWdyb3Vwcykge1xuICAgICAgbmV3RGF0YVNldCA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChncm91cHMgaW5zdGFuY2VvZiBEYXRhU2V0IHx8IGdyb3VwcyBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG4gICAgICBuZXdEYXRhU2V0ID0gZ3JvdXBzO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0dXJuIGFuIGFycmF5IGludG8gYSBkYXRhc2V0XG4gICAgICBuZXdEYXRhU2V0ID0gbmV3IERhdGFTZXQoZ3JvdXBzKTtcbiAgICB9XG5cbiAgICB0aGlzLmdyb3Vwc0RhdGEgPSBuZXdEYXRhU2V0O1xuICAgIHRoaXMubGluZWdyYXBoLnNldEdyb3VwcyhuZXdEYXRhU2V0KTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyBhbiBTVkcgZWxlbWVudCB3aXRoIHRoZSBpY29uIG9mIHRoZSBncm91cCAoc2l6ZSBkZXRlcm1pbmVkIGJ5IGljb25XaWR0aCBhbmQgaWNvbkhlaWdodCksIHRoZSBsYWJlbCBvZiB0aGUgZ3JvdXAgKGNvbnRlbnQpIGFuZCB0aGUgeUF4aXNPcmllbnRhdGlvbiBvZiB0aGUgZ3JvdXAgKGxlZnQgb3IgcmlnaHQpLlxuICAgKiBAcGFyYW0gZ3JvdXBJZFxuICAgKiBAcGFyYW0gd2lkdGhcbiAgICogQHBhcmFtIGhlaWdodFxuICAgKi9cbiAgR3JhcGgyZC5wcm90b3R5cGUuZ2V0TGVnZW5kID0gZnVuY3Rpb24gKGdyb3VwSWQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAod2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgd2lkdGggPSAxNTtcbiAgICB9XG4gICAgaWYgKGhlaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBoZWlnaHQgPSAxNTtcbiAgICB9XG4gICAgaWYgKHRoaXMubGluZWdyYXBoLmdyb3Vwc1tncm91cElkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5saW5lZ3JhcGguZ3JvdXBzW2dyb3VwSWRdLmdldExlZ2VuZCh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFwiY2Fubm90IGZpbmQgZ3JvdXA6J1wiICsgZ3JvdXBJZCArIFwiJ1wiO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBjaGVja3MgaWYgdGhlIHZpc2libGUgb3B0aW9uIG9mIHRoZSBzdXBwbGllZCBncm91cCAoYnkgSUQpIGlzIHRydWUgb3IgZmFsc2UuXG4gICAqIEBwYXJhbSBncm91cElkXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgR3JhcGgyZC5wcm90b3R5cGUuaXNHcm91cFZpc2libGUgPSBmdW5jdGlvbiAoZ3JvdXBJZCkge1xuICAgIGlmICh0aGlzLmxpbmVncmFwaC5ncm91cHNbZ3JvdXBJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMubGluZWdyYXBoLmdyb3Vwc1tncm91cElkXS52aXNpYmxlICYmICh0aGlzLmxpbmVncmFwaC5vcHRpb25zLmdyb3Vwcy52aXNpYmlsaXR5W2dyb3VwSWRdID09PSB1bmRlZmluZWQgfHwgdGhpcy5saW5lZ3JhcGgub3B0aW9ucy5ncm91cHMudmlzaWJpbGl0eVtncm91cElkXSA9PSB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBkYXRhIHJhbmdlIG9mIHRoZSBpdGVtIHNldC5cbiAgICogQHJldHVybnMge3ttaW46IERhdGUsIG1heDogRGF0ZX19IHJhbmdlICBBIHJhbmdlIHdpdGggYSBzdGFydCBhbmQgZW5kIERhdGUuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgV2hlbiBubyBtaW5pbXVtIGlzIGZvdW5kLCBtaW49PW51bGxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBXaGVuIG5vIG1heGltdW0gaXMgZm91bmQsIG1heD09bnVsbFxuICAgKi9cbiAgR3JhcGgyZC5wcm90b3R5cGUuZ2V0RGF0YVJhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtaW4gPSBudWxsO1xuICAgIHZhciBtYXggPSBudWxsO1xuXG4gICAgLy8gY2FsY3VsYXRlIG1pbiBmcm9tIHN0YXJ0IGZpbGVkXG4gICAgZm9yICh2YXIgZ3JvdXBJZCBpbiB0aGlzLmxpbmVncmFwaC5ncm91cHMpIHtcbiAgICAgIGlmICh0aGlzLmxpbmVncmFwaC5ncm91cHMuaGFzT3duUHJvcGVydHkoZ3JvdXBJZCkpIHtcbiAgICAgICAgaWYgKHRoaXMubGluZWdyYXBoLmdyb3Vwc1tncm91cElkXS52aXNpYmxlID09IHRydWUpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGluZWdyYXBoLmdyb3Vwc1tncm91cElkXS5pdGVtc0RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gdGhpcy5saW5lZ3JhcGguZ3JvdXBzW2dyb3VwSWRdLml0ZW1zRGF0YVtpXTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHV0aWwuY29udmVydChpdGVtLngsICdEYXRlJykudmFsdWVPZigpO1xuICAgICAgICAgICAgbWluID0gbWluID09IG51bGwgPyB2YWx1ZSA6IG1pbiA+IHZhbHVlID8gdmFsdWUgOiBtaW47XG4gICAgICAgICAgICBtYXggPSBtYXggPT0gbnVsbCA/IHZhbHVlIDogbWF4IDwgdmFsdWUgPyB2YWx1ZSA6IG1heDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbWluOiBtaW4gIT0gbnVsbCA/IG5ldyBEYXRlKG1pbikgOiBudWxsLFxuICAgICAgbWF4OiBtYXggIT0gbnVsbCA/IG5ldyBEYXRlKG1heCkgOiBudWxsXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogR2VuZXJhdGUgVGltZWxpbmUgcmVsYXRlZCBpbmZvcm1hdGlvbiBmcm9tIGFuIGV2ZW50XG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHdpdGggcmVsYXRlZCBpbmZvcm1hdGlvbiwgbGlrZSBvbiB3aGljaCBhcmVhXG4gICAqICAgICAgICAgICAgICAgICAgVGhlIGV2ZW50IGhhcHBlbmVkLCB3aGV0aGVyIGNsaWNrZWQgb24gYW4gaXRlbSwgZXRjLlxuICAgKi9cbiAgR3JhcGgyZC5wcm90b3R5cGUuZ2V0RXZlbnRQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGNsaWVudFggPSBldmVudC5jZW50ZXIgPyBldmVudC5jZW50ZXIueCA6IGV2ZW50LmNsaWVudFg7XG4gICAgdmFyIGNsaWVudFkgPSBldmVudC5jZW50ZXIgPyBldmVudC5jZW50ZXIueSA6IGV2ZW50LmNsaWVudFk7XG4gICAgdmFyIHggPSBjbGllbnRYIC0gdXRpbC5nZXRBYnNvbHV0ZUxlZnQodGhpcy5kb20uY2VudGVyQ29udGFpbmVyKTtcbiAgICB2YXIgeSA9IGNsaWVudFkgLSB1dGlsLmdldEFic29sdXRlVG9wKHRoaXMuZG9tLmNlbnRlckNvbnRhaW5lcik7XG4gICAgdmFyIHRpbWUgPSB0aGlzLl90b1RpbWUoeCk7XG5cbiAgICB2YXIgY3VzdG9tVGltZSA9IEN1c3RvbVRpbWUuY3VzdG9tVGltZUZyb21UYXJnZXQoZXZlbnQpO1xuXG4gICAgdmFyIGVsZW1lbnQgPSB1dGlsLmdldFRhcmdldChldmVudCk7XG4gICAgdmFyIHdoYXQgPSBudWxsO1xuICAgIGlmICh1dGlsLmhhc1BhcmVudChlbGVtZW50LCB0aGlzLnRpbWVBeGlzLmRvbS5mb3JlZ3JvdW5kKSkge1xuICAgICAgd2hhdCA9ICdheGlzJztcbiAgICB9IGVsc2UgaWYgKHRoaXMudGltZUF4aXMyICYmIHV0aWwuaGFzUGFyZW50KGVsZW1lbnQsIHRoaXMudGltZUF4aXMyLmRvbS5mb3JlZ3JvdW5kKSkge1xuICAgICAgd2hhdCA9ICdheGlzJztcbiAgICB9IGVsc2UgaWYgKHV0aWwuaGFzUGFyZW50KGVsZW1lbnQsIHRoaXMubGluZWdyYXBoLnlBeGlzTGVmdC5kb20uZnJhbWUpKSB7XG4gICAgICB3aGF0ID0gJ2RhdGEtYXhpcyc7XG4gICAgfSBlbHNlIGlmICh1dGlsLmhhc1BhcmVudChlbGVtZW50LCB0aGlzLmxpbmVncmFwaC55QXhpc1JpZ2h0LmRvbS5mcmFtZSkpIHtcbiAgICAgIHdoYXQgPSAnZGF0YS1heGlzJztcbiAgICB9IGVsc2UgaWYgKHV0aWwuaGFzUGFyZW50KGVsZW1lbnQsIHRoaXMubGluZWdyYXBoLmxlZ2VuZExlZnQuZG9tLmZyYW1lKSkge1xuICAgICAgd2hhdCA9ICdsZWdlbmQnO1xuICAgIH0gZWxzZSBpZiAodXRpbC5oYXNQYXJlbnQoZWxlbWVudCwgdGhpcy5saW5lZ3JhcGgubGVnZW5kUmlnaHQuZG9tLmZyYW1lKSkge1xuICAgICAgd2hhdCA9ICdsZWdlbmQnO1xuICAgIH0gZWxzZSBpZiAoY3VzdG9tVGltZSAhPSBudWxsKSB7XG4gICAgICB3aGF0ID0gJ2N1c3RvbS10aW1lJztcbiAgICB9IGVsc2UgaWYgKHV0aWwuaGFzUGFyZW50KGVsZW1lbnQsIHRoaXMuY3VycmVudFRpbWUuYmFyKSkge1xuICAgICAgd2hhdCA9ICdjdXJyZW50LXRpbWUnO1xuICAgIH0gZWxzZSBpZiAodXRpbC5oYXNQYXJlbnQoZWxlbWVudCwgdGhpcy5kb20uY2VudGVyKSkge1xuICAgICAgd2hhdCA9ICdiYWNrZ3JvdW5kJztcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSBbXTtcbiAgICB2YXIgeUF4aXNMZWZ0ID0gdGhpcy5saW5lZ3JhcGgueUF4aXNMZWZ0O1xuICAgIHZhciB5QXhpc1JpZ2h0ID0gdGhpcy5saW5lZ3JhcGgueUF4aXNSaWdodDtcbiAgICBpZiAoIXlBeGlzTGVmdC5oaWRkZW4pIHtcbiAgICAgIHZhbHVlLnB1c2goeUF4aXNMZWZ0LnNjcmVlblRvVmFsdWUoeSkpO1xuICAgIH1cbiAgICBpZiAoIXlBeGlzUmlnaHQuaGlkZGVuKSB7XG4gICAgICB2YWx1ZS5wdXNoKHlBeGlzUmlnaHQuc2NyZWVuVG9WYWx1ZSh5KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgIHdoYXQ6IHdoYXQsXG4gICAgICBwYWdlWDogZXZlbnQuc3JjRXZlbnQgPyBldmVudC5zcmNFdmVudC5wYWdlWCA6IGV2ZW50LnBhZ2VYLFxuICAgICAgcGFnZVk6IGV2ZW50LnNyY0V2ZW50ID8gZXZlbnQuc3JjRXZlbnQucGFnZVkgOiBldmVudC5wYWdlWSxcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5LFxuICAgICAgdGltZTogdGltZSxcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIExvYWQgYSBjb25maWd1cmF0b3JcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgR3JhcGgyZC5wcm90b3R5cGUuX2NyZWF0ZUNvbmZpZ3VyYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IF9Db25maWd1cmF0b3IyLmRlZmF1bHQodGhpcywgdGhpcy5kb20uY29udGFpbmVyLCBjb25maWd1cmVPcHRpb25zKTtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IEdyYXBoMmQ7XG5cbi8qKiovIH0sXG4vKiA1MSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbiAgdmFyIERPTXV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuICB2YXIgRGF0YVNldCA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG4gIHZhciBEYXRhVmlldyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuICB2YXIgQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSk7XG4gIHZhciBEYXRhQXhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oNTIpO1xuICB2YXIgR3JhcGhHcm91cCA9IF9fd2VicGFja19yZXF1aXJlX18oNTQpO1xuICB2YXIgTGVnZW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OCk7XG4gIHZhciBCYXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NSk7XG4gIHZhciBMaW5lcyA9IF9fd2VicGFja19yZXF1aXJlX18oNTcpO1xuICB2YXIgUG9pbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nik7XG5cbiAgdmFyIFVOR1JPVVBFRCA9ICdfX3VuZ3JvdXBlZF9fJzsgLy8gcmVzZXJ2ZWQgZ3JvdXAgaWQgZm9yIHVuZ3JvdXBlZCBpdGVtc1xuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgTGluZUdyYXBoLiBJdCByZXF1aXJlcyBhIFRpbWVsaW5lIGJvZHkgYW5kIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSBib2R5XG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gTGluZUdyYXBoKGJvZHksIG9wdGlvbnMpIHtcbiAgICB0aGlzLmlkID0gdXRpbC5yYW5kb21VVUlEKCk7XG4gICAgdGhpcy5ib2R5ID0gYm9keTtcblxuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICB5QXhpc09yaWVudGF0aW9uOiAnbGVmdCcsXG4gICAgICBkZWZhdWx0R3JvdXA6ICdkZWZhdWx0JyxcbiAgICAgIHNvcnQ6IHRydWUsXG4gICAgICBzYW1wbGluZzogdHJ1ZSxcbiAgICAgIHN0YWNrOiBmYWxzZSxcbiAgICAgIGdyYXBoSGVpZ2h0OiAnNDAwcHgnLFxuICAgICAgc2hhZGVkOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBvcmllbnRhdGlvbjogJ2JvdHRvbScgLy8gdG9wLCBib3R0b20sIHplcm9cbiAgICAgIH0sXG4gICAgICBzdHlsZTogJ2xpbmUnLCAvLyBsaW5lLCBiYXJcbiAgICAgIGJhckNoYXJ0OiB7XG4gICAgICAgIHdpZHRoOiA1MCxcbiAgICAgICAgc2lkZUJ5U2lkZTogZmFsc2UsXG4gICAgICAgIGFsaWduOiAnY2VudGVyJyAvLyBsZWZ0LCBjZW50ZXIsIHJpZ2h0XG4gICAgICB9LFxuICAgICAgaW50ZXJwb2xhdGlvbjoge1xuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBwYXJhbWV0cml6YXRpb246ICdjZW50cmlwZXRhbCcsIC8vIHVuaWZvcm0gKGFscGhhID0gMC4wKSwgY2hvcmRhbCAoYWxwaGEgPSAxLjApLCBjZW50cmlwZXRhbCAoYWxwaGEgPSAwLjUpXG4gICAgICAgIGFscGhhOiAwLjVcbiAgICAgIH0sXG4gICAgICBkcmF3UG9pbnRzOiB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIHNpemU6IDYsXG4gICAgICAgIHN0eWxlOiAnc3F1YXJlJyAvLyBzcXVhcmUsIGNpcmNsZVxuICAgICAgfSxcbiAgICAgIGRhdGFBeGlzOiB7fSwgLy9EZWZhdWx0cyBhcmUgZG9uZSBvbiBEYXRhQXhpcyBsZXZlbFxuICAgICAgbGVnZW5kOiB7fSwgLy9EZWZhdWx0cyBhcmUgZG9uZSBvbiBMZWdlbmQgbGV2ZWxcbiAgICAgIGdyb3Vwczoge1xuICAgICAgICB2aXNpYmlsaXR5OiB7fVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBvcHRpb25zIGlzIHNoYXJlZCBieSB0aGlzIGxpbmVHcmFwaCBhbmQgYWxsIGl0cyBpdGVtc1xuICAgIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcbiAgICB0aGlzLmRvbSA9IHt9O1xuICAgIHRoaXMucHJvcHMgPSB7fTtcbiAgICB0aGlzLmhhbW1lciA9IG51bGw7XG4gICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICB0aGlzLmFib3J0ZWRHcmFwaFVwZGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMudXBkYXRlU1ZHaGVpZ2h0ID0gZmFsc2U7XG4gICAgdGhpcy51cGRhdGVTVkdoZWlnaHRPblJlc2l6ZSA9IGZhbHNlO1xuICAgIHRoaXMuZm9yY2VHcmFwaFVwZGF0ZSA9IHRydWU7XG5cbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHRoaXMuaXRlbXNEYXRhID0gbnVsbDsgLy8gRGF0YVNldFxuICAgIHRoaXMuZ3JvdXBzRGF0YSA9IG51bGw7IC8vIERhdGFTZXRcblxuICAgIC8vIGxpc3RlbmVycyBmb3IgdGhlIERhdGFTZXQgb2YgdGhlIGl0ZW1zXG4gICAgdGhpcy5pdGVtTGlzdGVuZXJzID0ge1xuICAgICAgJ2FkZCc6IGZ1bmN0aW9uIGFkZChldmVudCwgcGFyYW1zLCBzZW5kZXJJZCkge1xuICAgICAgICBtZS5fb25BZGQocGFyYW1zLml0ZW1zKTtcbiAgICAgIH0sXG4gICAgICAndXBkYXRlJzogZnVuY3Rpb24gdXBkYXRlKGV2ZW50LCBwYXJhbXMsIHNlbmRlcklkKSB7XG4gICAgICAgIG1lLl9vblVwZGF0ZShwYXJhbXMuaXRlbXMpO1xuICAgICAgfSxcbiAgICAgICdyZW1vdmUnOiBmdW5jdGlvbiByZW1vdmUoZXZlbnQsIHBhcmFtcywgc2VuZGVySWQpIHtcbiAgICAgICAgbWUuX29uUmVtb3ZlKHBhcmFtcy5pdGVtcyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIGxpc3RlbmVycyBmb3IgdGhlIERhdGFTZXQgb2YgdGhlIGdyb3Vwc1xuICAgIHRoaXMuZ3JvdXBMaXN0ZW5lcnMgPSB7XG4gICAgICAnYWRkJzogZnVuY3Rpb24gYWRkKGV2ZW50LCBwYXJhbXMsIHNlbmRlcklkKSB7XG4gICAgICAgIG1lLl9vbkFkZEdyb3VwcyhwYXJhbXMuaXRlbXMpO1xuICAgICAgfSxcbiAgICAgICd1cGRhdGUnOiBmdW5jdGlvbiB1cGRhdGUoZXZlbnQsIHBhcmFtcywgc2VuZGVySWQpIHtcbiAgICAgICAgbWUuX29uVXBkYXRlR3JvdXBzKHBhcmFtcy5pdGVtcyk7XG4gICAgICB9LFxuICAgICAgJ3JlbW92ZSc6IGZ1bmN0aW9uIHJlbW92ZShldmVudCwgcGFyYW1zLCBzZW5kZXJJZCkge1xuICAgICAgICBtZS5fb25SZW1vdmVHcm91cHMocGFyYW1zLml0ZW1zKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5pdGVtcyA9IHt9OyAvLyBvYmplY3Qgd2l0aCBhbiBJdGVtIGZvciBldmVyeSBkYXRhIGl0ZW1cbiAgICB0aGlzLnNlbGVjdGlvbiA9IFtdOyAvLyBsaXN0IHdpdGggdGhlIGlkcyBvZiBhbGwgc2VsZWN0ZWQgbm9kZXNcbiAgICB0aGlzLmxhc3RTdGFydCA9IHRoaXMuYm9keS5yYW5nZS5zdGFydDtcbiAgICB0aGlzLnRvdWNoUGFyYW1zID0ge307IC8vIHN0b3JlcyBwcm9wZXJ0aWVzIHdoaWxlIGRyYWdnaW5nXG5cbiAgICB0aGlzLnN2Z0VsZW1lbnRzID0ge307XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIHRoaXMuZ3JvdXBzVXNpbmdEZWZhdWx0U3R5bGVzID0gWzBdO1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdyYW5nZWNoYW5nZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBtZS5sYXN0U3RhcnQgPSBtZS5ib2R5LnJhbmdlLnN0YXJ0O1xuICAgICAgbWUuc3ZnLnN0eWxlLmxlZnQgPSB1dGlsLm9wdGlvbi5hc1NpemUoLW1lLnByb3BzLndpZHRoKTtcblxuICAgICAgbWUuZm9yY2VHcmFwaFVwZGF0ZSA9IHRydWU7XG4gICAgICAvL0lzIHRoaXMgbG9jYWwgcmVkcmF3IG5lY2Vzc2FyeT8gKENvcmUgYWxzbyBkb2VzIGEgY2hhbmdlIGV2ZW50ISlcbiAgICAgIG1lLnJlZHJhdy5jYWxsKG1lKTtcbiAgICB9KTtcblxuICAgIC8vIGNyZWF0ZSB0aGUgSFRNTCBET01cbiAgICB0aGlzLl9jcmVhdGUoKTtcbiAgICB0aGlzLmZyYW1ld29yayA9IHsgc3ZnOiB0aGlzLnN2Zywgc3ZnRWxlbWVudHM6IHRoaXMuc3ZnRWxlbWVudHMsIG9wdGlvbnM6IHRoaXMub3B0aW9ucywgZ3JvdXBzOiB0aGlzLmdyb3VwcyB9O1xuICB9XG5cbiAgTGluZUdyYXBoLnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnQoKTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBIVE1MIERPTSBmb3IgdGhlIEl0ZW1TZXRcbiAgICovXG4gIExpbmVHcmFwaC5wcm90b3R5cGUuX2NyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBmcmFtZS5jbGFzc05hbWUgPSAndmlzLWxpbmUtZ3JhcGgnO1xuICAgIHRoaXMuZG9tLmZyYW1lID0gZnJhbWU7XG5cbiAgICAvLyBjcmVhdGUgc3ZnIGVsZW1lbnQgZm9yIGdyYXBoIGRyYXdpbmcuXG4gICAgdGhpcy5zdmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ3N2ZycpO1xuICAgIHRoaXMuc3ZnLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICB0aGlzLnN2Zy5zdHlsZS5oZWlnaHQgPSAoJycgKyB0aGlzLm9wdGlvbnMuZ3JhcGhIZWlnaHQpLnJlcGxhY2UoJ3B4JywgJycpICsgJ3B4JztcbiAgICB0aGlzLnN2Zy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICBmcmFtZS5hcHBlbmRDaGlsZCh0aGlzLnN2Zyk7XG5cbiAgICAvLyBkYXRhIGF4aXNcbiAgICB0aGlzLm9wdGlvbnMuZGF0YUF4aXMub3JpZW50YXRpb24gPSAnbGVmdCc7XG4gICAgdGhpcy55QXhpc0xlZnQgPSBuZXcgRGF0YUF4aXModGhpcy5ib2R5LCB0aGlzLm9wdGlvbnMuZGF0YUF4aXMsIHRoaXMuc3ZnLCB0aGlzLm9wdGlvbnMuZ3JvdXBzKTtcblxuICAgIHRoaXMub3B0aW9ucy5kYXRhQXhpcy5vcmllbnRhdGlvbiA9ICdyaWdodCc7XG4gICAgdGhpcy55QXhpc1JpZ2h0ID0gbmV3IERhdGFBeGlzKHRoaXMuYm9keSwgdGhpcy5vcHRpb25zLmRhdGFBeGlzLCB0aGlzLnN2ZywgdGhpcy5vcHRpb25zLmdyb3Vwcyk7XG4gICAgZGVsZXRlIHRoaXMub3B0aW9ucy5kYXRhQXhpcy5vcmllbnRhdGlvbjtcblxuICAgIC8vIGxlZ2VuZHNcbiAgICB0aGlzLmxlZ2VuZExlZnQgPSBuZXcgTGVnZW5kKHRoaXMuYm9keSwgdGhpcy5vcHRpb25zLmxlZ2VuZCwgJ2xlZnQnLCB0aGlzLm9wdGlvbnMuZ3JvdXBzKTtcbiAgICB0aGlzLmxlZ2VuZFJpZ2h0ID0gbmV3IExlZ2VuZCh0aGlzLmJvZHksIHRoaXMub3B0aW9ucy5sZWdlbmQsICdyaWdodCcsIHRoaXMub3B0aW9ucy5ncm91cHMpO1xuXG4gICAgdGhpcy5zaG93KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIHNldCB0aGUgb3B0aW9ucyBvZiB0aGUgTGluZUdyYXBoLiB0aGUgbWVyZ2VPcHRpb25zIGlzIHVzZWQgZm9yIHN1Yk9iamVjdHMgdGhhdCBoYXZlIGFuIGVuYWJsZWQgZWxlbWVudC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIExpbmVHcmFwaC5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIHZhciBmaWVsZHMgPSBbJ3NhbXBsaW5nJywgJ2RlZmF1bHRHcm91cCcsICdzdGFjaycsICdoZWlnaHQnLCAnZ3JhcGhIZWlnaHQnLCAneUF4aXNPcmllbnRhdGlvbicsICdzdHlsZScsICdiYXJDaGFydCcsICdkYXRhQXhpcycsICdzb3J0JywgJ2dyb3VwcyddO1xuICAgICAgaWYgKG9wdGlvbnMuZ3JhcGhIZWlnaHQgPT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU1ZHaGVpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy51cGRhdGVTVkdoZWlnaHRPblJlc2l6ZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuYm9keS5kb21Qcm9wcy5jZW50ZXJDb250YWluZXIuaGVpZ2h0ICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5ncmFwaEhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChwYXJzZUludCgob3B0aW9ucy5ncmFwaEhlaWdodCArICcnKS5yZXBsYWNlKFwicHhcIiwgJycpKSA8IHRoaXMuYm9keS5kb21Qcm9wcy5jZW50ZXJDb250YWluZXIuaGVpZ2h0KSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVTVkdoZWlnaHQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB1dGlsLnNlbGVjdGl2ZURlZXBFeHRlbmQoZmllbGRzLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgdXRpbC5tZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBvcHRpb25zLCAnaW50ZXJwb2xhdGlvbicpO1xuICAgICAgdXRpbC5tZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBvcHRpb25zLCAnZHJhd1BvaW50cycpO1xuICAgICAgdXRpbC5tZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBvcHRpb25zLCAnc2hhZGVkJyk7XG4gICAgICB1dGlsLm1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMsICdsZWdlbmQnKTtcblxuICAgICAgaWYgKG9wdGlvbnMuaW50ZXJwb2xhdGlvbikge1xuICAgICAgICBpZiAoX3R5cGVvZihvcHRpb25zLmludGVycG9sYXRpb24pID09ICdvYmplY3QnKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuaW50ZXJwb2xhdGlvbi5wYXJhbWV0cml6YXRpb24pIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmludGVycG9sYXRpb24ucGFyYW1ldHJpemF0aW9uID09ICd1bmlmb3JtJykge1xuICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5hbHBoYSA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuaW50ZXJwb2xhdGlvbi5wYXJhbWV0cml6YXRpb24gPT0gJ2Nob3JkYWwnKSB7XG4gICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmFscGhhID0gMS4wO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmludGVycG9sYXRpb24ucGFyYW1ldHJpemF0aW9uID0gJ2NlbnRyaXBldGFsJztcbiAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmludGVycG9sYXRpb24uYWxwaGEgPSAwLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnlBeGlzTGVmdCkge1xuICAgICAgICBpZiAob3B0aW9ucy5kYXRhQXhpcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy55QXhpc0xlZnQuc2V0T3B0aW9ucyh0aGlzLm9wdGlvbnMuZGF0YUF4aXMpO1xuICAgICAgICAgIHRoaXMueUF4aXNSaWdodC5zZXRPcHRpb25zKHRoaXMub3B0aW9ucy5kYXRhQXhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubGVnZW5kTGVmdCkge1xuICAgICAgICBpZiAob3B0aW9ucy5sZWdlbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMubGVnZW5kTGVmdC5zZXRPcHRpb25zKHRoaXMub3B0aW9ucy5sZWdlbmQpO1xuICAgICAgICAgIHRoaXMubGVnZW5kUmlnaHQuc2V0T3B0aW9ucyh0aGlzLm9wdGlvbnMubGVnZW5kKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkoVU5HUk9VUEVEKSkge1xuICAgICAgICB0aGlzLmdyb3Vwc1tVTkdST1VQRURdLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdGhpcyBpcyB1c2VkIHRvIHJlZHJhdyB0aGUgZ3JhcGggaWYgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGdyb3VwcyBpcyBjaGFuZ2VkLlxuICAgIGlmICh0aGlzLmRvbS5mcmFtZSkge1xuICAgICAgLy9ub3Qgb24gaW5pdGlhbCBydW4/XG4gICAgICB0aGlzLmZvcmNlR3JhcGhVcGRhdGUgPSB0cnVlO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9jaGFuZ2VcIiwgeyBxdWV1ZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhpZGUgdGhlIGNvbXBvbmVudCBmcm9tIHRoZSBET01cbiAgICovXG4gIExpbmVHcmFwaC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyByZW1vdmUgdGhlIGZyYW1lIGNvbnRhaW5pbmcgdGhlIGl0ZW1zXG4gICAgaWYgKHRoaXMuZG9tLmZyYW1lLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuZG9tLmZyYW1lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20uZnJhbWUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2hvdyB0aGUgY29tcG9uZW50IGluIHRoZSBET00gKHdoZW4gbm90IGFscmVhZHkgdmlzaWJsZSkuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGNoYW5nZWRcbiAgICovXG4gIExpbmVHcmFwaC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBzaG93IGZyYW1lIGNvbnRhaW5pbmcgdGhlIGl0ZW1zXG4gICAgaWYgKCF0aGlzLmRvbS5mcmFtZS5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLmJvZHkuZG9tLmNlbnRlci5hcHBlbmRDaGlsZCh0aGlzLmRvbS5mcmFtZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgaXRlbXNcbiAgICogQHBhcmFtIHt2aXMuRGF0YVNldCB8IG51bGx9IGl0ZW1zXG4gICAqL1xuICBMaW5lR3JhcGgucHJvdG90eXBlLnNldEl0ZW1zID0gZnVuY3Rpb24gKGl0ZW1zKSB7XG4gICAgdmFyIG1lID0gdGhpcyxcbiAgICAgICAgaWRzLFxuICAgICAgICBvbGRJdGVtc0RhdGEgPSB0aGlzLml0ZW1zRGF0YTtcblxuICAgIC8vIHJlcGxhY2UgdGhlIGRhdGFzZXRcbiAgICBpZiAoIWl0ZW1zKSB7XG4gICAgICB0aGlzLml0ZW1zRGF0YSA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChpdGVtcyBpbnN0YW5jZW9mIERhdGFTZXQgfHwgaXRlbXMgaW5zdGFuY2VvZiBEYXRhVmlldykge1xuICAgICAgdGhpcy5pdGVtc0RhdGEgPSBpdGVtcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRGF0YSBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIERhdGFTZXQgb3IgRGF0YVZpZXcnKTtcbiAgICB9XG5cbiAgICBpZiAob2xkSXRlbXNEYXRhKSB7XG4gICAgICAvLyB1bnN1YnNjcmliZSBmcm9tIG9sZCBkYXRhc2V0XG4gICAgICB1dGlsLmZvckVhY2godGhpcy5pdGVtTGlzdGVuZXJzLCBmdW5jdGlvbiAoY2FsbGJhY2ssIGV2ZW50KSB7XG4gICAgICAgIG9sZEl0ZW1zRGF0YS5vZmYoZXZlbnQsIGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyByZW1vdmUgYWxsIGRyYXduIGl0ZW1zXG4gICAgICBpZHMgPSBvbGRJdGVtc0RhdGEuZ2V0SWRzKCk7XG4gICAgICB0aGlzLl9vblJlbW92ZShpZHMpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLml0ZW1zRGF0YSkge1xuICAgICAgLy8gc3Vic2NyaWJlIHRvIG5ldyBkYXRhc2V0XG4gICAgICB2YXIgaWQgPSB0aGlzLmlkO1xuICAgICAgdXRpbC5mb3JFYWNoKHRoaXMuaXRlbUxpc3RlbmVycywgZnVuY3Rpb24gKGNhbGxiYWNrLCBldmVudCkge1xuICAgICAgICBtZS5pdGVtc0RhdGEub24oZXZlbnQsIGNhbGxiYWNrLCBpZCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gYWRkIGFsbCBuZXcgaXRlbXNcbiAgICAgIGlkcyA9IHRoaXMuaXRlbXNEYXRhLmdldElkcygpO1xuICAgICAgdGhpcy5fb25BZGQoaWRzKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBncm91cHNcbiAgICogQHBhcmFtIHt2aXMuRGF0YVNldH0gZ3JvdXBzXG4gICAqL1xuICBMaW5lR3JhcGgucHJvdG90eXBlLnNldEdyb3VwcyA9IGZ1bmN0aW9uIChncm91cHMpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciBpZHM7XG5cbiAgICAvLyB1bnN1YnNjcmliZSBmcm9tIGN1cnJlbnQgZGF0YXNldFxuICAgIGlmICh0aGlzLmdyb3Vwc0RhdGEpIHtcbiAgICAgIHV0aWwuZm9yRWFjaCh0aGlzLmdyb3VwTGlzdGVuZXJzLCBmdW5jdGlvbiAoY2FsbGJhY2ssIGV2ZW50KSB7XG4gICAgICAgIG1lLmdyb3Vwc0RhdGEub2ZmKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgICB9KTtcblxuICAgICAgLy8gcmVtb3ZlIGFsbCBkcmF3biBncm91cHNcbiAgICAgIGlkcyA9IHRoaXMuZ3JvdXBzRGF0YS5nZXRJZHMoKTtcbiAgICAgIHRoaXMuZ3JvdXBzRGF0YSA9IG51bGw7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLl9yZW1vdmVHcm91cChpZHNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJlcGxhY2UgdGhlIGRhdGFzZXRcbiAgICBpZiAoIWdyb3Vwcykge1xuICAgICAgdGhpcy5ncm91cHNEYXRhID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGdyb3VwcyBpbnN0YW5jZW9mIERhdGFTZXQgfHwgZ3JvdXBzIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICAgIHRoaXMuZ3JvdXBzRGF0YSA9IGdyb3VwcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRGF0YSBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIERhdGFTZXQgb3IgRGF0YVZpZXcnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5ncm91cHNEYXRhKSB7XG4gICAgICAvLyBzdWJzY3JpYmUgdG8gbmV3IGRhdGFzZXRcbiAgICAgIHZhciBpZCA9IHRoaXMuaWQ7XG4gICAgICB1dGlsLmZvckVhY2godGhpcy5ncm91cExpc3RlbmVycywgZnVuY3Rpb24gKGNhbGxiYWNrLCBldmVudCkge1xuICAgICAgICBtZS5ncm91cHNEYXRhLm9uKGV2ZW50LCBjYWxsYmFjaywgaWQpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGRyYXcgYWxsIG1zXG4gICAgICBpZHMgPSB0aGlzLmdyb3Vwc0RhdGEuZ2V0SWRzKCk7XG4gICAgICB0aGlzLl9vbkFkZEdyb3VwcyhpZHMpO1xuICAgIH1cbiAgfTtcblxuICBMaW5lR3JhcGgucHJvdG90eXBlLl9vblVwZGF0ZSA9IGZ1bmN0aW9uIChpZHMpIHtcbiAgICB0aGlzLl91cGRhdGVBbGxHcm91cERhdGEoKTtcbiAgfTtcbiAgTGluZUdyYXBoLnByb3RvdHlwZS5fb25BZGQgPSBmdW5jdGlvbiAoaWRzKSB7XG4gICAgdGhpcy5fb25VcGRhdGUoaWRzKTtcbiAgfTtcbiAgTGluZUdyYXBoLnByb3RvdHlwZS5fb25SZW1vdmUgPSBmdW5jdGlvbiAoaWRzKSB7XG4gICAgdGhpcy5fb25VcGRhdGUoaWRzKTtcbiAgfTtcbiAgTGluZUdyYXBoLnByb3RvdHlwZS5fb25VcGRhdGVHcm91cHMgPSBmdW5jdGlvbiAoZ3JvdXBJZHMpIHtcbiAgICB0aGlzLl91cGRhdGVBbGxHcm91cERhdGEoKTtcbiAgfTtcbiAgTGluZUdyYXBoLnByb3RvdHlwZS5fb25BZGRHcm91cHMgPSBmdW5jdGlvbiAoZ3JvdXBJZHMpIHtcbiAgICB0aGlzLl9vblVwZGF0ZUdyb3Vwcyhncm91cElkcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIHRoaXMgY2xlYW5zIHRoZSBncm91cCBvdXQgb2ZmIHRoZSBsZWdlbmRzIGFuZCB0aGUgZGF0YWF4aXMsIHVwZGF0ZXMgdGhlIHVuZ3JvdXBlZCBhbmQgdXBkYXRlcyB0aGUgZ3JhcGhcbiAgICogQHBhcmFtIHtBcnJheX0gZ3JvdXBJZHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIExpbmVHcmFwaC5wcm90b3R5cGUuX29uUmVtb3ZlR3JvdXBzID0gZnVuY3Rpb24gKGdyb3VwSWRzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cElkcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fcmVtb3ZlR3JvdXAoZ3JvdXBJZHNbaV0pO1xuICAgIH1cbiAgICB0aGlzLmZvcmNlR3JhcGhVcGRhdGUgPSB0cnVlO1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfY2hhbmdlXCIsIHsgcXVldWU6IHRydWUgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIHRoaXMgY2xlYW5zIHRoZSBncm91cCBvdXQgb2ZmIHRoZSBsZWdlbmRzIGFuZCB0aGUgZGF0YWF4aXNcbiAgICogQHBhcmFtIGdyb3VwSWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIExpbmVHcmFwaC5wcm90b3R5cGUuX3JlbW92ZUdyb3VwID0gZnVuY3Rpb24gKGdyb3VwSWQpIHtcbiAgICBpZiAodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkoZ3JvdXBJZCkpIHtcbiAgICAgIGlmICh0aGlzLmdyb3Vwc1tncm91cElkXS5vcHRpb25zLnlBeGlzT3JpZW50YXRpb24gPT0gJ3JpZ2h0Jykge1xuICAgICAgICB0aGlzLnlBeGlzUmlnaHQucmVtb3ZlR3JvdXAoZ3JvdXBJZCk7XG4gICAgICAgIHRoaXMubGVnZW5kUmlnaHQucmVtb3ZlR3JvdXAoZ3JvdXBJZCk7XG4gICAgICAgIHRoaXMubGVnZW5kUmlnaHQucmVkcmF3KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnlBeGlzTGVmdC5yZW1vdmVHcm91cChncm91cElkKTtcbiAgICAgICAgdGhpcy5sZWdlbmRMZWZ0LnJlbW92ZUdyb3VwKGdyb3VwSWQpO1xuICAgICAgICB0aGlzLmxlZ2VuZExlZnQucmVkcmF3KCk7XG4gICAgICB9XG4gICAgICBkZWxldGUgdGhpcy5ncm91cHNbZ3JvdXBJZF07XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiB1cGRhdGUgYSBncm91cCBvYmplY3Qgd2l0aCB0aGUgZ3JvdXAgZGF0YXNldCBlbnRyZWVcbiAgICpcbiAgICogQHBhcmFtIGdyb3VwXG4gICAqIEBwYXJhbSBncm91cElkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBMaW5lR3JhcGgucHJvdG90eXBlLl91cGRhdGVHcm91cCA9IGZ1bmN0aW9uIChncm91cCwgZ3JvdXBJZCkge1xuICAgIGlmICghdGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkoZ3JvdXBJZCkpIHtcbiAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwSWRdID0gbmV3IEdyYXBoR3JvdXAoZ3JvdXAsIGdyb3VwSWQsIHRoaXMub3B0aW9ucywgdGhpcy5ncm91cHNVc2luZ0RlZmF1bHRTdHlsZXMpO1xuICAgICAgaWYgKHRoaXMuZ3JvdXBzW2dyb3VwSWRdLm9wdGlvbnMueUF4aXNPcmllbnRhdGlvbiA9PSAncmlnaHQnKSB7XG4gICAgICAgIHRoaXMueUF4aXNSaWdodC5hZGRHcm91cChncm91cElkLCB0aGlzLmdyb3Vwc1tncm91cElkXSk7XG4gICAgICAgIHRoaXMubGVnZW5kUmlnaHQuYWRkR3JvdXAoZ3JvdXBJZCwgdGhpcy5ncm91cHNbZ3JvdXBJZF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy55QXhpc0xlZnQuYWRkR3JvdXAoZ3JvdXBJZCwgdGhpcy5ncm91cHNbZ3JvdXBJZF0pO1xuICAgICAgICB0aGlzLmxlZ2VuZExlZnQuYWRkR3JvdXAoZ3JvdXBJZCwgdGhpcy5ncm91cHNbZ3JvdXBJZF0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmdyb3Vwc1tncm91cElkXS51cGRhdGUoZ3JvdXApO1xuICAgICAgaWYgKHRoaXMuZ3JvdXBzW2dyb3VwSWRdLm9wdGlvbnMueUF4aXNPcmllbnRhdGlvbiA9PSAncmlnaHQnKSB7XG4gICAgICAgIHRoaXMueUF4aXNSaWdodC51cGRhdGVHcm91cChncm91cElkLCB0aGlzLmdyb3Vwc1tncm91cElkXSk7XG4gICAgICAgIHRoaXMubGVnZW5kUmlnaHQudXBkYXRlR3JvdXAoZ3JvdXBJZCwgdGhpcy5ncm91cHNbZ3JvdXBJZF0pO1xuICAgICAgICAvL0lmIHlBeGlzT3JpZW50YXRpb24gY2hhbmdlZCwgY2xlYW4gb3V0IHRoZSBncm91cCBmcm9tIHRoZSBvdGhlciBheGlzLlxuICAgICAgICB0aGlzLnlBeGlzTGVmdC5yZW1vdmVHcm91cChncm91cElkKTtcbiAgICAgICAgdGhpcy5sZWdlbmRMZWZ0LnJlbW92ZUdyb3VwKGdyb3VwSWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy55QXhpc0xlZnQudXBkYXRlR3JvdXAoZ3JvdXBJZCwgdGhpcy5ncm91cHNbZ3JvdXBJZF0pO1xuICAgICAgICB0aGlzLmxlZ2VuZExlZnQudXBkYXRlR3JvdXAoZ3JvdXBJZCwgdGhpcy5ncm91cHNbZ3JvdXBJZF0pO1xuICAgICAgICAvL0lmIHlBeGlzT3JpZW50YXRpb24gY2hhbmdlZCwgY2xlYW4gb3V0IHRoZSBncm91cCBmcm9tIHRoZSBvdGhlciBheGlzLlxuICAgICAgICB0aGlzLnlBeGlzUmlnaHQucmVtb3ZlR3JvdXAoZ3JvdXBJZCk7XG4gICAgICAgIHRoaXMubGVnZW5kUmlnaHQucmVtb3ZlR3JvdXAoZ3JvdXBJZCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubGVnZW5kTGVmdC5yZWRyYXcoKTtcbiAgICB0aGlzLmxlZ2VuZFJpZ2h0LnJlZHJhdygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiB0aGlzIHVwZGF0ZXMgYWxsIGdyb3VwcywgaXQgaXMgdXNlZCB3aGVuIHRoZXJlIGlzIGFuIHVwZGF0ZSB0aGUgdGhlIGl0ZW1zZXQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBMaW5lR3JhcGgucHJvdG90eXBlLl91cGRhdGVBbGxHcm91cERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuaXRlbXNEYXRhICE9IG51bGwpIHtcbiAgICAgIHZhciBncm91cHNDb250ZW50ID0ge307XG4gICAgICB2YXIgaXRlbXMgPSB0aGlzLml0ZW1zRGF0YS5nZXQoKTtcbiAgICAgIC8vcHJlLURldGVybWluZSBhcnJheSBzaXplcywgZm9yIG1vcmUgZWZmaWNpZW50IG1lbW9yeSBjbGFpbVxuICAgICAgdmFyIGdyb3VwQ291bnRzID0ge307XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIHZhciBncm91cElkID0gaXRlbS5ncm91cDtcbiAgICAgICAgaWYgKGdyb3VwSWQgPT09IG51bGwgfHwgZ3JvdXBJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZ3JvdXBJZCA9IFVOR1JPVVBFRDtcbiAgICAgICAgfVxuICAgICAgICBncm91cENvdW50cy5oYXNPd25Qcm9wZXJ0eShncm91cElkKSA/IGdyb3VwQ291bnRzW2dyb3VwSWRdKysgOiBncm91cENvdW50c1tncm91cElkXSA9IDE7XG4gICAgICB9XG4gICAgICAvL05vdyBpbnNlcnQgZGF0YSBpbnRvIHRoZSBhcnJheXMuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIHZhciBncm91cElkID0gaXRlbS5ncm91cDtcbiAgICAgICAgaWYgKGdyb3VwSWQgPT09IG51bGwgfHwgZ3JvdXBJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZ3JvdXBJZCA9IFVOR1JPVVBFRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWdyb3Vwc0NvbnRlbnQuaGFzT3duUHJvcGVydHkoZ3JvdXBJZCkpIHtcbiAgICAgICAgICBncm91cHNDb250ZW50W2dyb3VwSWRdID0gbmV3IEFycmF5KGdyb3VwQ291bnRzW2dyb3VwSWRdKTtcbiAgICAgICAgfVxuICAgICAgICAvL0NvcHkgZGF0YSAoYmVjYXVzZSBvZiB1bm1vZGlmaWFibGUgRGF0YVZpZXcgaW5wdXQuXG4gICAgICAgIHZhciBleHRlbmRlZCA9IHV0aWwuYnJpZGdlT2JqZWN0KGl0ZW0pO1xuICAgICAgICBleHRlbmRlZC54ID0gdXRpbC5jb252ZXJ0KGl0ZW0ueCwgJ0RhdGUnKTtcbiAgICAgICAgZXh0ZW5kZWQub3JnaW5hbFkgPSBpdGVtLnk7IC8vcmVhbCBZXG4gICAgICAgIGV4dGVuZGVkLnkgPSBOdW1iZXIoaXRlbS55KTtcblxuICAgICAgICB2YXIgaW5kZXggPSBncm91cHNDb250ZW50W2dyb3VwSWRdLmxlbmd0aCAtIGdyb3VwQ291bnRzW2dyb3VwSWRdLS07XG4gICAgICAgIGdyb3Vwc0NvbnRlbnRbZ3JvdXBJZF1baW5kZXhdID0gZXh0ZW5kZWQ7XG4gICAgICB9XG5cbiAgICAgIC8vTWFrZSBzdXJlIGFsbCBncm91cHMgYXJlIHByZXNlbnQsIHRvIGFsbG93IHJlbW92YWwgb2Ygb2xkIGdyb3Vwc1xuICAgICAgZm9yICh2YXIgZ3JvdXBJZCBpbiB0aGlzLmdyb3Vwcykge1xuICAgICAgICBpZiAodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkoZ3JvdXBJZCkpIHtcbiAgICAgICAgICBpZiAoIWdyb3Vwc0NvbnRlbnQuaGFzT3duUHJvcGVydHkoZ3JvdXBJZCkpIHtcbiAgICAgICAgICAgIGdyb3Vwc0NvbnRlbnRbZ3JvdXBJZF0gPSBuZXcgQXJyYXkoMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vVXBkYXRlIGxlZ2VuZGFzLCBzdHlsZSBhbmQgYXhpc1xuICAgICAgZm9yICh2YXIgZ3JvdXBJZCBpbiBncm91cHNDb250ZW50KSB7XG4gICAgICAgIGlmIChncm91cHNDb250ZW50Lmhhc093blByb3BlcnR5KGdyb3VwSWQpKSB7XG4gICAgICAgICAgaWYgKGdyb3Vwc0NvbnRlbnRbZ3JvdXBJZF0ubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShncm91cElkKSkge1xuICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVHcm91cChncm91cElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ3JvdXBzRGF0YSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZ3JvdXAgPSB0aGlzLmdyb3Vwc0RhdGEuZ2V0KGdyb3VwSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBncm91cCA9IHsgaWQ6IGdyb3VwSWQsIGNvbnRlbnQ6IHRoaXMub3B0aW9ucy5kZWZhdWx0R3JvdXAgKyBncm91cElkIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVHcm91cChncm91cCwgZ3JvdXBJZCk7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwc1tncm91cElkXS5zZXRJdGVtcyhncm91cHNDb250ZW50W2dyb3VwSWRdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZm9yY2VHcmFwaFVwZGF0ZSA9IHRydWU7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2NoYW5nZVwiLCB7IHF1ZXVlOiB0cnVlIH0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVkcmF3IHRoZSBjb21wb25lbnQsIG1hbmRhdG9yeSBmdW5jdGlvblxuICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGNvbXBvbmVudCBpcyByZXNpemVkXG4gICAqL1xuICBMaW5lR3JhcGgucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzaXplZCA9IGZhbHNlO1xuXG4gICAgLy8gY2FsY3VsYXRlIGFjdHVhbCBzaXplIGFuZCBwb3NpdGlvblxuICAgIHRoaXMucHJvcHMud2lkdGggPSB0aGlzLmRvbS5mcmFtZS5vZmZzZXRXaWR0aDtcbiAgICB0aGlzLnByb3BzLmhlaWdodCA9IHRoaXMuYm9keS5kb21Qcm9wcy5jZW50ZXJDb250YWluZXIuaGVpZ2h0IC0gdGhpcy5ib2R5LmRvbVByb3BzLmJvcmRlci50b3AgLSB0aGlzLmJvZHkuZG9tUHJvcHMuYm9yZGVyLmJvdHRvbTtcblxuICAgIC8vIGNoZWNrIGlmIHRoaXMgY29tcG9uZW50IGlzIHJlc2l6ZWRcbiAgICByZXNpemVkID0gdGhpcy5faXNSZXNpemVkKCkgfHwgcmVzaXplZDtcblxuICAgIC8vIGNoZWNrIHdoZXRoZXIgem9vbWVkIChpbiB0aGF0IGNhc2Ugd2UgbmVlZCB0byByZS1zdGFjayBldmVyeXRoaW5nKVxuICAgIHZhciB2aXNpYmxlSW50ZXJ2YWwgPSB0aGlzLmJvZHkucmFuZ2UuZW5kIC0gdGhpcy5ib2R5LnJhbmdlLnN0YXJ0O1xuICAgIHZhciB6b29tZWQgPSB2aXNpYmxlSW50ZXJ2YWwgIT0gdGhpcy5sYXN0VmlzaWJsZUludGVydmFsO1xuICAgIHRoaXMubGFzdFZpc2libGVJbnRlcnZhbCA9IHZpc2libGVJbnRlcnZhbDtcblxuICAgIC8vIHRoZSBzdmcgZWxlbWVudCBpcyB0aHJlZSB0aW1lcyBhcyBiaWcgYXMgdGhlIHdpZHRoLCB0aGlzIGFsbG93cyBmb3IgZnVsbHkgZHJhZ2dpbmcgbGVmdCBhbmQgcmlnaHRcbiAgICAvLyB3aXRob3V0IHJlbG9hZGluZyB0aGUgZ3JhcGguIHRoZSBjb250cm9scyBmb3IgdGhpcyBhcmUgYm91bmQgdG8gZXZlbnRzIGluIHRoZSBjb25zdHJ1Y3RvclxuICAgIGlmIChyZXNpemVkID09IHRydWUpIHtcbiAgICAgIHRoaXMuc3ZnLnN0eWxlLndpZHRoID0gdXRpbC5vcHRpb24uYXNTaXplKDMgKiB0aGlzLnByb3BzLndpZHRoKTtcbiAgICAgIHRoaXMuc3ZnLnN0eWxlLmxlZnQgPSB1dGlsLm9wdGlvbi5hc1NpemUoLXRoaXMucHJvcHMud2lkdGgpO1xuXG4gICAgICAvLyBpZiB0aGUgaGVpZ2h0IG9mIHRoZSBncmFwaCBpcyBzZXQgYXMgcHJvcG9ydGlvbmFsLCBjaGFuZ2UgdGhlIGhlaWdodCBvZiB0aGUgc3ZnXG4gICAgICBpZiAoKHRoaXMub3B0aW9ucy5oZWlnaHQgKyAnJykuaW5kZXhPZihcIiVcIikgIT0gLTEgfHwgdGhpcy51cGRhdGVTVkdoZWlnaHRPblJlc2l6ZSA9PSB0cnVlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU1ZHaGVpZ2h0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgdGhlIGhlaWdodCBvZiB0aGUgZ3JhcGggb24gZWFjaCByZWRyYXcgb2YgdGhlIGdyYXBoLlxuICAgIGlmICh0aGlzLnVwZGF0ZVNWR2hlaWdodCA9PSB0cnVlKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmdyYXBoSGVpZ2h0ICE9IHRoaXMucHJvcHMuaGVpZ2h0ICsgJ3B4Jykge1xuICAgICAgICB0aGlzLm9wdGlvbnMuZ3JhcGhIZWlnaHQgPSB0aGlzLnByb3BzLmhlaWdodCArICdweCc7XG4gICAgICAgIHRoaXMuc3ZnLnN0eWxlLmhlaWdodCA9IHRoaXMucHJvcHMuaGVpZ2h0ICsgJ3B4JztcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlU1ZHaGVpZ2h0ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3ZnLnN0eWxlLmhlaWdodCA9ICgnJyArIHRoaXMub3B0aW9ucy5ncmFwaEhlaWdodCkucmVwbGFjZSgncHgnLCAnJykgKyAncHgnO1xuICAgIH1cblxuICAgIC8vIHpvb21lZCBpcyBoZXJlIHRvIGVuc3VyZSB0aGF0IGFuaW1hdGlvbnMgYXJlIHNob3duIGNvcnJlY3RseS5cbiAgICBpZiAocmVzaXplZCA9PSB0cnVlIHx8IHpvb21lZCA9PSB0cnVlIHx8IHRoaXMuYWJvcnRlZEdyYXBoVXBkYXRlID09IHRydWUgfHwgdGhpcy5mb3JjZUdyYXBoVXBkYXRlID09IHRydWUpIHtcbiAgICAgIHJlc2l6ZWQgPSB0aGlzLl91cGRhdGVHcmFwaCgpIHx8IHJlc2l6ZWQ7XG4gICAgICB0aGlzLmZvcmNlR3JhcGhVcGRhdGUgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbW92ZSB0aGUgd2hvbGUgc3ZnIHdoaWxlIGRyYWdnaW5nXG4gICAgICBpZiAodGhpcy5sYXN0U3RhcnQgIT0gMCkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5ib2R5LnJhbmdlLnN0YXJ0IC0gdGhpcy5sYXN0U3RhcnQ7XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuYm9keS5yYW5nZS5lbmQgLSB0aGlzLmJvZHkucmFuZ2Uuc3RhcnQ7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLndpZHRoICE9IDApIHtcbiAgICAgICAgICB2YXIgcmFuZ2VQZXJQaXhlbEludiA9IHRoaXMucHJvcHMud2lkdGggLyByYW5nZTtcbiAgICAgICAgICB2YXIgeE9mZnNldCA9IG9mZnNldCAqIHJhbmdlUGVyUGl4ZWxJbnY7XG4gICAgICAgICAgdGhpcy5zdmcuc3R5bGUubGVmdCA9IC10aGlzLnByb3BzLndpZHRoIC0geE9mZnNldCArICdweCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5sZWdlbmRMZWZ0LnJlZHJhdygpO1xuICAgIHRoaXMubGVnZW5kUmlnaHQucmVkcmF3KCk7XG4gICAgcmV0dXJuIHJlc2l6ZWQ7XG4gIH07XG5cbiAgTGluZUdyYXBoLnByb3RvdHlwZS5fZ2V0U29ydGVkR3JvdXBJZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gZ2V0dGluZyBncm91cCBJZHNcbiAgICB2YXIgZ3JvdXBsaXN0ID0gW107XG4gICAgZm9yICh2YXIgZ3JvdXBJZCBpbiB0aGlzLmdyb3Vwcykge1xuICAgICAgaWYgKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KGdyb3VwSWQpKSB7XG4gICAgICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXBzW2dyb3VwSWRdO1xuICAgICAgICBpZiAoZ3JvdXAudmlzaWJsZSA9PSB0cnVlICYmICh0aGlzLm9wdGlvbnMuZ3JvdXBzLnZpc2liaWxpdHlbZ3JvdXBJZF0gPT09IHVuZGVmaW5lZCB8fCB0aGlzLm9wdGlvbnMuZ3JvdXBzLnZpc2liaWxpdHlbZ3JvdXBJZF0gPT0gdHJ1ZSkpIHtcbiAgICAgICAgICBncm91cGxpc3QucHVzaCh7IGlkOiBncm91cElkLCB6SW5kZXg6IGdyb3VwLm9wdGlvbnMuekluZGV4IH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHV0aWwuaW5zZXJ0U29ydChncm91cGxpc3QsIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICB2YXIgYXogPSBhLnpJbmRleDtcbiAgICAgIHZhciBieiA9IGIuekluZGV4O1xuICAgICAgaWYgKGF6ID09PSB1bmRlZmluZWQpIGF6ID0gMDtcbiAgICAgIGlmIChieiA9PT0gdW5kZWZpbmVkKSBieiA9IDA7XG4gICAgICByZXR1cm4gYXogPT0gYnogPyAwIDogYXogPCBieiA/IC0xIDogMTtcbiAgICB9KTtcbiAgICB2YXIgZ3JvdXBJZHMgPSBuZXcgQXJyYXkoZ3JvdXBsaXN0Lmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGdyb3VwSWRzW2ldID0gZ3JvdXBsaXN0W2ldLmlkO1xuICAgIH1cbiAgICByZXR1cm4gZ3JvdXBJZHM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBhbmQgcmVkcmF3IHRoZSBncmFwaC5cbiAgICpcbiAgICovXG4gIExpbmVHcmFwaC5wcm90b3R5cGUuX3VwZGF0ZUdyYXBoID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHJlc2V0IHRoZSBzdmcgZWxlbWVudHNcbiAgICBET011dGlsLnByZXBhcmVFbGVtZW50cyh0aGlzLnN2Z0VsZW1lbnRzKTtcbiAgICBpZiAodGhpcy5wcm9wcy53aWR0aCAhPSAwICYmIHRoaXMuaXRlbXNEYXRhICE9IG51bGwpIHtcbiAgICAgIHZhciBncm91cCwgaTtcbiAgICAgIHZhciBncm91cFJhbmdlcyA9IHt9O1xuICAgICAgdmFyIGNoYW5nZUNhbGxlZCA9IGZhbHNlO1xuICAgICAgLy8gdGhpcyBpcyB0aGUgcmFuZ2Ugb2YgdGhlIFNWRyBjYW52YXNcbiAgICAgIHZhciBtaW5EYXRlID0gdGhpcy5ib2R5LnV0aWwudG9HbG9iYWxUaW1lKC10aGlzLmJvZHkuZG9tUHJvcHMucm9vdC53aWR0aCk7XG4gICAgICB2YXIgbWF4RGF0ZSA9IHRoaXMuYm9keS51dGlsLnRvR2xvYmFsVGltZSgyICogdGhpcy5ib2R5LmRvbVByb3BzLnJvb3Qud2lkdGgpO1xuXG4gICAgICAvLyBnZXR0aW5nIGdyb3VwIElkc1xuICAgICAgdmFyIGdyb3VwSWRzID0gdGhpcy5fZ2V0U29ydGVkR3JvdXBJZHMoKTtcbiAgICAgIGlmIChncm91cElkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBncm91cHNEYXRhID0ge307XG5cbiAgICAgICAgLy8gZmlsbCBncm91cHMgZGF0YSwgdGhpcyBvbmx5IGxvYWRzIHRoZSBkYXRhIHdlIHJlcXVpcmUgYmFzZWQgb24gdGhlIHRpbWV3aW5kb3dcbiAgICAgICAgdGhpcy5fZ2V0UmVsZXZhbnREYXRhKGdyb3VwSWRzLCBncm91cHNEYXRhLCBtaW5EYXRlLCBtYXhEYXRlKTtcblxuICAgICAgICAvLyBhcHBseSBzYW1wbGluZywgaWYgZGlzYWJsZWQsIGl0IHdpbGwgcGFzcyB0aHJvdWdoIHRoaXMgZnVuY3Rpb24uXG4gICAgICAgIHRoaXMuX2FwcGx5U2FtcGxpbmcoZ3JvdXBJZHMsIGdyb3Vwc0RhdGEpO1xuXG4gICAgICAgIC8vIHdlIHRyYW5zZm9ybSB0aGUgWCBjb29yZGluYXRlcyB0byBkZXRlY3QgY29sbGlzaW9uc1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZ3JvdXBJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLl9jb252ZXJ0WGNvb3JkaW5hdGVzKGdyb3Vwc0RhdGFbZ3JvdXBJZHNbaV1dKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vdyBhbGwgbmVlZGVkIGRhdGEgaGFzIGJlZW4gY29sbGVjdGVkIHdlIHN0YXJ0IHRoZSBwcm9jZXNzaW5nLlxuICAgICAgICB0aGlzLl9nZXRZUmFuZ2VzKGdyb3VwSWRzLCBncm91cHNEYXRhLCBncm91cFJhbmdlcyk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBZIGF4aXMgZmlyc3QsIHdlIHVzZSB0aGlzIGRhdGEgdG8gZHJhdyBhdCB0aGUgY29ycmVjdCBZIHBvaW50c1xuICAgICAgICBjaGFuZ2VDYWxsZWQgPSB0aGlzLl91cGRhdGVZQXhpcyhncm91cElkcywgZ3JvdXBSYW5nZXMpO1xuXG4gICAgICAgIC8vICBhdCBjaGFuZ2VDYWxsZWQsIGFib3J0IHRoaXMgdXBkYXRlIGN5Y2xlIGFzIHRoZSBncmFwaCBuZWVkcyBhbm90aGVyIHVwZGF0ZSB3aXRoIG5ldyBXaWR0aCBpbnB1dCBmcm9tIHRoZSBSZWRyYXcgY29udGFpbmVyLlxuICAgICAgICAvLyAgQ2xlYW51cCBTVkcgZWxlbWVudHMgb24gYWJvcnQuXG4gICAgICAgIGlmIChjaGFuZ2VDYWxsZWQgPT0gdHJ1ZSkge1xuICAgICAgICAgIERPTXV0aWwuY2xlYW51cEVsZW1lbnRzKHRoaXMuc3ZnRWxlbWVudHMpO1xuICAgICAgICAgIHRoaXMuYWJvcnRlZEdyYXBoVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFib3J0ZWRHcmFwaFVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgICAgIC8vIFdpdGggdGhlIHlBeGlzIHNjYWxlZCBjb3JyZWN0bHksIHVzZSB0aGlzIHRvIGdldCB0aGUgWSB2YWx1ZXMgb2YgdGhlIHBvaW50cy5cbiAgICAgICAgdmFyIGJlbG93ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZ3JvdXBJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBncm91cCA9IHRoaXMuZ3JvdXBzW2dyb3VwSWRzW2ldXTtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0YWNrID09PSB0cnVlICYmIHRoaXMub3B0aW9ucy5zdHlsZSA9PT0gJ2xpbmUnKSB7XG4gICAgICAgICAgICBpZiAoZ3JvdXAub3B0aW9ucy5leGNsdWRlRnJvbVN0YWNraW5nID09IHVuZGVmaW5lZCB8fCAhZ3JvdXAub3B0aW9ucy5leGNsdWRlRnJvbVN0YWNraW5nKSB7XG4gICAgICAgICAgICAgIGlmIChiZWxvdyAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFjayhncm91cHNEYXRhW2dyb3VwLmlkXSwgZ3JvdXBzRGF0YVtiZWxvdy5pZF0pO1xuICAgICAgICAgICAgICAgIGlmIChncm91cC5vcHRpb25zLnNoYWRlZC5lbmFibGVkID09IHRydWUgJiYgZ3JvdXAub3B0aW9ucy5zaGFkZWQub3JpZW50YXRpb24gIT09IFwiZ3JvdXBcIikge1xuICAgICAgICAgICAgICAgICAgaWYgKGdyb3VwLm9wdGlvbnMuc2hhZGVkLm9yaWVudGF0aW9uID09IFwidG9wXCIgJiYgYmVsb3cub3B0aW9ucy5zaGFkZWQub3JpZW50YXRpb24gIT09IFwiZ3JvdXBcIikge1xuICAgICAgICAgICAgICAgICAgICBiZWxvdy5vcHRpb25zLnNoYWRlZC5vcmllbnRhdGlvbiA9IFwiZ3JvdXBcIjtcbiAgICAgICAgICAgICAgICAgICAgYmVsb3cub3B0aW9ucy5zaGFkZWQuZ3JvdXBJZCA9IGdyb3VwLmlkO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAub3B0aW9ucy5zaGFkZWQub3JpZW50YXRpb24gPSBcImdyb3VwXCI7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLm9wdGlvbnMuc2hhZGVkLmdyb3VwSWQgPSBiZWxvdy5pZDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYmVsb3cgPSBncm91cDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fY29udmVydFljb29yZGluYXRlcyhncm91cHNEYXRhW2dyb3VwSWRzW2ldXSwgZ3JvdXApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9QcmVjYWxjdWxhdGUgcGF0aHMgYW5kIGRyYXcgc2hhZGluZyBpZiBhcHByb3ByaWF0ZS4gVGhpcyB3aWxsIG1ha2Ugc3VyZSB0aGUgc2hhZGluZyBpcyBhbHdheXMgYmVoaW5kIGFueSBsaW5lcy5cbiAgICAgICAgdmFyIHBhdGhzID0ge307XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBncm91cElkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGdyb3VwID0gdGhpcy5ncm91cHNbZ3JvdXBJZHNbaV1dO1xuICAgICAgICAgIGlmIChncm91cC5vcHRpb25zLnN0eWxlID09PSAnbGluZScgJiYgZ3JvdXAub3B0aW9ucy5zaGFkZWQuZW5hYmxlZCA9PSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgZGF0YXNldCA9IGdyb3Vwc0RhdGFbZ3JvdXBJZHNbaV1dO1xuICAgICAgICAgICAgaWYgKGRhdGFzZXQgPT0gbnVsbCB8fCBkYXRhc2V0Lmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwYXRocy5oYXNPd25Qcm9wZXJ0eShncm91cElkc1tpXSkpIHtcbiAgICAgICAgICAgICAgcGF0aHNbZ3JvdXBJZHNbaV1dID0gTGluZXMuY2FsY1BhdGgoZGF0YXNldCwgZ3JvdXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyb3VwLm9wdGlvbnMuc2hhZGVkLm9yaWVudGF0aW9uID09PSBcImdyb3VwXCIpIHtcbiAgICAgICAgICAgICAgdmFyIHN1Ykdyb3VwSWQgPSBncm91cC5vcHRpb25zLnNoYWRlZC5ncm91cElkO1xuICAgICAgICAgICAgICBpZiAoZ3JvdXBJZHMuaW5kZXhPZihzdWJHcm91cElkKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhncm91cC5pZCArIFwiOiBVbmtub3duIHNoYWRpbmcgZ3JvdXAgdGFyZ2V0IGdpdmVuOlwiICsgc3ViR3JvdXBJZCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFwYXRocy5oYXNPd25Qcm9wZXJ0eShzdWJHcm91cElkKSkge1xuICAgICAgICAgICAgICAgIHBhdGhzW3N1Ykdyb3VwSWRdID0gTGluZXMuY2FsY1BhdGgoZ3JvdXBzRGF0YVtzdWJHcm91cElkXSwgdGhpcy5ncm91cHNbc3ViR3JvdXBJZF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIExpbmVzLmRyYXdTaGFkaW5nKHBhdGhzW2dyb3VwSWRzW2ldXSwgZ3JvdXAsIHBhdGhzW3N1Ykdyb3VwSWRdLCB0aGlzLmZyYW1ld29yayk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBMaW5lcy5kcmF3U2hhZGluZyhwYXRoc1tncm91cElkc1tpXV0sIGdyb3VwLCB1bmRlZmluZWQsIHRoaXMuZnJhbWV3b3JrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkcmF3IHRoZSBncm91cHMsIGNhbGN1bGF0aW5nIHBhdGhzIGlmIHN0aWxsIG5lY2Vzc2FyeS5cbiAgICAgICAgQmFycy5kcmF3KGdyb3VwSWRzLCBncm91cHNEYXRhLCB0aGlzLmZyYW1ld29yayk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBncm91cElkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGdyb3VwID0gdGhpcy5ncm91cHNbZ3JvdXBJZHNbaV1dO1xuICAgICAgICAgIGlmIChncm91cHNEYXRhW2dyb3VwSWRzW2ldXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGdyb3VwLm9wdGlvbnMuc3R5bGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImxpbmVcIjpcbiAgICAgICAgICAgICAgICBpZiAoIXBhdGhzLmhhc093blByb3BlcnR5KGdyb3VwSWRzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgcGF0aHNbZ3JvdXBJZHNbaV1dID0gTGluZXMuY2FsY1BhdGgoZ3JvdXBzRGF0YVtncm91cElkc1tpXV0sIGdyb3VwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgTGluZXMuZHJhdyhwYXRoc1tncm91cElkc1tpXV0sIGdyb3VwLCB0aGlzLmZyYW1ld29yayk7XG4gICAgICAgICAgICAgIC8vZXhwbGljaXQgbm8gYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJwb2ludFwiOlxuICAgICAgICAgICAgICAvL2V4cGxpY2l0IG5vIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwicG9pbnRzXCI6XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwLm9wdGlvbnMuc3R5bGUgPT0gXCJwb2ludFwiIHx8IGdyb3VwLm9wdGlvbnMuc3R5bGUgPT0gXCJwb2ludHNcIiB8fCBncm91cC5vcHRpb25zLmRyYXdQb2ludHMuZW5hYmxlZCA9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICBQb2ludHMuZHJhdyhncm91cHNEYXRhW2dyb3VwSWRzW2ldXSwgZ3JvdXAsIHRoaXMuZnJhbWV3b3JrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJiYXJcIjpcbiAgICAgICAgICAgICAgLy8gYmFyIG5lZWRzIHRvIGJlIGRyYXduIGVubWFzc2VcbiAgICAgICAgICAgICAgLy9leHBsaWNpdCBubyBicmVha1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAvL2RvIG5vdGhpbmcuLi5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjbGVhbnVwIHVudXNlZCBzdmcgZWxlbWVudHNcbiAgICBET011dGlsLmNsZWFudXBFbGVtZW50cyh0aGlzLnN2Z0VsZW1lbnRzKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgTGluZUdyYXBoLnByb3RvdHlwZS5fc3RhY2sgPSBmdW5jdGlvbiAoZGF0YSwgc3ViRGF0YSkge1xuICAgIHZhciBpbmRleCwgZHgsIGR5LCBzdWJQcmV2UG9pbnQsIHN1Yk5leHRQb2ludDtcbiAgICBpbmRleCA9IDA7XG4gICAgLy8gZm9yIGVhY2ggZGF0YSBwb2ludCB3ZSBsb29rIGZvciBhIG1hdGNoaW5nIG9uIGluIHRoZSBzZXQgYmVsb3dcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRhdGEubGVuZ3RoOyBqKyspIHtcbiAgICAgIHN1YlByZXZQb2ludCA9IHVuZGVmaW5lZDtcbiAgICAgIHN1Yk5leHRQb2ludCA9IHVuZGVmaW5lZDtcbiAgICAgIC8vIHdlIGxvb2sgZm9yIHRpbWUgbWF0Y2hlcyBvciBhIGJlZm9yZS1hZnRlciBwb2ludFxuICAgICAgZm9yICh2YXIgayA9IGluZGV4OyBrIDwgc3ViRGF0YS5sZW5ndGg7IGsrKykge1xuICAgICAgICAvLyBpZiB0aW1lcyBtYXRjaCBleGFjdGx5XG4gICAgICAgIGlmIChzdWJEYXRhW2tdLnggPT09IGRhdGFbal0ueCkge1xuICAgICAgICAgIHN1YlByZXZQb2ludCA9IHN1YkRhdGFba107XG4gICAgICAgICAgc3ViTmV4dFBvaW50ID0gc3ViRGF0YVtrXTtcbiAgICAgICAgICBpbmRleCA9IGs7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAoc3ViRGF0YVtrXS54ID4gZGF0YVtqXS54KSB7XG4gICAgICAgICAgLy8gb3ZlcnNob290XG4gICAgICAgICAgc3ViTmV4dFBvaW50ID0gc3ViRGF0YVtrXTtcbiAgICAgICAgICBpZiAoayA9PSAwKSB7XG4gICAgICAgICAgICBzdWJQcmV2UG9pbnQgPSBzdWJOZXh0UG9pbnQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1YlByZXZQb2ludCA9IHN1YkRhdGFbayAtIDFdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbmRleCA9IGs7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGluIGNhc2UgdGhlIGxhc3QgZGF0YSBwb2ludCBoYXMgYmVlbiB1c2VkLCB3ZSBhc3N1bWUgaXQgc3RheXMgbGlrZSB0aGlzLlxuICAgICAgaWYgKHN1Yk5leHRQb2ludCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN1YlByZXZQb2ludCA9IHN1YkRhdGFbc3ViRGF0YS5sZW5ndGggLSAxXTtcbiAgICAgICAgc3ViTmV4dFBvaW50ID0gc3ViRGF0YVtzdWJEYXRhLmxlbmd0aCAtIDFdO1xuICAgICAgfVxuICAgICAgLy8gbGluZWFyIGludGVycG9sYXRpb25cbiAgICAgIGR4ID0gc3ViTmV4dFBvaW50LnggLSBzdWJQcmV2UG9pbnQueDtcbiAgICAgIGR5ID0gc3ViTmV4dFBvaW50LnkgLSBzdWJQcmV2UG9pbnQueTtcbiAgICAgIGlmIChkeCA9PSAwKSB7XG4gICAgICAgIGRhdGFbal0ueSA9IGRhdGFbal0ub3JnaW5hbFkgKyBzdWJOZXh0UG9pbnQueTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGFbal0ueSA9IGRhdGFbal0ub3JnaW5hbFkgKyBkeSAvIGR4ICogKGRhdGFbal0ueCAtIHN1YlByZXZQb2ludC54KSArIHN1YlByZXZQb2ludC55OyAvLyBheCArIGIgd2hlcmUgYiBpcyBkYXRhW2pdLnlcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIGZpcnN0IHNlbGVjdCBhbmQgcHJlcHJvY2VzcyB0aGUgZGF0YSBmcm9tIHRoZSBkYXRhc2V0cy5cbiAgICogdGhlIGdyb3VwcyBoYXZlIHRoZWlyIHByZXNlbGVjdGlvbiBvZiBkYXRhLCB3ZSBub3cgbG9vcCBvdmVyIHRoaXMgZGF0YSB0byBzZWVcbiAgICogd2hhdCBkYXRhIHdlIG5lZWQgdG8gZHJhdy4gU29ydGVkIGRhdGEgaXMgbXVjaCBmYXN0ZXIuXG4gICAqIG1vcmUgb3B0aW1pemF0aW9uIGlzIHBvc3NpYmxlIGJ5IGRvaW5nIHRoZSBzYW1wbGluZyBiZWZvcmUgYW5kIHVzaW5nIHRoZSBiaW5hcnkgc2VhcmNoXG4gICAqIHRvIGZpbmQgdGhlIGVuZCBkYXRlIHRvIGRldGVybWluZSB0aGUgaW5jcmVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5fSAgZ3JvdXBJZHNcbiAgICogQHBhcmFtIHtvYmplY3R9IGdyb3Vwc0RhdGFcbiAgICogQHBhcmFtIHtkYXRlfSAgIG1pbkRhdGVcbiAgICogQHBhcmFtIHtkYXRlfSAgIG1heERhdGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIExpbmVHcmFwaC5wcm90b3R5cGUuX2dldFJlbGV2YW50RGF0YSA9IGZ1bmN0aW9uIChncm91cElkcywgZ3JvdXBzRGF0YSwgbWluRGF0ZSwgbWF4RGF0ZSkge1xuICAgIHZhciBncm91cCwgaSwgaiwgaXRlbTtcbiAgICBpZiAoZ3JvdXBJZHMubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGdyb3VwSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGdyb3VwID0gdGhpcy5ncm91cHNbZ3JvdXBJZHNbaV1dO1xuICAgICAgICB2YXIgaXRlbXNEYXRhID0gZ3JvdXAuZ2V0SXRlbXMoKTtcbiAgICAgICAgLy8gb3B0aW1pemF0aW9uIGZvciBzb3J0ZWQgZGF0YVxuICAgICAgICBpZiAoZ3JvdXAub3B0aW9ucy5zb3J0ID09IHRydWUpIHtcbiAgICAgICAgICB2YXIgZGF0ZUNvbXBhcmF0b3IgPSBmdW5jdGlvbiBkYXRlQ29tcGFyYXRvcihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5nZXRUaW1lKCkgPT0gYi5nZXRUaW1lKCkgPyAwIDogYSA8IGIgPyAtMSA6IDE7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgZmlyc3QgPSBNYXRoLm1heCgwLCB1dGlsLmJpbmFyeVNlYXJjaFZhbHVlKGl0ZW1zRGF0YSwgbWluRGF0ZSwgJ3gnLCAnYmVmb3JlJywgZGF0ZUNvbXBhcmF0b3IpKTtcbiAgICAgICAgICB2YXIgbGFzdCA9IE1hdGgubWluKGl0ZW1zRGF0YS5sZW5ndGgsIHV0aWwuYmluYXJ5U2VhcmNoVmFsdWUoaXRlbXNEYXRhLCBtYXhEYXRlLCAneCcsICdhZnRlcicsIGRhdGVDb21wYXJhdG9yKSArIDEpO1xuICAgICAgICAgIGlmIChsYXN0IDw9IDApIHtcbiAgICAgICAgICAgIGxhc3QgPSBpdGVtc0RhdGEubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZGF0YUNvbnRhaW5lciA9IG5ldyBBcnJheShsYXN0IC0gZmlyc3QpO1xuICAgICAgICAgIGZvciAoaiA9IGZpcnN0OyBqIDwgbGFzdDsgaisrKSB7XG4gICAgICAgICAgICBpdGVtID0gZ3JvdXAuaXRlbXNEYXRhW2pdO1xuICAgICAgICAgICAgZGF0YUNvbnRhaW5lcltqIC0gZmlyc3RdID0gaXRlbTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZ3JvdXBzRGF0YVtncm91cElkc1tpXV0gPSBkYXRhQ29udGFpbmVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIHVuc29ydGVkIGRhdGEsIGFsbCBkYXRhIGlzIHJlbGV2YW50LCBqdXN0IHJldHVybmluZyBlbnRpcmUgc3RydWN0dXJlXG4gICAgICAgICAgZ3JvdXBzRGF0YVtncm91cElkc1tpXV0gPSBncm91cC5pdGVtc0RhdGE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSBncm91cElkc1xuICAgKiBAcGFyYW0gZ3JvdXBzRGF0YVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTGluZUdyYXBoLnByb3RvdHlwZS5fYXBwbHlTYW1wbGluZyA9IGZ1bmN0aW9uIChncm91cElkcywgZ3JvdXBzRGF0YSkge1xuICAgIHZhciBncm91cDtcbiAgICBpZiAoZ3JvdXBJZHMubGVuZ3RoID4gMCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cElkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBncm91cCA9IHRoaXMuZ3JvdXBzW2dyb3VwSWRzW2ldXTtcbiAgICAgICAgaWYgKGdyb3VwLm9wdGlvbnMuc2FtcGxpbmcgPT0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBkYXRhQ29udGFpbmVyID0gZ3JvdXBzRGF0YVtncm91cElkc1tpXV07XG4gICAgICAgICAgaWYgKGRhdGFDb250YWluZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGluY3JlbWVudCA9IDE7XG4gICAgICAgICAgICB2YXIgYW1vdW50T2ZQb2ludHMgPSBkYXRhQ29udGFpbmVyLmxlbmd0aDtcblxuICAgICAgICAgICAgLy8gdGhlIGdsb2JhbCBzY3JlZW4gaXMgdXNlZCBiZWNhdXNlIGNoYW5naW5nIHRoZSB3aWR0aCBvZiB0aGUgeUF4aXMgbWF5IGFmZmVjdCB0aGUgaW5jcmVtZW50LCByZXN1bHRpbmcgaW4gYW4gZW5kbGVzcyBsb29wXG4gICAgICAgICAgICAvLyBvZiB3aWR0aCBjaGFuZ2luZyBvZiB0aGUgeUF4aXMuXG4gICAgICAgICAgICB2YXIgeERpc3RhbmNlID0gdGhpcy5ib2R5LnV0aWwudG9HbG9iYWxTY3JlZW4oZGF0YUNvbnRhaW5lcltkYXRhQ29udGFpbmVyLmxlbmd0aCAtIDFdLngpIC0gdGhpcy5ib2R5LnV0aWwudG9HbG9iYWxTY3JlZW4oZGF0YUNvbnRhaW5lclswXS54KTtcbiAgICAgICAgICAgIHZhciBwb2ludHNQZXJQaXhlbCA9IGFtb3VudE9mUG9pbnRzIC8geERpc3RhbmNlO1xuICAgICAgICAgICAgaW5jcmVtZW50ID0gTWF0aC5taW4oTWF0aC5jZWlsKDAuMiAqIGFtb3VudE9mUG9pbnRzKSwgTWF0aC5tYXgoMSwgTWF0aC5yb3VuZChwb2ludHNQZXJQaXhlbCkpKTtcblxuICAgICAgICAgICAgdmFyIHNhbXBsZWREYXRhID0gbmV3IEFycmF5KGFtb3VudE9mUG9pbnRzKTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYW1vdW50T2ZQb2ludHM7IGogKz0gaW5jcmVtZW50KSB7XG4gICAgICAgICAgICAgIHZhciBpZHggPSBNYXRoLnJvdW5kKGogLyBpbmNyZW1lbnQpO1xuICAgICAgICAgICAgICBzYW1wbGVkRGF0YVtpZHhdID0gZGF0YUNvbnRhaW5lcltqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdyb3Vwc0RhdGFbZ3JvdXBJZHNbaV1dID0gc2FtcGxlZERhdGEuc3BsaWNlKDAsIE1hdGgucm91bmQoYW1vdW50T2ZQb2ludHMgLyBpbmNyZW1lbnQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSB7YXJyYXl9ICBncm91cElkc1xuICAgKiBAcGFyYW0ge29iamVjdH0gZ3JvdXBzRGF0YVxuICAgKiBAcGFyYW0ge29iamVjdH0gZ3JvdXBSYW5nZXMgIHwgdGhpcyBpcyBiZWluZyBmaWxsZWQgaGVyZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTGluZUdyYXBoLnByb3RvdHlwZS5fZ2V0WVJhbmdlcyA9IGZ1bmN0aW9uIChncm91cElkcywgZ3JvdXBzRGF0YSwgZ3JvdXBSYW5nZXMpIHtcbiAgICB2YXIgZ3JvdXBEYXRhLCBncm91cCwgaTtcbiAgICB2YXIgY29tYmluZWREYXRhTGVmdCA9IFtdO1xuICAgIHZhciBjb21iaW5lZERhdGFSaWdodCA9IFtdO1xuICAgIHZhciBvcHRpb25zO1xuICAgIGlmIChncm91cElkcy5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZ3JvdXBJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZ3JvdXBEYXRhID0gZ3JvdXBzRGF0YVtncm91cElkc1tpXV07XG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLmdyb3Vwc1tncm91cElkc1tpXV0ub3B0aW9ucztcbiAgICAgICAgaWYgKGdyb3VwRGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZ3JvdXAgPSB0aGlzLmdyb3Vwc1tncm91cElkc1tpXV07XG4gICAgICAgICAgLy8gaWYgYmFyIGdyYXBocyBhcmUgc3RhY2tlZCwgdGhlaXIgcmFuZ2UgbmVlZCB0byBiZSBoYW5kbGVkIGRpZmZlcmVudGx5IGFuZCBhY2N1bXVsYXRlZCBvdmVyIGFsbCBncm91cHMuXG4gICAgICAgICAgaWYgKG9wdGlvbnMuc3RhY2sgPT09IHRydWUgJiYgb3B0aW9ucy5zdHlsZSA9PT0gJ2JhcicpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnlBeGlzT3JpZW50YXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgICBjb21iaW5lZERhdGFMZWZ0ID0gY29tYmluZWREYXRhTGVmdC5jb25jYXQoZ3JvdXAuZ2V0SXRlbXMoKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb21iaW5lZERhdGFSaWdodCA9IGNvbWJpbmVkRGF0YVJpZ2h0LmNvbmNhdChncm91cC5nZXRJdGVtcygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ3JvdXBSYW5nZXNbZ3JvdXBJZHNbaV1dID0gZ3JvdXAuZ2V0WVJhbmdlKGdyb3VwRGF0YSwgZ3JvdXBJZHNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBpZiBiYXIgZ3JhcGhzIGFyZSBzdGFja2VkLCB0aGVpciByYW5nZSBuZWVkIHRvIGJlIGhhbmRsZWQgZGlmZmVyZW50bHkgYW5kIGFjY3VtdWxhdGVkIG92ZXIgYWxsIGdyb3Vwcy5cbiAgICAgIEJhcnMuZ2V0U3RhY2tlZFlSYW5nZShjb21iaW5lZERhdGFMZWZ0LCBncm91cFJhbmdlcywgZ3JvdXBJZHMsICdfX2JhclN0YWNrTGVmdCcsICdsZWZ0Jyk7XG4gICAgICBCYXJzLmdldFN0YWNrZWRZUmFuZ2UoY29tYmluZWREYXRhUmlnaHQsIGdyb3VwUmFuZ2VzLCBncm91cElkcywgJ19fYmFyU3RhY2tSaWdodCcsICdyaWdodCcpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogdGhpcyBzZXRzIHRoZSBZIHJhbmdlcyBmb3IgdGhlIFkgYXhpcy4gSXQgYWxzbyBkZXRlcm1pbmVzIHdoaWNoIG9mIHRoZSBheGlzIHNob3VsZCBiZSBzaG93biBvciBoaWRkZW4uXG4gICAqIEBwYXJhbSB7QXJyYXl9IGdyb3VwSWRzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBncm91cFJhbmdlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTGluZUdyYXBoLnByb3RvdHlwZS5fdXBkYXRlWUF4aXMgPSBmdW5jdGlvbiAoZ3JvdXBJZHMsIGdyb3VwUmFuZ2VzKSB7XG4gICAgdmFyIHJlc2l6ZWQgPSBmYWxzZTtcbiAgICB2YXIgeUF4aXNMZWZ0VXNlZCA9IGZhbHNlO1xuICAgIHZhciB5QXhpc1JpZ2h0VXNlZCA9IGZhbHNlO1xuICAgIHZhciBtaW5MZWZ0ID0gMWU5LFxuICAgICAgICBtaW5SaWdodCA9IDFlOSxcbiAgICAgICAgbWF4TGVmdCA9IC0xZTksXG4gICAgICAgIG1heFJpZ2h0ID0gLTFlOSxcbiAgICAgICAgbWluVmFsLFxuICAgICAgICBtYXhWYWw7XG4gICAgLy8gaWYgZ3JvdXBzIGFyZSBwcmVzZW50XG4gICAgaWYgKGdyb3VwSWRzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIHRoaXMgaXMgaGVyZSB0byBtYWtlIHN1cmUgdGhhdCBpZiB0aGVyZSBhcmUgbm8gaXRlbXMgaW4gdGhlIGF4aXMgYnV0IHRoZXJlIGFyZSBncm91cHMsIHRoYXQgdGhlcmUgaXMgbm8gaW5maW5pdGUgZHJhdy9yZWRyYXcgbG9vcC5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cHNbZ3JvdXBJZHNbaV1dO1xuICAgICAgICBpZiAoZ3JvdXAgJiYgZ3JvdXAub3B0aW9ucy55QXhpc09yaWVudGF0aW9uICE9ICdyaWdodCcpIHtcbiAgICAgICAgICB5QXhpc0xlZnRVc2VkID0gdHJ1ZTtcbiAgICAgICAgICBtaW5MZWZ0ID0gMWU5O1xuICAgICAgICAgIG1heExlZnQgPSAtMWU5O1xuICAgICAgICB9IGVsc2UgaWYgKGdyb3VwICYmIGdyb3VwLm9wdGlvbnMueUF4aXNPcmllbnRhdGlvbikge1xuICAgICAgICAgIHlBeGlzUmlnaHRVc2VkID0gdHJ1ZTtcbiAgICAgICAgICBtaW5SaWdodCA9IDFlOTtcbiAgICAgICAgICBtYXhSaWdodCA9IC0xZTk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gaWYgdGhlcmUgYXJlIGl0ZW1zOlxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cElkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZ3JvdXBSYW5nZXMuaGFzT3duUHJvcGVydHkoZ3JvdXBJZHNbaV0pKSB7XG4gICAgICAgICAgaWYgKGdyb3VwUmFuZ2VzW2dyb3VwSWRzW2ldXS5pZ25vcmUgIT09IHRydWUpIHtcbiAgICAgICAgICAgIG1pblZhbCA9IGdyb3VwUmFuZ2VzW2dyb3VwSWRzW2ldXS5taW47XG4gICAgICAgICAgICBtYXhWYWwgPSBncm91cFJhbmdlc1tncm91cElkc1tpXV0ubWF4O1xuXG4gICAgICAgICAgICBpZiAoZ3JvdXBSYW5nZXNbZ3JvdXBJZHNbaV1dLnlBeGlzT3JpZW50YXRpb24gIT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgICB5QXhpc0xlZnRVc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgbWluTGVmdCA9IG1pbkxlZnQgPiBtaW5WYWwgPyBtaW5WYWwgOiBtaW5MZWZ0O1xuICAgICAgICAgICAgICBtYXhMZWZ0ID0gbWF4TGVmdCA8IG1heFZhbCA/IG1heFZhbCA6IG1heExlZnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB5QXhpc1JpZ2h0VXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgIG1pblJpZ2h0ID0gbWluUmlnaHQgPiBtaW5WYWwgPyBtaW5WYWwgOiBtaW5SaWdodDtcbiAgICAgICAgICAgICAgbWF4UmlnaHQgPSBtYXhSaWdodCA8IG1heFZhbCA/IG1heFZhbCA6IG1heFJpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoeUF4aXNMZWZ0VXNlZCA9PSB0cnVlKSB7XG4gICAgICAgIHRoaXMueUF4aXNMZWZ0LnNldFJhbmdlKG1pbkxlZnQsIG1heExlZnQpO1xuICAgICAgfVxuICAgICAgaWYgKHlBeGlzUmlnaHRVc2VkID09IHRydWUpIHtcbiAgICAgICAgdGhpcy55QXhpc1JpZ2h0LnNldFJhbmdlKG1pblJpZ2h0LCBtYXhSaWdodCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc2l6ZWQgPSB0aGlzLl90b2dnbGVBeGlzVmlzaWJsaXR5KHlBeGlzTGVmdFVzZWQsIHRoaXMueUF4aXNMZWZ0KSB8fCByZXNpemVkO1xuICAgIHJlc2l6ZWQgPSB0aGlzLl90b2dnbGVBeGlzVmlzaWJsaXR5KHlBeGlzUmlnaHRVc2VkLCB0aGlzLnlBeGlzUmlnaHQpIHx8IHJlc2l6ZWQ7XG5cbiAgICBpZiAoeUF4aXNSaWdodFVzZWQgPT0gdHJ1ZSAmJiB5QXhpc0xlZnRVc2VkID09IHRydWUpIHtcbiAgICAgIHRoaXMueUF4aXNMZWZ0LmRyYXdJY29ucyA9IHRydWU7XG4gICAgICB0aGlzLnlBeGlzUmlnaHQuZHJhd0ljb25zID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy55QXhpc0xlZnQuZHJhd0ljb25zID0gZmFsc2U7XG4gICAgICB0aGlzLnlBeGlzUmlnaHQuZHJhd0ljb25zID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMueUF4aXNSaWdodC5tYXN0ZXIgPSAheUF4aXNMZWZ0VXNlZDtcbiAgICB0aGlzLnlBeGlzUmlnaHQubWFzdGVyQXhpcyA9IHRoaXMueUF4aXNMZWZ0O1xuXG4gICAgaWYgKHRoaXMueUF4aXNSaWdodC5tYXN0ZXIgPT0gZmFsc2UpIHtcbiAgICAgIGlmICh5QXhpc1JpZ2h0VXNlZCA9PSB0cnVlKSB7XG4gICAgICAgIHRoaXMueUF4aXNMZWZ0LmxpbmVPZmZzZXQgPSB0aGlzLnlBeGlzUmlnaHQud2lkdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnlBeGlzTGVmdC5saW5lT2Zmc2V0ID0gMDtcbiAgICAgIH1cblxuICAgICAgcmVzaXplZCA9IHRoaXMueUF4aXNMZWZ0LnJlZHJhdygpIHx8IHJlc2l6ZWQ7XG4gICAgICByZXNpemVkID0gdGhpcy55QXhpc1JpZ2h0LnJlZHJhdygpIHx8IHJlc2l6ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc2l6ZWQgPSB0aGlzLnlBeGlzUmlnaHQucmVkcmF3KCkgfHwgcmVzaXplZDtcbiAgICB9XG5cbiAgICAvLyBjbGVhbiB0aGUgYWNjdW11bGF0ZWQgbGlzdHNcbiAgICB2YXIgdGVtcEdyb3VwcyA9IFsnX19iYXJTdGFja0xlZnQnLCAnX19iYXJTdGFja1JpZ2h0JywgJ19fbGluZVN0YWNrTGVmdCcsICdfX2xpbmVTdGFja1JpZ2h0J107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZW1wR3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZ3JvdXBJZHMuaW5kZXhPZih0ZW1wR3JvdXBzW2ldKSAhPSAtMSkge1xuICAgICAgICBncm91cElkcy5zcGxpY2UoZ3JvdXBJZHMuaW5kZXhPZih0ZW1wR3JvdXBzW2ldKSwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc2l6ZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgc2hvd3Mgb3IgaGlkZXMgdGhlIFkgYXhpcyBpZiBuZWVkZWQuIElmIHRoZXJlIGlzIGEgY2hhbmdlLCB0aGUgY2hhbmdlZCBldmVudCBpcyBlbWl0dGVkIGJ5IHRoZSB1cGRhdGVZQXhpcyBmdW5jdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGF4aXNVc2VkXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gYXhpc1xuICAgKi9cbiAgTGluZUdyYXBoLnByb3RvdHlwZS5fdG9nZ2xlQXhpc1Zpc2libGl0eSA9IGZ1bmN0aW9uIChheGlzVXNlZCwgYXhpcykge1xuICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG4gICAgaWYgKGF4aXNVc2VkID09IGZhbHNlKSB7XG4gICAgICBpZiAoYXhpcy5kb20uZnJhbWUucGFyZW50Tm9kZSAmJiBheGlzLmhpZGRlbiA9PSBmYWxzZSkge1xuICAgICAgICBheGlzLmhpZGUoKTtcbiAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghYXhpcy5kb20uZnJhbWUucGFyZW50Tm9kZSAmJiBheGlzLmhpZGRlbiA9PSB0cnVlKSB7XG4gICAgICAgIGF4aXMuc2hvdygpO1xuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgdXNlcyB0aGUgRGF0YUF4aXMgb2JqZWN0IHRvIGdlbmVyYXRlIHRoZSBjb3JyZWN0IFggY29vcmRpbmF0ZSBvbiB0aGUgU1ZHIHdpbmRvdy4gSXQgdXNlcyB0aGVcbiAgICogdXRpbCBmdW5jdGlvbiB0b1NjcmVlbiB0byBnZXQgdGhlIHggY29vcmRpbmF0ZSBmcm9tIHRoZSB0aW1lc3RhbXAuIEl0IGFsc28gcHJlLWZpbHRlcnMgdGhlIGRhdGEgYW5kIGdldCB0aGUgbWluTWF4IHJhbmdlcyBmb3JcbiAgICogdGhlIHlBeGlzLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YXBvaW50c1xuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBMaW5lR3JhcGgucHJvdG90eXBlLl9jb252ZXJ0WGNvb3JkaW5hdGVzID0gZnVuY3Rpb24gKGRhdGFwb2ludHMpIHtcbiAgICB2YXIgdG9TY3JlZW4gPSB0aGlzLmJvZHkudXRpbC50b1NjcmVlbjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGFwb2ludHNbaV0uc2NyZWVuX3ggPSB0b1NjcmVlbihkYXRhcG9pbnRzW2ldLngpICsgdGhpcy5wcm9wcy53aWR0aDtcbiAgICAgIGRhdGFwb2ludHNbaV0uc2NyZWVuX3kgPSBkYXRhcG9pbnRzW2ldLnk7IC8vc3RhcnRpbmcgcG9pbnQgZm9yIHJhbmdlIGNhbGN1bGF0aW9uc1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVGhpcyB1c2VzIHRoZSBEYXRhQXhpcyBvYmplY3QgdG8gZ2VuZXJhdGUgdGhlIGNvcnJlY3QgWCBjb29yZGluYXRlIG9uIHRoZSBTVkcgd2luZG93LiBJdCB1c2VzIHRoZVxuICAgKiB1dGlsIGZ1bmN0aW9uIHRvU2NyZWVuIHRvIGdldCB0aGUgeCBjb29yZGluYXRlIGZyb20gdGhlIHRpbWVzdGFtcC4gSXQgYWxzbyBwcmUtZmlsdGVycyB0aGUgZGF0YSBhbmQgZ2V0IHRoZSBtaW5NYXggcmFuZ2VzIGZvclxuICAgKiB0aGUgeUF4aXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhcG9pbnRzXG4gICAqIEBwYXJhbSBncm91cFxuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBMaW5lR3JhcGgucHJvdG90eXBlLl9jb252ZXJ0WWNvb3JkaW5hdGVzID0gZnVuY3Rpb24gKGRhdGFwb2ludHMsIGdyb3VwKSB7XG4gICAgdmFyIGF4aXMgPSB0aGlzLnlBeGlzTGVmdDtcbiAgICB2YXIgc3ZnSGVpZ2h0ID0gTnVtYmVyKHRoaXMuc3ZnLnN0eWxlLmhlaWdodC5yZXBsYWNlKCdweCcsICcnKSk7XG4gICAgaWYgKGdyb3VwLm9wdGlvbnMueUF4aXNPcmllbnRhdGlvbiA9PSAncmlnaHQnKSB7XG4gICAgICBheGlzID0gdGhpcy55QXhpc1JpZ2h0O1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGFwb2ludHNbaV0uc2NyZWVuX3kgPSBNYXRoLnJvdW5kKGF4aXMuY29udmVydFZhbHVlKGRhdGFwb2ludHNbaV0ueSkpO1xuICAgIH1cbiAgICBncm91cC5zZXRaZXJvUG9zaXRpb24oTWF0aC5taW4oc3ZnSGVpZ2h0LCBheGlzLmNvbnZlcnRWYWx1ZSgwKSkpO1xuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gTGluZUdyYXBoO1xuXG4vKioqLyB9LFxuLyogNTIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4gIHZhciBET011dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbiAgdmFyIENvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xuICB2YXIgRGF0YVNjYWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Myk7XG4gIC8qKlxuICAgKiBBIGhvcml6b250YWwgdGltZSBheGlzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgICAgIFNlZSBEYXRhQXhpcy5zZXRPcHRpb25zIGZvciB0aGUgYXZhaWxhYmxlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuXG4gICAqIEBjb25zdHJ1Y3RvciBEYXRhQXhpc1xuICAgKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAgICogQHBhcmFtIGJvZHlcbiAgICovXG4gIGZ1bmN0aW9uIERhdGFBeGlzKGJvZHksIG9wdGlvbnMsIHN2ZywgbGluZWdyYXBoT3B0aW9ucykge1xuICAgIHRoaXMuaWQgPSB1dGlsLnJhbmRvbVVVSUQoKTtcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuXG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIG9yaWVudGF0aW9uOiAnbGVmdCcsIC8vIHN1cHBvcnRlZDogJ2xlZnQnLCAncmlnaHQnXG4gICAgICBzaG93TWlub3JMYWJlbHM6IHRydWUsXG4gICAgICBzaG93TWFqb3JMYWJlbHM6IHRydWUsXG4gICAgICBpY29uczogZmFsc2UsXG4gICAgICBtYWpvckxpbmVzT2Zmc2V0OiA3LFxuICAgICAgbWlub3JMaW5lc09mZnNldDogNCxcbiAgICAgIGxhYmVsT2Zmc2V0WDogMTAsXG4gICAgICBsYWJlbE9mZnNldFk6IDIsXG4gICAgICBpY29uV2lkdGg6IDIwLFxuICAgICAgd2lkdGg6ICc0MHB4JyxcbiAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICBhbGlnblplcm9zOiB0cnVlLFxuICAgICAgbGVmdDoge1xuICAgICAgICByYW5nZTogeyBtaW46IHVuZGVmaW5lZCwgbWF4OiB1bmRlZmluZWQgfSxcbiAgICAgICAgZm9ybWF0OiBmdW5jdGlvbiBmb3JtYXQodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gJycgKyBwYXJzZUZsb2F0KHZhbHVlLnRvUHJlY2lzaW9uKDMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgdGl0bGU6IHsgdGV4dDogdW5kZWZpbmVkLCBzdHlsZTogdW5kZWZpbmVkIH1cbiAgICAgIH0sXG4gICAgICByaWdodDoge1xuICAgICAgICByYW5nZTogeyBtaW46IHVuZGVmaW5lZCwgbWF4OiB1bmRlZmluZWQgfSxcbiAgICAgICAgZm9ybWF0OiBmdW5jdGlvbiBmb3JtYXQodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gJycgKyBwYXJzZUZsb2F0KHZhbHVlLnRvUHJlY2lzaW9uKDMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgdGl0bGU6IHsgdGV4dDogdW5kZWZpbmVkLCBzdHlsZTogdW5kZWZpbmVkIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5saW5lZ3JhcGhPcHRpb25zID0gbGluZWdyYXBoT3B0aW9ucztcbiAgICB0aGlzLmxpbmVncmFwaFNWRyA9IHN2ZztcbiAgICB0aGlzLnByb3BzID0ge307XG4gICAgdGhpcy5ET01lbGVtZW50cyA9IHsgLy8gZHluYW1pYyBlbGVtZW50c1xuICAgICAgbGluZXM6IHt9LFxuICAgICAgbGFiZWxzOiB7fSxcbiAgICAgIHRpdGxlOiB7fVxuICAgIH07XG5cbiAgICB0aGlzLmRvbSA9IHt9O1xuICAgIHRoaXMuc2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yYW5nZSA9IHsgc3RhcnQ6IDAsIGVuZDogMCB9O1xuXG4gICAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoe30sIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuICAgIHRoaXMuY29udmVyc2lvbkZhY3RvciA9IDE7XG5cbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgdGhpcy53aWR0aCA9IE51bWJlcigoJycgKyB0aGlzLm9wdGlvbnMud2lkdGgpLnJlcGxhY2UoXCJweFwiLCBcIlwiKSk7XG4gICAgdGhpcy5taW5XaWR0aCA9IHRoaXMud2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLmxpbmVncmFwaFNWRy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgdGhpcy5oaWRkZW4gPSBmYWxzZTtcblxuICAgIHRoaXMuc3RlcFBpeGVscyA9IDI1O1xuICAgIHRoaXMuemVyb0Nyb3NzaW5nID0gLTE7XG4gICAgdGhpcy5hbW91bnRPZlN0ZXBzID0gLTE7XG5cbiAgICB0aGlzLmxpbmVPZmZzZXQgPSAwO1xuICAgIHRoaXMubWFzdGVyID0gdHJ1ZTtcbiAgICB0aGlzLm1hc3RlckF4aXMgPSBudWxsO1xuICAgIHRoaXMuc3ZnRWxlbWVudHMgPSB7fTtcbiAgICB0aGlzLmljb25zUmVtb3ZlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICB0aGlzLmFtb3VudE9mR3JvdXBzID0gMDtcblxuICAgIC8vIGNyZWF0ZSB0aGUgSFRNTCBET01cbiAgICB0aGlzLl9jcmVhdGUoKTtcbiAgICB0aGlzLmZyYW1ld29yayA9IHsgc3ZnOiB0aGlzLnN2Zywgc3ZnRWxlbWVudHM6IHRoaXMuc3ZnRWxlbWVudHMsIG9wdGlvbnM6IHRoaXMub3B0aW9ucywgZ3JvdXBzOiB0aGlzLmdyb3VwcyB9O1xuXG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcInZlcnRpY2FsRHJhZ1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBtZS5kb20ubGluZUNvbnRhaW5lci5zdHlsZS50b3AgPSBtZS5ib2R5LmRvbVByb3BzLnNjcm9sbFRvcCArICdweCc7XG4gICAgfSk7XG4gIH1cblxuICBEYXRhQXhpcy5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50KCk7XG5cbiAgRGF0YUF4aXMucHJvdG90eXBlLmFkZEdyb3VwID0gZnVuY3Rpb24gKGxhYmVsLCBncmFwaE9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KGxhYmVsKSkge1xuICAgICAgdGhpcy5ncm91cHNbbGFiZWxdID0gZ3JhcGhPcHRpb25zO1xuICAgIH1cbiAgICB0aGlzLmFtb3VudE9mR3JvdXBzICs9IDE7XG4gIH07XG5cbiAgRGF0YUF4aXMucHJvdG90eXBlLnVwZGF0ZUdyb3VwID0gZnVuY3Rpb24gKGxhYmVsLCBncmFwaE9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KGxhYmVsKSkge1xuICAgICAgdGhpcy5hbW91bnRPZkdyb3VwcyArPSAxO1xuICAgIH1cbiAgICB0aGlzLmdyb3Vwc1tsYWJlbF0gPSBncmFwaE9wdGlvbnM7XG4gIH07XG5cbiAgRGF0YUF4aXMucHJvdG90eXBlLnJlbW92ZUdyb3VwID0gZnVuY3Rpb24gKGxhYmVsKSB7XG4gICAgaWYgKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KGxhYmVsKSkge1xuICAgICAgZGVsZXRlIHRoaXMuZ3JvdXBzW2xhYmVsXTtcbiAgICAgIHRoaXMuYW1vdW50T2ZHcm91cHMgLT0gMTtcbiAgICB9XG4gIH07XG5cbiAgRGF0YUF4aXMucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICB2YXIgcmVkcmF3ID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLm9yaWVudGF0aW9uICE9IG9wdGlvbnMub3JpZW50YXRpb24gJiYgb3B0aW9ucy5vcmllbnRhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlZHJhdyA9IHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgZmllbGRzID0gWydvcmllbnRhdGlvbicsICdzaG93TWlub3JMYWJlbHMnLCAnc2hvd01ham9yTGFiZWxzJywgJ2ljb25zJywgJ21ham9yTGluZXNPZmZzZXQnLCAnbWlub3JMaW5lc09mZnNldCcsICdsYWJlbE9mZnNldFgnLCAnbGFiZWxPZmZzZXRZJywgJ2ljb25XaWR0aCcsICd3aWR0aCcsICd2aXNpYmxlJywgJ2xlZnQnLCAncmlnaHQnLCAnYWxpZ25aZXJvcyddO1xuICAgICAgdXRpbC5zZWxlY3RpdmVEZWVwRXh0ZW5kKGZpZWxkcywgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgdGhpcy5taW5XaWR0aCA9IE51bWJlcigoJycgKyB0aGlzLm9wdGlvbnMud2lkdGgpLnJlcGxhY2UoXCJweFwiLCBcIlwiKSk7XG4gICAgICBpZiAocmVkcmF3ID09PSB0cnVlICYmIHRoaXMuZG9tLmZyYW1lKSB7XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgSFRNTCBET00gZm9yIHRoZSBEYXRhQXhpc1xuICAgKi9cbiAgRGF0YUF4aXMucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kb20uZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmRvbS5mcmFtZS5zdHlsZS53aWR0aCA9IHRoaXMub3B0aW9ucy53aWR0aDtcbiAgICB0aGlzLmRvbS5mcmFtZS5zdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodDtcblxuICAgIHRoaXMuZG9tLmxpbmVDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmRvbS5saW5lQ29udGFpbmVyLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgIHRoaXMuZG9tLmxpbmVDb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgdGhpcy5kb20ubGluZUNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG5cbiAgICAvLyBjcmVhdGUgc3ZnIGVsZW1lbnQgZm9yIGdyYXBoIGRyYXdpbmcuXG4gICAgdGhpcy5zdmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgXCJzdmdcIik7XG4gICAgdGhpcy5zdmcuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgdGhpcy5zdmcuc3R5bGUudG9wID0gJzBweCc7XG4gICAgdGhpcy5zdmcuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgIHRoaXMuc3ZnLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgIHRoaXMuc3ZnLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgdGhpcy5kb20uZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5zdmcpO1xuICB9O1xuXG4gIERhdGFBeGlzLnByb3RvdHlwZS5fcmVkcmF3R3JvdXBJY29ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICBET011dGlsLnByZXBhcmVFbGVtZW50cyh0aGlzLnN2Z0VsZW1lbnRzKTtcblxuICAgIHZhciB4O1xuICAgIHZhciBpY29uV2lkdGggPSB0aGlzLm9wdGlvbnMuaWNvbldpZHRoO1xuICAgIHZhciBpY29uSGVpZ2h0ID0gMTU7XG4gICAgdmFyIGljb25PZmZzZXQgPSA0O1xuICAgIHZhciB5ID0gaWNvbk9mZnNldCArIDAuNSAqIGljb25IZWlnaHQ7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLm9yaWVudGF0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgIHggPSBpY29uT2Zmc2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0gdGhpcy53aWR0aCAtIGljb25XaWR0aCAtIGljb25PZmZzZXQ7XG4gICAgfVxuXG4gICAgdmFyIGdyb3VwQXJyYXkgPSBPYmplY3Qua2V5cyh0aGlzLmdyb3Vwcyk7XG4gICAgZ3JvdXBBcnJheS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IDE7XG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBncm91cElkID0gZ3JvdXBBcnJheVtpXTtcbiAgICAgIGlmICh0aGlzLmdyb3Vwc1tncm91cElkXS52aXNpYmxlID09PSB0cnVlICYmICh0aGlzLmxpbmVncmFwaE9wdGlvbnMudmlzaWJpbGl0eVtncm91cElkXSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMubGluZWdyYXBoT3B0aW9ucy52aXNpYmlsaXR5W2dyb3VwSWRdID09PSB0cnVlKSkge1xuICAgICAgICB0aGlzLmdyb3Vwc1tncm91cElkXS5nZXRMZWdlbmQoaWNvbldpZHRoLCBpY29uSGVpZ2h0LCB0aGlzLmZyYW1ld29yaywgeCwgeSk7XG4gICAgICAgIHkgKz0gaWNvbkhlaWdodCArIGljb25PZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgRE9NdXRpbC5jbGVhbnVwRWxlbWVudHModGhpcy5zdmdFbGVtZW50cyk7XG4gICAgdGhpcy5pY29uc1JlbW92ZWQgPSBmYWxzZTtcbiAgfTtcblxuICBEYXRhQXhpcy5wcm90b3R5cGUuX2NsZWFudXBJY29ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pY29uc1JlbW92ZWQgPT09IGZhbHNlKSB7XG4gICAgICBET011dGlsLnByZXBhcmVFbGVtZW50cyh0aGlzLnN2Z0VsZW1lbnRzKTtcbiAgICAgIERPTXV0aWwuY2xlYW51cEVsZW1lbnRzKHRoaXMuc3ZnRWxlbWVudHMpO1xuICAgICAgdGhpcy5pY29uc1JlbW92ZWQgPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBIVE1MIERPTSBmb3IgdGhlIERhdGFBeGlzXG4gICAqL1xuICBEYXRhQXhpcy5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmhpZGRlbiA9IGZhbHNlO1xuICAgIGlmICghdGhpcy5kb20uZnJhbWUucGFyZW50Tm9kZSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgICAgdGhpcy5ib2R5LmRvbS5sZWZ0LmFwcGVuZENoaWxkKHRoaXMuZG9tLmZyYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYm9keS5kb20ubGVmdC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5mcmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmRvbS5saW5lQ29udGFpbmVyLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuYm9keS5kb20uYmFja2dyb3VuZEhvcml6b250YWwuYXBwZW5kQ2hpbGQodGhpcy5kb20ubGluZUNvbnRhaW5lcik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIEhUTUwgRE9NIGZvciB0aGUgRGF0YUF4aXNcbiAgICovXG4gIERhdGFBeGlzLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaGlkZGVuID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5kb20uZnJhbWUucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5kb20uZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbS5mcmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZG9tLmxpbmVDb250YWluZXIucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5kb20ubGluZUNvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLmxpbmVDb250YWluZXIpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0IGEgcmFuZ2UgKHN0YXJ0IGFuZCBlbmQpXG4gICAqIEBwYXJhbSBlbmRcbiAgICogQHBhcmFtIHN0YXJ0XG4gICAqIEBwYXJhbSBlbmRcbiAgICovXG4gIERhdGFBeGlzLnByb3RvdHlwZS5zZXRSYW5nZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgdGhpcy5yYW5nZS5zdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMucmFuZ2UuZW5kID0gZW5kO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXBhaW50IHRoZSBjb21wb25lbnRcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBjb21wb25lbnQgaXMgcmVzaXplZFxuICAgKi9cbiAgRGF0YUF4aXMucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzaXplZCA9IGZhbHNlO1xuICAgIHZhciBhY3RpdmVHcm91cHMgPSAwO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBsaW5lIGNvbnRhaW5lciBhZGhlcmVzIHRvIHRoZSB2ZXJ0aWNhbCBzY3JvbGxpbmcuXG4gICAgdGhpcy5kb20ubGluZUNvbnRhaW5lci5zdHlsZS50b3AgPSB0aGlzLmJvZHkuZG9tUHJvcHMuc2Nyb2xsVG9wICsgJ3B4JztcblxuICAgIGZvciAodmFyIGdyb3VwSWQgaW4gdGhpcy5ncm91cHMpIHtcbiAgICAgIGlmICh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShncm91cElkKSkge1xuICAgICAgICBpZiAodGhpcy5ncm91cHNbZ3JvdXBJZF0udmlzaWJsZSA9PT0gdHJ1ZSAmJiAodGhpcy5saW5lZ3JhcGhPcHRpb25zLnZpc2liaWxpdHlbZ3JvdXBJZF0gPT09IHVuZGVmaW5lZCB8fCB0aGlzLmxpbmVncmFwaE9wdGlvbnMudmlzaWJpbGl0eVtncm91cElkXSA9PT0gdHJ1ZSkpIHtcbiAgICAgICAgICBhY3RpdmVHcm91cHMrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5hbW91bnRPZkdyb3VwcyA9PT0gMCB8fCBhY3RpdmVHcm91cHMgPT09IDApIHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNob3coKTtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gTnVtYmVyKHRoaXMubGluZWdyYXBoU1ZHLnN0eWxlLmhlaWdodC5yZXBsYWNlKFwicHhcIiwgXCJcIikpO1xuXG4gICAgICAvLyBzdmcgb2Zmc2V0aGVpZ2h0IGRpZCBub3Qgd29yayBpbiBmaXJlZm94IGFuZCBleHBsb3Jlci4uLlxuICAgICAgdGhpcy5kb20ubGluZUNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodCArICdweCc7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5vcHRpb25zLnZpc2libGUgPT09IHRydWUgPyBOdW1iZXIoKCcnICsgdGhpcy5vcHRpb25zLndpZHRoKS5yZXBsYWNlKFwicHhcIiwgXCJcIikpIDogMDtcblxuICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIHZhciBmcmFtZSA9IHRoaXMuZG9tLmZyYW1lO1xuXG4gICAgICAvLyB1cGRhdGUgY2xhc3NuYW1lXG4gICAgICBmcmFtZS5jbGFzc05hbWUgPSAndmlzLWRhdGEtYXhpcyc7XG5cbiAgICAgIC8vIGNhbGN1bGF0ZSBjaGFyYWN0ZXIgd2lkdGggYW5kIGhlaWdodFxuICAgICAgdGhpcy5fY2FsY3VsYXRlQ2hhclNpemUoKTtcblxuICAgICAgdmFyIG9yaWVudGF0aW9uID0gdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uO1xuICAgICAgdmFyIHNob3dNaW5vckxhYmVscyA9IHRoaXMub3B0aW9ucy5zaG93TWlub3JMYWJlbHM7XG4gICAgICB2YXIgc2hvd01ham9yTGFiZWxzID0gdGhpcy5vcHRpb25zLnNob3dNYWpvckxhYmVscztcblxuICAgICAgLy8gZGV0ZXJtaW5lIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBlbGVtZW50cyBmb3IgdGhlIGF4aXNcbiAgICAgIHByb3BzLm1pbm9yTGFiZWxIZWlnaHQgPSBzaG93TWlub3JMYWJlbHMgPyBwcm9wcy5taW5vckNoYXJIZWlnaHQgOiAwO1xuICAgICAgcHJvcHMubWFqb3JMYWJlbEhlaWdodCA9IHNob3dNYWpvckxhYmVscyA/IHByb3BzLm1ham9yQ2hhckhlaWdodCA6IDA7XG5cbiAgICAgIHByb3BzLm1pbm9yTGluZVdpZHRoID0gdGhpcy5ib2R5LmRvbS5iYWNrZ3JvdW5kSG9yaXpvbnRhbC5vZmZzZXRXaWR0aCAtIHRoaXMubGluZU9mZnNldCAtIHRoaXMud2lkdGggKyAyICogdGhpcy5vcHRpb25zLm1pbm9yTGluZXNPZmZzZXQ7XG4gICAgICBwcm9wcy5taW5vckxpbmVIZWlnaHQgPSAxO1xuICAgICAgcHJvcHMubWFqb3JMaW5lV2lkdGggPSB0aGlzLmJvZHkuZG9tLmJhY2tncm91bmRIb3Jpem9udGFsLm9mZnNldFdpZHRoIC0gdGhpcy5saW5lT2Zmc2V0IC0gdGhpcy53aWR0aCArIDIgKiB0aGlzLm9wdGlvbnMubWFqb3JMaW5lc09mZnNldDtcbiAgICAgIHByb3BzLm1ham9yTGluZUhlaWdodCA9IDE7XG5cbiAgICAgIC8vICB0YWtlIGZyYW1lIG9mZmxpbmUgd2hpbGUgdXBkYXRpbmcgKGlzIGFsbW9zdCB0d2ljZSBhcyBmYXN0KVxuICAgICAgaWYgKG9yaWVudGF0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgZnJhbWUuc3R5bGUudG9wID0gJzAnO1xuICAgICAgICBmcmFtZS5zdHlsZS5sZWZ0ID0gJzAnO1xuICAgICAgICBmcmFtZS5zdHlsZS5ib3R0b20gPSAnJztcbiAgICAgICAgZnJhbWUuc3R5bGUud2lkdGggPSB0aGlzLndpZHRoICsgJ3B4JztcbiAgICAgICAgZnJhbWUuc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyBcInB4XCI7XG4gICAgICAgIHRoaXMucHJvcHMud2lkdGggPSB0aGlzLmJvZHkuZG9tUHJvcHMubGVmdC53aWR0aDtcbiAgICAgICAgdGhpcy5wcm9wcy5oZWlnaHQgPSB0aGlzLmJvZHkuZG9tUHJvcHMubGVmdC5oZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByaWdodFxuICAgICAgICBmcmFtZS5zdHlsZS50b3AgPSAnJztcbiAgICAgICAgZnJhbWUuc3R5bGUuYm90dG9tID0gJzAnO1xuICAgICAgICBmcmFtZS5zdHlsZS5sZWZ0ID0gJzAnO1xuICAgICAgICBmcmFtZS5zdHlsZS53aWR0aCA9IHRoaXMud2lkdGggKyAncHgnO1xuICAgICAgICBmcmFtZS5zdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodCArIFwicHhcIjtcbiAgICAgICAgdGhpcy5wcm9wcy53aWR0aCA9IHRoaXMuYm9keS5kb21Qcm9wcy5yaWdodC53aWR0aDtcbiAgICAgICAgdGhpcy5wcm9wcy5oZWlnaHQgPSB0aGlzLmJvZHkuZG9tUHJvcHMucmlnaHQuaGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICByZXNpemVkID0gdGhpcy5fcmVkcmF3TGFiZWxzKCk7XG4gICAgICByZXNpemVkID0gdGhpcy5faXNSZXNpemVkKCkgfHwgcmVzaXplZDtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5pY29ucyA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLl9yZWRyYXdHcm91cEljb25zKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jbGVhbnVwSWNvbnMoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVkcmF3VGl0bGUob3JpZW50YXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzaXplZDtcbiAgfTtcblxuICAvKipcbiAgICogUmVwYWludCBtYWpvciBhbmQgbWlub3IgdGV4dCBsYWJlbHMgYW5kIHZlcnRpY2FsIGdyaWQgbGluZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIERhdGFBeGlzLnByb3RvdHlwZS5fcmVkcmF3TGFiZWxzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgcmVzaXplZCA9IGZhbHNlO1xuICAgIERPTXV0aWwucHJlcGFyZUVsZW1lbnRzKHRoaXMuRE9NZWxlbWVudHMubGluZXMpO1xuICAgIERPTXV0aWwucHJlcGFyZUVsZW1lbnRzKHRoaXMuRE9NZWxlbWVudHMubGFiZWxzKTtcbiAgICB2YXIgb3JpZW50YXRpb24gPSB0aGlzLm9wdGlvbnNbJ29yaWVudGF0aW9uJ107XG4gICAgdmFyIGN1c3RvbVJhbmdlID0gdGhpcy5vcHRpb25zW29yaWVudGF0aW9uXS5yYW5nZSAhPSB1bmRlZmluZWQgPyB0aGlzLm9wdGlvbnNbb3JpZW50YXRpb25dLnJhbmdlIDoge307XG5cbiAgICAvL092ZXJyaWRlIHJhbmdlIHdpdGggbWFudWFsIG9wdGlvbnM6XG4gICAgdmFyIGF1dG9TY2FsZUVuZCA9IHRydWU7XG4gICAgaWYgKGN1c3RvbVJhbmdlLm1heCAhPSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMucmFuZ2UuZW5kID0gY3VzdG9tUmFuZ2UubWF4O1xuICAgICAgYXV0b1NjYWxlRW5kID0gZmFsc2U7XG4gICAgfVxuICAgIHZhciBhdXRvU2NhbGVTdGFydCA9IHRydWU7XG4gICAgaWYgKGN1c3RvbVJhbmdlLm1pbiAhPSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMucmFuZ2Uuc3RhcnQgPSBjdXN0b21SYW5nZS5taW47XG4gICAgICBhdXRvU2NhbGVTdGFydCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuc2NhbGUgPSBuZXcgRGF0YVNjYWxlKHRoaXMucmFuZ2Uuc3RhcnQsIHRoaXMucmFuZ2UuZW5kLCBhdXRvU2NhbGVTdGFydCwgYXV0b1NjYWxlRW5kLCB0aGlzLmRvbS5mcmFtZS5vZmZzZXRIZWlnaHQsIHRoaXMucHJvcHMubWFqb3JDaGFySGVpZ2h0LCB0aGlzLm9wdGlvbnMuYWxpZ25aZXJvcywgdGhpcy5vcHRpb25zW29yaWVudGF0aW9uXS5mb3JtYXQpO1xuXG4gICAgaWYgKHRoaXMubWFzdGVyID09PSBmYWxzZSAmJiB0aGlzLm1hc3RlckF4aXMgIT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnNjYWxlLmZvbGxvd1NjYWxlKHRoaXMubWFzdGVyQXhpcy5zY2FsZSk7XG4gICAgfVxuXG4gICAgLy9JcyB1cGRhdGVkIGluIHNpZGUtZWZmZWN0IG9mIF9yZWRyYXdMYWJlbCgpOlxuICAgIHRoaXMubWF4TGFiZWxTaXplID0gMDtcblxuICAgIHZhciBsaW5lcyA9IHRoaXMuc2NhbGUuZ2V0TGluZXMoKTtcbiAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICB2YXIgeSA9IGxpbmUueTtcbiAgICAgIHZhciBpc01ham9yID0gbGluZS5tYWpvcjtcbiAgICAgIGlmIChfdGhpcy5vcHRpb25zWydzaG93TWlub3JMYWJlbHMnXSAmJiBpc01ham9yID09PSBmYWxzZSkge1xuICAgICAgICBfdGhpcy5fcmVkcmF3TGFiZWwoeSAtIDIsIGxpbmUudmFsLCBvcmllbnRhdGlvbiwgJ3Zpcy15LWF4aXMgdmlzLW1pbm9yJywgX3RoaXMucHJvcHMubWlub3JDaGFySGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGlmIChpc01ham9yKSB7XG4gICAgICAgIGlmICh5ID49IDApIHtcbiAgICAgICAgICBfdGhpcy5fcmVkcmF3TGFiZWwoeSAtIDIsIGxpbmUudmFsLCBvcmllbnRhdGlvbiwgJ3Zpcy15LWF4aXMgdmlzLW1ham9yJywgX3RoaXMucHJvcHMubWFqb3JDaGFySGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKF90aGlzLm1hc3RlciA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAoaXNNYWpvcikge1xuICAgICAgICAgIF90aGlzLl9yZWRyYXdMaW5lKHksIG9yaWVudGF0aW9uLCAndmlzLWdyaWQgdmlzLWhvcml6b250YWwgdmlzLW1ham9yJywgX3RoaXMub3B0aW9ucy5tYWpvckxpbmVzT2Zmc2V0LCBfdGhpcy5wcm9wcy5tYWpvckxpbmVXaWR0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMuX3JlZHJhd0xpbmUoeSwgb3JpZW50YXRpb24sICd2aXMtZ3JpZCB2aXMtaG9yaXpvbnRhbCB2aXMtbWlub3InLCBfdGhpcy5vcHRpb25zLm1pbm9yTGluZXNPZmZzZXQsIF90aGlzLnByb3BzLm1pbm9yTGluZVdpZHRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTm90ZSB0aGF0IHRpdGxlIGlzIHJvdGF0ZWQsIHNvIHdlJ3JlIHVzaW5nIHRoZSBoZWlnaHQsIG5vdCB3aWR0aCFcbiAgICB2YXIgdGl0bGVXaWR0aCA9IDA7XG4gICAgaWYgKHRoaXMub3B0aW9uc1tvcmllbnRhdGlvbl0udGl0bGUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9wdGlvbnNbb3JpZW50YXRpb25dLnRpdGxlLnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGl0bGVXaWR0aCA9IHRoaXMucHJvcHMudGl0bGVDaGFySGVpZ2h0O1xuICAgIH1cbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vcHRpb25zLmljb25zID09PSB0cnVlID8gTWF0aC5tYXgodGhpcy5vcHRpb25zLmljb25XaWR0aCwgdGl0bGVXaWR0aCkgKyB0aGlzLm9wdGlvbnMubGFiZWxPZmZzZXRYICsgMTUgOiB0aXRsZVdpZHRoICsgdGhpcy5vcHRpb25zLmxhYmVsT2Zmc2V0WCArIDE1O1xuXG4gICAgLy8gdGhpcyB3aWxsIHJlc2l6ZSB0aGUgeUF4aXMgdG8gYWNjb21tb2RhdGUgdGhlIGxhYmVscy5cbiAgICBpZiAodGhpcy5tYXhMYWJlbFNpemUgPiB0aGlzLndpZHRoIC0gb2Zmc2V0ICYmIHRoaXMub3B0aW9ucy52aXNpYmxlID09PSB0cnVlKSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5tYXhMYWJlbFNpemUgKyBvZmZzZXQ7XG4gICAgICB0aGlzLm9wdGlvbnMud2lkdGggPSB0aGlzLndpZHRoICsgXCJweFwiO1xuICAgICAgRE9NdXRpbC5jbGVhbnVwRWxlbWVudHModGhpcy5ET01lbGVtZW50cy5saW5lcyk7XG4gICAgICBET011dGlsLmNsZWFudXBFbGVtZW50cyh0aGlzLkRPTWVsZW1lbnRzLmxhYmVscyk7XG4gICAgICB0aGlzLnJlZHJhdygpO1xuICAgICAgcmVzaXplZCA9IHRydWU7XG4gICAgfVxuICAgIC8vIHRoaXMgd2lsbCByZXNpemUgdGhlIHlBeGlzIGlmIGl0IGlzIHRvbyBiaWcgZm9yIHRoZSBsYWJlbHMuXG4gICAgZWxzZSBpZiAodGhpcy5tYXhMYWJlbFNpemUgPCB0aGlzLndpZHRoIC0gb2Zmc2V0ICYmIHRoaXMub3B0aW9ucy52aXNpYmxlID09PSB0cnVlICYmIHRoaXMud2lkdGggPiB0aGlzLm1pbldpZHRoKSB7XG4gICAgICAgIHRoaXMud2lkdGggPSBNYXRoLm1heCh0aGlzLm1pbldpZHRoLCB0aGlzLm1heExhYmVsU2l6ZSArIG9mZnNldCk7XG4gICAgICAgIHRoaXMub3B0aW9ucy53aWR0aCA9IHRoaXMud2lkdGggKyBcInB4XCI7XG4gICAgICAgIERPTXV0aWwuY2xlYW51cEVsZW1lbnRzKHRoaXMuRE9NZWxlbWVudHMubGluZXMpO1xuICAgICAgICBET011dGlsLmNsZWFudXBFbGVtZW50cyh0aGlzLkRPTWVsZW1lbnRzLmxhYmVscyk7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgICAgIHJlc2l6ZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgRE9NdXRpbC5jbGVhbnVwRWxlbWVudHModGhpcy5ET01lbGVtZW50cy5saW5lcyk7XG4gICAgICAgIERPTXV0aWwuY2xlYW51cEVsZW1lbnRzKHRoaXMuRE9NZWxlbWVudHMubGFiZWxzKTtcbiAgICAgICAgcmVzaXplZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgcmV0dXJuIHJlc2l6ZWQ7XG4gIH07XG5cbiAgRGF0YUF4aXMucHJvdG90eXBlLmNvbnZlcnRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnNjYWxlLmNvbnZlcnRWYWx1ZSh2YWx1ZSk7XG4gIH07XG5cbiAgRGF0YUF4aXMucHJvdG90eXBlLnNjcmVlblRvVmFsdWUgPSBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiB0aGlzLnNjYWxlLnNjcmVlblRvVmFsdWUoeCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGxhYmVsIGZvciB0aGUgYXhpcyBhdCBwb3NpdGlvbiB4XG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB5XG4gICAqIEBwYXJhbSB0ZXh0XG4gICAqIEBwYXJhbSBvcmllbnRhdGlvblxuICAgKiBAcGFyYW0gY2xhc3NOYW1lXG4gICAqIEBwYXJhbSBjaGFyYWN0ZXJIZWlnaHRcbiAgICovXG4gIERhdGFBeGlzLnByb3RvdHlwZS5fcmVkcmF3TGFiZWwgPSBmdW5jdGlvbiAoeSwgdGV4dCwgb3JpZW50YXRpb24sIGNsYXNzTmFtZSwgY2hhcmFjdGVySGVpZ2h0KSB7XG4gICAgLy8gcmV1c2UgcmVkdW5kYW50IGxhYmVsXG4gICAgdmFyIGxhYmVsID0gRE9NdXRpbC5nZXRET01FbGVtZW50KCdkaXYnLCB0aGlzLkRPTWVsZW1lbnRzLmxhYmVscywgdGhpcy5kb20uZnJhbWUpOyAvL3RoaXMuZG9tLnJlZHVuZGFudC5sYWJlbHMuc2hpZnQoKTtcbiAgICBsYWJlbC5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgbGFiZWwuaW5uZXJIVE1MID0gdGV4dDtcbiAgICBpZiAob3JpZW50YXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgbGFiZWwuc3R5bGUubGVmdCA9ICctJyArIHRoaXMub3B0aW9ucy5sYWJlbE9mZnNldFggKyAncHgnO1xuICAgICAgbGFiZWwuc3R5bGUudGV4dEFsaWduID0gXCJyaWdodFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYWJlbC5zdHlsZS5yaWdodCA9ICctJyArIHRoaXMub3B0aW9ucy5sYWJlbE9mZnNldFggKyAncHgnO1xuICAgICAgbGFiZWwuc3R5bGUudGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgfVxuXG4gICAgbGFiZWwuc3R5bGUudG9wID0geSAtIDAuNSAqIGNoYXJhY3RlckhlaWdodCArIHRoaXMub3B0aW9ucy5sYWJlbE9mZnNldFkgKyAncHgnO1xuXG4gICAgdGV4dCArPSAnJztcblxuICAgIHZhciBsYXJnZXN0V2lkdGggPSBNYXRoLm1heCh0aGlzLnByb3BzLm1ham9yQ2hhcldpZHRoLCB0aGlzLnByb3BzLm1pbm9yQ2hhcldpZHRoKTtcbiAgICBpZiAodGhpcy5tYXhMYWJlbFNpemUgPCB0ZXh0Lmxlbmd0aCAqIGxhcmdlc3RXaWR0aCkge1xuICAgICAgdGhpcy5tYXhMYWJlbFNpemUgPSB0ZXh0Lmxlbmd0aCAqIGxhcmdlc3RXaWR0aDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG1pbm9yIGxpbmUgZm9yIHRoZSBheGlzIGF0IHBvc2l0aW9uIHlcbiAgICogQHBhcmFtIHlcbiAgICogQHBhcmFtIG9yaWVudGF0aW9uXG4gICAqIEBwYXJhbSBjbGFzc05hbWVcbiAgICogQHBhcmFtIG9mZnNldFxuICAgKiBAcGFyYW0gd2lkdGhcbiAgICovXG4gIERhdGFBeGlzLnByb3RvdHlwZS5fcmVkcmF3TGluZSA9IGZ1bmN0aW9uICh5LCBvcmllbnRhdGlvbiwgY2xhc3NOYW1lLCBvZmZzZXQsIHdpZHRoKSB7XG4gICAgaWYgKHRoaXMubWFzdGVyID09PSB0cnVlKSB7XG4gICAgICB2YXIgbGluZSA9IERPTXV0aWwuZ2V0RE9NRWxlbWVudCgnZGl2JywgdGhpcy5ET01lbGVtZW50cy5saW5lcywgdGhpcy5kb20ubGluZUNvbnRhaW5lcik7IC8vdGhpcy5kb20ucmVkdW5kYW50LmxpbmVzLnNoaWZ0KCk7XG4gICAgICBsaW5lLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgIGxpbmUuaW5uZXJIVE1MID0gJyc7XG5cbiAgICAgIGlmIChvcmllbnRhdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIGxpbmUuc3R5bGUubGVmdCA9IHRoaXMud2lkdGggLSBvZmZzZXQgKyAncHgnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGluZS5zdHlsZS5yaWdodCA9IHRoaXMud2lkdGggLSBvZmZzZXQgKyAncHgnO1xuICAgICAgfVxuXG4gICAgICBsaW5lLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgbGluZS5zdHlsZS50b3AgPSB5ICsgJ3B4JztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHRpdGxlIGZvciB0aGUgYXhpc1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gb3JpZW50YXRpb25cbiAgICovXG4gIERhdGFBeGlzLnByb3RvdHlwZS5fcmVkcmF3VGl0bGUgPSBmdW5jdGlvbiAob3JpZW50YXRpb24pIHtcbiAgICBET011dGlsLnByZXBhcmVFbGVtZW50cyh0aGlzLkRPTWVsZW1lbnRzLnRpdGxlKTtcblxuICAgIC8vIENoZWNrIGlmIHRoZSB0aXRsZSBpcyBkZWZpbmVkIGZvciB0aGlzIGF4ZXNcbiAgICBpZiAodGhpcy5vcHRpb25zW29yaWVudGF0aW9uXS50aXRsZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMub3B0aW9uc1tvcmllbnRhdGlvbl0udGl0bGUudGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgdGl0bGUgPSBET011dGlsLmdldERPTUVsZW1lbnQoJ2RpdicsIHRoaXMuRE9NZWxlbWVudHMudGl0bGUsIHRoaXMuZG9tLmZyYW1lKTtcbiAgICAgIHRpdGxlLmNsYXNzTmFtZSA9ICd2aXMteS1heGlzIHZpcy10aXRsZSB2aXMtJyArIG9yaWVudGF0aW9uO1xuICAgICAgdGl0bGUuaW5uZXJIVE1MID0gdGhpcy5vcHRpb25zW29yaWVudGF0aW9uXS50aXRsZS50ZXh0O1xuXG4gICAgICAvLyBBZGQgc3R5bGUgLSBpZiBwcm92aWRlZFxuICAgICAgaWYgKHRoaXMub3B0aW9uc1tvcmllbnRhdGlvbl0udGl0bGUuc3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1dGlsLmFkZENzc1RleHQodGl0bGUsIHRoaXMub3B0aW9uc1tvcmllbnRhdGlvbl0udGl0bGUuc3R5bGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3JpZW50YXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICB0aXRsZS5zdHlsZS5sZWZ0ID0gdGhpcy5wcm9wcy50aXRsZUNoYXJIZWlnaHQgKyAncHgnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGl0bGUuc3R5bGUucmlnaHQgPSB0aGlzLnByb3BzLnRpdGxlQ2hhckhlaWdodCArICdweCc7XG4gICAgICB9XG5cbiAgICAgIHRpdGxlLnN0eWxlLndpZHRoID0gdGhpcy5oZWlnaHQgKyAncHgnO1xuICAgIH1cblxuICAgIC8vIHdlIG5lZWQgdG8gY2xlYW4gdXAgaW4gY2FzZSB3ZSBkaWQgbm90IHVzZSBhbGwgZWxlbWVudHMuXG4gICAgRE9NdXRpbC5jbGVhbnVwRWxlbWVudHModGhpcy5ET01lbGVtZW50cy50aXRsZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERldGVybWluZSB0aGUgc2l6ZSBvZiB0ZXh0IG9uIHRoZSBheGlzIChib3RoIG1ham9yIGFuZCBtaW5vciBheGlzKS5cbiAgICogVGhlIHNpemUgaXMgY2FsY3VsYXRlZCBvbmx5IG9uY2UgYW5kIHRoZW4gY2FjaGVkIGluIHRoaXMucHJvcHMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBEYXRhQXhpcy5wcm90b3R5cGUuX2NhbGN1bGF0ZUNoYXJTaXplID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIGRldGVybWluZSB0aGUgY2hhciB3aWR0aCBhbmQgaGVpZ2h0IG9uIHRoZSBtaW5vciBheGlzXG4gICAgaWYgKCEoJ21pbm9yQ2hhckhlaWdodCcgaW4gdGhpcy5wcm9wcykpIHtcbiAgICAgIHZhciB0ZXh0TWlub3IgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnMCcpO1xuICAgICAgdmFyIG1lYXN1cmVDaGFyTWlub3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIG1lYXN1cmVDaGFyTWlub3IuY2xhc3NOYW1lID0gJ3Zpcy15LWF4aXMgdmlzLW1pbm9yIHZpcy1tZWFzdXJlJztcbiAgICAgIG1lYXN1cmVDaGFyTWlub3IuYXBwZW5kQ2hpbGQodGV4dE1pbm9yKTtcbiAgICAgIHRoaXMuZG9tLmZyYW1lLmFwcGVuZENoaWxkKG1lYXN1cmVDaGFyTWlub3IpO1xuXG4gICAgICB0aGlzLnByb3BzLm1pbm9yQ2hhckhlaWdodCA9IG1lYXN1cmVDaGFyTWlub3IuY2xpZW50SGVpZ2h0O1xuICAgICAgdGhpcy5wcm9wcy5taW5vckNoYXJXaWR0aCA9IG1lYXN1cmVDaGFyTWlub3IuY2xpZW50V2lkdGg7XG5cbiAgICAgIHRoaXMuZG9tLmZyYW1lLnJlbW92ZUNoaWxkKG1lYXN1cmVDaGFyTWlub3IpO1xuICAgIH1cblxuICAgIGlmICghKCdtYWpvckNoYXJIZWlnaHQnIGluIHRoaXMucHJvcHMpKSB7XG4gICAgICB2YXIgdGV4dE1ham9yID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJzAnKTtcbiAgICAgIHZhciBtZWFzdXJlQ2hhck1ham9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBtZWFzdXJlQ2hhck1ham9yLmNsYXNzTmFtZSA9ICd2aXMteS1heGlzIHZpcy1tYWpvciB2aXMtbWVhc3VyZSc7XG4gICAgICBtZWFzdXJlQ2hhck1ham9yLmFwcGVuZENoaWxkKHRleHRNYWpvcik7XG4gICAgICB0aGlzLmRvbS5mcmFtZS5hcHBlbmRDaGlsZChtZWFzdXJlQ2hhck1ham9yKTtcblxuICAgICAgdGhpcy5wcm9wcy5tYWpvckNoYXJIZWlnaHQgPSBtZWFzdXJlQ2hhck1ham9yLmNsaWVudEhlaWdodDtcbiAgICAgIHRoaXMucHJvcHMubWFqb3JDaGFyV2lkdGggPSBtZWFzdXJlQ2hhck1ham9yLmNsaWVudFdpZHRoO1xuXG4gICAgICB0aGlzLmRvbS5mcmFtZS5yZW1vdmVDaGlsZChtZWFzdXJlQ2hhck1ham9yKTtcbiAgICB9XG5cbiAgICBpZiAoISgndGl0bGVDaGFySGVpZ2h0JyBpbiB0aGlzLnByb3BzKSkge1xuICAgICAgdmFyIHRleHRUaXRsZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcwJyk7XG4gICAgICB2YXIgbWVhc3VyZUNoYXJUaXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgbWVhc3VyZUNoYXJUaXRsZS5jbGFzc05hbWUgPSAndmlzLXktYXhpcyB2aXMtdGl0bGUgdmlzLW1lYXN1cmUnO1xuICAgICAgbWVhc3VyZUNoYXJUaXRsZS5hcHBlbmRDaGlsZCh0ZXh0VGl0bGUpO1xuICAgICAgdGhpcy5kb20uZnJhbWUuYXBwZW5kQ2hpbGQobWVhc3VyZUNoYXJUaXRsZSk7XG5cbiAgICAgIHRoaXMucHJvcHMudGl0bGVDaGFySGVpZ2h0ID0gbWVhc3VyZUNoYXJUaXRsZS5jbGllbnRIZWlnaHQ7XG4gICAgICB0aGlzLnByb3BzLnRpdGxlQ2hhcldpZHRoID0gbWVhc3VyZUNoYXJUaXRsZS5jbGllbnRXaWR0aDtcblxuICAgICAgdGhpcy5kb20uZnJhbWUucmVtb3ZlQ2hpbGQobWVhc3VyZUNoYXJUaXRsZSk7XG4gICAgfVxuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gRGF0YUF4aXM7XG5cbi8qKiovIH0sXG4vKiA1MyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVkIGJ5IGx1ZG8gb24gMjUtMS0xNi5cbiAgICovXG5cbiAgZnVuY3Rpb24gRGF0YVNjYWxlKHN0YXJ0LCBlbmQsIGF1dG9TY2FsZVN0YXJ0LCBhdXRvU2NhbGVFbmQsIGNvbnRhaW5lckhlaWdodCwgbWFqb3JDaGFySGVpZ2h0KSB7XG4gICAgdmFyIHplcm9BbGlnbiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gNiB8fCBhcmd1bWVudHNbNl0gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogYXJndW1lbnRzWzZdO1xuICAgIHZhciBmb3JtYXR0aW5nRnVuY3Rpb24gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDcgfHwgYXJndW1lbnRzWzddID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1s3XTtcblxuICAgIHRoaXMubWFqb3JTdGVwcyA9IFsxLCAyLCA1LCAxMF07XG4gICAgdGhpcy5taW5vclN0ZXBzID0gWzAuMjUsIDAuNSwgMSwgMl07XG4gICAgdGhpcy5jdXN0b21MaW5lcyA9IG51bGw7XG5cbiAgICB0aGlzLmNvbnRhaW5lckhlaWdodCA9IGNvbnRhaW5lckhlaWdodDtcbiAgICB0aGlzLm1ham9yQ2hhckhlaWdodCA9IG1ham9yQ2hhckhlaWdodDtcbiAgICB0aGlzLl9zdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuX2VuZCA9IGVuZDtcblxuICAgIHRoaXMuc2NhbGUgPSAxO1xuICAgIHRoaXMubWlub3JTdGVwSWR4ID0gLTE7XG4gICAgdGhpcy5tYWduaXR1ZGVmYWN0b3IgPSAxO1xuICAgIHRoaXMuZGV0ZXJtaW5lU2NhbGUoKTtcblxuICAgIHRoaXMuemVyb0FsaWduID0gemVyb0FsaWduO1xuICAgIHRoaXMuYXV0b1NjYWxlU3RhcnQgPSBhdXRvU2NhbGVTdGFydDtcbiAgICB0aGlzLmF1dG9TY2FsZUVuZCA9IGF1dG9TY2FsZUVuZDtcblxuICAgIHRoaXMuZm9ybWF0dGluZ0Z1bmN0aW9uID0gZm9ybWF0dGluZ0Z1bmN0aW9uO1xuXG4gICAgaWYgKGF1dG9TY2FsZVN0YXJ0IHx8IGF1dG9TY2FsZUVuZCkge1xuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIHZhciByb3VuZFRvTWlub3IgPSBmdW5jdGlvbiByb3VuZFRvTWlub3IodmFsdWUpIHtcbiAgICAgICAgdmFyIHJvdW5kZWQgPSB2YWx1ZSAtIHZhbHVlICUgKG1lLm1hZ25pdHVkZWZhY3RvciAqIG1lLm1pbm9yU3RlcHNbbWUubWlub3JTdGVwSWR4XSk7XG4gICAgICAgIGlmICh2YWx1ZSAlIChtZS5tYWduaXR1ZGVmYWN0b3IgKiBtZS5taW5vclN0ZXBzW21lLm1pbm9yU3RlcElkeF0pID4gMC41ICogKG1lLm1hZ25pdHVkZWZhY3RvciAqIG1lLm1pbm9yU3RlcHNbbWUubWlub3JTdGVwSWR4XSkpIHtcbiAgICAgICAgICByZXR1cm4gcm91bmRlZCArIG1lLm1hZ25pdHVkZWZhY3RvciAqIG1lLm1pbm9yU3RlcHNbbWUubWlub3JTdGVwSWR4XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcm91bmRlZDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChhdXRvU2NhbGVTdGFydCkge1xuICAgICAgICB0aGlzLl9zdGFydCAtPSB0aGlzLm1hZ25pdHVkZWZhY3RvciAqIDIgKiB0aGlzLm1pbm9yU3RlcHNbdGhpcy5taW5vclN0ZXBJZHhdO1xuICAgICAgICB0aGlzLl9zdGFydCA9IHJvdW5kVG9NaW5vcih0aGlzLl9zdGFydCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhdXRvU2NhbGVFbmQpIHtcbiAgICAgICAgdGhpcy5fZW5kICs9IHRoaXMubWFnbml0dWRlZmFjdG9yICogdGhpcy5taW5vclN0ZXBzW3RoaXMubWlub3JTdGVwSWR4XTtcbiAgICAgICAgdGhpcy5fZW5kID0gcm91bmRUb01pbm9yKHRoaXMuX2VuZCk7XG4gICAgICB9XG4gICAgICB0aGlzLmRldGVybWluZVNjYWxlKCk7XG4gICAgfVxuICB9XG5cbiAgRGF0YVNjYWxlLnByb3RvdHlwZS5zZXRDaGFySGVpZ2h0ID0gZnVuY3Rpb24gKG1ham9yQ2hhckhlaWdodCkge1xuICAgIHRoaXMubWFqb3JDaGFySGVpZ2h0ID0gbWFqb3JDaGFySGVpZ2h0O1xuICB9O1xuXG4gIERhdGFTY2FsZS5wcm90b3R5cGUuc2V0SGVpZ2h0ID0gZnVuY3Rpb24gKGNvbnRhaW5lckhlaWdodCkge1xuICAgIHRoaXMuY29udGFpbmVySGVpZ2h0ID0gY29udGFpbmVySGVpZ2h0O1xuICB9O1xuXG4gIERhdGFTY2FsZS5wcm90b3R5cGUuZGV0ZXJtaW5lU2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJhbmdlID0gdGhpcy5fZW5kIC0gdGhpcy5fc3RhcnQ7XG4gICAgdGhpcy5zY2FsZSA9IHRoaXMuY29udGFpbmVySGVpZ2h0IC8gcmFuZ2U7XG4gICAgdmFyIG1pbmltdW1TdGVwVmFsdWUgPSB0aGlzLm1ham9yQ2hhckhlaWdodCAvIHRoaXMuc2NhbGU7XG4gICAgdmFyIG9yZGVyT2ZNYWduaXR1ZGUgPSByYW5nZSA+IDAgPyBNYXRoLnJvdW5kKE1hdGgubG9nKHJhbmdlKSAvIE1hdGguTE4xMCkgOiAwO1xuXG4gICAgdGhpcy5taW5vclN0ZXBJZHggPSAtMTtcbiAgICB0aGlzLm1hZ25pdHVkZWZhY3RvciA9IE1hdGgucG93KDEwLCBvcmRlck9mTWFnbml0dWRlKTtcblxuICAgIHZhciBzdGFydCA9IDA7XG4gICAgaWYgKG9yZGVyT2ZNYWduaXR1ZGUgPCAwKSB7XG4gICAgICBzdGFydCA9IG9yZGVyT2ZNYWduaXR1ZGU7XG4gICAgfVxuXG4gICAgdmFyIHNvbHV0aW9uRm91bmQgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBsID0gc3RhcnQ7IE1hdGguYWJzKGwpIDw9IE1hdGguYWJzKG9yZGVyT2ZNYWduaXR1ZGUpOyBsKyspIHtcbiAgICAgIHRoaXMubWFnbml0dWRlZmFjdG9yID0gTWF0aC5wb3coMTAsIGwpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLm1pbm9yU3RlcHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIHN0ZXBTaXplID0gdGhpcy5tYWduaXR1ZGVmYWN0b3IgKiB0aGlzLm1pbm9yU3RlcHNbal07XG4gICAgICAgIGlmIChzdGVwU2l6ZSA+PSBtaW5pbXVtU3RlcFZhbHVlKSB7XG4gICAgICAgICAgc29sdXRpb25Gb3VuZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5taW5vclN0ZXBJZHggPSBqO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc29sdXRpb25Gb3VuZCA9PT0gdHJ1ZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgRGF0YVNjYWxlLnByb3RvdHlwZS5pc19tYWpvciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAlICh0aGlzLm1hZ25pdHVkZWZhY3RvciAqIHRoaXMubWFqb3JTdGVwc1t0aGlzLm1pbm9yU3RlcElkeF0pID09PSAwO1xuICB9O1xuXG4gIERhdGFTY2FsZS5wcm90b3R5cGUuZ2V0U3RlcCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5tYWduaXR1ZGVmYWN0b3IgKiB0aGlzLm1pbm9yU3RlcHNbdGhpcy5taW5vclN0ZXBJZHhdO1xuICB9O1xuXG4gIERhdGFTY2FsZS5wcm90b3R5cGUuZ2V0Rmlyc3RNYWpvciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbWFqb3JTdGVwID0gdGhpcy5tYWduaXR1ZGVmYWN0b3IgKiB0aGlzLm1ham9yU3RlcHNbdGhpcy5taW5vclN0ZXBJZHhdO1xuICAgIHJldHVybiB0aGlzLmNvbnZlcnRWYWx1ZSh0aGlzLl9zdGFydCArIChtYWpvclN0ZXAgLSB0aGlzLl9zdGFydCAlIG1ham9yU3RlcCkgJSBtYWpvclN0ZXApO1xuICB9O1xuXG4gIERhdGFTY2FsZS5wcm90b3R5cGUuZm9ybWF0VmFsdWUgPSBmdW5jdGlvbiAoY3VycmVudCkge1xuICAgIHZhciByZXR1cm5WYWx1ZSA9IGN1cnJlbnQudG9QcmVjaXNpb24oNSk7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmZvcm1hdHRpbmdGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuVmFsdWUgPSB0aGlzLmZvcm1hdHRpbmdGdW5jdGlvbihjdXJyZW50KTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHJldHVyblZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuICcnICsgcmV0dXJuVmFsdWU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcmV0dXJuVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdXJyZW50LnRvUHJlY2lzaW9uKDUpO1xuICAgIH1cbiAgfTtcblxuICBEYXRhU2NhbGUucHJvdG90eXBlLmdldExpbmVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsaW5lcyA9IFtdO1xuICAgIHZhciBzdGVwID0gdGhpcy5nZXRTdGVwKCk7XG4gICAgdmFyIGJvdHRvbU9mZnNldCA9IChzdGVwIC0gdGhpcy5fc3RhcnQgJSBzdGVwKSAlIHN0ZXA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuX3N0YXJ0ICsgYm90dG9tT2Zmc2V0OyB0aGlzLl9lbmQgLSBpID4gMC4wMDAwMTsgaSArPSBzdGVwKSB7XG4gICAgICBpZiAoaSAhPSB0aGlzLl9zdGFydCkge1xuICAgICAgICAvL1NraXAgdGhlIGJvdHRvbSBsaW5lXG4gICAgICAgIGxpbmVzLnB1c2goeyBtYWpvcjogdGhpcy5pc19tYWpvcihpKSwgeTogdGhpcy5jb252ZXJ0VmFsdWUoaSksIHZhbDogdGhpcy5mb3JtYXRWYWx1ZShpKSB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxpbmVzO1xuICB9O1xuXG4gIERhdGFTY2FsZS5wcm90b3R5cGUuZm9sbG93U2NhbGUgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICB2YXIgb2xkU3RlcElkeCA9IHRoaXMubWlub3JTdGVwSWR4O1xuICAgIHZhciBvbGRTdGFydCA9IHRoaXMuX3N0YXJ0O1xuICAgIHZhciBvbGRFbmQgPSB0aGlzLl9lbmQ7XG5cbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciBpbmNyZWFzZU1hZ25pdHVkZSA9IGZ1bmN0aW9uIGluY3JlYXNlTWFnbml0dWRlKCkge1xuICAgICAgbWUubWFnbml0dWRlZmFjdG9yICo9IDI7XG4gICAgfTtcbiAgICB2YXIgZGVjcmVhc2VNYWduaXR1ZGUgPSBmdW5jdGlvbiBkZWNyZWFzZU1hZ25pdHVkZSgpIHtcbiAgICAgIG1lLm1hZ25pdHVkZWZhY3RvciAvPSAyO1xuICAgIH07XG5cbiAgICBpZiAob3RoZXIubWlub3JTdGVwSWR4IDw9IDEgJiYgdGhpcy5taW5vclN0ZXBJZHggPD0gMSB8fCBvdGhlci5taW5vclN0ZXBJZHggPiAxICYmIHRoaXMubWlub3JTdGVwSWR4ID4gMSkge1xuICAgICAgLy9lYXN5LCBubyBuZWVkIHRvIGNoYW5nZSBzdGVwSWR4IG5vciBtdWx0aXBsaWNhdGlvbiBmYWN0b3JcbiAgICB9IGVsc2UgaWYgKG90aGVyLm1pbm9yU3RlcElkeCA8IHRoaXMubWlub3JTdGVwSWR4KSB7XG4gICAgICAgIC8vSSdtIDUsIHRoZXkgYXJlIDQgcGVyIG1ham9yLlxuICAgICAgICB0aGlzLm1pbm9yU3RlcElkeCA9IDE7XG4gICAgICAgIGlmIChvbGRTdGVwSWR4ID09IDIpIHtcbiAgICAgICAgICBpbmNyZWFzZU1hZ25pdHVkZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluY3JlYXNlTWFnbml0dWRlKCk7XG4gICAgICAgICAgaW5jcmVhc2VNYWduaXR1ZGUoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9JJ20gNCwgdGhleSBhcmUgNSBwZXIgbWFqb3JcbiAgICAgICAgdGhpcy5taW5vclN0ZXBJZHggPSAyO1xuICAgICAgICBpZiAob2xkU3RlcElkeCA9PSAxKSB7XG4gICAgICAgICAgZGVjcmVhc2VNYWduaXR1ZGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWNyZWFzZU1hZ25pdHVkZSgpO1xuICAgICAgICAgIGRlY3JlYXNlTWFnbml0dWRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIC8vR2V0IG1hc3RlcnMgc3RhdHM6XG4gICAgdmFyIGxpbmVzID0gb3RoZXIuZ2V0TGluZXMoKTtcbiAgICB2YXIgb3RoZXJaZXJvID0gb3RoZXIuY29udmVydFZhbHVlKDApO1xuICAgIHZhciBvdGhlclN0ZXAgPSBvdGhlci5nZXRTdGVwKCkgKiBvdGhlci5zY2FsZTtcblxuICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICAvL0xvb3AgdW50aWwgbWFnbml0dWRlIGlzIGNvcnJlY3QgZm9yIGdpdmVuIGNvbnN0cmFpbnMuXG4gICAgd2hpbGUgKCFkb25lICYmIGNvdW50KysgPCA1KSB7XG5cbiAgICAgIC8vR2V0IG15IHN0YXRzOlxuICAgICAgdGhpcy5zY2FsZSA9IG90aGVyU3RlcCAvICh0aGlzLm1pbm9yU3RlcHNbdGhpcy5taW5vclN0ZXBJZHhdICogdGhpcy5tYWduaXR1ZGVmYWN0b3IpO1xuICAgICAgdmFyIG5ld1JhbmdlID0gdGhpcy5jb250YWluZXJIZWlnaHQgLyB0aGlzLnNjYWxlO1xuXG4gICAgICAvL0ZvciB0aGUgY2FzZSB0aGUgbWFnbml0dWRlZmFjdG9yIGhhcyBjaGFuZ2VkOlxuICAgICAgdGhpcy5fc3RhcnQgPSBvbGRTdGFydDtcbiAgICAgIHRoaXMuX2VuZCA9IHRoaXMuX3N0YXJ0ICsgbmV3UmFuZ2U7XG5cbiAgICAgIHZhciBteU9yaWdpbmFsWmVybyA9IHRoaXMuX2VuZCAqIHRoaXMuc2NhbGU7XG4gICAgICB2YXIgbWFqb3JTdGVwID0gdGhpcy5tYWduaXR1ZGVmYWN0b3IgKiB0aGlzLm1ham9yU3RlcHNbdGhpcy5taW5vclN0ZXBJZHhdO1xuICAgICAgdmFyIG1ham9yT2Zmc2V0ID0gdGhpcy5nZXRGaXJzdE1ham9yKCkgLSBvdGhlci5nZXRGaXJzdE1ham9yKCk7XG5cbiAgICAgIGlmICh0aGlzLnplcm9BbGlnbikge1xuICAgICAgICB2YXIgemVyb09mZnNldCA9IG90aGVyWmVybyAtIG15T3JpZ2luYWxaZXJvO1xuICAgICAgICB0aGlzLl9lbmQgKz0gemVyb09mZnNldCAvIHRoaXMuc2NhbGU7XG4gICAgICAgIHRoaXMuX3N0YXJ0ID0gdGhpcy5fZW5kIC0gbmV3UmFuZ2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXRoaXMuYXV0b1NjYWxlU3RhcnQpIHtcbiAgICAgICAgICB0aGlzLl9zdGFydCArPSBtYWpvclN0ZXAgLSBtYWpvck9mZnNldCAvIHRoaXMuc2NhbGU7XG4gICAgICAgICAgdGhpcy5fZW5kID0gdGhpcy5fc3RhcnQgKyBuZXdSYW5nZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9zdGFydCAtPSBtYWpvck9mZnNldCAvIHRoaXMuc2NhbGU7XG4gICAgICAgICAgdGhpcy5fZW5kID0gdGhpcy5fc3RhcnQgKyBuZXdSYW5nZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmF1dG9TY2FsZUVuZCAmJiB0aGlzLl9lbmQgPiBvbGRFbmQgKyAwLjAwMDAxKSB7XG4gICAgICAgIC8vTmVlZCB0byBkZWNyZWFzZSBtYWduaXR1ZGUgdG8gcHJldmVudCBzY2FsZSBvdmVyc2hvb3QhIChlbmQpXG4gICAgICAgIGRlY3JlYXNlTWFnbml0dWRlKCk7XG4gICAgICAgIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuYXV0b1NjYWxlU3RhcnQgJiYgdGhpcy5fc3RhcnQgPCBvbGRTdGFydCAtIDAuMDAwMDEpIHtcbiAgICAgICAgaWYgKHRoaXMuemVyb0FsaWduICYmIG9sZFN0YXJ0ID49IDApIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJDYW4ndCBhZGhlcmUgdG8gZ2l2ZW4gJ21pbicgcmFuZ2UsIGR1ZSB0byB6ZXJvYWxpZ25cIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9OZWVkIHRvIGRlY3JlYXNlIG1hZ25pdHVkZSB0byBwcmV2ZW50IHNjYWxlIG92ZXJzaG9vdCEgKHN0YXJ0KVxuICAgICAgICAgIGRlY3JlYXNlTWFnbml0dWRlKCk7XG4gICAgICAgICAgZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5hdXRvU2NhbGVTdGFydCAmJiB0aGlzLmF1dG9TY2FsZUVuZCAmJiBuZXdSYW5nZSA8IG9sZEVuZCAtIG9sZFN0YXJ0KSB7XG4gICAgICAgIGluY3JlYXNlTWFnbml0dWRlKCk7XG4gICAgICAgIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBkb25lID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgRGF0YVNjYWxlLnByb3RvdHlwZS5jb252ZXJ0VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXJIZWlnaHQgLSAodmFsdWUgLSB0aGlzLl9zdGFydCkgKiB0aGlzLnNjYWxlO1xuICB9O1xuXG4gIERhdGFTY2FsZS5wcm90b3R5cGUuc2NyZWVuVG9WYWx1ZSA9IGZ1bmN0aW9uIChwaXhlbHMpIHtcbiAgICByZXR1cm4gKHRoaXMuY29udGFpbmVySGVpZ2h0IC0gcGl4ZWxzKSAvIHRoaXMuc2NhbGUgKyB0aGlzLl9zdGFydDtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IERhdGFTY2FsZTtcblxuLyoqKi8gfSxcbi8qIDU0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbiAgdmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuICB2YXIgRE9NdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG4gIHZhciBCYXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NSk7XG4gIHZhciBMaW5lcyA9IF9fd2VicGFja19yZXF1aXJlX18oNTcpO1xuICB2YXIgUG9pbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nik7XG5cbiAgLyoqXG4gICAqIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZ3JvdXAgICAgICAgICAgICB8IHRoZSBvYmplY3Qgb2YgdGhlIGdyb3VwIGZyb20gdGhlIGRhdGFzZXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGdyb3VwSWQgICAgICAgICAgfCBJRCBvZiB0aGUgZ3JvdXBcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgICAgICAgICAgfCB0aGUgZGVmYXVsdCBvcHRpb25zXG4gICAqIEBwYXJhbSB7YXJyYXl9IGdyb3Vwc1VzaW5nRGVmYXVsdFN0eWxlcyAgfCB0aGlzIGFycmF5IGhhcyBvbmUgZW50cmVlLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSXQgaXMgcGFzc2VkIGFzIGFuIGFycmF5IHNvIGl0IGlzIHBhc3NlZCBieSByZWZlcmVuY2UuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJdCBlbnVtZXJhdGVzIHRocm91Z2ggdGhlIGRlZmF1bHQgc3R5bGVzXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gR3JhcGhHcm91cChncm91cCwgZ3JvdXBJZCwgb3B0aW9ucywgZ3JvdXBzVXNpbmdEZWZhdWx0U3R5bGVzKSB7XG4gICAgdGhpcy5pZCA9IGdyb3VwSWQ7XG4gICAgdmFyIGZpZWxkcyA9IFsnc2FtcGxpbmcnLCAnc3R5bGUnLCAnc29ydCcsICd5QXhpc09yaWVudGF0aW9uJywgJ2JhckNoYXJ0JywgJ2RyYXdQb2ludHMnLCAnc2hhZGVkJywgJ2ludGVycG9sYXRpb24nLCAnekluZGV4JywgJ2V4Y2x1ZGVGcm9tU3RhY2tpbmcnLCAnZXhjbHVkZUZyb21MZWdlbmQnXTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1dGlsLnNlbGVjdGl2ZUJyaWRnZU9iamVjdChmaWVsZHMsIG9wdGlvbnMpO1xuICAgIHRoaXMudXNpbmdEZWZhdWx0U3R5bGUgPSBncm91cC5jbGFzc05hbWUgPT09IHVuZGVmaW5lZDtcbiAgICB0aGlzLmdyb3Vwc1VzaW5nRGVmYXVsdFN0eWxlcyA9IGdyb3Vwc1VzaW5nRGVmYXVsdFN0eWxlcztcbiAgICB0aGlzLnplcm9Qb3NpdGlvbiA9IDA7XG4gICAgdGhpcy51cGRhdGUoZ3JvdXApO1xuICAgIGlmICh0aGlzLnVzaW5nRGVmYXVsdFN0eWxlID09IHRydWUpIHtcbiAgICAgIHRoaXMuZ3JvdXBzVXNpbmdEZWZhdWx0U3R5bGVzWzBdICs9IDE7XG4gICAgfVxuICAgIHRoaXMuaXRlbXNEYXRhID0gW107XG4gICAgdGhpcy52aXNpYmxlID0gZ3JvdXAudmlzaWJsZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGdyb3VwLnZpc2libGU7XG4gIH1cblxuICAvKipcbiAgICogdGhpcyBsb2FkcyBhIHJlZmVyZW5jZSB0byBhbGwgaXRlbXMgaW4gdGhpcyBncm91cCBpbnRvIHRoaXMgZ3JvdXAuXG4gICAqIEBwYXJhbSB7YXJyYXl9IGl0ZW1zXG4gICAqL1xuICBHcmFwaEdyb3VwLnByb3RvdHlwZS5zZXRJdGVtcyA9IGZ1bmN0aW9uIChpdGVtcykge1xuICAgIGlmIChpdGVtcyAhPSBudWxsKSB7XG4gICAgICB0aGlzLml0ZW1zRGF0YSA9IGl0ZW1zO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zb3J0ID09IHRydWUpIHtcbiAgICAgICAgdXRpbC5pbnNlcnRTb3J0KHRoaXMuaXRlbXNEYXRhLCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIHJldHVybiBhLnggPiBiLnggPyAxIDogLTE7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLml0ZW1zRGF0YSA9IFtdO1xuICAgIH1cbiAgfTtcblxuICBHcmFwaEdyb3VwLnByb3RvdHlwZS5nZXRJdGVtcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtc0RhdGE7XG4gIH07XG5cbiAgLyoqXG4gICAqIHRoaXMgaXMgdXNlZCBmb3IgYmFyY2hhcnRzIGFuZCBzaGFkaW5nLCB0aGlzIHdheSwgd2Ugb25seSBoYXZlIHRvIGNhbGN1bGF0ZSBpdCBvbmNlLlxuICAgKiBAcGFyYW0gcG9zXG4gICAqL1xuICBHcmFwaEdyb3VwLnByb3RvdHlwZS5zZXRaZXJvUG9zaXRpb24gPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgdGhpcy56ZXJvUG9zaXRpb24gPSBwb3M7XG4gIH07XG5cbiAgLyoqXG4gICAqIHNldCB0aGUgb3B0aW9ucyBvZiB0aGUgZ3JhcGggZ3JvdXAgb3ZlciB0aGUgZGVmYXVsdCBvcHRpb25zLlxuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKi9cbiAgR3JhcGhHcm91cC5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpZWxkcyA9IFsnc2FtcGxpbmcnLCAnc3R5bGUnLCAnc29ydCcsICd5QXhpc09yaWVudGF0aW9uJywgJ2JhckNoYXJ0JywgJ3pJbmRleCcsICdleGNsdWRlRnJvbVN0YWNraW5nJywgJ2V4Y2x1ZGVGcm9tTGVnZW5kJ107XG4gICAgICB1dGlsLnNlbGVjdGl2ZURlZXBFeHRlbmQoZmllbGRzLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBpZiB0aGUgZ3JvdXAncyBkcmF3UG9pbnRzIGlzIGEgZnVuY3Rpb24gZGVsZWdhdGUgdGhlIGNhbGxiYWNrIHRvIHRoZSBvblJlbmRlciBwcm9wZXJ0eVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmRyYXdQb2ludHMgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvcHRpb25zLmRyYXdQb2ludHMgPSB7XG4gICAgICAgICAgb25SZW5kZXI6IG9wdGlvbnMuZHJhd1BvaW50c1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB1dGlsLm1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMsICdpbnRlcnBvbGF0aW9uJyk7XG4gICAgICB1dGlsLm1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMsICdkcmF3UG9pbnRzJyk7XG4gICAgICB1dGlsLm1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMsICdzaGFkZWQnKTtcblxuICAgICAgaWYgKG9wdGlvbnMuaW50ZXJwb2xhdGlvbikge1xuICAgICAgICBpZiAoX3R5cGVvZihvcHRpb25zLmludGVycG9sYXRpb24pID09ICdvYmplY3QnKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuaW50ZXJwb2xhdGlvbi5wYXJhbWV0cml6YXRpb24pIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmludGVycG9sYXRpb24ucGFyYW1ldHJpemF0aW9uID09ICd1bmlmb3JtJykge1xuICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5hbHBoYSA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuaW50ZXJwb2xhdGlvbi5wYXJhbWV0cml6YXRpb24gPT0gJ2Nob3JkYWwnKSB7XG4gICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmFscGhhID0gMS4wO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmludGVycG9sYXRpb24ucGFyYW1ldHJpemF0aW9uID0gJ2NlbnRyaXBldGFsJztcbiAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmludGVycG9sYXRpb24uYWxwaGEgPSAwLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiB0aGlzIHVwZGF0ZXMgdGhlIGN1cnJlbnQgZ3JvdXAgY2xhc3Mgd2l0aCB0aGUgbGF0ZXN0IGdyb3VwIGRhdGFzZXQgZW50cmVlLCB1c2VkIGluIF91cGRhdGVHcm91cCBpbiBsaW5lZ3JhcGhcbiAgICogQHBhcmFtIGdyb3VwXG4gICAqL1xuICBHcmFwaEdyb3VwLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICB0aGlzLmdyb3VwID0gZ3JvdXA7XG4gICAgdGhpcy5jb250ZW50ID0gZ3JvdXAuY29udGVudCB8fCAnZ3JhcGgnO1xuICAgIHRoaXMuY2xhc3NOYW1lID0gZ3JvdXAuY2xhc3NOYW1lIHx8IHRoaXMuY2xhc3NOYW1lIHx8ICd2aXMtZ3JhcGgtZ3JvdXAnICsgdGhpcy5ncm91cHNVc2luZ0RlZmF1bHRTdHlsZXNbMF0gJSAxMDtcbiAgICB0aGlzLnZpc2libGUgPSBncm91cC52aXNpYmxlID09PSB1bmRlZmluZWQgPyB0cnVlIDogZ3JvdXAudmlzaWJsZTtcbiAgICB0aGlzLnN0eWxlID0gZ3JvdXAuc3R5bGU7XG4gICAgdGhpcy5zZXRPcHRpb25zKGdyb3VwLm9wdGlvbnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiByZXR1cm4gdGhlIGxlZ2VuZCBlbnRyZWUgZm9yIHRoaXMgZ3JvdXAuXG4gICAqXG4gICAqIEBwYXJhbSBpY29uV2lkdGhcbiAgICogQHBhcmFtIGljb25IZWlnaHRcbiAgICogQHJldHVybnMge3tpY29uOiBIVE1MRWxlbWVudCwgbGFiZWw6IChncm91cC5jb250ZW50fCp8c3RyaW5nKSwgb3JpZW50YXRpb246ICgub3B0aW9ucy55QXhpc09yaWVudGF0aW9ufCopfX1cbiAgICovXG4gIEdyYXBoR3JvdXAucHJvdG90eXBlLmdldExlZ2VuZCA9IGZ1bmN0aW9uIChpY29uV2lkdGgsIGljb25IZWlnaHQsIGZyYW1ld29yaywgeCwgeSkge1xuICAgIGlmIChmcmFtZXdvcmsgPT0gdW5kZWZpbmVkIHx8IGZyYW1ld29yayA9PSBudWxsKSB7XG4gICAgICB2YXIgc3ZnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIFwic3ZnXCIpO1xuICAgICAgZnJhbWV3b3JrID0geyBzdmc6IHN2Zywgc3ZnRWxlbWVudHM6IHt9LCBvcHRpb25zOiB0aGlzLm9wdGlvbnMsIGdyb3VwczogW3RoaXNdIH07XG4gICAgfVxuICAgIGlmICh4ID09IHVuZGVmaW5lZCB8fCB4ID09IG51bGwpIHtcbiAgICAgIHggPSAwO1xuICAgIH1cbiAgICBpZiAoeSA9PSB1bmRlZmluZWQgfHwgeSA9PSBudWxsKSB7XG4gICAgICB5ID0gMC41ICogaWNvbkhlaWdodDtcbiAgICB9XG4gICAgc3dpdGNoICh0aGlzLm9wdGlvbnMuc3R5bGUpIHtcbiAgICAgIGNhc2UgXCJsaW5lXCI6XG4gICAgICAgIExpbmVzLmRyYXdJY29uKHRoaXMsIHgsIHksIGljb25XaWR0aCwgaWNvbkhlaWdodCwgZnJhbWV3b3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicG9pbnRzXCI6IC8vZXhwbGljaXQgbm8gYnJlYWtcbiAgICAgIGNhc2UgXCJwb2ludFwiOlxuICAgICAgICBQb2ludHMuZHJhd0ljb24odGhpcywgeCwgeSwgaWNvbldpZHRoLCBpY29uSGVpZ2h0LCBmcmFtZXdvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJiYXJcIjpcbiAgICAgICAgQmFycy5kcmF3SWNvbih0aGlzLCB4LCB5LCBpY29uV2lkdGgsIGljb25IZWlnaHQsIGZyYW1ld29yayk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4geyBpY29uOiBmcmFtZXdvcmsuc3ZnLCBsYWJlbDogdGhpcy5jb250ZW50LCBvcmllbnRhdGlvbjogdGhpcy5vcHRpb25zLnlBeGlzT3JpZW50YXRpb24gfTtcbiAgfTtcblxuICBHcmFwaEdyb3VwLnByb3RvdHlwZS5nZXRZUmFuZ2UgPSBmdW5jdGlvbiAoZ3JvdXBEYXRhKSB7XG4gICAgdmFyIHlNaW4gPSBncm91cERhdGFbMF0ueTtcbiAgICB2YXIgeU1heCA9IGdyb3VwRGF0YVswXS55O1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ3JvdXBEYXRhLmxlbmd0aDsgaisrKSB7XG4gICAgICB5TWluID0geU1pbiA+IGdyb3VwRGF0YVtqXS55ID8gZ3JvdXBEYXRhW2pdLnkgOiB5TWluO1xuICAgICAgeU1heCA9IHlNYXggPCBncm91cERhdGFbal0ueSA/IGdyb3VwRGF0YVtqXS55IDogeU1heDtcbiAgICB9XG4gICAgcmV0dXJuIHsgbWluOiB5TWluLCBtYXg6IHlNYXgsIHlBeGlzT3JpZW50YXRpb246IHRoaXMub3B0aW9ucy55QXhpc09yaWVudGF0aW9uIH07XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBHcmFwaEdyb3VwO1xuXG4vKioqLyB9LFxuLyogNTUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgRE9NdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG4gIHZhciBQb2ludHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2KTtcblxuICBmdW5jdGlvbiBCYXJncmFwaChncm91cElkLCBvcHRpb25zKSB7fVxuXG4gIEJhcmdyYXBoLmRyYXdJY29uID0gZnVuY3Rpb24gKGdyb3VwLCB4LCB5LCBpY29uV2lkdGgsIGljb25IZWlnaHQsIGZyYW1ld29yaykge1xuICAgIHZhciBmaWxsSGVpZ2h0ID0gaWNvbkhlaWdodCAqIDAuNTtcbiAgICB2YXIgcGF0aCwgZmlsbFBhdGg7XG5cbiAgICB2YXIgb3V0bGluZSA9IERPTXV0aWwuZ2V0U1ZHRWxlbWVudChcInJlY3RcIiwgZnJhbWV3b3JrLnN2Z0VsZW1lbnRzLCBmcmFtZXdvcmsuc3ZnKTtcbiAgICBvdXRsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieFwiLCB4KTtcbiAgICBvdXRsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCB5IC0gZmlsbEhlaWdodCk7XG4gICAgb3V0bGluZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIndpZHRoXCIsIGljb25XaWR0aCk7XG4gICAgb3V0bGluZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImhlaWdodFwiLCAyICogZmlsbEhlaWdodCk7XG4gICAgb3V0bGluZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImNsYXNzXCIsIFwidmlzLW91dGxpbmVcIik7XG5cbiAgICB2YXIgYmFyV2lkdGggPSBNYXRoLnJvdW5kKDAuMyAqIGljb25XaWR0aCk7XG4gICAgdmFyIG9yaWdpbmFsV2lkdGggPSBncm91cC5vcHRpb25zLmJhckNoYXJ0LndpZHRoO1xuICAgIHZhciBzY2FsZSA9IG9yaWdpbmFsV2lkdGggLyBiYXJXaWR0aDtcbiAgICB2YXIgYmFyMUhlaWdodCA9IE1hdGgucm91bmQoMC40ICogaWNvbkhlaWdodCk7XG4gICAgdmFyIGJhcjJIZWlnaHQgPSBNYXRoLnJvdW5kKDAuNzUgKiBpY29uSGVpZ2h0KTtcblxuICAgIHZhciBvZmZzZXQgPSBNYXRoLnJvdW5kKChpY29uV2lkdGggLSAyICogYmFyV2lkdGgpIC8gMyk7XG5cbiAgICBET011dGlsLmRyYXdCYXIoeCArIDAuNSAqIGJhcldpZHRoICsgb2Zmc2V0LCB5ICsgZmlsbEhlaWdodCAtIGJhcjFIZWlnaHQgLSAxLCBiYXJXaWR0aCwgYmFyMUhlaWdodCwgZ3JvdXAuY2xhc3NOYW1lICsgJyB2aXMtYmFyJywgZnJhbWV3b3JrLnN2Z0VsZW1lbnRzLCBmcmFtZXdvcmsuc3ZnLCBncm91cC5zdHlsZSk7XG4gICAgRE9NdXRpbC5kcmF3QmFyKHggKyAxLjUgKiBiYXJXaWR0aCArIG9mZnNldCArIDIsIHkgKyBmaWxsSGVpZ2h0IC0gYmFyMkhlaWdodCAtIDEsIGJhcldpZHRoLCBiYXIySGVpZ2h0LCBncm91cC5jbGFzc05hbWUgKyAnIHZpcy1iYXInLCBmcmFtZXdvcmsuc3ZnRWxlbWVudHMsIGZyYW1ld29yay5zdmcsIGdyb3VwLnN0eWxlKTtcblxuICAgIGlmIChncm91cC5vcHRpb25zLmRyYXdQb2ludHMuZW5hYmxlZCA9PSB0cnVlKSB7XG4gICAgICB2YXIgZ3JvdXBUZW1wbGF0ZSA9IHtcbiAgICAgICAgc3R5bGU6IGdyb3VwLm9wdGlvbnMuZHJhd1BvaW50cy5zdHlsZSxcbiAgICAgICAgc3R5bGVzOiBncm91cC5vcHRpb25zLmRyYXdQb2ludHMuc3R5bGVzLFxuICAgICAgICBzaXplOiBncm91cC5vcHRpb25zLmRyYXdQb2ludHMuc2l6ZSAvIHNjYWxlLFxuICAgICAgICBjbGFzc05hbWU6IGdyb3VwLmNsYXNzTmFtZVxuICAgICAgfTtcbiAgICAgIERPTXV0aWwuZHJhd1BvaW50KHggKyAwLjUgKiBiYXJXaWR0aCArIG9mZnNldCwgeSArIGZpbGxIZWlnaHQgLSBiYXIxSGVpZ2h0IC0gMSwgZ3JvdXBUZW1wbGF0ZSwgZnJhbWV3b3JrLnN2Z0VsZW1lbnRzLCBmcmFtZXdvcmsuc3ZnKTtcbiAgICAgIERPTXV0aWwuZHJhd1BvaW50KHggKyAxLjUgKiBiYXJXaWR0aCArIG9mZnNldCArIDIsIHkgKyBmaWxsSGVpZ2h0IC0gYmFyMkhlaWdodCAtIDEsIGdyb3VwVGVtcGxhdGUsIGZyYW1ld29yay5zdmdFbGVtZW50cywgZnJhbWV3b3JrLnN2Zyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBkcmF3IGEgYmFyIGdyYXBoXG4gICAqXG4gICAqIEBwYXJhbSBncm91cElkc1xuICAgKiBAcGFyYW0gcHJvY2Vzc2VkR3JvdXBEYXRhXG4gICAqL1xuICBCYXJncmFwaC5kcmF3ID0gZnVuY3Rpb24gKGdyb3VwSWRzLCBwcm9jZXNzZWRHcm91cERhdGEsIGZyYW1ld29yaykge1xuICAgIHZhciBjb21iaW5lZERhdGEgPSBbXTtcbiAgICB2YXIgaW50ZXJzZWN0aW9ucyA9IHt9O1xuICAgIHZhciBjb3JlRGlzdGFuY2U7XG4gICAgdmFyIGtleSwgZHJhd0RhdGE7XG4gICAgdmFyIGdyb3VwO1xuICAgIHZhciBpLCBqO1xuICAgIHZhciBiYXJQb2ludHMgPSAwO1xuXG4gICAgLy8gY29tYmluZSBhbGwgYmFyY2hhcnQgZGF0YVxuICAgIGZvciAoaSA9IDA7IGkgPCBncm91cElkcy5sZW5ndGg7IGkrKykge1xuICAgICAgZ3JvdXAgPSBmcmFtZXdvcmsuZ3JvdXBzW2dyb3VwSWRzW2ldXTtcbiAgICAgIGlmIChncm91cC5vcHRpb25zLnN0eWxlID09PSAnYmFyJykge1xuICAgICAgICBpZiAoZ3JvdXAudmlzaWJsZSA9PT0gdHJ1ZSAmJiAoZnJhbWV3b3JrLm9wdGlvbnMuZ3JvdXBzLnZpc2liaWxpdHlbZ3JvdXBJZHNbaV1dID09PSB1bmRlZmluZWQgfHwgZnJhbWV3b3JrLm9wdGlvbnMuZ3JvdXBzLnZpc2liaWxpdHlbZ3JvdXBJZHNbaV1dID09PSB0cnVlKSkge1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBwcm9jZXNzZWRHcm91cERhdGFbZ3JvdXBJZHNbaV1dLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb21iaW5lZERhdGEucHVzaCh7XG4gICAgICAgICAgICAgIHNjcmVlbl94OiBwcm9jZXNzZWRHcm91cERhdGFbZ3JvdXBJZHNbaV1dW2pdLnNjcmVlbl94LFxuICAgICAgICAgICAgICBzY3JlZW5feTogcHJvY2Vzc2VkR3JvdXBEYXRhW2dyb3VwSWRzW2ldXVtqXS5zY3JlZW5feSxcbiAgICAgICAgICAgICAgeDogcHJvY2Vzc2VkR3JvdXBEYXRhW2dyb3VwSWRzW2ldXVtqXS54LFxuICAgICAgICAgICAgICB5OiBwcm9jZXNzZWRHcm91cERhdGFbZ3JvdXBJZHNbaV1dW2pdLnksXG4gICAgICAgICAgICAgIGdyb3VwSWQ6IGdyb3VwSWRzW2ldLFxuICAgICAgICAgICAgICBsYWJlbDogcHJvY2Vzc2VkR3JvdXBEYXRhW2dyb3VwSWRzW2ldXVtqXS5sYWJlbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBiYXJQb2ludHMgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYmFyUG9pbnRzID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gc29ydCBieSB0aW1lIGFuZCBieSBncm91cFxuICAgIGNvbWJpbmVkRGF0YS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICBpZiAoYS5zY3JlZW5feCA9PT0gYi5zY3JlZW5feCkge1xuICAgICAgICByZXR1cm4gYS5ncm91cElkIDwgYi5ncm91cElkID8gLTEgOiAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGEuc2NyZWVuX3ggLSBiLnNjcmVlbl94O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gZ2V0IGludGVyc2VjdGlvbnNcbiAgICBCYXJncmFwaC5fZ2V0RGF0YUludGVyc2VjdGlvbnMoaW50ZXJzZWN0aW9ucywgY29tYmluZWREYXRhKTtcblxuICAgIC8vIHBsb3QgYmFyY2hhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgY29tYmluZWREYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBncm91cCA9IGZyYW1ld29yay5ncm91cHNbY29tYmluZWREYXRhW2ldLmdyb3VwSWRdO1xuICAgICAgdmFyIG1pbldpZHRoID0gZ3JvdXAub3B0aW9ucy5iYXJDaGFydC5taW5XaWR0aCAhPSB1bmRlZmluZWQgPyBncm91cC5vcHRpb25zLmJhckNoYXJ0Lm1pbldpZHRoIDogMC4xICogZ3JvdXAub3B0aW9ucy5iYXJDaGFydC53aWR0aDtcblxuICAgICAga2V5ID0gY29tYmluZWREYXRhW2ldLnNjcmVlbl94O1xuICAgICAgdmFyIGhlaWdodE9mZnNldCA9IDA7XG4gICAgICBpZiAoaW50ZXJzZWN0aW9uc1trZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGkgKyAxIDwgY29tYmluZWREYXRhLmxlbmd0aCkge1xuICAgICAgICAgIGNvcmVEaXN0YW5jZSA9IE1hdGguYWJzKGNvbWJpbmVkRGF0YVtpICsgMV0uc2NyZWVuX3ggLSBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGRyYXdEYXRhID0gQmFyZ3JhcGguX2dldFNhZmVEcmF3RGF0YShjb3JlRGlzdGFuY2UsIGdyb3VwLCBtaW5XaWR0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbmV4dEtleSA9IGkgKyAoaW50ZXJzZWN0aW9uc1trZXldLmFtb3VudCAtIGludGVyc2VjdGlvbnNba2V5XS5yZXNvbHZlZCk7XG4gICAgICAgIHZhciBwcmV2S2V5ID0gaSAtIChpbnRlcnNlY3Rpb25zW2tleV0ucmVzb2x2ZWQgKyAxKTtcbiAgICAgICAgaWYgKG5leHRLZXkgPCBjb21iaW5lZERhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgY29yZURpc3RhbmNlID0gTWF0aC5hYnMoY29tYmluZWREYXRhW25leHRLZXldLnNjcmVlbl94IC0ga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBkcmF3RGF0YSA9IEJhcmdyYXBoLl9nZXRTYWZlRHJhd0RhdGEoY29yZURpc3RhbmNlLCBncm91cCwgbWluV2lkdGgpO1xuICAgICAgICBpbnRlcnNlY3Rpb25zW2tleV0ucmVzb2x2ZWQgKz0gMTtcblxuICAgICAgICBpZiAoZ3JvdXAub3B0aW9ucy5zdGFjayA9PT0gdHJ1ZSAmJiBncm91cC5vcHRpb25zLmV4Y2x1ZGVGcm9tU3RhY2tpbmcgIT09IHRydWUpIHtcbiAgICAgICAgICBpZiAoY29tYmluZWREYXRhW2ldLnNjcmVlbl95IDwgZ3JvdXAuemVyb1Bvc2l0aW9uKSB7XG4gICAgICAgICAgICBoZWlnaHRPZmZzZXQgPSBpbnRlcnNlY3Rpb25zW2tleV0uYWNjdW11bGF0ZWROZWdhdGl2ZTtcbiAgICAgICAgICAgIGludGVyc2VjdGlvbnNba2V5XS5hY2N1bXVsYXRlZE5lZ2F0aXZlICs9IGdyb3VwLnplcm9Qb3NpdGlvbiAtIGNvbWJpbmVkRGF0YVtpXS5zY3JlZW5feTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGVpZ2h0T2Zmc2V0ID0gaW50ZXJzZWN0aW9uc1trZXldLmFjY3VtdWxhdGVkUG9zaXRpdmU7XG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25zW2tleV0uYWNjdW11bGF0ZWRQb3NpdGl2ZSArPSBncm91cC56ZXJvUG9zaXRpb24gLSBjb21iaW5lZERhdGFbaV0uc2NyZWVuX3k7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGdyb3VwLm9wdGlvbnMuYmFyQ2hhcnQuc2lkZUJ5U2lkZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGRyYXdEYXRhLndpZHRoID0gZHJhd0RhdGEud2lkdGggLyBpbnRlcnNlY3Rpb25zW2tleV0uYW1vdW50O1xuICAgICAgICAgIGRyYXdEYXRhLm9mZnNldCArPSBpbnRlcnNlY3Rpb25zW2tleV0ucmVzb2x2ZWQgKiBkcmF3RGF0YS53aWR0aCAtIDAuNSAqIGRyYXdEYXRhLndpZHRoICogKGludGVyc2VjdGlvbnNba2V5XS5hbW91bnQgKyAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgRE9NdXRpbC5kcmF3QmFyKGNvbWJpbmVkRGF0YVtpXS5zY3JlZW5feCArIGRyYXdEYXRhLm9mZnNldCwgY29tYmluZWREYXRhW2ldLnNjcmVlbl95IC0gaGVpZ2h0T2Zmc2V0LCBkcmF3RGF0YS53aWR0aCwgZ3JvdXAuemVyb1Bvc2l0aW9uIC0gY29tYmluZWREYXRhW2ldLnNjcmVlbl95LCBncm91cC5jbGFzc05hbWUgKyAnIHZpcy1iYXInLCBmcmFtZXdvcmsuc3ZnRWxlbWVudHMsIGZyYW1ld29yay5zdmcsIGdyb3VwLnN0eWxlKTtcbiAgICAgIC8vIGRyYXcgcG9pbnRzXG4gICAgICBpZiAoZ3JvdXAub3B0aW9ucy5kcmF3UG9pbnRzLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIHBvaW50RGF0YSA9IHtcbiAgICAgICAgICBzY3JlZW5feDogY29tYmluZWREYXRhW2ldLnNjcmVlbl94LFxuICAgICAgICAgIHNjcmVlbl95OiBjb21iaW5lZERhdGFbaV0uc2NyZWVuX3kgLSBoZWlnaHRPZmZzZXQsXG4gICAgICAgICAgeDogY29tYmluZWREYXRhW2ldLngsXG4gICAgICAgICAgeTogY29tYmluZWREYXRhW2ldLnksXG4gICAgICAgICAgZ3JvdXBJZDogY29tYmluZWREYXRhW2ldLmdyb3VwSWQsXG4gICAgICAgICAgbGFiZWw6IGNvbWJpbmVkRGF0YVtpXS5sYWJlbFxuICAgICAgICB9O1xuICAgICAgICBQb2ludHMuZHJhdyhbcG9pbnREYXRhXSwgZ3JvdXAsIGZyYW1ld29yaywgZHJhd0RhdGEub2Zmc2V0KTtcbiAgICAgICAgLy9ET011dGlsLmRyYXdQb2ludChjb21iaW5lZERhdGFbaV0ueCArIGRyYXdEYXRhLm9mZnNldCwgY29tYmluZWREYXRhW2ldLnksIGdyb3VwLCBmcmFtZXdvcmsuc3ZnRWxlbWVudHMsIGZyYW1ld29yay5zdmcpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRmlsbCB0aGUgaW50ZXJzZWN0aW9ucyBvYmplY3Qgd2l0aCBjb3VudGVycyBvZiBob3cgbWFueSBkYXRhcG9pbnRzIHNoYXJlIHRoZSBzYW1lIHggY29vcmRpbmF0ZXNcbiAgICogQHBhcmFtIGludGVyc2VjdGlvbnNcbiAgICogQHBhcmFtIGNvbWJpbmVkRGF0YVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQmFyZ3JhcGguX2dldERhdGFJbnRlcnNlY3Rpb25zID0gZnVuY3Rpb24gKGludGVyc2VjdGlvbnMsIGNvbWJpbmVkRGF0YSkge1xuICAgIC8vIGdldCBpbnRlcnNlY3Rpb25zXG4gICAgdmFyIGNvcmVEaXN0YW5jZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbWJpbmVkRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGkgKyAxIDwgY29tYmluZWREYXRhLmxlbmd0aCkge1xuICAgICAgICBjb3JlRGlzdGFuY2UgPSBNYXRoLmFicyhjb21iaW5lZERhdGFbaSArIDFdLnNjcmVlbl94IC0gY29tYmluZWREYXRhW2ldLnNjcmVlbl94KTtcbiAgICAgIH1cbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICBjb3JlRGlzdGFuY2UgPSBNYXRoLm1pbihjb3JlRGlzdGFuY2UsIE1hdGguYWJzKGNvbWJpbmVkRGF0YVtpIC0gMV0uc2NyZWVuX3ggLSBjb21iaW5lZERhdGFbaV0uc2NyZWVuX3gpKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb3JlRGlzdGFuY2UgPT09IDApIHtcbiAgICAgICAgaWYgKGludGVyc2VjdGlvbnNbY29tYmluZWREYXRhW2ldLnNjcmVlbl94XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaW50ZXJzZWN0aW9uc1tjb21iaW5lZERhdGFbaV0uc2NyZWVuX3hdID0ge1xuICAgICAgICAgICAgYW1vdW50OiAwLFxuICAgICAgICAgICAgcmVzb2x2ZWQ6IDAsXG4gICAgICAgICAgICBhY2N1bXVsYXRlZFBvc2l0aXZlOiAwLFxuICAgICAgICAgICAgYWNjdW11bGF0ZWROZWdhdGl2ZTogMFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaW50ZXJzZWN0aW9uc1tjb21iaW5lZERhdGFbaV0uc2NyZWVuX3hdLmFtb3VudCArPSAxO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSB3aWR0aCBhbmQgb2Zmc2V0IGZvciBiYXJncmFwaHMgYmFzZWQgb24gdGhlIGNvcmVkaXN0YW5jZSBiZXR3ZWVuIGRhdGFwb2ludHNcbiAgICpcbiAgICogQHBhcmFtIGNvcmVEaXN0YW5jZVxuICAgKiBAcGFyYW0gZ3JvdXBcbiAgICogQHBhcmFtIG1pbldpZHRoXG4gICAqIEByZXR1cm5zIHt7d2lkdGg6IE51bWJlciwgb2Zmc2V0OiBOdW1iZXJ9fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQmFyZ3JhcGguX2dldFNhZmVEcmF3RGF0YSA9IGZ1bmN0aW9uIChjb3JlRGlzdGFuY2UsIGdyb3VwLCBtaW5XaWR0aCkge1xuICAgIHZhciB3aWR0aCwgb2Zmc2V0O1xuICAgIGlmIChjb3JlRGlzdGFuY2UgPCBncm91cC5vcHRpb25zLmJhckNoYXJ0LndpZHRoICYmIGNvcmVEaXN0YW5jZSA+IDApIHtcbiAgICAgIHdpZHRoID0gY29yZURpc3RhbmNlIDwgbWluV2lkdGggPyBtaW5XaWR0aCA6IGNvcmVEaXN0YW5jZTtcblxuICAgICAgb2Zmc2V0ID0gMDsgLy8gcmVjYWxjdWxhdGUgb2Zmc2V0IHdpdGggdGhlIG5ldyB3aWR0aDtcbiAgICAgIGlmIChncm91cC5vcHRpb25zLmJhckNoYXJ0LmFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgb2Zmc2V0IC09IDAuNSAqIGNvcmVEaXN0YW5jZTtcbiAgICAgIH0gZWxzZSBpZiAoZ3JvdXAub3B0aW9ucy5iYXJDaGFydC5hbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICBvZmZzZXQgKz0gMC41ICogY29yZURpc3RhbmNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkZWZhdWx0IHNldHRpbmdzXG4gICAgICB3aWR0aCA9IGdyb3VwLm9wdGlvbnMuYmFyQ2hhcnQud2lkdGg7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgICAgaWYgKGdyb3VwLm9wdGlvbnMuYmFyQ2hhcnQuYWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICBvZmZzZXQgLT0gMC41ICogZ3JvdXAub3B0aW9ucy5iYXJDaGFydC53aWR0aDtcbiAgICAgIH0gZWxzZSBpZiAoZ3JvdXAub3B0aW9ucy5iYXJDaGFydC5hbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICBvZmZzZXQgKz0gMC41ICogZ3JvdXAub3B0aW9ucy5iYXJDaGFydC53aWR0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyB3aWR0aDogd2lkdGgsIG9mZnNldDogb2Zmc2V0IH07XG4gIH07XG5cbiAgQmFyZ3JhcGguZ2V0U3RhY2tlZFlSYW5nZSA9IGZ1bmN0aW9uIChjb21iaW5lZERhdGEsIGdyb3VwUmFuZ2VzLCBncm91cElkcywgZ3JvdXBMYWJlbCwgb3JpZW50YXRpb24pIHtcbiAgICBpZiAoY29tYmluZWREYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIHNvcnQgYnkgdGltZSBhbmQgYnkgZ3JvdXBcbiAgICAgIGNvbWJpbmVkRGF0YS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIGlmIChhLnNjcmVlbl94ID09PSBiLnNjcmVlbl94KSB7XG4gICAgICAgICAgcmV0dXJuIGEuZ3JvdXBJZCA8IGIuZ3JvdXBJZCA/IC0xIDogMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYS5zY3JlZW5feCAtIGIuc2NyZWVuX3g7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIGludGVyc2VjdGlvbnMgPSB7fTtcblxuICAgICAgQmFyZ3JhcGguX2dldERhdGFJbnRlcnNlY3Rpb25zKGludGVyc2VjdGlvbnMsIGNvbWJpbmVkRGF0YSk7XG4gICAgICBncm91cFJhbmdlc1tncm91cExhYmVsXSA9IEJhcmdyYXBoLl9nZXRTdGFja2VkWVJhbmdlKGludGVyc2VjdGlvbnMsIGNvbWJpbmVkRGF0YSk7XG4gICAgICBncm91cFJhbmdlc1tncm91cExhYmVsXS55QXhpc09yaWVudGF0aW9uID0gb3JpZW50YXRpb247XG4gICAgICBncm91cElkcy5wdXNoKGdyb3VwTGFiZWwpO1xuICAgIH1cbiAgfTtcblxuICBCYXJncmFwaC5fZ2V0U3RhY2tlZFlSYW5nZSA9IGZ1bmN0aW9uIChpbnRlcnNlY3Rpb25zLCBjb21iaW5lZERhdGEpIHtcbiAgICB2YXIga2V5O1xuICAgIHZhciB5TWluID0gY29tYmluZWREYXRhWzBdLnNjcmVlbl95O1xuICAgIHZhciB5TWF4ID0gY29tYmluZWREYXRhWzBdLnNjcmVlbl95O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tYmluZWREYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBjb21iaW5lZERhdGFbaV0uc2NyZWVuX3g7XG4gICAgICBpZiAoaW50ZXJzZWN0aW9uc1trZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgeU1pbiA9IHlNaW4gPiBjb21iaW5lZERhdGFbaV0uc2NyZWVuX3kgPyBjb21iaW5lZERhdGFbaV0uc2NyZWVuX3kgOiB5TWluO1xuICAgICAgICB5TWF4ID0geU1heCA8IGNvbWJpbmVkRGF0YVtpXS5zY3JlZW5feSA/IGNvbWJpbmVkRGF0YVtpXS5zY3JlZW5feSA6IHlNYXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY29tYmluZWREYXRhW2ldLnNjcmVlbl95IDwgMCkge1xuICAgICAgICAgIGludGVyc2VjdGlvbnNba2V5XS5hY2N1bXVsYXRlZE5lZ2F0aXZlICs9IGNvbWJpbmVkRGF0YVtpXS5zY3JlZW5feTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnRlcnNlY3Rpb25zW2tleV0uYWNjdW11bGF0ZWRQb3NpdGl2ZSArPSBjb21iaW5lZERhdGFbaV0uc2NyZWVuX3k7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgeHBvcyBpbiBpbnRlcnNlY3Rpb25zKSB7XG4gICAgICBpZiAoaW50ZXJzZWN0aW9ucy5oYXNPd25Qcm9wZXJ0eSh4cG9zKSkge1xuICAgICAgICB5TWluID0geU1pbiA+IGludGVyc2VjdGlvbnNbeHBvc10uYWNjdW11bGF0ZWROZWdhdGl2ZSA/IGludGVyc2VjdGlvbnNbeHBvc10uYWNjdW11bGF0ZWROZWdhdGl2ZSA6IHlNaW47XG4gICAgICAgIHlNaW4gPSB5TWluID4gaW50ZXJzZWN0aW9uc1t4cG9zXS5hY2N1bXVsYXRlZFBvc2l0aXZlID8gaW50ZXJzZWN0aW9uc1t4cG9zXS5hY2N1bXVsYXRlZFBvc2l0aXZlIDogeU1pbjtcbiAgICAgICAgeU1heCA9IHlNYXggPCBpbnRlcnNlY3Rpb25zW3hwb3NdLmFjY3VtdWxhdGVkTmVnYXRpdmUgPyBpbnRlcnNlY3Rpb25zW3hwb3NdLmFjY3VtdWxhdGVkTmVnYXRpdmUgOiB5TWF4O1xuICAgICAgICB5TWF4ID0geU1heCA8IGludGVyc2VjdGlvbnNbeHBvc10uYWNjdW11bGF0ZWRQb3NpdGl2ZSA/IGludGVyc2VjdGlvbnNbeHBvc10uYWNjdW11bGF0ZWRQb3NpdGl2ZSA6IHlNYXg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgbWluOiB5TWluLCBtYXg6IHlNYXggfTtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IEJhcmdyYXBoO1xuXG4vKioqLyB9LFxuLyogNTYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuICB2YXIgRE9NdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cbiAgZnVuY3Rpb24gUG9pbnRzKGdyb3VwSWQsIG9wdGlvbnMpIHt9XG5cbiAgLyoqXG4gICAqIGRyYXcgdGhlIGRhdGEgcG9pbnRzXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGRhdGFzZXRcbiAgICogQHBhcmFtIHtPYmplY3R9IEpTT05jb250YWluZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IHN2ZyAgICAgICAgICAgIHwgU1ZHIERPTSBlbGVtZW50XG4gICAqIEBwYXJhbSB7R3JhcGhHcm91cH0gZ3JvdXBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvZmZzZXRdXG4gICAqL1xuICBQb2ludHMuZHJhdyA9IGZ1bmN0aW9uIChkYXRhc2V0LCBncm91cCwgZnJhbWV3b3JrLCBvZmZzZXQpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgICB2YXIgY2FsbGJhY2sgPSBnZXRDYWxsYmFjayhmcmFtZXdvcmssIGdyb3VwKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YXNldC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAvLyBkcmF3IHRoZSBwb2ludCB0aGUgc2ltcGxlIHdheS5cbiAgICAgICAgRE9NdXRpbC5kcmF3UG9pbnQoZGF0YXNldFtpXS5zY3JlZW5feCArIG9mZnNldCwgZGF0YXNldFtpXS5zY3JlZW5feSwgZ2V0R3JvdXBUZW1wbGF0ZShncm91cCksIGZyYW1ld29yay5zdmdFbGVtZW50cywgZnJhbWV3b3JrLnN2ZywgZGF0YXNldFtpXS5sYWJlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY2FsbGJhY2tSZXN1bHQgPSBjYWxsYmFjayhkYXRhc2V0W2ldLCBncm91cCk7IC8vIHJlc3VsdCBtaWdodCBiZSB0cnVlLCBmYWxzZSBvciBhbiBvYmplY3RcbiAgICAgICAgaWYgKGNhbGxiYWNrUmVzdWx0ID09PSB0cnVlIHx8ICh0eXBlb2YgY2FsbGJhY2tSZXN1bHQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGNhbGxiYWNrUmVzdWx0KSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgRE9NdXRpbC5kcmF3UG9pbnQoZGF0YXNldFtpXS5zY3JlZW5feCArIG9mZnNldCwgZGF0YXNldFtpXS5zY3JlZW5feSwgZ2V0R3JvdXBUZW1wbGF0ZShncm91cCwgY2FsbGJhY2tSZXN1bHQpLCBmcmFtZXdvcmsuc3ZnRWxlbWVudHMsIGZyYW1ld29yay5zdmcsIGRhdGFzZXRbaV0ubGFiZWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFBvaW50cy5kcmF3SWNvbiA9IGZ1bmN0aW9uIChncm91cCwgeCwgeSwgaWNvbldpZHRoLCBpY29uSGVpZ2h0LCBmcmFtZXdvcmspIHtcbiAgICB2YXIgZmlsbEhlaWdodCA9IGljb25IZWlnaHQgKiAwLjU7XG4gICAgdmFyIHBhdGgsIGZpbGxQYXRoO1xuXG4gICAgdmFyIG91dGxpbmUgPSBET011dGlsLmdldFNWR0VsZW1lbnQoXCJyZWN0XCIsIGZyYW1ld29yay5zdmdFbGVtZW50cywgZnJhbWV3b3JrLnN2Zyk7XG4gICAgb3V0bGluZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInhcIiwgeCk7XG4gICAgb3V0bGluZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgeSAtIGZpbGxIZWlnaHQpO1xuICAgIG91dGxpbmUuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ3aWR0aFwiLCBpY29uV2lkdGgpO1xuICAgIG91dGxpbmUuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJoZWlnaHRcIiwgMiAqIGZpbGxIZWlnaHQpO1xuICAgIG91dGxpbmUuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJjbGFzc1wiLCBcInZpcy1vdXRsaW5lXCIpO1xuXG4gICAgLy9Eb24ndCBjYWxsIGNhbGxiYWNrIG9uIGljb25cbiAgICBET011dGlsLmRyYXdQb2ludCh4ICsgMC41ICogaWNvbldpZHRoLCB5LCBnZXRHcm91cFRlbXBsYXRlKGdyb3VwKSwgZnJhbWV3b3JrLnN2Z0VsZW1lbnRzLCBmcmFtZXdvcmsuc3ZnKTtcbiAgfTtcblxuICBmdW5jdGlvbiBnZXRHcm91cFRlbXBsYXRlKGdyb3VwLCBjYWxsYmFja1Jlc3VsdCkge1xuICAgIGNhbGxiYWNrUmVzdWx0ID0gdHlwZW9mIGNhbGxiYWNrUmVzdWx0ID09PSAndW5kZWZpbmVkJyA/IHt9IDogY2FsbGJhY2tSZXN1bHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0eWxlOiBjYWxsYmFja1Jlc3VsdC5zdHlsZSB8fCBncm91cC5vcHRpb25zLmRyYXdQb2ludHMuc3R5bGUsXG4gICAgICBzdHlsZXM6IGNhbGxiYWNrUmVzdWx0LnN0eWxlcyB8fCBncm91cC5vcHRpb25zLmRyYXdQb2ludHMuc3R5bGVzLFxuICAgICAgc2l6ZTogY2FsbGJhY2tSZXN1bHQuc2l6ZSB8fCBncm91cC5vcHRpb25zLmRyYXdQb2ludHMuc2l6ZSxcbiAgICAgIGNsYXNzTmFtZTogY2FsbGJhY2tSZXN1bHQuY2xhc3NOYW1lIHx8IGdyb3VwLmNsYXNzTmFtZVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDYWxsYmFjayhmcmFtZXdvcmssIGdyb3VwKSB7XG4gICAgdmFyIGNhbGxiYWNrID0gdW5kZWZpbmVkO1xuICAgIC8vIGNoZWNrIGZvciB0aGUgZ3JhcGgyZCBvblJlbmRlclxuICAgIGlmIChmcmFtZXdvcmsub3B0aW9ucyAmJiBmcmFtZXdvcmsub3B0aW9ucy5kcmF3UG9pbnRzICYmIGZyYW1ld29yay5vcHRpb25zLmRyYXdQb2ludHMub25SZW5kZXIgJiYgdHlwZW9mIGZyYW1ld29yay5vcHRpb25zLmRyYXdQb2ludHMub25SZW5kZXIgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBmcmFtZXdvcmsub3B0aW9ucy5kcmF3UG9pbnRzLm9uUmVuZGVyO1xuICAgIH1cblxuICAgIC8vIG92ZXJyaWRlIGl0IHdpdGggdGhlIGdyb3VwIG9uUmVuZGVyIGlmIGRlZmluZWRcbiAgICBpZiAoZ3JvdXAuZ3JvdXAub3B0aW9ucyAmJiBncm91cC5ncm91cC5vcHRpb25zLmRyYXdQb2ludHMgJiYgZ3JvdXAuZ3JvdXAub3B0aW9ucy5kcmF3UG9pbnRzLm9uUmVuZGVyICYmIHR5cGVvZiBncm91cC5ncm91cC5vcHRpb25zLmRyYXdQb2ludHMub25SZW5kZXIgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBncm91cC5ncm91cC5vcHRpb25zLmRyYXdQb2ludHMub25SZW5kZXI7XG4gICAgfVxuICAgIHJldHVybiBjYWxsYmFjaztcbiAgfVxuXG4gIG1vZHVsZS5leHBvcnRzID0gUG9pbnRzO1xuXG4vKioqLyB9LFxuLyogNTcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBET011dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxuICBmdW5jdGlvbiBMaW5lKGdyb3VwSWQsIG9wdGlvbnMpIHt9XG5cbiAgTGluZS5jYWxjUGF0aCA9IGZ1bmN0aW9uIChkYXRhc2V0LCBncm91cCkge1xuICAgICAgaWYgKGRhdGFzZXQgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChkYXRhc2V0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgdmFyIGQgPSBbXTtcblxuICAgICAgICAgICAgICAvLyBjb25zdHJ1Y3QgcGF0aCBmcm9tIGRhdGFzZXRcbiAgICAgICAgICAgICAgaWYgKGdyb3VwLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5lbmFibGVkID09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIGQgPSBMaW5lLl9jYXRtdWxsUm9tKGRhdGFzZXQsIGdyb3VwKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGQgPSBMaW5lLl9saW5lYXIoZGF0YXNldCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgfVxuICAgICAgfVxuICB9O1xuXG4gIExpbmUuZHJhd0ljb24gPSBmdW5jdGlvbiAoZ3JvdXAsIHgsIHksIGljb25XaWR0aCwgaWNvbkhlaWdodCwgZnJhbWV3b3JrKSB7XG4gICAgICB2YXIgZmlsbEhlaWdodCA9IGljb25IZWlnaHQgKiAwLjU7XG4gICAgICB2YXIgcGF0aCwgZmlsbFBhdGg7XG5cbiAgICAgIHZhciBvdXRsaW5lID0gRE9NdXRpbC5nZXRTVkdFbGVtZW50KFwicmVjdFwiLCBmcmFtZXdvcmsuc3ZnRWxlbWVudHMsIGZyYW1ld29yay5zdmcpO1xuICAgICAgb3V0bGluZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInhcIiwgeCk7XG4gICAgICBvdXRsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCB5IC0gZmlsbEhlaWdodCk7XG4gICAgICBvdXRsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwid2lkdGhcIiwgaWNvbldpZHRoKTtcbiAgICAgIG91dGxpbmUuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJoZWlnaHRcIiwgMiAqIGZpbGxIZWlnaHQpO1xuICAgICAgb3V0bGluZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImNsYXNzXCIsIFwidmlzLW91dGxpbmVcIik7XG5cbiAgICAgIHBhdGggPSBET011dGlsLmdldFNWR0VsZW1lbnQoXCJwYXRoXCIsIGZyYW1ld29yay5zdmdFbGVtZW50cywgZnJhbWV3b3JrLnN2Zyk7XG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiY2xhc3NcIiwgZ3JvdXAuY2xhc3NOYW1lKTtcbiAgICAgIGlmIChncm91cC5zdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInN0eWxlXCIsIGdyb3VwLnN0eWxlKTtcbiAgICAgIH1cblxuICAgICAgcGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImRcIiwgXCJNXCIgKyB4ICsgXCIsXCIgKyB5ICsgXCIgTFwiICsgKHggKyBpY29uV2lkdGgpICsgXCIsXCIgKyB5ICsgXCJcIik7XG4gICAgICBpZiAoZ3JvdXAub3B0aW9ucy5zaGFkZWQuZW5hYmxlZCA9PSB0cnVlKSB7XG4gICAgICAgICAgZmlsbFBhdGggPSBET011dGlsLmdldFNWR0VsZW1lbnQoXCJwYXRoXCIsIGZyYW1ld29yay5zdmdFbGVtZW50cywgZnJhbWV3b3JrLnN2Zyk7XG4gICAgICAgICAgaWYgKGdyb3VwLm9wdGlvbnMuc2hhZGVkLm9yaWVudGF0aW9uID09ICd0b3AnKSB7XG4gICAgICAgICAgICAgIGZpbGxQYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZFwiLCBcIk1cIiArIHggKyBcIiwgXCIgKyAoeSAtIGZpbGxIZWlnaHQpICsgXCJMXCIgKyB4ICsgXCIsXCIgKyB5ICsgXCIgTFwiICsgKHggKyBpY29uV2lkdGgpICsgXCIsXCIgKyB5ICsgXCIgTFwiICsgKHggKyBpY29uV2lkdGgpICsgXCIsXCIgKyAoeSAtIGZpbGxIZWlnaHQpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmaWxsUGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImRcIiwgXCJNXCIgKyB4ICsgXCIsXCIgKyB5ICsgXCIgXCIgKyBcIkxcIiArIHggKyBcIixcIiArICh5ICsgZmlsbEhlaWdodCkgKyBcIiBcIiArIFwiTFwiICsgKHggKyBpY29uV2lkdGgpICsgXCIsXCIgKyAoeSArIGZpbGxIZWlnaHQpICsgXCJMXCIgKyAoeCArIGljb25XaWR0aCkgKyBcIixcIiArIHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmaWxsUGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImNsYXNzXCIsIGdyb3VwLmNsYXNzTmFtZSArIFwiIHZpcy1pY29uLWZpbGxcIik7XG4gICAgICAgICAgaWYgKGdyb3VwLm9wdGlvbnMuc2hhZGVkLnN0eWxlICE9PSB1bmRlZmluZWQgJiYgZ3JvdXAub3B0aW9ucy5zaGFkZWQuc3R5bGUgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgZmlsbFBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgXCJzdHlsZVwiLCBncm91cC5vcHRpb25zLnNoYWRlZC5zdHlsZSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZ3JvdXAub3B0aW9ucy5kcmF3UG9pbnRzLmVuYWJsZWQgPT0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBncm91cFRlbXBsYXRlID0ge1xuICAgICAgICAgICAgICBzdHlsZTogZ3JvdXAub3B0aW9ucy5kcmF3UG9pbnRzLnN0eWxlLFxuICAgICAgICAgICAgICBzdHlsZXM6IGdyb3VwLm9wdGlvbnMuZHJhd1BvaW50cy5zdHlsZXMsXG4gICAgICAgICAgICAgIHNpemU6IGdyb3VwLm9wdGlvbnMuZHJhd1BvaW50cy5zaXplLFxuICAgICAgICAgICAgICBjbGFzc05hbWU6IGdyb3VwLmNsYXNzTmFtZVxuICAgICAgICAgIH07XG4gICAgICAgICAgRE9NdXRpbC5kcmF3UG9pbnQoeCArIDAuNSAqIGljb25XaWR0aCwgeSwgZ3JvdXBUZW1wbGF0ZSwgZnJhbWV3b3JrLnN2Z0VsZW1lbnRzLCBmcmFtZXdvcmsuc3ZnKTtcbiAgICAgIH1cbiAgfTtcblxuICBMaW5lLmRyYXdTaGFkaW5nID0gZnVuY3Rpb24gKHBhdGhBcnJheSwgZ3JvdXAsIHN1YlBhdGhBcnJheSwgZnJhbWV3b3JrKSB7XG4gICAgICAvLyBhcHBlbmQgc2hhZGluZyB0byB0aGUgcGF0aFxuICAgICAgaWYgKGdyb3VwLm9wdGlvbnMuc2hhZGVkLmVuYWJsZWQgPT0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBzdmdIZWlnaHQgPSBOdW1iZXIoZnJhbWV3b3JrLnN2Zy5zdHlsZS5oZWlnaHQucmVwbGFjZSgncHgnLCAnJykpO1xuICAgICAgICAgIHZhciBmaWxsUGF0aCA9IERPTXV0aWwuZ2V0U1ZHRWxlbWVudCgncGF0aCcsIGZyYW1ld29yay5zdmdFbGVtZW50cywgZnJhbWV3b3JrLnN2Zyk7XG4gICAgICAgICAgdmFyIHR5cGUgPSBcIkxcIjtcbiAgICAgICAgICBpZiAoZ3JvdXAub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmVuYWJsZWQgPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICB0eXBlID0gXCJDXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBkRmlsbDtcbiAgICAgICAgICB2YXIgemVybyA9IDA7XG4gICAgICAgICAgaWYgKGdyb3VwLm9wdGlvbnMuc2hhZGVkLm9yaWVudGF0aW9uID09ICd0b3AnKSB7XG4gICAgICAgICAgICAgIHplcm8gPSAwO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZ3JvdXAub3B0aW9ucy5zaGFkZWQub3JpZW50YXRpb24gPT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgICAgemVybyA9IHN2Z0hlaWdodDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB6ZXJvID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgZ3JvdXAuemVyb1Bvc2l0aW9uKSwgc3ZnSGVpZ2h0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGdyb3VwLm9wdGlvbnMuc2hhZGVkLm9yaWVudGF0aW9uID09ICdncm91cCcgJiYgc3ViUGF0aEFycmF5ICE9IG51bGwgJiYgc3ViUGF0aEFycmF5ICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBkRmlsbCA9ICdNJyArIHBhdGhBcnJheVswXVswXSArIFwiLFwiICsgcGF0aEFycmF5WzBdWzFdICsgXCIgXCIgKyB0aGlzLnNlcmlhbGl6ZVBhdGgocGF0aEFycmF5LCB0eXBlLCBmYWxzZSkgKyAnIEwnICsgc3ViUGF0aEFycmF5W3N1YlBhdGhBcnJheS5sZW5ndGggLSAxXVswXSArIFwiLFwiICsgc3ViUGF0aEFycmF5W3N1YlBhdGhBcnJheS5sZW5ndGggLSAxXVsxXSArIFwiIFwiICsgdGhpcy5zZXJpYWxpemVQYXRoKHN1YlBhdGhBcnJheSwgdHlwZSwgdHJ1ZSkgKyBzdWJQYXRoQXJyYXlbMF1bMF0gKyBcIixcIiArIHN1YlBhdGhBcnJheVswXVsxXSArIFwiIFpcIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkRmlsbCA9ICdNJyArIHBhdGhBcnJheVswXVswXSArIFwiLFwiICsgcGF0aEFycmF5WzBdWzFdICsgXCIgXCIgKyB0aGlzLnNlcmlhbGl6ZVBhdGgocGF0aEFycmF5LCB0eXBlLCBmYWxzZSkgKyAnIFYnICsgemVybyArICcgSCcgKyBwYXRoQXJyYXlbMF1bMF0gKyBcIiBaXCI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmlsbFBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgJ2NsYXNzJywgZ3JvdXAuY2xhc3NOYW1lICsgJyB2aXMtZmlsbCcpO1xuICAgICAgICAgIGlmIChncm91cC5vcHRpb25zLnNoYWRlZC5zdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGZpbGxQYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsICdzdHlsZScsIGdyb3VwLm9wdGlvbnMuc2hhZGVkLnN0eWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmlsbFBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgJ2QnLCBkRmlsbCk7XG4gICAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIGRyYXcgYSBsaW5lIGdyYXBoXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhc2V0XG4gICAqIEBwYXJhbSBncm91cFxuICAgKi9cbiAgTGluZS5kcmF3ID0gZnVuY3Rpb24gKHBhdGhBcnJheSwgZ3JvdXAsIGZyYW1ld29yaykge1xuICAgICAgaWYgKHBhdGhBcnJheSAhPSBudWxsICYmIHBhdGhBcnJheSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgcGF0aCA9IERPTXV0aWwuZ2V0U1ZHRWxlbWVudCgncGF0aCcsIGZyYW1ld29yay5zdmdFbGVtZW50cywgZnJhbWV3b3JrLnN2Zyk7XG4gICAgICAgICAgcGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImNsYXNzXCIsIGdyb3VwLmNsYXNzTmFtZSk7XG4gICAgICAgICAgaWYgKGdyb3VwLnN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInN0eWxlXCIsIGdyb3VwLnN0eWxlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdHlwZSA9IFwiTFwiO1xuICAgICAgICAgIGlmIChncm91cC5vcHRpb25zLmludGVycG9sYXRpb24uZW5hYmxlZCA9PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHR5cGUgPSBcIkNcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gY29weSBwcm9wZXJ0aWVzIHRvIHBhdGggZm9yIGRyYXdpbmcuXG4gICAgICAgICAgcGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZCcsICdNJyArIHBhdGhBcnJheVswXVswXSArIFwiLFwiICsgcGF0aEFycmF5WzBdWzFdICsgXCIgXCIgKyB0aGlzLnNlcmlhbGl6ZVBhdGgocGF0aEFycmF5LCB0eXBlLCBmYWxzZSkpO1xuICAgICAgfVxuICB9O1xuXG4gIExpbmUuc2VyaWFsaXplUGF0aCA9IGZ1bmN0aW9uIChwYXRoQXJyYXksIHR5cGUsIGludmVyc2UpIHtcbiAgICAgIGlmIChwYXRoQXJyYXkubGVuZ3RoIDwgMikge1xuICAgICAgICAgIC8vVG9vIGxpdHRsZSBkYXRhIHRvIGNyZWF0ZSBhIHBhdGguXG4gICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgICB2YXIgZCA9IHR5cGU7XG4gICAgICBpZiAoaW52ZXJzZSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSBwYXRoQXJyYXkubGVuZ3RoIC0gMjsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgICBkICs9IHBhdGhBcnJheVtpXVswXSArIFwiLFwiICsgcGF0aEFycmF5W2ldWzFdICsgXCIgXCI7XG4gICAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBhdGhBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBkICs9IHBhdGhBcnJheVtpXVswXSArIFwiLFwiICsgcGF0aEFycmF5W2ldWzFdICsgXCIgXCI7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgdXNlcyBhbiB1bmlmb3JtIHBhcmFtZXRyaXphdGlvbiBvZiB0aGUgaW50ZXJwb2xhdGlvbiBhbGdvcml0aG06XG4gICAqICdPbiB0aGUgUGFyYW1ldGVyaXphdGlvbiBvZiBDYXRtdWxsLVJvbSBDdXJ2ZXMnIGJ5IENlbSBZdWtzZWwgZXQgYWwuXG4gICAqIEBwYXJhbSBkYXRhXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBMaW5lLl9jYXRtdWxsUm9tVW5pZm9ybSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAvLyBjYXRtdWxsIHJvbVxuICAgICAgdmFyIHAwLCBwMSwgcDIsIHAzLCBicDEsIGJwMjtcbiAgICAgIHZhciBkID0gW107XG4gICAgICBkLnB1c2goW01hdGgucm91bmQoZGF0YVswXS5zY3JlZW5feCksIE1hdGgucm91bmQoZGF0YVswXS5zY3JlZW5feSldKTtcbiAgICAgIHZhciBub3JtYWxpemF0aW9uID0gMSAvIDY7XG4gICAgICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aCAtIDE7IGkrKykge1xuXG4gICAgICAgICAgcDAgPSBpID09IDAgPyBkYXRhWzBdIDogZGF0YVtpIC0gMV07XG4gICAgICAgICAgcDEgPSBkYXRhW2ldO1xuICAgICAgICAgIHAyID0gZGF0YVtpICsgMV07XG4gICAgICAgICAgcDMgPSBpICsgMiA8IGxlbmd0aCA/IGRhdGFbaSArIDJdIDogcDI7XG5cbiAgICAgICAgICAvLyBDYXRtdWxsLVJvbSB0byBDdWJpYyBCZXppZXIgY29udmVyc2lvbiBtYXRyaXhcbiAgICAgICAgICAvLyAgICAwICAgICAgIDEgICAgICAgMCAgICAgICAwXG4gICAgICAgICAgLy8gIC0xLzYgICAgICAxICAgICAgMS82ICAgICAgMFxuICAgICAgICAgIC8vICAgIDAgICAgICAxLzYgICAgICAxICAgICAtMS82XG4gICAgICAgICAgLy8gICAgMCAgICAgICAwICAgICAgIDEgICAgICAgMFxuXG4gICAgICAgICAgLy8gICAgYnAwID0geyB4OiBwMS54LCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBwMS55IH07XG4gICAgICAgICAgYnAxID0ge1xuICAgICAgICAgICAgICBzY3JlZW5feDogKC1wMC5zY3JlZW5feCArIDYgKiBwMS5zY3JlZW5feCArIHAyLnNjcmVlbl94KSAqIG5vcm1hbGl6YXRpb24sXG4gICAgICAgICAgICAgIHNjcmVlbl95OiAoLXAwLnNjcmVlbl95ICsgNiAqIHAxLnNjcmVlbl95ICsgcDIuc2NyZWVuX3kpICogbm9ybWFsaXphdGlvblxuICAgICAgICAgIH07XG4gICAgICAgICAgYnAyID0ge1xuICAgICAgICAgICAgICBzY3JlZW5feDogKHAxLnNjcmVlbl94ICsgNiAqIHAyLnNjcmVlbl94IC0gcDMuc2NyZWVuX3gpICogbm9ybWFsaXphdGlvbixcbiAgICAgICAgICAgICAgc2NyZWVuX3k6IChwMS5zY3JlZW5feSArIDYgKiBwMi5zY3JlZW5feSAtIHAzLnNjcmVlbl95KSAqIG5vcm1hbGl6YXRpb25cbiAgICAgICAgICB9O1xuICAgICAgICAgIC8vICAgIGJwMCA9IHsgeDogcDIueCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogcDIueSB9O1xuXG4gICAgICAgICAgZC5wdXNoKFticDEuc2NyZWVuX3gsIGJwMS5zY3JlZW5feV0pO1xuICAgICAgICAgIGQucHVzaChbYnAyLnNjcmVlbl94LCBicDIuc2NyZWVuX3ldKTtcbiAgICAgICAgICBkLnB1c2goW3AyLnNjcmVlbl94LCBwMi5zY3JlZW5feV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZDtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyB1c2VzIGVpdGhlciB0aGUgY2hvcmRhbCBvciBjZW50cmlwZXRhbCBwYXJhbWV0ZXJpemF0aW9uIG9mIHRoZSBjYXRtdWxsLXJvbSBhbGdvcml0aG0uXG4gICAqIEJ5IGRlZmF1bHQsIHRoZSBjZW50cmlwZXRhbCBwYXJhbWV0ZXJpemF0aW9uIGlzIHVzZWQgYmVjYXVzZSB0aGlzIGdpdmVzIHRoZSBuaWNlc3QgcmVzdWx0cy5cbiAgICogVGhlc2UgcGFyYW1ldGVyaXphdGlvbnMgYXJlIHJlbGF0aXZlbHkgaGVhdnkgYmVjYXVzZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiA0IHBvaW50cyBoYXZlIHRvIGJlIGNhbGN1bGF0ZWQuXG4gICAqXG4gICAqIE9uZSBvcHRpbWl6YXRpb24gY2FuIGJlIHVzZWQgdG8gcmV1c2UgZGlzdGFuY2VzIHNpbmNlIHRoaXMgaXMgYSBzbGlkaW5nIHdpbmRvdyBhcHByb2FjaC5cbiAgICogQHBhcmFtIGRhdGFcbiAgICogQHBhcmFtIGdyb3VwXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBMaW5lLl9jYXRtdWxsUm9tID0gZnVuY3Rpb24gKGRhdGEsIGdyb3VwKSB7XG4gICAgICB2YXIgYWxwaGEgPSBncm91cC5vcHRpb25zLmludGVycG9sYXRpb24uYWxwaGE7XG4gICAgICBpZiAoYWxwaGEgPT0gMCB8fCBhbHBoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2NhdG11bGxSb21Vbmlmb3JtKGRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcDAsIHAxLCBwMiwgcDMsIGJwMSwgYnAyLCBkMSwgZDIsIGQzLCBBLCBCLCBOLCBNO1xuICAgICAgICAgIHZhciBkM3Bvd0EsIGQycG93QSwgZDNwb3cyQSwgZDJwb3cyQSwgZDFwb3cyQSwgZDFwb3dBO1xuICAgICAgICAgIHZhciBkID0gW107XG4gICAgICAgICAgZC5wdXNoKFtNYXRoLnJvdW5kKGRhdGFbMF0uc2NyZWVuX3gpLCBNYXRoLnJvdW5kKGRhdGFbMF0uc2NyZWVuX3kpXSk7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoIC0gMTsgaSsrKSB7XG5cbiAgICAgICAgICAgICAgcDAgPSBpID09IDAgPyBkYXRhWzBdIDogZGF0YVtpIC0gMV07XG4gICAgICAgICAgICAgIHAxID0gZGF0YVtpXTtcbiAgICAgICAgICAgICAgcDIgPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgICAgICAgcDMgPSBpICsgMiA8IGxlbmd0aCA/IGRhdGFbaSArIDJdIDogcDI7XG5cbiAgICAgICAgICAgICAgZDEgPSBNYXRoLnNxcnQoTWF0aC5wb3cocDAuc2NyZWVuX3ggLSBwMS5zY3JlZW5feCwgMikgKyBNYXRoLnBvdyhwMC5zY3JlZW5feSAtIHAxLnNjcmVlbl95LCAyKSk7XG4gICAgICAgICAgICAgIGQyID0gTWF0aC5zcXJ0KE1hdGgucG93KHAxLnNjcmVlbl94IC0gcDIuc2NyZWVuX3gsIDIpICsgTWF0aC5wb3cocDEuc2NyZWVuX3kgLSBwMi5zY3JlZW5feSwgMikpO1xuICAgICAgICAgICAgICBkMyA9IE1hdGguc3FydChNYXRoLnBvdyhwMi5zY3JlZW5feCAtIHAzLnNjcmVlbl94LCAyKSArIE1hdGgucG93KHAyLnNjcmVlbl95IC0gcDMuc2NyZWVuX3ksIDIpKTtcblxuICAgICAgICAgICAgICAvLyBDYXRtdWxsLVJvbSB0byBDdWJpYyBCZXppZXIgY29udmVyc2lvbiBtYXRyaXhcblxuICAgICAgICAgICAgICAvLyBBID0gMmQxXjJhICsgM2QxXmEgKiBkMl5hICsgZDNeMmFcbiAgICAgICAgICAgICAgLy8gQiA9IDJkM14yYSArIDNkM15hICogZDJeYSArIGQyXjJhXG5cbiAgICAgICAgICAgICAgLy8gWyAgIDAgICAgICAgICAgICAgMSAgICAgICAgICAgIDAgICAgICAgICAgMCAgICAgICAgICBdXG4gICAgICAgICAgICAgIC8vIFsgICAtZDJeMmEgL04gICAgIEEvTiAgICAgICAgICBkMV4yYSAvTiAgIDAgICAgICAgICAgXVxuICAgICAgICAgICAgICAvLyBbICAgMCAgICAgICAgICAgICBkM14yYSAvTSAgICAgQi9NICAgICAgICAtZDJeMmEgL00gIF1cbiAgICAgICAgICAgICAgLy8gWyAgIDAgICAgICAgICAgICAgMCAgICAgICAgICAgIDEgICAgICAgICAgMCAgICAgICAgICBdXG5cbiAgICAgICAgICAgICAgZDNwb3dBID0gTWF0aC5wb3coZDMsIGFscGhhKTtcbiAgICAgICAgICAgICAgZDNwb3cyQSA9IE1hdGgucG93KGQzLCAyICogYWxwaGEpO1xuICAgICAgICAgICAgICBkMnBvd0EgPSBNYXRoLnBvdyhkMiwgYWxwaGEpO1xuICAgICAgICAgICAgICBkMnBvdzJBID0gTWF0aC5wb3coZDIsIDIgKiBhbHBoYSk7XG4gICAgICAgICAgICAgIGQxcG93QSA9IE1hdGgucG93KGQxLCBhbHBoYSk7XG4gICAgICAgICAgICAgIGQxcG93MkEgPSBNYXRoLnBvdyhkMSwgMiAqIGFscGhhKTtcblxuICAgICAgICAgICAgICBBID0gMiAqIGQxcG93MkEgKyAzICogZDFwb3dBICogZDJwb3dBICsgZDJwb3cyQTtcbiAgICAgICAgICAgICAgQiA9IDIgKiBkM3BvdzJBICsgMyAqIGQzcG93QSAqIGQycG93QSArIGQycG93MkE7XG4gICAgICAgICAgICAgIE4gPSAzICogZDFwb3dBICogKGQxcG93QSArIGQycG93QSk7XG4gICAgICAgICAgICAgIGlmIChOID4gMCkge1xuICAgICAgICAgICAgICAgICAgTiA9IDEgLyBOO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIE0gPSAzICogZDNwb3dBICogKGQzcG93QSArIGQycG93QSk7XG4gICAgICAgICAgICAgIGlmIChNID4gMCkge1xuICAgICAgICAgICAgICAgICAgTSA9IDEgLyBNO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnAxID0ge1xuICAgICAgICAgICAgICAgICAgc2NyZWVuX3g6ICgtZDJwb3cyQSAqIHAwLnNjcmVlbl94ICsgQSAqIHAxLnNjcmVlbl94ICsgZDFwb3cyQSAqIHAyLnNjcmVlbl94KSAqIE4sXG4gICAgICAgICAgICAgICAgICBzY3JlZW5feTogKC1kMnBvdzJBICogcDAuc2NyZWVuX3kgKyBBICogcDEuc2NyZWVuX3kgKyBkMXBvdzJBICogcDIuc2NyZWVuX3kpICogTlxuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGJwMiA9IHtcbiAgICAgICAgICAgICAgICAgIHNjcmVlbl94OiAoZDNwb3cyQSAqIHAxLnNjcmVlbl94ICsgQiAqIHAyLnNjcmVlbl94IC0gZDJwb3cyQSAqIHAzLnNjcmVlbl94KSAqIE0sXG4gICAgICAgICAgICAgICAgICBzY3JlZW5feTogKGQzcG93MkEgKiBwMS5zY3JlZW5feSArIEIgKiBwMi5zY3JlZW5feSAtIGQycG93MkEgKiBwMy5zY3JlZW5feSkgKiBNXG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgaWYgKGJwMS5zY3JlZW5feCA9PSAwICYmIGJwMS5zY3JlZW5feSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICBicDEgPSBwMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoYnAyLnNjcmVlbl94ID09IDAgJiYgYnAyLnNjcmVlbl95ID09IDApIHtcbiAgICAgICAgICAgICAgICAgIGJwMiA9IHAyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGQucHVzaChbYnAxLnNjcmVlbl94LCBicDEuc2NyZWVuX3ldKTtcbiAgICAgICAgICAgICAgZC5wdXNoKFticDIuc2NyZWVuX3gsIGJwMi5zY3JlZW5feV0pO1xuICAgICAgICAgICAgICBkLnB1c2goW3AyLnNjcmVlbl94LCBwMi5zY3JlZW5feV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBkO1xuICAgICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiB0aGlzIGdlbmVyYXRlcyB0aGUgU1ZHIHBhdGggZm9yIGEgbGluZWFyIGRyYXdpbmcgYmV0d2VlbiBkYXRhcG9pbnRzLlxuICAgKiBAcGFyYW0gZGF0YVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTGluZS5fbGluZWFyID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIC8vIGxpbmVhclxuICAgICAgdmFyIGQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGQucHVzaChbZGF0YVtpXS5zY3JlZW5feCwgZGF0YVtpXS5zY3JlZW5feV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGQ7XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBMaW5lO1xuXG4vKioqLyB9LFxuLyogNTggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4gIHZhciBET011dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbiAgdmFyIENvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xuXG4gIC8qKlxuICAgKiBMZWdlbmQgZm9yIEdyYXBoMmRcbiAgICovXG4gIGZ1bmN0aW9uIExlZ2VuZChib2R5LCBvcHRpb25zLCBzaWRlLCBsaW5lZ3JhcGhPcHRpb25zKSB7XG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICBpY29uczogdHJ1ZSxcbiAgICAgIGljb25TaXplOiAyMCxcbiAgICAgIGljb25TcGFjaW5nOiA2LFxuICAgICAgbGVmdDoge1xuICAgICAgICB2aXNpYmxlOiB0cnVlLFxuICAgICAgICBwb3NpdGlvbjogJ3RvcC1sZWZ0JyAvLyB0b3AvYm90dG9tIC0gbGVmdCxjZW50ZXIscmlnaHRcbiAgICAgIH0sXG4gICAgICByaWdodDoge1xuICAgICAgICB2aXNpYmxlOiB0cnVlLFxuICAgICAgICBwb3NpdGlvbjogJ3RvcC1yaWdodCcgLy8gdG9wL2JvdHRvbSAtIGxlZnQsY2VudGVyLHJpZ2h0XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuc2lkZSA9IHNpZGU7XG4gICAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoe30sIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuICAgIHRoaXMubGluZWdyYXBoT3B0aW9ucyA9IGxpbmVncmFwaE9wdGlvbnM7XG5cbiAgICB0aGlzLnN2Z0VsZW1lbnRzID0ge307XG4gICAgdGhpcy5kb20gPSB7fTtcbiAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgIHRoaXMuYW1vdW50T2ZHcm91cHMgPSAwO1xuICAgIHRoaXMuX2NyZWF0ZSgpO1xuICAgIHRoaXMuZnJhbWV3b3JrID0geyBzdmc6IHRoaXMuc3ZnLCBzdmdFbGVtZW50czogdGhpcy5zdmdFbGVtZW50cywgb3B0aW9uczogdGhpcy5vcHRpb25zLCBncm91cHM6IHRoaXMuZ3JvdXBzIH07XG5cbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIH1cblxuICBMZWdlbmQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudCgpO1xuXG4gIExlZ2VuZC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICB0aGlzLmFtb3VudE9mR3JvdXBzID0gMDtcbiAgfTtcblxuICBMZWdlbmQucHJvdG90eXBlLmFkZEdyb3VwID0gZnVuY3Rpb24gKGxhYmVsLCBncmFwaE9wdGlvbnMpIHtcblxuICAgIC8vIEluY2x1ZGUgYSBncm91cCBvbmx5IGlmIHRoZSBncm91cCBvcHRpb24gJ2V4Y2x1ZGVGcm9tTGVnZW5kOiBmYWxzZScgaXMgbm90IHNldC5cbiAgICBpZiAoZ3JhcGhPcHRpb25zLm9wdGlvbnMuZXhjbHVkZUZyb21MZWdlbmQgIT0gdHJ1ZSkge1xuICAgICAgaWYgKCF0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShsYWJlbCkpIHtcbiAgICAgICAgdGhpcy5ncm91cHNbbGFiZWxdID0gZ3JhcGhPcHRpb25zO1xuICAgICAgfVxuICAgICAgdGhpcy5hbW91bnRPZkdyb3VwcyArPSAxO1xuICAgIH1cbiAgfTtcblxuICBMZWdlbmQucHJvdG90eXBlLnVwZGF0ZUdyb3VwID0gZnVuY3Rpb24gKGxhYmVsLCBncmFwaE9wdGlvbnMpIHtcbiAgICB0aGlzLmdyb3Vwc1tsYWJlbF0gPSBncmFwaE9wdGlvbnM7XG4gIH07XG5cbiAgTGVnZW5kLnByb3RvdHlwZS5yZW1vdmVHcm91cCA9IGZ1bmN0aW9uIChsYWJlbCkge1xuICAgIGlmICh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShsYWJlbCkpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmdyb3Vwc1tsYWJlbF07XG4gICAgICB0aGlzLmFtb3VudE9mR3JvdXBzIC09IDE7XG4gICAgfVxuICB9O1xuXG4gIExlZ2VuZC5wcm90b3R5cGUuX2NyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRvbS5mcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuZG9tLmZyYW1lLmNsYXNzTmFtZSA9ICd2aXMtbGVnZW5kJztcbiAgICB0aGlzLmRvbS5mcmFtZS5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICB0aGlzLmRvbS5mcmFtZS5zdHlsZS50b3AgPSBcIjEwcHhcIjtcbiAgICB0aGlzLmRvbS5mcmFtZS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuXG4gICAgdGhpcy5kb20udGV4dEFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmRvbS50ZXh0QXJlYS5jbGFzc05hbWUgPSAndmlzLWxlZ2VuZC10ZXh0JztcbiAgICB0aGlzLmRvbS50ZXh0QXJlYS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcbiAgICB0aGlzLmRvbS50ZXh0QXJlYS5zdHlsZS50b3AgPSBcIjBweFwiO1xuXG4gICAgdGhpcy5zdmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgXCJzdmdcIik7XG4gICAgdGhpcy5zdmcuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIHRoaXMuc3ZnLnN0eWxlLnRvcCA9IDAgKyAncHgnO1xuICAgIHRoaXMuc3ZnLnN0eWxlLndpZHRoID0gdGhpcy5vcHRpb25zLmljb25TaXplICsgNSArICdweCc7XG4gICAgdGhpcy5zdmcuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuXG4gICAgdGhpcy5kb20uZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5zdmcpO1xuICAgIHRoaXMuZG9tLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuZG9tLnRleHRBcmVhKTtcbiAgfTtcblxuICAvKipcbiAgICogSGlkZSB0aGUgY29tcG9uZW50IGZyb20gdGhlIERPTVxuICAgKi9cbiAgTGVnZW5kLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHJlbW92ZSB0aGUgZnJhbWUgY29udGFpbmluZyB0aGUgaXRlbXNcbiAgICBpZiAodGhpcy5kb20uZnJhbWUucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5kb20uZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbS5mcmFtZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTaG93IHRoZSBjb21wb25lbnQgaW4gdGhlIERPTSAod2hlbiBub3QgYWxyZWFkeSB2aXNpYmxlKS5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gY2hhbmdlZFxuICAgKi9cbiAgTGVnZW5kLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHNob3cgZnJhbWUgY29udGFpbmluZyB0aGUgaXRlbXNcbiAgICBpZiAoIXRoaXMuZG9tLmZyYW1lLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuYm9keS5kb20uY2VudGVyLmFwcGVuZENoaWxkKHRoaXMuZG9tLmZyYW1lKTtcbiAgICB9XG4gIH07XG5cbiAgTGVnZW5kLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgZmllbGRzID0gWydlbmFibGVkJywgJ29yaWVudGF0aW9uJywgJ2ljb25zJywgJ2xlZnQnLCAncmlnaHQnXTtcbiAgICB1dGlsLnNlbGVjdGl2ZURlZXBFeHRlbmQoZmllbGRzLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICB9O1xuXG4gIExlZ2VuZC5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhY3RpdmVHcm91cHMgPSAwO1xuICAgIHZhciBncm91cEFycmF5ID0gT2JqZWN0LmtleXModGhpcy5ncm91cHMpO1xuICAgIGdyb3VwQXJyYXkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiAxO1xuICAgIH0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZ3JvdXBJZCA9IGdyb3VwQXJyYXlbaV07XG4gICAgICBpZiAodGhpcy5ncm91cHNbZ3JvdXBJZF0udmlzaWJsZSA9PSB0cnVlICYmICh0aGlzLmxpbmVncmFwaE9wdGlvbnMudmlzaWJpbGl0eVtncm91cElkXSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMubGluZWdyYXBoT3B0aW9ucy52aXNpYmlsaXR5W2dyb3VwSWRdID09IHRydWUpKSB7XG4gICAgICAgIGFjdGl2ZUdyb3VwcysrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnNbdGhpcy5zaWRlXS52aXNpYmxlID09IGZhbHNlIHx8IHRoaXMuYW1vdW50T2ZHcm91cHMgPT0gMCB8fCB0aGlzLm9wdGlvbnMuZW5hYmxlZCA9PSBmYWxzZSB8fCBhY3RpdmVHcm91cHMgPT0gMCkge1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgaWYgKHRoaXMub3B0aW9uc1t0aGlzLnNpZGVdLnBvc2l0aW9uID09ICd0b3AtbGVmdCcgfHwgdGhpcy5vcHRpb25zW3RoaXMuc2lkZV0ucG9zaXRpb24gPT0gJ2JvdHRvbS1sZWZ0Jykge1xuICAgICAgICB0aGlzLmRvbS5mcmFtZS5zdHlsZS5sZWZ0ID0gJzRweCc7XG4gICAgICAgIHRoaXMuZG9tLmZyYW1lLnN0eWxlLnRleHRBbGlnbiA9IFwibGVmdFwiO1xuICAgICAgICB0aGlzLmRvbS50ZXh0QXJlYS5zdHlsZS50ZXh0QWxpZ24gPSBcImxlZnRcIjtcbiAgICAgICAgdGhpcy5kb20udGV4dEFyZWEuc3R5bGUubGVmdCA9IHRoaXMub3B0aW9ucy5pY29uU2l6ZSArIDE1ICsgJ3B4JztcbiAgICAgICAgdGhpcy5kb20udGV4dEFyZWEuc3R5bGUucmlnaHQgPSAnJztcbiAgICAgICAgdGhpcy5zdmcuc3R5bGUubGVmdCA9IDAgKyAncHgnO1xuICAgICAgICB0aGlzLnN2Zy5zdHlsZS5yaWdodCA9ICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kb20uZnJhbWUuc3R5bGUucmlnaHQgPSAnNHB4JztcbiAgICAgICAgdGhpcy5kb20uZnJhbWUuc3R5bGUudGV4dEFsaWduID0gXCJyaWdodFwiO1xuICAgICAgICB0aGlzLmRvbS50ZXh0QXJlYS5zdHlsZS50ZXh0QWxpZ24gPSBcInJpZ2h0XCI7XG4gICAgICAgIHRoaXMuZG9tLnRleHRBcmVhLnN0eWxlLnJpZ2h0ID0gdGhpcy5vcHRpb25zLmljb25TaXplICsgMTUgKyAncHgnO1xuICAgICAgICB0aGlzLmRvbS50ZXh0QXJlYS5zdHlsZS5sZWZ0ID0gJyc7XG4gICAgICAgIHRoaXMuc3ZnLnN0eWxlLnJpZ2h0ID0gMCArICdweCc7XG4gICAgICAgIHRoaXMuc3ZnLnN0eWxlLmxlZnQgPSAnJztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9uc1t0aGlzLnNpZGVdLnBvc2l0aW9uID09ICd0b3AtbGVmdCcgfHwgdGhpcy5vcHRpb25zW3RoaXMuc2lkZV0ucG9zaXRpb24gPT0gJ3RvcC1yaWdodCcpIHtcbiAgICAgICAgdGhpcy5kb20uZnJhbWUuc3R5bGUudG9wID0gNCAtIE51bWJlcih0aGlzLmJvZHkuZG9tLmNlbnRlci5zdHlsZS50b3AucmVwbGFjZShcInB4XCIsIFwiXCIpKSArICdweCc7XG4gICAgICAgIHRoaXMuZG9tLmZyYW1lLnN0eWxlLmJvdHRvbSA9ICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNjcm9sbGFibGVIZWlnaHQgPSB0aGlzLmJvZHkuZG9tUHJvcHMuY2VudGVyLmhlaWdodCAtIHRoaXMuYm9keS5kb21Qcm9wcy5jZW50ZXJDb250YWluZXIuaGVpZ2h0O1xuICAgICAgICB0aGlzLmRvbS5mcmFtZS5zdHlsZS5ib3R0b20gPSA0ICsgc2Nyb2xsYWJsZUhlaWdodCArIE51bWJlcih0aGlzLmJvZHkuZG9tLmNlbnRlci5zdHlsZS50b3AucmVwbGFjZShcInB4XCIsIFwiXCIpKSArICdweCc7XG4gICAgICAgIHRoaXMuZG9tLmZyYW1lLnN0eWxlLnRvcCA9ICcnO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmljb25zID09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuZG9tLmZyYW1lLnN0eWxlLndpZHRoID0gdGhpcy5kb20udGV4dEFyZWEub2Zmc2V0V2lkdGggKyAxMCArICdweCc7XG4gICAgICAgIHRoaXMuZG9tLnRleHRBcmVhLnN0eWxlLnJpZ2h0ID0gJyc7XG4gICAgICAgIHRoaXMuZG9tLnRleHRBcmVhLnN0eWxlLmxlZnQgPSAnJztcbiAgICAgICAgdGhpcy5zdmcuc3R5bGUud2lkdGggPSAnMHB4JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZG9tLmZyYW1lLnN0eWxlLndpZHRoID0gdGhpcy5vcHRpb25zLmljb25TaXplICsgMTUgKyB0aGlzLmRvbS50ZXh0QXJlYS5vZmZzZXRXaWR0aCArIDEwICsgJ3B4JztcbiAgICAgICAgdGhpcy5kcmF3TGVnZW5kSWNvbnMoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRlbnQgPSAnJztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZ3JvdXBJZCA9IGdyb3VwQXJyYXlbaV07XG4gICAgICAgIGlmICh0aGlzLmdyb3Vwc1tncm91cElkXS52aXNpYmxlID09IHRydWUgJiYgKHRoaXMubGluZWdyYXBoT3B0aW9ucy52aXNpYmlsaXR5W2dyb3VwSWRdID09PSB1bmRlZmluZWQgfHwgdGhpcy5saW5lZ3JhcGhPcHRpb25zLnZpc2liaWxpdHlbZ3JvdXBJZF0gPT0gdHJ1ZSkpIHtcbiAgICAgICAgICBjb250ZW50ICs9IHRoaXMuZ3JvdXBzW2dyb3VwSWRdLmNvbnRlbnQgKyAnPGJyIC8+JztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5kb20udGV4dEFyZWEuaW5uZXJIVE1MID0gY29udGVudDtcbiAgICAgIHRoaXMuZG9tLnRleHRBcmVhLnN0eWxlLmxpbmVIZWlnaHQgPSAwLjc1ICogdGhpcy5vcHRpb25zLmljb25TaXplICsgdGhpcy5vcHRpb25zLmljb25TcGFjaW5nICsgJ3B4JztcbiAgICB9XG4gIH07XG5cbiAgTGVnZW5kLnByb3RvdHlwZS5kcmF3TGVnZW5kSWNvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZG9tLmZyYW1lLnBhcmVudE5vZGUpIHtcbiAgICAgIHZhciBncm91cEFycmF5ID0gT2JqZWN0LmtleXModGhpcy5ncm91cHMpO1xuICAgICAgZ3JvdXBBcnJheS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhIDwgYiA/IC0xIDogMTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyB0aGlzIHJlc2V0cyB0aGUgZWxlbWVudHMgc28gdGhlIG9yZGVyIGlzIG1haW50YWluZWRcbiAgICAgIERPTXV0aWwucmVzZXRFbGVtZW50cyh0aGlzLnN2Z0VsZW1lbnRzKTtcblxuICAgICAgdmFyIHBhZGRpbmcgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmRvbS5mcmFtZSkucGFkZGluZ1RvcDtcbiAgICAgIHZhciBpY29uT2Zmc2V0ID0gTnVtYmVyKHBhZGRpbmcucmVwbGFjZSgncHgnLCAnJykpO1xuICAgICAgdmFyIHggPSBpY29uT2Zmc2V0O1xuICAgICAgdmFyIGljb25XaWR0aCA9IHRoaXMub3B0aW9ucy5pY29uU2l6ZTtcbiAgICAgIHZhciBpY29uSGVpZ2h0ID0gMC43NSAqIHRoaXMub3B0aW9ucy5pY29uU2l6ZTtcbiAgICAgIHZhciB5ID0gaWNvbk9mZnNldCArIDAuNSAqIGljb25IZWlnaHQgKyAzO1xuXG4gICAgICB0aGlzLnN2Zy5zdHlsZS53aWR0aCA9IGljb25XaWR0aCArIDUgKyBpY29uT2Zmc2V0ICsgJ3B4JztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBncm91cElkID0gZ3JvdXBBcnJheVtpXTtcbiAgICAgICAgaWYgKHRoaXMuZ3JvdXBzW2dyb3VwSWRdLnZpc2libGUgPT0gdHJ1ZSAmJiAodGhpcy5saW5lZ3JhcGhPcHRpb25zLnZpc2liaWxpdHlbZ3JvdXBJZF0gPT09IHVuZGVmaW5lZCB8fCB0aGlzLmxpbmVncmFwaE9wdGlvbnMudmlzaWJpbGl0eVtncm91cElkXSA9PSB0cnVlKSkge1xuICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwSWRdLmdldExlZ2VuZChpY29uV2lkdGgsIGljb25IZWlnaHQsIHRoaXMuZnJhbWV3b3JrLCB4LCB5KTtcbiAgICAgICAgICB5ICs9IGljb25IZWlnaHQgKyB0aGlzLm9wdGlvbnMuaWNvblNwYWNpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBMZWdlbmQ7XG5cbi8qKiovIH0sXG4vKiA1OSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuICAvKipcbiAgICogVGhpcyBvYmplY3QgY29udGFpbnMgYWxsIHBvc3NpYmxlIG9wdGlvbnMuIEl0IHdpbGwgY2hlY2sgaWYgdGhlIHR5cGVzIGFyZSBjb3JyZWN0LCBpZiByZXF1aXJlZCBpZiB0aGUgb3B0aW9uIGlzIG9uZVxuICAgKiBvZiB0aGUgYWxsb3dlZCB2YWx1ZXMuXG4gICAqXG4gICAqIF9fYW55X18gbWVhbnMgdGhhdCB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgZG9lcyBub3QgbWF0dGVyLlxuICAgKiBfX3R5cGVfXyBpcyBhIHJlcXVpcmVkIGZpZWxkIGZvciBhbGwgb2JqZWN0cyBhbmQgY29udGFpbnMgdGhlIGFsbG93ZWQgdHlwZXMgb2YgYWxsIG9iamVjdHNcbiAgICovXG4gIHZhciBzdHJpbmcgPSAnc3RyaW5nJztcbiAgdmFyIGJvb2xlYW4gPSAnYm9vbGVhbic7XG4gIHZhciBudW1iZXIgPSAnbnVtYmVyJztcbiAgdmFyIGFycmF5ID0gJ2FycmF5JztcbiAgdmFyIGRhdGUgPSAnZGF0ZSc7XG4gIHZhciBvYmplY3QgPSAnb2JqZWN0JzsgLy8gc2hvdWxkIG9ubHkgYmUgaW4gYSBfX3R5cGVfXyBwcm9wZXJ0eVxuICB2YXIgZG9tID0gJ2RvbSc7XG4gIHZhciBtb21lbnQgPSAnbW9tZW50JztcbiAgdmFyIGFueSA9ICdhbnknO1xuXG4gIHZhciBhbGxPcHRpb25zID0ge1xuICAgIGNvbmZpZ3VyZToge1xuICAgICAgZW5hYmxlZDogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICBmaWx0ZXI6IHsgYm9vbGVhbjogYm9vbGVhbiwgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgICAgY29udGFpbmVyOiB7IGRvbTogZG9tIH0sXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgYm9vbGVhbjogYm9vbGVhbiwgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9XG4gICAgfSxcblxuICAgIC8vZ2xvYmFscyA6XG4gICAgeUF4aXNPcmllbnRhdGlvbjogeyBzdHJpbmc6IFsnbGVmdCcsICdyaWdodCddIH0sXG4gICAgZGVmYXVsdEdyb3VwOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgc29ydDogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgc2FtcGxpbmc6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgIHN0YWNrOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICBncmFwaEhlaWdodDogeyBzdHJpbmc6IHN0cmluZywgbnVtYmVyOiBudW1iZXIgfSxcbiAgICBzaGFkZWQ6IHtcbiAgICAgIGVuYWJsZWQ6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgb3JpZW50YXRpb246IHsgc3RyaW5nOiBbJ2JvdHRvbScsICd0b3AnLCAnemVybycsICdncm91cCddIH0sIC8vIHRvcCwgYm90dG9tLCB6ZXJvLCBncm91cFxuICAgICAgZ3JvdXBJZDogeyBvYmplY3Q6IG9iamVjdCB9LFxuICAgICAgX190eXBlX186IHsgYm9vbGVhbjogYm9vbGVhbiwgb2JqZWN0OiBvYmplY3QgfVxuICAgIH0sXG4gICAgc3R5bGU6IHsgc3RyaW5nOiBbJ2xpbmUnLCAnYmFyJywgJ3BvaW50cyddIH0sIC8vIGxpbmUsIGJhclxuICAgIGJhckNoYXJ0OiB7XG4gICAgICB3aWR0aDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgbWluV2lkdGg6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIHNpZGVCeVNpZGU6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgYWxpZ246IHsgc3RyaW5nOiBbJ2xlZnQnLCAnY2VudGVyJywgJ3JpZ2h0J10gfSxcbiAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0IH1cbiAgICB9LFxuICAgIGludGVycG9sYXRpb246IHtcbiAgICAgIGVuYWJsZWQ6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgcGFyYW1ldHJpemF0aW9uOiB7IHN0cmluZzogWydjZW50cmlwZXRhbCcsICdjaG9yZGFsJywgJ3VuaWZvcm0nXSB9LCAvLyB1bmlmb3JtIChhbHBoYSA9IDAuMCksIGNob3JkYWwgKGFscGhhID0gMS4wKSwgY2VudHJpcGV0YWwgKGFscGhhID0gMC41KVxuICAgICAgYWxwaGE6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBib29sZWFuOiBib29sZWFuIH1cbiAgICB9LFxuICAgIGRyYXdQb2ludHM6IHtcbiAgICAgIGVuYWJsZWQ6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgb25SZW5kZXI6IHsgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgICAgc2l6ZTogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgc3R5bGU6IHsgc3RyaW5nOiBbJ3NxdWFyZScsICdjaXJjbGUnXSB9LCAvLyBzcXVhcmUsIGNpcmNsZVxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIGJvb2xlYW46IGJvb2xlYW4sICdmdW5jdGlvbic6ICdmdW5jdGlvbicgfVxuICAgIH0sXG4gICAgZGF0YUF4aXM6IHtcbiAgICAgIHNob3dNaW5vckxhYmVsczogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICBzaG93TWFqb3JMYWJlbHM6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgaWNvbnM6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgd2lkdGg6IHsgc3RyaW5nOiBzdHJpbmcsIG51bWJlcjogbnVtYmVyIH0sXG4gICAgICB2aXNpYmxlOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgIGFsaWduWmVyb3M6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgbGVmdDoge1xuICAgICAgICByYW5nZTogeyBtaW46IHsgbnVtYmVyOiBudW1iZXIgfSwgbWF4OiB7IG51bWJlcjogbnVtYmVyIH0sIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0IH0gfSxcbiAgICAgICAgZm9ybWF0OiB7ICdmdW5jdGlvbic6ICdmdW5jdGlvbicgfSxcbiAgICAgICAgdGl0bGU6IHsgdGV4dDogeyBzdHJpbmc6IHN0cmluZywgbnVtYmVyOiBudW1iZXIgfSwgc3R5bGU6IHsgc3RyaW5nOiBzdHJpbmcgfSwgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfSB9LFxuICAgICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gICAgICB9LFxuICAgICAgcmlnaHQ6IHtcbiAgICAgICAgcmFuZ2U6IHsgbWluOiB7IG51bWJlcjogbnVtYmVyIH0sIG1heDogeyBudW1iZXI6IG51bWJlciB9LCBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9IH0sXG4gICAgICAgIGZvcm1hdDogeyAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH0sXG4gICAgICAgIHRpdGxlOiB7IHRleHQ6IHsgc3RyaW5nOiBzdHJpbmcsIG51bWJlcjogbnVtYmVyIH0sIHN0eWxlOiB7IHN0cmluZzogc3RyaW5nIH0sIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0IH0gfSxcbiAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0IH1cbiAgICB9LFxuICAgIGxlZ2VuZDoge1xuICAgICAgZW5hYmxlZDogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICBpY29uczogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICBsZWZ0OiB7XG4gICAgICAgIHZpc2libGU6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgICBwb3NpdGlvbjogeyBzdHJpbmc6IFsndG9wLXJpZ2h0JywgJ2JvdHRvbS1yaWdodCcsICd0b3AtbGVmdCcsICdib3R0b20tbGVmdCddIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0IH1cbiAgICAgIH0sXG4gICAgICByaWdodDoge1xuICAgICAgICB2aXNpYmxlOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgICAgcG9zaXRpb246IHsgc3RyaW5nOiBbJ3RvcC1yaWdodCcsICdib3R0b20tcmlnaHQnLCAndG9wLWxlZnQnLCAnYm90dG9tLWxlZnQnXSB9LFxuICAgICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gICAgICB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIGJvb2xlYW46IGJvb2xlYW4gfVxuICAgIH0sXG4gICAgZ3JvdXBzOiB7XG4gICAgICB2aXNpYmlsaXR5OiB7IGFueTogYW55IH0sXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gICAgfSxcblxuICAgIGF1dG9SZXNpemU6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgIHRocm90dGxlUmVkcmF3OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgY2xpY2tUb1VzZTogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgZW5kOiB7IG51bWJlcjogbnVtYmVyLCBkYXRlOiBkYXRlLCBzdHJpbmc6IHN0cmluZywgbW9tZW50OiBtb21lbnQgfSxcbiAgICBmb3JtYXQ6IHtcbiAgICAgIG1pbm9yTGFiZWxzOiB7XG4gICAgICAgIG1pbGxpc2Vjb25kOiB7IHN0cmluZzogc3RyaW5nLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgICAgc2Vjb25kOiB7IHN0cmluZzogc3RyaW5nLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgICAgbWludXRlOiB7IHN0cmluZzogc3RyaW5nLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgICAgaG91cjogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICAgIHdlZWtkYXk6IHsgc3RyaW5nOiBzdHJpbmcsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgICBkYXk6IHsgc3RyaW5nOiBzdHJpbmcsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgICBtb250aDogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICAgIHllYXI6IHsgc3RyaW5nOiBzdHJpbmcsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gICAgICB9LFxuICAgICAgbWFqb3JMYWJlbHM6IHtcbiAgICAgICAgbWlsbGlzZWNvbmQ6IHsgc3RyaW5nOiBzdHJpbmcsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgICBzZWNvbmQ6IHsgc3RyaW5nOiBzdHJpbmcsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgICBtaW51dGU6IHsgc3RyaW5nOiBzdHJpbmcsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgICBob3VyOiB7IHN0cmluZzogc3RyaW5nLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgICAgd2Vla2RheTogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICAgIGRheTogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICAgIG1vbnRoOiB7IHN0cmluZzogc3RyaW5nLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgICAgeWVhcjogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0IH1cbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gICAgfSxcbiAgICBtb21lbnQ6IHsgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgIGhlaWdodDogeyBzdHJpbmc6IHN0cmluZywgbnVtYmVyOiBudW1iZXIgfSxcbiAgICBoaWRkZW5EYXRlczoge1xuICAgICAgc3RhcnQ6IHsgZGF0ZTogZGF0ZSwgbnVtYmVyOiBudW1iZXIsIHN0cmluZzogc3RyaW5nLCBtb21lbnQ6IG1vbWVudCB9LFxuICAgICAgZW5kOiB7IGRhdGU6IGRhdGUsIG51bWJlcjogbnVtYmVyLCBzdHJpbmc6IHN0cmluZywgbW9tZW50OiBtb21lbnQgfSxcbiAgICAgIHJlcGVhdDogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIGFycmF5OiBhcnJheSB9XG4gICAgfSxcbiAgICBsb2NhbGU6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICBsb2NhbGVzOiB7XG4gICAgICBfX2FueV9fOiB7IGFueTogYW55IH0sXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gICAgfSxcbiAgICBtYXg6IHsgZGF0ZTogZGF0ZSwgbnVtYmVyOiBudW1iZXIsIHN0cmluZzogc3RyaW5nLCBtb21lbnQ6IG1vbWVudCB9LFxuICAgIG1heEhlaWdodDogeyBudW1iZXI6IG51bWJlciwgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICBtYXhNaW5vckNoYXJzOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgbWluOiB7IGRhdGU6IGRhdGUsIG51bWJlcjogbnVtYmVyLCBzdHJpbmc6IHN0cmluZywgbW9tZW50OiBtb21lbnQgfSxcbiAgICBtaW5IZWlnaHQ6IHsgbnVtYmVyOiBudW1iZXIsIHN0cmluZzogc3RyaW5nIH0sXG4gICAgbW92ZWFibGU6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgIG11bHRpc2VsZWN0OiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICBvcmllbnRhdGlvbjogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgIHNob3dDdXJyZW50VGltZTogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgc2hvd01ham9yTGFiZWxzOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICBzaG93TWlub3JMYWJlbHM6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgIHN0YXJ0OiB7IGRhdGU6IGRhdGUsIG51bWJlcjogbnVtYmVyLCBzdHJpbmc6IHN0cmluZywgbW9tZW50OiBtb21lbnQgfSxcbiAgICB0aW1lQXhpczoge1xuICAgICAgc2NhbGU6IHsgc3RyaW5nOiBzdHJpbmcsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgc3RlcDogeyBudW1iZXI6IG51bWJlciwgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gICAgfSxcbiAgICB3aWR0aDogeyBzdHJpbmc6IHN0cmluZywgbnVtYmVyOiBudW1iZXIgfSxcbiAgICB6b29tYWJsZTogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgem9vbUtleTogeyBzdHJpbmc6IFsnY3RybEtleScsICdhbHRLZXknLCAnbWV0YUtleScsICcnXSB9LFxuICAgIHpvb21NYXg6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICB6b29tTWluOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgekluZGV4OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICB9O1xuXG4gIHZhciBjb25maWd1cmVPcHRpb25zID0ge1xuICAgIGdsb2JhbDoge1xuICAgICAgLy95QXhpc09yaWVudGF0aW9uOiBbJ2xlZnQnLCdyaWdodCddLCAvLyBURE9POiBlbmFibGUgYXMgc29vbiBhcyBHcmFocDJkIGRvZXNuJ3QgY3Jhc2ggd2hlbiBjaGFuZ2luZyB0aGlzIG9uIHRoZSBmbHlcbiAgICAgIHNvcnQ6IHRydWUsXG4gICAgICBzYW1wbGluZzogdHJ1ZSxcbiAgICAgIHN0YWNrOiBmYWxzZSxcbiAgICAgIHNoYWRlZDoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgb3JpZW50YXRpb246IFsnemVybycsICd0b3AnLCAnYm90dG9tJywgJ2dyb3VwJ10gLy8gemVybywgdG9wLCBib3R0b21cbiAgICAgIH0sXG4gICAgICBzdHlsZTogWydsaW5lJywgJ2JhcicsICdwb2ludHMnXSwgLy8gbGluZSwgYmFyXG4gICAgICBiYXJDaGFydDoge1xuICAgICAgICB3aWR0aDogWzUwLCA1LCAxMDAsIDVdLFxuICAgICAgICBtaW5XaWR0aDogWzUwLCA1LCAxMDAsIDVdLFxuICAgICAgICBzaWRlQnlTaWRlOiBmYWxzZSxcbiAgICAgICAgYWxpZ246IFsnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnXSAvLyBsZWZ0LCBjZW50ZXIsIHJpZ2h0XG4gICAgICB9LFxuICAgICAgaW50ZXJwb2xhdGlvbjoge1xuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBwYXJhbWV0cml6YXRpb246IFsnY2VudHJpcGV0YWwnLCAnY2hvcmRhbCcsICd1bmlmb3JtJ10gLy8gdW5pZm9ybSAoYWxwaGEgPSAwLjApLCBjaG9yZGFsIChhbHBoYSA9IDEuMCksIGNlbnRyaXBldGFsIChhbHBoYSA9IDAuNSlcbiAgICAgIH0sXG4gICAgICBkcmF3UG9pbnRzOiB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIHNpemU6IFs2LCAyLCAzMCwgMV0sXG4gICAgICAgIHN0eWxlOiBbJ3NxdWFyZScsICdjaXJjbGUnXSAvLyBzcXVhcmUsIGNpcmNsZVxuICAgICAgfSxcbiAgICAgIGRhdGFBeGlzOiB7XG4gICAgICAgIHNob3dNaW5vckxhYmVsczogdHJ1ZSxcbiAgICAgICAgc2hvd01ham9yTGFiZWxzOiB0cnVlLFxuICAgICAgICBpY29uczogZmFsc2UsXG4gICAgICAgIHdpZHRoOiBbNDAsIDAsIDIwMCwgMV0sXG4gICAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICAgIGFsaWduWmVyb3M6IHRydWUsXG4gICAgICAgIGxlZnQ6IHtcbiAgICAgICAgICAvL3JhbmdlOiB7bWluOid1bmRlZmluZWQnOiAndW5kZWZpbmVkJ2luZWQsbWF4Oid1bmRlZmluZWQnOiAndW5kZWZpbmVkJ2luZWR9LFxuICAgICAgICAgIC8vZm9ybWF0OiBmdW5jdGlvbiAodmFsdWUpIHtyZXR1cm4gdmFsdWU7fSxcbiAgICAgICAgICB0aXRsZTogeyB0ZXh0OiAnJywgc3R5bGU6ICcnIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmlnaHQ6IHtcbiAgICAgICAgICAvL3JhbmdlOiB7bWluOid1bmRlZmluZWQnOiAndW5kZWZpbmVkJ2luZWQsbWF4Oid1bmRlZmluZWQnOiAndW5kZWZpbmVkJ2luZWR9LFxuICAgICAgICAgIC8vZm9ybWF0OiBmdW5jdGlvbiAodmFsdWUpIHtyZXR1cm4gdmFsdWU7fSxcbiAgICAgICAgICB0aXRsZTogeyB0ZXh0OiAnJywgc3R5bGU6ICcnIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGxlZ2VuZDoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgaWNvbnM6IHRydWUsXG4gICAgICAgIGxlZnQ6IHtcbiAgICAgICAgICB2aXNpYmxlOiB0cnVlLFxuICAgICAgICAgIHBvc2l0aW9uOiBbJ3RvcC1yaWdodCcsICdib3R0b20tcmlnaHQnLCAndG9wLWxlZnQnLCAnYm90dG9tLWxlZnQnXSAvLyB0b3AvYm90dG9tIC0gbGVmdCxyaWdodFxuICAgICAgICB9LFxuICAgICAgICByaWdodDoge1xuICAgICAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICAgICAgcG9zaXRpb246IFsndG9wLXJpZ2h0JywgJ2JvdHRvbS1yaWdodCcsICd0b3AtbGVmdCcsICdib3R0b20tbGVmdCddIC8vIHRvcC9ib3R0b20gLSBsZWZ0LHJpZ2h0XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGF1dG9SZXNpemU6IHRydWUsXG4gICAgICB0aHJvdHRsZVJlZHJhdzogWzEwLCAwLCAxMDAwLCAxMF0sXG4gICAgICBjbGlja1RvVXNlOiBmYWxzZSxcbiAgICAgIGVuZDogJycsXG4gICAgICBmb3JtYXQ6IHtcbiAgICAgICAgbWlub3JMYWJlbHM6IHtcbiAgICAgICAgICBtaWxsaXNlY29uZDogJ1NTUycsXG4gICAgICAgICAgc2Vjb25kOiAncycsXG4gICAgICAgICAgbWludXRlOiAnSEg6bW0nLFxuICAgICAgICAgIGhvdXI6ICdISDptbScsXG4gICAgICAgICAgd2Vla2RheTogJ2RkZCBEJyxcbiAgICAgICAgICBkYXk6ICdEJyxcbiAgICAgICAgICBtb250aDogJ01NTScsXG4gICAgICAgICAgeWVhcjogJ1lZWVknXG4gICAgICAgIH0sXG4gICAgICAgIG1ham9yTGFiZWxzOiB7XG4gICAgICAgICAgbWlsbGlzZWNvbmQ6ICdISDptbTpzcycsXG4gICAgICAgICAgc2Vjb25kOiAnRCBNTU1NIEhIOm1tJyxcbiAgICAgICAgICBtaW51dGU6ICdkZGQgRCBNTU1NJyxcbiAgICAgICAgICBob3VyOiAnZGRkIEQgTU1NTScsXG4gICAgICAgICAgd2Vla2RheTogJ01NTU0gWVlZWScsXG4gICAgICAgICAgZGF5OiAnTU1NTSBZWVlZJyxcbiAgICAgICAgICBtb250aDogJ1lZWVknLFxuICAgICAgICAgIHllYXI6ICcnXG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGhlaWdodDogJycsXG4gICAgICBsb2NhbGU6ICcnLFxuICAgICAgbWF4OiAnJyxcbiAgICAgIG1heEhlaWdodDogJycsXG4gICAgICBtYXhNaW5vckNoYXJzOiBbNywgMCwgMjAsIDFdLFxuICAgICAgbWluOiAnJyxcbiAgICAgIG1pbkhlaWdodDogJycsXG4gICAgICBtb3ZlYWJsZTogdHJ1ZSxcbiAgICAgIG9yaWVudGF0aW9uOiBbJ2JvdGgnLCAnYm90dG9tJywgJ3RvcCddLFxuICAgICAgc2hvd0N1cnJlbnRUaW1lOiBmYWxzZSxcbiAgICAgIHNob3dNYWpvckxhYmVsczogdHJ1ZSxcbiAgICAgIHNob3dNaW5vckxhYmVsczogdHJ1ZSxcbiAgICAgIHN0YXJ0OiAnJyxcbiAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICB6b29tYWJsZTogdHJ1ZSxcbiAgICAgIHpvb21LZXk6IFsnY3RybEtleScsICdhbHRLZXknLCAnbWV0YUtleScsICcnXSxcbiAgICAgIHpvb21NYXg6IFszMTUzNjAwMDAwMDAwMDAsIDEwLCAzMTUzNjAwMDAwMDAwMDAsIDFdLFxuICAgICAgem9vbU1pbjogWzEwLCAxMCwgMzE1MzYwMDAwMDAwMDAwLCAxXSxcbiAgICAgIHpJbmRleDogMFxuICAgIH1cbiAgfTtcblxuICBleHBvcnRzLmFsbE9wdGlvbnMgPSBhbGxPcHRpb25zO1xuICBleHBvcnRzLmNvbmZpZ3VyZU9wdGlvbnMgPSBjb25maWd1cmVPcHRpb25zO1xuXG4vKioqLyB9LFxuLyogNjAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyB1dGlsc1xuICBleHBvcnRzLnV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuICBleHBvcnRzLkRPTXV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG4gIC8vIGRhdGFcbiAgZXhwb3J0cy5EYXRhU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcbiAgZXhwb3J0cy5EYXRhVmlldyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuICBleHBvcnRzLlF1ZXVlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cbiAgLy8gTmV0d29ya1xuICBleHBvcnRzLk5ldHdvcmsgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxKTtcbiAgZXhwb3J0cy5uZXR3b3JrID0ge1xuICAgIEltYWdlczogX193ZWJwYWNrX3JlcXVpcmVfXyg2MiksXG4gICAgZG90cGFyc2VyOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDExOCksXG4gICAgZ2VwaGlQYXJzZXI6IF9fd2VicGFja19yZXF1aXJlX18oMTE5KSxcbiAgICBhbGxPcHRpb25zOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDExNClcbiAgfTtcbiAgZXhwb3J0cy5uZXR3b3JrLmNvbnZlcnREb3QgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5uZXR3b3JrLmRvdHBhcnNlci5ET1RUb0dyYXBoKGlucHV0KTtcbiAgfTtcbiAgZXhwb3J0cy5uZXR3b3JrLmNvbnZlcnRHZXBoaSA9IGZ1bmN0aW9uIChpbnB1dCwgb3B0aW9ucykge1xuICAgIHJldHVybiBleHBvcnRzLm5ldHdvcmsuZ2VwaGlQYXJzZXIucGFyc2VHZXBoaShpbnB1dCwgb3B0aW9ucyk7XG4gIH07XG5cbiAgLy8gYnVuZGxlZCBleHRlcm5hbCBsaWJyYXJpZXNcbiAgZXhwb3J0cy5tb21lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuICBleHBvcnRzLkhhbW1lciA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuICBleHBvcnRzLmtleWNoYXJtID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5cbi8qKiovIH0sXG4vKiA2MSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBfSW1hZ2VzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Mik7XG5cbiAgdmFyIF9JbWFnZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfSW1hZ2VzKTtcblxuICB2YXIgX0dyb3VwcyA9IF9fd2VicGFja19yZXF1aXJlX18oNjMpO1xuXG4gIHZhciBfR3JvdXBzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0dyb3Vwcyk7XG5cbiAgdmFyIF9Ob2Rlc0hhbmRsZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY0KTtcblxuICB2YXIgX05vZGVzSGFuZGxlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Ob2Rlc0hhbmRsZXIpO1xuXG4gIHZhciBfRWRnZXNIYW5kbGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NCk7XG5cbiAgdmFyIF9FZGdlc0hhbmRsZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRWRnZXNIYW5kbGVyKTtcblxuICB2YXIgX1BoeXNpY3NFbmdpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkzKTtcblxuICB2YXIgX1BoeXNpY3NFbmdpbmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUGh5c2ljc0VuZ2luZSk7XG5cbiAgdmFyIF9DbHVzdGVyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDIpO1xuXG4gIHZhciBfQ2x1c3RlcmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DbHVzdGVyaW5nKTtcblxuICB2YXIgX0NhbnZhc1JlbmRlcmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDUpO1xuXG4gIHZhciBfQ2FudmFzUmVuZGVyZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2FudmFzUmVuZGVyZXIpO1xuXG4gIHZhciBfQ2FudmFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDYpO1xuXG4gIHZhciBfQ2FudmFzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NhbnZhcyk7XG5cbiAgdmFyIF9WaWV3ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDcpO1xuXG4gIHZhciBfVmlldzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9WaWV3KTtcblxuICB2YXIgX0ludGVyYWN0aW9uSGFuZGxlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTA4KTtcblxuICB2YXIgX0ludGVyYWN0aW9uSGFuZGxlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9JbnRlcmFjdGlvbkhhbmRsZXIpO1xuXG4gIHZhciBfU2VsZWN0aW9uSGFuZGxlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTExKTtcblxuICB2YXIgX1NlbGVjdGlvbkhhbmRsZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2VsZWN0aW9uSGFuZGxlcik7XG5cbiAgdmFyIF9MYXlvdXRFbmdpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMik7XG5cbiAgdmFyIF9MYXlvdXRFbmdpbmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTGF5b3V0RW5naW5lKTtcblxuICB2YXIgX01hbmlwdWxhdGlvblN5c3RlbSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEzKTtcblxuICB2YXIgX01hbmlwdWxhdGlvblN5c3RlbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NYW5pcHVsYXRpb25TeXN0ZW0pO1xuXG4gIHZhciBfQ29uZmlndXJhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XG5cbiAgdmFyIF9Db25maWd1cmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ29uZmlndXJhdG9yKTtcblxuICB2YXIgX1ZhbGlkYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xuXG4gIHZhciBfVmFsaWRhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1ZhbGlkYXRvcik7XG5cbiAgdmFyIF9vcHRpb25zID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTQpO1xuXG4gIHZhciBfS2FtYWRhS2F3YWkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExNSk7XG5cbiAgdmFyIF9LYW1hZGFLYXdhaTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9LYW1hZGFLYXdhaSk7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuICAvLyBMb2FkIGN1c3RvbSBzaGFwZXMgaW50byBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRcbiAgX193ZWJwYWNrX3JlcXVpcmVfXygxMTcpO1xuXG4gIHZhciBFbWl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbiAgdmFyIERhdGFTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuICB2YXIgRGF0YVZpZXcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcbiAgdmFyIGRvdHBhcnNlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTE4KTtcbiAgdmFyIGdlcGhpUGFyc2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTkpO1xuICB2YXIgQWN0aXZhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NSk7XG4gIHZhciBsb2NhbGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjApO1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3IgTmV0d29ya1xuICAgKiBDcmVhdGUgYSBuZXR3b3JrIHZpc3VhbGl6YXRpb24sIGRpc3BsYXlpbmcgbm9kZXMgYW5kIGVkZ2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRhaW5lciAgIFRoZSBET00gZWxlbWVudCBpbiB3aGljaCB0aGUgTmV0d29yayB3aWxsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlIGNyZWF0ZWQuIE5vcm1hbGx5IGEgZGl2IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVyc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtBcnJheX0gbm9kZXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7QXJyYXl9IGVkZ2VzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zICAgICAgT3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gTmV0d29yayhjb250YWluZXIsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE5ldHdvcmspKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0NvbnN0cnVjdG9yIG11c3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBvcGVyYXRvcicpO1xuICAgIH1cblxuICAgIC8vIHNldCBjb25zdGFudCB2YWx1ZXNcbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgbG9jYWxlOiAnZW4nLFxuICAgICAgbG9jYWxlczogbG9jYWxlcyxcbiAgICAgIGNsaWNrVG9Vc2U6IGZhbHNlXG4gICAgfTtcbiAgICB1dGlsLmV4dGVuZCh0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gICAgLy8gY29udGFpbmVycyBmb3Igbm9kZXMgYW5kIGVkZ2VzXG4gICAgdGhpcy5ib2R5ID0ge1xuICAgICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICBub2Rlczoge30sXG4gICAgICBub2RlSW5kaWNlczogW10sXG4gICAgICBlZGdlczoge30sXG4gICAgICBlZGdlSW5kaWNlczogW10sXG4gICAgICBlbWl0dGVyOiB7XG4gICAgICAgIG9uOiB0aGlzLm9uLmJpbmQodGhpcyksXG4gICAgICAgIG9mZjogdGhpcy5vZmYuYmluZCh0aGlzKSxcbiAgICAgICAgZW1pdDogdGhpcy5lbWl0LmJpbmQodGhpcyksXG4gICAgICAgIG9uY2U6IHRoaXMub25jZS5iaW5kKHRoaXMpXG4gICAgICB9LFxuICAgICAgZXZlbnRMaXN0ZW5lcnM6IHtcbiAgICAgICAgb25UYXA6IGZ1bmN0aW9uIG9uVGFwKCkge30sXG4gICAgICAgIG9uVG91Y2g6IGZ1bmN0aW9uIG9uVG91Y2goKSB7fSxcbiAgICAgICAgb25Eb3VibGVUYXA6IGZ1bmN0aW9uIG9uRG91YmxlVGFwKCkge30sXG4gICAgICAgIG9uSG9sZDogZnVuY3Rpb24gb25Ib2xkKCkge30sXG4gICAgICAgIG9uRHJhZ1N0YXJ0OiBmdW5jdGlvbiBvbkRyYWdTdGFydCgpIHt9LFxuICAgICAgICBvbkRyYWc6IGZ1bmN0aW9uIG9uRHJhZygpIHt9LFxuICAgICAgICBvbkRyYWdFbmQ6IGZ1bmN0aW9uIG9uRHJhZ0VuZCgpIHt9LFxuICAgICAgICBvbk1vdXNlV2hlZWw6IGZ1bmN0aW9uIG9uTW91c2VXaGVlbCgpIHt9LFxuICAgICAgICBvblBpbmNoOiBmdW5jdGlvbiBvblBpbmNoKCkge30sXG4gICAgICAgIG9uTW91c2VNb3ZlOiBmdW5jdGlvbiBvbk1vdXNlTW92ZSgpIHt9LFxuICAgICAgICBvblJlbGVhc2U6IGZ1bmN0aW9uIG9uUmVsZWFzZSgpIHt9LFxuICAgICAgICBvbkNvbnRleHQ6IGZ1bmN0aW9uIG9uQ29udGV4dCgpIHt9XG4gICAgICB9LFxuICAgICAgZGF0YToge1xuICAgICAgICBub2RlczogbnVsbCwgLy8gQSBEYXRhU2V0IG9yIERhdGFWaWV3XG4gICAgICAgIGVkZ2VzOiBudWxsIC8vIEEgRGF0YVNldCBvciBEYXRhVmlld1xuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uczoge1xuICAgICAgICBjcmVhdGVOb2RlOiBmdW5jdGlvbiBjcmVhdGVOb2RlKCkge30sXG4gICAgICAgIGNyZWF0ZUVkZ2U6IGZ1bmN0aW9uIGNyZWF0ZUVkZ2UoKSB7fSxcbiAgICAgICAgZ2V0UG9pbnRlcjogZnVuY3Rpb24gZ2V0UG9pbnRlcigpIHt9XG4gICAgICB9LFxuICAgICAgbW9kdWxlczoge30sXG4gICAgICB2aWV3OiB7XG4gICAgICAgIHNjYWxlOiAxLFxuICAgICAgICB0cmFuc2xhdGlvbjogeyB4OiAwLCB5OiAwIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gYmluZCB0aGUgZXZlbnQgbGlzdGVuZXJzXG4gICAgdGhpcy5iaW5kRXZlbnRMaXN0ZW5lcnMoKTtcblxuICAgIC8vIHNldHRpbmcgdXAgYWxsIG1vZHVsZXNcbiAgICB0aGlzLmltYWdlcyA9IG5ldyBfSW1hZ2VzMi5kZWZhdWx0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpO1xuICAgIH0pOyAvLyBvYmplY3Qgd2l0aCBpbWFnZXNcbiAgICB0aGlzLmdyb3VwcyA9IG5ldyBfR3JvdXBzMi5kZWZhdWx0KCk7IC8vIG9iamVjdCB3aXRoIGdyb3Vwc1xuICAgIHRoaXMuY2FudmFzID0gbmV3IF9DYW52YXMyLmRlZmF1bHQodGhpcy5ib2R5KTsgLy8gRE9NIGhhbmRsZXJcbiAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIgPSBuZXcgX1NlbGVjdGlvbkhhbmRsZXIyLmRlZmF1bHQodGhpcy5ib2R5LCB0aGlzLmNhbnZhcyk7IC8vIFNlbGVjdGlvbiBoYW5kbGVyXG4gICAgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXIgPSBuZXcgX0ludGVyYWN0aW9uSGFuZGxlcjIuZGVmYXVsdCh0aGlzLmJvZHksIHRoaXMuY2FudmFzLCB0aGlzLnNlbGVjdGlvbkhhbmRsZXIpOyAvLyBJbnRlcmFjdGlvbiBoYW5kbGVyIGhhbmRsZXMgYWxsIHRoZSBoYW1tZXIgYmluZGluZ3MgKHRoYXQgYXJlIGJvdW5kIGJ5IGNhbnZhcyksIGtleVxuICAgIHRoaXMudmlldyA9IG5ldyBfVmlldzIuZGVmYXVsdCh0aGlzLmJvZHksIHRoaXMuY2FudmFzKTsgLy8gY2FtZXJhIGhhbmRsZXIsIGRvZXMgYW5pbWF0aW9ucyBhbmQgem9vbXNcbiAgICB0aGlzLnJlbmRlcmVyID0gbmV3IF9DYW52YXNSZW5kZXJlcjIuZGVmYXVsdCh0aGlzLmJvZHksIHRoaXMuY2FudmFzKTsgLy8gcmVuZGVyZXIsIHN0YXJ0cyByZW5kZXJsb29wLCBoYXMgZXZlbnRzIHRoYXQgbW9kdWxlcyBjYW4gaG9vayBpbnRvXG4gICAgdGhpcy5waHlzaWNzID0gbmV3IF9QaHlzaWNzRW5naW5lMi5kZWZhdWx0KHRoaXMuYm9keSk7IC8vIHBoeXNpY3MgZW5naW5lLCBkb2VzIGFsbCB0aGUgc2ltdWxhdGlvbnNcbiAgICB0aGlzLmxheW91dEVuZ2luZSA9IG5ldyBfTGF5b3V0RW5naW5lMi5kZWZhdWx0KHRoaXMuYm9keSk7IC8vIGxheW91dCBlbmdpbmUgZm9yIGluaXRhbCBsYXlvdXQgYW5kIGhpZXJhcmNoaWNhbCBsYXlvdXRcbiAgICB0aGlzLmNsdXN0ZXJpbmcgPSBuZXcgX0NsdXN0ZXJpbmcyLmRlZmF1bHQodGhpcy5ib2R5KTsgLy8gY2x1c3RlcmluZyBhcGlcbiAgICB0aGlzLm1hbmlwdWxhdGlvbiA9IG5ldyBfTWFuaXB1bGF0aW9uU3lzdGVtMi5kZWZhdWx0KHRoaXMuYm9keSwgdGhpcy5jYW52YXMsIHRoaXMuc2VsZWN0aW9uSGFuZGxlcik7IC8vIGRhdGEgbWFuaXB1bGF0aW9uIHN5c3RlbVxuXG4gICAgdGhpcy5ub2Rlc0hhbmRsZXIgPSBuZXcgX05vZGVzSGFuZGxlcjIuZGVmYXVsdCh0aGlzLmJvZHksIHRoaXMuaW1hZ2VzLCB0aGlzLmdyb3VwcywgdGhpcy5sYXlvdXRFbmdpbmUpOyAvLyBIYW5kbGUgYWRkaW5nLCBkZWxldGluZyBhbmQgdXBkYXRpbmcgb2Ygbm9kZXMgYXMgd2VsbCBhcyBnbG9iYWwgb3B0aW9uc1xuICAgIHRoaXMuZWRnZXNIYW5kbGVyID0gbmV3IF9FZGdlc0hhbmRsZXIyLmRlZmF1bHQodGhpcy5ib2R5LCB0aGlzLmltYWdlcywgdGhpcy5ncm91cHMpOyAvLyBIYW5kbGUgYWRkaW5nLCBkZWxldGluZyBhbmQgdXBkYXRpbmcgb2YgZWRnZXMgYXMgd2VsbCBhcyBnbG9iYWwgb3B0aW9uc1xuXG4gICAgdGhpcy5ib2R5Lm1vZHVsZXNbXCJrYW1hZGFLYXdhaVwiXSA9IG5ldyBfS2FtYWRhS2F3YWkyLmRlZmF1bHQodGhpcy5ib2R5LCAxNTAsIDAuMDUpOyAvLyBMYXlvdXRpbmcgYWxnb3JpdGhtLlxuICAgIHRoaXMuYm9keS5tb2R1bGVzW1wiY2x1c3RlcmluZ1wiXSA9IHRoaXMuY2x1c3RlcmluZztcblxuICAgIC8vIGNyZWF0ZSB0aGUgRE9NIGVsZW1lbnRzXG4gICAgdGhpcy5jYW52YXMuX2NyZWF0ZSgpO1xuXG4gICAgLy8gYXBwbHkgb3B0aW9uc1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICAgIC8vIGxvYWQgZGF0YSAodGhlIGRpc2FibGUgc3RhcnQgdmFyaWFibGUgd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUgZW5hYmxlZCBjbHVzdGVyaW5nKVxuICAgIHRoaXMuc2V0RGF0YShkYXRhKTtcbiAgfVxuXG4gIC8vIEV4dGVuZCBOZXR3b3JrIHdpdGggYW4gRW1pdHRlciBtaXhpblxuICBFbWl0dGVyKE5ldHdvcmsucHJvdG90eXBlKTtcblxuICAvKipcbiAgICogU2V0IG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIE5ldHdvcmsucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGVycm9yRm91bmQgPSBfVmFsaWRhdG9yMi5kZWZhdWx0LnZhbGlkYXRlKG9wdGlvbnMsIF9vcHRpb25zLmFsbE9wdGlvbnMpO1xuICAgICAgaWYgKGVycm9yRm91bmQgPT09IHRydWUpIHtcbiAgICAgICAgY29uc29sZS5sb2coJyVjRXJyb3JzIGhhdmUgYmVlbiBmb3VuZCBpbiB0aGUgc3VwcGxpZWQgb3B0aW9ucyBvYmplY3QuJywgX1ZhbGlkYXRvci5wcmludFN0eWxlKTtcbiAgICAgIH1cblxuICAgICAgLy8gY29weSB0aGUgZ2xvYmFsIGZpZWxkcyBvdmVyXG4gICAgICB2YXIgZmllbGRzID0gWydsb2NhbGUnLCAnbG9jYWxlcycsICdjbGlja1RvVXNlJ107XG4gICAgICB1dGlsLnNlbGVjdGl2ZURlZXBFeHRlbmQoZmllbGRzLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICAvLyB0aGUgaGllcmFyY2hpY2FsIHN5c3RlbSBjYW4gYWRhcHQgdGhlIGVkZ2VzIGFuZCB0aGUgcGh5c2ljcyB0byBpdCdzIG93biBvcHRpb25zIGJlY2F1c2Ugbm90IGFsbCBjb21iaW5hdGlvbnMgd29yayB3aXRoIHRoZSBoaWVyYXJpY2hpY2FsIHN5c3RlbS5cbiAgICAgIG9wdGlvbnMgPSB0aGlzLmxheW91dEVuZ2luZS5zZXRPcHRpb25zKG9wdGlvbnMubGF5b3V0LCBvcHRpb25zKTtcblxuICAgICAgdGhpcy5jYW52YXMuc2V0T3B0aW9ucyhvcHRpb25zKTsgLy8gb3B0aW9ucyBmb3IgY2FudmFzIGFyZSBpbiBnbG9iYWxzXG5cbiAgICAgIC8vIHBhc3MgdGhlIG9wdGlvbnMgdG8gdGhlIG1vZHVsZXNcbiAgICAgIHRoaXMuZ3JvdXBzLnNldE9wdGlvbnMob3B0aW9ucy5ncm91cHMpO1xuICAgICAgdGhpcy5ub2Rlc0hhbmRsZXIuc2V0T3B0aW9ucyhvcHRpb25zLm5vZGVzKTtcbiAgICAgIHRoaXMuZWRnZXNIYW5kbGVyLnNldE9wdGlvbnMob3B0aW9ucy5lZGdlcyk7XG4gICAgICB0aGlzLnBoeXNpY3Muc2V0T3B0aW9ucyhvcHRpb25zLnBoeXNpY3MpO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb24uc2V0T3B0aW9ucyhvcHRpb25zLm1hbmlwdWxhdGlvbiwgb3B0aW9ucywgdGhpcy5vcHRpb25zKTsgLy8gbWFuaXB1bGF0aW9uIHVzZXMgdGhlIGxvY2FsZXMgaW4gdGhlIGdsb2JhbHNcblxuICAgICAgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXIuc2V0T3B0aW9ucyhvcHRpb25zLmludGVyYWN0aW9uKTtcbiAgICAgIHRoaXMucmVuZGVyZXIuc2V0T3B0aW9ucyhvcHRpb25zLmludGVyYWN0aW9uKTsgLy8gb3B0aW9ucyBmb3IgcmVuZGVyaW5nIGFyZSBpbiBpbnRlcmFjdGlvblxuICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnNldE9wdGlvbnMob3B0aW9ucy5pbnRlcmFjdGlvbik7IC8vIG9wdGlvbnMgZm9yIHNlbGVjdGlvbiBhcmUgaW4gaW50ZXJhY3Rpb25cblxuICAgICAgLy8gcmVsb2FkIHRoZSBzZXR0aW5ncyBvZiB0aGUgbm9kZXMgdG8gYXBwbHkgY2hhbmdlcyBpbiBncm91cHMgdGhhdCBhcmUgbm90IHJlZmVyZW5jZWQgYnkgcG9pbnRlci5cbiAgICAgIGlmIChvcHRpb25zLmdyb3VwcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJyZWZyZXNoTm9kZXNcIik7XG4gICAgICB9XG4gICAgICAvLyB0aGVzZSB0d28gZG8gbm90IGhhdmUgb3B0aW9ucyBhdCB0aGUgbW9tZW50LCBoZXJlIGZvciBjb21wbGV0ZW5lc3NcbiAgICAgIC8vdGhpcy52aWV3LnNldE9wdGlvbnMob3B0aW9ucy52aWV3KTtcbiAgICAgIC8vdGhpcy5jbHVzdGVyaW5nLnNldE9wdGlvbnMob3B0aW9ucy5jbHVzdGVyaW5nKTtcblxuICAgICAgaWYgKCdjb25maWd1cmUnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbmZpZ3VyYXRvcikge1xuICAgICAgICAgIHRoaXMuY29uZmlndXJhdG9yID0gbmV3IF9Db25maWd1cmF0b3IyLmRlZmF1bHQodGhpcywgdGhpcy5ib2R5LmNvbnRhaW5lciwgX29wdGlvbnMuY29uZmlndXJlT3B0aW9ucywgdGhpcy5jYW52YXMucGl4ZWxSYXRpbyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRvci5zZXRPcHRpb25zKG9wdGlvbnMuY29uZmlndXJlKTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgdGhlIGNvbmZpZ3VyYXRpb24gc3lzdGVtIGlzIGVuYWJsZWQsIGNvcHkgYWxsIG9wdGlvbnMgYW5kIHB1dCB0aGVtIGludG8gdGhlIGNvbmZpZyBzeXN0ZW1cbiAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRvciAmJiB0aGlzLmNvbmZpZ3VyYXRvci5vcHRpb25zLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIG5ldHdvcmtPcHRpb25zID0geyBub2Rlczoge30sIGVkZ2VzOiB7fSwgbGF5b3V0OiB7fSwgaW50ZXJhY3Rpb246IHt9LCBtYW5pcHVsYXRpb246IHt9LCBwaHlzaWNzOiB7fSwgZ2xvYmFsOiB7fSB9O1xuICAgICAgICB1dGlsLmRlZXBFeHRlbmQobmV0d29ya09wdGlvbnMubm9kZXMsIHRoaXMubm9kZXNIYW5kbGVyLm9wdGlvbnMpO1xuICAgICAgICB1dGlsLmRlZXBFeHRlbmQobmV0d29ya09wdGlvbnMuZWRnZXMsIHRoaXMuZWRnZXNIYW5kbGVyLm9wdGlvbnMpO1xuICAgICAgICB1dGlsLmRlZXBFeHRlbmQobmV0d29ya09wdGlvbnMubGF5b3V0LCB0aGlzLmxheW91dEVuZ2luZS5vcHRpb25zKTtcbiAgICAgICAgLy8gbG9hZCB0aGUgc2VsZWN0aW9uSGFuZGxlciBhbmQgcmVuZGVyIGRlZmF1bHQgb3B0aW9ucyBpbiB0byB0aGUgaW50ZXJhY3Rpb24gZ3JvdXBcbiAgICAgICAgdXRpbC5kZWVwRXh0ZW5kKG5ldHdvcmtPcHRpb25zLmludGVyYWN0aW9uLCB0aGlzLnNlbGVjdGlvbkhhbmRsZXIub3B0aW9ucyk7XG4gICAgICAgIHV0aWwuZGVlcEV4dGVuZChuZXR3b3JrT3B0aW9ucy5pbnRlcmFjdGlvbiwgdGhpcy5yZW5kZXJlci5vcHRpb25zKTtcblxuICAgICAgICB1dGlsLmRlZXBFeHRlbmQobmV0d29ya09wdGlvbnMuaW50ZXJhY3Rpb24sIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyLm9wdGlvbnMpO1xuICAgICAgICB1dGlsLmRlZXBFeHRlbmQobmV0d29ya09wdGlvbnMubWFuaXB1bGF0aW9uLCB0aGlzLm1hbmlwdWxhdGlvbi5vcHRpb25zKTtcbiAgICAgICAgdXRpbC5kZWVwRXh0ZW5kKG5ldHdvcmtPcHRpb25zLnBoeXNpY3MsIHRoaXMucGh5c2ljcy5vcHRpb25zKTtcblxuICAgICAgICAvLyBsb2FkIGdsb2JhbHMgaW50byB0aGUgZ2xvYmFsIG9iamVjdFxuICAgICAgICB1dGlsLmRlZXBFeHRlbmQobmV0d29ya09wdGlvbnMuZ2xvYmFsLCB0aGlzLmNhbnZhcy5vcHRpb25zKTtcbiAgICAgICAgdXRpbC5kZWVwRXh0ZW5kKG5ldHdvcmtPcHRpb25zLmdsb2JhbCwgdGhpcy5vcHRpb25zKTtcblxuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRvci5zZXRNb2R1bGVPcHRpb25zKG5ldHdvcmtPcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgLy8gaGFuZGxlIG5ldHdvcmsgZ2xvYmFsIG9wdGlvbnNcbiAgICAgIGlmIChvcHRpb25zLmNsaWNrVG9Vc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAob3B0aW9ucy5jbGlja1RvVXNlID09PSB0cnVlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuYWN0aXZhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdG9yID0gbmV3IEFjdGl2YXRvcih0aGlzLmNhbnZhcy5mcmFtZSk7XG4gICAgICAgICAgICB0aGlzLmFjdGl2YXRvci5vbignY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczIuYm9keS5lbWl0dGVyLmVtaXQoXCJhY3RpdmF0ZVwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5hY3RpdmF0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmF0b3IuZGVzdHJveSgpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuYWN0aXZhdG9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiYWN0aXZhdGVcIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJhY3RpdmF0ZVwiKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jYW52YXMuc2V0U2l6ZSgpO1xuICAgICAgLy8gc3RhcnQgdGhlIHBoeXNpY3Mgc2ltdWxhdGlvbi4gQ2FuIGJlIHNhZmVseSBjYWxsZWQgbXVsdGlwbGUgdGltZXMuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwic3RhcnRTaW11bGF0aW9uXCIpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSB0aGlzLmJvZHkubm9kZUluZGljZXMgd2l0aCB0aGUgbW9zdCByZWNlbnQgbm9kZSBpbmRleCBsaXN0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBOZXR3b3JrLnByb3RvdHlwZS5fdXBkYXRlVmlzaWJsZUluZGljZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcbiAgICB0aGlzLmJvZHkubm9kZUluZGljZXMgPSBbXTtcbiAgICB0aGlzLmJvZHkuZWRnZUluZGljZXMgPSBbXTtcblxuICAgIGZvciAodmFyIG5vZGVJZCBpbiBub2Rlcykge1xuICAgICAgaWYgKG5vZGVzLmhhc093blByb3BlcnR5KG5vZGVJZCkpIHtcbiAgICAgICAgaWYgKG5vZGVzW25vZGVJZF0ub3B0aW9ucy5oaWRkZW4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLnB1c2gobm9kZXNbbm9kZUlkXS5pZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBlZGdlSWQgaW4gZWRnZXMpIHtcbiAgICAgIGlmIChlZGdlcy5oYXNPd25Qcm9wZXJ0eShlZGdlSWQpKSB7XG4gICAgICAgIGlmIChlZGdlc1tlZGdlSWRdLm9wdGlvbnMuaGlkZGVuID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMuYm9keS5lZGdlSW5kaWNlcy5wdXNoKGVkZ2VzW2VkZ2VJZF0uaWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBCaW5kIGFsbCBldmVudHNcbiAgICovXG4gIE5ldHdvcmsucHJvdG90eXBlLmJpbmRFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIC8vIHRoaXMgZXZlbnQgd2lsbCB0cmlnZ2VyIGEgcmVidWlsZGluZyBvZiB0aGUgY2FjaGUgZXZlcnl0aGluZy4gVXNlZCB3aGVuIG5vZGVzIG9yIGVkZ2VzIGhhdmUgYmVlbiBhZGRlZCBvciByZW1vdmVkLlxuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2RhdGFDaGFuZ2VkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIHVwZGF0ZSBzaG9ydGN1dCBsaXN0c1xuICAgICAgX3RoaXMzLl91cGRhdGVWaXNpYmxlSW5kaWNlcygpO1xuICAgICAgX3RoaXMzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIik7XG4gICAgICAvLyBjYWxsIHRoZSBkYXRhVXBkYXRlZCBldmVudCBiZWNhdXNlIHRoZSBvbmx5IGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgdHdvIGlzIHRoZSB1cGRhdGluZyBvZiB0aGUgaW5kaWNlc1xuICAgICAgX3RoaXMzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFVcGRhdGVkXCIpO1xuICAgIH0pO1xuXG4gICAgLy8gdGhpcyBpcyBjYWxsZWQgd2hlbiBvcHRpb25zIG9mIEVYSVNUSU5HIG5vZGVzIG9yIGVkZ2VzIGhhdmUgY2hhbmdlZC5cbiAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9kYXRhVXBkYXRlZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyB1cGRhdGUgdmFsdWVzXG4gICAgICBfdGhpczMuX3VwZGF0ZVZhbHVlUmFuZ2UoX3RoaXMzLmJvZHkubm9kZXMpO1xuICAgICAgX3RoaXMzLl91cGRhdGVWYWx1ZVJhbmdlKF90aGlzMy5ib2R5LmVkZ2VzKTtcbiAgICAgIC8vIHN0YXJ0IHNpbXVsYXRpb24gKGNhbiBiZSBjYWxsZWQgc2FmZWx5LCBldmVuIGlmIGFscmVhZHkgcnVubmluZylcbiAgICAgIF90aGlzMy5ib2R5LmVtaXR0ZXIuZW1pdChcInN0YXJ0U2ltdWxhdGlvblwiKTtcbiAgICAgIF90aGlzMy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgbm9kZXMgYW5kIGVkZ2VzLCBhbmQgb3B0aW9uYWxseSBvcHRpb25zIGFzIHdlbGwuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICAgICAgICAgICBPYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJzOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0FycmF5IHwgRGF0YVNldCB8IERhdGFWaWV3fSBbbm9kZXNdIEFycmF5IHdpdGggbm9kZXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtBcnJheSB8IERhdGFTZXQgfCBEYXRhVmlld30gW2VkZ2VzXSBBcnJheSB3aXRoIGVkZ2VzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nfSBbZG90XSBTdHJpbmcgY29udGFpbmluZyBkYXRhIGluIERPVCBmb3JtYXRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmd9IFtnZXBoaV0gU3RyaW5nIGNvbnRhaW5pbmcgZGF0YSBpbiBnZXBoaSBKU09OIGZvcm1hdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge09wdGlvbnN9IFtvcHRpb25zXSBPYmplY3Qgd2l0aCBvcHRpb25zXG4gICAqL1xuICBOZXR3b3JrLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAvLyByZXNldCB0aGUgcGh5c2ljcyBlbmdpbmUuXG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInJlc2V0UGh5c2ljc1wiKTtcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3Jlc2V0RGF0YVwiKTtcblxuICAgIC8vIHVuc2VsZWN0IGFsbCB0byBlbnN1cmUgbm8gc2VsZWN0aW9ucyBmcm9tIG9sZCBkYXRhIGFyZSBjYXJyaWVkIG92ZXIuXG4gICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnVuc2VsZWN0QWxsKCk7XG5cbiAgICBpZiAoZGF0YSAmJiBkYXRhLmRvdCAmJiAoZGF0YS5ub2RlcyB8fCBkYXRhLmVkZ2VzKSkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdEYXRhIG11c3QgY29udGFpbiBlaXRoZXIgcGFyYW1ldGVyIFwiZG90XCIgb3IgJyArICcgcGFyYW1ldGVyIHBhaXIgXCJub2Rlc1wiIGFuZCBcImVkZ2VzXCIsIGJ1dCBub3QgYm90aC4nKTtcbiAgICB9XG5cbiAgICAvLyBzZXQgb3B0aW9uc1xuICAgIHRoaXMuc2V0T3B0aW9ucyhkYXRhICYmIGRhdGEub3B0aW9ucyk7XG4gICAgLy8gc2V0IGFsbCBkYXRhXG4gICAgaWYgKGRhdGEgJiYgZGF0YS5kb3QpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdUaGUgZG90IHByb3BlcnR5IGhhcyBiZWVuIGRlcHJpY2F0ZWQuIFBsZWFzZSB1c2UgdGhlIHN0YXRpYyBjb252ZXJ0RG90IG1ldGhvZCB0byBjb252ZXJ0IERPVCBpbnRvIHZpcy5uZXR3b3JrIGZvcm1hdCBhbmQgdXNlIHRoZSBub3JtYWwgZGF0YSBmb3JtYXQgd2l0aCBub2RlcyBhbmQgZWRnZXMuIFRoaXMgY29udmVydGVyIGlzIHVzZWQgbGlrZSB0aGlzOiB2YXIgZGF0YSA9IHZpcy5uZXR3b3JrLmNvbnZlcnREb3QoZG90U3RyaW5nKTsnKTtcbiAgICAgIC8vIHBhcnNlIERPVCBmaWxlXG4gICAgICB2YXIgZG90RGF0YSA9IGRvdHBhcnNlci5ET1RUb0dyYXBoKGRhdGEuZG90KTtcbiAgICAgIHRoaXMuc2V0RGF0YShkb3REYXRhKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKGRhdGEgJiYgZGF0YS5nZXBoaSkge1xuICAgICAgLy8gcGFyc2UgRE9UIGZpbGVcbiAgICAgIGNvbnNvbGUubG9nKCdUaGUgZ2VwaGkgcHJvcGVydHkgaGFzIGJlZW4gZGVwcmljYXRlZC4gUGxlYXNlIHVzZSB0aGUgc3RhdGljIGNvbnZlcnRHZXBoaSBtZXRob2QgdG8gY29udmVydCBnZXBoaSBpbnRvIHZpcy5uZXR3b3JrIGZvcm1hdCBhbmQgdXNlIHRoZSBub3JtYWwgZGF0YSBmb3JtYXQgd2l0aCBub2RlcyBhbmQgZWRnZXMuIFRoaXMgY29udmVydGVyIGlzIHVzZWQgbGlrZSB0aGlzOiB2YXIgZGF0YSA9IHZpcy5uZXR3b3JrLmNvbnZlcnRHZXBoaShnZXBoaUpzb24pOycpO1xuICAgICAgdmFyIGdlcGhpRGF0YSA9IGdlcGhpUGFyc2VyLnBhcnNlR2VwaGkoZGF0YS5nZXBoaSk7XG4gICAgICB0aGlzLnNldERhdGEoZ2VwaGlEYXRhKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ub2Rlc0hhbmRsZXIuc2V0RGF0YShkYXRhICYmIGRhdGEubm9kZXMsIHRydWUpO1xuICAgICAgdGhpcy5lZGdlc0hhbmRsZXIuc2V0RGF0YShkYXRhICYmIGRhdGEuZWRnZXMsIHRydWUpO1xuICAgIH1cblxuICAgIC8vIGVtaXQgY2hhbmdlIGluIGRhdGFcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuXG4gICAgLy8gZW1pdCBkYXRhIGxvYWRlZFxuICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUxvYWRlZFwiKTtcblxuICAgIC8vIGZpbmQgYSBzdGFibGUgcG9zaXRpb24gb3Igc3RhcnQgYW5pbWF0aW5nIHRvIGEgc3RhYmxlIHBvc2l0aW9uXG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImluaXRQaHlzaWNzXCIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhbnMgdXAgYWxsIGJpbmRpbmdzIG9mIHRoZSBuZXR3b3JrLCByZW1vdmluZyBpdCBmdWxseSBmcm9tIHRoZSBtZW1vcnkgSUYgdGhlIHZhcmlhYmxlIGlzIHNldCB0byBudWxsIGFmdGVyIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi5cbiAgICogdmFyIG5ldHdvcmsgPSBuZXcgdmlzLk5ldHdvcmsoLi4pO1xuICAgKiBuZXR3b3JrLmRlc3Ryb3koKTtcbiAgICogbmV0d29yayA9IG51bGw7XG4gICAqL1xuICBOZXR3b3JrLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJkZXN0cm95XCIpO1xuICAgIC8vIGNsZWFyIGV2ZW50c1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9mZigpO1xuICAgIHRoaXMub2ZmKCk7XG5cbiAgICAvLyBkZWxldGUgbW9kdWxlc1xuICAgIGRlbGV0ZSB0aGlzLmdyb3VwcztcbiAgICBkZWxldGUgdGhpcy5jYW52YXM7XG4gICAgZGVsZXRlIHRoaXMuc2VsZWN0aW9uSGFuZGxlcjtcbiAgICBkZWxldGUgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXI7XG4gICAgZGVsZXRlIHRoaXMudmlldztcbiAgICBkZWxldGUgdGhpcy5yZW5kZXJlcjtcbiAgICBkZWxldGUgdGhpcy5waHlzaWNzO1xuICAgIGRlbGV0ZSB0aGlzLmxheW91dEVuZ2luZTtcbiAgICBkZWxldGUgdGhpcy5jbHVzdGVyaW5nO1xuICAgIGRlbGV0ZSB0aGlzLm1hbmlwdWxhdGlvbjtcbiAgICBkZWxldGUgdGhpcy5ub2Rlc0hhbmRsZXI7XG4gICAgZGVsZXRlIHRoaXMuZWRnZXNIYW5kbGVyO1xuICAgIGRlbGV0ZSB0aGlzLmNvbmZpZ3VyYXRvcjtcbiAgICBkZWxldGUgdGhpcy5pbWFnZXM7XG5cbiAgICBmb3IgKHZhciBub2RlSWQgaW4gdGhpcy5ib2R5Lm5vZGVzKSB7XG4gICAgICBkZWxldGUgdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgfVxuICAgIGZvciAodmFyIGVkZ2VJZCBpbiB0aGlzLmJvZHkuZWRnZXMpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmJvZHkuZWRnZXNbZWRnZUlkXTtcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgdGhlIGNvbnRhaW5lciBhbmQgZXZlcnl0aGluZyBpbnNpZGUgaXQgcmVjdXJzaXZlbHlcbiAgICB1dGlsLnJlY3Vyc2l2ZURPTURlbGV0ZSh0aGlzLmJvZHkuY29udGFpbmVyKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSB2YWx1ZXMgb2YgYWxsIG9iamVjdCBpbiB0aGUgZ2l2ZW4gYXJyYXkgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50XG4gICAqIHZhbHVlIHJhbmdlIG9mIHRoZSBvYmplY3RzIGluIHRoZSBhcnJheS5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAgICBBbiBvYmplY3QgY29udGFpbmluZyBhIHNldCBvZiBFZGdlcyBvciBOb2Rlc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBvYmplY3RzIG11c3QgaGF2ZSBhIG1ldGhvZCBnZXRWYWx1ZSgpIGFuZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlUmFuZ2UobWluLCBtYXgpLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTmV0d29yay5wcm90b3R5cGUuX3VwZGF0ZVZhbHVlUmFuZ2UgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIGlkO1xuXG4gICAgLy8gZGV0ZXJtaW5lIHRoZSByYW5nZSBvZiB0aGUgb2JqZWN0c1xuICAgIHZhciB2YWx1ZU1pbiA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdmFsdWVNYXggPSB1bmRlZmluZWQ7XG4gICAgdmFyIHZhbHVlVG90YWwgPSAwO1xuICAgIGZvciAoaWQgaW4gb2JqKSB7XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmpbaWRdLmdldFZhbHVlKCk7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFsdWVNaW4gPSB2YWx1ZU1pbiA9PT0gdW5kZWZpbmVkID8gdmFsdWUgOiBNYXRoLm1pbih2YWx1ZSwgdmFsdWVNaW4pO1xuICAgICAgICAgIHZhbHVlTWF4ID0gdmFsdWVNYXggPT09IHVuZGVmaW5lZCA/IHZhbHVlIDogTWF0aC5tYXgodmFsdWUsIHZhbHVlTWF4KTtcbiAgICAgICAgICB2YWx1ZVRvdGFsICs9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRqdXN0IHRoZSByYW5nZSBvZiBhbGwgb2JqZWN0c1xuICAgIGlmICh2YWx1ZU1pbiAhPT0gdW5kZWZpbmVkICYmIHZhbHVlTWF4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGZvciAoaWQgaW4gb2JqKSB7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgb2JqW2lkXS5zZXRWYWx1ZVJhbmdlKHZhbHVlTWluLCB2YWx1ZU1heCwgdmFsdWVUb3RhbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSBOZXR3b3JrIGlzIGFjdGl2ZS5cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBOZXR3b3JrLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gIXRoaXMuYWN0aXZhdG9yIHx8IHRoaXMuYWN0aXZhdG9yLmFjdGl2ZTtcbiAgfTtcblxuICBOZXR3b3JrLnByb3RvdHlwZS5zZXRTaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNhbnZhcy5zZXRTaXplLmFwcGx5KHRoaXMuY2FudmFzLCBhcmd1bWVudHMpO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5jYW52YXNUb0RPTSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jYW52YXMuY2FudmFzVG9ET00uYXBwbHkodGhpcy5jYW52YXMsIGFyZ3VtZW50cyk7XG4gIH07XG4gIE5ldHdvcmsucHJvdG90eXBlLkRPTXRvQ2FudmFzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNhbnZhcy5ET010b0NhbnZhcy5hcHBseSh0aGlzLmNhbnZhcywgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuZmluZE5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy5maW5kTm9kZS5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsIGFyZ3VtZW50cyk7XG4gIH07XG4gIE5ldHdvcmsucHJvdG90eXBlLmlzQ2x1c3RlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jbHVzdGVyaW5nLmlzQ2x1c3Rlci5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsIGFyZ3VtZW50cyk7XG4gIH07XG4gIE5ldHdvcmsucHJvdG90eXBlLm9wZW5DbHVzdGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNsdXN0ZXJpbmcub3BlbkNsdXN0ZXIuYXBwbHkodGhpcy5jbHVzdGVyaW5nLCBhcmd1bWVudHMpO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5jbHVzdGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNsdXN0ZXJpbmcuY2x1c3Rlci5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsIGFyZ3VtZW50cyk7XG4gIH07XG4gIE5ldHdvcmsucHJvdG90eXBlLmdldE5vZGVzSW5DbHVzdGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNsdXN0ZXJpbmcuZ2V0Tm9kZXNJbkNsdXN0ZXIuYXBwbHkodGhpcy5jbHVzdGVyaW5nLCBhcmd1bWVudHMpO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5jbHVzdGVyQnlDb25uZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNsdXN0ZXJpbmcuY2x1c3RlckJ5Q29ubmVjdGlvbi5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsIGFyZ3VtZW50cyk7XG4gIH07XG4gIE5ldHdvcmsucHJvdG90eXBlLmNsdXN0ZXJCeUh1YnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy5jbHVzdGVyQnlIdWJzaXplLmFwcGx5KHRoaXMuY2x1c3RlcmluZywgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuY2x1c3Rlck91dGxpZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNsdXN0ZXJpbmcuY2x1c3Rlck91dGxpZXJzLmFwcGx5KHRoaXMuY2x1c3RlcmluZywgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuZ2V0U2VlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5sYXlvdXRFbmdpbmUuZ2V0U2VlZC5hcHBseSh0aGlzLmxheW91dEVuZ2luZSwgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuZW5hYmxlRWRpdE1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmVuYWJsZUVkaXRNb2RlLmFwcGx5KHRoaXMubWFuaXB1bGF0aW9uLCBhcmd1bWVudHMpO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5kaXNhYmxlRWRpdE1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmRpc2FibGVFZGl0TW9kZS5hcHBseSh0aGlzLm1hbmlwdWxhdGlvbiwgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuYWRkTm9kZU1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmFkZE5vZGVNb2RlLmFwcGx5KHRoaXMubWFuaXB1bGF0aW9uLCBhcmd1bWVudHMpO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5lZGl0Tm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5tYW5pcHVsYXRpb24uZWRpdE5vZGUuYXBwbHkodGhpcy5tYW5pcHVsYXRpb24sIGFyZ3VtZW50cyk7XG4gIH07XG4gIE5ldHdvcmsucHJvdG90eXBlLmVkaXROb2RlTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zb2xlLmxvZyhcIkRlcHJlY2F0ZWQ6IFBsZWFzZSB1c2UgZWRpdE5vZGUgaW5zdGVhZCBvZiBlZGl0Tm9kZU1vZGUuXCIpO3JldHVybiB0aGlzLm1hbmlwdWxhdGlvbi5lZGl0Tm9kZS5hcHBseSh0aGlzLm1hbmlwdWxhdGlvbiwgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuYWRkRWRnZU1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmFkZEVkZ2VNb2RlLmFwcGx5KHRoaXMubWFuaXB1bGF0aW9uLCBhcmd1bWVudHMpO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5lZGl0RWRnZU1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmVkaXRFZGdlTW9kZS5hcHBseSh0aGlzLm1hbmlwdWxhdGlvbiwgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuZGVsZXRlU2VsZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmRlbGV0ZVNlbGVjdGVkLmFwcGx5KHRoaXMubWFuaXB1bGF0aW9uLCBhcmd1bWVudHMpO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5nZXRQb3NpdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXNIYW5kbGVyLmdldFBvc2l0aW9ucy5hcHBseSh0aGlzLm5vZGVzSGFuZGxlciwgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuc3RvcmVQb3NpdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXNIYW5kbGVyLnN0b3JlUG9zaXRpb25zLmFwcGx5KHRoaXMubm9kZXNIYW5kbGVyLCBhcmd1bWVudHMpO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5tb3ZlTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlc0hhbmRsZXIubW92ZU5vZGUuYXBwbHkodGhpcy5ub2Rlc0hhbmRsZXIsIGFyZ3VtZW50cyk7XG4gIH07XG4gIE5ldHdvcmsucHJvdG90eXBlLmdldEJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzSGFuZGxlci5nZXRCb3VuZGluZ0JveC5hcHBseSh0aGlzLm5vZGVzSGFuZGxlciwgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuZ2V0Q29ubmVjdGVkTm9kZXMgPSBmdW5jdGlvbiAob2JqZWN0SWQpIHtcbiAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW29iamVjdElkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlc0hhbmRsZXIuZ2V0Q29ubmVjdGVkTm9kZXMuYXBwbHkodGhpcy5ub2Rlc0hhbmRsZXIsIGFyZ3VtZW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmVkZ2VzSGFuZGxlci5nZXRDb25uZWN0ZWROb2Rlcy5hcHBseSh0aGlzLmVkZ2VzSGFuZGxlciwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH07XG4gIE5ldHdvcmsucHJvdG90eXBlLmdldENvbm5lY3RlZEVkZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzSGFuZGxlci5nZXRDb25uZWN0ZWRFZGdlcy5hcHBseSh0aGlzLm5vZGVzSGFuZGxlciwgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuc3RhcnRTaW11bGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnBoeXNpY3Muc3RhcnRTaW11bGF0aW9uLmFwcGx5KHRoaXMucGh5c2ljcywgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuc3RvcFNpbXVsYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucGh5c2ljcy5zdG9wU2ltdWxhdGlvbi5hcHBseSh0aGlzLnBoeXNpY3MsIGFyZ3VtZW50cyk7XG4gIH07XG4gIE5ldHdvcmsucHJvdG90eXBlLnN0YWJpbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5waHlzaWNzLnN0YWJpbGl6ZS5hcHBseSh0aGlzLnBoeXNpY3MsIGFyZ3VtZW50cyk7XG4gIH07XG4gIE5ldHdvcmsucHJvdG90eXBlLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldFNlbGVjdGlvbi5hcHBseSh0aGlzLnNlbGVjdGlvbkhhbmRsZXIsIGFyZ3VtZW50cyk7XG4gIH07XG4gIE5ldHdvcmsucHJvdG90eXBlLnNldFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnNldFNlbGVjdGlvbi5hcHBseSh0aGlzLnNlbGVjdGlvbkhhbmRsZXIsIGFyZ3VtZW50cyk7XG4gIH07XG4gIE5ldHdvcmsucHJvdG90eXBlLmdldFNlbGVjdGVkTm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRTZWxlY3RlZE5vZGVzLmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlciwgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuZ2V0U2VsZWN0ZWRFZGdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldFNlbGVjdGVkRWRnZXMuYXBwbHkodGhpcy5zZWxlY3Rpb25IYW5kbGVyLCBhcmd1bWVudHMpO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5nZXROb2RlQXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0Tm9kZUF0LmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlciwgYXJndW1lbnRzKTtcbiAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkICYmIG5vZGUuaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG5vZGUuaWQ7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5nZXRFZGdlQXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVkZ2UgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0RWRnZUF0LmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlciwgYXJndW1lbnRzKTtcbiAgICBpZiAoZWRnZSAhPT0gdW5kZWZpbmVkICYmIGVkZ2UuaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGVkZ2UuaWQ7XG4gICAgfVxuICAgIHJldHVybiBlZGdlO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5zZWxlY3ROb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnNlbGVjdE5vZGVzLmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlciwgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuc2VsZWN0RWRnZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5zZWxlY3RFZGdlcy5hcHBseSh0aGlzLnNlbGVjdGlvbkhhbmRsZXIsIGFyZ3VtZW50cyk7XG4gIH07XG4gIE5ldHdvcmsucHJvdG90eXBlLnVuc2VsZWN0QWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci51bnNlbGVjdEFsbC5hcHBseSh0aGlzLnNlbGVjdGlvbkhhbmRsZXIsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5yZWRyYXcoKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLnJlZHJhdy5hcHBseSh0aGlzLnJlbmRlcmVyLCBhcmd1bWVudHMpO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5nZXRTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3LmdldFNjYWxlLmFwcGx5KHRoaXMudmlldywgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuZ2V0Vmlld1Bvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnZpZXcuZ2V0Vmlld1Bvc2l0aW9uLmFwcGx5KHRoaXMudmlldywgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuZml0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnZpZXcuZml0LmFwcGx5KHRoaXMudmlldywgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnZpZXcubW92ZVRvLmFwcGx5KHRoaXMudmlldywgYXJndW1lbnRzKTtcbiAgfTtcbiAgTmV0d29yay5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5mb2N1cy5hcHBseSh0aGlzLnZpZXcsIGFyZ3VtZW50cyk7XG4gIH07XG4gIE5ldHdvcmsucHJvdG90eXBlLnJlbGVhc2VOb2RlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnZpZXcucmVsZWFzZU5vZGUuYXBwbHkodGhpcy52aWV3LCBhcmd1bWVudHMpO1xuICB9O1xuICBOZXR3b3JrLnByb3RvdHlwZS5nZXRPcHRpb25zRnJvbUNvbmZpZ3VyYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRvcikge1xuICAgICAgb3B0aW9ucyA9IHRoaXMuY29uZmlndXJhdG9yLmdldE9wdGlvbnMuYXBwbHkodGhpcy5jb25maWd1cmF0b3IpO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IE5ldHdvcms7XG5cbi8qKiovIH0sXG4vKiA2MiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgLyoqXG4gICAqIEBjbGFzcyBJbWFnZXNcbiAgICogVGhpcyBjbGFzcyBsb2FkcyBpbWFnZXMgYW5kIGtlZXBzIHRoZW0gc3RvcmVkLlxuICAgKi9cblxuICB2YXIgSW1hZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gSW1hZ2VzKGNhbGxiYWNrKSB7XG4gICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEltYWdlcyk7XG5cbiAgICAgICAgICB0aGlzLmltYWdlcyA9IHt9O1xuICAgICAgICAgIHRoaXMuaW1hZ2VCcm9rZW4gPSB7fTtcbiAgICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAgICAgICAgICAgICAgICAgICAgICBUaGUgVXJsIHRvIGNhY2hlIHRoZSBpbWFnZSBhcyBcbiAgICAgICAgKiBAcmV0dXJuIHtJbWFnZX0gaW1hZ2VUb0xvYWRCcm9rZW5VcmxPbiAgVGhlIGltYWdlIG9iamVjdFxuICAgICAgICovXG5cblxuICAgICAgX2NyZWF0ZUNsYXNzKEltYWdlcywgW3tcbiAgICAgICAgICBrZXk6IFwiX2FkZEltYWdlVG9DYWNoZVwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkSW1hZ2VUb0NhY2hlKHVybCwgaW1hZ2VUb0NhY2hlKSB7XG4gICAgICAgICAgICAgIC8vIElFMTEgZml4IC0tIHRoYW5rcyBkcG9uY2ghXG4gICAgICAgICAgICAgIGlmIChpbWFnZVRvQ2FjaGUud2lkdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaW1hZ2VUb0NhY2hlKTtcbiAgICAgICAgICAgICAgICAgIGltYWdlVG9DYWNoZS53aWR0aCA9IGltYWdlVG9DYWNoZS5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgICAgICAgIGltYWdlVG9DYWNoZS5oZWlnaHQgPSBpbWFnZVRvQ2FjaGUub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChpbWFnZVRvQ2FjaGUpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5pbWFnZXNbdXJsXSA9IGltYWdlVG9DYWNoZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsICAgICAgICAgICAgICAgICAgICAgIFRoZSBvcmlnaW5hbCBVcmwgdGhhdCBmYWlsZWQgdG8gbG9hZCwgaWYgdGhlIGJyb2tlbiBpbWFnZSBpcyBzdWNjZXNzZnVsbHkgbG9hZGVkIGl0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIGNhY2hlIHVzaW5nIHRoaXMgVXJsIGFzIHRoZSBrZXkgc28gdGhhdCBzdWJzZXF1ZW50IHJlcXVlc3RzIGZvciB0aGlzIFVybCB3aWxsIHJldHVybiB0aGUgYnJva2VuIGltYWdlXG4gICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGJyb2tlblVybCAgICAgICAgICAgICAgICBVcmwgdGhlIGJyb2tlbiBpbWFnZSB0byB0cnkgYW5kIGxvYWRcbiAgICAgICAgICAgKiBAcmV0dXJuIHtJbWFnZX0gaW1hZ2VUb0xvYWRCcm9rZW5VcmxPbiAgIFRoZSBpbWFnZSBvYmplY3RcbiAgICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJfdHJ5bG9hZEJyb2tlblVybFwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdHJ5bG9hZEJyb2tlblVybCh1cmwsIGJyb2tlblVybCwgaW1hZ2VUb0xvYWRCcm9rZW5VcmxPbikge1xuICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgICAgICAgIC8vSWYgYW55IG9mIHRoZSBwYXJhbWV0ZXJzIGFyZW4ndCBzcGVjaWZpZWQgdGhlbiBleGl0IHRoZSBmdW5jdGlvbiBiZWNhdXNlIG5vdGhpbmcgY29uc3RydWN0aXZlIGNhbiBiZSBkb25lXG4gICAgICAgICAgICAgIGlmICh1cmwgPT09IHVuZGVmaW5lZCB8fCBicm9rZW5VcmwgPT09IHVuZGVmaW5lZCB8fCBpbWFnZVRvTG9hZEJyb2tlblVybE9uID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgICAgICAgICAgICAvL0NsZWFyIHRoZSBvbGQgc3Vic2NyaXB0aW9uIHRvIHRoZSBlcnJvciBldmVudCBhbmQgcHV0IGEgbmV3IGluIHBsYWNlIHRoYXQgb25seSBoYW5kbGUgZXJyb3JzIGluIGxvYWRpbmcgdGhlIGJyb2tlbkltYWdlVXJsXG4gICAgICAgICAgICAgIGltYWdlVG9Mb2FkQnJva2VuVXJsT24ub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDb3VsZCBub3QgbG9hZCBicm9rZW5JbWFnZTpcIiwgYnJva2VuVXJsKTtcbiAgICAgICAgICAgICAgICAgIC8vQWRkIGFuIGVtcHR5IGltYWdlIHRvIHRoZSBjYWNoZSBzbyB0aGF0IHdoZW4gc3Vic2VxdWVudCBsb2FkIGNhbGxzIGFyZSBtYWRlIGZvciB0aGUgdXJsIHdlIGRvbid0IHRyeSBsb2FkIHRoZSBpbWFnZSBhbmQgYnJva2VuIGltYWdlIGFnYWluXG4gICAgICAgICAgICAgICAgICBfdGhpcy5fYWRkSW1hZ2VUb0NhY2hlKHVybCwgbmV3IEltYWdlKCkpO1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIC8vU2V0IHRoZSBzb3VyY2Ugb2YgdGhlIGltYWdlIHRvIHRoZSBicm9rZW5VcmwsIHRoaXMgaXMgYWN0dWFsbHkgd2hhdCBraWNrcyBvZmYgdGhlIGxvYWRpbmcgb2YgdGhlIGJyb2tlbiBpbWFnZVxuICAgICAgICAgICAgICBpbWFnZVRvTG9hZEJyb2tlblVybE9uLnNyYyA9IGJyb2tlblVybDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBAcmV0dXJuIHtJbWFnZX0gaW1hZ2VUb1JlZHJhd1dpdGggVGhlIGltYWdlcyB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBjYWxsYmFjayB3aGVuIGl0IGlzIGludm9rZWRcbiAgICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJfcmVkcmF3V2l0aEltYWdlXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWRyYXdXaXRoSW1hZ2UoaW1hZ2VUb1JlZHJhd1dpdGgpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2soaW1hZ2VUb1JlZHJhd1dpdGgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAgICAgICAgICBVcmwgb2YgdGhlIGltYWdlXG4gICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGJyb2tlblVybCAgICBVcmwgb2YgYW4gaW1hZ2UgdG8gdXNlIGlmIHRoZSB1cmwgaW1hZ2UgaXMgbm90IGZvdW5kXG4gICAgICAgICAgICogQHJldHVybiB7SW1hZ2V9IGltZyAgICAgICAgICBUaGUgaW1hZ2Ugb2JqZWN0XG4gICAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwibG9hZFwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkKHVybCwgYnJva2VuVXJsLCBpZCkge1xuICAgICAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAgICAgICAvL1RyeSBhbmQgZ2V0IHRoZSBpbWFnZSBmcm9tIHRoZSBjYWNoZSwgaWYgc3VjY2Vzc2Z1bCB0aGVuIHJldHVybiB0aGUgY2FjaGVkIGltYWdlICBcbiAgICAgICAgICAgICAgdmFyIGNhY2hlZEltYWdlID0gdGhpcy5pbWFnZXNbdXJsXTtcbiAgICAgICAgICAgICAgaWYgKGNhY2hlZEltYWdlKSByZXR1cm4gY2FjaGVkSW1hZ2U7XG5cbiAgICAgICAgICAgICAgLy9DcmVhdGUgYSBuZXcgaW1hZ2VcbiAgICAgICAgICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuXG4gICAgICAgICAgICAgIC8vU3Vic2NyaWJlIHRvIHRoZSBldmVudCB0aGF0IGlzIHJhaXNlZCBpZiB0aGUgaW1hZ2UgbG9hZHMgc3VjY2Vzc2Z1bGx5XG4gICAgICAgICAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAvL0FkZCB0aGUgaW1hZ2UgdG8gdGhlIGNhY2hlIGFuZCB0aGVuIHJlcXVlc3QgYSByZWRyYXdcbiAgICAgICAgICAgICAgICAgIF90aGlzMi5fYWRkSW1hZ2VUb0NhY2hlKHVybCwgaW1nKTtcbiAgICAgICAgICAgICAgICAgIF90aGlzMi5fcmVkcmF3V2l0aEltYWdlKGltZyk7XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgLy9TdWJzY3JpYmUgdG8gdGhlIGV2ZW50IHRoYXQgaXMgcmFpc2VkIGlmIHRoZSBpbWFnZSBmYWlscyB0byBsb2FkXG4gICAgICAgICAgICAgIGltZy5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkNvdWxkIG5vdCBsb2FkIGltYWdlOlwiLCB1cmwpO1xuICAgICAgICAgICAgICAgICAgLy9UcnkgYW5kIGxvYWQgdGhlIGltYWdlIHNwZWNpZmllZCBieSB0aGUgYnJva2VuVXJsIHVzaW5nXG4gICAgICAgICAgICAgICAgICBfdGhpczIuX3RyeWxvYWRCcm9rZW5VcmwodXJsLCBicm9rZW5VcmwsIGltZyk7XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgLy9TZXQgdGhlIHNvdXJjZSBvZiB0aGUgaW1hZ2UgdG8gdGhlIHVybCwgdGhpcyBpcyBhY3R1YWxsIHdoYXQga2lja3Mgb2ZmIHRoZSBsb2FkaW5nIG9mIHRoZSBpbWFnZVxuICAgICAgICAgICAgICBpbWcuc3JjID0gdXJsO1xuXG4gICAgICAgICAgICAgIC8vUmV0dXJuIHRoZSBuZXcgaW1hZ2VcbiAgICAgICAgICAgICAgcmV0dXJuIGltZztcbiAgICAgICAgICB9XG4gICAgICB9XSk7XG5cbiAgICAgIHJldHVybiBJbWFnZXM7XG4gIH0oKTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBJbWFnZXM7XG5cbi8qKiovIH0sXG4vKiA2MyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuICAvKipcbiAgICogQGNsYXNzIEdyb3Vwc1xuICAgKiBUaGlzIGNsYXNzIGNhbiBzdG9yZSBncm91cHMgYW5kIG9wdGlvbnMgc3BlY2lmaWMgZm9yIGdyb3Vwcy5cbiAgICovXG5cbiAgdmFyIEdyb3VwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHcm91cHMoKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgR3JvdXBzKTtcblxuICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgdGhpcy5kZWZhdWx0SW5kZXggPSAwO1xuICAgICAgdGhpcy5ncm91cHNBcnJheSA9IFtdO1xuICAgICAgdGhpcy5ncm91cEluZGV4ID0gMDtcblxuICAgICAgdGhpcy5kZWZhdWx0R3JvdXBzID0gW3sgYm9yZGVyOiBcIiMyQjdDRTlcIiwgYmFja2dyb3VuZDogXCIjOTdDMkZDXCIsIGhpZ2hsaWdodDogeyBib3JkZXI6IFwiIzJCN0NFOVwiLCBiYWNrZ3JvdW5kOiBcIiNEMkU1RkZcIiB9LCBob3ZlcjogeyBib3JkZXI6IFwiIzJCN0NFOVwiLCBiYWNrZ3JvdW5kOiBcIiNEMkU1RkZcIiB9IH0sIC8vIDA6IGJsdWVcbiAgICAgIHsgYm9yZGVyOiBcIiNGRkE1MDBcIiwgYmFja2dyb3VuZDogXCIjRkZGRjAwXCIsIGhpZ2hsaWdodDogeyBib3JkZXI6IFwiI0ZGQTUwMFwiLCBiYWNrZ3JvdW5kOiBcIiNGRkZGQTNcIiB9LCBob3ZlcjogeyBib3JkZXI6IFwiI0ZGQTUwMFwiLCBiYWNrZ3JvdW5kOiBcIiNGRkZGQTNcIiB9IH0sIC8vIDE6IHllbGxvd1xuICAgICAgeyBib3JkZXI6IFwiI0ZBMEExMFwiLCBiYWNrZ3JvdW5kOiBcIiNGQjdFODFcIiwgaGlnaGxpZ2h0OiB7IGJvcmRlcjogXCIjRkEwQTEwXCIsIGJhY2tncm91bmQ6IFwiI0ZGQUZCMVwiIH0sIGhvdmVyOiB7IGJvcmRlcjogXCIjRkEwQTEwXCIsIGJhY2tncm91bmQ6IFwiI0ZGQUZCMVwiIH0gfSwgLy8gMjogcmVkXG4gICAgICB7IGJvcmRlcjogXCIjNDFBOTA2XCIsIGJhY2tncm91bmQ6IFwiIzdCRTE0MVwiLCBoaWdobGlnaHQ6IHsgYm9yZGVyOiBcIiM0MUE5MDZcIiwgYmFja2dyb3VuZDogXCIjQTFFQzc2XCIgfSwgaG92ZXI6IHsgYm9yZGVyOiBcIiM0MUE5MDZcIiwgYmFja2dyb3VuZDogXCIjQTFFQzc2XCIgfSB9LCAvLyAzOiBncmVlblxuICAgICAgeyBib3JkZXI6IFwiI0UxMjlGMFwiLCBiYWNrZ3JvdW5kOiBcIiNFQjdERjRcIiwgaGlnaGxpZ2h0OiB7IGJvcmRlcjogXCIjRTEyOUYwXCIsIGJhY2tncm91bmQ6IFwiI0YwQjNGNVwiIH0sIGhvdmVyOiB7IGJvcmRlcjogXCIjRTEyOUYwXCIsIGJhY2tncm91bmQ6IFwiI0YwQjNGNVwiIH0gfSwgLy8gNDogbWFnZW50YVxuICAgICAgeyBib3JkZXI6IFwiIzdDMjlGMFwiLCBiYWNrZ3JvdW5kOiBcIiNBRDg1RTRcIiwgaGlnaGxpZ2h0OiB7IGJvcmRlcjogXCIjN0MyOUYwXCIsIGJhY2tncm91bmQ6IFwiI0QzQkRGMFwiIH0sIGhvdmVyOiB7IGJvcmRlcjogXCIjN0MyOUYwXCIsIGJhY2tncm91bmQ6IFwiI0QzQkRGMFwiIH0gfSwgLy8gNTogcHVycGxlXG4gICAgICB7IGJvcmRlcjogXCIjQzM3RjAwXCIsIGJhY2tncm91bmQ6IFwiI0ZGQTgwN1wiLCBoaWdobGlnaHQ6IHsgYm9yZGVyOiBcIiNDMzdGMDBcIiwgYmFja2dyb3VuZDogXCIjRkZDQTY2XCIgfSwgaG92ZXI6IHsgYm9yZGVyOiBcIiNDMzdGMDBcIiwgYmFja2dyb3VuZDogXCIjRkZDQTY2XCIgfSB9LCAvLyA2OiBvcmFuZ2VcbiAgICAgIHsgYm9yZGVyOiBcIiM0MjIwRkJcIiwgYmFja2dyb3VuZDogXCIjNkU2RUZEXCIsIGhpZ2hsaWdodDogeyBib3JkZXI6IFwiIzQyMjBGQlwiLCBiYWNrZ3JvdW5kOiBcIiM5QjlCRkRcIiB9LCBob3ZlcjogeyBib3JkZXI6IFwiIzQyMjBGQlwiLCBiYWNrZ3JvdW5kOiBcIiM5QjlCRkRcIiB9IH0sIC8vIDc6IGRhcmtibHVlXG4gICAgICB7IGJvcmRlcjogXCIjRkQ1QTc3XCIsIGJhY2tncm91bmQ6IFwiI0ZGQzBDQlwiLCBoaWdobGlnaHQ6IHsgYm9yZGVyOiBcIiNGRDVBNzdcIiwgYmFja2dyb3VuZDogXCIjRkZEMUQ5XCIgfSwgaG92ZXI6IHsgYm9yZGVyOiBcIiNGRDVBNzdcIiwgYmFja2dyb3VuZDogXCIjRkZEMUQ5XCIgfSB9LCAvLyA4OiBwaW5rXG4gICAgICB7IGJvcmRlcjogXCIjNEFENjNBXCIsIGJhY2tncm91bmQ6IFwiI0MyRkFCQ1wiLCBoaWdobGlnaHQ6IHsgYm9yZGVyOiBcIiM0QUQ2M0FcIiwgYmFja2dyb3VuZDogXCIjRTZGRkUzXCIgfSwgaG92ZXI6IHsgYm9yZGVyOiBcIiM0QUQ2M0FcIiwgYmFja2dyb3VuZDogXCIjRTZGRkUzXCIgfSB9LCAvLyA5OiBtaW50XG5cbiAgICAgIHsgYm9yZGVyOiBcIiM5OTAwMDBcIiwgYmFja2dyb3VuZDogXCIjRUUwMDAwXCIsIGhpZ2hsaWdodDogeyBib3JkZXI6IFwiI0JCMDAwMFwiLCBiYWNrZ3JvdW5kOiBcIiNGRjMzMzNcIiB9LCBob3ZlcjogeyBib3JkZXI6IFwiI0JCMDAwMFwiLCBiYWNrZ3JvdW5kOiBcIiNGRjMzMzNcIiB9IH0sIC8vIDEwOmJyaWdodCByZWRcblxuICAgICAgeyBib3JkZXI6IFwiI0ZGNjAwMFwiLCBiYWNrZ3JvdW5kOiBcIiNGRjYwMDBcIiwgaGlnaGxpZ2h0OiB7IGJvcmRlcjogXCIjRkY2MDAwXCIsIGJhY2tncm91bmQ6IFwiI0ZGNjAwMFwiIH0sIGhvdmVyOiB7IGJvcmRlcjogXCIjRkY2MDAwXCIsIGJhY2tncm91bmQ6IFwiI0ZGNjAwMFwiIH0gfSwgLy8gMTI6IHJlYWwgb3JhbmdlXG4gICAgICB7IGJvcmRlcjogXCIjOTdDMkZDXCIsIGJhY2tncm91bmQ6IFwiIzJCN0NFOVwiLCBoaWdobGlnaHQ6IHsgYm9yZGVyOiBcIiNEMkU1RkZcIiwgYmFja2dyb3VuZDogXCIjMkI3Q0U5XCIgfSwgaG92ZXI6IHsgYm9yZGVyOiBcIiNEMkU1RkZcIiwgYmFja2dyb3VuZDogXCIjMkI3Q0U5XCIgfSB9LCAvLyAxMzogYmx1ZVxuICAgICAgeyBib3JkZXI6IFwiIzM5OTYwNVwiLCBiYWNrZ3JvdW5kOiBcIiMyNTVDMDNcIiwgaGlnaGxpZ2h0OiB7IGJvcmRlcjogXCIjMzk5NjA1XCIsIGJhY2tncm91bmQ6IFwiIzI1NUMwM1wiIH0sIGhvdmVyOiB7IGJvcmRlcjogXCIjMzk5NjA1XCIsIGJhY2tncm91bmQ6IFwiIzI1NUMwM1wiIH0gfSwgLy8gMTQ6IGdyZWVuXG4gICAgICB7IGJvcmRlcjogXCIjQjcwMDU0XCIsIGJhY2tncm91bmQ6IFwiI0ZGMDA3RVwiLCBoaWdobGlnaHQ6IHsgYm9yZGVyOiBcIiNCNzAwNTRcIiwgYmFja2dyb3VuZDogXCIjRkYwMDdFXCIgfSwgaG92ZXI6IHsgYm9yZGVyOiBcIiNCNzAwNTRcIiwgYmFja2dyb3VuZDogXCIjRkYwMDdFXCIgfSB9LCAvLyAxNTogbWFnZW50YVxuICAgICAgeyBib3JkZXI6IFwiI0FEODVFNFwiLCBiYWNrZ3JvdW5kOiBcIiM3QzI5RjBcIiwgaGlnaGxpZ2h0OiB7IGJvcmRlcjogXCIjRDNCREYwXCIsIGJhY2tncm91bmQ6IFwiIzdDMjlGMFwiIH0sIGhvdmVyOiB7IGJvcmRlcjogXCIjRDNCREYwXCIsIGJhY2tncm91bmQ6IFwiIzdDMjlGMFwiIH0gfSwgLy8gMTY6IHB1cnBsZVxuICAgICAgeyBib3JkZXI6IFwiIzQ1NTdGQVwiLCBiYWNrZ3JvdW5kOiBcIiMwMDBFQTFcIiwgaGlnaGxpZ2h0OiB7IGJvcmRlcjogXCIjNkU2RUZEXCIsIGJhY2tncm91bmQ6IFwiIzAwMEVBMVwiIH0sIGhvdmVyOiB7IGJvcmRlcjogXCIjNkU2RUZEXCIsIGJhY2tncm91bmQ6IFwiIzAwMEVBMVwiIH0gfSwgLy8gMTc6IGRhcmtibHVlXG4gICAgICB7IGJvcmRlcjogXCIjRkZDMENCXCIsIGJhY2tncm91bmQ6IFwiI0ZENUE3N1wiLCBoaWdobGlnaHQ6IHsgYm9yZGVyOiBcIiNGRkQxRDlcIiwgYmFja2dyb3VuZDogXCIjRkQ1QTc3XCIgfSwgaG92ZXI6IHsgYm9yZGVyOiBcIiNGRkQxRDlcIiwgYmFja2dyb3VuZDogXCIjRkQ1QTc3XCIgfSB9LCAvLyAxODogcGlua1xuICAgICAgeyBib3JkZXI6IFwiI0MyRkFCQ1wiLCBiYWNrZ3JvdW5kOiBcIiM3NEQ2NkFcIiwgaGlnaGxpZ2h0OiB7IGJvcmRlcjogXCIjRTZGRkUzXCIsIGJhY2tncm91bmQ6IFwiIzc0RDY2QVwiIH0sIGhvdmVyOiB7IGJvcmRlcjogXCIjRTZGRkUzXCIsIGJhY2tncm91bmQ6IFwiIzc0RDY2QVwiIH0gfSwgLy8gMTk6IG1pbnRcblxuICAgICAgeyBib3JkZXI6IFwiI0VFMDAwMFwiLCBiYWNrZ3JvdW5kOiBcIiM5OTAwMDBcIiwgaGlnaGxpZ2h0OiB7IGJvcmRlcjogXCIjRkYzMzMzXCIsIGJhY2tncm91bmQ6IFwiI0JCMDAwMFwiIH0sIGhvdmVyOiB7IGJvcmRlcjogXCIjRkYzMzMzXCIsIGJhY2tncm91bmQ6IFwiI0JCMDAwMFwiIH0gfSAvLyAyMDpicmlnaHQgcmVkXG4gICAgICBdO1xuXG4gICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICAgIHVzZURlZmF1bHRHcm91cHM6IHRydWVcbiAgICAgIH07XG4gICAgICB1dGlsLmV4dGVuZCh0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhHcm91cHMsIFt7XG4gICAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB2YXIgb3B0aW9uRmllbGRzID0gWyd1c2VEZWZhdWx0R3JvdXBzJ107XG5cbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGZvciAodmFyIGdyb3VwTmFtZSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShncm91cE5hbWUpKSB7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25GaWVsZHMuaW5kZXhPZihncm91cE5hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHZhciBncm91cCA9IG9wdGlvbnNbZ3JvdXBOYW1lXTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChncm91cE5hbWUsIGdyb3VwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENsZWFyIGFsbCBncm91cHNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImNsZWFyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgICAgIHRoaXMuZ3JvdXBzQXJyYXkgPSBbXTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBnZXQgZ3JvdXAgb3B0aW9ucyBvZiBhIGdyb3VwbmFtZS4gSWYgZ3JvdXBuYW1lIGlzIG5vdCBmb3VuZCwgYSBuZXcgZ3JvdXBcbiAgICAgICAqIGlzIGFkZGVkLlxuICAgICAgICogQHBhcmFtIHsqfSBncm91cG5hbWUgICAgICAgIENhbiBiZSBhIG51bWJlciwgc3RyaW5nLCBEYXRlLCBldGMuXG4gICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGdyb3VwICAgICAgVGhlIGNyZWF0ZWQgZ3JvdXAsIGNvbnRhaW5pbmcgYWxsIGdyb3VwIG9wdGlvbnNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImdldFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldChncm91cG5hbWUpIHtcbiAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cHNbZ3JvdXBuYW1lXTtcbiAgICAgICAgaWYgKGdyb3VwID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnVzZURlZmF1bHRHcm91cHMgPT09IGZhbHNlICYmIHRoaXMuZ3JvdXBzQXJyYXkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gY3JlYXRlIG5ldyBncm91cFxuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5ncm91cEluZGV4ICUgdGhpcy5ncm91cHNBcnJheS5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLmdyb3VwSW5kZXgrKztcbiAgICAgICAgICAgIGdyb3VwID0ge307XG4gICAgICAgICAgICBncm91cC5jb2xvciA9IHRoaXMuZ3JvdXBzW3RoaXMuZ3JvdXBzQXJyYXlbaW5kZXhdXTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwbmFtZV0gPSBncm91cDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY3JlYXRlIG5ldyBncm91cFxuICAgICAgICAgICAgdmFyIF9pbmRleCA9IHRoaXMuZGVmYXVsdEluZGV4ICUgdGhpcy5kZWZhdWx0R3JvdXBzLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdEluZGV4Kys7XG4gICAgICAgICAgICBncm91cCA9IHt9O1xuICAgICAgICAgICAgZ3JvdXAuY29sb3IgPSB0aGlzLmRlZmF1bHRHcm91cHNbX2luZGV4XTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2dyb3VwbmFtZV0gPSBncm91cDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQWRkIGEgY3VzdG9tIGdyb3VwIHN0eWxlXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZ3JvdXBOYW1lXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGUgICAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgYm9yZGVyQ29sb3IsXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yLCBldGMuXG4gICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGdyb3VwICAgICAgVGhlIGNyZWF0ZWQgZ3JvdXAgb2JqZWN0XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJhZGRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoZ3JvdXBOYW1lLCBzdHlsZSkge1xuICAgICAgICB0aGlzLmdyb3Vwc1tncm91cE5hbWVdID0gc3R5bGU7XG4gICAgICAgIHRoaXMuZ3JvdXBzQXJyYXkucHVzaChncm91cE5hbWUpO1xuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEdyb3VwcztcbiAgfSgpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IEdyb3VwcztcblxuLyoqKi8gfSxcbi8qIDY0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX05vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1KTtcblxuICB2YXIgX05vZGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTm9kZSk7XG5cbiAgdmFyIF9MYWJlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNjYpO1xuXG4gIHZhciBfTGFiZWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTGFiZWwpO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4gIHZhciBEYXRhU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcbiAgdmFyIERhdGFWaWV3ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cbiAgdmFyIE5vZGVzSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb2Rlc0hhbmRsZXIoYm9keSwgaW1hZ2VzLCBncm91cHMsIGxheW91dEVuZ2luZSkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vZGVzSGFuZGxlcik7XG5cbiAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICB0aGlzLmltYWdlcyA9IGltYWdlcztcbiAgICAgIHRoaXMuZ3JvdXBzID0gZ3JvdXBzO1xuICAgICAgdGhpcy5sYXlvdXRFbmdpbmUgPSBsYXlvdXRFbmdpbmU7XG5cbiAgICAgIC8vIGNyZWF0ZSB0aGUgbm9kZSBBUEkgaW4gdGhlIGJvZHkgY29udGFpbmVyXG4gICAgICB0aGlzLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZU5vZGUgPSB0aGlzLmNyZWF0ZS5iaW5kKHRoaXMpO1xuXG4gICAgICB0aGlzLm5vZGVzTGlzdGVuZXJzID0ge1xuICAgICAgICBhZGQ6IGZ1bmN0aW9uIGFkZChldmVudCwgcGFyYW1zKSB7XG4gICAgICAgICAgX3RoaXMuYWRkKHBhcmFtcy5pdGVtcyk7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKGV2ZW50LCBwYXJhbXMpIHtcbiAgICAgICAgICBfdGhpcy51cGRhdGUocGFyYW1zLml0ZW1zLCBwYXJhbXMuZGF0YSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGV2ZW50LCBwYXJhbXMpIHtcbiAgICAgICAgICBfdGhpcy5yZW1vdmUocGFyYW1zLml0ZW1zKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgICBib3JkZXJXaWR0aDogMSxcbiAgICAgICAgYm9yZGVyV2lkdGhTZWxlY3RlZDogMixcbiAgICAgICAgYnJva2VuSW1hZ2U6IHVuZGVmaW5lZCxcbiAgICAgICAgY29sb3I6IHtcbiAgICAgICAgICBib3JkZXI6ICcjMkI3Q0U5JyxcbiAgICAgICAgICBiYWNrZ3JvdW5kOiAnIzk3QzJGQycsXG4gICAgICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgICAgICBib3JkZXI6ICcjMkI3Q0U5JyxcbiAgICAgICAgICAgIGJhY2tncm91bmQ6ICcjRDJFNUZGJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgaG92ZXI6IHtcbiAgICAgICAgICAgIGJvcmRlcjogJyMyQjdDRTknLFxuICAgICAgICAgICAgYmFja2dyb3VuZDogJyNEMkU1RkYnXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmaXhlZDoge1xuICAgICAgICAgIHg6IGZhbHNlLFxuICAgICAgICAgIHk6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIGZvbnQ6IHtcbiAgICAgICAgICBjb2xvcjogJyMzNDM0MzQnLFxuICAgICAgICAgIHNpemU6IDE0LCAvLyBweFxuICAgICAgICAgIGZhY2U6ICdhcmlhbCcsXG4gICAgICAgICAgYmFja2dyb3VuZDogJ25vbmUnLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiAwLCAvLyBweFxuICAgICAgICAgIHN0cm9rZUNvbG9yOiAnI2ZmZmZmZicsXG4gICAgICAgICAgYWxpZ246ICdjZW50ZXInXG4gICAgICAgIH0sXG4gICAgICAgIGdyb3VwOiB1bmRlZmluZWQsXG4gICAgICAgIGhpZGRlbjogZmFsc2UsXG4gICAgICAgIGljb246IHtcbiAgICAgICAgICBmYWNlOiAnRm9udEF3ZXNvbWUnLCAvLydGb250QXdlc29tZScsXG4gICAgICAgICAgY29kZTogdW5kZWZpbmVkLCAvLydcXHVmMDA3JyxcbiAgICAgICAgICBzaXplOiA1MCwgLy81MCxcbiAgICAgICAgICBjb2xvcjogJyMyQjdDRTknIC8vJyNhYTAwZmYnXG4gICAgICAgIH0sXG4gICAgICAgIGltYWdlOiB1bmRlZmluZWQsIC8vIC0tPiBVUkxcbiAgICAgICAgbGFiZWw6IHVuZGVmaW5lZCxcbiAgICAgICAgbGFiZWxIaWdobGlnaHRCb2xkOiB0cnVlLFxuICAgICAgICBsZXZlbDogdW5kZWZpbmVkLFxuICAgICAgICBtYXNzOiAxLFxuICAgICAgICBwaHlzaWNzOiB0cnVlLFxuICAgICAgICBzY2FsaW5nOiB7XG4gICAgICAgICAgbWluOiAxMCxcbiAgICAgICAgICBtYXg6IDMwLFxuICAgICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgIG1pbjogMTQsXG4gICAgICAgICAgICBtYXg6IDMwLFxuICAgICAgICAgICAgbWF4VmlzaWJsZTogMzAsXG4gICAgICAgICAgICBkcmF3VGhyZXNob2xkOiA1XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjdXN0b21TY2FsaW5nRnVuY3Rpb246IGZ1bmN0aW9uIGN1c3RvbVNjYWxpbmdGdW5jdGlvbihtaW4sIG1heCwgdG90YWwsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDAuNTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBzY2FsZSA9IDEgLyAobWF4IC0gbWluKTtcbiAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsICh2YWx1ZSAtIG1pbikgKiBzY2FsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzaGFkb3c6IHtcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICBjb2xvcjogJ3JnYmEoMCwwLDAsMC41KScsXG4gICAgICAgICAgc2l6ZTogMTAsXG4gICAgICAgICAgeDogNSxcbiAgICAgICAgICB5OiA1XG4gICAgICAgIH0sXG4gICAgICAgIHNoYXBlOiAnZWxsaXBzZScsXG4gICAgICAgIHNoYXBlUHJvcGVydGllczoge1xuICAgICAgICAgIGJvcmRlckRhc2hlczogZmFsc2UsIC8vIG9ubHkgZm9yIGJvcmRlcnNcbiAgICAgICAgICBib3JkZXJSYWRpdXM6IDYsIC8vIG9ubHkgZm9yIGJveCBzaGFwZVxuICAgICAgICAgIGludGVycG9sYXRpb246IHRydWUsIC8vIG9ubHkgZm9yIGltYWdlIGFuZCBjaXJjdWxhckltYWdlIHNoYXBlc1xuICAgICAgICAgIHVzZUltYWdlU2l6ZTogZmFsc2UsIC8vIG9ubHkgZm9yIGltYWdlIGFuZCBjaXJjdWxhckltYWdlIHNoYXBlc1xuICAgICAgICAgIHVzZUJvcmRlcldpdGhJbWFnZTogZmFsc2UgLy8gb25seSBmb3IgaW1hZ2Ugc2hhcGVcbiAgICAgICAgfSxcbiAgICAgICAgc2l6ZTogMjUsXG4gICAgICAgIHRpdGxlOiB1bmRlZmluZWQsXG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIHg6IHVuZGVmaW5lZCxcbiAgICAgICAgeTogdW5kZWZpbmVkXG4gICAgICB9O1xuICAgICAgdXRpbC5leHRlbmQodGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICAgICAgdGhpcy5iaW5kRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoTm9kZXNIYW5kbGVyLCBbe1xuICAgICAga2V5OiAnYmluZEV2ZW50TGlzdGVuZXJzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIC8vIHJlZnJlc2ggdGhlIG5vZGVzLiBVc2VkIHdoZW4gcmV2ZXJ0aW5nIGZyb20gaGllcmFyY2hpY2FsIGxheW91dFxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbigncmVmcmVzaE5vZGVzJywgdGhpcy5yZWZyZXNoLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbigncmVmcmVzaCcsIHRoaXMucmVmcmVzaC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdXRpbC5mb3JFYWNoKF90aGlzMi5ub2Rlc0xpc3RlbmVycywgZnVuY3Rpb24gKGNhbGxiYWNrLCBldmVudCkge1xuICAgICAgICAgICAgaWYgKF90aGlzMi5ib2R5LmRhdGEubm9kZXMpIF90aGlzMi5ib2R5LmRhdGEubm9kZXMub2ZmKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZGVsZXRlIF90aGlzMi5ib2R5LmZ1bmN0aW9ucy5jcmVhdGVOb2RlO1xuICAgICAgICAgIGRlbGV0ZSBfdGhpczIubm9kZXNMaXN0ZW5lcnMuYWRkO1xuICAgICAgICAgIGRlbGV0ZSBfdGhpczIubm9kZXNMaXN0ZW5lcnMudXBkYXRlO1xuICAgICAgICAgIGRlbGV0ZSBfdGhpczIubm9kZXNMaXN0ZW5lcnMucmVtb3ZlO1xuICAgICAgICAgIGRlbGV0ZSBfdGhpczIubm9kZXNMaXN0ZW5lcnM7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NldE9wdGlvbnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgX05vZGUyLmRlZmF1bHQucGFyc2VPcHRpb25zKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgICAgICAvLyB1cGRhdGUgdGhlIHNoYXBlIGluIGFsbCBub2Rlc1xuICAgICAgICAgIGlmIChvcHRpb25zLnNoYXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiB0aGlzLmJvZHkubm9kZXMpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlcy5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0udXBkYXRlU2hhcGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgZm9udCBpbiBhbGwgbm9kZXNcbiAgICAgICAgICBpZiAob3B0aW9ucy5mb250ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIF9MYWJlbDIuZGVmYXVsdC5wYXJzZU9wdGlvbnModGhpcy5vcHRpb25zLmZvbnQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgZm9yICh2YXIgX25vZGVJZCBpbiB0aGlzLmJvZHkubm9kZXMpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlcy5oYXNPd25Qcm9wZXJ0eShfbm9kZUlkKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYm9keS5ub2Rlc1tfbm9kZUlkXS51cGRhdGVMYWJlbE1vZHVsZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYm9keS5ub2Rlc1tfbm9kZUlkXS5fcmVzZXQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgc2hhcGUgc2l6ZSBpbiBhbGwgbm9kZXNcbiAgICAgICAgICBpZiAob3B0aW9ucy5zaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9ub2RlSWQyIGluIHRoaXMuYm9keS5ub2Rlcykge1xuICAgICAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzLmhhc093blByb3BlcnR5KF9ub2RlSWQyKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYm9keS5ub2Rlc1tfbm9kZUlkMl0uX3Jlc2V0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB1cGRhdGUgdGhlIHN0YXRlIG9mIHRoZSBsZXRpYWJsZXMgaWYgbmVlZGVkXG4gICAgICAgICAgaWYgKG9wdGlvbnMuaGlkZGVuICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5waHlzaWNzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19kYXRhQ2hhbmdlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNldCBhIGRhdGEgc2V0IHdpdGggbm9kZXMgZm9yIHRoZSBuZXR3b3JrXG4gICAgICAgKiBAcGFyYW0ge0FycmF5IHwgRGF0YVNldCB8IERhdGFWaWV3fSBub2RlcyAgICAgICAgIFRoZSBkYXRhIGNvbnRhaW5pbmcgdGhlIG5vZGVzLlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc2V0RGF0YScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGF0YShub2Rlcykge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICB2YXIgZG9Ob3RFbWl0ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgdmFyIG9sZE5vZGVzRGF0YSA9IHRoaXMuYm9keS5kYXRhLm5vZGVzO1xuXG4gICAgICAgIGlmIChub2RlcyBpbnN0YW5jZW9mIERhdGFTZXQgfHwgbm9kZXMgaW5zdGFuY2VvZiBEYXRhVmlldykge1xuICAgICAgICAgIHRoaXMuYm9keS5kYXRhLm5vZGVzID0gbm9kZXM7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShub2RlcykpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZGF0YS5ub2RlcyA9IG5ldyBEYXRhU2V0KCk7XG4gICAgICAgICAgdGhpcy5ib2R5LmRhdGEubm9kZXMuYWRkKG5vZGVzKTtcbiAgICAgICAgfSBlbHNlIGlmICghbm9kZXMpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZGF0YS5ub2RlcyA9IG5ldyBEYXRhU2V0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkgb3IgRGF0YVNldCBleHBlY3RlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9sZE5vZGVzRGF0YSkge1xuICAgICAgICAgIC8vIHVuc3Vic2NyaWJlIGZyb20gb2xkIGRhdGFzZXRcbiAgICAgICAgICB1dGlsLmZvckVhY2godGhpcy5ub2Rlc0xpc3RlbmVycywgZnVuY3Rpb24gKGNhbGxiYWNrLCBldmVudCkge1xuICAgICAgICAgICAgb2xkTm9kZXNEYXRhLm9mZihldmVudCwgY2FsbGJhY2spO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIGRyYXduIG5vZGVzXG4gICAgICAgIHRoaXMuYm9keS5ub2RlcyA9IHt9O1xuXG4gICAgICAgIGlmICh0aGlzLmJvZHkuZGF0YS5ub2Rlcykge1xuICAgICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBzdWJzY3JpYmUgdG8gbmV3IGRhdGFzZXRcbiAgICAgICAgICAgIHZhciBtZSA9IF90aGlzMztcbiAgICAgICAgICAgIHV0aWwuZm9yRWFjaChfdGhpczMubm9kZXNMaXN0ZW5lcnMsIGZ1bmN0aW9uIChjYWxsYmFjaywgZXZlbnQpIHtcbiAgICAgICAgICAgICAgbWUuYm9keS5kYXRhLm5vZGVzLm9uKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gZHJhdyBhbGwgbmV3IG5vZGVzXG4gICAgICAgICAgICB2YXIgaWRzID0gX3RoaXMzLmJvZHkuZGF0YS5ub2Rlcy5nZXRJZHMoKTtcbiAgICAgICAgICAgIF90aGlzMy5hZGQoaWRzLCB0cnVlKTtcbiAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRvTm90RW1pdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQWRkIG5vZGVzXG4gICAgICAgKiBAcGFyYW0ge051bWJlcltdIHwgU3RyaW5nW119IGlkc1xuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnYWRkJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoaWRzKSB7XG4gICAgICAgIHZhciBkb05vdEVtaXQgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICB2YXIgaWQgPSB2b2lkIDA7XG4gICAgICAgIHZhciBuZXdOb2RlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlkID0gaWRzW2ldO1xuICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5ib2R5LmRhdGEubm9kZXMuZ2V0KGlkKTtcbiAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlKHByb3BlcnRpZXMpO1xuICAgICAgICAgIG5ld05vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW2lkXSA9IG5vZGU7IC8vIG5vdGU6IHRoaXMgbWF5IHJlcGxhY2UgYW4gZXhpc3Rpbmcgbm9kZVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sYXlvdXRFbmdpbmUucG9zaXRpb25Jbml0aWFsbHkobmV3Tm9kZXMpO1xuXG4gICAgICAgIGlmIChkb05vdEVtaXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFVwZGF0ZSBleGlzdGluZyBub2Rlcywgb3IgY3JlYXRlIHRoZW0gd2hlbiBub3QgeWV0IGV4aXN0aW5nXG4gICAgICAgKiBAcGFyYW0ge051bWJlcltdIHwgU3RyaW5nW119IGlkc1xuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAndXBkYXRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUoaWRzLCBjaGFuZ2VkRGF0YSkge1xuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICAgIHZhciBkYXRhQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBpZCA9IGlkc1tpXTtcbiAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2lkXTtcbiAgICAgICAgICB2YXIgZGF0YSA9IGNoYW5nZWREYXRhW2ldO1xuICAgICAgICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBub2RlXG4gICAgICAgICAgICBkYXRhQ2hhbmdlZCA9IG5vZGUuc2V0T3B0aW9ucyhkYXRhKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgLy8gY3JlYXRlIG5vZGVcbiAgICAgICAgICAgIG5vZGUgPSB0aGlzLmNyZWF0ZShkYXRhKTtcbiAgICAgICAgICAgIG5vZGVzW2lkXSA9IG5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhQ2hhbmdlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhVXBkYXRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZSBleGlzdGluZyBub2Rlcy4gSWYgbm9kZXMgZG8gbm90IGV4aXN0LCB0aGUgbWV0aG9kIHdpbGwganVzdCBpZ25vcmUgaXQuXG4gICAgICAgKiBAcGFyYW0ge051bWJlcltdIHwgU3RyaW5nW119IGlkc1xuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAncmVtb3ZlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoaWRzKSB7XG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBpZCA9IGlkc1tpXTtcbiAgICAgICAgICBkZWxldGUgbm9kZXNbaWRdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBjcmVhdGUgYSBub2RlXG4gICAgICAgKiBAcGFyYW0gcHJvcGVydGllc1xuICAgICAgICogQHBhcmFtIGNvbnN0cnVjdG9yQ2xhc3NcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnY3JlYXRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICB2YXIgY29uc3RydWN0b3JDbGFzcyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IF9Ob2RlMi5kZWZhdWx0IDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgIHJldHVybiBuZXcgY29uc3RydWN0b3JDbGFzcyhwcm9wZXJ0aWVzLCB0aGlzLmJvZHksIHRoaXMuaW1hZ2VzLCB0aGlzLmdyb3VwcywgdGhpcy5vcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyZWZyZXNoJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWZyZXNoKCkge1xuICAgICAgICB2YXIgY2xlYXJQb3NpdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiBub2Rlcykge1xuICAgICAgICAgIHZhciBub2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGlmIChub2Rlcy5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmJvZHkuZGF0YS5ub2Rlcy5fZGF0YVtub2RlSWRdO1xuICAgICAgICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQgJiYgZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoY2xlYXJQb3NpdGlvbnMgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgbm9kZS5zZXRPcHRpb25zKHsgeDogbnVsbCwgeTogbnVsbCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUuc2V0T3B0aW9ucyh7IGZpeGVkOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIG5vZGUuc2V0T3B0aW9ucyhkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbnMgb2YgdGhlIG5vZGVzLlxuICAgICAgICogQHBhcmFtIGlkcyAgLS0+IG9wdGlvbmFsLCBjYW4gYmUgYXJyYXkgb2Ygbm9kZUlkcywgY2FuIGJlIHN0cmluZ1xuICAgICAgICogQHJldHVybnMge3t9fVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXRQb3NpdGlvbnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvc2l0aW9ucyhpZHMpIHtcbiAgICAgICAgdmFyIGRhdGFBcnJheSA9IHt9O1xuICAgICAgICBpZiAoaWRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpZHMpID09PSB0cnVlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW2lkc1tpXV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW2lkc1tpXV07XG4gICAgICAgICAgICAgICAgZGF0YUFycmF5W2lkc1tpXV0gPSB7IHg6IE1hdGgucm91bmQobm9kZS54KSwgeTogTWF0aC5yb3VuZChub2RlLnkpIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1tpZHNdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdmFyIF9ub2RlID0gdGhpcy5ib2R5Lm5vZGVzW2lkc107XG4gICAgICAgICAgICAgIGRhdGFBcnJheVtpZHNdID0geyB4OiBNYXRoLnJvdW5kKF9ub2RlLngpLCB5OiBNYXRoLnJvdW5kKF9ub2RlLnkpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgX25vZGUyID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMuYm9keS5ub2RlSW5kaWNlc1tfaV1dO1xuICAgICAgICAgICAgZGF0YUFycmF5W3RoaXMuYm9keS5ub2RlSW5kaWNlc1tfaV1dID0geyB4OiBNYXRoLnJvdW5kKF9ub2RlMi54KSwgeTogTWF0aC5yb3VuZChfbm9kZTIueSkgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGFBcnJheTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBMb2FkIHRoZSBYWSBwb3NpdGlvbnMgb2YgdGhlIG5vZGVzIGludG8gdGhlIGRhdGFzZXQuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3N0b3JlUG9zaXRpb25zJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9yZVBvc2l0aW9ucygpIHtcbiAgICAgICAgLy8gdG9kbzogYWRkIHN1cHBvcnQgZm9yIGNsdXN0ZXJzIGFuZCBoaWVyYXJjaGljYWwuXG4gICAgICAgIHZhciBkYXRhQXJyYXkgPSBbXTtcbiAgICAgICAgdmFyIGRhdGFzZXQgPSB0aGlzLmJvZHkuZGF0YS5ub2Rlcy5nZXREYXRhU2V0KCk7XG5cbiAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIGRhdGFzZXQuX2RhdGEpIHtcbiAgICAgICAgICBpZiAoZGF0YXNldC5fZGF0YS5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgICAgICAgaWYgKGRhdGFzZXQuX2RhdGFbbm9kZUlkXS54ICE9IE1hdGgucm91bmQobm9kZS54KSB8fCBkYXRhc2V0Ll9kYXRhW25vZGVJZF0ueSAhPSBNYXRoLnJvdW5kKG5vZGUueSkpIHtcbiAgICAgICAgICAgICAgZGF0YUFycmF5LnB1c2goeyBpZDogbm9kZS5pZCwgeDogTWF0aC5yb3VuZChub2RlLngpLCB5OiBNYXRoLnJvdW5kKG5vZGUueSkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRhdGFzZXQudXBkYXRlKGRhdGFBcnJheSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogZ2V0IHRoZSBib3VuZGluZyBib3ggb2YgYSBub2RlLlxuICAgICAgICogQHBhcmFtIG5vZGVJZFxuICAgICAgICogQHJldHVybnMge2p8Kn1cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0Qm91bmRpbmdCb3gnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJvdW5kaW5nQm94KG5vZGVJZCkge1xuICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXS5zaGFwZS5ib3VuZGluZ0JveDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEdldCB0aGUgSWRzIG9mIG5vZGVzIGNvbm5lY3RlZCB0byB0aGlzIG5vZGUuXG4gICAgICAgKiBAcGFyYW0gbm9kZUlkXG4gICAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldENvbm5lY3RlZE5vZGVzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb25uZWN0ZWROb2Rlcyhub2RlSWQpIHtcbiAgICAgICAgdmFyIG5vZGVMaXN0ID0gW107XG4gICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICB2YXIgbm9kZU9iaiA9IHt9OyAvLyB1c2VkIHRvIHF1aWNrbHkgY2hlY2sgaWYgbm9kZSBhbHJlYWR5IGV4aXN0c1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5lZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGVkZ2UgPSBub2RlLmVkZ2VzW2ldO1xuICAgICAgICAgICAgaWYgKGVkZ2UudG9JZCA9PSBub2RlLmlkKSB7XG4gICAgICAgICAgICAgIC8vIHRoZXNlIGFyZSBkb3VibGUgZXF1YWxzIHNpbmNlIGlkcyBjYW4gYmUgbnVtZXJpYyBvciBzdHJpbmdcbiAgICAgICAgICAgICAgaWYgKG5vZGVPYmpbZWRnZS5mcm9tSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBub2RlTGlzdC5wdXNoKGVkZ2UuZnJvbUlkKTtcbiAgICAgICAgICAgICAgICBub2RlT2JqW2VkZ2UuZnJvbUlkXSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWRnZS5mcm9tSWQgPT0gbm9kZS5pZCkge1xuICAgICAgICAgICAgICAvLyB0aGVzZSBhcmUgZG91YmxlIGVxdWFscyBzaW5jZSBpZHMgY2FuIGJlIG51bWVyaWMgb3Igc3RyaW5nXG4gICAgICAgICAgICAgIGlmIChub2RlT2JqW2VkZ2UudG9JZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG5vZGVMaXN0LnB1c2goZWRnZS50b0lkKTtcbiAgICAgICAgICAgICAgICBub2RlT2JqW2VkZ2UudG9JZF0gPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlTGlzdDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBHZXQgdGhlIGlkcyBvZiB0aGUgZWRnZXMgY29ubmVjdGVkIHRvIHRoaXMgbm9kZS5cbiAgICAgICAqIEBwYXJhbSBub2RlSWRcbiAgICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXRDb25uZWN0ZWRFZGdlcycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29ubmVjdGVkRWRnZXMobm9kZUlkKSB7XG4gICAgICAgIHZhciBlZGdlTGlzdCA9IFtdO1xuICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBlZGdlTGlzdC5wdXNoKG5vZGUuZWRnZXNbaV0uaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIk5vZGVJZCBwcm92aWRlZCBmb3IgZ2V0Q29ubmVjdGVkRWRnZXMgZG9lcyBub3QgZXhpc3QuIFByb3ZpZGVkOiBcIiwgbm9kZUlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWRnZUxpc3Q7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogTW92ZSBhIG5vZGUuXG4gICAgICAgKiBAcGFyYW0gU3RyaW5nIG5vZGVJZFxuICAgICAgICogQHBhcmFtIE51bWJlciB4XG4gICAgICAgKiBAcGFyYW0gTnVtYmVyIHlcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnbW92ZU5vZGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmVOb2RlKG5vZGVJZCwgeCwgeSkge1xuICAgICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdLnggPSBOdW1iZXIoeCk7XG4gICAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0ueSA9IE51bWJlcih5KTtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzNC5ib2R5LmVtaXR0ZXIuZW1pdChcInN0YXJ0U2ltdWxhdGlvblwiKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIk5vZGUgaWQgc3VwcGxpZWQgdG8gbW92ZU5vZGUgZG9lcyBub3QgZXhpc3QuIFByb3ZpZGVkOiBcIiwgbm9kZUlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBOb2Rlc0hhbmRsZXI7XG4gIH0oKTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBOb2Rlc0hhbmRsZXI7XG5cbi8qKiovIH0sXG4vKiA2NSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgdmFyIF9MYWJlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNjYpO1xuXG4gIHZhciBfTGFiZWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTGFiZWwpO1xuXG4gIHZhciBfQm94ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nyk7XG5cbiAgdmFyIF9Cb3gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQm94KTtcblxuICB2YXIgX0NpcmNsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjkpO1xuXG4gIHZhciBfQ2lyY2xlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NpcmNsZSk7XG5cbiAgdmFyIF9DaXJjdWxhckltYWdlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MSk7XG5cbiAgdmFyIF9DaXJjdWxhckltYWdlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NpcmN1bGFySW1hZ2UpO1xuXG4gIHZhciBfRGF0YWJhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyKTtcblxuICB2YXIgX0RhdGFiYXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0RhdGFiYXNlKTtcblxuICB2YXIgX0RpYW1vbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDczKTtcblxuICB2YXIgX0RpYW1vbmQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRGlhbW9uZCk7XG5cbiAgdmFyIF9Eb3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc1KTtcblxuICB2YXIgX0RvdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Eb3QpO1xuXG4gIHZhciBfRWxsaXBzZSA9IF9fd2VicGFja19yZXF1aXJlX18oNzYpO1xuXG4gIHZhciBfRWxsaXBzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9FbGxpcHNlKTtcblxuICB2YXIgX0ljb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc3KTtcblxuICB2YXIgX0ljb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfSWNvbik7XG5cbiAgdmFyIF9JbWFnZSA9IF9fd2VicGFja19yZXF1aXJlX18oNzgpO1xuXG4gIHZhciBfSW1hZ2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfSW1hZ2UpO1xuXG4gIHZhciBfU3F1YXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OSk7XG5cbiAgdmFyIF9TcXVhcmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU3F1YXJlKTtcblxuICB2YXIgX1N0YXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgwKTtcblxuICB2YXIgX1N0YXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU3Rhcik7XG5cbiAgdmFyIF9UZXh0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MSk7XG5cbiAgdmFyIF9UZXh0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1RleHQpO1xuXG4gIHZhciBfVHJpYW5nbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgyKTtcblxuICB2YXIgX1RyaWFuZ2xlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1RyaWFuZ2xlKTtcblxuICB2YXIgX1RyaWFuZ2xlRG93biA9IF9fd2VicGFja19yZXF1aXJlX18oODMpO1xuXG4gIHZhciBfVHJpYW5nbGVEb3duMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1RyaWFuZ2xlRG93bik7XG5cbiAgdmFyIF9WYWxpZGF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KTtcblxuICB2YXIgX1ZhbGlkYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9WYWxpZGF0b3IpO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbiAgLyoqXG4gICAqIEBjbGFzcyBOb2RlXG4gICAqIEEgbm9kZS4gQSBub2RlIGNhbiBiZSBjb25uZWN0ZWQgdG8gb3RoZXIgbm9kZXMgdmlhIG9uZSBvciBtdWx0aXBsZSBlZGdlcy5cbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgb3B0aW9ucyBmb3IgdGhlIG5vZGUuIEFsbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zIGFyZSBvcHRpb25hbCwgZXhjZXB0IGZvciB0aGUgaWQuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge251bWJlcn0gaWQgICAgIElkIG9mIHRoZSBub2RlLiBSZXF1aXJlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmd9IGxhYmVsICBUZXh0IGxhYmVsIGZvciB0aGUgbm9kZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtudW1iZXJ9IHggICAgICBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBub2RlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge251bWJlcn0geSAgICAgIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSBub2RlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3N0cmluZ30gc2hhcGUgIE5vZGUgc2hhcGUsIGF2YWlsYWJsZTpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkYXRhYmFzZVwiLCBcImNpcmNsZVwiLCBcImVsbGlwc2VcIixcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJib3hcIiwgXCJpbWFnZVwiLCBcInRleHRcIiwgXCJkb3RcIixcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzdGFyXCIsIFwidHJpYW5nbGVcIiwgXCJ0cmlhbmdsZURvd25cIixcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzcXVhcmVcIiwgXCJpY29uXCJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nfSBpbWFnZSAgQW4gaW1hZ2UgdXJsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3N0cmluZ30gdGl0bGUgIEFuIHRpdGxlIHRleHQsIGNhbiBiZSBIVE1MXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2FueXR5cGV9IGdyb3VwIEEgZ3JvdXAgbmFtZSBvciBudW1iZXJcbiAgICogQHBhcmFtIHtOZXR3b3JrLkltYWdlc30gaW1hZ2VsaXN0ICAgIEEgbGlzdCB3aXRoIGltYWdlcy4gT25seSBuZWVkZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZW4gdGhlIG5vZGUgaGFzIGFuIGltYWdlXG4gICAqIEBwYXJhbSB7TmV0d29yay5Hcm91cHN9IGdyb3VwbGlzdCAgICBBIGxpc3Qgd2l0aCBncm91cHMuIE5lZWRlZCBmb3JcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHJpZXZpbmcgZ3JvdXAgb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgICAgICBjb25zdGFudHMgICAgQW4gb2JqZWN0IHdpdGggZGVmYXVsdCB2YWx1ZXMgZm9yXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGFtcGxlIGZvciB0aGUgY29sb3JcbiAgICpcbiAgICovXG5cbiAgdmFyIE5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm9kZShvcHRpb25zLCBib2R5LCBpbWFnZWxpc3QsIGdyb3VwbGlzdCwgZ2xvYmFsT3B0aW9ucykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vZGUpO1xuXG4gICAgICB0aGlzLm9wdGlvbnMgPSB1dGlsLmJyaWRnZU9iamVjdChnbG9iYWxPcHRpb25zKTtcbiAgICAgIHRoaXMuZ2xvYmFsT3B0aW9ucyA9IGdsb2JhbE9wdGlvbnM7XG4gICAgICB0aGlzLmJvZHkgPSBib2R5O1xuXG4gICAgICB0aGlzLmVkZ2VzID0gW107IC8vIGFsbCBlZGdlcyBjb25uZWN0ZWQgdG8gdGhpcyBub2RlXG5cbiAgICAgIC8vIHNldCBkZWZhdWx0cyBmb3IgdGhlIG9wdGlvbnNcbiAgICAgIHRoaXMuaWQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmltYWdlbGlzdCA9IGltYWdlbGlzdDtcbiAgICAgIHRoaXMuZ3JvdXBsaXN0ID0gZ3JvdXBsaXN0O1xuXG4gICAgICAvLyBzdGF0ZSBvcHRpb25zXG4gICAgICB0aGlzLnggPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnkgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmJhc2VTaXplID0gdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICB0aGlzLmJhc2VGb250U2l6ZSA9IHRoaXMub3B0aW9ucy5mb250LnNpemU7XG4gICAgICB0aGlzLnByZWRlZmluZWRQb3NpdGlvbiA9IGZhbHNlOyAvLyB1c2VkIHRvIGNoZWNrIGlmIGluaXRpYWwgZml0IHNob3VsZCBqdXN0IHRha2UgdGhlIHJhbmdlIG9yIGFwcHJveGltYXRlXG4gICAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmhvdmVyID0gZmFsc2U7XG5cbiAgICAgIHRoaXMubGFiZWxNb2R1bGUgPSBuZXcgX0xhYmVsMi5kZWZhdWx0KHRoaXMuYm9keSwgdGhpcy5vcHRpb25zLCBmYWxzZSAvKiBOb3QgZWRnZSBsYWJlbCAqLyk7XG4gICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXR0YWNoIGEgZWRnZSB0byB0aGUgbm9kZVxuICAgICAqIEBwYXJhbSB7RWRnZX0gZWRnZVxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoTm9kZSwgW3tcbiAgICAgIGtleTogJ2F0dGFjaEVkZ2UnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGF0dGFjaEVkZ2UoZWRnZSkge1xuICAgICAgICBpZiAodGhpcy5lZGdlcy5pbmRleE9mKGVkZ2UpID09PSAtMSkge1xuICAgICAgICAgIHRoaXMuZWRnZXMucHVzaChlZGdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIERldGFjaCBhIGVkZ2UgZnJvbSB0aGUgbm9kZVxuICAgICAgICogQHBhcmFtIHtFZGdlfSBlZGdlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2RldGFjaEVkZ2UnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRldGFjaEVkZ2UoZWRnZSkge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmVkZ2VzLmluZGV4T2YoZWRnZSk7XG4gICAgICAgIGlmIChpbmRleCAhPSAtMSkge1xuICAgICAgICAgIHRoaXMuZWRnZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNldCBvciBvdmVyd3JpdGUgb3B0aW9ucyBmb3IgdGhlIG5vZGVcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIGFuIG9iamVjdCB3aXRoIG9wdGlvbnNcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25zdGFudHMgIGFuZCBvYmplY3Qgd2l0aCBkZWZhdWx0LCBnbG9iYWwgb3B0aW9uc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzZXRPcHRpb25zJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRTaGFwZSA9IHRoaXMub3B0aW9ucy5zaGFwZTtcbiAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJhc2ljIG9wdGlvbnNcbiAgICAgICAgaWYgKG9wdGlvbnMuaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuaWQgPSBvcHRpb25zLmlkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IFwiTm9kZSBtdXN0IGhhdmUgYW4gaWRcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCB0aGVzZSBvcHRpb25zIGxvY2FsbHlcbiAgICAgICAgLy8gY2xlYXIgeCBhbmQgeSBwb3NpdGlvbnNcbiAgICAgICAgaWYgKG9wdGlvbnMueCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMueCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy54ID0gdW5kZWZpbmVkO3RoaXMucHJlZGVmaW5lZFBvc2l0aW9uID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMueCA9IHBhcnNlSW50KG9wdGlvbnMueCk7dGhpcy5wcmVkZWZpbmVkUG9zaXRpb24gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy55ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy55ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnkgPSB1bmRlZmluZWQ7dGhpcy5wcmVkZWZpbmVkUG9zaXRpb24gPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy55ID0gcGFyc2VJbnQob3B0aW9ucy55KTt0aGlzLnByZWRlZmluZWRQb3NpdGlvbiA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuYmFzZVNpemUgPSBvcHRpb25zLnNpemU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG9wdGlvbnMudmFsdWUgPSBwYXJzZUZsb2F0KG9wdGlvbnMudmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29weSBncm91cCBvcHRpb25zXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5ncm91cCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIG9wdGlvbnMuZ3JvdXAgPT09ICdzdHJpbmcnICYmIG9wdGlvbnMuZ3JvdXAgIT0gJycpIHtcbiAgICAgICAgICB2YXIgZ3JvdXBPYmogPSB0aGlzLmdyb3VwbGlzdC5nZXQob3B0aW9ucy5ncm91cCk7XG4gICAgICAgICAgdXRpbC5kZWVwRXh0ZW5kKHRoaXMub3B0aW9ucywgZ3JvdXBPYmopO1xuICAgICAgICAgIC8vIHRoZSBjb2xvciBvYmplY3QgbmVlZHMgdG8gYmUgY29tcGxldGVseSBkZWZpbmVkLiBTaW5jZSBncm91cHMgY2FuIHBhcnRpYWxseSBvdmVyd3JpdGUgdGhlIGNvbG9ycywgd2UgcGFyc2UgaXQgYWdhaW4sIGp1c3QgaW4gY2FzZS5cbiAgICAgICAgICB0aGlzLm9wdGlvbnMuY29sb3IgPSB1dGlsLnBhcnNlQ29sb3IodGhpcy5vcHRpb25zLmNvbG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoaXMgdHJhbnNmb3JtcyBhbGwgc2hvcnRoYW5kcyBpbnRvIGZ1bGx5IGRlZmluZWQgb3B0aW9uc1xuICAgICAgICBOb2RlLnBhcnNlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMsIHRydWUsIHRoaXMuZ2xvYmFsT3B0aW9ucyk7XG5cbiAgICAgICAgLy8gbG9hZCB0aGUgaW1hZ2VzXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW1hZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICh0aGlzLmltYWdlbGlzdCkge1xuICAgICAgICAgICAgdGhpcy5pbWFnZU9iaiA9IHRoaXMuaW1hZ2VsaXN0LmxvYWQodGhpcy5vcHRpb25zLmltYWdlLCB0aGlzLm9wdGlvbnMuYnJva2VuSW1hZ2UsIHRoaXMuaWQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBcIk5vIGltYWdlbGlzdCBwcm92aWRlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlTGFiZWxNb2R1bGUoKTtcbiAgICAgICAgdGhpcy51cGRhdGVTaGFwZShjdXJyZW50U2hhcGUpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmhpZGRlbiAhPT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMucGh5c2ljcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgcHJvY2VzcyBhbGwgcG9zc2libGUgc2hvcnRoYW5kcyBpbiB0aGUgbmV3IG9wdGlvbnMgYW5kIG1ha2VzIHN1cmUgdGhhdCB0aGUgcGFyZW50T3B0aW9ucyBhcmUgZnVsbHkgZGVmaW5lZC5cbiAgICAgICAqIFN0YXRpYyBzbyBpdCBjYW4gYWxzbyBiZSB1c2VkIGJ5IHRoZSBoYW5kbGVyLlxuICAgICAgICogQHBhcmFtIHBhcmVudE9wdGlvbnNcbiAgICAgICAqIEBwYXJhbSBuZXdPcHRpb25zXG4gICAgICAgKiBAcGFyYW0gYWxsb3dEZWxldGlvblxuICAgICAgICogQHBhcmFtIGdsb2JhbE9wdGlvbnNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAndXBkYXRlTGFiZWxNb2R1bGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUxhYmVsTW9kdWxlKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxhYmVsID09PSB1bmRlZmluZWQgfHwgdGhpcy5vcHRpb25zLmxhYmVsID09PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmxhYmVsID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYWJlbE1vZHVsZS5zZXRPcHRpb25zKHRoaXMub3B0aW9ucywgdHJ1ZSk7XG4gICAgICAgIGlmICh0aGlzLmxhYmVsTW9kdWxlLmJhc2VTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmJhc2VGb250U2l6ZSA9IHRoaXMubGFiZWxNb2R1bGUuYmFzZVNpemU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICd1cGRhdGVTaGFwZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlU2hhcGUoY3VycmVudFNoYXBlKSB7XG4gICAgICAgIGlmIChjdXJyZW50U2hhcGUgPT09IHRoaXMub3B0aW9ucy5zaGFwZSAmJiB0aGlzLnNoYXBlKSB7XG4gICAgICAgICAgdGhpcy5zaGFwZS5zZXRPcHRpb25zKHRoaXMub3B0aW9ucywgdGhpcy5pbWFnZU9iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY2hvb3NlIGRyYXcgbWV0aG9kIGRlcGVuZGluZyBvbiB0aGUgc2hhcGVcbiAgICAgICAgICBzd2l0Y2ggKHRoaXMub3B0aW9ucy5zaGFwZSkge1xuICAgICAgICAgICAgY2FzZSAnYm94JzpcbiAgICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBfQm94Mi5kZWZhdWx0KHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjaXJjbGUnOlxuICAgICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IF9DaXJjbGUyLmRlZmF1bHQodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NpcmN1bGFySW1hZ2UnOlxuICAgICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IF9DaXJjdWxhckltYWdlMi5kZWZhdWx0KHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlLCB0aGlzLmltYWdlT2JqKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkYXRhYmFzZSc6XG4gICAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgX0RhdGFiYXNlMi5kZWZhdWx0KHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkaWFtb25kJzpcbiAgICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBfRGlhbW9uZDIuZGVmYXVsdCh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZG90JzpcbiAgICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBfRG90Mi5kZWZhdWx0KHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdlbGxpcHNlJzpcbiAgICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBfRWxsaXBzZTIuZGVmYXVsdCh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaWNvbic6XG4gICAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgX0ljb24yLmRlZmF1bHQodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2ltYWdlJzpcbiAgICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBfSW1hZ2UyLmRlZmF1bHQodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUsIHRoaXMuaW1hZ2VPYmopO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NxdWFyZSc6XG4gICAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgX1NxdWFyZTIuZGVmYXVsdCh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc3Rhcic6XG4gICAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgX1N0YXIyLmRlZmF1bHQodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IF9UZXh0Mi5kZWZhdWx0KHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd0cmlhbmdsZSc6XG4gICAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgX1RyaWFuZ2xlMi5kZWZhdWx0KHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd0cmlhbmdsZURvd24nOlxuICAgICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IF9UcmlhbmdsZURvd24yLmRlZmF1bHQodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgX0VsbGlwc2UyLmRlZmF1bHQodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBzZWxlY3QgdGhpcyBub2RlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NlbGVjdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0KCkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiB1bnNlbGVjdCB0aGlzIG5vZGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAndW5zZWxlY3QnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVuc2VsZWN0KCkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVzZXQgdGhlIGNhbGN1bGF0ZWQgc2l6ZSBvZiB0aGUgbm9kZSwgZm9yY2VzIGl0IHRvIHJlY2FsY3VsYXRlIGl0cyBzaXplXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfcmVzZXQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXNldCgpIHtcbiAgICAgICAgdGhpcy5zaGFwZS53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zaGFwZS5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogZ2V0IHRoZSB0aXRsZSBvZiB0aGlzIG5vZGUuXG4gICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRpdGxlICAgIFRoZSB0aXRsZSBvZiB0aGUgbm9kZSwgb3IgdW5kZWZpbmVkIHdoZW4gbm8gdGl0bGVcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzIGJlZW4gc2V0LlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXRUaXRsZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGl0bGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMudGl0bGU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSB0byB0aGUgYm9yZGVyIG9mIHRoZSBOb2RlXG4gICAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gICBjdHhcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZSAgICAgICAgQW5nbGUgaW4gcmFkaWFuc1xuICAgICAgICogQHJldHVybnMge251bWJlcn0gZGlzdGFuY2UgICBEaXN0YW5jZSB0byB0aGUgYm9yZGVyIGluIHBpeGVsc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkaXN0YW5jZVRvQm9yZGVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hhcGUuZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDaGVjayBpZiB0aGlzIG5vZGUgaGFzIGEgZml4ZWQgeCBhbmQgeSBwb3NpdGlvblxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gICAgICB0cnVlIGlmIGZpeGVkLCBmYWxzZSBpZiBub3RcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnaXNGaXhlZCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaXNGaXhlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5maXhlZC54ICYmIHRoaXMub3B0aW9ucy5maXhlZC55O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGNoZWNrIGlmIHRoaXMgbm9kZSBpcyBzZWxlY3RlXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBzZWxlY3RlZCAgIFRydWUgaWYgbm9kZSBpcyBzZWxlY3RlZCwgZWxzZSBmYWxzZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdpc1NlbGVjdGVkJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc1NlbGVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXRyaWV2ZSB0aGUgdmFsdWUgb2YgdGhlIG5vZGUuIENhbiBiZSB1bmRlZmluZWRcbiAgICAgICAqIEByZXR1cm4ge051bWJlcn0gdmFsdWVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0VmFsdWUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnZhbHVlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFkanVzdCB0aGUgdmFsdWUgcmFuZ2Ugb2YgdGhlIG5vZGUuIFRoZSBub2RlIHdpbGwgYWRqdXN0IGl0J3Mgc2l6ZVxuICAgICAgICogYmFzZWQgb24gaXRzIHZhbHVlLlxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IG1pblxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IG1heFxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzZXRWYWx1ZVJhbmdlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZVJhbmdlKG1pbiwgbWF4LCB0b3RhbCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLm9wdGlvbnMuc2NhbGluZy5jdXN0b21TY2FsaW5nRnVuY3Rpb24obWluLCBtYXgsIHRvdGFsLCB0aGlzLm9wdGlvbnMudmFsdWUpO1xuICAgICAgICAgIHZhciBzaXplRGlmZiA9IHRoaXMub3B0aW9ucy5zY2FsaW5nLm1heCAtIHRoaXMub3B0aW9ucy5zY2FsaW5nLm1pbjtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNjYWxpbmcubGFiZWwuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIGZvbnREaWZmID0gdGhpcy5vcHRpb25zLnNjYWxpbmcubGFiZWwubWF4IC0gdGhpcy5vcHRpb25zLnNjYWxpbmcubGFiZWwubWluO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmZvbnQuc2l6ZSA9IHRoaXMub3B0aW9ucy5zY2FsaW5nLmxhYmVsLm1pbiArIHNjYWxlICogZm9udERpZmY7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMub3B0aW9ucy5zaXplID0gdGhpcy5vcHRpb25zLnNjYWxpbmcubWluICsgc2NhbGUgKiBzaXplRGlmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuc2l6ZSA9IHRoaXMuYmFzZVNpemU7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmZvbnQuc2l6ZSA9IHRoaXMuYmFzZUZvbnRTaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGVMYWJlbE1vZHVsZSgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIERyYXcgdGhpcyBub2RlIGluIHRoZSBnaXZlbiBjYW52YXNcbiAgICAgICAqIFRoZSAyZCBjb250ZXh0IG9mIGEgSFRNTCBjYW52YXMgY2FuIGJlIHJldHJpZXZlZCBieSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICAgY3R4XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2RyYXcnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4KSB7XG4gICAgICAgIHRoaXMuc2hhcGUuZHJhdyhjdHgsIHRoaXMueCwgdGhpcy55LCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBVcGRhdGUgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgc2hhcGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAndXBkYXRlQm91bmRpbmdCb3gnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kaW5nQm94KGN0eCkge1xuICAgICAgICB0aGlzLnNoYXBlLnVwZGF0ZUJvdW5kaW5nQm94KHRoaXMueCwgdGhpcy55LCBjdHgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlY2FsY3VsYXRlIHRoZSBzaXplIG9mIHRoaXMgbm9kZSBpbiB0aGUgZ2l2ZW4gY2FudmFzXG4gICAgICAgKiBUaGUgMmQgY29udGV4dCBvZiBhIEhUTUwgY2FudmFzIGNhbiBiZSByZXRyaWV2ZWQgYnkgY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAgIGN0eFxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyZXNpemUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShjdHgpIHtcbiAgICAgICAgdGhpcy5zaGFwZS5yZXNpemUoY3R4LCB0aGlzLnNlbGVjdGVkKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDaGVjayBpZiB0aGlzIG9iamVjdCBpcyBvdmVybGFwcGluZyB3aXRoIHRoZSBwcm92aWRlZCBvYmplY3RcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogICBhbiBvYmplY3Qgd2l0aCBwYXJhbWV0ZXJzIGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbVxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gICAgIFRydWUgaWYgbG9jYXRpb24gaXMgbG9jYXRlZCBvbiBub2RlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2lzT3ZlcmxhcHBpbmdXaXRoJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc092ZXJsYXBwaW5nV2l0aChvYmopIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hhcGUubGVmdCA8IG9iai5yaWdodCAmJiB0aGlzLnNoYXBlLmxlZnQgKyB0aGlzLnNoYXBlLndpZHRoID4gb2JqLmxlZnQgJiYgdGhpcy5zaGFwZS50b3AgPCBvYmouYm90dG9tICYmIHRoaXMuc2hhcGUudG9wICsgdGhpcy5zaGFwZS5oZWlnaHQgPiBvYmoudG9wO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENoZWNrIGlmIHRoaXMgb2JqZWN0IGlzIG92ZXJsYXBwaW5nIHdpdGggdGhlIHByb3ZpZGVkIG9iamVjdFxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAgIGFuIG9iamVjdCB3aXRoIHBhcmFtZXRlcnMgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSAgICAgVHJ1ZSBpZiBsb2NhdGlvbiBpcyBsb2NhdGVkIG9uIG5vZGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnaXNCb3VuZGluZ0JveE92ZXJsYXBwaW5nV2l0aCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaXNCb3VuZGluZ0JveE92ZXJsYXBwaW5nV2l0aChvYmopIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hhcGUuYm91bmRpbmdCb3gubGVmdCA8IG9iai5yaWdodCAmJiB0aGlzLnNoYXBlLmJvdW5kaW5nQm94LnJpZ2h0ID4gb2JqLmxlZnQgJiYgdGhpcy5zaGFwZS5ib3VuZGluZ0JveC50b3AgPCBvYmouYm90dG9tICYmIHRoaXMuc2hhcGUuYm91bmRpbmdCb3guYm90dG9tID4gb2JqLnRvcDtcbiAgICAgIH1cbiAgICB9XSwgW3tcbiAgICAgIGtleTogJ3BhcnNlT3B0aW9ucycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VPcHRpb25zKHBhcmVudE9wdGlvbnMsIG5ld09wdGlvbnMpIHtcbiAgICAgICAgdmFyIGFsbG93RGVsZXRpb24gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1syXTtcbiAgICAgICAgdmFyIGdsb2JhbE9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDMgfHwgYXJndW1lbnRzWzNdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1szXTtcblxuICAgICAgICB2YXIgZmllbGRzID0gWydjb2xvcicsICdmb250JywgJ2ZpeGVkJywgJ3NoYWRvdyddO1xuICAgICAgICB1dGlsLnNlbGVjdGl2ZU5vdERlZXBFeHRlbmQoZmllbGRzLCBwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zLCBhbGxvd0RlbGV0aW9uKTtcblxuICAgICAgICAvLyBtZXJnZSB0aGUgc2hhZG93IG9wdGlvbnMgaW50byB0aGUgcGFyZW50LlxuICAgICAgICB1dGlsLm1lcmdlT3B0aW9ucyhwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zLCAnc2hhZG93JywgYWxsb3dEZWxldGlvbiwgZ2xvYmFsT3B0aW9ucyk7XG5cbiAgICAgICAgLy8gaW5kaXZpZHVhbCBzaGFwZSBuZXdPcHRpb25zXG4gICAgICAgIGlmIChuZXdPcHRpb25zLmNvbG9yICE9PSB1bmRlZmluZWQgJiYgbmV3T3B0aW9ucy5jb2xvciAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBwYXJzZWRDb2xvciA9IHV0aWwucGFyc2VDb2xvcihuZXdPcHRpb25zLmNvbG9yKTtcbiAgICAgICAgICB1dGlsLmZpbGxJZkRlZmluZWQocGFyZW50T3B0aW9ucy5jb2xvciwgcGFyc2VkQ29sb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKGFsbG93RGVsZXRpb24gPT09IHRydWUgJiYgbmV3T3B0aW9ucy5jb2xvciA9PT0gbnVsbCkge1xuICAgICAgICAgIHBhcmVudE9wdGlvbnMuY29sb3IgPSB1dGlsLmJyaWRnZU9iamVjdChnbG9iYWxPcHRpb25zLmNvbG9yKTsgLy8gc2V0IHRoZSBvYmplY3QgYmFjayB0byB0aGUgZ2xvYmFsIG9wdGlvbnNcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhbmRsZSB0aGUgZml4ZWQgb3B0aW9uc1xuICAgICAgICBpZiAobmV3T3B0aW9ucy5maXhlZCAhPT0gdW5kZWZpbmVkICYmIG5ld09wdGlvbnMuZml4ZWQgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG5ld09wdGlvbnMuZml4ZWQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcGFyZW50T3B0aW9ucy5maXhlZC54ID0gbmV3T3B0aW9ucy5maXhlZDtcbiAgICAgICAgICAgIHBhcmVudE9wdGlvbnMuZml4ZWQueSA9IG5ld09wdGlvbnMuZml4ZWQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChuZXdPcHRpb25zLmZpeGVkLnggIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgbmV3T3B0aW9ucy5maXhlZC54ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgcGFyZW50T3B0aW9ucy5maXhlZC54ID0gbmV3T3B0aW9ucy5maXhlZC54O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld09wdGlvbnMuZml4ZWQueSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBuZXdPcHRpb25zLmZpeGVkLnkgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICBwYXJlbnRPcHRpb25zLmZpeGVkLnkgPSBuZXdPcHRpb25zLmZpeGVkLnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGFuZGxlIHRoZSBmb250IG9wdGlvbnNcbiAgICAgICAgaWYgKG5ld09wdGlvbnMuZm9udCAhPT0gdW5kZWZpbmVkICYmIG5ld09wdGlvbnMuZm9udCAhPT0gbnVsbCkge1xuICAgICAgICAgIF9MYWJlbDIuZGVmYXVsdC5wYXJzZU9wdGlvbnMocGFyZW50T3B0aW9ucy5mb250LCBuZXdPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmIChhbGxvd0RlbGV0aW9uID09PSB0cnVlICYmIG5ld09wdGlvbnMuZm9udCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBhcmVudE9wdGlvbnMuZm9udCA9IHV0aWwuYnJpZGdlT2JqZWN0KGdsb2JhbE9wdGlvbnMuZm9udCk7IC8vIHNldCB0aGUgb2JqZWN0IGJhY2sgdG8gdGhlIGdsb2JhbCBvcHRpb25zXG4gICAgICAgIH1cblxuICAgICAgICAvLyBoYW5kbGUgdGhlIHNjYWxpbmcgb3B0aW9ucywgc3BlY2lmaWNhbGx5IHRoZSBsYWJlbCBwYXJ0XG4gICAgICAgIGlmIChuZXdPcHRpb25zLnNjYWxpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHV0aWwubWVyZ2VPcHRpb25zKHBhcmVudE9wdGlvbnMuc2NhbGluZywgbmV3T3B0aW9ucy5zY2FsaW5nLCAnbGFiZWwnLCBhbGxvd0RlbGV0aW9uLCBnbG9iYWxPcHRpb25zLnNjYWxpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIE5vZGU7XG4gIH0oKTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBOb2RlO1xuXG4vKioqLyB9LFxuLyogNjYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX3NsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfSB9OyB9KCk7XG5cbiAgdmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuICB2YXIgTGFiZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGFiZWwoYm9keSwgb3B0aW9ucykge1xuICAgICAgdmFyIGVkZ2VsYWJlbCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogYXJndW1lbnRzWzJdO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGFiZWwpO1xuXG4gICAgICB0aGlzLmJvZHkgPSBib2R5O1xuXG4gICAgICB0aGlzLnBvaW50VG9TZWxmID0gZmFsc2U7XG4gICAgICB0aGlzLmJhc2VTaXplID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5mb250T3B0aW9ucyA9IHt9O1xuICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgdGhpcy5zaXplID0geyB0b3A6IDAsIGxlZnQ6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAsIHlMaW5lOiAwIH07IC8vIGNvdWxkIGJlIGNhY2hlZFxuICAgICAgdGhpcy5pc0VkZ2VMYWJlbCA9IGVkZ2VsYWJlbDtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoTGFiZWwsIFt7XG4gICAgICBrZXk6ICdzZXRPcHRpb25zJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGFsbG93RGVsZXRpb24gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICB0aGlzLm5vZGVPcHRpb25zID0gb3B0aW9ucztcblxuICAgICAgICAvLyBXZSB3YW50IHRvIGtlZXAgdGhlIGZvbnQgb3B0aW9ucyBzZXBlcmF0ZWQgZnJvbSB0aGUgbm9kZSBvcHRpb25zLlxuICAgICAgICAvLyBUaGUgbm9kZSBvcHRpb25zIGhhdmUgdG8gbWlycm9yIHRoZSBnbG9iYWxzIHdoZW4gdGhleSBhcmUgbm90IG92ZXJydWxlZC5cbiAgICAgICAgdGhpcy5mb250T3B0aW9ucyA9IHV0aWwuZGVlcEV4dGVuZCh7fSwgb3B0aW9ucy5mb250LCB0cnVlKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5sYWJlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5sYWJlbERpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmZvbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIExhYmVsLnBhcnNlT3B0aW9ucyh0aGlzLmZvbnRPcHRpb25zLCBvcHRpb25zLCBhbGxvd0RlbGV0aW9uKTtcbiAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZm9udCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZVNpemUgPSB0aGlzLmZvbnRPcHRpb25zLnNpemU7XG4gICAgICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKG9wdGlvbnMuZm9udCkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5mb250LnNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0aGlzLmJhc2VTaXplID0gb3B0aW9ucy5mb250LnNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZHJhdycsXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBNYWluIGZ1bmN0aW9uLiBUaGlzIGlzIGNhbGxlZCBmcm9tIGFueXRoaW5nIHRoYXQgd2FudHMgdG8gZHJhdyBhIGxhYmVsLlxuICAgICAgICogQHBhcmFtIGN0eFxuICAgICAgICogQHBhcmFtIHhcbiAgICAgICAqIEBwYXJhbSB5XG4gICAgICAgKiBAcGFyYW0gc2VsZWN0ZWRcbiAgICAgICAqIEBwYXJhbSBiYXNlbGluZVxuICAgICAgICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkKSB7XG4gICAgICAgIHZhciBiYXNlbGluZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gNCB8fCBhcmd1bWVudHNbNF0gPT09IHVuZGVmaW5lZCA/ICdtaWRkbGUnIDogYXJndW1lbnRzWzRdO1xuXG4gICAgICAgIC8vIGlmIG5vIGxhYmVsLCByZXR1cm5cbiAgICAgICAgaWYgKHRoaXMubm9kZU9wdGlvbnMubGFiZWwgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIHdlIGhhdmUgdG8gcmVuZGVyIHRoZSBsYWJlbFxuICAgICAgICB2YXIgdmlld0ZvbnRTaXplID0gdGhpcy5mb250T3B0aW9ucy5zaXplICogdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICAgIGlmICh0aGlzLm5vZGVPcHRpb25zLmxhYmVsICYmIHZpZXdGb250U2l6ZSA8IHRoaXMubm9kZU9wdGlvbnMuc2NhbGluZy5sYWJlbC5kcmF3VGhyZXNob2xkIC0gMSkgcmV0dXJuO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgc2l6ZSBjYWNoZSBpZiByZXF1aXJlZFxuICAgICAgICB0aGlzLmNhbGN1bGF0ZUxhYmVsU2l6ZShjdHgsIHNlbGVjdGVkLCB4LCB5LCBiYXNlbGluZSk7XG5cbiAgICAgICAgLy8gY3JlYXRlIHRoZSBmb250ZmlsbCBiYWNrZ3JvdW5kXG4gICAgICAgIHRoaXMuX2RyYXdCYWNrZ3JvdW5kKGN0eCk7XG4gICAgICAgIC8vIGRyYXcgdGV4dFxuICAgICAgICB0aGlzLl9kcmF3VGV4dChjdHgsIHNlbGVjdGVkLCB4LCB5LCBiYXNlbGluZSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRHJhd3MgdGhlIGxhYmVsIGJhY2tncm91bmRcbiAgICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19kcmF3QmFja2dyb3VuZCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdCYWNrZ3JvdW5kKGN0eCkge1xuICAgICAgICBpZiAodGhpcy5mb250T3B0aW9ucy5iYWNrZ3JvdW5kICE9PSB1bmRlZmluZWQgJiYgdGhpcy5mb250T3B0aW9ucy5iYWNrZ3JvdW5kICE9PSBcIm5vbmVcIikge1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmZvbnRPcHRpb25zLmJhY2tncm91bmQ7XG5cbiAgICAgICAgICB2YXIgbGluZU1hcmdpbiA9IDI7XG5cbiAgICAgICAgICBpZiAodGhpcy5pc0VkZ2VMYWJlbCkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmZvbnRPcHRpb25zLmFsaWduKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KC10aGlzLnNpemUud2lkdGggKiAwLjUsIC10aGlzLnNpemUuaGVpZ2h0ICogMC41LCB0aGlzLnNpemUud2lkdGgsIHRoaXMuc2l6ZS5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCgtdGhpcy5zaXplLndpZHRoICogMC41LCAtKHRoaXMuc2l6ZS5oZWlnaHQgKyBsaW5lTWFyZ2luKSwgdGhpcy5zaXplLndpZHRoLCB0aGlzLnNpemUuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoLXRoaXMuc2l6ZS53aWR0aCAqIDAuNSwgbGluZU1hcmdpbiwgdGhpcy5zaXplLndpZHRoLCB0aGlzLnNpemUuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QodGhpcy5zaXplLmxlZnQsIHRoaXMuc2l6ZS50b3AgLSAwLjUgKiBsaW5lTWFyZ2luLCB0aGlzLnNpemUud2lkdGgsIHRoaXMuc2l6ZS5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHguZmlsbFJlY3QodGhpcy5zaXplLmxlZnQsIHRoaXMuc2l6ZS50b3AgLSAwLjUgKiBsaW5lTWFyZ2luLCB0aGlzLnNpemUud2lkdGgsIHRoaXMuc2l6ZS5oZWlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gY3R4XG4gICAgICAgKiBAcGFyYW0geFxuICAgICAgICogQHBhcmFtIGJhc2VsaW5lXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZHJhd1RleHQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3VGV4dChjdHgsIHNlbGVjdGVkLCB4LCB5KSB7XG4gICAgICAgIHZhciBiYXNlbGluZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gNCB8fCBhcmd1bWVudHNbNF0gPT09IHVuZGVmaW5lZCA/ICdtaWRkbGUnIDogYXJndW1lbnRzWzRdO1xuXG4gICAgICAgIHZhciBmb250U2l6ZSA9IHRoaXMuZm9udE9wdGlvbnMuc2l6ZTtcbiAgICAgICAgdmFyIHZpZXdGb250U2l6ZSA9IGZvbnRTaXplICogdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICAgIC8vIHRoaXMgZW5zdXJlcyB0aGF0IHRoZXJlIHdpbGwgbm90IGJlIEhVR0UgbGV0dGVycyBvbiBzY3JlZW4gYnkgc2V0dGluZyBhbiB1cHBlciBsaW1pdCBvbiB0aGUgdmlzaWJsZSB0ZXh0IHNpemUgKHJlZ2FyZGxlc3Mgb2Ygem9vbUxldmVsKVxuICAgICAgICBpZiAodmlld0ZvbnRTaXplID49IHRoaXMubm9kZU9wdGlvbnMuc2NhbGluZy5sYWJlbC5tYXhWaXNpYmxlKSB7XG4gICAgICAgICAgZm9udFNpemUgPSBOdW1iZXIodGhpcy5ub2RlT3B0aW9ucy5zY2FsaW5nLmxhYmVsLm1heFZpc2libGUpIC8gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeUxpbmUgPSB0aGlzLnNpemUueUxpbmU7XG5cbiAgICAgICAgdmFyIF9nZXRDb2xvcjIgPSB0aGlzLl9nZXRDb2xvcih2aWV3Rm9udFNpemUpO1xuXG4gICAgICAgIHZhciBfZ2V0Q29sb3IzID0gX3NsaWNlZFRvQXJyYXkoX2dldENvbG9yMiwgMik7XG5cbiAgICAgICAgdmFyIGZvbnRDb2xvciA9IF9nZXRDb2xvcjNbMF07XG4gICAgICAgIHZhciBzdHJva2VDb2xvciA9IF9nZXRDb2xvcjNbMV07XG5cblxuICAgICAgICAvLyBjb25maWd1cmUgY29udGV4dCBmb3IgZHJhd2luZyB0aGUgdGV4dFxuXG4gICAgICAgIHZhciBfc2V0QWxpZ25tZW50MiA9IHRoaXMuX3NldEFsaWdubWVudChjdHgsIHgsIHlMaW5lLCBiYXNlbGluZSk7XG5cbiAgICAgICAgdmFyIF9zZXRBbGlnbm1lbnQzID0gX3NsaWNlZFRvQXJyYXkoX3NldEFsaWdubWVudDIsIDIpO1xuXG4gICAgICAgIHggPSBfc2V0QWxpZ25tZW50M1swXTtcbiAgICAgICAgeUxpbmUgPSBfc2V0QWxpZ25tZW50M1sxXTtcbiAgICAgICAgY3R4LmZvbnQgPSAoc2VsZWN0ZWQgJiYgdGhpcy5ub2RlT3B0aW9ucy5sYWJlbEhpZ2hsaWdodEJvbGQgPyAnYm9sZCAnIDogJycpICsgZm9udFNpemUgKyBcInB4IFwiICsgdGhpcy5mb250T3B0aW9ucy5mYWNlO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gZm9udENvbG9yO1xuICAgICAgICAvLyBXaGVuIHRoZSB0ZXh0QWxpZ24gcHJvcGVydHkgaXMgJ2xlZnQnLCBtYWtlIGxhYmVsIGxlZnQtanVzdGlmaWVkXG4gICAgICAgIGlmICghdGhpcy5pc0VkZ2VMYWJlbCAmJiB0aGlzLmZvbnRPcHRpb25zLmFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgICBjdHgudGV4dEFsaWduID0gdGhpcy5mb250T3B0aW9ucy5hbGlnbjtcbiAgICAgICAgICB4ID0geCAtIDAuNSAqIHRoaXMuc2l6ZS53aWR0aDsgLy8gU2hpZnQgbGFiZWwgMS8yLWRpc3RhbmNlIHRvIHRoZSBsZWZ0XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCB0aGUgc3Ryb2tlV2lkdGhcbiAgICAgICAgaWYgKHRoaXMuZm9udE9wdGlvbnMuc3Ryb2tlV2lkdGggPiAwKSB7XG4gICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuZm9udE9wdGlvbnMuc3Ryb2tlV2lkdGg7XG4gICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlQ29sb3I7XG4gICAgICAgICAgY3R4LmxpbmVKb2luID0gJ3JvdW5kJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRyYXcgdGhlIHRleHRcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpbmVDb3VudDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZm9udE9wdGlvbnMuc3Ryb2tlV2lkdGggPiAwKSB7XG4gICAgICAgICAgICBjdHguc3Ryb2tlVGV4dCh0aGlzLmxpbmVzW2ldLCB4LCB5TGluZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eC5maWxsVGV4dCh0aGlzLmxpbmVzW2ldLCB4LCB5TGluZSk7XG4gICAgICAgICAgeUxpbmUgKz0gZm9udFNpemU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc2V0QWxpZ25tZW50JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0QWxpZ25tZW50KGN0eCwgeCwgeUxpbmUsIGJhc2VsaW5lKSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciBsYWJlbCBhbGlnbm1lbnQgKGZvciBlZGdlcylcbiAgICAgICAgLy8gVE9ETzogbWFrZSBhbGlnbm1lbnQgZm9yIG5vZGVzXG4gICAgICAgIGlmICh0aGlzLmlzRWRnZUxhYmVsICYmIHRoaXMuZm9udE9wdGlvbnMuYWxpZ24gIT09ICdob3Jpem9udGFsJyAmJiB0aGlzLnBvaW50VG9TZWxmID09PSBmYWxzZSkge1xuICAgICAgICAgIHggPSAwO1xuICAgICAgICAgIHlMaW5lID0gMDtcblxuICAgICAgICAgIHZhciBsaW5lTWFyZ2luID0gMjtcbiAgICAgICAgICBpZiAodGhpcy5mb250T3B0aW9ucy5hbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnYWxwaGFiZXRpYyc7XG4gICAgICAgICAgICB5TGluZSAtPSAyICogbGluZU1hcmdpbjsgLy8gZGlzdGFuY2UgZnJvbSBlZGdlLCByZXF1aXJlZCBiZWNhdXNlIHdlIHVzZSBhbHBoYWJldGljLiBBbHBoYWJldGljIGhhcyBsZXNzIGRpZmZlcmVuY2UgYmV0d2VlbiBicm93c2Vyc1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5mb250T3B0aW9ucy5hbGlnbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdoYW5naW5nJztcbiAgICAgICAgICAgICAgeUxpbmUgKz0gMiAqIGxpbmVNYXJnaW47IC8vIGRpc3RhbmNlIGZyb20gZWRnZSwgcmVxdWlyZWQgYmVjYXVzZSB3ZSB1c2UgaGFuZ2luZy4gSGFuZ2luZyBoYXMgbGVzcyBkaWZmZXJlbmNlIGJldHdlZW4gYnJvd3NlcnNcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IGJhc2VsaW5lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFt4LCB5TGluZV07XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogZmFkZSBpbiB3aGVuIHJlbGF0aXZlIHNjYWxlIGlzIGJldHdlZW4gdGhyZXNob2xkIGFuZCB0aHJlc2hvbGQgLSAxLlxuICAgICAgICogSWYgdGhlIHJlbGF0aXZlIHNjYWxlIHdvdWxkIGJlIHNtYWxsZXIgdGhhbiB0aHJlc2hvbGQgLTEgdGhlIGRyYXcgZnVuY3Rpb24gd291bGQgaGF2ZSByZXR1cm5lZCBiZWZvcmUgY29taW5nIGhlcmUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHZpZXdGb250U2l6ZVxuICAgICAgICogQHJldHVybnMgeypbXX1cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19nZXRDb2xvcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldENvbG9yKHZpZXdGb250U2l6ZSkge1xuICAgICAgICB2YXIgZm9udENvbG9yID0gdGhpcy5mb250T3B0aW9ucy5jb2xvciB8fCAnIzAwMDAwMCc7XG4gICAgICAgIHZhciBzdHJva2VDb2xvciA9IHRoaXMuZm9udE9wdGlvbnMuc3Ryb2tlQ29sb3IgfHwgJyNmZmZmZmYnO1xuICAgICAgICBpZiAodmlld0ZvbnRTaXplIDw9IHRoaXMubm9kZU9wdGlvbnMuc2NhbGluZy5sYWJlbC5kcmF3VGhyZXNob2xkKSB7XG4gICAgICAgICAgdmFyIG9wYWNpdHkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCAxIC0gKHRoaXMubm9kZU9wdGlvbnMuc2NhbGluZy5sYWJlbC5kcmF3VGhyZXNob2xkIC0gdmlld0ZvbnRTaXplKSkpO1xuICAgICAgICAgIGZvbnRDb2xvciA9IHV0aWwub3ZlcnJpZGVPcGFjaXR5KGZvbnRDb2xvciwgb3BhY2l0eSk7XG4gICAgICAgICAgc3Ryb2tlQ29sb3IgPSB1dGlsLm92ZXJyaWRlT3BhY2l0eShzdHJva2VDb2xvciwgb3BhY2l0eSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtmb250Q29sb3IsIHN0cm9rZUNvbG9yXTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIGN0eFxuICAgICAgICogQHBhcmFtIHNlbGVjdGVkXG4gICAgICAgKiBAcmV0dXJucyB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX1cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0VGV4dFNpemUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRleHRTaXplKGN0eCkge1xuICAgICAgICB2YXIgc2VsZWN0ZWQgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICB2YXIgc2l6ZSA9IHtcbiAgICAgICAgICB3aWR0aDogdGhpcy5fcHJvY2Vzc0xhYmVsKGN0eCwgc2VsZWN0ZWQpLFxuICAgICAgICAgIGhlaWdodDogdGhpcy5mb250T3B0aW9ucy5zaXplICogdGhpcy5saW5lQ291bnQsXG4gICAgICAgICAgbGluZUNvdW50OiB0aGlzLmxpbmVDb3VudFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIGN0eFxuICAgICAgICogQHBhcmFtIHNlbGVjdGVkXG4gICAgICAgKiBAcGFyYW0geFxuICAgICAgICogQHBhcmFtIHlcbiAgICAgICAqIEBwYXJhbSBiYXNlbGluZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdjYWxjdWxhdGVMYWJlbFNpemUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZUxhYmVsU2l6ZShjdHgsIHNlbGVjdGVkKSB7XG4gICAgICAgIHZhciB4ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gMCA6IGFyZ3VtZW50c1syXTtcbiAgICAgICAgdmFyIHkgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDMgfHwgYXJndW1lbnRzWzNdID09PSB1bmRlZmluZWQgPyAwIDogYXJndW1lbnRzWzNdO1xuICAgICAgICB2YXIgYmFzZWxpbmUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDQgfHwgYXJndW1lbnRzWzRdID09PSB1bmRlZmluZWQgPyAnbWlkZGxlJyA6IGFyZ3VtZW50c1s0XTtcblxuICAgICAgICBpZiAodGhpcy5sYWJlbERpcnR5ID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5zaXplLndpZHRoID0gdGhpcy5fcHJvY2Vzc0xhYmVsKGN0eCwgc2VsZWN0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2l6ZS5oZWlnaHQgPSB0aGlzLmZvbnRPcHRpb25zLnNpemUgKiB0aGlzLmxpbmVDb3VudDtcbiAgICAgICAgdGhpcy5zaXplLmxlZnQgPSB4IC0gdGhpcy5zaXplLndpZHRoICogMC41O1xuICAgICAgICB0aGlzLnNpemUudG9wID0geSAtIHRoaXMuc2l6ZS5oZWlnaHQgKiAwLjU7XG4gICAgICAgIHRoaXMuc2l6ZS55TGluZSA9IHkgKyAoMSAtIHRoaXMubGluZUNvdW50KSAqIDAuNSAqIHRoaXMuZm9udE9wdGlvbnMuc2l6ZTtcbiAgICAgICAgaWYgKGJhc2VsaW5lID09PSBcImhhbmdpbmdcIikge1xuICAgICAgICAgIHRoaXMuc2l6ZS50b3AgKz0gMC41ICogdGhpcy5mb250T3B0aW9ucy5zaXplO1xuICAgICAgICAgIHRoaXMuc2l6ZS50b3AgKz0gNDsgLy8gZGlzdGFuY2UgZnJvbSBub2RlLCByZXF1aXJlZCBiZWNhdXNlIHdlIHVzZSBoYW5naW5nLiBIYW5naW5nIGhhcyBsZXNzIGRpZmZlcmVuY2UgYmV0d2VlbiBicm93c2Vyc1xuICAgICAgICAgIHRoaXMuc2l6ZS55TGluZSArPSA0OyAvLyBkaXN0YW5jZSBmcm9tIG5vZGVcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGFiZWxEaXJ0eSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgY2FsY3VsYXRlcyB0aGUgd2lkdGggYXMgd2VsbCBhcyBleHBsb2RlcyB0aGUgbGFiZWwgc3RyaW5nIGFuZCBjYWxjdWxhdGVzIHRoZSBhbW91bnQgb2YgbGluZXMuXG4gICAgICAgKiBAcGFyYW0gY3R4XG4gICAgICAgKiBAcGFyYW0gc2VsZWN0ZWRcbiAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfcHJvY2Vzc0xhYmVsJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcHJvY2Vzc0xhYmVsKGN0eCwgc2VsZWN0ZWQpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gMDtcbiAgICAgICAgdmFyIGxpbmVzID0gWycnXTtcbiAgICAgICAgdmFyIGxpbmVDb3VudCA9IDA7XG4gICAgICAgIGlmICh0aGlzLm5vZGVPcHRpb25zLmxhYmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBsaW5lcyA9IFN0cmluZyh0aGlzLm5vZGVPcHRpb25zLmxhYmVsKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgbGluZUNvdW50ID0gbGluZXMubGVuZ3RoO1xuICAgICAgICAgIGN0eC5mb250ID0gKHNlbGVjdGVkICYmIHRoaXMubm9kZU9wdGlvbnMubGFiZWxIaWdobGlnaHRCb2xkID8gJ2JvbGQgJyA6ICcnKSArIHRoaXMuZm9udE9wdGlvbnMuc2l6ZSArIFwicHggXCIgKyB0aGlzLmZvbnRPcHRpb25zLmZhY2U7XG4gICAgICAgICAgd2lkdGggPSBjdHgubWVhc3VyZVRleHQobGluZXNbMF0pLndpZHRoO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGluZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsaW5lV2lkdGggPSBjdHgubWVhc3VyZVRleHQobGluZXNbaV0pLndpZHRoO1xuICAgICAgICAgICAgd2lkdGggPSBsaW5lV2lkdGggPiB3aWR0aCA/IGxpbmVXaWR0aCA6IHdpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpbmVzID0gbGluZXM7XG4gICAgICAgIHRoaXMubGluZUNvdW50ID0gbGluZUNvdW50O1xuXG4gICAgICAgIHJldHVybiB3aWR0aDtcbiAgICAgIH1cbiAgICB9XSwgW3tcbiAgICAgIGtleTogJ3BhcnNlT3B0aW9ucycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VPcHRpb25zKHBhcmVudE9wdGlvbnMsIG5ld09wdGlvbnMpIHtcbiAgICAgICAgdmFyIGFsbG93RGVsZXRpb24gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1syXTtcblxuICAgICAgICBpZiAodHlwZW9mIG5ld09wdGlvbnMuZm9udCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB2YXIgbmV3T3B0aW9uc0FycmF5ID0gbmV3T3B0aW9ucy5mb250LnNwbGl0KFwiIFwiKTtcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLnNpemUgPSBuZXdPcHRpb25zQXJyYXlbMF0ucmVwbGFjZShcInB4XCIsICcnKTtcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLmZhY2UgPSBuZXdPcHRpb25zQXJyYXlbMV07XG4gICAgICAgICAgcGFyZW50T3B0aW9ucy5jb2xvciA9IG5ld09wdGlvbnNBcnJheVsyXTtcbiAgICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKG5ld09wdGlvbnMuZm9udCkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdXRpbC5maWxsSWZEZWZpbmVkKHBhcmVudE9wdGlvbnMsIG5ld09wdGlvbnMuZm9udCwgYWxsb3dEZWxldGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50T3B0aW9ucy5zaXplID0gTnVtYmVyKHBhcmVudE9wdGlvbnMuc2l6ZSk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIExhYmVsO1xuICB9KCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gTGFiZWw7XG5cbi8qKiovIH0sXG4vKiA2NyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgdmFyIF9Ob2RlQmFzZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4KTtcblxuICB2YXIgX05vZGVCYXNlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX05vZGVCYXNlMik7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG4gIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4gIHZhciBCb3ggPSBmdW5jdGlvbiAoX05vZGVCYXNlKSB7XG4gICAgX2luaGVyaXRzKEJveCwgX05vZGVCYXNlKTtcblxuICAgIGZ1bmN0aW9uIEJveChvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJveCk7XG5cbiAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQm94KS5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEJveCwgW3tcbiAgICAgIGtleTogJ3Jlc2l6ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKGN0eCwgc2VsZWN0ZWQpIHtcbiAgICAgICAgaWYgKHRoaXMud2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBtYXJnaW4gPSA1O1xuICAgICAgICAgIHZhciB0ZXh0U2l6ZSA9IHRoaXMubGFiZWxNb2R1bGUuZ2V0VGV4dFNpemUoY3R4LCBzZWxlY3RlZCk7XG4gICAgICAgICAgdGhpcy53aWR0aCA9IHRleHRTaXplLndpZHRoICsgMiAqIG1hcmdpbjtcbiAgICAgICAgICB0aGlzLmhlaWdodCA9IHRleHRTaXplLmhlaWdodCArIDIgKiBtYXJnaW47XG4gICAgICAgICAgdGhpcy5yYWRpdXMgPSAwLjUgKiB0aGlzLndpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZHJhdycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgICB0aGlzLnJlc2l6ZShjdHgsIHNlbGVjdGVkKTtcbiAgICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggLyAyO1xuICAgICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAvIDI7XG5cbiAgICAgICAgdmFyIGJvcmRlcldpZHRoID0gdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoO1xuICAgICAgICB2YXIgc2VsZWN0aW9uTGluZVdpZHRoID0gdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoU2VsZWN0ZWQgfHwgMiAqIHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aDtcblxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzZWxlY3RlZCA/IHRoaXMub3B0aW9ucy5jb2xvci5oaWdobGlnaHQuYm9yZGVyIDogaG92ZXIgPyB0aGlzLm9wdGlvbnMuY29sb3IuaG92ZXIuYm9yZGVyIDogdGhpcy5vcHRpb25zLmNvbG9yLmJvcmRlcjtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHNlbGVjdGVkID8gc2VsZWN0aW9uTGluZVdpZHRoIDogYm9yZGVyV2lkdGg7XG4gICAgICAgIGN0eC5saW5lV2lkdGggLz0gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBNYXRoLm1pbih0aGlzLndpZHRoLCBjdHgubGluZVdpZHRoKTtcblxuICAgICAgICBjdHguZmlsbFN0eWxlID0gc2VsZWN0ZWQgPyB0aGlzLm9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0LmJhY2tncm91bmQgOiBob3ZlciA/IHRoaXMub3B0aW9ucy5jb2xvci5ob3Zlci5iYWNrZ3JvdW5kIDogdGhpcy5vcHRpb25zLmNvbG9yLmJhY2tncm91bmQ7XG5cbiAgICAgICAgdmFyIGJvcmRlclJhZGl1cyA9IHRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMuYm9yZGVyUmFkaXVzOyAvLyBvbmx5IGVmZmVjdGl2ZSBmb3IgYm94XG4gICAgICAgIGN0eC5yb3VuZFJlY3QodGhpcy5sZWZ0LCB0aGlzLnRvcCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIGJvcmRlclJhZGl1cyk7XG5cbiAgICAgICAgLy8gZHJhdyBzaGFkb3cgaWYgZW5hYmxlZFxuICAgICAgICB0aGlzLmVuYWJsZVNoYWRvdyhjdHgpO1xuICAgICAgICAvLyBkcmF3IHRoZSBiYWNrZ3JvdW5kXG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIC8vIGRpc2FibGUgc2hhZG93cyBmb3Igb3RoZXIgZWxlbWVudHMuXG4gICAgICAgIHRoaXMuZGlzYWJsZVNoYWRvdyhjdHgpO1xuXG4gICAgICAgIC8vZHJhdyBkYXNoZWQgYm9yZGVyIGlmIGVuYWJsZWQsIHNhdmUgYW5kIHJlc3RvcmUgaXMgcmVxdWlyZWQgZm9yIGZpcmVmb3ggbm90IHRvIGNyYXNoIG9uIHVuaXguXG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIC8vIGlmIGJvcmRlcnMgYXJlIHplcm8gd2lkdGgsIHRoZXkgd2lsbCBiZSBkcmF3biB3aXRoIHdpZHRoIDEgYnkgZGVmYXVsdC4gVGhpcyBwcmV2ZW50cyB0aGF0XG4gICAgICAgIGlmIChib3JkZXJXaWR0aCA+IDApIHtcbiAgICAgICAgICB0aGlzLmVuYWJsZUJvcmRlckRhc2hlcyhjdHgpO1xuICAgICAgICAgIC8vZHJhdyB0aGUgYm9yZGVyXG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgIC8vZGlzYWJsZSBkYXNoZWQgYm9yZGVyIGZvciBvdGhlciBlbGVtZW50c1xuICAgICAgICAgIHRoaXMuZGlzYWJsZUJvcmRlckRhc2hlcyhjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ0JveCh4LCB5LCBjdHgsIHNlbGVjdGVkKTtcbiAgICAgICAgdGhpcy5sYWJlbE1vZHVsZS5kcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3VwZGF0ZUJvdW5kaW5nQm94JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVCb3VuZGluZ0JveCh4LCB5LCBjdHgsIHNlbGVjdGVkKSB7XG4gICAgICAgIHRoaXMucmVzaXplKGN0eCwgc2VsZWN0ZWQpO1xuICAgICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAqIDAuNTtcbiAgICAgICAgdGhpcy50b3AgPSB5IC0gdGhpcy5oZWlnaHQgKiAwLjU7XG5cbiAgICAgICAgdmFyIGJvcmRlclJhZGl1cyA9IHRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMuYm9yZGVyUmFkaXVzOyAvLyBvbmx5IGVmZmVjdGl2ZSBmb3IgYm94XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gubGVmdCA9IHRoaXMubGVmdCAtIGJvcmRlclJhZGl1cztcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC50b3AgPSB0aGlzLnRvcCAtIGJvcmRlclJhZGl1cztcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gPSB0aGlzLnRvcCArIHRoaXMuaGVpZ2h0ICsgYm9yZGVyUmFkaXVzO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LnJpZ2h0ID0gdGhpcy5sZWZ0ICsgdGhpcy53aWR0aCArIGJvcmRlclJhZGl1cztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkaXN0YW5jZVRvQm9yZGVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgICAgdGhpcy5yZXNpemUoY3R4KTtcbiAgICAgICAgdmFyIGJvcmRlcldpZHRoID0gdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoO1xuXG4gICAgICAgIHJldHVybiBNYXRoLm1pbihNYXRoLmFicyh0aGlzLndpZHRoIC8gMiAvIE1hdGguY29zKGFuZ2xlKSksIE1hdGguYWJzKHRoaXMuaGVpZ2h0IC8gMiAvIE1hdGguc2luKGFuZ2xlKSkpICsgYm9yZGVyV2lkdGg7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEJveDtcbiAgfShfTm9kZUJhc2UzLmRlZmF1bHQpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IEJveDtcblxuLyoqKi8gfSxcbi8qIDY4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuICBcInVzZSBzdHJpY3RcIjtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgdmFyIE5vZGVCYXNlID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vZGVCYXNlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9kZUJhc2UpO1xuXG4gICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgdGhpcy5sYWJlbE1vZHVsZSA9IGxhYmVsTW9kdWxlO1xuICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgdGhpcy50b3AgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmxlZnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3ggPSB7IHRvcDogMCwgbGVmdDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCB9O1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhOb2RlQmFzZSwgW3tcbiAgICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9kaXN0YW5jZVRvQm9yZGVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2Rpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgICB2YXIgYm9yZGVyV2lkdGggPSB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgICAgIHRoaXMucmVzaXplKGN0eCk7XG4gICAgICAgIHJldHVybiBNYXRoLm1pbihNYXRoLmFicyh0aGlzLndpZHRoIC8gMiAvIE1hdGguY29zKGFuZ2xlKSksIE1hdGguYWJzKHRoaXMuaGVpZ2h0IC8gMiAvIE1hdGguc2luKGFuZ2xlKSkpICsgYm9yZGVyV2lkdGg7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImVuYWJsZVNoYWRvd1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZVNoYWRvdyhjdHgpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaGFkb3cuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IHRoaXMub3B0aW9ucy5zaGFkb3cuY29sb3I7XG4gICAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSB0aGlzLm9wdGlvbnMuc2hhZG93LnNpemU7XG4gICAgICAgICAgY3R4LnNoYWRvd09mZnNldFggPSB0aGlzLm9wdGlvbnMuc2hhZG93Lng7XG4gICAgICAgICAgY3R4LnNoYWRvd09mZnNldFkgPSB0aGlzLm9wdGlvbnMuc2hhZG93Lnk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZGlzYWJsZVNoYWRvd1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGVTaGFkb3coY3R4KSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hhZG93LmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSAncmdiYSgwLDAsMCwwKSc7XG4gICAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSAwO1xuICAgICAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gMDtcbiAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZW5hYmxlQm9yZGVyRGFzaGVzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlQm9yZGVyRGFzaGVzKGN0eCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5ib3JkZXJEYXNoZXMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKGN0eC5zZXRMaW5lRGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgZGFzaGVzID0gdGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5ib3JkZXJEYXNoZXM7XG4gICAgICAgICAgICBpZiAoZGFzaGVzID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIGRhc2hlcyA9IFs1LCAxNV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguc2V0TGluZURhc2goZGFzaGVzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwic2V0TGluZURhc2ggaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIuIFRoZSBkYXNoZWQgYm9yZGVycyBjYW5ub3QgYmUgdXNlZC5cIik7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLmJvcmRlckRhc2hlcyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkaXNhYmxlQm9yZGVyRGFzaGVzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzYWJsZUJvcmRlckRhc2hlcyhjdHgpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMuYm9yZGVyRGFzaGVzICE9PSBmYWxzZSkge1xuICAgICAgICAgIGlmIChjdHguc2V0TGluZURhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY3R4LnNldExpbmVEYXNoKFswXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcInNldExpbmVEYXNoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyLiBUaGUgZGFzaGVkIGJvcmRlcnMgY2Fubm90IGJlIHVzZWQuXCIpO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5ib3JkZXJEYXNoZXMgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gTm9kZUJhc2U7XG4gIH0oKTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBOb2RlQmFzZTtcblxuLyoqKi8gfSxcbi8qIDY5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX0NpcmNsZUltYWdlQmFzZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwKTtcblxuICB2YXIgX0NpcmNsZUltYWdlQmFzZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DaXJjbGVJbWFnZUJhc2UyKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbiAgdmFyIENpcmNsZSA9IGZ1bmN0aW9uIChfQ2lyY2xlSW1hZ2VCYXNlKSB7XG4gICAgX2luaGVyaXRzKENpcmNsZSwgX0NpcmNsZUltYWdlQmFzZSk7XG5cbiAgICBmdW5jdGlvbiBDaXJjbGUob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDaXJjbGUpO1xuXG4gICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKENpcmNsZSkuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhDaXJjbGUsIFt7XG4gICAgICBrZXk6ICdyZXNpemUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShjdHgsIHNlbGVjdGVkKSB7XG4gICAgICAgIGlmICh0aGlzLndpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgbWFyZ2luID0gNTtcbiAgICAgICAgICB2YXIgdGV4dFNpemUgPSB0aGlzLmxhYmVsTW9kdWxlLmdldFRleHRTaXplKGN0eCwgc2VsZWN0ZWQpO1xuICAgICAgICAgIHZhciBkaWFtZXRlciA9IE1hdGgubWF4KHRleHRTaXplLndpZHRoLCB0ZXh0U2l6ZS5oZWlnaHQpICsgMiAqIG1hcmdpbjtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuc2l6ZSA9IGRpYW1ldGVyIC8gMjtcblxuICAgICAgICAgIHRoaXMud2lkdGggPSBkaWFtZXRlcjtcbiAgICAgICAgICB0aGlzLmhlaWdodCA9IGRpYW1ldGVyO1xuICAgICAgICAgIHRoaXMucmFkaXVzID0gMC41ICogdGhpcy53aWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2RyYXcnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgICAgdGhpcy5yZXNpemUoY3R4LCBzZWxlY3RlZCk7XG4gICAgICAgIHRoaXMubGVmdCA9IHggLSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgdGhpcy50b3AgPSB5IC0gdGhpcy5oZWlnaHQgLyAyO1xuXG4gICAgICAgIHRoaXMuX2RyYXdSYXdDaXJjbGUoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHRoaXMub3B0aW9ucy5zaXplKTtcblxuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LnRvcCA9IHkgLSB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0geCAtIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LnJpZ2h0ID0geCArIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSA9IHkgKyB0aGlzLm9wdGlvbnMuc2l6ZTtcblxuICAgICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nQm94KHgsIHkpO1xuICAgICAgICB0aGlzLmxhYmVsTW9kdWxlLmRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAndXBkYXRlQm91bmRpbmdCb3gnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kaW5nQm94KHgsIHkpIHtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC50b3AgPSB5IC0gdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gubGVmdCA9IHggLSB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5yaWdodCA9IHggKyB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gPSB5ICsgdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZGlzdGFuY2VUb0JvcmRlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICAgIHRoaXMucmVzaXplKGN0eCk7XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoICogMC41O1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBDaXJjbGU7XG4gIH0oX0NpcmNsZUltYWdlQmFzZTMuZGVmYXVsdCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gQ2lyY2xlO1xuXG4vKioqLyB9LFxuLyogNzAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIHZhciBfTm9kZUJhc2UyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OCk7XG5cbiAgdmFyIF9Ob2RlQmFzZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Ob2RlQmFzZTIpO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuICBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuICB2YXIgQ2lyY2xlSW1hZ2VCYXNlID0gZnVuY3Rpb24gKF9Ob2RlQmFzZSkge1xuICAgIF9pbmhlcml0cyhDaXJjbGVJbWFnZUJhc2UsIF9Ob2RlQmFzZSk7XG5cbiAgICBmdW5jdGlvbiBDaXJjbGVJbWFnZUJhc2Uob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDaXJjbGVJbWFnZUJhc2UpO1xuXG4gICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ2lyY2xlSW1hZ2VCYXNlKS5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSk7XG5cbiAgICAgIF90aGlzLmxhYmVsT2Zmc2V0ID0gMDtcbiAgICAgIF90aGlzLmltYWdlTG9hZGVkID0gZmFsc2U7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKENpcmNsZUltYWdlQmFzZSwgW3tcbiAgICAgIGtleTogJ3NldE9wdGlvbnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucywgaW1hZ2VPYmopIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgaWYgKGltYWdlT2JqKSB7XG4gICAgICAgICAgdGhpcy5pbWFnZU9iaiA9IGltYWdlT2JqO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBmdW5jdGlvbiByZXNpemVzIHRoZSBpbWFnZSBieSB0aGUgb3B0aW9ucyBzaXplIHdoZW4gdGhlIGltYWdlIGhhcyBub3QgeWV0IGxvYWRlZC4gSWYgdGhlIGltYWdlIGhhcyBsb2FkZWQsIHdlXG4gICAgICAgKiBmb3JjZSB0aGUgdXBkYXRlIG9mIHRoZSBzaXplIGFnYWluLlxuICAgICAgICpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19yZXNpemVJbWFnZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc2l6ZUltYWdlKCkge1xuICAgICAgICB2YXIgZm9yY2UgPSBmYWxzZTtcbiAgICAgICAgaWYgKCF0aGlzLmltYWdlT2JqLndpZHRoIHx8ICF0aGlzLmltYWdlT2JqLmhlaWdodCkge1xuICAgICAgICAgIC8vIHVuZGVmaW5lZCBvciAwXG4gICAgICAgICAgdGhpcy5pbWFnZUxvYWRlZCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaW1hZ2VMb2FkZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhpcy5pbWFnZUxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgZm9yY2UgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLndpZHRoIHx8ICF0aGlzLmhlaWdodCB8fCBmb3JjZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIC8vIHVuZGVmaW5lZCBvciAwXG4gICAgICAgICAgdmFyIHdpZHRoLCBoZWlnaHQsIHJhdGlvO1xuICAgICAgICAgIGlmICh0aGlzLmltYWdlT2JqLndpZHRoICYmIHRoaXMuaW1hZ2VPYmouaGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyBub3QgdW5kZWZpbmVkIG9yIDBcbiAgICAgICAgICAgIHdpZHRoID0gMDtcbiAgICAgICAgICAgIGhlaWdodCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLnVzZUltYWdlU2l6ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmltYWdlT2JqLndpZHRoID4gdGhpcy5pbWFnZU9iai5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgcmF0aW8gPSB0aGlzLmltYWdlT2JqLndpZHRoIC8gdGhpcy5pbWFnZU9iai5oZWlnaHQ7XG4gICAgICAgICAgICAgIHdpZHRoID0gdGhpcy5vcHRpb25zLnNpemUgKiAyICogcmF0aW8gfHwgdGhpcy5pbWFnZU9iai53aWR0aDtcbiAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5vcHRpb25zLnNpemUgKiAyIHx8IHRoaXMuaW1hZ2VPYmouaGVpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuaW1hZ2VPYmoud2lkdGggJiYgdGhpcy5pbWFnZU9iai5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAvLyBub3QgdW5kZWZpbmVkIG9yIDBcbiAgICAgICAgICAgICAgICByYXRpbyA9IHRoaXMuaW1hZ2VPYmouaGVpZ2h0IC8gdGhpcy5pbWFnZU9iai53aWR0aDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByYXRpbyA9IDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd2lkdGggPSB0aGlzLm9wdGlvbnMuc2l6ZSAqIDI7XG4gICAgICAgICAgICAgIGhlaWdodCA9IHRoaXMub3B0aW9ucy5zaXplICogMiAqIHJhdGlvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB3aGVuIG5vdCB1c2luZyB0aGUgc2l6ZSBwcm9wZXJ0eSwgd2UgdXNlIHRoZSBpbWFnZSBzaXplXG4gICAgICAgICAgICB3aWR0aCA9IHRoaXMuaW1hZ2VPYmoud2lkdGg7XG4gICAgICAgICAgICBoZWlnaHQgPSB0aGlzLmltYWdlT2JqLmhlaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgIHRoaXMucmFkaXVzID0gMC41ICogdGhpcy53aWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19kcmF3UmF3Q2lyY2xlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd1Jhd0NpcmNsZShjdHgsIHgsIHksIHNlbGVjdGVkLCBob3Zlciwgc2l6ZSkge1xuICAgICAgICB2YXIgbmV1dHJhbGJvcmRlcldpZHRoID0gdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoO1xuICAgICAgICB2YXIgc2VsZWN0aW9uTGluZVdpZHRoID0gdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoU2VsZWN0ZWQgfHwgMiAqIHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgICAgICAgdmFyIGJvcmRlcldpZHRoID0gKHNlbGVjdGVkID8gc2VsZWN0aW9uTGluZVdpZHRoIDogbmV1dHJhbGJvcmRlcldpZHRoKSAvIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gTWF0aC5taW4odGhpcy53aWR0aCwgYm9yZGVyV2lkdGgpO1xuXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHNlbGVjdGVkID8gdGhpcy5vcHRpb25zLmNvbG9yLmhpZ2hsaWdodC5ib3JkZXIgOiBob3ZlciA/IHRoaXMub3B0aW9ucy5jb2xvci5ob3Zlci5ib3JkZXIgOiB0aGlzLm9wdGlvbnMuY29sb3IuYm9yZGVyO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gc2VsZWN0ZWQgPyB0aGlzLm9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0LmJhY2tncm91bmQgOiBob3ZlciA/IHRoaXMub3B0aW9ucy5jb2xvci5ob3Zlci5iYWNrZ3JvdW5kIDogdGhpcy5vcHRpb25zLmNvbG9yLmJhY2tncm91bmQ7XG4gICAgICAgIGN0eC5jaXJjbGUoeCwgeSwgc2l6ZSk7XG5cbiAgICAgICAgLy8gZHJhdyBzaGFkb3cgaWYgZW5hYmxlZFxuICAgICAgICB0aGlzLmVuYWJsZVNoYWRvdyhjdHgpO1xuICAgICAgICAvLyBkcmF3IHRoZSBiYWNrZ3JvdW5kXG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIC8vIGRpc2FibGUgc2hhZG93cyBmb3Igb3RoZXIgZWxlbWVudHMuXG4gICAgICAgIHRoaXMuZGlzYWJsZVNoYWRvdyhjdHgpO1xuXG4gICAgICAgIC8vZHJhdyBkYXNoZWQgYm9yZGVyIGlmIGVuYWJsZWQsIHNhdmUgYW5kIHJlc3RvcmUgaXMgcmVxdWlyZWQgZm9yIGZpcmVmb3ggbm90IHRvIGNyYXNoIG9uIHVuaXguXG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIC8vIGlmIGJvcmRlcnMgYXJlIHplcm8gd2lkdGgsIHRoZXkgd2lsbCBiZSBkcmF3biB3aXRoIHdpZHRoIDEgYnkgZGVmYXVsdC4gVGhpcyBwcmV2ZW50cyB0aGF0XG4gICAgICAgIGlmIChib3JkZXJXaWR0aCA+IDApIHtcbiAgICAgICAgICB0aGlzLmVuYWJsZUJvcmRlckRhc2hlcyhjdHgpO1xuICAgICAgICAgIC8vZHJhdyB0aGUgYm9yZGVyXG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgIC8vZGlzYWJsZSBkYXNoZWQgYm9yZGVyIGZvciBvdGhlciBlbGVtZW50c1xuICAgICAgICAgIHRoaXMuZGlzYWJsZUJvcmRlckRhc2hlcyhjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2RyYXdJbWFnZUF0UG9zaXRpb24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3SW1hZ2VBdFBvc2l0aW9uKGN0eCkge1xuICAgICAgICBpZiAodGhpcy5pbWFnZU9iai53aWR0aCAhPSAwKSB7XG4gICAgICAgICAgLy8gZHJhdyB0aGUgaW1hZ2VcbiAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxLjA7XG5cbiAgICAgICAgICAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG4gICAgICAgICAgdGhpcy5lbmFibGVTaGFkb3coY3R4KTtcblxuICAgICAgICAgIHZhciBmYWN0b3IgPSB0aGlzLmltYWdlT2JqLndpZHRoIC8gdGhpcy53aWR0aCAvIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgICAgIGlmIChmYWN0b3IgPiAyICYmIHRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMuaW50ZXJwb2xhdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIHcgPSB0aGlzLmltYWdlT2JqLndpZHRoO1xuICAgICAgICAgICAgdmFyIGggPSB0aGlzLmltYWdlT2JqLmhlaWdodDtcbiAgICAgICAgICAgIHZhciBjYW4yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICBjYW4yLndpZHRoID0gdztcbiAgICAgICAgICAgIGNhbjIuaGVpZ2h0ID0gdztcbiAgICAgICAgICAgIHZhciBjdHgyID0gY2FuMi5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgICAgICBmYWN0b3IgKj0gMC41O1xuICAgICAgICAgICAgdyAqPSAwLjU7XG4gICAgICAgICAgICBoICo9IDAuNTtcbiAgICAgICAgICAgIGN0eDIuZHJhd0ltYWdlKHRoaXMuaW1hZ2VPYmosIDAsIDAsIHcsIGgpO1xuXG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSAwO1xuICAgICAgICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAxO1xuICAgICAgICAgICAgd2hpbGUgKGZhY3RvciA+IDIgJiYgaXRlcmF0aW9ucyA8IDQpIHtcbiAgICAgICAgICAgICAgY3R4Mi5kcmF3SW1hZ2UoY2FuMiwgZGlzdGFuY2UsIDAsIHcsIGgsIGRpc3RhbmNlICsgdywgMCwgdyAvIDIsIGggLyAyKTtcbiAgICAgICAgICAgICAgZGlzdGFuY2UgKz0gdztcbiAgICAgICAgICAgICAgZmFjdG9yICo9IDAuNTtcbiAgICAgICAgICAgICAgdyAqPSAwLjU7XG4gICAgICAgICAgICAgIGggKj0gMC41O1xuICAgICAgICAgICAgICBpdGVyYXRpb25zICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKGNhbjIsIGRpc3RhbmNlLCAwLCB3LCBoLCB0aGlzLmxlZnQsIHRoaXMudG9wLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGRyYXcgaW1hZ2VcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5pbWFnZU9iaiwgdGhpcy5sZWZ0LCB0aGlzLnRvcCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGRpc2FibGUgc2hhZG93cyBmb3Igb3RoZXIgZWxlbWVudHMuXG4gICAgICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZHJhd0ltYWdlTGFiZWwnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3SW1hZ2VMYWJlbChjdHgsIHgsIHksIHNlbGVjdGVkKSB7XG4gICAgICAgIHZhciB5TGFiZWw7XG4gICAgICAgIHZhciBvZmZzZXQgPSAwO1xuXG4gICAgICAgIGlmICh0aGlzLmhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gdGhpcy5oZWlnaHQgKiAwLjU7XG4gICAgICAgICAgdmFyIGxhYmVsRGltZW5zaW9ucyA9IHRoaXMubGFiZWxNb2R1bGUuZ2V0VGV4dFNpemUoY3R4KTtcbiAgICAgICAgICBpZiAobGFiZWxEaW1lbnNpb25zLmxpbmVDb3VudCA+PSAxKSB7XG4gICAgICAgICAgICBvZmZzZXQgKz0gbGFiZWxEaW1lbnNpb25zLmhlaWdodCAvIDI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgeUxhYmVsID0geSArIG9mZnNldDtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxhYmVsKSB7XG4gICAgICAgICAgdGhpcy5sYWJlbE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhYmVsTW9kdWxlLmRyYXcoY3R4LCB4LCB5TGFiZWwsIHNlbGVjdGVkLCAnaGFuZ2luZycpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBDaXJjbGVJbWFnZUJhc2U7XG4gIH0oX05vZGVCYXNlMy5kZWZhdWx0KTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBDaXJjbGVJbWFnZUJhc2U7XG5cbi8qKiovIH0sXG4vKiA3MSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgdmFyIF9DaXJjbGVJbWFnZUJhc2UyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MCk7XG5cbiAgdmFyIF9DaXJjbGVJbWFnZUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2lyY2xlSW1hZ2VCYXNlMik7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG4gIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4gIHZhciBDaXJjdWxhckltYWdlID0gZnVuY3Rpb24gKF9DaXJjbGVJbWFnZUJhc2UpIHtcbiAgICBfaW5oZXJpdHMoQ2lyY3VsYXJJbWFnZSwgX0NpcmNsZUltYWdlQmFzZSk7XG5cbiAgICBmdW5jdGlvbiBDaXJjdWxhckltYWdlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlLCBpbWFnZU9iaikge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENpcmN1bGFySW1hZ2UpO1xuXG4gICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ2lyY3VsYXJJbWFnZSkuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuXG4gICAgICBfdGhpcy5pbWFnZU9iaiA9IGltYWdlT2JqO1xuICAgICAgX3RoaXMuX3N3YXBUb0ltYWdlUmVzaXplV2hlbkltYWdlTG9hZGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQ2lyY3VsYXJJbWFnZSwgW3tcbiAgICAgIGtleTogJ3Jlc2l6ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKCkge1xuICAgICAgICBpZiAodGhpcy5pbWFnZU9iai5zcmMgPT09IHVuZGVmaW5lZCB8fCB0aGlzLmltYWdlT2JqLndpZHRoID09PSB1bmRlZmluZWQgfHwgdGhpcy5pbWFnZU9iai5oZWlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICghdGhpcy53aWR0aCkge1xuICAgICAgICAgICAgdmFyIGRpYW1ldGVyID0gdGhpcy5vcHRpb25zLnNpemUgKiAyO1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IGRpYW1ldGVyO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBkaWFtZXRlcjtcbiAgICAgICAgICAgIHRoaXMuX3N3YXBUb0ltYWdlUmVzaXplV2hlbkltYWdlTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMucmFkaXVzID0gMC41ICogdGhpcy53aWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3N3YXBUb0ltYWdlUmVzaXplV2hlbkltYWdlTG9hZGVkKSB7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLl9zd2FwVG9JbWFnZVJlc2l6ZVdoZW5JbWFnZUxvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9yZXNpemVJbWFnZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZHJhdycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuXG4gICAgICAgIHRoaXMubGVmdCA9IHggLSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgdGhpcy50b3AgPSB5IC0gdGhpcy5oZWlnaHQgLyAyO1xuXG4gICAgICAgIHZhciBzaXplID0gTWF0aC5taW4oMC41ICogdGhpcy5oZWlnaHQsIDAuNSAqIHRoaXMud2lkdGgpO1xuXG4gICAgICAgIC8vIGRyYXcgdGhlIGJhY2tncm91bmQgY2lyY2xlLiBJTVBPUlRBTlQ6IHRoZSBzdHJva2UgaW4gdGhpcyBtZXRob2QgaXMgdXNlZCBieSB0aGUgY2xpcCBtZXRob2QgYmVsb3cuXG4gICAgICAgIHRoaXMuX2RyYXdSYXdDaXJjbGUoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHNpemUpO1xuXG4gICAgICAgIC8vIG5vdyB3ZSBkcmF3IGluIHRoZSBjaXJjbGUsIHdlIHNhdmUgc28gd2UgY2FuIHJldmVydCB0aGUgY2xpcCBvcGVyYXRpb24gYWZ0ZXIgZHJhd2luZy5cbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgLy8gY2xpcCBpcyB1c2VkIHRvIHVzZSB0aGUgc3Ryb2tlIGluIGRyYXdSYXdDaXJjbGUgYXMgYW4gYXJlYSB0aGF0IHdlIGNhbiBkcmF3IGluLlxuICAgICAgICBjdHguY2xpcCgpO1xuICAgICAgICAvLyBkcmF3IHRoZSBpbWFnZVxuICAgICAgICB0aGlzLl9kcmF3SW1hZ2VBdFBvc2l0aW9uKGN0eCk7XG4gICAgICAgIC8vIHJlc3RvcmUgc28gd2UgY2FuIGFnYWluIGRyYXcgb24gdGhlIGZ1bGwgY2FudmFzXG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgICAgdGhpcy5fZHJhd0ltYWdlTGFiZWwoY3R4LCB4LCB5LCBzZWxlY3RlZCk7XG5cbiAgICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ0JveCh4LCB5KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICd1cGRhdGVCb3VuZGluZ0JveCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQm91bmRpbmdCb3goeCwgeSkge1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LnRvcCA9IHkgLSB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0geCAtIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LnJpZ2h0ID0geCArIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSA9IHkgKyB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0gTWF0aC5taW4odGhpcy5ib3VuZGluZ0JveC5sZWZ0LCB0aGlzLmxhYmVsTW9kdWxlLnNpemUubGVmdCk7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSBNYXRoLm1heCh0aGlzLmJvdW5kaW5nQm94LnJpZ2h0LCB0aGlzLmxhYmVsTW9kdWxlLnNpemUubGVmdCArIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS53aWR0aCk7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0gTWF0aC5tYXgodGhpcy5ib3VuZGluZ0JveC5ib3R0b20sIHRoaXMuYm91bmRpbmdCb3guYm90dG9tICsgdGhpcy5sYWJlbE9mZnNldCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZGlzdGFuY2VUb0JvcmRlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICAgIHRoaXMucmVzaXplKGN0eCk7XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoICogMC41O1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBDaXJjdWxhckltYWdlO1xuICB9KF9DaXJjbGVJbWFnZUJhc2UzLmRlZmF1bHQpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IENpcmN1bGFySW1hZ2U7XG5cbi8qKiovIH0sXG4vKiA3MiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgdmFyIF9Ob2RlQmFzZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4KTtcblxuICB2YXIgX05vZGVCYXNlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX05vZGVCYXNlMik7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG4gIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4gIHZhciBEYXRhYmFzZSA9IGZ1bmN0aW9uIChfTm9kZUJhc2UpIHtcbiAgICBfaW5oZXJpdHMoRGF0YWJhc2UsIF9Ob2RlQmFzZSk7XG5cbiAgICBmdW5jdGlvbiBEYXRhYmFzZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERhdGFiYXNlKTtcblxuICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihEYXRhYmFzZSkuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhEYXRhYmFzZSwgW3tcbiAgICAgIGtleTogJ3Jlc2l6ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKGN0eCwgc2VsZWN0ZWQpIHtcbiAgICAgICAgaWYgKHRoaXMud2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBtYXJnaW4gPSA1O1xuICAgICAgICAgIHZhciB0ZXh0U2l6ZSA9IHRoaXMubGFiZWxNb2R1bGUuZ2V0VGV4dFNpemUoY3R4LCBzZWxlY3RlZCk7XG4gICAgICAgICAgdmFyIHNpemUgPSB0ZXh0U2l6ZS53aWR0aCArIDIgKiBtYXJnaW47XG4gICAgICAgICAgdGhpcy53aWR0aCA9IHNpemU7XG4gICAgICAgICAgdGhpcy5oZWlnaHQgPSBzaXplO1xuICAgICAgICAgIHRoaXMucmFkaXVzID0gMC41ICogdGhpcy53aWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2RyYXcnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgICAgdGhpcy5yZXNpemUoY3R4LCBzZWxlY3RlZCk7XG4gICAgICAgIHRoaXMubGVmdCA9IHggLSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgdGhpcy50b3AgPSB5IC0gdGhpcy5oZWlnaHQgLyAyO1xuXG4gICAgICAgIHZhciBuZXV0cmFsYm9yZGVyV2lkdGggPSB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgICAgIHZhciBzZWxlY3Rpb25MaW5lV2lkdGggPSB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGhTZWxlY3RlZCB8fCAyICogdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoO1xuICAgICAgICB2YXIgYm9yZGVyV2lkdGggPSAoc2VsZWN0ZWQgPyBzZWxlY3Rpb25MaW5lV2lkdGggOiBuZXV0cmFsYm9yZGVyV2lkdGgpIC8gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBNYXRoLm1pbih0aGlzLndpZHRoLCBib3JkZXJXaWR0aCk7XG5cbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc2VsZWN0ZWQgPyB0aGlzLm9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0LmJvcmRlciA6IGhvdmVyID8gdGhpcy5vcHRpb25zLmNvbG9yLmhvdmVyLmJvcmRlciA6IHRoaXMub3B0aW9ucy5jb2xvci5ib3JkZXI7XG5cbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHNlbGVjdGVkID8gdGhpcy5vcHRpb25zLmNvbG9yLmhpZ2hsaWdodC5iYWNrZ3JvdW5kIDogaG92ZXIgPyB0aGlzLm9wdGlvbnMuY29sb3IuaG92ZXIuYmFja2dyb3VuZCA6IHRoaXMub3B0aW9ucy5jb2xvci5iYWNrZ3JvdW5kO1xuICAgICAgICBjdHguZGF0YWJhc2UoeCAtIHRoaXMud2lkdGggLyAyLCB5IC0gdGhpcy5oZWlnaHQgKiAwLjUsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblxuICAgICAgICAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG4gICAgICAgIHRoaXMuZW5hYmxlU2hhZG93KGN0eCk7XG4gICAgICAgIC8vIGRyYXcgdGhlIGJhY2tncm91bmRcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgLy8gZGlzYWJsZSBzaGFkb3dzIGZvciBvdGhlciBlbGVtZW50cy5cbiAgICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCk7XG5cbiAgICAgICAgLy9kcmF3IGRhc2hlZCBib3JkZXIgaWYgZW5hYmxlZCwgc2F2ZSBhbmQgcmVzdG9yZSBpcyByZXF1aXJlZCBmb3IgZmlyZWZveCBub3QgdG8gY3Jhc2ggb24gdW5peC5cbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgLy8gaWYgYm9yZGVycyBhcmUgemVybyB3aWR0aCwgdGhleSB3aWxsIGJlIGRyYXduIHdpdGggd2lkdGggMSBieSBkZWZhdWx0LiBUaGlzIHByZXZlbnRzIHRoYXRcbiAgICAgICAgaWYgKGJvcmRlcldpZHRoID4gMCkge1xuICAgICAgICAgIHRoaXMuZW5hYmxlQm9yZGVyRGFzaGVzKGN0eCk7XG4gICAgICAgICAgLy9kcmF3IHRoZSBib3JkZXJcbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgLy9kaXNhYmxlIGRhc2hlZCBib3JkZXIgZm9yIG90aGVyIGVsZW1lbnRzXG4gICAgICAgICAgdGhpcy5kaXNhYmxlQm9yZGVyRGFzaGVzKGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nQm94KHgsIHksIGN0eCwgc2VsZWN0ZWQpO1xuICAgICAgICB0aGlzLmxhYmVsTW9kdWxlLmRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAndXBkYXRlQm91bmRpbmdCb3gnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kaW5nQm94KHgsIHksIGN0eCwgc2VsZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5yZXNpemUoY3R4LCBzZWxlY3RlZCk7XG5cbiAgICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggKiAwLjU7XG4gICAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0ICogMC41O1xuXG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gubGVmdCA9IHRoaXMubGVmdDtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC50b3AgPSB0aGlzLnRvcDtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gPSB0aGlzLnRvcCArIHRoaXMuaGVpZ2h0O1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LnJpZ2h0ID0gdGhpcy5sZWZ0ICsgdGhpcy53aWR0aDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkaXN0YW5jZVRvQm9yZGVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIERhdGFiYXNlO1xuICB9KF9Ob2RlQmFzZTMuZGVmYXVsdCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gRGF0YWJhc2U7XG5cbi8qKiovIH0sXG4vKiA3MyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgdmFyIF9TaGFwZUJhc2UyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NCk7XG5cbiAgdmFyIF9TaGFwZUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2hhcGVCYXNlMik7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG4gIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4gIHZhciBEaWFtb25kID0gZnVuY3Rpb24gKF9TaGFwZUJhc2UpIHtcbiAgICBfaW5oZXJpdHMoRGlhbW9uZCwgX1NoYXBlQmFzZSk7XG5cbiAgICBmdW5jdGlvbiBEaWFtb25kKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGlhbW9uZCk7XG5cbiAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRGlhbW9uZCkuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhEaWFtb25kLCBbe1xuICAgICAga2V5OiAncmVzaXplJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoY3R4KSB7XG4gICAgICAgIHRoaXMuX3Jlc2l6ZVNoYXBlKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZHJhdycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgICB0aGlzLl9kcmF3U2hhcGUoY3R4LCAnZGlhbW9uZCcsIDQsIHgsIHksIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZGlzdGFuY2VUb0JvcmRlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBEaWFtb25kO1xuICB9KF9TaGFwZUJhc2UzLmRlZmF1bHQpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IERpYW1vbmQ7XG5cbi8qKiovIH0sXG4vKiA3NCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgdmFyIF9Ob2RlQmFzZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4KTtcblxuICB2YXIgX05vZGVCYXNlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX05vZGVCYXNlMik7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG4gIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4gIHZhciBTaGFwZUJhc2UgPSBmdW5jdGlvbiAoX05vZGVCYXNlKSB7XG4gICAgX2luaGVyaXRzKFNoYXBlQmFzZSwgX05vZGVCYXNlKTtcblxuICAgIGZ1bmN0aW9uIFNoYXBlQmFzZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNoYXBlQmFzZSk7XG5cbiAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU2hhcGVCYXNlKS5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFNoYXBlQmFzZSwgW3tcbiAgICAgIGtleTogJ19yZXNpemVTaGFwZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc2l6ZVNoYXBlKCkge1xuICAgICAgICBpZiAodGhpcy53aWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIHNpemUgPSAyICogdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICAgICAgdGhpcy53aWR0aCA9IHNpemU7XG4gICAgICAgICAgdGhpcy5oZWlnaHQgPSBzaXplO1xuICAgICAgICAgIHRoaXMucmFkaXVzID0gMC41ICogdGhpcy53aWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19kcmF3U2hhcGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3U2hhcGUoY3R4LCBzaGFwZSwgc2l6ZU11bHRpcGxpZXIsIHgsIHksIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgICB0aGlzLl9yZXNpemVTaGFwZSgpO1xuXG4gICAgICAgIHRoaXMubGVmdCA9IHggLSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgdGhpcy50b3AgPSB5IC0gdGhpcy5oZWlnaHQgLyAyO1xuXG4gICAgICAgIHZhciBuZXV0cmFsYm9yZGVyV2lkdGggPSB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgICAgIHZhciBzZWxlY3Rpb25MaW5lV2lkdGggPSB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGhTZWxlY3RlZCB8fCAyICogdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoO1xuICAgICAgICB2YXIgYm9yZGVyV2lkdGggPSAoc2VsZWN0ZWQgPyBzZWxlY3Rpb25MaW5lV2lkdGggOiBuZXV0cmFsYm9yZGVyV2lkdGgpIC8gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBNYXRoLm1pbih0aGlzLndpZHRoLCBib3JkZXJXaWR0aCk7XG5cbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc2VsZWN0ZWQgPyB0aGlzLm9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0LmJvcmRlciA6IGhvdmVyID8gdGhpcy5vcHRpb25zLmNvbG9yLmhvdmVyLmJvcmRlciA6IHRoaXMub3B0aW9ucy5jb2xvci5ib3JkZXI7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBzZWxlY3RlZCA/IHRoaXMub3B0aW9ucy5jb2xvci5oaWdobGlnaHQuYmFja2dyb3VuZCA6IGhvdmVyID8gdGhpcy5vcHRpb25zLmNvbG9yLmhvdmVyLmJhY2tncm91bmQgOiB0aGlzLm9wdGlvbnMuY29sb3IuYmFja2dyb3VuZDtcbiAgICAgICAgY3R4W3NoYXBlXSh4LCB5LCB0aGlzLm9wdGlvbnMuc2l6ZSk7XG5cbiAgICAgICAgLy8gZHJhdyBzaGFkb3cgaWYgZW5hYmxlZFxuICAgICAgICB0aGlzLmVuYWJsZVNoYWRvdyhjdHgpO1xuICAgICAgICAvLyBkcmF3IHRoZSBiYWNrZ3JvdW5kXG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIC8vIGRpc2FibGUgc2hhZG93cyBmb3Igb3RoZXIgZWxlbWVudHMuXG4gICAgICAgIHRoaXMuZGlzYWJsZVNoYWRvdyhjdHgpO1xuXG4gICAgICAgIC8vZHJhdyBkYXNoZWQgYm9yZGVyIGlmIGVuYWJsZWQsIHNhdmUgYW5kIHJlc3RvcmUgaXMgcmVxdWlyZWQgZm9yIGZpcmVmb3ggbm90IHRvIGNyYXNoIG9uIHVuaXguXG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIC8vIGlmIGJvcmRlcnMgYXJlIHplcm8gd2lkdGgsIHRoZXkgd2lsbCBiZSBkcmF3biB3aXRoIHdpZHRoIDEgYnkgZGVmYXVsdC4gVGhpcyBwcmV2ZW50cyB0aGF0XG4gICAgICAgIGlmIChib3JkZXJXaWR0aCA+IDApIHtcbiAgICAgICAgICB0aGlzLmVuYWJsZUJvcmRlckRhc2hlcyhjdHgpO1xuICAgICAgICAgIC8vZHJhdyB0aGUgYm9yZGVyXG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgIC8vZGlzYWJsZSBkYXNoZWQgYm9yZGVyIGZvciBvdGhlciBlbGVtZW50c1xuICAgICAgICAgIHRoaXMuZGlzYWJsZUJvcmRlckRhc2hlcyhjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sYWJlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIHlMYWJlbCA9IHkgKyAwLjUgKiB0aGlzLmhlaWdodCArIDM7IC8vIHRoZSArIDMgaXMgdG8gb2Zmc2V0IGl0IGEgYml0IGJlbG93IHRoZSBub2RlLlxuICAgICAgICAgIHRoaXMubGFiZWxNb2R1bGUuZHJhdyhjdHgsIHgsIHlMYWJlbCwgc2VsZWN0ZWQsICdoYW5naW5nJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nQm94KHgsIHkpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3VwZGF0ZUJvdW5kaW5nQm94JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVCb3VuZGluZ0JveCh4LCB5KSB7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gudG9wID0geSAtIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSB4IC0gdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSB4ICsgdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0geSArIHRoaXMub3B0aW9ucy5zaXplO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGFiZWwgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmxhYmVsTW9kdWxlLnNpemUud2lkdGggPiAwKSB7XG4gICAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0gTWF0aC5taW4odGhpcy5ib3VuZGluZ0JveC5sZWZ0LCB0aGlzLmxhYmVsTW9kdWxlLnNpemUubGVmdCk7XG4gICAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5yaWdodCA9IE1hdGgubWF4KHRoaXMuYm91bmRpbmdCb3gucmlnaHQsIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5sZWZ0ICsgdGhpcy5sYWJlbE1vZHVsZS5zaXplLndpZHRoKTtcbiAgICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSA9IE1hdGgubWF4KHRoaXMuYm91bmRpbmdCb3guYm90dG9tLCB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSArIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5oZWlnaHQgKyAzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBTaGFwZUJhc2U7XG4gIH0oX05vZGVCYXNlMy5kZWZhdWx0KTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBTaGFwZUJhc2U7XG5cbi8qKiovIH0sXG4vKiA3NSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgdmFyIF9TaGFwZUJhc2UyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NCk7XG5cbiAgdmFyIF9TaGFwZUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2hhcGVCYXNlMik7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG4gIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4gIHZhciBEb3QgPSBmdW5jdGlvbiAoX1NoYXBlQmFzZSkge1xuICAgIF9pbmhlcml0cyhEb3QsIF9TaGFwZUJhc2UpO1xuXG4gICAgZnVuY3Rpb24gRG90KG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRG90KTtcblxuICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihEb3QpLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoRG90LCBbe1xuICAgICAga2V5OiAncmVzaXplJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoY3R4KSB7XG4gICAgICAgIHRoaXMuX3Jlc2l6ZVNoYXBlKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZHJhdycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgICB0aGlzLl9kcmF3U2hhcGUoY3R4LCAnY2lyY2xlJywgMiwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkaXN0YW5jZVRvQm9yZGVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgICAgdGhpcy5yZXNpemUoY3R4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBEb3Q7XG4gIH0oX1NoYXBlQmFzZTMuZGVmYXVsdCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gRG90O1xuXG4vKioqLyB9LFxuLyogNzYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIHZhciBfTm9kZUJhc2UyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OCk7XG5cbiAgdmFyIF9Ob2RlQmFzZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Ob2RlQmFzZTIpO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuICBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuICB2YXIgRWxsaXBzZSA9IGZ1bmN0aW9uIChfTm9kZUJhc2UpIHtcbiAgICBfaW5oZXJpdHMoRWxsaXBzZSwgX05vZGVCYXNlKTtcblxuICAgIGZ1bmN0aW9uIEVsbGlwc2Uob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFbGxpcHNlKTtcblxuICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihFbGxpcHNlKS5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEVsbGlwc2UsIFt7XG4gICAgICBrZXk6ICdyZXNpemUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShjdHgsIHNlbGVjdGVkKSB7XG4gICAgICAgIGlmICh0aGlzLndpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgdGV4dFNpemUgPSB0aGlzLmxhYmVsTW9kdWxlLmdldFRleHRTaXplKGN0eCwgc2VsZWN0ZWQpO1xuXG4gICAgICAgICAgdGhpcy53aWR0aCA9IHRleHRTaXplLndpZHRoICogMS41O1xuICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gdGV4dFNpemUuaGVpZ2h0ICogMjtcbiAgICAgICAgICBpZiAodGhpcy53aWR0aCA8IHRoaXMuaGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5oZWlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMucmFkaXVzID0gMC41ICogdGhpcy53aWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2RyYXcnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgICAgdGhpcy5yZXNpemUoY3R4LCBzZWxlY3RlZCk7XG4gICAgICAgIHRoaXMubGVmdCA9IHggLSB0aGlzLndpZHRoICogMC41O1xuICAgICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAqIDAuNTtcblxuICAgICAgICB2YXIgbmV1dHJhbGJvcmRlcldpZHRoID0gdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoO1xuICAgICAgICB2YXIgc2VsZWN0aW9uTGluZVdpZHRoID0gdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoU2VsZWN0ZWQgfHwgMiAqIHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgICAgICAgdmFyIGJvcmRlcldpZHRoID0gKHNlbGVjdGVkID8gc2VsZWN0aW9uTGluZVdpZHRoIDogbmV1dHJhbGJvcmRlcldpZHRoKSAvIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gTWF0aC5taW4odGhpcy53aWR0aCwgYm9yZGVyV2lkdGgpO1xuXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHNlbGVjdGVkID8gdGhpcy5vcHRpb25zLmNvbG9yLmhpZ2hsaWdodC5ib3JkZXIgOiBob3ZlciA/IHRoaXMub3B0aW9ucy5jb2xvci5ob3Zlci5ib3JkZXIgOiB0aGlzLm9wdGlvbnMuY29sb3IuYm9yZGVyO1xuXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBzZWxlY3RlZCA/IHRoaXMub3B0aW9ucy5jb2xvci5oaWdobGlnaHQuYmFja2dyb3VuZCA6IGhvdmVyID8gdGhpcy5vcHRpb25zLmNvbG9yLmhvdmVyLmJhY2tncm91bmQgOiB0aGlzLm9wdGlvbnMuY29sb3IuYmFja2dyb3VuZDtcbiAgICAgICAgY3R4LmVsbGlwc2UodGhpcy5sZWZ0LCB0aGlzLnRvcCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXG4gICAgICAgIC8vIGRyYXcgc2hhZG93IGlmIGVuYWJsZWRcbiAgICAgICAgdGhpcy5lbmFibGVTaGFkb3coY3R4KTtcbiAgICAgICAgLy8gZHJhdyB0aGUgYmFja2dyb3VuZFxuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAvLyBkaXNhYmxlIHNoYWRvd3MgZm9yIG90aGVyIGVsZW1lbnRzLlxuICAgICAgICB0aGlzLmRpc2FibGVTaGFkb3coY3R4KTtcblxuICAgICAgICAvL2RyYXcgZGFzaGVkIGJvcmRlciBpZiBlbmFibGVkLCBzYXZlIGFuZCByZXN0b3JlIGlzIHJlcXVpcmVkIGZvciBmaXJlZm94IG5vdCB0byBjcmFzaCBvbiB1bml4LlxuICAgICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICAgIC8vIGlmIGJvcmRlcnMgYXJlIHplcm8gd2lkdGgsIHRoZXkgd2lsbCBiZSBkcmF3biB3aXRoIHdpZHRoIDEgYnkgZGVmYXVsdC4gVGhpcyBwcmV2ZW50cyB0aGF0XG4gICAgICAgIGlmIChib3JkZXJXaWR0aCA+IDApIHtcbiAgICAgICAgICB0aGlzLmVuYWJsZUJvcmRlckRhc2hlcyhjdHgpO1xuICAgICAgICAgIC8vZHJhdyB0aGUgYm9yZGVyXG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgIC8vZGlzYWJsZSBkYXNoZWQgYm9yZGVyIGZvciBvdGhlciBlbGVtZW50c1xuICAgICAgICAgIHRoaXMuZGlzYWJsZUJvcmRlckRhc2hlcyhjdHgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nQm94KHgsIHksIGN0eCwgc2VsZWN0ZWQpO1xuICAgICAgICB0aGlzLmxhYmVsTW9kdWxlLmRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAndXBkYXRlQm91bmRpbmdCb3gnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kaW5nQm94KHgsIHksIGN0eCwgc2VsZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5yZXNpemUoY3R4LCBzZWxlY3RlZCk7IC8vIGp1c3QgaW4gY2FzZVxuXG4gICAgICAgIHRoaXMubGVmdCA9IHggLSB0aGlzLndpZHRoICogMC41O1xuICAgICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAqIDAuNTtcblxuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSB0aGlzLmxlZnQ7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gudG9wID0gdGhpcy50b3A7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0gdGhpcy50b3AgKyB0aGlzLmhlaWdodDtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5yaWdodCA9IHRoaXMubGVmdCArIHRoaXMud2lkdGg7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZGlzdGFuY2VUb0JvcmRlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICAgIHRoaXMucmVzaXplKGN0eCk7XG4gICAgICAgIHZhciBhID0gdGhpcy53aWR0aCAqIDAuNTtcbiAgICAgICAgdmFyIGIgPSB0aGlzLmhlaWdodCAqIDAuNTtcbiAgICAgICAgdmFyIHcgPSBNYXRoLnNpbihhbmdsZSkgKiBhO1xuICAgICAgICB2YXIgaCA9IE1hdGguY29zKGFuZ2xlKSAqIGI7XG4gICAgICAgIHJldHVybiBhICogYiAvIE1hdGguc3FydCh3ICogdyArIGggKiBoKTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gRWxsaXBzZTtcbiAgfShfTm9kZUJhc2UzLmRlZmF1bHQpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IEVsbGlwc2U7XG5cbi8qKiovIH0sXG4vKiA3NyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgdmFyIF9Ob2RlQmFzZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4KTtcblxuICB2YXIgX05vZGVCYXNlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX05vZGVCYXNlMik7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG4gIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4gIHZhciBJY29uID0gZnVuY3Rpb24gKF9Ob2RlQmFzZSkge1xuICAgIF9pbmhlcml0cyhJY29uLCBfTm9kZUJhc2UpO1xuXG4gICAgZnVuY3Rpb24gSWNvbihvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEljb24pO1xuXG4gICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKEljb24pLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoSWNvbiwgW3tcbiAgICAgIGtleTogJ3Jlc2l6ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKGN0eCkge1xuICAgICAgICBpZiAodGhpcy53aWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIG1hcmdpbiA9IDU7XG4gICAgICAgICAgdmFyIGljb25TaXplID0ge1xuICAgICAgICAgICAgd2lkdGg6IE51bWJlcih0aGlzLm9wdGlvbnMuaWNvbi5zaXplKSxcbiAgICAgICAgICAgIGhlaWdodDogTnVtYmVyKHRoaXMub3B0aW9ucy5pY29uLnNpemUpXG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLndpZHRoID0gaWNvblNpemUud2lkdGggKyAyICogbWFyZ2luO1xuICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaWNvblNpemUuaGVpZ2h0ICsgMiAqIG1hcmdpbjtcbiAgICAgICAgICB0aGlzLnJhZGl1cyA9IDAuNSAqIHRoaXMud2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkcmF3JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICAgIHRoaXMucmVzaXplKGN0eCk7XG4gICAgICAgIHRoaXMub3B0aW9ucy5pY29uLnNpemUgPSB0aGlzLm9wdGlvbnMuaWNvbi5zaXplIHx8IDUwO1xuXG4gICAgICAgIHRoaXMubGVmdCA9IHggLSB0aGlzLndpZHRoICogMC41O1xuICAgICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAqIDAuNTtcbiAgICAgICAgdGhpcy5faWNvbihjdHgsIHgsIHksIHNlbGVjdGVkKTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxhYmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgaWNvblRleHRTcGFjaW5nID0gNTtcbiAgICAgICAgICB0aGlzLmxhYmVsTW9kdWxlLmRyYXcoY3R4LCB4LCB5ICsgdGhpcy5oZWlnaHQgKiAwLjUgKyBpY29uVGV4dFNwYWNpbmcsIHNlbGVjdGVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdCb3goeCwgeSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAndXBkYXRlQm91bmRpbmdCb3gnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kaW5nQm94KHgsIHkpIHtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC50b3AgPSB5IC0gdGhpcy5vcHRpb25zLmljb24uc2l6ZSAqIDAuNTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0geCAtIHRoaXMub3B0aW9ucy5pY29uLnNpemUgKiAwLjU7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSB4ICsgdGhpcy5vcHRpb25zLmljb24uc2l6ZSAqIDAuNTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gPSB5ICsgdGhpcy5vcHRpb25zLmljb24uc2l6ZSAqIDAuNTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxhYmVsICE9PSB1bmRlZmluZWQgJiYgdGhpcy5sYWJlbE1vZHVsZS5zaXplLndpZHRoID4gMCkge1xuICAgICAgICAgIHZhciBpY29uVGV4dFNwYWNpbmcgPSA1O1xuICAgICAgICAgIHRoaXMuYm91bmRpbmdCb3gubGVmdCA9IE1hdGgubWluKHRoaXMuYm91bmRpbmdCb3gubGVmdCwgdGhpcy5sYWJlbE1vZHVsZS5zaXplLmxlZnQpO1xuICAgICAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSBNYXRoLm1heCh0aGlzLmJvdW5kaW5nQm94LnJpZ2h0LCB0aGlzLmxhYmVsTW9kdWxlLnNpemUubGVmdCArIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS53aWR0aCk7XG4gICAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gPSBNYXRoLm1heCh0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSwgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gKyB0aGlzLmxhYmVsTW9kdWxlLnNpemUuaGVpZ2h0ICsgaWNvblRleHRTcGFjaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19pY29uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaWNvbihjdHgsIHgsIHksIHNlbGVjdGVkKSB7XG4gICAgICAgIHZhciBpY29uU2l6ZSA9IE51bWJlcih0aGlzLm9wdGlvbnMuaWNvbi5zaXplKTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmljb24uY29kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY3R4LmZvbnQgPSAoc2VsZWN0ZWQgPyBcImJvbGQgXCIgOiBcIlwiKSArIGljb25TaXplICsgXCJweCBcIiArIHRoaXMub3B0aW9ucy5pY29uLmZhY2U7XG5cbiAgICAgICAgICAvLyBkcmF3IGljb25cbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5vcHRpb25zLmljb24uY29sb3IgfHwgXCJibGFja1wiO1xuICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuXG4gICAgICAgICAgLy8gZHJhdyBzaGFkb3cgaWYgZW5hYmxlZFxuICAgICAgICAgIHRoaXMuZW5hYmxlU2hhZG93KGN0eCk7XG4gICAgICAgICAgY3R4LmZpbGxUZXh0KHRoaXMub3B0aW9ucy5pY29uLmNvZGUsIHgsIHkpO1xuXG4gICAgICAgICAgLy8gZGlzYWJsZSBzaGFkb3dzIGZvciBvdGhlciBlbGVtZW50cy5cbiAgICAgICAgICB0aGlzLmRpc2FibGVTaGFkb3coY3R4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdXaGVuIHVzaW5nIHRoZSBpY29uIHNoYXBlLCB5b3UgbmVlZCB0byBkZWZpbmUgdGhlIGNvZGUgaW4gdGhlIGljb24gb3B0aW9ucyBvYmplY3QuIFRoaXMgY2FuIGJlIGRvbmUgcGVyIG5vZGUgb3IgZ2xvYmFsbHkuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkaXN0YW5jZVRvQm9yZGVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEljb247XG4gIH0oX05vZGVCYXNlMy5kZWZhdWx0KTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBJY29uO1xuXG4vKioqLyB9LFxuLyogNzggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIHZhciBfQ2lyY2xlSW1hZ2VCYXNlMiA9IF9fd2VicGFja19yZXF1aXJlX18oNzApO1xuXG4gIHZhciBfQ2lyY2xlSW1hZ2VCYXNlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NpcmNsZUltYWdlQmFzZTIpO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuICBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuICB2YXIgSW1hZ2UgPSBmdW5jdGlvbiAoX0NpcmNsZUltYWdlQmFzZSkge1xuICAgIF9pbmhlcml0cyhJbWFnZSwgX0NpcmNsZUltYWdlQmFzZSk7XG5cbiAgICBmdW5jdGlvbiBJbWFnZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSwgaW1hZ2VPYmopIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbWFnZSk7XG5cbiAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihJbWFnZSkuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuXG4gICAgICBfdGhpcy5pbWFnZU9iaiA9IGltYWdlT2JqO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhJbWFnZSwgW3tcbiAgICAgIGtleTogJ3Jlc2l6ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKCkge1xuICAgICAgICB0aGlzLl9yZXNpemVJbWFnZSgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2RyYXcnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggLyAyO1xuICAgICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAvIDI7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMudXNlQm9yZGVyV2l0aEltYWdlID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIG5ldXRyYWxib3JkZXJXaWR0aCA9IHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgICAgICAgICB2YXIgc2VsZWN0aW9uTGluZVdpZHRoID0gdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoU2VsZWN0ZWQgfHwgMiAqIHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgICAgICAgICB2YXIgYm9yZGVyV2lkdGggPSAoc2VsZWN0ZWQgPyBzZWxlY3Rpb25MaW5lV2lkdGggOiBuZXV0cmFsYm9yZGVyV2lkdGgpIC8gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IE1hdGgubWluKHRoaXMud2lkdGgsIGJvcmRlcldpZHRoKTtcblxuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgICAgIC8vIHNldHVwIHRoZSBsaW5lIHByb3BlcnRpZXMuXG4gICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc2VsZWN0ZWQgPyB0aGlzLm9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0LmJvcmRlciA6IGhvdmVyID8gdGhpcy5vcHRpb25zLmNvbG9yLmhvdmVyLmJvcmRlciA6IHRoaXMub3B0aW9ucy5jb2xvci5ib3JkZXI7XG5cbiAgICAgICAgICAvLyBzZXQgYSBmaWxsc3R5bGVcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gc2VsZWN0ZWQgPyB0aGlzLm9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0LmJhY2tncm91bmQgOiBob3ZlciA/IHRoaXMub3B0aW9ucy5jb2xvci5ob3Zlci5iYWNrZ3JvdW5kIDogdGhpcy5vcHRpb25zLmNvbG9yLmJhY2tncm91bmQ7XG5cbiAgICAgICAgICAvLyBkcmF3IGEgcmVjdGFuZ2xlIHRvIGZvcm0gdGhlIGJvcmRlciBhcm91bmQuIFRoaXMgcmVjdGFuZ2xlIGlzIGZpbGxlZCBzbyB0aGUgb3BhY2l0eSBvZiBhIHBpY3R1cmUgKGluIGZ1dHVyZSB2aXMgcmVsZWFzZXM/KSBjYW4gYmUgdXNlZCB0byB0aW50IHRoZSBpbWFnZVxuICAgICAgICAgIGN0eC5yZWN0KHRoaXMubGVmdCAtIDAuNSAqIGN0eC5saW5lV2lkdGgsIHRoaXMudG9wIC0gMC41ICogY3R4LmxpbmVXaWR0aCwgdGhpcy53aWR0aCArIGN0eC5saW5lV2lkdGgsIHRoaXMuaGVpZ2h0ICsgY3R4LmxpbmVXaWR0aCk7XG4gICAgICAgICAgY3R4LmZpbGwoKTtcblxuICAgICAgICAgIC8vZHJhdyBkYXNoZWQgYm9yZGVyIGlmIGVuYWJsZWQsIHNhdmUgYW5kIHJlc3RvcmUgaXMgcmVxdWlyZWQgZm9yIGZpcmVmb3ggbm90IHRvIGNyYXNoIG9uIHVuaXguXG4gICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAvLyBpZiBib3JkZXJzIGFyZSB6ZXJvIHdpZHRoLCB0aGV5IHdpbGwgYmUgZHJhd24gd2l0aCB3aWR0aCAxIGJ5IGRlZmF1bHQuIFRoaXMgcHJldmVudHMgdGhhdFxuICAgICAgICAgIGlmIChib3JkZXJXaWR0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlQm9yZGVyRGFzaGVzKGN0eCk7XG4gICAgICAgICAgICAvL2RyYXcgdGhlIGJvcmRlclxuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgLy9kaXNhYmxlIGRhc2hlZCBib3JkZXIgZm9yIG90aGVyIGVsZW1lbnRzXG4gICAgICAgICAgICB0aGlzLmRpc2FibGVCb3JkZXJEYXNoZXMoY3R4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2RyYXdJbWFnZUF0UG9zaXRpb24oY3R4KTtcblxuICAgICAgICB0aGlzLl9kcmF3SW1hZ2VMYWJlbChjdHgsIHgsIHksIHNlbGVjdGVkIHx8IGhvdmVyKTtcblxuICAgICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nQm94KHgsIHkpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3VwZGF0ZUJvdW5kaW5nQm94JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVCb3VuZGluZ0JveCh4LCB5KSB7XG4gICAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICAgIHRoaXMubGVmdCA9IHggLSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgdGhpcy50b3AgPSB5IC0gdGhpcy5oZWlnaHQgLyAyO1xuXG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gudG9wID0gdGhpcy50b3A7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gubGVmdCA9IHRoaXMubGVmdDtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5yaWdodCA9IHRoaXMubGVmdCArIHRoaXMud2lkdGg7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0gdGhpcy50b3AgKyB0aGlzLmhlaWdodDtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxhYmVsICE9PSB1bmRlZmluZWQgJiYgdGhpcy5sYWJlbE1vZHVsZS5zaXplLndpZHRoID4gMCkge1xuICAgICAgICAgIHRoaXMuYm91bmRpbmdCb3gubGVmdCA9IE1hdGgubWluKHRoaXMuYm91bmRpbmdCb3gubGVmdCwgdGhpcy5sYWJlbE1vZHVsZS5zaXplLmxlZnQpO1xuICAgICAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSBNYXRoLm1heCh0aGlzLmJvdW5kaW5nQm94LnJpZ2h0LCB0aGlzLmxhYmVsTW9kdWxlLnNpemUubGVmdCArIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS53aWR0aCk7XG4gICAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gPSBNYXRoLm1heCh0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSwgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gKyB0aGlzLmxhYmVsT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Rpc3RhbmNlVG9Cb3JkZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gSW1hZ2U7XG4gIH0oX0NpcmNsZUltYWdlQmFzZTMuZGVmYXVsdCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gSW1hZ2U7XG5cbi8qKiovIH0sXG4vKiA3OSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgdmFyIF9TaGFwZUJhc2UyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NCk7XG5cbiAgdmFyIF9TaGFwZUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2hhcGVCYXNlMik7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG4gIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4gIHZhciBTcXVhcmUgPSBmdW5jdGlvbiAoX1NoYXBlQmFzZSkge1xuICAgIF9pbmhlcml0cyhTcXVhcmUsIF9TaGFwZUJhc2UpO1xuXG4gICAgZnVuY3Rpb24gU3F1YXJlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3F1YXJlKTtcblxuICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihTcXVhcmUpLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoU3F1YXJlLCBbe1xuICAgICAga2V5OiAncmVzaXplJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoKSB7XG4gICAgICAgIHRoaXMuX3Jlc2l6ZVNoYXBlKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZHJhdycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgICB0aGlzLl9kcmF3U2hhcGUoY3R4LCAnc3F1YXJlJywgMiwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkaXN0YW5jZVRvQm9yZGVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFNxdWFyZTtcbiAgfShfU2hhcGVCYXNlMy5kZWZhdWx0KTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBTcXVhcmU7XG5cbi8qKiovIH0sXG4vKiA4MCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgdmFyIF9TaGFwZUJhc2UyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NCk7XG5cbiAgdmFyIF9TaGFwZUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2hhcGVCYXNlMik7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG4gIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4gIHZhciBTdGFyID0gZnVuY3Rpb24gKF9TaGFwZUJhc2UpIHtcbiAgICBfaW5oZXJpdHMoU3RhciwgX1NoYXBlQmFzZSk7XG5cbiAgICBmdW5jdGlvbiBTdGFyKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3Rhcik7XG5cbiAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU3RhcikuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhTdGFyLCBbe1xuICAgICAga2V5OiAncmVzaXplJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoY3R4KSB7XG4gICAgICAgIHRoaXMuX3Jlc2l6ZVNoYXBlKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZHJhdycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgICB0aGlzLl9kcmF3U2hhcGUoY3R4LCAnc3RhcicsIDQsIHgsIHksIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZGlzdGFuY2VUb0JvcmRlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBTdGFyO1xuICB9KF9TaGFwZUJhc2UzLmRlZmF1bHQpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IFN0YXI7XG5cbi8qKiovIH0sXG4vKiA4MSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgdmFyIF9Ob2RlQmFzZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4KTtcblxuICB2YXIgX05vZGVCYXNlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX05vZGVCYXNlMik7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG4gIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4gIHZhciBUZXh0ID0gZnVuY3Rpb24gKF9Ob2RlQmFzZSkge1xuICAgIF9pbmhlcml0cyhUZXh0LCBfTm9kZUJhc2UpO1xuXG4gICAgZnVuY3Rpb24gVGV4dChvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHQpO1xuXG4gICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKFRleHQpLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoVGV4dCwgW3tcbiAgICAgIGtleTogJ3Jlc2l6ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKGN0eCwgc2VsZWN0ZWQpIHtcbiAgICAgICAgaWYgKHRoaXMud2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBtYXJnaW4gPSA1O1xuICAgICAgICAgIHZhciB0ZXh0U2l6ZSA9IHRoaXMubGFiZWxNb2R1bGUuZ2V0VGV4dFNpemUoY3R4LCBzZWxlY3RlZCk7XG4gICAgICAgICAgdGhpcy53aWR0aCA9IHRleHRTaXplLndpZHRoICsgMiAqIG1hcmdpbjtcbiAgICAgICAgICB0aGlzLmhlaWdodCA9IHRleHRTaXplLmhlaWdodCArIDIgKiBtYXJnaW47XG4gICAgICAgICAgdGhpcy5yYWRpdXMgPSAwLjUgKiB0aGlzLndpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZHJhdycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgICB0aGlzLnJlc2l6ZShjdHgsIHNlbGVjdGVkIHx8IGhvdmVyKTtcbiAgICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggLyAyO1xuICAgICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAvIDI7XG5cbiAgICAgICAgLy8gZHJhdyBzaGFkb3cgaWYgZW5hYmxlZFxuICAgICAgICB0aGlzLmVuYWJsZVNoYWRvdyhjdHgpO1xuICAgICAgICB0aGlzLmxhYmVsTW9kdWxlLmRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCB8fCBob3Zlcik7XG5cbiAgICAgICAgLy8gZGlzYWJsZSBzaGFkb3dzIGZvciBvdGhlciBlbGVtZW50cy5cbiAgICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCk7XG5cbiAgICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ0JveCh4LCB5LCBjdHgsIHNlbGVjdGVkKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICd1cGRhdGVCb3VuZGluZ0JveCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQm91bmRpbmdCb3goeCwgeSwgY3R4LCBzZWxlY3RlZCkge1xuICAgICAgICB0aGlzLnJlc2l6ZShjdHgsIHNlbGVjdGVkKTtcblxuICAgICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0IC8gMjtcblxuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LnRvcCA9IHRoaXMudG9wO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSB0aGlzLmxlZnQ7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSB0aGlzLmxlZnQgKyB0aGlzLndpZHRoO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSA9IHRoaXMudG9wICsgdGhpcy5oZWlnaHQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZGlzdGFuY2VUb0JvcmRlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBUZXh0O1xuICB9KF9Ob2RlQmFzZTMuZGVmYXVsdCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gVGV4dDtcblxuLyoqKi8gfSxcbi8qIDgyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX1NoYXBlQmFzZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0KTtcblxuICB2YXIgX1NoYXBlQmFzZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TaGFwZUJhc2UyKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbiAgdmFyIFRyaWFuZ2xlID0gZnVuY3Rpb24gKF9TaGFwZUJhc2UpIHtcbiAgICBfaW5oZXJpdHMoVHJpYW5nbGUsIF9TaGFwZUJhc2UpO1xuXG4gICAgZnVuY3Rpb24gVHJpYW5nbGUob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUcmlhbmdsZSk7XG5cbiAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVHJpYW5nbGUpLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoVHJpYW5nbGUsIFt7XG4gICAgICBrZXk6ICdyZXNpemUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShjdHgpIHtcbiAgICAgICAgdGhpcy5fcmVzaXplU2hhcGUoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkcmF3JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICAgIHRoaXMuX2RyYXdTaGFwZShjdHgsICd0cmlhbmdsZScsIDMsIHgsIHksIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZGlzdGFuY2VUb0JvcmRlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBUcmlhbmdsZTtcbiAgfShfU2hhcGVCYXNlMy5kZWZhdWx0KTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBUcmlhbmdsZTtcblxuLyoqKi8gfSxcbi8qIDgzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX1NoYXBlQmFzZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0KTtcblxuICB2YXIgX1NoYXBlQmFzZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TaGFwZUJhc2UyKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbiAgdmFyIFRyaWFuZ2xlRG93biA9IGZ1bmN0aW9uIChfU2hhcGVCYXNlKSB7XG4gICAgX2luaGVyaXRzKFRyaWFuZ2xlRG93biwgX1NoYXBlQmFzZSk7XG5cbiAgICBmdW5jdGlvbiBUcmlhbmdsZURvd24ob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUcmlhbmdsZURvd24pO1xuXG4gICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKFRyaWFuZ2xlRG93bikuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhUcmlhbmdsZURvd24sIFt7XG4gICAgICBrZXk6ICdyZXNpemUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShjdHgpIHtcbiAgICAgICAgdGhpcy5fcmVzaXplU2hhcGUoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkcmF3JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICAgIHRoaXMuX2RyYXdTaGFwZShjdHgsICd0cmlhbmdsZURvd24nLCAzLCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Rpc3RhbmNlVG9Cb3JkZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gVHJpYW5nbGVEb3duO1xuICB9KF9TaGFwZUJhc2UzLmRlZmF1bHQpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IFRyaWFuZ2xlRG93bjtcblxuLyoqKi8gfSxcbi8qIDg0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX0VkZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1KTtcblxuICB2YXIgX0VkZ2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRWRnZSk7XG5cbiAgdmFyIF9MYWJlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNjYpO1xuXG4gIHZhciBfTGFiZWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTGFiZWwpO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4gIHZhciBEYXRhU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcbiAgdmFyIERhdGFWaWV3ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cbiAgdmFyIEVkZ2VzSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFZGdlc0hhbmRsZXIoYm9keSwgaW1hZ2VzLCBncm91cHMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFZGdlc0hhbmRsZXIpO1xuXG4gICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgdGhpcy5pbWFnZXMgPSBpbWFnZXM7XG4gICAgICB0aGlzLmdyb3VwcyA9IGdyb3VwcztcblxuICAgICAgLy8gY3JlYXRlIHRoZSBlZGdlIEFQSSBpbiB0aGUgYm9keSBjb250YWluZXJcbiAgICAgIHRoaXMuYm9keS5mdW5jdGlvbnMuY3JlYXRlRWRnZSA9IHRoaXMuY3JlYXRlLmJpbmQodGhpcyk7XG5cbiAgICAgIHRoaXMuZWRnZXNMaXN0ZW5lcnMgPSB7XG4gICAgICAgIGFkZDogZnVuY3Rpb24gYWRkKGV2ZW50LCBwYXJhbXMpIHtcbiAgICAgICAgICBfdGhpcy5hZGQocGFyYW1zLml0ZW1zKTtcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoZXZlbnQsIHBhcmFtcykge1xuICAgICAgICAgIF90aGlzLnVwZGF0ZShwYXJhbXMuaXRlbXMpO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShldmVudCwgcGFyYW1zKSB7XG4gICAgICAgICAgX3RoaXMucmVtb3ZlKHBhcmFtcy5pdGVtcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgICAgYXJyb3dzOiB7XG4gICAgICAgICAgdG86IHsgZW5hYmxlZDogZmFsc2UsIHNjYWxlRmFjdG9yOiAxIH0sIC8vIGJvb2xlYW4gLyB7YXJyb3dTY2FsZUZhY3RvcjoxfSAvIHtlbmFibGVkOiBmYWxzZSwgYXJyb3dTY2FsZUZhY3RvcjoxfVxuICAgICAgICAgIG1pZGRsZTogeyBlbmFibGVkOiBmYWxzZSwgc2NhbGVGYWN0b3I6IDEgfSxcbiAgICAgICAgICBmcm9tOiB7IGVuYWJsZWQ6IGZhbHNlLCBzY2FsZUZhY3RvcjogMSB9XG4gICAgICAgIH0sXG4gICAgICAgIGFycm93U3RyaWtldGhyb3VnaDogdHJ1ZSxcbiAgICAgICAgY29sb3I6IHtcbiAgICAgICAgICBjb2xvcjogJyM4NDg0ODQnLFxuICAgICAgICAgIGhpZ2hsaWdodDogJyM4NDg0ODQnLFxuICAgICAgICAgIGhvdmVyOiAnIzg0ODQ4NCcsXG4gICAgICAgICAgaW5oZXJpdDogJ2Zyb20nLFxuICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICB9LFxuICAgICAgICBkYXNoZXM6IGZhbHNlLFxuICAgICAgICBmb250OiB7XG4gICAgICAgICAgY29sb3I6ICcjMzQzNDM0JyxcbiAgICAgICAgICBzaXplOiAxNCwgLy8gcHhcbiAgICAgICAgICBmYWNlOiAnYXJpYWwnLFxuICAgICAgICAgIGJhY2tncm91bmQ6ICdub25lJyxcbiAgICAgICAgICBzdHJva2VXaWR0aDogMiwgLy8gcHhcbiAgICAgICAgICBzdHJva2VDb2xvcjogJyNmZmZmZmYnLFxuICAgICAgICAgIGFsaWduOiAnaG9yaXpvbnRhbCdcbiAgICAgICAgfSxcbiAgICAgICAgaGlkZGVuOiBmYWxzZSxcbiAgICAgICAgaG92ZXJXaWR0aDogMS41LFxuICAgICAgICBsYWJlbDogdW5kZWZpbmVkLFxuICAgICAgICBsYWJlbEhpZ2hsaWdodEJvbGQ6IHRydWUsXG4gICAgICAgIGxlbmd0aDogdW5kZWZpbmVkLFxuICAgICAgICBwaHlzaWNzOiB0cnVlLFxuICAgICAgICBzY2FsaW5nOiB7XG4gICAgICAgICAgbWluOiAxLFxuICAgICAgICAgIG1heDogMTUsXG4gICAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICBtaW46IDE0LFxuICAgICAgICAgICAgbWF4OiAzMCxcbiAgICAgICAgICAgIG1heFZpc2libGU6IDMwLFxuICAgICAgICAgICAgZHJhd1RocmVzaG9sZDogNVxuICAgICAgICAgIH0sXG4gICAgICAgICAgY3VzdG9tU2NhbGluZ0Z1bmN0aW9uOiBmdW5jdGlvbiBjdXN0b21TY2FsaW5nRnVuY3Rpb24obWluLCBtYXgsIHRvdGFsLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgICAgICAgICAgIHJldHVybiAwLjU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgc2NhbGUgPSAxIC8gKG1heCAtIG1pbik7XG4gICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCgwLCAodmFsdWUgLSBtaW4pICogc2NhbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2VsZWN0aW9uV2lkdGg6IDEuNSxcbiAgICAgICAgc2VsZlJlZmVyZW5jZVNpemU6IDIwLFxuICAgICAgICBzaGFkb3c6IHtcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICBjb2xvcjogJ3JnYmEoMCwwLDAsMC41KScsXG4gICAgICAgICAgc2l6ZTogMTAsXG4gICAgICAgICAgeDogNSxcbiAgICAgICAgICB5OiA1XG4gICAgICAgIH0sXG4gICAgICAgIHNtb290aDoge1xuICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgdHlwZTogXCJkeW5hbWljXCIsXG4gICAgICAgICAgZm9yY2VEaXJlY3Rpb246ICdub25lJyxcbiAgICAgICAgICByb3VuZG5lc3M6IDAuNVxuICAgICAgICB9LFxuICAgICAgICB0aXRsZTogdW5kZWZpbmVkLFxuICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgICAgfTtcblxuICAgICAgdXRpbC5leHRlbmQodGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICAgICAgdGhpcy5iaW5kRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoRWRnZXNIYW5kbGVyLCBbe1xuICAgICAga2V5OiAnYmluZEV2ZW50TGlzdGVuZXJzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIC8vIHRoaXMgYWxsb3dzIGV4dGVybmFsIG1vZHVsZXMgdG8gZm9yY2UgYWxsIGR5bmFtaWMgY3VydmVzIHRvIHR1cm4gc3RhdGljLlxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9mb3JjZURpc2FibGVEeW5hbWljQ3VydmVzXCIsIGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdkeW5hbWljJykge1xuICAgICAgICAgICAgdHlwZSA9ICdjb250aW51b3VzJztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGVtaXRDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgICBmb3IgKHZhciBlZGdlSWQgaW4gX3RoaXMyLmJvZHkuZWRnZXMpIHtcbiAgICAgICAgICAgIGlmIChfdGhpczIuYm9keS5lZGdlcy5oYXNPd25Qcm9wZXJ0eShlZGdlSWQpKSB7XG4gICAgICAgICAgICAgIHZhciBlZGdlID0gX3RoaXMyLmJvZHkuZWRnZXNbZWRnZUlkXTtcbiAgICAgICAgICAgICAgdmFyIGVkZ2VEYXRhID0gX3RoaXMyLmJvZHkuZGF0YS5lZGdlcy5fZGF0YVtlZGdlSWRdO1xuXG4gICAgICAgICAgICAgIC8vIG9ubHkgZm9yY2libHkgcmVtb3ZlIHRoZSBzbW9vdGggY3VydmUgaWYgdGhlIGRhdGEgaGFzIGJlZW4gc2V0IG9mIHRoZSBlZGdlIGhhcyB0aGUgc21vb3RoIGN1cnZlcyBkZWZpbmVkLlxuICAgICAgICAgICAgICAvLyB0aGlzIGlzIGJlY2F1c2UgYSBjaGFuZ2UgaW4gdGhlIGdsb2JhbCB3b3VsZCBub3QgYWZmZWN0IHRoZXNlIGN1cnZlcy5cbiAgICAgICAgICAgICAgaWYgKGVkZ2VEYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWRnZU9wdGlvbnMgPSBlZGdlRGF0YS5zbW9vdGg7XG4gICAgICAgICAgICAgICAgaWYgKGVkZ2VPcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChlZGdlT3B0aW9ucy5lbmFibGVkID09PSB0cnVlICYmIGVkZ2VPcHRpb25zLnR5cGUgPT09ICdkeW5hbWljJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZWRnZS5zZXRPcHRpb25zKHsgc21vb3RoOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBlZGdlLnNldE9wdGlvbnMoeyBzbW9vdGg6IHsgdHlwZTogdHlwZSB9IH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVtaXRDaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZW1pdENoYW5nZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgX3RoaXMyLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gdGhpcyBpcyBjYWxsZWQgd2hlbiBvcHRpb25zIG9mIEVYSVNUSU5HIG5vZGVzIG9yIGVkZ2VzIGhhdmUgY2hhbmdlZC5cbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfZGF0YVVwZGF0ZWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMi5yZWNvbm5lY3RFZGdlcygpO1xuICAgICAgICAgIF90aGlzMi5tYXJrQWxsRWRnZXNBc0RpcnR5KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHJlZnJlc2ggdGhlIGVkZ2VzLiBVc2VkIHdoZW4gcmV2ZXJ0aW5nIGZyb20gaGllcmFyY2hpY2FsIGxheW91dFxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcInJlZnJlc2hFZGdlc1wiLCB0aGlzLnJlZnJlc2guYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwicmVmcmVzaFwiLCB0aGlzLnJlZnJlc2guYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiZGVzdHJveVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdXRpbC5mb3JFYWNoKF90aGlzMi5lZGdlc0xpc3RlbmVycywgZnVuY3Rpb24gKGNhbGxiYWNrLCBldmVudCkge1xuICAgICAgICAgICAgaWYgKF90aGlzMi5ib2R5LmRhdGEuZWRnZXMpIF90aGlzMi5ib2R5LmRhdGEuZWRnZXMub2ZmKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZGVsZXRlIF90aGlzMi5ib2R5LmZ1bmN0aW9ucy5jcmVhdGVFZGdlO1xuICAgICAgICAgIGRlbGV0ZSBfdGhpczIuZWRnZXNMaXN0ZW5lcnMuYWRkO1xuICAgICAgICAgIGRlbGV0ZSBfdGhpczIuZWRnZXNMaXN0ZW5lcnMudXBkYXRlO1xuICAgICAgICAgIGRlbGV0ZSBfdGhpczIuZWRnZXNMaXN0ZW5lcnMucmVtb3ZlO1xuICAgICAgICAgIGRlbGV0ZSBfdGhpczIuZWRnZXNMaXN0ZW5lcnM7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NldE9wdGlvbnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gdXNlIHRoZSBwYXJzZXIgZnJvbSB0aGUgRWRnZSBjbGFzcyB0byBmaWxsIGluIGFsbCBzaG9ydGhhbmQgbm90YXRpb25zXG4gICAgICAgICAgX0VkZ2UyLmRlZmF1bHQucGFyc2VPcHRpb25zKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgICAgICAvLyBoYW5kbGUgbXVsdGlwbGUgaW5wdXQgY2FzZXMgZm9yIGNvbG9yXG4gICAgICAgICAgaWYgKG9wdGlvbnMuY29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5tYXJrQWxsRWRnZXNBc0RpcnR5KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdXBkYXRlIHNtb290aCBzZXR0aW5ncyBpbiBhbGwgZWRnZXNcbiAgICAgICAgICB2YXIgZGF0YUNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5zbW9vdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgZWRnZUlkIGluIHRoaXMuYm9keS5lZGdlcykge1xuICAgICAgICAgICAgICBpZiAodGhpcy5ib2R5LmVkZ2VzLmhhc093blByb3BlcnR5KGVkZ2VJZCkpIHtcbiAgICAgICAgICAgICAgICBkYXRhQ2hhbmdlZCA9IHRoaXMuYm9keS5lZGdlc1tlZGdlSWRdLnVwZGF0ZUVkZ2VUeXBlKCkgfHwgZGF0YUNoYW5nZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB1cGRhdGUgZm9udHMgaW4gYWxsIGVkZ2VzXG4gICAgICAgICAgaWYgKG9wdGlvbnMuZm9udCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyB1c2UgdGhlIHBhcnNlciBmcm9tIHRoZSBMYWJlbCBjbGFzcyB0byBmaWxsIGluIGFsbCBzaG9ydGhhbmQgbm90YXRpb25zXG4gICAgICAgICAgICBfTGFiZWwyLmRlZmF1bHQucGFyc2VPcHRpb25zKHRoaXMub3B0aW9ucy5mb250LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGZvciAodmFyIF9lZGdlSWQgaW4gdGhpcy5ib2R5LmVkZ2VzKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmJvZHkuZWRnZXMuaGFzT3duUHJvcGVydHkoX2VkZ2VJZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJvZHkuZWRnZXNbX2VkZ2VJZF0udXBkYXRlTGFiZWxNb2R1bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgc3RhdGUgb2YgdGhlIHZhcmlhYmxlcyBpZiBuZWVkZWRcbiAgICAgICAgICBpZiAob3B0aW9ucy5oaWRkZW4gIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnBoeXNpY3MgIT09IHVuZGVmaW5lZCB8fCBkYXRhQ2hhbmdlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2RhdGFDaGFuZ2VkJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogTG9hZCBlZGdlcyBieSByZWFkaW5nIHRoZSBkYXRhIHRhYmxlXG4gICAgICAgKiBAcGFyYW0ge0FycmF5IHwgRGF0YVNldCB8IERhdGFWaWV3fSBlZGdlcyAgICBUaGUgZGF0YSBjb250YWluaW5nIHRoZSBlZGdlcy5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzZXREYXRhJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREYXRhKGVkZ2VzKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBkb05vdEVtaXQgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICB2YXIgb2xkRWRnZXNEYXRhID0gdGhpcy5ib2R5LmRhdGEuZWRnZXM7XG5cbiAgICAgICAgaWYgKGVkZ2VzIGluc3RhbmNlb2YgRGF0YVNldCB8fCBlZGdlcyBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmRhdGEuZWRnZXMgPSBlZGdlcztcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGVkZ2VzKSkge1xuICAgICAgICAgIHRoaXMuYm9keS5kYXRhLmVkZ2VzID0gbmV3IERhdGFTZXQoKTtcbiAgICAgICAgICB0aGlzLmJvZHkuZGF0YS5lZGdlcy5hZGQoZWRnZXMpO1xuICAgICAgICB9IGVsc2UgaWYgKCFlZGdlcykge1xuICAgICAgICAgIHRoaXMuYm9keS5kYXRhLmVkZ2VzID0gbmV3IERhdGFTZXQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheSBvciBEYXRhU2V0IGV4cGVjdGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBpcyB0aGlzIG51bGwgb3IgdW5kZWZpbmVkIG9yIGZhbHNlP1xuICAgICAgICBpZiAob2xkRWRnZXNEYXRhKSB7XG4gICAgICAgICAgLy8gdW5zdWJzY3JpYmUgZnJvbSBvbGQgZGF0YXNldFxuICAgICAgICAgIHV0aWwuZm9yRWFjaCh0aGlzLmVkZ2VzTGlzdGVuZXJzLCBmdW5jdGlvbiAoY2FsbGJhY2ssIGV2ZW50KSB7XG4gICAgICAgICAgICBvbGRFZGdlc0RhdGEub2ZmKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgZHJhd24gZWRnZXNcbiAgICAgICAgdGhpcy5ib2R5LmVkZ2VzID0ge307XG5cbiAgICAgICAgLy8gVE9ETzogaXMgdGhpcyBudWxsIG9yIHVuZGVmaW5lZCBvciBmYWxzZT9cbiAgICAgICAgaWYgKHRoaXMuYm9keS5kYXRhLmVkZ2VzKSB7XG4gICAgICAgICAgLy8gc3Vic2NyaWJlIHRvIG5ldyBkYXRhc2V0XG4gICAgICAgICAgdXRpbC5mb3JFYWNoKHRoaXMuZWRnZXNMaXN0ZW5lcnMsIGZ1bmN0aW9uIChjYWxsYmFjaywgZXZlbnQpIHtcbiAgICAgICAgICAgIF90aGlzMy5ib2R5LmRhdGEuZWRnZXMub24oZXZlbnQsIGNhbGxiYWNrKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIGRyYXcgYWxsIG5ldyBub2Rlc1xuICAgICAgICAgIHZhciBpZHMgPSB0aGlzLmJvZHkuZGF0YS5lZGdlcy5nZXRJZHMoKTtcbiAgICAgICAgICB0aGlzLmFkZChpZHMsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRvTm90RW1pdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQWRkIGVkZ2VzXG4gICAgICAgKiBAcGFyYW0ge051bWJlcltdIHwgU3RyaW5nW119IGlkc1xuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnYWRkJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoaWRzKSB7XG4gICAgICAgIHZhciBkb05vdEVtaXQgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gICAgICAgIHZhciBlZGdlc0RhdGEgPSB0aGlzLmJvZHkuZGF0YS5lZGdlcztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBpZCA9IGlkc1tpXTtcblxuICAgICAgICAgIHZhciBvbGRFZGdlID0gZWRnZXNbaWRdO1xuICAgICAgICAgIGlmIChvbGRFZGdlKSB7XG4gICAgICAgICAgICBvbGRFZGdlLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZGF0YSA9IGVkZ2VzRGF0YS5nZXQoaWQsIHsgXCJzaG93SW50ZXJuYWxJZHNcIjogdHJ1ZSB9KTtcbiAgICAgICAgICBlZGdlc1tpZF0gPSB0aGlzLmNyZWF0ZShkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb05vdEVtaXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFVwZGF0ZSBleGlzdGluZyBlZGdlcywgb3IgY3JlYXRlIHRoZW0gd2hlbiBub3QgeWV0IGV4aXN0aW5nXG4gICAgICAgKiBAcGFyYW0ge051bWJlcltdIHwgU3RyaW5nW119IGlkc1xuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAndXBkYXRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUoaWRzKSB7XG4gICAgICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcbiAgICAgICAgdmFyIGVkZ2VzRGF0YSA9IHRoaXMuYm9keS5kYXRhLmVkZ2VzO1xuICAgICAgICB2YXIgZGF0YUNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgaWQgPSBpZHNbaV07XG4gICAgICAgICAgdmFyIGRhdGEgPSBlZGdlc0RhdGEuZ2V0KGlkKTtcbiAgICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2lkXTtcbiAgICAgICAgICBpZiAoZWRnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyB1cGRhdGUgZWRnZVxuICAgICAgICAgICAgZWRnZS5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICBkYXRhQ2hhbmdlZCA9IGVkZ2Uuc2V0T3B0aW9ucyhkYXRhKSB8fCBkYXRhQ2hhbmdlZDsgLy8gaWYgYSBzdXBwb3J0IG5vZGUgaXMgYWRkZWQsIGRhdGEgY2FuIGJlIGNoYW5nZWQuXG4gICAgICAgICAgICBlZGdlLmNvbm5lY3QoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY3JlYXRlIGVkZ2VcbiAgICAgICAgICAgIHRoaXMuYm9keS5lZGdlc1tpZF0gPSB0aGlzLmNyZWF0ZShkYXRhKTtcbiAgICAgICAgICAgIGRhdGFDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YUNoYW5nZWQgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YVVwZGF0ZWRcIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmUgZXhpc3RpbmcgZWRnZXMuIE5vbiBleGlzdGluZyBpZHMgd2lsbCBiZSBpZ25vcmVkXG4gICAgICAgKiBAcGFyYW0ge051bWJlcltdIHwgU3RyaW5nW119IGlkc1xuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAncmVtb3ZlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoaWRzKSB7XG4gICAgICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgaWQgPSBpZHNbaV07XG4gICAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tpZF07XG4gICAgICAgICAgaWYgKGVkZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZWRnZS5jbGVhbnVwKCk7XG4gICAgICAgICAgICBlZGdlLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIGRlbGV0ZSBlZGdlc1tpZF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyZWZyZXNoJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWZyZXNoKCkge1xuICAgICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gICAgICAgIGZvciAodmFyIGVkZ2VJZCBpbiBlZGdlcykge1xuICAgICAgICAgIHZhciBlZGdlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGlmIChlZGdlcy5oYXNPd25Qcm9wZXJ0eShlZGdlSWQpKSB7XG4gICAgICAgICAgICBlZGdlID0gZWRnZXNbZWRnZUlkXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmJvZHkuZGF0YS5lZGdlcy5fZGF0YVtlZGdlSWRdO1xuICAgICAgICAgIGlmIChlZGdlICE9PSB1bmRlZmluZWQgJiYgZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlZGdlLnNldE9wdGlvbnMoZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnY3JlYXRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICByZXR1cm4gbmV3IF9FZGdlMi5kZWZhdWx0KHByb3BlcnRpZXMsIHRoaXMuYm9keSwgdGhpcy5vcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdtYXJrQWxsRWRnZXNBc0RpcnR5JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBtYXJrQWxsRWRnZXNBc0RpcnR5KCkge1xuICAgICAgICBmb3IgKHZhciBlZGdlSWQgaW4gdGhpcy5ib2R5LmVkZ2VzKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVkZ2VzW2VkZ2VJZF0uZWRnZVR5cGUuY29sb3JEaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZWNvbm5lY3QgYWxsIGVkZ2VzXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyZWNvbm5lY3RFZGdlcycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVjb25uZWN0RWRnZXMoKSB7XG4gICAgICAgIHZhciBpZDtcbiAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG5cbiAgICAgICAgZm9yIChpZCBpbiBub2Rlcykge1xuICAgICAgICAgIGlmIChub2Rlcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgIG5vZGVzW2lkXS5lZGdlcyA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaWQgaW4gZWRnZXMpIHtcbiAgICAgICAgICBpZiAoZWRnZXMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2lkXTtcbiAgICAgICAgICAgIGVkZ2UuZnJvbSA9IG51bGw7XG4gICAgICAgICAgICBlZGdlLnRvID0gbnVsbDtcbiAgICAgICAgICAgIGVkZ2UuY29ubmVjdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldENvbm5lY3RlZE5vZGVzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb25uZWN0ZWROb2RlcyhlZGdlSWQpIHtcbiAgICAgICAgdmFyIG5vZGVMaXN0ID0gW107XG4gICAgICAgIGlmICh0aGlzLmJvZHkuZWRnZXNbZWRnZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIGVkZ2UgPSB0aGlzLmJvZHkuZWRnZXNbZWRnZUlkXTtcbiAgICAgICAgICBpZiAoZWRnZS5mcm9tSWQpIHtcbiAgICAgICAgICAgIG5vZGVMaXN0LnB1c2goZWRnZS5mcm9tSWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZWRnZS50b0lkKSB7XG4gICAgICAgICAgICBub2RlTGlzdC5wdXNoKGVkZ2UudG9JZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlTGlzdDtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gRWRnZXNIYW5kbGVyO1xuICB9KCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gRWRnZXNIYW5kbGVyO1xuXG4vKioqLyB9LFxuLyogODUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIHZhciBfTGFiZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2KTtcblxuICB2YXIgX0xhYmVsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0xhYmVsKTtcblxuICB2YXIgX0N1YmljQmV6aWVyRWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oODYpO1xuXG4gIHZhciBfQ3ViaWNCZXppZXJFZGdlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0N1YmljQmV6aWVyRWRnZSk7XG5cbiAgdmFyIF9CZXppZXJFZGdlRHluYW1pYyA9IF9fd2VicGFja19yZXF1aXJlX18oOTApO1xuXG4gIHZhciBfQmV6aWVyRWRnZUR5bmFtaWMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmV6aWVyRWRnZUR5bmFtaWMpO1xuXG4gIHZhciBfQmV6aWVyRWRnZVN0YXRpYyA9IF9fd2VicGFja19yZXF1aXJlX18oOTEpO1xuXG4gIHZhciBfQmV6aWVyRWRnZVN0YXRpYzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CZXppZXJFZGdlU3RhdGljKTtcblxuICB2YXIgX1N0cmFpZ2h0RWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTIpO1xuXG4gIHZhciBfU3RyYWlnaHRFZGdlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N0cmFpZ2h0RWRnZSk7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuICAvKipcbiAgICogQGNsYXNzIEVkZ2VcbiAgICpcbiAgICogQSBlZGdlIGNvbm5lY3RzIHR3byBub2Rlc1xuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyAgICAgT2JqZWN0IHdpdGggb3B0aW9ucy4gTXVzdCBjb250YWluXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBdCBsZWFzdCBvcHRpb25zIGZyb20gYW5kIHRvLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXZhaWxhYmxlIG9wdGlvbnM6IGZyb20gKG51bWJlciksXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byAobnVtYmVyKSwgbGFiZWwgKHN0cmluZywgY29sb3IgKHN0cmluZyksXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCAobnVtYmVyKSwgc3R5bGUgKHN0cmluZyksXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggKG51bWJlciksIHRpdGxlIChzdHJpbmcpXG4gICAqIEBwYXJhbSB7TmV0d29ya30gbmV0d29yayAgICAgICBBIE5ldHdvcmsgb2JqZWN0LCB1c2VkIHRvIGZpbmQgYW5kIGVkZ2UgdG9cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uc3RhbnRzICAgICAgQW4gb2JqZWN0IHdpdGggZGVmYXVsdCB2YWx1ZXMgZm9yXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGFtcGxlIGZvciB0aGUgY29sb3JcbiAgICovXG5cbiAgdmFyIEVkZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRWRnZShvcHRpb25zLCBib2R5LCBnbG9iYWxPcHRpb25zKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRWRnZSk7XG5cbiAgICAgIGlmIChib2R5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgXCJObyBib2R5IHByb3ZpZGVkXCI7XG4gICAgICB9XG4gICAgICB0aGlzLm9wdGlvbnMgPSB1dGlsLmJyaWRnZU9iamVjdChnbG9iYWxPcHRpb25zKTtcbiAgICAgIHRoaXMuZ2xvYmFsT3B0aW9ucyA9IGdsb2JhbE9wdGlvbnM7XG4gICAgICB0aGlzLmJvZHkgPSBib2R5O1xuXG4gICAgICAvLyBpbml0aWFsaXplIHZhcmlhYmxlc1xuICAgICAgdGhpcy5pZCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZnJvbUlkID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy50b0lkID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5ob3ZlciA9IGZhbHNlO1xuICAgICAgdGhpcy5sYWJlbERpcnR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMuY29sb3JEaXJ0eSA9IHRydWU7XG5cbiAgICAgIHRoaXMuYmFzZVdpZHRoID0gdGhpcy5vcHRpb25zLndpZHRoO1xuICAgICAgdGhpcy5iYXNlRm9udFNpemUgPSB0aGlzLm9wdGlvbnMuZm9udC5zaXplO1xuXG4gICAgICB0aGlzLmZyb20gPSB1bmRlZmluZWQ7IC8vIGEgbm9kZVxuICAgICAgdGhpcy50byA9IHVuZGVmaW5lZDsgLy8gYSBub2RlXG5cbiAgICAgIHRoaXMuZWRnZVR5cGUgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG5cbiAgICAgIHRoaXMubGFiZWxNb2R1bGUgPSBuZXcgX0xhYmVsMi5kZWZhdWx0KHRoaXMuYm9keSwgdGhpcy5vcHRpb25zLCB0cnVlIC8qIEl0J3MgYW4gZWRnZSBsYWJlbCAqLyk7XG5cbiAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgb3Igb3ZlcndyaXRlIG9wdGlvbnMgZm9yIHRoZSBlZGdlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgIGFuIG9iamVjdCB3aXRoIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gZG9Ob3RFbWl0XG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhFZGdlLCBbe1xuICAgICAga2V5OiAnc2V0T3B0aW9ucycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbG9yRGlydHkgPSB0cnVlO1xuXG4gICAgICAgIEVkZ2UucGFyc2VPcHRpb25zKHRoaXMub3B0aW9ucywgb3B0aW9ucywgdHJ1ZSwgdGhpcy5nbG9iYWxPcHRpb25zKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5pZCA9IG9wdGlvbnMuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZnJvbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5mcm9tSWQgPSBvcHRpb25zLmZyb207XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMudG8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMudG9JZCA9IG9wdGlvbnMudG87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMudGl0bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMudGl0bGUgPSBvcHRpb25zLnRpdGxlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBvcHRpb25zLnZhbHVlID0gcGFyc2VGbG9hdChvcHRpb25zLnZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSBsYWJlbCBNb2R1bGVcbiAgICAgICAgdGhpcy51cGRhdGVMYWJlbE1vZHVsZSgpO1xuXG4gICAgICAgIHZhciBkYXRhQ2hhbmdlZCA9IHRoaXMudXBkYXRlRWRnZVR5cGUoKTtcblxuICAgICAgICAvLyBpZiBhbnl0aGluZyBoYXMgYmVlbiB1cGRhdGVzLCByZXNldCB0aGUgc2VsZWN0aW9uIHdpZHRoIGFuZCB0aGUgaG92ZXIgd2lkdGhcbiAgICAgICAgdGhpcy5fc2V0SW50ZXJhY3Rpb25XaWR0aHMoKTtcblxuICAgICAgICAvLyBBIG5vZGUgaXMgY29ubmVjdGVkIHdoZW4gaXQgaGFzIGEgZnJvbSBhbmQgdG8gbm9kZSB0aGF0IGJvdGggZXhpc3QgaW4gdGhlIG5ldHdvcmsuYm9keS5ub2Rlcy5cbiAgICAgICAgdGhpcy5jb25uZWN0KCk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuaGlkZGVuICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5waHlzaWNzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkYXRhQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YUNoYW5nZWQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAndXBkYXRlTGFiZWxNb2R1bGUnLFxuICAgICAgLy8gc2V0IHRoZSBvYmplY3QgYmFjayB0byB0aGUgZ2xvYmFsIG9wdGlvbnNcblxuXG4gICAgICAvKipcbiAgICAgICAqIHVwZGF0ZSB0aGUgb3B0aW9ucyBpbiB0aGUgbGFiZWwgbW9kdWxlXG4gICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVMYWJlbE1vZHVsZSgpIHtcbiAgICAgICAgdGhpcy5sYWJlbE1vZHVsZS5zZXRPcHRpb25zKHRoaXMub3B0aW9ucywgdHJ1ZSk7XG4gICAgICAgIGlmICh0aGlzLmxhYmVsTW9kdWxlLmJhc2VTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmJhc2VGb250U2l6ZSA9IHRoaXMubGFiZWxNb2R1bGUuYmFzZVNpemU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiB1cGRhdGUgdGhlIGVkZ2UgdHlwZSwgc2V0IHRoZSBvcHRpb25zXG4gICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAndXBkYXRlRWRnZVR5cGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUVkZ2VUeXBlKCkge1xuICAgICAgICB2YXIgZGF0YUNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGNoYW5nZUluVHlwZSA9IHRydWU7XG4gICAgICAgIHZhciBzbW9vdGggPSB0aGlzLm9wdGlvbnMuc21vb3RoO1xuICAgICAgICBpZiAodGhpcy5lZGdlVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZWRnZVR5cGUgaW5zdGFuY2VvZiBfQmV6aWVyRWRnZUR5bmFtaWMyLmRlZmF1bHQgJiYgc21vb3RoLmVuYWJsZWQgPT09IHRydWUgJiYgc21vb3RoLnR5cGUgPT09ICdkeW5hbWljJykge1xuICAgICAgICAgICAgY2hhbmdlSW5UeXBlID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLmVkZ2VUeXBlIGluc3RhbmNlb2YgX0N1YmljQmV6aWVyRWRnZTIuZGVmYXVsdCAmJiBzbW9vdGguZW5hYmxlZCA9PT0gdHJ1ZSAmJiBzbW9vdGgudHlwZSA9PT0gJ2N1YmljQmV6aWVyJykge1xuICAgICAgICAgICAgY2hhbmdlSW5UeXBlID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLmVkZ2VUeXBlIGluc3RhbmNlb2YgX0JlemllckVkZ2VTdGF0aWMyLmRlZmF1bHQgJiYgc21vb3RoLmVuYWJsZWQgPT09IHRydWUgJiYgc21vb3RoLnR5cGUgIT09ICdkeW5hbWljJyAmJiBzbW9vdGgudHlwZSAhPT0gJ2N1YmljQmV6aWVyJykge1xuICAgICAgICAgICAgY2hhbmdlSW5UeXBlID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLmVkZ2VUeXBlIGluc3RhbmNlb2YgX1N0cmFpZ2h0RWRnZTIuZGVmYXVsdCAmJiBzbW9vdGguZW5hYmxlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNoYW5nZUluVHlwZSA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjaGFuZ2VJblR5cGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGRhdGFDaGFuZ2VkID0gdGhpcy5jbGVhbnVwKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoYW5nZUluVHlwZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc21vb3RoLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc21vb3RoLnR5cGUgPT09ICdkeW5hbWljJykge1xuICAgICAgICAgICAgICBkYXRhQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgIHRoaXMuZWRnZVR5cGUgPSBuZXcgX0JlemllckVkZ2VEeW5hbWljMi5kZWZhdWx0KHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnNtb290aC50eXBlID09PSAnY3ViaWNCZXppZXInKSB7XG4gICAgICAgICAgICAgIHRoaXMuZWRnZVR5cGUgPSBuZXcgX0N1YmljQmV6aWVyRWRnZTIuZGVmYXVsdCh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmVkZ2VUeXBlID0gbmV3IF9CZXppZXJFZGdlU3RhdGljMi5kZWZhdWx0KHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lZGdlVHlwZSA9IG5ldyBfU3RyYWlnaHRFZGdlMi5kZWZhdWx0KHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaWYgbm90aGluZyBjaGFuZ2VzLCB3ZSBqdXN0IHNldCB0aGUgb3B0aW9ucy5cbiAgICAgICAgICB0aGlzLmVkZ2VUeXBlLnNldE9wdGlvbnModGhpcy5vcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhQ2hhbmdlZDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDb25uZWN0IGFuIGVkZ2UgdG8gaXRzIG5vZGVzXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Nvbm5lY3QnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuXG4gICAgICAgIHRoaXMuZnJvbSA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLmZyb21JZF0gfHwgdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnRvID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMudG9JZF0gfHwgdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IHRoaXMuZnJvbSAhPT0gdW5kZWZpbmVkICYmIHRoaXMudG8gIT09IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmZyb20uYXR0YWNoRWRnZSh0aGlzKTtcbiAgICAgICAgICB0aGlzLnRvLmF0dGFjaEVkZ2UodGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuZnJvbSkge1xuICAgICAgICAgICAgdGhpcy5mcm9tLmRldGFjaEVkZ2UodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLnRvKSB7XG4gICAgICAgICAgICB0aGlzLnRvLmRldGFjaEVkZ2UodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lZGdlVHlwZS5jb25uZWN0KCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRGlzY29ubmVjdCBhbiBlZGdlIGZyb20gaXRzIG5vZGVzXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Rpc2Nvbm5lY3QnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIGlmICh0aGlzLmZyb20pIHtcbiAgICAgICAgICB0aGlzLmZyb20uZGV0YWNoRWRnZSh0aGlzKTtcbiAgICAgICAgICB0aGlzLmZyb20gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudG8pIHtcbiAgICAgICAgICB0aGlzLnRvLmRldGFjaEVkZ2UodGhpcyk7XG4gICAgICAgICAgdGhpcy50byA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogZ2V0IHRoZSB0aXRsZSBvZiB0aGlzIGVkZ2UuXG4gICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRpdGxlICAgIFRoZSB0aXRsZSBvZiB0aGUgZWRnZSwgb3IgdW5kZWZpbmVkIHdoZW4gbm8gdGl0bGVcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzIGJlZW4gc2V0LlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXRUaXRsZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGl0bGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpdGxlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGNoZWNrIGlmIHRoaXMgbm9kZSBpcyBzZWxlY3RlXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBzZWxlY3RlZCAgIFRydWUgaWYgbm9kZSBpcyBzZWxlY3RlZCwgZWxzZSBmYWxzZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdpc1NlbGVjdGVkJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc1NlbGVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXRyaWV2ZSB0aGUgdmFsdWUgb2YgdGhlIGVkZ2UuIENhbiBiZSB1bmRlZmluZWRcbiAgICAgICAqIEByZXR1cm4ge051bWJlcn0gdmFsdWVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0VmFsdWUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnZhbHVlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFkanVzdCB0aGUgdmFsdWUgcmFuZ2Ugb2YgdGhlIGVkZ2UuIFRoZSBlZGdlIHdpbGwgYWRqdXN0IGl0J3Mgd2lkdGhcbiAgICAgICAqIGJhc2VkIG9uIGl0cyB2YWx1ZS5cbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtaW5cbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhcbiAgICAgICAqIEBwYXJhbSB0b3RhbFxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzZXRWYWx1ZVJhbmdlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZVJhbmdlKG1pbiwgbWF4LCB0b3RhbCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLm9wdGlvbnMuc2NhbGluZy5jdXN0b21TY2FsaW5nRnVuY3Rpb24obWluLCBtYXgsIHRvdGFsLCB0aGlzLm9wdGlvbnMudmFsdWUpO1xuICAgICAgICAgIHZhciB3aWR0aERpZmYgPSB0aGlzLm9wdGlvbnMuc2NhbGluZy5tYXggLSB0aGlzLm9wdGlvbnMuc2NhbGluZy5taW47XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zY2FsaW5nLmxhYmVsLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBmb250RGlmZiA9IHRoaXMub3B0aW9ucy5zY2FsaW5nLmxhYmVsLm1heCAtIHRoaXMub3B0aW9ucy5zY2FsaW5nLmxhYmVsLm1pbjtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5mb250LnNpemUgPSB0aGlzLm9wdGlvbnMuc2NhbGluZy5sYWJlbC5taW4gKyBzY2FsZSAqIGZvbnREaWZmO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm9wdGlvbnMud2lkdGggPSB0aGlzLm9wdGlvbnMuc2NhbGluZy5taW4gKyBzY2FsZSAqIHdpZHRoRGlmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMud2lkdGggPSB0aGlzLmJhc2VXaWR0aDtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZm9udC5zaXplID0gdGhpcy5iYXNlRm9udFNpemU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zZXRJbnRlcmFjdGlvbldpZHRocygpO1xuICAgICAgICB0aGlzLnVwZGF0ZUxhYmVsTW9kdWxlKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX3NldEludGVyYWN0aW9uV2lkdGhzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0SW50ZXJhY3Rpb25XaWR0aHMoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmhvdmVyV2lkdGggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzLmVkZ2VUeXBlLmhvdmVyV2lkdGggPSB0aGlzLm9wdGlvbnMuaG92ZXJXaWR0aCh0aGlzLm9wdGlvbnMud2lkdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZWRnZVR5cGUuaG92ZXJXaWR0aCA9IHRoaXMub3B0aW9ucy5ob3ZlcldpZHRoICsgdGhpcy5vcHRpb25zLndpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuc2VsZWN0aW9uV2lkdGggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzLmVkZ2VUeXBlLnNlbGVjdGlvbldpZHRoID0gdGhpcy5vcHRpb25zLnNlbGVjdGlvbldpZHRoKHRoaXMub3B0aW9ucy53aWR0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5lZGdlVHlwZS5zZWxlY3Rpb25XaWR0aCA9IHRoaXMub3B0aW9ucy5zZWxlY3Rpb25XaWR0aCArIHRoaXMub3B0aW9ucy53aWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlZHJhdyBhIGVkZ2VcbiAgICAgICAqIERyYXcgdGhpcyBlZGdlIGluIHRoZSBnaXZlbiBjYW52YXNcbiAgICAgICAqIFRoZSAyZCBjb250ZXh0IG9mIGEgSFRNTCBjYW52YXMgY2FuIGJlIHJldHJpZXZlZCBieSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICAgY3R4XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2RyYXcnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4KSB7XG4gICAgICAgIC8vIGdldCB0aGUgdmlhIG5vZGUgZnJvbSB0aGUgZWRnZSB0eXBlXG4gICAgICAgIHZhciB2aWFOb2RlID0gdGhpcy5lZGdlVHlwZS5nZXRWaWFOb2RlKCk7XG4gICAgICAgIHZhciBhcnJvd0RhdGEgPSB7fTtcblxuICAgICAgICAvLyByZXN0b3JlIGVkZ2UgdGFyZ2V0cyB0byBkZWZhdWx0c1xuICAgICAgICB0aGlzLmVkZ2VUeXBlLmZyb21Qb2ludCA9IHRoaXMuZWRnZVR5cGUuZnJvbTtcbiAgICAgICAgdGhpcy5lZGdlVHlwZS50b1BvaW50ID0gdGhpcy5lZGdlVHlwZS50bztcblxuICAgICAgICAvLyBmcm9tIGFuZCB0byBhcnJvd3MgZ2l2ZSBhIGRpZmZlcmVudCBlbmQgcG9pbnQgZm9yIGVkZ2VzLiB3ZSBzZXQgdGhlbSBoZXJlXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXJyb3dzLmZyb20uZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGFycm93RGF0YS5mcm9tID0gdGhpcy5lZGdlVHlwZS5nZXRBcnJvd0RhdGEoY3R4LCAnZnJvbScsIHZpYU5vZGUsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIpO1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXJyb3dTdHJpa2V0aHJvdWdoID09PSBmYWxzZSkgdGhpcy5lZGdlVHlwZS5mcm9tUG9pbnQgPSBhcnJvd0RhdGEuZnJvbS5jb3JlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXJyb3dzLnRvLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICBhcnJvd0RhdGEudG8gPSB0aGlzLmVkZ2VUeXBlLmdldEFycm93RGF0YShjdHgsICd0bycsIHZpYU5vZGUsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIpO1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXJyb3dTdHJpa2V0aHJvdWdoID09PSBmYWxzZSkgdGhpcy5lZGdlVHlwZS50b1BvaW50ID0gYXJyb3dEYXRhLnRvLmNvcmU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGUgbWlkZGxlIGFycm93IGRlcGVuZHMgb24gdGhlIGxpbmUsIHdoaWNoIGNhbiBkZXBlbmQgb24gdGhlIHRvIGFuZCBmcm9tIGFycm93cyBzbyB3ZSBkbyB0aGlzIG9uZSBsYXN0bHkuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXJyb3dzLm1pZGRsZS5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgYXJyb3dEYXRhLm1pZGRsZSA9IHRoaXMuZWRnZVR5cGUuZ2V0QXJyb3dEYXRhKGN0eCwgJ21pZGRsZScsIHZpYU5vZGUsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZHJhdyBldmVyeXRoaW5nXG4gICAgICAgIHRoaXMuZWRnZVR5cGUuZHJhd0xpbmUoY3R4LCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyLCB2aWFOb2RlKTtcbiAgICAgICAgdGhpcy5kcmF3QXJyb3dzKGN0eCwgYXJyb3dEYXRhKTtcbiAgICAgICAgdGhpcy5kcmF3TGFiZWwoY3R4LCB2aWFOb2RlKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkcmF3QXJyb3dzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3QXJyb3dzKGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXJyb3dzLmZyb20uZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuZWRnZVR5cGUuZHJhd0Fycm93SGVhZChjdHgsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIsIGFycm93RGF0YS5mcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFycm93cy5taWRkbGUuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuZWRnZVR5cGUuZHJhd0Fycm93SGVhZChjdHgsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIsIGFycm93RGF0YS5taWRkbGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXJyb3dzLnRvLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmVkZ2VUeXBlLmRyYXdBcnJvd0hlYWQoY3R4LCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyLCBhcnJvd0RhdGEudG8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZHJhd0xhYmVsJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3TGFiZWwoY3R4LCB2aWFOb2RlKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGFiZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIHNldCBzdHlsZVxuICAgICAgICAgIHZhciBub2RlMSA9IHRoaXMuZnJvbTtcbiAgICAgICAgICB2YXIgbm9kZTIgPSB0aGlzLnRvO1xuICAgICAgICAgIHZhciBzZWxlY3RlZCA9IHRoaXMuZnJvbS5zZWxlY3RlZCB8fCB0aGlzLnRvLnNlbGVjdGVkIHx8IHRoaXMuc2VsZWN0ZWQ7XG4gICAgICAgICAgaWYgKG5vZGUxLmlkICE9IG5vZGUyLmlkKSB7XG4gICAgICAgICAgICB0aGlzLmxhYmVsTW9kdWxlLnBvaW50VG9TZWxmID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgcG9pbnQgPSB0aGlzLmVkZ2VUeXBlLmdldFBvaW50KDAuNSwgdmlhTm9kZSk7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGUgbGFiZWwgaGFzIHRvIGJlIHJvdGF0ZWQ6XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmZvbnQuYWxpZ24gIT09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICAgICAgICAgIHRoaXMubGFiZWxNb2R1bGUuY2FsY3VsYXRlTGFiZWxTaXplKGN0eCwgc2VsZWN0ZWQsIHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHBvaW50LngsIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS55TGluZSk7XG4gICAgICAgICAgICAgIHRoaXMuX3JvdGF0ZUZvckxhYmVsQWxpZ25tZW50KGN0eCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRyYXcgdGhlIGxhYmVsXG4gICAgICAgICAgICB0aGlzLmxhYmVsTW9kdWxlLmRyYXcoY3R4LCBwb2ludC54LCBwb2ludC55LCBzZWxlY3RlZCk7XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZ25vcmUgdGhlIG9yaWVudGF0aW9ucy5cbiAgICAgICAgICAgIHRoaXMubGFiZWxNb2R1bGUucG9pbnRUb1NlbGYgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIHgsIHk7XG4gICAgICAgICAgICB2YXIgcmFkaXVzID0gdGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2VTaXplO1xuICAgICAgICAgICAgaWYgKG5vZGUxLnNoYXBlLndpZHRoID4gbm9kZTEuc2hhcGUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgIHggPSBub2RlMS54ICsgbm9kZTEuc2hhcGUud2lkdGggKiAwLjU7XG4gICAgICAgICAgICAgIHkgPSBub2RlMS55IC0gcmFkaXVzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgeCA9IG5vZGUxLnggKyByYWRpdXM7XG4gICAgICAgICAgICAgIHkgPSBub2RlMS55IC0gbm9kZTEuc2hhcGUuaGVpZ2h0ICogMC41O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9pbnQgPSB0aGlzLl9wb2ludE9uQ2lyY2xlKHgsIHksIHJhZGl1cywgMC4xMjUpO1xuICAgICAgICAgICAgdGhpcy5sYWJlbE1vZHVsZS5kcmF3KGN0eCwgcG9pbnQueCwgcG9pbnQueSwgc2VsZWN0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENoZWNrIGlmIHRoaXMgb2JqZWN0IGlzIG92ZXJsYXBwaW5nIHdpdGggdGhlIHByb3ZpZGVkIG9iamVjdFxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAgIGFuIG9iamVjdCB3aXRoIHBhcmFtZXRlcnMgbGVmdCwgdG9wXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSAgICAgVHJ1ZSBpZiBsb2NhdGlvbiBpcyBsb2NhdGVkIG9uIHRoZSBlZGdlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2lzT3ZlcmxhcHBpbmdXaXRoJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc092ZXJsYXBwaW5nV2l0aChvYmopIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgdmFyIGRpc3RNYXggPSAxMDtcbiAgICAgICAgICB2YXIgeEZyb20gPSB0aGlzLmZyb20ueDtcbiAgICAgICAgICB2YXIgeUZyb20gPSB0aGlzLmZyb20ueTtcbiAgICAgICAgICB2YXIgeFRvID0gdGhpcy50by54O1xuICAgICAgICAgIHZhciB5VG8gPSB0aGlzLnRvLnk7XG4gICAgICAgICAgdmFyIHhPYmogPSBvYmoubGVmdDtcbiAgICAgICAgICB2YXIgeU9iaiA9IG9iai50b3A7XG5cbiAgICAgICAgICB2YXIgZGlzdCA9IHRoaXMuZWRnZVR5cGUuZ2V0RGlzdGFuY2VUb0VkZ2UoeEZyb20sIHlGcm9tLCB4VG8sIHlUbywgeE9iaiwgeU9iaik7XG5cbiAgICAgICAgICByZXR1cm4gZGlzdCA8IGRpc3RNYXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUm90YXRlcyB0aGUgY2FudmFzIHNvIHRoZSB0ZXh0IGlzIG1vc3QgcmVhZGFibGVcbiAgICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19yb3RhdGVGb3JMYWJlbEFsaWdubWVudCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3JvdGF0ZUZvckxhYmVsQWxpZ25tZW50KGN0eCkge1xuICAgICAgICB2YXIgZHkgPSB0aGlzLmZyb20ueSAtIHRoaXMudG8ueTtcbiAgICAgICAgdmFyIGR4ID0gdGhpcy5mcm9tLnggLSB0aGlzLnRvLng7XG4gICAgICAgIHZhciBhbmdsZUluRGVncmVlcyA9IE1hdGguYXRhbjIoZHksIGR4KTtcblxuICAgICAgICAvLyByb3RhdGUgc28gbGFiZWwgaXQgaXMgcmVhZGFibGVcbiAgICAgICAgaWYgKGFuZ2xlSW5EZWdyZWVzIDwgLTEgJiYgZHggPCAwIHx8IGFuZ2xlSW5EZWdyZWVzID4gMCAmJiBkeCA8IDApIHtcbiAgICAgICAgICBhbmdsZUluRGVncmVlcyA9IGFuZ2xlSW5EZWdyZWVzICsgTWF0aC5QSTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5yb3RhdGUoYW5nbGVJbkRlZ3JlZXMpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEdldCBhIHBvaW50IG9uIGEgY2lyY2xlXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwZXJjZW50YWdlLiBWYWx1ZSBiZXR3ZWVuIDAgKGxpbmUgc3RhcnQpIGFuZCAxIChsaW5lIGVuZClcbiAgICAgICAqIEByZXR1cm4ge09iamVjdH0gcG9pbnRcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19wb2ludE9uQ2lyY2xlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcG9pbnRPbkNpcmNsZSh4LCB5LCByYWRpdXMsIHBlcmNlbnRhZ2UpIHtcbiAgICAgICAgdmFyIGFuZ2xlID0gcGVyY2VudGFnZSAqIDIgKiBNYXRoLlBJO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHggKyByYWRpdXMgKiBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgICAgeTogeSAtIHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NlbGVjdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0KCkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICd1bnNlbGVjdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdW5zZWxlY3QoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBjbGVhbnMgYWxsIHJlcXVpcmVkIHRoaW5ncyBvbiBkZWxldGVcbiAgICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdjbGVhbnVwJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lZGdlVHlwZS5jbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfV0sIFt7XG4gICAgICBrZXk6ICdwYXJzZU9wdGlvbnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlT3B0aW9ucyhwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zKSB7XG4gICAgICAgIHZhciBhbGxvd0RlbGV0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBhcmd1bWVudHNbMl07XG4gICAgICAgIHZhciBnbG9iYWxPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAzIHx8IGFyZ3VtZW50c1szXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbM107XG5cbiAgICAgICAgdmFyIGZpZWxkcyA9IFsnYXJyb3dTdHJpa2V0aHJvdWdoJywgJ2lkJywgJ2Zyb20nLCAnaGlkZGVuJywgJ2hvdmVyV2lkdGgnLCAnbGFiZWwnLCAnbGFiZWxIaWdobGlnaHRCb2xkJywgJ2xlbmd0aCcsICdsaW5lJywgJ29wYWNpdHknLCAncGh5c2ljcycsICdzY2FsaW5nJywgJ3NlbGVjdGlvbldpZHRoJywgJ3NlbGZSZWZlcmVuY2VTaXplJywgJ3RvJywgJ3RpdGxlJywgJ3ZhbHVlJywgJ3dpZHRoJ107XG5cbiAgICAgICAgLy8gb25seSBkZWVwIGV4dGVuZCB0aGUgaXRlbXMgaW4gdGhlIGZpZWxkIGFycmF5LiBUaGVzZSBkbyBub3QgaGF2ZSBzaG9ydGhhbmQuXG4gICAgICAgIHV0aWwuc2VsZWN0aXZlRGVlcEV4dGVuZChmaWVsZHMsIHBhcmVudE9wdGlvbnMsIG5ld09wdGlvbnMsIGFsbG93RGVsZXRpb24pO1xuXG4gICAgICAgIHV0aWwubWVyZ2VPcHRpb25zKHBhcmVudE9wdGlvbnMsIG5ld09wdGlvbnMsICdzbW9vdGgnLCBhbGxvd0RlbGV0aW9uLCBnbG9iYWxPcHRpb25zKTtcbiAgICAgICAgdXRpbC5tZXJnZU9wdGlvbnMocGFyZW50T3B0aW9ucywgbmV3T3B0aW9ucywgJ3NoYWRvdycsIGFsbG93RGVsZXRpb24sIGdsb2JhbE9wdGlvbnMpO1xuXG4gICAgICAgIGlmIChuZXdPcHRpb25zLmRhc2hlcyAhPT0gdW5kZWZpbmVkICYmIG5ld09wdGlvbnMuZGFzaGVzICE9PSBudWxsKSB7XG4gICAgICAgICAgcGFyZW50T3B0aW9ucy5kYXNoZXMgPSBuZXdPcHRpb25zLmRhc2hlcztcbiAgICAgICAgfSBlbHNlIGlmIChhbGxvd0RlbGV0aW9uID09PSB0cnVlICYmIG5ld09wdGlvbnMuZGFzaGVzID09PSBudWxsKSB7XG4gICAgICAgICAgcGFyZW50T3B0aW9ucy5kYXNoZXMgPSBPYmplY3QuY3JlYXRlKGdsb2JhbE9wdGlvbnMuZGFzaGVzKTsgLy8gdGhpcyBzZXRzIHRoZSBwb2ludGVyIG9mIHRoZSBvcHRpb24gYmFjayB0byB0aGUgZ2xvYmFsIG9wdGlvbi5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCB0aGUgc2NhbGluZyBuZXdPcHRpb25zXG4gICAgICAgIGlmIChuZXdPcHRpb25zLnNjYWxpbmcgIT09IHVuZGVmaW5lZCAmJiBuZXdPcHRpb25zLnNjYWxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAobmV3T3B0aW9ucy5zY2FsaW5nLm1pbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJlbnRPcHRpb25zLnNjYWxpbmcubWluID0gbmV3T3B0aW9ucy5zY2FsaW5nLm1pbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5ld09wdGlvbnMuc2NhbGluZy5tYXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyZW50T3B0aW9ucy5zY2FsaW5nLm1heCA9IG5ld09wdGlvbnMuc2NhbGluZy5tYXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHV0aWwubWVyZ2VPcHRpb25zKHBhcmVudE9wdGlvbnMuc2NhbGluZywgbmV3T3B0aW9ucy5zY2FsaW5nLCAnbGFiZWwnLCBhbGxvd0RlbGV0aW9uLCBnbG9iYWxPcHRpb25zLnNjYWxpbmcpO1xuICAgICAgICB9IGVsc2UgaWYgKGFsbG93RGVsZXRpb24gPT09IHRydWUgJiYgbmV3T3B0aW9ucy5zY2FsaW5nID09PSBudWxsKSB7XG4gICAgICAgICAgcGFyZW50T3B0aW9ucy5zY2FsaW5nID0gT2JqZWN0LmNyZWF0ZShnbG9iYWxPcHRpb25zLnNjYWxpbmcpOyAvLyB0aGlzIHNldHMgdGhlIHBvaW50ZXIgb2YgdGhlIG9wdGlvbiBiYWNrIHRvIHRoZSBnbG9iYWwgb3B0aW9uLlxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGFuZGxlIG11bHRpcGxlIGlucHV0IGNhc2VzIGZvciBhcnJvd3NcbiAgICAgICAgaWYgKG5ld09wdGlvbnMuYXJyb3dzICE9PSB1bmRlZmluZWQgJiYgbmV3T3B0aW9ucy5hcnJvd3MgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG5ld09wdGlvbnMuYXJyb3dzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIGFycm93cyA9IG5ld09wdGlvbnMuYXJyb3dzLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBwYXJlbnRPcHRpb25zLmFycm93cy50by5lbmFibGVkID0gYXJyb3dzLmluZGV4T2YoXCJ0b1wiKSAhPSAtMTtcbiAgICAgICAgICAgIHBhcmVudE9wdGlvbnMuYXJyb3dzLm1pZGRsZS5lbmFibGVkID0gYXJyb3dzLmluZGV4T2YoXCJtaWRkbGVcIikgIT0gLTE7XG4gICAgICAgICAgICBwYXJlbnRPcHRpb25zLmFycm93cy5mcm9tLmVuYWJsZWQgPSBhcnJvd3MuaW5kZXhPZihcImZyb21cIikgIT0gLTE7XG4gICAgICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKG5ld09wdGlvbnMuYXJyb3dzKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHV0aWwubWVyZ2VPcHRpb25zKHBhcmVudE9wdGlvbnMuYXJyb3dzLCBuZXdPcHRpb25zLmFycm93cywgJ3RvJywgYWxsb3dEZWxldGlvbiwgZ2xvYmFsT3B0aW9ucy5hcnJvd3MpO1xuICAgICAgICAgICAgdXRpbC5tZXJnZU9wdGlvbnMocGFyZW50T3B0aW9ucy5hcnJvd3MsIG5ld09wdGlvbnMuYXJyb3dzLCAnbWlkZGxlJywgYWxsb3dEZWxldGlvbiwgZ2xvYmFsT3B0aW9ucy5hcnJvd3MpO1xuICAgICAgICAgICAgdXRpbC5tZXJnZU9wdGlvbnMocGFyZW50T3B0aW9ucy5hcnJvd3MsIG5ld09wdGlvbnMuYXJyb3dzLCAnZnJvbScsIGFsbG93RGVsZXRpb24sIGdsb2JhbE9wdGlvbnMuYXJyb3dzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGFycm93IG5ld09wdGlvbnMgY2FuIG9ubHkgYmUgYW4gb2JqZWN0IG9yIGEgc3RyaW5nLiBSZWZlciB0byB0aGUgZG9jdW1lbnRhdGlvbi4gWW91IHVzZWQ6XCIgKyBKU09OLnN0cmluZ2lmeShuZXdPcHRpb25zLmFycm93cykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChhbGxvd0RlbGV0aW9uID09PSB0cnVlICYmIG5ld09wdGlvbnMuYXJyb3dzID09PSBudWxsKSB7XG4gICAgICAgICAgcGFyZW50T3B0aW9ucy5hcnJvd3MgPSBPYmplY3QuY3JlYXRlKGdsb2JhbE9wdGlvbnMuYXJyb3dzKTsgLy8gdGhpcyBzZXRzIHRoZSBwb2ludGVyIG9mIHRoZSBvcHRpb24gYmFjayB0byB0aGUgZ2xvYmFsIG9wdGlvbi5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhbmRsZSBtdWx0aXBsZSBpbnB1dCBjYXNlcyBmb3IgY29sb3JcbiAgICAgICAgaWYgKG5ld09wdGlvbnMuY29sb3IgIT09IHVuZGVmaW5lZCAmJiBuZXdPcHRpb25zLmNvbG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gbWFrZSBhIGNvcHkgb2YgdGhlIHBhcmVudCBvYmplY3QgaW4gY2FzZSB0aGlzIGlzIHJlZmVycmluZyB0byB0aGUgZ2xvYmFsIG9uZSAoZHVlIHRvIG9iamVjdCBjcmVhdGUgb25jZSwgdGhlbiB1cGRhdGUpXG4gICAgICAgICAgcGFyZW50T3B0aW9ucy5jb2xvciA9IHV0aWwuZGVlcEV4dGVuZCh7fSwgcGFyZW50T3B0aW9ucy5jb2xvciwgdHJ1ZSk7XG4gICAgICAgICAgaWYgKHV0aWwuaXNTdHJpbmcobmV3T3B0aW9ucy5jb2xvcikpIHtcbiAgICAgICAgICAgIHBhcmVudE9wdGlvbnMuY29sb3IuY29sb3IgPSBuZXdPcHRpb25zLmNvbG9yO1xuICAgICAgICAgICAgcGFyZW50T3B0aW9ucy5jb2xvci5oaWdobGlnaHQgPSBuZXdPcHRpb25zLmNvbG9yO1xuICAgICAgICAgICAgcGFyZW50T3B0aW9ucy5jb2xvci5ob3ZlciA9IG5ld09wdGlvbnMuY29sb3I7XG4gICAgICAgICAgICBwYXJlbnRPcHRpb25zLmNvbG9yLmluaGVyaXQgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNvbG9yc0RlZmluZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChuZXdPcHRpb25zLmNvbG9yLmNvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcGFyZW50T3B0aW9ucy5jb2xvci5jb2xvciA9IG5ld09wdGlvbnMuY29sb3IuY29sb3I7Y29sb3JzRGVmaW5lZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3T3B0aW9ucy5jb2xvci5oaWdobGlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBwYXJlbnRPcHRpb25zLmNvbG9yLmhpZ2hsaWdodCA9IG5ld09wdGlvbnMuY29sb3IuaGlnaGxpZ2h0O2NvbG9yc0RlZmluZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld09wdGlvbnMuY29sb3IuaG92ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBwYXJlbnRPcHRpb25zLmNvbG9yLmhvdmVyID0gbmV3T3B0aW9ucy5jb2xvci5ob3Zlcjtjb2xvcnNEZWZpbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdPcHRpb25zLmNvbG9yLmluaGVyaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBwYXJlbnRPcHRpb25zLmNvbG9yLmluaGVyaXQgPSBuZXdPcHRpb25zLmNvbG9yLmluaGVyaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3T3B0aW9ucy5jb2xvci5vcGFjaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcGFyZW50T3B0aW9ucy5jb2xvci5vcGFjaXR5ID0gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgbmV3T3B0aW9ucy5jb2xvci5vcGFjaXR5KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuZXdPcHRpb25zLmNvbG9yLmluaGVyaXQgPT09IHVuZGVmaW5lZCAmJiBjb2xvcnNEZWZpbmVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHBhcmVudE9wdGlvbnMuY29sb3IuaW5oZXJpdCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChhbGxvd0RlbGV0aW9uID09PSB0cnVlICYmIG5ld09wdGlvbnMuY29sb3IgPT09IG51bGwpIHtcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLmNvbG9yID0gdXRpbC5icmlkZ2VPYmplY3QoZ2xvYmFsT3B0aW9ucy5jb2xvcik7IC8vIHNldCB0aGUgb2JqZWN0IGJhY2sgdG8gdGhlIGdsb2JhbCBvcHRpb25zXG4gICAgICAgIH1cblxuICAgICAgICAvLyBoYW5kbGUgdGhlIGZvbnQgc2V0dGluZ3NcbiAgICAgICAgaWYgKG5ld09wdGlvbnMuZm9udCAhPT0gdW5kZWZpbmVkICYmIG5ld09wdGlvbnMuZm9udCAhPT0gbnVsbCkge1xuICAgICAgICAgIF9MYWJlbDIuZGVmYXVsdC5wYXJzZU9wdGlvbnMocGFyZW50T3B0aW9ucy5mb250LCBuZXdPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmIChhbGxvd0RlbGV0aW9uID09PSB0cnVlICYmIG5ld09wdGlvbnMuZm9udCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBhcmVudE9wdGlvbnMuZm9udCA9IHV0aWwuYnJpZGdlT2JqZWN0KGdsb2JhbE9wdGlvbnMuZm9udCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gRWRnZTtcbiAgfSgpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IEVkZ2U7XG5cbi8qKiovIH0sXG4vKiA4NiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIHZhciBfQ3ViaWNCZXppZXJFZGdlQmFzZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg3KTtcblxuICB2YXIgX0N1YmljQmV6aWVyRWRnZUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ3ViaWNCZXppZXJFZGdlQmFzZTIpO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuICBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuICB2YXIgQ3ViaWNCZXppZXJFZGdlID0gZnVuY3Rpb24gKF9DdWJpY0JlemllckVkZ2VCYXNlKSB7XG4gICAgX2luaGVyaXRzKEN1YmljQmV6aWVyRWRnZSwgX0N1YmljQmV6aWVyRWRnZUJhc2UpO1xuXG4gICAgZnVuY3Rpb24gQ3ViaWNCZXppZXJFZGdlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ3ViaWNCZXppZXJFZGdlKTtcblxuICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihDdWJpY0JlemllckVkZ2UpLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3IGEgbGluZSBiZXR3ZWVuIHR3byBub2Rlc1xuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoQ3ViaWNCZXppZXJFZGdlLCBbe1xuICAgICAga2V5OiAnX2xpbmUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9saW5lKGN0eCwgdmlhTm9kZXMpIHtcbiAgICAgICAgLy8gZ2V0IHRoZSBjb29yZGluYXRlcyBvZiB0aGUgc3VwcG9ydCBwb2ludHMuXG4gICAgICAgIHZhciB2aWExID0gdmlhTm9kZXNbMF07XG4gICAgICAgIHZhciB2aWEyID0gdmlhTm9kZXNbMV07XG5cbiAgICAgICAgLy8gc3RhcnQgZHJhd2luZyB0aGUgbGluZS5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKHRoaXMuZnJvbVBvaW50LngsIHRoaXMuZnJvbVBvaW50LnkpO1xuXG4gICAgICAgIC8vIGZhbGxiYWNrIHRvIG5vcm1hbCBzdHJhaWdodCBlZGdlc1xuICAgICAgICBpZiAodmlhTm9kZXMgPT09IHVuZGVmaW5lZCB8fCB2aWExLnggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGN0eC5saW5lVG8odGhpcy50b1BvaW50LngsIHRoaXMudG9Qb2ludC55KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyh2aWExLngsIHZpYTEueSwgdmlhMi54LCB2aWEyLnksIHRoaXMudG9Qb2ludC54LCB0aGlzLnRvUG9pbnQueSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZHJhdyBzaGFkb3cgaWYgZW5hYmxlZFxuICAgICAgICB0aGlzLmVuYWJsZVNoYWRvdyhjdHgpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIHRoaXMuZGlzYWJsZVNoYWRvdyhjdHgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19nZXRWaWFDb29yZGluYXRlcycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFZpYUNvb3JkaW5hdGVzKCkge1xuICAgICAgICB2YXIgZHggPSB0aGlzLmZyb20ueCAtIHRoaXMudG8ueDtcbiAgICAgICAgdmFyIGR5ID0gdGhpcy5mcm9tLnkgLSB0aGlzLnRvLnk7XG5cbiAgICAgICAgdmFyIHgxID0gdm9pZCAwLFxuICAgICAgICAgICAgeTEgPSB2b2lkIDAsXG4gICAgICAgICAgICB4MiA9IHZvaWQgMCxcbiAgICAgICAgICAgIHkyID0gdm9pZCAwO1xuICAgICAgICB2YXIgcm91bmRuZXNzID0gdGhpcy5vcHRpb25zLnNtb290aC5yb3VuZG5lc3M7XG5cbiAgICAgICAgLy8gaG9yaXpvbnRhbCBpZiB4ID4geSBvciBpZiBkaXJlY3Rpb24gaXMgZm9yY2VkIG9yIGlmIGRpcmVjdGlvbiBpcyBob3Jpem9udGFsXG4gICAgICAgIGlmICgoTWF0aC5hYnMoZHgpID4gTWF0aC5hYnMoZHkpIHx8IHRoaXMub3B0aW9ucy5zbW9vdGguZm9yY2VEaXJlY3Rpb24gPT09IHRydWUgfHwgdGhpcy5vcHRpb25zLnNtb290aC5mb3JjZURpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnKSAmJiB0aGlzLm9wdGlvbnMuc21vb3RoLmZvcmNlRGlyZWN0aW9uICE9PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgeTEgPSB0aGlzLmZyb20ueTtcbiAgICAgICAgICB5MiA9IHRoaXMudG8ueTtcbiAgICAgICAgICB4MSA9IHRoaXMuZnJvbS54IC0gcm91bmRuZXNzICogZHg7XG4gICAgICAgICAgeDIgPSB0aGlzLnRvLnggKyByb3VuZG5lc3MgKiBkeDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB5MSA9IHRoaXMuZnJvbS55IC0gcm91bmRuZXNzICogZHk7XG4gICAgICAgICAgeTIgPSB0aGlzLnRvLnkgKyByb3VuZG5lc3MgKiBkeTtcbiAgICAgICAgICB4MSA9IHRoaXMuZnJvbS54O1xuICAgICAgICAgIHgyID0gdGhpcy50by54O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFt7IHg6IHgxLCB5OiB5MSB9LCB7IHg6IHgyLCB5OiB5MiB9XTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXRWaWFOb2RlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWaWFOb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VmlhQ29vcmRpbmF0ZXMoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZmluZEJvcmRlclBvc2l0aW9uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZmluZEJvcmRlclBvc2l0aW9uKG5lYXJOb2RlLCBjdHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbkJlemllcihuZWFyTm9kZSwgY3R4KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZ2V0RGlzdGFuY2VUb0VkZ2UnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXREaXN0YW5jZVRvRWRnZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA8PSA2IHx8IGFyZ3VtZW50c1s2XSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fZ2V0VmlhQ29vcmRpbmF0ZXMoKSA6IGFyZ3VtZW50c1s2XTtcblxuICAgICAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKTtcblxuICAgICAgICB2YXIgdmlhMSA9IF9yZWYyWzBdO1xuICAgICAgICB2YXIgdmlhMiA9IF9yZWYyWzFdO1xuICAgICAgICAvLyB4Myx5MyBpcyB0aGUgcG9pbnRcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldERpc3RhbmNlVG9CZXppZXJFZGdlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHZpYTEsIHZpYTIpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENvbWJpbmVkIGZ1bmN0aW9uIG9mIHBvaW50T25MaW5lIGFuZCBwb2ludE9uQmV6aWVyLiBUaGlzIGdpdmVzIHRoZSBjb29yZGluYXRlcyBvZiBhIHBvaW50IG9uIHRoZSBsaW5lIGF0IGEgY2VydGFpbiBwZXJjZW50YWdlIG9mIHRoZSB3YXlcbiAgICAgICAqIEBwYXJhbSBwZXJjZW50YWdlXG4gICAgICAgKiBAcGFyYW0gdmlhXG4gICAgICAgKiBAcmV0dXJucyB7e3g6IG51bWJlciwgeTogbnVtYmVyfX1cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldFBvaW50JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb2ludChwZXJjZW50YWdlKSB7XG4gICAgICAgIHZhciBfcmVmMyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKCkgOiBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgdmFyIF9yZWY0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjMsIDIpO1xuXG4gICAgICAgIHZhciB2aWExID0gX3JlZjRbMF07XG4gICAgICAgIHZhciB2aWEyID0gX3JlZjRbMV07XG5cbiAgICAgICAgdmFyIHQgPSBwZXJjZW50YWdlO1xuICAgICAgICB2YXIgdmVjID0gW107XG4gICAgICAgIHZlY1swXSA9IE1hdGgucG93KDEgLSB0LCAzKTtcbiAgICAgICAgdmVjWzFdID0gMyAqIHQgKiBNYXRoLnBvdygxIC0gdCwgMik7XG4gICAgICAgIHZlY1syXSA9IDMgKiBNYXRoLnBvdyh0LCAyKSAqICgxIC0gdCk7XG4gICAgICAgIHZlY1szXSA9IE1hdGgucG93KHQsIDMpO1xuICAgICAgICB2YXIgeCA9IHZlY1swXSAqIHRoaXMuZnJvbVBvaW50LnggKyB2ZWNbMV0gKiB2aWExLnggKyB2ZWNbMl0gKiB2aWEyLnggKyB2ZWNbM10gKiB0aGlzLnRvUG9pbnQueDtcbiAgICAgICAgdmFyIHkgPSB2ZWNbMF0gKiB0aGlzLmZyb21Qb2ludC55ICsgdmVjWzFdICogdmlhMS55ICsgdmVjWzJdICogdmlhMi55ICsgdmVjWzNdICogdGhpcy50b1BvaW50Lnk7XG5cbiAgICAgICAgcmV0dXJuIHsgeDogeCwgeTogeSB9O1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBDdWJpY0JlemllckVkZ2U7XG4gIH0oX0N1YmljQmV6aWVyRWRnZUJhc2UzLmRlZmF1bHQpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IEN1YmljQmV6aWVyRWRnZTtcblxuLyoqKi8gfSxcbi8qIDg3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX0JlemllckVkZ2VCYXNlMiA9IF9fd2VicGFja19yZXF1aXJlX18oODgpO1xuXG4gIHZhciBfQmV6aWVyRWRnZUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmV6aWVyRWRnZUJhc2UyKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbiAgdmFyIEN1YmljQmV6aWVyRWRnZUJhc2UgPSBmdW5jdGlvbiAoX0JlemllckVkZ2VCYXNlKSB7XG4gICAgX2luaGVyaXRzKEN1YmljQmV6aWVyRWRnZUJhc2UsIF9CZXppZXJFZGdlQmFzZSk7XG5cbiAgICBmdW5jdGlvbiBDdWJpY0JlemllckVkZ2VCYXNlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ3ViaWNCZXppZXJFZGdlQmFzZSk7XG5cbiAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ3ViaWNCZXppZXJFZGdlQmFzZSkuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiBhIHBvaW50ICh4Myx5MykgYW5kIGEgbGluZSBzZWdtZW50IGZyb21cbiAgICAgKiAoeDEseTEpIHRvICh4Mix5MikuXG4gICAgICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84NDkyMTEvc2hvcnRlc3QtZGlzdGFuY2FlLWJldHdlZW4tYS1wb2ludC1hbmQtYS1saW5lLXNlZ21lbnRcbiAgICAgKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CJUMzJUE5emllcl9jdXJ2ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MSBmcm9tIHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTEgZnJvbSB5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgyIHRvIHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTIgdG8geVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MyBwb2ludCB0byBjaGVjayB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkzIHBvaW50IHRvIGNoZWNrIHlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoQ3ViaWNCZXppZXJFZGdlQmFzZSwgW3tcbiAgICAgIGtleTogJ19nZXREaXN0YW5jZVRvQmV6aWVyRWRnZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERpc3RhbmNlVG9CZXppZXJFZGdlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHZpYTEsIHZpYTIpIHtcbiAgICAgICAgLy8geDMseTMgaXMgdGhlIHBvaW50XG4gICAgICAgIHZhciBtaW5EaXN0YW5jZSA9IDFlOTtcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gdm9pZCAwO1xuICAgICAgICB2YXIgaSA9IHZvaWQgMCxcbiAgICAgICAgICAgIHQgPSB2b2lkIDAsXG4gICAgICAgICAgICB4ID0gdm9pZCAwLFxuICAgICAgICAgICAgeSA9IHZvaWQgMDtcbiAgICAgICAgdmFyIGxhc3RYID0geDE7XG4gICAgICAgIHZhciBsYXN0WSA9IHkxO1xuICAgICAgICB2YXIgdmVjID0gWzAsIDAsIDAsIDBdO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgMTA7IGkrKykge1xuICAgICAgICAgIHQgPSAwLjEgKiBpO1xuICAgICAgICAgIHZlY1swXSA9IE1hdGgucG93KDEgLSB0LCAzKTtcbiAgICAgICAgICB2ZWNbMV0gPSAzICogdCAqIE1hdGgucG93KDEgLSB0LCAyKTtcbiAgICAgICAgICB2ZWNbMl0gPSAzICogTWF0aC5wb3codCwgMikgKiAoMSAtIHQpO1xuICAgICAgICAgIHZlY1szXSA9IE1hdGgucG93KHQsIDMpO1xuICAgICAgICAgIHggPSB2ZWNbMF0gKiB4MSArIHZlY1sxXSAqIHZpYTEueCArIHZlY1syXSAqIHZpYTIueCArIHZlY1szXSAqIHgyO1xuICAgICAgICAgIHkgPSB2ZWNbMF0gKiB5MSArIHZlY1sxXSAqIHZpYTEueSArIHZlY1syXSAqIHZpYTIueSArIHZlY1szXSAqIHkyO1xuICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgZGlzdGFuY2UgPSB0aGlzLl9nZXREaXN0YW5jZVRvTGluZShsYXN0WCwgbGFzdFksIHgsIHksIHgzLCB5Myk7XG4gICAgICAgICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlIDwgbWluRGlzdGFuY2UgPyBkaXN0YW5jZSA6IG1pbkRpc3RhbmNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsYXN0WCA9IHg7XG4gICAgICAgICAgbGFzdFkgPSB5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1pbkRpc3RhbmNlO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBDdWJpY0JlemllckVkZ2VCYXNlO1xuICB9KF9CZXppZXJFZGdlQmFzZTMuZGVmYXVsdCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gQ3ViaWNCZXppZXJFZGdlQmFzZTtcblxuLyoqKi8gfSxcbi8qIDg4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX0VkZ2VCYXNlMiA9IF9fd2VicGFja19yZXF1aXJlX18oODkpO1xuXG4gIHZhciBfRWRnZUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRWRnZUJhc2UyKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbiAgdmFyIEJlemllckVkZ2VCYXNlID0gZnVuY3Rpb24gKF9FZGdlQmFzZSkge1xuICAgIF9pbmhlcml0cyhCZXppZXJFZGdlQmFzZSwgX0VkZ2VCYXNlKTtcblxuICAgIGZ1bmN0aW9uIEJlemllckVkZ2VCYXNlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmV6aWVyRWRnZUJhc2UpO1xuXG4gICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJlemllckVkZ2VCYXNlKS5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiB1c2VzIGJpbmFyeSBzZWFyY2ggdG8gbG9vayBmb3IgdGhlIHBvaW50IHdoZXJlIHRoZSBiZXppZXIgY3VydmUgY3Jvc3NlcyB0aGUgYm9yZGVyIG9mIHRoZSBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5lYXJOb2RlXG4gICAgICogQHBhcmFtIGN0eFxuICAgICAqIEBwYXJhbSB2aWFOb2RlXG4gICAgICogQHBhcmFtIG5lYXJOb2RlXG4gICAgICogQHBhcmFtIGN0eFxuICAgICAqIEBwYXJhbSB2aWFOb2RlXG4gICAgICogQHBhcmFtIG5lYXJOb2RlXG4gICAgICogQHBhcmFtIGN0eFxuICAgICAqIEBwYXJhbSB2aWFOb2RlXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhCZXppZXJFZGdlQmFzZSwgW3tcbiAgICAgIGtleTogJ19maW5kQm9yZGVyUG9zaXRpb25CZXppZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kQm9yZGVyUG9zaXRpb25CZXppZXIobmVhck5vZGUsIGN0eCkge1xuICAgICAgICB2YXIgdmlhTm9kZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IHRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKCkgOiBhcmd1bWVudHNbMl07XG5cbiAgICAgICAgdmFyIG1heEl0ZXJhdGlvbnMgPSAxMDtcbiAgICAgICAgdmFyIGl0ZXJhdGlvbiA9IDA7XG4gICAgICAgIHZhciBsb3cgPSAwO1xuICAgICAgICB2YXIgaGlnaCA9IDE7XG4gICAgICAgIHZhciBwb3MsIGFuZ2xlLCBkaXN0YW5jZVRvQm9yZGVyLCBkaXN0YW5jZVRvUG9pbnQsIGRpZmZlcmVuY2U7XG4gICAgICAgIHZhciB0aHJlc2hvbGQgPSAwLjI7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy50bztcbiAgICAgICAgdmFyIGZyb20gPSBmYWxzZTtcbiAgICAgICAgaWYgKG5lYXJOb2RlLmlkID09PSB0aGlzLmZyb20uaWQpIHtcbiAgICAgICAgICBub2RlID0gdGhpcy5mcm9tO1xuICAgICAgICAgIGZyb20gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGxvdyA8PSBoaWdoICYmIGl0ZXJhdGlvbiA8IG1heEl0ZXJhdGlvbnMpIHtcbiAgICAgICAgICB2YXIgbWlkZGxlID0gKGxvdyArIGhpZ2gpICogMC41O1xuXG4gICAgICAgICAgcG9zID0gdGhpcy5nZXRQb2ludChtaWRkbGUsIHZpYU5vZGUpO1xuICAgICAgICAgIGFuZ2xlID0gTWF0aC5hdGFuMihub2RlLnkgLSBwb3MueSwgbm9kZS54IC0gcG9zLngpO1xuICAgICAgICAgIGRpc3RhbmNlVG9Cb3JkZXIgPSBub2RlLmRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgICAgICAgZGlzdGFuY2VUb1BvaW50ID0gTWF0aC5zcXJ0KE1hdGgucG93KHBvcy54IC0gbm9kZS54LCAyKSArIE1hdGgucG93KHBvcy55IC0gbm9kZS55LCAyKSk7XG4gICAgICAgICAgZGlmZmVyZW5jZSA9IGRpc3RhbmNlVG9Cb3JkZXIgLSBkaXN0YW5jZVRvUG9pbnQ7XG4gICAgICAgICAgaWYgKE1hdGguYWJzKGRpZmZlcmVuY2UpIDwgdGhyZXNob2xkKSB7XG4gICAgICAgICAgICBicmVhazsgLy8gZm91bmRcbiAgICAgICAgICB9IGVsc2UgaWYgKGRpZmZlcmVuY2UgPCAwKSB7XG4gICAgICAgICAgICAgIC8vIGRpc3RhbmNlIHRvIG5vZGVzIGlzIGxhcmdlciB0aGFuIGRpc3RhbmNlIHRvIGJvcmRlciAtLT4gdCBuZWVkcyB0byBiZSBiaWdnZXIgaWYgd2UncmUgbG9va2luZyBhdCB0aGUgdG8gbm9kZS5cbiAgICAgICAgICAgICAgaWYgKGZyb20gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgbG93ID0gbWlkZGxlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWRkbGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChmcm9tID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWRkbGU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG93ID0gbWlkZGxlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBpdGVyYXRpb24rKztcbiAgICAgICAgfVxuICAgICAgICBwb3MudCA9IG1pZGRsZTtcblxuICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiBhIHBvaW50ICh4Myx5MykgYW5kIGEgbGluZSBzZWdtZW50IGZyb21cbiAgICAgICAqICh4MSx5MSkgdG8gKHgyLHkyKS5cbiAgICAgICAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODQ5MjExL3Nob3J0ZXN0LWRpc3RhbmNhZS1iZXR3ZWVuLWEtcG9pbnQtYW5kLWEtbGluZS1zZWdtZW50XG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0geDEgZnJvbSB4XG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0geTEgZnJvbSB5XG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0geDIgdG8geFxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHkyIHRvIHlcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MyBwb2ludCB0byBjaGVjayB4XG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0geTMgcG9pbnQgdG8gY2hlY2sgeVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2dldERpc3RhbmNlVG9CZXppZXJFZGdlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGlzdGFuY2VUb0JlemllckVkZ2UoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgdmlhKSB7XG4gICAgICAgIC8vIHgzLHkzIGlzIHRoZSBwb2ludFxuICAgICAgICB2YXIgbWluRGlzdGFuY2UgPSAxZTk7XG4gICAgICAgIHZhciBkaXN0YW5jZSA9IHZvaWQgMDtcbiAgICAgICAgdmFyIGkgPSB2b2lkIDAsXG4gICAgICAgICAgICB0ID0gdm9pZCAwLFxuICAgICAgICAgICAgeCA9IHZvaWQgMCxcbiAgICAgICAgICAgIHkgPSB2b2lkIDA7XG4gICAgICAgIHZhciBsYXN0WCA9IHgxO1xuICAgICAgICB2YXIgbGFzdFkgPSB5MTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgICB0ID0gMC4xICogaTtcbiAgICAgICAgICB4ID0gTWF0aC5wb3coMSAtIHQsIDIpICogeDEgKyAyICogdCAqICgxIC0gdCkgKiB2aWEueCArIE1hdGgucG93KHQsIDIpICogeDI7XG4gICAgICAgICAgeSA9IE1hdGgucG93KDEgLSB0LCAyKSAqIHkxICsgMiAqIHQgKiAoMSAtIHQpICogdmlhLnkgKyBNYXRoLnBvdyh0LCAyKSAqIHkyO1xuICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgZGlzdGFuY2UgPSB0aGlzLl9nZXREaXN0YW5jZVRvTGluZShsYXN0WCwgbGFzdFksIHgsIHksIHgzLCB5Myk7XG4gICAgICAgICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlIDwgbWluRGlzdGFuY2UgPyBkaXN0YW5jZSA6IG1pbkRpc3RhbmNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsYXN0WCA9IHg7XG4gICAgICAgICAgbGFzdFkgPSB5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1pbkRpc3RhbmNlO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBCZXppZXJFZGdlQmFzZTtcbiAgfShfRWRnZUJhc2UzLmRlZmF1bHQpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IEJlemllckVkZ2VCYXNlO1xuXG4vKioqLyB9LFxuLyogODkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX3NsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfSB9OyB9KCk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuICB2YXIgRWRnZUJhc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRWRnZUJhc2Uob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFZGdlQmFzZSk7XG5cbiAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICB0aGlzLmxhYmVsTW9kdWxlID0gbGFiZWxNb2R1bGU7XG4gICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIHRoaXMuY29sb3JEaXJ0eSA9IHRydWU7XG4gICAgICB0aGlzLmNvbG9yID0ge307XG4gICAgICB0aGlzLnNlbGVjdGlvbldpZHRoID0gMjtcbiAgICAgIHRoaXMuaG92ZXJXaWR0aCA9IDEuNTtcbiAgICAgIHRoaXMuZnJvbVBvaW50ID0gdGhpcy5mcm9tO1xuICAgICAgdGhpcy50b1BvaW50ID0gdGhpcy50bztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoRWRnZUJhc2UsIFt7XG4gICAgICBrZXk6ICdjb25uZWN0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb25uZWN0KCkge1xuICAgICAgICB0aGlzLmZyb20gPSB0aGlzLmJvZHkubm9kZXNbdGhpcy5vcHRpb25zLmZyb21dO1xuICAgICAgICB0aGlzLnRvID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMub3B0aW9ucy50b107XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnY2xlYW51cCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NldE9wdGlvbnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmZyb20gPSB0aGlzLmJvZHkubm9kZXNbdGhpcy5vcHRpb25zLmZyb21dO1xuICAgICAgICB0aGlzLnRvID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMub3B0aW9ucy50b107XG4gICAgICAgIHRoaXMuaWQgPSB0aGlzLm9wdGlvbnMuaWQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVkcmF3IGEgZWRnZSBhcyBhIGxpbmVcbiAgICAgICAqIERyYXcgdGhpcyBlZGdlIGluIHRoZSBnaXZlbiBjYW52YXNcbiAgICAgICAqIFRoZSAyZCBjb250ZXh0IG9mIGEgSFRNTCBjYW52YXMgY2FuIGJlIHJldHJpZXZlZCBieSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICAgY3R4XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkcmF3TGluZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0xpbmUoY3R4LCBzZWxlY3RlZCwgaG92ZXIsIHZpYU5vZGUpIHtcbiAgICAgICAgLy8gc2V0IHN0eWxlXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuZ2V0Q29sb3IoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5nZXRMaW5lV2lkdGgoc2VsZWN0ZWQsIGhvdmVyKTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRhc2hlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLl9kcmF3RGFzaGVkTGluZShjdHgsIHZpYU5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2RyYXdMaW5lKGN0eCwgdmlhTm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZHJhd0xpbmUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3TGluZShjdHgsIHZpYU5vZGUsIGZyb21Qb2ludCwgdG9Qb2ludCkge1xuICAgICAgICBpZiAodGhpcy5mcm9tICE9IHRoaXMudG8pIHtcbiAgICAgICAgICAvLyBkcmF3IGxpbmVcbiAgICAgICAgICB0aGlzLl9saW5lKGN0eCwgdmlhTm9kZSwgZnJvbVBvaW50LCB0b1BvaW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX2dldENpcmNsZURhdGEyID0gdGhpcy5fZ2V0Q2lyY2xlRGF0YShjdHgpO1xuXG4gICAgICAgICAgdmFyIF9nZXRDaXJjbGVEYXRhMyA9IF9zbGljZWRUb0FycmF5KF9nZXRDaXJjbGVEYXRhMiwgMyk7XG5cbiAgICAgICAgICB2YXIgeCA9IF9nZXRDaXJjbGVEYXRhM1swXTtcbiAgICAgICAgICB2YXIgeSA9IF9nZXRDaXJjbGVEYXRhM1sxXTtcbiAgICAgICAgICB2YXIgcmFkaXVzID0gX2dldENpcmNsZURhdGEzWzJdO1xuXG4gICAgICAgICAgdGhpcy5fY2lyY2xlKGN0eCwgeCwgeSwgcmFkaXVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19kcmF3RGFzaGVkTGluZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdEYXNoZWRMaW5lKGN0eCwgdmlhTm9kZSwgZnJvbVBvaW50LCB0b1BvaW50KSB7XG4gICAgICAgIGN0eC5saW5lQ2FwID0gJ3JvdW5kJztcbiAgICAgICAgdmFyIHBhdHRlcm4gPSBbNSwgNV07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMub3B0aW9ucy5kYXNoZXMpID09PSB0cnVlKSB7XG4gICAgICAgICAgcGF0dGVybiA9IHRoaXMub3B0aW9ucy5kYXNoZXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvbmx5IGZpcmVmb3ggYW5kIGNocm9tZSBzdXBwb3J0IHRoaXMgbWV0aG9kLCBlbHNlIHdlIHVzZSB0aGUgbGVnYWN5IG9uZS5cbiAgICAgICAgaWYgKGN0eC5zZXRMaW5lRGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY3R4LnNhdmUoKTtcblxuICAgICAgICAgIC8vIHNldCBkYXNoIHNldHRpbmdzIGZvciBjaHJvbWUgb3IgZmlyZWZveFxuICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChwYXR0ZXJuKTtcbiAgICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSAwO1xuXG4gICAgICAgICAgLy8gZHJhdyB0aGUgbGluZVxuICAgICAgICAgIGlmICh0aGlzLmZyb20gIT0gdGhpcy50bykge1xuICAgICAgICAgICAgLy8gZHJhdyBsaW5lXG4gICAgICAgICAgICB0aGlzLl9saW5lKGN0eCwgdmlhTm9kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBfZ2V0Q2lyY2xlRGF0YTQgPSB0aGlzLl9nZXRDaXJjbGVEYXRhKGN0eCk7XG5cbiAgICAgICAgICAgIHZhciBfZ2V0Q2lyY2xlRGF0YTUgPSBfc2xpY2VkVG9BcnJheShfZ2V0Q2lyY2xlRGF0YTQsIDMpO1xuXG4gICAgICAgICAgICB2YXIgeCA9IF9nZXRDaXJjbGVEYXRhNVswXTtcbiAgICAgICAgICAgIHZhciB5ID0gX2dldENpcmNsZURhdGE1WzFdO1xuICAgICAgICAgICAgdmFyIHJhZGl1cyA9IF9nZXRDaXJjbGVEYXRhNVsyXTtcblxuICAgICAgICAgICAgdGhpcy5fY2lyY2xlKGN0eCwgeCwgeSwgcmFkaXVzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyByZXN0b3JlIHRoZSBkYXNoIHNldHRpbmdzLlxuICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChbMF0pO1xuICAgICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IDA7XG4gICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB1bnN1cHBvcnRpbmcgc21vb3RoIGxpbmVzXG4gICAgICAgICAgaWYgKHRoaXMuZnJvbSAhPSB0aGlzLnRvKSB7XG4gICAgICAgICAgICAvLyBkcmF3IGxpbmVcbiAgICAgICAgICAgIGN0eC5kYXNoZWRMaW5lKHRoaXMuZnJvbS54LCB0aGlzLmZyb20ueSwgdGhpcy50by54LCB0aGlzLnRvLnksIHBhdHRlcm4pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgX2dldENpcmNsZURhdGE2ID0gdGhpcy5fZ2V0Q2lyY2xlRGF0YShjdHgpO1xuXG4gICAgICAgICAgICB2YXIgX2dldENpcmNsZURhdGE3ID0gX3NsaWNlZFRvQXJyYXkoX2dldENpcmNsZURhdGE2LCAzKTtcblxuICAgICAgICAgICAgdmFyIF94ID0gX2dldENpcmNsZURhdGE3WzBdO1xuICAgICAgICAgICAgdmFyIF95ID0gX2dldENpcmNsZURhdGE3WzFdO1xuICAgICAgICAgICAgdmFyIF9yYWRpdXMgPSBfZ2V0Q2lyY2xlRGF0YTdbMl07XG5cbiAgICAgICAgICAgIHRoaXMuX2NpcmNsZShjdHgsIF94LCBfeSwgX3JhZGl1cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGRyYXcgc2hhZG93IGlmIGVuYWJsZWRcbiAgICAgICAgICB0aGlzLmVuYWJsZVNoYWRvdyhjdHgpO1xuXG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgICAgLy8gZGlzYWJsZSBzaGFkb3dzIGZvciBvdGhlciBlbGVtZW50cy5cbiAgICAgICAgICB0aGlzLmRpc2FibGVTaGFkb3coY3R4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2ZpbmRCb3JkZXJQb3NpdGlvbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZmluZEJvcmRlclBvc2l0aW9uKG5lYXJOb2RlLCBjdHgsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuZnJvbSAhPSB0aGlzLnRvKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbihuZWFyTm9kZSwgY3R4LCBvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uQ2lyY2xlKG5lYXJOb2RlLCBjdHgsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZmluZEJvcmRlclBvc2l0aW9ucycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZmluZEJvcmRlclBvc2l0aW9ucyhjdHgpIHtcbiAgICAgICAgdmFyIGZyb20gPSB7fTtcbiAgICAgICAgdmFyIHRvID0ge307XG4gICAgICAgIGlmICh0aGlzLmZyb20gIT0gdGhpcy50bykge1xuICAgICAgICAgIGZyb20gPSB0aGlzLl9maW5kQm9yZGVyUG9zaXRpb24odGhpcy5mcm9tLCBjdHgpO1xuICAgICAgICAgIHRvID0gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uKHRoaXMudG8sIGN0eCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9nZXRDaXJjbGVEYXRhOCA9IHRoaXMuX2dldENpcmNsZURhdGEoY3R4KTtcblxuICAgICAgICAgIHZhciBfZ2V0Q2lyY2xlRGF0YTkgPSBfc2xpY2VkVG9BcnJheShfZ2V0Q2lyY2xlRGF0YTgsIDMpO1xuXG4gICAgICAgICAgdmFyIHggPSBfZ2V0Q2lyY2xlRGF0YTlbMF07XG4gICAgICAgICAgdmFyIHkgPSBfZ2V0Q2lyY2xlRGF0YTlbMV07XG4gICAgICAgICAgdmFyIHJhZGl1cyA9IF9nZXRDaXJjbGVEYXRhOVsyXTtcblxuXG4gICAgICAgICAgZnJvbSA9IHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbkNpcmNsZSh0aGlzLmZyb20sIGN0eCwgeyB4OiB4LCB5OiB5LCBsb3c6IDAuMjUsIGhpZ2g6IDAuNiwgZGlyZWN0aW9uOiAtMSB9KTtcbiAgICAgICAgICB0byA9IHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbkNpcmNsZSh0aGlzLmZyb20sIGN0eCwgeyB4OiB4LCB5OiB5LCBsb3c6IDAuNiwgaGlnaDogMC44LCBkaXJlY3Rpb246IDEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZnJvbTogZnJvbSwgdG86IHRvIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2dldENpcmNsZURhdGEnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDaXJjbGVEYXRhKGN0eCkge1xuICAgICAgICB2YXIgeCA9IHZvaWQgMCxcbiAgICAgICAgICAgIHkgPSB2b2lkIDA7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5mcm9tO1xuICAgICAgICB2YXIgcmFkaXVzID0gdGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2VTaXplO1xuXG4gICAgICAgIGlmIChjdHggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChub2RlLnNoYXBlLndpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5vZGUuc2hhcGUucmVzaXplKGN0eCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IGNpcmNsZSBjb29yZGluYXRlc1xuICAgICAgICBpZiAobm9kZS5zaGFwZS53aWR0aCA+IG5vZGUuc2hhcGUuaGVpZ2h0KSB7XG4gICAgICAgICAgeCA9IG5vZGUueCArIG5vZGUuc2hhcGUud2lkdGggKiAwLjU7XG4gICAgICAgICAgeSA9IG5vZGUueSAtIHJhZGl1cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4ID0gbm9kZS54ICsgcmFkaXVzO1xuICAgICAgICAgIHkgPSBub2RlLnkgLSBub2RlLnNoYXBlLmhlaWdodCAqIDAuNTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3gsIHksIHJhZGl1c107XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0IGEgcG9pbnQgb24gYSBjaXJjbGVcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHBlcmNlbnRhZ2UuIFZhbHVlIGJldHdlZW4gMCAobGluZSBzdGFydCkgYW5kIDEgKGxpbmUgZW5kKVxuICAgICAgICogQHJldHVybiB7T2JqZWN0fSBwb2ludFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3BvaW50T25DaXJjbGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9wb2ludE9uQ2lyY2xlKHgsIHksIHJhZGl1cywgcGVyY2VudGFnZSkge1xuICAgICAgICB2YXIgYW5nbGUgPSBwZXJjZW50YWdlICogMiAqIE1hdGguUEk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogeCArIHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgICB5OiB5IC0gcmFkaXVzICogTWF0aC5zaW4oYW5nbGUpXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBmdW5jdGlvbiB1c2VzIGJpbmFyeSBzZWFyY2ggdG8gbG9vayBmb3IgdGhlIHBvaW50IHdoZXJlIHRoZSBjaXJjbGUgY3Jvc3NlcyB0aGUgYm9yZGVyIG9mIHRoZSBub2RlLlxuICAgICAgICogQHBhcmFtIG5vZGVcbiAgICAgICAqIEBwYXJhbSBjdHhcbiAgICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19maW5kQm9yZGVyUG9zaXRpb25DaXJjbGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kQm9yZGVyUG9zaXRpb25DaXJjbGUobm9kZSwgY3R4LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB4ID0gb3B0aW9ucy54O1xuICAgICAgICB2YXIgeSA9IG9wdGlvbnMueTtcbiAgICAgICAgdmFyIGxvdyA9IG9wdGlvbnMubG93O1xuICAgICAgICB2YXIgaGlnaCA9IG9wdGlvbnMuaGlnaDtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IG9wdGlvbnMuZGlyZWN0aW9uO1xuXG4gICAgICAgIHZhciBtYXhJdGVyYXRpb25zID0gMTA7XG4gICAgICAgIHZhciBpdGVyYXRpb24gPSAwO1xuICAgICAgICB2YXIgcmFkaXVzID0gdGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2VTaXplO1xuICAgICAgICB2YXIgcG9zID0gdm9pZCAwLFxuICAgICAgICAgICAgYW5nbGUgPSB2b2lkIDAsXG4gICAgICAgICAgICBkaXN0YW5jZVRvQm9yZGVyID0gdm9pZCAwLFxuICAgICAgICAgICAgZGlzdGFuY2VUb1BvaW50ID0gdm9pZCAwLFxuICAgICAgICAgICAgZGlmZmVyZW5jZSA9IHZvaWQgMDtcbiAgICAgICAgdmFyIHRocmVzaG9sZCA9IDAuMDU7XG4gICAgICAgIHZhciBtaWRkbGUgPSAobG93ICsgaGlnaCkgKiAwLjU7XG5cbiAgICAgICAgd2hpbGUgKGxvdyA8PSBoaWdoICYmIGl0ZXJhdGlvbiA8IG1heEl0ZXJhdGlvbnMpIHtcbiAgICAgICAgICBtaWRkbGUgPSAobG93ICsgaGlnaCkgKiAwLjU7XG5cbiAgICAgICAgICBwb3MgPSB0aGlzLl9wb2ludE9uQ2lyY2xlKHgsIHksIHJhZGl1cywgbWlkZGxlKTtcbiAgICAgICAgICBhbmdsZSA9IE1hdGguYXRhbjIobm9kZS55IC0gcG9zLnksIG5vZGUueCAtIHBvcy54KTtcbiAgICAgICAgICBkaXN0YW5jZVRvQm9yZGVyID0gbm9kZS5kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgICAgICAgIGRpc3RhbmNlVG9Qb2ludCA9IE1hdGguc3FydChNYXRoLnBvdyhwb3MueCAtIG5vZGUueCwgMikgKyBNYXRoLnBvdyhwb3MueSAtIG5vZGUueSwgMikpO1xuICAgICAgICAgIGRpZmZlcmVuY2UgPSBkaXN0YW5jZVRvQm9yZGVyIC0gZGlzdGFuY2VUb1BvaW50O1xuICAgICAgICAgIGlmIChNYXRoLmFicyhkaWZmZXJlbmNlKSA8IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgYnJlYWs7IC8vIGZvdW5kXG4gICAgICAgICAgfSBlbHNlIGlmIChkaWZmZXJlbmNlID4gMCkge1xuICAgICAgICAgICAgICAvLyBkaXN0YW5jZSB0byBub2RlcyBpcyBsYXJnZXIgdGhhbiBkaXN0YW5jZSB0byBib3JkZXIgLS0+IHQgbmVlZHMgdG8gYmUgYmlnZ2VyIGlmIHdlJ3JlIGxvb2tpbmcgYXQgdGhlIHRvIG5vZGUuXG4gICAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPiAwKSB7XG4gICAgICAgICAgICAgICAgbG93ID0gbWlkZGxlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWRkbGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPiAwKSB7XG4gICAgICAgICAgICAgICAgaGlnaCA9IG1pZGRsZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb3cgPSBtaWRkbGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBpdGVyYXRpb24rKztcbiAgICAgICAgfVxuICAgICAgICBwb3MudCA9IG1pZGRsZTtcblxuICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEdldCB0aGUgbGluZSB3aWR0aCBvZiB0aGUgZWRnZS4gRGVwZW5kcyBvbiB3aWR0aCBhbmQgd2hldGhlciBvbmUgb2YgdGhlXG4gICAgICAgKiBjb25uZWN0ZWQgbm9kZXMgaXMgc2VsZWN0ZWQuXG4gICAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHdpZHRoXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXRMaW5lV2lkdGgnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldExpbmVXaWR0aChzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgICAgaWYgKHNlbGVjdGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuc2VsZWN0aW9uV2lkdGgsIDAuMyAvIHRoaXMuYm9keS52aWV3LnNjYWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaG92ZXIgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLmhvdmVyV2lkdGgsIDAuMyAvIHRoaXMuYm9keS52aWV3LnNjYWxlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMub3B0aW9ucy53aWR0aCwgMC4zIC8gdGhpcy5ib2R5LnZpZXcuc2NhbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldENvbG9yJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb2xvcihjdHgsIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgICB2YXIgY29sb3JPcHRpb25zID0gdGhpcy5vcHRpb25zLmNvbG9yO1xuICAgICAgICBpZiAoY29sb3JPcHRpb25zLmluaGVyaXQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgLy8gd2hlbiB0aGlzIGlzIGEgbG9vcCBlZGdlLCBqdXN0IHVzZSB0aGUgJ2Zyb20nIG1ldGhvZFxuICAgICAgICAgIGlmIChjb2xvck9wdGlvbnMuaW5oZXJpdCA9PT0gJ2JvdGgnICYmIHRoaXMuZnJvbS5pZCAhPT0gdGhpcy50by5pZCkge1xuICAgICAgICAgICAgdmFyIGdyZCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCh0aGlzLmZyb20ueCwgdGhpcy5mcm9tLnksIHRoaXMudG8ueCwgdGhpcy50by55KTtcbiAgICAgICAgICAgIHZhciBmcm9tQ29sb3IgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgdG9Db2xvciA9IHZvaWQgMDtcbiAgICAgICAgICAgIGZyb21Db2xvciA9IHRoaXMuZnJvbS5vcHRpb25zLmNvbG9yLmhpZ2hsaWdodC5ib3JkZXI7XG4gICAgICAgICAgICB0b0NvbG9yID0gdGhpcy50by5vcHRpb25zLmNvbG9yLmhpZ2hsaWdodC5ib3JkZXI7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmZyb20uc2VsZWN0ZWQgPT09IGZhbHNlICYmIHRoaXMudG8uc2VsZWN0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIGZyb21Db2xvciA9IHV0aWwub3ZlcnJpZGVPcGFjaXR5KHRoaXMuZnJvbS5vcHRpb25zLmNvbG9yLmJvcmRlciwgdGhpcy5vcHRpb25zLmNvbG9yLm9wYWNpdHkpO1xuICAgICAgICAgICAgICB0b0NvbG9yID0gdXRpbC5vdmVycmlkZU9wYWNpdHkodGhpcy50by5vcHRpb25zLmNvbG9yLmJvcmRlciwgdGhpcy5vcHRpb25zLmNvbG9yLm9wYWNpdHkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmZyb20uc2VsZWN0ZWQgPT09IHRydWUgJiYgdGhpcy50by5zZWxlY3RlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgdG9Db2xvciA9IHRoaXMudG8ub3B0aW9ucy5jb2xvci5ib3JkZXI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZnJvbS5zZWxlY3RlZCA9PT0gZmFsc2UgJiYgdGhpcy50by5zZWxlY3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICBmcm9tQ29sb3IgPSB0aGlzLmZyb20ub3B0aW9ucy5jb2xvci5ib3JkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBncmQuYWRkQ29sb3JTdG9wKDAsIGZyb21Db2xvcik7XG4gICAgICAgICAgICBncmQuYWRkQ29sb3JTdG9wKDEsIHRvQ29sb3IpO1xuXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLSB0aGlzIHJldHVybnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cbiAgICAgICAgICAgIHJldHVybiBncmQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMuY29sb3JEaXJ0eSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKGNvbG9yT3B0aW9ucy5pbmhlcml0ID09PSBcInRvXCIpIHtcbiAgICAgICAgICAgICAgdGhpcy5jb2xvci5oaWdobGlnaHQgPSB0aGlzLnRvLm9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0LmJvcmRlcjtcbiAgICAgICAgICAgICAgdGhpcy5jb2xvci5ob3ZlciA9IHRoaXMudG8ub3B0aW9ucy5jb2xvci5ob3Zlci5ib3JkZXI7XG4gICAgICAgICAgICAgIHRoaXMuY29sb3IuY29sb3IgPSB1dGlsLm92ZXJyaWRlT3BhY2l0eSh0aGlzLnRvLm9wdGlvbnMuY29sb3IuYm9yZGVyLCBjb2xvck9wdGlvbnMub3BhY2l0eSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyAodGhpcy5vcHRpb25zLmNvbG9yLmluaGVyaXQuc291cmNlID09PSBcImZyb21cIikge1xuICAgICAgICAgICAgICB0aGlzLmNvbG9yLmhpZ2hsaWdodCA9IHRoaXMuZnJvbS5vcHRpb25zLmNvbG9yLmhpZ2hsaWdodC5ib3JkZXI7XG4gICAgICAgICAgICAgIHRoaXMuY29sb3IuaG92ZXIgPSB0aGlzLmZyb20ub3B0aW9ucy5jb2xvci5ob3Zlci5ib3JkZXI7XG4gICAgICAgICAgICAgIHRoaXMuY29sb3IuY29sb3IgPSB1dGlsLm92ZXJyaWRlT3BhY2l0eSh0aGlzLmZyb20ub3B0aW9ucy5jb2xvci5ib3JkZXIsIGNvbG9yT3B0aW9ucy5vcGFjaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jb2xvckRpcnR5ID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5jb2xvci5oaWdobGlnaHQgPSBjb2xvck9wdGlvbnMuaGlnaGxpZ2h0O1xuICAgICAgICAgIHRoaXMuY29sb3IuaG92ZXIgPSBjb2xvck9wdGlvbnMuaG92ZXI7XG4gICAgICAgICAgdGhpcy5jb2xvci5jb2xvciA9IHV0aWwub3ZlcnJpZGVPcGFjaXR5KGNvbG9yT3B0aW9ucy5jb2xvciwgY29sb3JPcHRpb25zLm9wYWNpdHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgY29sb3IgaW5oZXJpdCBpcyBvbiBhbmQgZ3JhZGllbnRzIGFyZSB1c2VkLCB0aGUgZnVuY3Rpb24gaGFzIGFscmVhZHkgcmV0dXJuZWQgYnkgbm93LlxuICAgICAgICB0aGlzLmNvbG9yRGlydHkgPSBmYWxzZTtcblxuICAgICAgICBpZiAoc2VsZWN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb2xvci5oaWdobGlnaHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoaG92ZXIgPT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb2xvci5ob3ZlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb2xvci5jb2xvcjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIERyYXcgYSBsaW5lIGZyb20gYSBub2RlIHRvIGl0c2VsZiwgYSBjaXJjbGVcbiAgICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2NpcmNsZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NpcmNsZShjdHgsIHgsIHksIHJhZGl1cykge1xuICAgICAgICAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG4gICAgICAgIHRoaXMuZW5hYmxlU2hhZG93KGN0eCk7XG5cbiAgICAgICAgLy8gZHJhdyBhIGNpcmNsZVxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgLy8gZGlzYWJsZSBzaGFkb3dzIGZvciBvdGhlciBlbGVtZW50cy5cbiAgICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGEgcG9pbnQgKHgzLHkzKSBhbmQgYSBsaW5lIHNlZ21lbnQgZnJvbVxuICAgICAgICogKHgxLHkxKSB0byAoeDIseTIpLlxuICAgICAgICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84NDkyMTEvc2hvcnRlc3QtZGlzdGFuY2FlLWJldHdlZW4tYS1wb2ludC1hbmQtYS1saW5lLXNlZ21lbnRcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0geDJcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHgzXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0geTNcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldERpc3RhbmNlVG9FZGdlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREaXN0YW5jZVRvRWRnZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB2aWEpIHtcbiAgICAgICAgLy8geDMseTMgaXMgdGhlIHBvaW50XG4gICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IDA7XG4gICAgICAgIGlmICh0aGlzLmZyb20gIT0gdGhpcy50bykge1xuICAgICAgICAgIHJldHVyblZhbHVlID0gdGhpcy5fZ2V0RGlzdGFuY2VUb0VkZ2UoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgdmlhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX2dldENpcmNsZURhdGExMCA9IHRoaXMuX2dldENpcmNsZURhdGEoKTtcblxuICAgICAgICAgIHZhciBfZ2V0Q2lyY2xlRGF0YTExID0gX3NsaWNlZFRvQXJyYXkoX2dldENpcmNsZURhdGExMCwgMyk7XG5cbiAgICAgICAgICB2YXIgeCA9IF9nZXRDaXJjbGVEYXRhMTFbMF07XG4gICAgICAgICAgdmFyIHkgPSBfZ2V0Q2lyY2xlRGF0YTExWzFdO1xuICAgICAgICAgIHZhciByYWRpdXMgPSBfZ2V0Q2lyY2xlRGF0YTExWzJdO1xuXG4gICAgICAgICAgdmFyIGR4ID0geCAtIHgzO1xuICAgICAgICAgIHZhciBkeSA9IHkgLSB5MztcbiAgICAgICAgICByZXR1cm5WYWx1ZSA9IE1hdGguYWJzKE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSkgLSByYWRpdXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5sZWZ0IDwgeDMgJiYgdGhpcy5sYWJlbE1vZHVsZS5zaXplLmxlZnQgKyB0aGlzLmxhYmVsTW9kdWxlLnNpemUud2lkdGggPiB4MyAmJiB0aGlzLmxhYmVsTW9kdWxlLnNpemUudG9wIDwgeTMgJiYgdGhpcy5sYWJlbE1vZHVsZS5zaXplLnRvcCArIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5oZWlnaHQgPiB5Mykge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19nZXREaXN0YW5jZVRvTGluZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERpc3RhbmNlVG9MaW5lKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICAgICAgdmFyIHB4ID0geDIgLSB4MTtcbiAgICAgICAgdmFyIHB5ID0geTIgLSB5MTtcbiAgICAgICAgdmFyIHNvbWV0aGluZyA9IHB4ICogcHggKyBweSAqIHB5O1xuICAgICAgICB2YXIgdSA9ICgoeDMgLSB4MSkgKiBweCArICh5MyAtIHkxKSAqIHB5KSAvIHNvbWV0aGluZztcblxuICAgICAgICBpZiAodSA+IDEpIHtcbiAgICAgICAgICB1ID0gMTtcbiAgICAgICAgfSBlbHNlIGlmICh1IDwgMCkge1xuICAgICAgICAgIHUgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHggPSB4MSArIHUgKiBweDtcbiAgICAgICAgdmFyIHkgPSB5MSArIHUgKiBweTtcbiAgICAgICAgdmFyIGR4ID0geCAtIHgzO1xuICAgICAgICB2YXIgZHkgPSB5IC0geTM7XG5cbiAgICAgICAgLy8jIE5vdGU6IElmIHRoZSBhY3R1YWwgZGlzdGFuY2UgZG9lcyBub3QgbWF0dGVyLFxuICAgICAgICAvLyMgaWYgeW91IG9ubHkgd2FudCB0byBjb21wYXJlIHdoYXQgdGhpcyBmdW5jdGlvblxuICAgICAgICAvLyMgcmV0dXJucyB0byBvdGhlciByZXN1bHRzIG9mIHRoaXMgZnVuY3Rpb24sIHlvdVxuICAgICAgICAvLyMgY2FuIGp1c3QgcmV0dXJuIHRoZSBzcXVhcmVkIGRpc3RhbmNlIGluc3RlYWRcbiAgICAgICAgLy8jIChpLmUuIHJlbW92ZSB0aGUgc3FydCkgdG8gZ2FpbiBhIGxpdHRsZSBwZXJmb3JtYW5jZVxuXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gY3R4XG4gICAgICAgKiBAcGFyYW0gcG9zaXRpb25cbiAgICAgICAqIEBwYXJhbSB2aWFOb2RlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldEFycm93RGF0YScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QXJyb3dEYXRhKGN0eCwgcG9zaXRpb24sIHZpYU5vZGUsIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgICAvLyBzZXQgbGV0c1xuICAgICAgICB2YXIgYW5nbGUgPSB2b2lkIDA7XG4gICAgICAgIHZhciBhcnJvd1BvaW50ID0gdm9pZCAwO1xuICAgICAgICB2YXIgbm9kZTEgPSB2b2lkIDA7XG4gICAgICAgIHZhciBub2RlMiA9IHZvaWQgMDtcbiAgICAgICAgdmFyIGd1aWRlT2Zmc2V0ID0gdm9pZCAwO1xuICAgICAgICB2YXIgc2NhbGVGYWN0b3IgPSB2b2lkIDA7XG4gICAgICAgIHZhciBsaW5lV2lkdGggPSB0aGlzLmdldExpbmVXaWR0aChzZWxlY3RlZCwgaG92ZXIpO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2Zyb20nKSB7XG4gICAgICAgICAgbm9kZTEgPSB0aGlzLmZyb207XG4gICAgICAgICAgbm9kZTIgPSB0aGlzLnRvO1xuICAgICAgICAgIGd1aWRlT2Zmc2V0ID0gMC4xO1xuICAgICAgICAgIHNjYWxlRmFjdG9yID0gdGhpcy5vcHRpb25zLmFycm93cy5mcm9tLnNjYWxlRmFjdG9yO1xuICAgICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAndG8nKSB7XG4gICAgICAgICAgbm9kZTEgPSB0aGlzLnRvO1xuICAgICAgICAgIG5vZGUyID0gdGhpcy5mcm9tO1xuICAgICAgICAgIGd1aWRlT2Zmc2V0ID0gLTAuMTtcbiAgICAgICAgICBzY2FsZUZhY3RvciA9IHRoaXMub3B0aW9ucy5hcnJvd3MudG8uc2NhbGVGYWN0b3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZTEgPSB0aGlzLnRvO1xuICAgICAgICAgIG5vZGUyID0gdGhpcy5mcm9tO1xuICAgICAgICAgIHNjYWxlRmFjdG9yID0gdGhpcy5vcHRpb25zLmFycm93cy5taWRkbGUuc2NhbGVGYWN0b3I7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBub3QgY29ubmVjdGVkIHRvIGl0c2VsZlxuICAgICAgICBpZiAobm9kZTEgIT0gbm9kZTIpIHtcbiAgICAgICAgICBpZiAocG9zaXRpb24gIT09ICdtaWRkbGUnKSB7XG4gICAgICAgICAgICAvLyBkcmF3IGFycm93IGhlYWRcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc21vb3RoLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgYXJyb3dQb2ludCA9IHRoaXMuZmluZEJvcmRlclBvc2l0aW9uKG5vZGUxLCBjdHgsIHsgdmlhOiB2aWFOb2RlIH0pO1xuICAgICAgICAgICAgICB2YXIgZ3VpZGVQb3MgPSB0aGlzLmdldFBvaW50KE1hdGgubWF4KDAuMCwgTWF0aC5taW4oMS4wLCBhcnJvd1BvaW50LnQgKyBndWlkZU9mZnNldCkpLCB2aWFOb2RlKTtcbiAgICAgICAgICAgICAgYW5nbGUgPSBNYXRoLmF0YW4yKGFycm93UG9pbnQueSAtIGd1aWRlUG9zLnksIGFycm93UG9pbnQueCAtIGd1aWRlUG9zLngpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYW5nbGUgPSBNYXRoLmF0YW4yKG5vZGUxLnkgLSBub2RlMi55LCBub2RlMS54IC0gbm9kZTIueCk7XG4gICAgICAgICAgICAgIGFycm93UG9pbnQgPSB0aGlzLmZpbmRCb3JkZXJQb3NpdGlvbihub2RlMSwgY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5nbGUgPSBNYXRoLmF0YW4yKG5vZGUxLnkgLSBub2RlMi55LCBub2RlMS54IC0gbm9kZTIueCk7XG4gICAgICAgICAgICBhcnJvd1BvaW50ID0gdGhpcy5nZXRQb2ludCgwLjUsIHZpYU5vZGUpOyAvLyB0aGlzIGlzIDAuNiB0byBhY2NvdW50IGZvciB0aGUgc2l6ZSBvZiB0aGUgYXJyb3cuXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZHJhdyBjaXJjbGVcblxuICAgICAgICAgICAgdmFyIF9nZXRDaXJjbGVEYXRhMTIgPSB0aGlzLl9nZXRDaXJjbGVEYXRhKGN0eCk7XG5cbiAgICAgICAgICAgIHZhciBfZ2V0Q2lyY2xlRGF0YTEzID0gX3NsaWNlZFRvQXJyYXkoX2dldENpcmNsZURhdGExMiwgMyk7XG5cbiAgICAgICAgICAgIHZhciB4ID0gX2dldENpcmNsZURhdGExM1swXTtcbiAgICAgICAgICAgIHZhciB5ID0gX2dldENpcmNsZURhdGExM1sxXTtcbiAgICAgICAgICAgIHZhciByYWRpdXMgPSBfZ2V0Q2lyY2xlRGF0YTEzWzJdO1xuXG5cbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2Zyb20nKSB7XG4gICAgICAgICAgICAgIGFycm93UG9pbnQgPSB0aGlzLmZpbmRCb3JkZXJQb3NpdGlvbih0aGlzLmZyb20sIGN0eCwgeyB4OiB4LCB5OiB5LCBsb3c6IDAuMjUsIGhpZ2g6IDAuNiwgZGlyZWN0aW9uOiAtMSB9KTtcbiAgICAgICAgICAgICAgYW5nbGUgPSBhcnJvd1BvaW50LnQgKiAtMiAqIE1hdGguUEkgKyAxLjUgKiBNYXRoLlBJICsgMC4xICogTWF0aC5QSTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICd0bycpIHtcbiAgICAgICAgICAgICAgYXJyb3dQb2ludCA9IHRoaXMuZmluZEJvcmRlclBvc2l0aW9uKHRoaXMuZnJvbSwgY3R4LCB7IHg6IHgsIHk6IHksIGxvdzogMC42LCBoaWdoOiAxLjAsIGRpcmVjdGlvbjogMSB9KTtcbiAgICAgICAgICAgICAgYW5nbGUgPSBhcnJvd1BvaW50LnQgKiAtMiAqIE1hdGguUEkgKyAxLjUgKiBNYXRoLlBJIC0gMS4xICogTWF0aC5QSTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFycm93UG9pbnQgPSB0aGlzLl9wb2ludE9uQ2lyY2xlKHgsIHksIHJhZGl1cywgMC4xNzUpO1xuICAgICAgICAgICAgICBhbmdsZSA9IDMuOTI2OTkwODE2OTg3MjQxNDsgLy8gPT09IDAuMTc1ICogLTIgKiBNYXRoLlBJICsgMS41ICogTWF0aC5QSSArIDAuMSAqIE1hdGguUEk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZW5ndGggPSAxNSAqIHNjYWxlRmFjdG9yICsgMyAqIGxpbmVXaWR0aDsgLy8gMyogbGluZVdpZHRoIGlzIHRoZSB3aWR0aCBvZiB0aGUgZWRnZS5cblxuICAgICAgICB2YXIgeGkgPSBhcnJvd1BvaW50LnggLSBsZW5ndGggKiAwLjkgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgIHZhciB5aSA9IGFycm93UG9pbnQueSAtIGxlbmd0aCAqIDAuOSAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgdmFyIGFycm93Q29yZSA9IHsgeDogeGksIHk6IHlpIH07XG5cbiAgICAgICAgcmV0dXJuIHsgcG9pbnQ6IGFycm93UG9pbnQsIGNvcmU6IGFycm93Q29yZSwgYW5nbGU6IGFuZ2xlLCBsZW5ndGg6IGxlbmd0aCB9O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gY3R4XG4gICAgICAgKiBAcGFyYW0gc2VsZWN0ZWRcbiAgICAgICAqIEBwYXJhbSBob3ZlclxuICAgICAgICogQHBhcmFtIGFycm93RGF0YVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkcmF3QXJyb3dIZWFkJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3QXJyb3dIZWFkKGN0eCwgc2VsZWN0ZWQsIGhvdmVyLCBhcnJvd0RhdGEpIHtcbiAgICAgICAgLy8gc2V0IHN0eWxlXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuZ2V0Q29sb3IoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gY3R4LnN0cm9rZVN0eWxlO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5nZXRMaW5lV2lkdGgoc2VsZWN0ZWQsIGhvdmVyKTtcblxuICAgICAgICAvLyBkcmF3IGFycm93IGF0IHRoZSBlbmQgb2YgdGhlIGxpbmVcbiAgICAgICAgY3R4LmFycm93KGFycm93RGF0YS5wb2ludC54LCBhcnJvd0RhdGEucG9pbnQueSwgYXJyb3dEYXRhLmFuZ2xlLCBhcnJvd0RhdGEubGVuZ3RoKTtcblxuICAgICAgICAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG4gICAgICAgIHRoaXMuZW5hYmxlU2hhZG93KGN0eCk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIC8vIGRpc2FibGUgc2hhZG93cyBmb3Igb3RoZXIgZWxlbWVudHMuXG4gICAgICAgIHRoaXMuZGlzYWJsZVNoYWRvdyhjdHgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2VuYWJsZVNoYWRvdycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlU2hhZG93KGN0eCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNoYWRvdy5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gdGhpcy5vcHRpb25zLnNoYWRvdy5jb2xvcjtcbiAgICAgICAgICBjdHguc2hhZG93Qmx1ciA9IHRoaXMub3B0aW9ucy5zaGFkb3cuc2l6ZTtcbiAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WCA9IHRoaXMub3B0aW9ucy5zaGFkb3cueDtcbiAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IHRoaXMub3B0aW9ucy5zaGFkb3cueTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Rpc2FibGVTaGFkb3cnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGVTaGFkb3coY3R4KSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hhZG93LmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSAncmdiYSgwLDAsMCwwKSc7XG4gICAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSAwO1xuICAgICAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gMDtcbiAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gRWRnZUJhc2U7XG4gIH0oKTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBFZGdlQmFzZTtcblxuLyoqKi8gfSxcbi8qIDkwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICBcInVzZSBzdHJpY3RcIjtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIHZhciBfQmV6aWVyRWRnZUJhc2UyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4OCk7XG5cbiAgdmFyIF9CZXppZXJFZGdlQmFzZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CZXppZXJFZGdlQmFzZTIpO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuICBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuICB2YXIgQmV6aWVyRWRnZUR5bmFtaWMgPSBmdW5jdGlvbiAoX0JlemllckVkZ2VCYXNlKSB7XG4gICAgX2luaGVyaXRzKEJlemllckVkZ2VEeW5hbWljLCBfQmV6aWVyRWRnZUJhc2UpO1xuXG4gICAgZnVuY3Rpb24gQmV6aWVyRWRnZUR5bmFtaWMob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCZXppZXJFZGdlRHluYW1pYyk7XG5cbiAgICAgIC8vIC0tPiB0aGlzIGNhbGxzIHRoZSBzZXRPcHRpb25zIGJlbG93XG5cbiAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihCZXppZXJFZGdlRHluYW1pYykuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkpO1xuICAgICAgLy90aGlzLnZpYSA9IHVuZGVmaW5lZDsgLy8gSGVyZSBmb3IgY29tcGxldGVuZXNzIGJ1dCBub3QgYWxsb3dlZCB0byBkZWZpbmVkIGJlZm9yZSBzdXBlcigpIGlzIGludm9rZWQuXG5cblxuICAgICAgX3RoaXMuX2JvdW5kRnVuY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnBvc2l0aW9uQmV6aWVyTm9kZSgpO1xuICAgICAgfTtcbiAgICAgIF90aGlzLmJvZHkuZW1pdHRlci5vbihcIl9yZXBvc2l0aW9uQmV6aWVyTm9kZXNcIiwgX3RoaXMuX2JvdW5kRnVuY3Rpb24pO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhCZXppZXJFZGdlRHluYW1pYywgW3tcbiAgICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBwaHlzaWNzIGhhcyBjaGFuZ2VkLlxuICAgICAgICB2YXIgcGh5c2ljc0NoYW5nZSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBoeXNpY3MgIT09IG9wdGlvbnMucGh5c2ljcykge1xuICAgICAgICAgIHBoeXNpY3NDaGFuZ2UgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHRoZSBvcHRpb25zIGFuZCB0aGUgdG8gYW5kIGZyb20gbm9kZXNcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5pZCA9IHRoaXMub3B0aW9ucy5pZDtcbiAgICAgICAgdGhpcy5mcm9tID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMub3B0aW9ucy5mcm9tXTtcbiAgICAgICAgdGhpcy50byA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLm9wdGlvbnMudG9dO1xuXG4gICAgICAgIC8vIHNldHVwIHRoZSBzdXBwb3J0IG5vZGUgYW5kIGNvbm5lY3RcbiAgICAgICAgdGhpcy5zZXR1cFN1cHBvcnROb2RlKCk7XG4gICAgICAgIHRoaXMuY29ubmVjdCgpO1xuXG4gICAgICAgIC8vIHdoZW4gd2UgY2hhbmdlIHRoZSBwaHlzaWNzIHN0YXRlIG9mIHRoZSBlZGdlLCB3ZSByZXBvc2l0aW9uIHRoZSBzdXBwb3J0IG5vZGUuXG4gICAgICAgIGlmIChwaHlzaWNzQ2hhbmdlID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy52aWEuc2V0T3B0aW9ucyh7IHBoeXNpY3M6IHRoaXMub3B0aW9ucy5waHlzaWNzIH0pO1xuICAgICAgICAgIHRoaXMucG9zaXRpb25CZXppZXJOb2RlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY29ubmVjdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLm9wdGlvbnMuZnJvbV07XG4gICAgICAgIHRoaXMudG8gPSB0aGlzLmJvZHkubm9kZXNbdGhpcy5vcHRpb25zLnRvXTtcbiAgICAgICAgaWYgKHRoaXMuZnJvbSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMudG8gPT09IHVuZGVmaW5lZCB8fCB0aGlzLm9wdGlvbnMucGh5c2ljcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLnZpYS5zZXRPcHRpb25zKHsgcGh5c2ljczogZmFsc2UgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZml4IHdlaXJkIGJlaGF2aW91ciB3aGVyZSBhIHNlbGYgcmVmZXJlbmNpbmcgbm9kZSBoYXMgcGh5c2ljcyBlbmFibGVkXG4gICAgICAgICAgaWYgKHRoaXMuZnJvbS5pZCA9PT0gdGhpcy50by5pZCkge1xuICAgICAgICAgICAgdGhpcy52aWEuc2V0T3B0aW9ucyh7IHBoeXNpY3M6IGZhbHNlIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZpYS5zZXRPcHRpb25zKHsgcGh5c2ljczogdHJ1ZSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiByZW1vdmUgdGhlIHN1cHBvcnQgbm9kZXNcbiAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2xlYW51cFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9mZihcIl9yZXBvc2l0aW9uQmV6aWVyTm9kZXNcIiwgdGhpcy5fYm91bmRGdW5jdGlvbik7XG4gICAgICAgIGlmICh0aGlzLnZpYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuYm9keS5ub2Rlc1t0aGlzLnZpYS5pZF07XG4gICAgICAgICAgdGhpcy52aWEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEJlemllciBjdXJ2ZXMgcmVxdWlyZSBhbiBhbmNob3IgcG9pbnQgdG8gY2FsY3VsYXRlIHRoZSBzbW9vdGggZmxvdy4gVGhlc2UgcG9pbnRzIGFyZSBub2Rlcy4gVGhlc2Ugbm9kZXMgYXJlIGludmlzaWJsZSBidXRcbiAgICAgICAqIGFyZSB1c2VkIGZvciB0aGUgZm9yY2UgY2FsY3VsYXRpb24uXG4gICAgICAgKlxuICAgICAgICogVGhlIGNoYW5nZWQgZGF0YSBpcyBub3QgY2FsbGVkLCBpZiBuZWVkZWQsIGl0IGlzIHJldHVybmVkIGJ5IHRoZSBtYWluIGVkZ2UgY29uc3RydWN0b3IuXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0dXBTdXBwb3J0Tm9kZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldHVwU3VwcG9ydE5vZGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnZpYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIG5vZGVJZCA9IFwiZWRnZUlkOlwiICsgdGhpcy5pZDtcbiAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5mdW5jdGlvbnMuY3JlYXRlTm9kZSh7XG4gICAgICAgICAgICBpZDogbm9kZUlkLFxuICAgICAgICAgICAgc2hhcGU6ICdjaXJjbGUnLFxuICAgICAgICAgICAgcGh5c2ljczogdHJ1ZSxcbiAgICAgICAgICAgIGhpZGRlbjogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdID0gbm9kZTtcbiAgICAgICAgICB0aGlzLnZpYSA9IG5vZGU7XG4gICAgICAgICAgdGhpcy52aWEucGFyZW50RWRnZUlkID0gdGhpcy5pZDtcbiAgICAgICAgICB0aGlzLnBvc2l0aW9uQmV6aWVyTm9kZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInBvc2l0aW9uQmV6aWVyTm9kZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBvc2l0aW9uQmV6aWVyTm9kZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudmlhICE9PSB1bmRlZmluZWQgJiYgdGhpcy5mcm9tICE9PSB1bmRlZmluZWQgJiYgdGhpcy50byAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy52aWEueCA9IDAuNSAqICh0aGlzLmZyb20ueCArIHRoaXMudG8ueCk7XG4gICAgICAgICAgdGhpcy52aWEueSA9IDAuNSAqICh0aGlzLmZyb20ueSArIHRoaXMudG8ueSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy52aWEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMudmlhLnggPSAwO1xuICAgICAgICAgIHRoaXMudmlhLnkgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRHJhdyBhIGxpbmUgYmV0d2VlbiB0d28gbm9kZXNcbiAgICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfbGluZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9saW5lKGN0eCwgdmlhTm9kZSkge1xuICAgICAgICAvLyBkcmF3IGEgc3RyYWlnaHQgbGluZVxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8odGhpcy5mcm9tUG9pbnQueCwgdGhpcy5mcm9tUG9pbnQueSk7XG4gICAgICAgIC8vIGZhbGxiYWNrIHRvIG5vcm1hbCBzdHJhaWdodCBlZGdlc1xuICAgICAgICBpZiAodmlhTm9kZS54ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjdHgubGluZVRvKHRoaXMudG9Qb2ludC54LCB0aGlzLnRvUG9pbnQueSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8odmlhTm9kZS54LCB2aWFOb2RlLnksIHRoaXMudG9Qb2ludC54LCB0aGlzLnRvUG9pbnQueSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZHJhdyBzaGFkb3cgaWYgZW5hYmxlZFxuICAgICAgICB0aGlzLmVuYWJsZVNoYWRvdyhjdHgpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIHRoaXMuZGlzYWJsZVNoYWRvdyhjdHgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRWaWFOb2RlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmlhTm9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlhO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENvbWJpbmVkIGZ1bmN0aW9uIG9mIHBvaW50T25MaW5lIGFuZCBwb2ludE9uQmV6aWVyLiBUaGlzIGdpdmVzIHRoZSBjb29yZGluYXRlcyBvZiBhIHBvaW50IG9uIHRoZSBsaW5lIGF0IGEgY2VydGFpbiBwZXJjZW50YWdlIG9mIHRoZSB3YXlcbiAgICAgICAqIEBwYXJhbSBwZXJjZW50YWdlXG4gICAgICAgKiBAcGFyYW0gdmlhTm9kZVxuICAgICAgICogQHJldHVybnMge3t4OiBudW1iZXIsIHk6IG51bWJlcn19XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0UG9pbnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb2ludChwZXJjZW50YWdlKSB7XG4gICAgICAgIHZhciB2aWFOb2RlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gdGhpcy52aWEgOiBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgdmFyIHQgPSBwZXJjZW50YWdlO1xuICAgICAgICB2YXIgeCA9IE1hdGgucG93KDEgLSB0LCAyKSAqIHRoaXMuZnJvbVBvaW50LnggKyAyICogdCAqICgxIC0gdCkgKiB2aWFOb2RlLnggKyBNYXRoLnBvdyh0LCAyKSAqIHRoaXMudG9Qb2ludC54O1xuICAgICAgICB2YXIgeSA9IE1hdGgucG93KDEgLSB0LCAyKSAqIHRoaXMuZnJvbVBvaW50LnkgKyAyICogdCAqICgxIC0gdCkgKiB2aWFOb2RlLnkgKyBNYXRoLnBvdyh0LCAyKSAqIHRoaXMudG9Qb2ludC55O1xuXG4gICAgICAgIHJldHVybiB7IHg6IHgsIHk6IHkgfTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2ZpbmRCb3JkZXJQb3NpdGlvblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kQm9yZGVyUG9zaXRpb24obmVhck5vZGUsIGN0eCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uQmV6aWVyKG5lYXJOb2RlLCBjdHgsIHRoaXMudmlhKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2dldERpc3RhbmNlVG9FZGdlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERpc3RhbmNlVG9FZGdlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICAgICAgLy8geDMseTMgaXMgdGhlIHBvaW50XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXREaXN0YW5jZVRvQmV6aWVyRWRnZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB0aGlzLnZpYSk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEJlemllckVkZ2VEeW5hbWljO1xuICB9KF9CZXppZXJFZGdlQmFzZTMuZGVmYXVsdCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gQmV6aWVyRWRnZUR5bmFtaWM7XG5cbi8qKiovIH0sXG4vKiA5MSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgdmFyIF9CZXppZXJFZGdlQmFzZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg4KTtcblxuICB2YXIgX0JlemllckVkZ2VCYXNlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0JlemllckVkZ2VCYXNlMik7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG4gIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4gIHZhciBCZXppZXJFZGdlU3RhdGljID0gZnVuY3Rpb24gKF9CZXppZXJFZGdlQmFzZSkge1xuICAgIF9pbmhlcml0cyhCZXppZXJFZGdlU3RhdGljLCBfQmV6aWVyRWRnZUJhc2UpO1xuXG4gICAgZnVuY3Rpb24gQmV6aWVyRWRnZVN0YXRpYyhvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJlemllckVkZ2VTdGF0aWMpO1xuXG4gICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJlemllckVkZ2VTdGF0aWMpLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3IGEgbGluZSBiZXR3ZWVuIHR3byBub2Rlc1xuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoQmV6aWVyRWRnZVN0YXRpYywgW3tcbiAgICAgIGtleTogJ19saW5lJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbGluZShjdHgsIHZpYU5vZGUpIHtcbiAgICAgICAgLy8gZHJhdyBhIHN0cmFpZ2h0IGxpbmVcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKHRoaXMuZnJvbVBvaW50LngsIHRoaXMuZnJvbVBvaW50LnkpO1xuXG4gICAgICAgIC8vIGZhbGxiYWNrIHRvIG5vcm1hbCBzdHJhaWdodCBlZGdlc1xuICAgICAgICBpZiAodmlhTm9kZS54ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjdHgubGluZVRvKHRoaXMudG9Qb2ludC54LCB0aGlzLnRvUG9pbnQueSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8odmlhTm9kZS54LCB2aWFOb2RlLnksIHRoaXMudG9Qb2ludC54LCB0aGlzLnRvUG9pbnQueSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZHJhdyBzaGFkb3cgaWYgZW5hYmxlZFxuICAgICAgICB0aGlzLmVuYWJsZVNoYWRvdyhjdHgpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIHRoaXMuZGlzYWJsZVNoYWRvdyhjdHgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldFZpYU5vZGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZpYU5vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRWaWFDb29yZGluYXRlcygpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFdlIGRvIG5vdCB1c2UgdGhlIHRvIGFuZCBmcm9tUG9pbnRzIGhlcmUgdG8gbWFrZSB0aGUgdmlhIG5vZGVzIHRoZSBzYW1lIGFzIGVkZ2VzIHdpdGhvdXQgYXJyb3dzLlxuICAgICAgICogQHJldHVybnMge3t4OiB1bmRlZmluZWQsIHk6IHVuZGVmaW5lZH19XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZ2V0VmlhQ29vcmRpbmF0ZXMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRWaWFDb29yZGluYXRlcygpIHtcbiAgICAgICAgdmFyIHhWaWEgPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciB5VmlhID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgZmFjdG9yID0gdGhpcy5vcHRpb25zLnNtb290aC5yb3VuZG5lc3M7XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy5vcHRpb25zLnNtb290aC50eXBlO1xuICAgICAgICB2YXIgZHggPSBNYXRoLmFicyh0aGlzLmZyb20ueCAtIHRoaXMudG8ueCk7XG4gICAgICAgIHZhciBkeSA9IE1hdGguYWJzKHRoaXMuZnJvbS55IC0gdGhpcy50by55KTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdkaXNjcmV0ZScgfHwgdHlwZSA9PT0gJ2RpYWdvbmFsQ3Jvc3MnKSB7XG4gICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuZnJvbS54IC0gdGhpcy50by54KSA8PSBNYXRoLmFicyh0aGlzLmZyb20ueSAtIHRoaXMudG8ueSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZyb20ueSA+PSB0aGlzLnRvLnkpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuZnJvbS54IDw9IHRoaXMudG8ueCkge1xuICAgICAgICAgICAgICAgIHhWaWEgPSB0aGlzLmZyb20ueCArIGZhY3RvciAqIGR5O1xuICAgICAgICAgICAgICAgIHlWaWEgPSB0aGlzLmZyb20ueSAtIGZhY3RvciAqIGR5O1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZnJvbS54ID4gdGhpcy50by54KSB7XG4gICAgICAgICAgICAgICAgeFZpYSA9IHRoaXMuZnJvbS54IC0gZmFjdG9yICogZHk7XG4gICAgICAgICAgICAgICAgeVZpYSA9IHRoaXMuZnJvbS55IC0gZmFjdG9yICogZHk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5mcm9tLnkgPCB0aGlzLnRvLnkpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuZnJvbS54IDw9IHRoaXMudG8ueCkge1xuICAgICAgICAgICAgICAgIHhWaWEgPSB0aGlzLmZyb20ueCArIGZhY3RvciAqIGR5O1xuICAgICAgICAgICAgICAgIHlWaWEgPSB0aGlzLmZyb20ueSArIGZhY3RvciAqIGR5O1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZnJvbS54ID4gdGhpcy50by54KSB7XG4gICAgICAgICAgICAgICAgeFZpYSA9IHRoaXMuZnJvbS54IC0gZmFjdG9yICogZHk7XG4gICAgICAgICAgICAgICAgeVZpYSA9IHRoaXMuZnJvbS55ICsgZmFjdG9yICogZHk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcImRpc2NyZXRlXCIpIHtcbiAgICAgICAgICAgICAgeFZpYSA9IGR4IDwgZmFjdG9yICogZHkgPyB0aGlzLmZyb20ueCA6IHhWaWE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyh0aGlzLmZyb20ueCAtIHRoaXMudG8ueCkgPiBNYXRoLmFicyh0aGlzLmZyb20ueSAtIHRoaXMudG8ueSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZyb20ueSA+PSB0aGlzLnRvLnkpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuZnJvbS54IDw9IHRoaXMudG8ueCkge1xuICAgICAgICAgICAgICAgIHhWaWEgPSB0aGlzLmZyb20ueCArIGZhY3RvciAqIGR4O1xuICAgICAgICAgICAgICAgIHlWaWEgPSB0aGlzLmZyb20ueSAtIGZhY3RvciAqIGR4O1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZnJvbS54ID4gdGhpcy50by54KSB7XG4gICAgICAgICAgICAgICAgeFZpYSA9IHRoaXMuZnJvbS54IC0gZmFjdG9yICogZHg7XG4gICAgICAgICAgICAgICAgeVZpYSA9IHRoaXMuZnJvbS55IC0gZmFjdG9yICogZHg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5mcm9tLnkgPCB0aGlzLnRvLnkpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuZnJvbS54IDw9IHRoaXMudG8ueCkge1xuICAgICAgICAgICAgICAgIHhWaWEgPSB0aGlzLmZyb20ueCArIGZhY3RvciAqIGR4O1xuICAgICAgICAgICAgICAgIHlWaWEgPSB0aGlzLmZyb20ueSArIGZhY3RvciAqIGR4O1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZnJvbS54ID4gdGhpcy50by54KSB7XG4gICAgICAgICAgICAgICAgeFZpYSA9IHRoaXMuZnJvbS54IC0gZmFjdG9yICogZHg7XG4gICAgICAgICAgICAgICAgeVZpYSA9IHRoaXMuZnJvbS55ICsgZmFjdG9yICogZHg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcImRpc2NyZXRlXCIpIHtcbiAgICAgICAgICAgICAgeVZpYSA9IGR5IDwgZmFjdG9yICogZHggPyB0aGlzLmZyb20ueSA6IHlWaWE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwic3RyYWlnaHRDcm9zc1wiKSB7XG4gICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuZnJvbS54IC0gdGhpcy50by54KSA8PSBNYXRoLmFicyh0aGlzLmZyb20ueSAtIHRoaXMudG8ueSkpIHtcbiAgICAgICAgICAgIC8vIHVwIC0gZG93blxuICAgICAgICAgICAgeFZpYSA9IHRoaXMuZnJvbS54O1xuICAgICAgICAgICAgaWYgKHRoaXMuZnJvbS55IDwgdGhpcy50by55KSB7XG4gICAgICAgICAgICAgIHlWaWEgPSB0aGlzLnRvLnkgLSAoMSAtIGZhY3RvcikgKiBkeTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHlWaWEgPSB0aGlzLnRvLnkgKyAoMSAtIGZhY3RvcikgKiBkeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKHRoaXMuZnJvbS54IC0gdGhpcy50by54KSA+IE1hdGguYWJzKHRoaXMuZnJvbS55IC0gdGhpcy50by55KSkge1xuICAgICAgICAgICAgLy8gbGVmdCAtIHJpZ2h0XG4gICAgICAgICAgICBpZiAodGhpcy5mcm9tLnggPCB0aGlzLnRvLngpIHtcbiAgICAgICAgICAgICAgeFZpYSA9IHRoaXMudG8ueCAtICgxIC0gZmFjdG9yKSAqIGR4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgeFZpYSA9IHRoaXMudG8ueCArICgxIC0gZmFjdG9yKSAqIGR4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeVZpYSA9IHRoaXMuZnJvbS55O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICBpZiAodGhpcy5mcm9tLnggPCB0aGlzLnRvLngpIHtcbiAgICAgICAgICAgIHhWaWEgPSB0aGlzLnRvLnggLSAoMSAtIGZhY3RvcikgKiBkeDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeFZpYSA9IHRoaXMudG8ueCArICgxIC0gZmFjdG9yKSAqIGR4O1xuICAgICAgICAgIH1cbiAgICAgICAgICB5VmlhID0gdGhpcy5mcm9tLnk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgIHhWaWEgPSB0aGlzLmZyb20ueDtcbiAgICAgICAgICBpZiAodGhpcy5mcm9tLnkgPCB0aGlzLnRvLnkpIHtcbiAgICAgICAgICAgIHlWaWEgPSB0aGlzLnRvLnkgLSAoMSAtIGZhY3RvcikgKiBkeTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeVZpYSA9IHRoaXMudG8ueSArICgxIC0gZmFjdG9yKSAqIGR5O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnY3VydmVkQ1cnKSB7XG4gICAgICAgICAgZHggPSB0aGlzLnRvLnggLSB0aGlzLmZyb20ueDtcbiAgICAgICAgICBkeSA9IHRoaXMuZnJvbS55IC0gdGhpcy50by55O1xuICAgICAgICAgIHZhciByYWRpdXMgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICAgIHZhciBwaSA9IE1hdGguUEk7XG5cbiAgICAgICAgICB2YXIgb3JpZ2luYWxBbmdsZSA9IE1hdGguYXRhbjIoZHksIGR4KTtcbiAgICAgICAgICB2YXIgbXlBbmdsZSA9IChvcmlnaW5hbEFuZ2xlICsgKGZhY3RvciAqIDAuNSArIDAuNSkgKiBwaSkgJSAoMiAqIHBpKTtcblxuICAgICAgICAgIHhWaWEgPSB0aGlzLmZyb20ueCArIChmYWN0b3IgKiAwLjUgKyAwLjUpICogcmFkaXVzICogTWF0aC5zaW4obXlBbmdsZSk7XG4gICAgICAgICAgeVZpYSA9IHRoaXMuZnJvbS55ICsgKGZhY3RvciAqIDAuNSArIDAuNSkgKiByYWRpdXMgKiBNYXRoLmNvcyhteUFuZ2xlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnY3VydmVkQ0NXJykge1xuICAgICAgICAgIGR4ID0gdGhpcy50by54IC0gdGhpcy5mcm9tLng7XG4gICAgICAgICAgZHkgPSB0aGlzLmZyb20ueSAtIHRoaXMudG8ueTtcbiAgICAgICAgICB2YXIgX3JhZGl1cyA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgICAgdmFyIF9waSA9IE1hdGguUEk7XG5cbiAgICAgICAgICB2YXIgX29yaWdpbmFsQW5nbGUgPSBNYXRoLmF0YW4yKGR5LCBkeCk7XG4gICAgICAgICAgdmFyIF9teUFuZ2xlID0gKF9vcmlnaW5hbEFuZ2xlICsgKC1mYWN0b3IgKiAwLjUgKyAwLjUpICogX3BpKSAlICgyICogX3BpKTtcblxuICAgICAgICAgIHhWaWEgPSB0aGlzLmZyb20ueCArIChmYWN0b3IgKiAwLjUgKyAwLjUpICogX3JhZGl1cyAqIE1hdGguc2luKF9teUFuZ2xlKTtcbiAgICAgICAgICB5VmlhID0gdGhpcy5mcm9tLnkgKyAoZmFjdG9yICogMC41ICsgMC41KSAqIF9yYWRpdXMgKiBNYXRoLmNvcyhfbXlBbmdsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY29udGludW91c1xuICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLmZyb20ueCAtIHRoaXMudG8ueCkgPD0gTWF0aC5hYnModGhpcy5mcm9tLnkgLSB0aGlzLnRvLnkpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mcm9tLnkgPj0gdGhpcy50by55KSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmZyb20ueCA8PSB0aGlzLnRvLngpIHtcbiAgICAgICAgICAgICAgICB4VmlhID0gdGhpcy5mcm9tLnggKyBmYWN0b3IgKiBkeTtcbiAgICAgICAgICAgICAgICB5VmlhID0gdGhpcy5mcm9tLnkgLSBmYWN0b3IgKiBkeTtcbiAgICAgICAgICAgICAgICB4VmlhID0gdGhpcy50by54IDwgeFZpYSA/IHRoaXMudG8ueCA6IHhWaWE7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5mcm9tLnggPiB0aGlzLnRvLngpIHtcbiAgICAgICAgICAgICAgICB4VmlhID0gdGhpcy5mcm9tLnggLSBmYWN0b3IgKiBkeTtcbiAgICAgICAgICAgICAgICB5VmlhID0gdGhpcy5mcm9tLnkgLSBmYWN0b3IgKiBkeTtcbiAgICAgICAgICAgICAgICB4VmlhID0gdGhpcy50by54ID4geFZpYSA/IHRoaXMudG8ueCA6IHhWaWE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5mcm9tLnkgPCB0aGlzLnRvLnkpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuZnJvbS54IDw9IHRoaXMudG8ueCkge1xuICAgICAgICAgICAgICAgIHhWaWEgPSB0aGlzLmZyb20ueCArIGZhY3RvciAqIGR5O1xuICAgICAgICAgICAgICAgIHlWaWEgPSB0aGlzLmZyb20ueSArIGZhY3RvciAqIGR5O1xuICAgICAgICAgICAgICAgIHhWaWEgPSB0aGlzLnRvLnggPCB4VmlhID8gdGhpcy50by54IDogeFZpYTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmZyb20ueCA+IHRoaXMudG8ueCkge1xuICAgICAgICAgICAgICAgIHhWaWEgPSB0aGlzLmZyb20ueCAtIGZhY3RvciAqIGR5O1xuICAgICAgICAgICAgICAgIHlWaWEgPSB0aGlzLmZyb20ueSArIGZhY3RvciAqIGR5O1xuICAgICAgICAgICAgICAgIHhWaWEgPSB0aGlzLnRvLnggPiB4VmlhID8gdGhpcy50by54IDogeFZpYTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnModGhpcy5mcm9tLnggLSB0aGlzLnRvLngpID4gTWF0aC5hYnModGhpcy5mcm9tLnkgLSB0aGlzLnRvLnkpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mcm9tLnkgPj0gdGhpcy50by55KSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmZyb20ueCA8PSB0aGlzLnRvLngpIHtcbiAgICAgICAgICAgICAgICB4VmlhID0gdGhpcy5mcm9tLnggKyBmYWN0b3IgKiBkeDtcbiAgICAgICAgICAgICAgICB5VmlhID0gdGhpcy5mcm9tLnkgLSBmYWN0b3IgKiBkeDtcbiAgICAgICAgICAgICAgICB5VmlhID0gdGhpcy50by55ID4geVZpYSA/IHRoaXMudG8ueSA6IHlWaWE7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5mcm9tLnggPiB0aGlzLnRvLngpIHtcbiAgICAgICAgICAgICAgICB4VmlhID0gdGhpcy5mcm9tLnggLSBmYWN0b3IgKiBkeDtcbiAgICAgICAgICAgICAgICB5VmlhID0gdGhpcy5mcm9tLnkgLSBmYWN0b3IgKiBkeDtcbiAgICAgICAgICAgICAgICB5VmlhID0gdGhpcy50by55ID4geVZpYSA/IHRoaXMudG8ueSA6IHlWaWE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5mcm9tLnkgPCB0aGlzLnRvLnkpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuZnJvbS54IDw9IHRoaXMudG8ueCkge1xuICAgICAgICAgICAgICAgIHhWaWEgPSB0aGlzLmZyb20ueCArIGZhY3RvciAqIGR4O1xuICAgICAgICAgICAgICAgIHlWaWEgPSB0aGlzLmZyb20ueSArIGZhY3RvciAqIGR4O1xuICAgICAgICAgICAgICAgIHlWaWEgPSB0aGlzLnRvLnkgPCB5VmlhID8gdGhpcy50by55IDogeVZpYTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmZyb20ueCA+IHRoaXMudG8ueCkge1xuICAgICAgICAgICAgICAgIHhWaWEgPSB0aGlzLmZyb20ueCAtIGZhY3RvciAqIGR4O1xuICAgICAgICAgICAgICAgIHlWaWEgPSB0aGlzLmZyb20ueSArIGZhY3RvciAqIGR4O1xuICAgICAgICAgICAgICAgIHlWaWEgPSB0aGlzLnRvLnkgPCB5VmlhID8gdGhpcy50by55IDogeVZpYTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB4OiB4VmlhLCB5OiB5VmlhIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2ZpbmRCb3JkZXJQb3NpdGlvbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRCb3JkZXJQb3NpdGlvbihuZWFyTm9kZSwgY3R4KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMl07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbkJlemllcihuZWFyTm9kZSwgY3R4LCBvcHRpb25zLnZpYSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2dldERpc3RhbmNlVG9FZGdlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGlzdGFuY2VUb0VkZ2UoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgICAgICB2YXIgdmlhTm9kZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gNiB8fCBhcmd1bWVudHNbNl0gPT09IHVuZGVmaW5lZCA/IHRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKCkgOiBhcmd1bWVudHNbNl07XG4gICAgICAgIC8vIHgzLHkzIGlzIHRoZSBwb2ludFxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0RGlzdGFuY2VUb0JlemllckVkZ2UoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgdmlhTm9kZSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29tYmluZWQgZnVuY3Rpb24gb2YgcG9pbnRPbkxpbmUgYW5kIHBvaW50T25CZXppZXIuIFRoaXMgZ2l2ZXMgdGhlIGNvb3JkaW5hdGVzIG9mIGEgcG9pbnQgb24gdGhlIGxpbmUgYXQgYSBjZXJ0YWluIHBlcmNlbnRhZ2Ugb2YgdGhlIHdheVxuICAgICAgICogQHBhcmFtIHBlcmNlbnRhZ2VcbiAgICAgICAqIEBwYXJhbSB2aWFOb2RlXG4gICAgICAgKiBAcmV0dXJucyB7e3g6IG51bWJlciwgeTogbnVtYmVyfX1cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldFBvaW50JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb2ludChwZXJjZW50YWdlKSB7XG4gICAgICAgIHZhciB2aWFOb2RlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fZ2V0VmlhQ29vcmRpbmF0ZXMoKSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICB2YXIgdCA9IHBlcmNlbnRhZ2U7XG4gICAgICAgIHZhciB4ID0gTWF0aC5wb3coMSAtIHQsIDIpICogdGhpcy5mcm9tUG9pbnQueCArIDIgKiB0ICogKDEgLSB0KSAqIHZpYU5vZGUueCArIE1hdGgucG93KHQsIDIpICogdGhpcy50b1BvaW50Lng7XG4gICAgICAgIHZhciB5ID0gTWF0aC5wb3coMSAtIHQsIDIpICogdGhpcy5mcm9tUG9pbnQueSArIDIgKiB0ICogKDEgLSB0KSAqIHZpYU5vZGUueSArIE1hdGgucG93KHQsIDIpICogdGhpcy50b1BvaW50Lnk7XG5cbiAgICAgICAgcmV0dXJuIHsgeDogeCwgeTogeSB9O1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBCZXppZXJFZGdlU3RhdGljO1xuICB9KF9CZXppZXJFZGdlQmFzZTMuZGVmYXVsdCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gQmV6aWVyRWRnZVN0YXRpYztcblxuLyoqKi8gfSxcbi8qIDkyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX0VkZ2VCYXNlMiA9IF9fd2VicGFja19yZXF1aXJlX18oODkpO1xuXG4gIHZhciBfRWRnZUJhc2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRWRnZUJhc2UyKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbiAgdmFyIFN0cmFpZ2h0RWRnZSA9IGZ1bmN0aW9uIChfRWRnZUJhc2UpIHtcbiAgICBfaW5oZXJpdHMoU3RyYWlnaHRFZGdlLCBfRWRnZUJhc2UpO1xuXG4gICAgZnVuY3Rpb24gU3RyYWlnaHRFZGdlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RyYWlnaHRFZGdlKTtcblxuICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihTdHJhaWdodEVkZ2UpLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3IGEgbGluZSBiZXR3ZWVuIHR3byBub2Rlc1xuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoU3RyYWlnaHRFZGdlLCBbe1xuICAgICAga2V5OiAnX2xpbmUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9saW5lKGN0eCkge1xuICAgICAgICAvLyBkcmF3IGEgc3RyYWlnaHQgbGluZVxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8odGhpcy5mcm9tUG9pbnQueCwgdGhpcy5mcm9tUG9pbnQueSk7XG4gICAgICAgIGN0eC5saW5lVG8odGhpcy50b1BvaW50LngsIHRoaXMudG9Qb2ludC55KTtcbiAgICAgICAgLy8gZHJhdyBzaGFkb3cgaWYgZW5hYmxlZFxuICAgICAgICB0aGlzLmVuYWJsZVNoYWRvdyhjdHgpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIHRoaXMuZGlzYWJsZVNoYWRvdyhjdHgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldFZpYU5vZGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZpYU5vZGUoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29tYmluZWQgZnVuY3Rpb24gb2YgcG9pbnRPbkxpbmUgYW5kIHBvaW50T25CZXppZXIuIFRoaXMgZ2l2ZXMgdGhlIGNvb3JkaW5hdGVzIG9mIGEgcG9pbnQgb24gdGhlIGxpbmUgYXQgYSBjZXJ0YWluIHBlcmNlbnRhZ2Ugb2YgdGhlIHdheVxuICAgICAgICogQHBhcmFtIHBlcmNlbnRhZ2VcbiAgICAgICAqIEBwYXJhbSB2aWFcbiAgICAgICAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0UG9pbnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvaW50KHBlcmNlbnRhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiAoMSAtIHBlcmNlbnRhZ2UpICogdGhpcy5mcm9tUG9pbnQueCArIHBlcmNlbnRhZ2UgKiB0aGlzLnRvUG9pbnQueCxcbiAgICAgICAgICB5OiAoMSAtIHBlcmNlbnRhZ2UpICogdGhpcy5mcm9tUG9pbnQueSArIHBlcmNlbnRhZ2UgKiB0aGlzLnRvUG9pbnQueVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19maW5kQm9yZGVyUG9zaXRpb24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kQm9yZGVyUG9zaXRpb24obmVhck5vZGUsIGN0eCkge1xuICAgICAgICB2YXIgbm9kZTEgPSB0aGlzLnRvO1xuICAgICAgICB2YXIgbm9kZTIgPSB0aGlzLmZyb207XG4gICAgICAgIGlmIChuZWFyTm9kZS5pZCA9PT0gdGhpcy5mcm9tLmlkKSB7XG4gICAgICAgICAgbm9kZTEgPSB0aGlzLmZyb207XG4gICAgICAgICAgbm9kZTIgPSB0aGlzLnRvO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMihub2RlMS55IC0gbm9kZTIueSwgbm9kZTEueCAtIG5vZGUyLngpO1xuICAgICAgICB2YXIgZHggPSBub2RlMS54IC0gbm9kZTIueDtcbiAgICAgICAgdmFyIGR5ID0gbm9kZTEueSAtIG5vZGUyLnk7XG4gICAgICAgIHZhciBlZGdlU2VnbWVudExlbmd0aCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIHZhciB0b0JvcmRlckRpc3QgPSBuZWFyTm9kZS5kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgICAgICB2YXIgdG9Cb3JkZXJQb2ludCA9IChlZGdlU2VnbWVudExlbmd0aCAtIHRvQm9yZGVyRGlzdCkgLyBlZGdlU2VnbWVudExlbmd0aDtcblxuICAgICAgICB2YXIgYm9yZGVyUG9zID0ge307XG4gICAgICAgIGJvcmRlclBvcy54ID0gKDEgLSB0b0JvcmRlclBvaW50KSAqIG5vZGUyLnggKyB0b0JvcmRlclBvaW50ICogbm9kZTEueDtcbiAgICAgICAgYm9yZGVyUG9zLnkgPSAoMSAtIHRvQm9yZGVyUG9pbnQpICogbm9kZTIueSArIHRvQm9yZGVyUG9pbnQgKiBub2RlMS55O1xuXG4gICAgICAgIHJldHVybiBib3JkZXJQb3M7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2dldERpc3RhbmNlVG9FZGdlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGlzdGFuY2VUb0VkZ2UoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgICAgICAvLyB4Myx5MyBpcyB0aGUgcG9pbnRcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldERpc3RhbmNlVG9MaW5lKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBTdHJhaWdodEVkZ2U7XG4gIH0oX0VkZ2VCYXNlMy5kZWZhdWx0KTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBTdHJhaWdodEVkZ2U7XG5cbi8qKiovIH0sXG4vKiA5MyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgdmFyIF9CYXJuZXNIdXRTb2x2ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk0KTtcblxuICB2YXIgX0Jhcm5lc0h1dFNvbHZlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CYXJuZXNIdXRTb2x2ZXIpO1xuXG4gIHZhciBfUmVwdWxzaW9uU29sdmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NSk7XG5cbiAgdmFyIF9SZXB1bHNpb25Tb2x2ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUmVwdWxzaW9uU29sdmVyKTtcblxuICB2YXIgX0hpZXJhcmNoaWNhbFJlcHVsc2lvblNvbHZlciA9IF9fd2VicGFja19yZXF1aXJlX18oOTYpO1xuXG4gIHZhciBfSGllcmFyY2hpY2FsUmVwdWxzaW9uU29sdmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0hpZXJhcmNoaWNhbFJlcHVsc2lvblNvbHZlcik7XG5cbiAgdmFyIF9TcHJpbmdTb2x2ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk3KTtcblxuICB2YXIgX1NwcmluZ1NvbHZlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TcHJpbmdTb2x2ZXIpO1xuXG4gIHZhciBfSGllcmFyY2hpY2FsU3ByaW5nU29sdmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OCk7XG5cbiAgdmFyIF9IaWVyYXJjaGljYWxTcHJpbmdTb2x2ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfSGllcmFyY2hpY2FsU3ByaW5nU29sdmVyKTtcblxuICB2YXIgX0NlbnRyYWxHcmF2aXR5U29sdmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OSk7XG5cbiAgdmFyIF9DZW50cmFsR3Jhdml0eVNvbHZlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DZW50cmFsR3Jhdml0eVNvbHZlcik7XG5cbiAgdmFyIF9GQTJCYXNlZFJlcHVsc2lvblNvbHZlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTAwKTtcblxuICB2YXIgX0ZBMkJhc2VkUmVwdWxzaW9uU29sdmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0ZBMkJhc2VkUmVwdWxzaW9uU29sdmVyKTtcblxuICB2YXIgX0ZBMkJhc2VkQ2VudHJhbEdyYXZpdHlTb2x2ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMSk7XG5cbiAgdmFyIF9GQTJCYXNlZENlbnRyYWxHcmF2aXR5U29sdmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0ZBMkJhc2VkQ2VudHJhbEdyYXZpdHlTb2x2ZXIpO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbiAgdmFyIFBoeXNpY3NFbmdpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGh5c2ljc0VuZ2luZShib2R5KSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGh5c2ljc0VuZ2luZSk7XG5cbiAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICB0aGlzLnBoeXNpY3NCb2R5ID0geyBwaHlzaWNzTm9kZUluZGljZXM6IFtdLCBwaHlzaWNzRWRnZUluZGljZXM6IFtdLCBmb3JjZXM6IHt9LCB2ZWxvY2l0aWVzOiB7fSB9O1xuXG4gICAgICB0aGlzLnBoeXNpY3NFbmFibGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2ltdWxhdGlvbkludGVydmFsID0gMTAwMCAvIDYwO1xuICAgICAgdGhpcy5yZXF1aXJlc1RpbWVvdXQgPSB0cnVlO1xuICAgICAgdGhpcy5wcmV2aW91c1N0YXRlcyA9IHt9O1xuICAgICAgdGhpcy5yZWZlcmVuY2VTdGF0ZSA9IHt9O1xuICAgICAgdGhpcy5mcmVlemVDYWNoZSA9IHt9O1xuICAgICAgdGhpcy5yZW5kZXJUaW1lciA9IHVuZGVmaW5lZDtcblxuICAgICAgLy8gcGFyYW1ldGVycyBmb3IgdGhlIGFkYXB0aXZlIHRpbWVzdGVwXG4gICAgICB0aGlzLmFkYXB0aXZlVGltZXN0ZXAgPSBmYWxzZTtcbiAgICAgIHRoaXMuYWRhcHRpdmVUaW1lc3RlcEVuYWJsZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuYWRhcHRpdmVDb3VudGVyID0gMDtcbiAgICAgIHRoaXMuYWRhcHRpdmVJbnRlcnZhbCA9IDM7XG5cbiAgICAgIHRoaXMuc3RhYmlsaXplZCA9IGZhbHNlO1xuICAgICAgdGhpcy5zdGFydGVkU3RhYmlsaXphdGlvbiA9IGZhbHNlO1xuICAgICAgdGhpcy5zdGFiaWxpemF0aW9uSXRlcmF0aW9ucyA9IDA7XG4gICAgICB0aGlzLnJlYWR5ID0gZmFsc2U7IC8vIHdpbGwgYmUgc2V0IHRvIHRydWUgaWYgdGhlIHN0YWJpbGl6ZVxuXG4gICAgICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgYmFybmVzSHV0OiB7XG4gICAgICAgICAgdGhldGE6IDAuNSxcbiAgICAgICAgICBncmF2aXRhdGlvbmFsQ29uc3RhbnQ6IC0yMDAwLFxuICAgICAgICAgIGNlbnRyYWxHcmF2aXR5OiAwLjMsXG4gICAgICAgICAgc3ByaW5nTGVuZ3RoOiA5NSxcbiAgICAgICAgICBzcHJpbmdDb25zdGFudDogMC4wNCxcbiAgICAgICAgICBkYW1waW5nOiAwLjA5LFxuICAgICAgICAgIGF2b2lkT3ZlcmxhcDogMFxuICAgICAgICB9LFxuICAgICAgICBmb3JjZUF0bGFzMkJhc2VkOiB7XG4gICAgICAgICAgdGhldGE6IDAuNSxcbiAgICAgICAgICBncmF2aXRhdGlvbmFsQ29uc3RhbnQ6IC01MCxcbiAgICAgICAgICBjZW50cmFsR3Jhdml0eTogMC4wMSxcbiAgICAgICAgICBzcHJpbmdDb25zdGFudDogMC4wOCxcbiAgICAgICAgICBzcHJpbmdMZW5ndGg6IDEwMCxcbiAgICAgICAgICBkYW1waW5nOiAwLjQsXG4gICAgICAgICAgYXZvaWRPdmVybGFwOiAwXG4gICAgICAgIH0sXG4gICAgICAgIHJlcHVsc2lvbjoge1xuICAgICAgICAgIGNlbnRyYWxHcmF2aXR5OiAwLjIsXG4gICAgICAgICAgc3ByaW5nTGVuZ3RoOiAyMDAsXG4gICAgICAgICAgc3ByaW5nQ29uc3RhbnQ6IDAuMDUsXG4gICAgICAgICAgbm9kZURpc3RhbmNlOiAxMDAsXG4gICAgICAgICAgZGFtcGluZzogMC4wOSxcbiAgICAgICAgICBhdm9pZE92ZXJsYXA6IDBcbiAgICAgICAgfSxcbiAgICAgICAgaGllcmFyY2hpY2FsUmVwdWxzaW9uOiB7XG4gICAgICAgICAgY2VudHJhbEdyYXZpdHk6IDAuMCxcbiAgICAgICAgICBzcHJpbmdMZW5ndGg6IDEwMCxcbiAgICAgICAgICBzcHJpbmdDb25zdGFudDogMC4wMSxcbiAgICAgICAgICBub2RlRGlzdGFuY2U6IDEyMCxcbiAgICAgICAgICBkYW1waW5nOiAwLjA5XG4gICAgICAgIH0sXG4gICAgICAgIG1heFZlbG9jaXR5OiA1MCxcbiAgICAgICAgbWluVmVsb2NpdHk6IDAuNzUsIC8vIHB4L3NcbiAgICAgICAgc29sdmVyOiAnYmFybmVzSHV0JyxcbiAgICAgICAgc3RhYmlsaXphdGlvbjoge1xuICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgaXRlcmF0aW9uczogMTAwMCwgLy8gbWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9uIHRvIHN0YWJpbGl6ZVxuICAgICAgICAgIHVwZGF0ZUludGVydmFsOiA1MCxcbiAgICAgICAgICBvbmx5RHluYW1pY0VkZ2VzOiBmYWxzZSxcbiAgICAgICAgICBmaXQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgdGltZXN0ZXA6IDAuNSxcbiAgICAgICAgYWRhcHRpdmVUaW1lc3RlcDogdHJ1ZVxuICAgICAgfTtcbiAgICAgIHV0aWwuZXh0ZW5kKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG4gICAgICB0aGlzLnRpbWVzdGVwID0gMC41O1xuICAgICAgdGhpcy5sYXlvdXRGYWlsZWQgPSBmYWxzZTtcblxuICAgICAgdGhpcy5iaW5kRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoUGh5c2ljc0VuZ2luZSwgW3tcbiAgICAgIGtleTogJ2JpbmRFdmVudExpc3RlbmVycycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdpbml0UGh5c2ljcycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy5pbml0UGh5c2ljcygpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ19sYXlvdXRGYWlsZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMubGF5b3V0RmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdyZXNldFBoeXNpY3MnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMuc3RvcFNpbXVsYXRpb24oKTtfdGhpcy5yZWFkeSA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ2Rpc2FibGVQaHlzaWNzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLnBoeXNpY3NFbmFibGVkID0gZmFsc2U7X3RoaXMuc3RvcFNpbXVsYXRpb24oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdyZXN0b3JlUGh5c2ljcycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy5zZXRPcHRpb25zKF90aGlzLm9wdGlvbnMpO1xuICAgICAgICAgIGlmIChfdGhpcy5yZWFkeSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgX3RoaXMuc3RhcnRTaW11bGF0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ3N0YXJ0U2ltdWxhdGlvbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoX3RoaXMucmVhZHkgPT09IHRydWUpIHtcbiAgICAgICAgICAgIF90aGlzLnN0YXJ0U2ltdWxhdGlvbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdzdG9wU2ltdWxhdGlvbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy5zdG9wU2ltdWxhdGlvbigpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMuc3RvcFNpbXVsYXRpb24oZmFsc2UpO1xuICAgICAgICAgIF90aGlzLmJvZHkuZW1pdHRlci5vZmYoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHRoaXMgZXZlbnQgd2lsbCB0cmlnZ2VyIGEgcmVidWlsZGluZyBvZiB0aGUgY2FjaGUgZXZlcnl0aGluZy4gVXNlZCB3aGVuIG5vZGVzIG9yIGVkZ2VzIGhhdmUgYmVlbiBhZGRlZCBvciByZW1vdmVkLlxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9kYXRhQ2hhbmdlZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gdXBkYXRlIHNob3J0Y3V0IGxpc3RzXG4gICAgICAgICAgX3RoaXMudXBkYXRlUGh5c2ljc0RhdGEoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZGVidWc6IHNob3cgZm9yY2VzXG4gICAgICAgIC8vIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiYWZ0ZXJEcmF3aW5nXCIsIChjdHgpID0+IHt0aGlzLl9kcmF3Rm9yY2VzKGN0eCk7fSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogc2V0IHRoZSBwaHlzaWNzIG9wdGlvbnNcbiAgICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NldE9wdGlvbnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5waHlzaWNzRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5zdG9wU2ltdWxhdGlvbigpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBoeXNpY3NFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHV0aWwuc2VsZWN0aXZlTm90RGVlcEV4dGVuZChbJ3N0YWJpbGl6YXRpb24nXSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHV0aWwubWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgb3B0aW9ucywgJ3N0YWJpbGl6YXRpb24nKTtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZW5hYmxlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lbmFibGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICB0aGlzLnBoeXNpY3NFbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIHRoaXMuc3RvcFNpbXVsYXRpb24oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2V0IHRoZSB0aW1lc3RlcFxuICAgICAgICAgICAgdGhpcy50aW1lc3RlcCA9IHRoaXMub3B0aW9ucy50aW1lc3RlcDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogY29uZmlndXJlIHRoZSBlbmdpbmUuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2luaXQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgIHZhciBvcHRpb25zO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNvbHZlciA9PT0gJ2ZvcmNlQXRsYXMyQmFzZWQnKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5mb3JjZUF0bGFzMkJhc2VkO1xuICAgICAgICAgIHRoaXMubm9kZXNTb2x2ZXIgPSBuZXcgX0ZBMkJhc2VkUmVwdWxzaW9uU29sdmVyMi5kZWZhdWx0KHRoaXMuYm9keSwgdGhpcy5waHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgICAgICAgdGhpcy5lZGdlc1NvbHZlciA9IG5ldyBfU3ByaW5nU29sdmVyMi5kZWZhdWx0KHRoaXMuYm9keSwgdGhpcy5waHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgICAgICAgdGhpcy5ncmF2aXR5U29sdmVyID0gbmV3IF9GQTJCYXNlZENlbnRyYWxHcmF2aXR5U29sdmVyMi5kZWZhdWx0KHRoaXMuYm9keSwgdGhpcy5waHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnNvbHZlciA9PT0gJ3JlcHVsc2lvbicpIHtcbiAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLnJlcHVsc2lvbjtcbiAgICAgICAgICB0aGlzLm5vZGVzU29sdmVyID0gbmV3IF9SZXB1bHNpb25Tb2x2ZXIyLmRlZmF1bHQodGhpcy5ib2R5LCB0aGlzLnBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgICB0aGlzLmVkZ2VzU29sdmVyID0gbmV3IF9TcHJpbmdTb2x2ZXIyLmRlZmF1bHQodGhpcy5ib2R5LCB0aGlzLnBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgICB0aGlzLmdyYXZpdHlTb2x2ZXIgPSBuZXcgX0NlbnRyYWxHcmF2aXR5U29sdmVyMi5kZWZhdWx0KHRoaXMuYm9keSwgdGhpcy5waHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnNvbHZlciA9PT0gJ2hpZXJhcmNoaWNhbFJlcHVsc2lvbicpIHtcbiAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbFJlcHVsc2lvbjtcbiAgICAgICAgICB0aGlzLm5vZGVzU29sdmVyID0gbmV3IF9IaWVyYXJjaGljYWxSZXB1bHNpb25Tb2x2ZXIyLmRlZmF1bHQodGhpcy5ib2R5LCB0aGlzLnBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgICB0aGlzLmVkZ2VzU29sdmVyID0gbmV3IF9IaWVyYXJjaGljYWxTcHJpbmdTb2x2ZXIyLmRlZmF1bHQodGhpcy5ib2R5LCB0aGlzLnBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgICB0aGlzLmdyYXZpdHlTb2x2ZXIgPSBuZXcgX0NlbnRyYWxHcmF2aXR5U29sdmVyMi5kZWZhdWx0KHRoaXMuYm9keSwgdGhpcy5waHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gYmFybmVzSHV0XG4gICAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5iYXJuZXNIdXQ7XG4gICAgICAgICAgdGhpcy5ub2Rlc1NvbHZlciA9IG5ldyBfQmFybmVzSHV0U29sdmVyMi5kZWZhdWx0KHRoaXMuYm9keSwgdGhpcy5waHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgICAgICAgdGhpcy5lZGdlc1NvbHZlciA9IG5ldyBfU3ByaW5nU29sdmVyMi5kZWZhdWx0KHRoaXMuYm9keSwgdGhpcy5waHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgICAgICAgdGhpcy5ncmF2aXR5U29sdmVyID0gbmV3IF9DZW50cmFsR3Jhdml0eVNvbHZlcjIuZGVmYXVsdCh0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tb2RlbE9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGluaXRpYWxpemUgdGhlIGVuZ2luZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdpbml0UGh5c2ljcycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdFBoeXNpY3MoKSB7XG4gICAgICAgIGlmICh0aGlzLnBoeXNpY3NFbmFibGVkID09PSB0cnVlICYmIHRoaXMub3B0aW9ucy5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGFiaWxpemF0aW9uLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhYmlsaXplKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhYmlsaXplZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5yZWFkeSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdmaXQnLCB7fSwgdGhpcy5sYXlvdXRGYWlsZWQpOyAvLyBpZiB0aGUgbGF5b3V0IGZhaWxlZCwgd2UgdXNlIHRoZSBhcHByb3hpbWF0aW9uIGZvciB0aGUgem9vbVxuICAgICAgICAgICAgdGhpcy5zdGFydFNpbXVsYXRpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZWFkeSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnZml0Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTdGFydCB0aGUgc2ltdWxhdGlvblxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzdGFydFNpbXVsYXRpb24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0U2ltdWxhdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMucGh5c2ljc0VuYWJsZWQgPT09IHRydWUgJiYgdGhpcy5vcHRpb25zLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLnN0YWJpbGl6ZWQgPSBmYWxzZTtcblxuICAgICAgICAgIC8vIHdoZW4gdmlzaWJsZSwgYWRhcHRpdml0eSBpcyBkaXNhYmxlZC5cbiAgICAgICAgICB0aGlzLmFkYXB0aXZlVGltZXN0ZXAgPSBmYWxzZTtcblxuICAgICAgICAgIC8vIHRoaXMgc2V0cyB0aGUgd2lkdGggb2YgYWxsIG5vZGVzIGluaXRpYWxseSB3aGljaCBjb3VsZCBiZSByZXF1aXJlZCBmb3IgdGhlIGF2b2lkT3ZlcmxhcFxuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVzaXplTm9kZXNcIik7XG4gICAgICAgICAgaWYgKHRoaXMudmlld0Z1bmN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMudmlld0Z1bmN0aW9uID0gdGhpcy5zaW11bGF0aW9uU3RlcC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ2luaXRSZWRyYXcnLCB0aGlzLnZpZXdGdW5jdGlvbik7XG4gICAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfc3RhcnRSZW5kZXJpbmcnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX3JlZHJhdycpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU3RvcCB0aGUgc2ltdWxhdGlvbiwgZm9yY2Ugc3RhYmlsaXphdGlvbi5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc3RvcFNpbXVsYXRpb24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3BTaW11bGF0aW9uKCkge1xuICAgICAgICB2YXIgZW1pdCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhcmd1bWVudHNbMF07XG5cbiAgICAgICAgdGhpcy5zdGFiaWxpemVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKGVtaXQgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLl9lbWl0U3RhYmlsaXplZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZpZXdGdW5jdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub2ZmKCdpbml0UmVkcmF3JywgdGhpcy52aWV3RnVuY3Rpb24pO1xuICAgICAgICAgIHRoaXMudmlld0Z1bmN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGlmIChlbWl0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfc3RvcFJlbmRlcmluZycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSB2aWV3RnVuY3Rpb24gaW5zZXJ0cyB0aGlzIHN0ZXAgaW50byBlYWNoIHJlbmRlciBsb29wLiBJdCBjYWxscyB0aGUgcGh5c2ljcyB0aWNrIGFuZCBoYW5kbGVzIHRoZSBjbGVhbnVwIGF0IHN0YWJpbGl6ZWQuXG4gICAgICAgKlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzaW11bGF0aW9uU3RlcCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2ltdWxhdGlvblN0ZXAoKSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBwaHlzaWNzIGhhdmUgc2V0dGxlZFxuICAgICAgICB2YXIgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy5waHlzaWNzVGljaygpO1xuICAgICAgICB2YXIgcGh5c2ljc1RpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuXG4gICAgICAgIC8vIHJ1biBkb3VibGUgc3BlZWQgaWYgaXQgaXMgYSBsaXR0bGUgZ3JhcGhcbiAgICAgICAgaWYgKChwaHlzaWNzVGltZSA8IDAuNCAqIHRoaXMuc2ltdWxhdGlvbkludGVydmFsIHx8IHRoaXMucnVuRG91YmxlU3BlZWQgPT09IHRydWUpICYmIHRoaXMuc3RhYmlsaXplZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLnBoeXNpY3NUaWNrKCk7XG5cbiAgICAgICAgICAvLyB0aGlzIG1ha2VzIHN1cmUgdGhlcmUgaXMgbm8gaml0dGVyLiBUaGUgZGVjaXNpb24gaXMgdGFrZW4gb25jZSB0byBydW4gaXQgYXQgZG91YmxlIHNwZWVkLlxuICAgICAgICAgIHRoaXMucnVuRG91YmxlU3BlZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc3RhYmlsaXplZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuc3RvcFNpbXVsYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHRyaWdnZXIgdGhlIHN0YWJpbGl6ZWQgZXZlbnQuXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZW1pdFN0YWJpbGl6ZWQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9lbWl0U3RhYmlsaXplZCgpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGFtb3VudE9mSXRlcmF0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHRoaXMuc3RhYmlsaXphdGlvbkl0ZXJhdGlvbnMgOiBhcmd1bWVudHNbMF07XG5cbiAgICAgICAgaWYgKHRoaXMuc3RhYmlsaXphdGlvbkl0ZXJhdGlvbnMgPiAxIHx8IHRoaXMuc3RhcnRlZFN0YWJpbGl6YXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMi5ib2R5LmVtaXR0ZXIuZW1pdCgnc3RhYmlsaXplZCcsIHsgaXRlcmF0aW9uczogYW1vdW50T2ZJdGVyYXRpb25zIH0pO1xuICAgICAgICAgICAgX3RoaXMyLnN0YXJ0ZWRTdGFiaWxpemF0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICBfdGhpczIuc3RhYmlsaXphdGlvbkl0ZXJhdGlvbnMgPSAwO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQSBzaW5nbGUgc2ltdWxhdGlvbiBzdGVwIChvciAndGljaycpIGluIHRoZSBwaHlzaWNzIHNpbXVsYXRpb25cbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdwaHlzaWNzVGljaycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcGh5c2ljc1RpY2soKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgaGVyZSB0byBlbnN1cmUgdGhhdCB0aGVyZSBpcyBubyBzdGFydCBldmVudCB3aGVuIHRoZSBuZXR3b3JrIGlzIGFscmVhZHkgc3RhYmxlLlxuICAgICAgICBpZiAodGhpcy5zdGFydGVkU3RhYmlsaXphdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdzdGFydFN0YWJpbGl6aW5nJyk7XG4gICAgICAgICAgdGhpcy5zdGFydGVkU3RhYmlsaXphdGlvbiA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zdGFiaWxpemVkID09PSBmYWxzZSkge1xuICAgICAgICAgIC8vIGFkYXB0aXZpdHkgbWVhbnMgdGhlIHRpbWVzdGVwIGFkYXB0cyB0byB0aGUgc2l0dWF0aW9uLCBvbmx5IGFwcGxpY2FibGUgZm9yIHN0YWJpbGl6YXRpb25cbiAgICAgICAgICBpZiAodGhpcy5hZGFwdGl2ZVRpbWVzdGVwID09PSB0cnVlICYmIHRoaXMuYWRhcHRpdmVUaW1lc3RlcEVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIGZhY3RvciBmb3IgaW5jcmVhc2luZyB0aGUgdGltZXN0ZXAgb24gc3VjY2Vzcy5cbiAgICAgICAgICAgIHZhciBmYWN0b3IgPSAxLjI7XG5cbiAgICAgICAgICAgIC8vIHdlIGFzc3VtZSB0aGUgYWRhcHRpdmUgaW50ZXJ2YWwgaXNcbiAgICAgICAgICAgIGlmICh0aGlzLmFkYXB0aXZlQ291bnRlciAlIHRoaXMuYWRhcHRpdmVJbnRlcnZhbCA9PT0gMCkge1xuICAgICAgICAgICAgICAvLyB3ZSBsZWF2ZSB0aGUgdGltZXN0ZXAgc3RhYmxlIGZvciBcImludGVydmFsXCIgaXRlcmF0aW9ucy5cbiAgICAgICAgICAgICAgLy8gZmlyc3QgdGhlIGJpZyBzdGVwIGFuZCByZXZlcnQuIFJldmVydCBzYXZlcyB0aGUgcmVmZXJlbmNlIHN0YXRlLlxuICAgICAgICAgICAgICB0aGlzLnRpbWVzdGVwID0gMiAqIHRoaXMudGltZXN0ZXA7XG4gICAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlRm9yY2VzKCk7XG4gICAgICAgICAgICAgIHRoaXMubW92ZU5vZGVzKCk7XG4gICAgICAgICAgICAgIHRoaXMucmV2ZXJ0KCk7XG5cbiAgICAgICAgICAgICAgLy8gbm93IHRoZSBub3JtYWwgc3RlcC4gU2luY2UgdGhpcyBpcyB0aGUgbGFzdCBzdGVwLCBpdCBpcyB0aGUgbW9yZSBzdGFibGUgb25lIGFuZCB3ZSB3aWxsIHRha2UgdGhpcy5cbiAgICAgICAgICAgICAgdGhpcy50aW1lc3RlcCA9IDAuNSAqIHRoaXMudGltZXN0ZXA7XG5cbiAgICAgICAgICAgICAgLy8gc2luY2UgaXQncyBoYWxmIHRoZSBzdGVwLCB3ZSBkbyBpdCB0d2ljZS5cbiAgICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVGb3JjZXMoKTtcbiAgICAgICAgICAgICAgdGhpcy5tb3ZlTm9kZXMoKTtcbiAgICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVGb3JjZXMoKTtcbiAgICAgICAgICAgICAgdGhpcy5tb3ZlTm9kZXMoKTtcblxuICAgICAgICAgICAgICAvLyB3ZSBjb21wYXJlIHRoZSB0d28gc3RlcHMuIGlmIGl0IGlzIGFjY2VwdGFibGUgd2UgZG91YmxlIHRoZSBzdGVwLlxuICAgICAgICAgICAgICBpZiAodGhpcy5fZXZhbHVhdGVTdGVwUXVhbGl0eSgpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lc3RlcCA9IGZhY3RvciAqIHRoaXMudGltZXN0ZXA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgbm90LCB3ZSBkZWNyZWFzZSB0aGUgc3RlcCB0byBhIG1pbmltdW0gb2YgdGhlIG9wdGlvbnMgdGltZXN0ZXAuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGRlY3JlYXNlZCB0aW1lc3RlcCBpcyBzbWFsbGVyIHRoYW4gdGhlIG9wdGlvbnMgc3RlcCwgd2UgZG8gbm90IHJlc2V0IHRoZSBjb3VudGVyXG4gICAgICAgICAgICAgICAgLy8gd2UgYXNzdW1lIHRoYXQgdGhlIG9wdGlvbnMgdGltZXN0ZXAgaXMgc3RhYmxlIGVub3VnaC5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy50aW1lc3RlcCAvIGZhY3RvciA8IHRoaXMub3B0aW9ucy50aW1lc3RlcCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy50aW1lc3RlcCA9IHRoaXMub3B0aW9ucy50aW1lc3RlcDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHRpbWVzdGVwIHdhcyBsYXJnZXIgdGhhbiAyIHRpbWVzIHRoZSBvcHRpb24gb25lIHdlIGNoZWNrIHRoZSBhZGFwdGl2aXR5IGFnYWluIHRvIGVuc3VyZVxuICAgICAgICAgICAgICAgICAgLy8gdGhhdCBsYXJnZSBpbnN0YWJpbGl0aWVzIGRvIG5vdCBmb3JtLlxuICAgICAgICAgICAgICAgICAgdGhpcy5hZGFwdGl2ZUNvdW50ZXIgPSAtMTsgLy8gY2hlY2sgYWdhaW4gbmV4dCBpdGVyYXRpb25cbiAgICAgICAgICAgICAgICAgIHRoaXMudGltZXN0ZXAgPSBNYXRoLm1heCh0aGlzLm9wdGlvbnMudGltZXN0ZXAsIHRoaXMudGltZXN0ZXAgLyBmYWN0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gbm9ybWFsIHN0ZXAsIGtlZXBpbmcgdGltZXN0ZXAgY29uc3RhbnRcbiAgICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVGb3JjZXMoKTtcbiAgICAgICAgICAgICAgdGhpcy5tb3ZlTm9kZXMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaW5jcmVtZW50IHRoZSBjb3VudGVyXG4gICAgICAgICAgICB0aGlzLmFkYXB0aXZlQ291bnRlciArPSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjYXNlIGZvciB0aGUgc3RhdGljIHRpbWVzdGVwLCB3ZSByZXNldCBpdCB0byB0aGUgb25lIGluIG9wdGlvbnMgYW5kIHRha2UgYSBub3JtYWwgc3RlcC5cbiAgICAgICAgICAgIHRoaXMudGltZXN0ZXAgPSB0aGlzLm9wdGlvbnMudGltZXN0ZXA7XG4gICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZUZvcmNlcygpO1xuICAgICAgICAgICAgdGhpcy5tb3ZlTm9kZXMoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBkZXRlcm1pbmUgaWYgdGhlIG5ldHdvcmsgaGFzIHN0YWJpbHppZWRcbiAgICAgICAgICBpZiAodGhpcy5zdGFiaWxpemVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLnJldmVydCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuc3RhYmlsaXphdGlvbkl0ZXJhdGlvbnMrKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE5vZGVzIGFuZCBlZGdlcyBjYW4gaGF2ZSB0aGUgcGh5c2ljcyB0b2dnbGVzIG9uIG9yIG9mZi4gQSBjb2xsZWN0aW9uIG9mIGluZGljZXMgaXMgY3JlYXRlZCBoZXJlIHNvIHdlIGNhbiBza2lwIHRoZSBjaGVjayBhbGwgdGhlIHRpbWUuXG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAndXBkYXRlUGh5c2ljc0RhdGEnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVBoeXNpY3NEYXRhKCkge1xuICAgICAgICB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlcyA9IHt9O1xuICAgICAgICB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcyA9IFtdO1xuICAgICAgICB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NFZGdlSW5kaWNlcyA9IFtdO1xuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcblxuICAgICAgICAvLyBnZXQgbm9kZSBpbmRpY2VzIGZvciBwaHlzaWNzXG4gICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiBub2Rlcykge1xuICAgICAgICAgIGlmIChub2Rlcy5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgICBpZiAobm9kZXNbbm9kZUlkXS5vcHRpb25zLnBoeXNpY3MgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXMucHVzaChub2Rlc1tub2RlSWRdLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgZWRnZSBpbmRpY2VzIGZvciBwaHlzaWNzXG4gICAgICAgIGZvciAodmFyIGVkZ2VJZCBpbiBlZGdlcykge1xuICAgICAgICAgIGlmIChlZGdlcy5oYXNPd25Qcm9wZXJ0eShlZGdlSWQpKSB7XG4gICAgICAgICAgICBpZiAoZWRnZXNbZWRnZUlkXS5vcHRpb25zLnBoeXNpY3MgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgdGhpcy5waHlzaWNzQm9keS5waHlzaWNzRWRnZUluZGljZXMucHVzaChlZGdlc1tlZGdlSWRdLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgdGhlIHZlbG9jaXR5IGFuZCB0aGUgZm9yY2VzIHZlY3RvclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIF9ub2RlSWQgPSB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlc1tpXTtcbiAgICAgICAgICB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tfbm9kZUlkXSA9IHsgeDogMCwgeTogMCB9O1xuXG4gICAgICAgICAgLy8gZm9yY2VzIGNhbiBiZSByZXNldCBiZWNhdXNlIHRoZXkgYXJlIHJlY2FsY3VsYXRlZC4gVmVsb2NpdGllcyBoYXZlIHRvIHBlcnNpc3QuXG4gICAgICAgICAgaWYgKHRoaXMucGh5c2ljc0JvZHkudmVsb2NpdGllc1tfbm9kZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnBoeXNpY3NCb2R5LnZlbG9jaXRpZXNbX25vZGVJZF0gPSB7IHg6IDAsIHk6IDAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjbGVhbiBkZWxldGVkIG5vZGVzIGZyb20gdGhlIHZlbG9jaXR5IHZlY3RvclxuICAgICAgICBmb3IgKHZhciBfbm9kZUlkMiBpbiB0aGlzLnBoeXNpY3NCb2R5LnZlbG9jaXRpZXMpIHtcbiAgICAgICAgICBpZiAobm9kZXNbX25vZGVJZDJdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnBoeXNpY3NCb2R5LnZlbG9jaXRpZXNbX25vZGVJZDJdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldmVydCB0aGUgc2ltdWxhdGlvbiBvbmUgc3RlcC4gVGhpcyBpcyBkb25lIHNvIGFmdGVyIHN0YWJpbGl6YXRpb24sIGV2ZXJ5IG5ldyBzdGFydCBvZiB0aGUgc2ltdWxhdGlvbiB3aWxsIGFsc28gc2F5IHN0YWJpbGl6ZWQuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3JldmVydCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmV2ZXJ0KCkge1xuICAgICAgICB2YXIgbm9kZUlkcyA9IE9iamVjdC5rZXlzKHRoaXMucHJldmlvdXNTdGF0ZXMpO1xuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICAgIHZhciB2ZWxvY2l0aWVzID0gdGhpcy5waHlzaWNzQm9keS52ZWxvY2l0aWVzO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZVN0YXRlID0ge307XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5vZGVJZCA9IG5vZGVJZHNbaV07XG4gICAgICAgICAgaWYgKG5vZGVzW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKG5vZGVzW25vZGVJZF0ub3B0aW9ucy5waHlzaWNzID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHRoaXMucmVmZXJlbmNlU3RhdGVbbm9kZUlkXSA9IHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbnM6IHsgeDogbm9kZXNbbm9kZUlkXS54LCB5OiBub2Rlc1tub2RlSWRdLnkgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB2ZWxvY2l0aWVzW25vZGVJZF0ueCA9IHRoaXMucHJldmlvdXNTdGF0ZXNbbm9kZUlkXS52eDtcbiAgICAgICAgICAgICAgdmVsb2NpdGllc1tub2RlSWRdLnkgPSB0aGlzLnByZXZpb3VzU3RhdGVzW25vZGVJZF0udnk7XG4gICAgICAgICAgICAgIG5vZGVzW25vZGVJZF0ueCA9IHRoaXMucHJldmlvdXNTdGF0ZXNbbm9kZUlkXS54O1xuICAgICAgICAgICAgICBub2Rlc1tub2RlSWRdLnkgPSB0aGlzLnByZXZpb3VzU3RhdGVzW25vZGVJZF0ueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMucHJldmlvdXNTdGF0ZXNbbm9kZUlkXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIGNvbXBhcmVzIHRoZSByZWZlcmVuY2Ugc3RhdGUgdG8gdGhlIGN1cnJlbnQgc3RhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2V2YWx1YXRlU3RlcFF1YWxpdHknLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmFsdWF0ZVN0ZXBRdWFsaXR5KCkge1xuICAgICAgICB2YXIgZHggPSB2b2lkIDAsXG4gICAgICAgICAgICBkeSA9IHZvaWQgMCxcbiAgICAgICAgICAgIGRwb3MgPSB2b2lkIDA7XG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgICAgdmFyIHJlZmVyZW5jZSA9IHRoaXMucmVmZXJlbmNlU3RhdGU7XG4gICAgICAgIHZhciBwb3NUaHJlc2hvbGQgPSAwLjM7XG5cbiAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIHRoaXMucmVmZXJlbmNlU3RhdGUpIHtcbiAgICAgICAgICBpZiAodGhpcy5yZWZlcmVuY2VTdGF0ZS5oYXNPd25Qcm9wZXJ0eShub2RlSWQpICYmIG5vZGVzW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZHggPSBub2Rlc1tub2RlSWRdLnggLSByZWZlcmVuY2Vbbm9kZUlkXS5wb3NpdGlvbnMueDtcbiAgICAgICAgICAgIGR5ID0gbm9kZXNbbm9kZUlkXS55IC0gcmVmZXJlbmNlW25vZGVJZF0ucG9zaXRpb25zLnk7XG5cbiAgICAgICAgICAgIGRwb3MgPSBNYXRoLnNxcnQoTWF0aC5wb3coZHgsIDIpICsgTWF0aC5wb3coZHksIDIpKTtcblxuICAgICAgICAgICAgaWYgKGRwb3MgPiBwb3NUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBtb3ZlIHRoZSBub2RlcyBvbmUgdGltZXN0ZXAgYW5kIGNoZWNrIGlmIHRoZXkgYXJlIHN0YWJpbGl6ZWRcbiAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdtb3ZlTm9kZXMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmVOb2RlcygpIHtcbiAgICAgICAgdmFyIG5vZGVJbmRpY2VzID0gdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXM7XG4gICAgICAgIHZhciBtYXhWZWxvY2l0eSA9IHRoaXMub3B0aW9ucy5tYXhWZWxvY2l0eSA/IHRoaXMub3B0aW9ucy5tYXhWZWxvY2l0eSA6IDFlOTtcbiAgICAgICAgdmFyIG1heE5vZGVWZWxvY2l0eSA9IDA7XG4gICAgICAgIHZhciBhdmVyYWdlTm9kZVZlbG9jaXR5ID0gMDtcblxuICAgICAgICAvLyB0aGUgdmVsb2NpdHkgdGhyZXNob2xkIChlbmVyZ3kgaW4gdGhlIHN5c3RlbSkgZm9yIHRoZSBhZGFwdGl2aXR5IHRvZ2dsZVxuICAgICAgICB2YXIgdmVsb2NpdHlBZGFwdGl2ZVRocmVzaG9sZCA9IDU7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBub2RlSWQgPSBub2RlSW5kaWNlc1tpXTtcbiAgICAgICAgICB2YXIgbm9kZVZlbG9jaXR5ID0gdGhpcy5fcGVyZm9ybVN0ZXAobm9kZUlkLCBtYXhWZWxvY2l0eSk7XG4gICAgICAgICAgLy8gc3RhYmlsaXplZCBpcyB0cnVlIGlmIHN0YWJpbGl6ZWQgaXMgdHJ1ZSBhbmQgdmVsb2NpdHkgaXMgc21hbGxlciB0aGFuIHZtaW4gLS0+IGFsbCBub2RlcyBtdXN0IGJlIHN0YWJpbGl6ZWRcbiAgICAgICAgICBtYXhOb2RlVmVsb2NpdHkgPSBNYXRoLm1heChtYXhOb2RlVmVsb2NpdHksIG5vZGVWZWxvY2l0eSk7XG4gICAgICAgICAgYXZlcmFnZU5vZGVWZWxvY2l0eSArPSBub2RlVmVsb2NpdHk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBldmFsdWF0aW5nIHRoZSBzdGFiaWxpemVkIGFuZCBhZGFwdGl2ZVRpbWVzdGVwRW5hYmxlZCBjb25kaXRpb25zXG4gICAgICAgIHRoaXMuYWRhcHRpdmVUaW1lc3RlcEVuYWJsZWQgPSBhdmVyYWdlTm9kZVZlbG9jaXR5IC8gbm9kZUluZGljZXMubGVuZ3RoIDwgdmVsb2NpdHlBZGFwdGl2ZVRocmVzaG9sZDtcbiAgICAgICAgdGhpcy5zdGFiaWxpemVkID0gbWF4Tm9kZVZlbG9jaXR5IDwgdGhpcy5vcHRpb25zLm1pblZlbG9jaXR5O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFBlcmZvcm0gdGhlIGFjdHVhbCBzdGVwXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIG5vZGVJZFxuICAgICAgICogQHBhcmFtIG1heFZlbG9jaXR5XG4gICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3BlcmZvcm1TdGVwJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcGVyZm9ybVN0ZXAobm9kZUlkLCBtYXhWZWxvY2l0eSkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgICB2YXIgdGltZXN0ZXAgPSB0aGlzLnRpbWVzdGVwO1xuICAgICAgICB2YXIgZm9yY2VzID0gdGhpcy5waHlzaWNzQm9keS5mb3JjZXM7XG4gICAgICAgIHZhciB2ZWxvY2l0aWVzID0gdGhpcy5waHlzaWNzQm9keS52ZWxvY2l0aWVzO1xuXG4gICAgICAgIC8vIHN0b3JlIHRoZSBzdGF0ZSBzbyB3ZSBjYW4gcmV2ZXJ0XG4gICAgICAgIHRoaXMucHJldmlvdXNTdGF0ZXNbbm9kZUlkXSA9IHsgeDogbm9kZS54LCB5OiBub2RlLnksIHZ4OiB2ZWxvY2l0aWVzW25vZGVJZF0ueCwgdnk6IHZlbG9jaXRpZXNbbm9kZUlkXS55IH07XG5cbiAgICAgICAgaWYgKG5vZGUub3B0aW9ucy5maXhlZC54ID09PSBmYWxzZSkge1xuICAgICAgICAgIHZhciBkeCA9IHRoaXMubW9kZWxPcHRpb25zLmRhbXBpbmcgKiB2ZWxvY2l0aWVzW25vZGVJZF0ueDsgLy8gZGFtcGluZyBmb3JjZVxuICAgICAgICAgIHZhciBheCA9IChmb3JjZXNbbm9kZUlkXS54IC0gZHgpIC8gbm9kZS5vcHRpb25zLm1hc3M7IC8vIGFjY2VsZXJhdGlvblxuICAgICAgICAgIHZlbG9jaXRpZXNbbm9kZUlkXS54ICs9IGF4ICogdGltZXN0ZXA7IC8vIHZlbG9jaXR5XG4gICAgICAgICAgdmVsb2NpdGllc1tub2RlSWRdLnggPSBNYXRoLmFicyh2ZWxvY2l0aWVzW25vZGVJZF0ueCkgPiBtYXhWZWxvY2l0eSA/IHZlbG9jaXRpZXNbbm9kZUlkXS54ID4gMCA/IG1heFZlbG9jaXR5IDogLW1heFZlbG9jaXR5IDogdmVsb2NpdGllc1tub2RlSWRdLng7XG4gICAgICAgICAgbm9kZS54ICs9IHZlbG9jaXRpZXNbbm9kZUlkXS54ICogdGltZXN0ZXA7IC8vIHBvc2l0aW9uXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JjZXNbbm9kZUlkXS54ID0gMDtcbiAgICAgICAgICAgIHZlbG9jaXRpZXNbbm9kZUlkXS54ID0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vZGUub3B0aW9ucy5maXhlZC55ID09PSBmYWxzZSkge1xuICAgICAgICAgIHZhciBkeSA9IHRoaXMubW9kZWxPcHRpb25zLmRhbXBpbmcgKiB2ZWxvY2l0aWVzW25vZGVJZF0ueTsgLy8gZGFtcGluZyBmb3JjZVxuICAgICAgICAgIHZhciBheSA9IChmb3JjZXNbbm9kZUlkXS55IC0gZHkpIC8gbm9kZS5vcHRpb25zLm1hc3M7IC8vIGFjY2VsZXJhdGlvblxuICAgICAgICAgIHZlbG9jaXRpZXNbbm9kZUlkXS55ICs9IGF5ICogdGltZXN0ZXA7IC8vIHZlbG9jaXR5XG4gICAgICAgICAgdmVsb2NpdGllc1tub2RlSWRdLnkgPSBNYXRoLmFicyh2ZWxvY2l0aWVzW25vZGVJZF0ueSkgPiBtYXhWZWxvY2l0eSA/IHZlbG9jaXRpZXNbbm9kZUlkXS55ID4gMCA/IG1heFZlbG9jaXR5IDogLW1heFZlbG9jaXR5IDogdmVsb2NpdGllc1tub2RlSWRdLnk7XG4gICAgICAgICAgbm9kZS55ICs9IHZlbG9jaXRpZXNbbm9kZUlkXS55ICogdGltZXN0ZXA7IC8vIHBvc2l0aW9uXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JjZXNbbm9kZUlkXS55ID0gMDtcbiAgICAgICAgICAgIHZlbG9jaXRpZXNbbm9kZUlkXS55ID0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRvdGFsVmVsb2NpdHkgPSBNYXRoLnNxcnQoTWF0aC5wb3codmVsb2NpdGllc1tub2RlSWRdLngsIDIpICsgTWF0aC5wb3codmVsb2NpdGllc1tub2RlSWRdLnksIDIpKTtcbiAgICAgICAgcmV0dXJuIHRvdGFsVmVsb2NpdHk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogY2FsY3VsYXRlIHRoZSBmb3JjZXMgZm9yIG9uZSBwaHlzaWNzIGl0ZXJhdGlvbi5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnY2FsY3VsYXRlRm9yY2VzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVGb3JjZXMoKSB7XG4gICAgICAgIHRoaXMuZ3Jhdml0eVNvbHZlci5zb2x2ZSgpO1xuICAgICAgICB0aGlzLm5vZGVzU29sdmVyLnNvbHZlKCk7XG4gICAgICAgIHRoaXMuZWRnZXNTb2x2ZXIuc29sdmUoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBXaGVuIGluaXRpYWxpemluZyBhbmQgc3RhYmlsaXppbmcsIHdlIGNhbiBmcmVlemUgbm9kZXMgd2l0aCBhIHByZWRlZmluZWQgcG9zaXRpb24uIFRoaXMgZ3JlYXRseSBzcGVlZHMgdXAgc3RhYmlsaXphdGlvblxuICAgICAgICogYmVjYXVzZSBvbmx5IHRoZSBzdXBwb3J0bm9kZXMgZm9yIHRoZSBzbW9vdGhDdXJ2ZXMgaGF2ZSB0byBzZXR0bGUuXG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2ZyZWV6ZU5vZGVzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZnJlZXplTm9kZXMoKSB7XG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgICAgZm9yICh2YXIgaWQgaW4gbm9kZXMpIHtcbiAgICAgICAgICBpZiAobm9kZXMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICBpZiAobm9kZXNbaWRdLnggJiYgbm9kZXNbaWRdLnkpIHtcbiAgICAgICAgICAgICAgdGhpcy5mcmVlemVDYWNoZVtpZF0gPSB7IHg6IG5vZGVzW2lkXS5vcHRpb25zLmZpeGVkLngsIHk6IG5vZGVzW2lkXS5vcHRpb25zLmZpeGVkLnkgfTtcbiAgICAgICAgICAgICAgbm9kZXNbaWRdLm9wdGlvbnMuZml4ZWQueCA9IHRydWU7XG4gICAgICAgICAgICAgIG5vZGVzW2lkXS5vcHRpb25zLmZpeGVkLnkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFVuZnJlZXplcyB0aGUgbm9kZXMgdGhhdCBoYXZlIGJlZW4gZnJvemVuIGJ5IF9mcmVlemVEZWZpbmVkTm9kZXMuXG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3Jlc3RvcmVGcm96ZW5Ob2RlcycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc3RvcmVGcm96ZW5Ob2RlcygpIHtcbiAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgICBmb3IgKHZhciBpZCBpbiBub2Rlcykge1xuICAgICAgICAgIGlmIChub2Rlcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZyZWV6ZUNhY2hlW2lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIG5vZGVzW2lkXS5vcHRpb25zLmZpeGVkLnggPSB0aGlzLmZyZWV6ZUNhY2hlW2lkXS54O1xuICAgICAgICAgICAgICBub2Rlc1tpZF0ub3B0aW9ucy5maXhlZC55ID0gdGhpcy5mcmVlemVDYWNoZVtpZF0ueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mcmVlemVDYWNoZSA9IHt9O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEZpbmQgYSBzdGFibGUgcG9zaXRpb24gZm9yIGFsbCBub2Rlc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzdGFiaWxpemUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0YWJpbGl6ZSgpIHtcbiAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGl0ZXJhdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB0aGlzLm9wdGlvbnMuc3RhYmlsaXphdGlvbi5pdGVyYXRpb25zIDogYXJndW1lbnRzWzBdO1xuXG4gICAgICAgIGlmICh0eXBlb2YgaXRlcmF0aW9ucyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnVGhlIHN0YWJpbGl6ZSBtZXRob2QgbmVlZHMgYSBudW1lcmljIGFtb3VudCBvZiBpdGVyYXRpb25zLiBTd2l0Y2hpbmcgdG8gZGVmYXVsdDogJywgdGhpcy5vcHRpb25zLnN0YWJpbGl6YXRpb24uaXRlcmF0aW9ucyk7XG4gICAgICAgICAgaXRlcmF0aW9ucyA9IHRoaXMub3B0aW9ucy5zdGFiaWxpemF0aW9uLml0ZXJhdGlvbnM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5yZWFkeSA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW5hYmxlIGFkYXB0aXZlIHRpbWVzdGVwc1xuICAgICAgICB0aGlzLmFkYXB0aXZlVGltZXN0ZXAgPSB0cnVlICYmIHRoaXMub3B0aW9ucy5hZGFwdGl2ZVRpbWVzdGVwO1xuXG4gICAgICAgIC8vIHRoaXMgc2V0cyB0aGUgd2lkdGggb2YgYWxsIG5vZGVzIGluaXRpYWxseSB3aGljaCBjb3VsZCBiZSByZXF1aXJlZCBmb3IgdGhlIGF2b2lkT3ZlcmxhcFxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3Jlc2l6ZU5vZGVzXCIpO1xuXG4gICAgICAgIC8vIHN0b3AgdGhlIHJlbmRlciBsb29wXG4gICAgICAgIHRoaXMuc3RvcFNpbXVsYXRpb24oKTtcblxuICAgICAgICAvLyBzZXQgc3RhYmlsemUgdG8gZmFsc2VcbiAgICAgICAgdGhpcy5zdGFiaWxpemVkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gYmxvY2sgcmVkcmF3IHJlcXVlc3RzXG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19ibG9ja1JlZHJhdycpO1xuICAgICAgICB0aGlzLnRhcmdldEl0ZXJhdGlvbnMgPSBpdGVyYXRpb25zO1xuXG4gICAgICAgIC8vIHN0YXJ0IHRoZSBzdGFiaWxpemF0aW9uXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RhYmlsaXphdGlvbi5vbmx5RHluYW1pY0VkZ2VzID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5fZnJlZXplTm9kZXMoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YWJpbGl6YXRpb25JdGVyYXRpb25zID0gMDtcblxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMzLl9zdGFiaWxpemF0aW9uQmF0Y2goKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogT25lIGJhdGNoIG9mIHN0YWJpbGl6YXRpb25cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19zdGFiaWxpemF0aW9uQmF0Y2gnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zdGFiaWxpemF0aW9uQmF0Y2goKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgaGVyZSB0byBlbnN1cmUgdGhhdCB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgc3RhcnQgZXZlbnQuXG4gICAgICAgIGlmICh0aGlzLnN0YXJ0ZWRTdGFiaWxpemF0aW9uID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3N0YXJ0U3RhYmlsaXppbmcnKTtcbiAgICAgICAgICB0aGlzLnN0YXJ0ZWRTdGFiaWxpemF0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgIHdoaWxlICh0aGlzLnN0YWJpbGl6ZWQgPT09IGZhbHNlICYmIGNvdW50IDwgdGhpcy5vcHRpb25zLnN0YWJpbGl6YXRpb24udXBkYXRlSW50ZXJ2YWwgJiYgdGhpcy5zdGFiaWxpemF0aW9uSXRlcmF0aW9ucyA8IHRoaXMudGFyZ2V0SXRlcmF0aW9ucykge1xuICAgICAgICAgIHRoaXMucGh5c2ljc1RpY2soKTtcbiAgICAgICAgICBjb3VudCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc3RhYmlsaXplZCA9PT0gZmFsc2UgJiYgdGhpcy5zdGFiaWxpemF0aW9uSXRlcmF0aW9ucyA8IHRoaXMudGFyZ2V0SXRlcmF0aW9ucykge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3N0YWJpbGl6YXRpb25Qcm9ncmVzcycsIHsgaXRlcmF0aW9uczogdGhpcy5zdGFiaWxpemF0aW9uSXRlcmF0aW9ucywgdG90YWw6IHRoaXMudGFyZ2V0SXRlcmF0aW9ucyB9KTtcbiAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMuX3N0YWJpbGl6YXRpb25CYXRjaC5iaW5kKHRoaXMpLCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9maW5hbGl6ZVN0YWJpbGl6YXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFdyYXAgdXAgdGhlIHN0YWJpbGl6YXRpb24sIGZpdCBhbmQgZW1pdCB0aGUgZXZlbnRzLlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2ZpbmFsaXplU3RhYmlsaXphdGlvbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmFsaXplU3RhYmlsaXphdGlvbigpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX2FsbG93UmVkcmF3Jyk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RhYmlsaXphdGlvbi5maXQgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdmaXQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RhYmlsaXphdGlvbi5vbmx5RHluYW1pY0VkZ2VzID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5fcmVzdG9yZUZyb3plbk5vZGVzKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdzdGFiaWxpemF0aW9uSXRlcmF0aW9uc0RvbmUnKTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX3JlcXVlc3RSZWRyYXcnKTtcblxuICAgICAgICBpZiAodGhpcy5zdGFiaWxpemVkID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5fZW1pdFN0YWJpbGl6ZWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0YXJ0U2ltdWxhdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZWFkeSA9IHRydWU7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2RyYXdGb3JjZXMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3Rm9yY2VzKGN0eCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXNbaV1dO1xuICAgICAgICAgIHZhciBmb3JjZSA9IHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW3RoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzW2ldXTtcbiAgICAgICAgICB2YXIgZmFjdG9yID0gMjA7XG4gICAgICAgICAgdmFyIGNvbG9yRmFjdG9yID0gMC4wMztcbiAgICAgICAgICB2YXIgZm9yY2VTaXplID0gTWF0aC5zcXJ0KE1hdGgucG93KGZvcmNlLngsIDIpICsgTWF0aC5wb3coZm9yY2UueCwgMikpO1xuXG4gICAgICAgICAgdmFyIHNpemUgPSBNYXRoLm1pbihNYXRoLm1heCg1LCBmb3JjZVNpemUpLCAxNSk7XG4gICAgICAgICAgdmFyIGFycm93U2l6ZSA9IDMgKiBzaXplO1xuXG4gICAgICAgICAgdmFyIGNvbG9yID0gdXRpbC5IU1ZUb0hleCgoMTgwIC0gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgY29sb3JGYWN0b3IgKiBmb3JjZVNpemUpKSAqIDE4MCkgLyAzNjAsIDEsIDEpO1xuXG4gICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHNpemU7XG4gICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgIGN0eC5tb3ZlVG8obm9kZS54LCBub2RlLnkpO1xuICAgICAgICAgIGN0eC5saW5lVG8obm9kZS54ICsgZmFjdG9yICogZm9yY2UueCwgbm9kZS55ICsgZmFjdG9yICogZm9yY2UueSk7XG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMihmb3JjZS55LCBmb3JjZS54KTtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICAgICAgY3R4LmFycm93KG5vZGUueCArIGZhY3RvciAqIGZvcmNlLnggKyBNYXRoLmNvcyhhbmdsZSkgKiBhcnJvd1NpemUsIG5vZGUueSArIGZhY3RvciAqIGZvcmNlLnkgKyBNYXRoLnNpbihhbmdsZSkgKiBhcnJvd1NpemUsIGFuZ2xlLCBhcnJvd1NpemUpO1xuICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gUGh5c2ljc0VuZ2luZTtcbiAgfSgpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IFBoeXNpY3NFbmdpbmU7XG5cbi8qKiovIH0sXG4vKiA5NCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIHZhciBCYXJuZXNIdXRTb2x2ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmFybmVzSHV0U29sdmVyKGJvZHksIHBoeXNpY3NCb2R5LCBvcHRpb25zKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmFybmVzSHV0U29sdmVyKTtcblxuICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgIHRoaXMucGh5c2ljc0JvZHkgPSBwaHlzaWNzQm9keTtcbiAgICAgIHRoaXMuYmFybmVzSHV0VHJlZTtcbiAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIHRoaXMucmFuZG9tU2VlZCA9IDU7XG5cbiAgICAgIC8vIGRlYnVnOiBzaG93IGdyaWRcbiAgICAgIC8vdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJhZnRlckRyYXdpbmdcIiwgKGN0eCkgPT4ge3RoaXMuX2RlYnVnKGN0eCwnI2ZmMDAwMCcpfSlcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQmFybmVzSHV0U29sdmVyLCBbe1xuICAgICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy50aGV0YUludmVyc2VkID0gMSAvIHRoaXMub3B0aW9ucy50aGV0YTtcbiAgICAgICAgdGhpcy5vdmVybGFwQXZvaWRhbmNlRmFjdG9yID0gMSAtIE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHRoaXMub3B0aW9ucy5hdm9pZE92ZXJsYXApKTsgLy8gaWYgMSB0aGVuIG1pbiBkaXN0YW5jZSA9IDAuNSwgaWYgMC41IHRoZW4gbWluIGRpc3RhbmNlID0gMC41ICsgMC41Km5vZGUuc2hhcGUucmFkaXVzXG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNlZWRlZFJhbmRvbVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNlZWRlZFJhbmRvbSgpIHtcbiAgICAgICAgdmFyIHggPSBNYXRoLnNpbih0aGlzLnJhbmRvbVNlZWQrKykgKiAxMDAwMDtcbiAgICAgICAgcmV0dXJuIHggLSBNYXRoLmZsb29yKHgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyB0aGUgZm9yY2VzIHRoZSBub2RlcyBhcHBseSBvbiBlYWNoIG90aGVyIGJhc2VkIG9uIGEgZ3Jhdml0YXRpb25hbCBtb2RlbC5cbiAgICAgICAqIFRoZSBCYXJuZXMgSHV0IG1ldGhvZCBpcyB1c2VkIHRvIHNwZWVkIHVwIHRoaXMgTi1ib2R5IHNpbXVsYXRpb24uXG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInNvbHZlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc29sdmUoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZ3Jhdml0YXRpb25hbENvbnN0YW50ICE9PSAwICYmIHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IHZvaWQgMDtcbiAgICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICAgICAgdmFyIG5vZGVJbmRpY2VzID0gdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXM7XG4gICAgICAgICAgdmFyIG5vZGVDb3VudCA9IG5vZGVJbmRpY2VzLmxlbmd0aDtcblxuICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgdHJlZVxuICAgICAgICAgIHZhciBiYXJuZXNIdXRUcmVlID0gdGhpcy5fZm9ybUJhcm5lc0h1dFRyZWUobm9kZXMsIG5vZGVJbmRpY2VzKTtcblxuICAgICAgICAgIC8vIGZvciBkZWJ1Z2dpbmdcbiAgICAgICAgICB0aGlzLmJhcm5lc0h1dFRyZWUgPSBiYXJuZXNIdXRUcmVlO1xuXG4gICAgICAgICAgLy8gcGxhY2UgdGhlIG5vZGVzIG9uZSBieSBvbmUgcmVjdXJzaXZlbHlcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZXNbbm9kZUluZGljZXNbaV1dO1xuICAgICAgICAgICAgaWYgKG5vZGUub3B0aW9ucy5tYXNzID4gMCkge1xuICAgICAgICAgICAgICAvLyBzdGFydGluZyB3aXRoIHJvb3QgaXMgaXJyZWxldmFudCwgaXQgbmV2ZXIgcGFzc2VzIHRoZSBCYXJuZXNIdXRTb2x2ZXIgY29uZGl0aW9uXG4gICAgICAgICAgICAgIHRoaXMuX2dldEZvcmNlQ29udHJpYnV0aW9uKGJhcm5lc0h1dFRyZWUucm9vdC5jaGlsZHJlbi5OVywgbm9kZSk7XG4gICAgICAgICAgICAgIHRoaXMuX2dldEZvcmNlQ29udHJpYnV0aW9uKGJhcm5lc0h1dFRyZWUucm9vdC5jaGlsZHJlbi5ORSwgbm9kZSk7XG4gICAgICAgICAgICAgIHRoaXMuX2dldEZvcmNlQ29udHJpYnV0aW9uKGJhcm5lc0h1dFRyZWUucm9vdC5jaGlsZHJlbi5TVywgbm9kZSk7XG4gICAgICAgICAgICAgIHRoaXMuX2dldEZvcmNlQ29udHJpYnV0aW9uKGJhcm5lc0h1dFRyZWUucm9vdC5jaGlsZHJlbi5TRSwgbm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBmdW5jdGlvbiB0cmF2ZXJzZXMgdGhlIGJhcm5lc0h1dFRyZWUuIEl0IGNoZWNrcyB3aGVuIGl0IGNhbiBhcHByb3hpbWF0ZSBkaXN0YW50IG5vZGVzIHdpdGggdGhlaXIgY2VudGVyIG9mIG1hc3MuXG4gICAgICAgKiBJZiBhIHJlZ2lvbiBjb250YWlucyBhIHNpbmdsZSBub2RlLCB3ZSBjaGVjayBpZiBpdCBpcyBub3QgaXRzZWxmLCB0aGVuIHdlIGFwcGx5IHRoZSBmb3JjZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gcGFyZW50QnJhbmNoXG4gICAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9nZXRGb3JjZUNvbnRyaWJ1dGlvblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRGb3JjZUNvbnRyaWJ1dGlvbihwYXJlbnRCcmFuY2gsIG5vZGUpIHtcbiAgICAgICAgLy8gd2UgZ2V0IG5vIGZvcmNlIGNvbnRyaWJ1dGlvbiBmcm9tIGFuIGVtcHR5IHJlZ2lvblxuICAgICAgICBpZiAocGFyZW50QnJhbmNoLmNoaWxkcmVuQ291bnQgPiAwKSB7XG4gICAgICAgICAgdmFyIGR4ID0gdm9pZCAwLFxuICAgICAgICAgICAgICBkeSA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgZGlzdGFuY2UgPSB2b2lkIDA7XG5cbiAgICAgICAgICAvLyBnZXQgdGhlIGRpc3RhbmNlIGZyb20gdGhlIGNlbnRlciBvZiBtYXNzIHRvIHRoZSBub2RlLlxuICAgICAgICAgIGR4ID0gcGFyZW50QnJhbmNoLmNlbnRlck9mTWFzcy54IC0gbm9kZS54O1xuICAgICAgICAgIGR5ID0gcGFyZW50QnJhbmNoLmNlbnRlck9mTWFzcy55IC0gbm9kZS55O1xuICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblxuICAgICAgICAgIC8vIEJhcm5lc0h1dFNvbHZlciBjb25kaXRpb25cbiAgICAgICAgICAvLyBvcmlnaW5hbCBjb25kaXRpb24gOiBzL2QgPCB0aGV0YSA9IHBhc3NlZCAgPT09ICBkL3MgPiAxL3RoZXRhID0gcGFzc2VkXG4gICAgICAgICAgLy8gY2FsY1NpemUgPSAxL3MgLS0+IGQgKiAxL3MgPiAxL3RoZXRhID0gcGFzc2VkXG4gICAgICAgICAgaWYgKGRpc3RhbmNlICogcGFyZW50QnJhbmNoLmNhbGNTaXplID4gdGhpcy50aGV0YUludmVyc2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVGb3JjZXMoZGlzdGFuY2UsIGR4LCBkeSwgbm9kZSwgcGFyZW50QnJhbmNoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRGlkIG5vdCBwYXNzIHRoZSBjb25kaXRpb24sIGdvIGludG8gY2hpbGRyZW4gaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICBpZiAocGFyZW50QnJhbmNoLmNoaWxkcmVuQ291bnQgPT09IDQpIHtcbiAgICAgICAgICAgICAgdGhpcy5fZ2V0Rm9yY2VDb250cmlidXRpb24ocGFyZW50QnJhbmNoLmNoaWxkcmVuLk5XLCBub2RlKTtcbiAgICAgICAgICAgICAgdGhpcy5fZ2V0Rm9yY2VDb250cmlidXRpb24ocGFyZW50QnJhbmNoLmNoaWxkcmVuLk5FLCBub2RlKTtcbiAgICAgICAgICAgICAgdGhpcy5fZ2V0Rm9yY2VDb250cmlidXRpb24ocGFyZW50QnJhbmNoLmNoaWxkcmVuLlNXLCBub2RlKTtcbiAgICAgICAgICAgICAgdGhpcy5fZ2V0Rm9yY2VDb250cmlidXRpb24ocGFyZW50QnJhbmNoLmNoaWxkcmVuLlNFLCBub2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHBhcmVudEJyYW5jaCBtdXN0IGhhdmUgb25seSBvbmUgbm9kZSwgaWYgaXQgd2FzIGVtcHR5IHdlIHdvdWxkbnQgYmUgaGVyZVxuICAgICAgICAgICAgICBpZiAocGFyZW50QnJhbmNoLmNoaWxkcmVuLmRhdGEuaWQgIT0gbm9kZS5pZCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIGl0IGlzIG5vdCBzZWxmXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FsY3VsYXRlRm9yY2VzKGRpc3RhbmNlLCBkeCwgZHksIG5vZGUsIHBhcmVudEJyYW5jaCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxjdWxhdGUgdGhlIGZvcmNlcyBiYXNlZCBvbiB0aGUgZGlzdGFuY2UuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIGRpc3RhbmNlXG4gICAgICAgKiBAcGFyYW0gZHhcbiAgICAgICAqIEBwYXJhbSBkeVxuICAgICAgICogQHBhcmFtIG5vZGVcbiAgICAgICAqIEBwYXJhbSBwYXJlbnRCcmFuY2hcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfY2FsY3VsYXRlRm9yY2VzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGN1bGF0ZUZvcmNlcyhkaXN0YW5jZSwgZHgsIGR5LCBub2RlLCBwYXJlbnRCcmFuY2gpIHtcbiAgICAgICAgaWYgKGRpc3RhbmNlID09PSAwKSB7XG4gICAgICAgICAgZGlzdGFuY2UgPSAwLjE7XG4gICAgICAgICAgZHggPSBkaXN0YW5jZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm92ZXJsYXBBdm9pZGFuY2VGYWN0b3IgPCAxKSB7XG4gICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLm1heCgwLjEgKyB0aGlzLm92ZXJsYXBBdm9pZGFuY2VGYWN0b3IgKiBub2RlLnNoYXBlLnJhZGl1cywgZGlzdGFuY2UgLSBub2RlLnNoYXBlLnJhZGl1cyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGUgZGl2aWRpbmcgYnkgdGhlIGRpc3RhbmNlIGN1YmVkIGluc3RlYWQgb2Ygc3F1YXJlZCBhbGxvd3MgdXMgdG8gZ2V0IHRoZSBmeCBhbmQgZnkgY29tcG9uZW50cyB3aXRob3V0IHNpbmVzIGFuZCBjb3NpbmVzXG4gICAgICAgIC8vIGl0IGlzIHNob3J0aGFuZCBmb3IgZ3Jhdml0eWZvcmNlIHdpdGggZGlzdGFuY2Ugc3F1YXJlZCBhbmQgZnggPSBkeC9kaXN0YW5jZSAqIGdyYXZpdHlGb3JjZVxuICAgICAgICB2YXIgZ3Jhdml0eUZvcmNlID0gdGhpcy5vcHRpb25zLmdyYXZpdGF0aW9uYWxDb25zdGFudCAqIHBhcmVudEJyYW5jaC5tYXNzICogbm9kZS5vcHRpb25zLm1hc3MgLyBNYXRoLnBvdyhkaXN0YW5jZSwgMyk7XG4gICAgICAgIHZhciBmeCA9IGR4ICogZ3Jhdml0eUZvcmNlO1xuICAgICAgICB2YXIgZnkgPSBkeSAqIGdyYXZpdHlGb3JjZTtcblxuICAgICAgICB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tub2RlLmlkXS54ICs9IGZ4O1xuICAgICAgICB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tub2RlLmlkXS55ICs9IGZ5O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgZnVuY3Rpb24gY29uc3RydWN0cyB0aGUgYmFybmVzSHV0IHRyZWUgcmVjdXJzaXZlbHkuIEl0IGNyZWF0ZXMgdGhlIHJvb3QsIHNwbGl0cyBpdCBhbmQgc3RhcnRzIHBsYWNpbmcgdGhlIG5vZGVzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSBub2Rlc1xuICAgICAgICogQHBhcmFtIG5vZGVJbmRpY2VzXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2Zvcm1CYXJuZXNIdXRUcmVlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2Zvcm1CYXJuZXNIdXRUcmVlKG5vZGVzLCBub2RlSW5kaWNlcykge1xuICAgICAgICB2YXIgbm9kZSA9IHZvaWQgMDtcbiAgICAgICAgdmFyIG5vZGVDb3VudCA9IG5vZGVJbmRpY2VzLmxlbmd0aDtcblxuICAgICAgICB2YXIgbWluWCA9IG5vZGVzW25vZGVJbmRpY2VzWzBdXS54O1xuICAgICAgICB2YXIgbWluWSA9IG5vZGVzW25vZGVJbmRpY2VzWzBdXS55O1xuICAgICAgICB2YXIgbWF4WCA9IG5vZGVzW25vZGVJbmRpY2VzWzBdXS54O1xuICAgICAgICB2YXIgbWF4WSA9IG5vZGVzW25vZGVJbmRpY2VzWzBdXS55O1xuXG4gICAgICAgIC8vIGdldCB0aGUgcmFuZ2Ugb2YgdGhlIG5vZGVzXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbm9kZUNvdW50OyBpKyspIHtcbiAgICAgICAgICB2YXIgeCA9IG5vZGVzW25vZGVJbmRpY2VzW2ldXS54O1xuICAgICAgICAgIHZhciB5ID0gbm9kZXNbbm9kZUluZGljZXNbaV1dLnk7XG4gICAgICAgICAgaWYgKG5vZGVzW25vZGVJbmRpY2VzW2ldXS5vcHRpb25zLm1hc3MgPiAwKSB7XG4gICAgICAgICAgICBpZiAoeCA8IG1pblgpIHtcbiAgICAgICAgICAgICAgbWluWCA9IHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeCA+IG1heFgpIHtcbiAgICAgICAgICAgICAgbWF4WCA9IHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeSA8IG1pblkpIHtcbiAgICAgICAgICAgICAgbWluWSA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeSA+IG1heFkpIHtcbiAgICAgICAgICAgICAgbWF4WSA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIG1ha2UgdGhlIHJhbmdlIGEgc3F1YXJlXG4gICAgICAgIHZhciBzaXplRGlmZiA9IE1hdGguYWJzKG1heFggLSBtaW5YKSAtIE1hdGguYWJzKG1heFkgLSBtaW5ZKTsgLy8gZGlmZmVyZW5jZSBiZXR3ZWVuIFggYW5kIFlcbiAgICAgICAgaWYgKHNpemVEaWZmID4gMCkge1xuICAgICAgICAgIG1pblkgLT0gMC41ICogc2l6ZURpZmY7XG4gICAgICAgICAgbWF4WSArPSAwLjUgKiBzaXplRGlmZjtcbiAgICAgICAgfSAvLyB4U2l6ZSA+IHlTaXplXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWluWCArPSAwLjUgKiBzaXplRGlmZjtcbiAgICAgICAgICAgIG1heFggLT0gMC41ICogc2l6ZURpZmY7XG4gICAgICAgICAgfSAvLyB4U2l6ZSA8IHlTaXplXG5cbiAgICAgICAgdmFyIG1pbmltdW1UcmVlU2l6ZSA9IDFlLTU7XG4gICAgICAgIHZhciByb290U2l6ZSA9IE1hdGgubWF4KG1pbmltdW1UcmVlU2l6ZSwgTWF0aC5hYnMobWF4WCAtIG1pblgpKTtcbiAgICAgICAgdmFyIGhhbGZSb290U2l6ZSA9IDAuNSAqIHJvb3RTaXplO1xuICAgICAgICB2YXIgY2VudGVyWCA9IDAuNSAqIChtaW5YICsgbWF4WCksXG4gICAgICAgICAgICBjZW50ZXJZID0gMC41ICogKG1pblkgKyBtYXhZKTtcblxuICAgICAgICAvLyBjb25zdHJ1Y3QgdGhlIGJhcm5lc0h1dFRyZWVcbiAgICAgICAgdmFyIGJhcm5lc0h1dFRyZWUgPSB7XG4gICAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgY2VudGVyT2ZNYXNzOiB7IHg6IDAsIHk6IDAgfSxcbiAgICAgICAgICAgIG1hc3M6IDAsXG4gICAgICAgICAgICByYW5nZToge1xuICAgICAgICAgICAgICBtaW5YOiBjZW50ZXJYIC0gaGFsZlJvb3RTaXplLCBtYXhYOiBjZW50ZXJYICsgaGFsZlJvb3RTaXplLFxuICAgICAgICAgICAgICBtaW5ZOiBjZW50ZXJZIC0gaGFsZlJvb3RTaXplLCBtYXhZOiBjZW50ZXJZICsgaGFsZlJvb3RTaXplXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2l6ZTogcm9vdFNpemUsXG4gICAgICAgICAgICBjYWxjU2l6ZTogMSAvIHJvb3RTaXplLFxuICAgICAgICAgICAgY2hpbGRyZW46IHsgZGF0YTogbnVsbCB9LFxuICAgICAgICAgICAgbWF4V2lkdGg6IDAsXG4gICAgICAgICAgICBsZXZlbDogMCxcbiAgICAgICAgICAgIGNoaWxkcmVuQ291bnQ6IDRcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3NwbGl0QnJhbmNoKGJhcm5lc0h1dFRyZWUucm9vdCk7XG5cbiAgICAgICAgLy8gcGxhY2UgdGhlIG5vZGVzIG9uZSBieSBvbmUgcmVjdXJzaXZlbHlcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5vZGVDb3VudDsgX2krKykge1xuICAgICAgICAgIG5vZGUgPSBub2Rlc1tub2RlSW5kaWNlc1tfaV1dO1xuICAgICAgICAgIGlmIChub2RlLm9wdGlvbnMubWFzcyA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3BsYWNlSW5UcmVlKGJhcm5lc0h1dFRyZWUucm9vdCwgbm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWFrZSBnbG9iYWxcbiAgICAgICAgcmV0dXJuIGJhcm5lc0h1dFRyZWU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogdGhpcyB1cGRhdGVzIHRoZSBtYXNzIG9mIGEgYnJhbmNoLiB0aGlzIGlzIGluY3JlYXNlZCBieSBhZGRpbmcgYSBub2RlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSBwYXJlbnRCcmFuY2hcbiAgICAgICAqIEBwYXJhbSBub2RlXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3VwZGF0ZUJyYW5jaE1hc3NcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlQnJhbmNoTWFzcyhwYXJlbnRCcmFuY2gsIG5vZGUpIHtcbiAgICAgICAgdmFyIHRvdGFsTWFzcyA9IHBhcmVudEJyYW5jaC5tYXNzICsgbm9kZS5vcHRpb25zLm1hc3M7XG4gICAgICAgIHZhciB0b3RhbE1hc3NJbnYgPSAxIC8gdG90YWxNYXNzO1xuXG4gICAgICAgIHBhcmVudEJyYW5jaC5jZW50ZXJPZk1hc3MueCA9IHBhcmVudEJyYW5jaC5jZW50ZXJPZk1hc3MueCAqIHBhcmVudEJyYW5jaC5tYXNzICsgbm9kZS54ICogbm9kZS5vcHRpb25zLm1hc3M7XG4gICAgICAgIHBhcmVudEJyYW5jaC5jZW50ZXJPZk1hc3MueCAqPSB0b3RhbE1hc3NJbnY7XG5cbiAgICAgICAgcGFyZW50QnJhbmNoLmNlbnRlck9mTWFzcy55ID0gcGFyZW50QnJhbmNoLmNlbnRlck9mTWFzcy55ICogcGFyZW50QnJhbmNoLm1hc3MgKyBub2RlLnkgKiBub2RlLm9wdGlvbnMubWFzcztcbiAgICAgICAgcGFyZW50QnJhbmNoLmNlbnRlck9mTWFzcy55ICo9IHRvdGFsTWFzc0ludjtcblxuICAgICAgICBwYXJlbnRCcmFuY2gubWFzcyA9IHRvdGFsTWFzcztcbiAgICAgICAgdmFyIGJpZ2dlc3RTaXplID0gTWF0aC5tYXgoTWF0aC5tYXgobm9kZS5oZWlnaHQsIG5vZGUucmFkaXVzKSwgbm9kZS53aWR0aCk7XG4gICAgICAgIHBhcmVudEJyYW5jaC5tYXhXaWR0aCA9IHBhcmVudEJyYW5jaC5tYXhXaWR0aCA8IGJpZ2dlc3RTaXplID8gYmlnZ2VzdFNpemUgOiBwYXJlbnRCcmFuY2gubWF4V2lkdGg7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogZGV0ZXJtaW5lIGluIHdoaWNoIGJyYW5jaCB0aGUgbm9kZSB3aWxsIGJlIHBsYWNlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gcGFyZW50QnJhbmNoXG4gICAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAgICogQHBhcmFtIHNraXBNYXNzVXBkYXRlXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3BsYWNlSW5UcmVlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3BsYWNlSW5UcmVlKHBhcmVudEJyYW5jaCwgbm9kZSwgc2tpcE1hc3NVcGRhdGUpIHtcbiAgICAgICAgaWYgKHNraXBNYXNzVXBkYXRlICE9IHRydWUgfHwgc2tpcE1hc3NVcGRhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgbWFzcyBvZiB0aGUgYnJhbmNoLlxuICAgICAgICAgIHRoaXMuX3VwZGF0ZUJyYW5jaE1hc3MocGFyZW50QnJhbmNoLCBub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJlbnRCcmFuY2guY2hpbGRyZW4uTlcucmFuZ2UubWF4WCA+IG5vZGUueCkge1xuICAgICAgICAgIC8vIGluIE5XIG9yIFNXXG4gICAgICAgICAgaWYgKHBhcmVudEJyYW5jaC5jaGlsZHJlbi5OVy5yYW5nZS5tYXhZID4gbm9kZS55KSB7XG4gICAgICAgICAgICAvLyBpbiBOV1xuICAgICAgICAgICAgdGhpcy5fcGxhY2VJblJlZ2lvbihwYXJlbnRCcmFuY2gsIG5vZGUsIFwiTldcIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGluIFNXXG4gICAgICAgICAgICB0aGlzLl9wbGFjZUluUmVnaW9uKHBhcmVudEJyYW5jaCwgbm9kZSwgXCJTV1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaW4gTkUgb3IgU0VcbiAgICAgICAgICBpZiAocGFyZW50QnJhbmNoLmNoaWxkcmVuLk5XLnJhbmdlLm1heFkgPiBub2RlLnkpIHtcbiAgICAgICAgICAgIC8vIGluIE5FXG4gICAgICAgICAgICB0aGlzLl9wbGFjZUluUmVnaW9uKHBhcmVudEJyYW5jaCwgbm9kZSwgXCJORVwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaW4gU0VcbiAgICAgICAgICAgIHRoaXMuX3BsYWNlSW5SZWdpb24ocGFyZW50QnJhbmNoLCBub2RlLCBcIlNFXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGFjdHVhbGx5IHBsYWNlIHRoZSBub2RlIGluIGEgcmVnaW9uIChvciBicmFuY2gpXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHBhcmVudEJyYW5jaFxuICAgICAgICogQHBhcmFtIG5vZGVcbiAgICAgICAqIEBwYXJhbSByZWdpb25cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfcGxhY2VJblJlZ2lvblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9wbGFjZUluUmVnaW9uKHBhcmVudEJyYW5jaCwgbm9kZSwgcmVnaW9uKSB7XG4gICAgICAgIHN3aXRjaCAocGFyZW50QnJhbmNoLmNoaWxkcmVuW3JlZ2lvbl0uY2hpbGRyZW5Db3VudCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIC8vIHBsYWNlIG5vZGUgaGVyZVxuICAgICAgICAgICAgcGFyZW50QnJhbmNoLmNoaWxkcmVuW3JlZ2lvbl0uY2hpbGRyZW4uZGF0YSA9IG5vZGU7XG4gICAgICAgICAgICBwYXJlbnRCcmFuY2guY2hpbGRyZW5bcmVnaW9uXS5jaGlsZHJlbkNvdW50ID0gMTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUJyYW5jaE1hc3MocGFyZW50QnJhbmNoLmNoaWxkcmVuW3JlZ2lvbl0sIG5vZGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgLy8gY29udmVydCBpbnRvIGNoaWxkcmVuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgdHdvIG5vZGVzIGV4YWN0bHkgb3ZlcmxhcHBpbmcgKG9uIGluaXQsIG9uIG9wZW5pbmcgb2YgY2x1c3RlciBldGMuKVxuICAgICAgICAgICAgLy8gd2UgbW92ZSBvbmUgbm9kZSBhIGxpdHRsZSBiaXQgYW5kIHdlIGRvIG5vdCBwdXQgaXQgaW4gdGhlIHRyZWUuXG4gICAgICAgICAgICBpZiAocGFyZW50QnJhbmNoLmNoaWxkcmVuW3JlZ2lvbl0uY2hpbGRyZW4uZGF0YS54ID09PSBub2RlLnggJiYgcGFyZW50QnJhbmNoLmNoaWxkcmVuW3JlZ2lvbl0uY2hpbGRyZW4uZGF0YS55ID09PSBub2RlLnkpIHtcbiAgICAgICAgICAgICAgbm9kZS54ICs9IHRoaXMuc2VlZGVkUmFuZG9tKCk7XG4gICAgICAgICAgICAgIG5vZGUueSArPSB0aGlzLnNlZWRlZFJhbmRvbSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fc3BsaXRCcmFuY2gocGFyZW50QnJhbmNoLmNoaWxkcmVuW3JlZ2lvbl0pO1xuICAgICAgICAgICAgICB0aGlzLl9wbGFjZUluVHJlZShwYXJlbnRCcmFuY2guY2hpbGRyZW5bcmVnaW9uXSwgbm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAvLyBwbGFjZSBpbiBicmFuY2hcbiAgICAgICAgICAgIHRoaXMuX3BsYWNlSW5UcmVlKHBhcmVudEJyYW5jaC5jaGlsZHJlbltyZWdpb25dLCBub2RlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogdGhpcyBmdW5jdGlvbiBzcGxpdHMgYSBicmFuY2ggaW50byA0IHN1YiBicmFuY2hlcy4gSWYgdGhlIGJyYW5jaCBjb250YWluZWQgYSBub2RlLCB3ZSBwbGFjZSBpdCBpbiB0aGUgc3ViYnJhbmNoXG4gICAgICAgKiBhZnRlciB0aGUgc3BsaXQgaXMgY29tcGxldGUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHBhcmVudEJyYW5jaFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9zcGxpdEJyYW5jaFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zcGxpdEJyYW5jaChwYXJlbnRCcmFuY2gpIHtcbiAgICAgICAgLy8gaWYgdGhlIGJyYW5jaCBpcyBzaGFkZWQgd2l0aCBhIG5vZGUsIHJlcGxhY2UgdGhlIG5vZGUgaW4gdGhlIG5ldyBzdWJzZXQuXG4gICAgICAgIHZhciBjb250YWluZWROb2RlID0gbnVsbDtcbiAgICAgICAgaWYgKHBhcmVudEJyYW5jaC5jaGlsZHJlbkNvdW50ID09PSAxKSB7XG4gICAgICAgICAgY29udGFpbmVkTm9kZSA9IHBhcmVudEJyYW5jaC5jaGlsZHJlbi5kYXRhO1xuICAgICAgICAgIHBhcmVudEJyYW5jaC5tYXNzID0gMDtcbiAgICAgICAgICBwYXJlbnRCcmFuY2guY2VudGVyT2ZNYXNzLnggPSAwO1xuICAgICAgICAgIHBhcmVudEJyYW5jaC5jZW50ZXJPZk1hc3MueSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50QnJhbmNoLmNoaWxkcmVuQ291bnQgPSA0O1xuICAgICAgICBwYXJlbnRCcmFuY2guY2hpbGRyZW4uZGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2luc2VydFJlZ2lvbihwYXJlbnRCcmFuY2gsIFwiTldcIik7XG4gICAgICAgIHRoaXMuX2luc2VydFJlZ2lvbihwYXJlbnRCcmFuY2gsIFwiTkVcIik7XG4gICAgICAgIHRoaXMuX2luc2VydFJlZ2lvbihwYXJlbnRCcmFuY2gsIFwiU1dcIik7XG4gICAgICAgIHRoaXMuX2luc2VydFJlZ2lvbihwYXJlbnRCcmFuY2gsIFwiU0VcIik7XG5cbiAgICAgICAgaWYgKGNvbnRhaW5lZE5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuX3BsYWNlSW5UcmVlKHBhcmVudEJyYW5jaCwgY29udGFpbmVkTm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIGZ1bmN0aW9uIHN1YmRpdmlkZXMgdGhlIHJlZ2lvbiBpbnRvIGZvdXIgbmV3IHNlZ21lbnRzLlxuICAgICAgICogU3BlY2lmaWNhbGx5LCB0aGlzIGluc2VydHMgYSBzaW5nbGUgbmV3IHNlZ21lbnQuXG4gICAgICAgKiBJdCBmaWxscyB0aGUgY2hpbGRyZW4gc2VjdGlvbiBvZiB0aGUgcGFyZW50QnJhbmNoXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHBhcmVudEJyYW5jaFxuICAgICAgICogQHBhcmFtIHJlZ2lvblxuICAgICAgICogQHBhcmFtIHBhcmVudFJhbmdlXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2luc2VydFJlZ2lvblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pbnNlcnRSZWdpb24ocGFyZW50QnJhbmNoLCByZWdpb24pIHtcbiAgICAgICAgdmFyIG1pblggPSB2b2lkIDAsXG4gICAgICAgICAgICBtYXhYID0gdm9pZCAwLFxuICAgICAgICAgICAgbWluWSA9IHZvaWQgMCxcbiAgICAgICAgICAgIG1heFkgPSB2b2lkIDA7XG4gICAgICAgIHZhciBjaGlsZFNpemUgPSAwLjUgKiBwYXJlbnRCcmFuY2guc2l6ZTtcbiAgICAgICAgc3dpdGNoIChyZWdpb24pIHtcbiAgICAgICAgICBjYXNlIFwiTldcIjpcbiAgICAgICAgICAgIG1pblggPSBwYXJlbnRCcmFuY2gucmFuZ2UubWluWDtcbiAgICAgICAgICAgIG1heFggPSBwYXJlbnRCcmFuY2gucmFuZ2UubWluWCArIGNoaWxkU2l6ZTtcbiAgICAgICAgICAgIG1pblkgPSBwYXJlbnRCcmFuY2gucmFuZ2UubWluWTtcbiAgICAgICAgICAgIG1heFkgPSBwYXJlbnRCcmFuY2gucmFuZ2UubWluWSArIGNoaWxkU2l6ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJORVwiOlxuICAgICAgICAgICAgbWluWCA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5YICsgY2hpbGRTaXplO1xuICAgICAgICAgICAgbWF4WCA9IHBhcmVudEJyYW5jaC5yYW5nZS5tYXhYO1xuICAgICAgICAgICAgbWluWSA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5ZO1xuICAgICAgICAgICAgbWF4WSA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5ZICsgY2hpbGRTaXplO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIlNXXCI6XG4gICAgICAgICAgICBtaW5YID0gcGFyZW50QnJhbmNoLnJhbmdlLm1pblg7XG4gICAgICAgICAgICBtYXhYID0gcGFyZW50QnJhbmNoLnJhbmdlLm1pblggKyBjaGlsZFNpemU7XG4gICAgICAgICAgICBtaW5ZID0gcGFyZW50QnJhbmNoLnJhbmdlLm1pblkgKyBjaGlsZFNpemU7XG4gICAgICAgICAgICBtYXhZID0gcGFyZW50QnJhbmNoLnJhbmdlLm1heFk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiU0VcIjpcbiAgICAgICAgICAgIG1pblggPSBwYXJlbnRCcmFuY2gucmFuZ2UubWluWCArIGNoaWxkU2l6ZTtcbiAgICAgICAgICAgIG1heFggPSBwYXJlbnRCcmFuY2gucmFuZ2UubWF4WDtcbiAgICAgICAgICAgIG1pblkgPSBwYXJlbnRCcmFuY2gucmFuZ2UubWluWSArIGNoaWxkU2l6ZTtcbiAgICAgICAgICAgIG1heFkgPSBwYXJlbnRCcmFuY2gucmFuZ2UubWF4WTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50QnJhbmNoLmNoaWxkcmVuW3JlZ2lvbl0gPSB7XG4gICAgICAgICAgY2VudGVyT2ZNYXNzOiB7IHg6IDAsIHk6IDAgfSxcbiAgICAgICAgICBtYXNzOiAwLFxuICAgICAgICAgIHJhbmdlOiB7IG1pblg6IG1pblgsIG1heFg6IG1heFgsIG1pblk6IG1pblksIG1heFk6IG1heFkgfSxcbiAgICAgICAgICBzaXplOiAwLjUgKiBwYXJlbnRCcmFuY2guc2l6ZSxcbiAgICAgICAgICBjYWxjU2l6ZTogMiAqIHBhcmVudEJyYW5jaC5jYWxjU2l6ZSxcbiAgICAgICAgICBjaGlsZHJlbjogeyBkYXRhOiBudWxsIH0sXG4gICAgICAgICAgbWF4V2lkdGg6IDAsXG4gICAgICAgICAgbGV2ZWw6IHBhcmVudEJyYW5jaC5sZXZlbCArIDEsXG4gICAgICAgICAgY2hpbGRyZW5Db3VudDogMFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAgREVCVUdHSU5HIEJFTE9XICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgZm9yIGRlYnVnZ2luZyBwdXJwb3NlZCwgaXQgZHJhd3MgdGhlIHRyZWUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIGN0eFxuICAgICAgICogQHBhcmFtIGNvbG9yXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2RlYnVnXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2RlYnVnKGN0eCwgY29sb3IpIHtcbiAgICAgICAgaWYgKHRoaXMuYmFybmVzSHV0VHJlZSAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICBjdHgubGluZVdpZHRoID0gMTtcblxuICAgICAgICAgIHRoaXMuX2RyYXdCcmFuY2godGhpcy5iYXJuZXNIdXRUcmVlLnJvb3QsIGN0eCwgY29sb3IpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBmdW5jdGlvbiBpcyBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLiBJdCBkcmF3cyB0aGUgYnJhbmNoZXMgcmVjdXJzaXZlbHkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIGJyYW5jaFxuICAgICAgICogQHBhcmFtIGN0eFxuICAgICAgICogQHBhcmFtIGNvbG9yXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2RyYXdCcmFuY2hcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd0JyYW5jaChicmFuY2gsIGN0eCwgY29sb3IpIHtcbiAgICAgICAgaWYgKGNvbG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb2xvciA9IFwiI0ZGMDAwMFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJyYW5jaC5jaGlsZHJlbkNvdW50ID09PSA0KSB7XG4gICAgICAgICAgdGhpcy5fZHJhd0JyYW5jaChicmFuY2guY2hpbGRyZW4uTlcsIGN0eCk7XG4gICAgICAgICAgdGhpcy5fZHJhd0JyYW5jaChicmFuY2guY2hpbGRyZW4uTkUsIGN0eCk7XG4gICAgICAgICAgdGhpcy5fZHJhd0JyYW5jaChicmFuY2guY2hpbGRyZW4uU0UsIGN0eCk7XG4gICAgICAgICAgdGhpcy5fZHJhd0JyYW5jaChicmFuY2guY2hpbGRyZW4uU1csIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhicmFuY2gucmFuZ2UubWluWCwgYnJhbmNoLnJhbmdlLm1pblkpO1xuICAgICAgICBjdHgubGluZVRvKGJyYW5jaC5yYW5nZS5tYXhYLCBicmFuY2gucmFuZ2UubWluWSk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8oYnJhbmNoLnJhbmdlLm1heFgsIGJyYW5jaC5yYW5nZS5taW5ZKTtcbiAgICAgICAgY3R4LmxpbmVUbyhicmFuY2gucmFuZ2UubWF4WCwgYnJhbmNoLnJhbmdlLm1heFkpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKGJyYW5jaC5yYW5nZS5tYXhYLCBicmFuY2gucmFuZ2UubWF4WSk7XG4gICAgICAgIGN0eC5saW5lVG8oYnJhbmNoLnJhbmdlLm1pblgsIGJyYW5jaC5yYW5nZS5tYXhZKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhicmFuY2gucmFuZ2UubWluWCwgYnJhbmNoLnJhbmdlLm1heFkpO1xuICAgICAgICBjdHgubGluZVRvKGJyYW5jaC5yYW5nZS5taW5YLCBicmFuY2gucmFuZ2UubWluWSk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgICAvKlxuICAgICAgICAgaWYgKGJyYW5jaC5tYXNzID4gMCkge1xuICAgICAgICAgY3R4LmNpcmNsZShicmFuY2guY2VudGVyT2ZNYXNzLngsIGJyYW5jaC5jZW50ZXJPZk1hc3MueSwgMypicmFuY2gubWFzcyk7XG4gICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICB9XG4gICAgICAgICAqL1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBCYXJuZXNIdXRTb2x2ZXI7XG4gIH0oKTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBCYXJuZXNIdXRTb2x2ZXI7XG5cbi8qKiovIH0sXG4vKiA5NSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIHZhciBSZXB1bHNpb25Tb2x2ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVwdWxzaW9uU29sdmVyKGJvZHksIHBoeXNpY3NCb2R5LCBvcHRpb25zKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVwdWxzaW9uU29sdmVyKTtcblxuICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgIHRoaXMucGh5c2ljc0JvZHkgPSBwaHlzaWNzQm9keTtcbiAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoUmVwdWxzaW9uU29sdmVyLCBbe1xuICAgICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogQ2FsY3VsYXRlIHRoZSBmb3JjZXMgdGhlIG5vZGVzIGFwcGx5IG9uIGVhY2ggb3RoZXIgYmFzZWQgb24gYSByZXB1bHNpb24gZmllbGQuXG4gICAgICAgKiBUaGlzIGZpZWxkIGlzIGxpbmVhcmx5IGFwcHJveGltYXRlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic29sdmVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzb2x2ZSgpIHtcbiAgICAgICAgdmFyIGR4LCBkeSwgZGlzdGFuY2UsIGZ4LCBmeSwgcmVwdWxzaW5nRm9yY2UsIG5vZGUxLCBub2RlMjtcblxuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICAgIHZhciBub2RlSW5kaWNlcyA9IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzO1xuICAgICAgICB2YXIgZm9yY2VzID0gdGhpcy5waHlzaWNzQm9keS5mb3JjZXM7XG5cbiAgICAgICAgLy8gcmVwdWxzaW5nIGZvcmNlcyBiZXR3ZWVuIG5vZGVzXG4gICAgICAgIHZhciBub2RlRGlzdGFuY2UgPSB0aGlzLm9wdGlvbnMubm9kZURpc3RhbmNlO1xuXG4gICAgICAgIC8vIGFwcHJveGltYXRpb24gY29uc3RhbnRzXG4gICAgICAgIHZhciBhID0gLTIgLyAzIC8gbm9kZURpc3RhbmNlO1xuICAgICAgICB2YXIgYiA9IDQgLyAzO1xuXG4gICAgICAgIC8vIHdlIGxvb3AgZnJvbSBpIG92ZXIgYWxsIGJ1dCB0aGUgbGFzdCBlbnRyZWUgaW4gdGhlIGFycmF5XG4gICAgICAgIC8vIGogbG9vcHMgZnJvbSBpKzEgdG8gdGhlIGxhc3QuIFRoaXMgd2F5IHdlIGRvIG5vdCBkb3VibGUgY291bnQgYW55IG9mIHRoZSBpbmRpY2VzLCBub3IgaSA9PT0galxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVJbmRpY2VzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgIG5vZGUxID0gbm9kZXNbbm9kZUluZGljZXNbaV1dO1xuICAgICAgICAgIGZvciAodmFyIGogPSBpICsgMTsgaiA8IG5vZGVJbmRpY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBub2RlMiA9IG5vZGVzW25vZGVJbmRpY2VzW2pdXTtcblxuICAgICAgICAgICAgZHggPSBub2RlMi54IC0gbm9kZTEueDtcbiAgICAgICAgICAgIGR5ID0gbm9kZTIueSAtIG5vZGUxLnk7XG4gICAgICAgICAgICBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgICAgICAgICAgIC8vIHNhbWUgY29uZGl0aW9uIGFzIEJhcm5lc0h1dFNvbHZlciwgbWFraW5nIHN1cmUgbm9kZXMgYXJlIG5ldmVyIDEwMCUgb3ZlcmxhcHBpbmcuXG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPT09IDApIHtcbiAgICAgICAgICAgICAgZGlzdGFuY2UgPSAwLjEgKiBNYXRoLnJhbmRvbSgpO1xuICAgICAgICAgICAgICBkeCA9IGRpc3RhbmNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPCAyICogbm9kZURpc3RhbmNlKSB7XG4gICAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8IDAuNSAqIG5vZGVEaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHJlcHVsc2luZ0ZvcmNlID0gMS4wO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcHVsc2luZ0ZvcmNlID0gYSAqIGRpc3RhbmNlICsgYjsgLy8gbGluZWFyIGFwcHJveCBvZiAgMSAvICgxICsgTWF0aC5leHAoKGRpc3RhbmNlIC8gbm9kZURpc3RhbmNlIC0gMSkgKiBzdGVlcG5lc3MpKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlcHVsc2luZ0ZvcmNlID0gcmVwdWxzaW5nRm9yY2UgLyBkaXN0YW5jZTtcblxuICAgICAgICAgICAgICBmeCA9IGR4ICogcmVwdWxzaW5nRm9yY2U7XG4gICAgICAgICAgICAgIGZ5ID0gZHkgKiByZXB1bHNpbmdGb3JjZTtcblxuICAgICAgICAgICAgICBmb3JjZXNbbm9kZTEuaWRdLnggLT0gZng7XG4gICAgICAgICAgICAgIGZvcmNlc1tub2RlMS5pZF0ueSAtPSBmeTtcbiAgICAgICAgICAgICAgZm9yY2VzW25vZGUyLmlkXS54ICs9IGZ4O1xuICAgICAgICAgICAgICBmb3JjZXNbbm9kZTIuaWRdLnkgKz0gZnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFJlcHVsc2lvblNvbHZlcjtcbiAgfSgpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IFJlcHVsc2lvblNvbHZlcjtcblxuLyoqKi8gfSxcbi8qIDk2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuICBcInVzZSBzdHJpY3RcIjtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgdmFyIEhpZXJhcmNoaWNhbFJlcHVsc2lvblNvbHZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIaWVyYXJjaGljYWxSZXB1bHNpb25Tb2x2ZXIoYm9keSwgcGh5c2ljc0JvZHksIG9wdGlvbnMpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIaWVyYXJjaGljYWxSZXB1bHNpb25Tb2x2ZXIpO1xuXG4gICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgdGhpcy5waHlzaWNzQm9keSA9IHBoeXNpY3NCb2R5O1xuICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhIaWVyYXJjaGljYWxSZXB1bHNpb25Tb2x2ZXIsIFt7XG4gICAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGN1bGF0ZSB0aGUgZm9yY2VzIHRoZSBub2RlcyBhcHBseSBvbiBlYWNoIG90aGVyIGJhc2VkIG9uIGEgcmVwdWxzaW9uIGZpZWxkLlxuICAgICAgICogVGhpcyBmaWVsZCBpcyBsaW5lYXJseSBhcHByb3hpbWF0ZWQuXG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInNvbHZlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc29sdmUoKSB7XG4gICAgICAgIHZhciBkeCwgZHksIGRpc3RhbmNlLCBmeCwgZnksIHJlcHVsc2luZ0ZvcmNlLCBub2RlMSwgbm9kZTIsIGksIGo7XG5cbiAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgICB2YXIgbm9kZUluZGljZXMgPSB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcztcbiAgICAgICAgdmFyIGZvcmNlcyA9IHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzO1xuXG4gICAgICAgIC8vIHJlcHVsc2luZyBmb3JjZXMgYmV0d2VlbiBub2Rlc1xuICAgICAgICB2YXIgbm9kZURpc3RhbmNlID0gdGhpcy5vcHRpb25zLm5vZGVEaXN0YW5jZTtcblxuICAgICAgICAvLyB3ZSBsb29wIGZyb20gaSBvdmVyIGFsbCBidXQgdGhlIGxhc3QgZW50cmVlIGluIHRoZSBhcnJheVxuICAgICAgICAvLyBqIGxvb3BzIGZyb20gaSsxIHRvIHRoZSBsYXN0LiBUaGlzIHdheSB3ZSBkbyBub3QgZG91YmxlIGNvdW50IGFueSBvZiB0aGUgaW5kaWNlcywgbm9yIGkgPT09IGpcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5vZGVJbmRpY2VzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgIG5vZGUxID0gbm9kZXNbbm9kZUluZGljZXNbaV1dO1xuICAgICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgbm9kZUluZGljZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIG5vZGUyID0gbm9kZXNbbm9kZUluZGljZXNbal1dO1xuXG4gICAgICAgICAgICAvLyBub2RlcyBvbmx5IGFmZmVjdCBub2RlcyBvbiB0aGVpciBsZXZlbFxuICAgICAgICAgICAgaWYgKG5vZGUxLmxldmVsID09PSBub2RlMi5sZXZlbCkge1xuICAgICAgICAgICAgICBkeCA9IG5vZGUyLnggLSBub2RlMS54O1xuICAgICAgICAgICAgICBkeSA9IG5vZGUyLnkgLSBub2RlMS55O1xuICAgICAgICAgICAgICBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgICAgICAgICAgICAgdmFyIHN0ZWVwbmVzcyA9IDAuMDU7XG4gICAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8IG5vZGVEaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHJlcHVsc2luZ0ZvcmNlID0gLU1hdGgucG93KHN0ZWVwbmVzcyAqIGRpc3RhbmNlLCAyKSArIE1hdGgucG93KHN0ZWVwbmVzcyAqIG5vZGVEaXN0YW5jZSwgMik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVwdWxzaW5nRm9yY2UgPSAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSBmb3JjZSB3aXRoXG4gICAgICAgICAgICAgIGlmIChkaXN0YW5jZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gMC4wMTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXB1bHNpbmdGb3JjZSA9IHJlcHVsc2luZ0ZvcmNlIC8gZGlzdGFuY2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZnggPSBkeCAqIHJlcHVsc2luZ0ZvcmNlO1xuICAgICAgICAgICAgICBmeSA9IGR5ICogcmVwdWxzaW5nRm9yY2U7XG5cbiAgICAgICAgICAgICAgZm9yY2VzW25vZGUxLmlkXS54IC09IGZ4O1xuICAgICAgICAgICAgICBmb3JjZXNbbm9kZTEuaWRdLnkgLT0gZnk7XG4gICAgICAgICAgICAgIGZvcmNlc1tub2RlMi5pZF0ueCArPSBmeDtcbiAgICAgICAgICAgICAgZm9yY2VzW25vZGUyLmlkXS55ICs9IGZ5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBIaWVyYXJjaGljYWxSZXB1bHNpb25Tb2x2ZXI7XG4gIH0oKTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBIaWVyYXJjaGljYWxSZXB1bHNpb25Tb2x2ZXI7XG5cbi8qKiovIH0sXG4vKiA5NyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIHZhciBTcHJpbmdTb2x2ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3ByaW5nU29sdmVyKGJvZHksIHBoeXNpY3NCb2R5LCBvcHRpb25zKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3ByaW5nU29sdmVyKTtcblxuICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgIHRoaXMucGh5c2ljc0JvZHkgPSBwaHlzaWNzQm9keTtcbiAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoU3ByaW5nU29sdmVyLCBbe1xuICAgICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgdGhlIHNwcmluZ2ZvcmNlcyBvbiB0aGUgbm9kZXMsIGFjY291bnRpbmcgZm9yIHRoZSBzdXBwb3J0IG5vZGVzLlxuICAgICAgICpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzb2x2ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNvbHZlKCkge1xuICAgICAgICB2YXIgZWRnZUxlbmd0aCA9IHZvaWQgMCxcbiAgICAgICAgICAgIGVkZ2UgPSB2b2lkIDA7XG4gICAgICAgIHZhciBlZGdlSW5kaWNlcyA9IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc0VkZ2VJbmRpY2VzO1xuICAgICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gICAgICAgIHZhciBub2RlMSA9IHZvaWQgMCxcbiAgICAgICAgICAgIG5vZGUyID0gdm9pZCAwLFxuICAgICAgICAgICAgbm9kZTMgPSB2b2lkIDA7XG5cbiAgICAgICAgLy8gZm9yY2VzIGNhdXNlZCBieSB0aGUgZWRnZXMsIG1vZGVsbGVkIGFzIHNwcmluZ3NcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGVkZ2UgPSBlZGdlc1tlZGdlSW5kaWNlc1tpXV07XG4gICAgICAgICAgaWYgKGVkZ2UuY29ubmVjdGVkID09PSB0cnVlICYmIGVkZ2UudG9JZCAhPT0gZWRnZS5mcm9tSWQpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgY2FsY3VsYXRlIGZvcmNlcyBpZiBub2RlcyBhcmUgaW4gdGhlIHNhbWUgc2VjdG9yXG4gICAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW2VkZ2UudG9JZF0gIT09IHVuZGVmaW5lZCAmJiB0aGlzLmJvZHkubm9kZXNbZWRnZS5mcm9tSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgaWYgKGVkZ2UuZWRnZVR5cGUudmlhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBlZGdlTGVuZ3RoID0gZWRnZS5vcHRpb25zLmxlbmd0aCA9PT0gdW5kZWZpbmVkID8gdGhpcy5vcHRpb25zLnNwcmluZ0xlbmd0aCA6IGVkZ2Uub3B0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbm9kZTEgPSBlZGdlLnRvO1xuICAgICAgICAgICAgICAgIG5vZGUyID0gZWRnZS5lZGdlVHlwZS52aWE7XG4gICAgICAgICAgICAgICAgbm9kZTMgPSBlZGdlLmZyb207XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVTcHJpbmdGb3JjZShub2RlMSwgbm9kZTIsIDAuNSAqIGVkZ2VMZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGN1bGF0ZVNwcmluZ0ZvcmNlKG5vZGUyLCBub2RlMywgMC41ICogZWRnZUxlbmd0aCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlICogMS41IGlzIGhlcmUgc28gdGhlIGVkZ2UgbG9va3MgYXMgbGFyZ2UgYXMgYSBzbW9vdGggZWRnZS4gSXQgZG9lcyBub3QgaW5pdGlhbGx5IGJlY2F1c2UgdGhlIHNtb290aCBlZGdlcyB1c2VcbiAgICAgICAgICAgICAgICAvLyB0aGUgc3VwcG9ydCBub2RlcyB3aGljaCBleGVydCBhIHJlcHVsc2l2ZSBmb3JjZSBvbiB0aGUgdG8gYW5kIGZyb20gbm9kZXMsIG1ha2luZyB0aGUgZWRnZSBhcHBlYXIgbGFyZ2VyLlxuICAgICAgICAgICAgICAgIGVkZ2VMZW5ndGggPSBlZGdlLm9wdGlvbnMubGVuZ3RoID09PSB1bmRlZmluZWQgPyB0aGlzLm9wdGlvbnMuc3ByaW5nTGVuZ3RoICogMS41IDogZWRnZS5vcHRpb25zLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVTcHJpbmdGb3JjZShlZGdlLmZyb20sIGVkZ2UudG8sIGVkZ2VMZW5ndGgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBpcyB0aGUgY29kZSBhY3R1YWxseSBwZXJmb3JtaW5nIHRoZSBjYWxjdWxhdGlvbiBmb3IgdGhlIGZ1bmN0aW9uIGFib3ZlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSBub2RlMVxuICAgICAgICogQHBhcmFtIG5vZGUyXG4gICAgICAgKiBAcGFyYW0gZWRnZUxlbmd0aFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9jYWxjdWxhdGVTcHJpbmdGb3JjZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxjdWxhdGVTcHJpbmdGb3JjZShub2RlMSwgbm9kZTIsIGVkZ2VMZW5ndGgpIHtcbiAgICAgICAgdmFyIGR4ID0gbm9kZTEueCAtIG5vZGUyLng7XG4gICAgICAgIHZhciBkeSA9IG5vZGUxLnkgLSBub2RlMi55O1xuICAgICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLm1heChNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpLCAwLjAxKTtcblxuICAgICAgICAvLyB0aGUgMS9kaXN0YW5jZSBpcyBzbyB0aGUgZnggYW5kIGZ5IGNhbiBiZSBjYWxjdWxhdGVkIHdpdGhvdXQgc2luZSBvciBjb3NpbmUuXG4gICAgICAgIHZhciBzcHJpbmdGb3JjZSA9IHRoaXMub3B0aW9ucy5zcHJpbmdDb25zdGFudCAqIChlZGdlTGVuZ3RoIC0gZGlzdGFuY2UpIC8gZGlzdGFuY2U7XG5cbiAgICAgICAgdmFyIGZ4ID0gZHggKiBzcHJpbmdGb3JjZTtcbiAgICAgICAgdmFyIGZ5ID0gZHkgKiBzcHJpbmdGb3JjZTtcblxuICAgICAgICAvLyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgb25lIG5vZGUgaXMgbm90IHBhcnQgb2YgdGhlIHBoeXNjaXNcbiAgICAgICAgaWYgKHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGUxLmlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5waHlzaWNzQm9keS5mb3JjZXNbbm9kZTEuaWRdLnggKz0gZng7XG4gICAgICAgICAgdGhpcy5waHlzaWNzQm9keS5mb3JjZXNbbm9kZTEuaWRdLnkgKz0gZnk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5waHlzaWNzQm9keS5mb3JjZXNbbm9kZTIuaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tub2RlMi5pZF0ueCAtPSBmeDtcbiAgICAgICAgICB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tub2RlMi5pZF0ueSAtPSBmeTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBTcHJpbmdTb2x2ZXI7XG4gIH0oKTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBTcHJpbmdTb2x2ZXI7XG5cbi8qKiovIH0sXG4vKiA5OCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIHZhciBIaWVyYXJjaGljYWxTcHJpbmdTb2x2ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSGllcmFyY2hpY2FsU3ByaW5nU29sdmVyKGJvZHksIHBoeXNpY3NCb2R5LCBvcHRpb25zKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSGllcmFyY2hpY2FsU3ByaW5nU29sdmVyKTtcblxuICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgIHRoaXMucGh5c2ljc0JvZHkgPSBwaHlzaWNzQm9keTtcbiAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoSGllcmFyY2hpY2FsU3ByaW5nU29sdmVyLCBbe1xuICAgICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgdGhlIHNwcmluZ2ZvcmNlcyBvbiB0aGUgbm9kZXMsIGFjY291bnRpbmcgZm9yIHRoZSBzdXBwb3J0IG5vZGVzLlxuICAgICAgICpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzb2x2ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNvbHZlKCkge1xuICAgICAgICB2YXIgZWRnZUxlbmd0aCwgZWRnZTtcbiAgICAgICAgdmFyIGR4LCBkeSwgZngsIGZ5LCBzcHJpbmdGb3JjZSwgZGlzdGFuY2U7XG4gICAgICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcbiAgICAgICAgdmFyIGZhY3RvciA9IDAuNTtcblxuICAgICAgICB2YXIgZWRnZUluZGljZXMgPSB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NFZGdlSW5kaWNlcztcbiAgICAgICAgdmFyIG5vZGVJbmRpY2VzID0gdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXM7XG4gICAgICAgIHZhciBmb3JjZXMgPSB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlcztcblxuICAgICAgICAvLyBpbml0aWFsaXplIHRoZSBzcHJpbmcgZm9yY2UgY291bnRlcnNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBub2RlSWQgPSBub2RlSW5kaWNlc1tpXTtcbiAgICAgICAgICBmb3JjZXNbbm9kZUlkXS5zcHJpbmdGeCA9IDA7XG4gICAgICAgICAgZm9yY2VzW25vZGVJZF0uc3ByaW5nRnkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZm9yY2VzIGNhdXNlZCBieSB0aGUgZWRnZXMsIG1vZGVsbGVkIGFzIHNwcmluZ3NcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGVkZ2VJbmRpY2VzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIGVkZ2UgPSBlZGdlc1tlZGdlSW5kaWNlc1tfaV1dO1xuICAgICAgICAgIGlmIChlZGdlLmNvbm5lY3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgZWRnZUxlbmd0aCA9IGVkZ2Uub3B0aW9ucy5sZW5ndGggPT09IHVuZGVmaW5lZCA/IHRoaXMub3B0aW9ucy5zcHJpbmdMZW5ndGggOiBlZGdlLm9wdGlvbnMubGVuZ3RoO1xuXG4gICAgICAgICAgICBkeCA9IGVkZ2UuZnJvbS54IC0gZWRnZS50by54O1xuICAgICAgICAgICAgZHkgPSBlZGdlLmZyb20ueSAtIGVkZ2UudG8ueTtcbiAgICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgICAgIGRpc3RhbmNlID0gZGlzdGFuY2UgPT09IDAgPyAwLjAxIDogZGlzdGFuY2U7XG5cbiAgICAgICAgICAgIC8vIHRoZSAxL2Rpc3RhbmNlIGlzIHNvIHRoZSBmeCBhbmQgZnkgY2FuIGJlIGNhbGN1bGF0ZWQgd2l0aG91dCBzaW5lIG9yIGNvc2luZS5cbiAgICAgICAgICAgIHNwcmluZ0ZvcmNlID0gdGhpcy5vcHRpb25zLnNwcmluZ0NvbnN0YW50ICogKGVkZ2VMZW5ndGggLSBkaXN0YW5jZSkgLyBkaXN0YW5jZTtcblxuICAgICAgICAgICAgZnggPSBkeCAqIHNwcmluZ0ZvcmNlO1xuICAgICAgICAgICAgZnkgPSBkeSAqIHNwcmluZ0ZvcmNlO1xuXG4gICAgICAgICAgICBpZiAoZWRnZS50by5sZXZlbCAhPSBlZGdlLmZyb20ubGV2ZWwpIHtcbiAgICAgICAgICAgICAgaWYgKGZvcmNlc1tlZGdlLnRvSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmb3JjZXNbZWRnZS50b0lkXS5zcHJpbmdGeCAtPSBmeDtcbiAgICAgICAgICAgICAgICBmb3JjZXNbZWRnZS50b0lkXS5zcHJpbmdGeSAtPSBmeTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZm9yY2VzW2VkZ2UuZnJvbUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZm9yY2VzW2VkZ2UuZnJvbUlkXS5zcHJpbmdGeCArPSBmeDtcbiAgICAgICAgICAgICAgICBmb3JjZXNbZWRnZS5mcm9tSWRdLnNwcmluZ0Z5ICs9IGZ5O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoZm9yY2VzW2VkZ2UudG9JZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZvcmNlc1tlZGdlLnRvSWRdLnggLT0gZmFjdG9yICogZng7XG4gICAgICAgICAgICAgICAgZm9yY2VzW2VkZ2UudG9JZF0ueSAtPSBmYWN0b3IgKiBmeTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZm9yY2VzW2VkZ2UuZnJvbUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZm9yY2VzW2VkZ2UuZnJvbUlkXS54ICs9IGZhY3RvciAqIGZ4O1xuICAgICAgICAgICAgICAgIGZvcmNlc1tlZGdlLmZyb21JZF0ueSArPSBmYWN0b3IgKiBmeTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vcm1hbGl6ZSBzcHJpbmcgZm9yY2VzXG4gICAgICAgIHZhciBzcHJpbmdGb3JjZSA9IDE7XG4gICAgICAgIHZhciBzcHJpbmdGeCwgc3ByaW5nRnk7XG4gICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5vZGVJbmRpY2VzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICB2YXIgX25vZGVJZCA9IG5vZGVJbmRpY2VzW19pMl07XG4gICAgICAgICAgc3ByaW5nRnggPSBNYXRoLm1pbihzcHJpbmdGb3JjZSwgTWF0aC5tYXgoLXNwcmluZ0ZvcmNlLCBmb3JjZXNbX25vZGVJZF0uc3ByaW5nRngpKTtcbiAgICAgICAgICBzcHJpbmdGeSA9IE1hdGgubWluKHNwcmluZ0ZvcmNlLCBNYXRoLm1heCgtc3ByaW5nRm9yY2UsIGZvcmNlc1tfbm9kZUlkXS5zcHJpbmdGeSkpO1xuXG4gICAgICAgICAgZm9yY2VzW19ub2RlSWRdLnggKz0gc3ByaW5nRng7XG4gICAgICAgICAgZm9yY2VzW19ub2RlSWRdLnkgKz0gc3ByaW5nRnk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXRhaW4gZW5lcmd5IGJhbGFuY2VcbiAgICAgICAgdmFyIHRvdGFsRnggPSAwO1xuICAgICAgICB2YXIgdG90YWxGeSA9IDA7XG4gICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IG5vZGVJbmRpY2VzLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgICAgICB2YXIgX25vZGVJZDIgPSBub2RlSW5kaWNlc1tfaTNdO1xuICAgICAgICAgIHRvdGFsRnggKz0gZm9yY2VzW19ub2RlSWQyXS54O1xuICAgICAgICAgIHRvdGFsRnkgKz0gZm9yY2VzW19ub2RlSWQyXS55O1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb3JyZWN0aW9uRnggPSB0b3RhbEZ4IC8gbm9kZUluZGljZXMubGVuZ3RoO1xuICAgICAgICB2YXIgY29ycmVjdGlvbkZ5ID0gdG90YWxGeSAvIG5vZGVJbmRpY2VzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBub2RlSW5kaWNlcy5sZW5ndGg7IF9pNCsrKSB7XG4gICAgICAgICAgdmFyIF9ub2RlSWQzID0gbm9kZUluZGljZXNbX2k0XTtcbiAgICAgICAgICBmb3JjZXNbX25vZGVJZDNdLnggLT0gY29ycmVjdGlvbkZ4O1xuICAgICAgICAgIGZvcmNlc1tfbm9kZUlkM10ueSAtPSBjb3JyZWN0aW9uRnk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gSGllcmFyY2hpY2FsU3ByaW5nU29sdmVyO1xuICB9KCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gSGllcmFyY2hpY2FsU3ByaW5nU29sdmVyO1xuXG4vKioqLyB9LFxuLyogOTkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICB2YXIgQ2VudHJhbEdyYXZpdHlTb2x2ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2VudHJhbEdyYXZpdHlTb2x2ZXIoYm9keSwgcGh5c2ljc0JvZHksIG9wdGlvbnMpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDZW50cmFsR3Jhdml0eVNvbHZlcik7XG5cbiAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICB0aGlzLnBoeXNpY3NCb2R5ID0gcGh5c2ljc0JvZHk7XG4gICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKENlbnRyYWxHcmF2aXR5U29sdmVyLCBbe1xuICAgICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic29sdmVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzb2x2ZSgpIHtcbiAgICAgICAgdmFyIGR4ID0gdm9pZCAwLFxuICAgICAgICAgICAgZHkgPSB2b2lkIDAsXG4gICAgICAgICAgICBkaXN0YW5jZSA9IHZvaWQgMCxcbiAgICAgICAgICAgIG5vZGUgPSB2b2lkIDA7XG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgICAgdmFyIG5vZGVJbmRpY2VzID0gdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXM7XG4gICAgICAgIHZhciBmb3JjZXMgPSB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlcztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5vZGVJZCA9IG5vZGVJbmRpY2VzW2ldO1xuICAgICAgICAgIG5vZGUgPSBub2Rlc1tub2RlSWRdO1xuICAgICAgICAgIGR4ID0gLW5vZGUueDtcbiAgICAgICAgICBkeSA9IC1ub2RlLnk7XG4gICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICAgICAgdGhpcy5fY2FsY3VsYXRlRm9yY2VzKGRpc3RhbmNlLCBkeCwgZHksIGZvcmNlcywgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxjdWxhdGUgdGhlIGZvcmNlcyBiYXNlZCBvbiB0aGUgZGlzdGFuY2UuXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2NhbGN1bGF0ZUZvcmNlc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxjdWxhdGVGb3JjZXMoZGlzdGFuY2UsIGR4LCBkeSwgZm9yY2VzLCBub2RlKSB7XG4gICAgICAgIHZhciBncmF2aXR5Rm9yY2UgPSBkaXN0YW5jZSA9PT0gMCA/IDAgOiB0aGlzLm9wdGlvbnMuY2VudHJhbEdyYXZpdHkgLyBkaXN0YW5jZTtcbiAgICAgICAgZm9yY2VzW25vZGUuaWRdLnggPSBkeCAqIGdyYXZpdHlGb3JjZTtcbiAgICAgICAgZm9yY2VzW25vZGUuaWRdLnkgPSBkeSAqIGdyYXZpdHlGb3JjZTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQ2VudHJhbEdyYXZpdHlTb2x2ZXI7XG4gIH0oKTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBDZW50cmFsR3Jhdml0eVNvbHZlcjtcblxuLyoqKi8gfSxcbi8qIDEwMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX0Jhcm5lc0h1dFNvbHZlcjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk0KTtcblxuICB2YXIgX0Jhcm5lc0h1dFNvbHZlcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CYXJuZXNIdXRTb2x2ZXIyKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbiAgdmFyIEZvcmNlQXRsYXMyQmFzZWRSZXB1bHNpb25Tb2x2ZXIgPSBmdW5jdGlvbiAoX0Jhcm5lc0h1dFNvbHZlcikge1xuICAgIF9pbmhlcml0cyhGb3JjZUF0bGFzMkJhc2VkUmVwdWxzaW9uU29sdmVyLCBfQmFybmVzSHV0U29sdmVyKTtcblxuICAgIGZ1bmN0aW9uIEZvcmNlQXRsYXMyQmFzZWRSZXB1bHNpb25Tb2x2ZXIoYm9keSwgcGh5c2ljc0JvZHksIG9wdGlvbnMpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGb3JjZUF0bGFzMkJhc2VkUmVwdWxzaW9uU29sdmVyKTtcblxuICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihGb3JjZUF0bGFzMkJhc2VkUmVwdWxzaW9uU29sdmVyKS5jYWxsKHRoaXMsIGJvZHksIHBoeXNpY3NCb2R5LCBvcHRpb25zKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBmb3JjZXMgYmFzZWQgb24gdGhlIGRpc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRpc3RhbmNlXG4gICAgICogQHBhcmFtIGR4XG4gICAgICogQHBhcmFtIGR5XG4gICAgICogQHBhcmFtIG5vZGVcbiAgICAgKiBAcGFyYW0gcGFyZW50QnJhbmNoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKEZvcmNlQXRsYXMyQmFzZWRSZXB1bHNpb25Tb2x2ZXIsIFt7XG4gICAgICBrZXk6IFwiX2NhbGN1bGF0ZUZvcmNlc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxjdWxhdGVGb3JjZXMoZGlzdGFuY2UsIGR4LCBkeSwgbm9kZSwgcGFyZW50QnJhbmNoKSB7XG4gICAgICAgIGlmIChkaXN0YW5jZSA9PT0gMCkge1xuICAgICAgICAgIGRpc3RhbmNlID0gMC4xICogTWF0aC5yYW5kb20oKTtcbiAgICAgICAgICBkeCA9IGRpc3RhbmNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3ZlcmxhcEF2b2lkYW5jZUZhY3RvciA8IDEpIHtcbiAgICAgICAgICBkaXN0YW5jZSA9IE1hdGgubWF4KDAuMSArIHRoaXMub3ZlcmxhcEF2b2lkYW5jZUZhY3RvciAqIG5vZGUuc2hhcGUucmFkaXVzLCBkaXN0YW5jZSAtIG5vZGUuc2hhcGUucmFkaXVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZWdyZWUgPSBub2RlLmVkZ2VzLmxlbmd0aCArIDE7XG4gICAgICAgIC8vIHRoZSBkaXZpZGluZyBieSB0aGUgZGlzdGFuY2UgY3ViZWQgaW5zdGVhZCBvZiBzcXVhcmVkIGFsbG93cyB1cyB0byBnZXQgdGhlIGZ4IGFuZCBmeSBjb21wb25lbnRzIHdpdGhvdXQgc2luZXMgYW5kIGNvc2luZXNcbiAgICAgICAgLy8gaXQgaXMgc2hvcnRoYW5kIGZvciBncmF2aXR5Zm9yY2Ugd2l0aCBkaXN0YW5jZSBzcXVhcmVkIGFuZCBmeCA9IGR4L2Rpc3RhbmNlICogZ3Jhdml0eUZvcmNlXG4gICAgICAgIHZhciBncmF2aXR5Rm9yY2UgPSB0aGlzLm9wdGlvbnMuZ3Jhdml0YXRpb25hbENvbnN0YW50ICogcGFyZW50QnJhbmNoLm1hc3MgKiBub2RlLm9wdGlvbnMubWFzcyAqIGRlZ3JlZSAvIE1hdGgucG93KGRpc3RhbmNlLCAyKTtcbiAgICAgICAgdmFyIGZ4ID0gZHggKiBncmF2aXR5Rm9yY2U7XG4gICAgICAgIHZhciBmeSA9IGR5ICogZ3Jhdml0eUZvcmNlO1xuXG4gICAgICAgIHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGUuaWRdLnggKz0gZng7XG4gICAgICAgIHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGUuaWRdLnkgKz0gZnk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEZvcmNlQXRsYXMyQmFzZWRSZXB1bHNpb25Tb2x2ZXI7XG4gIH0oX0Jhcm5lc0h1dFNvbHZlcjMuZGVmYXVsdCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gRm9yY2VBdGxhczJCYXNlZFJlcHVsc2lvblNvbHZlcjtcblxuLyoqKi8gfSxcbi8qIDEwMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICB2YXIgX0NlbnRyYWxHcmF2aXR5U29sdmVyMiA9IF9fd2VicGFja19yZXF1aXJlX18oOTkpO1xuXG4gIHZhciBfQ2VudHJhbEdyYXZpdHlTb2x2ZXIzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2VudHJhbEdyYXZpdHlTb2x2ZXIyKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbiAgdmFyIEZvcmNlQXRsYXMyQmFzZWRDZW50cmFsR3Jhdml0eVNvbHZlciA9IGZ1bmN0aW9uIChfQ2VudHJhbEdyYXZpdHlTb2x2ZXIpIHtcbiAgICBfaW5oZXJpdHMoRm9yY2VBdGxhczJCYXNlZENlbnRyYWxHcmF2aXR5U29sdmVyLCBfQ2VudHJhbEdyYXZpdHlTb2x2ZXIpO1xuXG4gICAgZnVuY3Rpb24gRm9yY2VBdGxhczJCYXNlZENlbnRyYWxHcmF2aXR5U29sdmVyKGJvZHksIHBoeXNpY3NCb2R5LCBvcHRpb25zKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRm9yY2VBdGxhczJCYXNlZENlbnRyYWxHcmF2aXR5U29sdmVyKTtcblxuICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihGb3JjZUF0bGFzMkJhc2VkQ2VudHJhbEdyYXZpdHlTb2x2ZXIpLmNhbGwodGhpcywgYm9keSwgcGh5c2ljc0JvZHksIG9wdGlvbnMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGZvcmNlcyBiYXNlZCBvbiB0aGUgZGlzdGFuY2UuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKEZvcmNlQXRsYXMyQmFzZWRDZW50cmFsR3Jhdml0eVNvbHZlciwgW3tcbiAgICAgIGtleTogXCJfY2FsY3VsYXRlRm9yY2VzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGN1bGF0ZUZvcmNlcyhkaXN0YW5jZSwgZHgsIGR5LCBmb3JjZXMsIG5vZGUpIHtcbiAgICAgICAgaWYgKGRpc3RhbmNlID4gMCkge1xuICAgICAgICAgIHZhciBkZWdyZWUgPSBub2RlLmVkZ2VzLmxlbmd0aCArIDE7XG4gICAgICAgICAgdmFyIGdyYXZpdHlGb3JjZSA9IHRoaXMub3B0aW9ucy5jZW50cmFsR3Jhdml0eSAqIGRlZ3JlZSAqIG5vZGUub3B0aW9ucy5tYXNzO1xuICAgICAgICAgIGZvcmNlc1tub2RlLmlkXS54ID0gZHggKiBncmF2aXR5Rm9yY2U7XG4gICAgICAgICAgZm9yY2VzW25vZGUuaWRdLnkgPSBkeSAqIGdyYXZpdHlGb3JjZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBGb3JjZUF0bGFzMkJhc2VkQ2VudHJhbEdyYXZpdHlTb2x2ZXI7XG4gIH0oX0NlbnRyYWxHcmF2aXR5U29sdmVyMy5kZWZhdWx0KTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBGb3JjZUF0bGFzMkJhc2VkQ2VudHJhbEdyYXZpdHlTb2x2ZXI7XG5cbi8qKiovIH0sXG4vKiAxMDIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIHZhciBfTmV0d29ya1V0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMyk7XG5cbiAgdmFyIF9OZXR3b3JrVXRpbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9OZXR3b3JrVXRpbCk7XG5cbiAgdmFyIF9DbHVzdGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDQpO1xuXG4gIHZhciBfQ2x1c3RlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DbHVzdGVyKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgdmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4gIHZhciBDbHVzdGVyRW5naW5lID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENsdXN0ZXJFbmdpbmUoYm9keSkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENsdXN0ZXJFbmdpbmUpO1xuXG4gICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgdGhpcy5jbHVzdGVyZWROb2RlcyA9IHt9O1xuICAgICAgdGhpcy5jbHVzdGVyZWRFZGdlcyA9IHt9O1xuXG4gICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7fTtcbiAgICAgIHV0aWwuZXh0ZW5kKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdfcmVzZXREYXRhJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5jbHVzdGVyZWROb2RlcyA9IHt9O190aGlzLmNsdXN0ZXJlZEVkZ2VzID0ge307XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQ2x1c3RlckVuZ2luZSwgW3tcbiAgICAgIGtleTogJ3NldE9wdGlvbnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7fVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICpcbiAgICAgICogQHBhcmFtIGh1YnNpemVcbiAgICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdjbHVzdGVyQnlIdWJzaXplJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbHVzdGVyQnlIdWJzaXplKGh1YnNpemUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGh1YnNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGh1YnNpemUgPSB0aGlzLl9nZXRIdWJTaXplKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoKHR5cGVvZiBodWJzaXplID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihodWJzaXplKSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBvcHRpb25zID0gdGhpcy5fY2hlY2tPcHRpb25zKGh1YnNpemUpO1xuICAgICAgICAgIGh1YnNpemUgPSB0aGlzLl9nZXRIdWJTaXplKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbm9kZXNUb0NsdXN0ZXIgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLmJvZHkubm9kZUluZGljZXNbaV1dO1xuICAgICAgICAgIGlmIChub2RlLmVkZ2VzLmxlbmd0aCA+PSBodWJzaXplKSB7XG4gICAgICAgICAgICBub2Rlc1RvQ2x1c3Rlci5wdXNoKG5vZGUuaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBub2Rlc1RvQ2x1c3Rlci5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICB0aGlzLmNsdXN0ZXJCeUNvbm5lY3Rpb24obm9kZXNUb0NsdXN0ZXJbX2ldLCBvcHRpb25zLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19kYXRhQ2hhbmdlZCcpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICogbG9vcCBvdmVyIGFsbCBub2RlcywgY2hlY2sgaWYgdGhleSBhZGhlcmUgdG8gdGhlIGNvbmRpdGlvbiBhbmQgY2x1c3RlciBpZiBuZWVkZWQuXG4gICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICAqIEBwYXJhbSByZWZyZXNoRGF0YVxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2NsdXN0ZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsdXN0ZXIoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG4gICAgICAgIHZhciByZWZyZXNoRGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuam9pbkNvbmRpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgY2x1c3RlckJ5Tm9kZURhdGEgd2l0aG91dCBhIGpvaW5Db25kaXRpb24gZnVuY3Rpb24gaW4gdGhlIG9wdGlvbnMuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIG9wdGlvbnMgb2JqZWN0IGlzIGZpbmUsIGFwcGVuZCBpZiBuZWVkZWRcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMuX2NoZWNrT3B0aW9ucyhvcHRpb25zKTtcblxuICAgICAgICB2YXIgY2hpbGROb2Rlc09iaiA9IHt9O1xuICAgICAgICB2YXIgY2hpbGRFZGdlc09iaiA9IHt9O1xuXG4gICAgICAgIC8vIGNvbGxlY3QgdGhlIG5vZGVzIHRoYXQgd2lsbCBiZSBpbiB0aGUgY2x1c3RlclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBub2RlSWQgPSB0aGlzLmJvZHkubm9kZUluZGljZXNbaV07XG4gICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICB2YXIgY2xvbmVkT3B0aW9ucyA9IF9OZXR3b3JrVXRpbDIuZGVmYXVsdC5jbG9uZU9wdGlvbnMobm9kZSk7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuam9pbkNvbmRpdGlvbihjbG9uZWRPcHRpb25zKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY2hpbGROb2Rlc09ialtub2RlSWRdID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG5cbiAgICAgICAgICAgIC8vIGNvbGxlY3QgdGhlIG5vZGVzIHRoYXQgd2lsbCBiZSBpbiB0aGUgY2x1c3RlclxuICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbm9kZS5lZGdlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgICAgIHZhciBlZGdlID0gbm9kZS5lZGdlc1tfaTJdO1xuICAgICAgICAgICAgICBpZiAodGhpcy5jbHVzdGVyZWRFZGdlc1tlZGdlLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRFZGdlc09ialtlZGdlLmlkXSA9IGVkZ2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jbHVzdGVyKGNoaWxkTm9kZXNPYmosIGNoaWxkRWRnZXNPYmosIG9wdGlvbnMsIHJlZnJlc2hEYXRhKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDbHVzdGVyIGFsbCBub2RlcyBpbiB0aGUgbmV0d29yayB0aGF0IGhhdmUgb25seSBYIGVkZ2VzXG4gICAgICAgKiBAcGFyYW0gZWRnZUNvdW50XG4gICAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAgICogQHBhcmFtIHJlZnJlc2hEYXRhXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2NsdXN0ZXJCeUVkZ2VDb3VudCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2x1c3RlckJ5RWRnZUNvdW50KGVkZ2VDb3VudCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgcmVmcmVzaERhdGEgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyB0cnVlIDogYXJndW1lbnRzWzJdO1xuXG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLl9jaGVja09wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHZhciBjbHVzdGVycyA9IFtdO1xuICAgICAgICB2YXIgdXNlZE5vZGVzID0ge307XG4gICAgICAgIHZhciBlZGdlID0gdm9pZCAwLFxuICAgICAgICAgICAgZWRnZXMgPSB2b2lkIDAsXG4gICAgICAgICAgICBub2RlID0gdm9pZCAwLFxuICAgICAgICAgICAgbm9kZUlkID0gdm9pZCAwLFxuICAgICAgICAgICAgcmVsZXZhbnRFZGdlQ291bnQgPSB2b2lkIDA7XG4gICAgICAgIC8vIGNvbGxlY3QgdGhlIG5vZGVzIHRoYXQgd2lsbCBiZSBpbiB0aGUgY2x1c3RlclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBjaGlsZE5vZGVzT2JqID0ge307XG4gICAgICAgICAgdmFyIGNoaWxkRWRnZXNPYmogPSB7fTtcbiAgICAgICAgICBub2RlSWQgPSB0aGlzLmJvZHkubm9kZUluZGljZXNbaV07XG5cbiAgICAgICAgICAvLyBpZiB0aGlzIG5vZGUgaXMgYWxyZWFkeSB1c2VkIGluIGFub3RoZXIgY2x1c3RlciB0aGlzIHNlc3Npb24sIHdlIGRvIG5vdCBoYXZlIHRvIHJlLWV2YWx1YXRlIGl0LlxuICAgICAgICAgIGlmICh1c2VkTm9kZXNbbm9kZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZWxldmFudEVkZ2VDb3VudCA9IDA7XG4gICAgICAgICAgICBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICAgICAgICBlZGdlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2RlLmVkZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIGVkZ2UgPSBub2RlLmVkZ2VzW2pdO1xuICAgICAgICAgICAgICBpZiAodGhpcy5jbHVzdGVyZWRFZGdlc1tlZGdlLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVkZ2UudG9JZCAhPT0gZWRnZS5mcm9tSWQpIHtcbiAgICAgICAgICAgICAgICAgIHJlbGV2YW50RWRnZUNvdW50Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVkZ2VzLnB1c2goZWRnZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGhpcyBub2RlIHF1YWxpZmllcywgd2UgY29sbGVjdCBpdHMgbmVpZ2hib3VycyB0byBzdGFydCB0aGUgY2x1c3RlcmluZyBwcm9jZXNzLlxuICAgICAgICAgICAgaWYgKHJlbGV2YW50RWRnZUNvdW50ID09PSBlZGdlQ291bnQpIHtcbiAgICAgICAgICAgICAgdmFyIGdhdGhlcmluZ1N1Y2Nlc3NmdWwgPSB0cnVlO1xuICAgICAgICAgICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgZWRnZXMubGVuZ3RoOyBfaisrKSB7XG4gICAgICAgICAgICAgICAgZWRnZSA9IGVkZ2VzW19qXTtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGROb2RlSWQgPSB0aGlzLl9nZXRDb25uZWN0ZWRJZChlZGdlLCBub2RlSWQpO1xuICAgICAgICAgICAgICAgIC8vIGFkZCB0aGUgbm9kZXMgdG8gdGhlIGxpc3QgYnkgdGhlIGpvaW4gY29uZGl0aW9uLlxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmpvaW5Db25kaXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgY2hpbGRFZGdlc09ialtlZGdlLmlkXSA9IGVkZ2U7XG4gICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzT2JqW25vZGVJZF0gPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXNPYmpbY2hpbGROb2RlSWRdID0gdGhpcy5ib2R5Lm5vZGVzW2NoaWxkTm9kZUlkXTtcbiAgICAgICAgICAgICAgICAgIHVzZWROb2Rlc1tub2RlSWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIGNsb25lZE9wdGlvbnMgPSBfTmV0d29ya1V0aWwyLmRlZmF1bHQuY2xvbmVPcHRpb25zKHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdKTtcbiAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmpvaW5Db25kaXRpb24oY2xvbmVkT3B0aW9ucykgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRFZGdlc09ialtlZGdlLmlkXSA9IGVkZ2U7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXNPYmpbbm9kZUlkXSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgICAgICAgICAgICAgICB1c2VkTm9kZXNbbm9kZUlkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIG5vZGUgZG9lcyBub3QgcXVhbGlmeSBhZnRlciBhbGwuXG4gICAgICAgICAgICAgICAgICAgIGdhdGhlcmluZ1N1Y2Nlc3NmdWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gYWRkIHRvIHRoZSBjbHVzdGVyIHF1ZXVlXG4gICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhjaGlsZE5vZGVzT2JqKS5sZW5ndGggPiAwICYmIE9iamVjdC5rZXlzKGNoaWxkRWRnZXNPYmopLmxlbmd0aCA+IDAgJiYgZ2F0aGVyaW5nU3VjY2Vzc2Z1bCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNsdXN0ZXJzLnB1c2goeyBub2RlczogY2hpbGROb2Rlc09iaiwgZWRnZXM6IGNoaWxkRWRnZXNPYmogfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBjbHVzdGVycy5sZW5ndGg7IF9pMysrKSB7XG4gICAgICAgICAgdGhpcy5fY2x1c3RlcihjbHVzdGVyc1tfaTNdLm5vZGVzLCBjbHVzdGVyc1tfaTNdLmVkZ2VzLCBvcHRpb25zLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVmcmVzaERhdGEgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfZGF0YUNoYW5nZWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICogQ2x1c3RlciBhbGwgbm9kZXMgaW4gdGhlIG5ldHdvcmsgdGhhdCBoYXZlIG9ubHkgMSBlZGdlXG4gICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICAqIEBwYXJhbSByZWZyZXNoRGF0YVxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2NsdXN0ZXJPdXRsaWVycycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2x1c3Rlck91dGxpZXJzKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlZnJlc2hEYXRhID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICB0aGlzLmNsdXN0ZXJCeUVkZ2VDb3VudCgxLCBvcHRpb25zLCByZWZyZXNoRGF0YSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2x1c3RlciBhbGwgbm9kZXMgaW4gdGhlIG5ldHdvcmsgdGhhdCBoYXZlIG9ubHkgMiBlZGdlXG4gICAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAgICogQHBhcmFtIHJlZnJlc2hEYXRhXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2NsdXN0ZXJCcmlkZ2VzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbHVzdGVyQnJpZGdlcyhvcHRpb25zKSB7XG4gICAgICAgIHZhciByZWZyZXNoRGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgdGhpcy5jbHVzdGVyQnlFZGdlQ291bnQoMiwgb3B0aW9ucywgcmVmcmVzaERhdGEpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICogc3VjayBhbGwgY29ubmVjdGVkIG5vZGVzIG9mIGEgbm9kZSBpbnRvIHRoZSBub2RlLlxuICAgICAgKiBAcGFyYW0gbm9kZUlkXG4gICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICAqIEBwYXJhbSByZWZyZXNoRGF0YVxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2NsdXN0ZXJCeUNvbm5lY3Rpb24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsdXN0ZXJCeUNvbm5lY3Rpb24obm9kZUlkLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciByZWZyZXNoRGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhcmd1bWVudHNbMl07XG5cbiAgICAgICAgLy8ga2lsbCBjb25kaXRpb25zXG4gICAgICAgIGlmIChub2RlSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIG5vZGVJZCBzdXBwbGllZCB0byBjbHVzdGVyQnlDb25uZWN0aW9uIVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBub2RlSWQgZ2l2ZW4gdG8gY2x1c3RlckJ5Q29ubmVjdGlvbiBkb2VzIG5vdCBleGlzdCFcIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgICBvcHRpb25zID0gdGhpcy5fY2hlY2tPcHRpb25zKG9wdGlvbnMsIG5vZGUpO1xuICAgICAgICBpZiAob3B0aW9ucy5jbHVzdGVyTm9kZVByb3BlcnRpZXMueCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb3B0aW9ucy5jbHVzdGVyTm9kZVByb3BlcnRpZXMueCA9IG5vZGUueDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5jbHVzdGVyTm9kZVByb3BlcnRpZXMueSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb3B0aW9ucy5jbHVzdGVyTm9kZVByb3BlcnRpZXMueSA9IG5vZGUueTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5jbHVzdGVyTm9kZVByb3BlcnRpZXMuZml4ZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmZpeGVkID0ge307XG4gICAgICAgICAgb3B0aW9ucy5jbHVzdGVyTm9kZVByb3BlcnRpZXMuZml4ZWQueCA9IG5vZGUub3B0aW9ucy5maXhlZC54O1xuICAgICAgICAgIG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmZpeGVkLnkgPSBub2RlLm9wdGlvbnMuZml4ZWQueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGlsZE5vZGVzT2JqID0ge307XG4gICAgICAgIHZhciBjaGlsZEVkZ2VzT2JqID0ge307XG4gICAgICAgIHZhciBwYXJlbnROb2RlSWQgPSBub2RlLmlkO1xuICAgICAgICB2YXIgcGFyZW50Q2xvbmVkT3B0aW9ucyA9IF9OZXR3b3JrVXRpbDIuZGVmYXVsdC5jbG9uZU9wdGlvbnMobm9kZSk7XG4gICAgICAgIGNoaWxkTm9kZXNPYmpbcGFyZW50Tm9kZUlkXSA9IG5vZGU7XG5cbiAgICAgICAgLy8gY29sbGVjdCB0aGUgbm9kZXMgdGhhdCB3aWxsIGJlIGluIHRoZSBjbHVzdGVyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5lZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlZGdlID0gbm9kZS5lZGdlc1tpXTtcbiAgICAgICAgICBpZiAodGhpcy5jbHVzdGVyZWRFZGdlc1tlZGdlLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGROb2RlSWQgPSB0aGlzLl9nZXRDb25uZWN0ZWRJZChlZGdlLCBwYXJlbnROb2RlSWQpO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGUgY2hpbGQgbm9kZSBpcyBub3QgaW4gYSBjbHVzdGVyXG4gICAgICAgICAgICBpZiAodGhpcy5jbHVzdGVyZWROb2Rlc1tjaGlsZE5vZGVJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBpZiAoY2hpbGROb2RlSWQgIT09IHBhcmVudE5vZGVJZCkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmpvaW5Db25kaXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgY2hpbGRFZGdlc09ialtlZGdlLmlkXSA9IGVkZ2U7XG4gICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzT2JqW2NoaWxkTm9kZUlkXSA9IHRoaXMuYm9keS5ub2Rlc1tjaGlsZE5vZGVJZF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIGNsb25lIHRoZSBvcHRpb25zIGFuZCBpbnNlcnQgc29tZSBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgdGhhdCBjb3VsZCBiZSBpbnRlcmVzdGluZy5cbiAgICAgICAgICAgICAgICAgIHZhciBjaGlsZENsb25lZE9wdGlvbnMgPSBfTmV0d29ya1V0aWwyLmRlZmF1bHQuY2xvbmVPcHRpb25zKHRoaXMuYm9keS5ub2Rlc1tjaGlsZE5vZGVJZF0pO1xuICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuam9pbkNvbmRpdGlvbihwYXJlbnRDbG9uZWRPcHRpb25zLCBjaGlsZENsb25lZE9wdGlvbnMpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkRWRnZXNPYmpbZWRnZS5pZF0gPSBlZGdlO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzT2JqW2NoaWxkTm9kZUlkXSA9IHRoaXMuYm9keS5ub2Rlc1tjaGlsZE5vZGVJZF07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHN3YWxsb3cgdGhlIGVkZ2UgaWYgaXQgaXMgc2VsZi1yZWZlcmVuY2luZy5cbiAgICAgICAgICAgICAgICBjaGlsZEVkZ2VzT2JqW2VkZ2UuaWRdID0gZWRnZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NsdXN0ZXIoY2hpbGROb2Rlc09iaiwgY2hpbGRFZGdlc09iaiwgb3B0aW9ucywgcmVmcmVzaERhdGEpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICogVGhpcyBmdW5jdGlvbiBjcmVhdGVzIHRoZSBlZGdlcyB0aGF0IHdpbGwgYmUgYXR0YWNoZWQgdG8gdGhlIGNsdXN0ZXJcbiAgICAgICogSXQgbG9va3MgZm9yIGVkZ2VzIHRoYXQgYXJlIGNvbm5lY3RlZCB0byB0aGUgbm9kZXMgZnJvbSB0aGUgXCJvdXRzaWRlJyBvZiB0aGUgY2x1c3Rlci5cbiAgICAgICpcbiAgICAgICogQHBhcmFtIGNoaWxkTm9kZXNPYmpcbiAgICAgICogQHBhcmFtIGNoaWxkRWRnZXNPYmpcbiAgICAgICogQHBhcmFtIGNsdXN0ZXJOb2RlUHJvcGVydGllc1xuICAgICAgKiBAcGFyYW0gY2x1c3RlckVkZ2VQcm9wZXJ0aWVzXG4gICAgICAqIEBwcml2YXRlXG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2NyZWF0ZUNsdXN0ZXJFZGdlcycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUNsdXN0ZXJFZGdlcyhjaGlsZE5vZGVzT2JqLCBjaGlsZEVkZ2VzT2JqLCBjbHVzdGVyTm9kZVByb3BlcnRpZXMsIGNsdXN0ZXJFZGdlUHJvcGVydGllcykge1xuICAgICAgICB2YXIgZWRnZSA9IHZvaWQgMCxcbiAgICAgICAgICAgIGNoaWxkTm9kZUlkID0gdm9pZCAwLFxuICAgICAgICAgICAgY2hpbGROb2RlID0gdm9pZCAwLFxuICAgICAgICAgICAgdG9JZCA9IHZvaWQgMCxcbiAgICAgICAgICAgIGZyb21JZCA9IHZvaWQgMCxcbiAgICAgICAgICAgIG90aGVyTm9kZUlkID0gdm9pZCAwO1xuXG4gICAgICAgIC8vIGxvb3Agb3ZlciBhbGwgY2hpbGQgbm9kZXMgYW5kIHRoZWlyIGVkZ2VzIHRvIGZpbmQgZWRnZXMgZ29pbmcgb3V0IG9mIHRoZSBjbHVzdGVyXG4gICAgICAgIC8vIHRoZXNlIGVkZ2VzIHdpbGwgYmUgcmVwbGFjZWQgYnkgY2x1c3RlckVkZ2VzLlxuICAgICAgICB2YXIgY2hpbGRLZXlzID0gT2JqZWN0LmtleXMoY2hpbGROb2Rlc09iaik7XG4gICAgICAgIHZhciBjcmVhdGVFZGdlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNoaWxkTm9kZUlkID0gY2hpbGRLZXlzW2ldO1xuICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXNPYmpbY2hpbGROb2RlSWRdO1xuXG4gICAgICAgICAgLy8gY29uc3RydWN0IG5ldyBlZGdlcyBmcm9tIHRoZSBjbHVzdGVyIHRvIG90aGVyc1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2hpbGROb2RlLmVkZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBlZGdlID0gY2hpbGROb2RlLmVkZ2VzW2pdO1xuICAgICAgICAgICAgLy8gd2Ugb25seSBoYW5kbGUgZWRnZXMgdGhhdCBhcmUgdmlzaWJsZSB0byB0aGUgc3lzdGVtLCBub3QgdGhlIGRpc2FibGVkIG9uZXMgZnJvbSB0aGUgY2x1c3RlcmluZyBwcm9jZXNzLlxuICAgICAgICAgICAgaWYgKHRoaXMuY2x1c3RlcmVkRWRnZXNbZWRnZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAvLyBzZWxmLXJlZmVyZW5jaW5nIGVkZ2VzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIFwiaGlkZGVuXCIgbGlzdFxuICAgICAgICAgICAgICBpZiAoZWRnZS50b0lkID09IGVkZ2UuZnJvbUlkKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRFZGdlc09ialtlZGdlLmlkXSA9IGVkZ2U7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gc2V0IHVwIHRoZSBmcm9tIGFuZCB0by5cbiAgICAgICAgICAgICAgICBpZiAoZWRnZS50b0lkID09IGNoaWxkTm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGEgZG91YmxlIGVxdWFscyBiZWNhdXNlIGludHMgYW5kIHN0cmluZ3MgY2FuIGJlIGludGVyY2hhbmdlZCBoZXJlLlxuICAgICAgICAgICAgICAgICAgdG9JZCA9IGNsdXN0ZXJOb2RlUHJvcGVydGllcy5pZDtcbiAgICAgICAgICAgICAgICAgIGZyb21JZCA9IGVkZ2UuZnJvbUlkO1xuICAgICAgICAgICAgICAgICAgb3RoZXJOb2RlSWQgPSBmcm9tSWQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRvSWQgPSBlZGdlLnRvSWQ7XG4gICAgICAgICAgICAgICAgICBmcm9tSWQgPSBjbHVzdGVyTm9kZVByb3BlcnRpZXMuaWQ7XG4gICAgICAgICAgICAgICAgICBvdGhlck5vZGVJZCA9IHRvSWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gT25seSBlZGdlcyBmcm9tIHRoZSBjbHVzdGVyIG91dHdhcmRzIGFyZSBiZWluZyByZXBsYWNlZC5cbiAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZXNPYmpbb3RoZXJOb2RlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjcmVhdGVFZGdlcy5wdXNoKHsgZWRnZTogZWRnZSwgZnJvbUlkOiBmcm9tSWQsIHRvSWQ6IHRvSWQgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoZXJlIHdlIGFjdHVhbGx5IGNyZWF0ZSB0aGUgcmVwbGFjZW1lbnQgZWRnZXMuIFdlIGNvdWxkIG5vdCBkbyB0aGlzIGluIHRoZSBsb29wIGFib3ZlIGFzIHRoZSBjcmVhdGlvbiBwcm9jZXNzXG4gICAgICAgIC8vIHdvdWxkIGFkZCBhbiBlZGdlIHRvIHRoZSBlZGdlcyBhcnJheSB3ZSBhcmUgaXRlcmF0aW5nIG92ZXIuXG4gICAgICAgIGZvciAodmFyIF9qMiA9IDA7IF9qMiA8IGNyZWF0ZUVkZ2VzLmxlbmd0aDsgX2oyKyspIHtcbiAgICAgICAgICB2YXIgX2VkZ2UgPSBjcmVhdGVFZGdlc1tfajJdLmVkZ2U7XG4gICAgICAgICAgLy8gY29weSB0aGUgb3B0aW9ucyBvZiB0aGUgZWRnZSB3ZSB3aWxsIHJlcGxhY2VcbiAgICAgICAgICB2YXIgY2xvbmVkT3B0aW9ucyA9IF9OZXR3b3JrVXRpbDIuZGVmYXVsdC5jbG9uZU9wdGlvbnMoX2VkZ2UsICdlZGdlJyk7XG4gICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBwcm9wZXJ0aWVzIG9mIGNsdXN0ZXJFZGdlcyBhcmUgc3VwZXJpbXBvc2VkIG9uIGl0XG4gICAgICAgICAgdXRpbC5kZWVwRXh0ZW5kKGNsb25lZE9wdGlvbnMsIGNsdXN0ZXJFZGdlUHJvcGVydGllcyk7XG5cbiAgICAgICAgICAvLyBzZXQgdXAgdGhlIGVkZ2VcbiAgICAgICAgICBjbG9uZWRPcHRpb25zLmZyb20gPSBjcmVhdGVFZGdlc1tfajJdLmZyb21JZDtcbiAgICAgICAgICBjbG9uZWRPcHRpb25zLnRvID0gY3JlYXRlRWRnZXNbX2oyXS50b0lkO1xuICAgICAgICAgIGNsb25lZE9wdGlvbnMuaWQgPSAnY2x1c3RlckVkZ2U6JyArIHV0aWwucmFuZG9tVVVJRCgpO1xuICAgICAgICAgIC8vY2xvbmVkT3B0aW9ucy5pZCA9ICcoY2Y6ICcgKyBjcmVhdGVFZGdlc1tqXS5mcm9tSWQgKyBcIiB0bzogXCIgKyBjcmVhdGVFZGdlc1tqXS50b0lkICsgXCIpXCIgKyBNYXRoLnJhbmRvbSgpO1xuXG4gICAgICAgICAgLy8gY3JlYXRlIHRoZSBlZGdlIGFuZCBnaXZlIGEgcmVmZXJlbmNlIHRvIHRoZSBvbmUgaXQgcmVwbGFjZWQuXG4gICAgICAgICAgdmFyIG5ld0VkZ2UgPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZUVkZ2UoY2xvbmVkT3B0aW9ucyk7XG4gICAgICAgICAgbmV3RWRnZS5jbHVzdGVyaW5nRWRnZVJlcGxhY2luZ0lkID0gX2VkZ2UuaWQ7XG5cbiAgICAgICAgICAvLyBjb25uZWN0IHRoZSBlZGdlLlxuICAgICAgICAgIHRoaXMuYm9keS5lZGdlc1tuZXdFZGdlLmlkXSA9IG5ld0VkZ2U7XG4gICAgICAgICAgbmV3RWRnZS5jb25uZWN0KCk7XG5cbiAgICAgICAgICAvLyBoaWRlIHRoZSByZXBsYWNlZCBlZGdlXG4gICAgICAgICAgdGhpcy5fYmFja3VwRWRnZU9wdGlvbnMoX2VkZ2UpO1xuICAgICAgICAgIF9lZGdlLnNldE9wdGlvbnMoeyBwaHlzaWNzOiBmYWxzZSwgaGlkZGVuOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgKiBUaGlzIGZ1bmN0aW9uIGNoZWNrcyB0aGUgb3B0aW9ucyB0aGF0IGNhbiBiZSBzdXBwbGllZCB0byB0aGUgZGlmZmVyZW50IGNsdXN0ZXIgZnVuY3Rpb25zXG4gICAgICAqIGZvciBjZXJ0YWluIGZpZWxkcyBhbmQgaW5zZXJ0cyBkZWZhdWx0cyBpZiBuZWVkZWRcbiAgICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAqIEBwcml2YXRlXG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2NoZWNrT3B0aW9ucycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NoZWNrT3B0aW9ucygpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgICBpZiAob3B0aW9ucy5jbHVzdGVyRWRnZVByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG9wdGlvbnMuY2x1c3RlckVkZ2VQcm9wZXJ0aWVzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBvcHRpb25zLmNsdXN0ZXJOb2RlUHJvcGVydGllcyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgKlxuICAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgY2hpbGROb2Rlc09iaiAgICAgICAgIHwgb2JqZWN0IHdpdGggbm9kZSBvYmplY3RzLCBpZCBhcyBrZXlzLCBzYW1lIGFzIGNoaWxkTm9kZXMgZXhjZXB0IGl0IGFsc28gY29udGFpbnMgYSBzb3VyY2Ugbm9kZVxuICAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgY2hpbGRFZGdlc09iaiAgICAgICAgIHwgb2JqZWN0IHdpdGggZWRnZSBvYmplY3RzLCBpZCBhcyBrZXlzXG4gICAgICAqIEBwYXJhbSB7QXJyYXl9ICAgICBvcHRpb25zICAgICAgICAgICAgICAgfCBvYmplY3Qgd2l0aCB7Y2x1c3Rlck5vZGVQcm9wZXJ0aWVzLCBjbHVzdGVyRWRnZVByb3BlcnRpZXMsIHByb2Nlc3NQcm9wZXJ0aWVzfVxuICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgcmVmcmVzaERhdGEgfCB3aGVuIHRydWUsIGRvIG5vdCB3cmFwIHVwXG4gICAgICAqIEBwcml2YXRlXG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2NsdXN0ZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jbHVzdGVyKGNoaWxkTm9kZXNPYmosIGNoaWxkRWRnZXNPYmosIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlZnJlc2hEYXRhID0gYXJndW1lbnRzLmxlbmd0aCA8PSAzIHx8IGFyZ3VtZW50c1szXSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFyZ3VtZW50c1szXTtcblxuICAgICAgICAvLyBraWxsIGNvbmRpdGlvbjogbm8gY2hpbGRyZW4gc28gY2FuJ3QgY2x1c3RlciBvciBvbmx5IG9uZSBub2RlIGluIHRoZSBjbHVzdGVyLCBkb24ndCBib3RoZXJcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGNoaWxkTm9kZXNPYmopLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGNsdXN0ZXIgY2FsbCBpcyBub3QgdHJ5aW5nIHRvIGNsdXN0ZXIgYW55dGhpbmcgdGhhdCBpcyBpbiBhbm90aGVyIGNsdXN0ZXIuXG4gICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiBjaGlsZE5vZGVzT2JqKSB7XG4gICAgICAgICAgaWYgKGNoaWxkTm9kZXNPYmouaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2x1c3RlcmVkTm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2x1c3Rlck5vZGVQcm9wZXJ0aWVzID0gdXRpbC5kZWVwRXh0ZW5kKHt9LCBvcHRpb25zLmNsdXN0ZXJOb2RlUHJvcGVydGllcyk7XG5cbiAgICAgICAgLy8gY29uc3RydWN0IHRoZSBjbHVzdGVyTm9kZVByb3BlcnRpZXNcbiAgICAgICAgaWYgKG9wdGlvbnMucHJvY2Vzc1Byb3BlcnRpZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIGdldCB0aGUgY2hpbGROb2RlIG9wdGlvbnNcbiAgICAgICAgICB2YXIgY2hpbGROb2Rlc09wdGlvbnMgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBfbm9kZUlkIGluIGNoaWxkTm9kZXNPYmopIHtcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGVzT2JqLmhhc093blByb3BlcnR5KF9ub2RlSWQpKSB7XG4gICAgICAgICAgICAgIHZhciBjbG9uZWRPcHRpb25zID0gX05ldHdvcmtVdGlsMi5kZWZhdWx0LmNsb25lT3B0aW9ucyhjaGlsZE5vZGVzT2JqW19ub2RlSWRdKTtcbiAgICAgICAgICAgICAgY2hpbGROb2Rlc09wdGlvbnMucHVzaChjbG9uZWRPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBnZXQgY2x1c3RlciBwcm9wZXJ0aWVzIGJhc2VkIG9uIGNoaWxkTm9kZXNcbiAgICAgICAgICB2YXIgY2hpbGRFZGdlc09wdGlvbnMgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBlZGdlSWQgaW4gY2hpbGRFZGdlc09iaikge1xuICAgICAgICAgICAgaWYgKGNoaWxkRWRnZXNPYmouaGFzT3duUHJvcGVydHkoZWRnZUlkKSkge1xuICAgICAgICAgICAgICAvLyB0aGVzZSBjbHVzdGVyIGVkZ2VzIHdpbGwgYmUgcmVtb3ZlZCBvbiBjcmVhdGlvbiBvZiB0aGUgY2x1c3Rlci5cbiAgICAgICAgICAgICAgaWYgKGVkZ2VJZC5zdWJzdHIoMCwgMTIpICE9PSBcImNsdXN0ZXJFZGdlOlwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9jbG9uZWRPcHRpb25zID0gX05ldHdvcmtVdGlsMi5kZWZhdWx0LmNsb25lT3B0aW9ucyhjaGlsZEVkZ2VzT2JqW2VkZ2VJZF0sICdlZGdlJyk7XG4gICAgICAgICAgICAgICAgY2hpbGRFZGdlc09wdGlvbnMucHVzaChfY2xvbmVkT3B0aW9ucyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjbHVzdGVyTm9kZVByb3BlcnRpZXMgPSBvcHRpb25zLnByb2Nlc3NQcm9wZXJ0aWVzKGNsdXN0ZXJOb2RlUHJvcGVydGllcywgY2hpbGROb2Rlc09wdGlvbnMsIGNoaWxkRWRnZXNPcHRpb25zKTtcbiAgICAgICAgICBpZiAoIWNsdXN0ZXJOb2RlUHJvcGVydGllcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHByb2Nlc3NQcm9wZXJ0aWVzIGZ1bmN0aW9uIGRvZXMgbm90IHJldHVybiBwcm9wZXJ0aWVzIVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBpZiB3ZSBoYXZlIGFuIHVuaXF1ZSBpZDtcbiAgICAgICAgaWYgKGNsdXN0ZXJOb2RlUHJvcGVydGllcy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmlkID0gJ2NsdXN0ZXI6JyArIHV0aWwucmFuZG9tVVVJRCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjbHVzdGVySWQgPSBjbHVzdGVyTm9kZVByb3BlcnRpZXMuaWQ7XG5cbiAgICAgICAgaWYgKGNsdXN0ZXJOb2RlUHJvcGVydGllcy5sYWJlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmxhYmVsID0gJ2NsdXN0ZXInO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2l2ZSB0aGUgY2x1c3Rlck5vZGUgYSBwb3NpdGlvbiBpZiBpdCBkb2VzIG5vdCBoYXZlIG9uZS5cbiAgICAgICAgdmFyIHBvcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGNsdXN0ZXJOb2RlUHJvcGVydGllcy54ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwb3MgPSB0aGlzLl9nZXRDbHVzdGVyUG9zaXRpb24oY2hpbGROb2Rlc09iaik7XG4gICAgICAgICAgY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLnggPSBwb3MueDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChwb3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcG9zID0gdGhpcy5fZ2V0Q2x1c3RlclBvc2l0aW9uKGNoaWxkTm9kZXNPYmopO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjbHVzdGVyTm9kZVByb3BlcnRpZXMueSA9IHBvcy55O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZm9yY2UgdGhlIElEIHRvIHJlbWFpbiB0aGUgc2FtZVxuICAgICAgICBjbHVzdGVyTm9kZVByb3BlcnRpZXMuaWQgPSBjbHVzdGVySWQ7XG5cbiAgICAgICAgLy8gY3JlYXRlIHRoZSBjbHVzdGVyTm9kZVxuICAgICAgICB2YXIgY2x1c3Rlck5vZGUgPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZU5vZGUoY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLCBfQ2x1c3RlcjIuZGVmYXVsdCk7XG4gICAgICAgIGNsdXN0ZXJOb2RlLmlzQ2x1c3RlciA9IHRydWU7XG4gICAgICAgIGNsdXN0ZXJOb2RlLmNvbnRhaW5lZE5vZGVzID0gY2hpbGROb2Rlc09iajtcbiAgICAgICAgY2x1c3Rlck5vZGUuY29udGFpbmVkRWRnZXMgPSBjaGlsZEVkZ2VzT2JqO1xuICAgICAgICAvLyBjYWNoZSBhIGNvcHkgZnJvbSB0aGUgY2x1c3RlciBlZGdlIHByb3BlcnRpZXMgaWYgd2UgaGF2ZSB0byByZWNvbm5lY3Qgb3RoZXJzIGxhdGVyIG9uXG4gICAgICAgIGNsdXN0ZXJOb2RlLmNsdXN0ZXJFZGdlUHJvcGVydGllcyA9IG9wdGlvbnMuY2x1c3RlckVkZ2VQcm9wZXJ0aWVzO1xuXG4gICAgICAgIC8vIGZpbmFsbHkgcHV0IHRoZSBjbHVzdGVyIG5vZGUgaW50byBnbG9iYWxcbiAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW2NsdXN0ZXJOb2RlUHJvcGVydGllcy5pZF0gPSBjbHVzdGVyTm9kZTtcblxuICAgICAgICAvLyBjcmVhdGUgdGhlIG5ldyBlZGdlcyB0aGF0IHdpbGwgY29ubmVjdCB0byB0aGUgY2x1c3RlciwgYWxsIHNlbGYtcmVmZXJlbmNpbmcgZWRnZXMgd2lsbCBiZSBhZGRlZCB0byBjaGlsZEVkZ2VzT2JqZWN0IGhlcmUuXG4gICAgICAgIHRoaXMuX2NyZWF0ZUNsdXN0ZXJFZGdlcyhjaGlsZE5vZGVzT2JqLCBjaGlsZEVkZ2VzT2JqLCBjbHVzdGVyTm9kZVByb3BlcnRpZXMsIG9wdGlvbnMuY2x1c3RlckVkZ2VQcm9wZXJ0aWVzKTtcblxuICAgICAgICAvLyBkaXNhYmxlIHRoZSBjaGlsZEVkZ2VzXG4gICAgICAgIGZvciAodmFyIF9lZGdlSWQgaW4gY2hpbGRFZGdlc09iaikge1xuICAgICAgICAgIGlmIChjaGlsZEVkZ2VzT2JqLmhhc093blByb3BlcnR5KF9lZGdlSWQpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ib2R5LmVkZ2VzW19lZGdlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdmFyIGVkZ2UgPSB0aGlzLmJvZHkuZWRnZXNbX2VkZ2VJZF07XG4gICAgICAgICAgICAgIC8vIGNhY2hlIHRoZSBvcHRpb25zIGJlZm9yZSBjaGFuZ2luZ1xuICAgICAgICAgICAgICB0aGlzLl9iYWNrdXBFZGdlT3B0aW9ucyhlZGdlKTtcbiAgICAgICAgICAgICAgLy8gZGlzYWJsZSBwaHlzaWNzIGFuZCBoaWRlIHRoZSBlZGdlXG4gICAgICAgICAgICAgIGVkZ2Uuc2V0T3B0aW9ucyh7IHBoeXNpY3M6IGZhbHNlLCBoaWRkZW46IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGlzYWJsZSB0aGUgY2hpbGROb2Rlc1xuICAgICAgICBmb3IgKHZhciBfbm9kZUlkMiBpbiBjaGlsZE5vZGVzT2JqKSB7XG4gICAgICAgICAgaWYgKGNoaWxkTm9kZXNPYmouaGFzT3duUHJvcGVydHkoX25vZGVJZDIpKSB7XG4gICAgICAgICAgICB0aGlzLmNsdXN0ZXJlZE5vZGVzW19ub2RlSWQyXSA9IHsgY2x1c3RlcklkOiBjbHVzdGVyTm9kZVByb3BlcnRpZXMuaWQsIG5vZGU6IHRoaXMuYm9keS5ub2Rlc1tfbm9kZUlkMl0gfTtcbiAgICAgICAgICAgIHRoaXMuYm9keS5ub2Rlc1tfbm9kZUlkMl0uc2V0T3B0aW9ucyh7IGhpZGRlbjogdHJ1ZSwgcGh5c2ljczogZmFsc2UgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IElEIHRvIHVuZGVmaW5lZCBzbyBubyBkdXBsaWNhdGVzIGFyaXNlXG4gICAgICAgIGNsdXN0ZXJOb2RlUHJvcGVydGllcy5pZCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyB3cmFwIHVwXG4gICAgICAgIGlmIChyZWZyZXNoRGF0YSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19kYXRhQ2hhbmdlZCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2JhY2t1cEVkZ2VPcHRpb25zJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYmFja3VwRWRnZU9wdGlvbnMoZWRnZSkge1xuICAgICAgICBpZiAodGhpcy5jbHVzdGVyZWRFZGdlc1tlZGdlLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5jbHVzdGVyZWRFZGdlc1tlZGdlLmlkXSA9IHsgcGh5c2ljczogZWRnZS5vcHRpb25zLnBoeXNpY3MsIGhpZGRlbjogZWRnZS5vcHRpb25zLmhpZGRlbiB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX3Jlc3RvcmVFZGdlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzdG9yZUVkZ2UoZWRnZSkge1xuICAgICAgICB2YXIgb3JpZ2luYWxPcHRpb25zID0gdGhpcy5jbHVzdGVyZWRFZGdlc1tlZGdlLmlkXTtcbiAgICAgICAgaWYgKG9yaWdpbmFsT3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZWRnZS5zZXRPcHRpb25zKHsgcGh5c2ljczogb3JpZ2luYWxPcHRpb25zLnBoeXNpY3MsIGhpZGRlbjogb3JpZ2luYWxPcHRpb25zLmhpZGRlbiB9KTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5jbHVzdGVyZWRFZGdlc1tlZGdlLmlkXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICogQ2hlY2sgaWYgYSBub2RlIGlzIGEgY2x1c3Rlci5cbiAgICAgICogQHBhcmFtIG5vZGVJZFxuICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdpc0NsdXN0ZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzQ2x1c3Rlcihub2RlSWQpIHtcbiAgICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0uaXNDbHVzdGVyID09PSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm9kZSBkb2VzIG5vdCBleGlzdC5cIik7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgKiBnZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBjbHVzdGVyIG5vZGUgYmFzZWQgb24gd2hhdCdzIGluc2lkZVxuICAgICAgKiBAcGFyYW0ge29iamVjdH0gY2hpbGROb2Rlc09iaiAgICB8IG9iamVjdCB3aXRoIG5vZGUgb2JqZWN0cywgaWQgYXMga2V5c1xuICAgICAgKiBAcmV0dXJucyB7e3g6IG51bWJlciwgeTogbnVtYmVyfX1cbiAgICAgICogQHByaXZhdGVcbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZ2V0Q2x1c3RlclBvc2l0aW9uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q2x1c3RlclBvc2l0aW9uKGNoaWxkTm9kZXNPYmopIHtcbiAgICAgICAgdmFyIGNoaWxkS2V5cyA9IE9iamVjdC5rZXlzKGNoaWxkTm9kZXNPYmopO1xuICAgICAgICB2YXIgbWluWCA9IGNoaWxkTm9kZXNPYmpbY2hpbGRLZXlzWzBdXS54O1xuICAgICAgICB2YXIgbWF4WCA9IGNoaWxkTm9kZXNPYmpbY2hpbGRLZXlzWzBdXS54O1xuICAgICAgICB2YXIgbWluWSA9IGNoaWxkTm9kZXNPYmpbY2hpbGRLZXlzWzBdXS55O1xuICAgICAgICB2YXIgbWF4WSA9IGNoaWxkTm9kZXNPYmpbY2hpbGRLZXlzWzBdXS55O1xuICAgICAgICB2YXIgbm9kZSA9IHZvaWQgMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBjaGlsZEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBub2RlID0gY2hpbGROb2Rlc09ialtjaGlsZEtleXNbaV1dO1xuICAgICAgICAgIG1pblggPSBub2RlLnggPCBtaW5YID8gbm9kZS54IDogbWluWDtcbiAgICAgICAgICBtYXhYID0gbm9kZS54ID4gbWF4WCA/IG5vZGUueCA6IG1heFg7XG4gICAgICAgICAgbWluWSA9IG5vZGUueSA8IG1pblkgPyBub2RlLnkgOiBtaW5ZO1xuICAgICAgICAgIG1heFkgPSBub2RlLnkgPiBtYXhZID8gbm9kZS55IDogbWF4WTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHg6IDAuNSAqIChtaW5YICsgbWF4WCksIHk6IDAuNSAqIChtaW5ZICsgbWF4WSkgfTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAqIE9wZW4gYSBjbHVzdGVyIGJ5IGNhbGxpbmcgdGhpcyBmdW5jdGlvbi5cbiAgICAgICogQHBhcmFtIHtTdHJpbmd9ICBjbHVzdGVyTm9kZUlkIHwgdGhlIElEIG9mIHRoZSBjbHVzdGVyIG5vZGVcbiAgICAgICogQHBhcmFtIHtCb29sZWFufSByZWZyZXNoRGF0YSB8IHdyYXAgdXAgYWZ0ZXJ3YXJkcyBpZiBub3QgdHJ1ZVxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ29wZW5DbHVzdGVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvcGVuQ2x1c3RlcihjbHVzdGVyTm9kZUlkLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciByZWZyZXNoRGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhcmd1bWVudHNbMl07XG5cbiAgICAgICAgLy8ga2lsbCBjb25kaXRpb25zXG4gICAgICAgIGlmIChjbHVzdGVyTm9kZUlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBjbHVzdGVyTm9kZUlkIHN1cHBsaWVkIHRvIG9wZW5DbHVzdGVyLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW2NsdXN0ZXJOb2RlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY2x1c3Rlck5vZGVJZCBzdXBwbGllZCB0byBvcGVuQ2x1c3RlciBkb2VzIG5vdCBleGlzdC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1tjbHVzdGVyTm9kZUlkXS5jb250YWluZWROb2RlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJUaGUgbm9kZTpcIiArIGNsdXN0ZXJOb2RlSWQgKyBcIiBpcyBub3QgYSBjbHVzdGVyLlwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNsdXN0ZXJOb2RlID0gdGhpcy5ib2R5Lm5vZGVzW2NsdXN0ZXJOb2RlSWRdO1xuICAgICAgICB2YXIgY29udGFpbmVkTm9kZXMgPSBjbHVzdGVyTm9kZS5jb250YWluZWROb2RlcztcbiAgICAgICAgdmFyIGNvbnRhaW5lZEVkZ2VzID0gY2x1c3Rlck5vZGUuY29udGFpbmVkRWRnZXM7XG5cbiAgICAgICAgLy8gYWxsb3cgdGhlIHVzZXIgdG8gcG9zaXRpb24gdGhlIG5vZGVzIGFmdGVyIHJlbGVhc2UuXG4gICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5yZWxlYXNlRnVuY3Rpb24gIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0aW9ucy5yZWxlYXNlRnVuY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgcG9zaXRpb25zID0ge307XG4gICAgICAgICAgdmFyIGNsdXN0ZXJQb3NpdGlvbiA9IHsgeDogY2x1c3Rlck5vZGUueCwgeTogY2x1c3Rlck5vZGUueSB9O1xuICAgICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiBjb250YWluZWROb2Rlcykge1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5lZE5vZGVzLmhhc093blByb3BlcnR5KG5vZGVJZCkpIHtcbiAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lZE5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICAgICAgcG9zaXRpb25zW25vZGVJZF0gPSB7IHg6IGNvbnRhaW5lZE5vZGUueCwgeTogY29udGFpbmVkTm9kZS55IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBuZXdQb3NpdGlvbnMgPSBvcHRpb25zLnJlbGVhc2VGdW5jdGlvbihjbHVzdGVyUG9zaXRpb24sIHBvc2l0aW9ucyk7XG5cbiAgICAgICAgICBmb3IgKHZhciBfbm9kZUlkMyBpbiBjb250YWluZWROb2Rlcykge1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5lZE5vZGVzLmhhc093blByb3BlcnR5KF9ub2RlSWQzKSkge1xuICAgICAgICAgICAgICB2YXIgX2NvbnRhaW5lZE5vZGUgPSB0aGlzLmJvZHkubm9kZXNbX25vZGVJZDNdO1xuICAgICAgICAgICAgICBpZiAobmV3UG9zaXRpb25zW19ub2RlSWQzXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRhaW5lZE5vZGUueCA9IG5ld1Bvc2l0aW9uc1tfbm9kZUlkM10ueCA9PT0gdW5kZWZpbmVkID8gY2x1c3Rlck5vZGUueCA6IG5ld1Bvc2l0aW9uc1tfbm9kZUlkM10ueDtcbiAgICAgICAgICAgICAgICBfY29udGFpbmVkTm9kZS55ID0gbmV3UG9zaXRpb25zW19ub2RlSWQzXS55ID09PSB1bmRlZmluZWQgPyBjbHVzdGVyTm9kZS55IDogbmV3UG9zaXRpb25zW19ub2RlSWQzXS55O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNvcHkgdGhlIHBvc2l0aW9uIGZyb20gdGhlIGNsdXN0ZXJcbiAgICAgICAgICBmb3IgKHZhciBfbm9kZUlkNCBpbiBjb250YWluZWROb2Rlcykge1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5lZE5vZGVzLmhhc093blByb3BlcnR5KF9ub2RlSWQ0KSkge1xuICAgICAgICAgICAgICB2YXIgX2NvbnRhaW5lZE5vZGUyID0gdGhpcy5ib2R5Lm5vZGVzW19ub2RlSWQ0XTtcbiAgICAgICAgICAgICAgX2NvbnRhaW5lZE5vZGUyID0gY29udGFpbmVkTm9kZXNbX25vZGVJZDRdO1xuICAgICAgICAgICAgICAvLyBpbmhlcml0IHBvc2l0aW9uXG4gICAgICAgICAgICAgIGlmIChfY29udGFpbmVkTm9kZTIub3B0aW9ucy5maXhlZC54ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIF9jb250YWluZWROb2RlMi54ID0gY2x1c3Rlck5vZGUueDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoX2NvbnRhaW5lZE5vZGUyLm9wdGlvbnMuZml4ZWQueSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBfY29udGFpbmVkTm9kZTIueSA9IGNsdXN0ZXJOb2RlLnk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZWxlYXNlIG5vZGVzXG4gICAgICAgIGZvciAodmFyIF9ub2RlSWQ1IGluIGNvbnRhaW5lZE5vZGVzKSB7XG4gICAgICAgICAgaWYgKGNvbnRhaW5lZE5vZGVzLmhhc093blByb3BlcnR5KF9ub2RlSWQ1KSkge1xuICAgICAgICAgICAgdmFyIF9jb250YWluZWROb2RlMyA9IHRoaXMuYm9keS5ub2Rlc1tfbm9kZUlkNV07XG5cbiAgICAgICAgICAgIC8vIGluaGVyaXQgc3BlZWRcbiAgICAgICAgICAgIF9jb250YWluZWROb2RlMy52eCA9IGNsdXN0ZXJOb2RlLnZ4O1xuICAgICAgICAgICAgX2NvbnRhaW5lZE5vZGUzLnZ5ID0gY2x1c3Rlck5vZGUudnk7XG5cbiAgICAgICAgICAgIC8vIHdlIHVzZSB0aGVzZSBtZXRob2RzIHRvIGF2b2lkIHJlLWluc3RhbnRpYXRpbmcgdGhlIHNoYXBlLCB3aGljaCBoYXBwZW5zIHdpdGggc2V0T3B0aW9ucy5cbiAgICAgICAgICAgIF9jb250YWluZWROb2RlMy5zZXRPcHRpb25zKHsgaGlkZGVuOiBmYWxzZSwgcGh5c2ljczogdHJ1ZSB9KTtcblxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuY2x1c3RlcmVkTm9kZXNbX25vZGVJZDVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvcHkgdGhlIGNsdXN0ZXJOb2RlIGVkZ2VzIGJlY2F1c2Ugd2UgY2Fubm90IGl0ZXJhdGUgb3ZlciBhbiBvYmplY3QgdGhhdCB3ZSBhZGQgb3IgcmVtb3ZlIGZyb20uXG4gICAgICAgIHZhciBlZGdlc1RvQmVEZWxldGVkID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2x1c3Rlck5vZGUuZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBlZGdlc1RvQmVEZWxldGVkLnB1c2goY2x1c3Rlck5vZGUuZWRnZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWN0dWFsbHkgaGFuZGxpbmcgdGhlIGRlbGV0aW5nLlxuICAgICAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBlZGdlc1RvQmVEZWxldGVkLmxlbmd0aDsgX2k0KyspIHtcbiAgICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzVG9CZURlbGV0ZWRbX2k0XTtcblxuICAgICAgICAgIHZhciBvdGhlck5vZGVJZCA9IHRoaXMuX2dldENvbm5lY3RlZElkKGVkZ2UsIGNsdXN0ZXJOb2RlSWQpO1xuICAgICAgICAgIC8vIGlmIHRoZSBvdGhlciBub2RlIGlzIGluIGFub3RoZXIgY2x1c3Rlciwgd2UgdHJhbnNmZXIgb3duZXJzaGlwIG9mIHRoaXMgZWRnZSB0byB0aGUgb3RoZXIgY2x1c3RlclxuICAgICAgICAgIGlmICh0aGlzLmNsdXN0ZXJlZE5vZGVzW290aGVyTm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyB0cmFuc2ZlciBvd25lcnNoaXA6XG4gICAgICAgICAgICB2YXIgb3RoZXJDbHVzdGVyID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMuY2x1c3RlcmVkTm9kZXNbb3RoZXJOb2RlSWRdLmNsdXN0ZXJJZF07XG4gICAgICAgICAgICB2YXIgdHJhbnNmZXJFZGdlID0gdGhpcy5ib2R5LmVkZ2VzW2VkZ2UuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZF07XG4gICAgICAgICAgICBpZiAodHJhbnNmZXJFZGdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgb3RoZXJDbHVzdGVyLmNvbnRhaW5lZEVkZ2VzW3RyYW5zZmVyRWRnZS5pZF0gPSB0cmFuc2ZlckVkZ2U7XG5cbiAgICAgICAgICAgICAgLy8gZGVsZXRlIGxvY2FsIHJlZmVyZW5jZVxuICAgICAgICAgICAgICBkZWxldGUgY29udGFpbmVkRWRnZXNbdHJhbnNmZXJFZGdlLmlkXTtcblxuICAgICAgICAgICAgICAvLyBjcmVhdGUgbmV3IGNsdXN0ZXIgZWRnZSBmcm9tIHRoZSBvdGhlckNsdXN0ZXI6XG4gICAgICAgICAgICAgIC8vIGdldCB0byBhbmQgZnJvbVxuICAgICAgICAgICAgICB2YXIgZnJvbUlkID0gdHJhbnNmZXJFZGdlLmZyb21JZDtcbiAgICAgICAgICAgICAgdmFyIHRvSWQgPSB0cmFuc2ZlckVkZ2UudG9JZDtcbiAgICAgICAgICAgICAgaWYgKHRyYW5zZmVyRWRnZS50b0lkID09IG90aGVyTm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgdG9JZCA9IHRoaXMuY2x1c3RlcmVkTm9kZXNbb3RoZXJOb2RlSWRdLmNsdXN0ZXJJZDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmcm9tSWQgPSB0aGlzLmNsdXN0ZXJlZE5vZGVzW290aGVyTm9kZUlkXS5jbHVzdGVySWQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBjbG9uZSB0aGUgb3B0aW9ucyBhbmQgYXBwbHkgdGhlIGNsdXN0ZXIgb3B0aW9ucyB0byB0aGVtXG4gICAgICAgICAgICAgIHZhciBjbG9uZWRPcHRpb25zID0gX05ldHdvcmtVdGlsMi5kZWZhdWx0LmNsb25lT3B0aW9ucyh0cmFuc2ZlckVkZ2UsICdlZGdlJyk7XG4gICAgICAgICAgICAgIHV0aWwuZGVlcEV4dGVuZChjbG9uZWRPcHRpb25zLCBvdGhlckNsdXN0ZXIuY2x1c3RlckVkZ2VQcm9wZXJ0aWVzKTtcblxuICAgICAgICAgICAgICAvLyBhcHBseSB0aGUgZWRnZSBzcGVjaWZpYyBvcHRpb25zIHRvIGl0LlxuICAgICAgICAgICAgICB2YXIgaWQgPSAnY2x1c3RlckVkZ2U6JyArIHV0aWwucmFuZG9tVVVJRCgpO1xuICAgICAgICAgICAgICB1dGlsLmRlZXBFeHRlbmQoY2xvbmVkT3B0aW9ucywgeyBmcm9tOiBmcm9tSWQsIHRvOiB0b0lkLCBoaWRkZW46IGZhbHNlLCBwaHlzaWNzOiB0cnVlLCBpZDogaWQgfSk7XG5cbiAgICAgICAgICAgICAgLy8gY3JlYXRlIGl0XG4gICAgICAgICAgICAgIHZhciBuZXdFZGdlID0gdGhpcy5ib2R5LmZ1bmN0aW9ucy5jcmVhdGVFZGdlKGNsb25lZE9wdGlvbnMpO1xuICAgICAgICAgICAgICBuZXdFZGdlLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWQgPSB0cmFuc2ZlckVkZ2UuaWQ7XG4gICAgICAgICAgICAgIHRoaXMuYm9keS5lZGdlc1tpZF0gPSBuZXdFZGdlO1xuICAgICAgICAgICAgICB0aGlzLmJvZHkuZWRnZXNbaWRdLmNvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlcGxhY2VkRWRnZSA9IHRoaXMuYm9keS5lZGdlc1tlZGdlLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRdO1xuICAgICAgICAgICAgaWYgKHJlcGxhY2VkRWRnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Jlc3RvcmVFZGdlKHJlcGxhY2VkRWRnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVkZ2UuY2xlYW51cCgpO1xuICAgICAgICAgIC8vIHRoaXMgcmVtb3ZlcyB0aGUgZWRnZSBmcm9tIG5vZGUuZWRnZXMsIHdoaWNoIGlzIHdoeSBlZGdlSWRzIGlzIGZvcm1lZFxuICAgICAgICAgIGVkZ2UuZGlzY29ubmVjdCgpO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLmJvZHkuZWRnZXNbZWRnZS5pZF07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoYW5kbGUgdGhlIHJlbGVhc2luZyBvZiB0aGUgZWRnZXNcbiAgICAgICAgZm9yICh2YXIgZWRnZUlkIGluIGNvbnRhaW5lZEVkZ2VzKSB7XG4gICAgICAgICAgaWYgKGNvbnRhaW5lZEVkZ2VzLmhhc093blByb3BlcnR5KGVkZ2VJZCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc3RvcmVFZGdlKGNvbnRhaW5lZEVkZ2VzW2VkZ2VJZF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSBjbHVzdGVyTm9kZVxuICAgICAgICBkZWxldGUgdGhpcy5ib2R5Lm5vZGVzW2NsdXN0ZXJOb2RlSWRdO1xuXG4gICAgICAgIGlmIChyZWZyZXNoRGF0YSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19kYXRhQ2hhbmdlZCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0Tm9kZXNJbkNsdXN0ZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5vZGVzSW5DbHVzdGVyKGNsdXN0ZXJJZCkge1xuICAgICAgICB2YXIgbm9kZXNBcnJheSA9IFtdO1xuICAgICAgICBpZiAodGhpcy5pc0NsdXN0ZXIoY2x1c3RlcklkKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBjb250YWluZWROb2RlcyA9IHRoaXMuYm9keS5ub2Rlc1tjbHVzdGVySWRdLmNvbnRhaW5lZE5vZGVzO1xuICAgICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiBjb250YWluZWROb2Rlcykge1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5lZE5vZGVzLmhhc093blByb3BlcnR5KG5vZGVJZCkpIHtcbiAgICAgICAgICAgICAgbm9kZXNBcnJheS5wdXNoKHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZXNBcnJheTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAqIEdldCB0aGUgc3RhY2sgY2x1c3RlcklkJ3MgdGhhdCBhIGNlcnRhaW4gbm9kZSByZXNpZGVzIGluLiBjbHVzdGVyIEEgLT4gY2x1c3RlciBCIC0+IGNsdXN0ZXIgQyAtPiBub2RlXG4gICAgICAqIEBwYXJhbSBub2RlSWRcbiAgICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2ZpbmROb2RlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kTm9kZShub2RlSWQpIHtcbiAgICAgICAgdmFyIHN0YWNrID0gW107XG4gICAgICAgIHZhciBtYXggPSAxMDA7XG4gICAgICAgIHZhciBjb3VudGVyID0gMDtcblxuICAgICAgICB3aGlsZSAodGhpcy5jbHVzdGVyZWROb2Rlc1tub2RlSWRdICE9PSB1bmRlZmluZWQgJiYgY291bnRlciA8IG1heCkge1xuICAgICAgICAgIHN0YWNrLnB1c2godGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0uaWQpO1xuICAgICAgICAgIG5vZGVJZCA9IHRoaXMuY2x1c3RlcmVkTm9kZXNbbm9kZUlkXS5jbHVzdGVySWQ7XG4gICAgICAgICAgY291bnRlcisrO1xuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnB1c2godGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0uaWQpO1xuICAgICAgICBzdGFjay5yZXZlcnNlKCk7XG5cbiAgICAgICAgcmV0dXJuIHN0YWNrO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICogR2V0IHRoZSBJZCB0aGUgbm9kZSBpcyBjb25uZWN0ZWQgdG9cbiAgICAgICogQHBhcmFtIGVkZ2VcbiAgICAgICogQHBhcmFtIG5vZGVJZFxuICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICogQHByaXZhdGVcbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZ2V0Q29ubmVjdGVkSWQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDb25uZWN0ZWRJZChlZGdlLCBub2RlSWQpIHtcbiAgICAgICAgaWYgKGVkZ2UudG9JZCAhPSBub2RlSWQpIHtcbiAgICAgICAgICByZXR1cm4gZWRnZS50b0lkO1xuICAgICAgICB9IGVsc2UgaWYgKGVkZ2UuZnJvbUlkICE9IG5vZGVJZCkge1xuICAgICAgICAgIHJldHVybiBlZGdlLmZyb21JZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZWRnZS5mcm9tSWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAqIFdlIGRldGVybWluZSBob3cgbWFueSBjb25uZWN0aW9ucyBkZW5vdGUgYW4gaW1wb3J0YW50IGh1Yi5cbiAgICAgICogV2UgdGFrZSB0aGUgbWVhbiArIDIqc3RkIGFzIHRoZSBpbXBvcnRhbnQgaHViIHNpemUuIChBc3N1bWluZyBhIG5vcm1hbCBkaXN0cmlidXRpb24gb2YgZGF0YSwgfjIuMiUpXG4gICAgICAqXG4gICAgICAqIEBwcml2YXRlXG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2dldEh1YlNpemUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRIdWJTaXplKCkge1xuICAgICAgICB2YXIgYXZlcmFnZSA9IDA7XG4gICAgICAgIHZhciBhdmVyYWdlU3F1YXJlZCA9IDA7XG4gICAgICAgIHZhciBodWJDb3VudGVyID0gMDtcbiAgICAgICAgdmFyIGxhcmdlc3RIdWIgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbdGhpcy5ib2R5Lm5vZGVJbmRpY2VzW2ldXTtcbiAgICAgICAgICBpZiAobm9kZS5lZGdlcy5sZW5ndGggPiBsYXJnZXN0SHViKSB7XG4gICAgICAgICAgICBsYXJnZXN0SHViID0gbm9kZS5lZGdlcy5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF2ZXJhZ2UgKz0gbm9kZS5lZGdlcy5sZW5ndGg7XG4gICAgICAgICAgYXZlcmFnZVNxdWFyZWQgKz0gTWF0aC5wb3cobm9kZS5lZGdlcy5sZW5ndGgsIDIpO1xuICAgICAgICAgIGh1YkNvdW50ZXIgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBhdmVyYWdlID0gYXZlcmFnZSAvIGh1YkNvdW50ZXI7XG4gICAgICAgIGF2ZXJhZ2VTcXVhcmVkID0gYXZlcmFnZVNxdWFyZWQgLyBodWJDb3VudGVyO1xuXG4gICAgICAgIHZhciB2YXJpYW5jZSA9IGF2ZXJhZ2VTcXVhcmVkIC0gTWF0aC5wb3coYXZlcmFnZSwgMik7XG4gICAgICAgIHZhciBzdGFuZGFyZERldmlhdGlvbiA9IE1hdGguc3FydCh2YXJpYW5jZSk7XG5cbiAgICAgICAgdmFyIGh1YlRocmVzaG9sZCA9IE1hdGguZmxvb3IoYXZlcmFnZSArIDIgKiBzdGFuZGFyZERldmlhdGlvbik7XG5cbiAgICAgICAgLy8gYWx3YXlzIGhhdmUgYXQgbGVhc3Qgb25lIHRvIGNsdXN0ZXJcbiAgICAgICAgaWYgKGh1YlRocmVzaG9sZCA+IGxhcmdlc3RIdWIpIHtcbiAgICAgICAgICBodWJUaHJlc2hvbGQgPSBsYXJnZXN0SHViO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGh1YlRocmVzaG9sZDtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQ2x1c3RlckVuZ2luZTtcbiAgfSgpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IENsdXN0ZXJFbmdpbmU7XG5cbi8qKiovIH0sXG4vKiAxMDMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbiAgdmFyIE5ldHdvcmtVdGlsID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5ldHdvcmtVdGlsKCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5ldHdvcmtVdGlsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBjZW50ZXIgcG9zaXRpb24gb2YgdGhlIG5ldHdvcmsgY29uc2lkZXJpbmcgdGhlIGJvdW5kaW5nIGJveGVzXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhOZXR3b3JrVXRpbCwgbnVsbCwgW3tcbiAgICAgIGtleTogXCJnZXRSYW5nZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJhbmdlKGFsbE5vZGVzKSB7XG4gICAgICAgIHZhciBzcGVjaWZpY05vZGVzID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gW10gOiBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgdmFyIG1pblkgPSAxZTksXG4gICAgICAgICAgICBtYXhZID0gLTFlOSxcbiAgICAgICAgICAgIG1pblggPSAxZTksXG4gICAgICAgICAgICBtYXhYID0gLTFlOSxcbiAgICAgICAgICAgIG5vZGU7XG4gICAgICAgIGlmIChzcGVjaWZpY05vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwZWNpZmljTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG5vZGUgPSBhbGxOb2Rlc1tzcGVjaWZpY05vZGVzW2ldXTtcbiAgICAgICAgICAgIGlmIChtaW5YID4gbm9kZS5zaGFwZS5ib3VuZGluZ0JveC5sZWZ0KSB7XG4gICAgICAgICAgICAgIG1pblggPSBub2RlLnNoYXBlLmJvdW5kaW5nQm94LmxlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF4WCA8IG5vZGUuc2hhcGUuYm91bmRpbmdCb3gucmlnaHQpIHtcbiAgICAgICAgICAgICAgbWF4WCA9IG5vZGUuc2hhcGUuYm91bmRpbmdCb3gucmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWluWSA+IG5vZGUuc2hhcGUuYm91bmRpbmdCb3gudG9wKSB7XG4gICAgICAgICAgICAgIG1pblkgPSBub2RlLnNoYXBlLmJvdW5kaW5nQm94LnRvcDtcbiAgICAgICAgICAgIH0gLy8gdG9wIGlzIG5lZ2F0aXZlLCBib3R0b20gaXMgcG9zaXRpdmVcbiAgICAgICAgICAgIGlmIChtYXhZIDwgbm9kZS5zaGFwZS5ib3VuZGluZ0JveC5ib3R0b20pIHtcbiAgICAgICAgICAgICAgbWF4WSA9IG5vZGUuc2hhcGUuYm91bmRpbmdCb3guYm90dG9tO1xuICAgICAgICAgICAgfSAvLyB0b3AgaXMgbmVnYXRpdmUsIGJvdHRvbSBpcyBwb3NpdGl2ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtaW5YID09PSAxZTkgJiYgbWF4WCA9PT0gLTFlOSAmJiBtaW5ZID09PSAxZTkgJiYgbWF4WSA9PT0gLTFlOSkge1xuICAgICAgICAgIG1pblkgPSAwLCBtYXhZID0gMCwgbWluWCA9IDAsIG1heFggPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG1pblg6IG1pblgsIG1heFg6IG1heFgsIG1pblk6IG1pblksIG1heFk6IG1heFkgfTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBGaW5kIHRoZSBjZW50ZXIgcG9zaXRpb24gb2YgdGhlIG5ldHdvcmtcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImdldFJhbmdlQ29yZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJhbmdlQ29yZShhbGxOb2Rlcykge1xuICAgICAgICB2YXIgc3BlY2lmaWNOb2RlcyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IFtdIDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgIHZhciBtaW5ZID0gMWU5LFxuICAgICAgICAgICAgbWF4WSA9IC0xZTksXG4gICAgICAgICAgICBtaW5YID0gMWU5LFxuICAgICAgICAgICAgbWF4WCA9IC0xZTksXG4gICAgICAgICAgICBub2RlO1xuICAgICAgICBpZiAoc3BlY2lmaWNOb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGVjaWZpY05vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBub2RlID0gYWxsTm9kZXNbc3BlY2lmaWNOb2Rlc1tpXV07XG4gICAgICAgICAgICBpZiAobWluWCA+IG5vZGUueCkge1xuICAgICAgICAgICAgICBtaW5YID0gbm9kZS54O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1heFggPCBub2RlLngpIHtcbiAgICAgICAgICAgICAgbWF4WCA9IG5vZGUueDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtaW5ZID4gbm9kZS55KSB7XG4gICAgICAgICAgICAgIG1pblkgPSBub2RlLnk7XG4gICAgICAgICAgICB9IC8vIHRvcCBpcyBuZWdhdGl2ZSwgYm90dG9tIGlzIHBvc2l0aXZlXG4gICAgICAgICAgICBpZiAobWF4WSA8IG5vZGUueSkge1xuICAgICAgICAgICAgICBtYXhZID0gbm9kZS55O1xuICAgICAgICAgICAgfSAvLyB0b3AgaXMgbmVnYXRpdmUsIGJvdHRvbSBpcyBwb3NpdGl2ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtaW5YID09PSAxZTkgJiYgbWF4WCA9PT0gLTFlOSAmJiBtaW5ZID09PSAxZTkgJiYgbWF4WSA9PT0gLTFlOSkge1xuICAgICAgICAgIG1pblkgPSAwLCBtYXhZID0gMCwgbWluWCA9IDAsIG1heFggPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG1pblg6IG1pblgsIG1heFg6IG1heFgsIG1pblk6IG1pblksIG1heFk6IG1heFkgfTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge29iamVjdH0gcmFuZ2UgPSB7bWluWDogbWluWCwgbWF4WDogbWF4WCwgbWluWTogbWluWSwgbWF4WTogbWF4WX07XG4gICAgICAgKiBAcmV0dXJucyB7e3g6IG51bWJlciwgeTogbnVtYmVyfX1cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImZpbmRDZW50ZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kQ2VudGVyKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiB7IHg6IDAuNSAqIChyYW5nZS5tYXhYICsgcmFuZ2UubWluWCksXG4gICAgICAgICAgeTogMC41ICogKHJhbmdlLm1heFkgKyByYW5nZS5taW5ZKSB9O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgcmV0dXJucyBhIGNsb25lIG9mIHRoZSBvcHRpb25zIG9yIG9wdGlvbnMgb2YgdGhlIGVkZ2Ugb3Igbm9kZSB0byBiZSB1c2VkIGZvciBjb25zdHJ1Y3Rpb24gb2YgbmV3IGVkZ2VzIG9yIGNoZWNrIGZ1bmN0aW9ucyBmb3IgbmV3IG5vZGVzLlxuICAgICAgICogQHBhcmFtIGl0ZW1cbiAgICAgICAqIEBwYXJhbSB0eXBlXG4gICAgICAgKiBAcmV0dXJucyB7e319XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjbG9uZU9wdGlvbnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZU9wdGlvbnMoaXRlbSwgdHlwZSkge1xuICAgICAgICB2YXIgY2xvbmVkT3B0aW9ucyA9IHt9O1xuICAgICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09ICdub2RlJykge1xuICAgICAgICAgIHV0aWwuZGVlcEV4dGVuZChjbG9uZWRPcHRpb25zLCBpdGVtLm9wdGlvbnMsIHRydWUpO1xuICAgICAgICAgIGNsb25lZE9wdGlvbnMueCA9IGl0ZW0ueDtcbiAgICAgICAgICBjbG9uZWRPcHRpb25zLnkgPSBpdGVtLnk7XG4gICAgICAgICAgY2xvbmVkT3B0aW9ucy5hbW91bnRPZkNvbm5lY3Rpb25zID0gaXRlbS5lZGdlcy5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXRpbC5kZWVwRXh0ZW5kKGNsb25lZE9wdGlvbnMsIGl0ZW0ub3B0aW9ucywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsb25lZE9wdGlvbnM7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIE5ldHdvcmtVdGlsO1xuICB9KCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gTmV0d29ya1V0aWw7XG5cbi8qKiovIH0sXG4vKiAxMDQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX05vZGUyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NSk7XG5cbiAgdmFyIF9Ob2RlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX05vZGUyKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbiAgLyoqXG4gICAqXG4gICAqL1xuXG4gIHZhciBDbHVzdGVyID0gZnVuY3Rpb24gKF9Ob2RlKSB7XG4gICAgX2luaGVyaXRzKENsdXN0ZXIsIF9Ob2RlKTtcblxuICAgIGZ1bmN0aW9uIENsdXN0ZXIob3B0aW9ucywgYm9keSwgaW1hZ2VsaXN0LCBncm91cGxpc3QsIGdsb2JhbE9wdGlvbnMpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDbHVzdGVyKTtcblxuICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKENsdXN0ZXIpLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgaW1hZ2VsaXN0LCBncm91cGxpc3QsIGdsb2JhbE9wdGlvbnMpKTtcblxuICAgICAgX3RoaXMuaXNDbHVzdGVyID0gdHJ1ZTtcbiAgICAgIF90aGlzLmNvbnRhaW5lZE5vZGVzID0ge307XG4gICAgICBfdGhpcy5jb250YWluZWRFZGdlcyA9IHt9O1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBDbHVzdGVyO1xuICB9KF9Ob2RlMy5kZWZhdWx0KTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBDbHVzdGVyO1xuXG4vKioqLyB9LFxuLyogMTA1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG4gIH1cblxuICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbiAgdmFyIENhbnZhc1JlbmRlcmVyID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhbnZhc1JlbmRlcmVyKGJvZHksIGNhbnZhcykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhbnZhc1JlbmRlcmVyKTtcblxuICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuXG4gICAgICB0aGlzLnJlZHJhd1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5yZW5kZXJUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMucmVxdWlyZXNUaW1lb3V0ID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVuZGVyaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgICB0aGlzLnJlbmRlclJlcXVlc3RzID0gMDtcbiAgICAgIHRoaXMucGl4ZWxSYXRpbyA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuYWxsb3dSZWRyYXcgPSB0cnVlO1xuXG4gICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICAgIGhpZGVFZGdlc09uRHJhZzogZmFsc2UsXG4gICAgICAgIGhpZGVOb2Rlc09uRHJhZzogZmFsc2VcbiAgICAgIH07XG4gICAgICB1dGlsLmV4dGVuZCh0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gICAgICB0aGlzLl9kZXRlcm1pbmVCcm93c2VyTWV0aG9kKCk7XG4gICAgICB0aGlzLmJpbmRFdmVudExpc3RlbmVycygpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhDYW52YXNSZW5kZXJlciwgW3tcbiAgICAgIGtleTogJ2JpbmRFdmVudExpc3RlbmVycycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiZHJhZ1N0YXJ0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImRyYWdFbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfcmVzaXplTm9kZXNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5fcmVzaXplTm9kZXMoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX3JlZHJhd1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKF90aGlzLnJlbmRlcmluZ0FjdGl2ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIF90aGlzLl9yZWRyYXcoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9ibG9ja1JlZHJhd1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMuYWxsb3dSZWRyYXcgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2FsbG93UmVkcmF3XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy5hbGxvd1JlZHJhdyA9IHRydWU7X3RoaXMucmVkcmF3UmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9yZXF1ZXN0UmVkcmF3XCIsIHRoaXMuX3JlcXVlc3RSZWRyYXcuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX3N0YXJ0UmVuZGVyaW5nXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy5yZW5kZXJSZXF1ZXN0cyArPSAxO1xuICAgICAgICAgIF90aGlzLnJlbmRlcmluZ0FjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgX3RoaXMuX3N0YXJ0UmVuZGVyaW5nKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9zdG9wUmVuZGVyaW5nXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy5yZW5kZXJSZXF1ZXN0cyAtPSAxO1xuICAgICAgICAgIF90aGlzLnJlbmRlcmluZ0FjdGl2ZSA9IF90aGlzLnJlbmRlclJlcXVlc3RzID4gMDtcbiAgICAgICAgICBfdGhpcy5yZW5kZXJUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLnJlbmRlclJlcXVlc3RzID0gMDtcbiAgICAgICAgICBfdGhpcy5hbGxvd1JlZHJhdyA9IGZhbHNlO1xuICAgICAgICAgIF90aGlzLnJlbmRlcmluZ0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgIGlmIChfdGhpcy5yZXF1aXJlc1RpbWVvdXQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy5yZW5kZXJUaW1lcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKF90aGlzLnJlbmRlclRpbWVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3RoaXMuYm9keS5lbWl0dGVyLm9mZigpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzZXRPcHRpb25zJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBmaWVsZHMgPSBbJ2hpZGVFZGdlc09uRHJhZycsICdoaWRlTm9kZXNPbkRyYWcnXTtcbiAgICAgICAgICB1dGlsLnNlbGVjdGl2ZURlZXBFeHRlbmQoZmllbGRzLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX3N0YXJ0UmVuZGVyaW5nJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc3RhcnRSZW5kZXJpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlbmRlcmluZ0FjdGl2ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGlmICh0aGlzLnJlbmRlclRpbWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlcXVpcmVzVGltZW91dCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICB0aGlzLnJlbmRlclRpbWVyID0gd2luZG93LnNldFRpbWVvdXQodGhpcy5fcmVuZGVyU3RlcC5iaW5kKHRoaXMpLCB0aGlzLnNpbXVsYXRpb25JbnRlcnZhbCk7IC8vIHdhaXQgdGhpcy5yZW5kZXJUaW1lU3RlcCBtaWxsaXNlY29uZHMgYW5kIHBlcmZvcm0gdGhlIGFuaW1hdGlvbiBzdGVwIGZ1bmN0aW9uXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyVGltZXIgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlbmRlclN0ZXAuYmluZCh0aGlzKSk7IC8vIHdhaXQgdGhpcy5yZW5kZXJUaW1lU3RlcCBtaWxsaXNlY29uZHMgYW5kIHBlcmZvcm0gdGhlIGFuaW1hdGlvbiBzdGVwIGZ1bmN0aW9uXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfcmVuZGVyU3RlcCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbmRlclN0ZXAoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlbmRlcmluZ0FjdGl2ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIC8vIHJlc2V0IHRoZSByZW5kZXJUaW1lciBzbyBhIG5ldyBzY2hlZHVsZWQgYW5pbWF0aW9uIHN0ZXAgY2FuIGJlIHNldFxuICAgICAgICAgIHRoaXMucmVuZGVyVGltZXIgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBpZiAodGhpcy5yZXF1aXJlc1RpbWVvdXQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgc2NoZWR1bGVzIGEgbmV3IHNpbXVsYXRpb24gc3RlcFxuICAgICAgICAgICAgdGhpcy5fc3RhcnRSZW5kZXJpbmcoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9yZWRyYXcoKTtcblxuICAgICAgICAgIGlmICh0aGlzLnJlcXVpcmVzVGltZW91dCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgc2NoZWR1bGVzIGEgbmV3IHNpbXVsYXRpb24gc3RlcFxuICAgICAgICAgICAgdGhpcy5fc3RhcnRSZW5kZXJpbmcoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZWRyYXcgdGhlIG5ldHdvcmsgd2l0aCB0aGUgY3VycmVudCBkYXRhXG4gICAgICAgKiBjaGFydCB3aWxsIGJlIHJlc2l6ZWQgdG9vLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyZWRyYXcnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlZHJhdygpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnc2V0U2l6ZScpO1xuICAgICAgICB0aGlzLl9yZWRyYXcoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZWRyYXcgdGhlIG5ldHdvcmsgd2l0aCB0aGUgY3VycmVudCBkYXRhXG4gICAgICAgKiBAcGFyYW0gaGlkZGVuIHwgdXNlZCB0byBnZXQgdGhlIGZpcnN0IGVzdGltYXRlIG9mIHRoZSBub2RlIHNpemVzLiBvbmx5IHRoZSBub2RlcyBhcmUgZHJhd24gYWZ0ZXIgd2hpY2ggdGhleSBhcmUgcXVpY2tseSBkcmF3biBvdmVyLlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3JlcXVlc3RSZWRyYXcnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXF1ZXN0UmVkcmF3KCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICBpZiAodGhpcy5yZWRyYXdSZXF1ZXN0ZWQgIT09IHRydWUgJiYgdGhpcy5yZW5kZXJpbmdBY3RpdmUgPT09IGZhbHNlICYmIHRoaXMuYWxsb3dSZWRyYXcgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLnJlZHJhd1JlcXVlc3RlZCA9IHRydWU7XG4gICAgICAgICAgaWYgKHRoaXMucmVxdWlyZXNUaW1lb3V0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzMi5fcmVkcmF3KGZhbHNlKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXMyLl9yZWRyYXcoZmFsc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX3JlZHJhdycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3JlZHJhdygpIHtcbiAgICAgICAgdmFyIGhpZGRlbiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogYXJndW1lbnRzWzBdO1xuXG4gICAgICAgIGlmICh0aGlzLmFsbG93UmVkcmF3ID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImluaXRSZWRyYXdcIik7XG5cbiAgICAgICAgICB0aGlzLnJlZHJhd1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICAgIHZhciBjdHggPSB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICAgIC8vIHdoZW4gdGhlIGNvbnRhaW5lciBkaXYgd2FzIGhpZGRlbiwgdGhpcyBmaXhlcyBpdCBiYWNrIHVwIVxuICAgICAgICAgIGlmICh0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMud2lkdGggPT09IDAgfHwgdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmhlaWdodCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuc2V0U2l6ZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMucGl4ZWxSYXRpbyA9ICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSAvIChjdHgud2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHguYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCAxKTtcblxuICAgICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0odGhpcy5waXhlbFJhdGlvLCAwLCAwLCB0aGlzLnBpeGVsUmF0aW8sIDAsIDApO1xuXG4gICAgICAgICAgLy8gY2xlYXIgdGhlIGNhbnZhc1xuICAgICAgICAgIHZhciB3ID0gdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoO1xuICAgICAgICAgIHZhciBoID0gdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodDtcbiAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHcsIGgpO1xuXG4gICAgICAgICAgLy8gaWYgdGhlIGRpdiBpcyBoaWRkZW4sIHdlIHN0b3AgdGhlIHJlZHJhdyBoZXJlIGZvciBwZXJmb3JtYW5jZS5cbiAgICAgICAgICBpZiAodGhpcy5jYW52YXMuZnJhbWUuY2xpZW50V2lkdGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBzZXQgc2NhbGluZyBhbmQgdHJhbnNsYXRpb25cbiAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgIGN0eC50cmFuc2xhdGUodGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueCwgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueSk7XG4gICAgICAgICAgY3R4LnNjYWxlKHRoaXMuYm9keS52aWV3LnNjYWxlLCB0aGlzLmJvZHkudmlldy5zY2FsZSk7XG5cbiAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImJlZm9yZURyYXdpbmdcIiwgY3R4KTtcbiAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG5cbiAgICAgICAgICBpZiAoaGlkZGVuID09PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcgPT09IGZhbHNlIHx8IHRoaXMuZHJhZ2dpbmcgPT09IHRydWUgJiYgdGhpcy5vcHRpb25zLmhpZGVFZGdlc09uRHJhZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgdGhpcy5fZHJhd0VkZ2VzKGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcgPT09IGZhbHNlIHx8IHRoaXMuZHJhZ2dpbmcgPT09IHRydWUgJiYgdGhpcy5vcHRpb25zLmhpZGVOb2Rlc09uRHJhZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2RyYXdOb2RlcyhjdHgsIGhpZGRlbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJhZnRlckRyYXdpbmdcIiwgY3R4KTtcbiAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG5cbiAgICAgICAgICAvLyByZXN0b3JlIG9yaWdpbmFsIHNjYWxpbmcgYW5kIHRyYW5zbGF0aW9uXG4gICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICBpZiAoaGlkZGVuID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHcsIGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlZHJhdyBhbGwgbm9kZXNcbiAgICAgICAqIFRoZSAyZCBjb250ZXh0IG9mIGEgSFRNTCBjYW52YXMgY2FuIGJlIHJldHJpZXZlZCBieSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAgIGN0eFxuICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbYWx3YXlzU2hvd11cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19yZXNpemVOb2RlcycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc2l6ZU5vZGVzKCkge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGlmICh0aGlzLnBpeGVsUmF0aW8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMucGl4ZWxSYXRpbyA9ICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSAvIChjdHgud2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHguYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCAxKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguc2V0VHJhbnNmb3JtKHRoaXMucGl4ZWxSYXRpbywgMCwgMCwgdGhpcy5waXhlbFJhdGlvLCAwLCAwKTtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi54LCB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi55KTtcbiAgICAgICAgY3R4LnNjYWxlKHRoaXMuYm9keS52aWV3LnNjYWxlLCB0aGlzLmJvZHkudmlldy5zY2FsZSk7XG5cbiAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgICB2YXIgbm9kZSA9IHZvaWQgMDtcblxuICAgICAgICAvLyByZXNpemUgYWxsIG5vZGVzXG4gICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiBub2Rlcykge1xuICAgICAgICAgIGlmIChub2Rlcy5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICAgIG5vZGUucmVzaXplKGN0eCk7XG4gICAgICAgICAgICBub2RlLnVwZGF0ZUJvdW5kaW5nQm94KGN0eCwgbm9kZS5zZWxlY3RlZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVzdG9yZSBvcmlnaW5hbCBzY2FsaW5nIGFuZCB0cmFuc2xhdGlvblxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlZHJhdyBhbGwgbm9kZXNcbiAgICAgICAqIFRoZSAyZCBjb250ZXh0IG9mIGEgSFRNTCBjYW52YXMgY2FuIGJlIHJldHJpZXZlZCBieSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAgIGN0eFxuICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbYWx3YXlzU2hvd11cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19kcmF3Tm9kZXMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3Tm9kZXMoY3R4KSB7XG4gICAgICAgIHZhciBhbHdheXNTaG93ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgICB2YXIgbm9kZUluZGljZXMgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG4gICAgICAgIHZhciBub2RlID0gdm9pZCAwO1xuICAgICAgICB2YXIgc2VsZWN0ZWQgPSBbXTtcbiAgICAgICAgdmFyIG1hcmdpbiA9IDIwO1xuICAgICAgICB2YXIgdG9wTGVmdCA9IHRoaXMuY2FudmFzLkRPTXRvQ2FudmFzKHsgeDogLW1hcmdpbiwgeTogLW1hcmdpbiB9KTtcbiAgICAgICAgdmFyIGJvdHRvbVJpZ2h0ID0gdGhpcy5jYW52YXMuRE9NdG9DYW52YXMoe1xuICAgICAgICAgIHg6IHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCArIG1hcmdpbixcbiAgICAgICAgICB5OiB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0ICsgbWFyZ2luXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgdmlld2FibGVBcmVhID0geyB0b3A6IHRvcExlZnQueSwgbGVmdDogdG9wTGVmdC54LCBib3R0b206IGJvdHRvbVJpZ2h0LnksIHJpZ2h0OiBib3R0b21SaWdodC54IH07XG5cbiAgICAgICAgLy8gZHJhdyB1bnNlbGVjdGVkIG5vZGVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbm9kZSA9IG5vZGVzW25vZGVJbmRpY2VzW2ldXTtcbiAgICAgICAgICAvLyBzZXQgc2VsZWN0ZWQgbm9kZXMgYXNpZGVcbiAgICAgICAgICBpZiAobm9kZS5pc1NlbGVjdGVkKCkpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkLnB1c2gobm9kZUluZGljZXNbaV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYWx3YXlzU2hvdyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICBub2RlLmRyYXcoY3R4KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5pc0JvdW5kaW5nQm94T3ZlcmxhcHBpbmdXaXRoKHZpZXdhYmxlQXJlYSkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgbm9kZS5kcmF3KGN0eCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBub2RlLnVwZGF0ZUJvdW5kaW5nQm94KGN0eCwgbm9kZS5zZWxlY3RlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZHJhdyB0aGUgc2VsZWN0ZWQgbm9kZXMgb24gdG9wXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBzZWxlY3RlZC5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICBub2RlID0gbm9kZXNbc2VsZWN0ZWRbX2ldXTtcbiAgICAgICAgICBub2RlLmRyYXcoY3R4KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlZHJhdyBhbGwgZWRnZXNcbiAgICAgICAqIFRoZSAyZCBjb250ZXh0IG9mIGEgSFRNTCBjYW52YXMgY2FuIGJlIHJldHJpZXZlZCBieSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAgIGN0eFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2RyYXdFZGdlcycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdFZGdlcyhjdHgpIHtcbiAgICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuICAgICAgICB2YXIgZWRnZUluZGljZXMgPSB0aGlzLmJvZHkuZWRnZUluZGljZXM7XG4gICAgICAgIHZhciBlZGdlID0gdm9pZCAwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBlZGdlID0gZWRnZXNbZWRnZUluZGljZXNbaV1dO1xuICAgICAgICAgIGlmIChlZGdlLmNvbm5lY3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgZWRnZS5kcmF3KGN0eCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRGV0ZXJtaW5lIGlmIHRoZSBicm93c2VyIHJlcXVpcmVzIGEgc2V0VGltZW91dCBvciBhIHJlcXVlc3RBbmltYXRpb25GcmFtZS4gVGhpcyB3YXMgcmVxdWlyZWQgYmVjYXVzZVxuICAgICAgICogc29tZSBpbXBsZW1lbnRhdGlvbnMgKHNhZmFyaSBhbmQgSUU5KSBkaWQgbm90IHN1cHBvcnQgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZGV0ZXJtaW5lQnJvd3Nlck1ldGhvZCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2RldGVybWluZUJyb3dzZXJNZXRob2QoKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHZhciBicm93c2VyVHlwZSA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICB0aGlzLnJlcXVpcmVzVGltZW91dCA9IGZhbHNlO1xuICAgICAgICAgIGlmIChicm93c2VyVHlwZS5pbmRleE9mKCdtc2llIDkuMCcpICE9IC0xKSB7XG4gICAgICAgICAgICAvLyBJRSA5XG4gICAgICAgICAgICB0aGlzLnJlcXVpcmVzVGltZW91dCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChicm93c2VyVHlwZS5pbmRleE9mKCdzYWZhcmknKSAhPSAtMSkge1xuICAgICAgICAgICAgLy8gc2FmYXJpXG4gICAgICAgICAgICBpZiAoYnJvd3NlclR5cGUuaW5kZXhPZignY2hyb21lJykgPD0gLTEpIHtcbiAgICAgICAgICAgICAgdGhpcy5yZXF1aXJlc1RpbWVvdXQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlcXVpcmVzVGltZW91dCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQ2FudmFzUmVuZGVyZXI7XG4gIH0oKTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBDYW52YXNSZW5kZXJlcjtcblxuLyoqKi8gfSxcbi8qIDEwNiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICB2YXIgSGFtbWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG4gIHZhciBoYW1tZXJVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG5cbiAgdmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIG1haW4gZnJhbWUgZm9yIHRoZSBOZXR3b3JrLlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIG9uY2Ugd2hlbiBhIE5ldHdvcmsgb2JqZWN0IGlzIGNyZWF0ZWQuIFRoZSBmcmFtZVxuICAgKiBjb250YWlucyBhIGNhbnZhcywgYW5kIHRoaXMgY2FudmFzIGNvbnRhaW5zIGFsbCBvYmplY3RzIGxpa2UgdGhlIGF4aXMgYW5kXG4gICAqIG5vZGVzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB2YXIgQ2FudmFzID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhbnZhcyhib2R5KSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FudmFzKTtcblxuICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgIHRoaXMucGl4ZWxSYXRpbyA9IDE7XG4gICAgICB0aGlzLnJlc2l6ZVRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5yZXNpemVGdW5jdGlvbiA9IHRoaXMuX29uUmVzaXplLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLmNhbWVyYVN0YXRlID0ge307XG4gICAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG5cbiAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgICAgYXV0b1Jlc2l6ZTogdHJ1ZSxcbiAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgIHdpZHRoOiAnMTAwJSdcbiAgICAgIH07XG4gICAgICB1dGlsLmV4dGVuZCh0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gICAgICB0aGlzLmJpbmRFdmVudExpc3RlbmVycygpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhDYW52YXMsIFt7XG4gICAgICBrZXk6ICdiaW5kRXZlbnRMaXN0ZW5lcnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAvLyBiaW5kIHRoZSBldmVudHNcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub25jZShcInJlc2l6ZVwiLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgaWYgKG9iai53aWR0aCAhPT0gMCkge1xuICAgICAgICAgICAgX3RoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnggPSBvYmoud2lkdGggKiAwLjU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmouaGVpZ2h0ICE9PSAwKSB7XG4gICAgICAgICAgICBfdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueSA9IG9iai5oZWlnaHQgKiAwLjU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJzZXRTaXplXCIsIHRoaXMuc2V0U2l6ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJkZXN0cm95XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy5oYW1tZXJGcmFtZS5kZXN0cm95KCk7XG4gICAgICAgICAgX3RoaXMuaGFtbWVyLmRlc3Ryb3koKTtcbiAgICAgICAgICBfdGhpcy5fY2xlYW5VcCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzZXRPcHRpb25zJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBmaWVsZHMgPSBbJ3dpZHRoJywgJ2hlaWdodCcsICdhdXRvUmVzaXplJ107XG4gICAgICAgICAgdXRpbC5zZWxlY3RpdmVEZWVwRXh0ZW5kKGZpZWxkcywgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b1Jlc2l6ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgYWRhcHQgdG8gYSBjaGFuZ2luZyBzaXplIG9mIHRoZSBicm93c2VyLlxuICAgICAgICAgIHRoaXMuX2NsZWFuVXAoKTtcbiAgICAgICAgICB0aGlzLnJlc2l6ZVRpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNoYW5nZWQgPSBfdGhpczIuc2V0U2l6ZSgpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgX3RoaXMyLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgICAgdGhpcy5yZXNpemVGdW5jdGlvbiA9IHRoaXMuX29uUmVzaXplLmJpbmQodGhpcyk7XG4gICAgICAgICAgdXRpbC5hZGRFdmVudExpc3RlbmVyKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMucmVzaXplRnVuY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2NsZWFuVXAnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jbGVhblVwKCkge1xuICAgICAgICAvLyBhdXRvbWF0aWNhbGx5IGFkYXB0IHRvIGEgY2hhbmdpbmcgc2l6ZSBvZiB0aGUgYnJvd3Nlci5cbiAgICAgICAgaWYgKHRoaXMucmVzaXplVGltZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5yZXNpemVUaW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5yZW1vdmVFdmVudExpc3RlbmVyKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMucmVzaXplRnVuY3Rpb24pO1xuICAgICAgICB0aGlzLnJlc2l6ZUZ1bmN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19vblJlc2l6ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX29uUmVzaXplKCkge1xuICAgICAgICB0aGlzLnNldFNpemUoKTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZWRyYXdcIik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0IGFuZCBzdG9yZSB0aGUgY2FtZXJhU3RhdGVcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19nZXRDYW1lcmFTdGF0ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldENhbWVyYVN0YXRlKCkge1xuICAgICAgICB2YXIgcGl4ZWxSYXRpbyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHRoaXMucGl4ZWxSYXRpbyA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgICBpZiAodGhpcy5pbml0aWFsaXplZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuY2FtZXJhU3RhdGUucHJldmlvdXNXaWR0aCA9IHRoaXMuZnJhbWUuY2FudmFzLndpZHRoIC8gcGl4ZWxSYXRpbztcbiAgICAgICAgICB0aGlzLmNhbWVyYVN0YXRlLnByZXZpb3VzSGVpZ2h0ID0gdGhpcy5mcmFtZS5jYW52YXMuaGVpZ2h0IC8gcGl4ZWxSYXRpbztcbiAgICAgICAgICB0aGlzLmNhbWVyYVN0YXRlLnNjYWxlID0gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICAgICAgdGhpcy5jYW1lcmFTdGF0ZS5wb3NpdGlvbiA9IHRoaXMuRE9NdG9DYW52YXMoe1xuICAgICAgICAgICAgeDogMC41ICogdGhpcy5mcmFtZS5jYW52YXMud2lkdGggLyBwaXhlbFJhdGlvLFxuICAgICAgICAgICAgeTogMC41ICogdGhpcy5mcmFtZS5jYW52YXMuaGVpZ2h0IC8gcGl4ZWxSYXRpb1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0IHRoZSBjYW1lcmFTdGF0ZVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3NldENhbWVyYVN0YXRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0Q2FtZXJhU3RhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbWVyYVN0YXRlLnNjYWxlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGggIT09IDAgJiYgdGhpcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0ICE9PSAwICYmIHRoaXMucGl4ZWxSYXRpbyAhPT0gMCAmJiB0aGlzLmNhbWVyYVN0YXRlLnByZXZpb3VzV2lkdGggPiAwKSB7XG5cbiAgICAgICAgICB2YXIgd2lkdGhSYXRpbyA9IHRoaXMuZnJhbWUuY2FudmFzLndpZHRoIC8gdGhpcy5waXhlbFJhdGlvIC8gdGhpcy5jYW1lcmFTdGF0ZS5wcmV2aW91c1dpZHRoO1xuICAgICAgICAgIHZhciBoZWlnaHRSYXRpbyA9IHRoaXMuZnJhbWUuY2FudmFzLmhlaWdodCAvIHRoaXMucGl4ZWxSYXRpbyAvIHRoaXMuY2FtZXJhU3RhdGUucHJldmlvdXNIZWlnaHQ7XG4gICAgICAgICAgdmFyIG5ld1NjYWxlID0gdGhpcy5jYW1lcmFTdGF0ZS5zY2FsZTtcblxuICAgICAgICAgIGlmICh3aWR0aFJhdGlvICE9IDEgJiYgaGVpZ2h0UmF0aW8gIT0gMSkge1xuICAgICAgICAgICAgbmV3U2NhbGUgPSB0aGlzLmNhbWVyYVN0YXRlLnNjYWxlICogMC41ICogKHdpZHRoUmF0aW8gKyBoZWlnaHRSYXRpbyk7XG4gICAgICAgICAgfSBlbHNlIGlmICh3aWR0aFJhdGlvICE9IDEpIHtcbiAgICAgICAgICAgIG5ld1NjYWxlID0gdGhpcy5jYW1lcmFTdGF0ZS5zY2FsZSAqIHdpZHRoUmF0aW87XG4gICAgICAgICAgfSBlbHNlIGlmIChoZWlnaHRSYXRpbyAhPSAxKSB7XG4gICAgICAgICAgICBuZXdTY2FsZSA9IHRoaXMuY2FtZXJhU3RhdGUuc2NhbGUgKiBoZWlnaHRSYXRpbztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmJvZHkudmlldy5zY2FsZSA9IG5ld1NjYWxlO1xuICAgICAgICAgIC8vIHRoaXMgY29tZXMgZnJvbSB0aGUgdmlldyBtb2R1bGUuXG4gICAgICAgICAgdmFyIGN1cnJlbnRWaWV3Q2VudGVyID0gdGhpcy5ET010b0NhbnZhcyh7XG4gICAgICAgICAgICB4OiAwLjUgKiB0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgIHk6IDAuNSAqIHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIGRpc3RhbmNlRnJvbUNlbnRlciA9IHsgLy8gb2Zmc2V0IGZyb20gdmlldywgZGlzdGFuY2UgdmlldyBoYXMgdG8gY2hhbmdlIGJ5IHRoZXNlIHggYW5kIHkgdG8gY2VudGVyIHRoZSBub2RlXG4gICAgICAgICAgICB4OiBjdXJyZW50Vmlld0NlbnRlci54IC0gdGhpcy5jYW1lcmFTdGF0ZS5wb3NpdGlvbi54LFxuICAgICAgICAgICAgeTogY3VycmVudFZpZXdDZW50ZXIueSAtIHRoaXMuY2FtZXJhU3RhdGUucG9zaXRpb24ueVxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueCArPSBkaXN0YW5jZUZyb21DZW50ZXIueCAqIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnkgKz0gZGlzdGFuY2VGcm9tQ2VudGVyLnkgKiB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19wcmVwYXJlVmFsdWUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9wcmVwYXJlVmFsdWUodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUgKyAncHgnO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpZiAodmFsdWUuaW5kZXhPZignJScpICE9PSAtMSB8fCB2YWx1ZS5pbmRleE9mKCdweCcpICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUuaW5kZXhPZignJScpID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICsgJ3B4JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgdXNlIHRoZSB2YWx1ZSBzdXBwbGllZCBmb3Igd2lkdGggb3IgaGVpZ2h0OicgKyB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlIHRoZSBIVE1MXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19jcmVhdGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGUoKSB7XG4gICAgICAgIC8vIHJlbW92ZSBhbGwgZWxlbWVudHMgZnJvbSB0aGUgY29udGFpbmVyIGVsZW1lbnQuXG4gICAgICAgIHdoaWxlICh0aGlzLmJvZHkuY29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgIHRoaXMuYm9keS5jb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5ib2R5LmNvbnRhaW5lci5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5mcmFtZS5jbGFzc05hbWUgPSAndmlzLW5ldHdvcmsnO1xuICAgICAgICB0aGlzLmZyYW1lLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgICAgdGhpcy5mcmFtZS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICB0aGlzLmZyYW1lLnRhYkluZGV4ID0gOTAwOyAvLyB0YWIgaW5kZXggaXMgcmVxdWlyZWQgZm9yIGtleWNoYXJtIHRvIGJpbmQga2V5c3Ryb2tlcyB0byB0aGUgZGl2IGluc3RlYWQgb2YgdGhlIHdpbmRvd1xuXG4gICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgIHRoaXMuZnJhbWUuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgdGhpcy5mcmFtZS5jYW52YXMuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuZnJhbWUuY2FudmFzKTtcblxuICAgICAgICBpZiAoIXRoaXMuZnJhbWUuY2FudmFzLmdldENvbnRleHQpIHtcbiAgICAgICAgICB2YXIgbm9DYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcbiAgICAgICAgICBub0NhbnZhcy5zdHlsZS5jb2xvciA9ICdyZWQnO1xuICAgICAgICAgIG5vQ2FudmFzLnN0eWxlLmZvbnRXZWlnaHQgPSAnYm9sZCc7XG4gICAgICAgICAgbm9DYW52YXMuc3R5bGUucGFkZGluZyA9ICcxMHB4JztcbiAgICAgICAgICBub0NhbnZhcy5pbm5lckhUTUwgPSAnRXJyb3I6IHlvdXIgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IEhUTUwgY2FudmFzJztcbiAgICAgICAgICB0aGlzLmZyYW1lLmNhbnZhcy5hcHBlbmRDaGlsZChub0NhbnZhcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGN0eCA9IHRoaXMuZnJhbWUuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgICB0aGlzLnBpeGVsUmF0aW8gPSAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkgLyAoY3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMSk7XG5cbiAgICAgICAgICB0aGlzLmZyYW1lLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIikuc2V0VHJhbnNmb3JtKHRoaXMucGl4ZWxSYXRpbywgMCwgMCwgdGhpcy5waXhlbFJhdGlvLCAwLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCB0aGUgZnJhbWUgdG8gdGhlIGNvbnRhaW5lciBlbGVtZW50XG4gICAgICAgIHRoaXMuYm9keS5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5mcmFtZSk7XG5cbiAgICAgICAgdGhpcy5ib2R5LnZpZXcuc2NhbGUgPSAxO1xuICAgICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbiA9IHsgeDogMC41ICogdGhpcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGgsIHk6IDAuNSAqIHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodCB9O1xuXG4gICAgICAgIHRoaXMuX2JpbmRIYW1tZXIoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIGZ1bmN0aW9uIGJpbmRzIGhhbW1lciwgaXQgY2FuIGJlIHJlcGVhdGVkIG92ZXIgYW5kIG92ZXIgZHVlIHRvIHRoZSB1bmlxdWVuZXNzIGNoZWNrLlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2JpbmRIYW1tZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9iaW5kSGFtbWVyKCkge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICBpZiAodGhpcy5oYW1tZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuaGFtbWVyLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYWcgPSB7fTtcbiAgICAgICAgdGhpcy5waW5jaCA9IHt9O1xuXG4gICAgICAgIC8vIGluaXQgaGFtbWVyXG4gICAgICAgIHRoaXMuaGFtbWVyID0gbmV3IEhhbW1lcih0aGlzLmZyYW1lLmNhbnZhcyk7XG4gICAgICAgIHRoaXMuaGFtbWVyLmdldCgncGluY2gnKS5zZXQoeyBlbmFibGU6IHRydWUgfSk7XG4gICAgICAgIC8vIGVuYWJsZSB0byBnZXQgYmV0dGVyIHJlc3BvbnNlLCB0b2RvOiB0ZXN0IG9uIG1vYmlsZS5cbiAgICAgICAgdGhpcy5oYW1tZXIuZ2V0KCdwYW4nKS5zZXQoeyB0aHJlc2hvbGQ6IDUsIGRpcmVjdGlvbjogSGFtbWVyLkRJUkVDVElPTl9BTEwgfSk7XG5cbiAgICAgICAgaGFtbWVyVXRpbC5vblRvdWNoKHRoaXMuaGFtbWVyLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vblRvdWNoKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGFtbWVyLm9uKCd0YXAnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vblRhcChldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhhbW1lci5vbignZG91YmxldGFwJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Eb3VibGVUYXAoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5oYW1tZXIub24oJ3ByZXNzJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Ib2xkKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGFtbWVyLm9uKCdwYW5zdGFydCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uRHJhZ1N0YXJ0KGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGFtbWVyLm9uKCdwYW5tb3ZlJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25EcmFnKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGFtbWVyLm9uKCdwYW5lbmQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vbkRyYWdFbmQoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5oYW1tZXIub24oJ3BpbmNoJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25QaW5jaChldmVudCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFRPRE86IG5lYXRseSBjbGVhbnVwIHRoZXNlIGhhbmRsZXJzIHdoZW4gcmUtY3JlYXRpbmcgdGhlIENhbnZhcywgSUYgdGhlc2UgYXJlIGRvbmUgd2l0aCBoYW1tZXIsIGV2ZW50LnN0b3BQcm9wYWdhdGlvbiB3aWxsIG5vdCB3b3JrP1xuICAgICAgICB0aGlzLmZyYW1lLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Nb3VzZVdoZWVsKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZnJhbWUuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ0RPTU1vdXNlU2Nyb2xsJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Nb3VzZVdoZWVsKGV2ZW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5mcmFtZS5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Nb3VzZU1vdmUoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5mcmFtZS5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vbkNvbnRleHQoZXZlbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmhhbW1lckZyYW1lID0gbmV3IEhhbW1lcih0aGlzLmZyYW1lKTtcbiAgICAgICAgaGFtbWVyVXRpbC5vblJlbGVhc2UodGhpcy5oYW1tZXJGcmFtZSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25SZWxlYXNlKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0IGEgbmV3IHNpemUgZm9yIHRoZSBuZXR3b3JrXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2lkdGggICBXaWR0aCBpbiBwaXhlbHMgb3IgcGVyY2VudGFnZSAoZm9yIGV4YW1wbGUgJzgwMHB4J1xuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgb3IgJzUwJScpXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaGVpZ2h0ICBIZWlnaHQgaW4gcGl4ZWxzIG9yIHBlcmNlbnRhZ2UgIChmb3IgZXhhbXBsZSAnNDAwcHgnXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBvciAnMzAlJylcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc2V0U2l6ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U2l6ZSgpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gdGhpcy5vcHRpb25zLndpZHRoIDogYXJndW1lbnRzWzBdO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gdGhpcy5vcHRpb25zLmhlaWdodCA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICB3aWR0aCA9IHRoaXMuX3ByZXBhcmVWYWx1ZSh3aWR0aCk7XG4gICAgICAgIGhlaWdodCA9IHRoaXMuX3ByZXBhcmVWYWx1ZShoZWlnaHQpO1xuXG4gICAgICAgIHZhciBlbWl0RXZlbnQgPSBmYWxzZTtcbiAgICAgICAgdmFyIG9sZFdpZHRoID0gdGhpcy5mcmFtZS5jYW52YXMud2lkdGg7XG4gICAgICAgIHZhciBvbGRIZWlnaHQgPSB0aGlzLmZyYW1lLmNhbnZhcy5oZWlnaHQ7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBwaXhlbCByYXRpb1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5mcmFtZS5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICB2YXIgcHJldmlvdXNSYXRpbyA9IHRoaXMucGl4ZWxSYXRpbzsgLy8gd2UgY2FjaGUgdGhpcyBiZWNhdXNlIHRoZSBjYW1lcmEgc3RhdGUgc3RvcmFnZSBuZWVkcyB0aGUgb2xkIHZhbHVlXG4gICAgICAgIHRoaXMucGl4ZWxSYXRpbyA9ICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSAvIChjdHgud2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHguYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCAxKTtcblxuICAgICAgICBpZiAod2lkdGggIT0gdGhpcy5vcHRpb25zLndpZHRoIHx8IGhlaWdodCAhPSB0aGlzLm9wdGlvbnMuaGVpZ2h0IHx8IHRoaXMuZnJhbWUuc3R5bGUud2lkdGggIT0gd2lkdGggfHwgdGhpcy5mcmFtZS5zdHlsZS5oZWlnaHQgIT0gaGVpZ2h0KSB7XG4gICAgICAgICAgdGhpcy5fZ2V0Q2FtZXJhU3RhdGUocHJldmlvdXNSYXRpbyk7XG5cbiAgICAgICAgICB0aGlzLmZyYW1lLnN0eWxlLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgdGhpcy5mcmFtZS5zdHlsZS5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgICB0aGlzLmZyYW1lLmNhbnZhcy5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgICAgICB0aGlzLmZyYW1lLmNhbnZhcy5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG5cbiAgICAgICAgICB0aGlzLmZyYW1lLmNhbnZhcy53aWR0aCA9IE1hdGgucm91bmQodGhpcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGggKiB0aGlzLnBpeGVsUmF0aW8pO1xuICAgICAgICAgIHRoaXMuZnJhbWUuY2FudmFzLmhlaWdodCA9IE1hdGgucm91bmQodGhpcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0ICogdGhpcy5waXhlbFJhdGlvKTtcblxuICAgICAgICAgIHRoaXMub3B0aW9ucy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgICBlbWl0RXZlbnQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRoaXMgd291bGQgYWRhcHQgdGhlIHdpZHRoIG9mIHRoZSBjYW52YXMgdG8gdGhlIHdpZHRoIGZyb20gMTAwJSBpZiBhbmQgb25seSBpZlxuICAgICAgICAgIC8vIHRoZXJlIGlzIGEgY2hhbmdlLlxuXG4gICAgICAgICAgLy8gc3RvcmUgdGhlIGNhbWVyYSBpZiB0aGVyZSBpcyBhIGNoYW5nZSBpbiBzaXplLlxuICAgICAgICAgIGlmICh0aGlzLmZyYW1lLmNhbnZhcy53aWR0aCAhPSBNYXRoLnJvdW5kKHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoICogdGhpcy5waXhlbFJhdGlvKSB8fCB0aGlzLmZyYW1lLmNhbnZhcy5oZWlnaHQgIT0gTWF0aC5yb3VuZCh0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW8pKSB7XG4gICAgICAgICAgICB0aGlzLl9nZXRDYW1lcmFTdGF0ZShwcmV2aW91c1JhdGlvKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5mcmFtZS5jYW52YXMud2lkdGggIT0gTWF0aC5yb3VuZCh0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCAqIHRoaXMucGl4ZWxSYXRpbykpIHtcbiAgICAgICAgICAgIHRoaXMuZnJhbWUuY2FudmFzLndpZHRoID0gTWF0aC5yb3VuZCh0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCAqIHRoaXMucGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICBlbWl0RXZlbnQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5mcmFtZS5jYW52YXMuaGVpZ2h0ICE9IE1hdGgucm91bmQodGhpcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0ICogdGhpcy5waXhlbFJhdGlvKSkge1xuICAgICAgICAgICAgdGhpcy5mcmFtZS5jYW52YXMuaGVpZ2h0ID0gTWF0aC5yb3VuZCh0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgZW1pdEV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW1pdEV2ZW50ID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgncmVzaXplJywge1xuICAgICAgICAgICAgd2lkdGg6IE1hdGgucm91bmQodGhpcy5mcmFtZS5jYW52YXMud2lkdGggLyB0aGlzLnBpeGVsUmF0aW8pLFxuICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLnJvdW5kKHRoaXMuZnJhbWUuY2FudmFzLmhlaWdodCAvIHRoaXMucGl4ZWxSYXRpbyksXG4gICAgICAgICAgICBvbGRXaWR0aDogTWF0aC5yb3VuZChvbGRXaWR0aCAvIHRoaXMucGl4ZWxSYXRpbyksXG4gICAgICAgICAgICBvbGRIZWlnaHQ6IE1hdGgucm91bmQob2xkSGVpZ2h0IC8gdGhpcy5waXhlbFJhdGlvKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gcmVzdG9yZSB0aGUgY2FtZXJhIG9uIGNoYW5nZS5cbiAgICAgICAgICB0aGlzLl9zZXRDYW1lcmFTdGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IGluaXRpYWxpemVkIHNvIHRoZSBnZXQgYW5kIHNldCBjYW1lcmEgd2lsbCB3b3JrIGZyb20gbm93IG9uLlxuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGVtaXRFdmVudDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfWGNvbnZlcnRET010b0NhbnZhcycsXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBDb252ZXJ0IHRoZSBYIGNvb3JkaW5hdGUgaW4gRE9NLXNwYWNlIChjb29yZGluYXRlIHBvaW50IGluIGJyb3dzZXIgcmVsYXRpdmUgdG8gdGhlIGNvbnRhaW5lciBkaXYpIHRvXG4gICAgICAgKiB0aGUgWCBjb29yZGluYXRlIGluIGNhbnZhcy1zcGFjZSAodGhlIHNpbXVsYXRpb24gc2FuZGJveCwgd2hpY2ggdGhlIGNhbWVyYSBsb29rcyB1cG9uKVxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX1hjb252ZXJ0RE9NdG9DYW52YXMoeCkge1xuICAgICAgICByZXR1cm4gKHggLSB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi54KSAvIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENvbnZlcnQgdGhlIFggY29vcmRpbmF0ZSBpbiBjYW52YXMtc3BhY2UgKHRoZSBzaW11bGF0aW9uIHNhbmRib3gsIHdoaWNoIHRoZSBjYW1lcmEgbG9va3MgdXBvbikgdG9cbiAgICAgICAqIHRoZSBYIGNvb3JkaW5hdGUgaW4gRE9NLXNwYWNlIChjb29yZGluYXRlIHBvaW50IGluIGJyb3dzZXIgcmVsYXRpdmUgdG8gdGhlIGNvbnRhaW5lciBkaXYpXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19YY29udmVydENhbnZhc1RvRE9NJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfWGNvbnZlcnRDYW52YXNUb0RPTSh4KSB7XG4gICAgICAgIHJldHVybiB4ICogdGhpcy5ib2R5LnZpZXcuc2NhbGUgKyB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi54O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENvbnZlcnQgdGhlIFkgY29vcmRpbmF0ZSBpbiBET00tc3BhY2UgKGNvb3JkaW5hdGUgcG9pbnQgaW4gYnJvd3NlciByZWxhdGl2ZSB0byB0aGUgY29udGFpbmVyIGRpdikgdG9cbiAgICAgICAqIHRoZSBZIGNvb3JkaW5hdGUgaW4gY2FudmFzLXNwYWNlICh0aGUgc2ltdWxhdGlvbiBzYW5kYm94LCB3aGljaCB0aGUgY2FtZXJhIGxvb2tzIHVwb24pXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19ZY29udmVydERPTXRvQ2FudmFzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfWWNvbnZlcnRET010b0NhbnZhcyh5KSB7XG4gICAgICAgIHJldHVybiAoeSAtIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnkpIC8gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29udmVydCB0aGUgWSBjb29yZGluYXRlIGluIGNhbnZhcy1zcGFjZSAodGhlIHNpbXVsYXRpb24gc2FuZGJveCwgd2hpY2ggdGhlIGNhbWVyYSBsb29rcyB1cG9uKSB0b1xuICAgICAgICogdGhlIFkgY29vcmRpbmF0ZSBpbiBET00tc3BhY2UgKGNvb3JkaW5hdGUgcG9pbnQgaW4gYnJvd3NlciByZWxhdGl2ZSB0byB0aGUgY29udGFpbmVyIGRpdilcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX1ljb252ZXJ0Q2FudmFzVG9ET00nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9ZY29udmVydENhbnZhc1RvRE9NKHkpIHtcbiAgICAgICAgcmV0dXJuIHkgKiB0aGlzLmJvZHkudmlldy5zY2FsZSArIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwb3MgICA9IHt4OiBudW1iZXIsIHk6IG51bWJlcn1cbiAgICAgICAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fVxuICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2NhbnZhc1RvRE9NJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjYW52YXNUb0RPTShwb3MpIHtcbiAgICAgICAgcmV0dXJuIHsgeDogdGhpcy5fWGNvbnZlcnRDYW52YXNUb0RPTShwb3MueCksIHk6IHRoaXMuX1ljb252ZXJ0Q2FudmFzVG9ET00ocG9zLnkpIH07XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwb3MgICA9IHt4OiBudW1iZXIsIHk6IG51bWJlcn1cbiAgICAgICAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fVxuICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ0RPTXRvQ2FudmFzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBET010b0NhbnZhcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIHsgeDogdGhpcy5fWGNvbnZlcnRET010b0NhbnZhcyhwb3MueCksIHk6IHRoaXMuX1ljb252ZXJ0RE9NdG9DYW52YXMocG9zLnkpIH07XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIENhbnZhcztcbiAgfSgpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IENhbnZhcztcblxuLyoqKi8gfSxcbi8qIDEwNyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgdmFyIF9OZXR3b3JrVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTAzKTtcblxuICB2YXIgX05ldHdvcmtVdGlsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX05ldHdvcmtVdGlsKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgdmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4gIHZhciBWaWV3ID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZpZXcoYm9keSwgY2FudmFzKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVmlldyk7XG5cbiAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcblxuICAgICAgdGhpcy5hbmltYXRpb25TcGVlZCA9IDEgLyB0aGlzLnJlbmRlclJlZnJlc2hSYXRlO1xuICAgICAgdGhpcy5hbmltYXRpb25FYXNpbmdGdW5jdGlvbiA9IFwiZWFzZUluT3V0UXVpbnRcIjtcbiAgICAgIHRoaXMuZWFzaW5nVGltZSA9IDA7XG4gICAgICB0aGlzLnNvdXJjZVNjYWxlID0gMDtcbiAgICAgIHRoaXMudGFyZ2V0U2NhbGUgPSAwO1xuICAgICAgdGhpcy5zb3VyY2VUcmFuc2xhdGlvbiA9IDA7XG4gICAgICB0aGlzLnRhcmdldFRyYW5zbGF0aW9uID0gMDtcbiAgICAgIHRoaXMubG9ja2VkT25Ob2RlSWQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmxvY2tlZE9uTm9kZU9mZnNldCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMudG91Y2hUaW1lID0gMDtcblxuICAgICAgdGhpcy52aWV3RnVuY3Rpb24gPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiZml0XCIsIHRoaXMuZml0LmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJhbmltYXRpb25GaW5pc2hlZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3N0b3BSZW5kZXJpbmdcIik7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwidW5sb2NrTm9kZVwiLCB0aGlzLnJlbGVhc2VOb2RlLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhWaWV3LCBbe1xuICAgICAga2V5OiAnc2V0T3B0aW9ucycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucygpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgZnVuY3Rpb24gem9vbXMgb3V0IHRvIGZpdCBhbGwgZGF0YSBvbiBzY3JlZW4gYmFzZWQgb24gYW1vdW50IG9mIG5vZGVzXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gT3B0aW9uc1xuICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbaW5pdGlhbFpvb21dICB8IHpvb20gYmFzZWQgb24gZml0dGVkIGZvcm11bGEgb3IgcmFuZ2UsIHRydWUgPSBmaXR0ZWQsIGRlZmF1bHQgPSBmYWxzZTtcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZml0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaXQoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8geyBub2RlczogW10gfSA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgdmFyIGluaXRpYWxab29tID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgdmFyIHJhbmdlID0gdm9pZCAwO1xuICAgICAgICB2YXIgem9vbUxldmVsID0gdm9pZCAwO1xuICAgICAgICBpZiAob3B0aW9ucy5ub2RlcyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMubm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgb3B0aW9ucy5ub2RlcyA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbml0aWFsWm9vbSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIC8vIGNoZWNrIGlmIG1vcmUgdGhhbiBoYWxmIG9mIHRoZSBub2RlcyBoYXZlIGEgcHJlZGVmaW5lZCBwb3NpdGlvbi4gSWYgc28sIHdlIHVzZSB0aGUgcmFuZ2UsIG5vdCB0aGUgYXBwcm94aW1hdGlvbi5cbiAgICAgICAgICB2YXIgcG9zaXRpb25EZWZpbmVkID0gMDtcbiAgICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gdGhpcy5ib2R5Lm5vZGVzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzLmhhc093blByb3BlcnR5KG5vZGVJZCkpIHtcbiAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICAgICAgaWYgKG5vZGUucHJlZGVmaW5lZFBvc2l0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25EZWZpbmVkICs9IDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBvc2l0aW9uRGVmaW5lZCA+IDAuNSAqIHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZml0KG9wdGlvbnMsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByYW5nZSA9IF9OZXR3b3JrVXRpbDIuZGVmYXVsdC5nZXRSYW5nZSh0aGlzLmJvZHkubm9kZXMsIG9wdGlvbnMubm9kZXMpO1xuXG4gICAgICAgICAgdmFyIG51bWJlck9mTm9kZXMgPSB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoO1xuICAgICAgICAgIHpvb21MZXZlbCA9IDEyLjY2MiAvIChudW1iZXJPZk5vZGVzICsgNy40MTQ3KSArIDAuMDk2NDgyMjsgLy8gdGhpcyBpcyBvYnRhaW5lZCBmcm9tIGZpdHRpbmcgYSBkYXRhc2V0IGZyb20gNSBwb2ludHMgd2l0aCBzY2FsZSBsZXZlbHMgdGhhdCBsb29rZWQgZ29vZC5cblxuICAgICAgICAgIC8vIGNvcnJlY3QgZm9yIGxhcmdlciBjYW52YXNzZXMuXG4gICAgICAgICAgdmFyIGZhY3RvciA9IE1hdGgubWluKHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCAvIDYwMCwgdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodCAvIDYwMCk7XG4gICAgICAgICAgem9vbUxldmVsICo9IGZhY3RvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3Jlc2l6ZU5vZGVzXCIpO1xuICAgICAgICAgIHJhbmdlID0gX05ldHdvcmtVdGlsMi5kZWZhdWx0LmdldFJhbmdlKHRoaXMuYm9keS5ub2Rlcywgb3B0aW9ucy5ub2Rlcyk7XG5cbiAgICAgICAgICB2YXIgeERpc3RhbmNlID0gTWF0aC5hYnMocmFuZ2UubWF4WCAtIHJhbmdlLm1pblgpICogMS4xO1xuICAgICAgICAgIHZhciB5RGlzdGFuY2UgPSBNYXRoLmFicyhyYW5nZS5tYXhZIC0gcmFuZ2UubWluWSkgKiAxLjE7XG5cbiAgICAgICAgICB2YXIgeFpvb21MZXZlbCA9IHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCAvIHhEaXN0YW5jZTtcbiAgICAgICAgICB2YXIgeVpvb21MZXZlbCA9IHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHQgLyB5RGlzdGFuY2U7XG5cbiAgICAgICAgICB6b29tTGV2ZWwgPSB4Wm9vbUxldmVsIDw9IHlab29tTGV2ZWwgPyB4Wm9vbUxldmVsIDogeVpvb21MZXZlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh6b29tTGV2ZWwgPiAxLjApIHtcbiAgICAgICAgICB6b29tTGV2ZWwgPSAxLjA7XG4gICAgICAgIH0gZWxzZSBpZiAoem9vbUxldmVsID09PSAwKSB7XG4gICAgICAgICAgem9vbUxldmVsID0gMS4wO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNlbnRlciA9IF9OZXR3b3JrVXRpbDIuZGVmYXVsdC5maW5kQ2VudGVyKHJhbmdlKTtcbiAgICAgICAgdmFyIGFuaW1hdGlvbk9wdGlvbnMgPSB7IHBvc2l0aW9uOiBjZW50ZXIsIHNjYWxlOiB6b29tTGV2ZWwsIGFuaW1hdGlvbjogb3B0aW9ucy5hbmltYXRpb24gfTtcbiAgICAgICAgdGhpcy5tb3ZlVG8oYW5pbWF0aW9uT3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFuaW1hdGlvblxuXG4gICAgICAvKipcbiAgICAgICAqIENlbnRlciBhIG5vZGUgaW4gdmlldy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gbm9kZUlkXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnNdXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2ZvY3VzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmb2N1cyhub2RlSWQpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBub2RlUG9zaXRpb24gPSB7IHg6IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdLngsIHk6IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdLnkgfTtcbiAgICAgICAgICBvcHRpb25zLnBvc2l0aW9uID0gbm9kZVBvc2l0aW9uO1xuICAgICAgICAgIG9wdGlvbnMubG9ja2VkT25Ob2RlID0gbm9kZUlkO1xuXG4gICAgICAgICAgdGhpcy5tb3ZlVG8ob3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJOb2RlOiBcIiArIG5vZGVJZCArIFwiIGNhbm5vdCBiZSBmb3VuZC5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgIHwgIG9wdGlvbnMub2Zmc2V0ICAgPSB7eDpOdW1iZXIsIHk6TnVtYmVyfSAgIC8vIG9mZnNldCBmcm9tIHRoZSBjZW50ZXIgaW4gRE9NIHBpeGVsc1xuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG9wdGlvbnMuc2NhbGUgICAgPSBOdW1iZXIgICAgICAgICAgICAgICAgIC8vIHNjYWxlIHRvIG1vdmUgdG9cbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBvcHRpb25zLnBvc2l0aW9uID0ge3g6TnVtYmVyLCB5Ok51bWJlcn0gICAvLyBwb3NpdGlvbiB0byBtb3ZlIHRvXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgb3B0aW9ucy5hbmltYXRpb24gPSB7ZHVyYXRpb246TnVtYmVyLCBlYXNpbmdGdW5jdGlvbjpTdHJpbmd9IHx8IEJvb2xlYW4gICAvLyBwb3NpdGlvbiB0byBtb3ZlIHRvXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ21vdmVUbycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZVRvKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMub2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBvcHRpb25zLm9mZnNldCA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLm9mZnNldC54ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBvcHRpb25zLm9mZnNldC54ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5vZmZzZXQueSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb3B0aW9ucy5vZmZzZXQueSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuc2NhbGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG9wdGlvbnMuc2NhbGUgPSB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5wb3NpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb3B0aW9ucy5wb3NpdGlvbiA9IHRoaXMuZ2V0Vmlld1Bvc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBvcHRpb25zLmFuaW1hdGlvbiA9IHsgZHVyYXRpb246IDAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5hbmltYXRpb24gPT09IGZhbHNlKSB7XG4gICAgICAgICAgb3B0aW9ucy5hbmltYXRpb24gPSB7IGR1cmF0aW9uOiAwIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgb3B0aW9ucy5hbmltYXRpb24gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5hbmltYXRpb24uZHVyYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG9wdGlvbnMuYW5pbWF0aW9uLmR1cmF0aW9uID0gMTAwMDtcbiAgICAgICAgfSAvLyBkZWZhdWx0IGR1cmF0aW9uXG4gICAgICAgIGlmIChvcHRpb25zLmFuaW1hdGlvbi5lYXNpbmdGdW5jdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb3B0aW9ucy5hbmltYXRpb24uZWFzaW5nRnVuY3Rpb24gPSBcImVhc2VJbk91dFF1YWRcIjtcbiAgICAgICAgfSAvLyBkZWZhdWx0IGVhc2luZyBmdW5jdGlvblxuXG4gICAgICAgIHRoaXMuYW5pbWF0ZVZpZXcob3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zICB8ICBvcHRpb25zLm9mZnNldCAgID0ge3g6TnVtYmVyLCB5Ok51bWJlcn0gICAvLyBvZmZzZXQgZnJvbSB0aGUgY2VudGVyIGluIERPTSBwaXhlbHNcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBvcHRpb25zLnRpbWUgICAgID0gTnVtYmVyICAgICAgICAgICAgICAgICAvLyBhbmltYXRpb24gdGltZSBpbiBtaWxsaXNlY29uZHNcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBvcHRpb25zLnNjYWxlICAgID0gTnVtYmVyICAgICAgICAgICAgICAgICAvLyBzY2FsZSB0byBhbmltYXRlIHRvXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgb3B0aW9ucy5wb3NpdGlvbiA9IHt4Ok51bWJlciwgeTpOdW1iZXJ9ICAgLy8gcG9zaXRpb24gdG8gYW5pbWF0ZSB0b1xuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG9wdGlvbnMuZWFzaW5nRnVuY3Rpb24gPSBTdHJpbmcgICAgICAgICAgIC8vIGxpbmVhciwgZWFzZUluUXVhZCwgZWFzZU91dFF1YWQsIGVhc2VJbk91dFF1YWQsXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWFzZUluQ3ViaWMsIGVhc2VPdXRDdWJpYywgZWFzZUluT3V0Q3ViaWMsXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWFzZUluUXVhcnQsIGVhc2VPdXRRdWFydCwgZWFzZUluT3V0UXVhcnQsXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWFzZUluUXVpbnQsIGVhc2VPdXRRdWludCwgZWFzZUluT3V0UXVpbnRcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnYW5pbWF0ZVZpZXcnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFuaW1hdGVWaWV3KG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFuaW1hdGlvbkVhc2luZ0Z1bmN0aW9uID0gb3B0aW9ucy5hbmltYXRpb24uZWFzaW5nRnVuY3Rpb247XG4gICAgICAgIC8vIHJlbGVhc2UgaWYgc29tZXRoaW5nIGZvY3Vzc2VkIG9uIHRoZSBub2RlXG4gICAgICAgIHRoaXMucmVsZWFzZU5vZGUoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMubG9ja2VkID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5sb2NrZWRPbk5vZGVJZCA9IG9wdGlvbnMubG9ja2VkT25Ob2RlO1xuICAgICAgICAgIHRoaXMubG9ja2VkT25Ob2RlT2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmb3JjZWZ1bGx5IGNvbXBsZXRlIHRoZSBvbGQgYW5pbWF0aW9uIGlmIGl0IHdhcyBzdGlsbCBydW5uaW5nXG4gICAgICAgIGlmICh0aGlzLmVhc2luZ1RpbWUgIT0gMCkge1xuICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25SZWRyYXcodHJ1ZSk7IC8vIGJ5IHNldHRpbmcgZWFzaW5ndGltZSB0byAxLCB3ZSBmaW5pc2ggdGhlIGFuaW1hdGlvbi5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc291cmNlU2NhbGUgPSB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgICAgdGhpcy5zb3VyY2VUcmFuc2xhdGlvbiA9IHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uO1xuICAgICAgICB0aGlzLnRhcmdldFNjYWxlID0gb3B0aW9ucy5zY2FsZTtcblxuICAgICAgICAvLyBzZXQgdGhlIHNjYWxlIHNvIHRoZSB2aWV3Q2VudGVyIGlzIGJhc2VkIG9uIHRoZSBjb3JyZWN0IHpvb20gbGV2ZWwuIFRoaXMgaXMgb3ZlcnJpZGRlbiBpbiB0aGUgdHJhbnNpdGlvblJlZHJhd1xuICAgICAgICAvLyBidXQgYXQgbGVhc3QgdGhlbiB3ZSdsbCBoYXZlIHRoZSB0YXJnZXQgdHJhbnNpdGlvblxuICAgICAgICB0aGlzLmJvZHkudmlldy5zY2FsZSA9IHRoaXMudGFyZ2V0U2NhbGU7XG4gICAgICAgIHZhciB2aWV3Q2VudGVyID0gdGhpcy5jYW52YXMuRE9NdG9DYW52YXMoeyB4OiAwLjUgKiB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGgsIHk6IDAuNSAqIHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHQgfSk7XG5cbiAgICAgICAgdmFyIGRpc3RhbmNlRnJvbUNlbnRlciA9IHsgLy8gb2Zmc2V0IGZyb20gdmlldywgZGlzdGFuY2UgdmlldyBoYXMgdG8gY2hhbmdlIGJ5IHRoZXNlIHggYW5kIHkgdG8gY2VudGVyIHRoZSBub2RlXG4gICAgICAgICAgeDogdmlld0NlbnRlci54IC0gb3B0aW9ucy5wb3NpdGlvbi54LFxuICAgICAgICAgIHk6IHZpZXdDZW50ZXIueSAtIG9wdGlvbnMucG9zaXRpb24ueVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRhcmdldFRyYW5zbGF0aW9uID0ge1xuICAgICAgICAgIHg6IHRoaXMuc291cmNlVHJhbnNsYXRpb24ueCArIGRpc3RhbmNlRnJvbUNlbnRlci54ICogdGhpcy50YXJnZXRTY2FsZSArIG9wdGlvbnMub2Zmc2V0LngsXG4gICAgICAgICAgeTogdGhpcy5zb3VyY2VUcmFuc2xhdGlvbi55ICsgZGlzdGFuY2VGcm9tQ2VudGVyLnkgKiB0aGlzLnRhcmdldFNjYWxlICsgb3B0aW9ucy5vZmZzZXQueVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGlmIHRoZSB0aW1lIGlzIHNldCB0byAwLCBkb24ndCBkbyBhbiBhbmltYXRpb25cbiAgICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uLmR1cmF0aW9uID09PSAwKSB7XG4gICAgICAgICAgaWYgKHRoaXMubG9ja2VkT25Ob2RlSWQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdGdW5jdGlvbiA9IHRoaXMuX2xvY2tlZFJlZHJhdy5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJpbml0UmVkcmF3XCIsIHRoaXMudmlld0Z1bmN0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ib2R5LnZpZXcuc2NhbGUgPSB0aGlzLnRhcmdldFNjYWxlO1xuICAgICAgICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24gPSB0aGlzLnRhcmdldFRyYW5zbGF0aW9uO1xuICAgICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFuaW1hdGlvblNwZWVkID0gMSAvICg2MCAqIG9wdGlvbnMuYW5pbWF0aW9uLmR1cmF0aW9uICogMC4wMDEpIHx8IDEgLyA2MDsgLy8gNjAgZm9yIDYwIHNlY29uZHMsIDAuMDAxIGZvciBtaWxsaSdzXG4gICAgICAgICAgdGhpcy5hbmltYXRpb25FYXNpbmdGdW5jdGlvbiA9IG9wdGlvbnMuYW5pbWF0aW9uLmVhc2luZ0Z1bmN0aW9uO1xuXG4gICAgICAgICAgdGhpcy52aWV3RnVuY3Rpb24gPSB0aGlzLl90cmFuc2l0aW9uUmVkcmF3LmJpbmQodGhpcyk7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJpbml0UmVkcmF3XCIsIHRoaXMudmlld0Z1bmN0aW9uKTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3N0YXJ0UmVuZGVyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogdXNlZCB0byBhbmltYXRlIHNtb290aGx5IGJ5IGhpamFja2luZyB0aGUgcmVkcmF3IGZ1bmN0aW9uLlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2xvY2tlZFJlZHJhdycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2xvY2tlZFJlZHJhdygpIHtcbiAgICAgICAgdmFyIG5vZGVQb3NpdGlvbiA9IHsgeDogdGhpcy5ib2R5Lm5vZGVzW3RoaXMubG9ja2VkT25Ob2RlSWRdLngsIHk6IHRoaXMuYm9keS5ub2Rlc1t0aGlzLmxvY2tlZE9uTm9kZUlkXS55IH07XG4gICAgICAgIHZhciB2aWV3Q2VudGVyID0gdGhpcy5jYW52YXMuRE9NdG9DYW52YXMoeyB4OiAwLjUgKiB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGgsIHk6IDAuNSAqIHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHQgfSk7XG4gICAgICAgIHZhciBkaXN0YW5jZUZyb21DZW50ZXIgPSB7IC8vIG9mZnNldCBmcm9tIHZpZXcsIGRpc3RhbmNlIHZpZXcgaGFzIHRvIGNoYW5nZSBieSB0aGVzZSB4IGFuZCB5IHRvIGNlbnRlciB0aGUgbm9kZVxuICAgICAgICAgIHg6IHZpZXdDZW50ZXIueCAtIG5vZGVQb3NpdGlvbi54LFxuICAgICAgICAgIHk6IHZpZXdDZW50ZXIueSAtIG5vZGVQb3NpdGlvbi55XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzb3VyY2VUcmFuc2xhdGlvbiA9IHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uO1xuICAgICAgICB2YXIgdGFyZ2V0VHJhbnNsYXRpb24gPSB7XG4gICAgICAgICAgeDogc291cmNlVHJhbnNsYXRpb24ueCArIGRpc3RhbmNlRnJvbUNlbnRlci54ICogdGhpcy5ib2R5LnZpZXcuc2NhbGUgKyB0aGlzLmxvY2tlZE9uTm9kZU9mZnNldC54LFxuICAgICAgICAgIHk6IHNvdXJjZVRyYW5zbGF0aW9uLnkgKyBkaXN0YW5jZUZyb21DZW50ZXIueSAqIHRoaXMuYm9keS52aWV3LnNjYWxlICsgdGhpcy5sb2NrZWRPbk5vZGVPZmZzZXQueVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uID0gdGFyZ2V0VHJhbnNsYXRpb247XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAncmVsZWFzZU5vZGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbGVhc2VOb2RlKCkge1xuICAgICAgICBpZiAodGhpcy5sb2NrZWRPbk5vZGVJZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMudmlld0Z1bmN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vZmYoXCJpbml0UmVkcmF3XCIsIHRoaXMudmlld0Z1bmN0aW9uKTtcbiAgICAgICAgICB0aGlzLmxvY2tlZE9uTm9kZUlkID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHRoaXMubG9ja2VkT25Ob2RlT2Zmc2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSBlYXNpbmdUaW1lXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfdHJhbnNpdGlvblJlZHJhdycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3RyYW5zaXRpb25SZWRyYXcoKSB7XG4gICAgICAgIHZhciBmaW5pc2hlZCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogYXJndW1lbnRzWzBdO1xuXG4gICAgICAgIHRoaXMuZWFzaW5nVGltZSArPSB0aGlzLmFuaW1hdGlvblNwZWVkO1xuICAgICAgICB0aGlzLmVhc2luZ1RpbWUgPSBmaW5pc2hlZCA9PT0gdHJ1ZSA/IDEuMCA6IHRoaXMuZWFzaW5nVGltZTtcblxuICAgICAgICB2YXIgcHJvZ3Jlc3MgPSB1dGlsLmVhc2luZ0Z1bmN0aW9uc1t0aGlzLmFuaW1hdGlvbkVhc2luZ0Z1bmN0aW9uXSh0aGlzLmVhc2luZ1RpbWUpO1xuXG4gICAgICAgIHRoaXMuYm9keS52aWV3LnNjYWxlID0gdGhpcy5zb3VyY2VTY2FsZSArICh0aGlzLnRhcmdldFNjYWxlIC0gdGhpcy5zb3VyY2VTY2FsZSkgKiBwcm9ncmVzcztcbiAgICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24gPSB7XG4gICAgICAgICAgeDogdGhpcy5zb3VyY2VUcmFuc2xhdGlvbi54ICsgKHRoaXMudGFyZ2V0VHJhbnNsYXRpb24ueCAtIHRoaXMuc291cmNlVHJhbnNsYXRpb24ueCkgKiBwcm9ncmVzcyxcbiAgICAgICAgICB5OiB0aGlzLnNvdXJjZVRyYW5zbGF0aW9uLnkgKyAodGhpcy50YXJnZXRUcmFuc2xhdGlvbi55IC0gdGhpcy5zb3VyY2VUcmFuc2xhdGlvbi55KSAqIHByb2dyZXNzXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gY2xlYW51cFxuICAgICAgICBpZiAodGhpcy5lYXNpbmdUaW1lID49IDEuMCkge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9mZihcImluaXRSZWRyYXdcIiwgdGhpcy52aWV3RnVuY3Rpb24pO1xuICAgICAgICAgIHRoaXMuZWFzaW5nVGltZSA9IDA7XG4gICAgICAgICAgaWYgKHRoaXMubG9ja2VkT25Ob2RlSWQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdGdW5jdGlvbiA9IHRoaXMuX2xvY2tlZFJlZHJhdy5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJpbml0UmVkcmF3XCIsIHRoaXMudmlld0Z1bmN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImFuaW1hdGlvbkZpbmlzaGVkXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0U2NhbGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNjYWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0Vmlld1Bvc2l0aW9uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWaWV3UG9zaXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyh7IHg6IDAuNSAqIHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCwgeTogMC41ICogdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodCB9KTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gVmlldztcbiAgfSgpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IFZpZXc7XG5cbi8qKiovIH0sXG4vKiAxMDggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIHZhciBfTmF2aWdhdGlvbkhhbmRsZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwOSk7XG5cbiAgdmFyIF9OYXZpZ2F0aW9uSGFuZGxlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9OYXZpZ2F0aW9uSGFuZGxlcik7XG5cbiAgdmFyIF9Qb3B1cCA9IF9fd2VicGFja19yZXF1aXJlX18oMTEwKTtcblxuICB2YXIgX1BvcHVwMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1BvcHVwKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgdmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4gIHZhciBJbnRlcmFjdGlvbkhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW50ZXJhY3Rpb25IYW5kbGVyKGJvZHksIGNhbnZhcywgc2VsZWN0aW9uSGFuZGxlcikge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEludGVyYWN0aW9uSGFuZGxlcik7XG5cbiAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlciA9IHNlbGVjdGlvbkhhbmRsZXI7XG4gICAgICB0aGlzLm5hdmlnYXRpb25IYW5kbGVyID0gbmV3IF9OYXZpZ2F0aW9uSGFuZGxlcjIuZGVmYXVsdChib2R5LCBjYW52YXMpO1xuXG4gICAgICAvLyBiaW5kIHRoZSBldmVudHMgZnJvbSBoYW1tZXIgdG8gZnVuY3Rpb25zIGluIHRoaXMgb2JqZWN0XG4gICAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25UYXAgPSB0aGlzLm9uVGFwLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Ub3VjaCA9IHRoaXMub25Ub3VjaC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uRG91YmxlVGFwID0gdGhpcy5vbkRvdWJsZVRhcC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uSG9sZCA9IHRoaXMub25Ib2xkLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25EcmFnU3RhcnQgPSB0aGlzLm9uRHJhZ1N0YXJ0LmJpbmQodGhpcyk7XG4gICAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25EcmFnID0gdGhpcy5vbkRyYWcuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vbkRyYWdFbmQgPSB0aGlzLm9uRHJhZ0VuZC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uTW91c2VXaGVlbCA9IHRoaXMub25Nb3VzZVdoZWVsLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25QaW5jaCA9IHRoaXMub25QaW5jaC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uTW91c2VNb3ZlID0gdGhpcy5vbk1vdXNlTW92ZS5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uUmVsZWFzZSA9IHRoaXMub25SZWxlYXNlLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Db250ZXh0ID0gdGhpcy5vbkNvbnRleHQuYmluZCh0aGlzKTtcblxuICAgICAgdGhpcy50b3VjaFRpbWUgPSAwO1xuICAgICAgdGhpcy5kcmFnID0ge307XG4gICAgICB0aGlzLnBpbmNoID0ge307XG4gICAgICB0aGlzLnBvcHVwID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5wb3B1cE9iaiA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMucG9wdXBUaW1lciA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy5ib2R5LmZ1bmN0aW9ucy5nZXRQb2ludGVyID0gdGhpcy5nZXRQb2ludGVyLmJpbmQodGhpcyk7XG5cbiAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgICAgZHJhZ05vZGVzOiB0cnVlLFxuICAgICAgICBkcmFnVmlldzogdHJ1ZSxcbiAgICAgICAgaG92ZXI6IGZhbHNlLFxuICAgICAgICBrZXlib2FyZDoge1xuICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgIHNwZWVkOiB7IHg6IDEwLCB5OiAxMCwgem9vbTogMC4wMiB9LFxuICAgICAgICAgIGJpbmRUb1dpbmRvdzogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBuYXZpZ2F0aW9uQnV0dG9uczogZmFsc2UsXG4gICAgICAgIHRvb2x0aXBEZWxheTogMzAwLFxuICAgICAgICB6b29tVmlldzogdHJ1ZVxuICAgICAgfTtcbiAgICAgIHV0aWwuZXh0ZW5kKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgICAgIHRoaXMuYmluZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEludGVyYWN0aW9uSGFuZGxlciwgW3tcbiAgICAgIGtleTogJ2JpbmRFdmVudExpc3RlbmVycycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy5wb3B1cFRpbWVyKTtcbiAgICAgICAgICBkZWxldGUgX3RoaXMuYm9keS5mdW5jdGlvbnMuZ2V0UG9pbnRlcjtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnc2V0T3B0aW9ucycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBleHRlbmQgYWxsIGJ1dCB0aGUgdmFsdWVzIGluIGZpZWxkc1xuICAgICAgICAgIHZhciBmaWVsZHMgPSBbJ2hpZGVFZGdlc09uRHJhZycsICdoaWRlTm9kZXNPbkRyYWcnLCAna2V5Ym9hcmQnLCAnbXVsdGlzZWxlY3QnLCAnc2VsZWN0YWJsZScsICdzZWxlY3RDb25uZWN0ZWRFZGdlcyddO1xuICAgICAgICAgIHV0aWwuc2VsZWN0aXZlTm90RGVlcEV4dGVuZChmaWVsZHMsIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgICAgICAvLyBtZXJnZSB0aGUga2V5Ym9hcmQgb3B0aW9ucyBpbi5cbiAgICAgICAgICB1dGlsLm1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMsICdrZXlib2FyZCcpO1xuXG4gICAgICAgICAgaWYgKG9wdGlvbnMudG9vbHRpcCkge1xuICAgICAgICAgICAgdXRpbC5leHRlbmQodGhpcy5vcHRpb25zLnRvb2x0aXAsIG9wdGlvbnMudG9vbHRpcCk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy50b29sdGlwLmNvbG9yKSB7XG4gICAgICAgICAgICAgIHRoaXMub3B0aW9ucy50b29sdGlwLmNvbG9yID0gdXRpbC5wYXJzZUNvbG9yKG9wdGlvbnMudG9vbHRpcC5jb2xvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uSGFuZGxlci5zZXRPcHRpb25zKHRoaXMub3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0IHRoZSBwb2ludGVyIGxvY2F0aW9uIGZyb20gYSB0b3VjaCBsb2NhdGlvblxuICAgICAgICogQHBhcmFtIHt7eDogTnVtYmVyLCB5OiBOdW1iZXJ9fSB0b3VjaFxuICAgICAgICogQHJldHVybiB7e3g6IE51bWJlciwgeTogTnVtYmVyfX0gcG9pbnRlclxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0UG9pbnRlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9pbnRlcih0b3VjaCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHRvdWNoLnggLSB1dGlsLmdldEFic29sdXRlTGVmdCh0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMpLFxuICAgICAgICAgIHk6IHRvdWNoLnkgLSB1dGlsLmdldEFic29sdXRlVG9wKHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcylcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBPbiBzdGFydCBvZiBhIHRvdWNoIGdlc3R1cmUsIHN0b3JlIHRoZSBwb2ludGVyXG4gICAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ29uVG91Y2gnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uVG91Y2goZXZlbnQpIHtcbiAgICAgICAgaWYgKG5ldyBEYXRlKCkudmFsdWVPZigpIC0gdGhpcy50b3VjaFRpbWUgPiA1MCkge1xuICAgICAgICAgIHRoaXMuZHJhZy5wb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICAgICAgdGhpcy5kcmFnLnBpbmNoZWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLnBpbmNoLnNjYWxlID0gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICAgICAgLy8gdG8gYXZvaWQgZG91YmxlIGZpcmVpbmcgb2YgdGhpcyBldmVudCBiZWNhdXNlIHdlIGhhdmUgdHdvIGhhbW1lciBpbnN0YW5jZXMuIChvbiBjYW52YXMgYW5kIG9uIGZyYW1lKVxuICAgICAgICAgIHRoaXMudG91Y2hUaW1lID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBoYW5kbGUgdGFwL2NsaWNrIGV2ZW50OiBzZWxlY3QvdW5zZWxlY3QgYSBub2RlXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdvblRhcCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gb25UYXAoZXZlbnQpIHtcbiAgICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgICAgdmFyIG11bHRpc2VsZWN0ID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLm9wdGlvbnMubXVsdGlzZWxlY3QgJiYgKGV2ZW50LmNoYW5nZWRQb2ludGVyc1swXS5jdHJsS2V5IHx8IGV2ZW50LmNoYW5nZWRQb2ludGVyc1swXS5tZXRhS2V5KTtcblxuICAgICAgICB0aGlzLmNoZWNrU2VsZWN0aW9uQ2hhbmdlcyhwb2ludGVyLCBldmVudCwgbXVsdGlzZWxlY3QpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dlbmVyYXRlQ2xpY2tFdmVudCgnY2xpY2snLCBldmVudCwgcG9pbnRlcik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogaGFuZGxlIGRvdWJsZXRhcCBldmVudFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnb25Eb3VibGVUYXAnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uRG91YmxlVGFwKGV2ZW50KSB7XG4gICAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2VuZXJhdGVDbGlja0V2ZW50KCdkb3VibGVDbGljaycsIGV2ZW50LCBwb2ludGVyKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBoYW5kbGUgbG9uZyB0YXAgZXZlbnQ6IG11bHRpIHNlbGVjdCBub2Rlc1xuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnb25Ib2xkJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkhvbGQoZXZlbnQpIHtcbiAgICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgICAgdmFyIG11bHRpc2VsZWN0ID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLm9wdGlvbnMubXVsdGlzZWxlY3Q7XG5cbiAgICAgICAgdGhpcy5jaGVja1NlbGVjdGlvbkNoYW5nZXMocG9pbnRlciwgZXZlbnQsIG11bHRpc2VsZWN0KTtcblxuICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dlbmVyYXRlQ2xpY2tFdmVudCgnY2xpY2snLCBldmVudCwgcG9pbnRlcik7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2VuZXJhdGVDbGlja0V2ZW50KCdob2xkJywgZXZlbnQsIHBvaW50ZXIpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGhhbmRsZSB0aGUgcmVsZWFzZSBvZiB0aGUgc2NyZWVuXG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnb25SZWxlYXNlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvblJlbGVhc2UoZXZlbnQpIHtcbiAgICAgICAgaWYgKG5ldyBEYXRlKCkudmFsdWVPZigpIC0gdGhpcy50b3VjaFRpbWUgPiAxMCkge1xuICAgICAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZW5lcmF0ZUNsaWNrRXZlbnQoJ3JlbGVhc2UnLCBldmVudCwgcG9pbnRlcik7XG4gICAgICAgICAgLy8gdG8gYXZvaWQgZG91YmxlIGZpcmVpbmcgb2YgdGhpcyBldmVudCBiZWNhdXNlIHdlIGhhdmUgdHdvIGhhbW1lciBpbnN0YW5jZXMuIChvbiBjYW52YXMgYW5kIG9uIGZyYW1lKVxuICAgICAgICAgIHRoaXMudG91Y2hUaW1lID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdvbkNvbnRleHQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uQ29udGV4dChldmVudCkge1xuICAgICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcih7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFkgfSk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2VuZXJhdGVDbGlja0V2ZW50KCdvbmNvbnRleHQnLCBldmVudCwgcG9pbnRlcik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSBwb2ludGVyXG4gICAgICAgKiBAcGFyYW0gYWRkXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2NoZWNrU2VsZWN0aW9uQ2hhbmdlcycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tTZWxlY3Rpb25DaGFuZ2VzKHBvaW50ZXIsIGV2ZW50KSB7XG4gICAgICAgIHZhciBhZGQgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1syXTtcblxuICAgICAgICB2YXIgcHJldmlvdXNseVNlbGVjdGVkRWRnZUNvdW50ID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZXRTZWxlY3RlZEVkZ2VDb3VudCgpO1xuICAgICAgICB2YXIgcHJldmlvdXNseVNlbGVjdGVkTm9kZUNvdW50ID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZXRTZWxlY3RlZE5vZGVDb3VudCgpO1xuICAgICAgICB2YXIgcHJldmlvdXNTZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIHZhciBzZWxlY3RlZCA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGFkZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHNlbGVjdGVkID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnNlbGVjdEFkZGl0aW9uYWxPblBvaW50KHBvaW50ZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGVjdGVkID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnNlbGVjdE9uUG9pbnQocG9pbnRlcik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlbGVjdGVkRWRnZXNDb3VudCA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2V0U2VsZWN0ZWRFZGdlQ291bnQoKTtcbiAgICAgICAgdmFyIHNlbGVjdGVkTm9kZXNDb3VudCA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2V0U2VsZWN0ZWROb2RlQ291bnQoKTtcbiAgICAgICAgdmFyIGN1cnJlbnRTZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgICAgdmFyIF9kZXRlcm1pbmVJZkRpZmZlcmVudDIgPSB0aGlzLl9kZXRlcm1pbmVJZkRpZmZlcmVudChwcmV2aW91c1NlbGVjdGlvbiwgY3VycmVudFNlbGVjdGlvbik7XG5cbiAgICAgICAgdmFyIG5vZGVzQ2hhbmdlZCA9IF9kZXRlcm1pbmVJZkRpZmZlcmVudDIubm9kZXNDaGFuZ2VkO1xuICAgICAgICB2YXIgZWRnZXNDaGFuZ2VkID0gX2RldGVybWluZUlmRGlmZmVyZW50Mi5lZGdlc0NoYW5nZWQ7XG5cbiAgICAgICAgdmFyIG5vZGVTZWxlY3RlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChzZWxlY3RlZE5vZGVzQ291bnQgLSBwcmV2aW91c2x5U2VsZWN0ZWROb2RlQ291bnQgPiAwKSB7XG4gICAgICAgICAgLy8gbm9kZSB3YXMgc2VsZWN0ZWRcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dlbmVyYXRlQ2xpY2tFdmVudCgnc2VsZWN0Tm9kZScsIGV2ZW50LCBwb2ludGVyKTtcbiAgICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgbm9kZVNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChub2Rlc0NoYW5nZWQgPT09IHRydWUgJiYgc2VsZWN0ZWROb2Rlc0NvdW50ID4gMCkge1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2VuZXJhdGVDbGlja0V2ZW50KCdkZXNlbGVjdE5vZGUnLCBldmVudCwgcG9pbnRlciwgcHJldmlvdXNTZWxlY3Rpb24pO1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2VuZXJhdGVDbGlja0V2ZW50KCdzZWxlY3ROb2RlJywgZXZlbnQsIHBvaW50ZXIpO1xuICAgICAgICAgIG5vZGVTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHNlbGVjdGVkTm9kZXNDb3VudCAtIHByZXZpb3VzbHlTZWxlY3RlZE5vZGVDb3VudCA8IDApIHtcbiAgICAgICAgICAvLyBub2RlIHdhcyBkZXNlbGVjdGVkXG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZW5lcmF0ZUNsaWNrRXZlbnQoJ2Rlc2VsZWN0Tm9kZScsIGV2ZW50LCBwb2ludGVyLCBwcmV2aW91c1NlbGVjdGlvbik7XG4gICAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGFuZGxlIHRoZSBzZWxlY3RlZCBlZGdlc1xuICAgICAgICBpZiAoc2VsZWN0ZWRFZGdlc0NvdW50IC0gcHJldmlvdXNseVNlbGVjdGVkRWRnZUNvdW50ID4gMCAmJiBub2RlU2VsZWN0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgLy8gZWRnZSB3YXMgc2VsZWN0ZWRcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dlbmVyYXRlQ2xpY2tFdmVudCgnc2VsZWN0RWRnZScsIGV2ZW50LCBwb2ludGVyKTtcbiAgICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0ZWRFZGdlc0NvdW50ID4gMCAmJiBlZGdlc0NoYW5nZWQgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dlbmVyYXRlQ2xpY2tFdmVudCgnZGVzZWxlY3RFZGdlJywgZXZlbnQsIHBvaW50ZXIsIHByZXZpb3VzU2VsZWN0aW9uKTtcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dlbmVyYXRlQ2xpY2tFdmVudCgnc2VsZWN0RWRnZScsIGV2ZW50LCBwb2ludGVyKTtcbiAgICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0ZWRFZGdlc0NvdW50IC0gcHJldmlvdXNseVNlbGVjdGVkRWRnZUNvdW50IDwgMCkge1xuICAgICAgICAgIC8vIGVkZ2Ugd2FzIGRlc2VsZWN0ZWRcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dlbmVyYXRlQ2xpY2tFdmVudCgnZGVzZWxlY3RFZGdlJywgZXZlbnQsIHBvaW50ZXIsIHByZXZpb3VzU2VsZWN0aW9uKTtcbiAgICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaXJlIHRoZSBzZWxlY3QgZXZlbnQgaWYgYW55dGhpbmcgaGFzIGJlZW4gc2VsZWN0ZWQgb3IgZGVzZWxlY3RlZFxuICAgICAgICBpZiAoc2VsZWN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAvLyBzZWxlY3Qgb3IgdW5zZWxlY3RcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dlbmVyYXRlQ2xpY2tFdmVudCgnc2VsZWN0JywgZXZlbnQsIHBvaW50ZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBmdW5jdGlvbiBjaGVja3MgaWYgdGhlIG5vZGVzIGFuZCBlZGdlcyBwcmV2aW91c2x5IHNlbGVjdGVkIGhhdmUgY2hhbmdlZC5cbiAgICAgICAqIEBwYXJhbSBwcmV2aW91c1NlbGVjdGlvblxuICAgICAgICogQHBhcmFtIGN1cnJlbnRTZWxlY3Rpb25cbiAgICAgICAqIEByZXR1cm5zIHt7bm9kZXNDaGFuZ2VkOiBib29sZWFuLCBlZGdlc0NoYW5nZWQ6IGJvb2xlYW59fVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2RldGVybWluZUlmRGlmZmVyZW50JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZGV0ZXJtaW5lSWZEaWZmZXJlbnQocHJldmlvdXNTZWxlY3Rpb24sIGN1cnJlbnRTZWxlY3Rpb24pIHtcbiAgICAgICAgdmFyIG5vZGVzQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgZWRnZXNDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmV2aW91c1NlbGVjdGlvbi5ub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChjdXJyZW50U2VsZWN0aW9uLm5vZGVzLmluZGV4T2YocHJldmlvdXNTZWxlY3Rpb24ubm9kZXNbaV0pID09PSAtMSkge1xuICAgICAgICAgICAgbm9kZXNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGN1cnJlbnRTZWxlY3Rpb24ubm9kZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgaWYgKHByZXZpb3VzU2VsZWN0aW9uLm5vZGVzLmluZGV4T2YocHJldmlvdXNTZWxlY3Rpb24ubm9kZXNbX2ldKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIG5vZGVzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHByZXZpb3VzU2VsZWN0aW9uLmVkZ2VzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICBpZiAoY3VycmVudFNlbGVjdGlvbi5lZGdlcy5pbmRleE9mKHByZXZpb3VzU2VsZWN0aW9uLmVkZ2VzW19pMl0pID09PSAtMSkge1xuICAgICAgICAgICAgZWRnZXNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgY3VycmVudFNlbGVjdGlvbi5lZGdlcy5sZW5ndGg7IF9pMysrKSB7XG4gICAgICAgICAgaWYgKHByZXZpb3VzU2VsZWN0aW9uLmVkZ2VzLmluZGV4T2YocHJldmlvdXNTZWxlY3Rpb24uZWRnZXNbX2kzXSkgPT09IC0xKSB7XG4gICAgICAgICAgICBlZGdlc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IG5vZGVzQ2hhbmdlZDogbm9kZXNDaGFuZ2VkLCBlZGdlc0NoYW5nZWQ6IGVkZ2VzQ2hhbmdlZCB9O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGJ5IG9uRHJhZ1N0YXJ0LlxuICAgICAgICogSXQgaXMgc2VwYXJhdGVkIG91dCBiZWNhdXNlIHdlIGNhbiB0aGVuIG92ZXJsb2FkIGl0IGZvciB0aGUgZGF0YW1hbmlwdWxhdGlvbiBzeXN0ZW0uXG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnb25EcmFnU3RhcnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uRHJhZ1N0YXJ0KGV2ZW50KSB7XG4gICAgICAgIC8vaW4gY2FzZSB0aGUgdG91Y2ggZXZlbnQgd2FzIHRyaWdnZXJlZCBvbiBhbiBleHRlcm5hbCBkaXYsIGRvIHRoZSBpbml0aWFsIHRvdWNoIG5vdy5cbiAgICAgICAgaWYgKHRoaXMuZHJhZy5wb2ludGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLm9uVG91Y2goZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm90ZTogZHJhZy5wb2ludGVyIGlzIHNldCBpbiBvblRvdWNoIHRvIGdldCB0aGUgaW5pdGlhbCB0b3VjaCBsb2NhdGlvblxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXROb2RlQXQodGhpcy5kcmFnLnBvaW50ZXIpO1xuXG4gICAgICAgIHRoaXMuZHJhZy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgIHRoaXMuZHJhZy5zZWxlY3Rpb24gPSBbXTtcbiAgICAgICAgdGhpcy5kcmFnLnRyYW5zbGF0aW9uID0gdXRpbC5leHRlbmQoe30sIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uKTsgLy8gY29weSB0aGUgb2JqZWN0XG4gICAgICAgIHRoaXMuZHJhZy5ub2RlSWQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9wdGlvbnMuZHJhZ05vZGVzID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5kcmFnLm5vZGVJZCA9IG5vZGUuaWQ7XG4gICAgICAgICAgLy8gc2VsZWN0IHRoZSBjbGlja2VkIG5vZGUgaWYgbm90IHlldCBzZWxlY3RlZFxuICAgICAgICAgIGlmIChub2RlLmlzU2VsZWN0ZWQoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci51bnNlbGVjdEFsbCgpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnNlbGVjdE9iamVjdChub2RlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBhZnRlciBzZWxlY3QgdG8gY29udGFpbiB0aGUgbm9kZVxuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2VuZXJhdGVDbGlja0V2ZW50KCdkcmFnU3RhcnQnLCBldmVudCwgdGhpcy5kcmFnLnBvaW50ZXIpO1xuXG4gICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5zZWxlY3Rpb25PYmoubm9kZXM7XG4gICAgICAgICAgLy8gY3JlYXRlIGFuIGFycmF5IHdpdGggdGhlIHNlbGVjdGVkIG5vZGVzIGFuZCB0aGVpciBvcmlnaW5hbCBsb2NhdGlvbiBhbmQgc3RhdHVzXG4gICAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIHNlbGVjdGlvbikge1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgICAgIHZhciBvYmplY3QgPSBzZWxlY3Rpb25bbm9kZUlkXTtcbiAgICAgICAgICAgICAgdmFyIHMgPSB7XG4gICAgICAgICAgICAgICAgaWQ6IG9iamVjdC5pZCxcbiAgICAgICAgICAgICAgICBub2RlOiBvYmplY3QsXG5cbiAgICAgICAgICAgICAgICAvLyBzdG9yZSBvcmlnaW5hbCB4LCB5LCB4Rml4ZWQgYW5kIHlGaXhlZCwgbWFrZSB0aGUgbm9kZSB0ZW1wb3JhcmlseSBGaXhlZFxuICAgICAgICAgICAgICAgIHg6IG9iamVjdC54LFxuICAgICAgICAgICAgICAgIHk6IG9iamVjdC55LFxuICAgICAgICAgICAgICAgIHhGaXhlZDogb2JqZWN0Lm9wdGlvbnMuZml4ZWQueCxcbiAgICAgICAgICAgICAgICB5Rml4ZWQ6IG9iamVjdC5vcHRpb25zLmZpeGVkLnlcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBvYmplY3Qub3B0aW9ucy5maXhlZC54ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgb2JqZWN0Lm9wdGlvbnMuZml4ZWQueSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgdGhpcy5kcmFnLnNlbGVjdGlvbi5wdXNoKHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBmYWxsYmFjayBpZiBubyBub2RlIGlzIHNlbGVjdGVkIGFuZCB0aHVzIHRoZSB2aWV3IGlzIGRyYWdnZWQuXG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZW5lcmF0ZUNsaWNrRXZlbnQoJ2RyYWdTdGFydCcsIGV2ZW50LCB0aGlzLmRyYWcucG9pbnRlciwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGhhbmRsZSBkcmFnIGV2ZW50XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdvbkRyYWcnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uRHJhZyhldmVudCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICBpZiAodGhpcy5kcmFnLnBpbmNoZWQgPT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgdGhlIGZvY3VzIG9uIG5vZGUgaWYgaXQgaXMgZm9jdXNzZWQgb24gYnkgdGhlIGZvY3VzT25Ob2RlXG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3VubG9ja05vZGUnKTtcblxuICAgICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuXG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLmRyYWcuc2VsZWN0aW9uO1xuICAgICAgICBpZiAoc2VsZWN0aW9uICYmIHNlbGVjdGlvbi5sZW5ndGggJiYgdGhpcy5vcHRpb25zLmRyYWdOb2RlcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczIuc2VsZWN0aW9uSGFuZGxlci5fZ2VuZXJhdGVDbGlja0V2ZW50KCdkcmFnZ2luZycsIGV2ZW50LCBwb2ludGVyKTtcblxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIGRlbHRhJ3MgYW5kIG5ldyBsb2NhdGlvblxuICAgICAgICAgICAgdmFyIGRlbHRhWCA9IHBvaW50ZXIueCAtIF90aGlzMi5kcmFnLnBvaW50ZXIueDtcbiAgICAgICAgICAgIHZhciBkZWx0YVkgPSBwb2ludGVyLnkgLSBfdGhpczIuZHJhZy5wb2ludGVyLnk7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBwb3NpdGlvbiBvZiBhbGwgc2VsZWN0ZWQgbm9kZXNcbiAgICAgICAgICAgIHNlbGVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgdmFyIG5vZGUgPSBzZWxlY3Rpb24ubm9kZTtcbiAgICAgICAgICAgICAgLy8gb25seSBtb3ZlIHRoZSBub2RlIGlmIGl0IHdhcyBub3QgZml4ZWQgaW5pdGlhbGx5XG4gICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24ueEZpeGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIG5vZGUueCA9IF90aGlzMi5jYW52YXMuX1hjb252ZXJ0RE9NdG9DYW52YXMoX3RoaXMyLmNhbnZhcy5fWGNvbnZlcnRDYW52YXNUb0RPTShzZWxlY3Rpb24ueCkgKyBkZWx0YVgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIG9ubHkgbW92ZSB0aGUgbm9kZSBpZiBpdCB3YXMgbm90IGZpeGVkIGluaXRpYWxseVxuICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uLnlGaXhlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBub2RlLnkgPSBfdGhpczIuY2FudmFzLl9ZY29udmVydERPTXRvQ2FudmFzKF90aGlzMi5jYW52YXMuX1ljb252ZXJ0Q2FudmFzVG9ET00oc2VsZWN0aW9uLnkpICsgZGVsdGFZKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHN0YXJ0IHRoZSBzaW11bGF0aW9uIG9mIHRoZSBwaHlzaWNzXG4gICAgICAgICAgICBfdGhpczIuYm9keS5lbWl0dGVyLmVtaXQoJ3N0YXJ0U2ltdWxhdGlvbicpO1xuICAgICAgICAgIH0pKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbW92ZSB0aGUgbmV0d29ya1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZHJhZ1ZpZXcgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2VuZXJhdGVDbGlja0V2ZW50KCdkcmFnZ2luZycsIGV2ZW50LCBwb2ludGVyLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGUgZHJhZyB3YXMgbm90IHN0YXJ0ZWQgcHJvcGVybHkgYmVjYXVzZSB0aGUgY2xpY2sgc3RhcnRlZCBvdXRzaWRlIHRoZSBuZXR3b3JrIGRpdiwgc3RhcnQgaXQgbm93LlxuICAgICAgICAgICAgaWYgKHRoaXMuZHJhZy5wb2ludGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5vbkRyYWdTdGFydChldmVudCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkaWZmWCA9IHBvaW50ZXIueCAtIHRoaXMuZHJhZy5wb2ludGVyLng7XG4gICAgICAgICAgICB2YXIgZGlmZlkgPSBwb2ludGVyLnkgLSB0aGlzLmRyYWcucG9pbnRlci55O1xuXG4gICAgICAgICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbiA9IHsgeDogdGhpcy5kcmFnLnRyYW5zbGF0aW9uLnggKyBkaWZmWCwgeTogdGhpcy5kcmFnLnRyYW5zbGF0aW9uLnkgKyBkaWZmWSB9O1xuICAgICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX3JlZHJhdycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGhhbmRsZSBkcmFnIHN0YXJ0IGV2ZW50XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdvbkRyYWdFbmQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uRHJhZ0VuZChldmVudCkge1xuICAgICAgICB0aGlzLmRyYWcuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuZHJhZy5zZWxlY3Rpb247XG4gICAgICAgIGlmIChzZWxlY3Rpb24gJiYgc2VsZWN0aW9uLmxlbmd0aCkge1xuICAgICAgICAgIHNlbGVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICAvLyByZXN0b3JlIG9yaWdpbmFsIHhGaXhlZCBhbmQgeUZpeGVkXG4gICAgICAgICAgICBzLm5vZGUub3B0aW9ucy5maXhlZC54ID0gcy54Rml4ZWQ7XG4gICAgICAgICAgICBzLm5vZGUub3B0aW9ucy5maXhlZC55ID0gcy55Rml4ZWQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZW5lcmF0ZUNsaWNrRXZlbnQoJ2RyYWdFbmQnLCBldmVudCwgdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcikpO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3N0YXJ0U2ltdWxhdGlvbicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2VuZXJhdGVDbGlja0V2ZW50KCdkcmFnRW5kJywgZXZlbnQsIHRoaXMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19yZXF1ZXN0UmVkcmF3Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBIYW5kbGUgcGluY2ggZXZlbnRcbiAgICAgICAqIEBwYXJhbSBldmVudFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnb25QaW5jaCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gb25QaW5jaChldmVudCkge1xuICAgICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuXG4gICAgICAgIHRoaXMuZHJhZy5waW5jaGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMucGluY2hbJ3NjYWxlJ10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMucGluY2guc2NhbGUgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogZW5hYmxlZCBtb3Zpbmcgd2hpbGUgcGluY2hpbmc/XG4gICAgICAgIHZhciBzY2FsZSA9IHRoaXMucGluY2guc2NhbGUgKiBldmVudC5zY2FsZTtcbiAgICAgICAgdGhpcy56b29tKHNjYWxlLCBwb2ludGVyKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBab29tIHRoZSBuZXR3b3JrIGluIG9yIG91dFxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIGEgbnVtYmVyIGFyb3VuZCAxLCBhbmQgYmV0d2VlbiAwLjAxIGFuZCAxMFxuICAgICAgICogQHBhcmFtIHt7eDogTnVtYmVyLCB5OiBOdW1iZXJ9fSBwb2ludGVyICAgIFBvc2l0aW9uIG9uIHNjcmVlblxuICAgICAgICogQHJldHVybiB7TnVtYmVyfSBhcHBsaWVkU2NhbGUgICAgc2NhbGUgaXMgbGltaXRlZCB3aXRoaW4gdGhlIGJvdW5kYXJpZXNcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3pvb20nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHpvb20oc2NhbGUsIHBvaW50ZXIpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy56b29tVmlldyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBzY2FsZU9sZCA9IHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgICAgIGlmIChzY2FsZSA8IDAuMDAwMDEpIHtcbiAgICAgICAgICAgIHNjYWxlID0gMC4wMDAwMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNjYWxlID4gMTApIHtcbiAgICAgICAgICAgIHNjYWxlID0gMTA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHByZVNjYWxlRHJhZ1BvaW50ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKHRoaXMuZHJhZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kcmFnLmRyYWdnaW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHByZVNjYWxlRHJhZ1BvaW50ZXIgPSB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyh0aGlzLmRyYWcucG9pbnRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vICsgdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodCAvIDJcbiAgICAgICAgICB2YXIgdHJhbnNsYXRpb24gPSB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbjtcblxuICAgICAgICAgIHZhciBzY2FsZUZyYWMgPSBzY2FsZSAvIHNjYWxlT2xkO1xuICAgICAgICAgIHZhciB0eCA9ICgxIC0gc2NhbGVGcmFjKSAqIHBvaW50ZXIueCArIHRyYW5zbGF0aW9uLnggKiBzY2FsZUZyYWM7XG4gICAgICAgICAgdmFyIHR5ID0gKDEgLSBzY2FsZUZyYWMpICogcG9pbnRlci55ICsgdHJhbnNsYXRpb24ueSAqIHNjYWxlRnJhYztcblxuICAgICAgICAgIHRoaXMuYm9keS52aWV3LnNjYWxlID0gc2NhbGU7XG4gICAgICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24gPSB7IHg6IHR4LCB5OiB0eSB9O1xuXG4gICAgICAgICAgaWYgKHByZVNjYWxlRHJhZ1BvaW50ZXIgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgcG9zdFNjYWxlRHJhZ1BvaW50ZXIgPSB0aGlzLmNhbnZhcy5jYW52YXNUb0RPTShwcmVTY2FsZURyYWdQb2ludGVyKTtcbiAgICAgICAgICAgIHRoaXMuZHJhZy5wb2ludGVyLnggPSBwb3N0U2NhbGVEcmFnUG9pbnRlci54O1xuICAgICAgICAgICAgdGhpcy5kcmFnLnBvaW50ZXIueSA9IHBvc3RTY2FsZURyYWdQb2ludGVyLnk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX3JlcXVlc3RSZWRyYXcnKTtcblxuICAgICAgICAgIGlmIChzY2FsZU9sZCA8IHNjYWxlKSB7XG4gICAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCd6b29tJywgeyBkaXJlY3Rpb246ICcrJywgc2NhbGU6IHRoaXMuYm9keS52aWV3LnNjYWxlIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCd6b29tJywgeyBkaXJlY3Rpb246ICctJywgc2NhbGU6IHRoaXMuYm9keS52aWV3LnNjYWxlIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEV2ZW50IGhhbmRsZXIgZm9yIG1vdXNlIHdoZWVsIGV2ZW50LCB1c2VkIHRvIHpvb20gdGhlIHRpbWVsaW5lXG4gICAgICAgKiBTZWUgaHR0cDovL2Fkb21hcy5vcmcvamF2YXNjcmlwdC1tb3VzZS13aGVlbC9cbiAgICAgICAqICAgICBodHRwczovL2dpdGh1Yi5jb20vRWlnaHRNZWRpYS9oYW1tZXIuanMvaXNzdWVzLzI1NlxuICAgICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSAgZXZlbnRcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ29uTW91c2VXaGVlbCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gb25Nb3VzZVdoZWVsKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuem9vbVZpZXcgPT09IHRydWUpIHtcbiAgICAgICAgICAvLyByZXRyaWV2ZSBkZWx0YVxuICAgICAgICAgIHZhciBkZWx0YSA9IDA7XG4gICAgICAgICAgaWYgKGV2ZW50LndoZWVsRGVsdGEpIHtcbiAgICAgICAgICAgIC8qIElFL09wZXJhLiAqL1xuICAgICAgICAgICAgZGVsdGEgPSBldmVudC53aGVlbERlbHRhIC8gMTIwO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGV0YWlsKSB7XG4gICAgICAgICAgICAvKiBNb3ppbGxhIGNhc2UuICovXG4gICAgICAgICAgICAvLyBJbiBNb3ppbGxhLCBzaWduIG9mIGRlbHRhIGlzIGRpZmZlcmVudCB0aGFuIGluIElFLlxuICAgICAgICAgICAgLy8gQWxzbywgZGVsdGEgaXMgbXVsdGlwbGUgb2YgMy5cbiAgICAgICAgICAgIGRlbHRhID0gLWV2ZW50LmRldGFpbCAvIDM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgZGVsdGEgaXMgbm9uemVybywgaGFuZGxlIGl0LlxuICAgICAgICAgIC8vIEJhc2ljYWxseSwgZGVsdGEgaXMgbm93IHBvc2l0aXZlIGlmIHdoZWVsIHdhcyBzY3JvbGxlZCB1cCxcbiAgICAgICAgICAvLyBhbmQgbmVnYXRpdmUsIGlmIHdoZWVsIHdhcyBzY3JvbGxlZCBkb3duLlxuICAgICAgICAgIGlmIChkZWx0YSAhPT0gMCkge1xuXG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIG5ldyBzY2FsZVxuICAgICAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICAgICAgICB2YXIgem9vbSA9IGRlbHRhIC8gMTA7XG4gICAgICAgICAgICBpZiAoZGVsdGEgPCAwKSB7XG4gICAgICAgICAgICAgIHpvb20gPSB6b29tIC8gKDEgLSB6b29tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNjYWxlICo9IDEgKyB6b29tO1xuXG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHBvaW50ZXIgbG9jYXRpb25cbiAgICAgICAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSB9KTtcblxuICAgICAgICAgICAgLy8gYXBwbHkgdGhlIG5ldyBzY2FsZVxuICAgICAgICAgICAgdGhpcy56b29tKHNjYWxlLCBwb2ludGVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBQcmV2ZW50IGRlZmF1bHQgYWN0aW9ucyBjYXVzZWQgYnkgbW91c2Ugd2hlZWwuXG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE1vdXNlIG1vdmUgaGFuZGxlciBmb3IgY2hlY2tpbmcgd2hldGhlciB0aGUgdGl0bGUgbW92ZXMgb3ZlciBhIG5vZGUgd2l0aCBhIHRpdGxlLlxuICAgICAgICogQHBhcmFtICB7RXZlbnR9IGV2ZW50XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdvbk1vdXNlTW92ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoeyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZIH0pO1xuICAgICAgICB2YXIgcG9wdXBWaXNpYmxlID0gZmFsc2U7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIHByZXZpb3VzbHkgc2VsZWN0ZWQgbm9kZSBpcyBzdGlsbCBzZWxlY3RlZFxuICAgICAgICBpZiAodGhpcy5wb3B1cCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHRoaXMucG9wdXAuaGlkZGVuID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tIaWRlUG9wdXAocG9pbnRlcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaWYgdGhlIHBvcHVwIHdhcyBub3QgaGlkZGVuIGFib3ZlXG4gICAgICAgICAgaWYgKHRoaXMucG9wdXAuaGlkZGVuID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcG9wdXBWaXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMucG9wdXAuc2V0UG9zaXRpb24ocG9pbnRlci54ICsgMywgcG9pbnRlci55IC0gNSk7XG4gICAgICAgICAgICB0aGlzLnBvcHVwLnNob3coKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB3ZSBiaW5kIHRoZSBrZXlib2FyZCB0byB0aGUgZGl2LCB3ZSBoYXZlIHRvIGhpZ2hsaWdodCBpdCB0byB1c2UgaXQuIFRoaXMgaGlnaGxpZ2h0cyBpdCBvbiBtb3VzZSBvdmVyLlxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmtleWJvYXJkLmJpbmRUb1dpbmRvdyA9PT0gZmFsc2UgJiYgdGhpcy5vcHRpb25zLmtleWJvYXJkLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmNhbnZhcy5mcmFtZS5mb2N1cygpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3RhcnQgYSB0aW1lb3V0IHRoYXQgd2lsbCBjaGVjayBpZiB0aGUgbW91c2UgaXMgcG9zaXRpb25lZCBhYm92ZSBhbiBlbGVtZW50XG4gICAgICAgIGlmIChwb3B1cFZpc2libGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKHRoaXMucG9wdXBUaW1lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMucG9wdXBUaW1lcik7IC8vIHN0b3AgYW55IHJ1bm5pbmcgY2FsY3VsYXRpb25UaW1lclxuICAgICAgICAgICAgdGhpcy5wb3B1cFRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMuZHJhZy5kcmFnZ2luZykge1xuICAgICAgICAgICAgdGhpcy5wb3B1cFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczMuX2NoZWNrU2hvd1BvcHVwKHBvaW50ZXIpO1xuICAgICAgICAgICAgfSwgdGhpcy5vcHRpb25zLnRvb2x0aXBEZWxheSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICogQWRkaW5nIGhvdmVyIGhpZ2hsaWdodHNcbiAgICAgICAgKi9cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ob3ZlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgIC8vIGFkZGluZyBob3ZlciBoaWdobGlnaHRzXG4gICAgICAgICAgdmFyIG9iaiA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXROb2RlQXQocG9pbnRlcik7XG4gICAgICAgICAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYmogPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0RWRnZUF0KHBvaW50ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuaG92ZXJPYmplY3Qob2JqKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENoZWNrIGlmIHRoZXJlIGlzIGFuIGVsZW1lbnQgb24gdGhlIGdpdmVuIHBvc2l0aW9uIGluIHRoZSBuZXR3b3JrXG4gICAgICAgKiAoYSBub2RlIG9yIGVkZ2UpLiBJZiBzbywgYW5kIGlmIHRoaXMgZWxlbWVudCBoYXMgYSB0aXRsZSxcbiAgICAgICAqIHNob3cgYSBwb3B1cCB3aW5kb3cgd2l0aCBpdHMgdGl0bGUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHt7eDpOdW1iZXIsIHk6TnVtYmVyfX0gcG9pbnRlclxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2NoZWNrU2hvd1BvcHVwJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY2hlY2tTaG93UG9wdXAocG9pbnRlcikge1xuICAgICAgICB2YXIgeCA9IHRoaXMuY2FudmFzLl9YY29udmVydERPTXRvQ2FudmFzKHBvaW50ZXIueCk7XG4gICAgICAgIHZhciB5ID0gdGhpcy5jYW52YXMuX1ljb252ZXJ0RE9NdG9DYW52YXMocG9pbnRlci55KTtcbiAgICAgICAgdmFyIHBvaW50ZXJPYmogPSB7XG4gICAgICAgICAgbGVmdDogeCxcbiAgICAgICAgICB0b3A6IHksXG4gICAgICAgICAgcmlnaHQ6IHgsXG4gICAgICAgICAgYm90dG9tOiB5XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHByZXZpb3VzUG9wdXBPYmpJZCA9IHRoaXMucG9wdXBPYmogPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHRoaXMucG9wdXBPYmouaWQ7XG4gICAgICAgIHZhciBub2RlVW5kZXJDdXJzb3IgPSBmYWxzZTtcbiAgICAgICAgdmFyIHBvcHVwVHlwZSA9ICdub2RlJztcblxuICAgICAgICAvLyBjaGVjayBpZiBhIG5vZGUgaXMgdW5kZXIgdGhlIGN1cnNvci5cbiAgICAgICAgaWYgKHRoaXMucG9wdXBPYmogPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIHNlYXJjaCB0aGUgbm9kZXMgZm9yIG92ZXJsYXAsIHNlbGVjdCB0aGUgdG9wIG9uZSBpbiBjYXNlIG9mIG11bHRpcGxlIG5vZGVzXG4gICAgICAgICAgdmFyIG5vZGVJbmRpY2VzID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzO1xuICAgICAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgICAgICB2YXIgbm9kZSA9IHZvaWQgMDtcbiAgICAgICAgICB2YXIgb3ZlcmxhcHBpbmdOb2RlcyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2Rlc1tub2RlSW5kaWNlc1tpXV07XG4gICAgICAgICAgICBpZiAobm9kZS5pc092ZXJsYXBwaW5nV2l0aChwb2ludGVyT2JqKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICBpZiAobm9kZS5nZXRUaXRsZSgpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBvdmVybGFwcGluZ05vZGVzLnB1c2gobm9kZUluZGljZXNbaV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG92ZXJsYXBwaW5nTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG92ZXJsYXBwaW5nIG5vZGVzLCBzZWxlY3QgdGhlIGxhc3Qgb25lLCB0aGlzIGlzIHRoZSBvbmUgd2hpY2ggaXMgZHJhd24gb24gdG9wIG9mIHRoZSBvdGhlcnNcbiAgICAgICAgICAgIHRoaXMucG9wdXBPYmogPSBub2Rlc1tvdmVybGFwcGluZ05vZGVzW292ZXJsYXBwaW5nTm9kZXMubGVuZ3RoIC0gMV1dO1xuICAgICAgICAgICAgLy8gaWYgeW91IGhvdmVyIG92ZXIgYSBub2RlLCB0aGUgdGl0bGUgb2YgdGhlIGVkZ2UgaXMgbm90IHN1cHBvc2VkIHRvIGJlIHNob3duLlxuICAgICAgICAgICAgbm9kZVVuZGVyQ3Vyc29yID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5wb3B1cE9iaiA9PT0gdW5kZWZpbmVkICYmIG5vZGVVbmRlckN1cnNvciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAvLyBzZWFyY2ggdGhlIGVkZ2VzIGZvciBvdmVybGFwXG4gICAgICAgICAgdmFyIGVkZ2VJbmRpY2VzID0gdGhpcy5ib2R5LmVkZ2VJbmRpY2VzO1xuICAgICAgICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcbiAgICAgICAgICB2YXIgZWRnZSA9IHZvaWQgMDtcbiAgICAgICAgICB2YXIgb3ZlcmxhcHBpbmdFZGdlcyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IGVkZ2VJbmRpY2VzLmxlbmd0aDsgX2k0KyspIHtcbiAgICAgICAgICAgIGVkZ2UgPSBlZGdlc1tlZGdlSW5kaWNlc1tfaTRdXTtcbiAgICAgICAgICAgIGlmIChlZGdlLmlzT3ZlcmxhcHBpbmdXaXRoKHBvaW50ZXJPYmopID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIGlmIChlZGdlLmNvbm5lY3RlZCA9PT0gdHJ1ZSAmJiBlZGdlLmdldFRpdGxlKCkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG92ZXJsYXBwaW5nRWRnZXMucHVzaChlZGdlSW5kaWNlc1tfaTRdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvdmVybGFwcGluZ0VkZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMucG9wdXBPYmogPSBlZGdlc1tvdmVybGFwcGluZ0VkZ2VzW292ZXJsYXBwaW5nRWRnZXMubGVuZ3RoIC0gMV1dO1xuICAgICAgICAgICAgcG9wdXBUeXBlID0gJ2VkZ2UnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnBvcHVwT2JqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBzaG93IHBvcHVwIG1lc3NhZ2Ugd2luZG93XG4gICAgICAgICAgaWYgKHRoaXMucG9wdXBPYmouaWQgIT09IHByZXZpb3VzUG9wdXBPYmpJZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucG9wdXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0aGlzLnBvcHVwID0gbmV3IF9Qb3B1cDIuZGVmYXVsdCh0aGlzLmNhbnZhcy5mcmFtZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucG9wdXAucG9wdXBUYXJnZXRUeXBlID0gcG9wdXBUeXBlO1xuICAgICAgICAgICAgdGhpcy5wb3B1cC5wb3B1cFRhcmdldElkID0gdGhpcy5wb3B1cE9iai5pZDtcblxuICAgICAgICAgICAgLy8gYWRqdXN0IGEgc21hbGwgb2Zmc2V0IHN1Y2ggdGhhdCB0aGUgbW91c2UgY3Vyc29yIGlzIGxvY2F0ZWQgaW4gdGhlXG4gICAgICAgICAgICAvLyBib3R0b20gbGVmdCBsb2NhdGlvbiBvZiB0aGUgcG9wdXAsIGFuZCB5b3UgY2FuIGVhc2lseSBtb3ZlIG92ZXIgdGhlXG4gICAgICAgICAgICAvLyBwb3B1cCBhcmVhXG4gICAgICAgICAgICB0aGlzLnBvcHVwLnNldFBvc2l0aW9uKHBvaW50ZXIueCArIDMsIHBvaW50ZXIueSAtIDUpO1xuICAgICAgICAgICAgdGhpcy5wb3B1cC5zZXRUZXh0KHRoaXMucG9wdXBPYmouZ2V0VGl0bGUoKSk7XG4gICAgICAgICAgICB0aGlzLnBvcHVwLnNob3coKTtcbiAgICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3Nob3dQb3B1cCcsIHRoaXMucG9wdXBPYmouaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5wb3B1cCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnBvcHVwLmhpZGUoKTtcbiAgICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ2hpZGVQb3B1cCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENoZWNrIGlmIHRoZSBwb3B1cCBtdXN0IGJlIGhpZGRlbiwgd2hpY2ggaXMgdGhlIGNhc2Ugd2hlbiB0aGUgbW91c2UgaXMgbm9cbiAgICAgICAqIGxvbmdlciBob3ZlcmluZyBvbiB0aGUgb2JqZWN0XG4gICAgICAgKiBAcGFyYW0ge3t4Ok51bWJlciwgeTpOdW1iZXJ9fSBwb2ludGVyXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY2hlY2tIaWRlUG9wdXAnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jaGVja0hpZGVQb3B1cChwb2ludGVyKSB7XG4gICAgICAgIHZhciBwb2ludGVyT2JqID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9wb2ludGVyVG9Qb3NpdGlvbk9iamVjdChwb2ludGVyKTtcblxuICAgICAgICB2YXIgc3RpbGxPbk9iaiA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5wb3B1cC5wb3B1cFRhcmdldFR5cGUgPT09ICdub2RlJykge1xuICAgICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbdGhpcy5wb3B1cC5wb3B1cFRhcmdldElkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdGlsbE9uT2JqID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMucG9wdXAucG9wdXBUYXJnZXRJZF0uaXNPdmVybGFwcGluZ1dpdGgocG9pbnRlck9iaik7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSBtb3VzZSBpcyBzdGlsbCBvbmUgdGhlIG5vZGUsIHdlIGhhdmUgdG8gY2hlY2sgaWYgaXQgaXMgbm90IGFsc28gb24gb25lIHRoYXQgaXMgZHJhd24gb24gdG9wIG9mIGl0LlxuICAgICAgICAgICAgLy8gd2UgaW5pdGlhbGx5IG9ubHkgY2hlY2sgc3RpbGxPbk9iaiBiZWNhdXNlIHRoaXMgaXMgbXVjaCBmYXN0ZXIuXG4gICAgICAgICAgICBpZiAoc3RpbGxPbk9iaiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICB2YXIgb3Zlck5vZGUgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0Tm9kZUF0KHBvaW50ZXIpO1xuICAgICAgICAgICAgICBzdGlsbE9uT2JqID0gb3Zlck5vZGUuaWQgPT09IHRoaXMucG9wdXAucG9wdXBUYXJnZXRJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXROb2RlQXQocG9pbnRlcikgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYm9keS5lZGdlc1t0aGlzLnBvcHVwLnBvcHVwVGFyZ2V0SWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgc3RpbGxPbk9iaiA9IHRoaXMuYm9keS5lZGdlc1t0aGlzLnBvcHVwLnBvcHVwVGFyZ2V0SWRdLmlzT3ZlcmxhcHBpbmdXaXRoKHBvaW50ZXJPYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGlsbE9uT2JqID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMucG9wdXBPYmogPSB1bmRlZmluZWQ7XG4gICAgICAgICAgdGhpcy5wb3B1cC5oaWRlKCk7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnaGlkZVBvcHVwJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gSW50ZXJhY3Rpb25IYW5kbGVyO1xuICB9KCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gSW50ZXJhY3Rpb25IYW5kbGVyO1xuXG4vKioqLyB9LFxuLyogMTA5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbiAgdmFyIEhhbW1lciA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuICB2YXIgaGFtbWVyVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xuICB2YXIga2V5Y2hhcm0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcblxuICB2YXIgTmF2aWdhdGlvbkhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmF2aWdhdGlvbkhhbmRsZXIoYm9keSwgY2FudmFzKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTmF2aWdhdGlvbkhhbmRsZXIpO1xuXG4gICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG5cbiAgICAgIHRoaXMuaWNvbnNDcmVhdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLm5hdmlnYXRpb25IYW1tZXJzID0gW107XG4gICAgICB0aGlzLmJvdW5kRnVuY3Rpb25zID0ge307XG4gICAgICB0aGlzLnRvdWNoVGltZSA9IDA7XG4gICAgICB0aGlzLmFjdGl2YXRlZCA9IGZhbHNlO1xuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImFjdGl2YXRlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuYWN0aXZhdGVkID0gdHJ1ZTtfdGhpcy5jb25maWd1cmVLZXlib2FyZEJpbmRpbmdzKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiZGVhY3RpdmF0ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmFjdGl2YXRlZCA9IGZhbHNlO190aGlzLmNvbmZpZ3VyZUtleWJvYXJkQmluZGluZ3MoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJkZXN0cm95XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF90aGlzLmtleWNoYXJtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBfdGhpcy5rZXljaGFybS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoTmF2aWdhdGlvbkhhbmRsZXIsIFt7XG4gICAgICBrZXk6ICdzZXRPcHRpb25zJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgICAgdGhpcy5jcmVhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2NyZWF0ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm5hdmlnYXRpb25CdXR0b25zID09PSB0cnVlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaWNvbnNDcmVhdGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5sb2FkTmF2aWdhdGlvbkVsZW1lbnRzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaWNvbnNDcmVhdGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5jbGVhbk5hdmlnYXRpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29uZmlndXJlS2V5Ym9hcmRCaW5kaW5ncygpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2NsZWFuTmF2aWdhdGlvbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYW5OYXZpZ2F0aW9uKCkge1xuICAgICAgICAvLyBjbGVhbiBoYW1tZXIgYmluZGluZ3NcbiAgICAgICAgaWYgKHRoaXMubmF2aWdhdGlvbkhhbW1lcnMubGVuZ3RoICE9IDApIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubmF2aWdhdGlvbkhhbW1lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMubmF2aWdhdGlvbkhhbW1lcnNbaV0uZGVzdHJveSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm5hdmlnYXRpb25IYW1tZXJzID0gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjbGVhbiB1cCBwcmV2aW91cyBuYXZpZ2F0aW9uIGl0ZW1zXG4gICAgICAgIGlmICh0aGlzLm5hdmlnYXRpb25ET00gJiYgdGhpcy5uYXZpZ2F0aW9uRE9NWyd3cmFwcGVyJ10gJiYgdGhpcy5uYXZpZ2F0aW9uRE9NWyd3cmFwcGVyJ10ucGFyZW50Tm9kZSkge1xuICAgICAgICAgIHRoaXMubmF2aWdhdGlvbkRPTVsnd3JhcHBlciddLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5uYXZpZ2F0aW9uRE9NWyd3cmFwcGVyJ10pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pY29uc0NyZWF0ZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGlvbiBvZiB0aGUgbmF2aWdhdGlvbiBjb250cm9scyBub2Rlcy4gVGhleSBhcmUgZHJhd24gb3ZlciB0aGUgcmVzdCBvZiB0aGUgbm9kZXMgYW5kIGFyZSBub3QgYWZmZWN0ZWQgYnkgc2NhbGUgYW5kIHRyYW5zbGF0aW9uXG4gICAgICAgKiB0aGV5IGhhdmUgYSB0cmlnZ2VyRnVuY3Rpb24gd2hpY2ggaXMgY2FsbGVkIG9uIGNsaWNrLiBJZiB0aGUgcG9zaXRpb24gb2YgdGhlIG5hdmlnYXRpb24gY29udHJvbHMgaXMgZGVwZW5kZW50XG4gICAgICAgKiBvbiB0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCBvciB0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHQsIHdlIGZsYWcgaG9yaXpvbnRhbEFsaWduTGVmdCBhbmQgdmVydGljYWxBbGlnblRvcCBmYWxzZS5cbiAgICAgICAqIFRoaXMgbWVhbnMgdGhhdCB0aGUgbG9jYXRpb24gd2lsbCBiZSBjb3JyZWN0ZWQgYnkgdGhlIF9yZWxvY2F0ZU5hdmlnYXRpb24gZnVuY3Rpb24gb24gYSBzaXplIGNoYW5nZSBvZiB0aGUgY2FudmFzLlxuICAgICAgICpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2xvYWROYXZpZ2F0aW9uRWxlbWVudHMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWROYXZpZ2F0aW9uRWxlbWVudHMoKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuY2xlYW5OYXZpZ2F0aW9uKCk7XG5cbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uRE9NID0ge307XG4gICAgICAgIHZhciBuYXZpZ2F0aW9uRGl2cyA9IFsndXAnLCAnZG93bicsICdsZWZ0JywgJ3JpZ2h0JywgJ3pvb21JbicsICd6b29tT3V0JywgJ3pvb21FeHRlbmRzJ107XG4gICAgICAgIHZhciBuYXZpZ2F0aW9uRGl2QWN0aW9ucyA9IFsnX21vdmVVcCcsICdfbW92ZURvd24nLCAnX21vdmVMZWZ0JywgJ19tb3ZlUmlnaHQnLCAnX3pvb21JbicsICdfem9vbU91dCcsICdfZml0J107XG5cbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uRE9NWyd3cmFwcGVyJ10gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uRE9NWyd3cmFwcGVyJ10uY2xhc3NOYW1lID0gJ3Zpcy1uYXZpZ2F0aW9uJztcbiAgICAgICAgdGhpcy5jYW52YXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5uYXZpZ2F0aW9uRE9NWyd3cmFwcGVyJ10pO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmF2aWdhdGlvbkRpdnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLm5hdmlnYXRpb25ET01bbmF2aWdhdGlvbkRpdnNbaV1dID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uRE9NW25hdmlnYXRpb25EaXZzW2ldXS5jbGFzc05hbWUgPSAndmlzLWJ1dHRvbiB2aXMtJyArIG5hdmlnYXRpb25EaXZzW2ldO1xuICAgICAgICAgIHRoaXMubmF2aWdhdGlvbkRPTVsnd3JhcHBlciddLmFwcGVuZENoaWxkKHRoaXMubmF2aWdhdGlvbkRPTVtuYXZpZ2F0aW9uRGl2c1tpXV0pO1xuXG4gICAgICAgICAgdmFyIGhhbW1lciA9IG5ldyBIYW1tZXIodGhpcy5uYXZpZ2F0aW9uRE9NW25hdmlnYXRpb25EaXZzW2ldXSk7XG4gICAgICAgICAgaWYgKG5hdmlnYXRpb25EaXZBY3Rpb25zW2ldID09PSBcIl9maXRcIikge1xuICAgICAgICAgICAgaGFtbWVyVXRpbC5vblRvdWNoKGhhbW1lciwgdGhpcy5fZml0LmJpbmQodGhpcykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoYW1tZXJVdGlsLm9uVG91Y2goaGFtbWVyLCB0aGlzLmJpbmRUb1JlZHJhdy5iaW5kKHRoaXMsIG5hdmlnYXRpb25EaXZBY3Rpb25zW2ldKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uSGFtbWVycy5wdXNoKGhhbW1lcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1c2UgYSBoYW1tZXIgZm9yIHRoZSByZWxlYXNlIHNvIHdlIGRvIG5vdCByZXF1aXJlIHRoZSBvbmUgdXNlZCBpbiB0aGUgcmVzdCBvZiB0aGUgbmV0d29ya1xuICAgICAgICAvLyB0aGUgb25lIHRoZSByZXN0IHVzZXMgY2FuIGJlIG92ZXJsb2FkZWQgYnkgdGhlIG1hbmlwdWxhdGlvbiBzeXN0ZW0uXG4gICAgICAgIHZhciBoYW1tZXJGcmFtZSA9IG5ldyBIYW1tZXIodGhpcy5jYW52YXMuZnJhbWUpO1xuICAgICAgICBoYW1tZXJVdGlsLm9uUmVsZWFzZShoYW1tZXJGcmFtZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMi5fc3RvcE1vdmVtZW50KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5hdmlnYXRpb25IYW1tZXJzLnB1c2goaGFtbWVyRnJhbWUpO1xuXG4gICAgICAgIHRoaXMuaWNvbnNDcmVhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdiaW5kVG9SZWRyYXcnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRUb1JlZHJhdyhhY3Rpb24pIHtcbiAgICAgICAgaWYgKHRoaXMuYm91bmRGdW5jdGlvbnNbYWN0aW9uXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5ib3VuZEZ1bmN0aW9uc1thY3Rpb25dID0gdGhpc1thY3Rpb25dLmJpbmQodGhpcyk7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJpbml0UmVkcmF3XCIsIHRoaXMuYm91bmRGdW5jdGlvbnNbYWN0aW9uXSk7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9zdGFydFJlbmRlcmluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3VuYmluZEZyb21SZWRyYXcnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVuYmluZEZyb21SZWRyYXcoYWN0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLmJvdW5kRnVuY3Rpb25zW2FjdGlvbl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9mZihcImluaXRSZWRyYXdcIiwgdGhpcy5ib3VuZEZ1bmN0aW9uc1thY3Rpb25dKTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3N0b3BSZW5kZXJpbmdcIik7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuYm91bmRGdW5jdGlvbnNbYWN0aW9uXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHRoaXMgc3RvcHMgYWxsIG1vdmVtZW50IGluZHVjZWQgYnkgdGhlIG5hdmlnYXRpb24gYnV0dG9uc1xuICAgICAgICpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19maXQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9maXQoKSB7XG4gICAgICAgIGlmIChuZXcgRGF0ZSgpLnZhbHVlT2YoKSAtIHRoaXMudG91Y2hUaW1lID4gNzAwKSB7XG4gICAgICAgICAgLy8gVE9ETzogZml4IHVnbHkgaGFjayB0byBhdm9pZCBoYW1tZXIncyBkb3VibGUgZmlyZWluZyBvZiBldmVudCAoYmVjYXVzZSB3ZSB1c2UgcmVsZWFzZT8pXG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImZpdFwiLCB7IGR1cmF0aW9uOiA3MDAgfSk7XG4gICAgICAgICAgdGhpcy50b3VjaFRpbWUgPSBuZXcgRGF0ZSgpLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHRoaXMgc3RvcHMgYWxsIG1vdmVtZW50IGluZHVjZWQgYnkgdGhlIG5hdmlnYXRpb24gYnV0dG9uc1xuICAgICAgICpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19zdG9wTW92ZW1lbnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zdG9wTW92ZW1lbnQoKSB7XG4gICAgICAgIGZvciAodmFyIGJvdW5kQWN0aW9uIGluIHRoaXMuYm91bmRGdW5jdGlvbnMpIHtcbiAgICAgICAgICBpZiAodGhpcy5ib3VuZEZ1bmN0aW9ucy5oYXNPd25Qcm9wZXJ0eShib3VuZEFjdGlvbikpIHtcbiAgICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9mZihcImluaXRSZWRyYXdcIiwgdGhpcy5ib3VuZEZ1bmN0aW9uc1tib3VuZEFjdGlvbl0pO1xuICAgICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9zdG9wUmVuZGVyaW5nXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJvdW5kRnVuY3Rpb25zID0ge307XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX21vdmVVcCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX21vdmVVcCgpIHtcbiAgICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueSArPSB0aGlzLm9wdGlvbnMua2V5Ym9hcmQuc3BlZWQueTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfbW92ZURvd24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9tb3ZlRG93bigpIHtcbiAgICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueSAtPSB0aGlzLm9wdGlvbnMua2V5Ym9hcmQuc3BlZWQueTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfbW92ZUxlZnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9tb3ZlTGVmdCgpIHtcbiAgICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueCArPSB0aGlzLm9wdGlvbnMua2V5Ym9hcmQuc3BlZWQueDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfbW92ZVJpZ2h0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbW92ZVJpZ2h0KCkge1xuICAgICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi54IC09IHRoaXMub3B0aW9ucy5rZXlib2FyZC5zcGVlZC54O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ196b29tSW4nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF96b29tSW4oKSB7XG4gICAgICAgIHRoaXMuYm9keS52aWV3LnNjYWxlICo9IDEgKyB0aGlzLm9wdGlvbnMua2V5Ym9hcmQuc3BlZWQuem9vbTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnem9vbScsIHsgZGlyZWN0aW9uOiAnKycsIHNjYWxlOiB0aGlzLmJvZHkudmlldy5zY2FsZSB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfem9vbU91dCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3pvb21PdXQoKSB7XG4gICAgICAgIHRoaXMuYm9keS52aWV3LnNjYWxlIC89IDEgKyB0aGlzLm9wdGlvbnMua2V5Ym9hcmQuc3BlZWQuem9vbTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnem9vbScsIHsgZGlyZWN0aW9uOiAnLScsIHNjYWxlOiB0aGlzLmJvZHkudmlldy5zY2FsZSB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBiaW5kIGFsbCBrZXlzIHVzaW5nIGtleWNoYXJtLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdjb25maWd1cmVLZXlib2FyZEJpbmRpbmdzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb25maWd1cmVLZXlib2FyZEJpbmRpbmdzKCkge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICBpZiAodGhpcy5rZXljaGFybSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5rZXljaGFybS5kZXN0cm95KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmtleWJvYXJkLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmtleWJvYXJkLmJpbmRUb1dpbmRvdyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5rZXljaGFybSA9IGtleWNoYXJtKHsgY29udGFpbmVyOiB3aW5kb3csIHByZXZlbnREZWZhdWx0OiB0cnVlIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmtleWNoYXJtID0ga2V5Y2hhcm0oeyBjb250YWluZXI6IHRoaXMuY2FudmFzLmZyYW1lLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmtleWNoYXJtLnJlc2V0KCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5hY3RpdmF0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMua2V5Y2hhcm0uYmluZChcInVwXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdyhcIl9tb3ZlVXBcIik7XG4gICAgICAgICAgICB9LCBcImtleWRvd25cIik7XG4gICAgICAgICAgICB0aGlzLmtleWNoYXJtLmJpbmQoXCJkb3duXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdyhcIl9tb3ZlRG93blwiKTtcbiAgICAgICAgICAgIH0sIFwia2V5ZG93blwiKTtcbiAgICAgICAgICAgIHRoaXMua2V5Y2hhcm0uYmluZChcImxlZnRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczMuYmluZFRvUmVkcmF3KFwiX21vdmVMZWZ0XCIpO1xuICAgICAgICAgICAgfSwgXCJrZXlkb3duXCIpO1xuICAgICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKFwicmlnaHRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczMuYmluZFRvUmVkcmF3KFwiX21vdmVSaWdodFwiKTtcbiAgICAgICAgICAgIH0sIFwia2V5ZG93blwiKTtcbiAgICAgICAgICAgIHRoaXMua2V5Y2hhcm0uYmluZChcIj1cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczMuYmluZFRvUmVkcmF3KFwiX3pvb21JblwiKTtcbiAgICAgICAgICAgIH0sIFwia2V5ZG93blwiKTtcbiAgICAgICAgICAgIHRoaXMua2V5Y2hhcm0uYmluZChcIm51bStcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczMuYmluZFRvUmVkcmF3KFwiX3pvb21JblwiKTtcbiAgICAgICAgICAgIH0sIFwia2V5ZG93blwiKTtcbiAgICAgICAgICAgIHRoaXMua2V5Y2hhcm0uYmluZChcIm51bS1cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczMuYmluZFRvUmVkcmF3KFwiX3pvb21PdXRcIik7XG4gICAgICAgICAgICB9LCBcImtleWRvd25cIik7XG4gICAgICAgICAgICB0aGlzLmtleWNoYXJtLmJpbmQoXCItXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdyhcIl96b29tT3V0XCIpO1xuICAgICAgICAgICAgfSwgXCJrZXlkb3duXCIpO1xuICAgICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKFwiW1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfem9vbU91dFwiKTtcbiAgICAgICAgICAgIH0sIFwia2V5ZG93blwiKTtcbiAgICAgICAgICAgIHRoaXMua2V5Y2hhcm0uYmluZChcIl1cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczMuYmluZFRvUmVkcmF3KFwiX3pvb21JblwiKTtcbiAgICAgICAgICAgIH0sIFwia2V5ZG93blwiKTtcbiAgICAgICAgICAgIHRoaXMua2V5Y2hhcm0uYmluZChcInBhZ2V1cFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfem9vbUluXCIpO1xuICAgICAgICAgICAgfSwgXCJrZXlkb3duXCIpO1xuICAgICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKFwicGFnZWRvd25cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczMuYmluZFRvUmVkcmF3KFwiX3pvb21PdXRcIik7XG4gICAgICAgICAgICB9LCBcImtleWRvd25cIik7XG5cbiAgICAgICAgICAgIHRoaXMua2V5Y2hhcm0uYmluZChcInVwXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoXCJfbW92ZVVwXCIpO1xuICAgICAgICAgICAgfSwgXCJrZXl1cFwiKTtcbiAgICAgICAgICAgIHRoaXMua2V5Y2hhcm0uYmluZChcImRvd25cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczMudW5iaW5kRnJvbVJlZHJhdyhcIl9tb3ZlRG93blwiKTtcbiAgICAgICAgICAgIH0sIFwia2V5dXBcIik7XG4gICAgICAgICAgICB0aGlzLmtleWNoYXJtLmJpbmQoXCJsZWZ0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoXCJfbW92ZUxlZnRcIik7XG4gICAgICAgICAgICB9LCBcImtleXVwXCIpO1xuICAgICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKFwicmlnaHRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczMudW5iaW5kRnJvbVJlZHJhdyhcIl9tb3ZlUmlnaHRcIik7XG4gICAgICAgICAgICB9LCBcImtleXVwXCIpO1xuICAgICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKFwiPVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KFwiX3pvb21JblwiKTtcbiAgICAgICAgICAgIH0sIFwia2V5dXBcIik7XG4gICAgICAgICAgICB0aGlzLmtleWNoYXJtLmJpbmQoXCJudW0rXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoXCJfem9vbUluXCIpO1xuICAgICAgICAgICAgfSwgXCJrZXl1cFwiKTtcbiAgICAgICAgICAgIHRoaXMua2V5Y2hhcm0uYmluZChcIm51bS1cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczMudW5iaW5kRnJvbVJlZHJhdyhcIl96b29tT3V0XCIpO1xuICAgICAgICAgICAgfSwgXCJrZXl1cFwiKTtcbiAgICAgICAgICAgIHRoaXMua2V5Y2hhcm0uYmluZChcIi1cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczMudW5iaW5kRnJvbVJlZHJhdyhcIl96b29tT3V0XCIpO1xuICAgICAgICAgICAgfSwgXCJrZXl1cFwiKTtcbiAgICAgICAgICAgIHRoaXMua2V5Y2hhcm0uYmluZChcIltcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczMudW5iaW5kRnJvbVJlZHJhdyhcIl96b29tT3V0XCIpO1xuICAgICAgICAgICAgfSwgXCJrZXl1cFwiKTtcbiAgICAgICAgICAgIHRoaXMua2V5Y2hhcm0uYmluZChcIl1cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczMudW5iaW5kRnJvbVJlZHJhdyhcIl96b29tSW5cIik7XG4gICAgICAgICAgICB9LCBcImtleXVwXCIpO1xuICAgICAgICAgICAgdGhpcy5rZXljaGFybS5iaW5kKFwicGFnZXVwXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoXCJfem9vbUluXCIpO1xuICAgICAgICAgICAgfSwgXCJrZXl1cFwiKTtcbiAgICAgICAgICAgIHRoaXMua2V5Y2hhcm0uYmluZChcInBhZ2Vkb3duXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoXCJfem9vbU91dFwiKTtcbiAgICAgICAgICAgIH0sIFwia2V5dXBcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIE5hdmlnYXRpb25IYW5kbGVyO1xuICB9KCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gTmF2aWdhdGlvbkhhbmRsZXI7XG5cbi8qKiovIH0sXG4vKiAxMTAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgLyoqXG4gICAqIFBvcHVwIGlzIGEgY2xhc3MgdG8gY3JlYXRlIGEgcG9wdXAgd2luZG93IHdpdGggc29tZSB0ZXh0XG4gICAqIEBwYXJhbSB7RWxlbWVudH0gIGNvbnRhaW5lciAgICAgVGhlIGNvbnRhaW5lciBvYmplY3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbeF1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt5XVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3RleHRdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbc3R5bGVdICAgICBBbiBvYmplY3QgY29udGFpbmluZyBib3JkZXJDb2xvcixcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvciwgZXRjLlxuICAgKi9cblxuICB2YXIgUG9wdXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUG9wdXAoY29udGFpbmVyKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9wdXApO1xuXG4gICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcblxuICAgICAgdGhpcy54ID0gMDtcbiAgICAgIHRoaXMueSA9IDA7XG4gICAgICB0aGlzLnBhZGRpbmcgPSA1O1xuICAgICAgdGhpcy5oaWRkZW4gPSBmYWxzZTtcblxuICAgICAgLy8gY3JlYXRlIHRoZSBmcmFtZVxuICAgICAgdGhpcy5mcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5mcmFtZS5jbGFzc05hbWUgPSAndmlzLW5ldHdvcmstdG9vbHRpcCc7XG4gICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmZyYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAgIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIHBvcHVwIHdpbmRvd1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5ICAgVmVydGljYWwgcG9zaXRpb24gb2YgdGhlIHBvcHVwIHdpbmRvd1xuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoUG9wdXAsIFt7XG4gICAgICBrZXk6ICdzZXRQb3NpdGlvbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UG9zaXRpb24oeCwgeSkge1xuICAgICAgICB0aGlzLnggPSBwYXJzZUludCh4KTtcbiAgICAgICAgdGhpcy55ID0gcGFyc2VJbnQoeSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0IHRoZSBjb250ZW50IGZvciB0aGUgcG9wdXAgd2luZG93LiBUaGlzIGNhbiBiZSBIVE1MIGNvZGUgb3IgdGV4dC5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgRWxlbWVudH0gY29udGVudFxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzZXRUZXh0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRUZXh0KGNvbnRlbnQpIHtcbiAgICAgICAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgdGhpcy5mcmFtZS5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZnJhbWUuaW5uZXJIVE1MID0gY29udGVudDsgLy8gc3RyaW5nIGNvbnRhaW5pbmcgdGV4dCBvciBIVE1MXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTaG93IHRoZSBwb3B1cCB3aW5kb3dcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RvU2hvd10gICAgU2hvdyBvciBoaWRlIHRoZSB3aW5kb3dcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc2hvdycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2hvdyhkb1Nob3cpIHtcbiAgICAgICAgaWYgKGRvU2hvdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZG9TaG93ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb1Nob3cgPT09IHRydWUpIHtcbiAgICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5mcmFtZS5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5mcmFtZS5jbGllbnRXaWR0aDtcbiAgICAgICAgICB2YXIgbWF4SGVpZ2h0ID0gdGhpcy5mcmFtZS5wYXJlbnROb2RlLmNsaWVudEhlaWdodDtcbiAgICAgICAgICB2YXIgbWF4V2lkdGggPSB0aGlzLmZyYW1lLnBhcmVudE5vZGUuY2xpZW50V2lkdGg7XG5cbiAgICAgICAgICB2YXIgdG9wID0gdGhpcy55IC0gaGVpZ2h0O1xuICAgICAgICAgIGlmICh0b3AgKyBoZWlnaHQgKyB0aGlzLnBhZGRpbmcgPiBtYXhIZWlnaHQpIHtcbiAgICAgICAgICAgIHRvcCA9IG1heEhlaWdodCAtIGhlaWdodCAtIHRoaXMucGFkZGluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRvcCA8IHRoaXMucGFkZGluZykge1xuICAgICAgICAgICAgdG9wID0gdGhpcy5wYWRkaW5nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBsZWZ0ID0gdGhpcy54O1xuICAgICAgICAgIGlmIChsZWZ0ICsgd2lkdGggKyB0aGlzLnBhZGRpbmcgPiBtYXhXaWR0aCkge1xuICAgICAgICAgICAgbGVmdCA9IG1heFdpZHRoIC0gd2lkdGggLSB0aGlzLnBhZGRpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsZWZ0IDwgdGhpcy5wYWRkaW5nKSB7XG4gICAgICAgICAgICBsZWZ0ID0gdGhpcy5wYWRkaW5nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZnJhbWUuc3R5bGUubGVmdCA9IGxlZnQgKyBcInB4XCI7XG4gICAgICAgICAgdGhpcy5mcmFtZS5zdHlsZS50b3AgPSB0b3AgKyBcInB4XCI7XG4gICAgICAgICAgdGhpcy5mcmFtZS5zdHlsZS52aXNpYmlsaXR5ID0gXCJ2aXNpYmxlXCI7XG4gICAgICAgICAgdGhpcy5oaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhpZGUgdGhlIHBvcHVwIHdpbmRvd1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdoaWRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgICB0aGlzLmhpZGRlbiA9IHRydWU7XG4gICAgICAgIHRoaXMuZnJhbWUuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFBvcHVwO1xuICB9KCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gUG9wdXA7XG5cbi8qKiovIH0sXG4vKiAxMTEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIHZhciBfTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjUpO1xuXG4gIHZhciBfTm9kZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Ob2RlKTtcblxuICB2YXIgX0VkZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1KTtcblxuICB2YXIgX0VkZ2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRWRnZSk7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuICB2YXIgU2VsZWN0aW9uSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZWxlY3Rpb25IYW5kbGVyKGJvZHksIGNhbnZhcykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNlbGVjdGlvbkhhbmRsZXIpO1xuXG4gICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgICB0aGlzLnNlbGVjdGlvbk9iaiA9IHsgbm9kZXM6IFtdLCBlZGdlczogW10gfTtcbiAgICAgIHRoaXMuaG92ZXJPYmogPSB7IG5vZGVzOiB7fSwgZWRnZXM6IHt9IH07XG5cbiAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgICAgbXVsdGlzZWxlY3Q6IGZhbHNlLFxuICAgICAgICBzZWxlY3RhYmxlOiB0cnVlLFxuICAgICAgICBzZWxlY3RDb25uZWN0ZWRFZGdlczogdHJ1ZSxcbiAgICAgICAgaG92ZXJDb25uZWN0ZWRFZGdlczogdHJ1ZVxuICAgICAgfTtcbiAgICAgIHV0aWwuZXh0ZW5kKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2RhdGFDaGFuZ2VkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMudXBkYXRlU2VsZWN0aW9uKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoU2VsZWN0aW9uSGFuZGxlciwgW3tcbiAgICAgIGtleTogJ3NldE9wdGlvbnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIGZpZWxkcyA9IFsnbXVsdGlzZWxlY3QnLCAnaG92ZXJDb25uZWN0ZWRFZGdlcycsICdzZWxlY3RhYmxlJywgJ3NlbGVjdENvbm5lY3RlZEVkZ2VzJ107XG4gICAgICAgICAgdXRpbC5zZWxlY3RpdmVEZWVwRXh0ZW5kKGZpZWxkcywgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGhhbmRsZXMgdGhlIHNlbGVjdGlvbiBwYXJ0IG9mIHRoZSB0YXA7XG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NlbGVjdE9uUG9pbnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdE9uUG9pbnQocG9pbnRlcikge1xuICAgICAgICB2YXIgc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zZWxlY3RhYmxlID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIG9iaiA9IHRoaXMuZ2V0Tm9kZUF0KHBvaW50ZXIpIHx8IHRoaXMuZ2V0RWRnZUF0KHBvaW50ZXIpO1xuXG4gICAgICAgICAgLy8gdW5zZWxlY3QgYWZ0ZXIgZ2V0dGluZyB0aGUgb2JqZWN0cyBpbiBvcmRlciB0byByZXN0b3JlIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgICAgICAgdGhpcy51bnNlbGVjdEFsbCgpO1xuXG4gICAgICAgICAgaWYgKG9iaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzZWxlY3RlZCA9IHRoaXMuc2VsZWN0T2JqZWN0KG9iaik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnc2VsZWN0QWRkaXRpb25hbE9uUG9pbnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdEFkZGl0aW9uYWxPblBvaW50KHBvaW50ZXIpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zZWxlY3RhYmxlID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIG9iaiA9IHRoaXMuZ2V0Tm9kZUF0KHBvaW50ZXIpIHx8IHRoaXMuZ2V0RWRnZUF0KHBvaW50ZXIpO1xuXG4gICAgICAgICAgaWYgKG9iaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25DaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChvYmouaXNTZWxlY3RlZCgpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHRoaXMuZGVzZWxlY3RPYmplY3Qob2JqKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuc2VsZWN0T2JqZWN0KG9iaik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGVjdGlvbkNoYW5nZWQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2dlbmVyYXRlQ2xpY2tFdmVudCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2dlbmVyYXRlQ2xpY2tFdmVudChldmVudFR5cGUsIGV2ZW50LCBwb2ludGVyLCBvbGRTZWxlY3Rpb24pIHtcbiAgICAgICAgdmFyIGVtcHR5U2VsZWN0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA8PSA0IHx8IGFyZ3VtZW50c1s0XSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBhcmd1bWVudHNbNF07XG5cbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB2b2lkIDA7XG4gICAgICAgIGlmIChlbXB0eVNlbGVjdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHByb3BlcnRpZXMgPSB7IG5vZGVzOiBbXSwgZWRnZXM6IFtdIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcGVydGllcyA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvcGVydGllc1sncG9pbnRlciddID0ge1xuICAgICAgICAgIERPTTogeyB4OiBwb2ludGVyLngsIHk6IHBvaW50ZXIueSB9LFxuICAgICAgICAgIGNhbnZhczogdGhpcy5jYW52YXMuRE9NdG9DYW52YXMocG9pbnRlcilcbiAgICAgICAgfTtcbiAgICAgICAgcHJvcGVydGllc1snZXZlbnQnXSA9IGV2ZW50O1xuXG4gICAgICAgIGlmIChvbGRTZWxlY3Rpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHByb3BlcnRpZXNbJ3ByZXZpb3VzU2VsZWN0aW9uJ10gPSBvbGRTZWxlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChldmVudFR5cGUsIHByb3BlcnRpZXMpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NlbGVjdE9iamVjdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0T2JqZWN0KG9iaikge1xuICAgICAgICB2YXIgaGlnaGxpZ2h0RWRnZXMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB0aGlzLm9wdGlvbnMuc2VsZWN0Q29ubmVjdGVkRWRnZXMgOiBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgaWYgKG9iaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIF9Ob2RlMi5kZWZhdWx0KSB7XG4gICAgICAgICAgICBpZiAoaGlnaGxpZ2h0RWRnZXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0Q29ubmVjdGVkRWRnZXMob2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgb2JqLnNlbGVjdCgpO1xuICAgICAgICAgIHRoaXMuX2FkZFRvU2VsZWN0aW9uKG9iaik7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Rlc2VsZWN0T2JqZWN0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXNlbGVjdE9iamVjdChvYmopIHtcbiAgICAgICAgaWYgKG9iai5pc1NlbGVjdGVkKCkgPT09IHRydWUpIHtcbiAgICAgICAgICBvYmouc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLl9yZW1vdmVGcm9tU2VsZWN0aW9uKG9iaik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiByZXRyaWV2ZSBhbGwgbm9kZXMgb3ZlcmxhcHBpbmcgd2l0aCBnaXZlbiBvYmplY3RcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgIEFuIG9iamVjdCB3aXRoIHBhcmFtZXRlcnMgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tXG4gICAgICAgKiBAcmV0dXJuIHtOdW1iZXJbXX0gICBBbiBhcnJheSB3aXRoIGlkJ3Mgb2YgdGhlIG92ZXJsYXBwaW5nIG5vZGVzXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZ2V0QWxsTm9kZXNPdmVybGFwcGluZ1dpdGgnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRBbGxOb2Rlc092ZXJsYXBwaW5nV2l0aChvYmplY3QpIHtcbiAgICAgICAgdmFyIG92ZXJsYXBwaW5nTm9kZXMgPSBbXTtcbiAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBub2RlSWQgPSB0aGlzLmJvZHkubm9kZUluZGljZXNbaV07XG4gICAgICAgICAgaWYgKG5vZGVzW25vZGVJZF0uaXNPdmVybGFwcGluZ1dpdGgob2JqZWN0KSkge1xuICAgICAgICAgICAgb3ZlcmxhcHBpbmdOb2Rlcy5wdXNoKG5vZGVJZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdmVybGFwcGluZ05vZGVzO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybiBhIHBvc2l0aW9uIG9iamVjdCBpbiBjYW52YXNzcGFjZSBmcm9tIGEgc2luZ2xlIHBvaW50IGluIHNjcmVlbnNwYWNlXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHBvaW50ZXJcbiAgICAgICAqIEByZXR1cm5zIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgcmlnaHQ6IG51bWJlciwgYm90dG9tOiBudW1iZXJ9fVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3BvaW50ZXJUb1Bvc2l0aW9uT2JqZWN0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcG9pbnRlclRvUG9zaXRpb25PYmplY3QocG9pbnRlcikge1xuICAgICAgICB2YXIgY2FudmFzUG9zID0gdGhpcy5jYW52YXMuRE9NdG9DYW52YXMocG9pbnRlcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGVmdDogY2FudmFzUG9zLnggLSAxLFxuICAgICAgICAgIHRvcDogY2FudmFzUG9zLnkgKyAxLFxuICAgICAgICAgIHJpZ2h0OiBjYW52YXNQb3MueCArIDEsXG4gICAgICAgICAgYm90dG9tOiBjYW52YXNQb3MueSAtIDFcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBHZXQgdGhlIHRvcCBub2RlIGF0IHRoZSBhIHNwZWNpZmljIHBvaW50IChsaWtlIGEgY2xpY2spXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHt7eDogTnVtYmVyLCB5OiBOdW1iZXJ9fSBwb2ludGVyXG4gICAgICAgKiBAcmV0dXJuIHtOb2RlIHwgdW5kZWZpbmVkfSBub2RlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldE5vZGVBdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Tm9kZUF0KHBvaW50ZXIpIHtcbiAgICAgICAgdmFyIHJldHVybk5vZGUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB0cnVlIDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgIC8vIHdlIGZpcnN0IGNoZWNrIGlmIHRoaXMgaXMgYW4gbmF2aWdhdGlvbiBjb250cm9scyBlbGVtZW50XG4gICAgICAgIHZhciBwb3NpdGlvbk9iamVjdCA9IHRoaXMuX3BvaW50ZXJUb1Bvc2l0aW9uT2JqZWN0KHBvaW50ZXIpO1xuICAgICAgICB2YXIgb3ZlcmxhcHBpbmdOb2RlcyA9IHRoaXMuX2dldEFsbE5vZGVzT3ZlcmxhcHBpbmdXaXRoKHBvc2l0aW9uT2JqZWN0KTtcbiAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG92ZXJsYXBwaW5nIG5vZGVzLCBzZWxlY3QgdGhlIGxhc3Qgb25lLCB0aGlzIGlzIHRoZVxuICAgICAgICAvLyBvbmUgd2hpY2ggaXMgZHJhd24gb24gdG9wIG9mIHRoZSBvdGhlcnNcbiAgICAgICAgaWYgKG92ZXJsYXBwaW5nTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGlmIChyZXR1cm5Ob2RlID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5Lm5vZGVzW292ZXJsYXBwaW5nTm9kZXNbb3ZlcmxhcHBpbmdOb2Rlcy5sZW5ndGggLSAxXV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvdmVybGFwcGluZ05vZGVzW292ZXJsYXBwaW5nTm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiByZXRyaWV2ZSBhbGwgZWRnZXMgb3ZlcmxhcHBpbmcgd2l0aCBnaXZlbiBvYmplY3QsIHNlbGVjdG9yIGlzIGFyb3VuZCBjZW50ZXJcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgIEFuIG9iamVjdCB3aXRoIHBhcmFtZXRlcnMgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tXG4gICAgICAgKiBAcmV0dXJuIHtOdW1iZXJbXX0gICBBbiBhcnJheSB3aXRoIGlkJ3Mgb2YgdGhlIG92ZXJsYXBwaW5nIG5vZGVzXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZ2V0RWRnZXNPdmVybGFwcGluZ1dpdGgnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRFZGdlc092ZXJsYXBwaW5nV2l0aChvYmplY3QsIG92ZXJsYXBwaW5nRWRnZXMpIHtcbiAgICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9keS5lZGdlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlZGdlSWQgPSB0aGlzLmJvZHkuZWRnZUluZGljZXNbaV07XG4gICAgICAgICAgaWYgKGVkZ2VzW2VkZ2VJZF0uaXNPdmVybGFwcGluZ1dpdGgob2JqZWN0KSkge1xuICAgICAgICAgICAgb3ZlcmxhcHBpbmdFZGdlcy5wdXNoKGVkZ2VJZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogcmV0cmlldmUgYWxsIG5vZGVzIG92ZXJsYXBwaW5nIHdpdGggZ2l2ZW4gb2JqZWN0XG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0ICBBbiBvYmplY3Qgd2l0aCBwYXJhbWV0ZXJzIGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbVxuICAgICAgICogQHJldHVybiB7TnVtYmVyW119ICAgQW4gYXJyYXkgd2l0aCBpZCdzIG9mIHRoZSBvdmVybGFwcGluZyBub2Rlc1xuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2dldEFsbEVkZ2VzT3ZlcmxhcHBpbmdXaXRoJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0QWxsRWRnZXNPdmVybGFwcGluZ1dpdGgob2JqZWN0KSB7XG4gICAgICAgIHZhciBvdmVybGFwcGluZ0VkZ2VzID0gW107XG4gICAgICAgIHRoaXMuX2dldEVkZ2VzT3ZlcmxhcHBpbmdXaXRoKG9iamVjdCwgb3ZlcmxhcHBpbmdFZGdlcyk7XG4gICAgICAgIHJldHVybiBvdmVybGFwcGluZ0VkZ2VzO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFBsYWNlIGhvbGRlci4gVG8gaW1wbGVtZW50IGNoYW5nZSB0aGUgZ2V0Tm9kZUF0IHRvIGEgX2dldE9iamVjdEF0LiBIYXZlIHRoZSBfZ2V0T2JqZWN0QXQgY2FsbFxuICAgICAgICogZ2V0Tm9kZUF0IGFuZCBfZ2V0RWRnZXNBdCwgdGhlbiBwcmlvcnRpemUgdGhlIHNlbGVjdGlvbiB0byB1c2VyIHByZWZlcmVuY2VzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSBwb2ludGVyXG4gICAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXRFZGdlQXQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVkZ2VBdChwb2ludGVyKSB7XG4gICAgICAgIHZhciByZXR1cm5FZGdlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICB2YXIgcG9zaXRpb25PYmplY3QgPSB0aGlzLl9wb2ludGVyVG9Qb3NpdGlvbk9iamVjdChwb2ludGVyKTtcbiAgICAgICAgdmFyIG92ZXJsYXBwaW5nRWRnZXMgPSB0aGlzLl9nZXRBbGxFZGdlc092ZXJsYXBwaW5nV2l0aChwb3NpdGlvbk9iamVjdCk7XG5cbiAgICAgICAgaWYgKG92ZXJsYXBwaW5nRWRnZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGlmIChyZXR1cm5FZGdlID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5LmVkZ2VzW292ZXJsYXBwaW5nRWRnZXNbb3ZlcmxhcHBpbmdFZGdlcy5sZW5ndGggLSAxXV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvdmVybGFwcGluZ0VkZ2VzW292ZXJsYXBwaW5nRWRnZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBZGQgb2JqZWN0IHRvIHRoZSBzZWxlY3Rpb24gYXJyYXkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIG9ialxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2FkZFRvU2VsZWN0aW9uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkVG9TZWxlY3Rpb24ob2JqKSB7XG4gICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBfTm9kZTIuZGVmYXVsdCkge1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uT2JqLm5vZGVzW29iai5pZF0gPSBvYmo7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25PYmouZWRnZXNbb2JqLmlkXSA9IG9iajtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFkZCBvYmplY3QgdG8gdGhlIHNlbGVjdGlvbiBhcnJheS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gb2JqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfYWRkVG9Ib3ZlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZFRvSG92ZXIob2JqKSB7XG4gICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBfTm9kZTIuZGVmYXVsdCkge1xuICAgICAgICAgIHRoaXMuaG92ZXJPYmoubm9kZXNbb2JqLmlkXSA9IG9iajtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmhvdmVyT2JqLmVkZ2VzW29iai5pZF0gPSBvYmo7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmUgYSBzaW5nbGUgb3B0aW9uIGZyb20gc2VsZWN0aW9uLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19yZW1vdmVGcm9tU2VsZWN0aW9uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlRnJvbVNlbGVjdGlvbihvYmopIHtcbiAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIF9Ob2RlMi5kZWZhdWx0KSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuc2VsZWN0aW9uT2JqLm5vZGVzW29iai5pZF07XG4gICAgICAgICAgdGhpcy5fdW5zZWxlY3RDb25uZWN0ZWRFZGdlcyhvYmopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnNlbGVjdGlvbk9iai5lZGdlc1tvYmouaWRdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVW5zZWxlY3QgYWxsLiBUaGUgc2VsZWN0aW9uT2JqIGlzIHVzZWZ1bCBmb3IgdGhpcy5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAndW5zZWxlY3RBbGwnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVuc2VsZWN0QWxsKCkge1xuICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gdGhpcy5zZWxlY3Rpb25PYmoubm9kZXMpIHtcbiAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25PYmoubm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25PYmoubm9kZXNbbm9kZUlkXS51bnNlbGVjdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBlZGdlSWQgaW4gdGhpcy5zZWxlY3Rpb25PYmouZWRnZXMpIHtcbiAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25PYmouZWRnZXMuaGFzT3duUHJvcGVydHkoZWRnZUlkKSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25PYmouZWRnZXNbZWRnZUlkXS51bnNlbGVjdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uT2JqID0geyBub2Rlczoge30sIGVkZ2VzOiB7fSB9O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHJldHVybiB0aGUgbnVtYmVyIG9mIHNlbGVjdGVkIG5vZGVzXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19nZXRTZWxlY3RlZE5vZGVDb3VudCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFNlbGVjdGVkTm9kZUNvdW50KCkge1xuICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gdGhpcy5zZWxlY3Rpb25PYmoubm9kZXMpIHtcbiAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25PYmoubm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHJldHVybiB0aGUgc2VsZWN0ZWQgbm9kZVxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZ2V0U2VsZWN0ZWROb2RlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0U2VsZWN0ZWROb2RlKCkge1xuICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gdGhpcy5zZWxlY3Rpb25PYmoubm9kZXMpIHtcbiAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25PYmoubm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uT2JqLm5vZGVzW25vZGVJZF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogcmV0dXJuIHRoZSBzZWxlY3RlZCBlZGdlXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19nZXRTZWxlY3RlZEVkZ2UnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRTZWxlY3RlZEVkZ2UoKSB7XG4gICAgICAgIGZvciAodmFyIGVkZ2VJZCBpbiB0aGlzLnNlbGVjdGlvbk9iai5lZGdlcykge1xuICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk9iai5lZGdlcy5oYXNPd25Qcm9wZXJ0eShlZGdlSWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25PYmouZWRnZXNbZWRnZUlkXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiByZXR1cm4gdGhlIG51bWJlciBvZiBzZWxlY3RlZCBlZGdlc1xuICAgICAgICpcbiAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZ2V0U2VsZWN0ZWRFZGdlQ291bnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRTZWxlY3RlZEVkZ2VDb3VudCgpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgZm9yICh2YXIgZWRnZUlkIGluIHRoaXMuc2VsZWN0aW9uT2JqLmVkZ2VzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uT2JqLmVkZ2VzLmhhc093blByb3BlcnR5KGVkZ2VJZCkpIHtcbiAgICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiByZXR1cm4gdGhlIG51bWJlciBvZiBzZWxlY3RlZCBvYmplY3RzLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZ2V0U2VsZWN0ZWRPYmplY3RDb3VudCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFNlbGVjdGVkT2JqZWN0Q291bnQoKSB7XG4gICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiB0aGlzLnNlbGVjdGlvbk9iai5ub2Rlcykge1xuICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk9iai5ub2Rlcy5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBlZGdlSWQgaW4gdGhpcy5zZWxlY3Rpb25PYmouZWRnZXMpIHtcbiAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25PYmouZWRnZXMuaGFzT3duUHJvcGVydHkoZWRnZUlkKSkge1xuICAgICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENoZWNrIGlmIGFueXRoaW5nIGlzIHNlbGVjdGVkXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc2VsZWN0aW9uSXNFbXB0eScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NlbGVjdGlvbklzRW1wdHkoKSB7XG4gICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiB0aGlzLnNlbGVjdGlvbk9iai5ub2Rlcykge1xuICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk9iai5ub2Rlcy5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGVkZ2VJZCBpbiB0aGlzLnNlbGVjdGlvbk9iai5lZGdlcykge1xuICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk9iai5lZGdlcy5oYXNPd25Qcm9wZXJ0eShlZGdlSWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGNoZWNrIGlmIG9uZSBvZiB0aGUgc2VsZWN0ZWQgbm9kZXMgaXMgYSBjbHVzdGVyLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2NsdXN0ZXJJblNlbGVjdGlvbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NsdXN0ZXJJblNlbGVjdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIHRoaXMuc2VsZWN0aW9uT2JqLm5vZGVzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uT2JqLm5vZGVzLmhhc093blByb3BlcnR5KG5vZGVJZCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk9iai5ub2Rlc1tub2RlSWRdLmNsdXN0ZXJTaXplID4gMSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHNlbGVjdCB0aGUgZWRnZXMgY29ubmVjdGVkIHRvIHRoZSBub2RlIHRoYXQgaXMgYmVpbmcgc2VsZWN0ZWRcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19zZWxlY3RDb25uZWN0ZWRFZGdlcycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NlbGVjdENvbm5lY3RlZEVkZ2VzKG5vZGUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVkZ2UgPSBub2RlLmVkZ2VzW2ldO1xuICAgICAgICAgIGVkZ2Uuc2VsZWN0KCk7XG4gICAgICAgICAgdGhpcy5fYWRkVG9TZWxlY3Rpb24oZWRnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBzZWxlY3QgdGhlIGVkZ2VzIGNvbm5lY3RlZCB0byB0aGUgbm9kZSB0aGF0IGlzIGJlaW5nIHNlbGVjdGVkXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfaG92ZXJDb25uZWN0ZWRFZGdlcycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hvdmVyQ29ubmVjdGVkRWRnZXMobm9kZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWRnZSA9IG5vZGUuZWRnZXNbaV07XG4gICAgICAgICAgZWRnZS5ob3ZlciA9IHRydWU7XG4gICAgICAgICAgdGhpcy5fYWRkVG9Ib3ZlcihlZGdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHVuc2VsZWN0IHRoZSBlZGdlcyBjb25uZWN0ZWQgdG8gdGhlIG5vZGUgdGhhdCBpcyBiZWluZyBzZWxlY3RlZFxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3Vuc2VsZWN0Q29ubmVjdGVkRWRnZXMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91bnNlbGVjdENvbm5lY3RlZEVkZ2VzKG5vZGUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVkZ2UgPSBub2RlLmVkZ2VzW2ldO1xuICAgICAgICAgIGVkZ2UudW5zZWxlY3QoKTtcbiAgICAgICAgICB0aGlzLl9yZW1vdmVGcm9tU2VsZWN0aW9uKGVkZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiBzb21lb25lIGNsaWNrcyBvbiBhIG5vZGUuIGVpdGhlciBzZWxlY3Qgb3IgZGVzZWxlY3QgaXQuXG4gICAgICAgKiBJZiB0aGVyZSBpcyBhbiBleGlzdGluZyBzZWxlY3Rpb24gYW5kIHdlIGRvbid0IHdhbnQgdG8gYXBwZW5kIHRvIGl0LCBjbGVhciB0aGUgZXhpc3Rpbmcgc2VsZWN0aW9uXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtOb2RlIHx8IEVkZ2V9IG9iamVjdFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnYmx1ck9iamVjdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYmx1ck9iamVjdChvYmplY3QpIHtcbiAgICAgICAgaWYgKG9iamVjdC5ob3ZlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgIG9iamVjdC5ob3ZlciA9IGZhbHNlO1xuICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBfTm9kZTIuZGVmYXVsdCkge1xuICAgICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImJsdXJOb2RlXCIsIHsgbm9kZTogb2JqZWN0LmlkIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiYmx1ckVkZ2VcIiwgeyBlZGdlOiBvYmplY3QuaWQgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiBzb21lb25lIGNsaWNrcyBvbiBhIG5vZGUuIGVpdGhlciBzZWxlY3Qgb3IgZGVzZWxlY3QgaXQuXG4gICAgICAgKiBJZiB0aGVyZSBpcyBhbiBleGlzdGluZyBzZWxlY3Rpb24gYW5kIHdlIGRvbid0IHdhbnQgdG8gYXBwZW5kIHRvIGl0LCBjbGVhciB0aGUgZXhpc3Rpbmcgc2VsZWN0aW9uXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtOb2RlIHx8IEVkZ2V9IG9iamVjdFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnaG92ZXJPYmplY3QnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhvdmVyT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2YXIgaG92ZXJDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIC8vIHJlbW92ZSBhbGwgbm9kZSBob3ZlciBoaWdobGlnaHRzXG4gICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiB0aGlzLmhvdmVyT2JqLm5vZGVzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaG92ZXJPYmoubm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCA9PT0gdW5kZWZpbmVkIHx8IG9iamVjdCBpbnN0YW5jZW9mIF9Ob2RlMi5kZWZhdWx0ICYmIG9iamVjdC5pZCAhPSBub2RlSWQgfHwgb2JqZWN0IGluc3RhbmNlb2YgX0VkZ2UyLmRlZmF1bHQpIHtcbiAgICAgICAgICAgICAgdGhpcy5ibHVyT2JqZWN0KHRoaXMuaG92ZXJPYmoubm9kZXNbbm9kZUlkXSk7XG4gICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmhvdmVyT2JqLm5vZGVzW25vZGVJZF07XG4gICAgICAgICAgICAgIGhvdmVyQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZpbmcgYWxsIGVkZ2UgaG92ZXIgaGlnaGxpZ2h0c1xuICAgICAgICBmb3IgKHZhciBlZGdlSWQgaW4gdGhpcy5ob3Zlck9iai5lZGdlcykge1xuICAgICAgICAgIGlmICh0aGlzLmhvdmVyT2JqLmVkZ2VzLmhhc093blByb3BlcnR5KGVkZ2VJZCkpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBob3ZlciBoYXMgYmVlbiBjaGFuZ2VkIGhlcmUgaXQgbWVhbnMgdGhhdCB0aGUgbm9kZSBoYXMgYmVlbiBob3ZlcmVkIG92ZXIgb3Igb2ZmXG4gICAgICAgICAgICAvLyB3ZSB0aGVuIGRvIG5vdCB1c2UgdGhlIGJsdXJPYmplY3QgbWV0aG9kIGhlcmUuXG4gICAgICAgICAgICBpZiAoaG92ZXJDaGFuZ2VkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHRoaXMuaG92ZXJPYmouZWRnZXNbZWRnZUlkXS5ob3ZlciA9IGZhbHNlO1xuICAgICAgICAgICAgICBkZWxldGUgdGhpcy5ob3Zlck9iai5lZGdlc1tlZGdlSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgdGhlIGJsdXIgcmVtYWlucyB0aGUgc2FtZSBhbmQgdGhlIG9iamVjdCBpcyB1bmRlZmluZWQgKG1vdXNlIG9mZiksIHdlIGJsdXIgdGhlIGVkZ2VcbiAgICAgICAgICAgIGVsc2UgaWYgKG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ibHVyT2JqZWN0KHRoaXMuaG92ZXJPYmouZWRnZXNbZWRnZUlkXSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuaG92ZXJPYmouZWRnZXNbZWRnZUlkXTtcbiAgICAgICAgICAgICAgICBob3ZlckNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9iamVjdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKG9iamVjdC5ob3ZlciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG9iamVjdC5ob3ZlciA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9hZGRUb0hvdmVyKG9iamVjdCk7XG4gICAgICAgICAgICBob3ZlckNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIF9Ob2RlMi5kZWZhdWx0KSB7XG4gICAgICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJob3Zlck5vZGVcIiwgeyBub2RlOiBvYmplY3QuaWQgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiaG92ZXJFZGdlXCIsIHsgZWRnZTogb2JqZWN0LmlkIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgX05vZGUyLmRlZmF1bHQgJiYgdGhpcy5vcHRpb25zLmhvdmVyQ29ubmVjdGVkRWRnZXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2hvdmVyQ29ubmVjdGVkRWRnZXMob2JqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaG92ZXJDaGFuZ2VkID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX3JlcXVlc3RSZWRyYXcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqXG4gICAgICAgKiByZXRyaWV2ZSB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG9iamVjdHNcbiAgICAgICAqIEByZXR1cm4ge3tub2RlczogQXJyYXkuPFN0cmluZz4sIGVkZ2VzOiBBcnJheS48U3RyaW5nPn19IHNlbGVjdGlvblxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXRTZWxlY3Rpb24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlbGVjdGlvbigpIHtcbiAgICAgICAgdmFyIG5vZGVJZHMgPSB0aGlzLmdldFNlbGVjdGVkTm9kZXMoKTtcbiAgICAgICAgdmFyIGVkZ2VJZHMgPSB0aGlzLmdldFNlbGVjdGVkRWRnZXMoKTtcbiAgICAgICAgcmV0dXJuIHsgbm9kZXM6IG5vZGVJZHMsIGVkZ2VzOiBlZGdlSWRzIH07XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICpcbiAgICAgICAqIHJldHJpZXZlIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgbm9kZXNcbiAgICAgICAqIEByZXR1cm4ge1N0cmluZ1tdfSBzZWxlY3Rpb24gICAgQW4gYXJyYXkgd2l0aCB0aGUgaWRzIG9mIHRoZVxuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkIG5vZGVzLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXRTZWxlY3RlZE5vZGVzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZWxlY3RlZE5vZGVzKCkge1xuICAgICAgICB2YXIgaWRBcnJheSA9IFtdO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNlbGVjdGFibGUgPT09IHRydWUpIHtcbiAgICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gdGhpcy5zZWxlY3Rpb25PYmoubm9kZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk9iai5ub2Rlcy5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgICAgIGlkQXJyYXkucHVzaCh0aGlzLnNlbGVjdGlvbk9iai5ub2Rlc1tub2RlSWRdLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkQXJyYXk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICpcbiAgICAgICAqIHJldHJpZXZlIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZWRnZXNcbiAgICAgICAqIEByZXR1cm4ge0FycmF5fSBzZWxlY3Rpb24gICAgQW4gYXJyYXkgd2l0aCB0aGUgaWRzIG9mIHRoZVxuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkIG5vZGVzLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXRTZWxlY3RlZEVkZ2VzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZWxlY3RlZEVkZ2VzKCkge1xuICAgICAgICB2YXIgaWRBcnJheSA9IFtdO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNlbGVjdGFibGUgPT09IHRydWUpIHtcbiAgICAgICAgICBmb3IgKHZhciBlZGdlSWQgaW4gdGhpcy5zZWxlY3Rpb25PYmouZWRnZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk9iai5lZGdlcy5oYXNPd25Qcm9wZXJ0eShlZGdlSWQpKSB7XG4gICAgICAgICAgICAgIGlkQXJyYXkucHVzaCh0aGlzLnNlbGVjdGlvbk9iai5lZGdlc1tlZGdlSWRdLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkQXJyYXk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVXBkYXRlcyB0aGUgY3VycmVudCBzZWxlY3Rpb25cbiAgICAgICAqIEBwYXJhbSB7e25vZGVzOiBBcnJheS48U3RyaW5nPiwgZWRnZXM6IEFycmF5LjxTdHJpbmc+fX0gU2VsZWN0aW9uXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9wdGlvbnNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc2V0U2VsZWN0aW9uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTZWxlY3Rpb24oc2VsZWN0aW9uKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgdmFyIGkgPSB2b2lkIDAsXG4gICAgICAgICAgICBpZCA9IHZvaWQgMDtcblxuICAgICAgICBpZiAoIXNlbGVjdGlvbiB8fCAhc2VsZWN0aW9uLm5vZGVzICYmICFzZWxlY3Rpb24uZWRnZXMpIHRocm93ICdTZWxlY3Rpb24gbXVzdCBiZSBhbiBvYmplY3Qgd2l0aCBub2RlcyBhbmQvb3IgZWRnZXMgcHJvcGVydGllcyc7XG4gICAgICAgIC8vIGZpcnN0IHVuc2VsZWN0IGFueSBzZWxlY3RlZCBub2RlLCBpZiBvcHRpb24gaXMgdHJ1ZSBvciB1bmRlZmluZWRcbiAgICAgICAgaWYgKG9wdGlvbnMudW5zZWxlY3RBbGwgfHwgb3B0aW9ucy51bnNlbGVjdEFsbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy51bnNlbGVjdEFsbCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxlY3Rpb24ubm9kZXMpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2VsZWN0aW9uLm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZCA9IHNlbGVjdGlvbi5ub2Rlc1tpXTtcblxuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbaWRdO1xuICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdOb2RlIHdpdGggaWQgXCInICsgaWQgKyAnXCIgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkb24ndCBzZWxlY3QgZWRnZXMgd2l0aCBpdFxuICAgICAgICAgICAgdGhpcy5zZWxlY3RPYmplY3Qobm9kZSwgb3B0aW9ucy5oaWdobGlnaHRFZGdlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbi5lZGdlcykge1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWxlY3Rpb24uZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlkID0gc2VsZWN0aW9uLmVkZ2VzW2ldO1xuXG4gICAgICAgICAgICB2YXIgZWRnZSA9IHRoaXMuYm9keS5lZGdlc1tpZF07XG4gICAgICAgICAgICBpZiAoIWVkZ2UpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0VkZ2Ugd2l0aCBpZCBcIicgKyBpZCArICdcIiBub3QgZm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2VsZWN0T2JqZWN0KGVkZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfcmVxdWVzdFJlZHJhdycpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHNlbGVjdCB6ZXJvIG9yIG1vcmUgbm9kZXMgd2l0aCB0aGUgb3B0aW9uIHRvIGhpZ2hsaWdodCBlZGdlc1xuICAgICAgICogQHBhcmFtIHtOdW1iZXJbXSB8IFN0cmluZ1tdfSBzZWxlY3Rpb24gICAgIEFuIGFycmF5IHdpdGggdGhlIGlkcyBvZiB0aGVcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZCBub2Rlcy5cbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hpZ2hsaWdodEVkZ2VzXVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzZWxlY3ROb2RlcycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0Tm9kZXMoc2VsZWN0aW9uKSB7XG4gICAgICAgIHZhciBoaWdobGlnaHRFZGdlcyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLmxlbmd0aCA9PT0gdW5kZWZpbmVkKSB0aHJvdyAnU2VsZWN0aW9uIG11c3QgYmUgYW4gYXJyYXkgd2l0aCBpZHMnO1xuXG4gICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKHsgbm9kZXM6IHNlbGVjdGlvbiB9LCB7IGhpZ2hsaWdodEVkZ2VzOiBoaWdobGlnaHRFZGdlcyB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBzZWxlY3QgemVybyBvciBtb3JlIGVkZ2VzXG4gICAgICAgKiBAcGFyYW0ge051bWJlcltdIHwgU3RyaW5nW119IHNlbGVjdGlvbiAgICAgQW4gYXJyYXkgd2l0aCB0aGUgaWRzIG9mIHRoZVxuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkIG5vZGVzLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzZWxlY3RFZGdlcycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0RWRnZXMoc2VsZWN0aW9uKSB7XG4gICAgICAgIGlmICghc2VsZWN0aW9uIHx8IHNlbGVjdGlvbi5sZW5ndGggPT09IHVuZGVmaW5lZCkgdGhyb3cgJ1NlbGVjdGlvbiBtdXN0IGJlIGFuIGFycmF5IHdpdGggaWRzJztcblxuICAgICAgICB0aGlzLnNldFNlbGVjdGlvbih7IGVkZ2VzOiBzZWxlY3Rpb24gfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVmFsaWRhdGUgdGhlIHNlbGVjdGlvbjogcmVtb3ZlIGlkcyBvZiBub2RlcyB3aGljaCBubyBsb25nZXIgZXhpc3RcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3VwZGF0ZVNlbGVjdGlvbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlU2VsZWN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gdGhpcy5zZWxlY3Rpb25PYmoubm9kZXMpIHtcbiAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25PYmoubm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmJvZHkubm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zZWxlY3Rpb25PYmoubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgZWRnZUlkIGluIHRoaXMuc2VsZWN0aW9uT2JqLmVkZ2VzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uT2JqLmVkZ2VzLmhhc093blByb3BlcnR5KGVkZ2VJZCkpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5ib2R5LmVkZ2VzLmhhc093blByb3BlcnR5KGVkZ2VJZCkpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2VsZWN0aW9uT2JqLmVkZ2VzW2VkZ2VJZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFNlbGVjdGlvbkhhbmRsZXI7XG4gIH0oKTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBTZWxlY3Rpb25IYW5kbGVyO1xuXG4vKioqLyB9LFxuLyogMTEyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG4gIHZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgdmFyIF9OZXR3b3JrVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTAzKTtcblxuICB2YXIgX05ldHdvcmtVdGlsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX05ldHdvcmtVdGlsKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgdmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4gIHZhciBMYXlvdXRFbmdpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGF5b3V0RW5naW5lKGJvZHkpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMYXlvdXRFbmdpbmUpO1xuXG4gICAgICB0aGlzLmJvZHkgPSBib2R5O1xuXG4gICAgICB0aGlzLmluaXRpYWxSYW5kb21TZWVkID0gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogMTAwMDAwMCk7XG4gICAgICB0aGlzLnJhbmRvbVNlZWQgPSB0aGlzLmluaXRpYWxSYW5kb21TZWVkO1xuICAgICAgdGhpcy5zZXRQaHlzaWNzID0gZmFsc2U7XG4gICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgIHRoaXMub3B0aW9uc0JhY2t1cCA9IHsgcGh5c2ljczoge30gfTtcblxuICAgICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgICAgcmFuZG9tU2VlZDogdW5kZWZpbmVkLFxuICAgICAgICBpbXByb3ZlZExheW91dDogdHJ1ZSxcbiAgICAgICAgaGllcmFyY2hpY2FsOiB7XG4gICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgbGV2ZWxTZXBhcmF0aW9uOiAxNTAsXG4gICAgICAgICAgbm9kZVNwYWNpbmc6IDEwMCxcbiAgICAgICAgICB0cmVlU3BhY2luZzogMjAwLFxuICAgICAgICAgIGJsb2NrU2hpZnRpbmc6IHRydWUsXG4gICAgICAgICAgZWRnZU1pbmltaXphdGlvbjogdHJ1ZSxcbiAgICAgICAgICBwYXJlbnRDZW50cmFsaXphdGlvbjogdHJ1ZSxcbiAgICAgICAgICBkaXJlY3Rpb246ICdVRCcsIC8vIFVELCBEVSwgTFIsIFJMXG4gICAgICAgICAgc29ydE1ldGhvZDogJ2h1YnNpemUnIC8vIGh1YnNpemUsIGRpcmVjdGVkXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB1dGlsLmV4dGVuZCh0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuICAgICAgdGhpcy5iaW5kRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoTGF5b3V0RW5naW5lLCBbe1xuICAgICAga2V5OiAnYmluZEV2ZW50TGlzdGVuZXJzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ19kYXRhQ2hhbmdlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy5zZXR1cEhpZXJhcmNoaWNhbExheW91dCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ19kYXRhTG9hZGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLmxheW91dE5ldHdvcmsoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdfcmVzZXRIaWVyYXJjaGljYWxMYXlvdXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMuc2V0dXBIaWVyYXJjaGljYWxMYXlvdXQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnc2V0T3B0aW9ucycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zLCBhbGxPcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgcHJldkhpZXJhcmNoaWNhbFN0YXRlID0gdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5lbmFibGVkO1xuICAgICAgICAgIHV0aWwuc2VsZWN0aXZlRGVlcEV4dGVuZChbXCJyYW5kb21TZWVkXCIsIFwiaW1wcm92ZWRMYXlvdXRcIl0sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgICAgdXRpbC5tZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBvcHRpb25zLCAnaGllcmFyY2hpY2FsJyk7XG4gICAgICAgICAgaWYgKG9wdGlvbnMucmFuZG9tU2VlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxSYW5kb21TZWVkID0gb3B0aW9ucy5yYW5kb21TZWVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmIChwcmV2SGllcmFyY2hpY2FsU3RhdGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgLy8gcmVmcmVzaCB0aGUgb3ZlcnJpZGRlbiBvcHRpb25zIGZvciBub2RlcyBhbmQgZWRnZXMuXG4gICAgICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3JlZnJlc2gnLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBsZXZlbCBzZXBhcmF0aW9uIGlzIHRoZSByaWdodCB3YXkgdXBcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmRpcmVjdGlvbiA9PT0gJ1JMJyB8fCB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmRpcmVjdGlvbiA9PT0gJ0RVJykge1xuICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5sZXZlbFNlcGFyYXRpb24gPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5sZXZlbFNlcGFyYXRpb24gKj0gLTE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmxldmVsU2VwYXJhdGlvbiA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmxldmVsU2VwYXJhdGlvbiAqPSAtMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfcmVzZXRIaWVyYXJjaGljYWxMYXlvdXQnKTtcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhlIGhpZXJhcmNoaWNhbCBzeXN0ZW0gbmVlZHMgaXQncyBvd24gcGh5c2ljcyBhbmQgc21vb3RoIGN1cnZlIHNldHRpbmdzLCB3ZSBhZGFwdCB0aGUgb3RoZXIgb3B0aW9ucyBpZiBuZWVkZWQuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGFwdEFsbE9wdGlvbnNGb3JIaWVyYXJjaGljYWxMYXlvdXQoYWxsT3B0aW9ucyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwcmV2SGllcmFyY2hpY2FsU3RhdGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgLy8gcmVmcmVzaCB0aGUgb3ZlcnJpZGRlbiBvcHRpb25zIGZvciBub2RlcyBhbmQgZWRnZXMuXG4gICAgICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3JlZnJlc2gnKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHV0aWwuZGVlcEV4dGVuZChhbGxPcHRpb25zLCB0aGlzLm9wdGlvbnNCYWNrdXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWxsT3B0aW9ucztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdhZGFwdEFsbE9wdGlvbnNGb3JIaWVyYXJjaGljYWxMYXlvdXQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkYXB0QWxsT3B0aW9uc0ZvckhpZXJhcmNoaWNhbExheW91dChhbGxPcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAvLyBzZXQgdGhlIHBoeXNpY3NcbiAgICAgICAgICBpZiAoYWxsT3B0aW9ucy5waHlzaWNzID09PSB1bmRlZmluZWQgfHwgYWxsT3B0aW9ucy5waHlzaWNzID09PSB0cnVlKSB7XG4gICAgICAgICAgICBhbGxPcHRpb25zLnBoeXNpY3MgPSB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRoaXMub3B0aW9uc0JhY2t1cC5waHlzaWNzLmVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiB0aGlzLm9wdGlvbnNCYWNrdXAucGh5c2ljcy5lbmFibGVkLFxuICAgICAgICAgICAgICBzb2x2ZXI6ICdoaWVyYXJjaGljYWxSZXB1bHNpb24nXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zQmFja3VwLnBoeXNpY3MuZW5hYmxlZCA9IHRoaXMub3B0aW9uc0JhY2t1cC5waHlzaWNzLmVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiB0aGlzLm9wdGlvbnNCYWNrdXAucGh5c2ljcy5lbmFibGVkO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zQmFja3VwLnBoeXNpY3Muc29sdmVyID0gdGhpcy5vcHRpb25zQmFja3VwLnBoeXNpY3Muc29sdmVyIHx8ICdiYXJuZXNIdXQnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihhbGxPcHRpb25zLnBoeXNpY3MpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zQmFja3VwLnBoeXNpY3MuZW5hYmxlZCA9IGFsbE9wdGlvbnMucGh5c2ljcy5lbmFibGVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogYWxsT3B0aW9ucy5waHlzaWNzLmVuYWJsZWQ7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNCYWNrdXAucGh5c2ljcy5zb2x2ZXIgPSBhbGxPcHRpb25zLnBoeXNpY3Muc29sdmVyIHx8ICdiYXJuZXNIdXQnO1xuICAgICAgICAgICAgYWxsT3B0aW9ucy5waHlzaWNzLnNvbHZlciA9ICdoaWVyYXJjaGljYWxSZXB1bHNpb24nO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYWxsT3B0aW9ucy5waHlzaWNzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zQmFja3VwLnBoeXNpY3Muc29sdmVyID0gJ2Jhcm5lc0h1dCc7XG4gICAgICAgICAgICBhbGxPcHRpb25zLnBoeXNpY3MgPSB7IHNvbHZlcjogJ2hpZXJhcmNoaWNhbFJlcHVsc2lvbicgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBnZXQgdGhlIHR5cGUgb2Ygc3RhdGljIHNtb290aCBjdXJ2ZSBpbiBjYXNlIGl0IGlzIHJlcXVpcmVkXG4gICAgICAgICAgdmFyIHR5cGUgPSAnaG9yaXpvbnRhbCc7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZGlyZWN0aW9uID09PSAnUkwnIHx8IHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZGlyZWN0aW9uID09PSAnTFInKSB7XG4gICAgICAgICAgICB0eXBlID0gJ3ZlcnRpY2FsJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBkaXNhYmxlIHNtb290aCBjdXJ2ZXMgaWYgbm90aGluZyBpcyBkZWZpbmVkLiBJZiBzbW9vdGggY3VydmVzIGhhdmUgYmVlbiB0dXJuZWQgb24sIHR1cm4gdGhlbSBpbnRvIHN0YXRpYyBzbW9vdGggY3VydmVzLlxuICAgICAgICAgIGlmIChhbGxPcHRpb25zLmVkZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc0JhY2t1cC5lZGdlcyA9IHsgc21vb3RoOiB7IGVuYWJsZWQ6IHRydWUsIHR5cGU6ICdkeW5hbWljJyB9IH07XG4gICAgICAgICAgICBhbGxPcHRpb25zLmVkZ2VzID0geyBzbW9vdGg6IGZhbHNlIH07XG4gICAgICAgICAgfSBlbHNlIGlmIChhbGxPcHRpb25zLmVkZ2VzLnNtb290aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNCYWNrdXAuZWRnZXMgPSB7IHNtb290aDogeyBlbmFibGVkOiB0cnVlLCB0eXBlOiAnZHluYW1pYycgfSB9O1xuICAgICAgICAgICAgYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGggPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhbGxPcHRpb25zLmVkZ2VzLnNtb290aCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgIHRoaXMub3B0aW9uc0JhY2t1cC5lZGdlcyA9IHsgc21vb3RoOiBhbGxPcHRpb25zLmVkZ2VzLnNtb290aCB9O1xuICAgICAgICAgICAgICBhbGxPcHRpb25zLmVkZ2VzLnNtb290aCA9IHsgZW5hYmxlZDogYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGgsIHR5cGU6IHR5cGUgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGFsbG93IGN1c3RvbSB0eXBlcyBleGNlcHQgZm9yIGR5bmFtaWNcbiAgICAgICAgICAgICAgaWYgKGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoLnR5cGUgIT09IHVuZGVmaW5lZCAmJiBhbGxPcHRpb25zLmVkZ2VzLnNtb290aC50eXBlICE9PSAnZHluYW1pYycpIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGgudHlwZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMub3B0aW9uc0JhY2t1cC5lZGdlcyA9IHtcbiAgICAgICAgICAgICAgICBzbW9vdGg6IGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoLmVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhbGxPcHRpb25zLmVkZ2VzLnNtb290aC5lbmFibGVkLFxuICAgICAgICAgICAgICAgIHR5cGU6IGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoLnR5cGUgPT09IHVuZGVmaW5lZCA/ICdkeW5hbWljJyA6IGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoLnR5cGUsXG4gICAgICAgICAgICAgICAgcm91bmRuZXNzOiBhbGxPcHRpb25zLmVkZ2VzLnNtb290aC5yb3VuZG5lc3MgPT09IHVuZGVmaW5lZCA/IDAuNSA6IGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoLnJvdW5kbmVzcyxcbiAgICAgICAgICAgICAgICBmb3JjZURpcmVjdGlvbjogYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGguZm9yY2VEaXJlY3Rpb24gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGguZm9yY2VEaXJlY3Rpb25cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGggPSB7XG4gICAgICAgICAgICAgICAgZW5hYmxlZDogYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGguZW5hYmxlZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoLmVuYWJsZWQsXG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICByb3VuZG5lc3M6IGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoLnJvdW5kbmVzcyA9PT0gdW5kZWZpbmVkID8gMC41IDogYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGgucm91bmRuZXNzLFxuICAgICAgICAgICAgICAgIGZvcmNlRGlyZWN0aW9uOiBhbGxPcHRpb25zLmVkZ2VzLnNtb290aC5mb3JjZURpcmVjdGlvbiA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBhbGxPcHRpb25zLmVkZ2VzLnNtb290aC5mb3JjZURpcmVjdGlvblxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGZvcmNlIGFsbCBlZGdlcyBpbnRvIHN0YXRpYyBzbW9vdGggY3VydmVzLiBPbmx5IGFwcGxpZXMgdG8gZWRnZXMgdGhhdCBkbyBub3QgdXNlIHRoZSBnbG9iYWwgb3B0aW9ucyBmb3Igc21vb3RoLlxuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19mb3JjZURpc2FibGVEeW5hbWljQ3VydmVzJywgdHlwZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYWxsT3B0aW9ucztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzZWVkZWRSYW5kb20nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNlZWRlZFJhbmRvbSgpIHtcbiAgICAgICAgdmFyIHggPSBNYXRoLnNpbih0aGlzLnJhbmRvbVNlZWQrKykgKiAxMDAwMDtcbiAgICAgICAgcmV0dXJuIHggLSBNYXRoLmZsb29yKHgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3Bvc2l0aW9uSW5pdGlhbGx5JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwb3NpdGlvbkluaXRpYWxseShub2Rlc0FycmF5KSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmVuYWJsZWQgIT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLnJhbmRvbVNlZWQgPSB0aGlzLmluaXRpYWxSYW5kb21TZWVkO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXNBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc0FycmF5W2ldO1xuICAgICAgICAgICAgdmFyIHJhZGl1cyA9IDEwICogMC4xICogbm9kZXNBcnJheS5sZW5ndGggKyAxMDtcbiAgICAgICAgICAgIHZhciBhbmdsZSA9IDIgKiBNYXRoLlBJICogdGhpcy5zZWVkZWRSYW5kb20oKTtcbiAgICAgICAgICAgIGlmIChub2RlLnggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBub2RlLnggPSByYWRpdXMgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS55ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgbm9kZS55ID0gcmFkaXVzICogTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZSBLYW1hZGEgS2F3YWkgdG8gcG9zaXRpb24gbm9kZXMuIFRoaXMgaXMgcXVpdGUgYSBoZWF2eSBhbGdvcml0aG0gc28gaWYgdGhlcmUgYXJlIGEgbG90IG9mIG5vZGVzIHdlXG4gICAgICAgKiBjbHVzdGVyIHRoZW0gZmlyc3QgdG8gcmVkdWNlIHRoZSBhbW91bnQuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2xheW91dE5ldHdvcmsnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxheW91dE5ldHdvcmsoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmVuYWJsZWQgIT09IHRydWUgJiYgdGhpcy5vcHRpb25zLmltcHJvdmVkTGF5b3V0ID09PSB0cnVlKSB7XG4gICAgICAgICAgLy8gZmlyc3QgY2hlY2sgaWYgd2Ugc2hvdWxkIEthbWFkYSBLYXdhaSB0byBsYXlvdXQuIFRoZSB0aHJlc2hvbGQgaXMgaWYgbGVzcyB0aGFuIGhhbGYgb2YgdGhlIHZpc2libGVcbiAgICAgICAgICAvLyBub2RlcyBoYXZlIHByZWRlZmluZWQgcG9zaXRpb25zIHdlIHVzZSB0aGlzLlxuICAgICAgICAgIHZhciBwb3NpdGlvbkRlZmluZWQgPSAwO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLmJvZHkubm9kZUluZGljZXNbaV1dO1xuICAgICAgICAgICAgaWYgKG5vZGUucHJlZGVmaW5lZFBvc2l0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHBvc2l0aW9uRGVmaW5lZCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGlmIGxlc3MgdGhhbiBoYWxmIG9mIHRoZSBub2RlcyBoYXZlIGEgcHJlZGVmaW5lZCBwb3NpdGlvbiB3ZSBjb250aW51ZVxuICAgICAgICAgIGlmIChwb3NpdGlvbkRlZmluZWQgPCAwLjUgKiB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgTUFYX0xFVkVMUyA9IDEwO1xuICAgICAgICAgICAgdmFyIGxldmVsID0gMDtcbiAgICAgICAgICAgIHZhciBjbHVzdGVyVGhyZXNob2xkID0gMTAwO1xuICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIGEgbG90IG9mIG5vZGVzLCB3ZSBjbHVzdGVyIGJlZm9yZSB3ZSBydW4gdGhlIGFsZ29yaXRobS5cbiAgICAgICAgICAgIGlmICh0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoID4gY2x1c3RlclRocmVzaG9sZCkge1xuICAgICAgICAgICAgICB2YXIgc3RhcnRMZW5ndGggPSB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoO1xuICAgICAgICAgICAgICB3aGlsZSAodGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aCA+IGNsdXN0ZXJUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUudGltZShcImNsdXN0ZXJpbmdcIilcbiAgICAgICAgICAgICAgICBsZXZlbCArPSAxO1xuICAgICAgICAgICAgICAgIHZhciBiZWZvcmUgPSB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBtYW55IG5vZGVzIHdlIGRvIGEgaHVic2l6ZSBjbHVzdGVyXG4gICAgICAgICAgICAgICAgaWYgKGxldmVsICUgMyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5ib2R5Lm1vZHVsZXMuY2x1c3RlcmluZy5jbHVzdGVyQnJpZGdlcygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmJvZHkubW9kdWxlcy5jbHVzdGVyaW5nLmNsdXN0ZXJPdXRsaWVycygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgYWZ0ZXIgPSB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChiZWZvcmUgPT0gYWZ0ZXIgJiYgbGV2ZWwgJSAzICE9PSAwIHx8IGxldmVsID4gTUFYX0xFVkVMUykge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fZGVjbHVzdGVyQWxsKCk7XG4gICAgICAgICAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2xheW91dEZhaWxlZFwiKTtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIlRoaXMgbmV0d29yayBjb3VsZCBub3QgYmUgcG9zaXRpb25lZCBieSB0aGlzIHZlcnNpb24gb2YgdGhlIGltcHJvdmVkIGxheW91dCBhbGdvcml0aG0uIFBsZWFzZSBkaXNhYmxlIGltcHJvdmVkTGF5b3V0IGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuXCIpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUudGltZUVuZChcImNsdXN0ZXJpbmdcIilcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGxldmVsLGFmdGVyKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGluY3JlYXNlIHRoZSBzaXplIG9mIHRoZSBlZGdlc1xuICAgICAgICAgICAgICB0aGlzLmJvZHkubW9kdWxlcy5rYW1hZGFLYXdhaS5zZXRPcHRpb25zKHsgc3ByaW5nTGVuZ3RoOiBNYXRoLm1heCgxNTAsIDIgKiBzdGFydExlbmd0aCkgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHBvc2l0aW9uIHRoZSBzeXN0ZW0gZm9yIHRoZXNlIG5vZGVzIGFuZCBlZGdlc1xuICAgICAgICAgICAgdGhpcy5ib2R5Lm1vZHVsZXMua2FtYWRhS2F3YWkuc29sdmUodGhpcy5ib2R5Lm5vZGVJbmRpY2VzLCB0aGlzLmJvZHkuZWRnZUluZGljZXMsIHRydWUpO1xuXG4gICAgICAgICAgICAvLyBzaGlmdCB0byBjZW50ZXIgcG9pbnRcbiAgICAgICAgICAgIHRoaXMuX3NoaWZ0VG9DZW50ZXIoKTtcblxuICAgICAgICAgICAgLy8gcGVydHVyYiB0aGUgbm9kZXMgYSBsaXR0bGUgYml0IHRvIGZvcmNlIHRoZSBwaHlzaWNzIHRvIGtpY2sgaW5cbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSA3MDtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgIHRoaXMuYm9keS5ub2Rlc1t0aGlzLmJvZHkubm9kZUluZGljZXNbX2ldXS54ICs9ICgwLjUgLSB0aGlzLnNlZWRlZFJhbmRvbSgpKSAqIG9mZnNldDtcbiAgICAgICAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW3RoaXMuYm9keS5ub2RlSW5kaWNlc1tfaV1dLnkgKz0gKDAuNSAtIHRoaXMuc2VlZGVkUmFuZG9tKCkpICogb2Zmc2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB1bmNsdXN0ZXIgYWxsIGNsdXN0ZXJzXG4gICAgICAgICAgICB0aGlzLl9kZWNsdXN0ZXJBbGwoKTtcblxuICAgICAgICAgICAgLy8gcmVwb3NpdGlvbiBhbGwgYmV6aWVyIG5vZGVzLlxuICAgICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXBvc2l0aW9uQmV6aWVyTm9kZXNcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogTW92ZSBhbGwgdGhlIG5vZGVzIHRvd2FyZHMgdG8gdGhlIGNlbnRlciBzbyBncmF2aXRhdGlvbmFsIHB1bGwgd2lsIG5vdCBtb3ZlIHRoZSBub2RlcyBhd2F5IGZyb20gdmlld1xuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3NoaWZ0VG9DZW50ZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zaGlmdFRvQ2VudGVyKCkge1xuICAgICAgICB2YXIgcmFuZ2UgPSBfTmV0d29ya1V0aWwyLmRlZmF1bHQuZ2V0UmFuZ2VDb3JlKHRoaXMuYm9keS5ub2RlcywgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzKTtcbiAgICAgICAgdmFyIGNlbnRlciA9IF9OZXR3b3JrVXRpbDIuZGVmYXVsdC5maW5kQ2VudGVyKHJhbmdlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLmJvZHkubm9kZXNbdGhpcy5ib2R5Lm5vZGVJbmRpY2VzW2ldXS54IC09IGNlbnRlci54O1xuICAgICAgICAgIHRoaXMuYm9keS5ub2Rlc1t0aGlzLmJvZHkubm9kZUluZGljZXNbaV1dLnkgLT0gY2VudGVyLnk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZGVjbHVzdGVyQWxsJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVjbHVzdGVyQWxsKCkge1xuICAgICAgICB2YXIgY2x1c3RlcnNQcmVzZW50ID0gdHJ1ZTtcbiAgICAgICAgd2hpbGUgKGNsdXN0ZXJzUHJlc2VudCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGNsdXN0ZXJzUHJlc2VudCA9IGZhbHNlO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW3RoaXMuYm9keS5ub2RlSW5kaWNlc1tpXV0uaXNDbHVzdGVyID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIGNsdXN0ZXJzUHJlc2VudCA9IHRydWU7XG4gICAgICAgICAgICAgIHRoaXMuYm9keS5tb2R1bGVzLmNsdXN0ZXJpbmcub3BlbkNsdXN0ZXIodGhpcy5ib2R5Lm5vZGVJbmRpY2VzW2ldLCB7fSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2x1c3RlcnNQcmVzZW50ID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfZGF0YUNoYW5nZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXRTZWVkJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZWVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbml0aWFsUmFuZG9tU2VlZDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIGlzIHRoZSBtYWluIGZ1bmN0aW9uIHRvIGxheW91dCB0aGUgbm9kZXMgaW4gYSBoaWVyYXJjaGljYWwgd2F5LlxuICAgICAgICogSXQgY2hlY2tzIGlmIHRoZSBub2RlIGRldGFpbHMgYXJlIHN1cHBsaWVkIGNvcnJlY3RseVxuICAgICAgICpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NldHVwSGllcmFyY2hpY2FsTGF5b3V0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXR1cEhpZXJhcmNoaWNhbExheW91dCgpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZW5hYmxlZCA9PT0gdHJ1ZSAmJiB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIGdldCB0aGUgc2l6ZSBvZiB0aGUgbGFyZ2VzdCBodWJzIGFuZCBjaGVjayBpZiB0aGUgdXNlciBoYXMgZGVmaW5lZCBhIGxldmVsIGZvciBhIG5vZGUuXG4gICAgICAgICAgdmFyIG5vZGUgPSB2b2lkIDAsXG4gICAgICAgICAgICAgIG5vZGVJZCA9IHZvaWQgMDtcbiAgICAgICAgICB2YXIgZGVmaW5lZExldmVsID0gZmFsc2U7XG4gICAgICAgICAgdmFyIGRlZmluZWRQb3NpdGlvbnMgPSB0cnVlO1xuICAgICAgICAgIHZhciB1bmRlZmluZWRMZXZlbCA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuaGllcmFyY2hpY2FsTGV2ZWxzID0ge307XG4gICAgICAgICAgdGhpcy5sYXN0Tm9kZU9uTGV2ZWwgPSB7fTtcbiAgICAgICAgICB0aGlzLmhpZXJhcmNoaWNhbENoaWxkcmVuUmVmZXJlbmNlID0ge307XG4gICAgICAgICAgdGhpcy5oaWVyYXJjaGljYWxQYXJlbnRSZWZlcmVuY2UgPSB7fTtcbiAgICAgICAgICB0aGlzLmhpZXJhcmNoaWNhbFRyZWVzID0ge307XG4gICAgICAgICAgdGhpcy50cmVlSW5kZXggPSAtMTtcblxuICAgICAgICAgIHRoaXMuZGlzdHJpYnV0aW9uT3JkZXJpbmcgPSB7fTtcbiAgICAgICAgICB0aGlzLmRpc3RyaWJ1dGlvbkluZGV4ID0ge307XG4gICAgICAgICAgdGhpcy5kaXN0cmlidXRpb25PcmRlcmluZ1ByZXNlbmNlID0ge307XG5cbiAgICAgICAgICBmb3IgKG5vZGVJZCBpbiB0aGlzLmJvZHkubm9kZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgICAgICBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICAgICAgICAgIGlmIChub2RlLm9wdGlvbnMueCA9PT0gdW5kZWZpbmVkICYmIG5vZGUub3B0aW9ucy55ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVkUG9zaXRpb25zID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG5vZGUub3B0aW9ucy5sZXZlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lZExldmVsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZXJhcmNoaWNhbExldmVsc1tub2RlSWRdID0gbm9kZS5vcHRpb25zLmxldmVsO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVuZGVmaW5lZExldmVsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGlmIHRoZSB1c2VyIGRlZmluZWQgc29tZSBsZXZlbHMgYnV0IG5vdCBhbGwsIGFsZXJ0IGFuZCBydW4gd2l0aG91dCBoaWVyYXJjaGljYWwgbGF5b3V0XG4gICAgICAgICAgaWYgKHVuZGVmaW5lZExldmVsID09PSB0cnVlICYmIGRlZmluZWRMZXZlbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUbyB1c2UgdGhlIGhpZXJhcmNoaWNhbCBsYXlvdXQsIG5vZGVzIHJlcXVpcmUgZWl0aGVyIG5vIHByZWRlZmluZWQgbGV2ZWxzIG9yIGxldmVscyBoYXZlIHRvIGJlIGRlZmluZWQgZm9yIGFsbCBub2Rlcy4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZGVmaW5lIGxldmVscyBpZiB1bmRlZmluZWQgYnkgdGhlIHVzZXJzLiBCYXNlZCBvbiBodWJzaXplLlxuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZExldmVsID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLnNvcnRNZXRob2QgPT09ICdodWJzaXplJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RldGVybWluZUxldmVsc0J5SHVic2l6ZSgpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuc29ydE1ldGhvZCA9PT0gJ2RpcmVjdGVkJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RldGVybWluZUxldmVsc0RpcmVjdGVkKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5zb3J0TWV0aG9kID09PSAnY3VzdG9tJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RldGVybWluZUxldmVsc0N1c3RvbUNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZmFsbGJhY2sgZm9yIGNhc2VzIHdoZXJlIHRoZXJlIGFyZSBub2RlcyBidXQgbm8gZWRnZXNcbiAgICAgICAgICAgIGZvciAodmFyIF9ub2RlSWQgaW4gdGhpcy5ib2R5Lm5vZGVzKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXMuaGFzT3duUHJvcGVydHkoX25vZGVJZCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oaWVyYXJjaGljYWxMZXZlbHNbX25vZGVJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5oaWVyYXJjaGljYWxMZXZlbHNbX25vZGVJZF0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2hlY2sgdGhlIGRpc3RyaWJ1dGlvbiBvZiB0aGUgbm9kZXMgcGVyIGxldmVsLlxuICAgICAgICAgICAgdmFyIGRpc3RyaWJ1dGlvbiA9IHRoaXMuX2dldERpc3RyaWJ1dGlvbigpO1xuXG4gICAgICAgICAgICAvLyBnZXQgdGhlIHBhcmVudCBjaGlsZHJlbiByZWxhdGlvbnMuXG4gICAgICAgICAgICB0aGlzLl9nZW5lcmF0ZU1hcCgpO1xuXG4gICAgICAgICAgICAvLyBwbGFjZSB0aGUgbm9kZXMgb24gdGhlIGNhbnZhcy5cbiAgICAgICAgICAgIHRoaXMuX3BsYWNlTm9kZXNCeUhpZXJhcmNoeShkaXN0cmlidXRpb24pO1xuXG4gICAgICAgICAgICAvLyBjb25kZW5zZSB0aGUgd2hpdGVzcGFjZS5cbiAgICAgICAgICAgIHRoaXMuX2NvbmRlbnNlSGllcmFyY2h5KCk7XG5cbiAgICAgICAgICAgIC8vIHNoaWZ0IHRvIGNlbnRlciBzbyBncmF2aXR5IGRvZXMgbm90IGhhdmUgdG8gZG8gbXVjaFxuICAgICAgICAgICAgdGhpcy5fc2hpZnRUb0NlbnRlcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19jb25kZW5zZUhpZXJhcmNoeScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbmRlbnNlSGllcmFyY2h5KCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAvLyBHbG9iYWwgdmFyIGluIHRoaXMgc2NvcGUgdG8gZGVmaW5lIHdoZW4gdGhlIG1vdmVtZW50IGhhcyBzdG9wcGVkLlxuICAgICAgICB2YXIgc3RpbGxTaGlmdGluZyA9IGZhbHNlO1xuICAgICAgICB2YXIgYnJhbmNoZXMgPSB7fTtcbiAgICAgICAgLy8gZmlyc3Qgd2UgaGF2ZSBzb21lIG1ldGhvZHMgdG8gaGVscCBzaGlmdGluZyB0cmVlcyBhcm91bmQuXG4gICAgICAgIC8vIHRoZSBtYWluIG1ldGhvZCB0byBzaGlmdCB0aGUgdHJlZXNcbiAgICAgICAgdmFyIHNoaWZ0VHJlZXMgPSBmdW5jdGlvbiBzaGlmdFRyZWVzKCkge1xuICAgICAgICAgIHZhciB0cmVlU2l6ZXMgPSBnZXRUcmVlU2l6ZXMoKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWVTaXplcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkaWZmID0gdHJlZVNpemVzW2ldLm1heCAtIHRyZWVTaXplc1tpICsgMV0ubWluO1xuICAgICAgICAgICAgc2hpZnRUcmVlKGkgKyAxLCBkaWZmICsgX3RoaXMyLm9wdGlvbnMuaGllcmFyY2hpY2FsLnRyZWVTcGFjaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gc2hpZnQgYSBzaW5nbGUgdHJlZSBieSBhbiBvZmZzZXRcbiAgICAgICAgdmFyIHNoaWZ0VHJlZSA9IGZ1bmN0aW9uIHNoaWZ0VHJlZShpbmRleCwgb2Zmc2V0KSB7XG4gICAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIF90aGlzMi5oaWVyYXJjaGljYWxUcmVlcykge1xuICAgICAgICAgICAgaWYgKF90aGlzMi5oaWVyYXJjaGljYWxUcmVlcy5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSB7XG4gICAgICAgICAgICAgIGlmIChfdGhpczIuaGllcmFyY2hpY2FsVHJlZXNbbm9kZUlkXSA9PT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IF90aGlzMi5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICAgICAgICAgICAgdmFyIHBvcyA9IF90aGlzMi5fZ2V0UG9zaXRpb25Gb3JIaWVyYXJjaHkobm9kZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMyLl9zZXRQb3NpdGlvbkZvckhpZXJhcmNoeShub2RlLCBwb3MgKyBvZmZzZXQsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZ2V0IHRoZSB3aWR0aCBvZiBhIHRyZWVcbiAgICAgICAgdmFyIGdldFRyZWVTaXplID0gZnVuY3Rpb24gZ2V0VHJlZVNpemUoaW5kZXgpIHtcbiAgICAgICAgICB2YXIgbWluID0gMWU5O1xuICAgICAgICAgIHZhciBtYXggPSAtMWU5O1xuICAgICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiBfdGhpczIuaGllcmFyY2hpY2FsVHJlZXMpIHtcbiAgICAgICAgICAgIGlmIChfdGhpczIuaGllcmFyY2hpY2FsVHJlZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgICAgICBpZiAoX3RoaXMyLmhpZXJhcmNoaWNhbFRyZWVzW25vZGVJZF0gPT09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvcyA9IF90aGlzMi5fZ2V0UG9zaXRpb25Gb3JIaWVyYXJjaHkoX3RoaXMyLmJvZHkubm9kZXNbbm9kZUlkXSk7XG4gICAgICAgICAgICAgICAgbWluID0gTWF0aC5taW4ocG9zLCBtaW4pO1xuICAgICAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KHBvcywgbWF4KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4geyBtaW46IG1pbiwgbWF4OiBtYXggfTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBnZXQgdGhlIHdpZHRoIG9mIGFsbCB0cmVlc1xuICAgICAgICB2YXIgZ2V0VHJlZVNpemVzID0gZnVuY3Rpb24gZ2V0VHJlZVNpemVzKCkge1xuICAgICAgICAgIHZhciB0cmVlV2lkdGhzID0gW107XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gX3RoaXMyLnRyZWVJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICB0cmVlV2lkdGhzLnB1c2goZ2V0VHJlZVNpemUoaSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJlZVdpZHRocztcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBnZXQgYSBtYXAgb2YgYWxsIG5vZGVzIGluIHRoaXMgYnJhbmNoXG4gICAgICAgIHZhciBnZXRCcmFuY2hOb2RlcyA9IGZ1bmN0aW9uIGdldEJyYW5jaE5vZGVzKHNvdXJjZSwgbWFwKSB7XG4gICAgICAgICAgbWFwW3NvdXJjZS5pZF0gPSB0cnVlO1xuICAgICAgICAgIGlmIChfdGhpczIuaGllcmFyY2hpY2FsQ2hpbGRyZW5SZWZlcmVuY2Vbc291cmNlLmlkXSkge1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gX3RoaXMyLmhpZXJhcmNoaWNhbENoaWxkcmVuUmVmZXJlbmNlW3NvdXJjZS5pZF07XG4gICAgICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZ2V0QnJhbmNoTm9kZXMoX3RoaXMyLmJvZHkubm9kZXNbY2hpbGRyZW5baV1dLCBtYXApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGdldCBhIG1pbiBtYXggd2lkdGggYXMgd2VsbCBhcyB0aGUgbWF4aW11bSBtb3ZlbWVudCBzcGFjZSBpdCBoYXMgb24gZWl0aGVyIHNpZGVzXG4gICAgICAgIC8vIHdlIHVzZSBtaW4gbWF4IHRlcm1pbm9sb2d5IGJlY2F1c2Ugd2lkdGggYW5kIGhlaWdodCBjYW4gaW50ZXJjaGFuZ2UgZGVwZW5kaW5nIG9uIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGxheW91dFxuICAgICAgICB2YXIgZ2V0QnJhbmNoQm91bmRhcnkgPSBmdW5jdGlvbiBnZXRCcmFuY2hCb3VuZGFyeShicmFuY2hNYXApIHtcbiAgICAgICAgICB2YXIgbWF4TGV2ZWwgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyAxZTkgOiBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgICB2YXIgbWluU3BhY2UgPSAxZTk7XG4gICAgICAgICAgdmFyIG1heFNwYWNlID0gMWU5O1xuICAgICAgICAgIHZhciBtaW4gPSAxZTk7XG4gICAgICAgICAgdmFyIG1heCA9IC0xZTk7XG4gICAgICAgICAgZm9yICh2YXIgYnJhbmNoTm9kZSBpbiBicmFuY2hNYXApIHtcbiAgICAgICAgICAgIGlmIChicmFuY2hNYXAuaGFzT3duUHJvcGVydHkoYnJhbmNoTm9kZSkpIHtcbiAgICAgICAgICAgICAgdmFyIG5vZGUgPSBfdGhpczIuYm9keS5ub2Rlc1ticmFuY2hOb2RlXTtcbiAgICAgICAgICAgICAgdmFyIGxldmVsID0gX3RoaXMyLmhpZXJhcmNoaWNhbExldmVsc1tub2RlLmlkXTtcbiAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gX3RoaXMyLl9nZXRQb3NpdGlvbkZvckhpZXJhcmNoeShub2RlKTtcblxuICAgICAgICAgICAgICAvLyBnZXQgdGhlIHNwYWNlIGFyb3VuZCB0aGUgbm9kZS5cblxuICAgICAgICAgICAgICB2YXIgX2dldFNwYWNlQXJvdW5kTm9kZTIgPSBfdGhpczIuX2dldFNwYWNlQXJvdW5kTm9kZShub2RlLCBicmFuY2hNYXApO1xuXG4gICAgICAgICAgICAgIHZhciBfZ2V0U3BhY2VBcm91bmROb2RlMyA9IF9zbGljZWRUb0FycmF5KF9nZXRTcGFjZUFyb3VuZE5vZGUyLCAyKTtcblxuICAgICAgICAgICAgICB2YXIgbWluU3BhY2VOb2RlID0gX2dldFNwYWNlQXJvdW5kTm9kZTNbMF07XG4gICAgICAgICAgICAgIHZhciBtYXhTcGFjZU5vZGUgPSBfZ2V0U3BhY2VBcm91bmROb2RlM1sxXTtcblxuICAgICAgICAgICAgICBtaW5TcGFjZSA9IE1hdGgubWluKG1pblNwYWNlTm9kZSwgbWluU3BhY2UpO1xuICAgICAgICAgICAgICBtYXhTcGFjZSA9IE1hdGgubWluKG1heFNwYWNlTm9kZSwgbWF4U3BhY2UpO1xuXG4gICAgICAgICAgICAgIC8vIHRoZSB3aWR0aCBpcyBvbmx5IHJlbGV2YW50IGZvciB0aGUgbGV2ZWxzIHR3byBub2RlcyBoYXZlIGluIGNvbW1vbi4gVGhpcyBpcyB3aHkgd2UgZmlsdGVyIG9uIHRoaXMuXG4gICAgICAgICAgICAgIGlmIChsZXZlbCA8PSBtYXhMZXZlbCkge1xuICAgICAgICAgICAgICAgIG1pbiA9IE1hdGgubWluKHBvc2l0aW9uLCBtaW4pO1xuICAgICAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KHBvc2l0aW9uLCBtYXgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIFttaW4sIG1heCwgbWluU3BhY2UsIG1heFNwYWNlXTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBnZXQgdGhlIG1heGltdW0gbGV2ZWwgb2YgYSBicmFuY2guXG4gICAgICAgIHZhciBnZXRNYXhMZXZlbCA9IGZ1bmN0aW9uIGdldE1heExldmVsKG5vZGVJZCkge1xuICAgICAgICAgIHZhciBsZXZlbCA9IF90aGlzMi5oaWVyYXJjaGljYWxMZXZlbHNbbm9kZUlkXTtcbiAgICAgICAgICBpZiAoX3RoaXMyLmhpZXJhcmNoaWNhbENoaWxkcmVuUmVmZXJlbmNlW25vZGVJZF0pIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IF90aGlzMi5oaWVyYXJjaGljYWxDaGlsZHJlblJlZmVyZW5jZVtub2RlSWRdO1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldmVsID0gTWF0aC5tYXgobGV2ZWwsIGdldE1heExldmVsKGNoaWxkcmVuW2ldKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGxldmVsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGNoZWNrIHdoYXQgdGhlIG1heGltdW0gbGV2ZWwgaXMgdGhlc2Ugbm9kZXMgaGF2ZSBpbiBjb21tb24uXG4gICAgICAgIHZhciBnZXRDb2xsaXNpb25MZXZlbCA9IGZ1bmN0aW9uIGdldENvbGxpc2lvbkxldmVsKG5vZGUxLCBub2RlMikge1xuICAgICAgICAgIHZhciBtYXhMZXZlbDEgPSBnZXRNYXhMZXZlbChub2RlMS5pZCk7XG4gICAgICAgICAgdmFyIG1heExldmVsMiA9IGdldE1heExldmVsKG5vZGUyLmlkKTtcbiAgICAgICAgICByZXR1cm4gTWF0aC5taW4obWF4TGV2ZWwxLCBtYXhMZXZlbDIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIHR3byBub2RlcyBoYXZlIHRoZSBzYW1lIHBhcmVudChzKVxuICAgICAgICB2YXIgaGFzU2FtZVBhcmVudCA9IGZ1bmN0aW9uIGhhc1NhbWVQYXJlbnQobm9kZTEsIG5vZGUyKSB7XG4gICAgICAgICAgdmFyIHBhcmVudHMxID0gX3RoaXMyLmhpZXJhcmNoaWNhbFBhcmVudFJlZmVyZW5jZVtub2RlMS5pZF07XG4gICAgICAgICAgdmFyIHBhcmVudHMyID0gX3RoaXMyLmhpZXJhcmNoaWNhbFBhcmVudFJlZmVyZW5jZVtub2RlMi5pZF07XG4gICAgICAgICAgaWYgKHBhcmVudHMxID09PSB1bmRlZmluZWQgfHwgcGFyZW50czIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50czEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGFyZW50czIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgaWYgKHBhcmVudHMxW2ldID09IHBhcmVudHMyW2pdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGNvbmRlbnNlIGVsZW1lbnRzLiBUaGVzZSBjYW4gYmUgbm9kZXMgb3IgYnJhbmNoZXMgZGVwZW5kaW5nIG9uIHRoZSBjYWxsYmFjay5cbiAgICAgICAgdmFyIHNoaWZ0RWxlbWVudHNDbG9zZXIgPSBmdW5jdGlvbiBzaGlmdEVsZW1lbnRzQ2xvc2VyKGNhbGxiYWNrLCBsZXZlbHMsIGNlbnRlclBhcmVudHMpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxldmVsID0gbGV2ZWxzW2ldO1xuICAgICAgICAgICAgdmFyIGxldmVsTm9kZXMgPSBfdGhpczIuZGlzdHJpYnV0aW9uT3JkZXJpbmdbbGV2ZWxdO1xuICAgICAgICAgICAgaWYgKGxldmVsTm9kZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxldmVsTm9kZXMubGVuZ3RoIC0gMTsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc1NhbWVQYXJlbnQobGV2ZWxOb2Rlc1tqXSwgbGV2ZWxOb2Rlc1tqICsgMV0pID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoX3RoaXMyLmhpZXJhcmNoaWNhbFRyZWVzW2xldmVsTm9kZXNbal0uaWRdID09PSBfdGhpczIuaGllcmFyY2hpY2FsVHJlZXNbbGV2ZWxOb2Rlc1tqICsgMV0uaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGxldmVsTm9kZXNbal0sIGxldmVsTm9kZXNbaiArIDFdLCBjZW50ZXJQYXJlbnRzKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gY2FsbGJhY2sgZm9yIHNoaWZ0aW5nIGJyYW5jaGVzXG4gICAgICAgIHZhciBicmFuY2hTaGlmdENhbGxiYWNrID0gZnVuY3Rpb24gYnJhbmNoU2hpZnRDYWxsYmFjayhub2RlMSwgbm9kZTIpIHtcbiAgICAgICAgICB2YXIgY2VudGVyUGFyZW50ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBhcmd1bWVudHNbMl07XG5cbiAgICAgICAgICAvL3dpbmRvdy5DQUxMQkFDS1MucHVzaCgoKSA9PiB7XG4gICAgICAgICAgdmFyIHBvczEgPSBfdGhpczIuX2dldFBvc2l0aW9uRm9ySGllcmFyY2h5KG5vZGUxKTtcbiAgICAgICAgICB2YXIgcG9zMiA9IF90aGlzMi5fZ2V0UG9zaXRpb25Gb3JIaWVyYXJjaHkobm9kZTIpO1xuICAgICAgICAgIHZhciBkaWZmQWJzID0gTWF0aC5hYnMocG9zMiAtIHBvczEpO1xuICAgICAgICAgIC8vY29uc29sZS5sb2coXCJOT1cgQ0hFY0tJTkc6XCIsIG5vZGUxLmlkLCBub2RlMi5pZCwgZGlmZkFicyk7XG4gICAgICAgICAgaWYgKGRpZmZBYnMgPiBfdGhpczIub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcpIHtcbiAgICAgICAgICAgIHZhciBicmFuY2hOb2RlczEgPSB7fTticmFuY2hOb2RlczFbbm9kZTEuaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBicmFuY2hOb2RlczIgPSB7fTticmFuY2hOb2RlczJbbm9kZTIuaWRdID0gdHJ1ZTtcblxuICAgICAgICAgICAgZ2V0QnJhbmNoTm9kZXMobm9kZTEsIGJyYW5jaE5vZGVzMSk7XG4gICAgICAgICAgICBnZXRCcmFuY2hOb2Rlcyhub2RlMiwgYnJhbmNoTm9kZXMyKTtcblxuICAgICAgICAgICAgLy8gY2hlY2sgdGhlIGxhcmdlc3QgZGlzdGFuY2UgYmV0d2VlbiB0aGUgYnJhbmNoZXNcbiAgICAgICAgICAgIHZhciBtYXhMZXZlbCA9IGdldENvbGxpc2lvbkxldmVsKG5vZGUxLCBub2RlMik7XG5cbiAgICAgICAgICAgIHZhciBfZ2V0QnJhbmNoQm91bmRhcnkgPSBnZXRCcmFuY2hCb3VuZGFyeShicmFuY2hOb2RlczEsIG1heExldmVsKTtcblxuICAgICAgICAgICAgdmFyIF9nZXRCcmFuY2hCb3VuZGFyeTIgPSBfc2xpY2VkVG9BcnJheShfZ2V0QnJhbmNoQm91bmRhcnksIDQpO1xuXG4gICAgICAgICAgICB2YXIgbWluMSA9IF9nZXRCcmFuY2hCb3VuZGFyeTJbMF07XG4gICAgICAgICAgICB2YXIgbWF4MSA9IF9nZXRCcmFuY2hCb3VuZGFyeTJbMV07XG4gICAgICAgICAgICB2YXIgbWluU3BhY2UxID0gX2dldEJyYW5jaEJvdW5kYXJ5MlsyXTtcbiAgICAgICAgICAgIHZhciBtYXhTcGFjZTEgPSBfZ2V0QnJhbmNoQm91bmRhcnkyWzNdO1xuXG4gICAgICAgICAgICB2YXIgX2dldEJyYW5jaEJvdW5kYXJ5MyA9IGdldEJyYW5jaEJvdW5kYXJ5KGJyYW5jaE5vZGVzMiwgbWF4TGV2ZWwpO1xuXG4gICAgICAgICAgICB2YXIgX2dldEJyYW5jaEJvdW5kYXJ5NCA9IF9zbGljZWRUb0FycmF5KF9nZXRCcmFuY2hCb3VuZGFyeTMsIDQpO1xuXG4gICAgICAgICAgICB2YXIgbWluMiA9IF9nZXRCcmFuY2hCb3VuZGFyeTRbMF07XG4gICAgICAgICAgICB2YXIgbWF4MiA9IF9nZXRCcmFuY2hCb3VuZGFyeTRbMV07XG4gICAgICAgICAgICB2YXIgbWluU3BhY2UyID0gX2dldEJyYW5jaEJvdW5kYXJ5NFsyXTtcbiAgICAgICAgICAgIHZhciBtYXhTcGFjZTIgPSBfZ2V0QnJhbmNoQm91bmRhcnk0WzNdO1xuXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKG5vZGUxLmlkLCBnZXRCcmFuY2hCb3VuZGFyeShicmFuY2hOb2RlczEsIG1heExldmVsKSwgbm9kZTIuaWQsIGdldEJyYW5jaEJvdW5kYXJ5KGJyYW5jaE5vZGVzMiwgbWF4TGV2ZWwpLCBtYXhMZXZlbCk7XG5cbiAgICAgICAgICAgIHZhciBkaWZmQnJhbmNoID0gTWF0aC5hYnMobWF4MSAtIG1pbjIpO1xuICAgICAgICAgICAgaWYgKGRpZmZCcmFuY2ggPiBfdGhpczIub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcpIHtcbiAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IG1heDEgLSBtaW4yICsgX3RoaXMyLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nO1xuICAgICAgICAgICAgICBpZiAob2Zmc2V0IDwgLW1pblNwYWNlMiArIF90aGlzMi5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZykge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IC1taW5TcGFjZTIgKyBfdGhpczIub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmc7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlJFU0VUVElORyBPRkZTRVRcIiwgbWF4MSAtIG1pbjIgKyB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nLCAtbWluU3BhY2UyLCBvZmZzZXQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlNISUZUSU5HXCIsIG5vZGUyLmlkLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIF90aGlzMi5fc2hpZnRCbG9jayhub2RlMi5pZCwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBzdGlsbFNoaWZ0aW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIGlmIChjZW50ZXJQYXJlbnQgPT09IHRydWUpIF90aGlzMi5fY2VudGVyUGFyZW50KG5vZGUyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvL3RoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVkcmF3XCIpO30pXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIG1pbmltaXplRWRnZUxlbmd0aCA9IGZ1bmN0aW9uIG1pbmltaXplRWRnZUxlbmd0aChpdGVyYXRpb25zLCBub2RlKSB7XG4gICAgICAgICAgLy93aW5kb3cuQ0FMTEJBQ0tTLnB1c2goKCkgPT4ge1xuICAgICAgICAgIC8vICBjb25zb2xlLmxvZyhcInRzXCIsbm9kZS5pZCk7XG4gICAgICAgICAgdmFyIG5vZGVJZCA9IG5vZGUuaWQ7XG4gICAgICAgICAgdmFyIGFsbEVkZ2VzID0gbm9kZS5lZGdlcztcbiAgICAgICAgICB2YXIgbm9kZUxldmVsID0gX3RoaXMyLmhpZXJhcmNoaWNhbExldmVsc1tub2RlLmlkXTtcblxuICAgICAgICAgIC8vIGdhdGhlciBjb25zdGFudHNcbiAgICAgICAgICB2YXIgQzIgPSBfdGhpczIub3B0aW9ucy5oaWVyYXJjaGljYWwubGV2ZWxTZXBhcmF0aW9uICogX3RoaXMyLm9wdGlvbnMuaGllcmFyY2hpY2FsLmxldmVsU2VwYXJhdGlvbjtcbiAgICAgICAgICB2YXIgcmVmZXJlbmNlTm9kZXMgPSB7fTtcbiAgICAgICAgICB2YXIgYWJvdmVFZGdlcyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsRWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBlZGdlID0gYWxsRWRnZXNbaV07XG4gICAgICAgICAgICBpZiAoZWRnZS50b0lkICE9IGVkZ2UuZnJvbUlkKSB7XG4gICAgICAgICAgICAgIHZhciBvdGhlck5vZGUgPSBlZGdlLnRvSWQgPT0gbm9kZUlkID8gZWRnZS5mcm9tIDogZWRnZS50bztcbiAgICAgICAgICAgICAgcmVmZXJlbmNlTm9kZXNbYWxsRWRnZXNbaV0uaWRdID0gb3RoZXJOb2RlO1xuICAgICAgICAgICAgICBpZiAoX3RoaXMyLmhpZXJhcmNoaWNhbExldmVsc1tvdGhlck5vZGUuaWRdIDwgbm9kZUxldmVsKSB7XG4gICAgICAgICAgICAgICAgYWJvdmVFZGdlcy5wdXNoKGVkZ2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZGlmZmVyZW50aWF0ZWQgc3VtIG9mIGxlbmd0aHMgYmFzZWQgb24gb25seSBtb3Zpbmcgb25lIG5vZGUgb3ZlciBvbmUgYXhpc1xuICAgICAgICAgIHZhciBnZXRGeCA9IGZ1bmN0aW9uIGdldEZ4KHBvaW50LCBlZGdlcykge1xuICAgICAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBlZGdlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgICAgIGlmIChyZWZlcmVuY2VOb2Rlc1tlZGdlc1tfaTJdLmlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSBfdGhpczIuX2dldFBvc2l0aW9uRm9ySGllcmFyY2h5KHJlZmVyZW5jZU5vZGVzW2VkZ2VzW19pMl0uaWRdKSAtIHBvaW50O1xuICAgICAgICAgICAgICAgIHN1bSArPSBhIC8gTWF0aC5zcXJ0KGEgKiBhICsgQzIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3VtO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBkb3VibHkgZGlmZmVyZW50aWF0ZWQgc3VtIG9mIGxlbmd0aHMgYmFzZWQgb24gb25seSBtb3Zpbmcgb25lIG5vZGUgb3ZlciBvbmUgYXhpc1xuICAgICAgICAgIHZhciBnZXRERnggPSBmdW5jdGlvbiBnZXRERngocG9pbnQsIGVkZ2VzKSB7XG4gICAgICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGVkZ2VzLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgICAgICAgICAgaWYgKHJlZmVyZW5jZU5vZGVzW2VkZ2VzW19pM10uaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IF90aGlzMi5fZ2V0UG9zaXRpb25Gb3JIaWVyYXJjaHkocmVmZXJlbmNlTm9kZXNbZWRnZXNbX2kzXS5pZF0pIC0gcG9pbnQ7XG4gICAgICAgICAgICAgICAgc3VtIC09IEMyICogTWF0aC5wb3coYSAqIGEgKyBDMiwgLTEuNSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdW07XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZhciBnZXRHdWVzcyA9IGZ1bmN0aW9uIGdldEd1ZXNzKGl0ZXJhdGlvbnMsIGVkZ2VzKSB7XG4gICAgICAgICAgICB2YXIgZ3Vlc3MgPSBfdGhpczIuX2dldFBvc2l0aW9uRm9ySGllcmFyY2h5KG5vZGUpO1xuICAgICAgICAgICAgLy8gTmV3dG9uJ3MgbWV0aG9kIGZvciBvcHRpbWl6YXRpb25cbiAgICAgICAgICAgIHZhciBndWVzc01hcCA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgaXRlcmF0aW9uczsgX2k0KyspIHtcbiAgICAgICAgICAgICAgdmFyIGZ4ID0gZ2V0RngoZ3Vlc3MsIGVkZ2VzKTtcbiAgICAgICAgICAgICAgdmFyIGRmeCA9IGdldERGeChndWVzcywgZWRnZXMpO1xuXG4gICAgICAgICAgICAgIC8vIHdlIGxpbWl0IHRoZSBtb3ZlbWVudCB0byBhdm9pZCBpbnN0YWJpbGl0eS5cbiAgICAgICAgICAgICAgdmFyIGxpbWl0ID0gNDA7XG4gICAgICAgICAgICAgIHZhciByYXRpbyA9IE1hdGgubWF4KC1saW1pdCwgTWF0aC5taW4obGltaXQsIE1hdGgucm91bmQoZnggLyBkZngpKSk7XG4gICAgICAgICAgICAgIGd1ZXNzID0gZ3Vlc3MgLSByYXRpbztcbiAgICAgICAgICAgICAgLy8gcmVkdWNlIGR1cGxpY2F0ZXNcbiAgICAgICAgICAgICAgaWYgKGd1ZXNzTWFwW2d1ZXNzXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZ3Vlc3NNYXBbZ3Vlc3NdID0gX2k0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGd1ZXNzO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB2YXIgbW92ZUJyYW5jaCA9IGZ1bmN0aW9uIG1vdmVCcmFuY2goZ3Vlc3MpIHtcbiAgICAgICAgICAgIC8vIHBvc2l0aW9uIG5vZGUgaWYgdGhlcmUgaXMgc3BhY2VcbiAgICAgICAgICAgIHZhciBub2RlUG9zaXRpb24gPSBfdGhpczIuX2dldFBvc2l0aW9uRm9ySGllcmFyY2h5KG5vZGUpO1xuXG4gICAgICAgICAgICAvLyBjaGVjayBtb3ZhYmxlIGFyZWEgb2YgdGhlIGJyYW5jaFxuICAgICAgICAgICAgaWYgKGJyYW5jaGVzW25vZGUuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdmFyIGJyYW5jaE5vZGVzID0ge307XG4gICAgICAgICAgICAgIGJyYW5jaE5vZGVzW25vZGUuaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgZ2V0QnJhbmNoTm9kZXMobm9kZSwgYnJhbmNoTm9kZXMpO1xuICAgICAgICAgICAgICBicmFuY2hlc1tub2RlLmlkXSA9IGJyYW5jaE5vZGVzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgX2dldEJyYW5jaEJvdW5kYXJ5NSA9IGdldEJyYW5jaEJvdW5kYXJ5KGJyYW5jaGVzW25vZGUuaWRdKTtcblxuICAgICAgICAgICAgdmFyIF9nZXRCcmFuY2hCb3VuZGFyeTYgPSBfc2xpY2VkVG9BcnJheShfZ2V0QnJhbmNoQm91bmRhcnk1LCA0KTtcblxuICAgICAgICAgICAgdmFyIG1pbkJyYW5jaCA9IF9nZXRCcmFuY2hCb3VuZGFyeTZbMF07XG4gICAgICAgICAgICB2YXIgbWF4QnJhbmNoID0gX2dldEJyYW5jaEJvdW5kYXJ5NlsxXTtcbiAgICAgICAgICAgIHZhciBtaW5TcGFjZUJyYW5jaCA9IF9nZXRCcmFuY2hCb3VuZGFyeTZbMl07XG4gICAgICAgICAgICB2YXIgbWF4U3BhY2VCcmFuY2ggPSBfZ2V0QnJhbmNoQm91bmRhcnk2WzNdO1xuXG5cbiAgICAgICAgICAgIHZhciBkaWZmID0gZ3Vlc3MgLSBub2RlUG9zaXRpb247XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIGFyZSBhbGxvd2VkIHRvIG1vdmUgdGhlIG5vZGU6XG4gICAgICAgICAgICB2YXIgYnJhbmNoT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGlmIChkaWZmID4gMCkge1xuICAgICAgICAgICAgICBicmFuY2hPZmZzZXQgPSBNYXRoLm1pbihkaWZmLCBtYXhTcGFjZUJyYW5jaCAtIF90aGlzMi5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRpZmYgPCAwKSB7XG4gICAgICAgICAgICAgIGJyYW5jaE9mZnNldCA9IC1NYXRoLm1pbigtZGlmZiwgbWluU3BhY2VCcmFuY2ggLSBfdGhpczIub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYnJhbmNoT2Zmc2V0ICE9IDApIHtcbiAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIm1vdmluZyBicmFuY2g6XCIsYnJhbmNoT2Zmc2V0LCBtYXhTcGFjZUJyYW5jaCwgbWluU3BhY2VCcmFuY2gpXG4gICAgICAgICAgICAgIF90aGlzMi5fc2hpZnRCbG9jayhub2RlLmlkLCBicmFuY2hPZmZzZXQpO1xuICAgICAgICAgICAgICAvL3RoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVkcmF3XCIpO1xuICAgICAgICAgICAgICBzdGlsbFNoaWZ0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIG1vdmVOb2RlID0gZnVuY3Rpb24gbW92ZU5vZGUoZ3Vlc3MpIHtcbiAgICAgICAgICAgIHZhciBub2RlUG9zaXRpb24gPSBfdGhpczIuX2dldFBvc2l0aW9uRm9ySGllcmFyY2h5KG5vZGUpO1xuXG4gICAgICAgICAgICAvLyBwb3NpdGlvbiBub2RlIGlmIHRoZXJlIGlzIHNwYWNlXG5cbiAgICAgICAgICAgIHZhciBfZ2V0U3BhY2VBcm91bmROb2RlNCA9IF90aGlzMi5fZ2V0U3BhY2VBcm91bmROb2RlKG5vZGUpO1xuXG4gICAgICAgICAgICB2YXIgX2dldFNwYWNlQXJvdW5kTm9kZTUgPSBfc2xpY2VkVG9BcnJheShfZ2V0U3BhY2VBcm91bmROb2RlNCwgMik7XG5cbiAgICAgICAgICAgIHZhciBtaW5TcGFjZSA9IF9nZXRTcGFjZUFyb3VuZE5vZGU1WzBdO1xuICAgICAgICAgICAgdmFyIG1heFNwYWNlID0gX2dldFNwYWNlQXJvdW5kTm9kZTVbMV07XG5cbiAgICAgICAgICAgIHZhciBkaWZmID0gZ3Vlc3MgLSBub2RlUG9zaXRpb247XG4gICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSBhcmUgYWxsb3dlZCB0byBtb3ZlIHRoZSBub2RlOlxuICAgICAgICAgICAgdmFyIG5ld1Bvc2l0aW9uID0gbm9kZVBvc2l0aW9uO1xuICAgICAgICAgICAgaWYgKGRpZmYgPiAwKSB7XG4gICAgICAgICAgICAgIG5ld1Bvc2l0aW9uID0gTWF0aC5taW4obm9kZVBvc2l0aW9uICsgKG1heFNwYWNlIC0gX3RoaXMyLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nKSwgZ3Vlc3MpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkaWZmIDwgMCkge1xuICAgICAgICAgICAgICBuZXdQb3NpdGlvbiA9IE1hdGgubWF4KG5vZGVQb3NpdGlvbiAtIChtaW5TcGFjZSAtIF90aGlzMi5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZyksIGd1ZXNzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5ld1Bvc2l0aW9uICE9PSBub2RlUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIm1vdmluZyBOb2RlOlwiLGRpZmYsIG1pblNwYWNlLCBtYXhTcGFjZSk7XG4gICAgICAgICAgICAgIF90aGlzMi5fc2V0UG9zaXRpb25Gb3JIaWVyYXJjaHkobm9kZSwgbmV3UG9zaXRpb24sIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgIC8vdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZWRyYXdcIik7XG4gICAgICAgICAgICAgIHN0aWxsU2hpZnRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICB2YXIgZ3Vlc3MgPSBnZXRHdWVzcyhpdGVyYXRpb25zLCBhYm92ZUVkZ2VzKTtcbiAgICAgICAgICBtb3ZlQnJhbmNoKGd1ZXNzKTtcbiAgICAgICAgICBndWVzcyA9IGdldEd1ZXNzKGl0ZXJhdGlvbnMsIGFsbEVkZ2VzKTtcbiAgICAgICAgICBtb3ZlTm9kZShndWVzcyk7XG4gICAgICAgICAgLy99KVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIG1ldGhvZCB0byByZW1vdmUgd2hpdGVzcGFjZSBiZXR3ZWVuIGJyYW5jaGVzLiBCZWNhdXNlIHdlIGRvIGJvdHRvbSB1cCwgd2UgY2FuIGNlbnRlciB0aGUgcGFyZW50cy5cbiAgICAgICAgdmFyIG1pbmltaXplRWRnZUxlbmd0aEJvdHRvbVVwID0gZnVuY3Rpb24gbWluaW1pemVFZGdlTGVuZ3RoQm90dG9tVXAoaXRlcmF0aW9ucykge1xuICAgICAgICAgIHZhciBsZXZlbHMgPSBPYmplY3Qua2V5cyhfdGhpczIuZGlzdHJpYnV0aW9uT3JkZXJpbmcpO1xuICAgICAgICAgIGxldmVscyA9IGxldmVscy5yZXZlcnNlKCk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVyYXRpb25zOyBpKyspIHtcbiAgICAgICAgICAgIHN0aWxsU2hpZnRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGV2ZWxzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIHZhciBsZXZlbCA9IGxldmVsc1tqXTtcbiAgICAgICAgICAgICAgdmFyIGxldmVsTm9kZXMgPSBfdGhpczIuZGlzdHJpYnV0aW9uT3JkZXJpbmdbbGV2ZWxdO1xuICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGxldmVsTm9kZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICBtaW5pbWl6ZUVkZ2VMZW5ndGgoMTAwMCwgbGV2ZWxOb2Rlc1trXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGlsbFNoaWZ0aW5nICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJGSU5JU0hFRCBtaW5pbWl6ZUVkZ2VMZW5ndGhCb3R0b21VcCBJTiBcIiArIGkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gbWV0aG9kIHRvIHJlbW92ZSB3aGl0ZXNwYWNlIGJldHdlZW4gYnJhbmNoZXMuIEJlY2F1c2Ugd2UgZG8gYm90dG9tIHVwLCB3ZSBjYW4gY2VudGVyIHRoZSBwYXJlbnRzLlxuICAgICAgICB2YXIgc2hpZnRCcmFuY2hlc0Nsb3NlckJvdHRvbVVwID0gZnVuY3Rpb24gc2hpZnRCcmFuY2hlc0Nsb3NlckJvdHRvbVVwKGl0ZXJhdGlvbnMpIHtcbiAgICAgICAgICB2YXIgbGV2ZWxzID0gT2JqZWN0LmtleXMoX3RoaXMyLmRpc3RyaWJ1dGlvbk9yZGVyaW5nKTtcbiAgICAgICAgICBsZXZlbHMgPSBsZXZlbHMucmV2ZXJzZSgpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlcmF0aW9uczsgaSsrKSB7XG4gICAgICAgICAgICBzdGlsbFNoaWZ0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBzaGlmdEVsZW1lbnRzQ2xvc2VyKGJyYW5jaFNoaWZ0Q2FsbGJhY2ssIGxldmVscywgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoc3RpbGxTaGlmdGluZyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiRklOSVNIRUQgc2hpZnRCcmFuY2hlc0Nsb3NlckJvdHRvbVVwIElOIFwiICsgKGkrMSkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gY2VudGVyIGFsbCBwYXJlbnRzXG4gICAgICAgIHZhciBjZW50ZXJBbGxQYXJlbnRzID0gZnVuY3Rpb24gY2VudGVyQWxsUGFyZW50cygpIHtcbiAgICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gX3RoaXMyLmJvZHkubm9kZXMpIHtcbiAgICAgICAgICAgIGlmIChfdGhpczIuYm9keS5ub2Rlcy5oYXNPd25Qcm9wZXJ0eShub2RlSWQpKSBfdGhpczIuX2NlbnRlclBhcmVudChfdGhpczIuYm9keS5ub2Rlc1tub2RlSWRdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gY2VudGVyIGFsbCBwYXJlbnRzXG4gICAgICAgIHZhciBjZW50ZXJBbGxQYXJlbnRzQm90dG9tVXAgPSBmdW5jdGlvbiBjZW50ZXJBbGxQYXJlbnRzQm90dG9tVXAoKSB7XG4gICAgICAgICAgdmFyIGxldmVscyA9IE9iamVjdC5rZXlzKF90aGlzMi5kaXN0cmlidXRpb25PcmRlcmluZyk7XG4gICAgICAgICAgbGV2ZWxzID0gbGV2ZWxzLnJldmVyc2UoKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxldmVsID0gbGV2ZWxzW2ldO1xuICAgICAgICAgICAgdmFyIGxldmVsTm9kZXMgPSBfdGhpczIuZGlzdHJpYnV0aW9uT3JkZXJpbmdbbGV2ZWxdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZXZlbE5vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIF90aGlzMi5fY2VudGVyUGFyZW50KGxldmVsTm9kZXNbal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyB0aGUgYWN0dWFsIHdvcmsgaXMgZG9uZSBoZXJlLlxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ibG9ja1NoaWZ0aW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgc2hpZnRCcmFuY2hlc0Nsb3NlckJvdHRvbVVwKDUpO1xuICAgICAgICAgIGNlbnRlckFsbFBhcmVudHMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1pbmltaXplIGVkZ2UgbGVuZ3RoXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmVkZ2VNaW5pbWl6YXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgICBtaW5pbWl6ZUVkZ2VMZW5ndGhCb3R0b21VcCgyMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5wYXJlbnRDZW50cmFsaXphdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGNlbnRlckFsbFBhcmVudHNCb3R0b21VcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2hpZnRUcmVlcygpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgZ2l2ZXMgdGhlIHNwYWNlIGFyb3VuZCB0aGUgbm9kZS4gSUYgYSBtYXAgaXMgc3VwcGxpZWQsIGl0IHdpbGwgb25seSBjaGVjayBhZ2FpbnN0IG5vZGVzIE5PVCBpbiB0aGUgbWFwLlxuICAgICAgICogVGhpcyBpcyB1c2VkIHRvIG9ubHkgZ2V0IHRoZSBkaXN0YW5jZXMgdG8gbm9kZXMgb3V0c2lkZSBvZiBhIGJyYW5jaC5cbiAgICAgICAqIEBwYXJhbSBub2RlXG4gICAgICAgKiBAcGFyYW0gbWFwXG4gICAgICAgKiBAcmV0dXJucyB7KltdfVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2dldFNwYWNlQXJvdW5kTm9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFNwYWNlQXJvdW5kTm9kZShub2RlLCBtYXApIHtcbiAgICAgICAgdmFyIHVzZU1hcCA9IHRydWU7XG4gICAgICAgIGlmIChtYXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHVzZU1hcCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZXZlbCA9IHRoaXMuaGllcmFyY2hpY2FsTGV2ZWxzW25vZGUuaWRdO1xuICAgICAgICBpZiAobGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuZGlzdHJpYnV0aW9uSW5kZXhbbm9kZS5pZF07XG4gICAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5fZ2V0UG9zaXRpb25Gb3JIaWVyYXJjaHkobm9kZSk7XG4gICAgICAgICAgdmFyIG1pblNwYWNlID0gMWU5O1xuICAgICAgICAgIHZhciBtYXhTcGFjZSA9IDFlOTtcbiAgICAgICAgICBpZiAoaW5kZXggIT09IDApIHtcbiAgICAgICAgICAgIHZhciBwcmV2Tm9kZSA9IHRoaXMuZGlzdHJpYnV0aW9uT3JkZXJpbmdbbGV2ZWxdW2luZGV4IC0gMV07XG4gICAgICAgICAgICBpZiAodXNlTWFwID09PSB0cnVlICYmIG1hcFtwcmV2Tm9kZS5pZF0gPT09IHVuZGVmaW5lZCB8fCB1c2VNYXAgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2UG9zID0gdGhpcy5fZ2V0UG9zaXRpb25Gb3JIaWVyYXJjaHkocHJldk5vZGUpO1xuICAgICAgICAgICAgICBtaW5TcGFjZSA9IHBvc2l0aW9uIC0gcHJldlBvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaW5kZXggIT0gdGhpcy5kaXN0cmlidXRpb25PcmRlcmluZ1tsZXZlbF0ubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgdmFyIG5leHROb2RlID0gdGhpcy5kaXN0cmlidXRpb25PcmRlcmluZ1tsZXZlbF1baW5kZXggKyAxXTtcbiAgICAgICAgICAgIGlmICh1c2VNYXAgPT09IHRydWUgJiYgbWFwW25leHROb2RlLmlkXSA9PT0gdW5kZWZpbmVkIHx8IHVzZU1hcCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgdmFyIG5leHRQb3MgPSB0aGlzLl9nZXRQb3NpdGlvbkZvckhpZXJhcmNoeShuZXh0Tm9kZSk7XG4gICAgICAgICAgICAgIG1heFNwYWNlID0gTWF0aC5taW4obWF4U3BhY2UsIG5leHRQb3MgLSBwb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIFttaW5TcGFjZSwgbWF4U3BhY2VdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbMCwgMF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBXZSB1c2UgdGhpcyBtZXRob2QgdG8gY2VudGVyIGEgcGFyZW50IG5vZGUgYW5kIGNoZWNrIGlmIGl0IGRvZXMgbm90IGNyb3NzIG90aGVyIG5vZGVzIHdoZW4gaXQgZG9lcy5cbiAgICAgICAqIEBwYXJhbSBub2RlXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY2VudGVyUGFyZW50JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY2VudGVyUGFyZW50KG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaGllcmFyY2hpY2FsUGFyZW50UmVmZXJlbmNlW25vZGUuaWRdKSB7XG4gICAgICAgICAgdmFyIHBhcmVudHMgPSB0aGlzLmhpZXJhcmNoaWNhbFBhcmVudFJlZmVyZW5jZVtub2RlLmlkXTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRJZCA9IHBhcmVudHNbaV07XG4gICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IHRoaXMuYm9keS5ub2Rlc1twYXJlbnRJZF07XG4gICAgICAgICAgICBpZiAodGhpcy5oaWVyYXJjaGljYWxDaGlsZHJlblJlZmVyZW5jZVtwYXJlbnRJZF0pIHtcbiAgICAgICAgICAgICAgLy8gZ2V0IHRoZSByYW5nZSBvZiB0aGUgY2hpbGRyZW5cbiAgICAgICAgICAgICAgdmFyIG1pblBvcyA9IDFlOTtcbiAgICAgICAgICAgICAgdmFyIG1heFBvcyA9IC0xZTk7XG4gICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuaGllcmFyY2hpY2FsQ2hpbGRyZW5SZWZlcmVuY2VbcGFyZW50SWRdO1xuICAgICAgICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IGNoaWxkcmVuLmxlbmd0aDsgX2k1KyspIHtcbiAgICAgICAgICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSB0aGlzLmJvZHkubm9kZXNbY2hpbGRyZW5bX2k1XV07XG4gICAgICAgICAgICAgICAgICBtaW5Qb3MgPSBNYXRoLm1pbihtaW5Qb3MsIHRoaXMuX2dldFBvc2l0aW9uRm9ySGllcmFyY2h5KGNoaWxkTm9kZSkpO1xuICAgICAgICAgICAgICAgICAgbWF4UG9zID0gTWF0aC5tYXgobWF4UG9zLCB0aGlzLl9nZXRQb3NpdGlvbkZvckhpZXJhcmNoeShjaGlsZE5vZGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLl9nZXRQb3NpdGlvbkZvckhpZXJhcmNoeShwYXJlbnROb2RlKTtcblxuICAgICAgICAgICAgICB2YXIgX2dldFNwYWNlQXJvdW5kTm9kZTYgPSB0aGlzLl9nZXRTcGFjZUFyb3VuZE5vZGUocGFyZW50Tm9kZSk7XG5cbiAgICAgICAgICAgICAgdmFyIF9nZXRTcGFjZUFyb3VuZE5vZGU3ID0gX3NsaWNlZFRvQXJyYXkoX2dldFNwYWNlQXJvdW5kTm9kZTYsIDIpO1xuXG4gICAgICAgICAgICAgIHZhciBtaW5TcGFjZSA9IF9nZXRTcGFjZUFyb3VuZE5vZGU3WzBdO1xuICAgICAgICAgICAgICB2YXIgbWF4U3BhY2UgPSBfZ2V0U3BhY2VBcm91bmROb2RlN1sxXTtcblxuICAgICAgICAgICAgICB2YXIgbmV3UG9zaXRpb24gPSAwLjUgKiAobWluUG9zICsgbWF4UG9zKTtcbiAgICAgICAgICAgICAgdmFyIGRpZmYgPSBwb3NpdGlvbiAtIG5ld1Bvc2l0aW9uO1xuICAgICAgICAgICAgICBpZiAoZGlmZiA8IDAgJiYgTWF0aC5hYnMoZGlmZikgPCBtYXhTcGFjZSAtIHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcgfHwgZGlmZiA+IDAgJiYgTWF0aC5hYnMoZGlmZikgPCBtaW5TcGFjZSAtIHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRQb3NpdGlvbkZvckhpZXJhcmNoeShwYXJlbnROb2RlLCBuZXdQb3NpdGlvbiwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgZnVuY3Rpb24gcGxhY2VzIHRoZSBub2RlcyBvbiB0aGUgY2FudmFzIGJhc2VkIG9uIHRoZSBoaWVyYXJjaGlhbCBkaXN0cmlidXRpb24uXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGRpc3RyaWJ1dGlvbiB8IG9idGFpbmVkIGJ5IHRoZSBmdW5jdGlvbiB0aGlzLl9nZXREaXN0cmlidXRpb24oKVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3BsYWNlTm9kZXNCeUhpZXJhcmNoeScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3BsYWNlTm9kZXNCeUhpZXJhcmNoeShkaXN0cmlidXRpb24pIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbmVkTm9kZXMgPSB7fTtcbiAgICAgICAgLy8gc3RhcnQgcGxhY2luZyBhbGwgdGhlIGxldmVsIDAgbm9kZXMgZmlyc3QuIFRoZW4gcmVjdXJzaXZlbHkgcG9zaXRpb24gdGhlaXIgYnJhbmNoZXMuXG4gICAgICAgIGZvciAodmFyIGxldmVsIGluIGRpc3RyaWJ1dGlvbikge1xuICAgICAgICAgIGlmIChkaXN0cmlidXRpb24uaGFzT3duUHJvcGVydHkobGV2ZWwpKSB7XG4gICAgICAgICAgICAvLyBzb3J0IG5vZGVzIGluIGxldmVsIGJ5IHBvc2l0aW9uOlxuICAgICAgICAgICAgdmFyIG5vZGVBcnJheSA9IE9iamVjdC5rZXlzKGRpc3RyaWJ1dGlvbltsZXZlbF0pO1xuICAgICAgICAgICAgbm9kZUFycmF5ID0gdGhpcy5faW5kZXhBcnJheVRvTm9kZXMobm9kZUFycmF5KTtcbiAgICAgICAgICAgIHRoaXMuX3NvcnROb2RlQXJyYXkobm9kZUFycmF5KTtcbiAgICAgICAgICAgIHZhciBoYW5kbGVkTm9kZUNvdW50ID0gMDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIG5vZGUgPSBub2RlQXJyYXlbaV07XG4gICAgICAgICAgICAgIGlmICh0aGlzLnBvc2l0aW9uZWROb2Rlc1tub2RlLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvcyA9IHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcgKiBoYW5kbGVkTm9kZUNvdW50O1xuICAgICAgICAgICAgICAgIC8vIHdlIGdldCB0aGUgWCBvciBZIHZhbHVlcyB3ZSBuZWVkIGFuZCBzdG9yZSB0aGVtIGluIHBvcyBhbmQgcHJldmlvdXNQb3MuIFRoZSBnZXQgYW5kIHNldCBtYWtlIHN1cmUgd2UgZ2V0IFggb3IgWVxuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVkTm9kZUNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgICAgcG9zID0gdGhpcy5fZ2V0UG9zaXRpb25Gb3JIaWVyYXJjaHkobm9kZUFycmF5W2kgLSAxXSkgKyB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRQb3NpdGlvbkZvckhpZXJhcmNoeShub2RlLCBwb3MsIGxldmVsKTtcbiAgICAgICAgICAgICAgICB0aGlzLl92YWxpZGF0YVBvc2l0aW9uQW5kQ29udGludWUobm9kZSwgbGV2ZWwsIHBvcyk7XG5cbiAgICAgICAgICAgICAgICBoYW5kbGVkTm9kZUNvdW50Kys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIGlzIGEgcmVjdXJzaXZlbHkgY2FsbGVkIGZ1bmN0aW9uIHRvIGVudW1lcmF0ZSB0aGUgYnJhbmNoZXMgZnJvbSB0aGUgbGFyZ2VzdCBodWJzIGFuZCBwbGFjZSB0aGUgbm9kZXNcbiAgICAgICAqIG9uIGEgWCBwb3NpdGlvbiB0aGF0IGVuc3VyZXMgdGhlcmUgd2lsbCBiZSBubyBvdmVybGFwLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSBwYXJlbnRJZFxuICAgICAgICogQHBhcmFtIHBhcmVudExldmVsXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfcGxhY2VCcmFuY2hOb2RlcycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3BsYWNlQnJhbmNoTm9kZXMocGFyZW50SWQsIHBhcmVudExldmVsKSB7XG4gICAgICAgIC8vIGlmIHRoaXMgaXMgbm90IGEgcGFyZW50LCBjYW5jZWwgdGhlIHBsYWNpbmcuIFRoaXMgY2FuIGhhcHBlbiB3aXRoIG11bHRpcGxlIHBhcmVudHMgdG8gb25lIGNoaWxkLlxuICAgICAgICBpZiAodGhpcy5oaWVyYXJjaGljYWxDaGlsZHJlblJlZmVyZW5jZVtwYXJlbnRJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCBhIGxpc3Qgb2YgY2hpbGROb2Rlc1xuICAgICAgICB2YXIgY2hpbGROb2RlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaGllcmFyY2hpY2FsQ2hpbGRyZW5SZWZlcmVuY2VbcGFyZW50SWRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY2hpbGROb2Rlcy5wdXNoKHRoaXMuYm9keS5ub2Rlc1t0aGlzLmhpZXJhcmNoaWNhbENoaWxkcmVuUmVmZXJlbmNlW3BhcmVudElkXVtpXV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXNlIHRoZSBwb3NpdGlvbnMgdG8gb3JkZXIgdGhlIG5vZGVzLlxuICAgICAgICB0aGlzLl9zb3J0Tm9kZUFycmF5KGNoaWxkTm9kZXMpO1xuXG4gICAgICAgIC8vIHBvc2l0aW9uIHRoZSBjaGlsZE5vZGVzXG4gICAgICAgIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IGNoaWxkTm9kZXMubGVuZ3RoOyBfaTYrKykge1xuICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzW19pNl07XG4gICAgICAgICAgdmFyIGNoaWxkTm9kZUxldmVsID0gdGhpcy5oaWVyYXJjaGljYWxMZXZlbHNbY2hpbGROb2RlLmlkXTtcbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgY2hpbGQgbm9kZSBpcyBiZWxvdyB0aGUgcGFyZW50IG5vZGUgYW5kIGlmIGl0IGhhcyBhbHJlYWR5IGJlZW4gcG9zaXRpb25lZC5cbiAgICAgICAgICBpZiAoY2hpbGROb2RlTGV2ZWwgPiBwYXJlbnRMZXZlbCAmJiB0aGlzLnBvc2l0aW9uZWROb2Rlc1tjaGlsZE5vZGUuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGdldCB0aGUgYW1vdW50IG9mIHNwYWNlIHJlcXVpcmVkIGZvciB0aGlzIG5vZGUuIElmIHBhcmVudCB0aGUgd2lkdGggaXMgYmFzZWQgb24gdGhlIGFtb3VudCBvZiBjaGlsZHJlbi5cbiAgICAgICAgICAgIHZhciBwb3MgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIC8vIHdlIGdldCB0aGUgWCBvciBZIHZhbHVlcyB3ZSBuZWVkIGFuZCBzdG9yZSB0aGVtIGluIHBvcyBhbmQgcHJldmlvdXNQb3MuIFRoZSBnZXQgYW5kIHNldCBtYWtlIHN1cmUgd2UgZ2V0IFggb3IgWVxuICAgICAgICAgICAgaWYgKF9pNiA9PT0gMCkge1xuICAgICAgICAgICAgICBwb3MgPSB0aGlzLl9nZXRQb3NpdGlvbkZvckhpZXJhcmNoeSh0aGlzLmJvZHkubm9kZXNbcGFyZW50SWRdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBvcyA9IHRoaXMuX2dldFBvc2l0aW9uRm9ySGllcmFyY2h5KGNoaWxkTm9kZXNbX2k2IC0gMV0pICsgdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NldFBvc2l0aW9uRm9ySGllcmFyY2h5KGNoaWxkTm9kZSwgcG9zLCBjaGlsZE5vZGVMZXZlbCk7XG4gICAgICAgICAgICB0aGlzLl92YWxpZGF0YVBvc2l0aW9uQW5kQ29udGludWUoY2hpbGROb2RlLCBjaGlsZE5vZGVMZXZlbCwgcG9zKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNlbnRlciB0aGUgcGFyZW50IG5vZGVzLlxuICAgICAgICB2YXIgbWluUG9zID0gMWU5O1xuICAgICAgICB2YXIgbWF4UG9zID0gLTFlOTtcbiAgICAgICAgZm9yICh2YXIgX2k3ID0gMDsgX2k3IDwgY2hpbGROb2Rlcy5sZW5ndGg7IF9pNysrKSB7XG4gICAgICAgICAgdmFyIGNoaWxkTm9kZUlkID0gY2hpbGROb2Rlc1tfaTddLmlkO1xuICAgICAgICAgIG1pblBvcyA9IE1hdGgubWluKG1pblBvcywgdGhpcy5fZ2V0UG9zaXRpb25Gb3JIaWVyYXJjaHkodGhpcy5ib2R5Lm5vZGVzW2NoaWxkTm9kZUlkXSkpO1xuICAgICAgICAgIG1heFBvcyA9IE1hdGgubWF4KG1heFBvcywgdGhpcy5fZ2V0UG9zaXRpb25Gb3JIaWVyYXJjaHkodGhpcy5ib2R5Lm5vZGVzW2NoaWxkTm9kZUlkXSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldFBvc2l0aW9uRm9ySGllcmFyY2h5KHRoaXMuYm9keS5ub2Rlc1twYXJlbnRJZF0sIDAuNSAqIChtaW5Qb3MgKyBtYXhQb3MpLCBwYXJlbnRMZXZlbCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBtZXRob2QgY2hlY2tzIGZvciBvdmVybGFwIGFuZCBpZiByZXF1aXJlZCBzaGlmdHMgdGhlIGJyYW5jaC4gSXQgYWxzbyBrZWVwcyByZWNvcmRzIG9mIHBvc2l0aW9uZWQgbm9kZXMuXG4gICAgICAgKiBGaW5hbGx5IGl0IHdpbGwgY2FsbCBfcGxhY2VCcmFuY2hOb2RlcyB0byBwbGFjZSB0aGUgYnJhbmNoIG5vZGVzLlxuICAgICAgICogQHBhcmFtIG5vZGVcbiAgICAgICAqIEBwYXJhbSBsZXZlbFxuICAgICAgICogQHBhcmFtIHBvc1xuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3ZhbGlkYXRhUG9zaXRpb25BbmRDb250aW51ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3ZhbGlkYXRhUG9zaXRpb25BbmRDb250aW51ZShub2RlLCBsZXZlbCwgcG9zKSB7XG4gICAgICAgIC8vIGlmIG92ZXJsYXAgaGFzIGJlZW4gZGV0ZWN0ZWQsIHdlIHNoaWZ0IHRoZSBicmFuY2hcbiAgICAgICAgaWYgKHRoaXMubGFzdE5vZGVPbkxldmVsW2xldmVsXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIHByZXZpb3VzUG9zID0gdGhpcy5fZ2V0UG9zaXRpb25Gb3JIaWVyYXJjaHkodGhpcy5ib2R5Lm5vZGVzW3RoaXMubGFzdE5vZGVPbkxldmVsW2xldmVsXV0pO1xuICAgICAgICAgIGlmIChwb3MgLSBwcmV2aW91c1BvcyA8IHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcpIHtcbiAgICAgICAgICAgIHZhciBkaWZmID0gcHJldmlvdXNQb3MgKyB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nIC0gcG9zO1xuICAgICAgICAgICAgdmFyIHNoYXJlZFBhcmVudCA9IHRoaXMuX2ZpbmRDb21tb25QYXJlbnQodGhpcy5sYXN0Tm9kZU9uTGV2ZWxbbGV2ZWxdLCBub2RlLmlkKTtcbiAgICAgICAgICAgIHRoaXMuX3NoaWZ0QmxvY2soc2hhcmVkUGFyZW50LndpdGhDaGlsZCwgZGlmZik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3RvcmUgY2hhbmdlIGluIHBvc2l0aW9uLlxuICAgICAgICB0aGlzLmxhc3ROb2RlT25MZXZlbFtsZXZlbF0gPSBub2RlLmlkO1xuXG4gICAgICAgIHRoaXMucG9zaXRpb25lZE5vZGVzW25vZGUuaWRdID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLl9wbGFjZUJyYW5jaE5vZGVzKG5vZGUuaWQsIGxldmVsKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZWNlaXZlcyBhbiBhcnJheSB3aXRoIG5vZGUgaW5kaWNlcyBhbmQgcmV0dXJucyBhbiBhcnJheSB3aXRoIHRoZSBhY3R1YWwgbm9kZSByZWZlcmVuY2VzLiBVc2VkIGZvciBzb3J0aW5nIGJhc2VkIG9uXG4gICAgICAgKiBub2RlIHByb3BlcnRpZXMuXG4gICAgICAgKiBAcGFyYW0gaWRBcnJheVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfaW5kZXhBcnJheVRvTm9kZXMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pbmRleEFycmF5VG9Ob2RlcyhpZEFycmF5KSB7XG4gICAgICAgIHZhciBhcnJheSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcnJheS5wdXNoKHRoaXMuYm9keS5ub2Rlc1tpZEFycmF5W2ldXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgZnVuY3Rpb24gZ2V0IHRoZSBkaXN0cmlidXRpb24gb2YgbGV2ZWxzIGJhc2VkIG9uIGh1YnNpemVcbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2dldERpc3RyaWJ1dGlvbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERpc3RyaWJ1dGlvbigpIHtcbiAgICAgICAgdmFyIGRpc3RyaWJ1dGlvbiA9IHt9O1xuICAgICAgICB2YXIgbm9kZUlkID0gdm9pZCAwLFxuICAgICAgICAgICAgbm9kZSA9IHZvaWQgMDtcblxuICAgICAgICAvLyB3ZSBmaXggWSBiZWNhdXNlIHRoZSBoaWVyYXJjaHkgaXMgdmVydGljYWwsIHdlIGZpeCBYIHNvIHdlIGRvIG5vdCBnaXZlIGEgbm9kZSBhbiB4IHBvc2l0aW9uIGZvciBhIHNlY29uZCB0aW1lLlxuICAgICAgICAvLyB0aGUgZml4IG9mIFggaXMgcmVtb3ZlZCBhZnRlciB0aGUgeCB2YWx1ZSBoYXMgYmVlbiBzZXQuXG4gICAgICAgIGZvciAobm9kZUlkIGluIHRoaXMuYm9keS5ub2Rlcykge1xuICAgICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgICAgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgICAgICAgdmFyIGxldmVsID0gdGhpcy5oaWVyYXJjaGljYWxMZXZlbHNbbm9kZUlkXSA9PT0gdW5kZWZpbmVkID8gMCA6IHRoaXMuaGllcmFyY2hpY2FsTGV2ZWxzW25vZGVJZF07XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5kaXJlY3Rpb24gPT09ICdVRCcgfHwgdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5kaXJlY3Rpb24gPT09ICdEVScpIHtcbiAgICAgICAgICAgICAgbm9kZS55ID0gdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5sZXZlbFNlcGFyYXRpb24gKiBsZXZlbDtcbiAgICAgICAgICAgICAgbm9kZS5vcHRpb25zLmZpeGVkLnkgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbm9kZS54ID0gdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5sZXZlbFNlcGFyYXRpb24gKiBsZXZlbDtcbiAgICAgICAgICAgICAgbm9kZS5vcHRpb25zLmZpeGVkLnggPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpc3RyaWJ1dGlvbltsZXZlbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBkaXN0cmlidXRpb25bbGV2ZWxdID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXN0cmlidXRpb25bbGV2ZWxdW25vZGVJZF0gPSBub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlzdHJpYnV0aW9uO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEdldCB0aGUgaHVic2l6ZSBmcm9tIGFsbCByZW1haW5pbmcgdW5sZXZlbGxlZCBub2Rlcy5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2dldEh1YlNpemUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRIdWJTaXplKCkge1xuICAgICAgICB2YXIgaHViU2l6ZSA9IDA7XG4gICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiB0aGlzLmJvZHkubm9kZXMpIHtcbiAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzLmhhc093blByb3BlcnR5KG5vZGVJZCkpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICAgICAgICBpZiAodGhpcy5oaWVyYXJjaGljYWxMZXZlbHNbbm9kZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGh1YlNpemUgPSBub2RlLmVkZ2VzLmxlbmd0aCA8IGh1YlNpemUgPyBodWJTaXplIDogbm9kZS5lZGdlcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBodWJTaXplO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHRoaXMgZnVuY3Rpb24gYWxsb2NhdGVzIG5vZGVzIGluIGxldmVscyBiYXNlZCBvbiB0aGUgcmVjdXJzaXZlIGJyYW5jaGluZyBmcm9tIHRoZSBsYXJnZXN0IGh1YnMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIGh1YnNpemVcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19kZXRlcm1pbmVMZXZlbHNCeUh1YnNpemUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXRlcm1pbmVMZXZlbHNCeUh1YnNpemUoKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBodWJTaXplID0gMTtcblxuICAgICAgICB2YXIgbGV2ZWxEb3duc3RyZWFtID0gZnVuY3Rpb24gbGV2ZWxEb3duc3RyZWFtKG5vZGVBLCBub2RlQikge1xuICAgICAgICAgIGlmIChfdGhpczMuaGllcmFyY2hpY2FsTGV2ZWxzW25vZGVCLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBzZXQgaW5pdGlhbCBsZXZlbFxuICAgICAgICAgICAgaWYgKF90aGlzMy5oaWVyYXJjaGljYWxMZXZlbHNbbm9kZUEuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgX3RoaXMzLmhpZXJhcmNoaWNhbExldmVsc1tub2RlQS5pZF0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2V0IGxldmVsXG4gICAgICAgICAgICBfdGhpczMuaGllcmFyY2hpY2FsTGV2ZWxzW25vZGVCLmlkXSA9IF90aGlzMy5oaWVyYXJjaGljYWxMZXZlbHNbbm9kZUEuaWRdICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgd2hpbGUgKGh1YlNpemUgPiAwKSB7XG4gICAgICAgICAgLy8gZGV0ZXJtaW5lIGh1YnNcbiAgICAgICAgICBodWJTaXplID0gdGhpcy5fZ2V0SHViU2l6ZSgpO1xuICAgICAgICAgIGlmIChodWJTaXplID09PSAwKSBicmVhaztcblxuICAgICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiB0aGlzLmJvZHkubm9kZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgICAgICAgICBpZiAobm9kZS5lZGdlcy5sZW5ndGggPT09IGh1YlNpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jcmF3bE5ldHdvcmsobGV2ZWxEb3duc3RyZWFtLCBub2RlSWQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVE9ETzogcmVsZWFzZSBmZWF0dXJlXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZGV0ZXJtaW5lTGV2ZWxzQ3VzdG9tQ2FsbGJhY2snLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXRlcm1pbmVMZXZlbHNDdXN0b21DYWxsYmFjaygpIHtcbiAgICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgICAgdmFyIG1pbkxldmVsID0gMTAwMDAwO1xuXG4gICAgICAgIC8vIFRPRE86IHRoaXMgc2hvdWxkIGNvbWUgZnJvbSBvcHRpb25zLlxuICAgICAgICB2YXIgY3VzdG9tQ2FsbGJhY2sgPSBmdW5jdGlvbiBjdXN0b21DYWxsYmFjayhub2RlQSwgbm9kZUIsIGVkZ2UpIHt9O1xuXG4gICAgICAgIHZhciBsZXZlbEJ5RGlyZWN0aW9uID0gZnVuY3Rpb24gbGV2ZWxCeURpcmVjdGlvbihub2RlQSwgbm9kZUIsIGVkZ2UpIHtcbiAgICAgICAgICB2YXIgbGV2ZWxBID0gX3RoaXM0LmhpZXJhcmNoaWNhbExldmVsc1tub2RlQS5pZF07XG4gICAgICAgICAgLy8gc2V0IGluaXRpYWwgbGV2ZWxcbiAgICAgICAgICBpZiAobGV2ZWxBID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIF90aGlzNC5oaWVyYXJjaGljYWxMZXZlbHNbbm9kZUEuaWRdID0gbWluTGV2ZWw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGRpZmYgPSBjdXN0b21DYWxsYmFjayhfTmV0d29ya1V0aWwyLmRlZmF1bHQuY2xvbmVPcHRpb25zKG5vZGVBLCAnbm9kZScpLCBfTmV0d29ya1V0aWwyLmRlZmF1bHQuY2xvbmVPcHRpb25zKG5vZGVCLCAnbm9kZScpLCBfTmV0d29ya1V0aWwyLmRlZmF1bHQuY2xvbmVPcHRpb25zKGVkZ2UsICdlZGdlJykpO1xuXG4gICAgICAgICAgX3RoaXM0LmhpZXJhcmNoaWNhbExldmVsc1tub2RlQi5pZF0gPSBfdGhpczQuaGllcmFyY2hpY2FsTGV2ZWxzW25vZGVBLmlkXSArIGRpZmY7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fY3Jhd2xOZXR3b3JrKGxldmVsQnlEaXJlY3Rpb24pO1xuICAgICAgICB0aGlzLl9zZXRNaW5MZXZlbFRvWmVybygpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHRoaXMgZnVuY3Rpb24gYWxsb2NhdGVzIG5vZGVzIGluIGxldmVscyBiYXNlZCBvbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBlZGdlc1xuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSBodWJzaXplXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZGV0ZXJtaW5lTGV2ZWxzRGlyZWN0ZWQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXRlcm1pbmVMZXZlbHNEaXJlY3RlZCgpIHtcbiAgICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgICAgdmFyIG1pbkxldmVsID0gMTAwMDA7XG4gICAgICAgIHZhciBsZXZlbEJ5RGlyZWN0aW9uID0gZnVuY3Rpb24gbGV2ZWxCeURpcmVjdGlvbihub2RlQSwgbm9kZUIsIGVkZ2UpIHtcbiAgICAgICAgICB2YXIgbGV2ZWxBID0gX3RoaXM1LmhpZXJhcmNoaWNhbExldmVsc1tub2RlQS5pZF07XG4gICAgICAgICAgLy8gc2V0IGluaXRpYWwgbGV2ZWxcbiAgICAgICAgICBpZiAobGV2ZWxBID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIF90aGlzNS5oaWVyYXJjaGljYWxMZXZlbHNbbm9kZUEuaWRdID0gbWluTGV2ZWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlZGdlLnRvSWQgPT0gbm9kZUIuaWQpIHtcbiAgICAgICAgICAgIF90aGlzNS5oaWVyYXJjaGljYWxMZXZlbHNbbm9kZUIuaWRdID0gX3RoaXM1LmhpZXJhcmNoaWNhbExldmVsc1tub2RlQS5pZF0gKyAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfdGhpczUuaGllcmFyY2hpY2FsTGV2ZWxzW25vZGVCLmlkXSA9IF90aGlzNS5oaWVyYXJjaGljYWxMZXZlbHNbbm9kZUEuaWRdIC0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2NyYXdsTmV0d29yayhsZXZlbEJ5RGlyZWN0aW9uKTtcbiAgICAgICAgdGhpcy5fc2V0TWluTGV2ZWxUb1plcm8oKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTbWFsbCB1dGlsIG1ldGhvZCB0byBzZXQgdGhlIG1pbmltdW0gbGV2ZWxzIG9mIHRoZSBub2RlcyB0byB6ZXJvLlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3NldE1pbkxldmVsVG9aZXJvJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0TWluTGV2ZWxUb1plcm8oKSB7XG4gICAgICAgIHZhciBtaW5MZXZlbCA9IDFlOTtcbiAgICAgICAgLy8gZ2V0IHRoZSBtaW5pbXVtIGxldmVsXG4gICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiB0aGlzLmJvZHkubm9kZXMpIHtcbiAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzLmhhc093blByb3BlcnR5KG5vZGVJZCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhpZXJhcmNoaWNhbExldmVsc1tub2RlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgbWluTGV2ZWwgPSBNYXRoLm1pbih0aGlzLmhpZXJhcmNoaWNhbExldmVsc1tub2RlSWRdLCBtaW5MZXZlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3VidHJhY3QgdGhlIG1pbmltdW0gZnJvbSB0aGUgc2V0IHNvIHdlIGhhdmUgYSByYW5nZSBzdGFydGluZyBmcm9tIDBcbiAgICAgICAgZm9yICh2YXIgX25vZGVJZDIgaW4gdGhpcy5ib2R5Lm5vZGVzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlcy5oYXNPd25Qcm9wZXJ0eShfbm9kZUlkMikpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhpZXJhcmNoaWNhbExldmVsc1tfbm9kZUlkMl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0aGlzLmhpZXJhcmNoaWNhbExldmVsc1tfbm9kZUlkMl0gLT0gbWluTGV2ZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVXBkYXRlIHRoZSBib29ra2VlcGluZyBvZiBwYXJlbnQgYW5kIGNoaWxkLlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2dlbmVyYXRlTWFwJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2VuZXJhdGVNYXAoKSB7XG4gICAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICAgIHZhciBmaWxsSW5SZWxhdGlvbnMgPSBmdW5jdGlvbiBmaWxsSW5SZWxhdGlvbnMocGFyZW50Tm9kZSwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgaWYgKF90aGlzNi5oaWVyYXJjaGljYWxMZXZlbHNbY2hpbGROb2RlLmlkXSA+IF90aGlzNi5oaWVyYXJjaGljYWxMZXZlbHNbcGFyZW50Tm9kZS5pZF0pIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnROb2RlSWQgPSBwYXJlbnROb2RlLmlkO1xuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZUlkID0gY2hpbGROb2RlLmlkO1xuICAgICAgICAgICAgaWYgKF90aGlzNi5oaWVyYXJjaGljYWxDaGlsZHJlblJlZmVyZW5jZVtwYXJlbnROb2RlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgX3RoaXM2LmhpZXJhcmNoaWNhbENoaWxkcmVuUmVmZXJlbmNlW3BhcmVudE5vZGVJZF0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzNi5oaWVyYXJjaGljYWxDaGlsZHJlblJlZmVyZW5jZVtwYXJlbnROb2RlSWRdLnB1c2goY2hpbGROb2RlSWQpO1xuICAgICAgICAgICAgaWYgKF90aGlzNi5oaWVyYXJjaGljYWxQYXJlbnRSZWZlcmVuY2VbY2hpbGROb2RlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgX3RoaXM2LmhpZXJhcmNoaWNhbFBhcmVudFJlZmVyZW5jZVtjaGlsZE5vZGVJZF0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzNi5oaWVyYXJjaGljYWxQYXJlbnRSZWZlcmVuY2VbY2hpbGROb2RlSWRdLnB1c2gocGFyZW50Tm9kZUlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fY3Jhd2xOZXR3b3JrKGZpbGxJblJlbGF0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3Jhd2wgb3ZlciB0aGUgZW50aXJlIG5ldHdvcmsgYW5kIHVzZSBhIGNhbGxiYWNrIG9uIGVhY2ggbm9kZSBjb3VwbGUgdGhhdCBpcyBjb25uZWN0ZWQgdG8gZWFjaCBvdGhlci5cbiAgICAgICAqIEBwYXJhbSBjYWxsYmFjayAgICAgICAgICB8IHdpbGwgcmVjZWl2ZSBub2RlQSBub2RlQiBhbmQgdGhlIGNvbm5lY3RpbmcgZWRnZS4gQSBhbmQgQiBhcmUgdW5pcXVlLlxuICAgICAgICogQHBhcmFtIHN0YXJ0aW5nTm9kZUlkXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY3Jhd2xOZXR3b3JrJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY3Jhd2xOZXR3b3JrKCkge1xuICAgICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoKSB7fSA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgdmFyIHN0YXJ0aW5nTm9kZUlkID0gYXJndW1lbnRzWzFdO1xuXG4gICAgICAgIHZhciBwcm9ncmVzcyA9IHt9O1xuICAgICAgICB2YXIgdHJlZUluZGV4ID0gMDtcblxuICAgICAgICB2YXIgY3Jhd2xlciA9IGZ1bmN0aW9uIGNyYXdsZXIobm9kZSwgdHJlZSkge1xuICAgICAgICAgIGlmIChwcm9ncmVzc1tub2RlLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgIGlmIChfdGhpczcuaGllcmFyY2hpY2FsVHJlZXNbbm9kZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBfdGhpczcuaGllcmFyY2hpY2FsVHJlZXNbbm9kZS5pZF0gPSB0cmVlO1xuICAgICAgICAgICAgICBfdGhpczcudHJlZUluZGV4ID0gTWF0aC5tYXgodHJlZSwgX3RoaXM3LnRyZWVJbmRleCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByb2dyZXNzW25vZGUuaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSB2b2lkIDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKG5vZGUuZWRnZXNbaV0uY29ubmVjdGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuZWRnZXNbaV0udG9JZCA9PT0gbm9kZS5pZCkge1xuICAgICAgICAgICAgICAgICAgY2hpbGROb2RlID0gbm9kZS5lZGdlc1tpXS5mcm9tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjaGlsZE5vZGUgPSBub2RlLmVkZ2VzW2ldLnRvO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChub2RlLmlkICE9PSBjaGlsZE5vZGUuaWQpIHtcbiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5vZGUsIGNoaWxkTm9kZSwgbm9kZS5lZGdlc1tpXSk7XG4gICAgICAgICAgICAgICAgICBjcmF3bGVyKGNoaWxkTm9kZSwgdHJlZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHdlIGNhbiBjcmF3bCBmcm9tIGEgc3BlY2lmaWMgbm9kZSBvciBvdmVyIGFsbCBub2Rlcy5cbiAgICAgICAgaWYgKHN0YXJ0aW5nTm9kZUlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbdGhpcy5ib2R5Lm5vZGVJbmRpY2VzW2ldXTtcbiAgICAgICAgICAgIGlmIChwcm9ncmVzc1tub2RlLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGNyYXdsZXIobm9kZSwgdHJlZUluZGV4KTtcbiAgICAgICAgICAgICAgdHJlZUluZGV4ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tzdGFydGluZ05vZGVJZF07XG4gICAgICAgICAgaWYgKF9ub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJOb2RlIG5vdCBmb3VuZDpcIiwgc3RhcnRpbmdOb2RlSWQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjcmF3bGVyKF9ub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNoaWZ0IGEgYnJhbmNoIGEgY2VydGFpbiBkaXN0YW5jZVxuICAgICAgICogQHBhcmFtIHBhcmVudElkXG4gICAgICAgKiBAcGFyYW0gZGlmZlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3NoaWZ0QmxvY2snLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zaGlmdEJsb2NrKHBhcmVudElkLCBkaWZmKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmRpcmVjdGlvbiA9PT0gJ1VEJyB8fCB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmRpcmVjdGlvbiA9PT0gJ0RVJykge1xuICAgICAgICAgIHRoaXMuYm9keS5ub2Rlc1twYXJlbnRJZF0ueCArPSBkaWZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYm9keS5ub2Rlc1twYXJlbnRJZF0ueSArPSBkaWZmO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhpZXJhcmNoaWNhbENoaWxkcmVuUmVmZXJlbmNlW3BhcmVudElkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmhpZXJhcmNoaWNhbENoaWxkcmVuUmVmZXJlbmNlW3BhcmVudElkXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fc2hpZnRCbG9jayh0aGlzLmhpZXJhcmNoaWNhbENoaWxkcmVuUmVmZXJlbmNlW3BhcmVudElkXVtpXSwgZGlmZik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRmluZCBhIGNvbW1vbiBwYXJlbnQgYmV0d2VlbiBicmFuY2hlcy5cbiAgICAgICAqIEBwYXJhbSBjaGlsZEFcbiAgICAgICAqIEBwYXJhbSBjaGlsZEJcbiAgICAgICAqIEByZXR1cm5zIHt7Zm91bmRQYXJlbnQsIHdpdGhDaGlsZH19XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZmluZENvbW1vblBhcmVudCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRDb21tb25QYXJlbnQoY2hpbGRBLCBjaGlsZEIpIHtcbiAgICAgICAgdmFyIF90aGlzOCA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHBhcmVudHMgPSB7fTtcbiAgICAgICAgdmFyIGl0ZXJhdGVQYXJlbnRzID0gZnVuY3Rpb24gaXRlcmF0ZVBhcmVudHMocGFyZW50cywgY2hpbGQpIHtcbiAgICAgICAgICBpZiAoX3RoaXM4LmhpZXJhcmNoaWNhbFBhcmVudFJlZmVyZW5jZVtjaGlsZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpczguaGllcmFyY2hpY2FsUGFyZW50UmVmZXJlbmNlW2NoaWxkXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gX3RoaXM4LmhpZXJhcmNoaWNhbFBhcmVudFJlZmVyZW5jZVtjaGlsZF1baV07XG4gICAgICAgICAgICAgIHBhcmVudHNbcGFyZW50XSA9IHRydWU7XG4gICAgICAgICAgICAgIGl0ZXJhdGVQYXJlbnRzKHBhcmVudHMsIHBhcmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgZmluZFBhcmVudCA9IGZ1bmN0aW9uIGZpbmRQYXJlbnQocGFyZW50cywgY2hpbGQpIHtcbiAgICAgICAgICBpZiAoX3RoaXM4LmhpZXJhcmNoaWNhbFBhcmVudFJlZmVyZW5jZVtjaGlsZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpczguaGllcmFyY2hpY2FsUGFyZW50UmVmZXJlbmNlW2NoaWxkXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gX3RoaXM4LmhpZXJhcmNoaWNhbFBhcmVudFJlZmVyZW5jZVtjaGlsZF1baV07XG4gICAgICAgICAgICAgIGlmIChwYXJlbnRzW3BhcmVudF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGZvdW5kUGFyZW50OiBwYXJlbnQsIHdpdGhDaGlsZDogY2hpbGQgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgYnJhbmNoID0gZmluZFBhcmVudChwYXJlbnRzLCBwYXJlbnQpO1xuICAgICAgICAgICAgICBpZiAoYnJhbmNoLmZvdW5kUGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJyYW5jaDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4geyBmb3VuZFBhcmVudDogbnVsbCwgd2l0aENoaWxkOiBjaGlsZCB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIGl0ZXJhdGVQYXJlbnRzKHBhcmVudHMsIGNoaWxkQSk7XG4gICAgICAgIHJldHVybiBmaW5kUGFyZW50KHBhcmVudHMsIGNoaWxkQik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQWJzdHJhY3QgdGhlIGdldHRpbmcgb2YgdGhlIHBvc2l0aW9uIHNvIHdlIHdvbid0IGhhdmUgdG8gcmVwZWF0IHRoZSBjaGVjayBmb3IgZGlyZWN0aW9uIGFsbCB0aGUgdGltZVxuICAgICAgICogQHBhcmFtIG5vZGVcbiAgICAgICAqIEBwYXJhbSBwb3NpdGlvblxuICAgICAgICogQHBhcmFtIGxldmVsXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc2V0UG9zaXRpb25Gb3JIaWVyYXJjaHknLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRQb3NpdGlvbkZvckhpZXJhcmNoeShub2RlLCBwb3NpdGlvbiwgbGV2ZWwpIHtcbiAgICAgICAgdmFyIGRvTm90VXBkYXRlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAzIHx8IGFyZ3VtZW50c1szXSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBhcmd1bWVudHNbM107XG5cbiAgICAgICAgLy9jb25zb2xlLmxvZygnX3NldFBvc2l0aW9uRm9ySGllcmFyY2h5Jyxub2RlLmlkLCBwb3NpdGlvbilcbiAgICAgICAgaWYgKGRvTm90VXBkYXRlICE9PSB0cnVlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZGlzdHJpYnV0aW9uT3JkZXJpbmdbbGV2ZWxdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzdHJpYnV0aW9uT3JkZXJpbmdbbGV2ZWxdID0gW107XG4gICAgICAgICAgICB0aGlzLmRpc3RyaWJ1dGlvbk9yZGVyaW5nUHJlc2VuY2VbbGV2ZWxdID0ge307XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMuZGlzdHJpYnV0aW9uT3JkZXJpbmdQcmVzZW5jZVtsZXZlbF1bbm9kZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5kaXN0cmlidXRpb25PcmRlcmluZ1tsZXZlbF0ucHVzaChub2RlKTtcbiAgICAgICAgICAgIHRoaXMuZGlzdHJpYnV0aW9uSW5kZXhbbm9kZS5pZF0gPSB0aGlzLmRpc3RyaWJ1dGlvbk9yZGVyaW5nW2xldmVsXS5sZW5ndGggLSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmRpc3RyaWJ1dGlvbk9yZGVyaW5nUHJlc2VuY2VbbGV2ZWxdW25vZGUuaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmRpcmVjdGlvbiA9PT0gJ1VEJyB8fCB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmRpcmVjdGlvbiA9PT0gJ0RVJykge1xuICAgICAgICAgIG5vZGUueCA9IHBvc2l0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUueSA9IHBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQWJzdHJhY3QgdGhlIGdldHRpbmcgb2YgdGhlIHBvc2l0aW9uIG9mIGEgbm9kZSBzbyB3ZSBkbyBub3QgaGF2ZSB0byByZXBlYXQgdGhlIGRpcmVjdGlvbiBjaGVjayBhbGwgdGhlIHRpbWUuXG4gICAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAgICogQHJldHVybnMge251bWJlcnwqfVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2dldFBvc2l0aW9uRm9ySGllcmFyY2h5JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0UG9zaXRpb25Gb3JIaWVyYXJjaHkobm9kZSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5kaXJlY3Rpb24gPT09ICdVRCcgfHwgdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5kaXJlY3Rpb24gPT09ICdEVScpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZS54O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBub2RlLnk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBVc2UgdGhlIHggb3IgeSB2YWx1ZSB0byBzb3J0IHRoZSBhcnJheSwgYWxsb3dpbmcgdXNlcnMgdG8gc3BlY2lmeSBvcmRlci5cbiAgICAgICAqIEBwYXJhbSBub2RlQXJyYXlcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19zb3J0Tm9kZUFycmF5JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc29ydE5vZGVBcnJheShub2RlQXJyYXkpIHtcbiAgICAgICAgaWYgKG5vZGVBcnJheS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZGlyZWN0aW9uID09PSAnVUQnIHx8IHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZGlyZWN0aW9uID09PSAnRFUnKSB7XG4gICAgICAgICAgICBub2RlQXJyYXkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICByZXR1cm4gYS54IC0gYi54O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGVBcnJheS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhLnkgLSBiLnk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gTGF5b3V0RW5naW5lO1xuICB9KCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gTGF5b3V0RW5naW5lO1xuXG4vKioqLyB9LFxuLyogMTEzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbiAgdmFyIEhhbW1lciA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuICB2YXIgaGFtbWVyVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xuXG4gIC8qKlxuICAgKiBjbGVhcnMgdGhlIHRvb2xiYXIgZGl2IGVsZW1lbnQgb2YgY2hpbGRyZW5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdmFyIE1hbmlwdWxhdGlvblN5c3RlbSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYW5pcHVsYXRpb25TeXN0ZW0oYm9keSwgY2FudmFzLCBzZWxlY3Rpb25IYW5kbGVyKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWFuaXB1bGF0aW9uU3lzdGVtKTtcblxuICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyID0gc2VsZWN0aW9uSGFuZGxlcjtcblxuICAgICAgdGhpcy5lZGl0TW9kZSA9IGZhbHNlO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmVkaXRNb2RlRGl2ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5jbG9zZURpdiA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy5tYW5pcHVsYXRpb25IYW1tZXJzID0gW107XG4gICAgICB0aGlzLnRlbXBvcmFyeVVJRnVuY3Rpb25zID0ge307XG4gICAgICB0aGlzLnRlbXBvcmFyeUV2ZW50RnVuY3Rpb25zID0gW107XG5cbiAgICAgIHRoaXMudG91Y2hUaW1lID0gMDtcbiAgICAgIHRoaXMudGVtcG9yYXJ5SWRzID0geyBub2RlczogW10sIGVkZ2VzOiBbXSB9O1xuICAgICAgdGhpcy5ndWlFbmFibGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmluTW9kZSA9IGZhbHNlO1xuICAgICAgdGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBpbml0aWFsbHlBY3RpdmU6IGZhbHNlLFxuICAgICAgICBhZGROb2RlOiB0cnVlLFxuICAgICAgICBhZGRFZGdlOiB0cnVlLFxuICAgICAgICBlZGl0Tm9kZTogdW5kZWZpbmVkLFxuICAgICAgICBlZGl0RWRnZTogdHJ1ZSxcbiAgICAgICAgZGVsZXRlTm9kZTogdHJ1ZSxcbiAgICAgICAgZGVsZXRlRWRnZTogdHJ1ZSxcbiAgICAgICAgY29udHJvbE5vZGVTdHlsZToge1xuICAgICAgICAgIHNoYXBlOiAnZG90JyxcbiAgICAgICAgICBzaXplOiA2LFxuICAgICAgICAgIGNvbG9yOiB7IGJhY2tncm91bmQ6ICcjZmYwMDAwJywgYm9yZGVyOiAnIzNjM2MzYycsIGhpZ2hsaWdodDogeyBiYWNrZ3JvdW5kOiAnIzA3Zjk2OCcsIGJvcmRlcjogJyMzYzNjM2MnIH0gfSxcbiAgICAgICAgICBib3JkZXJXaWR0aDogMixcbiAgICAgICAgICBib3JkZXJXaWR0aFNlbGVjdGVkOiAyXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB1dGlsLmV4dGVuZCh0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbignZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuX2NsZWFuKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdfZGF0YUNoYW5nZWQnLCB0aGlzLl9yZXN0b3JlLmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ19yZXNldERhdGEnLCB0aGlzLl9yZXN0b3JlLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHNvbWV0aGluZyBjaGFuZ2VzIGluIHRoZSBkYXRhIGR1cmluZyBlZGl0aW5nLCBzd2l0Y2ggYmFjayB0byB0aGUgaW5pdGlhbCBkYXRhbWFuaXB1bGF0aW9uIHN0YXRlIGFuZCBjbG9zZSBhbGwgZWRpdCBtb2Rlcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoTWFuaXB1bGF0aW9uU3lzdGVtLCBbe1xuICAgICAga2V5OiAnX3Jlc3RvcmUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXN0b3JlKCkge1xuICAgICAgICBpZiAodGhpcy5pbk1vZGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbml0aWFsbHlBY3RpdmUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kaXNhYmxlRWRpdE1vZGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXQgdGhlIE9wdGlvbnNcbiAgICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NldE9wdGlvbnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucywgYWxsT3B0aW9ucywgZ2xvYmFsT3B0aW9ucykge1xuICAgICAgICBpZiAoYWxsT3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKGFsbE9wdGlvbnMubG9jYWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5sb2NhbGUgPSBhbGxPcHRpb25zLmxvY2FsZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmxvY2FsZSA9IGdsb2JhbE9wdGlvbnMubG9jYWxlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYWxsT3B0aW9ucy5sb2NhbGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5sb2NhbGVzID0gYWxsT3B0aW9ucy5sb2NhbGVzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMubG9jYWxlcyA9IGdsb2JhbE9wdGlvbnMubG9jYWxlcztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lbmFibGVkID0gb3B0aW9ucztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgdXRpbC5kZWVwRXh0ZW5kKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW5pdGlhbGx5QWN0aXZlID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLmVkaXRNb2RlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fc2V0dXAoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIGVkaXQtbW9kZS4gRHJhd3MgdGhlIERPTSByZXF1aXJlZCBhbmQgY2xlYW5zIHVwIGFmdGVyIGl0c2VsZi5cbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd0b2dnbGVFZGl0TW9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlRWRpdE1vZGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmVkaXRNb2RlID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5kaXNhYmxlRWRpdE1vZGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdlbmFibGVFZGl0TW9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlRWRpdE1vZGUoKSB7XG4gICAgICAgIHRoaXMuZWRpdE1vZGUgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuX2NsZWFuKCk7XG4gICAgICAgIGlmICh0aGlzLmd1aUVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICB0aGlzLmNsb3NlRGl2LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgIHRoaXMuZWRpdE1vZGVEaXYuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Rpc2FibGVFZGl0TW9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzYWJsZUVkaXRNb2RlKCkge1xuICAgICAgICB0aGlzLmVkaXRNb2RlID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fY2xlYW4oKTtcbiAgICAgICAgaWYgKHRoaXMuZ3VpRW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgdGhpcy5jbG9zZURpdi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgIHRoaXMuZWRpdE1vZGVEaXYuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgdGhpcy5fY3JlYXRlRWRpdEJ1dHRvbigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyB0aGUgbWFpbiB0b29sYmFyLiBSZW1vdmVzIGZ1bmN0aW9ucyBib3VuZCB0byB0aGUgc2VsZWN0IGV2ZW50LiBCaW5kcyBhbGwgdGhlIGJ1dHRvbnMgb2YgdGhlIHRvb2xiYXIuXG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc2hvd01hbmlwdWxhdG9yVG9vbGJhcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpIHtcbiAgICAgICAgLy8gcmVzdG9yZSB0aGUgc3RhdGUgb2YgYW55IGJvdW5kIGZ1bmN0aW9ucyBvciBldmVudHMsIHJlbW92ZSBjb250cm9sIG5vZGVzLCByZXN0b3JlIHBoeXNpY3NcbiAgICAgICAgdGhpcy5fY2xlYW4oKTtcblxuICAgICAgICAvLyByZXNldCBnbG9iYWwgdmFyaWFibGVzXG4gICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NID0ge307XG5cbiAgICAgICAgLy8gaWYgdGhlIGd1aSBpcyBlbmFibGVkLCBkcmF3IGFsbCBlbGVtZW50cy5cbiAgICAgICAgaWYgKHRoaXMuZ3VpRW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIC8vIGEgX3Jlc3RvcmUgd2lsbCBoaWRlIHRoZXNlIG1lbnVzXG4gICAgICAgICAgdGhpcy5lZGl0TW9kZSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgdGhpcy5jbG9zZURpdi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblxuICAgICAgICAgIHZhciBzZWxlY3RlZE5vZGVDb3VudCA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2V0U2VsZWN0ZWROb2RlQ291bnQoKTtcbiAgICAgICAgICB2YXIgc2VsZWN0ZWRFZGdlQ291bnQgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dldFNlbGVjdGVkRWRnZUNvdW50KCk7XG4gICAgICAgICAgdmFyIHNlbGVjdGVkVG90YWxDb3VudCA9IHNlbGVjdGVkTm9kZUNvdW50ICsgc2VsZWN0ZWRFZGdlQ291bnQ7XG4gICAgICAgICAgdmFyIGxvY2FsZSA9IHRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdO1xuICAgICAgICAgIHZhciBuZWVkU2VwZXJhdG9yID0gZmFsc2U7XG5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFkZE5vZGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVBZGROb2RlQnV0dG9uKGxvY2FsZSk7XG4gICAgICAgICAgICBuZWVkU2VwZXJhdG9yID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hZGRFZGdlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKG5lZWRTZXBlcmF0b3IgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlU2VwZXJhdG9yKDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmVlZFNlcGVyYXRvciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVBZGRFZGdlQnV0dG9uKGxvY2FsZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlbGVjdGVkTm9kZUNvdW50ID09PSAxICYmIHR5cGVvZiB0aGlzLm9wdGlvbnMuZWRpdE5vZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmIChuZWVkU2VwZXJhdG9yID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVNlcGVyYXRvcigyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5lZWRTZXBlcmF0b3IgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY3JlYXRlRWRpdE5vZGVCdXR0b24obG9jYWxlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNlbGVjdGVkRWRnZUNvdW50ID09PSAxICYmIHNlbGVjdGVkTm9kZUNvdW50ID09PSAwICYmIHRoaXMub3B0aW9ucy5lZGl0RWRnZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmIChuZWVkU2VwZXJhdG9yID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVNlcGVyYXRvcigzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5lZWRTZXBlcmF0b3IgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY3JlYXRlRWRpdEVkZ2VCdXR0b24obG9jYWxlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyByZW1vdmUgYnV0dG9uc1xuICAgICAgICAgIGlmIChzZWxlY3RlZFRvdGFsQ291bnQgIT09IDApIHtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZE5vZGVDb3VudCA+IDAgJiYgdGhpcy5vcHRpb25zLmRlbGV0ZU5vZGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIGlmIChuZWVkU2VwZXJhdG9yID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlU2VwZXJhdG9yKDQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZURlbGV0ZUJ1dHRvbihsb2NhbGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxlY3RlZE5vZGVDb3VudCA9PT0gMCAmJiB0aGlzLm9wdGlvbnMuZGVsZXRlRWRnZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgaWYgKG5lZWRTZXBlcmF0b3IgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVTZXBlcmF0b3IoNCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlRGVsZXRlQnV0dG9uKGxvY2FsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gYmluZCB0aGUgY2xvc2UgYnV0dG9uXG4gICAgICAgICAgdGhpcy5fYmluZEhhbW1lclRvRGl2KHRoaXMuY2xvc2VEaXYsIHRoaXMudG9nZ2xlRWRpdE1vZGUuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAvLyByZWZyZXNoIHRoaXMgYmFyIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gc2VsZWN0ZWRcbiAgICAgICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kRXZlbnQoJ3NlbGVjdCcsIHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhci5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlZHJhdyB0byBzaG93IGFueSBwb3NzaWJsZSBjaGFuZ2VzXG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19yZWRyYXcnKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGUgdGhlIHRvb2xiYXIgZm9yIGFkZGluZyBOb2Rlc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdhZGROb2RlTW9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkTm9kZU1vZGUoKSB7XG4gICAgICAgIC8vIHdoZW4gdXNpbmcgdGhlIGd1aSwgZW5hYmxlIGVkaXQgbW9kZSBpZiBpdCB3YXNudCBhbHJlYWR5LlxuICAgICAgICBpZiAodGhpcy5lZGl0TW9kZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlc3RvcmUgdGhlIHN0YXRlIG9mIGFueSBib3VuZCBmdW5jdGlvbnMgb3IgZXZlbnRzLCByZW1vdmUgY29udHJvbCBub2RlcywgcmVzdG9yZSBwaHlzaWNzXG4gICAgICAgIHRoaXMuX2NsZWFuKCk7XG5cbiAgICAgICAgdGhpcy5pbk1vZGUgPSAnYWRkTm9kZSc7XG4gICAgICAgIGlmICh0aGlzLmd1aUVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICB2YXIgbG9jYWxlID0gdGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV07XG4gICAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET00gPSB7fTtcbiAgICAgICAgICB0aGlzLl9jcmVhdGVCYWNrQnV0dG9uKGxvY2FsZSk7XG4gICAgICAgICAgdGhpcy5fY3JlYXRlU2VwZXJhdG9yKCk7XG4gICAgICAgICAgdGhpcy5fY3JlYXRlRGVzY3JpcHRpb24obG9jYWxlWydhZGREZXNjcmlwdGlvbiddIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzWydlbiddWydhZGREZXNjcmlwdGlvbiddKTtcblxuICAgICAgICAgIC8vIGJpbmQgdGhlIGNsb3NlIGJ1dHRvblxuICAgICAgICAgIHRoaXMuX2JpbmRIYW1tZXJUb0Rpdih0aGlzLmNsb3NlRGl2LCB0aGlzLnRvZ2dsZUVkaXRNb2RlLmJpbmQodGhpcykpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZEV2ZW50KCdjbGljaycsIHRoaXMuX3BlcmZvcm1BZGROb2RlLmJpbmQodGhpcykpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGNhbGwgdGhlIGJvdW5kIGZ1bmN0aW9uIHRvIGhhbmRsZSB0aGUgZWRpdGluZyBvZiB0aGUgbm9kZS4gVGhlIG5vZGUgaGFzIHRvIGJlIHNlbGVjdGVkLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdlZGl0Tm9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZWRpdE5vZGUoKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIC8vIHdoZW4gdXNpbmcgdGhlIGd1aSwgZW5hYmxlIGVkaXQgbW9kZSBpZiBpdCB3YXNudCBhbHJlYWR5LlxuICAgICAgICBpZiAodGhpcy5lZGl0TW9kZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlc3RvcmUgdGhlIHN0YXRlIG9mIGFueSBib3VuZCBmdW5jdGlvbnMgb3IgZXZlbnRzLCByZW1vdmUgY29udHJvbCBub2RlcywgcmVzdG9yZSBwaHlzaWNzXG4gICAgICAgIHRoaXMuX2NsZWFuKCk7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZXRTZWxlY3RlZE5vZGUoKTtcbiAgICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuaW5Nb2RlID0gJ2VkaXROb2RlJztcbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5lZGl0Tm9kZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaWYgKG5vZGUuaXNDbHVzdGVyICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHZhciBkYXRhID0gdXRpbC5kZWVwRXh0ZW5kKHt9LCBub2RlLm9wdGlvbnMsIGZhbHNlKTtcbiAgICAgICAgICAgICAgZGF0YS54ID0gbm9kZS54O1xuICAgICAgICAgICAgICBkYXRhLnkgPSBub2RlLnk7XG5cbiAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lZGl0Tm9kZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZWRpdE5vZGUoZGF0YSwgZnVuY3Rpb24gKGZpbmFsaXplZERhdGEpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmaW5hbGl6ZWREYXRhICE9PSBudWxsICYmIGZpbmFsaXplZERhdGEgIT09IHVuZGVmaW5lZCAmJiBfdGhpczIuaW5Nb2RlID09PSAnZWRpdE5vZGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGZvciB3aGF0ZXZlciByZWFzb24gdGhlIG1vZGUgaGFzIGNoYW5nZXMgKGR1ZSB0byBkYXRhc2V0IGNoYW5nZSkgZGlzcmVnYXJkIHRoZSBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpczIuYm9keS5kYXRhLm5vZGVzLmdldERhdGFTZXQoKS51cGRhdGUoZmluYWxpemVkRGF0YSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBfdGhpczIuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGZ1bmN0aW9uIGZvciBlZGl0IGRvZXMgbm90IHN1cHBvcnQgdHdvIGFyZ3VtZW50cyAoZGF0YSwgY2FsbGJhY2spJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFsZXJ0KHRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdWydlZGl0Q2x1c3RlckVycm9yJ10gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbJ2VuJ11bJ2VkaXRDbHVzdGVyRXJyb3InXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZnVuY3Rpb24gaGFzIGJlZW4gY29uZmlndXJlZCB0byBoYW5kbGUgdGhlIGVkaXRpbmcgb2Ygbm9kZXMuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogY3JlYXRlIHRoZSB0b29sYmFyIHRvIGNvbm5lY3Qgbm9kZXNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnYWRkRWRnZU1vZGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEVkZ2VNb2RlKCkge1xuICAgICAgICAvLyB3aGVuIHVzaW5nIHRoZSBndWksIGVuYWJsZSBlZGl0IG1vZGUgaWYgaXQgd2FzbnQgYWxyZWFkeS5cbiAgICAgICAgaWYgKHRoaXMuZWRpdE1vZGUgIT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXN0b3JlIHRoZSBzdGF0ZSBvZiBhbnkgYm91bmQgZnVuY3Rpb25zIG9yIGV2ZW50cywgcmVtb3ZlIGNvbnRyb2wgbm9kZXMsIHJlc3RvcmUgcGh5c2ljc1xuICAgICAgICB0aGlzLl9jbGVhbigpO1xuXG4gICAgICAgIHRoaXMuaW5Nb2RlID0gJ2FkZEVkZ2UnO1xuICAgICAgICBpZiAodGhpcy5ndWlFbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIGxvY2FsZSA9IHRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdO1xuICAgICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NID0ge307XG4gICAgICAgICAgdGhpcy5fY3JlYXRlQmFja0J1dHRvbihsb2NhbGUpO1xuICAgICAgICAgIHRoaXMuX2NyZWF0ZVNlcGVyYXRvcigpO1xuICAgICAgICAgIHRoaXMuX2NyZWF0ZURlc2NyaXB0aW9uKGxvY2FsZVsnZWRnZURlc2NyaXB0aW9uJ10gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbJ2VuJ11bJ2VkZ2VEZXNjcmlwdGlvbiddKTtcblxuICAgICAgICAgIC8vIGJpbmQgdGhlIGNsb3NlIGJ1dHRvblxuICAgICAgICAgIHRoaXMuX2JpbmRIYW1tZXJUb0Rpdih0aGlzLmNsb3NlRGl2LCB0aGlzLnRvZ2dsZUVkaXRNb2RlLmJpbmQodGhpcykpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGVtcG9yYXJpbHkgb3ZlcmxvYWQgZnVuY3Rpb25zXG4gICAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSSgnb25Ub3VjaCcsIHRoaXMuX2hhbmRsZUNvbm5lY3QuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSSgnb25EcmFnRW5kJywgdGhpcy5fZmluaXNoQ29ubmVjdC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZFVJKCdvbkRyYWcnLCB0aGlzLl9kcmFnQ29udHJvbE5vZGUuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSSgnb25SZWxlYXNlJywgdGhpcy5fZmluaXNoQ29ubmVjdC5iaW5kKHRoaXMpKTtcblxuICAgICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kVUkoJ29uRHJhZ1N0YXJ0JywgZnVuY3Rpb24gKCkge30pO1xuICAgICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kVUkoJ29uSG9sZCcsIGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBjcmVhdGUgdGhlIHRvb2xiYXIgdG8gZWRpdCBlZGdlc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdlZGl0RWRnZU1vZGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVkaXRFZGdlTW9kZSgpIHtcbiAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgLy8gd2hlbiB1c2luZyB0aGUgZ3VpLCBlbmFibGUgZWRpdCBtb2RlIGlmIGl0IHdhc24ndCBhbHJlYWR5LlxuICAgICAgICBpZiAodGhpcy5lZGl0TW9kZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlc3RvcmUgdGhlIHN0YXRlIG9mIGFueSBib3VuZCBmdW5jdGlvbnMgb3IgZXZlbnRzLCByZW1vdmUgY29udHJvbCBub2RlcywgcmVzdG9yZSBwaHlzaWNzXG4gICAgICAgIHRoaXMuX2NsZWFuKCk7XG5cbiAgICAgICAgdGhpcy5pbk1vZGUgPSAnZWRpdEVkZ2UnO1xuICAgICAgICBpZiAodGhpcy5ndWlFbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIGxvY2FsZSA9IHRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdO1xuICAgICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NID0ge307XG4gICAgICAgICAgdGhpcy5fY3JlYXRlQmFja0J1dHRvbihsb2NhbGUpO1xuICAgICAgICAgIHRoaXMuX2NyZWF0ZVNlcGVyYXRvcigpO1xuICAgICAgICAgIHRoaXMuX2NyZWF0ZURlc2NyaXB0aW9uKGxvY2FsZVsnZWRpdEVkZ2VEZXNjcmlwdGlvbiddIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzWydlbiddWydlZGl0RWRnZURlc2NyaXB0aW9uJ10pO1xuXG4gICAgICAgICAgLy8gYmluZCB0aGUgY2xvc2UgYnV0dG9uXG4gICAgICAgICAgdGhpcy5fYmluZEhhbW1lclRvRGl2KHRoaXMuY2xvc2VEaXYsIHRoaXMudG9nZ2xlRWRpdE1vZGUuYmluZCh0aGlzKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVkZ2VCZWluZ0VkaXRlZElkID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldFNlbGVjdGVkRWRnZXMoKVswXTtcbiAgICAgICAgaWYgKHRoaXMuZWRnZUJlaW5nRWRpdGVkSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZWRnZSA9IF90aGlzMy5ib2R5LmVkZ2VzW190aGlzMy5lZGdlQmVpbmdFZGl0ZWRJZF07XG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBjb250cm9sIG5vZGVzXG4gICAgICAgICAgICB2YXIgY29udHJvbE5vZGVGcm9tID0gX3RoaXMzLl9nZXROZXdUYXJnZXROb2RlKGVkZ2UuZnJvbS54LCBlZGdlLmZyb20ueSk7XG4gICAgICAgICAgICB2YXIgY29udHJvbE5vZGVUbyA9IF90aGlzMy5fZ2V0TmV3VGFyZ2V0Tm9kZShlZGdlLnRvLngsIGVkZ2UudG8ueSk7XG5cbiAgICAgICAgICAgIF90aGlzMy50ZW1wb3JhcnlJZHMubm9kZXMucHVzaChjb250cm9sTm9kZUZyb20uaWQpO1xuICAgICAgICAgICAgX3RoaXMzLnRlbXBvcmFyeUlkcy5ub2Rlcy5wdXNoKGNvbnRyb2xOb2RlVG8uaWQpO1xuXG4gICAgICAgICAgICBfdGhpczMuYm9keS5ub2Rlc1tjb250cm9sTm9kZUZyb20uaWRdID0gY29udHJvbE5vZGVGcm9tO1xuICAgICAgICAgICAgX3RoaXMzLmJvZHkubm9kZUluZGljZXMucHVzaChjb250cm9sTm9kZUZyb20uaWQpO1xuICAgICAgICAgICAgX3RoaXMzLmJvZHkubm9kZXNbY29udHJvbE5vZGVUby5pZF0gPSBjb250cm9sTm9kZVRvO1xuICAgICAgICAgICAgX3RoaXMzLmJvZHkubm9kZUluZGljZXMucHVzaChjb250cm9sTm9kZVRvLmlkKTtcblxuICAgICAgICAgICAgLy8gdGVtcG9yYXJpbHkgb3ZlcmxvYWQgVUkgZnVuY3Rpb25zLCBjbGVhbmVkIHVwIGF1dG9tYXRpY2FsbHkgYmVjYXVzZSBvZiBfdGVtcG9yYXJ5QmluZFVJXG4gICAgICAgICAgICBfdGhpczMuX3RlbXBvcmFyeUJpbmRVSSgnb25Ub3VjaCcsIF90aGlzMy5fY29udHJvbE5vZGVUb3VjaC5iaW5kKF90aGlzMykpOyAvLyB1c2VkIHRvIGdldCB0aGUgcG9zaXRpb25cbiAgICAgICAgICAgIF90aGlzMy5fdGVtcG9yYXJ5QmluZFVJKCdvblRhcCcsIGZ1bmN0aW9uICgpIHt9KTsgLy8gZGlzYWJsZWRcbiAgICAgICAgICAgIF90aGlzMy5fdGVtcG9yYXJ5QmluZFVJKCdvbkhvbGQnLCBmdW5jdGlvbiAoKSB7fSk7IC8vIGRpc2FibGVkXG4gICAgICAgICAgICBfdGhpczMuX3RlbXBvcmFyeUJpbmRVSSgnb25EcmFnU3RhcnQnLCBfdGhpczMuX2NvbnRyb2xOb2RlRHJhZ1N0YXJ0LmJpbmQoX3RoaXMzKSk7IC8vIHVzZWQgdG8gc2VsZWN0IGNvbnRyb2wgbm9kZVxuICAgICAgICAgICAgX3RoaXMzLl90ZW1wb3JhcnlCaW5kVUkoJ29uRHJhZycsIF90aGlzMy5fY29udHJvbE5vZGVEcmFnLmJpbmQoX3RoaXMzKSk7IC8vIHVzZWQgdG8gZHJhZyBjb250cm9sIG5vZGVcbiAgICAgICAgICAgIF90aGlzMy5fdGVtcG9yYXJ5QmluZFVJKCdvbkRyYWdFbmQnLCBfdGhpczMuX2NvbnRyb2xOb2RlRHJhZ0VuZC5iaW5kKF90aGlzMykpOyAvLyB1c2VkIHRvIGNvbm5lY3Qgb3IgcmV2ZXJ0IGNvbnRyb2wgbm9kZXNcbiAgICAgICAgICAgIF90aGlzMy5fdGVtcG9yYXJ5QmluZFVJKCdvbk1vdXNlTW92ZScsIGZ1bmN0aW9uICgpIHt9KTsgLy8gZGlzYWJsZWRcblxuICAgICAgICAgICAgLy8gY3JlYXRlIGZ1bmN0aW9uIHRvIHBvc2l0aW9uIGNvbnRyb2wgbm9kZXMgY29ycmVjdGx5IG9uIG1vdmVtZW50XG4gICAgICAgICAgICAvLyBhdXRvbWF0aWNhbGx5IGNsZWFuZWQgdXAgYmVjYXVzZSB3ZSB1c2UgdGhlIHRlbXBvcmFyeSBiaW5kXG4gICAgICAgICAgICBfdGhpczMuX3RlbXBvcmFyeUJpbmRFdmVudCgnYmVmb3JlRHJhd2luZycsIGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgICAgdmFyIHBvc2l0aW9ucyA9IGVkZ2UuZWRnZVR5cGUuZmluZEJvcmRlclBvc2l0aW9ucyhjdHgpO1xuICAgICAgICAgICAgICBpZiAoY29udHJvbE5vZGVGcm9tLnNlbGVjdGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xOb2RlRnJvbS54ID0gcG9zaXRpb25zLmZyb20ueDtcbiAgICAgICAgICAgICAgICBjb250cm9sTm9kZUZyb20ueSA9IHBvc2l0aW9ucy5mcm9tLnk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNvbnRyb2xOb2RlVG8uc2VsZWN0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbE5vZGVUby54ID0gcG9zaXRpb25zLnRvLng7XG4gICAgICAgICAgICAgICAgY29udHJvbE5vZGVUby55ID0gcG9zaXRpb25zLnRvLnk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBfdGhpczMuYm9keS5lbWl0dGVyLmVtaXQoJ19yZWRyYXcnKTtcbiAgICAgICAgICB9KSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogZGVsZXRlIGV2ZXJ5dGhpbmcgaW4gdGhlIHNlbGVjdGlvblxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkZWxldGVTZWxlY3RlZCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlU2VsZWN0ZWQoKSB7XG4gICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAgIC8vIHdoZW4gdXNpbmcgdGhlIGd1aSwgZW5hYmxlIGVkaXQgbW9kZSBpZiBpdCB3YXNudCBhbHJlYWR5LlxuICAgICAgICBpZiAodGhpcy5lZGl0TW9kZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlc3RvcmUgdGhlIHN0YXRlIG9mIGFueSBib3VuZCBmdW5jdGlvbnMgb3IgZXZlbnRzLCByZW1vdmUgY29udHJvbCBub2RlcywgcmVzdG9yZSBwaHlzaWNzXG4gICAgICAgIHRoaXMuX2NsZWFuKCk7XG5cbiAgICAgICAgdGhpcy5pbk1vZGUgPSAnZGVsZXRlJztcbiAgICAgICAgdmFyIHNlbGVjdGVkTm9kZXMgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0ZWROb2RlcygpO1xuICAgICAgICB2YXIgc2VsZWN0ZWRFZGdlcyA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRTZWxlY3RlZEVkZ2VzKCk7XG4gICAgICAgIHZhciBkZWxldGVGdW5jdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHNlbGVjdGVkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1tzZWxlY3RlZE5vZGVzW2ldXS5pc0NsdXN0ZXIgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgYWxlcnQodGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV1bJ2RlbGV0ZUNsdXN0ZXJFcnJvciddIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzWydlbiddWydkZWxldGVDbHVzdGVyRXJyb3InXSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5kZWxldGVOb2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBkZWxldGVGdW5jdGlvbiA9IHRoaXMub3B0aW9ucy5kZWxldGVOb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzZWxlY3RlZEVkZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5kZWxldGVFZGdlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBkZWxldGVGdW5jdGlvbiA9IHRoaXMub3B0aW9ucy5kZWxldGVFZGdlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZGVsZXRlRnVuY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IHsgbm9kZXM6IHNlbGVjdGVkTm9kZXMsIGVkZ2VzOiBzZWxlY3RlZEVkZ2VzIH07XG4gICAgICAgICAgaWYgKGRlbGV0ZUZ1bmN0aW9uLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgZGVsZXRlRnVuY3Rpb24oZGF0YSwgZnVuY3Rpb24gKGZpbmFsaXplZERhdGEpIHtcbiAgICAgICAgICAgICAgaWYgKGZpbmFsaXplZERhdGEgIT09IG51bGwgJiYgZmluYWxpemVkRGF0YSAhPT0gdW5kZWZpbmVkICYmIF90aGlzNC5pbk1vZGUgPT09ICdkZWxldGUnKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgZm9yIHdoYXRldmVyIHJlYXNvbiB0aGUgbW9kZSBoYXMgY2hhbmdlcyAoZHVlIHRvIGRhdGFzZXQgY2hhbmdlKSBkaXNyZWdhcmQgdGhlIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgX3RoaXM0LmJvZHkuZGF0YS5lZGdlcy5nZXREYXRhU2V0KCkucmVtb3ZlKGZpbmFsaXplZERhdGEuZWRnZXMpO1xuICAgICAgICAgICAgICAgIF90aGlzNC5ib2R5LmRhdGEubm9kZXMuZ2V0RGF0YVNldCgpLnJlbW92ZShmaW5hbGl6ZWREYXRhLm5vZGVzKTtcbiAgICAgICAgICAgICAgICBfdGhpczQuYm9keS5lbWl0dGVyLmVtaXQoJ3N0YXJ0U2ltdWxhdGlvbicpO1xuICAgICAgICAgICAgICAgIF90aGlzNC5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXM0LmJvZHkuZW1pdHRlci5lbWl0KCdzdGFydFNpbXVsYXRpb24nKTtcbiAgICAgICAgICAgICAgICBfdGhpczQuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZnVuY3Rpb24gZm9yIGRlbGV0ZSBkb2VzIG5vdCBzdXBwb3J0IHR3byBhcmd1bWVudHMgKGRhdGEsIGNhbGxiYWNrKScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZGF0YS5lZGdlcy5nZXREYXRhU2V0KCkucmVtb3ZlKHNlbGVjdGVkRWRnZXMpO1xuICAgICAgICAgIHRoaXMuYm9keS5kYXRhLm5vZGVzLmdldERhdGFTZXQoKS5yZW1vdmUoc2VsZWN0ZWROb2Rlcyk7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnc3RhcnRTaW11bGF0aW9uJyk7XG4gICAgICAgICAgdGhpcy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIFBSSVZBVEUgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqLy9cblxuICAgICAgLyoqXG4gICAgICAgKiBkcmF3IG9yIHJlbW92ZSB0aGUgRE9NXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc2V0dXAnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cCgpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgLy8gRW5hYmxlIHRoZSBHVUlcbiAgICAgICAgICB0aGlzLmd1aUVuYWJsZWQgPSB0cnVlO1xuXG4gICAgICAgICAgdGhpcy5fY3JlYXRlV3JhcHBlcnMoKTtcbiAgICAgICAgICBpZiAodGhpcy5lZGl0TW9kZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUVkaXRCdXR0b24oKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3JlbW92ZU1hbmlwdWxhdGlvbkRPTSgpO1xuXG4gICAgICAgICAgLy8gZGlzYWJsZSB0aGUgZ3VpXG4gICAgICAgICAgdGhpcy5ndWlFbmFibGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBjcmVhdGUgdGhlIGRpdiBvdmVybGF5cyB0aGF0IGNvbnRhaW4gdGhlIERPTVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2NyZWF0ZVdyYXBwZXJzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlV3JhcHBlcnMoKSB7XG4gICAgICAgIC8vIGxvYWQgdGhlIG1hbmlwdWxhdG9yIEhUTUwgZWxlbWVudHMuIEFsbCBzdHlsaW5nIGRvbmUgaW4gY3NzLlxuICAgICAgICBpZiAodGhpcy5tYW5pcHVsYXRpb25EaXYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuY2xhc3NOYW1lID0gJ3Zpcy1tYW5pcHVsYXRpb24nO1xuICAgICAgICAgIGlmICh0aGlzLmVkaXRNb2RlID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5jYW52YXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5tYW5pcHVsYXRpb25EaXYpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29udGFpbmVyIGZvciB0aGUgZWRpdCBidXR0b24uXG4gICAgICAgIGlmICh0aGlzLmVkaXRNb2RlRGl2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmVkaXRNb2RlRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgdGhpcy5lZGl0TW9kZURpdi5jbGFzc05hbWUgPSAndmlzLWVkaXQtbW9kZSc7XG4gICAgICAgICAgaWYgKHRoaXMuZWRpdE1vZGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdE1vZGVEaXYuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lZGl0TW9kZURpdi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5jYW52YXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5lZGl0TW9kZURpdik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb250YWluZXIgZm9yIHRoZSBjbG9zZSBkaXYgYnV0dG9uXG4gICAgICAgIGlmICh0aGlzLmNsb3NlRGl2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmNsb3NlRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgdGhpcy5jbG9zZURpdi5jbGFzc05hbWUgPSAndmlzLWNsb3NlJztcbiAgICAgICAgICB0aGlzLmNsb3NlRGl2LnN0eWxlLmRpc3BsYXkgPSB0aGlzLm1hbmlwdWxhdGlvbkRpdi5zdHlsZS5kaXNwbGF5O1xuICAgICAgICAgIHRoaXMuY2FudmFzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuY2xvc2VEaXYpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogZ2VuZXJhdGUgYSBuZXcgdGFyZ2V0IG5vZGUuIFVzZWQgZm9yIGNyZWF0aW5nIG5ldyBlZGdlcyBhbmQgZWRpdGluZyBlZGdlc1xuICAgICAgICogQHBhcmFtIHhcbiAgICAgICAqIEBwYXJhbSB5XG4gICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19nZXROZXdUYXJnZXROb2RlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0TmV3VGFyZ2V0Tm9kZSh4LCB5KSB7XG4gICAgICAgIHZhciBjb250cm9sTm9kZVN0eWxlID0gdXRpbC5kZWVwRXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMuY29udHJvbE5vZGVTdHlsZSk7XG5cbiAgICAgICAgY29udHJvbE5vZGVTdHlsZS5pZCA9ICd0YXJnZXROb2RlJyArIHV0aWwucmFuZG9tVVVJRCgpO1xuICAgICAgICBjb250cm9sTm9kZVN0eWxlLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgICBjb250cm9sTm9kZVN0eWxlLnBoeXNpY3MgPSBmYWxzZTtcbiAgICAgICAgY29udHJvbE5vZGVTdHlsZS54ID0geDtcbiAgICAgICAgY29udHJvbE5vZGVTdHlsZS55ID0geTtcblxuICAgICAgICAvLyB3ZSBoYXZlIHRvIGRlZmluZSB0aGUgYm91bmRpbmcgYm94IGluIG9yZGVyIGZvciB0aGUgbm9kZXMgdG8gYmUgZHJhd24gaW1tZWRpYXRlbHlcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZU5vZGUoY29udHJvbE5vZGVTdHlsZSk7XG4gICAgICAgIG5vZGUuc2hhcGUuYm91bmRpbmdCb3ggPSB7IGxlZnQ6IHgsIHJpZ2h0OiB4LCB0b3A6IHksIGJvdHRvbTogeSB9O1xuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZSB0aGUgZWRpdCBidXR0b25cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2NyZWF0ZUVkaXRCdXR0b24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVFZGl0QnV0dG9uKCkge1xuICAgICAgICAvLyByZXN0b3JlIGV2ZXJ5dGhpbmcgdG8gaXQncyBvcmlnaW5hbCBzdGF0ZSAoaWYgYXBwbGljYWJsZSlcbiAgICAgICAgdGhpcy5fY2xlYW4oKTtcblxuICAgICAgICAvLyByZXNldCB0aGUgbWFuaXB1bGF0aW9uRE9NXG4gICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NID0ge307XG5cbiAgICAgICAgLy8gZW1wdHkgdGhlIGVkaXRNb2RlRGl2XG4gICAgICAgIHV0aWwucmVjdXJzaXZlRE9NRGVsZXRlKHRoaXMuZWRpdE1vZGVEaXYpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgY29udGVudHMgZm9yIHRoZSBlZGl0TW9kZSBidXR0b25cbiAgICAgICAgdmFyIGxvY2FsZSA9IHRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdO1xuICAgICAgICB2YXIgYnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKCdlZGl0TW9kZScsICd2aXMtYnV0dG9uIHZpcy1lZGl0IHZpcy1lZGl0LW1vZGUnLCBsb2NhbGVbJ2VkaXQnXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1snZW4nXVsnZWRpdCddKTtcbiAgICAgICAgdGhpcy5lZGl0TW9kZURpdi5hcHBlbmRDaGlsZChidXR0b24pO1xuXG4gICAgICAgIC8vIGJpbmQgYSBoYW1tZXIgbGlzdGVuZXIgdG8gdGhlIGJ1dHRvbiwgY2FsbGluZyB0aGUgZnVuY3Rpb24gdG9nZ2xlRWRpdE1vZGUuXG4gICAgICAgIHRoaXMuX2JpbmRIYW1tZXJUb0RpdihidXR0b24sIHRoaXMudG9nZ2xlRWRpdE1vZGUuYmluZCh0aGlzKSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogdGhpcyBmdW5jdGlvbiBjbGVhbnMgdXAgYWZ0ZXIgZXZlcnl0aGluZyB0aGlzIG1vZHVsZSBkb2VzLiBUZW1wb3JhcnkgZWxlbWVudHMsIGZ1bmN0aW9ucyBhbmQgZXZlbnRzIGFyZSByZW1vdmVkLCBwaHlzaWNzIHJlc3RvcmVkLCBoYW1tZXJzIHJlbW92ZWQuXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY2xlYW4nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jbGVhbigpIHtcbiAgICAgICAgLy8gbm90IGluIG1vZGVcbiAgICAgICAgdGhpcy5pbk1vZGUgPSBmYWxzZTtcblxuICAgICAgICAvLyBfY2xlYW4gdGhlIGRpdnNcbiAgICAgICAgaWYgKHRoaXMuZ3VpRW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHV0aWwucmVjdXJzaXZlRE9NRGVsZXRlKHRoaXMuZWRpdE1vZGVEaXYpO1xuICAgICAgICAgIHV0aWwucmVjdXJzaXZlRE9NRGVsZXRlKHRoaXMubWFuaXB1bGF0aW9uRGl2KTtcblxuICAgICAgICAgIC8vIHJlbW92ZXMgYWxsIHRoZSBiaW5kaW5ncyBhbmQgb3ZlcmxvYWRzXG4gICAgICAgICAgdGhpcy5fY2xlYW5NYW5pcHVsYXRvckhhbW1lcnMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSB0ZW1wb3Jhcnkgbm9kZXMgYW5kIGVkZ2VzXG4gICAgICAgIHRoaXMuX2NsZWFudXBUZW1wb3JhcnlOb2Rlc0FuZEVkZ2VzKCk7XG5cbiAgICAgICAgLy8gcmVzdG9yZSBvdmVybG9hZGVkIFVJIGZ1bmN0aW9uc1xuICAgICAgICB0aGlzLl91bmJpbmRUZW1wb3JhcnlVSXMoKTtcblxuICAgICAgICAvLyByZW1vdmUgdGhlIHRlbXBvcmFyeUV2ZW50RnVuY3Rpb25zXG4gICAgICAgIHRoaXMuX3VuYmluZFRlbXBvcmFyeUV2ZW50cygpO1xuXG4gICAgICAgIC8vIHJlc3RvcmUgdGhlIHBoeXNpY3MgaWYgcmVxdWlyZWRcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgncmVzdG9yZVBoeXNpY3MnKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBFYWNoIGRvbSBlbGVtZW50IGhhcyBpdCdzIG93biBoYW1tZXIuIFRoZXkgYXJlIHN0b3JlZCBpbiB0aGlzLm1hbmlwdWxhdGlvbkhhbW1lcnMuIFRoaXMgY2xlYW5zIHRoZW0gdXAuXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY2xlYW5NYW5pcHVsYXRvckhhbW1lcnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jbGVhbk1hbmlwdWxhdG9ySGFtbWVycygpIHtcbiAgICAgICAgLy8gX2NsZWFuIGhhbW1lciBiaW5kaW5nc1xuICAgICAgICBpZiAodGhpcy5tYW5pcHVsYXRpb25IYW1tZXJzLmxlbmd0aCAhPSAwKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1hbmlwdWxhdGlvbkhhbW1lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMubWFuaXB1bGF0aW9uSGFtbWVyc1tpXS5kZXN0cm95KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubWFuaXB1bGF0aW9uSGFtbWVycyA9IFtdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlIGFsbCBET00gZWxlbWVudHMgY3JlYXRlZCBieSB0aGlzIG1vZHVsZS5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19yZW1vdmVNYW5pcHVsYXRpb25ET00nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVNYW5pcHVsYXRpb25ET00oKSB7XG4gICAgICAgIC8vIHJlbW92ZXMgYWxsIHRoZSBiaW5kaW5ncyBhbmQgb3ZlcmxvYWRzXG4gICAgICAgIHRoaXMuX2NsZWFuKCk7XG5cbiAgICAgICAgLy8gZW1wdHkgdGhlIG1hbmlwdWxhdGlvbiBkaXZzXG4gICAgICAgIHV0aWwucmVjdXJzaXZlRE9NRGVsZXRlKHRoaXMubWFuaXB1bGF0aW9uRGl2KTtcbiAgICAgICAgdXRpbC5yZWN1cnNpdmVET01EZWxldGUodGhpcy5lZGl0TW9kZURpdik7XG4gICAgICAgIHV0aWwucmVjdXJzaXZlRE9NRGVsZXRlKHRoaXMuY2xvc2VEaXYpO1xuXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgbWFuaXB1bGF0aW9uIGRpdnNcbiAgICAgICAgaWYgKHRoaXMubWFuaXB1bGF0aW9uRGl2KSB7XG4gICAgICAgICAgdGhpcy5jYW52YXMuZnJhbWUucmVtb3ZlQ2hpbGQodGhpcy5tYW5pcHVsYXRpb25EaXYpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVkaXRNb2RlRGl2KSB7XG4gICAgICAgICAgdGhpcy5jYW52YXMuZnJhbWUucmVtb3ZlQ2hpbGQodGhpcy5lZGl0TW9kZURpdik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2xvc2VEaXYpIHtcbiAgICAgICAgICB0aGlzLmNhbnZhcy5mcmFtZS5yZW1vdmVDaGlsZCh0aGlzLmNsb3NlRGl2KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCB0aGUgcmVmZXJlbmNlcyB0byB1bmRlZmluZWRcbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZWRpdE1vZGVEaXYgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY2xvc2VEaXYgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogY3JlYXRlIGEgc2VwZXJhdG9yIGxpbmUuIHRoZSBpbmRleCBpcyB0byBkaWZmZXJlbnRpYXRlIGluIHRoZSBtYW5pcHVsYXRpb24gZG9tXG4gICAgICAgKiBAcGFyYW0gaW5kZXhcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19jcmVhdGVTZXBlcmF0b3InLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVTZXBlcmF0b3IoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IDEgOiBhcmd1bWVudHNbMF07XG5cbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET01bJ3NlcGVyYXRvckxpbmVEaXYnICsgaW5kZXhdID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NWydzZXBlcmF0b3JMaW5lRGl2JyArIGluZGV4XS5jbGFzc05hbWUgPSAndmlzLXNlcGFyYXRvci1saW5lJztcbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuYXBwZW5kQ2hpbGQodGhpcy5tYW5pcHVsYXRpb25ET01bJ3NlcGVyYXRvckxpbmVEaXYnICsgaW5kZXhdKTtcbiAgICAgIH1cblxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAgICBET00gZnVuY3Rpb25zIGZvciBidXR0b25zICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLy9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19jcmVhdGVBZGROb2RlQnV0dG9uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlQWRkTm9kZUJ1dHRvbihsb2NhbGUpIHtcbiAgICAgICAgdmFyIGJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbignYWRkTm9kZScsICd2aXMtYnV0dG9uIHZpcy1hZGQnLCBsb2NhbGVbJ2FkZE5vZGUnXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1snZW4nXVsnYWRkTm9kZSddKTtcbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcbiAgICAgICAgdGhpcy5fYmluZEhhbW1lclRvRGl2KGJ1dHRvbiwgdGhpcy5hZGROb2RlTW9kZS5iaW5kKHRoaXMpKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY3JlYXRlQWRkRWRnZUJ1dHRvbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUFkZEVkZ2VCdXR0b24obG9jYWxlKSB7XG4gICAgICAgIHZhciBidXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oJ2FkZEVkZ2UnLCAndmlzLWJ1dHRvbiB2aXMtY29ubmVjdCcsIGxvY2FsZVsnYWRkRWRnZSddIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzWydlbiddWydhZGRFZGdlJ10pO1xuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5hcHBlbmRDaGlsZChidXR0b24pO1xuICAgICAgICB0aGlzLl9iaW5kSGFtbWVyVG9EaXYoYnV0dG9uLCB0aGlzLmFkZEVkZ2VNb2RlLmJpbmQodGhpcykpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19jcmVhdGVFZGl0Tm9kZUJ1dHRvbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUVkaXROb2RlQnV0dG9uKGxvY2FsZSkge1xuICAgICAgICB2YXIgYnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKCdlZGl0Tm9kZScsICd2aXMtYnV0dG9uIHZpcy1lZGl0JywgbG9jYWxlWydlZGl0Tm9kZSddIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzWydlbiddWydlZGl0Tm9kZSddKTtcbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcbiAgICAgICAgdGhpcy5fYmluZEhhbW1lclRvRGl2KGJ1dHRvbiwgdGhpcy5lZGl0Tm9kZS5iaW5kKHRoaXMpKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY3JlYXRlRWRpdEVkZ2VCdXR0b24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVFZGl0RWRnZUJ1dHRvbihsb2NhbGUpIHtcbiAgICAgICAgdmFyIGJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbignZWRpdEVkZ2UnLCAndmlzLWJ1dHRvbiB2aXMtZWRpdCcsIGxvY2FsZVsnZWRpdEVkZ2UnXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1snZW4nXVsnZWRpdEVkZ2UnXSk7XG4gICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gICAgICAgIHRoaXMuX2JpbmRIYW1tZXJUb0RpdihidXR0b24sIHRoaXMuZWRpdEVkZ2VNb2RlLmJpbmQodGhpcykpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19jcmVhdGVEZWxldGVCdXR0b24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVEZWxldGVCdXR0b24obG9jYWxlKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucnRsKSB7XG4gICAgICAgICAgdmFyIGRlbGV0ZUJ0bkNsYXNzID0gJ3Zpcy1idXR0b24gdmlzLWRlbGV0ZS1ydGwnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBkZWxldGVCdG5DbGFzcyA9ICd2aXMtYnV0dG9uIHZpcy1kZWxldGUnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBidXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oJ2RlbGV0ZScsIGRlbGV0ZUJ0bkNsYXNzLCBsb2NhbGVbJ2RlbCddIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzWydlbiddWydkZWwnXSk7XG4gICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gICAgICAgIHRoaXMuX2JpbmRIYW1tZXJUb0RpdihidXR0b24sIHRoaXMuZGVsZXRlU2VsZWN0ZWQuYmluZCh0aGlzKSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2NyZWF0ZUJhY2tCdXR0b24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVCYWNrQnV0dG9uKGxvY2FsZSkge1xuICAgICAgICB2YXIgYnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKCdiYWNrJywgJ3Zpcy1idXR0b24gdmlzLWJhY2snLCBsb2NhbGVbJ2JhY2snXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1snZW4nXVsnYmFjayddKTtcbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcbiAgICAgICAgdGhpcy5fYmluZEhhbW1lclRvRGl2KGJ1dHRvbiwgdGhpcy5zaG93TWFuaXB1bGF0b3JUb29sYmFyLmJpbmQodGhpcykpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19jcmVhdGVCdXR0b24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVCdXR0b24oaWQsIGNsYXNzTmFtZSwgbGFiZWwpIHtcbiAgICAgICAgdmFyIGxhYmVsQ2xhc3NOYW1lID0gYXJndW1lbnRzLmxlbmd0aCA8PSAzIHx8IGFyZ3VtZW50c1szXSA9PT0gdW5kZWZpbmVkID8gJ3Zpcy1sYWJlbCcgOiBhcmd1bWVudHNbM107XG5cblxuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTVtpZCArICdEaXYnXSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTVtpZCArICdEaXYnXS5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NW2lkICsgJ0xhYmVsJ10gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET01baWQgKyAnTGFiZWwnXS5jbGFzc05hbWUgPSBsYWJlbENsYXNzTmFtZTtcbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET01baWQgKyAnTGFiZWwnXS5pbm5lckhUTUwgPSBsYWJlbDtcbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET01baWQgKyAnRGl2J10uYXBwZW5kQ2hpbGQodGhpcy5tYW5pcHVsYXRpb25ET01baWQgKyAnTGFiZWwnXSk7XG4gICAgICAgIHJldHVybiB0aGlzLm1hbmlwdWxhdGlvbkRPTVtpZCArICdEaXYnXTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY3JlYXRlRGVzY3JpcHRpb24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVEZXNjcmlwdGlvbihsYWJlbCkge1xuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5hcHBlbmRDaGlsZCh0aGlzLl9jcmVhdGVCdXR0b24oJ2Rlc2NyaXB0aW9uJywgJ3Zpcy1idXR0b24gdmlzLW5vbmUnLCBsYWJlbCkpO1xuICAgICAgfVxuXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFbmQgb2YgRE9NIGZ1bmN0aW9ucyBmb3IgYnV0dG9ucyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xuXG4gICAgICAvKipcbiAgICAgICAqIHRoaXMgYmluZHMgYW4gZXZlbnQgdW50aWwgY2xlYW51cCBieSB0aGUgY2xlYW4gZnVuY3Rpb25zLlxuICAgICAgICogQHBhcmFtIGV2ZW50XG4gICAgICAgKiBAcGFyYW0gbmV3RnVuY3Rpb25cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ190ZW1wb3JhcnlCaW5kRXZlbnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF90ZW1wb3JhcnlCaW5kRXZlbnQoZXZlbnQsIG5ld0Z1bmN0aW9uKSB7XG4gICAgICAgIHRoaXMudGVtcG9yYXJ5RXZlbnRGdW5jdGlvbnMucHVzaCh7IGV2ZW50OiBldmVudCwgYm91bmRGdW5jdGlvbjogbmV3RnVuY3Rpb24gfSk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKGV2ZW50LCBuZXdGdW5jdGlvbik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogdGhpcyBvdmVycmlkZXMgYW4gVUkgZnVuY3Rpb24gdW50aWwgY2xlYW51cCBieSB0aGUgY2xlYW4gZnVuY3Rpb25cbiAgICAgICAqIEBwYXJhbSBVSWZ1bmN0aW9uTmFtZVxuICAgICAgICogQHBhcmFtIG5ld0Z1bmN0aW9uXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfdGVtcG9yYXJ5QmluZFVJJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdGVtcG9yYXJ5QmluZFVJKFVJZnVuY3Rpb25OYW1lLCBuZXdGdW5jdGlvbikge1xuICAgICAgICBpZiAodGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzW1VJZnVuY3Rpb25OYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy50ZW1wb3JhcnlVSUZ1bmN0aW9uc1tVSWZ1bmN0aW9uTmFtZV0gPSB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnNbVUlmdW5jdGlvbk5hbWVdO1xuICAgICAgICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVyc1tVSWZ1bmN0aW9uTmFtZV0gPSBuZXdGdW5jdGlvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgVUkgZnVuY3Rpb24gZG9lcyBub3QgZXhpc3QuIFR5cG8/IFlvdSB0cmllZDogJyArIFVJZnVuY3Rpb25OYW1lICsgJyBwb3NzaWJsZSBhcmU6ICcgKyBKU09OLnN0cmluZ2lmeShPYmplY3Qua2V5cyh0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMpKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXN0b3JlIHRoZSBvdmVycmlkZGVuIFVJIGZ1bmN0aW9ucyB0byB0aGVpciBvcmlnaW5hbCBzdGF0ZS5cbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfdW5iaW5kVGVtcG9yYXJ5VUlzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5iaW5kVGVtcG9yYXJ5VUlzKCkge1xuICAgICAgICBmb3IgKHZhciBmdW5jdGlvbk5hbWUgaW4gdGhpcy50ZW1wb3JhcnlVSUZ1bmN0aW9ucykge1xuICAgICAgICAgIGlmICh0aGlzLnRlbXBvcmFyeVVJRnVuY3Rpb25zLmhhc093blByb3BlcnR5KGZ1bmN0aW9uTmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVyc1tmdW5jdGlvbk5hbWVdID0gdGhpcy50ZW1wb3JhcnlVSUZ1bmN0aW9uc1tmdW5jdGlvbk5hbWVdO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMudGVtcG9yYXJ5VUlGdW5jdGlvbnNbZnVuY3Rpb25OYW1lXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50ZW1wb3JhcnlVSUZ1bmN0aW9ucyA9IHt9O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFVuYmluZCB0aGUgZXZlbnRzIGNyZWF0ZWQgYnkgX3RlbXBvcmFyeUJpbmRFdmVudFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3VuYmluZFRlbXBvcmFyeUV2ZW50cycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3VuYmluZFRlbXBvcmFyeUV2ZW50cygpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRlbXBvcmFyeUV2ZW50RnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGV2ZW50TmFtZSA9IHRoaXMudGVtcG9yYXJ5RXZlbnRGdW5jdGlvbnNbaV0uZXZlbnQ7XG4gICAgICAgICAgdmFyIGJvdW5kRnVuY3Rpb24gPSB0aGlzLnRlbXBvcmFyeUV2ZW50RnVuY3Rpb25zW2ldLmJvdW5kRnVuY3Rpb247XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub2ZmKGV2ZW50TmFtZSwgYm91bmRGdW5jdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50ZW1wb3JhcnlFdmVudEZ1bmN0aW9ucyA9IFtdO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEJpbmQgYW4gaGFtbWVyIGluc3RhbmNlIHRvIGEgRE9NIGVsZW1lbnQuXG4gICAgICAgKiBAcGFyYW0gZG9tRWxlbWVudFxuICAgICAgICogQHBhcmFtIGZ1bmN0XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19iaW5kSGFtbWVyVG9EaXYnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9iaW5kSGFtbWVyVG9EaXYoZG9tRWxlbWVudCwgYm91bmRGdW5jdGlvbikge1xuICAgICAgICB2YXIgaGFtbWVyID0gbmV3IEhhbW1lcihkb21FbGVtZW50LCB7fSk7XG4gICAgICAgIGhhbW1lclV0aWwub25Ub3VjaChoYW1tZXIsIGJvdW5kRnVuY3Rpb24pO1xuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkhhbW1lcnMucHVzaChoYW1tZXIpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE5lYXRseSBjbGVhbiB1cCB0ZW1wb3JhcnkgZWRnZXMgYW5kIG5vZGVzXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY2xlYW51cFRlbXBvcmFyeU5vZGVzQW5kRWRnZXMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jbGVhbnVwVGVtcG9yYXJ5Tm9kZXNBbmRFZGdlcygpIHtcbiAgICAgICAgLy8gX2NsZWFuIHRlbXBvcmFyeSBlZGdlc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudGVtcG9yYXJ5SWRzLmVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVkZ2VzW3RoaXMudGVtcG9yYXJ5SWRzLmVkZ2VzW2ldXS5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuYm9keS5lZGdlc1t0aGlzLnRlbXBvcmFyeUlkcy5lZGdlc1tpXV07XG4gICAgICAgICAgdmFyIGluZGV4VGVtcEVkZ2UgPSB0aGlzLmJvZHkuZWRnZUluZGljZXMuaW5kZXhPZih0aGlzLnRlbXBvcmFyeUlkcy5lZGdlc1tpXSk7XG4gICAgICAgICAgaWYgKGluZGV4VGVtcEVkZ2UgIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmJvZHkuZWRnZUluZGljZXMuc3BsaWNlKGluZGV4VGVtcEVkZ2UsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIF9jbGVhbiB0ZW1wb3Jhcnkgbm9kZXNcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRoaXMudGVtcG9yYXJ5SWRzLm5vZGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLmJvZHkubm9kZXNbdGhpcy50ZW1wb3JhcnlJZHMubm9kZXNbX2ldXTtcbiAgICAgICAgICB2YXIgaW5kZXhUZW1wTm9kZSA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcy5pbmRleE9mKHRoaXMudGVtcG9yYXJ5SWRzLm5vZGVzW19pXSk7XG4gICAgICAgICAgaWYgKGluZGV4VGVtcE5vZGUgIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmJvZHkubm9kZUluZGljZXMuc3BsaWNlKGluZGV4VGVtcE5vZGUsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudGVtcG9yYXJ5SWRzID0geyBub2RlczogW10sIGVkZ2VzOiBbXSB9O1xuICAgICAgfVxuXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRURJVCBFREdFIEZVTkNUSU9OUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG5cbiAgICAgIC8qKlxuICAgICAgICogdGhlIHRvdWNoIGlzIHVzZWQgdG8gZ2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgaW5pdGlhbCBjbGlja1xuICAgICAgICogQHBhcmFtIGV2ZW50XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY29udHJvbE5vZGVUb3VjaCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbnRyb2xOb2RlVG91Y2goZXZlbnQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnVuc2VsZWN0QWxsKCk7XG4gICAgICAgIHRoaXMubGFzdFRvdWNoID0gdGhpcy5ib2R5LmZ1bmN0aW9ucy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICAgIHRoaXMubGFzdFRvdWNoLnRyYW5zbGF0aW9uID0gdXRpbC5leHRlbmQoe30sIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uKTsgLy8gY29weSB0aGUgb2JqZWN0XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogdGhlIGRyYWcgc3RhcnQgaXMgdXNlZCB0byBtYXJrIG9uZSBvZiB0aGUgY29udHJvbCBub2RlcyBhcyBzZWxlY3RlZC5cbiAgICAgICAqIEBwYXJhbSBldmVudFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2NvbnRyb2xOb2RlRHJhZ1N0YXJ0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY29udHJvbE5vZGVEcmFnU3RhcnQoZXZlbnQpIHtcbiAgICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmxhc3RUb3VjaDtcbiAgICAgICAgdmFyIHBvaW50ZXJPYmogPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX3BvaW50ZXJUb1Bvc2l0aW9uT2JqZWN0KHBvaW50ZXIpO1xuICAgICAgICB2YXIgZnJvbSA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLnRlbXBvcmFyeUlkcy5ub2Rlc1swXV07XG4gICAgICAgIHZhciB0byA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLnRlbXBvcmFyeUlkcy5ub2Rlc1sxXV07XG4gICAgICAgIHZhciBlZGdlID0gdGhpcy5ib2R5LmVkZ2VzW3RoaXMuZWRnZUJlaW5nRWRpdGVkSWRdO1xuICAgICAgICB0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgdmFyIGZyb21TZWxlY3QgPSBmcm9tLmlzT3ZlcmxhcHBpbmdXaXRoKHBvaW50ZXJPYmopO1xuICAgICAgICB2YXIgdG9TZWxlY3QgPSB0by5pc092ZXJsYXBwaW5nV2l0aChwb2ludGVyT2JqKTtcblxuICAgICAgICBpZiAoZnJvbVNlbGVjdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZSA9IGZyb207XG4gICAgICAgICAgZWRnZS5lZGdlVHlwZS5mcm9tID0gZnJvbTtcbiAgICAgICAgfSBlbHNlIGlmICh0b1NlbGVjdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZSA9IHRvO1xuICAgICAgICAgIGVkZ2UuZWRnZVR5cGUudG8gPSB0bztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlIHVzZSB0aGUgc2VsZWN0aW9uIHRvIGZpbmQgdGhlIG5vZGUgdGhhdCBpcyBiZWluZyBkcmFnZ2VkLiBXZSBleHBsaWNpdGx5IHNlbGVjdCBpdCBoZXJlLlxuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuc2VsZWN0T2JqZWN0KHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfcmVkcmF3Jyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogZHJhZ2dpbmcgdGhlIGNvbnRyb2wgbm9kZXMgb3IgdGhlIGNhbnZhc1xuICAgICAgICogQHBhcmFtIGV2ZW50XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY29udHJvbE5vZGVEcmFnJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY29udHJvbE5vZGVEcmFnKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ2Rpc2FibGVQaHlzaWNzJyk7XG4gICAgICAgIHZhciBwb2ludGVyID0gdGhpcy5ib2R5LmZ1bmN0aW9ucy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICAgIHZhciBwb3MgPSB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyhwb2ludGVyKTtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlLnggPSBwb3MueDtcbiAgICAgICAgICB0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUueSA9IHBvcy55O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGlmIHRoZSBkcmFnIHdhcyBub3Qgc3RhcnRlZCBwcm9wZXJseSBiZWNhdXNlIHRoZSBjbGljayBzdGFydGVkIG91dHNpZGUgdGhlIG5ldHdvcmsgZGl2LCBzdGFydCBpdCBub3cuXG4gICAgICAgICAgdmFyIGRpZmZYID0gcG9pbnRlci54IC0gdGhpcy5sYXN0VG91Y2gueDtcbiAgICAgICAgICB2YXIgZGlmZlkgPSBwb2ludGVyLnkgLSB0aGlzLmxhc3RUb3VjaC55O1xuICAgICAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uID0geyB4OiB0aGlzLmxhc3RUb3VjaC50cmFuc2xhdGlvbi54ICsgZGlmZlgsIHk6IHRoaXMubGFzdFRvdWNoLnRyYW5zbGF0aW9uLnkgKyBkaWZmWSB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19yZWRyYXcnKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBjb25uZWN0aW5nIG9yIHJlc3RvcmluZyB0aGUgY29udHJvbCBub2Rlcy5cbiAgICAgICAqIEBwYXJhbSBldmVudFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2NvbnRyb2xOb2RlRHJhZ0VuZCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbnRyb2xOb2RlRHJhZ0VuZChldmVudCkge1xuICAgICAgICB2YXIgcG9pbnRlciA9IHRoaXMuYm9keS5mdW5jdGlvbnMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuICAgICAgICB2YXIgcG9pbnRlck9iaiA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fcG9pbnRlclRvUG9zaXRpb25PYmplY3QocG9pbnRlcik7XG4gICAgICAgIHZhciBlZGdlID0gdGhpcy5ib2R5LmVkZ2VzW3RoaXMuZWRnZUJlaW5nRWRpdGVkSWRdO1xuICAgICAgICAvLyBpZiB0aGUgbm9kZSB0aGF0IHdhcyBkcmFnZ2VkIGlzIG5vdCBhIGNvbnRyb2wgbm9kZSwgcmV0dXJuXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlIHVzZSB0aGUgc2VsZWN0aW9uIHRvIGZpbmQgdGhlIG5vZGUgdGhhdCBpcyBiZWluZyBkcmFnZ2VkLiBXZSBleHBsaWNpdGx5IERFc2VsZWN0IHRoZSBjb250cm9sIG5vZGUgaGVyZS5cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnVuc2VsZWN0QWxsKCk7XG4gICAgICAgIHZhciBvdmVybGFwcGluZ05vZGVJZHMgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dldEFsbE5vZGVzT3ZlcmxhcHBpbmdXaXRoKHBvaW50ZXJPYmopO1xuICAgICAgICB2YXIgbm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yICh2YXIgaSA9IG92ZXJsYXBwaW5nTm9kZUlkcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChvdmVybGFwcGluZ05vZGVJZHNbaV0gIT09IHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZS5pZCkge1xuICAgICAgICAgICAgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tvdmVybGFwcGluZ05vZGVJZHNbaV1dO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHBlcmZvcm0gdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChub2RlLmlzQ2x1c3RlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgYWxlcnQodGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV1bJ2NyZWF0ZUVkZ2VFcnJvciddIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzWydlbiddWydjcmVhdGVFZGdlRXJyb3InXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBmcm9tID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMudGVtcG9yYXJ5SWRzLm5vZGVzWzBdXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUuaWQgPT09IGZyb20uaWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcGVyZm9ybUVkaXRFZGdlKG5vZGUuaWQsIGVkZ2UudG8uaWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fcGVyZm9ybUVkaXRFZGdlKGVkZ2UuZnJvbS5pZCwgbm9kZS5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVkZ2UudXBkYXRlRWRnZVR5cGUoKTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdyZXN0b3JlUGh5c2ljcycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ19yZWRyYXcnKTtcbiAgICAgIH1cblxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVORCBPRiBFRElUIEVER0UgRlVOQ1RJT05TIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLy9cblxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBBREQgRURHRSBGVU5DVElPTlMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xuICAgICAgLyoqXG4gICAgICAgKiB0aGUgZnVuY3Rpb24gYm91bmQgdG8gdGhlIHNlbGVjdGlvbiBldmVudC4gSXQgY2hlY2tzIGlmIHlvdSB3YW50IHRvIGNvbm5lY3QgYSBjbHVzdGVyIGFuZCBjaGFuZ2VzIHRoZSBkZXNjcmlwdGlvblxuICAgICAgICogdG8gd2FsayB0aGUgdXNlciB0aHJvdWdoIHRoZSBwcm9jZXNzLlxuICAgICAgICpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19oYW5kbGVDb25uZWN0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlQ29ubmVjdChldmVudCkge1xuICAgICAgICAvLyBjaGVjayB0byBhdm9pZCBkb3VibGUgZmlyZWluZyBvZiB0aGlzIGZ1bmN0aW9uLlxuICAgICAgICBpZiAobmV3IERhdGUoKS52YWx1ZU9mKCkgLSB0aGlzLnRvdWNoVGltZSA+IDEwMCkge1xuICAgICAgICAgIHRoaXMubGFzdFRvdWNoID0gdGhpcy5ib2R5LmZ1bmN0aW9ucy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICAgICAgdGhpcy5sYXN0VG91Y2gudHJhbnNsYXRpb24gPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24pOyAvLyBjb3B5IHRoZSBvYmplY3RcblxuICAgICAgICAgIHZhciBwb2ludGVyID0gdGhpcy5sYXN0VG91Y2g7XG4gICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0Tm9kZUF0KHBvaW50ZXIpO1xuXG4gICAgICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKG5vZGUuaXNDbHVzdGVyID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIGFsZXJ0KHRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdWydjcmVhdGVFZGdlRXJyb3InXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1snZW4nXVsnY3JlYXRlRWRnZUVycm9yJ10pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gY3JlYXRlIGEgbm9kZSB0aGUgdGVtcG9yYXJ5IGxpbmUgY2FuIGxvb2sgYXRcbiAgICAgICAgICAgICAgdmFyIHRhcmdldE5vZGUgPSB0aGlzLl9nZXROZXdUYXJnZXROb2RlKG5vZGUueCwgbm9kZS55KTtcbiAgICAgICAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW3RhcmdldE5vZGUuaWRdID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgICAgICAgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLnB1c2godGFyZ2V0Tm9kZS5pZCk7XG5cbiAgICAgICAgICAgICAgLy8gY3JlYXRlIGEgdGVtcG9yYXJ5IGVkZ2VcbiAgICAgICAgICAgICAgdmFyIGNvbm5lY3Rpb25FZGdlID0gdGhpcy5ib2R5LmZ1bmN0aW9ucy5jcmVhdGVFZGdlKHtcbiAgICAgICAgICAgICAgICBpZDogJ2Nvbm5lY3Rpb25FZGdlJyArIHV0aWwucmFuZG9tVVVJRCgpLFxuICAgICAgICAgICAgICAgIGZyb206IG5vZGUuaWQsXG4gICAgICAgICAgICAgICAgdG86IHRhcmdldE5vZGUuaWQsXG4gICAgICAgICAgICAgICAgcGh5c2ljczogZmFsc2UsXG4gICAgICAgICAgICAgICAgc21vb3RoOiB7XG4gICAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgdHlwZTogJ2NvbnRpbnVvdXMnLFxuICAgICAgICAgICAgICAgICAgcm91bmRuZXNzOiAwLjVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0aGlzLmJvZHkuZWRnZXNbY29ubmVjdGlvbkVkZ2UuaWRdID0gY29ubmVjdGlvbkVkZ2U7XG4gICAgICAgICAgICAgIHRoaXMuYm9keS5lZGdlSW5kaWNlcy5wdXNoKGNvbm5lY3Rpb25FZGdlLmlkKTtcblxuICAgICAgICAgICAgICB0aGlzLnRlbXBvcmFyeUlkcy5ub2Rlcy5wdXNoKHRhcmdldE5vZGUuaWQpO1xuICAgICAgICAgICAgICB0aGlzLnRlbXBvcmFyeUlkcy5lZGdlcy5wdXNoKGNvbm5lY3Rpb25FZGdlLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy50b3VjaFRpbWUgPSBuZXcgRGF0ZSgpLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19kcmFnQ29udHJvbE5vZGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmFnQ29udHJvbE5vZGUoZXZlbnQpIHtcbiAgICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgICAgaWYgKHRoaXMudGVtcG9yYXJ5SWRzLm5vZGVzWzBdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgdGFyZ2V0Tm9kZSA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLnRlbXBvcmFyeUlkcy5ub2Rlc1swXV07IC8vIHRoZXJlIGlzIG9ubHkgb25lIHRlbXAgbm9kZSBpbiB0aGUgYWRkIGVkZ2UgbW9kZS5cbiAgICAgICAgICB0YXJnZXROb2RlLnggPSB0aGlzLmNhbnZhcy5fWGNvbnZlcnRET010b0NhbnZhcyhwb2ludGVyLngpO1xuICAgICAgICAgIHRhcmdldE5vZGUueSA9IHRoaXMuY2FudmFzLl9ZY29udmVydERPTXRvQ2FudmFzKHBvaW50ZXIueSk7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnX3JlZHJhdycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBkaWZmWCA9IHBvaW50ZXIueCAtIHRoaXMubGFzdFRvdWNoLng7XG4gICAgICAgICAgdmFyIGRpZmZZID0gcG9pbnRlci55IC0gdGhpcy5sYXN0VG91Y2gueTtcbiAgICAgICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbiA9IHsgeDogdGhpcy5sYXN0VG91Y2gudHJhbnNsYXRpb24ueCArIGRpZmZYLCB5OiB0aGlzLmxhc3RUb3VjaC50cmFuc2xhdGlvbi55ICsgZGlmZlkgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENvbm5lY3QgdGhlIG5ldyBlZGdlIHRvIHRoZSB0YXJnZXQgaWYgb25lIGV4aXN0cywgb3RoZXJ3aXNlIHJlbW92ZSB0ZW1wIGxpbmVcbiAgICAgICAqIEBwYXJhbSBldmVudFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2ZpbmlzaENvbm5lY3QnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5pc2hDb25uZWN0KGV2ZW50KSB7XG4gICAgICAgIHZhciBwb2ludGVyID0gdGhpcy5ib2R5LmZ1bmN0aW9ucy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICAgIHZhciBwb2ludGVyT2JqID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9wb2ludGVyVG9Qb3NpdGlvbk9iamVjdChwb2ludGVyKTtcblxuICAgICAgICAvLyByZW1lbWJlciB0aGUgZWRnZSBpZFxuICAgICAgICB2YXIgY29ubmVjdEZyb21JZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRoaXMudGVtcG9yYXJ5SWRzLmVkZ2VzWzBdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb25uZWN0RnJvbUlkID0gdGhpcy5ib2R5LmVkZ2VzW3RoaXMudGVtcG9yYXJ5SWRzLmVkZ2VzWzBdXS5mcm9tSWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgdGhlIG92ZXJsYXBwaW5nIG5vZGUgYnV0IE5PVCB0aGUgdGVtcG9yYXJ5IG5vZGU7XG4gICAgICAgIHZhciBvdmVybGFwcGluZ05vZGVJZHMgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dldEFsbE5vZGVzT3ZlcmxhcHBpbmdXaXRoKHBvaW50ZXJPYmopO1xuICAgICAgICB2YXIgbm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yICh2YXIgaSA9IG92ZXJsYXBwaW5nTm9kZUlkcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIC8vIGlmIHRoZSBub2RlIGlkIGlzIE5PVCBhIHRlbXBvcmFyeSBub2RlLCBhY2NlcHQgdGhlIG5vZGUuXG4gICAgICAgICAgaWYgKHRoaXMudGVtcG9yYXJ5SWRzLm5vZGVzLmluZGV4T2Yob3ZlcmxhcHBpbmdOb2RlSWRzW2ldKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbb3ZlcmxhcHBpbmdOb2RlSWRzW2ldXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFuIHRlbXBvcmFyeSBub2RlcyBhbmQgZWRnZXMuXG4gICAgICAgIHRoaXMuX2NsZWFudXBUZW1wb3JhcnlOb2Rlc0FuZEVkZ2VzKCk7XG5cbiAgICAgICAgLy8gcGVyZm9ybSB0aGUgY29ubmVjdGlvblxuICAgICAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKG5vZGUuaXNDbHVzdGVyID09PSB0cnVlKSB7XG4gICAgICAgICAgICBhbGVydCh0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXVsnY3JlYXRlRWRnZUVycm9yJ10gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbJ2VuJ11bJ2NyZWF0ZUVkZ2VFcnJvciddKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1tjb25uZWN0RnJvbUlkXSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuYm9keS5ub2Rlc1tub2RlLmlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3BlcmZvcm1BZGRFZGdlKGNvbm5lY3RGcm9tSWQsIG5vZGUuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdfcmVkcmF3Jyk7XG4gICAgICB9XG5cbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFTkQgT0YgQUREIEVER0UgRlVOQ1RJT05TIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xuXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUGVyZm9ybWluZyBhbGwgdGhlIGFjdHVhbCBkYXRhIG1hbmlwdWxhdGlvbiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xuXG4gICAgICAvKipcbiAgICAgICAqIEFkZHMgYSBub2RlIG9uIHRoZSBzcGVjaWZpZWQgbG9jYXRpb25cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3BlcmZvcm1BZGROb2RlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcGVyZm9ybUFkZE5vZGUoY2xpY2tEYXRhKSB7XG4gICAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHtcbiAgICAgICAgICBpZDogdXRpbC5yYW5kb21VVUlEKCksXG4gICAgICAgICAgeDogY2xpY2tEYXRhLnBvaW50ZXIuY2FudmFzLngsXG4gICAgICAgICAgeTogY2xpY2tEYXRhLnBvaW50ZXIuY2FudmFzLnksXG4gICAgICAgICAgbGFiZWw6ICduZXcnXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuYWRkTm9kZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWRkTm9kZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5hZGROb2RlKGRlZmF1bHREYXRhLCBmdW5jdGlvbiAoZmluYWxpemVkRGF0YSkge1xuICAgICAgICAgICAgICBpZiAoZmluYWxpemVkRGF0YSAhPT0gbnVsbCAmJiBmaW5hbGl6ZWREYXRhICE9PSB1bmRlZmluZWQgJiYgX3RoaXM1LmluTW9kZSA9PT0gJ2FkZE5vZGUnKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgZm9yIHdoYXRldmVyIHJlYXNvbiB0aGUgbW9kZSBoYXMgY2hhbmdlcyAoZHVlIHRvIGRhdGFzZXQgY2hhbmdlKSBkaXNyZWdhcmQgdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgX3RoaXM1LmJvZHkuZGF0YS5ub2Rlcy5nZXREYXRhU2V0KCkuYWRkKGZpbmFsaXplZERhdGEpO1xuICAgICAgICAgICAgICAgIF90aGlzNS5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBmdW5jdGlvbiBmb3IgYWRkIGRvZXMgbm90IHN1cHBvcnQgdHdvIGFyZ3VtZW50cyAoZGF0YSxjYWxsYmFjayknKTtcbiAgICAgICAgICAgIHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZGF0YS5ub2Rlcy5nZXREYXRhU2V0KCkuYWRkKGRlZmF1bHREYXRhKTtcbiAgICAgICAgICB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGNvbm5lY3QgdHdvIG5vZGVzIHdpdGggYSBuZXcgZWRnZS5cbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfcGVyZm9ybUFkZEVkZ2UnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9wZXJmb3JtQWRkRWRnZShzb3VyY2VOb2RlSWQsIHRhcmdldE5vZGVJZCkge1xuICAgICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgICB2YXIgZGVmYXVsdERhdGEgPSB7IGZyb206IHNvdXJjZU5vZGVJZCwgdG86IHRhcmdldE5vZGVJZCB9O1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5hZGRFZGdlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hZGRFZGdlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmFkZEVkZ2UoZGVmYXVsdERhdGEsIGZ1bmN0aW9uIChmaW5hbGl6ZWREYXRhKSB7XG4gICAgICAgICAgICAgIGlmIChmaW5hbGl6ZWREYXRhICE9PSBudWxsICYmIGZpbmFsaXplZERhdGEgIT09IHVuZGVmaW5lZCAmJiBfdGhpczYuaW5Nb2RlID09PSAnYWRkRWRnZScpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBmb3Igd2hhdGV2ZXIgcmVhc29uIHRoZSBtb2RlIGhhcyBjaGFuZ2VzIChkdWUgdG8gZGF0YXNldCBjaGFuZ2UpIGRpc3JlZ2FyZCB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICBfdGhpczYuYm9keS5kYXRhLmVkZ2VzLmdldERhdGFTZXQoKS5hZGQoZmluYWxpemVkRGF0YSk7XG4gICAgICAgICAgICAgICAgX3RoaXM2LnNlbGVjdGlvbkhhbmRsZXIudW5zZWxlY3RBbGwoKTtcbiAgICAgICAgICAgICAgICBfdGhpczYuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZnVuY3Rpb24gZm9yIGNvbm5lY3QgZG9lcyBub3Qgc3VwcG9ydCB0d28gYXJndW1lbnRzIChkYXRhLGNhbGxiYWNrKScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZGF0YS5lZGdlcy5nZXREYXRhU2V0KCkuYWRkKGRlZmF1bHREYXRhKTtcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIudW5zZWxlY3RBbGwoKTtcbiAgICAgICAgICB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGNvbm5lY3QgdHdvIG5vZGVzIHdpdGggYSBuZXcgZWRnZS5cbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfcGVyZm9ybUVkaXRFZGdlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcGVyZm9ybUVkaXRFZGdlKHNvdXJjZU5vZGVJZCwgdGFyZ2V0Tm9kZUlkKSB7XG4gICAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHsgaWQ6IHRoaXMuZWRnZUJlaW5nRWRpdGVkSWQsIGZyb206IHNvdXJjZU5vZGVJZCwgdG86IHRhcmdldE5vZGVJZCB9O1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5lZGl0RWRnZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWRpdEVkZ2UubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZWRpdEVkZ2UoZGVmYXVsdERhdGEsIGZ1bmN0aW9uIChmaW5hbGl6ZWREYXRhKSB7XG4gICAgICAgICAgICAgIGlmIChmaW5hbGl6ZWREYXRhID09PSBudWxsIHx8IGZpbmFsaXplZERhdGEgPT09IHVuZGVmaW5lZCB8fCBfdGhpczcuaW5Nb2RlICE9PSAnZWRpdEVkZ2UnKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgZm9yIHdoYXRldmVyIHJlYXNvbiB0aGUgbW9kZSBoYXMgY2hhbmdlcyAoZHVlIHRvIGRhdGFzZXQgY2hhbmdlKSBkaXNyZWdhcmQgdGhlIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgX3RoaXM3LmJvZHkuZWRnZXNbZGVmYXVsdERhdGEuaWRdLnVwZGF0ZUVkZ2VUeXBlKCk7XG4gICAgICAgICAgICAgICAgX3RoaXM3LmJvZHkuZW1pdHRlci5lbWl0KCdfcmVkcmF3Jyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXM3LmJvZHkuZGF0YS5lZGdlcy5nZXREYXRhU2V0KCkudXBkYXRlKGZpbmFsaXplZERhdGEpO1xuICAgICAgICAgICAgICAgIF90aGlzNy5zZWxlY3Rpb25IYW5kbGVyLnVuc2VsZWN0QWxsKCk7XG4gICAgICAgICAgICAgICAgX3RoaXM3LnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGZ1bmN0aW9uIGZvciBlZGl0IGRvZXMgbm90IHN1cHBvcnQgdHdvIGFyZ3VtZW50cyAoZGF0YSwgY2FsbGJhY2spJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYm9keS5kYXRhLmVkZ2VzLmdldERhdGFTZXQoKS51cGRhdGUoZGVmYXVsdERhdGEpO1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci51bnNlbGVjdEFsbCgpO1xuICAgICAgICAgIHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIE1hbmlwdWxhdGlvblN5c3RlbTtcbiAgfSgpO1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IE1hbmlwdWxhdGlvblN5c3RlbTtcblxuLyoqKi8gfSxcbi8qIDExNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuICAvKipcbiAgICogVGhpcyBvYmplY3QgY29udGFpbnMgYWxsIHBvc3NpYmxlIG9wdGlvbnMuIEl0IHdpbGwgY2hlY2sgaWYgdGhlIHR5cGVzIGFyZSBjb3JyZWN0LCBpZiByZXF1aXJlZCBpZiB0aGUgb3B0aW9uIGlzIG9uZVxuICAgKiBvZiB0aGUgYWxsb3dlZCB2YWx1ZXMuXG4gICAqXG4gICAqIF9fYW55X18gbWVhbnMgdGhhdCB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgZG9lcyBub3QgbWF0dGVyLlxuICAgKiBfX3R5cGVfXyBpcyBhIHJlcXVpcmVkIGZpZWxkIGZvciBhbGwgb2JqZWN0cyBhbmQgY29udGFpbnMgdGhlIGFsbG93ZWQgdHlwZXMgb2YgYWxsIG9iamVjdHNcbiAgICovXG4gIHZhciBzdHJpbmcgPSAnc3RyaW5nJztcbiAgdmFyIGJvb2xlYW4gPSAnYm9vbGVhbic7XG4gIHZhciBudW1iZXIgPSAnbnVtYmVyJztcbiAgdmFyIGFycmF5ID0gJ2FycmF5JztcbiAgdmFyIG9iamVjdCA9ICdvYmplY3QnOyAvLyBzaG91bGQgb25seSBiZSBpbiBhIF9fdHlwZV9fIHByb3BlcnR5XG4gIHZhciBkb20gPSAnZG9tJztcbiAgdmFyIGFueSA9ICdhbnknO1xuXG4gIHZhciBhbGxPcHRpb25zID0ge1xuICAgIGNvbmZpZ3VyZToge1xuICAgICAgZW5hYmxlZDogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICBmaWx0ZXI6IHsgYm9vbGVhbjogYm9vbGVhbiwgc3RyaW5nOiBzdHJpbmcsIGFycmF5OiBhcnJheSwgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgICAgY29udGFpbmVyOiB7IGRvbTogZG9tIH0sXG4gICAgICBzaG93QnV0dG9uOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBib29sZWFuOiBib29sZWFuLCBzdHJpbmc6IHN0cmluZywgYXJyYXk6IGFycmF5LCAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH1cbiAgICB9LFxuICAgIGVkZ2VzOiB7XG4gICAgICBhcnJvd3M6IHtcbiAgICAgICAgdG86IHsgZW5hYmxlZDogeyBib29sZWFuOiBib29sZWFuIH0sIHNjYWxlRmFjdG9yOiB7IG51bWJlcjogbnVtYmVyIH0sIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBib29sZWFuOiBib29sZWFuIH0gfSxcbiAgICAgICAgbWlkZGxlOiB7IGVuYWJsZWQ6IHsgYm9vbGVhbjogYm9vbGVhbiB9LCBzY2FsZUZhY3RvcjogeyBudW1iZXI6IG51bWJlciB9LCBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgYm9vbGVhbjogYm9vbGVhbiB9IH0sXG4gICAgICAgIGZyb206IHsgZW5hYmxlZDogeyBib29sZWFuOiBib29sZWFuIH0sIHNjYWxlRmFjdG9yOiB7IG51bWJlcjogbnVtYmVyIH0sIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBib29sZWFuOiBib29sZWFuIH0gfSxcbiAgICAgICAgX190eXBlX186IHsgc3RyaW5nOiBbJ2Zyb20nLCAndG8nLCAnbWlkZGxlJ10sIG9iamVjdDogb2JqZWN0IH1cbiAgICAgIH0sXG4gICAgICBhcnJvd1N0cmlrZXRocm91Z2g6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgY29sb3I6IHtcbiAgICAgICAgY29sb3I6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgICAgaGlnaGxpZ2h0OiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgIGhvdmVyOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgIGluaGVyaXQ6IHsgc3RyaW5nOiBbJ2Zyb20nLCAndG8nLCAnYm90aCddLCBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICAgIG9wYWNpdHk6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIHN0cmluZzogc3RyaW5nIH1cbiAgICAgIH0sXG4gICAgICBkYXNoZXM6IHsgYm9vbGVhbjogYm9vbGVhbiwgYXJyYXk6IGFycmF5IH0sXG4gICAgICBmb250OiB7XG4gICAgICAgIGNvbG9yOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgIHNpemU6IHsgbnVtYmVyOiBudW1iZXIgfSwgLy8gcHhcbiAgICAgICAgZmFjZTogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgICBiYWNrZ3JvdW5kOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgIHN0cm9rZVdpZHRoOiB7IG51bWJlcjogbnVtYmVyIH0sIC8vIHB4XG4gICAgICAgIHN0cm9rZUNvbG9yOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgIGFsaWduOiB7IHN0cmluZzogWydob3Jpem9udGFsJywgJ3RvcCcsICdtaWRkbGUnLCAnYm90dG9tJ10gfSxcbiAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIHN0cmluZzogc3RyaW5nIH1cbiAgICAgIH0sXG4gICAgICBoaWRkZW46IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgaG92ZXJXaWR0aDogeyAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nLCBudW1iZXI6IG51bWJlciB9LFxuICAgICAgbGFiZWw6IHsgc3RyaW5nOiBzdHJpbmcsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgbGFiZWxIaWdobGlnaHRCb2xkOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgIGxlbmd0aDogeyBudW1iZXI6IG51bWJlciwgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICBwaHlzaWNzOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgIHNjYWxpbmc6IHtcbiAgICAgICAgbWluOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIG1heDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgIGVuYWJsZWQ6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgICAgIG1pbjogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICAgIG1heDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICAgIG1heFZpc2libGU6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgICBkcmF3VGhyZXNob2xkOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIGJvb2xlYW46IGJvb2xlYW4gfVxuICAgICAgICB9LFxuICAgICAgICBjdXN0b21TY2FsaW5nRnVuY3Rpb246IHsgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gICAgICB9LFxuICAgICAgc2VsZWN0aW9uV2lkdGg6IHsgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJywgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIHNlbGZSZWZlcmVuY2VTaXplOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICBzaGFkb3c6IHtcbiAgICAgICAgZW5hYmxlZDogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICAgIGNvbG9yOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgIHNpemU6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgeDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICB5OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBib29sZWFuOiBib29sZWFuIH1cbiAgICAgIH0sXG4gICAgICBzbW9vdGg6IHtcbiAgICAgICAgZW5hYmxlZDogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICAgIHR5cGU6IHsgc3RyaW5nOiBbJ2R5bmFtaWMnLCAnY29udGludW91cycsICdkaXNjcmV0ZScsICdkaWFnb25hbENyb3NzJywgJ3N0cmFpZ2h0Q3Jvc3MnLCAnaG9yaXpvbnRhbCcsICd2ZXJ0aWNhbCcsICdjdXJ2ZWRDVycsICdjdXJ2ZWRDQ1cnLCAnY3ViaWNCZXppZXInXSB9LFxuICAgICAgICByb3VuZG5lc3M6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgZm9yY2VEaXJlY3Rpb246IHsgc3RyaW5nOiBbJ2hvcml6b250YWwnLCAndmVydGljYWwnLCAnbm9uZSddLCBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBib29sZWFuOiBib29sZWFuIH1cbiAgICAgIH0sXG4gICAgICB0aXRsZTogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICB3aWR0aDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgdmFsdWU6IHsgbnVtYmVyOiBudW1iZXIsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICAgIH0sXG4gICAgZ3JvdXBzOiB7XG4gICAgICB1c2VEZWZhdWx0R3JvdXBzOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgIF9fYW55X186ICdnZXQgZnJvbSBub2Rlcywgd2lsbCBiZSBvdmVyd3JpdHRlbiBiZWxvdycsXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gICAgfSxcbiAgICBpbnRlcmFjdGlvbjoge1xuICAgICAgZHJhZ05vZGVzOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgIGRyYWdWaWV3OiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgIGhpZGVFZGdlc09uRHJhZzogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICBoaWRlTm9kZXNPbkRyYWc6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgaG92ZXI6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAga2V5Ym9hcmQ6IHtcbiAgICAgICAgZW5hYmxlZDogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICAgIHNwZWVkOiB7IHg6IHsgbnVtYmVyOiBudW1iZXIgfSwgeTogeyBudW1iZXI6IG51bWJlciB9LCB6b29tOiB7IG51bWJlcjogbnVtYmVyIH0sIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0IH0gfSxcbiAgICAgICAgYmluZFRvV2luZG93OiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIGJvb2xlYW46IGJvb2xlYW4gfVxuICAgICAgfSxcbiAgICAgIG11bHRpc2VsZWN0OiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgIG5hdmlnYXRpb25CdXR0b25zOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgIHNlbGVjdGFibGU6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgc2VsZWN0Q29ubmVjdGVkRWRnZXM6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgaG92ZXJDb25uZWN0ZWRFZGdlczogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICB0b29sdGlwRGVsYXk6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIHpvb21WaWV3OiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0IH1cbiAgICB9LFxuICAgIGxheW91dDoge1xuICAgICAgcmFuZG9tU2VlZDogeyAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcsIG51bWJlcjogbnVtYmVyIH0sXG4gICAgICBpbXByb3ZlZExheW91dDogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICBoaWVyYXJjaGljYWw6IHtcbiAgICAgICAgZW5hYmxlZDogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICAgIGxldmVsU2VwYXJhdGlvbjogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBub2RlU3BhY2luZzogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICB0cmVlU3BhY2luZzogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBibG9ja1NoaWZ0aW5nOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgICAgZWRnZU1pbmltaXphdGlvbjogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICAgIHBhcmVudENlbnRyYWxpemF0aW9uOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgICAgZGlyZWN0aW9uOiB7IHN0cmluZzogWydVRCcsICdEVScsICdMUicsICdSTCddIH0sIC8vIFVELCBEVSwgTFIsIFJMXG4gICAgICAgIHNvcnRNZXRob2Q6IHsgc3RyaW5nOiBbJ2h1YnNpemUnLCAnZGlyZWN0ZWQnXSB9LCAvLyBodWJzaXplLCBkaXJlY3RlZFxuICAgICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgYm9vbGVhbjogYm9vbGVhbiB9XG4gICAgICB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICAgIH0sXG4gICAgbWFuaXB1bGF0aW9uOiB7XG4gICAgICBlbmFibGVkOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgIGluaXRpYWxseUFjdGl2ZTogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICBhZGROb2RlOiB7IGJvb2xlYW46IGJvb2xlYW4sICdmdW5jdGlvbic6ICdmdW5jdGlvbicgfSxcbiAgICAgIGFkZEVkZ2U6IHsgYm9vbGVhbjogYm9vbGVhbiwgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgICAgZWRpdE5vZGU6IHsgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgICAgZWRpdEVkZ2U6IHsgYm9vbGVhbjogYm9vbGVhbiwgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyB9LFxuICAgICAgZGVsZXRlTm9kZTogeyBib29sZWFuOiBib29sZWFuLCAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nIH0sXG4gICAgICBkZWxldGVFZGdlOiB7IGJvb2xlYW46IGJvb2xlYW4sICdmdW5jdGlvbic6ICdmdW5jdGlvbicgfSxcbiAgICAgIGNvbnRyb2xOb2RlU3R5bGU6ICdnZXQgZnJvbSBub2Rlcywgd2lsbCBiZSBvdmVyd3JpdHRlbiBiZWxvdycsXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgYm9vbGVhbjogYm9vbGVhbiB9XG4gICAgfSxcbiAgICBub2Rlczoge1xuICAgICAgYm9yZGVyV2lkdGg6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIGJvcmRlcldpZHRoU2VsZWN0ZWQ6IHsgbnVtYmVyOiBudW1iZXIsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgYnJva2VuSW1hZ2U6IHsgc3RyaW5nOiBzdHJpbmcsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgY29sb3I6IHtcbiAgICAgICAgYm9yZGVyOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgIGJhY2tncm91bmQ6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgICAgYm9yZGVyOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgICAgYmFja2dyb3VuZDogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBzdHJpbmc6IHN0cmluZyB9XG4gICAgICAgIH0sXG4gICAgICAgIGhvdmVyOiB7XG4gICAgICAgICAgYm9yZGVyOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgICAgYmFja2dyb3VuZDogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBzdHJpbmc6IHN0cmluZyB9XG4gICAgICAgIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBzdHJpbmc6IHN0cmluZyB9XG4gICAgICB9LFxuICAgICAgZml4ZWQ6IHtcbiAgICAgICAgeDogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICAgIHk6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgYm9vbGVhbjogYm9vbGVhbiB9XG4gICAgICB9LFxuICAgICAgZm9udDoge1xuICAgICAgICBhbGlnbjogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgICBjb2xvcjogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgICBzaXplOiB7IG51bWJlcjogbnVtYmVyIH0sIC8vIHB4XG4gICAgICAgIGZhY2U6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgICAgYmFja2dyb3VuZDogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgICBzdHJva2VXaWR0aDogeyBudW1iZXI6IG51bWJlciB9LCAvLyBweFxuICAgICAgICBzdHJva2VDb2xvcjogeyBzdHJpbmc6IHN0cmluZyB9LFxuICAgICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgc3RyaW5nOiBzdHJpbmcgfVxuICAgICAgfSxcbiAgICAgIGdyb3VwOiB7IHN0cmluZzogc3RyaW5nLCBudW1iZXI6IG51bWJlciwgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICBoaWRkZW46IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgaWNvbjoge1xuICAgICAgICBmYWNlOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgICAgIGNvZGU6IHsgc3RyaW5nOiBzdHJpbmcgfSwgLy8nXFx1ZjAwNycsXG4gICAgICAgIHNpemU6IHsgbnVtYmVyOiBudW1iZXIgfSwgLy81MCxcbiAgICAgICAgY29sb3I6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICAgICAgfSxcbiAgICAgIGlkOiB7IHN0cmluZzogc3RyaW5nLCBudW1iZXI6IG51bWJlciB9LFxuICAgICAgaW1hZ2U6IHsgc3RyaW5nOiBzdHJpbmcsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LCAvLyAtLT4gVVJMXG4gICAgICBsYWJlbDogeyBzdHJpbmc6IHN0cmluZywgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnIH0sXG4gICAgICBsYWJlbEhpZ2hsaWdodEJvbGQ6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgbGV2ZWw6IHsgbnVtYmVyOiBudW1iZXIsICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJyB9LFxuICAgICAgbWFzczogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgcGh5c2ljczogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICBzY2FsaW5nOiB7XG4gICAgICAgIG1pbjogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBtYXg6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICBlbmFibGVkOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgICAgICBtaW46IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgICBtYXg6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgICBtYXhWaXNpYmxlOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgICAgZHJhd1RocmVzaG9sZDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBib29sZWFuOiBib29sZWFuIH1cbiAgICAgICAgfSxcbiAgICAgICAgY3VzdG9tU2NhbGluZ0Z1bmN0aW9uOiB7ICdmdW5jdGlvbic6ICdmdW5jdGlvbicgfSxcbiAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICAgICAgfSxcbiAgICAgIHNoYWRvdzoge1xuICAgICAgICBlbmFibGVkOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgICAgY29sb3I6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICAgICAgc2l6ZTogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICB4OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIHk6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QsIGJvb2xlYW46IGJvb2xlYW4gfVxuICAgICAgfSxcbiAgICAgIHNoYXBlOiB7IHN0cmluZzogWydlbGxpcHNlJywgJ2NpcmNsZScsICdkYXRhYmFzZScsICdib3gnLCAndGV4dCcsICdpbWFnZScsICdjaXJjdWxhckltYWdlJywgJ2RpYW1vbmQnLCAnZG90JywgJ3N0YXInLCAndHJpYW5nbGUnLCAndHJpYW5nbGVEb3duJywgJ3NxdWFyZScsICdpY29uJ10gfSxcbiAgICAgIHNoYXBlUHJvcGVydGllczoge1xuICAgICAgICBib3JkZXJEYXNoZXM6IHsgYm9vbGVhbjogYm9vbGVhbiwgYXJyYXk6IGFycmF5IH0sXG4gICAgICAgIGJvcmRlclJhZGl1czogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBpbnRlcnBvbGF0aW9uOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgICAgdXNlSW1hZ2VTaXplOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgICAgdXNlQm9yZGVyV2l0aEltYWdlOiB7IGJvb2xlYW46IGJvb2xlYW4gfSxcbiAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICAgICAgfSxcbiAgICAgIHNpemU6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIHRpdGxlOiB7IHN0cmluZzogc3RyaW5nLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgIHZhbHVlOiB7IG51bWJlcjogbnVtYmVyLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCcgfSxcbiAgICAgIHg6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIHk6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0IH1cbiAgICB9LFxuICAgIHBoeXNpY3M6IHtcbiAgICAgIGVuYWJsZWQ6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgYmFybmVzSHV0OiB7XG4gICAgICAgIGdyYXZpdGF0aW9uYWxDb25zdGFudDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBjZW50cmFsR3Jhdml0eTogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBzcHJpbmdMZW5ndGg6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgc3ByaW5nQ29uc3RhbnQ6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgZGFtcGluZzogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBhdm9pZE92ZXJsYXA6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICAgICAgfSxcbiAgICAgIGZvcmNlQXRsYXMyQmFzZWQ6IHtcbiAgICAgICAgZ3Jhdml0YXRpb25hbENvbnN0YW50OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIGNlbnRyYWxHcmF2aXR5OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIHNwcmluZ0xlbmd0aDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBzcHJpbmdDb25zdGFudDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBkYW1waW5nOiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIGF2b2lkT3ZlcmxhcDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gICAgICB9LFxuICAgICAgcmVwdWxzaW9uOiB7XG4gICAgICAgIGNlbnRyYWxHcmF2aXR5OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIHNwcmluZ0xlbmd0aDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBzcHJpbmdDb25zdGFudDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBub2RlRGlzdGFuY2U6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgZGFtcGluZzogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gICAgICB9LFxuICAgICAgaGllcmFyY2hpY2FsUmVwdWxzaW9uOiB7XG4gICAgICAgIGNlbnRyYWxHcmF2aXR5OiB7IG51bWJlcjogbnVtYmVyIH0sXG4gICAgICAgIHNwcmluZ0xlbmd0aDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBzcHJpbmdDb25zdGFudDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBub2RlRGlzdGFuY2U6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgZGFtcGluZzogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gICAgICB9LFxuICAgICAgbWF4VmVsb2NpdHk6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgIG1pblZlbG9jaXR5OiB7IG51bWJlcjogbnVtYmVyIH0sIC8vIHB4L3NcbiAgICAgIHNvbHZlcjogeyBzdHJpbmc6IFsnYmFybmVzSHV0JywgJ3JlcHVsc2lvbicsICdoaWVyYXJjaGljYWxSZXB1bHNpb24nLCAnZm9yY2VBdGxhczJCYXNlZCddIH0sXG4gICAgICBzdGFiaWxpemF0aW9uOiB7XG4gICAgICAgIGVuYWJsZWQ6IHsgYm9vbGVhbjogYm9vbGVhbiB9LFxuICAgICAgICBpdGVyYXRpb25zOiB7IG51bWJlcjogbnVtYmVyIH0sIC8vIG1heGltdW0gbnVtYmVyIG9mIGl0ZXJhdGlvbiB0byBzdGFiaWxpemVcbiAgICAgICAgdXBkYXRlSW50ZXJ2YWw6IHsgbnVtYmVyOiBudW1iZXIgfSxcbiAgICAgICAgb25seUR5bmFtaWNFZGdlczogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICAgIGZpdDogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7IG9iamVjdDogb2JqZWN0LCBib29sZWFuOiBib29sZWFuIH1cbiAgICAgIH0sXG4gICAgICB0aW1lc3RlcDogeyBudW1iZXI6IG51bWJlciB9LFxuICAgICAgYWRhcHRpdmVUaW1lc3RlcDogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCwgYm9vbGVhbjogYm9vbGVhbiB9XG4gICAgfSxcblxuICAgIC8vZ2xvYmFscyA6XG4gICAgYXV0b1Jlc2l6ZTogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgY2xpY2tUb1VzZTogeyBib29sZWFuOiBib29sZWFuIH0sXG4gICAgbG9jYWxlOiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgbG9jYWxlczoge1xuICAgICAgX19hbnlfXzogeyBhbnk6IGFueSB9LFxuICAgICAgX190eXBlX186IHsgb2JqZWN0OiBvYmplY3QgfVxuICAgIH0sXG4gICAgaGVpZ2h0OiB7IHN0cmluZzogc3RyaW5nIH0sXG4gICAgd2lkdGg6IHsgc3RyaW5nOiBzdHJpbmcgfSxcbiAgICBfX3R5cGVfXzogeyBvYmplY3Q6IG9iamVjdCB9XG4gIH07XG5cbiAgYWxsT3B0aW9ucy5ncm91cHMuX19hbnlfXyA9IGFsbE9wdGlvbnMubm9kZXM7XG4gIGFsbE9wdGlvbnMubWFuaXB1bGF0aW9uLmNvbnRyb2xOb2RlU3R5bGUgPSBhbGxPcHRpb25zLm5vZGVzO1xuXG4gIHZhciBjb25maWd1cmVPcHRpb25zID0ge1xuICAgIG5vZGVzOiB7XG4gICAgICBib3JkZXJXaWR0aDogWzEsIDAsIDEwLCAxXSxcbiAgICAgIGJvcmRlcldpZHRoU2VsZWN0ZWQ6IFsyLCAwLCAxMCwgMV0sXG4gICAgICBjb2xvcjoge1xuICAgICAgICBib3JkZXI6IFsnY29sb3InLCAnIzJCN0NFOSddLFxuICAgICAgICBiYWNrZ3JvdW5kOiBbJ2NvbG9yJywgJyM5N0MyRkMnXSxcbiAgICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgICAgYm9yZGVyOiBbJ2NvbG9yJywgJyMyQjdDRTknXSxcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBbJ2NvbG9yJywgJyNEMkU1RkYnXVxuICAgICAgICB9LFxuICAgICAgICBob3Zlcjoge1xuICAgICAgICAgIGJvcmRlcjogWydjb2xvcicsICcjMkI3Q0U5J10sXG4gICAgICAgICAgYmFja2dyb3VuZDogWydjb2xvcicsICcjRDJFNUZGJ11cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGZpeGVkOiB7XG4gICAgICAgIHg6IGZhbHNlLFxuICAgICAgICB5OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGZvbnQ6IHtcbiAgICAgICAgY29sb3I6IFsnY29sb3InLCAnIzM0MzQzNCddLFxuICAgICAgICBzaXplOiBbMTQsIDAsIDEwMCwgMV0sIC8vIHB4XG4gICAgICAgIGZhY2U6IFsnYXJpYWwnLCAndmVyZGFuYScsICd0YWhvbWEnXSxcbiAgICAgICAgYmFja2dyb3VuZDogWydjb2xvcicsICdub25lJ10sXG4gICAgICAgIHN0cm9rZVdpZHRoOiBbMCwgMCwgNTAsIDFdLCAvLyBweFxuICAgICAgICBzdHJva2VDb2xvcjogWydjb2xvcicsICcjZmZmZmZmJ11cbiAgICAgIH0sXG4gICAgICAvL2dyb3VwOiAnc3RyaW5nJyxcbiAgICAgIGhpZGRlbjogZmFsc2UsXG4gICAgICBsYWJlbEhpZ2hsaWdodEJvbGQ6IHRydWUsXG4gICAgICAvL2ljb246IHtcbiAgICAgIC8vICBmYWNlOiAnc3RyaW5nJywgIC8vJ0ZvbnRBd2Vzb21lJyxcbiAgICAgIC8vICBjb2RlOiAnc3RyaW5nJywgIC8vJ1xcdWYwMDcnLFxuICAgICAgLy8gIHNpemU6IFs1MCwgMCwgMjAwLCAxXSwgIC8vNTAsXG4gICAgICAvLyAgY29sb3I6IFsnY29sb3InLCcjMkI3Q0U5J10gICAvLycjYWEwMGZmJ1xuICAgICAgLy99LFxuICAgICAgLy9pbWFnZTogJ3N0cmluZycsIC8vIC0tPiBVUkxcbiAgICAgIHBoeXNpY3M6IHRydWUsXG4gICAgICBzY2FsaW5nOiB7XG4gICAgICAgIG1pbjogWzEwLCAwLCAyMDAsIDFdLFxuICAgICAgICBtYXg6IFszMCwgMCwgMjAwLCAxXSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICBtaW46IFsxNCwgMCwgMjAwLCAxXSxcbiAgICAgICAgICBtYXg6IFszMCwgMCwgMjAwLCAxXSxcbiAgICAgICAgICBtYXhWaXNpYmxlOiBbMzAsIDAsIDIwMCwgMV0sXG4gICAgICAgICAgZHJhd1RocmVzaG9sZDogWzUsIDAsIDIwLCAxXVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2hhZG93OiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBjb2xvcjogJ3JnYmEoMCwwLDAsMC41KScsXG4gICAgICAgIHNpemU6IFsxMCwgMCwgMjAsIDFdLFxuICAgICAgICB4OiBbNSwgLTMwLCAzMCwgMV0sXG4gICAgICAgIHk6IFs1LCAtMzAsIDMwLCAxXVxuICAgICAgfSxcbiAgICAgIHNoYXBlOiBbJ2VsbGlwc2UnLCAnYm94JywgJ2NpcmNsZScsICdkYXRhYmFzZScsICdkaWFtb25kJywgJ2RvdCcsICdzcXVhcmUnLCAnc3RhcicsICd0ZXh0JywgJ3RyaWFuZ2xlJywgJ3RyaWFuZ2xlRG93biddLFxuICAgICAgc2hhcGVQcm9wZXJ0aWVzOiB7XG4gICAgICAgIGJvcmRlckRhc2hlczogZmFsc2UsXG4gICAgICAgIGJvcmRlclJhZGl1czogWzYsIDAsIDIwLCAxXSxcbiAgICAgICAgaW50ZXJwb2xhdGlvbjogdHJ1ZSxcbiAgICAgICAgdXNlSW1hZ2VTaXplOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHNpemU6IFsyNSwgMCwgMjAwLCAxXVxuICAgIH0sXG4gICAgZWRnZXM6IHtcbiAgICAgIGFycm93czoge1xuICAgICAgICB0bzogeyBlbmFibGVkOiBmYWxzZSwgc2NhbGVGYWN0b3I6IFsxLCAwLCAzLCAwLjA1XSB9LCAvLyBib29sZWFuIC8ge2Fycm93U2NhbGVGYWN0b3I6MX0gLyB7ZW5hYmxlZDogZmFsc2UsIGFycm93U2NhbGVGYWN0b3I6MX1cbiAgICAgICAgbWlkZGxlOiB7IGVuYWJsZWQ6IGZhbHNlLCBzY2FsZUZhY3RvcjogWzEsIDAsIDMsIDAuMDVdIH0sXG4gICAgICAgIGZyb206IHsgZW5hYmxlZDogZmFsc2UsIHNjYWxlRmFjdG9yOiBbMSwgMCwgMywgMC4wNV0gfVxuICAgICAgfSxcbiAgICAgIGFycm93U3RyaWtldGhyb3VnaDogdHJ1ZSxcbiAgICAgIGNvbG9yOiB7XG4gICAgICAgIGNvbG9yOiBbJ2NvbG9yJywgJyM4NDg0ODQnXSxcbiAgICAgICAgaGlnaGxpZ2h0OiBbJ2NvbG9yJywgJyM4NDg0ODQnXSxcbiAgICAgICAgaG92ZXI6IFsnY29sb3InLCAnIzg0ODQ4NCddLFxuICAgICAgICBpbmhlcml0OiBbJ2Zyb20nLCAndG8nLCAnYm90aCcsIHRydWUsIGZhbHNlXSxcbiAgICAgICAgb3BhY2l0eTogWzEsIDAsIDEsIDAuMDVdXG4gICAgICB9LFxuICAgICAgZGFzaGVzOiBmYWxzZSxcbiAgICAgIGZvbnQ6IHtcbiAgICAgICAgY29sb3I6IFsnY29sb3InLCAnIzM0MzQzNCddLFxuICAgICAgICBzaXplOiBbMTQsIDAsIDEwMCwgMV0sIC8vIHB4XG4gICAgICAgIGZhY2U6IFsnYXJpYWwnLCAndmVyZGFuYScsICd0YWhvbWEnXSxcbiAgICAgICAgYmFja2dyb3VuZDogWydjb2xvcicsICdub25lJ10sXG4gICAgICAgIHN0cm9rZVdpZHRoOiBbMiwgMCwgNTAsIDFdLCAvLyBweFxuICAgICAgICBzdHJva2VDb2xvcjogWydjb2xvcicsICcjZmZmZmZmJ10sXG4gICAgICAgIGFsaWduOiBbJ2hvcml6b250YWwnLCAndG9wJywgJ21pZGRsZScsICdib3R0b20nXVxuICAgICAgfSxcbiAgICAgIGhpZGRlbjogZmFsc2UsXG4gICAgICBob3ZlcldpZHRoOiBbMS41LCAwLCA1LCAwLjFdLFxuICAgICAgbGFiZWxIaWdobGlnaHRCb2xkOiB0cnVlLFxuICAgICAgcGh5c2ljczogdHJ1ZSxcbiAgICAgIHNjYWxpbmc6IHtcbiAgICAgICAgbWluOiBbMSwgMCwgMTAwLCAxXSxcbiAgICAgICAgbWF4OiBbMTUsIDAsIDEwMCwgMV0sXG4gICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICBtaW46IFsxNCwgMCwgMjAwLCAxXSxcbiAgICAgICAgICBtYXg6IFszMCwgMCwgMjAwLCAxXSxcbiAgICAgICAgICBtYXhWaXNpYmxlOiBbMzAsIDAsIDIwMCwgMV0sXG4gICAgICAgICAgZHJhd1RocmVzaG9sZDogWzUsIDAsIDIwLCAxXVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2VsZWN0aW9uV2lkdGg6IFsxLjUsIDAsIDUsIDAuMV0sXG4gICAgICBzZWxmUmVmZXJlbmNlU2l6ZTogWzIwLCAwLCAyMDAsIDFdLFxuICAgICAgc2hhZG93OiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBjb2xvcjogJ3JnYmEoMCwwLDAsMC41KScsXG4gICAgICAgIHNpemU6IFsxMCwgMCwgMjAsIDFdLFxuICAgICAgICB4OiBbNSwgLTMwLCAzMCwgMV0sXG4gICAgICAgIHk6IFs1LCAtMzAsIDMwLCAxXVxuICAgICAgfSxcbiAgICAgIHNtb290aDoge1xuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICB0eXBlOiBbJ2R5bmFtaWMnLCAnY29udGludW91cycsICdkaXNjcmV0ZScsICdkaWFnb25hbENyb3NzJywgJ3N0cmFpZ2h0Q3Jvc3MnLCAnaG9yaXpvbnRhbCcsICd2ZXJ0aWNhbCcsICdjdXJ2ZWRDVycsICdjdXJ2ZWRDQ1cnLCAnY3ViaWNCZXppZXInXSxcbiAgICAgICAgZm9yY2VEaXJlY3Rpb246IFsnaG9yaXpvbnRhbCcsICd2ZXJ0aWNhbCcsICdub25lJ10sXG4gICAgICAgIHJvdW5kbmVzczogWzAuNSwgMCwgMSwgMC4wNV1cbiAgICAgIH0sXG4gICAgICB3aWR0aDogWzEsIDAsIDMwLCAxXVxuICAgIH0sXG4gICAgbGF5b3V0OiB7XG4gICAgICAvL3JhbmRvbVNlZWQ6IFswLCAwLCA1MDAsIDFdLFxuICAgICAgLy9pbXByb3ZlZExheW91dDogdHJ1ZSxcbiAgICAgIGhpZXJhcmNoaWNhbDoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgbGV2ZWxTZXBhcmF0aW9uOiBbMTUwLCAyMCwgNTAwLCA1XSxcbiAgICAgICAgbm9kZVNwYWNpbmc6IFsxMDAsIDIwLCA1MDAsIDVdLFxuICAgICAgICB0cmVlU3BhY2luZzogWzIwMCwgMjAsIDUwMCwgNV0sXG4gICAgICAgIGJsb2NrU2hpZnRpbmc6IHRydWUsXG4gICAgICAgIGVkZ2VNaW5pbWl6YXRpb246IHRydWUsXG4gICAgICAgIHBhcmVudENlbnRyYWxpemF0aW9uOiB0cnVlLFxuICAgICAgICBkaXJlY3Rpb246IFsnVUQnLCAnRFUnLCAnTFInLCAnUkwnXSwgLy8gVUQsIERVLCBMUiwgUkxcbiAgICAgICAgc29ydE1ldGhvZDogWydodWJzaXplJywgJ2RpcmVjdGVkJ10gLy8gaHVic2l6ZSwgZGlyZWN0ZWRcbiAgICAgIH1cbiAgICB9LFxuICAgIGludGVyYWN0aW9uOiB7XG4gICAgICBkcmFnTm9kZXM6IHRydWUsXG4gICAgICBkcmFnVmlldzogdHJ1ZSxcbiAgICAgIGhpZGVFZGdlc09uRHJhZzogZmFsc2UsXG4gICAgICBoaWRlTm9kZXNPbkRyYWc6IGZhbHNlLFxuICAgICAgaG92ZXI6IGZhbHNlLFxuICAgICAga2V5Ym9hcmQ6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIHNwZWVkOiB7IHg6IFsxMCwgMCwgNDAsIDFdLCB5OiBbMTAsIDAsIDQwLCAxXSwgem9vbTogWzAuMDIsIDAsIDAuMSwgMC4wMDVdIH0sXG4gICAgICAgIGJpbmRUb1dpbmRvdzogdHJ1ZVxuICAgICAgfSxcbiAgICAgIG11bHRpc2VsZWN0OiBmYWxzZSxcbiAgICAgIG5hdmlnYXRpb25CdXR0b25zOiBmYWxzZSxcbiAgICAgIHNlbGVjdGFibGU6IHRydWUsXG4gICAgICBzZWxlY3RDb25uZWN0ZWRFZGdlczogdHJ1ZSxcbiAgICAgIGhvdmVyQ29ubmVjdGVkRWRnZXM6IHRydWUsXG4gICAgICB0b29sdGlwRGVsYXk6IFszMDAsIDAsIDEwMDAsIDI1XSxcbiAgICAgIHpvb21WaWV3OiB0cnVlXG4gICAgfSxcbiAgICBtYW5pcHVsYXRpb246IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgaW5pdGlhbGx5QWN0aXZlOiBmYWxzZVxuICAgIH0sXG4gICAgcGh5c2ljczoge1xuICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgIGJhcm5lc0h1dDoge1xuICAgICAgICAvL3RoZXRhOiBbMC41LCAwLjEsIDEsIDAuMDVdLFxuICAgICAgICBncmF2aXRhdGlvbmFsQ29uc3RhbnQ6IFstMjAwMCwgLTMwMDAwLCAwLCA1MF0sXG4gICAgICAgIGNlbnRyYWxHcmF2aXR5OiBbMC4zLCAwLCAxMCwgMC4wNV0sXG4gICAgICAgIHNwcmluZ0xlbmd0aDogWzk1LCAwLCA1MDAsIDVdLFxuICAgICAgICBzcHJpbmdDb25zdGFudDogWzAuMDQsIDAsIDEuMiwgMC4wMDVdLFxuICAgICAgICBkYW1waW5nOiBbMC4wOSwgMCwgMSwgMC4wMV0sXG4gICAgICAgIGF2b2lkT3ZlcmxhcDogWzAsIDAsIDEsIDAuMDFdXG4gICAgICB9LFxuICAgICAgZm9yY2VBdGxhczJCYXNlZDoge1xuICAgICAgICAvL3RoZXRhOiBbMC41LCAwLjEsIDEsIDAuMDVdLFxuICAgICAgICBncmF2aXRhdGlvbmFsQ29uc3RhbnQ6IFstNTAsIC01MDAsIDAsIDFdLFxuICAgICAgICBjZW50cmFsR3Jhdml0eTogWzAuMDEsIDAsIDEsIDAuMDA1XSxcbiAgICAgICAgc3ByaW5nTGVuZ3RoOiBbOTUsIDAsIDUwMCwgNV0sXG4gICAgICAgIHNwcmluZ0NvbnN0YW50OiBbMC4wOCwgMCwgMS4yLCAwLjAwNV0sXG4gICAgICAgIGRhbXBpbmc6IFswLjQsIDAsIDEsIDAuMDFdLFxuICAgICAgICBhdm9pZE92ZXJsYXA6IFswLCAwLCAxLCAwLjAxXVxuICAgICAgfSxcbiAgICAgIHJlcHVsc2lvbjoge1xuICAgICAgICBjZW50cmFsR3Jhdml0eTogWzAuMiwgMCwgMTAsIDAuMDVdLFxuICAgICAgICBzcHJpbmdMZW5ndGg6IFsyMDAsIDAsIDUwMCwgNV0sXG4gICAgICAgIHNwcmluZ0NvbnN0YW50OiBbMC4wNSwgMCwgMS4yLCAwLjAwNV0sXG4gICAgICAgIG5vZGVEaXN0YW5jZTogWzEwMCwgMCwgNTAwLCA1XSxcbiAgICAgICAgZGFtcGluZzogWzAuMDksIDAsIDEsIDAuMDFdXG4gICAgICB9LFxuICAgICAgaGllcmFyY2hpY2FsUmVwdWxzaW9uOiB7XG4gICAgICAgIGNlbnRyYWxHcmF2aXR5OiBbMC4yLCAwLCAxMCwgMC4wNV0sXG4gICAgICAgIHNwcmluZ0xlbmd0aDogWzEwMCwgMCwgNTAwLCA1XSxcbiAgICAgICAgc3ByaW5nQ29uc3RhbnQ6IFswLjAxLCAwLCAxLjIsIDAuMDA1XSxcbiAgICAgICAgbm9kZURpc3RhbmNlOiBbMTIwLCAwLCA1MDAsIDVdLFxuICAgICAgICBkYW1waW5nOiBbMC4wOSwgMCwgMSwgMC4wMV1cbiAgICAgIH0sXG4gICAgICBtYXhWZWxvY2l0eTogWzUwLCAwLCAxNTAsIDFdLFxuICAgICAgbWluVmVsb2NpdHk6IFswLjEsIDAuMDEsIDAuNSwgMC4wMV0sXG4gICAgICBzb2x2ZXI6IFsnYmFybmVzSHV0JywgJ2ZvcmNlQXRsYXMyQmFzZWQnLCAncmVwdWxzaW9uJywgJ2hpZXJhcmNoaWNhbFJlcHVsc2lvbiddLFxuICAgICAgdGltZXN0ZXA6IFswLjUsIDAuMDEsIDEsIDAuMDFdXG4gICAgfSxcbiAgICAvL2FkYXB0aXZlVGltZXN0ZXA6IHRydWVcbiAgICBnbG9iYWw6IHtcbiAgICAgIGxvY2FsZTogWydlbicsICdubCddXG4gICAgfVxuICB9O1xuXG4gIGV4cG9ydHMuYWxsT3B0aW9ucyA9IGFsbE9wdGlvbnM7XG4gIGV4cG9ydHMuY29uZmlndXJlT3B0aW9ucyA9IGNvbmZpZ3VyZU9wdGlvbnM7XG5cbi8qKiovIH0sXG4vKiAxMTUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpOyAvLyBkaXN0YW5jZSBmaW5kaW5nIGFsZ29yaXRobVxuXG5cbiAgdmFyIF9GbG95ZFdhcnNoYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTYpO1xuXG4gIHZhciBfRmxveWRXYXJzaGFsbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9GbG95ZFdhcnNoYWxsKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgLyoqXG4gICAqIEthbWFkYUthd2FpIHBvc2l0aW9ucyB0aGUgbm9kZXMgaW5pdGlhbGx5IGJhc2VkIG9uXG4gICAqXG4gICAqIFwiQU4gQUxHT1JJVEhNIEZPUiBEUkFXSU5HIEdFTkVSQUwgVU5ESVJFQ1RFRCBHUkFQSFNcIlxuICAgKiAtLSBUb21paGlzYSBLQU1BREEgYW5kIFNhdG9ydSBLQVdBSSBpbiAxOTg5XG4gICAqXG4gICAqIFBvc3NpYmxlIG9wdGltaXphdGlvbnMgaW4gdGhlIGRpc3RhbmNlIGNhbGN1bGF0aW9uIGNhbiBiZSBpbXBsZW1lbnRlZC5cbiAgICovXG5cbiAgdmFyIEthbWFkYUthd2FpID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEthbWFkYUthd2FpKGJvZHksIGVkZ2VMZW5ndGgsIGVkZ2VTdHJlbmd0aCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEthbWFkYUthd2FpKTtcblxuICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgIHRoaXMuc3ByaW5nTGVuZ3RoID0gZWRnZUxlbmd0aDtcbiAgICAgIHRoaXMuc3ByaW5nQ29uc3RhbnQgPSBlZGdlU3RyZW5ndGg7XG4gICAgICB0aGlzLmRpc3RhbmNlU29sdmVyID0gbmV3IF9GbG95ZFdhcnNoYWxsMi5kZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm90IHN1cmUgaWYgbmVlZGVkIGJ1dCBjYW4gYmUgdXNlZCB0byB1cGRhdGUgdGhlIHNwcmluZyBsZW5ndGggYW5kIHNwcmluZyBjb25zdGFudFxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhLYW1hZGFLYXdhaSwgW3tcbiAgICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuc3ByaW5nTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnNwcmluZ0xlbmd0aCA9IG9wdGlvbnMuc3ByaW5nTGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3B0aW9ucy5zcHJpbmdDb25zdGFudCkge1xuICAgICAgICAgICAgdGhpcy5zcHJpbmdDb25zdGFudCA9IG9wdGlvbnMuc3ByaW5nQ29uc3RhbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUG9zaXRpb24gdGhlIHN5c3RlbVxuICAgICAgICogQHBhcmFtIG5vZGVzQXJyYXlcbiAgICAgICAqIEBwYXJhbSBlZGdlc0FycmF5XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzb2x2ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNvbHZlKG5vZGVzQXJyYXksIGVkZ2VzQXJyYXkpIHtcbiAgICAgICAgdmFyIGlnbm9yZUNsdXN0ZXJzID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBhcmd1bWVudHNbMl07XG5cbiAgICAgICAgLy8gZ2V0IGRpc3RhbmNlIG1hdHJpeFxuICAgICAgICB2YXIgRF9tYXRyaXggPSB0aGlzLmRpc3RhbmNlU29sdmVyLmdldERpc3RhbmNlcyh0aGlzLmJvZHksIG5vZGVzQXJyYXksIGVkZ2VzQXJyYXkpOyAvLyBkaXN0YW5jZSBtYXRyaXhcblxuICAgICAgICAvLyBnZXQgdGhlIEwgTWF0cml4XG4gICAgICAgIHRoaXMuX2NyZWF0ZUxfbWF0cml4KERfbWF0cml4KTtcblxuICAgICAgICAvLyBnZXQgdGhlIEsgTWF0cml4XG4gICAgICAgIHRoaXMuX2NyZWF0ZUtfbWF0cml4KERfbWF0cml4KTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgcG9zaXRpb25zXG4gICAgICAgIHZhciB0aHJlc2hvbGQgPSAwLjAxO1xuICAgICAgICB2YXIgaW5uZXJUaHJlc2hvbGQgPSAxO1xuICAgICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICAgIHZhciBtYXhJdGVyYXRpb25zID0gTWF0aC5tYXgoMTAwMCwgTWF0aC5taW4oMTAgKiB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoLCA2MDAwKSk7XG4gICAgICAgIHZhciBtYXhJbm5lckl0ZXJhdGlvbnMgPSA1O1xuXG4gICAgICAgIHZhciBtYXhFbmVyZ3kgPSAxZTk7XG4gICAgICAgIHZhciBoaWdoRV9ub2RlSWQgPSAwLFxuICAgICAgICAgICAgZEVfZHggPSAwLFxuICAgICAgICAgICAgZEVfZHkgPSAwLFxuICAgICAgICAgICAgZGVsdGFfbSA9IDAsXG4gICAgICAgICAgICBzdWJJdGVyYXRpb25zID0gMDtcblxuICAgICAgICB3aGlsZSAobWF4RW5lcmd5ID4gdGhyZXNob2xkICYmIGl0ZXJhdGlvbnMgPCBtYXhJdGVyYXRpb25zKSB7XG4gICAgICAgICAgaXRlcmF0aW9ucyArPSAxO1xuXG4gICAgICAgICAgdmFyIF9nZXRIaWdoZXN0RW5lcmd5Tm9kZTIgPSB0aGlzLl9nZXRIaWdoZXN0RW5lcmd5Tm9kZShpZ25vcmVDbHVzdGVycyk7XG5cbiAgICAgICAgICB2YXIgX2dldEhpZ2hlc3RFbmVyZ3lOb2RlMyA9IF9zbGljZWRUb0FycmF5KF9nZXRIaWdoZXN0RW5lcmd5Tm9kZTIsIDQpO1xuXG4gICAgICAgICAgaGlnaEVfbm9kZUlkID0gX2dldEhpZ2hlc3RFbmVyZ3lOb2RlM1swXTtcbiAgICAgICAgICBtYXhFbmVyZ3kgPSBfZ2V0SGlnaGVzdEVuZXJneU5vZGUzWzFdO1xuICAgICAgICAgIGRFX2R4ID0gX2dldEhpZ2hlc3RFbmVyZ3lOb2RlM1syXTtcbiAgICAgICAgICBkRV9keSA9IF9nZXRIaWdoZXN0RW5lcmd5Tm9kZTNbM107XG5cbiAgICAgICAgICBkZWx0YV9tID0gbWF4RW5lcmd5O1xuICAgICAgICAgIHN1Ykl0ZXJhdGlvbnMgPSAwO1xuICAgICAgICAgIHdoaWxlIChkZWx0YV9tID4gaW5uZXJUaHJlc2hvbGQgJiYgc3ViSXRlcmF0aW9ucyA8IG1heElubmVySXRlcmF0aW9ucykge1xuICAgICAgICAgICAgc3ViSXRlcmF0aW9ucyArPSAxO1xuICAgICAgICAgICAgdGhpcy5fbW92ZU5vZGUoaGlnaEVfbm9kZUlkLCBkRV9keCwgZEVfZHkpO1xuXG4gICAgICAgICAgICB2YXIgX2dldEVuZXJneTIgPSB0aGlzLl9nZXRFbmVyZ3koaGlnaEVfbm9kZUlkKTtcblxuICAgICAgICAgICAgdmFyIF9nZXRFbmVyZ3kzID0gX3NsaWNlZFRvQXJyYXkoX2dldEVuZXJneTIsIDMpO1xuXG4gICAgICAgICAgICBkZWx0YV9tID0gX2dldEVuZXJneTNbMF07XG4gICAgICAgICAgICBkRV9keCA9IF9nZXRFbmVyZ3kzWzFdO1xuICAgICAgICAgICAgZEVfZHkgPSBfZ2V0RW5lcmd5M1syXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBnZXQgdGhlIG5vZGUgd2l0aCB0aGUgaGlnaGVzdCBlbmVyZ3lcbiAgICAgICAqIEByZXR1cm5zIHsqW119XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2dldEhpZ2hlc3RFbmVyZ3lOb2RlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEhpZ2hlc3RFbmVyZ3lOb2RlKGlnbm9yZUNsdXN0ZXJzKSB7XG4gICAgICAgIHZhciBub2Rlc0FycmF5ID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzO1xuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICAgIHZhciBtYXhFbmVyZ3kgPSAwO1xuICAgICAgICB2YXIgbWF4RW5lcmd5Tm9kZUlkID0gbm9kZXNBcnJheVswXTtcbiAgICAgICAgdmFyIGRFX2R4X21heCA9IDAsXG4gICAgICAgICAgICBkRV9keV9tYXggPSAwO1xuXG4gICAgICAgIGZvciAodmFyIG5vZGVJZHggPSAwOyBub2RlSWR4IDwgbm9kZXNBcnJheS5sZW5ndGg7IG5vZGVJZHgrKykge1xuICAgICAgICAgIHZhciBtID0gbm9kZXNBcnJheVtub2RlSWR4XTtcbiAgICAgICAgICAvLyBieSBub3QgZXZhbHVhdGluZyBub2RlcyB3aXRoIHByZWRlZmluZWQgcG9zaXRpb25zIHdlIHNob3VsZCBvbmx5IG1vdmUgbm9kZXMgdGhhdCBoYXZlIG5vIHBvc2l0aW9ucy5cbiAgICAgICAgICBpZiAobm9kZXNbbV0ucHJlZGVmaW5lZFBvc2l0aW9uID09PSBmYWxzZSB8fCBub2Rlc1ttXS5pc0NsdXN0ZXIgPT09IHRydWUgJiYgaWdub3JlQ2x1c3RlcnMgPT09IHRydWUgfHwgbm9kZXNbbV0ub3B0aW9ucy5maXhlZC54ID09PSB0cnVlIHx8IG5vZGVzW21dLm9wdGlvbnMuZml4ZWQueSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIF9nZXRFbmVyZ3k0ID0gdGhpcy5fZ2V0RW5lcmd5KG0pO1xuXG4gICAgICAgICAgICB2YXIgX2dldEVuZXJneTUgPSBfc2xpY2VkVG9BcnJheShfZ2V0RW5lcmd5NCwgMyk7XG5cbiAgICAgICAgICAgIHZhciBkZWx0YV9tID0gX2dldEVuZXJneTVbMF07XG4gICAgICAgICAgICB2YXIgZEVfZHggPSBfZ2V0RW5lcmd5NVsxXTtcbiAgICAgICAgICAgIHZhciBkRV9keSA9IF9nZXRFbmVyZ3k1WzJdO1xuXG4gICAgICAgICAgICBpZiAobWF4RW5lcmd5IDwgZGVsdGFfbSkge1xuICAgICAgICAgICAgICBtYXhFbmVyZ3kgPSBkZWx0YV9tO1xuICAgICAgICAgICAgICBtYXhFbmVyZ3lOb2RlSWQgPSBtO1xuICAgICAgICAgICAgICBkRV9keF9tYXggPSBkRV9keDtcbiAgICAgICAgICAgICAgZEVfZHlfbWF4ID0gZEVfZHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFttYXhFbmVyZ3lOb2RlSWQsIG1heEVuZXJneSwgZEVfZHhfbWF4LCBkRV9keV9tYXhdO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGNhbGN1bGF0ZSB0aGUgZW5lcmd5IG9mIGEgc2luZ2xlIG5vZGVcbiAgICAgICAqIEBwYXJhbSBtXG4gICAgICAgKiBAcmV0dXJucyB7KltdfVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9nZXRFbmVyZ3lcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RW5lcmd5KG0pIHtcbiAgICAgICAgdmFyIG5vZGVzQXJyYXkgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcblxuICAgICAgICB2YXIgeF9tID0gbm9kZXNbbV0ueDtcbiAgICAgICAgdmFyIHlfbSA9IG5vZGVzW21dLnk7XG4gICAgICAgIHZhciBkRV9keCA9IDA7XG4gICAgICAgIHZhciBkRV9keSA9IDA7XG4gICAgICAgIGZvciAodmFyIGlJZHggPSAwOyBpSWR4IDwgbm9kZXNBcnJheS5sZW5ndGg7IGlJZHgrKykge1xuICAgICAgICAgIHZhciBpID0gbm9kZXNBcnJheVtpSWR4XTtcbiAgICAgICAgICBpZiAoaSAhPT0gbSkge1xuICAgICAgICAgICAgdmFyIHhfaSA9IG5vZGVzW2ldLng7XG4gICAgICAgICAgICB2YXIgeV9pID0gbm9kZXNbaV0ueTtcbiAgICAgICAgICAgIHZhciBkZW5vbWluYXRvciA9IDEuMCAvIE1hdGguc3FydChNYXRoLnBvdyh4X20gLSB4X2ksIDIpICsgTWF0aC5wb3coeV9tIC0geV9pLCAyKSk7XG4gICAgICAgICAgICBkRV9keCArPSB0aGlzLktfbWF0cml4W21dW2ldICogKHhfbSAtIHhfaSAtIHRoaXMuTF9tYXRyaXhbbV1baV0gKiAoeF9tIC0geF9pKSAqIGRlbm9taW5hdG9yKTtcbiAgICAgICAgICAgIGRFX2R5ICs9IHRoaXMuS19tYXRyaXhbbV1baV0gKiAoeV9tIC0geV9pIC0gdGhpcy5MX21hdHJpeFttXVtpXSAqICh5X20gLSB5X2kpICogZGVub21pbmF0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZWx0YV9tID0gTWF0aC5zcXJ0KE1hdGgucG93KGRFX2R4LCAyKSArIE1hdGgucG93KGRFX2R5LCAyKSk7XG4gICAgICAgIHJldHVybiBbZGVsdGFfbSwgZEVfZHgsIGRFX2R5XTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBtb3ZlIHRoZSBub2RlIGJhc2VkIG9uIGl0J3MgZW5lcmd5XG4gICAgICAgKiB0aGUgZHggYW5kIGR5IGFyZSBjYWxjdWxhdGVkIGZyb20gdGhlIGxpbmVhciBzeXN0ZW0gcHJvcG9zZWQgYnkgS2FtYWRhIGFuZCBLYXdhaVxuICAgICAgICogQHBhcmFtIG1cbiAgICAgICAqIEBwYXJhbSBkRV9keFxuICAgICAgICogQHBhcmFtIGRFX2R5XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX21vdmVOb2RlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX21vdmVOb2RlKG0sIGRFX2R4LCBkRV9keSkge1xuICAgICAgICB2YXIgbm9kZXNBcnJheSA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcztcbiAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgICB2YXIgZDJFX2R4MiA9IDA7XG4gICAgICAgIHZhciBkMkVfZHhkeSA9IDA7XG4gICAgICAgIHZhciBkMkVfZHkyID0gMDtcblxuICAgICAgICB2YXIgeF9tID0gbm9kZXNbbV0ueDtcbiAgICAgICAgdmFyIHlfbSA9IG5vZGVzW21dLnk7XG4gICAgICAgIGZvciAodmFyIGlJZHggPSAwOyBpSWR4IDwgbm9kZXNBcnJheS5sZW5ndGg7IGlJZHgrKykge1xuICAgICAgICAgIHZhciBpID0gbm9kZXNBcnJheVtpSWR4XTtcbiAgICAgICAgICBpZiAoaSAhPT0gbSkge1xuICAgICAgICAgICAgdmFyIHhfaSA9IG5vZGVzW2ldLng7XG4gICAgICAgICAgICB2YXIgeV9pID0gbm9kZXNbaV0ueTtcbiAgICAgICAgICAgIHZhciBkZW5vbWluYXRvciA9IDEuMCAvIE1hdGgucG93KE1hdGgucG93KHhfbSAtIHhfaSwgMikgKyBNYXRoLnBvdyh5X20gLSB5X2ksIDIpLCAxLjUpO1xuICAgICAgICAgICAgZDJFX2R4MiArPSB0aGlzLktfbWF0cml4W21dW2ldICogKDEgLSB0aGlzLkxfbWF0cml4W21dW2ldICogTWF0aC5wb3coeV9tIC0geV9pLCAyKSAqIGRlbm9taW5hdG9yKTtcbiAgICAgICAgICAgIGQyRV9keGR5ICs9IHRoaXMuS19tYXRyaXhbbV1baV0gKiAodGhpcy5MX21hdHJpeFttXVtpXSAqICh4X20gLSB4X2kpICogKHlfbSAtIHlfaSkgKiBkZW5vbWluYXRvcik7XG4gICAgICAgICAgICBkMkVfZHkyICs9IHRoaXMuS19tYXRyaXhbbV1baV0gKiAoMSAtIHRoaXMuTF9tYXRyaXhbbV1baV0gKiBNYXRoLnBvdyh4X20gLSB4X2ksIDIpICogZGVub21pbmF0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBtYWtlIHRoZSB2YXJpYWJsZSBuYW1lcyBlYXNpZXIgdG8gbWFrZSB0aGUgc29sdmluZyBvZiB0aGUgbGluZWFyIHN5c3RlbSBlYXNpZXIgdG8gcmVhZFxuICAgICAgICB2YXIgQSA9IGQyRV9keDIsXG4gICAgICAgICAgICBCID0gZDJFX2R4ZHksXG4gICAgICAgICAgICBDID0gZEVfZHgsXG4gICAgICAgICAgICBEID0gZDJFX2R5MixcbiAgICAgICAgICAgIEUgPSBkRV9keTtcblxuICAgICAgICAvLyBzb2x2ZSB0aGUgbGluZWFyIHN5c3RlbSBmb3IgZHggYW5kIGR5XG4gICAgICAgIHZhciBkeSA9IChDIC8gQSArIEUgLyBCKSAvIChCIC8gQSAtIEQgLyBCKTtcbiAgICAgICAgdmFyIGR4ID0gLShCICogZHkgKyBDKSAvIEE7XG5cbiAgICAgICAgLy8gbW92ZSB0aGUgbm9kZVxuICAgICAgICBub2Rlc1ttXS54ICs9IGR4O1xuICAgICAgICBub2Rlc1ttXS55ICs9IGR5O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZSB0aGUgTCBtYXRyaXg6IGVkZ2UgbGVuZ3RoIHRpbWVzIHNob3J0ZXN0IHBhdGhcbiAgICAgICAqIEBwYXJhbSBEX21hdHJpeFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9jcmVhdGVMX21hdHJpeFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVMX21hdHJpeChEX21hdHJpeCkge1xuICAgICAgICB2YXIgbm9kZXNBcnJheSA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcztcbiAgICAgICAgdmFyIGVkZ2VMZW5ndGggPSB0aGlzLnNwcmluZ0xlbmd0aDtcblxuICAgICAgICB0aGlzLkxfbWF0cml4ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXNBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuTF9tYXRyaXhbbm9kZXNBcnJheVtpXV0gPSB7fTtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vZGVzQXJyYXkubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHRoaXMuTF9tYXRyaXhbbm9kZXNBcnJheVtpXV1bbm9kZXNBcnJheVtqXV0gPSBlZGdlTGVuZ3RoICogRF9tYXRyaXhbbm9kZXNBcnJheVtpXV1bbm9kZXNBcnJheVtqXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlIHRoZSBLIG1hdHJpeDogc3ByaW5nIGNvbnN0YW50cyB0aW1lcyBzaG9ydGVzdCBwYXRoXG4gICAgICAgKiBAcGFyYW0gRF9tYXRyaXhcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfY3JlYXRlS19tYXRyaXhcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlS19tYXRyaXgoRF9tYXRyaXgpIHtcbiAgICAgICAgdmFyIG5vZGVzQXJyYXkgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG4gICAgICAgIHZhciBlZGdlU3RyZW5ndGggPSB0aGlzLnNwcmluZ0NvbnN0YW50O1xuXG4gICAgICAgIHRoaXMuS19tYXRyaXggPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlc0FycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5LX21hdHJpeFtub2Rlc0FycmF5W2ldXSA9IHt9O1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm9kZXNBcnJheS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdGhpcy5LX21hdHJpeFtub2Rlc0FycmF5W2ldXVtub2Rlc0FycmF5W2pdXSA9IGVkZ2VTdHJlbmd0aCAqIE1hdGgucG93KERfbWF0cml4W25vZGVzQXJyYXlbaV1dW25vZGVzQXJyYXlbal1dLCAtMik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEthbWFkYUthd2FpO1xuICB9KCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gS2FtYWRhS2F3YWk7XG5cbi8qKiovIH0sXG4vKiAxMTYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICAvKipcbiAgICogQ3JlYXRlZCBieSBBbGV4IG9uIDEwLUF1Zy0xNS5cbiAgICovXG5cbiAgdmFyIEZsb3lkV2Fyc2hhbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRmxveWRXYXJzaGFsbCgpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGbG95ZFdhcnNoYWxsKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoRmxveWRXYXJzaGFsbCwgW3tcbiAgICAgIGtleTogXCJnZXREaXN0YW5jZXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREaXN0YW5jZXMoYm9keSwgbm9kZXNBcnJheSwgZWRnZXNBcnJheSkge1xuICAgICAgICB2YXIgRF9tYXRyaXggPSB7fTtcbiAgICAgICAgdmFyIGVkZ2VzID0gYm9keS5lZGdlcztcblxuICAgICAgICAvLyBwcmVwYXJlIG1hdHJpeCB3aXRoIGxhcmdlIG51bWJlcnNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlc0FycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgRF9tYXRyaXhbbm9kZXNBcnJheVtpXV0gPSB7fTtcbiAgICAgICAgICBEX21hdHJpeFtub2Rlc0FycmF5W2ldXSA9IHt9O1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm9kZXNBcnJheS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgRF9tYXRyaXhbbm9kZXNBcnJheVtpXV1bbm9kZXNBcnJheVtqXV0gPSBpID09IGogPyAwIDogMWU5O1xuICAgICAgICAgICAgRF9tYXRyaXhbbm9kZXNBcnJheVtpXV1bbm9kZXNBcnJheVtqXV0gPSBpID09IGogPyAwIDogMWU5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHB1dCB0aGUgd2VpZ2h0cyBmb3IgdGhlIGVkZ2VzIGluLiBUaGlzIGFzc3VtZXMgdW5pZGlyZWN0aW9uYWxpdHkuXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBlZGdlc0FycmF5Lmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIHZhciBlZGdlID0gZWRnZXNbZWRnZXNBcnJheVtfaV1dO1xuICAgICAgICAgIC8vIGVkZ2UgaGFzIHRvIGJlIGNvbm5lY3RlZCBpZiBpdCBjb3VudHMgdG8gdGhlIGRpc3RhbmNlcy4gSWYgaXQgaXMgY29ubmVjdGVkIHRvIGlubmVyIGNsdXN0ZXJzIGl0IHdpbGwgY3Jhc2ggc28gd2UgYWxzbyBjaGVjayBpZiBpdCBpcyBpbiB0aGUgRF9tYXRyaXhcbiAgICAgICAgICBpZiAoZWRnZS5jb25uZWN0ZWQgPT09IHRydWUgJiYgRF9tYXRyaXhbZWRnZS5mcm9tSWRdICE9PSB1bmRlZmluZWQgJiYgRF9tYXRyaXhbZWRnZS50b0lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBEX21hdHJpeFtlZGdlLmZyb21JZF1bZWRnZS50b0lkXSA9IDE7XG4gICAgICAgICAgICBEX21hdHJpeFtlZGdlLnRvSWRdW2VkZ2UuZnJvbUlkXSA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vZGVDb3VudCA9IG5vZGVzQXJyYXkubGVuZ3RoO1xuXG4gICAgICAgIC8vIEFkYXB0ZWQgRmxveWRXYXJzaGFsbCBiYXNlZCBvbiB1bmlkaXJlY3Rpb25hbGl0eSB0byBncmVhdGx5IHJlZHVjZSBjb21wbGV4aXR5LlxuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IG5vZGVDb3VudDsgaysrKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbm9kZUNvdW50IC0gMTsgX2kyKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9qID0gX2kyICsgMTsgX2ogPCBub2RlQ291bnQ7IF9qKyspIHtcbiAgICAgICAgICAgICAgRF9tYXRyaXhbbm9kZXNBcnJheVtfaTJdXVtub2Rlc0FycmF5W19qXV0gPSBNYXRoLm1pbihEX21hdHJpeFtub2Rlc0FycmF5W19pMl1dW25vZGVzQXJyYXlbX2pdXSwgRF9tYXRyaXhbbm9kZXNBcnJheVtfaTJdXVtub2Rlc0FycmF5W2tdXSArIERfbWF0cml4W25vZGVzQXJyYXlba11dW25vZGVzQXJyYXlbX2pdXSk7XG4gICAgICAgICAgICAgIERfbWF0cml4W25vZGVzQXJyYXlbX2pdXVtub2Rlc0FycmF5W19pMl1dID0gRF9tYXRyaXhbbm9kZXNBcnJheVtfaTJdXVtub2Rlc0FycmF5W19qXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIERfbWF0cml4O1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBGbG95ZFdhcnNoYWxsO1xuICB9KCk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gRmxveWRXYXJzaGFsbDtcblxuLyoqKi8gfSxcbi8qIDExNyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBDYW52YXMgc2hhcGVzIHVzZWQgYnkgTmV0d29ya1xuICAgKi9cbiAgaWYgKHR5cGVvZiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgIT09ICd1bmRlZmluZWQnKSB7XG5cbiAgICAvKipcbiAgICAgKiBEcmF3IGEgY2lyY2xlIHNoYXBlXG4gICAgICovXG4gICAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5jaXJjbGUgPSBmdW5jdGlvbiAoeCwgeSwgcikge1xuICAgICAgdGhpcy5iZWdpblBhdGgoKTtcbiAgICAgIHRoaXMuYXJjKHgsIHksIHIsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG4gICAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEcmF3IGEgc3F1YXJlIHNoYXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggaG9yaXpvbnRhbCBjZW50ZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSB2ZXJ0aWNhbCBjZW50ZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gciAgIHNpemUsIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIHNxdWFyZVxuICAgICAqL1xuICAgIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuc3F1YXJlID0gZnVuY3Rpb24gKHgsIHksIHIpIHtcbiAgICAgIHRoaXMuYmVnaW5QYXRoKCk7XG4gICAgICB0aGlzLnJlY3QoeCAtIHIsIHkgLSByLCByICogMiwgciAqIDIpO1xuICAgICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRHJhdyBhIHRyaWFuZ2xlIHNoYXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggaG9yaXpvbnRhbCBjZW50ZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSB2ZXJ0aWNhbCBjZW50ZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gciAgIHJhZGl1cywgaGFsZiB0aGUgbGVuZ3RoIG9mIHRoZSBzaWRlcyBvZiB0aGUgdHJpYW5nbGVcbiAgICAgKi9cbiAgICBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLnRyaWFuZ2xlID0gZnVuY3Rpb24gKHgsIHksIHIpIHtcbiAgICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXF1aWxhdGVyYWxfdHJpYW5nbGVcbiAgICAgIHRoaXMuYmVnaW5QYXRoKCk7XG5cbiAgICAgIC8vIHRoZSBjaGFuZ2UgaW4gcmFkaXVzIGFuZCB0aGUgb2Zmc2V0IGlzIGhlcmUgdG8gY2VudGVyIHRoZSBzaGFwZVxuICAgICAgciAqPSAxLjE1O1xuICAgICAgeSArPSAwLjI3NSAqIHI7XG5cbiAgICAgIHZhciBzID0gciAqIDI7XG4gICAgICB2YXIgczIgPSBzIC8gMjtcbiAgICAgIHZhciBpciA9IE1hdGguc3FydCgzKSAvIDYgKiBzOyAvLyByYWRpdXMgb2YgaW5uZXIgY2lyY2xlXG4gICAgICB2YXIgaCA9IE1hdGguc3FydChzICogcyAtIHMyICogczIpOyAvLyBoZWlnaHRcblxuICAgICAgdGhpcy5tb3ZlVG8oeCwgeSAtIChoIC0gaXIpKTtcbiAgICAgIHRoaXMubGluZVRvKHggKyBzMiwgeSArIGlyKTtcbiAgICAgIHRoaXMubGluZVRvKHggLSBzMiwgeSArIGlyKTtcbiAgICAgIHRoaXMubGluZVRvKHgsIHkgLSAoaCAtIGlyKSk7XG4gICAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEcmF3IGEgdHJpYW5nbGUgc2hhcGUgaW4gZG93bndhcmQgb3JpZW50YXRpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBob3Jpem9udGFsIGNlbnRlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IHZlcnRpY2FsIGNlbnRlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByIHJhZGl1c1xuICAgICAqL1xuICAgIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUudHJpYW5nbGVEb3duID0gZnVuY3Rpb24gKHgsIHksIHIpIHtcbiAgICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXF1aWxhdGVyYWxfdHJpYW5nbGVcbiAgICAgIHRoaXMuYmVnaW5QYXRoKCk7XG5cbiAgICAgIC8vIHRoZSBjaGFuZ2UgaW4gcmFkaXVzIGFuZCB0aGUgb2Zmc2V0IGlzIGhlcmUgdG8gY2VudGVyIHRoZSBzaGFwZVxuICAgICAgciAqPSAxLjE1O1xuICAgICAgeSAtPSAwLjI3NSAqIHI7XG5cbiAgICAgIHZhciBzID0gciAqIDI7XG4gICAgICB2YXIgczIgPSBzIC8gMjtcbiAgICAgIHZhciBpciA9IE1hdGguc3FydCgzKSAvIDYgKiBzOyAvLyByYWRpdXMgb2YgaW5uZXIgY2lyY2xlXG4gICAgICB2YXIgaCA9IE1hdGguc3FydChzICogcyAtIHMyICogczIpOyAvLyBoZWlnaHRcblxuICAgICAgdGhpcy5tb3ZlVG8oeCwgeSArIChoIC0gaXIpKTtcbiAgICAgIHRoaXMubGluZVRvKHggKyBzMiwgeSAtIGlyKTtcbiAgICAgIHRoaXMubGluZVRvKHggLSBzMiwgeSAtIGlyKTtcbiAgICAgIHRoaXMubGluZVRvKHgsIHkgKyAoaCAtIGlyKSk7XG4gICAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEcmF3IGEgc3RhciBzaGFwZSwgYSBzdGFyIHdpdGggNSBwb2ludHNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBob3Jpem9udGFsIGNlbnRlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IHZlcnRpY2FsIGNlbnRlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByICAgcmFkaXVzLCBoYWxmIHRoZSBsZW5ndGggb2YgdGhlIHNpZGVzIG9mIHRoZSB0cmlhbmdsZVxuICAgICAqL1xuICAgIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuc3RhciA9IGZ1bmN0aW9uICh4LCB5LCByKSB7XG4gICAgICAvLyBodHRwOi8vd3d3Lmh0bWw1Y2FudmFzdHV0b3JpYWxzLmNvbS9sYWJzL2h0bWw1LWNhbnZhcy1zdGFyLXNwaW5uZXIvXG4gICAgICB0aGlzLmJlZ2luUGF0aCgpO1xuXG4gICAgICAvLyB0aGUgY2hhbmdlIGluIHJhZGl1cyBhbmQgdGhlIG9mZnNldCBpcyBoZXJlIHRvIGNlbnRlciB0aGUgc2hhcGVcbiAgICAgIHIgKj0gMC44MjtcbiAgICAgIHkgKz0gMC4xICogcjtcblxuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCAxMDsgbisrKSB7XG4gICAgICAgIHZhciByYWRpdXMgPSBuICUgMiA9PT0gMCA/IHIgKiAxLjMgOiByICogMC41O1xuICAgICAgICB0aGlzLmxpbmVUbyh4ICsgcmFkaXVzICogTWF0aC5zaW4obiAqIDIgKiBNYXRoLlBJIC8gMTApLCB5IC0gcmFkaXVzICogTWF0aC5jb3MobiAqIDIgKiBNYXRoLlBJIC8gMTApKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRHJhdyBhIERpYW1vbmQgc2hhcGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBob3Jpem9udGFsIGNlbnRlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IHZlcnRpY2FsIGNlbnRlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByICAgcmFkaXVzLCBoYWxmIHRoZSBsZW5ndGggb2YgdGhlIHNpZGVzIG9mIHRoZSB0cmlhbmdsZVxuICAgICAqL1xuICAgIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuZGlhbW9uZCA9IGZ1bmN0aW9uICh4LCB5LCByKSB7XG4gICAgICAvLyBodHRwOi8vd3d3Lmh0bWw1Y2FudmFzdHV0b3JpYWxzLmNvbS9sYWJzL2h0bWw1LWNhbnZhcy1zdGFyLXNwaW5uZXIvXG4gICAgICB0aGlzLmJlZ2luUGF0aCgpO1xuXG4gICAgICB0aGlzLmxpbmVUbyh4LCB5ICsgcik7XG4gICAgICB0aGlzLmxpbmVUbyh4ICsgciwgeSk7XG4gICAgICB0aGlzLmxpbmVUbyh4LCB5IC0gcik7XG4gICAgICB0aGlzLmxpbmVUbyh4IC0gciwgeSk7XG5cbiAgICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTI1NTUxMi9ob3ctdG8tZHJhdy1hLXJvdW5kZWQtcmVjdGFuZ2xlLW9uLWh0bWwtY2FudmFzXG4gICAgICovXG4gICAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5yb3VuZFJlY3QgPSBmdW5jdGlvbiAoeCwgeSwgdywgaCwgcikge1xuICAgICAgdmFyIHIyZCA9IE1hdGguUEkgLyAxODA7XG4gICAgICBpZiAodyAtIDIgKiByIDwgMCkge1xuICAgICAgICByID0gdyAvIDI7XG4gICAgICB9IC8vZW5zdXJlIHRoYXQgdGhlIHJhZGl1cyBpc24ndCB0b28gbGFyZ2UgZm9yIHhcbiAgICAgIGlmIChoIC0gMiAqIHIgPCAwKSB7XG4gICAgICAgIHIgPSBoIC8gMjtcbiAgICAgIH0gLy9lbnN1cmUgdGhhdCB0aGUgcmFkaXVzIGlzbid0IHRvbyBsYXJnZSBmb3IgeVxuICAgICAgdGhpcy5iZWdpblBhdGgoKTtcbiAgICAgIHRoaXMubW92ZVRvKHggKyByLCB5KTtcbiAgICAgIHRoaXMubGluZVRvKHggKyB3IC0gciwgeSk7XG4gICAgICB0aGlzLmFyYyh4ICsgdyAtIHIsIHkgKyByLCByLCByMmQgKiAyNzAsIHIyZCAqIDM2MCwgZmFsc2UpO1xuICAgICAgdGhpcy5saW5lVG8oeCArIHcsIHkgKyBoIC0gcik7XG4gICAgICB0aGlzLmFyYyh4ICsgdyAtIHIsIHkgKyBoIC0gciwgciwgMCwgcjJkICogOTAsIGZhbHNlKTtcbiAgICAgIHRoaXMubGluZVRvKHggKyByLCB5ICsgaCk7XG4gICAgICB0aGlzLmFyYyh4ICsgciwgeSArIGggLSByLCByLCByMmQgKiA5MCwgcjJkICogMTgwLCBmYWxzZSk7XG4gICAgICB0aGlzLmxpbmVUbyh4LCB5ICsgcik7XG4gICAgICB0aGlzLmFyYyh4ICsgciwgeSArIHIsIHIsIHIyZCAqIDE4MCwgcjJkICogMjcwLCBmYWxzZSk7XG4gICAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIxNzI3OTgvaG93LXRvLWRyYXctYW4tb3ZhbC1pbi1odG1sNS1jYW52YXNcbiAgICAgKi9cbiAgICBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLmVsbGlwc2UgPSBmdW5jdGlvbiAoeCwgeSwgdywgaCkge1xuICAgICAgdmFyIGthcHBhID0gLjU1MjI4NDgsXG4gICAgICAgICAgb3ggPSB3IC8gMiAqIGthcHBhLFxuICAgICAgICAgIC8vIGNvbnRyb2wgcG9pbnQgb2Zmc2V0IGhvcml6b250YWxcbiAgICAgIG95ID0gaCAvIDIgKiBrYXBwYSxcbiAgICAgICAgICAvLyBjb250cm9sIHBvaW50IG9mZnNldCB2ZXJ0aWNhbFxuICAgICAgeGUgPSB4ICsgdyxcbiAgICAgICAgICAvLyB4LWVuZFxuICAgICAgeWUgPSB5ICsgaCxcbiAgICAgICAgICAvLyB5LWVuZFxuICAgICAgeG0gPSB4ICsgdyAvIDIsXG4gICAgICAgICAgLy8geC1taWRkbGVcbiAgICAgIHltID0geSArIGggLyAyOyAvLyB5LW1pZGRsZVxuXG4gICAgICB0aGlzLmJlZ2luUGF0aCgpO1xuICAgICAgdGhpcy5tb3ZlVG8oeCwgeW0pO1xuICAgICAgdGhpcy5iZXppZXJDdXJ2ZVRvKHgsIHltIC0gb3ksIHhtIC0gb3gsIHksIHhtLCB5KTtcbiAgICAgIHRoaXMuYmV6aWVyQ3VydmVUbyh4bSArIG94LCB5LCB4ZSwgeW0gLSBveSwgeGUsIHltKTtcbiAgICAgIHRoaXMuYmV6aWVyQ3VydmVUbyh4ZSwgeW0gKyBveSwgeG0gKyBveCwgeWUsIHhtLCB5ZSk7XG4gICAgICB0aGlzLmJlemllckN1cnZlVG8oeG0gLSBveCwgeWUsIHgsIHltICsgb3ksIHgsIHltKTtcbiAgICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjE3Mjc5OC9ob3ctdG8tZHJhdy1hbi1vdmFsLWluLWh0bWw1LWNhbnZhc1xuICAgICAqL1xuICAgIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuZGF0YWJhc2UgPSBmdW5jdGlvbiAoeCwgeSwgdywgaCkge1xuICAgICAgdmFyIGYgPSAxIC8gMztcbiAgICAgIHZhciB3RWxsaXBzZSA9IHc7XG4gICAgICB2YXIgaEVsbGlwc2UgPSBoICogZjtcblxuICAgICAgdmFyIGthcHBhID0gLjU1MjI4NDgsXG4gICAgICAgICAgb3ggPSB3RWxsaXBzZSAvIDIgKiBrYXBwYSxcbiAgICAgICAgICAvLyBjb250cm9sIHBvaW50IG9mZnNldCBob3Jpem9udGFsXG4gICAgICBveSA9IGhFbGxpcHNlIC8gMiAqIGthcHBhLFxuICAgICAgICAgIC8vIGNvbnRyb2wgcG9pbnQgb2Zmc2V0IHZlcnRpY2FsXG4gICAgICB4ZSA9IHggKyB3RWxsaXBzZSxcbiAgICAgICAgICAvLyB4LWVuZFxuICAgICAgeWUgPSB5ICsgaEVsbGlwc2UsXG4gICAgICAgICAgLy8geS1lbmRcbiAgICAgIHhtID0geCArIHdFbGxpcHNlIC8gMixcbiAgICAgICAgICAvLyB4LW1pZGRsZVxuICAgICAgeW0gPSB5ICsgaEVsbGlwc2UgLyAyLFxuICAgICAgICAgIC8vIHktbWlkZGxlXG4gICAgICB5bWIgPSB5ICsgKGggLSBoRWxsaXBzZSAvIDIpLFxuICAgICAgICAgIC8vIHktbWlkbGxlLCBib3R0b20gZWxsaXBzZVxuICAgICAgeWViID0geSArIGg7IC8vIHktZW5kLCBib3R0b20gZWxsaXBzZVxuXG4gICAgICB0aGlzLmJlZ2luUGF0aCgpO1xuICAgICAgdGhpcy5tb3ZlVG8oeGUsIHltKTtcblxuICAgICAgdGhpcy5iZXppZXJDdXJ2ZVRvKHhlLCB5bSArIG95LCB4bSArIG94LCB5ZSwgeG0sIHllKTtcbiAgICAgIHRoaXMuYmV6aWVyQ3VydmVUbyh4bSAtIG94LCB5ZSwgeCwgeW0gKyBveSwgeCwgeW0pO1xuXG4gICAgICB0aGlzLmJlemllckN1cnZlVG8oeCwgeW0gLSBveSwgeG0gLSBveCwgeSwgeG0sIHkpO1xuICAgICAgdGhpcy5iZXppZXJDdXJ2ZVRvKHhtICsgb3gsIHksIHhlLCB5bSAtIG95LCB4ZSwgeW0pO1xuXG4gICAgICB0aGlzLmxpbmVUbyh4ZSwgeW1iKTtcblxuICAgICAgdGhpcy5iZXppZXJDdXJ2ZVRvKHhlLCB5bWIgKyBveSwgeG0gKyBveCwgeWViLCB4bSwgeWViKTtcbiAgICAgIHRoaXMuYmV6aWVyQ3VydmVUbyh4bSAtIG94LCB5ZWIsIHgsIHltYiArIG95LCB4LCB5bWIpO1xuXG4gICAgICB0aGlzLmxpbmVUbyh4LCB5bSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERyYXcgYW4gYXJyb3cgcG9pbnQgKG5vIGxpbmUpXG4gICAgICovXG4gICAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5hcnJvdyA9IGZ1bmN0aW9uICh4LCB5LCBhbmdsZSwgbGVuZ3RoKSB7XG4gICAgICAvLyB0YWlsXG4gICAgICB2YXIgeHQgPSB4IC0gbGVuZ3RoICogTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgdmFyIHl0ID0geSAtIGxlbmd0aCAqIE1hdGguc2luKGFuZ2xlKTtcblxuICAgICAgLy8gaW5uZXIgdGFpbFxuICAgICAgdmFyIHhpID0geCAtIGxlbmd0aCAqIDAuOSAqIE1hdGguY29zKGFuZ2xlKTtcbiAgICAgIHZhciB5aSA9IHkgLSBsZW5ndGggKiAwLjkgKiBNYXRoLnNpbihhbmdsZSk7XG5cbiAgICAgIC8vIGxlZnRcbiAgICAgIHZhciB4bCA9IHh0ICsgbGVuZ3RoIC8gMyAqIE1hdGguY29zKGFuZ2xlICsgMC41ICogTWF0aC5QSSk7XG4gICAgICB2YXIgeWwgPSB5dCArIGxlbmd0aCAvIDMgKiBNYXRoLnNpbihhbmdsZSArIDAuNSAqIE1hdGguUEkpO1xuXG4gICAgICAvLyByaWdodFxuICAgICAgdmFyIHhyID0geHQgKyBsZW5ndGggLyAzICogTWF0aC5jb3MoYW5nbGUgLSAwLjUgKiBNYXRoLlBJKTtcbiAgICAgIHZhciB5ciA9IHl0ICsgbGVuZ3RoIC8gMyAqIE1hdGguc2luKGFuZ2xlIC0gMC41ICogTWF0aC5QSSk7XG5cbiAgICAgIHRoaXMuYmVnaW5QYXRoKCk7XG4gICAgICB0aGlzLm1vdmVUbyh4LCB5KTtcbiAgICAgIHRoaXMubGluZVRvKHhsLCB5bCk7XG4gICAgICB0aGlzLmxpbmVUbyh4aSwgeWkpO1xuICAgICAgdGhpcy5saW5lVG8oeHIsIHlyKTtcbiAgICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgdGhlIGRhc2hlZExpbmUgZnVuY3Rpb25hbGl0eSBmb3IgZHJhd2luZ1xuICAgICAqIE9yaWdpbmFsIGNvZGUgY2FtZSBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDU3NjcyNC9kb3R0ZWQtc3Ryb2tlLWluLWNhbnZhc1xuICAgICAqIEBhdXRob3IgRGF2aWQgSm9yZGFuXG4gICAgICogQGRhdGUgMjAxMi0wOC0wOFxuICAgICAqL1xuICAgIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuZGFzaGVkTGluZSA9IGZ1bmN0aW9uICh4LCB5LCB4MiwgeTIsIHBhdHRlcm4pIHtcbiAgICAgIHRoaXMuYmVnaW5QYXRoKCk7XG4gICAgICB0aGlzLm1vdmVUbyh4LCB5KTtcblxuICAgICAgdmFyIHBhdHRlcm5MZW5ndGggPSBwYXR0ZXJuLmxlbmd0aDtcbiAgICAgIHZhciBkeCA9IHgyIC0geDtcbiAgICAgIHZhciBkeSA9IHkyIC0geTtcbiAgICAgIHZhciBzbG9wZSA9IGR5IC8gZHg7XG4gICAgICB2YXIgZGlzdFJlbWFpbmluZyA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICB2YXIgcGF0dGVybkluZGV4ID0gMDtcbiAgICAgIHZhciBkcmF3ID0gdHJ1ZTtcbiAgICAgIHZhciB4U3RlcCA9IDA7XG4gICAgICB2YXIgZGFzaExlbmd0aCA9IHBhdHRlcm5bMF07XG5cbiAgICAgIHdoaWxlIChkaXN0UmVtYWluaW5nID49IDAuMSkge1xuICAgICAgICBkYXNoTGVuZ3RoID0gcGF0dGVybltwYXR0ZXJuSW5kZXgrKyAlIHBhdHRlcm5MZW5ndGhdO1xuICAgICAgICBpZiAoZGFzaExlbmd0aCA+IGRpc3RSZW1haW5pbmcpIHtcbiAgICAgICAgICBkYXNoTGVuZ3RoID0gZGlzdFJlbWFpbmluZztcbiAgICAgICAgfVxuXG4gICAgICAgIHhTdGVwID0gTWF0aC5zcXJ0KGRhc2hMZW5ndGggKiBkYXNoTGVuZ3RoIC8gKDEgKyBzbG9wZSAqIHNsb3BlKSk7XG4gICAgICAgIHhTdGVwID0gZHggPCAwID8gLXhTdGVwIDogeFN0ZXA7XG4gICAgICAgIHggKz0geFN0ZXA7XG4gICAgICAgIHkgKz0gc2xvcGUgKiB4U3RlcDtcblxuICAgICAgICBpZiAoZHJhdyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMubGluZVRvKHgsIHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubW92ZVRvKHgsIHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGlzdFJlbWFpbmluZyAtPSBkYXNoTGVuZ3RoO1xuICAgICAgICBkcmF3ID0gIWRyYXc7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4vKioqLyB9LFxuLyogMTE4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIFBhcnNlIGEgdGV4dCBzb3VyY2UgY29udGFpbmluZyBkYXRhIGluIERPVCBsYW5ndWFnZSBpbnRvIGEgSlNPTiBvYmplY3QuXG4gICAqIFRoZSBvYmplY3QgY29udGFpbnMgdHdvIGxpc3RzOiBvbmUgd2l0aCBub2RlcyBhbmQgb25lIHdpdGggZWRnZXMuXG4gICAqXG4gICAqIERPVCBsYW5ndWFnZSByZWZlcmVuY2U6IGh0dHA6Ly93d3cuZ3JhcGh2aXoub3JnL2RvYy9pbmZvL2xhbmcuaHRtbFxuICAgKlxuICAgKiBET1QgbGFuZ3VhZ2UgYXR0cmlidXRlczogaHR0cDovL2dyYXBodml6Lm9yZy9jb250ZW50L2F0dHJzXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhICAgICBUZXh0IGNvbnRhaW5pbmcgYSBncmFwaCBpbiBET1Qtbm90YXRpb25cbiAgICogQHJldHVybiB7T2JqZWN0fSBncmFwaCAgIEFuIG9iamVjdCBjb250YWluaW5nIHR3byBwYXJhbWV0ZXJzOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAge09iamVjdFtdfSBub2Rlc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAge09iamVjdFtdfSBlZGdlc1xuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VET1QoZGF0YSkge1xuICAgIGRvdCA9IGRhdGE7XG4gICAgcmV0dXJuIHBhcnNlR3JhcGgoKTtcbiAgfVxuXG4gIC8vIG1hcHBpbmcgb2YgYXR0cmlidXRlcyBmcm9tIERPVCAodGhlIGtleXMpIHRvIHZpcy5qcyAodGhlIHZhbHVlcylcbiAgdmFyIE5PREVfQVRUUl9NQVBQSU5HID0ge1xuICAgICdmb250c2l6ZSc6ICdmb250LnNpemUnLFxuICAgICdmb250Y29sb3InOiAnZm9udC5jb2xvcicsXG4gICAgJ2xhYmVsZm9udGNvbG9yJzogJ2ZvbnQuY29sb3InLFxuICAgICdmb250bmFtZSc6ICdmb250LmZhY2UnLFxuICAgICdjb2xvcic6IFsnY29sb3IuYm9yZGVyJywgJ2NvbG9yLmJhY2tncm91bmQnXSxcbiAgICAnZmlsbGNvbG9yJzogJ2NvbG9yLmJhY2tncm91bmQnLFxuICAgICd0b29sdGlwJzogJ3RpdGxlJyxcbiAgICAnbGFiZWx0b29sdGlwJzogJ3RpdGxlJ1xuICB9O1xuICB2YXIgRURHRV9BVFRSX01BUFBJTkcgPSBPYmplY3QuY3JlYXRlKE5PREVfQVRUUl9NQVBQSU5HKTtcbiAgRURHRV9BVFRSX01BUFBJTkcuY29sb3IgPSAnY29sb3IuY29sb3InO1xuXG4gIC8vIHRva2VuIHR5cGVzIGVudW1lcmF0aW9uXG4gIHZhciBUT0tFTlRZUEUgPSB7XG4gICAgTlVMTDogMCxcbiAgICBERUxJTUlURVI6IDEsXG4gICAgSURFTlRJRklFUjogMixcbiAgICBVTktOT1dOOiAzXG4gIH07XG5cbiAgLy8gbWFwIHdpdGggYWxsIGRlbGltaXRlcnNcbiAgdmFyIERFTElNSVRFUlMgPSB7XG4gICAgJ3snOiB0cnVlLFxuICAgICd9JzogdHJ1ZSxcbiAgICAnWyc6IHRydWUsXG4gICAgJ10nOiB0cnVlLFxuICAgICc7JzogdHJ1ZSxcbiAgICAnPSc6IHRydWUsXG4gICAgJywnOiB0cnVlLFxuXG4gICAgJy0+JzogdHJ1ZSxcbiAgICAnLS0nOiB0cnVlXG4gIH07XG5cbiAgdmFyIGRvdCA9ICcnOyAvLyBjdXJyZW50IGRvdCBmaWxlXG4gIHZhciBpbmRleCA9IDA7IC8vIGN1cnJlbnQgaW5kZXggaW4gZG90IGZpbGVcbiAgdmFyIGMgPSAnJzsgLy8gY3VycmVudCB0b2tlbiBjaGFyYWN0ZXIgaW4gZXhwclxuICB2YXIgdG9rZW4gPSAnJzsgLy8gY3VycmVudCB0b2tlblxuICB2YXIgdG9rZW5UeXBlID0gVE9LRU5UWVBFLk5VTEw7IC8vIHR5cGUgb2YgdGhlIHRva2VuXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZmlyc3QgY2hhcmFjdGVyIGZyb20gdGhlIGRvdCBmaWxlLlxuICAgKiBUaGUgY2hhcmFjdGVyIGlzIHN0b3JlZCBpbnRvIHRoZSBjaGFyIGMuIElmIHRoZSBlbmQgb2YgdGhlIGRvdCBmaWxlIGlzXG4gICAqIHJlYWNoZWQsIHRoZSBmdW5jdGlvbiBwdXRzIGFuIGVtcHR5IHN0cmluZyBpbiBjLlxuICAgKi9cbiAgZnVuY3Rpb24gZmlyc3QoKSB7XG4gICAgaW5kZXggPSAwO1xuICAgIGMgPSBkb3QuY2hhckF0KDApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmV4dCBjaGFyYWN0ZXIgZnJvbSB0aGUgZG90IGZpbGUuXG4gICAqIFRoZSBjaGFyYWN0ZXIgaXMgc3RvcmVkIGludG8gdGhlIGNoYXIgYy4gSWYgdGhlIGVuZCBvZiB0aGUgZG90IGZpbGUgaXNcbiAgICogcmVhY2hlZCwgdGhlIGZ1bmN0aW9uIHB1dHMgYW4gZW1wdHkgc3RyaW5nIGluIGMuXG4gICAqL1xuICBmdW5jdGlvbiBuZXh0KCkge1xuICAgIGluZGV4Kys7XG4gICAgYyA9IGRvdC5jaGFyQXQoaW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZXZpZXcgdGhlIG5leHQgY2hhcmFjdGVyIGZyb20gdGhlIGRvdCBmaWxlLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGNOZXh0XG4gICAqL1xuICBmdW5jdGlvbiBuZXh0UHJldmlldygpIHtcbiAgICByZXR1cm4gZG90LmNoYXJBdChpbmRleCArIDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRlc3Qgd2hldGhlciBnaXZlbiBjaGFyYWN0ZXIgaXMgYWxwaGFiZXRpYyBvciBudW1lcmljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGlzQWxwaGFOdW1lcmljXG4gICAqL1xuICB2YXIgcmVnZXhBbHBoYU51bWVyaWMgPSAvW2EtekEtWl8wLTkuOiNdLztcbiAgZnVuY3Rpb24gaXNBbHBoYU51bWVyaWMoYykge1xuICAgIHJldHVybiByZWdleEFscGhhTnVtZXJpYy50ZXN0KGMpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1lcmdlIGFsbCBvcHRpb25zIG9mIG9iamVjdCBiIGludG8gb2JqZWN0IGJcbiAgICogQHBhcmFtIHtPYmplY3R9IGFcbiAgICogQHBhcmFtIHtPYmplY3R9IGJcbiAgICogQHJldHVybiB7T2JqZWN0fSBhXG4gICAqL1xuICBmdW5jdGlvbiBtZXJnZShhLCBiKSB7XG4gICAgaWYgKCFhKSB7XG4gICAgICBhID0ge307XG4gICAgfVxuXG4gICAgaWYgKGIpIHtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gYikge1xuICAgICAgICBpZiAoYi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIGFbbmFtZV0gPSBiW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBhIHZhbHVlIGluIGFuIG9iamVjdCwgd2hlcmUgdGhlIHByb3ZpZGVkIHBhcmFtZXRlciBuYW1lIGNhbiBiZSBhXG4gICAqIHBhdGggd2l0aCBuZXN0ZWQgcGFyYW1ldGVycy4gRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqICAgICB2YXIgb2JqID0ge2E6IDJ9O1xuICAgKiAgICAgc2V0VmFsdWUob2JqLCAnYi5jJywgMyk7ICAgICAvLyBvYmogPSB7YTogMiwgYjoge2M6IDN9fVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoICBBIHBhcmFtZXRlciBuYW1lIG9yIGRvdC1zZXBhcmF0ZWQgcGFyYW1ldGVyIHBhdGgsXG4gICAqICAgICAgICAgICAgICAgICAgICAgIGxpa2UgXCJjb2xvci5oaWdobGlnaHQuYm9yZGVyXCIuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICovXG4gIGZ1bmN0aW9uIHNldFZhbHVlKG9iaiwgcGF0aCwgdmFsdWUpIHtcbiAgICB2YXIga2V5cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICB2YXIgbyA9IG9iajtcbiAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzLnNoaWZ0KCk7XG4gICAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgLy8gdGhpcyBpc24ndCB0aGUgZW5kIHBvaW50XG4gICAgICAgIGlmICghb1trZXldKSB7XG4gICAgICAgICAgb1trZXldID0ge307XG4gICAgICAgIH1cbiAgICAgICAgbyA9IG9ba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoaXMgaXMgdGhlIGVuZCBwb2ludFxuICAgICAgICBvW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgbm9kZSB0byBhIGdyYXBoIG9iamVjdC4gSWYgdGhlcmUgaXMgYWxyZWFkeSBhIG5vZGUgd2l0aFxuICAgKiB0aGUgc2FtZSBpZCwgdGhlaXIgYXR0cmlidXRlcyB3aWxsIGJlIG1lcmdlZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGdyYXBoXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXG4gICAqL1xuICBmdW5jdGlvbiBhZGROb2RlKGdyYXBoLCBub2RlKSB7XG4gICAgdmFyIGksIGxlbjtcbiAgICB2YXIgY3VycmVudCA9IG51bGw7XG5cbiAgICAvLyBmaW5kIHJvb3QgZ3JhcGggKGluIGNhc2Ugb2Ygc3ViZ3JhcGgpXG4gICAgdmFyIGdyYXBocyA9IFtncmFwaF07IC8vIGxpc3Qgd2l0aCBhbGwgZ3JhcGhzIGZyb20gY3VycmVudCBncmFwaCB0byByb290IGdyYXBoXG4gICAgdmFyIHJvb3QgPSBncmFwaDtcbiAgICB3aGlsZSAocm9vdC5wYXJlbnQpIHtcbiAgICAgIGdyYXBocy5wdXNoKHJvb3QucGFyZW50KTtcbiAgICAgIHJvb3QgPSByb290LnBhcmVudDtcbiAgICB9XG5cbiAgICAvLyBmaW5kIGV4aXN0aW5nIG5vZGUgKGF0IHJvb3QgbGV2ZWwpIGJ5IGl0cyBpZFxuICAgIGlmIChyb290Lm5vZGVzKSB7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSByb290Lm5vZGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChub2RlLmlkID09PSByb290Lm5vZGVzW2ldLmlkKSB7XG4gICAgICAgICAgY3VycmVudCA9IHJvb3Qubm9kZXNbaV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgIC8vIHRoaXMgaXMgYSBuZXcgbm9kZVxuICAgICAgY3VycmVudCA9IHtcbiAgICAgICAgaWQ6IG5vZGUuaWRcbiAgICAgIH07XG4gICAgICBpZiAoZ3JhcGgubm9kZSkge1xuICAgICAgICAvLyBjbG9uZSBkZWZhdWx0IGF0dHJpYnV0ZXNcbiAgICAgICAgY3VycmVudC5hdHRyID0gbWVyZ2UoY3VycmVudC5hdHRyLCBncmFwaC5ub2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhZGQgbm9kZSB0byB0aGlzIChzdWIpZ3JhcGggYW5kIGFsbCBpdHMgcGFyZW50IGdyYXBoc1xuICAgIGZvciAoaSA9IGdyYXBocy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGcgPSBncmFwaHNbaV07XG5cbiAgICAgIGlmICghZy5ub2Rlcykge1xuICAgICAgICBnLm5vZGVzID0gW107XG4gICAgICB9XG4gICAgICBpZiAoZy5ub2Rlcy5pbmRleE9mKGN1cnJlbnQpID09PSAtMSkge1xuICAgICAgICBnLm5vZGVzLnB1c2goY3VycmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gbWVyZ2UgYXR0cmlidXRlc1xuICAgIGlmIChub2RlLmF0dHIpIHtcbiAgICAgIGN1cnJlbnQuYXR0ciA9IG1lcmdlKGN1cnJlbnQuYXR0ciwgbm9kZS5hdHRyKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkIGFuIGVkZ2UgdG8gYSBncmFwaCBvYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IGdyYXBoXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlZGdlXG4gICAqL1xuICBmdW5jdGlvbiBhZGRFZGdlKGdyYXBoLCBlZGdlKSB7XG4gICAgaWYgKCFncmFwaC5lZGdlcykge1xuICAgICAgZ3JhcGguZWRnZXMgPSBbXTtcbiAgICB9XG4gICAgZ3JhcGguZWRnZXMucHVzaChlZGdlKTtcbiAgICBpZiAoZ3JhcGguZWRnZSkge1xuICAgICAgdmFyIGF0dHIgPSBtZXJnZSh7fSwgZ3JhcGguZWRnZSk7IC8vIGNsb25lIGRlZmF1bHQgYXR0cmlidXRlc1xuICAgICAgZWRnZS5hdHRyID0gbWVyZ2UoYXR0ciwgZWRnZS5hdHRyKTsgLy8gbWVyZ2UgYXR0cmlidXRlc1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gZWRnZSB0byBhIGdyYXBoIG9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gZ3JhcGhcbiAgICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXIgfCBPYmplY3R9IGZyb21cbiAgICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXIgfCBPYmplY3R9IHRvXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0IHwgbnVsbH0gYXR0clxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGVkZ2VcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUVkZ2UoZ3JhcGgsIGZyb20sIHRvLCB0eXBlLCBhdHRyKSB7XG4gICAgdmFyIGVkZ2UgPSB7XG4gICAgICBmcm9tOiBmcm9tLFxuICAgICAgdG86IHRvLFxuICAgICAgdHlwZTogdHlwZVxuICAgIH07XG5cbiAgICBpZiAoZ3JhcGguZWRnZSkge1xuICAgICAgZWRnZS5hdHRyID0gbWVyZ2Uoe30sIGdyYXBoLmVkZ2UpOyAvLyBjbG9uZSBkZWZhdWx0IGF0dHJpYnV0ZXNcbiAgICB9XG4gICAgZWRnZS5hdHRyID0gbWVyZ2UoZWRnZS5hdHRyIHx8IHt9LCBhdHRyKTsgLy8gbWVyZ2UgYXR0cmlidXRlc1xuXG4gICAgcmV0dXJuIGVkZ2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0IG5leHQgdG9rZW4gaW4gdGhlIGN1cnJlbnQgZG90IGZpbGUuXG4gICAqIFRoZSB0b2tlbiBhbmQgdG9rZW4gdHlwZSBhcmUgYXZhaWxhYmxlIGFzIHRva2VuIGFuZCB0b2tlblR5cGVcbiAgICovXG4gIGZ1bmN0aW9uIGdldFRva2VuKCkge1xuICAgIHRva2VuVHlwZSA9IFRPS0VOVFlQRS5OVUxMO1xuICAgIHRva2VuID0gJyc7XG5cbiAgICAvLyBza2lwIG92ZXIgd2hpdGVzcGFjZXNcbiAgICB3aGlsZSAoYyA9PT0gJyAnIHx8IGMgPT09ICdcXHQnIHx8IGMgPT09ICdcXG4nIHx8IGMgPT09ICdcXHInKSB7XG4gICAgICAvLyBzcGFjZSwgdGFiLCBlbnRlclxuICAgICAgbmV4dCgpO1xuICAgIH1cblxuICAgIGRvIHtcbiAgICAgIHZhciBpc0NvbW1lbnQgPSBmYWxzZTtcblxuICAgICAgLy8gc2tpcCBjb21tZW50XG4gICAgICBpZiAoYyA9PT0gJyMnKSB7XG4gICAgICAgIC8vIGZpbmQgdGhlIHByZXZpb3VzIG5vbi1zcGFjZSBjaGFyYWN0ZXJcbiAgICAgICAgdmFyIGkgPSBpbmRleCAtIDE7XG4gICAgICAgIHdoaWxlIChkb3QuY2hhckF0KGkpID09PSAnICcgfHwgZG90LmNoYXJBdChpKSA9PT0gJ1xcdCcpIHtcbiAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvdC5jaGFyQXQoaSkgPT09ICdcXG4nIHx8IGRvdC5jaGFyQXQoaSkgPT09ICcnKSB7XG4gICAgICAgICAgLy8gdGhlICMgaXMgYXQgdGhlIHN0YXJ0IG9mIGEgbGluZSwgdGhpcyBpcyBpbmRlZWQgYSBsaW5lIGNvbW1lbnRcbiAgICAgICAgICB3aGlsZSAoYyAhPSAnJyAmJiBjICE9ICdcXG4nKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzQ29tbWVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjID09PSAnLycgJiYgbmV4dFByZXZpZXcoKSA9PT0gJy8nKSB7XG4gICAgICAgIC8vIHNraXAgbGluZSBjb21tZW50XG4gICAgICAgIHdoaWxlIChjICE9ICcnICYmIGMgIT0gJ1xcbicpIHtcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaXNDb21tZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjID09PSAnLycgJiYgbmV4dFByZXZpZXcoKSA9PT0gJyonKSB7XG4gICAgICAgIC8vIHNraXAgYmxvY2sgY29tbWVudFxuICAgICAgICB3aGlsZSAoYyAhPSAnJykge1xuICAgICAgICAgIGlmIChjID09PSAnKicgJiYgbmV4dFByZXZpZXcoKSA9PT0gJy8nKSB7XG4gICAgICAgICAgICAvLyBlbmQgb2YgYmxvY2sgY29tbWVudCBmb3VuZC4gc2tpcCB0aGVzZSBsYXN0IHR3byBjaGFyYWN0ZXJzXG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpc0NvbW1lbnQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBza2lwIG92ZXIgd2hpdGVzcGFjZXNcbiAgICAgIHdoaWxlIChjID09PSAnICcgfHwgYyA9PT0gJ1xcdCcgfHwgYyA9PT0gJ1xcbicgfHwgYyA9PT0gJ1xccicpIHtcbiAgICAgICAgLy8gc3BhY2UsIHRhYiwgZW50ZXJcbiAgICAgICAgbmV4dCgpO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKGlzQ29tbWVudCk7XG5cbiAgICAvLyBjaGVjayBmb3IgZW5kIG9mIGRvdCBmaWxlXG4gICAgaWYgKGMgPT09ICcnKSB7XG4gICAgICAvLyB0b2tlbiBpcyBzdGlsbCBlbXB0eVxuICAgICAgdG9rZW5UeXBlID0gVE9LRU5UWVBFLkRFTElNSVRFUjtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBmb3IgZGVsaW1pdGVycyBjb25zaXN0aW5nIG9mIDIgY2hhcmFjdGVyc1xuICAgIHZhciBjMiA9IGMgKyBuZXh0UHJldmlldygpO1xuICAgIGlmIChERUxJTUlURVJTW2MyXSkge1xuICAgICAgdG9rZW5UeXBlID0gVE9LRU5UWVBFLkRFTElNSVRFUjtcbiAgICAgIHRva2VuID0gYzI7XG4gICAgICBuZXh0KCk7XG4gICAgICBuZXh0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgZm9yIGRlbGltaXRlcnMgY29uc2lzdGluZyBvZiAxIGNoYXJhY3RlclxuICAgIGlmIChERUxJTUlURVJTW2NdKSB7XG4gICAgICB0b2tlblR5cGUgPSBUT0tFTlRZUEUuREVMSU1JVEVSO1xuICAgICAgdG9rZW4gPSBjO1xuICAgICAgbmV4dCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGZvciBhbiBpZGVudGlmaWVyIChudW1iZXIgb3Igc3RyaW5nKVxuICAgIC8vIFRPRE86IG1vcmUgcHJlY2lzZSBwYXJzaW5nIG9mIG51bWJlcnMvc3RyaW5ncyAoYW5kIHRoZSBwb3J0IHNlcGFyYXRvciAnOicpXG4gICAgaWYgKGlzQWxwaGFOdW1lcmljKGMpIHx8IGMgPT09ICctJykge1xuICAgICAgdG9rZW4gKz0gYztcbiAgICAgIG5leHQoKTtcblxuICAgICAgd2hpbGUgKGlzQWxwaGFOdW1lcmljKGMpKSB7XG4gICAgICAgIHRva2VuICs9IGM7XG4gICAgICAgIG5leHQoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0b2tlbiA9PT0gJ2ZhbHNlJykge1xuICAgICAgICB0b2tlbiA9IGZhbHNlOyAvLyBjb252ZXJ0IHRvIGJvb2xlYW5cbiAgICAgIH0gZWxzZSBpZiAodG9rZW4gPT09ICd0cnVlJykge1xuICAgICAgICAgIHRva2VuID0gdHJ1ZTsgLy8gY29udmVydCB0byBib29sZWFuXG4gICAgICAgIH0gZWxzZSBpZiAoIWlzTmFOKE51bWJlcih0b2tlbikpKSB7XG4gICAgICAgICAgICB0b2tlbiA9IE51bWJlcih0b2tlbik7IC8vIGNvbnZlcnQgdG8gbnVtYmVyXG4gICAgICAgICAgfVxuICAgICAgdG9rZW5UeXBlID0gVE9LRU5UWVBFLklERU5USUZJRVI7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgZm9yIGEgc3RyaW5nIGVuY2xvc2VkIGJ5IGRvdWJsZSBxdW90ZXNcbiAgICBpZiAoYyA9PT0gJ1wiJykge1xuICAgICAgbmV4dCgpO1xuICAgICAgd2hpbGUgKGMgIT0gJycgJiYgKGMgIT0gJ1wiJyB8fCBjID09PSAnXCInICYmIG5leHRQcmV2aWV3KCkgPT09ICdcIicpKSB7XG4gICAgICAgIHRva2VuICs9IGM7XG4gICAgICAgIGlmIChjID09PSAnXCInKSB7XG4gICAgICAgICAgLy8gc2tpcCB0aGUgZXNjYXBlIGNoYXJhY3RlclxuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0KCk7XG4gICAgICB9XG4gICAgICBpZiAoYyAhPSAnXCInKSB7XG4gICAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKCdFbmQgb2Ygc3RyaW5nIFwiIGV4cGVjdGVkJyk7XG4gICAgICB9XG4gICAgICBuZXh0KCk7XG4gICAgICB0b2tlblR5cGUgPSBUT0tFTlRZUEUuSURFTlRJRklFUjtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBzb21ldGhpbmcgdW5rbm93biBpcyBmb3VuZCwgd3JvbmcgY2hhcmFjdGVycywgYSBzeW50YXggZXJyb3JcbiAgICB0b2tlblR5cGUgPSBUT0tFTlRZUEUuVU5LTk9XTjtcbiAgICB3aGlsZSAoYyAhPSAnJykge1xuICAgICAgdG9rZW4gKz0gYztcbiAgICAgIG5leHQoKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdTeW50YXggZXJyb3IgaW4gcGFydCBcIicgKyBjaG9wKHRva2VuLCAzMCkgKyAnXCInKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBhIGdyYXBoLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBncmFwaFxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VHcmFwaCgpIHtcbiAgICB2YXIgZ3JhcGggPSB7fTtcblxuICAgIGZpcnN0KCk7XG4gICAgZ2V0VG9rZW4oKTtcblxuICAgIC8vIG9wdGlvbmFsIHN0cmljdCBrZXl3b3JkXG4gICAgaWYgKHRva2VuID09PSAnc3RyaWN0Jykge1xuICAgICAgZ3JhcGguc3RyaWN0ID0gdHJ1ZTtcbiAgICAgIGdldFRva2VuKCk7XG4gICAgfVxuXG4gICAgLy8gZ3JhcGggb3IgZGlncmFwaCBrZXl3b3JkXG4gICAgaWYgKHRva2VuID09PSAnZ3JhcGgnIHx8IHRva2VuID09PSAnZGlncmFwaCcpIHtcbiAgICAgIGdyYXBoLnR5cGUgPSB0b2tlbjtcbiAgICAgIGdldFRva2VuKCk7XG4gICAgfVxuXG4gICAgLy8gb3B0aW9uYWwgZ3JhcGggaWRcbiAgICBpZiAodG9rZW5UeXBlID09PSBUT0tFTlRZUEUuSURFTlRJRklFUikge1xuICAgICAgZ3JhcGguaWQgPSB0b2tlbjtcbiAgICAgIGdldFRva2VuKCk7XG4gICAgfVxuXG4gICAgLy8gb3BlbiBhbmdsZSBicmFja2V0XG4gICAgaWYgKHRva2VuICE9ICd7Jykge1xuICAgICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoJ0FuZ2xlIGJyYWNrZXQgeyBleHBlY3RlZCcpO1xuICAgIH1cbiAgICBnZXRUb2tlbigpO1xuXG4gICAgLy8gc3RhdGVtZW50c1xuICAgIHBhcnNlU3RhdGVtZW50cyhncmFwaCk7XG5cbiAgICAvLyBjbG9zZSBhbmdsZSBicmFja2V0XG4gICAgaWYgKHRva2VuICE9ICd9Jykge1xuICAgICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoJ0FuZ2xlIGJyYWNrZXQgfSBleHBlY3RlZCcpO1xuICAgIH1cbiAgICBnZXRUb2tlbigpO1xuXG4gICAgLy8gZW5kIG9mIGZpbGVcbiAgICBpZiAodG9rZW4gIT09ICcnKSB7XG4gICAgICB0aHJvdyBuZXdTeW50YXhFcnJvcignRW5kIG9mIGZpbGUgZXhwZWN0ZWQnKTtcbiAgICB9XG4gICAgZ2V0VG9rZW4oKTtcblxuICAgIC8vIHJlbW92ZSB0ZW1wb3JhcnkgZGVmYXVsdCBvcHRpb25zXG4gICAgZGVsZXRlIGdyYXBoLm5vZGU7XG4gICAgZGVsZXRlIGdyYXBoLmVkZ2U7XG4gICAgZGVsZXRlIGdyYXBoLmdyYXBoO1xuXG4gICAgcmV0dXJuIGdyYXBoO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGEgbGlzdCB3aXRoIHN0YXRlbWVudHMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBncmFwaFxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VTdGF0ZW1lbnRzKGdyYXBoKSB7XG4gICAgd2hpbGUgKHRva2VuICE9PSAnJyAmJiB0b2tlbiAhPSAnfScpIHtcbiAgICAgIHBhcnNlU3RhdGVtZW50KGdyYXBoKTtcbiAgICAgIGlmICh0b2tlbiA9PT0gJzsnKSB7XG4gICAgICAgIGdldFRva2VuKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGEgc2luZ2xlIHN0YXRlbWVudC4gQ2FuIGJlIGEgYW4gYXR0cmlidXRlIHN0YXRlbWVudCwgbm9kZVxuICAgKiBzdGF0ZW1lbnQsIGEgc2VyaWVzIG9mIG5vZGUgc3RhdGVtZW50cyBhbmQgZWRnZSBzdGF0ZW1lbnRzLCBvciBhXG4gICAqIHBhcmFtZXRlci5cbiAgICogQHBhcmFtIHtPYmplY3R9IGdyYXBoXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZVN0YXRlbWVudChncmFwaCkge1xuICAgIC8vIHBhcnNlIHN1YmdyYXBoXG4gICAgdmFyIHN1YmdyYXBoID0gcGFyc2VTdWJncmFwaChncmFwaCk7XG4gICAgaWYgKHN1YmdyYXBoKSB7XG4gICAgICAvLyBlZGdlIHN0YXRlbWVudHNcbiAgICAgIHBhcnNlRWRnZShncmFwaCwgc3ViZ3JhcGgpO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gcGFyc2UgYW4gYXR0cmlidXRlIHN0YXRlbWVudFxuICAgIHZhciBhdHRyID0gcGFyc2VBdHRyaWJ1dGVTdGF0ZW1lbnQoZ3JhcGgpO1xuICAgIGlmIChhdHRyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gcGFyc2Ugbm9kZVxuICAgIGlmICh0b2tlblR5cGUgIT0gVE9LRU5UWVBFLklERU5USUZJRVIpIHtcbiAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKCdJZGVudGlmaWVyIGV4cGVjdGVkJyk7XG4gICAgfVxuICAgIHZhciBpZCA9IHRva2VuOyAvLyBpZCBjYW4gYmUgYSBzdHJpbmcgb3IgYSBudW1iZXJcbiAgICBnZXRUb2tlbigpO1xuXG4gICAgaWYgKHRva2VuID09PSAnPScpIHtcbiAgICAgIC8vIGlkIHN0YXRlbWVudFxuICAgICAgZ2V0VG9rZW4oKTtcbiAgICAgIGlmICh0b2tlblR5cGUgIT0gVE9LRU5UWVBFLklERU5USUZJRVIpIHtcbiAgICAgICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoJ0lkZW50aWZpZXIgZXhwZWN0ZWQnKTtcbiAgICAgIH1cbiAgICAgIGdyYXBoW2lkXSA9IHRva2VuO1xuICAgICAgZ2V0VG9rZW4oKTtcbiAgICAgIC8vIFRPRE86IGltcGxlbWVudCBjb21tYSBzZXBhcmF0ZWQgbGlzdCB3aXRoIFwiYV9saXN0OiBJRD1JRCBbJywnXSBbYV9saXN0XSBcIlxuICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlTm9kZVN0YXRlbWVudChncmFwaCwgaWQpO1xuICAgICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGEgc3ViZ3JhcGhcbiAgICogQHBhcmFtIHtPYmplY3R9IGdyYXBoICAgIHBhcmVudCBncmFwaCBvYmplY3RcbiAgICogQHJldHVybiB7T2JqZWN0IHwgbnVsbH0gc3ViZ3JhcGhcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlU3ViZ3JhcGgoZ3JhcGgpIHtcbiAgICB2YXIgc3ViZ3JhcGggPSBudWxsO1xuXG4gICAgLy8gb3B0aW9uYWwgc3ViZ3JhcGgga2V5d29yZFxuICAgIGlmICh0b2tlbiA9PT0gJ3N1YmdyYXBoJykge1xuICAgICAgc3ViZ3JhcGggPSB7fTtcbiAgICAgIHN1YmdyYXBoLnR5cGUgPSAnc3ViZ3JhcGgnO1xuICAgICAgZ2V0VG9rZW4oKTtcblxuICAgICAgLy8gb3B0aW9uYWwgZ3JhcGggaWRcbiAgICAgIGlmICh0b2tlblR5cGUgPT09IFRPS0VOVFlQRS5JREVOVElGSUVSKSB7XG4gICAgICAgIHN1YmdyYXBoLmlkID0gdG9rZW47XG4gICAgICAgIGdldFRva2VuKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gb3BlbiBhbmdsZSBicmFja2V0XG4gICAgaWYgKHRva2VuID09PSAneycpIHtcbiAgICAgIGdldFRva2VuKCk7XG5cbiAgICAgIGlmICghc3ViZ3JhcGgpIHtcbiAgICAgICAgc3ViZ3JhcGggPSB7fTtcbiAgICAgIH1cbiAgICAgIHN1YmdyYXBoLnBhcmVudCA9IGdyYXBoO1xuICAgICAgc3ViZ3JhcGgubm9kZSA9IGdyYXBoLm5vZGU7XG4gICAgICBzdWJncmFwaC5lZGdlID0gZ3JhcGguZWRnZTtcbiAgICAgIHN1YmdyYXBoLmdyYXBoID0gZ3JhcGguZ3JhcGg7XG5cbiAgICAgIC8vIHN0YXRlbWVudHNcbiAgICAgIHBhcnNlU3RhdGVtZW50cyhzdWJncmFwaCk7XG5cbiAgICAgIC8vIGNsb3NlIGFuZ2xlIGJyYWNrZXRcbiAgICAgIGlmICh0b2tlbiAhPSAnfScpIHtcbiAgICAgICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoJ0FuZ2xlIGJyYWNrZXQgfSBleHBlY3RlZCcpO1xuICAgICAgfVxuICAgICAgZ2V0VG9rZW4oKTtcblxuICAgICAgLy8gcmVtb3ZlIHRlbXBvcmFyeSBkZWZhdWx0IG9wdGlvbnNcbiAgICAgIGRlbGV0ZSBzdWJncmFwaC5ub2RlO1xuICAgICAgZGVsZXRlIHN1YmdyYXBoLmVkZ2U7XG4gICAgICBkZWxldGUgc3ViZ3JhcGguZ3JhcGg7XG4gICAgICBkZWxldGUgc3ViZ3JhcGgucGFyZW50O1xuXG4gICAgICAvLyByZWdpc3RlciBhdCB0aGUgcGFyZW50IGdyYXBoXG4gICAgICBpZiAoIWdyYXBoLnN1YmdyYXBocykge1xuICAgICAgICBncmFwaC5zdWJncmFwaHMgPSBbXTtcbiAgICAgIH1cbiAgICAgIGdyYXBoLnN1YmdyYXBocy5wdXNoKHN1YmdyYXBoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3ViZ3JhcGg7XG4gIH1cblxuICAvKipcbiAgICogcGFyc2UgYW4gYXR0cmlidXRlIHN0YXRlbWVudCBsaWtlIFwibm9kZSBbc2hhcGU9Y2lyY2xlIGZvbnRTaXplPTE2XVwiLlxuICAgKiBBdmFpbGFibGUga2V5d29yZHMgYXJlICdub2RlJywgJ2VkZ2UnLCAnZ3JhcGgnLlxuICAgKiBUaGUgcHJldmlvdXMgbGlzdCB3aXRoIGRlZmF1bHQgYXR0cmlidXRlcyB3aWxsIGJlIHJlcGxhY2VkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBncmFwaFxuICAgKiBAcmV0dXJucyB7U3RyaW5nIHwgbnVsbH0ga2V5d29yZCBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBwYXJzZWQgYXR0cmlidXRlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChub2RlLCBlZGdlLCBncmFwaCksIG9yIG51bGwgaWYgbm90aGluZ1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBwYXJzZWQuXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZUF0dHJpYnV0ZVN0YXRlbWVudChncmFwaCkge1xuICAgIC8vIGF0dHJpYnV0ZSBzdGF0ZW1lbnRzXG4gICAgaWYgKHRva2VuID09PSAnbm9kZScpIHtcbiAgICAgIGdldFRva2VuKCk7XG5cbiAgICAgIC8vIG5vZGUgYXR0cmlidXRlc1xuICAgICAgZ3JhcGgubm9kZSA9IHBhcnNlQXR0cmlidXRlTGlzdCgpO1xuICAgICAgcmV0dXJuICdub2RlJztcbiAgICB9IGVsc2UgaWYgKHRva2VuID09PSAnZWRnZScpIHtcbiAgICAgIGdldFRva2VuKCk7XG5cbiAgICAgIC8vIGVkZ2UgYXR0cmlidXRlc1xuICAgICAgZ3JhcGguZWRnZSA9IHBhcnNlQXR0cmlidXRlTGlzdCgpO1xuICAgICAgcmV0dXJuICdlZGdlJztcbiAgICB9IGVsc2UgaWYgKHRva2VuID09PSAnZ3JhcGgnKSB7XG4gICAgICBnZXRUb2tlbigpO1xuXG4gICAgICAvLyBncmFwaCBhdHRyaWJ1dGVzXG4gICAgICBncmFwaC5ncmFwaCA9IHBhcnNlQXR0cmlidXRlTGlzdCgpO1xuICAgICAgcmV0dXJuICdncmFwaCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogcGFyc2UgYSBub2RlIHN0YXRlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gZ3JhcGhcbiAgICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXJ9IGlkXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZU5vZGVTdGF0ZW1lbnQoZ3JhcGgsIGlkKSB7XG4gICAgLy8gbm9kZSBzdGF0ZW1lbnRcbiAgICB2YXIgbm9kZSA9IHtcbiAgICAgIGlkOiBpZFxuICAgIH07XG4gICAgdmFyIGF0dHIgPSBwYXJzZUF0dHJpYnV0ZUxpc3QoKTtcbiAgICBpZiAoYXR0cikge1xuICAgICAgbm9kZS5hdHRyID0gYXR0cjtcbiAgICB9XG4gICAgYWRkTm9kZShncmFwaCwgbm9kZSk7XG5cbiAgICAvLyBlZGdlIHN0YXRlbWVudHNcbiAgICBwYXJzZUVkZ2UoZ3JhcGgsIGlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBhbiBlZGdlIG9yIGEgc2VyaWVzIG9mIGVkZ2VzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBncmFwaFxuICAgKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlcn0gZnJvbSAgICAgICAgSWQgb2YgdGhlIGZyb20gbm9kZVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VFZGdlKGdyYXBoLCBmcm9tKSB7XG4gICAgd2hpbGUgKHRva2VuID09PSAnLT4nIHx8IHRva2VuID09PSAnLS0nKSB7XG4gICAgICB2YXIgdG87XG4gICAgICB2YXIgdHlwZSA9IHRva2VuO1xuICAgICAgZ2V0VG9rZW4oKTtcblxuICAgICAgdmFyIHN1YmdyYXBoID0gcGFyc2VTdWJncmFwaChncmFwaCk7XG4gICAgICBpZiAoc3ViZ3JhcGgpIHtcbiAgICAgICAgdG8gPSBzdWJncmFwaDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0b2tlblR5cGUgIT0gVE9LRU5UWVBFLklERU5USUZJRVIpIHtcbiAgICAgICAgICB0aHJvdyBuZXdTeW50YXhFcnJvcignSWRlbnRpZmllciBvciBzdWJncmFwaCBleHBlY3RlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRvID0gdG9rZW47XG4gICAgICAgIGFkZE5vZGUoZ3JhcGgsIHtcbiAgICAgICAgICBpZDogdG9cbiAgICAgICAgfSk7XG4gICAgICAgIGdldFRva2VuKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHBhcnNlIGVkZ2UgYXR0cmlidXRlc1xuICAgICAgdmFyIGF0dHIgPSBwYXJzZUF0dHJpYnV0ZUxpc3QoKTtcblxuICAgICAgLy8gY3JlYXRlIGVkZ2VcbiAgICAgIHZhciBlZGdlID0gY3JlYXRlRWRnZShncmFwaCwgZnJvbSwgdG8sIHR5cGUsIGF0dHIpO1xuICAgICAgYWRkRWRnZShncmFwaCwgZWRnZSk7XG5cbiAgICAgIGZyb20gPSB0bztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgYSBzZXQgd2l0aCBhdHRyaWJ1dGVzLFxuICAgKiBmb3IgZXhhbXBsZSBbbGFiZWw9XCIxLjAwMFwiLCBzaGFwZT1zb2xpZF1cbiAgICogQHJldHVybiB7T2JqZWN0IHwgbnVsbH0gYXR0clxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VBdHRyaWJ1dGVMaXN0KCkge1xuICAgIHZhciBhdHRyID0gbnVsbDtcblxuICAgIHdoaWxlICh0b2tlbiA9PT0gJ1snKSB7XG4gICAgICBnZXRUb2tlbigpO1xuICAgICAgYXR0ciA9IHt9O1xuICAgICAgd2hpbGUgKHRva2VuICE9PSAnJyAmJiB0b2tlbiAhPSAnXScpIHtcbiAgICAgICAgaWYgKHRva2VuVHlwZSAhPSBUT0tFTlRZUEUuSURFTlRJRklFUikge1xuICAgICAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKCdBdHRyaWJ1dGUgbmFtZSBleHBlY3RlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuYW1lID0gdG9rZW47XG5cbiAgICAgICAgZ2V0VG9rZW4oKTtcbiAgICAgICAgaWYgKHRva2VuICE9ICc9Jykge1xuICAgICAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKCdFcXVhbCBzaWduID0gZXhwZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRUb2tlbigpO1xuXG4gICAgICAgIGlmICh0b2tlblR5cGUgIT0gVE9LRU5UWVBFLklERU5USUZJRVIpIHtcbiAgICAgICAgICB0aHJvdyBuZXdTeW50YXhFcnJvcignQXR0cmlidXRlIHZhbHVlIGV4cGVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlID0gdG9rZW47XG4gICAgICAgIHNldFZhbHVlKGF0dHIsIG5hbWUsIHZhbHVlKTsgLy8gbmFtZSBjYW4gYmUgYSBwYXRoXG5cbiAgICAgICAgZ2V0VG9rZW4oKTtcbiAgICAgICAgaWYgKHRva2VuID09ICcsJykge1xuICAgICAgICAgIGdldFRva2VuKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuICE9ICddJykge1xuICAgICAgICB0aHJvdyBuZXdTeW50YXhFcnJvcignQnJhY2tldCBdIGV4cGVjdGVkJyk7XG4gICAgICB9XG4gICAgICBnZXRUb2tlbigpO1xuICAgIH1cblxuICAgIHJldHVybiBhdHRyO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHN5bnRheCBlcnJvciB3aXRoIGV4dHJhIGluZm9ybWF0aW9uIG9uIGN1cnJlbnQgdG9rZW4gYW5kIGluZGV4LlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAcmV0dXJucyB7U3ludGF4RXJyb3J9IGVyclxuICAgKi9cbiAgZnVuY3Rpb24gbmV3U3ludGF4RXJyb3IobWVzc2FnZSkge1xuICAgIHJldHVybiBuZXcgU3ludGF4RXJyb3IobWVzc2FnZSArICcsIGdvdCBcIicgKyBjaG9wKHRva2VuLCAzMCkgKyAnXCIgKGNoYXIgJyArIGluZGV4ICsgJyknKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaG9wIG9mZiB0ZXh0IGFmdGVyIGEgbWF4aW11bSBsZW5ndGhcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRleHRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1heExlbmd0aFxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKi9cbiAgZnVuY3Rpb24gY2hvcCh0ZXh0LCBtYXhMZW5ndGgpIHtcbiAgICByZXR1cm4gdGV4dC5sZW5ndGggPD0gbWF4TGVuZ3RoID8gdGV4dCA6IHRleHQuc3Vic3RyKDAsIDI3KSArICcuLi4nO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYSBmdW5jdGlvbiBmbiBmb3IgZWFjaCBwYWlyIG9mIGVsZW1lbnRzIGluIHR3byBhcnJheXNcbiAgICogQHBhcmFtIHtBcnJheSB8ICp9IGFycmF5MVxuICAgKiBAcGFyYW0ge0FycmF5IHwgKn0gYXJyYXkyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuXG4gICAqL1xuICBmdW5jdGlvbiBmb3JFYWNoMihhcnJheTEsIGFycmF5MiwgZm4pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnJheTEpKSB7XG4gICAgICBhcnJheTEuZm9yRWFjaChmdW5jdGlvbiAoZWxlbTEpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXkyKSkge1xuICAgICAgICAgIGFycmF5Mi5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtMikge1xuICAgICAgICAgICAgZm4oZWxlbTEsIGVsZW0yKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmbihlbGVtMSwgYXJyYXkyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFycmF5MikpIHtcbiAgICAgICAgYXJyYXkyLmZvckVhY2goZnVuY3Rpb24gKGVsZW0yKSB7XG4gICAgICAgICAgZm4oYXJyYXkxLCBlbGVtMik7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm4oYXJyYXkxLCBhcnJheTIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYSBuZXN0ZWQgcHJvcGVydHkgb24gYW4gb2JqZWN0XG4gICAqIFdoZW4gbmVzdGVkIG9iamVjdHMgYXJlIG1pc3NpbmcsIHRoZXkgd2lsbCBiZSBjcmVhdGVkLlxuICAgKiBGb3IgZXhhbXBsZSBzZXRQcm9wKHt9LCAnZm9udC5jb2xvcicsICdyZWQnKSB3aWxsIHJldHVybiB7Zm9udDoge2NvbG9yOiAncmVkJ319XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggICBBIGRvdCBzZXBhcmF0ZWQgc3RyaW5nIGxpa2UgJ2ZvbnQuY29sb3InXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgICAgICAgVmFsdWUgZm9yIHRoZSBwcm9wZXJ0eVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIG9yaWdpbmFsIG9iamVjdCwgYWxsb3dzIGZvciBjaGFpbmluZy5cbiAgICovXG4gIGZ1bmN0aW9uIHNldFByb3Aob2JqZWN0LCBwYXRoLCB2YWx1ZSkge1xuICAgIHZhciBuYW1lcyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICB2YXIgcHJvcCA9IG5hbWVzLnBvcCgpO1xuXG4gICAgLy8gdHJhdmVyc2Ugb3ZlciB0aGUgbmVzdGVkIG9iamVjdHNcbiAgICB2YXIgb2JqID0gb2JqZWN0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuYW1lID0gbmFtZXNbaV07XG4gICAgICBpZiAoIShuYW1lIGluIG9iaikpIHtcbiAgICAgICAgb2JqW25hbWVdID0ge307XG4gICAgICB9XG4gICAgICBvYmogPSBvYmpbbmFtZV07XG4gICAgfVxuXG4gICAgLy8gc2V0IHRoZSBwcm9wZXJ0eSB2YWx1ZVxuICAgIG9ialtwcm9wXSA9IHZhbHVlO1xuXG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGFuIG9iamVjdCB3aXRoIERPVCBhdHRyaWJ1dGVzIHRvIHRoZWlyIHZpcy5qcyBlcXVpdmFsZW50cy5cbiAgICogQHBhcmFtIHtPYmplY3R9IGF0dHIgICAgIE9iamVjdCB3aXRoIERPVCBhdHRyaWJ1dGVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtYXBwaW5nXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHZpcy5qcyBhdHRyaWJ1dGVzXG4gICAqL1xuICBmdW5jdGlvbiBjb252ZXJ0QXR0cihhdHRyLCBtYXBwaW5nKSB7XG4gICAgdmFyIGNvbnZlcnRlZCA9IHt9O1xuXG4gICAgZm9yICh2YXIgcHJvcCBpbiBhdHRyKSB7XG4gICAgICBpZiAoYXR0ci5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICB2YXIgdmlzUHJvcCA9IG1hcHBpbmdbcHJvcF07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZpc1Byb3ApKSB7XG4gICAgICAgICAgdmlzUHJvcC5mb3JFYWNoKGZ1bmN0aW9uICh2aXNQcm9wSSkge1xuICAgICAgICAgICAgc2V0UHJvcChjb252ZXJ0ZWQsIHZpc1Byb3BJLCBhdHRyW3Byb3BdKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmlzUHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBzZXRQcm9wKGNvbnZlcnRlZCwgdmlzUHJvcCwgYXR0cltwcm9wXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0UHJvcChjb252ZXJ0ZWQsIHByb3AsIGF0dHJbcHJvcF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnZlcnRlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgc3RyaW5nIGNvbnRhaW5pbmcgYSBncmFwaCBpbiBET1QgbGFuZ3VhZ2UgaW50byBhIG1hcCBjb250YWluaW5nXG4gICAqIHdpdGggbm9kZXMgYW5kIGVkZ2VzIGluIHRoZSBmb3JtYXQgb2YgZ3JhcGguXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhICAgICAgICAgVGV4dCBjb250YWluaW5nIGEgZ3JhcGggaW4gRE9ULW5vdGF0aW9uXG4gICAqIEByZXR1cm4ge09iamVjdH0gZ3JhcGhEYXRhXG4gICAqL1xuICBmdW5jdGlvbiBET1RUb0dyYXBoKGRhdGEpIHtcbiAgICAvLyBwYXJzZSB0aGUgRE9UIGZpbGVcbiAgICB2YXIgZG90RGF0YSA9IHBhcnNlRE9UKGRhdGEpO1xuICAgIHZhciBncmFwaERhdGEgPSB7XG4gICAgICBub2RlczogW10sXG4gICAgICBlZGdlczogW10sXG4gICAgICBvcHRpb25zOiB7fVxuICAgIH07XG5cbiAgICAvLyBjb3B5IHRoZSBub2Rlc1xuICAgIGlmIChkb3REYXRhLm5vZGVzKSB7XG4gICAgICBkb3REYXRhLm5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGRvdE5vZGUpIHtcbiAgICAgICAgdmFyIGdyYXBoTm9kZSA9IHtcbiAgICAgICAgICBpZDogZG90Tm9kZS5pZCxcbiAgICAgICAgICBsYWJlbDogU3RyaW5nKGRvdE5vZGUubGFiZWwgfHwgZG90Tm9kZS5pZClcbiAgICAgICAgfTtcbiAgICAgICAgbWVyZ2UoZ3JhcGhOb2RlLCBjb252ZXJ0QXR0cihkb3ROb2RlLmF0dHIsIE5PREVfQVRUUl9NQVBQSU5HKSk7XG4gICAgICAgIGlmIChncmFwaE5vZGUuaW1hZ2UpIHtcbiAgICAgICAgICBncmFwaE5vZGUuc2hhcGUgPSAnaW1hZ2UnO1xuICAgICAgICB9XG4gICAgICAgIGdyYXBoRGF0YS5ub2Rlcy5wdXNoKGdyYXBoTm9kZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBjb3B5IHRoZSBlZGdlc1xuICAgIGlmIChkb3REYXRhLmVkZ2VzKSB7XG4gICAgICAvKipcbiAgICAgICAqIENvbnZlcnQgYW4gZWRnZSBpbiBET1QgZm9ybWF0IHRvIGFuIGVkZ2Ugd2l0aCBWaXNHcmFwaCBmb3JtYXRcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkb3RFZGdlXG4gICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBncmFwaEVkZ2VcbiAgICAgICAqL1xuICAgICAgdmFyIGNvbnZlcnRFZGdlID0gZnVuY3Rpb24gY29udmVydEVkZ2UoZG90RWRnZSkge1xuICAgICAgICB2YXIgZ3JhcGhFZGdlID0ge1xuICAgICAgICAgIGZyb206IGRvdEVkZ2UuZnJvbSxcbiAgICAgICAgICB0bzogZG90RWRnZS50b1xuICAgICAgICB9O1xuICAgICAgICBtZXJnZShncmFwaEVkZ2UsIGNvbnZlcnRBdHRyKGRvdEVkZ2UuYXR0ciwgRURHRV9BVFRSX01BUFBJTkcpKTtcbiAgICAgICAgZ3JhcGhFZGdlLmFycm93cyA9IGRvdEVkZ2UudHlwZSA9PT0gJy0+JyA/ICd0bycgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgcmV0dXJuIGdyYXBoRWRnZTtcbiAgICAgIH07XG5cbiAgICAgIGRvdERhdGEuZWRnZXMuZm9yRWFjaChmdW5jdGlvbiAoZG90RWRnZSkge1xuICAgICAgICB2YXIgZnJvbSwgdG87XG4gICAgICAgIGlmIChkb3RFZGdlLmZyb20gaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICBmcm9tID0gZG90RWRnZS5mcm9tLm5vZGVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZyb20gPSB7XG4gICAgICAgICAgICBpZDogZG90RWRnZS5mcm9tXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IHN1cHBvcnQgb2Ygc29saWQvZG90dGVkL2Rhc2hlZCBlZGdlcyAoYXR0ciA9ICdzdHlsZScpXG4gICAgICAgIC8vIFRPRE86IHN1cHBvcnQgZm9yIGF0dHJpYnV0ZXMgJ2RpcicgYW5kICdhcnJvd2hlYWQnIChlZGdlIGFycm93cylcblxuICAgICAgICBpZiAoZG90RWRnZS50byBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgIHRvID0gZG90RWRnZS50by5ub2RlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0byA9IHtcbiAgICAgICAgICAgIGlkOiBkb3RFZGdlLnRvXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb3RFZGdlLmZyb20gaW5zdGFuY2VvZiBPYmplY3QgJiYgZG90RWRnZS5mcm9tLmVkZ2VzKSB7XG4gICAgICAgICAgZG90RWRnZS5mcm9tLmVkZ2VzLmZvckVhY2goZnVuY3Rpb24gKHN1YkVkZ2UpIHtcbiAgICAgICAgICAgIHZhciBncmFwaEVkZ2UgPSBjb252ZXJ0RWRnZShzdWJFZGdlKTtcbiAgICAgICAgICAgIGdyYXBoRGF0YS5lZGdlcy5wdXNoKGdyYXBoRWRnZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JFYWNoMihmcm9tLCB0bywgZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gICAgICAgICAgdmFyIHN1YkVkZ2UgPSBjcmVhdGVFZGdlKGdyYXBoRGF0YSwgZnJvbS5pZCwgdG8uaWQsIGRvdEVkZ2UudHlwZSwgZG90RWRnZS5hdHRyKTtcbiAgICAgICAgICB2YXIgZ3JhcGhFZGdlID0gY29udmVydEVkZ2Uoc3ViRWRnZSk7XG4gICAgICAgICAgZ3JhcGhEYXRhLmVkZ2VzLnB1c2goZ3JhcGhFZGdlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGRvdEVkZ2UudG8gaW5zdGFuY2VvZiBPYmplY3QgJiYgZG90RWRnZS50by5lZGdlcykge1xuICAgICAgICAgIGRvdEVkZ2UudG8uZWRnZXMuZm9yRWFjaChmdW5jdGlvbiAoc3ViRWRnZSkge1xuICAgICAgICAgICAgdmFyIGdyYXBoRWRnZSA9IGNvbnZlcnRFZGdlKHN1YkVkZ2UpO1xuICAgICAgICAgICAgZ3JhcGhEYXRhLmVkZ2VzLnB1c2goZ3JhcGhFZGdlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gY29weSB0aGUgb3B0aW9uc1xuICAgIGlmIChkb3REYXRhLmF0dHIpIHtcbiAgICAgIGdyYXBoRGF0YS5vcHRpb25zID0gZG90RGF0YS5hdHRyO1xuICAgIH1cblxuICAgIHJldHVybiBncmFwaERhdGE7XG4gIH1cblxuICAvLyBleHBvcnRzXG4gIGV4cG9ydHMucGFyc2VET1QgPSBwYXJzZURPVDtcbiAgZXhwb3J0cy5ET1RUb0dyYXBoID0gRE9UVG9HcmFwaDtcblxuLyoqKi8gfSxcbi8qIDExOSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIHBhcnNlR2VwaGkoZ2VwaGlKU09OLCBvcHRpb25zT2JqKSB7XG4gICAgdmFyIGVkZ2VzID0gW107XG4gICAgdmFyIG5vZGVzID0gW107XG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBlZGdlczoge1xuICAgICAgICBpbmhlcml0Q29sb3I6IGZhbHNlXG4gICAgICB9LFxuICAgICAgbm9kZXM6IHtcbiAgICAgICAgZml4ZWQ6IGZhbHNlLFxuICAgICAgICBwYXJzZUNvbG9yOiBmYWxzZVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAob3B0aW9uc09iaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAob3B0aW9uc09iai5maXhlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMubm9kZXMuZml4ZWQgPSBvcHRpb25zT2JqLmZpeGVkO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnNPYmoucGFyc2VDb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMubm9kZXMucGFyc2VDb2xvciA9IG9wdGlvbnNPYmoucGFyc2VDb2xvcjtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zT2JqLmluaGVyaXRDb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMuZWRnZXMuaW5oZXJpdENvbG9yID0gb3B0aW9uc09iai5pbmhlcml0Q29sb3I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGdFZGdlcyA9IGdlcGhpSlNPTi5lZGdlcztcbiAgICB2YXIgZ05vZGVzID0gZ2VwaGlKU09OLm5vZGVzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ0VkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWRnZSA9IHt9O1xuICAgICAgdmFyIGdFZGdlID0gZ0VkZ2VzW2ldO1xuICAgICAgZWRnZVsnaWQnXSA9IGdFZGdlLmlkO1xuICAgICAgZWRnZVsnZnJvbSddID0gZ0VkZ2Uuc291cmNlO1xuICAgICAgZWRnZVsndG8nXSA9IGdFZGdlLnRhcmdldDtcbiAgICAgIGVkZ2VbJ2F0dHJpYnV0ZXMnXSA9IGdFZGdlLmF0dHJpYnV0ZXM7XG4gICAgICBlZGdlWydsYWJlbCddID0gZ0VkZ2UubGFiZWw7XG4gICAgICBlZGdlWyd0aXRsZSddID0gZ0VkZ2UuYXR0cmlidXRlcyAhPT0gdW5kZWZpbmVkID8gZ0VkZ2UuYXR0cmlidXRlcy50aXRsZSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChnRWRnZVsndHlwZSddID09PSAnRGlyZWN0ZWQnKSB7XG4gICAgICAgIGVkZ2VbJ2Fycm93cyddID0gJ3RvJztcbiAgICAgIH1cbiAgICAgIC8vICAgIGVkZ2VbJ3ZhbHVlJ10gPSBnRWRnZS5hdHRyaWJ1dGVzICE9PSB1bmRlZmluZWQgPyBnRWRnZS5hdHRyaWJ1dGVzLldlaWdodCA6IHVuZGVmaW5lZDtcbiAgICAgIC8vICAgIGVkZ2VbJ3dpZHRoJ10gPSBlZGdlWyd2YWx1ZSddICE9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBlZGdlZ0VkZ2Uuc2l6ZTtcbiAgICAgIGlmIChnRWRnZS5jb2xvciAmJiBvcHRpb25zLmluaGVyaXRDb2xvciA9PT0gZmFsc2UpIHtcbiAgICAgICAgZWRnZVsnY29sb3InXSA9IGdFZGdlLmNvbG9yO1xuICAgICAgfVxuICAgICAgZWRnZXMucHVzaChlZGdlKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5vZGUgPSB7fTtcbiAgICAgIHZhciBnTm9kZSA9IGdOb2Rlc1tpXTtcbiAgICAgIG5vZGVbJ2lkJ10gPSBnTm9kZS5pZDtcbiAgICAgIG5vZGVbJ2F0dHJpYnV0ZXMnXSA9IGdOb2RlLmF0dHJpYnV0ZXM7XG4gICAgICBub2RlWyd0aXRsZSddID0gZ05vZGUudGl0bGU7XG4gICAgICBub2RlWyd4J10gPSBnTm9kZS54O1xuICAgICAgbm9kZVsneSddID0gZ05vZGUueTtcbiAgICAgIG5vZGVbJ2xhYmVsJ10gPSBnTm9kZS5sYWJlbDtcbiAgICAgIG5vZGVbJ3RpdGxlJ10gPSBnTm9kZS5hdHRyaWJ1dGVzICE9PSB1bmRlZmluZWQgPyBnTm9kZS5hdHRyaWJ1dGVzLnRpdGxlIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKG9wdGlvbnMubm9kZXMucGFyc2VDb2xvciA9PT0gdHJ1ZSkge1xuICAgICAgICBub2RlWydjb2xvciddID0gZ05vZGUuY29sb3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlWydjb2xvciddID0gZ05vZGUuY29sb3IgIT09IHVuZGVmaW5lZCA/IHsgYmFja2dyb3VuZDogZ05vZGUuY29sb3IsIGJvcmRlcjogZ05vZGUuY29sb3IsIGhpZ2hsaWdodDogeyBiYWNrZ3JvdW5kOiBnTm9kZS5jb2xvciwgYm9yZGVyOiBnTm9kZS5jb2xvciB9LCBob3ZlcjogeyBiYWNrZ3JvdW5kOiBnTm9kZS5jb2xvciwgYm9yZGVyOiBnTm9kZS5jb2xvciB9IH0gOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBub2RlWydzaXplJ10gPSBnTm9kZS5zaXplO1xuICAgICAgbm9kZVsnZml4ZWQnXSA9IG9wdGlvbnMubm9kZXMuZml4ZWQgJiYgZ05vZGUueCAhPT0gdW5kZWZpbmVkICYmIGdOb2RlLnkgIT09IHVuZGVmaW5lZDtcbiAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgbm9kZXM6IG5vZGVzLCBlZGdlczogZWRnZXMgfTtcbiAgfVxuXG4gIGV4cG9ydHMucGFyc2VHZXBoaSA9IHBhcnNlR2VwaGk7XG5cbi8qKiovIH0sXG4vKiAxMjAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBFbmdsaXNoXG4gIGV4cG9ydHNbJ2VuJ10gPSB7XG4gICAgZWRpdDogJ0VkaXQnLFxuICAgIGRlbDogJ0RlbGV0ZSBzZWxlY3RlZCcsXG4gICAgYmFjazogJ0JhY2snLFxuICAgIGFkZE5vZGU6ICdBZGQgTm9kZScsXG4gICAgYWRkRWRnZTogJ0FkZCBFZGdlJyxcbiAgICBlZGl0Tm9kZTogJ0VkaXQgTm9kZScsXG4gICAgZWRpdEVkZ2U6ICdFZGl0IEVkZ2UnLFxuICAgIGFkZERlc2NyaXB0aW9uOiAnQ2xpY2sgaW4gYW4gZW1wdHkgc3BhY2UgdG8gcGxhY2UgYSBuZXcgbm9kZS4nLFxuICAgIGVkZ2VEZXNjcmlwdGlvbjogJ0NsaWNrIG9uIGEgbm9kZSBhbmQgZHJhZyB0aGUgZWRnZSB0byBhbm90aGVyIG5vZGUgdG8gY29ubmVjdCB0aGVtLicsXG4gICAgZWRpdEVkZ2VEZXNjcmlwdGlvbjogJ0NsaWNrIG9uIHRoZSBjb250cm9sIHBvaW50cyBhbmQgZHJhZyB0aGVtIHRvIGEgbm9kZSB0byBjb25uZWN0IHRvIGl0LicsXG4gICAgY3JlYXRlRWRnZUVycm9yOiAnQ2Fubm90IGxpbmsgZWRnZXMgdG8gYSBjbHVzdGVyLicsXG4gICAgZGVsZXRlQ2x1c3RlckVycm9yOiAnQ2x1c3RlcnMgY2Fubm90IGJlIGRlbGV0ZWQuJyxcbiAgICBlZGl0Q2x1c3RlckVycm9yOiAnQ2x1c3RlcnMgY2Fubm90IGJlIGVkaXRlZC4nXG4gIH07XG4gIGV4cG9ydHNbJ2VuX0VOJ10gPSBleHBvcnRzWydlbiddO1xuICBleHBvcnRzWydlbl9VUyddID0gZXhwb3J0c1snZW4nXTtcblxuICAvLyBHZXJtYW5cbiAgZXhwb3J0c1snZGUnXSA9IHtcbiAgICBlZGl0OiAnRWRpdGllcmVuJyxcbiAgICBkZWw6ICdMw7ZzY2hlIEF1c3dhaGwnLFxuICAgIGJhY2s6ICdadXLDvGNrJyxcbiAgICBhZGROb2RlOiAnS25vdGVuIGhpbnp1ZsO8Z2VuJyxcbiAgICBhZGRFZGdlOiAnS2FudGUgaGluenVmw7xnZW4nLFxuICAgIGVkaXROb2RlOiAnS25vdGVuIGVkaXRpZXJlbicsXG4gICAgZWRpdEVkZ2U6ICdLYW50ZSBlZGl0aWVyZW4nLFxuICAgIGFkZERlc2NyaXB0aW9uOiAnS2xpY2tlIGF1ZiBlaW5lIGZyZWllIFN0ZWxsZSwgdW0gZWluZW4gbmV1ZW4gS25vdGVuIHp1IHBsYXppZXJlbi4nLFxuICAgIGVkZ2VEZXNjcmlwdGlvbjogJ0tsaWNrZSBhdWYgZWluZW4gS25vdGVuIHVuZCB6aWVoZSBkaWUgS2FudGUgenUgZWluZW0gYW5kZXJlbiBLbm90ZW4sIHVtIGRpZXNlIHp1IHZlcmJpbmRlbi4nLFxuICAgIGVkaXRFZGdlRGVzY3JpcHRpb246ICdLbGlja2UgYXVmIGRpZSBWZXJiaW5kdW5nc3B1bmt0ZSB1bmQgemllaGUgZGllc2UgYXVmIGVpbmVuIEtub3RlbiwgdW0gc2llIHp1IHZlcmJpbmRlbi4nLFxuICAgIGNyZWF0ZUVkZ2VFcnJvcjogJ0VzIGlzdCBuaWNodCBtw7ZnbGljaCwgS2FudGVuIG1pdCBDbHVzdGVybiB6dSB2ZXJiaW5kZW4uJyxcbiAgICBkZWxldGVDbHVzdGVyRXJyb3I6ICdDbHVzdGVyIGvDtm5uZW4gbmljaHQgZ2Vsw7ZzY2h0IHdlcmRlbi4nLFxuICAgIGVkaXRDbHVzdGVyRXJyb3I6ICdDbHVzdGVyIGvDtm5uZW4gbmljaHQgZWRpdGllcnQgd2VyZGVuLidcbiAgfTtcbiAgZXhwb3J0c1snZGVfREUnXSA9IGV4cG9ydHNbJ2RlJ107XG5cbiAgLy8gU3BhbmlzaFxuICBleHBvcnRzWydlcyddID0ge1xuICAgIGVkaXQ6ICdFZGl0YXInLFxuICAgIGRlbDogJ0VsaW1pbmFyIHNlbGVjY2nDs24nLFxuICAgIGJhY2s6ICfDgXRyYXMnLFxuICAgIGFkZE5vZGU6ICdBw7FhZGlyIG5vZG8nLFxuICAgIGFkZEVkZ2U6ICdBw7FhZGlyIGFyaXN0YScsXG4gICAgZWRpdE5vZGU6ICdFZGl0YXIgbm9kbycsXG4gICAgZWRpdEVkZ2U6ICdFZGl0YXIgYXJpc3RhJyxcbiAgICBhZGREZXNjcmlwdGlvbjogJ0hhZ2EgY2xpYyBlbiB1biBsdWdhciB2YWPDrW8gcGFyYSBjb2xvY2FyIHVuIG51ZXZvIG5vZG8uJyxcbiAgICBlZGdlRGVzY3JpcHRpb246ICdIYWdhIGNsaWMgZW4gdW4gbm9kbyB5IGFycmFzdHJlIGxhIGFyaXN0YSBoYWNpYSBvdHJvIG5vZG8gcGFyYSBjb25lY3Rhcmxvcy4nLFxuICAgIGVkaXRFZGdlRGVzY3JpcHRpb246ICdIYWdhIGNsaWMgZW4gdW4gcHVudG8gZGUgY29udHJvbCB5IGFycmFzdHJlbG8gYSB1biBub2RvIHBhcmEgY29uZWN0YXJsby4nLFxuICAgIGNyZWF0ZUVkZ2VFcnJvcjogJ05vIHNlIHB1ZWRlIGNvbmVjdGFyIHVuYSBhcmlzdGEgYSB1biBncnVwby4nLFxuICAgIGRlbGV0ZUNsdXN0ZXJFcnJvcjogJ05vIGVzIHBvc2libGUgZWxpbWluYXIgZ3J1cG9zLicsXG4gICAgZWRpdENsdXN0ZXJFcnJvcjogJ05vIGVzIHBvc2libGUgZWRpdGFyIGdydXBvcy4nXG4gIH07XG4gIGV4cG9ydHNbJ2VzX0VTJ10gPSBleHBvcnRzWydlcyddO1xuXG4gIC8vIER1dGNoXG4gIGV4cG9ydHNbJ25sJ10gPSB7XG4gICAgZWRpdDogJ1dpanppZ2VuJyxcbiAgICBkZWw6ICdTZWxlY3RpZSB2ZXJ3aWpkZXJlbicsXG4gICAgYmFjazogJ1RlcnVnJyxcbiAgICBhZGROb2RlOiAnTm9kZSB0b2V2b2VnZW4nLFxuICAgIGFkZEVkZ2U6ICdMaW5rIHRvZXZvZWdlbicsXG4gICAgZWRpdE5vZGU6ICdOb2RlIHdpanppZ2VuJyxcbiAgICBlZGl0RWRnZTogJ0xpbmsgd2lqemlnZW4nLFxuICAgIGFkZERlc2NyaXB0aW9uOiAnS2xpayBvcCBlZW4gbGVlZyBnZWJpZWQgb20gZWVuIG5pZXV3ZSBub2RlIHRlIG1ha2VuLicsXG4gICAgZWRnZURlc2NyaXB0aW9uOiAnS2xpayBvcCBlZW4gbm9kZSBlbiBzbGVlcCBkZSBsaW5rIG5hYXIgZWVuIGFuZGVyZSBub2RlIG9tIHplIHRlIHZlcmJpbmRlbi4nLFxuICAgIGVkaXRFZGdlRGVzY3JpcHRpb246ICdLbGlrIG9wIGRlIHZlcmJpbmRpbmdzcHVudGVuIGVuIHNsZWVwIHplIG5hYXIgZWVuIG5vZGUgb20gZGFhcm1lZSB0ZSB2ZXJiaW5kZW4uJyxcbiAgICBjcmVhdGVFZGdlRXJyb3I6ICdLYW4gZ2VlbiBsaW5rIG1ha2VuIG5hYXIgZWVuIGNsdXN0ZXIuJyxcbiAgICBkZWxldGVDbHVzdGVyRXJyb3I6ICdDbHVzdGVycyBrdW5uZW4gbmlldCB3b3JkZW4gdmVyd2lqZGVyZC4nLFxuICAgIGVkaXRDbHVzdGVyRXJyb3I6ICdDbHVzdGVycyBrdW5uZW4gbmlldCB3b3JkZW4gYWFuZ2VwYXN0LidcbiAgfTtcbiAgZXhwb3J0c1snbmxfTkwnXSA9IGV4cG9ydHNbJ25sJ107XG4gIGV4cG9ydHNbJ25sX0JFJ10gPSBleHBvcnRzWydubCddO1xuXG4vKioqLyB9XG4vKioqKioqLyBdKVxufSk7XG47Il19
